WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[欢呼声]

00:00:21.516 --> 00:00:27.500 A:middle
[掌声]

00:00:29.206 --> 00:00:29.956 A:middle
&gt;&gt; 大家好

00:00:30.306 --> 00:00:31.546 A:middle
欢迎大家

00:00:31.546 --> 00:00:32.246 A:middle
来到可测试性工程学讲座

00:00:33.256 --> 00:00:34.546 A:middle
我是 Brian Croom

00:00:34.546 --> 00:00:36.306 A:middle
现在在 Xcode 团队工作

00:00:37.356 --> 00:00:38.846 A:middle
我和我的同事 Greg

00:00:38.846 --> 00:00:39.786 A:middle
想要和大家分享一下

00:00:39.786 --> 00:00:41.896 A:middle
我们对于可测试性的学习成果

00:00:42.046 --> 00:00:42.946 A:middle
以及可测试性在

00:00:42.946 --> 00:00:45.486 A:middle
开发出色 app 进程中

00:00:48.826 --> 00:00:48.936 A:middle
起到的重要作用

00:00:49.136 --> 00:00:50.776 A:middle
首先 我想要讲一讲

00:00:50.776 --> 00:00:52.296 A:middle
一个 app 的代码具有可测试性

00:00:52.346 --> 00:00:52.766 A:middle
究竟是什么意思

00:00:53.686 --> 00:00:55.316 A:middle
我们会看到一些实例

00:00:55.316 --> 00:00:56.476 A:middle
看看如何应用技术

00:00:56.546 --> 00:00:58.376 A:middle
来提高现有代码

00:00:58.376 --> 00:00:59.746 A:middle
的可测试性

00:01:01.276 --> 00:01:03.286 A:middle
然后 Gregg 会和大家探讨

00:01:03.286 --> 00:01:04.616 A:middle
如何使用测试套件

00:01:04.616 --> 00:01:06.196 A:middle
来确保

00:01:06.196 --> 00:01:08.146 A:middle
它能够对你的 app 开发

00:01:08.146 --> 00:01:09.986 A:middle
起到协助作用 即使是在

00:01:09.986 --> 00:01:11.516 A:middle
开发规模和复杂性不断提高的情况下

00:01:14.256 --> 00:01:15.786 A:middle
好的 我们这就开始

00:01:15.786 --> 00:01:16.896 A:middle
首先来谈谈可测试性

00:01:17.346 --> 00:01:20.616 A:middle
我记得在不久之前

00:01:20.616 --> 00:01:21.876 A:middle
我最初开始学习写

00:01:22.386 --> 00:01:22.666 A:middle
测试

00:01:23.746 --> 00:01:25.116 A:middle
我已经听说过很多有关

00:01:25.116 --> 00:01:26.806 A:middle
测试套件如何能够

00:01:26.806 --> 00:01:27.766 A:middle
帮助我开发 app 的信息

00:01:27.966 --> 00:01:30.816 A:middle
测试套件如何能够使我

00:01:31.176 --> 00:01:32.656 A:middle
对正在编写的代码更有把握

00:01:32.656 --> 00:01:33.906 A:middle
能够让其按照期望的方式

00:01:34.646 --> 00:01:34.716 A:middle
运行

00:01:35.636 --> 00:01:36.766 A:middle
测试套件如何能够帮我

00:01:36.826 --> 00:01:38.916 A:middle
在 app 不断升级变化的情况下

00:01:39.066 --> 00:01:40.266 A:middle
为代码中的regression打补丁

00:01:40.866 --> 00:01:43.626 A:middle
以及如何充当

00:01:43.626 --> 00:01:45.206 A:middle
我的代码的

00:01:45.206 --> 00:01:45.506 A:middle
可执行文件

00:01:46.126 --> 00:01:49.066 A:middle
但是 我一开始写测试时

00:01:49.066 --> 00:01:51.636 A:middle
还没有达到这些讨论的范畴

00:01:51.636 --> 00:01:52.496 A:middle
就陷入停滞无法继续编写下去了

00:01:53.136 --> 00:01:56.166 A:middle
感觉好像我的 app 代码

00:01:56.166 --> 00:01:57.976 A:middle
主动地抗拒我

00:01:57.976 --> 00:01:58.876 A:middle
写测试

00:01:59.416 --> 00:02:02.946 A:middle
这个情况持续了一段时间

00:01:59.416 --> 00:02:02.946 A:middle
这个情况持续了一段时间

00:02:02.946 --> 00:02:04.256 A:middle
不过最后我发现

00:02:04.256 --> 00:02:06.076 A:middle
我构建代码的方式

00:02:06.076 --> 00:02:07.236 A:middle
阻碍了

00:02:07.286 --> 00:02:07.500 A:middle
我进行有效的测试

00:02:10.895 --> 00:02:12.386 A:middle
为了搞清楚这是什么意思

00:02:12.896 --> 00:02:14.056 A:middle
首先请大家看这个单元测试

00:02:14.056 --> 00:02:15.936 A:middle
这个单元测试的对象是

00:02:15.936 --> 00:02:18.486 A:middle
已经具有可测试性的代码

00:02:18.876 --> 00:02:18.946 A:middle
该代码是用来进行数组排序的

00:02:21.456 --> 00:02:23.636 A:middle
这个测试使用的是

00:02:23.636 --> 00:02:25.186 A:middle
Swift Standard Library 中的

00:02:25.186 --> 00:02:25.966 A:middle
Sorted Method

00:02:26.676 --> 00:02:29.796 A:middle
首先它创建一组

00:02:29.796 --> 00:02:30.876 A:middle
未经排序的数值

00:02:31.556 --> 00:02:35.446 A:middle
然后它为这组数值

00:02:35.446 --> 00:02:35.926 A:middle
调用 Sorted Method

00:02:36.646 --> 00:02:39.556 A:middle
然后再判断

00:02:39.556 --> 00:02:41.606 A:middle
返回的数组中数值按照预期的

00:02:41.686 --> 00:02:44.996 A:middle
顺序排列

00:02:45.186 --> 00:02:47.366 A:middle
概括说来 我们能够看到

00:02:47.366 --> 00:02:49.056 A:middle
该测试的结构由三部分组成

00:02:49.056 --> 00:02:51.226 A:middle
第一 创建任何

00:02:51.226 --> 00:02:53.386 A:middle
所需的输入状态或数值

00:02:54.526 --> 00:02:56.136 A:middle
然后 调用被测试的代码

00:02:56.136 --> 00:02:59.386 A:middle
最后 判断

00:02:59.386 --> 00:03:00.556 A:middle
返回的输出信息

00:02:59.386 --> 00:03:00.556 A:middle
返回的输出信息

00:03:00.556 --> 00:03:01.746 A:middle
是正确的

00:03:02.416 --> 00:03:04.356 A:middle
有些情况下 这个模式被称作

00:03:04.356 --> 00:03:05.956 A:middle
3A 模式（Arrange Act Assert）

00:03:06.586 --> 00:03:11.426 A:middle
我们已经看过了

00:03:11.426 --> 00:03:13.206 A:middle
这个具有不错可测试性的排序代码

00:03:14.266 --> 00:03:15.466 A:middle
不过 我知道你们现在在想

00:03:16.176 --> 00:03:17.396 A:middle
我的 app 代码里

00:03:17.486 --> 00:03:19.426 A:middle
没有一点排序算法啊

00:03:20.496 --> 00:03:22.056 A:middle
就我的经验而言 app 里面的

00:03:22.056 --> 00:03:23.486 A:middle
大多数代码

00:03:23.486 --> 00:03:24.306 A:middle
确实都和排序算法有

00:03:24.306 --> 00:03:24.816 A:middle
天差地别

00:03:25.276 --> 00:03:27.616 A:middle
不过 我们还是可以

00:03:27.616 --> 00:03:29.326 A:middle
在我们的 app 中努力

00:03:29.326 --> 00:03:31.116 A:middle
实现一些 Sorted Method 的

00:03:31.116 --> 00:03:32.426 A:middle
特性

00:03:32.836 --> 00:03:34.016 A:middle
以使其更加具有可测试性

00:03:35.286 --> 00:03:38.206 A:middle
更确切地说 具有可测试性的代码

00:03:38.206 --> 00:03:39.836 A:middle
能够帮助其客户端

00:03:39.836 --> 00:03:41.516 A:middle
对代码处理的所有 inputs

00:03:41.516 --> 00:03:42.836 A:middle
进行完全控制

00:03:43.416 --> 00:03:46.446 A:middle
它能够帮助用户端

00:03:46.446 --> 00:03:48.276 A:middle
检查所有

00:03:48.276 --> 00:03:49.026 A:middle
正在生成的 output

00:03:49.656 --> 00:03:52.436 A:middle
它避免了完全依赖于

00:03:52.436 --> 00:03:54.166 A:middle
内部状态的情况 而这种情况

00:03:54.166 --> 00:03:55.346 A:middle
有可能在日后影响到代码的行为

00:03:55.346 --> 00:04:02.106 A:middle
我想要举一些关于代码的例子

00:03:55.346 --> 00:04:02.106 A:middle
我想要举一些关于代码的例子

00:04:02.416 --> 00:04:03.306 A:middle
来向大家展示几种技术

00:04:03.306 --> 00:04:05.016 A:middle
这些技术可以用来把

00:04:05.016 --> 00:04:06.616 A:middle
这些特性赋予给应用程序的代码

00:04:06.616 --> 00:04:08.636 A:middle
并借此

00:04:08.636 --> 00:04:09.876 A:middle
提高其可测试性

00:04:13.836 --> 00:04:15.656 A:middle
第一个技术是

00:04:15.656 --> 00:04:16.916 A:middle
如何将 protocols 及

00:04:16.916 --> 00:04:18.336 A:middle
parameterization 引进到

00:04:18.336 --> 00:04:18.500 A:middle
一个代码中

00:04:21.406 --> 00:04:23.456 A:middle
比如 想象这是一个文档浏览的 app

00:04:23.456 --> 00:04:25.466 A:middle
能够对

00:04:25.466 --> 00:04:27.056 A:middle
各种不同类型的文档

00:04:27.056 --> 00:04:29.046 A:middle
进行预览

00:04:29.046 --> 00:04:30.406 A:middle
也可以切换到另一个不同的 app 里

00:04:30.406 --> 00:04:31.776 A:middle
进行更加细致的查看

00:04:31.776 --> 00:04:33.766 A:middle
或者编辑

00:04:34.936 --> 00:04:36.676 A:middle
我们看到的前一个画面

00:04:36.676 --> 00:04:38.086 A:middle
包括一个打开按钮

00:04:38.086 --> 00:04:39.546 A:middle
还有一个分段控制

00:04:39.546 --> 00:04:40.896 A:middle
用来选择

00:04:41.146 --> 00:04:42.546 A:middle
是进行查看还是进行编辑

00:04:42.546 --> 00:04:46.776 A:middle
好的 我们先来看看

00:04:46.776 --> 00:04:48.506 A:middle
这一界面

00:04:48.856 --> 00:04:49.000 A:middle
背后的代码

00:04:51.716 --> 00:04:52.796 A:middle
当打开按钮被按下时

00:04:52.796 --> 00:04:54.216 A:middle
view controller 中的

00:04:54.216 --> 00:04:55.626 A:middle
event handler

00:04:56.636 --> 00:04:56.766 A:middle
被调用

00:04:58.996 --> 00:05:00.216 A:middle
首先是一些 business logic

00:04:58.996 --> 00:05:00.216 A:middle
首先是一些 business logic

00:05:00.216 --> 00:05:02.756 A:middle
用来构建一个 URL

00:05:02.756 --> 00:05:04.536 A:middle
这个 URL 被用来请求 iOS

00:05:04.536 --> 00:05:06.186 A:middle
切换到其它 app

00:05:08.216 --> 00:05:10.586 A:middle
然后 它使用由

00:05:10.586 --> 00:05:12.356 A:middle
UIKit 提供的

00:05:12.356 --> 00:05:14.576 A:middle
shared UI application instance

00:05:14.576 --> 00:05:15.806 A:middle
来确定系统是否能够处理

00:05:15.806 --> 00:05:18.256 A:middle
这个打开的请求 如果可以的话

00:05:18.256 --> 00:05:19.926 A:middle
则执行这个打开 URL 的动作

00:05:20.596 --> 00:05:23.386 A:middle
如果不可以的话 则调用辅助方式

00:05:23.386 --> 00:05:25.386 A:middle
显示一些 UI 来引导

00:05:25.386 --> 00:05:26.526 A:middle
用户去安装另一个

00:05:26.526 --> 00:05:27.000 A:middle
app

00:05:30.086 --> 00:05:31.536 A:middle
现在 我想要写一些测试

00:05:31.696 --> 00:05:32.996 A:middle
来确保这个打开按钮

00:05:32.996 --> 00:05:34.186 A:middle
能够以我们期望的方式

00:05:34.186 --> 00:05:35.436 A:middle
运行

00:05:36.916 --> 00:05:38.196 A:middle
测试这一点

00:05:38.196 --> 00:05:39.896 A:middle
有许多种不同的途径

00:05:41.446 --> 00:05:43.346 A:middle
一种方式就是写一个

00:05:43.346 --> 00:05:43.916 A:middle
UI 测试

00:05:45.216 --> 00:05:46.566 A:middle
我们要求启动 app

00:05:46.566 --> 00:05:48.886 A:middle
导航到这一屏

00:05:48.936 --> 00:05:50.316 A:middle
点击控制键

00:05:50.316 --> 00:05:52.256 A:middle
轻击 open mode

00:05:52.256 --> 00:05:55.196 A:middle
点击打开按钮

00:05:55.196 --> 00:05:56.506 A:middle
然后验证手机切换显示

00:05:56.506 --> 00:05:57.186 A:middle
另一个 app

00:05:57.446 --> 00:06:00.196 A:middle
虽然这个办法行得通

00:05:57.446 --> 00:06:00.196 A:middle
虽然这个办法行得通

00:06:00.196 --> 00:06:01.446 A:middle
但是也有些缺点

00:06:01.886 --> 00:06:04.866 A:middle
比如 它运行时间

00:06:04.866 --> 00:06:07.006 A:middle
可能会比较长

00:06:07.006 --> 00:06:08.836 A:middle
特别是当我想要对测试内容进行拓展时

00:06:08.836 --> 00:06:09.976 A:middle
比如测试不同种类文档

00:06:09.976 --> 00:06:11.066 A:middle
在不同打开模式下

00:06:11.066 --> 00:06:11.466 A:middle
的运行效果

00:06:11.996 --> 00:06:15.086 A:middle
更严重的缺点是

00:06:15.086 --> 00:06:17.606 A:middle
一个 UI 测试无论如何都无法

00:06:17.606 --> 00:06:19.206 A:middle
检查刚刚被生成的

00:06:19.206 --> 00:06:21.366 A:middle
用来请求 iOS 切换 app

00:06:21.366 --> 00:06:22.236 A:middle
的 URL

00:06:23.166 --> 00:06:24.526 A:middle
而那个 URL 则是

00:06:24.526 --> 00:06:25.436 A:middle
我真正想要

00:06:25.436 --> 00:06:26.576 A:middle
进行更加精准检查的对象

00:06:28.176 --> 00:06:29.626 A:middle
所以 似乎

00:06:29.626 --> 00:06:30.876 A:middle
单元测试是更加

00:06:30.876 --> 00:06:31.556 A:middle
适合这种情况的

00:06:34.416 --> 00:06:35.586 A:middle
我们就来看看

00:06:35.586 --> 00:06:36.836 A:middle
要为这个代码写一个

00:06:36.836 --> 00:06:37.000 A:middle
单元测试需要些什么

00:06:40.016 --> 00:06:41.806 A:middle
首先 你需要一个 view controller

00:06:41.806 --> 00:06:42.756 A:middle
的 instance

00:06:42.756 --> 00:06:42.926 A:middle
来进行操作

00:06:44.346 --> 00:06:45.286 A:middle
我的 view controller 为其 UI

00:06:45.286 --> 00:06:47.406 A:middle
使用了一个 storyboard

00:06:47.406 --> 00:06:48.986 A:middle
所以我会让 UI Storyboard 来

00:06:48.986 --> 00:06:50.126 A:middle
提供给我一个 view controller 的 instance

00:06:50.646 --> 00:06:54.616 A:middle
然后我们需要加载这个视图

00:06:55.976 --> 00:06:57.186 A:middle
来填入控制属性

00:06:57.186 --> 00:06:59.856 A:middle
这样

00:06:59.856 --> 00:07:01.776 A:middle
它就被视图数据填充了

00:06:59.856 --> 00:07:01.776 A:middle
它就被视图数据填充了

00:07:01.776 --> 00:07:03.786 A:middle
然后可以依据我们的 open mode

00:07:03.786 --> 00:07:05.096 A:middle
对其进行配置

00:07:05.756 --> 00:07:07.406 A:middle
提供一个可供处理的文档

00:07:08.106 --> 00:07:12.136 A:middle
设定最终完成之后

00:07:12.136 --> 00:07:13.566 A:middle
我们现在就可以

00:07:13.566 --> 00:07:15.546 A:middle
调用要被测试的 method 了

00:07:18.116 --> 00:07:19.576 A:middle
但是我们现在该怎么做呢

00:07:20.836 --> 00:07:22.046 A:middle
我们能够在这里写哪一种

00:07:22.046 --> 00:07:23.000 A:middle
assertion 似乎不太明了

00:07:27.056 --> 00:07:29.176 A:middle
我们先回到代码那里

00:07:29.176 --> 00:07:30.346 A:middle
再仔细看看究竟是什么

00:07:30.346 --> 00:07:32.146 A:middle
导致了我们在进行测试时遇到这样的挑战

00:07:34.386 --> 00:07:36.476 A:middle
首先 单单是因为在 view controller 内

00:07:36.476 --> 00:07:37.806 A:middle
的这个情况

00:07:37.806 --> 00:07:39.346 A:middle
就使得 methods 测试更加复杂了

00:07:39.986 --> 00:07:40.806 A:middle
为了得到可以进行操作的

00:07:40.806 --> 00:07:41.436 A:middle
view controller instance

00:07:41.436 --> 00:07:42.506 A:middle
你就必须要

00:07:42.506 --> 00:07:42.656 A:middle
越过重重关卡

00:07:43.236 --> 00:07:46.776 A:middle
在这里 我们是从视图中直接

00:07:46.776 --> 00:07:48.286 A:middle
取出 input 状态

00:07:48.286 --> 00:07:50.646 A:middle
测试不得不强制

00:07:50.646 --> 00:07:52.536 A:middle
加载该视图

00:07:52.576 --> 00:07:54.636 A:middle
然后再间接地通过在

00:07:54.636 --> 00:07:56.066 A:middle
一些 sub-view 上设置一个属性来

00:07:56.776 --> 00:08:00.066 A:middle
提供 input

00:07:56.776 --> 00:08:00.066 A:middle
提供 input

00:08:00.266 --> 00:08:01.966 A:middle
不过 最严重的问题

00:08:01.966 --> 00:08:03.826 A:middle
是这个 UI application shared instance

00:08:03.826 --> 00:08:04.706 A:middle
的使用

00:08:08.516 --> 00:08:10.286 A:middle
这个 canOpenURL 的回传值

00:08:10.286 --> 00:08:12.816 A:middle
实际上

00:08:12.816 --> 00:08:14.126 A:middle
是该 method 的另一个 input

00:08:15.586 --> 00:08:16.966 A:middle
但是因为这个是依赖于

00:08:16.966 --> 00:08:18.676 A:middle
全局系统状态的

00:08:18.676 --> 00:08:20.356 A:middle
我们并无法给测试提供程序化的方法

00:08:20.356 --> 00:08:21.506 A:middle
来控制这个 query

00:08:21.506 --> 00:08:22.000 A:middle
的结果

00:08:25.396 --> 00:08:26.606 A:middle
对于一个单元测试而言

00:08:26.606 --> 00:08:28.306 A:middle
也没有一个好的方式能够观察

00:08:28.306 --> 00:08:29.836 A:middle
打开一个 URL 的副效应

00:08:30.616 --> 00:08:33.806 A:middle
实际上 在调用这个之后

00:08:33.806 --> 00:08:35.155 A:middle
测试渲染的 app

00:08:35.155 --> 00:08:36.635 A:middle
会被送至后台

00:08:36.635 --> 00:08:37.546 A:middle
之后就再也没有办法

00:08:37.546 --> 00:08:38.206 A:middle
把它带回到

00:08:38.206 --> 00:08:38.765 A:middle
前台了

00:08:38.765 --> 00:08:42.645 A:middle
那么 我们就来看看

00:08:42.645 --> 00:08:43.946 A:middle
我们能够做些什么来提升

00:08:43.946 --> 00:08:44.206 A:middle
这个代码的可测试性

00:08:44.856 --> 00:08:48.846 A:middle
首先我们可以将其从

00:08:48.846 --> 00:08:49.586 A:middle
view controller 中取出来

00:08:50.046 --> 00:08:53.076 A:middle
然后引入一个新的

00:08:53.076 --> 00:08:55.206 A:middle
document opener 类 将

00:08:55.206 --> 00:08:56.206 A:middle
这个 logic 和 behavior 封装起来

00:08:58.756 --> 00:09:00.506 A:middle
现在应该为 Open mode

00:08:58.756 --> 00:09:00.506 A:middle
现在应该为 Open mode

00:09:00.506 --> 00:09:02.426 A:middle
和 document inputs

00:09:02.426 --> 00:09:04.126 A:middle
提供一个简单的 method arguments

00:09:04.126 --> 00:09:05.346 A:middle
这样测试就可以间接地通过

00:09:05.996 --> 00:09:09.306 A:middle
但是 我们仍然需要解决

00:09:09.306 --> 00:09:11.026 A:middle
由 shared UI application incidence

00:09:11.026 --> 00:09:12.496 A:middle
引起的问题

00:09:13.026 --> 00:09:17.246 A:middle
我们能够怎么做呢

00:09:18.056 --> 00:09:20.086 A:middle
首先 我们可以停止

00:09:20.086 --> 00:09:21.336 A:middle
在这里直接

00:09:21.336 --> 00:09:22.376 A:middle
使用 accessor

00:09:22.966 --> 00:09:25.696 A:middle
让我们向类中加入

00:09:25.696 --> 00:09:27.786 A:middle
一个 initializer 这样我们就能够

00:09:27.786 --> 00:09:29.776 A:middle
得到一个特别的 application instance

00:09:30.316 --> 00:09:34.126 A:middle
我们可以为此 argument

00:09:34.126 --> 00:09:35.986 A:middle
提供一个初始数值

00:09:35.986 --> 00:09:36.336 A:middle
这样 在 view controller 中

00:09:36.336 --> 00:09:37.436 A:middle
就不必要

00:09:37.436 --> 00:09:38.426 A:middle
担心这个细节了

00:09:38.996 --> 00:09:44.546 A:middle
回到 open method 这里

00:09:44.546 --> 00:09:45.556 A:middle
我们随后切换使用

00:09:45.556 --> 00:09:47.006 A:middle
刚才得到的

00:09:47.006 --> 00:09:49.416 A:middle
application instance

00:09:49.636 --> 00:09:50.366 A:middle
一起来看看

00:09:50.366 --> 00:09:51.356 A:middle
这个代码重构给我们带来什么效果吧

00:09:55.016 --> 00:09:56.556 A:middle
如果我们现在尝试

00:09:56.556 --> 00:09:58.536 A:middle
在文档打开或者保持其当前状态的情况下

00:09:58.536 --> 00:10:00.116 A:middle
重写测试

00:09:58.536 --> 00:10:00.116 A:middle
重写测试

00:10:00.116 --> 00:10:01.006 A:middle
我们会发现自己

00:10:01.006 --> 00:10:01.606 A:middle
又被卡住了

00:10:02.896 --> 00:10:03.786 A:middle
你想要得到一个

00:10:03.786 --> 00:10:04.836 A:middle
我们能够控制的

00:10:04.836 --> 00:10:05.966 A:middle
application instance

00:10:06.566 --> 00:10:07.886 A:middle
自然 你可以想象将 UI 应用

00:10:07.886 --> 00:10:10.156 A:middle
加入子类别

00:10:10.156 --> 00:10:12.236 A:middle
覆写这个 canOpenURL 和 open methods

00:10:12.456 --> 00:10:13.896 A:middle
来得到我们想要的控制

00:10:14.166 --> 00:10:16.616 A:middle
但是 最后的结果是

00:10:16.616 --> 00:10:18.486 A:middle
UI 应用严格地遵守其

00:10:18.486 --> 00:10:19.446 A:middle
单例本质

00:10:20.166 --> 00:10:21.476 A:middle
引发异常产生例外情况来试图

00:10:21.476 --> 00:10:23.086 A:middle
创造第二个 instance

00:10:23.086 --> 00:10:24.000 A:middle
即使它是一个子类

00:10:27.046 --> 00:10:28.006 A:middle
所以 为了得到我们想要的控制

00:10:28.066 --> 00:10:29.876 A:middle
我们不用加入子类别这个方式

00:10:29.876 --> 00:10:32.176 A:middle
而是加入一个 protocol

00:10:32.176 --> 00:10:33.766 A:middle
URL Opening

00:10:34.316 --> 00:10:38.136 A:middle
我们看这个 protocol

00:10:38.786 --> 00:10:39.756 A:middle
和这两个 methods

00:10:39.756 --> 00:10:41.596 A:middle
它们所用的 signatures

00:10:41.596 --> 00:10:43.506 A:middle
和我们到目前为止的应用 methods 所使用的

00:10:44.166 --> 00:10:47.506 A:middle
signatures 一模一样

00:10:47.506 --> 00:10:49.546 A:middle
我们仍然想让 UI 应用

00:10:49.546 --> 00:10:50.966 A:middle
成为这个 protocol 的

00:10:50.966 --> 00:10:51.596 A:middle
最主要的实现

00:10:52.876 --> 00:10:54.626 A:middle
然后 我们会给 UI 应用

00:10:54.626 --> 00:10:56.466 A:middle
添加一个 extension 来

00:10:56.466 --> 00:10:57.726 A:middle
赋予其 URLOpening 一致性

00:10:58.226 --> 00:11:02.066 A:middle
因为这些方法的 signatures 都

00:10:58.226 --> 00:11:02.066 A:middle
因为这些方法的 signatures 都

00:11:02.066 --> 00:11:03.736 A:middle
正好对应

00:11:03.736 --> 00:11:05.106 A:middle
你就不需要再在这个 extension 上

00:11:05.106 --> 00:11:05.896 A:middle
添加额外的代码

00:11:05.896 --> 00:11:06.386 A:middle
来达到一致了

00:11:06.426 --> 00:11:12.056 A:middle
现在有一个 protocol 已经就绪

00:11:12.056 --> 00:11:13.736 A:middle
我们就更新 DocumentOpener

00:11:13.736 --> 00:11:15.436 A:middle
来使用这个 protocol

00:11:15.436 --> 00:11:17.000 A:middle
而不用 UI 应用本身了

00:11:20.366 --> 00:11:21.946 A:middle
首先 我们来更改其属性

00:11:21.946 --> 00:11:24.306 A:middle
并初始化参数来接受

00:11:24.306 --> 00:11:25.766 A:middle
这个 URLOpening protocol 的

00:11:25.766 --> 00:11:26.856 A:middle
任何的实现

00:11:27.446 --> 00:11:30.216 A:middle
要注意 我们仍然能够

00:11:30.216 --> 00:11:31.716 A:middle
保持 shard UI application instance 的

00:11:31.716 --> 00:11:32.846 A:middle
默认参数

00:11:32.846 --> 00:11:34.816 A:middle
这样我们之后

00:11:34.816 --> 00:11:35.506 A:middle
在 view controller 使用它时

00:11:35.506 --> 00:11:35.986 A:middle
就会方便很多

00:11:39.316 --> 00:11:40.856 A:middle
最后一个变更需要

00:11:40.856 --> 00:11:43.176 A:middle
document opener 采用

00:11:43.176 --> 00:11:45.416 A:middle
URL opener 的属性名称

00:11:48.576 --> 00:11:49.826 A:middle
一切都做好了 我们现在回到测试去

00:11:49.826 --> 00:11:51.546 A:middle
来一起看看这样操作之后的

00:11:51.546 --> 00:11:52.000 A:middle
效果如何

00:11:57.046 --> 00:11:58.796 A:middle
因为 UI 应用不能

00:11:58.796 --> 00:12:00.196 A:middle
使我们得到在测试中需要的控制

00:11:58.796 --> 00:12:00.196 A:middle
使我们得到在测试中需要的控制

00:12:00.196 --> 00:12:02.146 A:middle
我们就想建构

00:12:02.146 --> 00:12:04.076 A:middle
protocol 的一个

00:12:04.076 --> 00:12:06.566 A:middle
次级的mock implementation虚拟实现

00:12:08.436 --> 00:12:08.566 A:middle
来在其位置使用

00:12:08.746 --> 00:12:10.506 A:middle
我们在这里已经加上了

00:12:10.596 --> 00:12:13.866 A:middle
两个 methods 的 sub-implementation

00:12:13.866 --> 00:12:16.246 A:middle
canOpen URL method 充当

00:12:16.246 --> 00:12:17.516 A:middle
来自 document opener 的

00:12:17.516 --> 00:12:17.896 A:middle
一个 input

00:12:18.726 --> 00:12:19.596 A:middle
所以 测试需要控制

00:12:19.596 --> 00:12:20.776 A:middle
此 input

00:12:21.806 --> 00:12:22.816 A:middle
通过使 implementation 返回

00:12:22.816 --> 00:12:24.716 A:middle
测试事先设置好的

00:12:24.716 --> 00:12:26.276 A:middle
属性的数值

00:12:26.276 --> 00:12:27.096 A:middle
我们就能够做到这一点

00:12:30.296 --> 00:12:32.106 A:middle
而 open method 则充当了

00:12:32.106 --> 00:12:33.636 A:middle
来自 document opener 的 output

00:12:34.836 --> 00:12:35.776 A:middle
测试希望能够

00:12:35.776 --> 00:12:37.996 A:middle
接入任何传进这个 method

00:12:37.996 --> 00:12:38.696 A:middle
的 URL

00:12:39.176 --> 00:12:41.916 A:middle
为了达到这一点 我们可以将

00:12:41.916 --> 00:12:43.916 A:middle
URL 藏到一个属性之中

00:12:43.976 --> 00:12:45.346 A:middle
然后可以让测试在随后读取

00:12:48.956 --> 00:12:50.616 A:middle
好的 我们继续

00:12:50.616 --> 00:12:51.000 A:middle
编写这个测试

00:12:53.436 --> 00:12:54.726 A:middle
首先 我们为刚刚写好的

00:12:54.726 --> 00:12:56.146 A:middle
mockURLOpener 创建一个 instance,

00:12:56.146 --> 00:12:58.306 A:middle
然后用 canOpen 属性

00:12:58.546 --> 00:12:59.706 A:middle
设置 input

00:13:02.296 --> 00:13:03.446 A:middle
创建一个 documentOpener

00:13:03.446 --> 00:13:06.046 A:middle
然后将 mock urlOpener 加入

00:13:06.046 --> 00:13:07.106 A:middle
作为 argument

00:13:07.666 --> 00:13:11.756 A:middle
设置好了这个

00:13:11.756 --> 00:13:14.216 A:middle
我们就可以调用 open method

00:13:14.216 --> 00:13:15.696 A:middle
加入 document 和 open mode 的数值

00:13:16.066 --> 00:13:18.186 A:middle
作为余下的 input

00:13:20.316 --> 00:13:22.296 A:middle
然后 我们可以判断

00:13:22.296 --> 00:13:24.116 A:middle
mock URLOpener 的

00:13:24.116 --> 00:13:26.216 A:middle
openedURL 属性已经设置为

00:13:26.216 --> 00:13:27.036 A:middle
期望的 URL

00:13:27.666 --> 00:13:30.966 A:middle
这个 assertion 在

00:13:30.966 --> 00:13:32.446 A:middle
被调用的 open method 和

00:13:32.446 --> 00:13:34.756 A:middle
包含有正确数据的

00:13:34.756 --> 00:13:36.436 A:middle
传入的 URL 上

00:13:36.436 --> 00:13:37.006 A:middle
都进行测试

00:13:40.696 --> 00:13:42.186 A:middle
已经学习过这个测试后

00:13:42.546 --> 00:13:43.606 A:middle
大家就可以继续

00:13:43.606 --> 00:13:45.046 A:middle
为其它 input 数据的变体

00:13:45.046 --> 00:13:47.286 A:middle
编写测试了

00:13:47.286 --> 00:13:48.626 A:middle
比如 canOpen 属性设置为 false 的变体

00:13:48.626 --> 00:13:50.436 A:middle
我们接下来还有很多内容要讲

00:13:50.436 --> 00:13:51.806 A:middle
这部分就先讲到这里

00:13:55.646 --> 00:13:57.776 A:middle
在这个例子中

00:13:57.776 --> 00:13:59.766 A:middle
我们进行了一些代码重构

00:13:59.766 --> 00:14:01.406 A:middle
以使得我们能够为自己的代码

00:13:59.766 --> 00:14:01.406 A:middle
以使得我们能够为自己的代码

00:14:01.406 --> 00:14:02.000 A:middle
编写单元测试

00:14:04.436 --> 00:14:05.506 A:middle
我们抽离掉对一个

00:14:05.506 --> 00:14:07.046 A:middle
shared singleton instance 的

00:14:07.046 --> 00:14:09.416 A:middle
显示引用

00:14:09.416 --> 00:14:11.516 A:middle
然后用 parameterized input 取代显示引用

00:14:11.516 --> 00:14:12.246 A:middle
来作置换

00:14:13.666 --> 00:14:15.566 A:middle
一些情况下

00:14:15.566 --> 00:14:17.976 A:middle
这个被称作 penancy injection

00:14:18.196 --> 00:14:20.186 A:middle
在这个例子中

00:14:20.186 --> 00:14:22.356 A:middle
我们使用了一个 initialized parameter

00:14:22.356 --> 00:14:22.916 A:middle
来达到这个目的

00:14:23.296 --> 00:14:24.466 A:middle
我们也可以使用一个

00:14:24.466 --> 00:14:26.636 A:middle
属性 setter 或者是

00:14:26.636 --> 00:14:27.500 A:middle
接受测试的 method 的一个 parameter

00:14:31.196 --> 00:14:33.236 A:middle
我们创建了一个 protocol 来

00:14:33.236 --> 00:14:34.276 A:middle
将代码从其先前依赖的

00:14:34.276 --> 00:14:35.396 A:middle
具体类中

00:14:35.396 --> 00:14:37.000 A:middle
解耦出来

00:14:39.096 --> 00:14:40.396 A:middle
然后我们又创建了一个

00:14:40.396 --> 00:14:42.756 A:middle
测试 implementation 来

00:14:42.756 --> 00:14:43.176 A:middle
在其位置运行

00:14:43.176 --> 00:14:45.506 A:middle
这给予了我们所需的

00:14:45.506 --> 00:14:46.826 A:middle
对于 inputs 的控制

00:14:47.426 --> 00:14:49.346 A:middle
以及 outputs 的可视性

00:14:56.276 --> 00:14:58.656 A:middle
接下来 我希望带大家看看

00:14:58.656 --> 00:15:00.356 A:middle
如何将 logic 从 effects 中分离出来

00:14:58.656 --> 00:15:00.356 A:middle
如何将 logic 从 effects 中分离出来

00:15:00.356 --> 00:15:02.176 A:middle
以及如何用此种操作

00:15:02.176 --> 00:15:03.386 A:middle
提升可测试性

00:15:07.636 --> 00:15:10.226 A:middle
这里的例子是一个

00:15:10.316 --> 00:15:12.466 A:middle
OnDiskCache 类

00:15:12.466 --> 00:15:14.526 A:middle
可能是被 app 用来

00:15:14.526 --> 00:15:15.806 A:middle
对先前已经从服务器下载下来的 assets

00:15:15.806 --> 00:15:17.346 A:middle
进行更快速的

00:15:17.856 --> 00:15:18.000 A:middle
取回

00:15:20.946 --> 00:15:22.866 A:middle
该 Cache 界定了

00:15:22.866 --> 00:15:24.066 A:middle
一个脚本

00:15:24.066 --> 00:15:24.416 A:middle
此脚本代表了其所储存的条目

00:15:24.896 --> 00:15:26.926 A:middle
它界定了在文件系统中

00:15:26.926 --> 00:15:28.936 A:middle
获取该条目的路径

00:15:28.936 --> 00:15:30.436 A:middle
以及它在 cache 上存在的时间

00:15:30.436 --> 00:15:31.146 A:middle
和在磁盘上的大小

00:15:31.656 --> 00:15:34.166 A:middle
并提供了获取

00:15:34.166 --> 00:15:35.706 A:middle
目前所有储存在 cache 上条目集合

00:15:35.706 --> 00:15:36.586 A:middle
的方法

00:15:40.096 --> 00:15:41.176 A:middle
现在需要注意的 method

00:15:41.176 --> 00:15:43.216 A:middle
是一个

00:15:43.216 --> 00:15:43.586 A:middle
cleanup method

00:15:44.316 --> 00:15:45.096 A:middle
这个 method 应该是被

00:15:45.096 --> 00:15:46.816 A:middle
周期性地调用

00:15:46.816 --> 00:15:47.976 A:middle
以保证 cache 不会增加得过多

00:15:47.976 --> 00:15:49.146 A:middle
占据文件系统

00:15:49.146 --> 00:15:49.486 A:middle
太多的空间

00:15:49.836 --> 00:15:53.136 A:middle
好的 我们来看一看

00:15:53.136 --> 00:15:54.716 A:middle
这个 method 对应的

00:15:55.176 --> 00:15:55.326 A:middle
起始实现

00:15:57.256 --> 00:15:59.716 A:middle
首先 它请求

00:15:59.716 --> 00:16:00.916 A:middle
当前所有处在 cache 上的

00:15:59.716 --> 00:16:00.916 A:middle
当前所有处在 cache 上的

00:16:00.916 --> 00:16:02.926 A:middle
条目集合

00:16:02.926 --> 00:16:03.456 A:middle
按照从最新到最老的顺序排列

00:16:03.936 --> 00:16:07.646 A:middle
然后

00:16:07.646 --> 00:16:09.986 A:middle
这些条目

00:16:09.986 --> 00:16:11.406 A:middle
记录下所有已见到条目

00:16:11.406 --> 00:16:12.000 A:middle
的总大小

00:16:15.086 --> 00:16:16.086 A:middle
一旦你看到了

00:16:16.156 --> 00:16:17.196 A:middle
达到了我们的最大容量

00:16:17.196 --> 00:16:19.416 A:middle
的足够多的条目 我们就可以开始

00:16:19.416 --> 00:16:23.636 A:middle
将其余的从文件系统中移除出去了

00:16:23.896 --> 00:16:24.986 A:middle
好的 让我们想想应该

00:16:24.986 --> 00:16:25.646 A:middle
如何测试这个 method

00:16:26.976 --> 00:16:27.846 A:middle
什么是其 inputs

00:16:28.186 --> 00:16:31.566 A:middle
什么是其 outputs

00:16:31.696 --> 00:16:33.896 A:middle
一个 input 是指定了

00:16:33.896 --> 00:16:35.116 A:middle
你想要 cache 最大能增大到多少的

00:16:35.116 --> 00:16:36.346 A:middle
parameter

00:16:36.346 --> 00:16:39.076 A:middle
这是一个简单的整数

00:16:39.076 --> 00:16:40.996 A:middle
一个 method parameter

00:16:40.996 --> 00:16:42.476 A:middle
所以测试对其已经拥有

00:16:42.606 --> 00:16:42.660 A:middle
完全的控制

00:16:45.316 --> 00:16:47.506 A:middle
另外一个 input

00:16:47.506 --> 00:16:48.816 A:middle
是现在储存在 cache 上的

00:16:48.816 --> 00:16:51.226 A:middle
条目列表

00:16:51.436 --> 00:16:52.636 A:middle
我们就不去花时间看

00:16:52.636 --> 00:16:54.326 A:middle
这个到底是怎么实现的了

00:16:54.326 --> 00:16:56.236 A:middle
但是这里的关键是

00:16:56.236 --> 00:16:57.976 A:middle
它使用了一个 file manage r来

00:16:57.976 --> 00:16:59.586 A:middle
从磁盘上取回一个文件列表

00:17:01.736 --> 00:17:03.326 A:middle
这就意味着

00:17:03.326 --> 00:17:04.626 A:middle
input 实际是来源于

00:17:04.626 --> 00:17:06.836 A:middle
文件系统的

00:17:06.836 --> 00:17:07.726 A:middle
测试则需要

00:17:07.726 --> 00:17:08.976 A:middle
处理好这种依赖性

00:17:12.296 --> 00:17:14.276 A:middle
clean cache method 没有

00:17:14.276 --> 00:17:14.965 A:middle
返回数值

00:17:15.576 --> 00:17:18.606 A:middle
所以 它的 output 不可能是数据

00:17:18.786 --> 00:17:20.566 A:middle
换句话说 它是

00:17:20.566 --> 00:17:22.296 A:middle
在一系列特定的文件被从磁盘移除后

00:17:22.296 --> 00:17:23.606 A:middle
产生的副效应

00:17:24.056 --> 00:17:27.195 A:middle
因为它依赖于文件系统

00:17:27.195 --> 00:17:29.146 A:middle
对于这个 method 的测试

00:17:29.146 --> 00:17:31.436 A:middle
就需要和在文件系统中的

00:17:31.436 --> 00:17:33.126 A:middle
一个文件管理器打交道

00:17:34.336 --> 00:17:35.966 A:middle
设置这些测试时

00:17:35.966 --> 00:17:37.876 A:middle
可能需要它们创建一个临时文件夹

00:17:37.876 --> 00:17:39.716 A:middle
然后向其中填入一些

00:17:39.716 --> 00:17:41.526 A:middle
特定大小的文件

00:17:41.526 --> 00:17:43.196 A:middle
并给它们加上特定的 timestamps

00:17:43.196 --> 00:17:43.936 A:middle
来提供 input

00:17:45.856 --> 00:17:47.466 A:middle
为了验证 output

00:17:47.836 --> 00:17:48.876 A:middle
你则需要随后返回到

00:17:48.876 --> 00:17:50.936 A:middle
文件系统去看看哪些文件

00:17:50.936 --> 00:17:52.000 A:middle
还在那里

00:17:56.176 --> 00:17:57.266 A:middle
一种实现该目的的方式

00:17:57.266 --> 00:17:59.816 A:middle
就是使用

00:17:59.816 --> 00:18:01.116 A:middle
我们之前看过的

00:17:59.816 --> 00:18:01.116 A:middle
我们之前看过的

00:18:01.116 --> 00:18:01.926 A:middle
protocols 和 parameterization 技术

00:18:03.296 --> 00:18:04.636 A:middle
你可以引进一个

00:18:04.636 --> 00:18:06.676 A:middle
文件管理器 protocol

00:18:06.676 --> 00:18:07.916 A:middle
它具有我们需要的 methods

00:18:07.916 --> 00:18:09.606 A:middle
能够帮助我们得到一个文件列表

00:18:09.606 --> 00:18:10.306 A:middle
并移除一个文件

00:18:11.786 --> 00:18:13.026 A:middle
然后创建一个测试实现

00:18:13.026 --> 00:18:15.206 A:middle
能够详细列举

00:18:15.206 --> 00:18:16.446 A:middle
会被返回的

00:18:16.446 --> 00:18:17.986 A:middle
文件列表

00:18:17.986 --> 00:18:19.246 A:middle
并针对哪些文件被移除

00:18:19.746 --> 00:18:19.946 A:middle
发出一个 query

00:18:21.996 --> 00:18:23.396 A:middle
如果我们这么做

00:18:23.396 --> 00:18:25.136 A:middle
我们还是在间接地

00:18:25.286 --> 00:18:26.276 A:middle
同想要测试的代码互动

00:18:26.276 --> 00:18:28.386 A:middle
文件管理器

00:18:28.386 --> 00:18:28.756 A:middle
负责居中进行协调

00:18:32.306 --> 00:18:34.146 A:middle
我们不这样做

00:18:34.146 --> 00:18:35.156 A:middle
来试试不同的方式

00:18:35.826 --> 00:18:37.406 A:middle
我们可以使用

00:18:37.406 --> 00:18:40.376 A:middle
clean cache method 并

00:18:40.656 --> 00:18:41.896 A:middle
从负责确定哪些文件需要被移除的 logic 中

00:18:41.896 --> 00:18:44.126 A:middle
提出撰因子

00:18:44.126 --> 00:18:46.606 A:middle
就是 clean-up policy

00:18:46.606 --> 00:18:47.576 A:middle
然后你就能够

00:18:47.576 --> 00:18:48.026 A:middle
进行更直接的互动了

00:18:48.666 --> 00:18:51.606 A:middle
我们来看看这个是如何运转的

00:18:54.776 --> 00:18:56.136 A:middle
为了清楚地界定我们

00:18:56.136 --> 00:18:57.316 A:middle
要使用的 APIs

00:18:57.586 --> 00:18:59.206 A:middle
首先我们将 clean-up policy 定义为

00:18:59.206 --> 00:18:59.776 A:middle
一个 protocol

00:19:00.406 --> 00:19:03.976 A:middle
这只需要一个 method 即

00:19:04.326 --> 00:19:05.126 A:middle
itemsToRemove

00:19:06.456 --> 00:19:07.876 A:middle
注意下我们给它加上的

00:19:07.876 --> 00:19:09.696 A:middle
type signature

00:19:09.696 --> 00:19:11.836 A:middle
和之前我们开始时的

00:19:11.836 --> 00:19:13.126 A:middle
clean cache method 的

00:19:13.416 --> 00:19:13.500 A:middle
看起来有些不一样

00:19:16.066 --> 00:19:18.856 A:middle
作为 input

00:19:18.916 --> 00:19:20.276 A:middle
这个新的 method 使用一组 cache 条目数值

00:19:21.616 --> 00:19:23.316 A:middle
而对于 output

00:19:23.416 --> 00:19:25.506 A:middle
它能够返回另一组数值

00:19:25.506 --> 00:19:27.206 A:middle
但是这是那些将被移除的条目数值

00:19:30.596 --> 00:19:32.046 A:middle
好的 我们就看看

00:19:32.046 --> 00:19:33.696 A:middle
如何用我们先前在

00:19:33.696 --> 00:19:35.166 A:middle
cache 类里面看到的算法

00:19:35.166 --> 00:19:37.326 A:middle
来实现这个 protocol

00:19:39.416 --> 00:19:40.546 A:middle
好的 首先为 input 的最大值

00:19:40.756 --> 00:19:41.966 A:middle
界定一个属性

00:19:42.896 --> 00:19:44.276 A:middle
这可以让我们明确这个最大的大小

00:19:44.276 --> 00:19:45.496 A:middle
然后我们可以构建

00:19:45.496 --> 00:19:45.936 A:middle
policy

00:19:48.916 --> 00:19:50.646 A:middle
然后我们添加

00:19:50.646 --> 00:19:52.166 A:middle
protocol 要求的

00:19:52.166 --> 00:19:52.716 A:middle
itemsToRemove method

00:19:56.136 --> 00:19:57.686 A:middle
我们想要检查

00:19:57.686 --> 00:19:59.096 A:middle
每一个传递进 method 的条目

00:19:59.786 --> 00:20:01.246 A:middle
然后构建一组将被移除的条目

00:19:59.786 --> 00:20:01.246 A:middle
然后构建一组将被移除的条目

00:20:01.246 --> 00:20:02.906 A:middle
在完成之后

00:20:02.906 --> 00:20:04.000 A:middle
再将其返回给 method

00:20:07.216 --> 00:20:09.166 A:middle
为了填充该组

00:20:09.166 --> 00:20:10.346 A:middle
我们将这些条目按照从新至老的顺序

00:20:10.346 --> 00:20:13.416 A:middle
进行循环

00:20:13.416 --> 00:20:14.826 A:middle
计算已见所有条目大小

00:20:14.826 --> 00:20:16.006 A:middle
的总数

00:20:18.336 --> 00:20:19.776 A:middle
一旦我们达到了最大值

00:20:19.776 --> 00:20:22.346 A:middle
就开始向这组 itemsToRemove

00:20:22.346 --> 00:20:24.186 A:middle
添加剩余的

00:20:27.496 --> 00:20:29.826 A:middle
请看这条代码

00:20:29.826 --> 00:20:31.086 A:middle
我们能够发现在先前版本中

00:20:31.086 --> 00:20:32.556 A:middle
容易出现的副效应

00:20:32.806 --> 00:20:33.556 A:middle
在此处已经被移除

00:20:34.166 --> 00:20:36.666 A:middle
保留下来的是底层算法

00:20:36.666 --> 00:20:40.096 A:middle
将数据取作 input

00:20:40.806 --> 00:20:44.016 A:middle
然后返回一些数据

00:20:44.016 --> 00:20:44.416 A:middle
作为 output

00:20:45.566 --> 00:20:46.886 A:middle
我们也可以将由此而

00:20:46.886 --> 00:20:47.956 A:middle
实现的数据流

00:20:47.956 --> 00:20:48.496 A:middle
可视化

00:20:49.106 --> 00:20:51.826 A:middle
注意下 这个代码采用了

00:20:51.826 --> 00:20:53.206 A:middle
功能样式

00:20:53.946 --> 00:20:55.376 A:middle
数据进入 数据输出

00:20:59.736 --> 00:21:01.336 A:middle
通过这种方式将 logic

00:20:59.736 --> 00:21:01.336 A:middle
通过这种方式将 logic

00:21:01.336 --> 00:21:03.456 A:middle
进行提出撰因子操作

00:21:03.456 --> 00:21:04.796 A:middle
我们能够写出清晰

00:21:04.796 --> 00:21:06.536 A:middle
简明的测试

00:21:06.536 --> 00:21:10.216 A:middle
然后对算法进行全面的测试

00:21:10.336 --> 00:21:12.046 A:middle
我们需要做的就是界定

00:21:12.156 --> 00:21:16.536 A:middle
包含有一些 cache 条目的输入集

00:21:16.536 --> 00:21:17.826 A:middle
创建一个该类型的 instance

00:21:18.656 --> 00:21:20.296 A:middle
调用 method

00:21:20.296 --> 00:21:21.486 A:middle
直接将其需要的数值传递进入

00:21:21.486 --> 00:21:25.246 A:middle
然后判断

00:21:25.246 --> 00:21:27.026 A:middle
返回的条目

00:21:27.026 --> 00:21:27.736 A:middle
匹配预期的结果

00:21:28.266 --> 00:21:32.296 A:middle
有了这种形式的代码

00:21:32.296 --> 00:21:33.326 A:middle
我们现在就能够轻易获得

00:21:33.326 --> 00:21:35.446 A:middle
对 inputs 的控制

00:21:35.446 --> 00:21:38.116 A:middle
及 outputs 的可视化显示

00:21:38.116 --> 00:21:39.486 A:middle
没有任何需要进行处理的隐藏状态了

00:21:40.476 --> 00:21:41.656 A:middle
这个特别能让我们

00:21:41.656 --> 00:21:43.606 A:middle
联想到一开始看到的

00:21:43.606 --> 00:21:44.576 A:middle
为 sorted method 所写的测试

00:21:46.496 --> 00:21:48.406 A:middle
测试因此变得

00:21:48.406 --> 00:21:50.136 A:middle
极易读取

00:21:50.136 --> 00:21:51.926 A:middle
测试要针对的要素

00:21:51.926 --> 00:21:55.506 A:middle
也运行飞快

00:21:55.506 --> 00:21:57.446 A:middle
受到的干扰也最小

00:21:57.446 --> 00:21:59.536 A:middle
因为它不再需要依赖于运行速度慢的资源了

00:21:59.536 --> 00:22:00.436 A:middle
比如文件系统

00:21:59.536 --> 00:22:00.436 A:middle
比如文件系统

00:22:00.966 --> 00:22:04.406 A:middle
而且极具确定性

00:22:04.576 --> 00:22:06.256 A:middle
因为所有使用的数据

00:22:06.256 --> 00:22:06.936 A:middle
都是独立的

00:22:11.756 --> 00:22:13.596 A:middle
再回来看一眼

00:22:13.596 --> 00:22:15.136 A:middle
最初的 clean cache method

00:22:15.476 --> 00:22:17.476 A:middle
我们发现在进行取出操作后

00:22:17.476 --> 00:22:19.326 A:middle
剩下的东西就不多了

00:22:21.476 --> 00:22:22.826 A:middle
我们现在只要请求

00:22:22.826 --> 00:22:24.736 A:middle
clean-up policy 来

00:22:24.736 --> 00:22:28.126 A:middle
将条目移除

00:22:28.126 --> 00:22:30.076 A:middle
然后迭代直到

00:22:30.076 --> 00:22:30.906 A:middle
将其全部移除出文件系统

00:22:33.236 --> 00:22:36.036 A:middle
为了测试剩余的代码

00:22:36.036 --> 00:22:37.496 A:middle
我们可以引进

00:22:37.496 --> 00:22:39.186 A:middle
文件管理器 protocol 以及

00:22:39.186 --> 00:22:41.236 A:middle
具备可测试性的实现

00:22:41.236 --> 00:22:42.836 A:middle
来使得我们能够为其写一个

00:22:43.446 --> 00:22:43.500 A:middle.
十分独立的单元测试

00:22:44.496 --> 00:22:46.486 A:middle
当然 我们也许也会觉得

00:22:46.486 --> 00:22:48.466 A:middle
几个综合测试

00:22:48.466 --> 00:22:49.506 A:middle
就已经足够了

00:22:49.506 --> 00:22:51.496 A:middle
就能够让我们对代码可以正确运行

00:22:51.496 --> 00:22:52.646 A:middle
有足够的把握

00:22:53.916 --> 00:22:55.176 A:middle
这一薄薄的[听不清]

00:22:55.296 --> 00:22:56.986 A:middle
代码层就是剩下的

00:23:01.816 --> 00:23:04.186 A:middle
好的 在这个例子中

00:23:04.736 --> 00:23:08.036 A:middle
我们看到了如何利用副效应

00:23:08.036 --> 00:23:09.606 A:middle
将 business logic 和算法

00:23:09.606 --> 00:23:12.176 A:middle
从代码中抽取出到

00:23:12.206 --> 00:23:13.606 A:middle
单独的类型中

00:23:15.636 --> 00:23:17.806 A:middle
在进行这种操作时

00:23:17.806 --> 00:23:19.046 A:middle
算法通常会倾向于呈现功能样式

00:23:19.046 --> 00:23:21.026 A:middle
使用数值类型

00:23:21.026 --> 00:23:22.976 A:middle
来描述 inputs

00:23:23.186 --> 00:23:23.976 A:middle
和 outputs

00:23:24.466 --> 00:23:26.926 A:middle
这个使我们能够利用

00:23:26.926 --> 00:23:29.216 A:middle
简单直接的单元测试

00:23:29.216 --> 00:23:30.806 A:middle
对算法进行测试

00:23:30.806 --> 00:23:31.326 A:middle
可以达到任何你所需的细致程度

00:23:34.676 --> 00:23:36.116 A:middle
我们还剩下一小部分

00:23:36.116 --> 00:23:37.636 A:middle
代码用来运行

00:23:37.636 --> 00:23:38.966 A:middle
基于电脑数据的

00:23:38.966 --> 00:23:39.406 A:middle
副效应

00:23:39.906 --> 00:23:42.336 A:middle
这个部分经常

00:23:42.336 --> 00:23:43.856 A:middle
可以用综合测试

00:23:43.856 --> 00:23:46.316 A:middle
来进行很好的测试

00:23:46.316 --> 00:23:47.406 A:middle
这样就能够跟踪

00:23:47.406 --> 00:23:48.526 A:middle
它和余下的系统间的互动

00:23:48.526 --> 00:23:49.256 A:middle
正在正常进行

00:23:54.176 --> 00:23:57.126 A:middle
总结一下

00:23:57.126 --> 00:23:59.186 A:middle
我们看过了一些例子

00:23:59.186 --> 00:24:00.956 A:middle
这些例子能够帮助我们探索一些

00:23:59.186 --> 00:24:00.956 A:middle
这些例子能够帮助我们探索一些

00:24:00.956 --> 00:24:03.116 A:middle
允许我们构建或者请求代码的技术

00:24:03.116 --> 00:24:04.956 A:middle
这样测试就能够拥有对代码 inputs 的控制

00:24:04.956 --> 00:24:06.996 A:middle
以及其 outputs 的可视性

00:24:06.996 --> 00:24:09.126 A:middle
因此 这就能够使我们

00:24:09.126 --> 00:24:10.456 A:middle
为其写出

00:24:10.456 --> 00:24:12.026 A:middle
有效的单元测试

00:24:14.776 --> 00:24:16.296 A:middle
好的 现在我想要请我的同事上来

00:24:16.296 --> 00:24:18.146 A:middle
Greg Tracy 来给大家讲一讲

00:24:18.146 --> 00:24:19.466 A:middle
如何创建能够随着你的 app

00:24:19.816 --> 00:24:21.126 A:middle
成长也进行扩展的

00:24:21.126 --> 00:24:21.556 A:middle
测试套件

00:24:23.516 --> 00:24:27.500 A:middle
[掌声]

00:24:31.636 --> 00:24:32.586 A:middle
&gt;&gt; 大家好

00:24:32.796 --> 00:24:33.536 A:middle
我叫 Greg

00:24:33.536 --> 00:24:35.996 A:middle
现在也在 Xcode 工作

00:24:37.316 --> 00:24:38.866 A:middle
刚才 Brian 给大家展示了

00:24:38.866 --> 00:24:40.176 A:middle
如何使得 app 代码更具可测试性

00:24:40.176 --> 00:24:41.216 A:middle
的一些技术

00:24:41.826 --> 00:24:42.926 A:middle
现在我想要给大家展示

00:24:42.926 --> 00:24:44.336 A:middle
如何使得伴随着的测试代码

00:24:44.336 --> 00:24:45.356 A:middle
更加具有可扩展性

00:24:45.356 --> 00:24:47.316 A:middle
为了达到这一点

00:24:47.316 --> 00:24:49.376 A:middle
我们会来一起看看几种能够让

00:24:49.376 --> 00:24:51.166 A:middle
测试运行更快 更加易读 更模块化

00:24:51.166 --> 00:24:52.006 A:middle
的方法

00:24:52.446 --> 00:24:54.306 A:middle
我也想要提一下

00:24:54.306 --> 00:24:55.606 A:middle
刚才 Brian 所介绍的技术

00:24:55.606 --> 00:24:57.256 A:middle
大多对测试代码

00:24:57.256 --> 00:24:58.256 A:middle
也是适用的

00:24:58.926 --> 00:25:00.056 A:middle
不过在这里 我们会看看

00:24:58.926 --> 00:25:00.056 A:middle
不过在这里 我们会看看

00:25:00.056 --> 00:25:01.766 A:middle
更多的小窍门

00:25:03.196 --> 00:25:05.516 A:middle
首先 我会讲讲

00:25:05.606 --> 00:25:07.166 A:middle
在 UI 和单元测试间达到一个平衡

00:25:08.106 --> 00:25:08.330 A:middle
这个话题

00:25:09.376 --> 00:25:11.496 A:middle
然后 我会讲讲如何能够帮助测试

00:25:11.496 --> 00:25:13.816 A:middle
具备可扩展性的代码

00:25:13.816 --> 00:25:14.376 A:middle
重点放在 UI 测试代码上

00:25:15.086 --> 00:25:17.386 A:middle
随后 我会给大家说明

00:25:17.386 --> 00:25:19.416 A:middle
测试代码质量

00:25:19.416 --> 00:25:20.000 A:middle
的重要性

00:25:22.736 --> 00:25:23.716 A:middle
在 UI 测试和单元测试间

00:25:23.776 --> 00:25:27.436 A:middle
达到正确的平衡

00:25:27.436 --> 00:25:28.436 A:middle
有些时候 我喜欢

00:25:28.436 --> 00:25:30.006 A:middle
将测试的分布视作

00:25:30.006 --> 00:25:30.536 A:middle
一个金字塔

00:25:31.816 --> 00:25:33.216 A:middle
最顶端的是 UI 测试

00:25:33.216 --> 00:25:36.036 A:middle
底部呢

00:25:36.036 --> 00:25:37.906 A:middle
则是单元测试

00:25:38.656 --> 00:25:40.026 A:middle
这个[听不清]

00:25:40.026 --> 00:25:42.286 A:middle
金字塔的结构也正好体现了现实情况

00:25:42.406 --> 00:25:44.336 A:middle
相较于 UI 测试而言

00:25:44.336 --> 00:25:44.826 A:middle
我们进行的单元测试数量会更多一些

00:25:45.336 --> 00:25:46.526 A:middle
这个通常是因为

00:25:46.526 --> 00:25:48.496 A:middle
单元测试的运行速度

00:25:48.496 --> 00:25:49.566 A:middle
要比 UI 测试快很多

00:25:50.956 --> 00:25:53.296 A:middle
在 UI 测试和单元测试之间

00:25:53.456 --> 00:25:56.206 A:middle
我们还有综合测试

00:25:56.986 --> 00:25:58.726 A:middle
不过 今天我们会把重点

00:25:58.726 --> 00:26:00.156 A:middle
放在 UI 测试

00:25:58.726 --> 00:26:00.156 A:middle
放在 UI 测试

00:26:00.156 --> 00:26:00.330 A:middle
和单元测试上

00:26:04.396 --> 00:26:06.216 A:middle
除了能够体现分布状态

00:26:06.216 --> 00:26:07.516 A:middle
这个金字塔结构

00:26:07.516 --> 00:26:08.786 A:middle
也能够体现不同测试的

00:26:08.786 --> 00:26:09.246 A:middle
维护成本

00:26:09.986 --> 00:26:11.496 A:middle
一般情况下

00:26:11.496 --> 00:26:12.586 A:middle
UI 测试的维护成本会比较高

00:26:12.586 --> 00:26:14.036 A:middle
因为会有各种各样的

00:26:14.036 --> 00:26:14.716 A:middle
情况发生

00:26:15.896 --> 00:26:17.106 A:middle
另一方面 单元测试

00:26:17.396 --> 00:26:19.206 A:middle
的维护成本则比较低

00:26:19.476 --> 00:26:21.626 A:middle
所以 当一个单元测试失败后

00:26:21.626 --> 00:26:23.206 A:middle
哪里出现了问题

00:26:23.346 --> 00:26:24.146 A:middle
一般都是瞬间就一目了然的

00:26:25.336 --> 00:26:27.066 A:middle
而 UI 测试

00:26:27.066 --> 00:26:28.916 A:middle
则像是撒下了一张大网

00:26:28.916 --> 00:26:30.006 A:middle
可能能够捕捉到

00:26:30.006 --> 00:26:31.996 A:middle
难以理解的测试失败结果

00:26:31.996 --> 00:26:33.286 A:middle
或者得到和手头测试相关性并不高的结果

00:26:33.336 --> 00:26:34.946 A:middle
所以 UI 测试可能会有些难以捉摸

00:26:38.216 --> 00:26:39.556 A:middle
虽然这个金字塔结构

00:26:39.556 --> 00:26:41.216 A:middle
能够很好地展示

00:26:41.506 --> 00:26:43.176 A:middle
我们各种测试的分布状况

00:26:43.176 --> 00:26:45.096 A:middle
但是并不能够

00:26:45.096 --> 00:26:46.486 A:middle
体现

00:26:46.536 --> 00:26:47.136 A:middle
每一种可能出现的情况

00:26:47.826 --> 00:26:48.996 A:middle
事实上 你可以将测试

00:26:48.996 --> 00:26:50.816 A:middle
想象成为一个频谱

00:26:50.816 --> 00:26:51.726 A:middle
而非一个金字塔

00:26:52.296 --> 00:26:53.886 A:middle
一些 UI 测试和

00:26:54.376 --> 00:26:55.606 A:middle
单元测试 经常会存在于

00:26:55.676 --> 00:26:56.946 A:middle
这个频谱的两端

00:26:57.406 --> 00:26:58.726 A:middle
或者是这个金字塔结构的两端

00:26:59.306 --> 00:27:01.056 A:middle
一些 UI 测试可能会

00:26:59.306 --> 00:27:01.056 A:middle
一些 UI 测试可能会

00:27:01.056 --> 00:27:03.626 A:middle
更像单元测试

00:27:03.696 --> 00:27:04.936 A:middle
而一个单元测试也可以

00:27:04.936 --> 00:27:07.136 A:middle
和不同代码模块进行互动

00:27:07.136 --> 00:27:08.886 A:middle
并不总是和单一独立的模块互动

00:27:09.986 --> 00:27:10.916 A:middle
只能说这个金字塔结构

00:27:10.916 --> 00:27:11.746 A:middle
是最相近与真实情况的

00:27:11.746 --> 00:27:15.816 A:middle
当然 它不可能是一成不变完全准确的

00:27:15.906 --> 00:27:16.896 A:middle
审视这两种

00:27:16.896 --> 00:27:18.146 A:middle
不同测试的时候

00:27:18.146 --> 00:27:19.036 A:middle
我们需要考虑

00:27:19.036 --> 00:27:20.000 A:middle
它们各自的优势

00:27:21.386 --> 00:27:23.326 A:middle
单元测试很适合被用于测试

00:27:23.326 --> 00:27:25.136 A:middle
一小部分代码

00:27:25.136 --> 00:27:26.846 A:middle
而这部分代码可能在

00:27:26.846 --> 00:27:28.026 A:middle
无法访问我们 app 全部源码的情况下很难接触到

00:27:28.546 --> 00:27:30.896 A:middle
另一方面 UI 测试

00:27:30.896 --> 00:27:32.196 A:middle
则在测试一大块代码

00:27:32.196 --> 00:27:34.106 A:middle
同时运行的状况时

00:27:34.106 --> 00:27:34.526 A:middle
表现出众

00:27:35.686 --> 00:27:36.956 A:middle
当然了 我们还是要

00:27:36.956 --> 00:27:38.406 A:middle
时刻记住

00:27:38.406 --> 00:27:39.716 A:middle
单元测试能够访问到我们 app 的所有资源

00:27:39.716 --> 00:27:42.686 A:middle
而 UI 测试则不可以

00:27:45.036 --> 00:27:46.826 A:middle
现在把重点放在 UI 测试上

00:27:47.056 --> 00:27:48.096 A:middle
我们来看看

00:27:48.096 --> 00:27:49.306 A:middle
大家能够为提升自己测试代码质量

00:27:49.306 --> 00:27:50.026 A:middle
采取哪些操作

00:27:51.066 --> 00:27:52.006 A:middle
采用我接下来建议的

00:27:52.006 --> 00:27:54.236 A:middle
一些变更

00:27:54.236 --> 00:27:56.026 A:middle
我们能够轻松地创建

00:27:56.246 --> 00:27:57.766 A:middle
可以随着我们 app 代码扩展的

00:27:57.876 --> 00:27:57.976 A:middle
测试

00:28:01.046 --> 00:28:03.356 A:middle
我们讲如下几个方面

00:28:03.356 --> 00:28:06.196 A:middle
抽象出 UI element queries

00:28:06.246 --> 00:28:07.686 A:middle
在 utility functions 中创建 objects

00:28:07.716 --> 00:28:08.736 A:middle
这个可以放在函数库中

00:28:08.736 --> 00:28:11.916 A:middle
以后经常使用

00:28:12.126 --> 00:28:13.586 A:middle
以及启用快捷键

00:28:17.326 --> 00:28:18.116 A:middle
首先 我们来看看

00:28:18.116 --> 00:28:19.606 A:middle
抽象出 UI element queries 这个方面

00:28:20.976 --> 00:28:22.116 A:middle
比如说我有一个 app

00:28:22.246 --> 00:28:23.186 A:middle
在它的 view controller 中

00:28:23.186 --> 00:28:23.696 A:middle
有一些按钮

00:28:24.496 --> 00:28:25.926 A:middle
每一个按钮

00:28:25.926 --> 00:28:27.086 A:middle
都处在相同的视图层级

00:28:27.086 --> 00:28:29.306 A:middle
唯一的区别

00:28:29.406 --> 00:28:31.736 A:middle
就是每个按钮的名称不同

00:28:31.896 --> 00:28:32.836 A:middle
与其把这个 query 写 7 次

00:28:32.836 --> 00:28:34.706 A:middle
不如把它们一起放在

00:28:34.706 --> 00:28:35.416 A:middle
一个 method 中

00:28:39.116 --> 00:28:40.746 A:middle
现在我们就能够用

00:28:40.746 --> 00:28:42.416 A:middle
刚刚创建好的新 method 来

00:28:42.416 --> 00:28:43.066 A:middle
修改每一个 query 了

00:28:43.676 --> 00:28:45.556 A:middle
但是

00:28:45.556 --> 00:28:45.876 A:middle
我还想要更进一步

00:28:49.366 --> 00:28:50.656 A:middle
既然每个 method 调用的对象

00:28:50.766 --> 00:28:53.026 A:middle
除去名字不同外 其它都一样

00:28:53.026 --> 00:28:54.326 A:middle
我们就把那些名字放在一个数组中

00:28:54.326 --> 00:28:56.486 A:middle
然后对其进行循环即可

00:28:56.696 --> 00:28:57.646 A:middle
这个方法有利于

00:28:57.646 --> 00:28:59.116 A:middle
提高该代码的可维护性

00:28:59.616 --> 00:29:00.756 A:middle
如果我今后要添加

00:28:59.616 --> 00:29:00.756 A:middle
如果我今后要添加

00:29:00.806 --> 00:29:02.926 A:middle
一个新按钮的话

00:29:02.926 --> 00:29:03.756 A:middle
我就不需要再添加一行新代码了

00:29:03.886 --> 00:29:04.996 A:middle
我只需要向数组中

00:29:04.996 --> 00:29:09.206 A:middle
多添加一个按钮的名字就可以了

00:29:09.376 --> 00:29:11.086 A:middle
由 UI 测试的性质决定

00:29:11.726 --> 00:29:14.116 A:middle
我们会使用很多这样的

00:29:14.116 --> 00:29:14.576 A:middle
queries

00:29:14.576 --> 00:29:16.926 A:middle
如果你要多次

00:29:16.926 --> 00:29:18.946 A:middle
使用同一个 query

00:29:18.946 --> 00:29:19.776 A:middle
就最好将其储存起来作为一个 variable

00:29:20.076 --> 00:29:21.666 A:middle
即使只是一个 query 的一部分

00:29:21.816 --> 00:29:26.126 A:middle
也把它储存起来

00:29:26.236 --> 00:29:27.826 A:middle
同样的 如果你的 queries

00:29:27.826 --> 00:29:29.386 A:middle
都比较相似

00:29:29.386 --> 00:29:30.686 A:middle
则可以考虑围绕着 query

00:29:30.686 --> 00:29:31.316 A:middle
创建一个辅助方法(helper method)

00:29:32.526 --> 00:29:34.056 A:middle
代码就看起来整洁很多了

00:29:34.056 --> 00:29:35.566 A:middle
也会变得更加易读

00:29:36.416 --> 00:29:38.246 A:middle
就拓展我们的测试套件的角度说

00:29:38.246 --> 00:29:39.866 A:middle
使用更短的代码行

00:29:39.966 --> 00:29:42.356 A:middle
更短的测试代码行

00:29:42.356 --> 00:29:43.476 A:middle
及细心命名的辅助方法

00:29:43.476 --> 00:29:44.996 A:middle
可以在需要的时候

00:29:45.146 --> 00:29:46.576 A:middle
更快速更简便地

00:29:46.576 --> 00:29:51.046 A:middle
施行新的测试

00:29:51.236 --> 00:29:52.346 A:middle
这就是如何抽象出 UI element queries

00:29:52.346 --> 00:29:53.396 A:middle
这一部分的内容

00:29:54.166 --> 00:29:55.286 A:middle
现在我们继续下一个话题

00:29:55.286 --> 00:29:56.646 A:middle
在utility functions 中创建 objects

00:29:56.996 --> 00:29:59.946 A:middle
我手头在做一款游戏

00:29:59.946 --> 00:30:01.916 A:middle
对于每一个测试

00:29:59.946 --> 00:30:01.916 A:middle
对于每一个测试

00:30:01.916 --> 00:30:02.976 A:middle
我都想要变更一些设置

00:30:04.326 --> 00:30:06.506 A:middle
我们现在看到的这个例子

00:30:06.506 --> 00:30:07.176 A:middle
就不是一个很好的具有扩展性的代码

00:30:08.166 --> 00:30:09.296 A:middle
因为我最近

00:30:09.296 --> 00:30:10.376 A:middle
一直都在和这个 app 打交道

00:30:10.376 --> 00:30:11.686 A:middle
我自然很熟悉

00:30:11.686 --> 00:30:12.076 A:middle
这个代码的里里外外

00:30:13.006 --> 00:30:14.296 A:middle
我清楚的知道

00:30:14.296 --> 00:30:14.746 A:middle
所有正在发生的事情

00:30:15.746 --> 00:30:17.866 A:middle
但是 如果在一段时间后

00:30:17.866 --> 00:30:19.106 A:middle
比如几个星期后

00:30:19.106 --> 00:30:21.546 A:middle
我再回头来看这个代码

00:30:21.546 --> 00:30:23.126 A:middle
或者另一个不熟悉我的代码的人

00:30:23.126 --> 00:30:24.796 A:middle
不得不坐下来读我写的这些代码的话

00:30:25.026 --> 00:30:26.406 A:middle
这些代码

00:30:26.486 --> 00:30:27.000 A:middle
就不一定能被很简单地读懂了

00:30:28.336 --> 00:30:30.146 A:middle
首先我需要看出

00:30:30.376 --> 00:30:32.886 A:middle
我有一个 Settings 页面

00:30:32.886 --> 00:30:35.156 A:middle
我需要能够进入并离开这个页面

00:30:35.156 --> 00:30:36.636 A:middle
然后我需要看出

00:30:36.636 --> 00:30:38.446 A:middle
在这两行之间

00:30:38.446 --> 00:30:39.796 A:middle
我有一个 difficulty 页

00:30:40.066 --> 00:30:42.796 A:middle
设置 difficulty

00:30:42.796 --> 00:30:43.666 A:middle
然后还有 sound 页

00:30:43.666 --> 00:30:44.726 A:middle
设置 sound

00:30:45.946 --> 00:30:47.176 A:middle
时间一旦过长

00:30:47.176 --> 00:30:49.066 A:middle
我就可能会忘掉

00:30:49.066 --> 00:30:50.486 A:middle
自己为什么会在底部

00:30:50.486 --> 00:30:50.876 A:middle
有两个 back tabs

00:30:50.876 --> 00:30:53.326 A:middle
我必须使用测试

00:30:53.366 --> 00:30:54.616 A:middle
来看看这个

00:30:54.616 --> 00:30:55.026 A:middle
代码到底会如何运行

00:30:56.666 --> 00:30:58.366 A:middle
如果因为实际 UI

00:30:58.366 --> 00:30:59.376 A:middle
发生的变更

00:30:59.376 --> 00:31:01.146 A:middle
而导致测试不成功

00:30:59.376 --> 00:31:01.146 A:middle
而导致测试不成功

00:31:01.146 --> 00:31:02.626 A:middle
我就无法进行测试

00:31:02.626 --> 00:31:03.686 A:middle
也就无法看到我想要的结果

00:31:04.506 --> 00:31:05.876 A:middle
这样 我基本上对当初

00:31:05.876 --> 00:31:07.316 A:middle
为什么这样写这些代码这个问题无能为力了

00:31:08.516 --> 00:31:09.926 A:middle
为了解决这个问题

00:31:09.926 --> 00:31:11.306 A:middle
我们试一试将一些 logic 抽象到

00:31:11.306 --> 00:31:12.226 A:middle
辅助方法里面

00:31:12.916 --> 00:31:16.666 A:middle
我们可以创建一个 method

00:31:16.696 --> 00:31:17.396 A:middle
来设置 difficulty

00:31:17.396 --> 00:31:19.676 A:middle
同样的

00:31:19.676 --> 00:31:20.586 A:middle
我们也可以创建一个 method

00:31:20.676 --> 00:31:21.066 A:middle
来设置 sound
 
00:31:21.636 --> 00:31:23.056 A:middle
不过 我们能够做的更好吗

00:31:24.046 --> 00:31:26.856 A:middle
当然了

00:31:26.856 --> 00:31:27.946 A:middle
我们可以不传入 stream typed arguments

00:31:28.006 --> 00:31:29.826 A:middle
转而使用 enums

00:31:30.996 --> 00:31:32.406 A:middle
这样 Xcode 就能够

00:31:32.406 --> 00:31:34.036 A:middle
帮助我们在进行编译前确认

00:31:34.036 --> 00:31:35.876 A:middle
正在传入的 arguments

00:31:35.876 --> 00:31:36.916 A:middle
是否是有效的

00:31:40.276 --> 00:31:41.456 A:middle
现在看一下我们先前的代码

00:31:41.456 --> 00:31:43.056 A:middle
如果我们用新的辅助方法

00:31:43.056 --> 00:31:44.126 A:middle
代替一些代码

00:31:44.126 --> 00:31:47.386 A:middle
我们就能够减少

00:31:47.386 --> 00:31:47.826 A:middle
原来写的一些东西

00:31:47.826 --> 00:31:48.966 A:middle
这样已经看起来

00:31:48.966 --> 00:31:49.796 A:middle
好多了

00:31:49.796 --> 00:31:53.116 A:middle
那我们可以对最初的跳入跳出的

00:31:53.116 --> 00:31:54.386 A:middle
Settings 页面做些什么呢

00:31:55.016 --> 00:31:56.726 A:middle
我们能够对它进行改善吗

00:31:57.086 --> 00:31:57.866 A:middle
我觉得是可以的

00:31:58.836 --> 00:32:00.556 A:middle
让我们创建一个 GameApp 类

00:31:58.836 --> 00:32:00.556 A:middle
让我们创建一个 GameApp 类

00:32:00.556 --> 00:32:03.566 A:middle
在这个类中

00:32:03.566 --> 00:32:05.276 A:middle
我会加入之前为设定 difficulty 和sound

00:32:05.276 --> 00:32:07.786 A:middle
界定好的 enums

00:32:07.826 --> 00:32:09.066 A:middle
我也会加入

00:32:09.066 --> 00:32:10.826 A:middle
之前用来配置那些设置的

00:32:10.826 --> 00:32:12.000 A:middle
辅助方法

00:32:13.396 --> 00:32:14.516 A:middle
我们创建另一个 method

00:32:14.516 --> 00:32:16.286 A:middle
叫做 configureSettings

00:32:16.286 --> 00:32:17.326 A:middle
它将之前的两个设置作为 inputs

00:32:17.326 --> 00:32:20.496 A:middle
然后我们将之前的

00:32:20.546 --> 00:32:22.336 A:middle
setup logic 移植进

00:32:22.336 --> 00:32:23.206 A:middle
configure method 里面

00:32:23.716 --> 00:32:26.966 A:middle
回到我们先前的位置

00:32:27.206 --> 00:32:28.286 A:middle
因为我们已经创建了

00:32:28.286 --> 00:32:30.276 A:middle
这 个GameApp 类

00:32:30.276 --> 00:32:32.266 A:middle
我们就可以拿走原来所写的全部代码了

00:32:32.266 --> 00:32:33.866 A:middle
然后只需要用一个调用即可

00:32:33.866 --> 00:32:34.626 A:middle
也就是 configure method

00:32:35.476 --> 00:32:36.956 A:middle
相较于之前的版本

00:32:36.956 --> 00:32:38.286 A:middle
这个对于我来说可读性要大多了

00:32:39.276 --> 00:32:41.416 A:middle
现在 如果我需要写更多的测试

00:32:41.416 --> 00:32:42.856 A:middle
来配置设置

00:32:43.206 --> 00:32:44.156 A:middle
我只需要调用

00:32:44.156 --> 00:32:44.660 A:middle
configure method 就可以了

00:32:46.166 --> 00:32:48.276 A:middle
如果我需要

00:32:48.276 --> 00:32:49.386 A:middle
或者决定在 app 中

00:32:49.386 --> 00:32:50.836 A:middle
加入更多的设置

00:32:50.836 --> 00:32:51.826 A:middle
我只需要更新我们的

00:32:51.826 --> 00:32:53.026 A:middle
configure settings method

00:32:53.026 --> 00:32:53.946 A:middle
就能够处理这些新添加的

00:32:53.946 --> 00:32:54.306 A:middle
设置了

00:32:54.996 --> 00:32:58.856 A:middle
从这个例子我们可以看出

00:32:58.856 --> 00:33:00.516 A:middle
要扩展你的测试

00:32:58.856 --> 00:33:00.516 A:middle
要扩展你的测试

00:33:00.516 --> 00:33:02.096 A:middle
最重要的一点就是

00:33:02.096 --> 00:33:03.926 A:middle
创建你能够随后放入

00:33:04.056 --> 00:33:05.726 A:middle
library suite

00:33:05.726 --> 00:33:06.006 A:middle
的 abstraction

00:33:06.606 --> 00:33:07.796 A:middle
这样做

00:33:07.796 --> 00:33:09.476 A:middle
我们其实是在封装通用工作流程

00:33:09.806 --> 00:33:10.986 A:middle
以将其适用在

00:33:10.986 --> 00:33:12.266 A:middle
多个测试上

00:33:13.816 --> 00:33:15.296 A:middle
这也意味着

00:33:15.296 --> 00:33:16.676 A:middle
我们能够将测试代码

00:33:16.746 --> 00:33:17.716 A:middle
分享到不同的平台上

00:33:18.256 --> 00:33:22.306 A:middle
当然了 分享代码

00:33:22.306 --> 00:33:23.906 A:middle
能够便于我们的维护

00:33:24.926 --> 00:33:26.006 A:middle
如果出现了和抽象出的工作流程

00:33:26.006 --> 00:33:27.876 A:middle
相关的改动

00:33:27.876 --> 00:33:29.146 A:middle
我们只需要在一个地方更新代码即可

00:33:29.146 --> 00:33:32.076 A:middle
而不需要在

00:33:34.756 --> 00:33:35.196 A:middle
多处都进行操作

00:33:35.246 --> 00:33:36.176 A:middle
我想要提一下另外一个改进

00:33:36.176 --> 00:33:37.646 A:middle
在我们的 configure method 中

00:33:37.646 --> 00:33:39.756 A:middle
因为今年 Xcode 进行了改进

00:33:39.916 --> 00:33:42.566 A:middle
我们可以

00:33:42.566 --> 00:33:45.036 A:middle
在自己的代码中加入一个

00:33:45.666 --> 00:33:46.706 A:middle
XCTContent.runActivity

00:33:46.906 --> 00:33:48.086 A:middle
当我们运行测试时

00:33:48.086 --> 00:33:49.636 A:middle
我们可以用 runActivity 来

00:33:49.636 --> 00:33:51.006 A:middle
嵌套我们的 logging

00:33:51.006 --> 00:33:52.426 A:middle
而不是得到一个

00:33:52.426 --> 00:33:55.056 A:middle
包含所有顶层行为

00:33:55.056 --> 00:33:56.076 A:middle
的 log

00:33:56.626 --> 00:33:59.406 A:middle
这个能够帮助我们整理 logging

00:33:59.406 --> 00:34:01.686 A:middle
可以让内容

00:33:59.406 --> 00:34:01.686 A:middle
可以让内容

00:34:02.556 --> 00:34:02.726 A:middle
看起来更加整洁一些

00:34:02.856 --> 00:34:03.986 A:middle
有关测试 activity 特性的

00:34:03.986 --> 00:34:05.926 A:middle
更多信息

00:34:05.926 --> 00:34:07.516 A:middle
请查看我们先前的演讲

00:34:07.516 --> 00:34:11.005 A:middle
What’s New in Testing

00:34:11.545 --> 00:34:13.116 A:middle
好的 现在我们继续下一个话题

00:34:13.116 --> 00:34:14.996 A:middle
如何对 macOS UI 测试

00:34:14.996 --> 00:34:15.330 A:middle
使用快捷键

00:34:17.886 --> 00:34:19.166 A:middle
比如说我这里有一个 app

00:34:19.166 --> 00:34:20.606 A:middle
用户能够为他们的 text

00:34:20.606 --> 00:34:21.876 A:middle
挑选颜色

00:34:21.876 --> 00:34:23.275 A:middle
使用的是标准 macOS color picker

00:34:23.886 --> 00:34:25.335 A:middle
我现在要写一个测试

00:34:25.335 --> 00:34:26.646 A:middle
来验证颜色都设置正确了

00:34:27.196 --> 00:34:30.186 A:middle
最典型的方式是在 app 中

00:34:30.186 --> 00:34:32.056 A:middle
通过打开 Format menu

00:34:32.056 --> 00:34:34.056 A:middle
然后导航到 Font sub-menu

00:34:34.056 --> 00:34:35.716 A:middle
最后选择

00:34:36.085 --> 00:34:37.315 A:middle
Show Colors

00:34:37.315 --> 00:34:37.926 A:middle
来打开 color picker

00:34:37.985 --> 00:34:40.795 A:middle
我可以在 UI 测试中这样写

00:34:40.795 --> 00:34:41.500 A:middle
就像这样

00:34:43.976 --> 00:34:45.616 A:middle
但是有一种更快捷的方式

00:34:45.616 --> 00:34:47.016 A:middle
这个方式也能在我的测试[听不清]增多时

00:34:47.016 --> 00:34:47.846 A:middle
更好地扩展

00:34:49.166 --> 00:34:50.815 A:middle
注意这个 Show Colors menu 条目

00:34:50.815 --> 00:34:52.576 A:middle
有一个与其相关联的

00:34:52.576 --> 00:34:53.235 A:middle
键盘快捷方式了吧

00:34:53.846 --> 00:34:57.456 A:middle
与其使用多行代码

00:34:57.456 --> 00:34:58.516 A:middle
来启用 color picker

00:34:58.516 --> 00:35:01.166 A:middle
我们实际可以借助这个快捷键

00:34:58.516 --> 00:35:01.166 A:middle
我们实际可以借助这个快捷键

00:35:01.166 --> 00:35:02.666 A:middle
只用一行代码就达到目的

00:35:03.236 --> 00:35:06.436 A:middle
出于可读性的考虑

00:35:06.616 --> 00:35:07.806 A:middle
我也可能会使用一个 wrapper

00:35:07.806 --> 00:35:08.576 A:middle
来帮我调用

00:35:09.646 --> 00:35:11.266 A:middle
这样 在我的测试中

00:35:11.266 --> 00:35:13.056 A:middle
不仅能够减少需要维护的代码数量

00:35:13.056 --> 00:35:14.306 A:middle
而且实际运行的代码也变少了

00:35:14.306 --> 00:35:15.846 A:middle
那些和我想要进行的测试

00:35:15.846 --> 00:35:17.016 A:middle
并不直接相关的代码

00:35:17.046 --> 00:35:18.000 A:middle
都被削减掉了

00:35:20.576 --> 00:35:22.326 A:middle
在之前测试 method 例子中

00:35:22.326 --> 00:35:23.446 A:middle
我需要通过 menu

00:35:23.446 --> 00:35:25.006 A:middle
来最后显示出

00:35:25.006 --> 00:35:25.316 A:middle
color picker

00:35:25.826 --> 00:35:29.136 A:middle
用这个新的 wrapper method

00:35:29.136 --> 00:35:30.406 A:middle
我们就去掉了这些多余的代码行

00:35:30.406 --> 00:35:31.856 A:middle
将它精简到了一个 method

00:35:32.586 --> 00:35:33.906 A:middle
这样不仅使我的测试

00:35:34.036 --> 00:35:35.426 A:middle
运行得更快

00:35:35.426 --> 00:35:36.876 A:middle
而且也提高了我的代码的可读性

00:35:39.206 --> 00:35:40.886 A:middle
我们刚才已经看到了

00:35:40.886 --> 00:35:42.066 A:middle
如果你正在为一个 macOS 应用

00:35:42.066 --> 00:35:44.076 A:middle
写 UI 测试

00:35:44.076 --> 00:35:45.416 A:middle
你可以直接提供一个键盘快捷键

00:35:45.416 --> 00:35:46.416 A:middle
而不再需要通过 menu bar 来实现

00:35:47.056 --> 00:35:49.016 A:middle
我还需要

00:35:49.016 --> 00:35:50.736 A:middle
至少一个测试

00:35:50.736 --> 00:35:52.046 A:middle
来保证通过 menu bar 启用的 color picker

00:35:52.046 --> 00:35:53.686 A:middle
能够正常运行

00:35:54.076 --> 00:35:56.246 A:middle
但是这不需要

00:35:56.246 --> 00:35:57.826 A:middle
在每次包含 color picker

00:35:57.826 --> 00:35:58.786 A:middle
的测试上

00:35:58.786 --> 00:35:59.126 A:middle
都重复运行

00:36:02.916 --> 00:36:04.956 A:middle
使用键盘快捷方式

00:36:04.956 --> 00:36:06.876 A:middle
我们可以通过

00:36:06.876 --> 00:36:09.196 A:middle
跳过一些 UI 中的步骤

00:36:09.196 --> 00:36:10.496 A:middle
来使得测试代码

00:36:10.496 --> 00:36:12.856 A:middle
变得更加紧凑

00:36:12.856 --> 00:36:14.206 A:middle
有时可以将多行代码缩减到一行

00:36:14.546 --> 00:36:15.746 A:middle
这样也有助于提高代码可读性

00:36:18.636 --> 00:36:20.346 A:middle
最后 我想要对各位强调一点

00:36:20.346 --> 00:36:21.966 A:middle
想要写出好的测试

00:36:22.096 --> 00:36:23.496 A:middle
其实就是要写出好的代码

00:36:24.126 --> 00:36:25.886 A:middle
大家很容易把测试

00:36:25.886 --> 00:36:26.436 A:middle
看成是马后炮 有些无关紧要

00:36:27.446 --> 00:36:29.366 A:middle
一般情况下

00:36:29.366 --> 00:36:30.466 A:middle
我们都十分看重 app 的制作 想将其做到最好

00:36:30.466 --> 00:36:32.346 A:middle
将所有的时间都投入到

00:36:32.346 --> 00:36:33.506 A:middle
写出优美的

00:36:33.506 --> 00:36:35.216 A:middle
符合好的设计准则的

00:36:35.216 --> 00:36:36.696 A:middle
app 代码中去

00:36:36.966 --> 00:36:38.246 A:middle
对于编写测试代码

00:36:38.496 --> 00:36:40.336 A:middle
我们也需要

00:36:40.396 --> 00:36:40.686 A:middle
提高一点标准

00:36:40.686 --> 00:36:41.746 A:middle
有可能你在最后一刻

00:36:41.746 --> 00:36:43.196 A:middle
才匆忙挤出时间来写测试代码

00:36:43.196 --> 00:36:44.546 A:middle
只是为了完成一项任务

00:36:44.606 --> 00:36:46.896 A:middle
但是我们不应该

00:36:47.186 --> 00:36:47.330 A:middle
让这样的情况出现

00:36:48.926 --> 00:36:50.476 A:middle
如果不注意

00:36:50.476 --> 00:36:52.326 A:middle
测试代码的细节

00:36:52.326 --> 00:36:53.896 A:middle
它就无法像我们的 app 代码一样

00:36:53.896 --> 00:36:54.000 A:middle
扩展下去

00:36:56.416 --> 00:36:58.546 A:middle
最后

00:36:58.546 --> 00:37:00.266 A:middle
测试代码虽然不是 shipping

00:36:58.546 --> 00:37:00.266 A:middle
测试代码虽然不是 shipping

00:37:00.266 --> 00:37:00.736 A:middle
但仍然至关重要

00:37:02.156 --> 00:37:03.496 A:middle
也请注意

00:37:03.496 --> 00:37:04.936 A:middle
测试套件理应能够帮助你的 app

00:37:04.936 --> 00:37:06.686 A:middle
不断改进 而不是阻碍改变

00:37:07.156 --> 00:37:08.396 A:middle
如果测试代码质量不高

00:37:08.396 --> 00:37:10.006 A:middle
每次你要对 app 做改动时

00:37:10.006 --> 00:37:11.056 A:middle
都需要更新测试

00:37:11.056 --> 00:37:12.276 A:middle
它就变成了你的负担

00:37:13.156 --> 00:37:14.626 A:middle
要有意识地

00:37:14.626 --> 00:37:16.416 A:middle
提高测试代码的质量

00:37:16.816 --> 00:37:18.736 A:middle
这样我们扩展的能力

00:37:18.736 --> 00:37:19.856 A:middle
就不会因为设计不良的测试

00:37:19.856 --> 00:37:20.106 A:middle
而受到阻碍

00:37:20.836 --> 00:37:24.156 A:middle
当然了

00:37:24.156 --> 00:37:26.056 A:middle
编写 app 代码的原则

00:37:26.056 --> 00:37:27.086 A:middle
也同样适用于编写测试代码

00:37:27.686 --> 00:37:28.826 A:middle
测试代码和 app 代码

00:37:28.826 --> 00:37:29.536 A:middle
应该被平等看待

00:37:30.106 --> 00:37:33.246 A:middle
这里我可以给大家出个主意

00:37:33.286 --> 00:37:34.706 A:middle
我们需要对测试代码

00:37:34.706 --> 00:37:36.646 A:middle
进行代码审查

00:37:36.886 --> 00:37:37.986 A:middle
而不仅仅是将测试代码用于代码审查

00:37:38.596 --> 00:37:39.446 A:middle
要给测试代码

00:37:39.446 --> 00:37:40.976 A:middle
进行单独的代码审查

00:37:40.976 --> 00:37:42.006 A:middle
保证是由别人来检查

00:37:42.006 --> 00:37:42.656 A:middle
你的工作

00:37:44.946 --> 00:37:46.256 A:middle
这也是改进测试本身

00:37:46.256 --> 00:37:47.566 A:middle
的一个机会

00:37:47.566 --> 00:37:51.506 A:middle
好的 现在我给大家留下

00:37:51.506 --> 00:37:51.726 A:middle
一个思路

00:37:52.316 --> 00:37:54.016 A:middle
app 代码以及

00:37:54.016 --> 00:37:55.516 A:middle
验证它的测试

00:37:55.516 --> 00:37:56.016 A:middle
其实是不可分割的两部分

00:37:56.726 --> 00:37:57.896 A:middle
当你更新 app 代码时

00:37:57.966 --> 00:37:58.976 A:middle
你也需要

00:37:59.196 --> 00:37:59.716 A:middle
更新测试代码

00:37:59.716 --> 00:38:04.026 A:middle
我们需要将 app 代码

00:37:59.716 --> 00:38:04.026 A:middle
我们需要将 app 代码

00:38:04.026 --> 00:38:05.966 A:middle
和测试代码视为同一件事的两部分

00:38:05.966 --> 00:38:07.526 A:middle
这个事情就是我们的代码

00:38:08.476 --> 00:38:09.366 A:middle
将我们的代码变得更

00:38:09.366 --> 00:38:10.956 A:middle
具有可测试性 正如 Brian 先前和大家讨论的

00:38:10.956 --> 00:38:12.546 A:middle
用对待 app 代码同样认真的态度

00:38:12.546 --> 00:38:13.816 A:middle
对待测试代码

00:38:13.816 --> 00:38:15.286 A:middle
你就能够提升

00:38:15.286 --> 00:38:16.306 A:middle
整个 app 的质量了

00:38:17.196 --> 00:38:18.236 A:middle
我们理应对

00:38:18.236 --> 00:38:20.166 A:middle
两部分都感到自豪

00:38:20.166 --> 00:38:21.496 A:middle
并给予它们应得的

00:38:21.496 --> 00:38:21.926 A:middle
关注

00:38:25.826 --> 00:38:26.996 A:middle
有关这次讲座

00:38:26.996 --> 00:38:27.976 A:middle
更多的信息和资源

00:38:27.976 --> 00:38:29.286 A:middle
大家可以通过屏幕上的链接

00:38:29.316 --> 00:38:30.226 A:middle
获得

00:38:30.226 --> 00:38:33.296 A:middle
这里有几个相关的讲座

00:38:33.356 --> 00:38:34.596 A:middle
有一个是昨天的

00:38:34.596 --> 00:38:35.826 A:middle
还有一些是前几年

00:38:35.826 --> 00:38:36.196 A:middle
的讲座

00:38:36.226 --> 00:38:37.616 A:middle
大家可以上网查询

00:38:37.706 --> 00:38:40.156 A:middle
或者通过 WWDC app 查看

00:38:40.446 --> 00:38:41.476 A:middle
好了 谢谢大家的

00:38:41.476 --> 00:38:42.506 A:middle
认真聆听

00:38:42.506 --> 00:38:43.336 A:middle
我祝愿各位在剩下的时间里

00:38:43.336 --> 00:38:43.676 A:middle
与会愉快
