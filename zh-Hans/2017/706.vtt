WEBVTT

00:00:17.818 --> 00:00:21.255 align:middle line:0
<c.magenta>（现代化GCD用法</c>
<c.magenta>如何粘附在内核上）</c>

00:00:22.356 --> 00:00:23.524 align:middle line:-1
<c.magenta>早上好 欢迎参加</c>

00:00:23.590 --> 00:00:26.360 align:middle line:-1
<c.magenta>现代化中心调度GCD用法演讲</c>

00:00:26.426 --> 00:00:28.595 align:middle line:-2
<c.magenta>我是Daniel Chimene</c>
<c.magenta>来自Core Darwin团队</c>

00:00:28.862 --> 00:00:31.698 align:middle line:-1
<c.magenta>我和我的同事们今天要跟大家谈谈</c>

00:00:31.765 --> 00:00:34.234 align:middle line:-1
<c.magenta>如何利用中心调度</c>

00:00:34.468 --> 00:00:36.103 align:middle line:-1
<c.magenta>在你的应用中获得最佳性能</c>

00:00:37.471 --> 00:00:38.438 align:middle line:-1
<c.magenta>作为应用开发人员</c>

00:00:38.772 --> 00:00:40.974 align:middle line:-1
<c.magenta>你会花成百上千个小时</c>

00:00:41.041 --> 00:00:43.410 align:middle line:-1
<c.magenta>为你的用户打造出色体验</c>

00:00:43.477 --> 00:00:45.612 align:middle line:-1
<c.magenta>利用你强大的设备</c>

00:00:46.613 --> 00:00:49.349 align:middle line:-1
<c.magenta>你想让你的用户拥有出色的体验</c>

00:00:49.583 --> 00:00:50.684 align:middle line:-1
<c.magenta>不仅是在一台设备上</c>

00:00:51.218 --> 00:00:53.854 align:middle line:-1
<c.magenta>而是在Apple的各种设备上</c>

00:00:56.723 --> 00:01:00.394 align:middle line:-2
<c.magenta>GCD的目的是帮助你动态地</c>
<c.magenta>调整你应用的代码</c>

00:00:56.723 --> 00:01:00.394 align:middle line:-2
<c.magenta>GCD的目的是帮助你动态地</c>
<c.magenta>调整你应用的代码</c>

00:01:00.460 --> 00:01:03.697 align:middle line:-2
<c.magenta>从单核的Apple Watch</c>
<c.magenta>一直到迷你核的Mac</c>

00:01:04.431 --> 00:01:06.033 align:middle line:-1
<c.magenta>你不必太过担心</c>

00:01:06.099 --> 00:01:08.569 align:middle line:-1
<c.magenta>你的用户运行的是哪种硬件</c>

00:01:09.036 --> 00:01:10.737 align:middle line:-1
<c.magenta>但会出现不确定的模式</c>

00:01:10.804 --> 00:01:14.241 align:middle line:-1
<c.magenta>可能会影响你代码的可扩展性和效率</c>

00:01:14.308 --> 00:01:16.310 align:middle line:-1
<c.magenta>无论是高端还是低端都一样</c>

00:01:17.177 --> 00:01:18.879 align:middle line:-1
<c.magenta>这也是我们今天要谈的内容</c>

00:01:19.313 --> 00:01:20.647 align:middle line:-1
<c.magenta>我们要帮助你确保</c>

00:01:20.714 --> 00:01:22.649 align:middle line:-1
<c.magenta>你放到应用中的代码</c>

00:01:22.716 --> 00:01:24.818 align:middle line:-1
<c.magenta>会给用户打造一种出色的体验</c>

00:01:25.485 --> 00:01:27.387 align:middle line:-1
<c.magenta>可以在各种设备间进行转换</c>

00:01:28.989 --> 00:01:32.392 align:middle line:-2
<c.magenta>你可能用过GCD API</c>
<c.magenta>比如异步调度</c>

00:01:32.926 --> 00:01:35.696 align:middle line:-2
<c.magenta>还有其它创建提示</c>
<c.magenta>以及给系统调度工作的API</c>

00:01:36.230 --> 00:01:39.433 align:middle line:-1
<c.magenta>这些只是并发性技术的一些接口</c>

00:01:39.499 --> 00:01:41.235 align:middle line:-1
<c.magenta>我们叫作中心调度GCD</c>

00:01:41.668 --> 00:01:44.805 align:middle line:-1
<c.magenta>今天我们要看看GCD底层的东西</c>

00:01:45.405 --> 00:01:48.041 align:middle line:-1
<c.magenta>这是一场充斥着各种信息的高级演讲</c>

00:01:48.342 --> 00:01:51.245 align:middle line:-2
<c.magenta>那么让我们立即开始吧</c>
<c.magenta>先看一下我们的硬件</c>

00:01:52.012 --> 00:01:53.680 align:middle line:-1
<c.magenta>我们的设备中出色的芯片</c>

00:01:53.747 --> 00:01:55.983 align:middle line:-1
<c.magenta>随着时间的推移速度变得越来越快</c>

00:01:56.250 --> 00:01:57.384 align:middle line:-1
<c.magenta>然而 速度快</c>

00:01:57.451 --> 00:02:00.220 align:middle line:-1
<c.magenta>并不只是因为芯片自身变快了</c>

00:01:57.451 --> 00:02:00.220 align:middle line:-1
<c.magenta>并不只是因为芯片自身变快了</c>

00:02:00.287 --> 00:02:03.090 align:middle line:-2
<c.magenta>还因为它们在运行你的代码方面</c>
<c.magenta>变得越来越智能了</c>

00:02:03.156 --> 00:02:04.224 align:middle line:-1
<c.magenta>并且它们</c>

00:02:04.291 --> 00:02:07.160 align:middle line:-2
<c.magenta>随着时间的过去也在学习你代码的作用</c>
<c.magenta>以便更有效地运作</c>

00:02:10.430 --> 00:02:14.067 align:middle line:-2
<c.magenta>然而如果你的代码远离了内核</c>
<c.magenta>因为它完成了它的任务</c>

00:02:14.701 --> 00:02:16.570 align:middle line:0
<c.magenta>那么它将不再利用</c>

00:02:16.637 --> 00:02:18.906 align:middle line:0
<c.magenta>那个内核所创建的历史</c>

00:02:18.972 --> 00:02:22.509 align:middle line:-2
<c.magenta>你可能会把性能丢开</c>
<c.magenta>当你返回到内核上时</c>

00:02:23.243 --> 00:02:25.712 align:middle line:-2
<c.magenta>我们在我们自己的框架中</c>
<c.magenta>看到过这样的例子</c>

00:02:25.779 --> 00:02:27.681 align:middle line:-1
<c.magenta>当我们应用一些优化技巧时</c>

00:02:27.748 --> 00:02:29.550 align:middle line:-1
<c.magenta>我们今天也要讨论这些优化技巧</c>

00:02:29.616 --> 00:02:34.655 align:middle line:-2
<c.magenta>我们看到简单的变更就会很大程度上</c>
<c.magenta>加快速度 从而避免这些不确定的模式</c>

00:02:34.721 --> 00:02:36.790 align:middle line:-2
<c.magenta>（速度快了1.3倍</c>
<c.magenta>结合队列等级）</c>

00:02:36.857 --> 00:02:38.525 align:middle line:-1
<c.magenta>那么通过这些技巧</c>

00:02:38.592 --> 00:02:41.962 align:middle line:-2
<c.magenta>你可以用更少量的工作</c>
<c.magenta>给更多的用户带来高性能应用</c>

00:02:42.663 --> 00:02:44.932 align:middle line:-1
<c.magenta>今天我们要深入研究</c>

00:02:44.998 --> 00:02:48.068 align:middle line:-1
<c.magenta>我们系统底层是如何运作你的代码的</c>

00:02:48.135 --> 00:02:50.470 align:middle line:-1
<c.magenta>那么你可以调整你的代码以最好地利用</c>

00:02:50.537 --> 00:02:51.905 align:middle line:-1
<c.magenta>GCD所提供的功能</c>

00:02:52.639 --> 00:02:54.308 align:middle line:-1
<c.magenta>我们今天要讨论一些东西</c>

00:02:55.075 --> 00:02:57.611 align:middle line:-1
<c.magenta>首先我们要讨论如何最好地表达</c>

00:02:57.945 --> 00:02:59.379 align:middle line:-1
<c.magenta>并行和并发</c>

00:03:00.013 --> 00:03:02.049 align:middle line:-1
<c.magenta>如何选择最佳方式</c>

00:03:02.115 --> 00:03:04.651 align:middle line:-1
<c.magenta>向GCD表达并发</c>

00:03:05.519 --> 00:03:07.721 align:middle line:-1
<c.magenta>我们要介绍一下统一队列身份</c>

00:03:07.788 --> 00:03:09.823 align:middle line:-1
<c.magenta>这是GCD底层的一个重要改进</c>

00:03:09.890 --> 00:03:11.592 align:middle line:-1
<c.magenta>是我们今年发布的</c>

00:03:11.658 --> 00:03:14.061 align:middle line:-2
<c.magenta>我们最后要给你们演示</c>
<c.magenta>如何发现代码中的问题点</c>

00:03:14.127 --> 00:03:15.662 align:middle line:-1
<c.magenta>通过仪表</c>

00:03:16.630 --> 00:03:19.433 align:middle line:-1
<c.magenta>那么让我们先讨论并行和并发</c>

00:03:20.400 --> 00:03:21.268 align:middle line:-1
<c.magenta>那么…</c>

00:03:23.637 --> 00:03:25.138 align:middle line:-1
<c.magenta>为了演讲的目的</c>

00:03:25.205 --> 00:03:28.675 align:middle line:-2
<c.magenta>我们要谈谈平行</c>
<c.magenta>就是关于你的代码如何</c>

00:03:29.309 --> 00:03:32.346 align:middle line:-1
<c.magenta>同时在多个不同的内核上并行执行</c>

00:03:32.713 --> 00:03:35.048 align:middle line:-1
<c.magenta>并发是关于你如何构造</c>

00:03:35.115 --> 00:03:38.352 align:middle line:-1
<c.magenta>你应用的独立组件使其同时运行</c>

00:03:39.119 --> 00:03:41.121 align:middle line:-1
<c.magenta>那么区分这两个概念有一个简单的方式</c>

00:03:41.188 --> 00:03:42.089 align:middle line:-1
<c.magenta>就是明白</c>

00:03:42.155 --> 00:03:44.758 align:middle line:-1
<c.magenta>并行通常需要多内核</c>

00:03:44.825 --> 00:03:46.560 align:middle line:-1
<c.magenta>你想同时使用全部的内核</c>

00:03:46.627 --> 00:03:49.463 align:middle line:-1
<c.magenta>而并发甚至可以在单核系统中实现</c>

00:03:49.530 --> 00:03:51.532 align:middle line:-1
<c.magenta>它是关于你如何介入</c>

00:03:51.865 --> 00:03:53.867 align:middle line:-1
<c.magenta>作为应用的一部分的不同任务</c>

00:03:53.934 --> 00:03:55.869 align:middle line:-1
<c.magenta>那么让我们从并行开始谈</c>

00:03:56.303 --> 00:03:58.839 align:middle line:-1
<c.magenta>以及当你在写应用时如何使用它</c>

00:03:59.673 --> 00:04:00.607 align:middle line:-1
<c.magenta>那么</c>

00:03:59.673 --> 00:04:00.607 align:middle line:-1
<c.magenta>那么</c>

00:04:00.941 --> 00:04:04.545 align:middle line:-2
<c.magenta>让我们想象一下你正在开发一款应用</c>
<c.magenta>而它会处理大量图片</c>

00:04:04.845 --> 00:04:07.881 align:middle line:-1
<c.magenta>你希望能利用Mac Pro上的多核</c>

00:04:07.948 --> 00:04:09.716 align:middle line:-1
<c.magenta>来更快地处理这些图片</c>

00:04:10.350 --> 00:04:12.719 align:middle line:-1
<c.magenta>于是你就把图片分别放到组块中</c>

00:04:13.520 --> 00:04:15.789 align:middle line:-1
<c.magenta>并且让每个内核</c>

00:04:17.558 --> 00:04:18.492 align:middle line:-1
<c.magenta>并行地处理这些组块</c>

00:04:19.392 --> 00:04:20.527 align:middle line:-1
<c.magenta>这就提升了你的速度</c>

00:04:20.594 --> 00:04:22.629 align:middle line:-1
<c.magenta>因为多核同时</c>

00:04:22.696 --> 00:04:24.331 align:middle line:-1
<c.magenta>处理图片的不同部分</c>

00:04:25.332 --> 00:04:27.534 align:middle line:-1
<c.magenta>那么你要如何实施呢？嗯 首先</c>

00:04:28.802 --> 00:04:30.237 align:middle line:-1
<c.magenta>你应该停下来思考</c>

00:04:30.437 --> 00:04:32.606 align:middle line:-1
<c.magenta>你是否可以利用我们系统框架</c>

00:04:33.407 --> 00:04:36.443 align:middle line:-1
<c.magenta>比如Accelerate框架有内嵌支持</c>

00:04:36.743 --> 00:04:39.313 align:middle line:-1
<c.magenta>可以支持高级图片算法的并行执行</c>

00:04:40.013 --> 00:04:44.218 align:middle line:-2
<c.magenta>Metal和Core图片</c>
<c.magenta>可以利用强大的GPU</c>

00:04:45.853 --> 00:04:48.722 align:middle line:-1
<c.magenta>嗯 假如说你已经决定自己实施</c>

00:04:48.789 --> 00:04:52.159 align:middle line:-2
<c.magenta>GCD会给你提供一个工具</c>
<c.magenta>可以让你轻松地表达这个模式</c>

00:04:52.960 --> 00:04:56.897 align:middle line:-2
<c.magenta>你向GCD表达并行的模式是使用一个</c>
<c.magenta>叫作concurrentPerform的API</c>

00:04:57.231 --> 00:04:59.733 align:middle line:-1
<c.magenta>它会让框架优化并行</c>

00:04:59.967 --> 00:05:01.101 align:middle line:-1
<c.magenta>因为它知道你正在尝试</c>

00:04:59.967 --> 00:05:01.101 align:middle line:-1
<c.magenta>因为它知道你正在尝试</c>

00:05:01.168 --> 00:05:03.637 align:middle line:-1
<c.magenta>利用所有内核实现并行计算</c>

00:05:04.571 --> 00:05:07.574 align:middle line:-1
<c.magenta>concurrentPerform是一个循环并行</c>

00:05:07.641 --> 00:05:10.644 align:middle line:-2
<c.magenta>会自动负载平衡系统中</c>
<c.magenta>所有内核的计算任务</c>

00:05:11.211 --> 00:05:14.481 align:middle line:-2
<c.magenta>Swift 当你与Swift一起用时</c>
<c.magenta>它会自动选择</c>

00:05:14.548 --> 00:05:17.050 align:middle line:-1
<c.magenta>运行你所有计算的正确情境</c>

00:05:17.117 --> 00:05:18.886 align:middle line:-1
<c.magenta>今年 我们把同样的功能</c>

00:05:18.952 --> 00:05:21.121 align:middle line:-1
<c.magenta>引入了Objective C的接口</c>

00:05:21.755 --> 00:05:23.557 align:middle line:0
<c.magenta>通过调度应用自动关键字来调度应用</c>

00:05:24.324 --> 00:05:25.826 align:middle line:0
<c.magenta>这替换了Q参数</c>

00:05:26.426 --> 00:05:28.028 align:middle line:0
<c.magenta>允许系统</c>

00:05:28.095 --> 00:05:30.397 align:middle line:0
<c.magenta>自动选择运行你代码的正确情境</c>

00:05:31.331 --> 00:05:33.367 align:middle line:0
<c.magenta>那么现在让我们看一下另一个参数</c>

00:05:33.433 --> 00:05:34.868 align:middle line:0
<c.magenta>即重复技术</c>

00:05:35.202 --> 00:05:38.505 align:middle line:0
<c.magenta>这是在系统中</c>
<c.magenta>并行调用你的代码块的次数</c>

00:05:39.339 --> 00:05:41.041 align:middle line:0
<c.magenta>在这里你要如何选择一个适当的值呢？</c>

00:05:41.775 --> 00:05:45.212 align:middle line:0
<c.magenta>你可能认为适当的值应该是内核的数量</c>

00:05:45.279 --> 00:05:46.146 align:middle line:0
<c.magenta>让我们想象一下</c>

00:05:47.047 --> 00:05:49.850 align:middle line:0
<c.magenta>我们正在一个三核系统中</c>
<c.magenta>执行我们的工作</c>

00:05:50.017 --> 00:05:51.685 align:middle line:0
<c.magenta>在这里你可以看到理想情况</c>

00:05:52.119 --> 00:05:54.388 align:middle line:0
<c.magenta>也就是三个代码块在全部</c>
<c.magenta>三个内核上并行运行</c>

00:05:55.022 --> 00:05:57.157 align:middle line:0
<c.magenta>但现实世界总是不会这么完美</c>

00:05:57.791 --> 00:05:59.393 align:middle line:0
<c.magenta>如果第三个内核</c>

00:05:59.459 --> 00:06:01.128 align:middle line:0
<c.magenta>被占用执行UI渲染会发生什么呢？</c>

00:05:59.459 --> 00:06:01.128 align:middle line:0
<c.magenta>被占用执行UI渲染会发生什么呢？</c>

00:06:03.297 --> 00:06:04.765 align:middle line:0
<c.magenta>嗯 情况就会变成这样</c>

00:06:04.831 --> 00:06:08.569 align:middle line:0
<c.magenta>负载平衡器必须得把那第三个代码块</c>
<c.magenta>挪到第一个内核上</c>

00:06:08.936 --> 00:06:11.438 align:middle line:0
<c.magenta>以便执行第三个代码块</c>
<c.magenta>因为第三个内核被占用了</c>

00:06:11.905 --> 00:06:13.874 align:middle line:0
<c.magenta>我们的CPU闲置</c>

00:06:13.941 --> 00:06:17.778 align:middle line:0
<c.magenta>我们可以利用这段时间</c>
<c.magenta>来执行更多的并行工作</c>

00:06:18.145 --> 00:06:20.080 align:middle line:0
<c.magenta>那么相反 我们的工作花的时间更长</c>

00:06:21.281 --> 00:06:22.482 align:middle line:0
<c.magenta>那么如何修复呢？</c>

00:06:22.549 --> 00:06:25.118 align:middle line:0
<c.magenta>嗯 我们可以增加重复计数</c>

00:06:26.486 --> 00:06:28.622 align:middle line:0
<c.magenta>并给负载平衡器提供更多的灵活性</c>

00:06:29.723 --> 00:06:31.325 align:middle line:0
<c.magenta>看起来不错 堵上那个窟窿了</c>

00:06:31.859 --> 00:06:35.662 align:middle line:0
<c.magenta>但其实这里还有一个窟窿</c>
<c.magenta>就是在第三个内核上</c>

00:06:36.196 --> 00:06:37.998 align:middle line:0
<c.magenta>我们也可以利用那段时间</c>

00:06:39.766 --> 00:06:44.004 align:middle line:0
<c.magenta>那么正如提姆在周一的演讲上所说的</c>
<c.magenta>让我们把重复次数增加 增加到11</c>

00:06:46.740 --> 00:06:50.110 align:middle line:-2
<c.magenta>然后我们就填上这个窟窿了</c>
<c.magenta>我们的执行也更有效率了</c>

00:06:50.410 --> 00:06:53.113 align:middle line:-2
<c.magenta>我们用了系统上全部可用的资源</c>
<c.magenta>直到我们完成</c>

00:06:53.614 --> 00:06:56.049 align:middle line:-1
<c.magenta>这是一个非常简单的例子</c>

00:06:56.717 --> 00:06:58.151 align:middle line:-1
<c.magenta>要处理实际的复杂性</c>

00:06:58.552 --> 00:07:00.521 align:middle line:-1
<c.magenta>你得使用更大的量级</c>

00:06:58.552 --> 00:07:00.521 align:middle line:-1
<c.magenta>你得使用更大的量级</c>

00:07:00.854 --> 00:07:02.022 align:middle line:-1
<c.magenta>比如1000</c>

00:07:03.123 --> 00:07:04.825 align:middle line:-1
<c.magenta>你可以使用足够大的重复计数</c>

00:07:05.092 --> 00:07:07.961 align:middle line:-2
<c.magenta>以便负载平衡器可以灵活地</c>
<c.magenta>填补系统中的空白</c>

00:07:08.028 --> 00:07:10.797 align:middle line:-1
<c.magenta>并最大限度地利用</c>

00:07:10.864 --> 00:07:12.366 align:middle line:-1
<c.magenta>系统中可用的资源</c>

00:07:13.100 --> 00:07:16.637 align:middle line:-2
<c.magenta>然而你应该确保平衡</c>
<c.magenta>负载平衡器的消耗</c>

00:07:16.703 --> 00:07:20.674 align:middle line:-2
<c.magenta>相对于并行循环中每个代码块</c>
<c.magenta>做执行的有效工作</c>

00:07:21.708 --> 00:07:24.311 align:middle line:-1
<c.magenta>请记住每个CPU并不总是全部可用</c>

00:07:24.478 --> 00:07:27.247 align:middle line:-1
<c.magenta>系统中同时还运行着许多任务</c>

00:07:28.248 --> 00:07:31.485 align:middle line:-2
<c.magenta>此外 并不是每个辅助线程</c>
<c.magenta>都能取得同等的进度</c>

00:07:32.452 --> 00:07:35.255 align:middle line:-1
<c.magenta>那么回顾一下 如果你有并行问题</c>

00:07:35.956 --> 00:07:38.559 align:middle line:-1
<c.magenta>确保利用一切可用的系统框架</c>

00:07:38.625 --> 00:07:40.994 align:middle line:-1
<c.magenta>你可以用它们的能力来解决你的问题</c>

00:07:42.062 --> 00:07:44.631 align:middle line:-1
<c.magenta>此外 确保利用自动负载平衡</c>

00:07:44.698 --> 00:07:46.300 align:middle line:-1
<c.magenta>位于concurrentPerform内</c>

00:07:46.366 --> 00:07:48.735 align:middle line:-1
<c.magenta>给它提供一定的灵活性以最好地利用它</c>

00:07:50.003 --> 00:07:51.638 align:middle line:-1
<c.magenta>那么这是关于并行的讨论</c>

00:07:51.939 --> 00:07:55.242 align:middle line:-1
<c.magenta>现在让我们回到主话题上 即并发</c>

00:07:56.610 --> 00:07:58.445 align:middle line:-1
<c.magenta>那么并发</c>

00:07:59.580 --> 00:08:01.782 align:middle line:-2
<c.magenta>让我们想象一下</c>
<c.magenta>你正在写一个简单的新闻应用</c>

00:07:59.580 --> 00:08:01.782 align:middle line:-2
<c.magenta>让我们想象一下</c>
<c.magenta>你正在写一个简单的新闻应用</c>

00:08:02.883 --> 00:08:05.853 align:middle line:-1
<c.magenta>你会如何构造它？嗯 你从把它拆解到</c>

00:08:05.919 --> 00:08:08.555 align:middle line:-1
<c.magenta>组成应用的独立子系统中开始</c>

00:08:09.223 --> 00:08:11.058 align:middle line:-1
<c.magenta>思考一下如何把新闻应用拆解</c>

00:08:11.358 --> 00:08:14.628 align:middle line:-2
<c.magenta>到其独立的子系统中</c>
<c.magenta>你可能有一个UI组件</c>

00:08:14.695 --> 00:08:16.630 align:middle line:-1
<c.magenta>是渲染UI的 这就是主线程</c>

00:08:16.697 --> 00:08:20.200 align:middle line:-1
<c.magenta>你可能有一个存储这些文章的数据库</c>

00:08:20.734 --> 00:08:22.369 align:middle line:-1
<c.magenta>且你可能还有一个联网的子系统</c>

00:08:22.436 --> 00:08:24.137 align:middle line:-1
<c.magenta>从网络上获取这些文章</c>

00:08:24.738 --> 00:08:26.406 align:middle line:-2
<c.magenta>为了给你一个更好的描述</c>
<c.magenta>关于这个应用是如何运作</c>

00:08:26.473 --> 00:08:28.842 align:middle line:-1
<c.magenta>以及如何拆解到子系统中</c>

00:08:29.243 --> 00:08:32.980 align:middle line:-2
<c.magenta>让我们在一个现代化系统上</c>
<c.magenta>形象化一下那是如何同时执行的</c>

00:08:33.413 --> 00:08:39.019 align:middle line:-2
<c.magenta>那么假如这个时间轴</c>
<c.magenta>在CPU轨道的顶部显示</c>

00:08:39.086 --> 00:08:40.988 align:middle line:-2
<c.magenta>让我们想象一下</c>
<c.magenta>我们只剩下了一个CPU</c>

00:08:41.054 --> 00:08:44.658 align:middle line:-2
<c.magenta>其它CPU都忙于其它任务</c>
<c.magenta>我们只有一个可用的内核</c>

00:08:44.925 --> 00:08:47.694 align:middle line:-2
<c.magenta>无论什么时候只能有一个线程</c>
<c.magenta>运行在那个CPU上</c>

00:08:48.529 --> 00:08:50.731 align:middle line:-1
<c.magenta>那么当用户在新闻应用中点击按钮</c>

00:08:51.031 --> 00:08:53.534 align:middle line:-1
<c.magenta>并刷新文章列表时会发生什么？</c>

00:08:54.134 --> 00:08:56.870 align:middle line:-1
<c.magenta>嗯 这些界面会渲染对那个按钮的响应</c>

00:08:56.937 --> 00:08:59.406 align:middle line:-1
<c.magenta>然后给数据库发送异步指令</c>

00:09:00.140 --> 00:09:02.910 align:middle line:-1
<c.magenta>然后数据库就决定它需要刷新文章</c>

00:09:02.976 --> 00:09:06.013 align:middle line:-1
<c.magenta>它会对联网子系统选择另一个命令</c>

00:09:06.880 --> 00:09:09.616 align:middle line:-1
<c.magenta>然而在这点上 用户再次触摸应用</c>

00:09:09.917 --> 00:09:13.854 align:middle line:-2
<c.magenta>因为数据库脱离应用的主线程</c>
<c.magenta>完成了执行</c>

00:09:14.288 --> 00:09:17.457 align:middle line:-1
<c.magenta>OS可以立即切换CPU处理UI线程</c>

00:09:17.791 --> 00:09:19.560 align:middle line:-1
<c.magenta>它可以立即响应用户</c>

00:09:19.626 --> 00:09:22.462 align:middle line:-1
<c.magenta>而无需等待数据库线程执行完成</c>

00:09:23.630 --> 00:09:26.400 align:middle line:-1
<c.magenta>这就是把工作从主线程上脱离的好处</c>

00:09:28.468 --> 00:09:30.537 align:middle line:-1
<c.magenta>当用户界面完成响应时</c>

00:09:30.971 --> 00:09:33.574 align:middle line:0
<c.magenta>CPU就可以切换回数据库线程</c>

00:09:33.740 --> 00:09:35.876 align:middle line:-1
<c.magenta>然后完成联网任务</c>

00:09:36.510 --> 00:09:38.745 align:middle line:-1
<c.magenta>像这样利用并发</c>

00:09:39.112 --> 00:09:40.948 align:middle line:-1
<c.magenta>可以让你创建响应性的应用</c>

00:09:41.215 --> 00:09:43.851 align:middle line:-1
<c.magenta>主线程总是响应用户的行动</c>

00:09:44.084 --> 00:09:47.487 align:middle line:-1
<c.magenta>而无需等待应用的其它部分完成</c>

00:09:48.155 --> 00:09:50.591 align:middle line:-2
<c.magenta>那么让我们看看对于CPU来说</c>
<c.magenta>是什么样的</c>

00:09:51.425 --> 00:09:52.826 align:middle line:-1
<c.magenta>上边的这些白线</c>

00:09:52.893 --> 00:09:55.195 align:middle line:-1
<c.magenta>显示的是子系统之间的内容切换</c>

00:09:55.963 --> 00:09:58.031 align:middle line:-1
<c.magenta>接触开关是当CPU</c>

00:09:58.098 --> 00:10:01.335 align:middle line:-2
<c.magenta>在不同的子系统之间</c>
<c.magenta>或组成你应用的线程之间进行切换时</c>

00:09:58.098 --> 00:10:01.335 align:middle line:-2
<c.magenta>在不同的子系统之间</c>
<c.magenta>或组成你应用的线程之间进行切换时</c>

00:10:01.902 --> 00:10:05.072 align:middle line:-1
<c.magenta>如果你想这在你的应用中是什么样的</c>

00:10:05.138 --> 00:10:06.940 align:middle line:-1
<c.magenta>你可以使用仪表系统进行追踪</c>

00:10:07.007 --> 00:10:09.643 align:middle line:-1
<c.magenta>可以给你显示CPU和线程正在做什么</c>

00:10:09.710 --> 00:10:11.178 align:middle line:-1
<c.magenta>当它们在你的应用中运行时</c>

00:10:11.678 --> 00:10:13.380 align:middle line:-1
<c.magenta>如果你想了解更多信息</c>

00:10:13.447 --> 00:10:15.616 align:middle line:-2
<c.magenta>你可以参看去年的</c>
<c.magenta>“深度解析系统追踪”演讲</c>

00:10:15.682 --> 00:10:18.385 align:middle line:-1
<c.magenta>仪表团队描述了你该如何使用系统追踪</c>

00:10:19.286 --> 00:10:23.557 align:middle line:-2
<c.magenta>那么这个情境切换的概念是</c>
<c.magenta>并发的能力来自哪里</c>

00:10:24.024 --> 00:10:26.660 align:middle line:-1
<c.magenta>让我们看看何时会发生这些情境切换</c>

00:10:26.727 --> 00:10:27.861 align:middle line:-1
<c.magenta>以及导致情境切换的原因</c>

00:10:28.362 --> 00:10:29.229 align:middle line:-1
<c.magenta>嗯</c>

00:10:29.596 --> 00:10:31.965 align:middle line:-1
<c.magenta>当高优先级线程需要CPU时会发生</c>

00:10:32.032 --> 00:10:33.100 align:middle line:-1
<c.magenta>正如我们之前看到过的</c>

00:10:33.166 --> 00:10:35.402 align:middle line:-1
<c.magenta>UI线程会先于数据库线程</c>

00:10:35.969 --> 00:10:38.805 align:middle line:-1
<c.magenta>当线程结束当前任务时</c>

00:10:39.306 --> 00:10:41.341 align:middle line:-1
<c.magenta>或等待取得资源时</c>

00:10:41.742 --> 00:10:44.178 align:middle line:-1
<c.magenta>或等待异步请求完成时也会发生</c>

00:10:44.845 --> 00:10:47.147 align:middle line:-1
<c.magenta>然而 通过并发的强大力量</c>

00:10:47.481 --> 00:10:49.550 align:middle line:-1
<c.magenta>也会伴随着强大的责任</c>

00:10:49.616 --> 00:10:51.585 align:middle line:-1
<c.magenta>你拥有太多好东西了</c>

00:10:52.886 --> 00:10:56.323 align:middle line:-2
<c.magenta>假如说你正在网络</c>
<c.magenta>和数据库线程之间切换</c>

00:10:56.890 --> 00:10:57.824 align:middle line:-1
<c.magenta>在你的CPU上</c>

00:10:58.392 --> 00:10:59.560 align:middle line:-1
<c.magenta>切换几个情境没问题</c>

00:10:59.626 --> 00:11:02.062 align:middle line:-2
<c.magenta>这就是并发的能力所在</c>
<c.magenta>你可以在不同的任务之前切换</c>

00:10:59.626 --> 00:11:02.062 align:middle line:-2
<c.magenta>这就是并发的能力所在</c>
<c.magenta>你可以在不同的任务之前切换</c>

00:11:02.629 --> 00:11:05.132 align:middle line:-1
<c.magenta>然而如果你要做上千次切换</c>

00:11:05.199 --> 00:11:08.202 align:middle line:-1
<c.magenta>连续迅速切换 你就有大麻烦啦</c>

00:11:08.268 --> 00:11:09.670 align:middle line:-1
<c.magenta>你就开始丢失性能</c>

00:11:09.937 --> 00:11:12.673 align:middle line:-2
<c.magenta>因为这里的每一条白线</c>
<c.magenta>都是一个情境切换</c>

00:11:13.073 --> 00:11:14.641 align:middle line:-1
<c.magenta>情境切换的消耗也增加了</c>

00:11:14.708 --> 00:11:17.144 align:middle line:-1
<c.magenta>并不只是说执行情境切换的时间</c>

00:11:17.477 --> 00:11:19.313 align:middle line:-1
<c.magenta>还有内核所创建的历史</c>

00:11:19.379 --> 00:11:21.548 align:middle line:-2
<c.magenta>它必须得在每次情境切换后</c>
<c.magenta>恢复那个历史</c>

00:11:23.550 --> 00:11:25.485 align:middle line:-1
<c.magenta>你可能还会有其它影响因素</c>

00:11:25.552 --> 00:11:29.489 align:middle line:-2
<c.magenta>比如可能还有其它线程</c>
<c.magenta>正在排队等待获取CPU</c>

00:11:30.490 --> 00:11:33.126 align:middle line:-1
<c.magenta>每次切换情境时</c>

00:11:33.193 --> 00:11:34.962 align:middle line:-1
<c.magenta>剩余的线程队列都必须等待疏通</c>

00:11:35.028 --> 00:11:38.932 align:middle line:-2
<c.magenta>那么你可能会被队列中的其它线程</c>
<c.magenta>超越而导致延迟</c>

00:11:39.600 --> 00:11:42.736 align:middle line:-2
<c.magenta>那么让我们看看</c>
<c.magenta>导致情境切换次数过多的原因</c>

00:11:43.637 --> 00:11:46.607 align:middle line:-1
<c.magenta>那么今天我们要讲的是三个主要原因</c>

00:11:46.907 --> 00:11:50.577 align:middle line:-1
<c.magenta>第一是反复等待独占资源</c>

00:11:50.844 --> 00:11:53.614 align:middle line:-1
<c.magenta>在独立的运作之间反复切换</c>

00:11:53.680 --> 00:11:56.216 align:middle line:-1
<c.magenta>并且在线程间反复跳过某个运作</c>

00:11:56.950 --> 00:11:59.820 align:middle line:-1
<c.magenta>你注意到我反复几次提到了反复这个词</c>

00:12:00.587 --> 00:12:01.555 align:middle line:-1
<c.magenta>我是刻意这么说的</c>

00:12:03.257 --> 00:12:05.225 align:middle line:-1
<c.magenta>情境切换几次是没问题的</c>

00:12:05.559 --> 00:12:08.395 align:middle line:-2
<c.magenta>这就是并发的作用</c>
<c.magenta>也是我们赋予你们的能力</c>

00:12:08.662 --> 00:12:12.065 align:middle line:-2
<c.magenta>然而当你重复切换太多次时</c>
<c.magenta>消耗就开始增加了</c>

00:12:13.400 --> 00:12:15.402 align:middle line:-1
<c.magenta>那么让我们来看第一种情况</c>

00:12:15.469 --> 00:12:17.838 align:middle line:-1
<c.magenta>也就是独占资源</c>

00:12:18.672 --> 00:12:19.873 align:middle line:-1
<c.magenta>什么时候会发生这种情况？</c>

00:12:20.407 --> 00:12:24.845 align:middle line:-2
<c.magenta>嗯 这种发生的主要情况是</c>
<c.magenta>当你有一个锁定</c>

00:12:24.912 --> 00:12:28.182 align:middle line:-1
<c.magenta>而大量线程都尝试获取那个锁定时</c>

00:12:29.483 --> 00:12:31.818 align:middle line:-2
<c.magenta>那么如何了解你的应用中</c>
<c.magenta>是否有这种情况发生？</c>

00:12:31.885 --> 00:12:33.787 align:middle line:-1
<c.magenta>嗯 我们可以返回到系统追踪</c>

00:12:34.354 --> 00:12:36.857 align:middle line:-2
<c.magenta>我们可以在仪表中</c>
<c.magenta>形象化具体是怎么样的</c>

00:12:37.191 --> 00:12:39.726 align:middle line:-1
<c.magenta>那么假如说它显示我们有许多线程</c>

00:12:39.793 --> 00:12:41.228 align:middle line:-1
<c.magenta>只运行很短的时间</c>

00:12:41.295 --> 00:12:43.363 align:middle line:-1
<c.magenta>并且它们会在一个小串联中相互转换</c>

00:12:44.264 --> 00:12:46.767 align:middle line:-2
<c.magenta>让我们主要关注第一个线程</c>
<c.magenta>看看它会告诉我们哪些东西</c>

00:12:47.835 --> 00:12:51.839 align:middle line:-2
<c.magenta>我们有这个蓝色线</c>
<c.magenta>它表示的是线程在CPU上的时间</c>

00:12:52.539 --> 00:12:55.042 align:middle line:-1
<c.magenta>而红色线表示执行系统调用的时间</c>

00:12:55.108 --> 00:12:57.477 align:middle line:-2
<c.magenta>在本例中</c>
<c.magenta>它会执行一个无声文本系统调用</c>

00:12:58.579 --> 00:13:00.214 align:middle line:-1
<c.magenta>这显示出它绝大部分时间</c>

00:12:58.579 --> 00:13:00.214 align:middle line:-1
<c.magenta>这显示出它绝大部分时间</c>

00:13:00.280 --> 00:13:02.883 align:middle line:-1
<c.magenta>都在等待无声文本变为可用</c>

00:13:02.950 --> 00:13:06.220 align:middle line:-1
<c.magenta>在内核上的时间很短 只有10毫秒</c>

00:13:06.987 --> 00:13:09.857 align:middle line:-1
<c.magenta>系统中有大量情境切换</c>

00:13:09.923 --> 00:13:11.825 align:middle line:-1
<c.magenta>通过顶部的情境切换条显示</c>

00:13:13.794 --> 00:13:15.629 align:middle line:-1
<c.magenta>那么是什么原因导致了这样的情况？</c>

00:13:15.863 --> 00:13:17.865 align:middle line:-1
<c.magenta>让我们返回去看那个简单的时间轴</c>

00:13:18.298 --> 00:13:21.168 align:middle line:-1
<c.magenta>了解如何…如何获取情境[听不清]…</c>

00:13:22.135 --> 00:13:24.471 align:middle line:-1
<c.magenta>如何用完过度的负债</c>

00:13:25.239 --> 00:13:27.708 align:middle line:-1
<c.magenta>那么你可以及时了解到这种阶梯式模式</c>

00:13:28.008 --> 00:13:29.776 align:middle line:-1
<c.magenta>每个线程都只运行很短的时间</c>

00:13:29.843 --> 00:13:31.545 align:middle line:-1
<c.magenta>然后就把CPU让给下一个线程</c>

00:13:31.612 --> 00:13:33.180 align:middle line:-1
<c.magenta>以此类推 然后等待很长时间</c>

00:13:33.914 --> 00:13:35.816 align:middle line:-1
<c.magenta>你想让你的应用看起来像这样</c>

00:13:36.683 --> 00:13:39.419 align:middle line:-1
<c.magenta>你必须 CPU每次只能专注于一件事</c>

00:13:39.620 --> 00:13:41.355 align:middle line:-1
<c.magenta>完成它 然后再执行下一个任务</c>

00:13:42.322 --> 00:13:44.525 align:middle line:-2
<c.magenta>那么这里发生了什么</c>
<c.magenta>才导致了那种阶梯？</c>

00:13:44.691 --> 00:13:46.560 align:middle line:-1
<c.magenta>让我们放大其中一个阶梯</c>

00:13:47.628 --> 00:13:51.231 align:middle line:-2
<c.magenta>那么在这里我们正在专注两个线程</c>
<c.magenta>绿色线程和蓝色线程</c>

00:13:51.765 --> 00:13:53.534 align:middle line:-1
<c.magenta>并且顶部有CPU</c>

00:13:54.234 --> 00:13:55.836 align:middle line:-1
<c.magenta>我们在这里添加了一个新的锁定追踪</c>

00:13:55.969 --> 00:13:58.105 align:middle line:-1
<c.magenta>表明了锁定的状态以及哪个线程拥有它</c>

00:13:58.305 --> 00:13:59.339 align:middle line:-1
<c.magenta>在本例中</c>

00:13:59.406 --> 00:14:02.543 align:middle line:-2
<c.magenta>蓝色线程拥有这个锁定</c>
<c.magenta>而绿色线程正在等待</c>

00:13:59.406 --> 00:14:02.543 align:middle line:-2
<c.magenta>蓝色线程拥有这个锁定</c>
<c.magenta>而绿色线程正在等待</c>

00:14:03.443 --> 00:14:05.379 align:middle line:-1
<c.magenta>那么当蓝色线程解锁时</c>

00:14:05.445 --> 00:14:07.447 align:middle line:-1
<c.magenta>那个锁定的所有权就转给了绿色线程</c>

00:14:07.514 --> 00:14:08.615 align:middle line:-1
<c.magenta>因为它是队列中的下一个</c>

00:14:09.449 --> 00:14:13.587 align:middle line:-1
<c.magenta>然而当蓝色线程转回来再次获取锁定时</c>

00:14:13.654 --> 00:14:16.590 align:middle line:-1
<c.magenta>它不会成功 因为绿色线程预定了锁定</c>

00:14:16.657 --> 00:14:20.093 align:middle line:-2
<c.magenta>它强制进行情境切换</c>
<c.magenta>因为我们现在必须做其它事</c>

00:14:20.494 --> 00:14:23.497 align:middle line:-2
<c.magenta>我们切换到了绿色线程</c>
<c.magenta>那么CPU就可以</c>

00:14:24.097 --> 00:14:25.933 align:middle line:-1
<c.magenta>结束锁定 我们可以反复这个过程</c>

00:14:27.034 --> 00:14:28.202 align:middle line:-1
<c.magenta>有时候很有帮助</c>

00:14:28.268 --> 00:14:29.903 align:middle line:-1
<c.magenta>你希望等待锁定的每一个线程</c>

00:14:29.970 --> 00:14:31.872 align:middle line:-1
<c.magenta>都有机会获取资源</c>

00:14:32.606 --> 00:14:35.742 align:middle line:-2
<c.magenta>然而如果锁定的工作方式</c>
<c.magenta>不一样会发生什么呢？</c>

00:14:36.543 --> 00:14:39.880 align:middle line:-2
<c.magenta>让我们再从开始做</c>
<c.magenta>通过查看一个不公平的锁定会做什么</c>

00:14:40.881 --> 00:14:45.385 align:middle line:-2
<c.magenta>那么这一次当蓝色线程解锁时</c>
<c.magenta>锁定并没有被预定</c>

00:14:45.853 --> 00:14:47.621 align:middle line:-1
<c.magenta>锁定的所有权被公开拍卖了</c>

00:14:48.622 --> 00:14:51.992 align:middle line:-2
<c.magenta>蓝色线程可以再次获取锁定</c>
<c.magenta>并且它可以立即重新获取</c>

00:14:52.059 --> 00:14:54.795 align:middle line:-2
<c.magenta>并保留在CPU上</c>
<c.magenta>而不需要强制进行情景切换</c>

00:14:55.495 --> 00:14:56.697 align:middle line:-1
<c.magenta>那可能会导致绿色线程很难</c>

00:14:56.763 --> 00:14:59.366 align:middle line:-1
<c.magenta>有机会获取锁定</c>

00:14:59.433 --> 00:15:02.803 align:middle line:-1
<c.magenta>但它减少了强制情景切换的次数…</c>

00:14:59.433 --> 00:15:02.803 align:middle line:-1
<c.magenta>但它减少了强制情景切换的次数…</c>

00:15:02.870 --> 00:15:06.640 align:middle line:-2
<c.magenta>是蓝色线程为了重新获取锁定</c>
<c.magenta>而发起的强制切换</c>

00:15:08.008 --> 00:15:09.843 align:middle line:-1
<c.magenta>那么回顾一下当我们谈到锁定竞争时</c>

00:15:10.143 --> 00:15:13.547 align:middle line:-2
<c.magenta>你实际上是想确保</c>
<c.magenta>衡量你的应用和系统追踪</c>

00:15:13.847 --> 00:15:15.349 align:middle line:-1
<c.magenta>了解是否存在问题</c>

00:15:15.415 --> 00:15:20.254 align:middle line:-2
<c.magenta>如果你这么做了 这种不公平的锁定</c>
<c.magenta>通常适用于对象、属性</c>

00:15:20.320 --> 00:15:21.822 align:middle line:-1
<c.magenta>或全局状态 你的应用</c>

00:15:21.889 --> 00:15:24.124 align:middle line:-1
<c.magenta>可能会发生的锁定会跌很多很多次</c>

00:15:25.526 --> 00:15:27.728 align:middle line:-1
<c.magenta>当提到锁定时 我还想谈另外一件事</c>

00:15:27.995 --> 00:15:29.096 align:middle line:-1
<c.magenta>就是锁定的所有权</c>

00:15:29.863 --> 00:15:31.832 align:middle line:-1
<c.magenta>那么请记住我们之前的锁定追踪</c>

00:15:32.499 --> 00:15:35.135 align:middle line:-2
<c.magenta>运行时间知道接下来是哪个线程</c>
<c.magenta>会解锁锁定</c>

00:15:36.003 --> 00:15:37.638 align:middle line:-1
<c.magenta>我们可以利用那种能力</c>

00:15:37.704 --> 00:15:40.440 align:middle line:-1
<c.magenta>自动计算你应用中的优先级反转</c>

00:15:40.507 --> 00:15:42.342 align:middle line:-2
<c.magenta>在等待锁定的线程</c>
<c.magenta>和拥有锁定的线程之间</c>

00:15:43.043 --> 00:15:44.978 align:middle line:-1
<c.magenta>甚至启用其它优化</c>

00:15:45.045 --> 00:15:47.347 align:middle line:-1
<c.magenta>比如让CPU转到拥有锁定的线程上</c>

00:15:47.748 --> 00:15:49.816 align:middle line:-1
<c.magenta>稍后Pierre会跟大家讨论这个话题</c>

00:15:49.883 --> 00:15:51.151 align:middle line:-1
<c.magenta>当我们谈同步调度时</c>

00:15:52.186 --> 00:15:53.487 align:middle line:-1
<c.magenta>我们通常会有这个问题</c>

00:15:53.987 --> 00:15:56.557 align:middle line:-1
<c.magenta>哪些基元有这种能力而哪些没有呢？</c>

00:15:57.457 --> 00:16:00.494 align:middle line:-1
<c.magenta>让我们看看哪些低等级基元可以实现</c>

00:15:57.457 --> 00:16:00.494 align:middle line:-1
<c.magenta>让我们看看哪些低等级基元可以实现</c>

00:16:01.495 --> 00:16:04.531 align:middle line:-2
<c.magenta>那么拥有单一</c>
<c.magenta>已知所有者的基元有这种能力</c>

00:16:04.932 --> 00:16:07.100 align:middle line:-1
<c.magenta>比如连续队列和OS的不公平锁定</c>

00:16:08.202 --> 00:16:10.504 align:middle line:-1
<c.magenta>然而不对称基元</c>

00:16:10.571 --> 00:16:13.807 align:middle line:-1
<c.magenta>比如调度信号和调度群就没有这种能力</c>

00:16:13.974 --> 00:16:17.311 align:middle line:-2
<c.magenta>因为运行时间不知道哪个线程</c>
<c.magenta>会单一化子基元</c>

00:16:18.612 --> 00:16:21.381 align:middle line:-1
<c.magenta>最终 拥有多个所有者的基元</c>

00:16:21.448 --> 00:16:23.851 align:middle line:-1
<c.magenta>比如私人化的并发队列和读或写锁定</c>

00:16:24.251 --> 00:16:25.719 align:middle line:-1
<c.magenta>系统就不用利用那些</c>

00:16:25.786 --> 00:16:27.521 align:middle line:-1
<c.magenta>因为它们不是只有一个所有者</c>

00:16:28.488 --> 00:16:31.959 align:middle line:-1
<c.magenta>当你选择基元时 要考虑你是否</c>

00:16:32.025 --> 00:16:34.228 align:middle line:-1
<c.magenta>涉及多基元的线程交互</c>

00:16:35.095 --> 00:16:38.599 align:middle line:-2
<c.magenta>比如拥有较低优先级</c>
<c.magenta>后台线程的高级UI线程</c>

00:16:39.800 --> 00:16:42.970 align:middle line:-2
<c.magenta>如果是这样的话</c>
<c.magenta>你可能想利用基元的所有权</c>

00:16:43.370 --> 00:16:45.472 align:middle line:-1
<c.magenta>确保你的UI线程</c>

00:16:45.539 --> 00:16:47.941 align:middle line:-2
<c.magenta>不会因为等待</c>
<c.magenta>较低优先级的后台线程而延迟</c>

00:16:49.810 --> 00:16:50.844 align:middle line:-1
<c.magenta>那么总的来说</c>

00:16:50.911 --> 00:16:54.114 align:middle line:-2
<c.magenta>这些效率低的行为</c>
<c.magenta>通常会出现在你应用的属性中</c>

00:16:54.481 --> 00:16:57.317 align:middle line:-1
<c.magenta>仅仅通过看代码是很难发现这些问题的</c>

00:16:57.818 --> 00:17:00.320 align:middle line:-1
<c.magenta>你应该在仪表系统追踪中进行观察</c>

00:16:57.818 --> 00:17:00.320 align:middle line:-1
<c.magenta>你应该在仪表系统追踪中进行观察</c>

00:17:00.721 --> 00:17:02.990 align:middle line:-1
<c.magenta>形象化应用的真实行为</c>

00:17:03.357 --> 00:17:05.759 align:middle line:-1
<c.magenta>以便你可以利用正确的锁定执行任务</c>

00:17:06.527 --> 00:17:08.295 align:middle line:-1
<c.magenta>那么我刚才谈了</c>

00:17:08.362 --> 00:17:11.231 align:middle line:-2
<c.magenta>情境切换列表中的第一个原因</c>
<c.magenta>也就是独占资源</c>

00:17:12.566 --> 00:17:13.733 align:middle line:-1
<c.magenta>要谈</c>

00:17:13.800 --> 00:17:15.935 align:middle line:-2
<c.magenta>应用可能会拥有过度情境</c>
<c.magenta>切换的其它方式</c>

00:17:16.170 --> 00:17:18.505 align:middle line:-2
<c.magenta>让我们欢迎我的同事</c>
<c.magenta>Daniel Steffen上台</c>

00:17:18.571 --> 00:17:22.608 align:middle line:-1
<c.magenta>跟大家谈谈如何通过GDC管理并发</c>

00:17:22.675 --> 00:17:23.877 align:middle line:-1
<c.magenta>以避免这些陷阱</c>

00:17:31.618 --> 00:17:33.020 align:middle line:-1
<c.magenta>好的 谢谢Daniel</c>

00:17:33.086 --> 00:17:34.254 align:middle line:-1
<c.magenta>（使用GCD处理并发）</c>

00:17:34.321 --> 00:17:37.090 align:middle line:-2
<c.magenta>那么我们今天要讲很多内容</c>
<c.magenta>所以我不会</c>

00:17:37.157 --> 00:17:39.860 align:middle line:-1
<c.magenta>讲太多GCD的基本原理</c>

00:17:40.394 --> 00:17:43.697 align:middle line:-2
<c.magenta>如果你刚接触这个技术</c>
<c.magenta>或者需要回顾一些知识</c>

00:17:43.764 --> 00:17:46.567 align:middle line:-1
<c.magenta>这里有一些WWDC之前发布的演讲</c>

00:17:47.034 --> 00:17:50.103 align:middle line:-2
<c.magenta>是前几年我们做的演讲</c>
<c.magenta>详细介绍了GCD及其改进</c>

00:17:50.671 --> 00:17:52.806 align:middle line:-1
<c.magenta>那么我鼓励你查看这些视频</c>

00:17:53.941 --> 00:17:56.944 align:middle line:-1
<c.magenta>我们还会涉及GCD的一些基本概念</c>

00:17:57.010 --> 00:17:59.580 align:middle line:-1
<c.magenta>让我们从调度连续队列开始讲</c>

00:18:00.581 --> 00:18:04.218 align:middle line:-1
<c.magenta>这真的是GCD中基本的同步基元</c>

00:18:04.818 --> 00:18:07.988 align:middle line:-1
<c.magenta>它提供互斥以及FIFO排序</c>

00:18:08.055 --> 00:18:11.792 align:middle line:-2
<c.magenta>这是刚才Daniel提到的其中一个</c>
<c.magenta>有序的和公平的基元</c>

00:18:13.293 --> 00:18:15.829 align:middle line:-1
<c.magenta>它在队列运作中有一个并发原子</c>

00:18:15.896 --> 00:18:17.231 align:middle line:-1
<c.magenta>所以多线程</c>

00:18:17.297 --> 00:18:19.566 align:middle line:-1
<c.magenta>排队同时处理队列是没问题的</c>

00:18:19.867 --> 00:18:22.536 align:middle line:-1
<c.magenta>以及系统提供的单一DQS线程</c>

00:18:22.603 --> 00:18:24.671 align:middle line:-1
<c.magenta>在队列之外执行异步运作也是没问题的</c>

00:18:25.405 --> 00:18:27.508 align:middle line:-1
<c.magenta>那么让我们实际看个例子</c>

00:18:28.442 --> 00:18:31.778 align:middle line:0
<c.magenta>在这里我们创建了一个串行序列</c>
<c.magenta>通过调用调度队列构造器</c>

00:18:32.346 --> 00:18:34.448 align:middle line:0
<c.magenta>它会给你留下一个印象</c>

00:18:34.615 --> 00:18:38.051 align:middle line:0
<c.magenta>只要你还没有用它</c>
<c.magenta>它就会存在于你的应用中</c>

00:18:38.785 --> 00:18:39.887 align:middle line:0
<c.magenta>现在想象一下有两个线程</c>

00:18:39.953 --> 00:18:42.422 align:middle line:0
<c.magenta>同时出现并调用queue.async方法</c>

00:18:42.656 --> 00:18:44.725 align:middle line:0
<c.magenta>来向这个队列提交一些异步任务</c>

00:18:45.392 --> 00:18:47.327 align:middle line:0
<c.magenta>我们刚提到过</c>
<c.magenta>它寻找能实现此功能的多线程</c>

00:18:47.394 --> 00:18:50.731 align:middle line:0
<c.magenta>而项会进入队列 以便它们能出现</c>

00:18:52.299 --> 00:18:54.101 align:middle line:0
<c.magenta>因为这是个异步方法</c>

00:18:54.168 --> 00:18:58.505 align:middle line:0
<c.magenta>这个方法会返回并且线程可以继续</c>

00:18:58.572 --> 00:19:01.375 align:middle line:0
<c.magenta>那么也许这第一个线程</c>
<c.magenta>最终会调用queue.sync</c>

00:18:58.572 --> 00:19:01.375 align:middle line:0
<c.magenta>那么也许这第一个线程</c>
<c.magenta>最终会调用queue.sync</c>

00:19:01.975 --> 00:19:03.944 align:middle line:0
<c.magenta>这就是你与队列同步交互的方式</c>

00:19:04.311 --> 00:19:06.180 align:middle line:0
<c.magenta>因为这是个有序基元</c>

00:19:06.246 --> 00:19:08.982 align:middle line:0
<c.magenta>它的作用是它将作为</c>
<c.magenta>队列中的一个队列占位符</c>

00:19:09.550 --> 00:19:13.487 align:middle line:0
<c.magenta>以便线程可以等待直到轮到它</c>

00:19:14.555 --> 00:19:18.759 align:middle line:0
<c.magenta>现在有了这个自动辅助线程</c>

00:19:19.092 --> 00:19:21.195 align:middle line:0
<c.magenta>它可以执行异步工作</c>

00:19:21.261 --> 00:19:23.664 align:middle line:0
<c.magenta>直到你排到那个占位符那儿</c>

00:19:23.730 --> 00:19:25.966 align:middle line:0
<c.magenta>那时候队列的所有者将会转交给线程</c>

00:19:26.033 --> 00:19:29.069 align:middle line:0
<c.magenta>在queue.sync中等待</c>
<c.magenta>以便可以执行自己的代码块</c>

00:19:31.238 --> 00:19:34.875 align:middle line:-1
<c.magenta>那么下一个概念是调度源</c>

00:19:35.042 --> 00:19:37.411 align:middle line:-1
<c.magenta>这是GCD中的事件监控基元</c>

00:19:37.778 --> 00:19:38.979 align:middle line:-1
<c.magenta>在这里我们设置了一个</c>

00:19:39.313 --> 00:19:41.348 align:middle line:-1
<c.magenta>用于监控一个默认基元的可读性</c>

00:19:41.682 --> 00:19:43.450 align:middle line:-1
<c.magenta>如果你有读取资源构造器的话</c>

00:19:44.251 --> 00:19:46.987 align:middle line:-1
<c.magenta>你在队列中传递它 就是源的目标队列</c>

00:19:47.321 --> 00:19:50.123 align:middle line:-1
<c.magenta>也是我们执行源的事件处理的地方</c>

00:19:50.457 --> 00:19:52.259 align:middle line:-1
<c.magenta>在这里只需要从默认描述符中读取</c>

00:19:53.026 --> 00:19:55.162 align:middle line:-1
<c.magenta>这个目标队列还是你可能会放置</c>

00:19:55.229 --> 00:19:57.531 align:middle line:-2
<c.magenta>应该与这个运作</c>
<c.magenta>一起序列化的任务的地方</c>

00:19:57.598 --> 00:19:59.600 align:middle line:-1
<c.magenta>比如处理所读取的数据</c>

00:20:00.667 --> 00:20:02.736 align:middle line:-1
<c.magenta>那么我们给源设置了取消处理器</c>

00:20:02.936 --> 00:20:06.340 align:middle line:-2
<c.magenta>是源如何将它们</c>
<c.magenta>实施为无效模式的方式</c>

00:20:07.040 --> 00:20:08.375 align:middle line:-1
<c.magenta>最终当一切都设置好之后</c>

00:20:08.442 --> 00:20:10.577 align:middle line:-1
<c.magenta>你需要调用源并激活以开始监控</c>

00:20:11.645 --> 00:20:14.047 align:middle line:-1
<c.magenta>那么值得注意的是源只是</c>

00:20:14.348 --> 00:20:17.518 align:middle line:-1
<c.magenta>OS中一个更通用的模式的实例</c>

00:20:17.684 --> 00:20:21.655 align:middle line:-2
<c.magenta>其中包括可以按照你指定的目标队列</c>
<c.magenta>向你提交事件的对象</c>

00:20:22.055 --> 00:20:23.590 align:middle line:0
<c.magenta>那么如果你熟悉XPC</c>

00:20:23.657 --> 00:20:26.660 align:middle line:0
<c.magenta>那可以作为</c>
<c.magenta>那个XPC连接的另一个例子</c>

00:20:27.995 --> 00:20:31.298 align:middle line:0
<c.magenta>并且值得注意的是我们今天</c>
<c.magenta>告诉你们的与源有关的全部内容</c>

00:20:31.365 --> 00:20:34.334 align:middle line:-1
<c.magenta>一般来说都可以应用到全部这种对象上</c>

00:20:36.270 --> 00:20:38.305 align:middle line:-1
<c.magenta>那么把这两个概念结合到一起</c>

00:20:38.372 --> 00:20:40.607 align:middle line:-1
<c.magenta>我们就得到了一个目标队列等级</c>

00:20:44.945 --> 00:20:47.581 align:middle line:-2
<c.magenta>那么在这里我们有两个源</c>
<c.magenta>及其相关联的目标队列</c>

00:20:47.648 --> 00:20:50.651 align:middle line:-1
<c.magenta>S1、S2 队列是Q1和Q2</c>

00:20:50.884 --> 00:20:53.187 align:middle line:-2
<c.magenta>我们构造一个小的树形结构</c>
<c.magenta>解决这种情况</c>

00:20:53.253 --> 00:20:55.155 align:middle line:-1
<c.magenta>通过添加另一个连续队列</c>

00:20:55.455 --> 00:20:58.692 align:middle line:-1
<c.magenta>通过在底部添加互斥队列EQ</c>

00:20:59.326 --> 00:21:02.462 align:middle line:0
<c.magenta>我们的实现方式是通过把可选目标参数</c>

00:20:59.326 --> 00:21:02.462 align:middle line:0
<c.magenta>我们的实现方式是通过把可选目标参数</c>

00:21:02.529 --> 00:21:04.164 align:middle line:0
<c.magenta>传给调度队列构造器</c>

00:21:05.232 --> 00:21:09.102 align:middle line:0
<c.magenta>那么这就为整个树形结构</c>
<c.magenta>提供了一个共享单一互斥情境</c>

00:21:09.503 --> 00:21:13.807 align:middle line:0
<c.magenta>每次只能执行其中一个源</c>
<c.magenta>或队列中的一项</c>

00:21:14.441 --> 00:21:17.277 align:middle line:-1
<c.magenta>但它为队列1和队列2</c>

00:21:17.344 --> 00:21:18.679 align:middle line:-1
<c.magenta>保持了独立的单项队列顺序</c>

00:21:19.179 --> 00:21:20.914 align:middle line:-1
<c.magenta>那么让我们具体来看看我所表达的意思</c>

00:21:22.649 --> 00:21:24.952 align:middle line:-2
<c.magenta>在这里我有两个队列</c>
<c.magenta>队列1和队列2</c>

00:21:25.018 --> 00:21:27.354 align:middle line:-1
<c.magenta>它们以指定顺序排列</c>

00:21:27.754 --> 00:21:30.090 align:middle line:-1
<c.magenta>因为我们底部有这个额外的连续队列</c>

00:21:30.157 --> 00:21:33.260 align:middle line:-1
<c.magenta>还有执行 那么它们将在EQ中执行</c>

00:21:33.627 --> 00:21:35.996 align:middle line:-1
<c.magenta>并且会有一个单一辅助线程执行这些</c>

00:21:36.063 --> 00:21:39.900 align:middle line:-2
<c.magenta>为你提供互斥属性的项</c>
<c.magenta>每次只能执行一项</c>

00:21:40.167 --> 00:21:43.504 align:middle line:-2
<c.magenta>但正如你所看到的</c>
<c.magenta>两个队列中的项可以穿插执行</c>

00:21:43.904 --> 00:21:47.040 align:middle line:-1
<c.magenta>并保留各自在原始队列中的顺序</c>

00:21:49.443 --> 00:21:54.114 align:middle line:-2
<c.magenta>那么我们今天涉及到的最后一个</c>
<c.magenta>概念就是服务质量</c>

00:21:55.282 --> 00:21:58.752 align:middle line:0
<c.magenta>这其实是以前详细谈过的一个概念</c>

00:21:58.819 --> 00:22:03.857 align:middle line:0
<c.magenta>尤其是在2014年的能力性能</c>
<c.magenta>和诊断演讲上</c>

00:21:58.819 --> 00:22:03.857 align:middle line:0
<c.magenta>尤其是在2014年的能力性能</c>
<c.magenta>和诊断演讲上</c>

00:22:04.224 --> 00:22:07.661 align:middle line:0
<c.magenta>那么如果这对于你来说不熟悉</c>
<c.magenta>我建议你参看那场演讲的资料</c>

00:22:08.462 --> 00:22:11.565 align:middle line:-1
<c.magenta>但我们今天要讲的主要是</c>

00:22:11.832 --> 00:22:13.534 align:middle line:-1
<c.magenta>优先级的抽象概念</c>

00:22:14.701 --> 00:22:17.137 align:middle line:-1
<c.magenta>我们会用到术语QOS和优先级</c>

00:22:17.204 --> 00:22:20.140 align:middle line:-1
<c.magenta>在接下来的演讲中会交替出现</c>

00:22:21.275 --> 00:22:23.677 align:middle line:-1
<c.magenta>我们的系统上的服务级别有四种质量</c>

00:22:23.744 --> 00:22:26.380 align:middle line:-1
<c.magenta>最高的是用户交互性UI、</c>

00:22:26.547 --> 00:22:32.953 align:middle line:-2
<c.magenta>到用户发起（或IN）、效用（UT）</c>
<c.magenta>到后台（BG） 最低优先级</c>

00:22:33.954 --> 00:22:37.424 align:middle line:-1
<c.magenta>那么让我们看看要如何结合服务质量</c>

00:22:37.491 --> 00:22:39.826 align:middle line:-1
<c.magenta>通过我们刚看过的目标队列等级</c>

00:22:40.294 --> 00:22:42.095 align:middle line:-1
<c.magenta>在这个等级中 树结构中的每个节点</c>

00:22:42.162 --> 00:22:44.998 align:middle line:-2
<c.magenta>其实都可以有一个与之</c>
<c.magenta>相关联的服务标签质量</c>

00:22:45.732 --> 00:22:48.802 align:middle line:-1
<c.magenta>那么比如说源2可能与用户界面相关</c>

00:22:49.102 --> 00:22:50.437 align:middle line:-1
<c.magenta>它可能会针对事件被监控</c>

00:22:50.504 --> 00:22:52.906 align:middle line:-2
<c.magenta>一旦触发事件</c>
<c.magenta>我们就应该更新它们的UI</c>

00:22:52.973 --> 00:22:57.044 align:middle line:-2
<c.magenta>那么有可能我们想把这个UI标签</c>
<c.magenta>放到源上</c>

00:22:57.911 --> 00:22:59.646 align:middle line:-1
<c.magenta>另一个常见的用例是</c>

00:22:59.913 --> 00:23:04.451 align:middle line:-2
<c.magenta>把标签放在互斥队列中</c>
<c.magenta>以提供一系列的执行</c>

00:22:59.913 --> 00:23:04.451 align:middle line:-2
<c.magenta>把标签放在互斥队列中</c>
<c.magenta>以提供一系列的执行</c>

00:23:04.618 --> 00:23:08.722 align:middle line:-2
<c.magenta>从而树形结构中的全部都能在这个</c>
<c.magenta>等级下执行 那么本例中就是UT</c>

00:23:10.357 --> 00:23:14.261 align:middle line:-2
<c.magenta>现在如果这个队列中的任意其它项</c>
<c.magenta>被触发 比如源1</c>

00:23:14.528 --> 00:23:17.331 align:middle line:-1
<c.magenta>我们将使用这个属性结构的等级</c>

00:23:17.397 --> 00:23:19.700 align:middle line:-2
<c.magenta>如果它没有</c>
<c.magenta>与自己相关联的服务质量的话</c>

00:23:21.435 --> 00:23:26.673 align:middle line:-2
<c.magenta>源触发其实就像</c>
<c.magenta>从内核中执行的异步运作</c>

00:23:26.874 --> 00:23:29.910 align:middle line:0
<c.magenta>在发生之前也一样</c>
<c.magenta>我们会排在源处理器队列的最后</c>

00:23:30.143 --> 00:23:32.679 align:middle line:0
<c.magenta>最终进入互斥队列执行</c>

00:23:34.181 --> 00:23:37.184 align:middle line:0
<c.magenta>对于用户空间的异步运作</c>
<c.magenta>你的服务质量</c>

00:23:37.251 --> 00:23:39.753 align:middle line:0
<c.magenta>通常是由那个</c>
<c.magenta>叫作queue.async的线程决定的</c>

00:23:40.120 --> 00:23:44.625 align:middle line:0
<c.magenta>现在我们有一个用户发起的线程</c>
<c.magenta>把项提交</c>

00:23:44.691 --> 00:23:47.661 align:middle line:0
<c.magenta>到队列中 并最终执行到E队列中</c>

00:23:48.295 --> 00:23:50.531 align:middle line:0
<c.magenta>现在也许我们有源2</c>

00:23:50.597 --> 00:23:53.634 align:middle line:0
<c.magenta>与这个高优先级的UI相关事件一起</c>

00:23:53.700 --> 00:23:57.204 align:middle line:0
<c.magenta>源2执行其事件处理器</c>
<c.magenta>并把它的事件处理器排到了EQ中</c>

00:23:58.205 --> 00:24:01.575 align:middle line:0
<c.magenta>那么现在你会注意到我们</c>
<c.magenta>处于优先级倒置的情况中</c>

00:23:58.205 --> 00:24:01.575 align:middle line:0
<c.magenta>那么现在你会注意到我们</c>
<c.magenta>处于优先级倒置的情况中</c>

00:24:01.642 --> 00:24:04.778 align:middle line:0
<c.magenta>我们的队列中有三个项</c>
<c.magenta>最后一个项的优先级很高</c>

00:24:04.945 --> 00:24:08.849 align:middle line:0
<c.magenta>前边是一些低优先级项</c>
<c.magenta>并且必须要按顺序执行</c>

00:24:09.616 --> 00:24:12.819 align:middle line:0
<c.magenta>系统为你解决了这种倒置</c>
<c.magenta>通过一个拉动一个</c>

00:24:13.120 --> 00:24:16.690 align:middle line:0
<c.magenta>比当前队列中所有项都高的</c>
<c.magenta>最高优先级辅助线程</c>

00:24:17.891 --> 00:24:20.827 align:middle line:0
<c.magenta>我们一定要记住右边的这个树形图</c>

00:24:20.894 --> 00:24:23.130 align:middle line:0
<c.magenta>因为稍后它会再次出现</c>

00:24:26.934 --> 00:24:29.837 align:middle line:-1
<c.magenta>让我们继续我们的主话题</c>

00:24:29.903 --> 00:24:34.174 align:middle line:-2
<c.magenta>即如何使用我们刚学到的知识</c>
<c.magenta>来向GCD表达优良的并发间隔</c>

00:24:35.943 --> 00:24:38.579 align:middle line:-2
<c.magenta>让我们返回去看Daniel</c>
<c.magenta>刚刚介绍过的新闻应用</c>

00:24:38.745 --> 00:24:41.381 align:middle line:-1
<c.magenta>稍微多关注一点联网子系统</c>

00:24:43.016 --> 00:24:45.719 align:middle line:-1
<c.magenta>在联网子系统中 你必须监控</c>

00:24:45.786 --> 00:24:47.421 align:middle line:-1
<c.magenta>内核中的一些网络连接</c>

00:24:47.921 --> 00:24:49.957 align:middle line:-1
<c.magenta>有了GCD 你可以用调度源</c>

00:24:50.023 --> 00:24:51.859 align:middle line:-2
<c.magenta>和调度队列实现</c>
<c.magenta>就像你刚看到的那样</c>

00:24:52.192 --> 00:24:54.161 align:middle line:-1
<c.magenta>但当然了在任何网络子系统中</c>

00:24:54.228 --> 00:24:57.097 align:middle line:-2
<c.magenta>你通常不仅仅有一个网络连接</c>
<c.magenta>你会有许多网络连接</c>

00:24:57.698 --> 00:24:59.867 align:middle line:-1
<c.magenta>它们会复制同样的设置</c>

00:25:00.701 --> 00:25:03.871 align:middle line:-1
<c.magenta>那么让我们主要关注右边的这三个连接</c>

00:25:04.037 --> 00:25:05.472 align:middle line:-1
<c.magenta>看看它们是如何执行的</c>

00:25:06.940 --> 00:25:08.509 align:middle line:-1
<c.magenta>如果触发了第一个连接</c>

00:25:08.809 --> 00:25:10.978 align:middle line:-1
<c.magenta>跟我们刚看到的一样</c>

00:25:11.044 --> 00:25:14.581 align:middle line:-2
<c.magenta>我们会排在那个源的事件处理器的最后</c>
<c.magenta>并将其排入目标队列</c>

00:25:15.115 --> 00:25:17.651 align:middle line:-1
<c.magenta>当然如果同时触发了其它两个连接</c>

00:25:17.718 --> 00:25:19.786 align:middle line:-2
<c.magenta>它们仍会复制</c>
<c.magenta>然后你将结束这三个队列</c>

00:25:20.020 --> 00:25:21.288 align:middle line:-1
<c.magenta>而事件处理器排在最后</c>

00:25:22.022 --> 00:25:25.259 align:middle line:-1
<c.magenta>因为你在底部有这三个独立的连续队列</c>

00:25:25.425 --> 00:25:27.160 align:middle line:-1
<c.magenta>你其实已经请求系统给你提供</c>

00:25:27.227 --> 00:25:29.196 align:middle line:-1
<c.magenta>三个独立的并发情境</c>

00:25:29.663 --> 00:25:33.200 align:middle line:-2
<c.magenta>如果全部三个同时被激活</c>
<c.magenta>系统将强制创建</c>

00:25:33.367 --> 00:25:35.502 align:middle line:-1
<c.magenta>三个线程用于执行时间处理器</c>

00:25:36.603 --> 00:25:39.740 align:middle line:-2
<c.magenta>现在这也许就是你想要的</c>
<c.magenta>也许正是你所要追寻的效果</c>

00:25:40.140 --> 00:25:45.012 align:middle line:-2
<c.magenta>但常见的情况是这些事件处理器很小</c>
<c.magenta>而且只能</c>

00:25:45.078 --> 00:25:48.115 align:middle line:-2
<c.magenta>从网络中读取一些数据</c>
<c.magenta>并把它排入一个常见的数据结构中</c>

00:25:48.682 --> 00:25:51.552 align:middle line:-2
<c.magenta>此外正如我们之前所看到的</c>
<c.magenta>你并不只是有三个连接</c>

00:25:51.618 --> 00:25:53.153 align:middle line:-1
<c.magenta>你可能有很多很多连接</c>

00:25:53.220 --> 00:25:56.323 align:middle line:-1
<c.magenta>如果你的子系统中有许多网络连接的话</c>

00:25:57.157 --> 00:25:59.860 align:middle line:-1
<c.magenta>那么这可能会导致这种</c>

00:26:00.027 --> 00:26:03.463 align:middle line:-2
<c.magenta>情境切换模式的出现</c>
<c.magenta>就是Daniel刚谈过的过度的情境切换</c>

00:26:03.530 --> 00:26:05.432 align:middle line:-1
<c.magenta>就是你执行少量工作</c>

00:26:05.499 --> 00:26:08.569 align:middle line:-2
<c.magenta>情境切换到另一个线程</c>
<c.magenta>再执行少量工作 如此反复</c>

00:26:09.436 --> 00:26:12.706 align:middle line:-2
<c.magenta>那么我们该如何改善</c>
<c.magenta>这个例子中的这种情况呢？</c>

00:26:13.273 --> 00:26:17.044 align:middle line:-2
<c.magenta>我们可以应用我们刚谈到的那个</c>
<c.magenta>单一互斥情境的概念</c>

00:26:17.444 --> 00:26:20.414 align:middle line:-1
<c.magenta>只需要在底部放一个额外的连续队列</c>

00:26:20.480 --> 00:26:24.718 align:middle line:-1
<c.magenta>并形成一个等级即可 你可以获得</c>

00:26:24.785 --> 00:26:26.253 align:middle line:-1
<c.magenta>全部这些连接的单一互斥情境</c>

00:26:26.720 --> 00:26:29.823 align:middle line:-2
<c.magenta>如果它们同时被触发</c>
<c.magenta>将会发生跟以前一模一样的情况</c>

00:26:29.890 --> 00:26:32.426 align:middle line:-1
<c.magenta>事件处理器将会排在目标队列的最后</c>

00:26:32.492 --> 00:26:34.995 align:middle line:-1
<c.magenta>但因为底部有了这个额外的连续队列</c>

00:26:35.062 --> 00:26:37.264 align:middle line:-2
<c.magenta>它是单一线程</c>
<c.magenta>它会按顺序执行这些事件处理器</c>

00:26:37.331 --> 00:26:40.200 align:middle line:-1
<c.magenta>而不是由我们之前的那个多线程来执行</c>

00:26:41.134 --> 00:26:45.205 align:middle line:-2
<c.magenta>那么看起来像是个非常简单的修改</c>
<c.magenta>但这种修改却</c>

00:26:45.272 --> 00:26:48.709 align:middle line:-2
<c.magenta>将我们自己某些代码的性能</c>
<c.magenta>提升了1.3倍</c>

00:26:49.009 --> 00:26:51.712 align:middle line:-1
<c.magenta>正如Daniel之前提到过的一样</c>

00:26:55.516 --> 00:26:59.186 align:middle line:-1
<c.magenta>那么这是如何避免问题模式的一个例子</c>

00:26:59.253 --> 00:27:01.522 align:middle line:-1
<c.magenta>关于在独立运作之间反复切换的问题</c>

00:26:59.253 --> 00:27:01.522 align:middle line:-1
<c.magenta>关于在独立运作之间反复切换的问题</c>

00:27:02.422 --> 00:27:05.025 align:middle line:-2
<c.magenta>但它却归入了一个通用标题</c>
<c.magenta>叫作在应用中避免</c>

00:27:05.092 --> 00:27:08.028 align:middle line:-1
<c.magenta>多余的和不受控制的并发</c>

00:27:09.329 --> 00:27:13.100 align:middle line:-1
<c.magenta>解决办法之一就是同时激活许多队列</c>

00:27:13.367 --> 00:27:14.568 align:middle line:-1
<c.magenta>其中一个例子是</c>

00:27:14.635 --> 00:27:17.971 align:middle line:-1
<c.magenta>我们刚才看到的那个需要独立的源模式</c>

00:27:18.038 --> 00:27:21.275 align:middle line:-1
<c.magenta>如果你有独立或对象队列也可以解决</c>

00:27:21.542 --> 00:27:24.178 align:middle line:-2
<c.magenta>如果你的应用中许多对象</c>
<c.magenta>都有自己的连续队列</c>

00:27:24.244 --> 00:27:26.747 align:middle line:-1
<c.magenta>并且你同时给赋予它们异步运作</c>

00:27:26.813 --> 00:27:29.216 align:middle line:-1
<c.magenta>你就可以得到一模一样的效果</c>

00:27:31.018 --> 00:27:33.453 align:middle line:-1
<c.magenta>如果你有许多工作项</c>

00:27:33.520 --> 00:27:35.656 align:middle line:-1
<c.magenta>同时提交到全局并发队列 也可以解决</c>

00:27:36.356 --> 00:27:38.192 align:middle line:-1
<c.magenta>特别是如果有工作项阻塞时</c>

00:27:38.725 --> 00:27:42.129 align:middle line:-2
<c.magenta>全局并发队列的运作方式是</c>
<c.magenta>它会纠正更多的线程</c>

00:27:42.396 --> 00:27:43.697 align:middle line:-1
<c.magenta>当现有线程阻塞了</c>

00:27:43.764 --> 00:27:46.700 align:middle line:-1
<c.magenta>给你提供并发的持续性良好等级</c>

00:27:47.034 --> 00:27:48.869 align:middle line:-1
<c.magenta>但如果这些线程再次阻塞</c>

00:27:49.036 --> 00:27:51.839 align:middle line:-1
<c.magenta>你可以用一个叫作线程爆炸的东西</c>

00:27:52.873 --> 00:27:54.875 align:middle line:-1
<c.magenta>在这个话题中 我们要接触到一些细节</c>

00:27:54.942 --> 00:27:59.146 align:middle line:-2
<c.magenta>在2015年的“用GCD创建响应性</c>
<c.magenta>和高效率应用”演讲中有详细介绍</c>

00:27:59.646 --> 00:28:01.515 align:middle line:-1
<c.magenta>那么如果你不熟悉这些</c>

00:27:59.646 --> 00:28:01.515 align:middle line:-1
<c.magenta>那么如果你不熟悉这些</c>

00:28:01.582 --> 00:28:03.550 align:middle line:-1
<c.magenta>我建议你参看那场演讲的视频</c>

00:28:04.785 --> 00:28:06.787 align:middle line:-1
<c.magenta>那么如何选择适当数量的并发</c>

00:28:06.854 --> 00:28:09.489 align:middle line:-1
<c.magenta>以避免这些问题模式呢？</c>

00:28:10.290 --> 00:28:12.326 align:middle line:-1
<c.magenta>以前我们推荐给你的一个方法是</c>

00:28:12.392 --> 00:28:14.661 align:middle line:-1
<c.magenta>给子系统使用一个队列</c>

00:28:16.129 --> 00:28:17.898 align:middle line:-1
<c.magenta>那么返回到我们的新闻应用</c>

00:28:17.965 --> 00:28:20.567 align:middle line:-2
<c.magenta>我们用户界面已经有了一个队列</c>
<c.magenta>就是主队列</c>

00:28:20.634 --> 00:28:23.103 align:middle line:-1
<c.magenta>我们可以给网络连接选择一个连续队列</c>

00:28:23.170 --> 00:28:26.006 align:middle line:-2
<c.magenta>并另外给数据库子系统选择一个</c>
<c.magenta>连续队列</c>

00:28:27.007 --> 00:28:29.810 align:middle line:-2
<c.magenta>但我们今天学了另一种</c>
<c.magenta>思考这种情况的新方式</c>

00:28:29.877 --> 00:28:32.579 align:middle line:-2
<c.magenta>其实就是给每个子系统</c>
<c.magenta>使用一个队列等级</c>

00:28:35.916 --> 00:28:38.752 align:middle line:-1
<c.magenta>这就给子系统提供了一个互斥情境</c>

00:28:38.819 --> 00:28:43.223 align:middle line:-2
<c.magenta>你可以让队列中余下的事件</c>
<c.magenta>单独进行子构建和拥有子系统</c>

00:28:43.290 --> 00:28:47.060 align:middle line:-2
<c.magenta>只把那个网络队列</c>
<c.magenta>或数据库队列作为目标</c>

00:28:47.127 --> 00:28:49.930 align:middle line:-1
<c.magenta>就是位于队列等级底部的那个队列</c>

00:28:54.735 --> 00:28:57.538 align:middle line:-1
<c.magenta>但那可能是一个太过简单的模式</c>

00:28:57.604 --> 00:28:59.773 align:middle line:-1
<c.magenta>对于复杂应用或复杂子系统来说</c>

00:29:00.174 --> 00:29:01.842 align:middle line:-1
<c.magenta>这里的重点是</c>

00:29:02.009 --> 00:29:04.144 align:middle line:-1
<c.magenta>在应用中拥有固定数量的连续队列等级</c>

00:29:04.611 --> 00:29:06.813 align:middle line:-2
<c.magenta>拥有额外队列等级对于</c>
<c.magenta>复杂的子系统来说很有必要</c>

00:29:07.047 --> 00:29:10.217 align:middle line:-2
<c.magenta>比如第二队列等级</c>
<c.magenta>用于处理较慢的工作</c>

00:29:10.284 --> 00:29:12.486 align:middle line:-1
<c.magenta>或较大的工作项 那么第一个队列等级</c>

00:29:12.553 --> 00:29:14.821 align:middle line:-2
<c.magenta>就是主要的队列等级</c>
<c.magenta>可以保持子系统响应</c>

00:29:14.888 --> 00:29:16.490 align:middle line:-1
<c.magenta>外面进来的请求</c>

00:29:18.425 --> 00:29:21.128 align:middle line:-1
<c.magenta>这个情境中需要思考的另一个重点</c>

00:29:21.428 --> 00:29:24.731 align:middle line:-1
<c.magenta>是提交给那些子系统的工作的间隔</c>

00:29:25.766 --> 00:29:28.969 align:middle line:-2
<c.magenta>你想使用相当大的工作项</c>
<c.magenta>当你在子系统中移动</c>

00:29:29.236 --> 00:29:31.972 align:middle line:-1
<c.magenta>以实现我们之前看到过的那种情况</c>

00:29:32.039 --> 00:29:35.809 align:middle line:0
<c.magenta>也就是CP有足够长的时间</c>
<c.magenta>执行你的子系统</c>

00:29:36.143 --> 00:29:38.512 align:middle line:0
<c.magenta>以达到一种高效的性能状态</c>

00:29:39.980 --> 00:29:42.916 align:middle line:0
<c.magenta>一旦你处于子系统内部</c>
<c.magenta>比如这里的网络子系统</c>

00:29:43.250 --> 00:29:47.354 align:middle line:0
<c.magenta>就有必要把子系统细分为</c>
<c.magenta>更小的组块项了</c>

00:29:47.421 --> 00:29:51.158 align:middle line:0
<c.magenta>并且用更精细的间隔来改善</c>
<c.magenta>那个子系统的响应能力</c>

00:29:51.592 --> 00:29:54.661 align:middle line:0
<c.magenta>比如你可以拆分你的工作并重新异步</c>

00:29:54.728 --> 00:29:56.663 align:middle line:0
<c.magenta>到你队列等级中的另一个队列</c>

00:29:56.730 --> 00:29:58.198 align:middle line:0
<c.magenta>那并不会导致情境切换</c>

00:29:58.265 --> 00:30:00.033 align:middle line:0
<c.magenta>因为你已经在那个子系统中了</c>

00:29:58.265 --> 00:30:00.033 align:middle line:0
<c.magenta>因为你已经在那个子系统中了</c>

00:30:03.437 --> 00:30:05.973 align:middle line:-2
<c.magenta>那么总的来说我们在这部分</c>
<c.magenta>学到了什么？</c>

00:30:06.940 --> 00:30:10.878 align:middle line:-2
<c.magenta>我们了解了如何把队列和源</c>
<c.magenta>组织到连续队列等级中</c>

00:30:11.245 --> 00:30:13.714 align:middle line:-1
<c.magenta>如何使用固定数量的连续队列等级</c>

00:30:13.780 --> 00:30:16.216 align:middle line:-1
<c.magenta>使GCD获得一个不错的并发间隔</c>

00:30:16.683 --> 00:30:20.921 align:middle line:-1
<c.magenta>以及如何合适地拆分你的工作项</c>

00:30:20.988 --> 00:30:24.157 align:middle line:-2
<c.magenta>用于之前讲的并行工作</c>
<c.magenta>和这里的并发工作</c>

00:30:24.224 --> 00:30:27.094 align:middle line:-1
<c.magenta>在子系统内以及子系统之间</c>

00:30:28.028 --> 00:30:30.531 align:middle line:-1
<c.magenta>好的 我要把舞台交给Pierre</c>

00:30:30.597 --> 00:30:33.100 align:middle line:-2
<c.magenta>他会深入探讨我们对GCD的改进</c>
<c.magenta>使其总是</c>

00:30:33.166 --> 00:30:36.136 align:middle line:-2
<c.magenta>在单一线程上执行队列等级</c>
<c.magenta>以及如何现代化你的代码</c>

00:30:36.370 --> 00:30:38.005 align:middle line:-1
<c.magenta>来利用这个改进</c>

00:30:44.378 --> 00:30:45.412 align:middle line:-1
<c.magenta>谢谢Daniel</c>

00:30:47.047 --> 00:30:51.618 align:middle line:-2
<c.magenta>那么的确我们今年</c>
<c.magenta>彻底改造了GCD的内部构件</c>

00:30:51.685 --> 00:30:54.521 align:middle line:-1
<c.magenta>以剔除某些多余的情境切换</c>

00:30:54.588 --> 00:30:56.657 align:middle line:-1
<c.magenta>并执行单一队列等级</c>

00:30:56.723 --> 00:30:59.593 align:middle line:-2
<c.magenta>就像Daniel在单一线程上</c>
<c.magenta>所展示的那个例子一样</c>

00:31:00.460 --> 00:31:04.598 align:middle line:-1
<c.magenta>为此我们创建了一个新概念</c>

00:31:04.665 --> 00:31:07.267 align:middle line:-2
<c.magenta>我们叫作统一队列身份</c>
<c.magenta>让我们来实践一下</c>

00:31:07.334 --> 00:31:09.403 align:middle line:-1
<c.magenta>我们会逐步带你认识它是如何工作的</c>

00:31:11.471 --> 00:31:14.107 align:middle line:-1
<c.magenta>那么其实这部分内容…</c>

00:31:14.708 --> 00:31:18.312 align:middle line:-1
<c.magenta>开始…将主要关注单一队列等级</c>

00:31:18.378 --> 00:31:20.180 align:middle line:-1
<c.magenta>比如Daniel刚展示的那几个</c>

00:31:20.514 --> 00:31:24.518 align:middle line:-2
<c.magenta>然而我们会处理一些简化的</c>
<c.magenta>单一队列等级 它们的顶部有源</c>

00:31:24.785 --> 00:31:27.421 align:middle line:-1
<c.magenta>底部有互斥情境</c>

00:31:27.487 --> 00:31:31.692 align:middle line:-2
<c.magenta>GCD内部的注释并不是为了</c>
<c.magenta>那部分演讲而准备的</c>

00:31:34.027 --> 00:31:35.696 align:middle line:-1
<c.magenta>那么当你创建[听不清]情境时</c>

00:31:35.762 --> 00:31:37.564 align:middle line:-1
<c.magenta>你通常会调度队列构造器</c>

00:31:38.332 --> 00:31:41.869 align:middle line:-2
<c.magenta>那只会给你的应用留下一个印象</c>
<c.magenta>表明那是一个注释</c>

00:31:42.302 --> 00:31:44.137 align:middle line:-1
<c.magenta>你可能要做的第一件事</c>

00:31:44.304 --> 00:31:46.940 align:middle line:-1
<c.magenta>就是给它调度最近编码的项</c>

00:31:48.141 --> 00:31:51.044 align:middle line:-1
<c.magenta>那么你的应用中将有代码会在这里</c>

00:31:51.612 --> 00:31:54.515 align:middle line:-1
<c.magenta>并在队列中[听不清]排队</c>

00:31:55.649 --> 00:31:58.352 align:middle line:0
<c.magenta>以前当那种情况发生时</c>
<c.magenta>我们通常会请求</c>

00:31:58.418 --> 00:32:01.455 align:middle line:0
<c.magenta>给系统调度一个匿名线程</c>

00:31:58.418 --> 00:32:01.455 align:middle line:0
<c.magenta>给系统调度一个匿名线程</c>

00:32:01.622 --> 00:32:04.825 align:middle line:0
<c.magenta>并且那个匿名线程必须要做的决心</c>

00:32:04.892 --> 00:32:06.927 align:middle line:0
<c.magenta>稍后会在你应用内部发生</c>

00:32:08.262 --> 00:32:12.933 align:middle line:0
<c.magenta>在这种情况下 我们进行了修改</c>
<c.magenta>我们要做的是创建我们的计数器对象</c>

00:32:13.100 --> 00:32:16.136 align:middle line:0
<c.magenta>绑定到你的队列的统一队列身份</c>

00:32:16.336 --> 00:32:19.173 align:middle line:0
<c.magenta>恰好要在内核中代表你的队列</c>

00:32:20.073 --> 00:32:22.676 align:middle line:0
<c.magenta>我们可以给那个对象绑定</c>
<c.magenta>执行工作所需要的等级</c>

00:32:22.743 --> 00:32:24.678 align:middle line:0
<c.magenta>那么在这里就是备份</c>

00:32:25.746 --> 00:32:28.182 align:middle line:0
<c.magenta>那会导致系统请求线程</c>

00:32:28.849 --> 00:32:32.386 align:middle line:0
<c.magenta>线程请求 就是幻灯片上的虚线</c>

00:32:32.586 --> 00:32:36.990 align:middle line:0
<c.magenta>有时可能不会实现</c>
<c.magenta>因为这里有一个后台线程</c>

00:32:37.224 --> 00:32:38.692 align:middle line:0
<c.magenta>也许系统已加载了足够多</c>

00:32:38.759 --> 00:32:41.195 align:middle line:0
<c.magenta>甚至不值得再提供给你一个线程</c>

00:32:43.897 --> 00:32:45.933 align:middle line:0
<c.magenta>稍后你应用的其它路径</c>

00:32:46.099 --> 00:32:49.269 align:middle line:0
<c.magenta>可能实际上会尝试让更多工作排队</c>

00:32:49.336 --> 00:32:52.472 align:middle line:0
<c.magenta>这里有一个UT[听不清]项</c>
<c.magenta>优先级稍高</c>

00:32:54.007 --> 00:32:57.845 align:middle line:0
<c.magenta>我们可以使用队列身份</c>
<c.magenta>内核中的统一身份</c>

00:32:57.911 --> 00:32:59.279 align:middle line:0
<c.magenta>来查看和解决优先级倒置问题</c>

00:32:59.346 --> 00:33:01.381 align:middle line:0
<c.magenta>并利用那个线程请求的优先级</c>

00:32:59.346 --> 00:33:01.381 align:middle line:0
<c.magenta>并利用那个线程请求的优先级</c>

00:33:01.915 --> 00:33:05.586 align:middle line:0
<c.magenta>也许那就是系统所需要的小的推进</c>

00:33:05.652 --> 00:33:07.421 align:middle line:0
<c.magenta>要在此给你一个线程来执行你的工作</c>

00:33:08.021 --> 00:33:11.525 align:middle line:0
<c.magenta>但这个线程是排程器中的队列</c>
<c.magenta>目前并不是听候调用 也不会执行</c>

00:33:11.925 --> 00:33:14.962 align:middle line:-1
<c.magenta>原因是你的应用中有另一个线程</c>

00:33:15.028 --> 00:33:17.464 align:middle line:-1
<c.magenta>与队列交互并同步工作</c>

00:33:17.531 --> 00:33:19.733 align:middle line:-1
<c.magenta>以较高的优先级 甚至通常会被遮住</c>

00:33:21.768 --> 00:33:24.538 align:middle line:-2
<c.magenta>现在我们有了那个统一队列身份</c>
<c.magenta>我们实际上可以</c>

00:33:24.738 --> 00:33:27.674 align:middle line:-1
<c.magenta>因为那个线程必须阻塞占位符的排队</c>

00:33:27.741 --> 00:33:33.547 align:middle line:-2
<c.magenta>这是Daniel之前刚跟你们谈过的</c>
<c.magenta>我们可以阻塞</c>

00:33:33.614 --> 00:33:35.649 align:middle line:-1
<c.magenta>那个线程在统一队列身份上的同步执行</c>

00:33:35.716 --> 00:33:37.651 align:middle line:-1
<c.magenta>对于异步工作我们采取了同样的方式</c>

00:33:37.718 --> 00:33:39.319 align:middle line:-1
<c.magenta>[听不清]</c>

00:33:39.486 --> 00:33:41.822 align:middle line:-2
<c.magenta>但现在我们以单一身份</c>
<c.magenta>统一了队列的异步</c>

00:33:41.889 --> 00:33:45.459 align:middle line:-1
<c.magenta>和同步部分</c>

00:33:45.626 --> 00:33:48.962 align:middle line:-1
<c.magenta>我们可以应用一个优化 并直接切换</c>

00:33:49.029 --> 00:33:51.865 align:middle line:-1
<c.magenta>阻塞你通过排程器队列的线程</c>

00:33:51.932 --> 00:33:55.002 align:middle line:-1
<c.magenta>并注册队列延迟 就是Daniel在最开始</c>

00:33:55.068 --> 00:33:57.237 align:middle line:-1
<c.magenta>讲到排程器时跟大家介绍的</c>

00:33:58.105 --> 00:34:00.073 align:middle line:-1
<c.magenta>那么这就是统一队列身份</c>

00:33:58.105 --> 00:34:00.073 align:middle line:-1
<c.magenta>那么这就是统一队列身份</c>

00:34:00.140 --> 00:34:02.910 align:middle line:-1
<c.magenta>处理异步和同步工作项的方式</c>

00:34:05.412 --> 00:34:09.049 align:middle line:-2
<c.magenta>现在我们如何把它用在事件上？</c>
<c.magenta>为什么有用呢？</c>

00:34:09.850 --> 00:34:12.886 align:middle line:-1
<c.magenta>那么这是我们一直在用的小树形图</c>

00:34:13.320 --> 00:34:16.056 align:middle line:-1
<c.magenta>让我们看看这些源的创建</c>

00:34:17.357 --> 00:34:20.092 align:middle line:-2
<c.magenta>当你用makeResource工厂按钮</c>
<c.magenta>创建源时</c>

00:34:20.726 --> 00:34:24.031 align:middle line:-2
<c.magenta>你就设置了一堆事件</c>
<c.magenta>分别有适当的处理器和属性</c>

00:34:24.464 --> 00:34:27.634 align:middle line:-2
<c.magenta>但有意思的是当你激活对象时</c>
<c.magenta>会发生什么</c>

00:34:29.770 --> 00:34:34.641 align:middle line:-2
<c.magenta>就在那时我们才意识到</c>
<c.magenta>那个效用就是QOS</c>

00:34:34.708 --> 00:34:37.277 align:middle line:-2
<c.magenta>你的源将在那个QOS上</c>
<c.magenta>一直执行处理器</c>

00:34:37.511 --> 00:34:39.545 align:middle line:0
<c.magenta>因为它是从你的队列等级中继承来的</c>

00:34:40.112 --> 00:34:43.217 align:middle line:0
<c.magenta>我们现在还知道通过新系统</c>

00:34:43.449 --> 00:34:46.286 align:middle line:0
<c.magenta>处理器最终会</c>

00:34:46.353 --> 00:34:49.922 align:middle line:0
<c.magenta>在队列执行互斥情境中执行</c>

00:34:50.824 --> 00:34:53.726 align:middle line:0
<c.magenta>现在将会在前端注册源</c>

00:34:53.793 --> 00:34:57.531 align:middle line:0
<c.magenta>通过我稍早之前谈到过的同步统一身份</c>

00:34:59.600 --> 00:35:04.638 align:middle line:0
<c.magenta>如果我们看一下树形图上</c>
<c.magenta>较高等级的UI QOS源</c>

00:34:59.600 --> 00:35:04.638 align:middle line:0
<c.magenta>如果我们看一下树形图上</c>
<c.magenta>较高等级的UI QOS源</c>

00:35:05.138 --> 00:35:08.308 align:middle line:0
<c.magenta>我们的创建方式与第一个十分相似</c>

00:35:08.809 --> 00:35:11.044 align:middle line:0
<c.magenta>除了当你设置处理器时</c>

00:35:11.111 --> 00:35:14.414 align:middle line:0
<c.magenta>要指定你想要的QOS</c>

00:35:15.382 --> 00:35:18.085 align:middle line:0
<c.magenta>有意思的是在激活状态时</c>
<c.magenta>所发生的情况</c>

00:35:18.151 --> 00:35:20.187 align:middle line:0
<c.magenta>这是我们在快照中时</c>

00:35:20.354 --> 00:35:24.157 align:middle line:0
<c.magenta>和以前一样 当我们从你的等级</c>
<c.magenta>获取统一QOS之后</c>

00:35:24.424 --> 00:35:26.126 align:middle line:0
<c.magenta>在这里我们从你的暗示中获取它</c>

00:35:26.793 --> 00:35:30.030 align:middle line:0
<c.magenta>我们回想一下 它们将在</c>

00:35:30.097 --> 00:35:31.765 align:middle line:-1
<c.magenta>同一个执行情境中执行两个源</c>

00:35:31.832 --> 00:35:34.468 align:middle line:-1
<c.magenta>并将第二个源再次注册到最前面</c>

00:35:34.635 --> 00:35:36.770 align:middle line:-1
<c.magenta>第二个源在内核中有统一身份</c>

00:35:39.506 --> 00:35:45.045 align:middle line:-2
<c.magenta>那么我们尝试要做的是</c>
<c.magenta>通过非常复杂的身份解决</c>

00:35:45.279 --> 00:35:49.016 align:middle line:-2
<c.magenta>的是一个我们在OS之前的阶段</c>
<c.magenta>存在的一个问题</c>

00:35:49.216 --> 00:35:53.453 align:middle line:-1
<c.magenta>相关运作会脱离老线程</c>

00:35:53.620 --> 00:35:55.355 align:middle line:-1
<c.magenta>让我们看看它通常是如何运作的</c>

00:35:56.089 --> 00:35:59.159 align:middle line:-1
<c.magenta>那么请记住这是我们的队列等级</c>

00:36:00.394 --> 00:36:01.929 align:middle line:-1
<c.magenta>让我们打开你在本次演讲中</c>

00:36:01.995 --> 00:36:05.132 align:middle line:-1
<c.magenta>多次看到过的时间轴</c>

00:36:05.632 --> 00:36:08.402 align:middle line:-1
<c.magenta>顶部是CPU 但现在有一个新追踪</c>

00:36:08.468 --> 00:36:12.439 align:middle line:-1
<c.magenta>执行队列卡将表示</c>

00:36:12.506 --> 00:36:14.608 align:middle line:-1
<c.magenta>在任意时刻该队列上正在执行什么</c>

00:36:16.109 --> 00:36:18.712 align:middle line:-1
<c.magenta>那么这是运行时间真正的运作方式</c>

00:36:18.779 --> 00:36:22.349 align:middle line:-2
<c.magenta>在我们进入macOS Sierra</c>
<c.magenta>和iOS 10之前的阶段</c>

00:36:23.016 --> 00:36:25.953 align:middle line:-2
<c.magenta>那么让我们看看如果第一个源</c>
<c.magenta>失败了会发生什么</c>

00:36:26.620 --> 00:36:29.323 align:middle line:-1
<c.magenta>正如我所说的 之前线程请求是异步的</c>

00:36:29.389 --> 00:36:32.459 align:middle line:-2
<c.magenta>我们会请求一个异步线程</c>
<c.magenta>在线程上提交事件</c>

00:36:32.626 --> 00:36:34.127 align:middle line:-1
<c.magenta>然后我们会查看事件</c>

00:36:35.395 --> 00:36:38.031 align:middle line:-1
<c.magenta>当我们在应用内查看事件时</c>

00:36:38.098 --> 00:36:42.536 align:middle line:-2
<c.magenta>我们才会意识到这个事件</c>
<c.magenta>必须要在队列上运行</c>

00:36:42.603 --> 00:36:44.271 align:middle line:-1
<c.magenta>然后我们会在让事件处理器排队</c>

00:36:46.039 --> 00:36:47.574 align:middle line:-1
<c.magenta>但因为队列是未经声明的队列</c>

00:36:47.641 --> 00:36:50.511 align:middle line:-1
<c.magenta>线程实际上可以变成那个队列</c>

00:36:50.577 --> 00:36:53.680 align:middle line:-1
<c.magenta>并开始为那个源执行指定的处理器</c>

00:36:54.314 --> 00:36:55.249 align:middle line:-1
<c.magenta>我们会这么做</c>

00:36:55.849 --> 00:36:57.551 align:middle line:-1
<c.magenta>现在有意思的是</c>

00:36:57.618 --> 00:36:59.887 align:middle line:-2
<c.magenta>当触发优先级较高的第二个源时</c>
<c.magenta>会怎么样？</c>

00:37:00.721 --> 00:37:01.622 align:middle line:-1
<c.magenta>实际上情况一模一样</c>

00:37:02.122 --> 00:37:03.724 align:middle line:-1
<c.magenta>因为它在这里是一个等级QOS</c>

00:37:03.891 --> 00:37:06.226 align:middle line:-1
<c.magenta>优先级较高 这就是你现在正在执行的</c>

00:37:07.427 --> 00:37:09.396 align:middle line:-1
<c.magenta>我们会打开一个新的异步线程</c>

00:37:09.463 --> 00:37:11.431 align:middle line:-1
<c.magenta>在线程上提交那个优先级较高的事件</c>

00:37:13.200 --> 00:37:14.968 align:middle line:-1
<c.magenta>并查看那个事件是什么意思</c>

00:37:15.035 --> 00:37:18.105 align:middle line:-2
<c.magenta>直到那时我们才注意到</c>
<c.magenta>那是同一个一模一样的队列等级</c>

00:37:18.172 --> 00:37:20.941 align:middle line:-2
<c.magenta>然后把处理器排在我们</c>
<c.magenta>预先占用的处理器之后</c>

00:37:21.608 --> 00:37:24.178 align:middle line:-2
<c.magenta>正如你所看到的</c>
<c.magenta>我们关闭了第一个情境切换</c>

00:37:24.711 --> 00:37:26.547 align:middle line:-1
<c.magenta>就是那个优先级较高的事件的情境</c>

00:37:27.147 --> 00:37:30.017 align:middle line:-2
<c.magenta>但我们不能促进进展</c>
<c.magenta>因为跟第一次不同</c>

00:37:30.083 --> 00:37:31.952 align:middle line:-1
<c.magenta>第二个线程不能接受</c>

00:37:32.019 --> 00:37:33.887 align:middle line:-1
<c.magenta>已经与某个线程相关联的队列</c>

00:37:33.954 --> 00:37:34.922 align:middle line:-1
<c.magenta>我们不能接受它</c>

00:37:35.489 --> 00:37:36.456 align:middle line:-1
<c.magenta>那么线程就结束了</c>

00:37:36.523 --> 00:37:40.227 align:middle line:-2
<c.magenta>正如Daniel所阐述过的</c>
<c.magenta>这就是你再次切换情境的原因之一</c>

00:37:40.761 --> 00:37:43.030 align:middle line:-2
<c.magenta>这是我们所做的工作</c>
<c.magenta>我们把情境切换回第一个线程</c>

00:37:43.096 --> 00:37:44.831 align:middle line:0
<c.magenta>就是实际上取得进展的那个</c>

00:37:44.898 --> 00:37:48.869 align:middle line:0
<c.magenta>我们执行第一个处理器余下的部分</c>
<c.magenta>并最终执行第二个处理器</c>

00:37:50.504 --> 00:37:51.738 align:middle line:0
<c.magenta>那么正如你所看到的</c>

00:37:51.805 --> 00:37:54.208 align:middle line:0
<c.magenta>我们使用两个线程和两次情境切换</c>

00:37:54.274 --> 00:37:57.110 align:middle line:0
<c.magenta>你实际上不想针对一个</c>
<c.magenta>单一执行情境这样做</c>

00:37:58.679 --> 00:38:04.818 align:middle line:0
<c.magenta>我们在macOS High Sierra和iOS 11中</c>
<c.magenta>用统一身份修复了那个问题</c>

00:37:58.679 --> 00:38:04.818 align:middle line:0
<c.magenta>我们在macOS High Sierra和iOS 11中</c>
<c.magenta>用统一身份修复了那个问题</c>

00:38:05.819 --> 00:38:07.154 align:middle line:0
<c.magenta>我们摆脱了那个线程</c>

00:38:08.622 --> 00:38:09.523 align:middle line:0
<c.magenta>[听不清]</c>

00:38:10.157 --> 00:38:15.262 align:middle line:0
<c.magenta>当然了 我们还摆脱了</c>
<c.magenta>以前的那两次情境切换</c>

00:38:15.329 --> 00:38:16.663 align:middle line:0
<c.magenta>那是多余的</c>

00:38:17.664 --> 00:38:19.299 align:middle line:0
<c.magenta>这当然很重要 因为</c>

00:38:19.733 --> 00:38:22.069 align:middle line:0
<c.magenta>跟Daniel通过那个触摸事件给你展示</c>

00:38:22.135 --> 00:38:25.539 align:middle line:0
<c.magenta>占先及优先级时所发生的不一样</c>

00:38:26.106 --> 00:38:30.344 align:middle line:-2
<c.magenta>我们可以利用</c>
<c.magenta>我们实际有两个线程的事实</c>

00:38:30.410 --> 00:38:33.347 align:middle line:-1
<c.magenta>相对独立并且响应性更强</c>

00:38:33.614 --> 00:38:36.283 align:middle line:-1
<c.magenta>在这里我们没有从任何情境切换中受益</c>

00:38:36.550 --> 00:38:41.054 align:middle line:-2
<c.magenta>因为这些事件处理器</c>
<c.magenta>不管怎样S1和M2必须得按顺序执行</c>

00:38:41.121 --> 00:38:43.490 align:middle line:-2
<c.magenta>那么提前知道那个事件</c>
<c.magenta>并不会有什么帮助</c>

00:38:44.858 --> 00:38:48.695 align:middle line:-1
<c.magenta>如果你看一下…今天的流程</c>

00:38:48.762 --> 00:38:49.963 align:middle line:-1
<c.magenta>看起来更应该是这样的</c>

00:38:52.199 --> 00:38:53.500 align:middle line:-1
<c.magenta>这里发生了什么？</c>

00:38:55.202 --> 00:38:57.104 align:middle line:-1
<c.magenta>那个流程中最重要的事</c>

00:38:57.171 --> 00:39:00.307 align:middle line:-1
<c.magenta>就是现在如果你查看线程 它叫作EQ</c>

00:38:57.171 --> 00:39:00.307 align:middle line:-1
<c.magenta>就是现在如果你查看线程 它叫作EQ</c>

00:39:00.374 --> 00:39:02.442 align:middle line:-1
<c.magenta>因为它是统一身份的一个部分</c>

00:39:02.509 --> 00:39:04.978 align:middle line:-1
<c.magenta>线程和EQ从根本上说是同一个对象</c>

00:39:05.312 --> 00:39:08.182 align:middle line:-1
<c.magenta>而内核知道它其实正在执行队列</c>

00:39:08.248 --> 00:39:10.851 align:middle line:-2
<c.magenta>在CPU标签上反映出来了</c>
<c.magenta>你再也看不到事件了</c>

00:39:10.918 --> 00:39:12.286 align:middle line:-1
<c.magenta>那就会运行你的队列</c>

00:39:14.488 --> 00:39:19.393 align:middle line:-2
<c.magenta>然而你可能会问</c>
<c.magenta>我们该如何设法提交事件呢</c>

00:39:19.459 --> 00:39:21.795 align:middle line:-1
<c.magenta>提交第二个事件而不需要帮手</c>

00:39:21.862 --> 00:39:23.363 align:middle line:-1
<c.magenta>这是个好问题</c>

00:39:25.432 --> 00:39:28.702 align:middle line:-2
<c.magenta>当事件被触发时</c>
<c.magenta>现在我们知道它会在哪儿执行</c>

00:39:28.769 --> 00:39:29.937 align:middle line:-1
<c.magenta>你会在哪儿处理它</c>

00:39:30.337 --> 00:39:31.672 align:middle line:-1
<c.magenta>我们只需要标记线程</c>

00:39:32.472 --> 00:39:33.407 align:middle line:-1
<c.magenta>不需要帮手</c>

00:39:34.241 --> 00:39:38.278 align:middle line:-1
<c.magenta>在第一个可能的时间</c>

00:39:38.979 --> 00:39:42.349 align:middle line:-2
<c.magenta>我们就会注意到那个线程被你标记了</c>
<c.magenta>有待定的事件</c>

00:39:42.950 --> 00:39:45.652 align:middle line:-1
<c.magenta>当我们让事件出列时需要隐藏时间</c>

00:39:46.153 --> 00:39:48.255 align:middle line:-1
<c.magenta>藏在第一个处理器结束之后</c>

00:39:48.689 --> 00:39:51.191 align:middle line:-1
<c.magenta>我们可以从内核中获取事件并查看</c>

00:39:51.258 --> 00:39:53.827 align:middle line:-2
<c.magenta>然后把它们的处理器</c>
<c.magenta>排在你的等级队列中</c>

00:39:55.829 --> 00:39:59.032 align:middle line:-2
<c.magenta>那么我们为什么</c>
<c.magenta>要给出这么复杂的解释呢？</c>

00:39:59.867 --> 00:40:01.301 align:middle line:-1
<c.magenta>原因是你</c>

00:39:59.867 --> 00:40:01.301 align:middle line:-1
<c.magenta>原因是你</c>

00:40:01.635 --> 00:40:06.573 align:middle line:-2
<c.magenta>这样可以理解如何最好地利用</c>
<c.magenta>运行时间行为 因为很清楚</c>

00:40:06.640 --> 00:40:09.843 align:middle line:-2
<c.magenta>运行时间使用了</c>
<c.magenta>你提供给我们的每一个可能的暗示</c>

00:40:09.910 --> 00:40:12.012 align:middle line:-1
<c.magenta>在你的应用中优化行为</c>

00:40:13.213 --> 00:40:15.482 align:middle line:-1
<c.magenta>并且进入按钮知道如何暗示</c>

00:40:15.549 --> 00:40:19.887 align:middle line:-2
<c.magenta>以及何时正确地暗示运行时间</c>
<c.magenta>因此我们就做除了正确的决策</c>

00:40:21.955 --> 00:40:25.993 align:middle line:-2
<c.magenta>这就导致我今天跟大家讲</c>
<c.magenta>你们应该如何处理现有代码基</c>

00:40:26.059 --> 00:40:29.997 align:middle line:-2
<c.magenta>以最大限度地利用</c>
<c.magenta>我们重新创建的内核技术</c>

00:40:33.166 --> 00:40:35.369 align:middle line:-1
<c.magenta>现在实际上只需要两个步骤</c>

00:40:35.802 --> 00:40:38.872 align:middle line:-1
<c.magenta>就可以充分利用那个技术了</c>

00:40:38.939 --> 00:40:42.142 align:middle line:-1
<c.magenta>第一个步骤是在激活后没有变化</c>

00:40:42.676 --> 00:40:45.279 align:middle line:-1
<c.magenta>第二个步骤是特别关注</c>

00:40:45.345 --> 00:40:48.115 align:middle line:-1
<c.magenta>目标队列等级</c>

00:40:49.116 --> 00:40:50.117 align:middle line:-1
<c.magenta>那么这是什么意思？</c>

00:40:51.251 --> 00:40:53.887 align:middle line:-1
<c.magenta>没有变化越过激活其实是说</c>

00:40:53.954 --> 00:40:57.724 align:middle line:-2
<c.magenta>当你在调度对象上有任意属性时</c>
<c.magenta>你可以发送它们</c>

00:40:57.791 --> 00:41:01.161 align:middle line:-2
<c.magenta>一旦你激活对象</c>
<c.magenta>你就应该停止改变它们</c>

00:40:57.791 --> 00:41:01.161 align:middle line:-2
<c.magenta>一旦你激活对象</c>
<c.magenta>你就应该停止改变它们</c>

00:41:01.628 --> 00:41:02.796 align:middle line:-1
<c.magenta>第二个例子</c>

00:41:04.398 --> 00:41:07.634 align:middle line:-2
<c.magenta>这是我们在本场演讲中</c>
<c.magenta>看到过多次的源</c>

00:41:08.335 --> 00:41:10.671 align:middle line:-1
<c.magenta>那个[听不清]能力</c>

00:41:11.772 --> 00:41:14.074 align:middle line:-1
<c.magenta>并且你会设置一堆属性、处理器；</c>

00:41:14.141 --> 00:41:17.544 align:middle line:-2
<c.magenta>事件处理器、同意处理器</c>
<c.magenta>你可能还有注册处理器</c>

00:41:18.178 --> 00:41:21.481 align:middle line:-2
<c.magenta>你甚至可以修改几次 这没问题</c>
<c.magenta>你可以改变主意</c>

00:41:22.983 --> 00:41:24.351 align:middle line:-1
<c.magenta>当你激活源时</c>

00:41:26.353 --> 00:41:29.556 align:middle line:0
<c.magenta>这里的联系是你应该停止改变你的对象</c>

00:41:30.257 --> 00:41:31.391 align:middle line:0
<c.magenta>诱惑力很大</c>

00:41:31.692 --> 00:41:34.294 align:middle line:0
<c.magenta>事后 比如说修改源的目标队列</c>

00:41:34.361 --> 00:41:35.462 align:middle line:0
<c.magenta>那将会导致问题</c>

00:41:35.796 --> 00:41:38.732 align:middle line:0
<c.magenta>原因就是我早些时候所展示过的</c>

00:41:38.799 --> 00:41:42.603 align:middle line:0
<c.magenta>在激活时</c>
<c.magenta>我们会给你对象的属性生成快照</c>

00:41:42.669 --> 00:41:45.606 align:middle line:0
<c.magenta>将来我们将按照那个快照做出决策</c>

00:41:46.907 --> 00:41:50.377 align:middle line:-1
<c.magenta>如果你在事后修改了目标队列等级</c>

00:41:50.444 --> 00:41:53.447 align:middle line:-1
<c.magenta>它会阻碍那个快照 使其失效</c>

00:41:53.514 --> 00:41:56.250 align:middle line:-1
<c.magenta>那将会导致一些列非常重要的优化失败</c>

00:41:56.316 --> 00:41:59.653 align:middle line:-1
<c.magenta>比如优先级倒置避免[听不清]GCD</c>

00:41:59.720 --> 00:42:02.556 align:middle line:-1
<c.magenta>我之前展示的</c>

00:41:59.720 --> 00:42:02.556 align:middle line:-1
<c.magenta>我之前展示的</c>

00:42:02.623 --> 00:42:04.024 align:middle line:-1
<c.magenta>同步调度的直接切换</c>

00:42:04.091 --> 00:42:08.061 align:middle line:-2
<c.magenta>这些都是我们刚刚看过的防御型</c>
<c.magenta>和可交付的优化</c>

00:42:10.564 --> 00:42:11.398 align:middle line:-1
<c.magenta>我会坚持</c>

00:42:11.465 --> 00:42:14.635 align:middle line:-1
<c.magenta>Daniel之前的观点</c>

00:42:15.235 --> 00:42:19.139 align:middle line:-2
<c.magenta>就是你们中有许多人可能从来不需要</c>
<c.magenta>在你们的应用中创建一个调度源</c>

00:42:19.206 --> 00:42:21.408 align:middle line:-1
<c.magenta>这没问题 这就是它的运作方式</c>

00:42:22.242 --> 00:42:26.413 align:middle line:-2
<c.magenta>你实际上很可能在系统框架中</c>
<c.magenta>大量使用它们</c>

00:42:26.480 --> 00:42:30.484 align:middle line:-2
<c.magenta>每次你有框架时 你就会调度队列</c>
<c.magenta>因为</c>

00:42:30.551 --> 00:42:34.655 align:middle line:-2
<c.magenta>它们会以你的名义在队列上</c>
<c.magenta>异步处理一些通知</c>

00:42:34.721 --> 00:42:36.890 align:middle line:-1
<c.magenta>在底层 它们拥有其中一个源</c>

00:42:37.224 --> 00:42:40.694 align:middle line:-2
<c.magenta>那么如果你修改了系统的假设</c>
<c.magenta>你实际上也会打断</c>

00:42:41.562 --> 00:42:43.463 align:middle line:-1
<c.magenta>全部这些</c>

00:42:43.530 --> 00:42:44.364 align:middle line:-1
<c.magenta>优化</c>

00:42:46.533 --> 00:42:50.804 align:middle line:-2
<c.magenta>那么我希望很清楚地表达了一点</c>
<c.magenta>把你的等级作为目标</c>

00:42:50.871 --> 00:42:53.373 align:middle line:-1
<c.magenta>非常重要 你必须保护它</c>

00:42:54.641 --> 00:42:57.511 align:middle line:-1
<c.magenta>这是什么意思？需要怎么做？</c>

00:42:58.745 --> 00:43:00.848 align:middle line:-1
<c.magenta>第一种方式是一个很简单的建议</c>

00:42:58.745 --> 00:43:00.848 align:middle line:-1
<c.magenta>第一种方式是一个很简单的建议</c>

00:43:00.914 --> 00:43:02.583 align:middle line:-1
<c.magenta>就是当你创建等级时</c>

00:43:03.250 --> 00:43:06.186 align:middle line:-1
<c.magenta>从底部开始往顶部创建</c>

00:43:07.487 --> 00:43:11.959 align:middle line:-2
<c.magenta>当你看到幻灯片上的这个树形图</c>
<c.magenta>创建好之后 正如你所看到的</c>

00:43:12.025 --> 00:43:15.529 align:middle line:-2
<c.magenta>那儿有一些很宽的窟窿</c>
<c.magenta>那就是你的目标队列关系</c>

00:43:15.762 --> 00:43:18.398 align:middle line:-2
<c.magenta>如果你按那个顺序创建</c>
<c.magenta>哪个也不会被改变</c>

00:43:20.467 --> 00:43:21.368 align:middle line:-1
<c.magenta>然而</c>

00:43:21.435 --> 00:43:25.005 align:middle line:-1
<c.magenta>当你有一个很大的应用或当你隐藏框架</c>

00:43:25.072 --> 00:43:28.242 align:middle line:-1
<c.magenta>并把其中一个队列传给</c>

00:43:29.209 --> 00:43:33.881 align:middle line:-2
<c.magenta>你们公司的另一个团队时</c>
<c.magenta>你可能更希望得到较多的保证</c>

00:43:34.248 --> 00:43:36.083 align:middle line:-1
<c.magenta>你可能想锁定这些关系</c>

00:43:36.149 --> 00:43:38.619 align:middle line:-1
<c.magenta>以便没有任何人可以在事后改变它们</c>

00:43:40.787 --> 00:43:42.389 align:middle line:-1
<c.magenta>实际上你可以</c>

00:43:42.456 --> 00:43:45.359 align:middle line:-2
<c.magenta>通过我们的一种叫作</c>
<c.magenta>设置队列等级的技术实现</c>

00:43:45.425 --> 00:43:49.730 align:middle line:-2
<c.magenta>我们去年引入了这种技术</c>
<c.magenta>实际上如果你正在使用Swift 3</c>

00:43:49.796 --> 00:43:51.164 align:middle line:-1
<c.magenta>你就可以停下来听我讲</c>

00:43:51.231 --> 00:43:54.067 align:middle line:-2
<c.magenta>因为你已经在那种形式中了</c>
<c.magenta>那是你正在生存的唯一的世界</c>

00:43:55.602 --> 00:43:58.939 align:middle line:-2
<c.magenta>然而如果你有一个现有的基于云的应用</c>
<c.magenta>或你用的是Swift的较老版本</c>

00:43:59.006 --> 00:44:02.609 align:middle line:-1
<c.magenta>你需要一些额外的步骤</c>

00:43:59.006 --> 00:44:02.609 align:middle line:-1
<c.magenta>你需要一些额外的步骤</c>

00:44:05.812 --> 00:44:08.815 align:middle line:-2
<c.magenta>那么让我们重点看一下</c>
<c.magenta>Q1和EQ之间的关系</c>

00:44:09.783 --> 00:44:15.022 align:middle line:-2
<c.magenta>当你用Objective-C创建时</c>
<c.magenta>你的代码很可能会是这样的</c>

00:44:15.422 --> 00:44:18.158 align:middle line:-1
<c.magenta>你创建你的队列 然后第二步</c>

00:44:18.225 --> 00:44:21.528 align:middle line:-1
<c.magenta>把Q1的目标队列设置为EQ</c>

00:44:22.162 --> 00:44:24.498 align:middle line:-1
<c.magenta>这并不会保护你的队列等级</c>

00:44:24.565 --> 00:44:27.467 align:middle line:-1
<c.magenta>任何人都可以再次调用调度目标队列</c>

00:44:27.534 --> 00:44:28.836 align:middle line:-1
<c.magenta>并打乱你的全部假设</c>

00:44:29.069 --> 00:44:30.137 align:middle line:-1
<c.magenta>这可不妙</c>

00:44:30.904 --> 00:44:32.940 align:middle line:-1
<c.magenta>有一个简单的步骤可以</c>

00:44:33.006 --> 00:44:34.908 align:middle line:-1
<c.magenta>修复那段代码让它变得安全</c>

00:44:35.309 --> 00:44:38.612 align:middle line:-1
<c.magenta>就是采用我们去年引入的一个新API</c>

00:44:38.679 --> 00:44:40.981 align:middle line:-1
<c.magenta>即用调度目标队列的创建</c>

00:44:41.048 --> 00:44:43.283 align:middle line:-1
<c.magenta>这是一个单一的自动化步骤</c>

00:44:43.350 --> 00:44:48.121 align:middle line:-2
<c.magenta>将创建队列</c>
<c.magenta>设置队列等级高度并保护它</c>

00:44:49.823 --> 00:44:51.491 align:middle line:-1
<c.magenta>就是这样 这就是这两个步骤</c>

00:44:51.558 --> 00:44:53.427 align:middle line:-1
<c.magenta>通过这两个步骤你可以</c>

00:44:53.493 --> 00:44:55.395 align:middle line:-1
<c.magenta>很好地[听不清] 非常简单</c>

00:44:56.897 --> 00:45:01.535 align:middle line:-2
<c.magenta>另外 与Daniel刚才给你们演示的</c>
<c.magenta>那个突变的例子有点类似</c>

00:44:56.897 --> 00:45:01.535 align:middle line:-2
<c.magenta>另外 与Daniel刚才给你们演示的</c>
<c.magenta>那个突变的例子有点类似</c>

00:45:01.835 --> 00:45:04.671 align:middle line:-1
<c.magenta>寻找何时做出了错误的决定</c>

00:45:04.738 --> 00:45:07.574 align:middle line:-2
<c.magenta>非常具有挑战性</c>
<c.magenta>尤其是在大的基于云的应用上</c>

00:45:07.641 --> 00:45:11.445 align:middle line:-2
<c.magenta>我们发现在现有的基于云的应用中</c>
<c.magenta>检验全部代码是非常困难的</c>

00:45:12.346 --> 00:45:16.450 align:middle line:-2
<c.magenta>这也就是我们为什么</c>
<c.magenta>创建一个新GCD性能仪表工具</c>

00:45:16.517 --> 00:45:19.419 align:middle line:-1
<c.magenta>来寻找现有应用中的问题点的原因</c>

00:45:19.987 --> 00:45:22.523 align:middle line:-2
<c.magenta>我将把舞台交换给Daniel</c>
<c.magenta>他会给你们做演示</c>

00:45:29.363 --> 00:45:30.197 align:middle line:-1
<c.magenta>谢谢Pierre</c>

00:45:31.665 --> 00:45:32.766 align:middle line:-1
<c.magenta>好的 让我们开始吧</c>

00:45:32.833 --> 00:45:35.969 align:middle line:-2
<c.magenta>请注意我们即将看到的这个</c>
<c.magenta>GCD性能仪表</c>

00:45:36.036 --> 00:45:38.672 align:middle line:-1
<c.magenta>目前Xcode 9中还没有</c>

00:45:38.739 --> 00:45:42.176 align:middle line:-2
<c.magenta>但你们很快就能用了</c>
<c.magenta>我们即将发布Xcode 9的种子</c>

00:45:43.277 --> 00:45:44.244 align:middle line:-1
<c.magenta>那么对于这个演示</c>

00:45:44.311 --> 00:45:47.714 align:middle line:-2
<c.magenta>让我们具体分析一下</c>
<c.magenta>我们的示例新闻应用的执行</c>

00:45:48.582 --> 00:45:50.584 align:middle line:-2
<c.magenta>如果你点击底部的这个</c>
<c.magenta>连接按钮会发生什么呢</c>

00:45:50.651 --> 00:45:54.388 align:middle line:-2
<c.magenta>这个应用会向服务器</c>
<c.magenta>创建若干网络连接吗</c>

00:45:54.454 --> 00:45:57.224 align:middle line:-1
<c.magenta>以便读取URL列表</c>

00:45:57.291 --> 00:46:00.394 align:middle line:-2
<c.magenta>然后就显示在WebViews中</c>
<c.magenta>无论何时点击刷新按钮时</c>

00:45:57.291 --> 00:46:00.394 align:middle line:-2
<c.magenta>然后就显示在WebViews中</c>
<c.magenta>无论何时点击刷新按钮时</c>

00:46:01.161 --> 00:46:04.565 align:middle line:-2
<c.magenta>那么让我们深入Xcode查看</c>
<c.magenta>我们是如何设置这些网络连接的</c>

00:46:06.133 --> 00:46:10.971 align:middle line:-1
<c.magenta>那么这是Xcode中的创建连接方法</c>

00:46:11.371 --> 00:46:13.140 align:middle line:-1
<c.magenta>非常简单 我们有一个循环</c>

00:46:13.207 --> 00:46:16.543 align:middle line:-2
<c.magenta>也许只是创建一些套接口</c>
<c.magenta>并把它们连接到我们的服务器</c>

00:46:17.277 --> 00:46:21.281 align:middle line:-2
<c.magenta>我们通过其中一个调度读取</c>
<c.magenta>源监控那个套接口的可读性</c>

00:46:21.348 --> 00:46:23.450 align:middle line:-2
<c.magenta>就是我们在本场演讲中</c>
<c.magenta>多次见到的那个源</c>

00:46:23.784 --> 00:46:25.686 align:middle line:-1
<c.magenta>在这里查看API是受信任的</c>

00:46:26.553 --> 00:46:30.290 align:middle line:-2
<c.magenta>然后我们可以为那个调度源</c>
<c.magenta>设置事件处理器代码块</c>

00:46:30.357 --> 00:46:33.227 align:middle line:-1
<c.magenta>当套接口可读时 我们就从中读取</c>

00:46:33.293 --> 00:46:36.029 align:middle line:-1
<c.magenta>通过读取系统调用 直到没有可用数据</c>

00:46:36.763 --> 00:46:40.567 align:middle line:0
<c.magenta>一旦我们有了数据</c>
<c.magenta>我们就把它传给我们的数据库子系统</c>

00:46:40.634 --> 00:46:42.569 align:middle line:0
<c.magenta>通过这个process 0方法</c>

00:46:43.670 --> 00:46:45.873 align:middle line:0
<c.magenta>那么让我们创建并运行</c>
<c.magenta>并执行这个应用的系统追踪</c>

00:46:45.939 --> 00:46:48.242 align:middle line:0
<c.magenta>了解它是如何执行的</c>

00:46:51.044 --> 00:46:53.413 align:middle line:-2
<c.magenta>那么我们在仪表中</c>
<c.magenta>在系统追踪中</c>

00:46:53.480 --> 00:46:55.315 align:middle line:-1
<c.magenta>除了系统追踪中的常见追踪</c>

00:46:55.382 --> 00:46:57.684 align:middle line:-1
<c.magenta>我们还添加了这个新的GCD性能仪表</c>

00:46:58.085 --> 00:47:00.954 align:middle line:-2
<c.magenta>当我们点击它时</c>
<c.magenta>我们可以看到许多性能事件</c>

00:46:58.085 --> 00:47:00.954 align:middle line:-2
<c.magenta>当我们点击它时</c>
<c.magenta>我们可以看到许多性能事件</c>

00:47:01.021 --> 00:47:03.357 align:middle line:-1
<c.magenta>被报告为有性能问题</c>

00:47:03.757 --> 00:47:06.159 align:middle line:-1
<c.magenta>其中一个就是这个激活事件后改变</c>

00:47:06.226 --> 00:47:08.996 align:middle line:-2
<c.magenta>我们还可以看到随着时间轴</c>
<c.magenta>何时数量众多</c>

00:47:09.329 --> 00:47:11.498 align:middle line:-1
<c.magenta>你还可以点击这里的一个事件</c>

00:47:11.565 --> 00:47:13.834 align:middle line:-1
<c.magenta>比如在激活事件之后点击这个改变目标</c>

00:47:14.501 --> 00:47:18.138 align:middle line:-2
<c.magenta>这个列表将会把我们直接带到那儿</c>
<c.magenta>如果你想获取更多详细信息</c>

00:47:18.205 --> 00:47:21.642 align:middle line:-1
<c.magenta>我们可以公开仪表右侧的向后追踪</c>

00:47:21.708 --> 00:47:24.745 align:middle line:-2
<c.magenta>那将会给我们显示这个事件</c>
<c.magenta>具体发生在你应用中的哪个位置</c>

00:47:25.179 --> 00:47:28.215 align:middle line:-2
<c.magenta>那么在这里比如说是</c>
<c.magenta>在我们的创建连接方法中</c>

00:47:29.550 --> 00:47:33.053 align:middle line:-2
<c.magenta>如果我们双击这个框架</c>
<c.magenta>仪表将会直接给我们显示</c>

00:47:33.120 --> 00:47:34.821 align:middle line:-1
<c.magenta>问题所在的代码行</c>

00:47:35.389 --> 00:47:38.959 align:middle line:0
<c.magenta>这是几上是一个目标队列调用</c>
<c.magenta>是在激活事件之后发生的</c>

00:47:39.426 --> 00:47:41.528 align:middle line:0
<c.magenta>就像刚跟你说过的这个模式</c>

00:47:41.795 --> 00:47:44.031 align:middle line:0
<c.magenta>要修复这个问题</c>
<c.magenta>我们可以直接进入Xcode</c>

00:47:44.097 --> 00:47:46.200 align:middle line:0
<c.magenta>用在Xcode中打开文件快捷按钮</c>
<c.magenta>打开文件</c>

00:47:47.167 --> 00:47:49.736 align:middle line:0
<c.magenta>那么在这里</c>
<c.magenta>我们是在调度目标队列代码行</c>

00:47:49.803 --> 00:47:53.140 align:middle line:0
<c.magenta>的确是在这行 在事件处理器有调度源</c>

00:47:53.207 --> 00:47:54.942 align:middle line:0
<c.magenta>设置发生在激活之后</c>

00:47:55.475 --> 00:47:57.678 align:middle line:0
<c.magenta>那么在这个例子中 非常容易修复</c>

00:47:57.744 --> 00:48:01.648 align:middle line:0
<c.magenta>我们只需要把这两行往下挪</c>
<c.magenta>然后就修复了问题</c>

00:47:57.744 --> 00:48:01.648 align:middle line:0
<c.magenta>我们只需要把这两行往下挪</c>
<c.magenta>然后就修复了问题</c>

00:48:01.715 --> 00:48:04.852 align:middle line:0
<c.magenta>我们在设置源之后激活而不是之前</c>

00:48:05.519 --> 00:48:07.254 align:middle line:0
<c.magenta>那么让我们返回仪表并查看</c>

00:48:07.321 --> 00:48:09.556 align:middle line:-1
<c.magenta>我们现在能在系统追踪中看到什么</c>

00:48:09.857 --> 00:48:13.193 align:middle line:-2
<c.magenta>看起来跟以前一样</c>
<c.magenta>除了当你点击GCD性能追踪时</c>

00:48:13.260 --> 00:48:16.496 align:middle line:0
<c.magenta>你将看到没有检测到</c>
<c.magenta>任何严重的性能问题了</c>

00:48:16.797 --> 00:48:18.765 align:middle line:0
<c.magenta>如果你用了这个仪表</c>
<c.magenta>你应该会看到这个结果</c>

00:48:19.566 --> 00:48:22.669 align:middle line:0
<c.magenta>那么当然这对于这个应用来说很简单</c>
<c.magenta>你可能需要做一些工作</c>

00:48:24.571 --> 00:48:26.840 align:middle line:-2
<c.magenta>那么让我们重点看一下</c>
<c.magenta>应用中的点追踪</c>

00:48:26.907 --> 00:48:29.376 align:middle line:-1
<c.magenta>这会给我们显示许多网络事件处理器</c>

00:48:29.810 --> 00:48:32.179 align:middle line:-1
<c.magenta>这些是我们应用中的源事件处理器</c>

00:48:32.679 --> 00:48:35.015 align:middle line:-2
<c.magenta>那么你要如何设法</c>
<c.magenta>在仪表中显示这些呢？</c>

00:48:35.616 --> 00:48:37.184 align:middle line:-1
<c.magenta>实际上理解起来很有意思</c>

00:48:37.251 --> 00:48:39.720 align:middle line:-2
<c.magenta>因为这是你可以应用到</c>
<c.magenta>你自己的代码中的东西</c>

00:48:39.786 --> 00:48:42.256 align:middle line:-1
<c.magenta>以在仪表中了解它是如何执行的</c>

00:48:43.790 --> 00:48:47.060 align:middle line:-2
<c.magenta>嗯 让我们返回到Xcode</c>
<c.magenta>中的创建连接方法</c>

00:48:47.127 --> 00:48:50.163 align:middle line:0
<c.magenta>当我们设置源及其源事件处理器时</c>

00:48:50.230 --> 00:48:53.000 align:middle line:0
<c.magenta>我们就对那个</c>
<c.magenta>事件处理器的执行感兴趣了</c>

00:48:53.066 --> 00:48:55.102 align:middle line:0
<c.magenta>并尝试了解它的时间安排</c>

00:48:55.502 --> 00:48:56.737 align:middle line:-1
<c.magenta>为了在仪表中看到它</c>

00:48:56.803 --> 00:48:59.806 align:middle line:-2
<c.magenta>我们增加了</c>
<c.magenta>kdebug signpost start函数</c>

00:48:59.873 --> 00:49:01.408 align:middle line:-1
<c.magenta>放在处理器的开始</c>

00:48:59.873 --> 00:49:01.408 align:middle line:-1
<c.magenta>放在处理器的开始</c>

00:49:01.475 --> 00:49:04.111 align:middle line:-2
<c.magenta>以及kdebug signpost end函数</c>
<c.magenta>放在处理器的末端</c>

00:49:04.378 --> 00:49:06.713 align:middle line:0
<c.magenta>这就是它所需要做的工作 让这段代码</c>

00:49:06.780 --> 00:49:10.217 align:middle line:0
<c.magenta>突出显示在仪表系统追踪的点追踪中</c>

00:49:10.951 --> 00:49:12.719 align:middle line:0
<c.magenta>那么如果你切换回仪表</c>

00:49:12.786 --> 00:49:15.756 align:middle line:-1
<c.magenta>就是点追踪顶部的这些红点</c>

00:49:15.822 --> 00:49:19.293 align:middle line:-2
<c.magenta>我们可以看到在向后追踪中</c>
<c.magenta>它把我们的事件处理器</c>

00:49:19.359 --> 00:49:20.661 align:middle line:-1
<c.magenta>与其中一个事件相匹配了</c>

00:49:21.562 --> 00:49:25.599 align:middle line:-2
<c.magenta>如果你放大点追踪中的一个</c>
<c.magenta>有意思的查看区域</c>

00:49:25.666 --> 00:49:28.335 align:middle line:-1
<c.magenta>你可以看到有许多事件处理器</c>

00:49:28.402 --> 00:49:30.938 align:middle line:-1
<c.magenta>非常紧凑地发生</c>

00:49:31.104 --> 00:49:33.640 align:middle line:-2
<c.magenta>鼠标悬浮在其中一个处理器上</c>
<c.magenta>我们实际上可以看到</c>

00:49:33.707 --> 00:49:36.009 align:middle line:-1
<c.magenta>它们只执行了非常短的一段时间</c>

00:49:36.343 --> 00:49:39.813 align:middle line:-1
<c.magenta>弹出会告诉我们它所执行的时间长度</c>

00:49:39.880 --> 00:49:42.716 align:middle line:-2
<c.magenta>我们甚至可以看到</c>
<c.magenta>有时会有重叠的事件处理器</c>

00:49:42.783 --> 00:49:45.619 align:middle line:-1
<c.magenta>同时并发执行</c>

00:49:46.386 --> 00:49:48.121 align:middle line:-1
<c.magenta>那么这是我们应用中的</c>

00:49:48.188 --> 00:49:50.290 align:middle line:-1
<c.magenta>其中一个潜在的不利并行</c>

00:49:50.357 --> 00:49:52.326 align:middle line:-1
<c.magenta>是看起来</c>

00:49:52.392 --> 00:49:54.328 align:middle line:-1
<c.magenta>不会在代码中导致并行的东西</c>

00:49:54.394 --> 00:49:57.998 align:middle line:-2
<c.magenta>但实际上却以并发方式</c>
<c.magenta>运行或多线程运行</c>

00:49:58.065 --> 00:50:00.067 align:middle line:-1
<c.magenta>并导致了潜在的额外情境切换</c>

00:49:58.065 --> 00:50:00.067 align:middle line:-1
<c.magenta>并导致了潜在的额外情境切换</c>

00:50:01.468 --> 00:50:05.239 align:middle line:-2
<c.magenta>那么为了更好地理解</c>
<c.magenta>让我们在仪表中拉动线程</c>

00:50:05.439 --> 00:50:07.674 align:middle line:-1
<c.magenta>以及执行这段代码的系统追踪</c>

00:50:12.579 --> 00:50:14.448 align:middle line:-1
<c.magenta>在这里我已经突出了三个辅助线程</c>

00:50:14.515 --> 00:50:16.149 align:middle line:-1
<c.magenta>就是执行这些事件处理器的辅助线程</c>

00:50:16.483 --> 00:50:20.387 align:middle line:-2
<c.magenta>我们之前可以看到</c>
<c.magenta>它们在这段时间待命执行</c>

00:50:20.921 --> 00:50:22.556 align:middle line:-1
<c.magenta>这也是它们运行的时间</c>

00:50:22.823 --> 00:50:24.892 align:middle line:-1
<c.magenta>但在这里我们可以看到它们再一次</c>

00:50:24.958 --> 00:50:27.761 align:middle line:-1
<c.magenta>在这个区域运行了很短的时间</c>

00:50:27.928 --> 00:50:31.565 align:middle line:-2
<c.magenta>并且我们可以识别它们</c>
<c.magenta>正在发起这些读取系统调用</c>

00:50:31.632 --> 00:50:33.534 align:middle line:-1
<c.magenta>是我们之前在事件处理器中看到的</c>

00:50:34.134 --> 00:50:37.070 align:middle line:-2
<c.magenta>我们可以通过再一次查看</c>
<c.magenta>向后追踪获取更多信息</c>

00:50:37.137 --> 00:50:40.240 align:middle line:-2
<c.magenta>并查看 是的就是我们在</c>
<c.magenta>调用那个读取系统调用</c>

00:50:40.307 --> 00:50:42.376 align:middle line:-2
<c.magenta>且它从我们的套接口中</c>
<c.magenta>读取了97个字节</c>

00:50:44.144 --> 00:50:46.613 align:middle line:-1
<c.magenta>查看其它线程 重复了同一种模式</c>

00:50:46.680 --> 00:50:49.049 align:middle line:-2
<c.magenta>你可以看到那里发生的是</c>
<c.magenta>同一个读取系统调用</c>

00:50:49.116 --> 00:50:50.851 align:middle line:-1
<c.magenta>或多或少都在同一个时间框架中</c>

00:50:50.918 --> 00:50:53.820 align:middle line:-2
<c.magenta>那么也就是在第二个线程上</c>
<c.magenta>或第一个线程上</c>

00:50:53.987 --> 00:50:56.790 align:middle line:-1
<c.magenta>它们实际上做的是同样的事 重叠了</c>

00:50:57.858 --> 00:51:01.161 align:middle line:-1
<c.magenta>如果这些事在单一线程上执行</c>

00:50:57.858 --> 00:51:01.161 align:middle line:-1
<c.magenta>如果这些事在单一线程上执行</c>

00:51:01.228 --> 00:51:02.496 align:middle line:-1
<c.magenta>对于我们的程序来说会更棒</c>

00:51:02.563 --> 00:51:05.199 align:middle line:-1
<c.magenta>在这里我们并没有真正从并发中受益</c>

00:51:05.265 --> 00:51:07.534 align:middle line:-1
<c.magenta>因为我们执行的是这种很短的代码</c>

00:51:07.901 --> 00:51:10.304 align:middle line:-1
<c.magenta>很可能坏处大于益处</c>

00:51:10.370 --> 00:51:12.206 align:middle line:-1
<c.magenta>从添加这些额外情境切换的角度来说</c>

00:51:13.040 --> 00:51:15.108 align:middle line:-1
<c.magenta>那么让我们应用我们之前看到的模式</c>

00:51:15.175 --> 00:51:17.344 align:middle line:-1
<c.magenta>来修复这个示例应用中的这个问题</c>

00:51:17.811 --> 00:51:19.146 align:middle line:-1
<c.magenta>返回到Xcode</c>

00:51:19.213 --> 00:51:21.849 align:middle line:0
<c.magenta>让我们看看我们要如何</c>
<c.magenta>为我们的那个源设置目标队列</c>

00:51:23.050 --> 00:51:25.285 align:middle line:0
<c.magenta>那么当你在这个函数框架顶部</c>
<c.magenta>创建这个队列时</c>

00:51:25.352 --> 00:51:28.155 align:middle line:0
<c.magenta>正如你所看到的</c>

00:51:28.222 --> 00:51:30.691 align:middle line:-2
<c.magenta>我们很简单地就实现了</c>
<c.magenta>通过正确地调用这个调度队列</c>

00:51:31.458 --> 00:51:33.560 align:middle line:-1
<c.magenta>那会创建一个独立的连续队列</c>

00:51:33.627 --> 00:51:36.196 align:middle line:-1
<c.magenta>并不会连接到我们应用中的任何东西</c>

00:51:36.563 --> 00:51:38.465 align:middle line:-1
<c.magenta>这根我们之前看到的例子一模一样</c>

00:51:38.532 --> 00:51:40.934 align:middle line:-1
<c.magenta>就是那个联网子系统的例子</c>

00:51:41.635 --> 00:51:44.404 align:middle line:-1
<c.magenta>那么让我们修复这个问题</c>

00:51:44.471 --> 00:51:47.241 align:middle line:-2
<c.magenta>通过在所有队列的底部为全部</c>
<c.magenta>连接添加一个互斥情境</c>

00:51:47.608 --> 00:51:49.843 align:middle line:-1
<c.magenta>我们通过添加 或通过切换到</c>

00:51:49.910 --> 00:51:52.579 align:middle line:-1
<c.magenta>调度队列 调度队列是通过</c>

00:51:52.646 --> 00:51:54.248 align:middle line:-1
<c.magenta>之前给你介绍的这个目标函数创建的</c>

00:51:57.684 --> 00:51:59.920 align:middle line:-2
<c.magenta>在这里我们添加了调度队列</c>
<c.magenta>创建了这个目标</c>

00:52:00.220 --> 00:52:03.991 align:middle line:-2
<c.magenta>并且我们将单一互斥队列</c>
<c.magenta>作为全部队列的目标队列</c>

00:52:04.191 --> 00:52:06.693 align:middle line:-2
<c.magenta>并且这个连续队列是我们</c>
<c.magenta>在其它地方创建的</c>

00:52:07.427 --> 00:52:10.664 align:middle line:-2
<c.magenta>然后我们再次创建并运行</c>
<c.magenta>并再次查看系统追踪</c>

00:52:11.565 --> 00:52:12.833 align:middle line:-1
<c.magenta>现在看起来很不一样了</c>

00:52:14.434 --> 00:52:17.905 align:middle line:-2
<c.magenta>在这里我们仍然有同样的点追踪</c>
<c.magenta>我们仍然能看到同样的网络事件发生</c>

00:52:17.971 --> 00:52:21.808 align:middle line:-2
<c.magenta>但正如你所看到的</c>
<c.magenta>那个追踪中不再有重叠事件了</c>

00:52:21.875 --> 00:52:24.778 align:middle line:-2
<c.magenta>并且有一个单一辅助线程</c>
<c.magenta>执行这段代码</c>

00:52:25.245 --> 00:52:27.014 align:middle line:-1
<c.magenta>如果我们放大其中一个集群</c>

00:52:27.080 --> 00:52:30.083 align:middle line:-2
<c.magenta>我们可以看到这实际上是</c>
<c.magenta>那个事件处理器的许多实例</c>

00:52:30.150 --> 00:52:33.887 align:middle line:-2
<c.magenta>接连不断地执行</c>
<c.magenta>这正是我们所期待的结果</c>

00:52:34.221 --> 00:52:36.790 align:middle line:-1
<c.magenta>当你再放大其中某个事件时</c>

00:52:36.857 --> 00:52:40.260 align:middle line:-2
<c.magenta>你可以看到它仍然执行</c>
<c.magenta>相当短的一段时间</c>

00:52:40.327 --> 00:52:42.296 align:middle line:-1
<c.magenta>并做出了同样的读取系统调用</c>

00:52:42.729 --> 00:52:44.598 align:middle line:-1
<c.magenta>但现在问题小多了</c>

00:52:44.665 --> 00:52:46.567 align:middle line:-1
<c.magenta>因为这全部发生在一个单线程上</c>

00:52:49.870 --> 00:52:50.704 align:middle line:0
<c.magenta>（找到问题点）</c>

00:52:50.771 --> 00:52:53.373 align:middle line:-2
<c.magenta>那么这看起来可能像是一个很简单、</c>
<c.magenta>很微小的修改</c>

00:52:53.440 --> 00:52:54.474 align:middle line:-1
<c.magenta>但值得注意的是</c>

00:52:54.541 --> 00:52:58.812 align:middle line:-1
<c.magenta>正是这种小的调整导致</c>

00:52:58.879 --> 00:53:01.381 align:middle line:-2
<c.magenta>我们自己的某些框架代码的性能</c>
<c.magenta>提升了1.3倍</c>

00:52:58.879 --> 00:53:01.381 align:middle line:-2
<c.magenta>我们自己的某些框架代码的性能</c>
<c.magenta>提升了1.3倍</c>

00:53:01.448 --> 00:53:03.150 align:middle line:-2
<c.magenta>这正是Daniel在演讲</c>
<c.magenta>一开始就指出来的</c>

00:53:03.417 --> 00:53:06.019 align:middle line:-2
<c.magenta>那么像这样的很小的修改</c>
<c.magenta>可以导致很大的不同</c>

00:53:10.891 --> 00:53:13.360 align:middle line:-2
<c.magenta>好了 让我们回顾一下</c>
<c.magenta>我们今天演讲的内容</c>

00:53:14.094 --> 00:53:16.063 align:middle line:-1
<c.magenta>Daniel在一开始就跟大家具体谈了</c>

00:53:16.129 --> 00:53:20.601 align:middle line:-2
<c.magenta>在不必要的情况下不离开内核的方式</c>
<c.magenta>永远比现代化的CPU要重要</c>

00:53:20.667 --> 00:53:22.836 align:middle line:-1
<c.magenta>从而它可以达到最高效的性能状态</c>

00:53:23.504 --> 00:53:27.474 align:middle line:-2
<c.magenta>我们看了调整能力</c>
<c.magenta>工作负载的劳动力的重要性</c>

00:53:27.541 --> 00:53:30.143 align:middle line:-1
<c.magenta>以及在应用中的子系统之间</c>

00:53:30.210 --> 00:53:32.446 align:middle line:-1
<c.magenta>以及这些子系统内部的工作转移</c>

00:53:33.113 --> 00:53:36.683 align:middle line:-2
<c.magenta>我们还谈了如何通过GCD</c>
<c.magenta>选择不错的并发间隔</c>

00:53:36.750 --> 00:53:39.720 align:middle line:-1
<c.magenta>通过在应用中使用固定数量的连续队列</c>

00:53:40.087 --> 00:53:43.156 align:middle line:-2
<c.magenta>并且Pierre跟你们一起演示了</c>
<c.magenta>如何现代化你的GCD使用</c>

00:53:43.223 --> 00:53:46.827 align:middle line:-1
<c.magenta>以充分地利用OS中对硬件的改进</c>

00:53:47.628 --> 00:53:49.663 align:middle line:-1
<c.magenta>最后我们了解了如何使用仪表</c>

00:53:49.730 --> 00:53:53.033 align:middle line:-2
<c.magenta>在我们的应用中发现问题点</c>
<c.magenta>以及如何修复它们</c>

00:53:55.169 --> 00:53:58.772 align:middle line:-2
<c.magenta>要获取更多关于本场演讲的信息</c>
<c.magenta>请参看这个URL</c>

00:53:58.839 --> 00:54:03.477 align:middle line:-1
<c.magenta>这里有GCD的文档链接以及演讲视频</c>

00:53:58.839 --> 00:54:03.477 align:middle line:-1
<c.magenta>这里有GCD的文档链接以及演讲视频</c>

00:54:03.544 --> 00:54:07.681 align:middle line:-2
<c.magenta>本周还有一些相关演讲</c>
<c.magenta>可能值得一去</c>

00:54:07.748 --> 00:54:11.185 align:middle line:-2
<c.magenta>已经结束了的有Core ML介绍</c>
<c.magenta>另外两场</c>

00:54:11.251 --> 00:54:14.321 align:middle line:-2
<c.magenta>会帮助你处理并行</c>
<c.magenta>和计算[听不清]任务</c>

00:54:14.388 --> 00:54:16.390 align:middle line:-2
<c.magenta>在你的应用中</c>
<c.magenta>正如我们在一开始所谈到的那样</c>

00:54:16.957 --> 00:54:20.827 align:middle line:-2
<c.magenta>最后两场可以帮助你处理</c>
<c.magenta>更多的性能分析</c>

00:54:20.894 --> 00:54:23.230 align:middle line:-1
<c.magenta>和改善应用的不同方面</c>

00:54:24.064 --> 00:54:26.066 align:middle line:-1
<c.magenta>就这样了 我想谢谢大家的参与</c>

00:54:26.133 --> 00:54:28.502 align:middle line:-2
<c.magenta>如果你有任何疑问</c>
<c.magenta>欢迎来我们的实验室咨询</c>
