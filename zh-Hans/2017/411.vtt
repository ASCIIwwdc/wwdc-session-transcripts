WEBVTT

00:00:07.516 --> 00:00:16.500 A:middle
[背景对话]

00:00:21.516 --> 00:00:25.586 A:middle
[掌声]

00:00:26.086 --> 00:00:28.446 A:middle
&gt;&gt; 大家好 欢迎来到

00:00:28.446 --> 00:00:29.016 A:middle
“What’s New in LLVM（LLVM 的新内容）”

00:00:29.736 --> 00:00:31.396 A:middle
我是 Devin 是一名工程师

00:00:31.396 --> 00:00:32.646 A:middle
来自程序分析团队

00:00:33.636 --> 00:00:35.656 A:middle
今天 我们有很多非常不错的新

00:00:35.656 --> 00:00:36.766 A:middle
功能和大家

00:00:36.766 --> 00:00:37.076 A:middle
分享

00:00:38.266 --> 00:00:39.616 A:middle
我们首先会介绍

00:00:39.846 --> 00:00:41.306 A:middle
Objective-C 的

00:00:41.306 --> 00:00:41.976 A:middle
可用性检查

00:00:41.976 --> 00:00:44.086 A:middle
可用性检查能够帮助用户安全配置

00:00:44.086 --> 00:00:46.136 A:middle
App 到旧的系统中

00:00:47.186 --> 00:00:48.246 A:middle
然后我们将介绍新的静态

00:00:48.246 --> 00:00:49.626 A:middle
分析器检查和编译器

00:00:49.626 --> 00:00:51.506 A:middle
警告功能 来帮助你找到 Bug

00:00:52.676 --> 00:00:54.336 A:middle
接着我们将讨论为 C++ 开发人员

00:00:54.336 --> 00:00:56.196 A:middle
打造的一些绝妙的新功能

00:00:56.646 --> 00:00:58.366 A:middle
包括 Xcode 代码中的

00:00:58.366 --> 00:01:01.056 A:middle
C++ 重构支持

00:00:58.366 --> 00:01:01.056 A:middle
C++ 重构支持

00:01:01.056 --> 00:01:02.866 A:middle
最后

00:01:02.866 --> 00:01:03.996 A:middle
介绍链接时间优化的更新

00:01:04.506 --> 00:01:07.786 A:middle
让我们先从可用性检查

00:01:07.786 --> 00:01:08.000 A:middle
开始说起

00:01:10.556 --> 00:01:12.316 A:middle
每一次主要的 OS 发布时

00:01:12.606 --> 00:01:14.556 A:middle
我们都会介绍一些非常棒的新功能

00:01:14.556 --> 00:01:16.096 A:middle
你的顾客希望你能把

00:01:16.096 --> 00:01:18.046 A:middle
这些 API 运用到你们的 App 上

00:01:19.086 --> 00:01:20.256 A:middle
但你仍须支持

00:01:20.256 --> 00:01:22.626 A:middle
使用旧 OS 的顾客 虽然

00:01:22.626 --> 00:01:24.136 A:middle
这些 API 在旧的 OS 中无法使用

00:01:24.136 --> 00:01:29.246 A:middle
在我们的平台上 我们支持

00:01:29.246 --> 00:01:30.766 A:middle
反向配置 通过

00:01:30.766 --> 00:01:32.686 A:middle
将基础 SDK 版本

00:01:32.946 --> 00:01:34.026 A:middle
从配置目标版本隔离

00:01:34.026 --> 00:01:34.456 A:middle
来实现

00:01:35.296 --> 00:01:36.716 A:middle
也就是说

00:01:36.716 --> 00:01:38.586 A:middle
即使在旧的系统中进行配置时

00:01:38.586 --> 00:01:41.286 A:middle
你也可以利用最新的

00:01:41.286 --> 00:01:42.496 A:middle
SDK 进行编译

00:01:43.266 --> 00:01:45.736 A:middle
举个例子 在 Xcode 9 中

00:01:45.736 --> 00:01:49.326 A:middle
如果你使用 iOS 11 SDK  且你的

00:01:49.326 --> 00:01:52.086 A:middle
App 只针对 iOS 11

00:01:52.086 --> 00:01:53.716 A:middle
你会把它也作为配置

00:01:53.716 --> 00:01:54.596 A:middle
目标

00:01:55.146 --> 00:01:57.666 A:middle
但我知道在座的很多人

00:01:57.666 --> 00:01:59.466 A:middle
希望在 iOS 10 中支持你们的用户

00:01:59.546 --> 00:02:01.606 A:middle
给用户一个机会

00:01:59.546 --> 00:02:01.606 A:middle
给用户一个机会

00:02:01.606 --> 00:02:02.216 A:middle
进行升级

00:02:03.416 --> 00:02:04.406 A:middle
要这么做的话 你可以前往

00:02:04.406 --> 00:02:07.126 A:middle
“Build Settings（构建设置）”

00:02:07.516 --> 00:02:08.656 A:middle
选择 10.0 作为配置目标

00:02:09.756 --> 00:02:11.346 A:middle
这可以保证你的 App

00:02:11.346 --> 00:02:12.886 A:middle
能够支持

00:02:12.886 --> 00:02:15.296 A:middle
iOS 10 以及更新系统的

00:02:15.296 --> 00:02:15.746 A:middle
所有版本

00:02:15.746 --> 00:02:20.976 A:middle
这其实有点投机取巧

00:02:21.136 --> 00:02:23.416 A:middle
因为只有调用

00:02:23.486 --> 00:02:25.656 A:middle
系统真正支持的 API

00:02:25.656 --> 00:02:26.496 A:middle
才安全

00:02:27.236 --> 00:02:29.476 A:middle
如果你在旧系统中调用新版本 API

00:02:29.476 --> 00:02:31.486 A:middle
那么你的 App 很可能

00:02:31.486 --> 00:02:33.146 A:middle
崩溃 或出现其他意外

00:02:33.146 --> 00:02:33.646 A:middle
行为

00:02:33.646 --> 00:02:37.766 A:middle
过去 我们推荐

00:02:37.766 --> 00:02:39.676 A:middle
查询 Objective-C 运行时

00:02:40.106 --> 00:02:41.896 A:middle
来确定 API 是否

00:02:41.896 --> 00:02:42.386 A:middle
适用

00:02:43.496 --> 00:02:45.236 A:middle
但是这个方法很容易出错

00:02:45.236 --> 00:02:47.346 A:middle
或被忘记 而且很难

00:02:47.346 --> 00:02:47.836 A:middle
进行测试

00:02:49.286 --> 00:02:51.336 A:middle
而且 它需要不同的

00:02:51.436 --> 00:02:54.586 A:middle
语法来检查每项

00:02:55.136 --> 00:02:58.066 A:middle
全局变量 函数 类

00:02:58.576 --> 00:03:00.296 A:middle
实例方法和

00:02:58.576 --> 00:03:00.296 A:middle
实例方法和

00:03:00.296 --> 00:03:00.666 A:middle
类方法

00:03:01.286 --> 00:03:04.956 A:middle
你们之中在使用 Swift 的人

00:03:04.956 --> 00:03:06.896 A:middle
可能会想 这有什么

00:03:06.896 --> 00:03:07.696 A:middle
大不了的吗

00:03:07.956 --> 00:03:09.426 A:middle
Swift 有一个统一的语法

00:03:09.476 --> 00:03:11.516 A:middle
#available 可在运行时用于查询 API

00:03:11.516 --> 00:03:13.466 A:middle
的可用性 而且

00:03:13.466 --> 00:03:16.176 A:middle
编译器甚至可以在编译时

00:03:16.176 --> 00:03:18.346 A:middle
捕捉缺失的可用性

00:03:18.786 --> 00:03:18.876 A:middle
检查

00:03:20.656 --> 00:03:21.936 A:middle
想要了解更多

00:03:21.936 --> 00:03:22.996 A:middle
关于 Swift 可用性的信息请

00:03:22.996 --> 00:03:24.406 A:middle
前往 WWDC 2015 中的“Swift in Practice”

00:03:24.406 --> 00:03:29.276 A:middle
以了解更多

00:03:29.376 --> 00:03:31.396 A:middle
现在我们将 Swift 类的

00:03:31.396 --> 00:03:32.816 A:middle
可用性检查带入了

00:03:32.816 --> 00:03:33.516 A:middle
Objective-C

00:03:34.516 --> 00:03:39.406 A:middle
[掌声]

00:03:39.906 --> 00:03:41.096 A:middle
我想为大家介绍一下

00:03:41.946 --> 00:03:42.000 A:middle
这个功能

00:03:43.046 --> 00:03:44.726 A:middle
假设你有一个 App

00:03:44.896 --> 00:03:46.796 A:middle
你想把它配置回 iOS 10 中

00:03:47.726 --> 00:03:49.536 A:middle
并且你决定利用

00:03:49.716 --> 00:03:51.956 A:middle
iOS 11 提供的

00:03:51.956 --> 00:03:53.806 A:middle
Vision 框架中全新的

00:03:53.806 --> 00:03:55.426 A:middle
人脸检测 API

00:03:56.626 --> 00:03:57.886 A:middle
当你将这些 API

00:03:57.886 --> 00:04:00.606 A:middle
添加至 App 并构建时

00:03:57.886 --> 00:04:00.606 A:middle
添加至 App 并构建时

00:04:00.606 --> 00:04:02.706 A:middle
你会收到一个编译器警告

00:04:02.706 --> 00:04:04.736 A:middle
告诉你这些 API 只

00:04:04.736 --> 00:04:07.046 A:middle
适用于 iOS 11 或更新的系统

00:04:07.576 --> 00:04:10.336 A:middle
你可以

00:04:10.696 --> 00:04:12.866 A:middle
通过使用新的@available 结构

00:04:12.866 --> 00:04:14.826 A:middle
查询 API 可用性

00:04:14.826 --> 00:04:15.486 A:middle
来处理这些警告

00:04:16.565 --> 00:04:18.656 A:middle
当 iOS 11 API 适用时

00:04:18.656 --> 00:04:20.466 A:middle
@available 结构返回值为真

00:04:20.916 --> 00:04:23.076 A:middle
这种情况下调用 API 很安全

00:04:23.266 --> 00:04:24.266 A:middle
如果不适用 你可以

00:04:24.266 --> 00:04:25.236 A:middle
提供一个 Fallback（回退）

00:04:26.516 --> 00:04:28.636 A:middle
我们来仔细看看

00:04:28.856 --> 00:04:29.000 A:middle
查询功能

00:04:31.046 --> 00:04:35.046 A:middle
我刚刚提过 在 iOS 11系统或

00:04:35.046 --> 00:04:37.176 A:middle
更新的系统里 它的返回真为值

00:04:37.736 --> 00:04:40.026 A:middle
这个星号是必须的

00:04:40.996 --> 00:04:42.676 A:middle
它表明在其他所有

00:04:42.676 --> 00:04:44.976 A:middle
平台上 查询总会

00:04:44.976 --> 00:04:45.796 A:middle
返回真值

00:04:47.166 --> 00:04:48.316 A:middle
也就是说 如果你

00:04:48.316 --> 00:04:49.906 A:middle
决定将 App 转移至

00:04:49.906 --> 00:04:51.806 A:middle
另一个平台 比如 macOS

00:04:52.486 --> 00:04:54.286 A:middle
那么 默认情况下

00:04:54.286 --> 00:04:55.626 A:middle
它会利用这个新的

00:04:55.626 --> 00:04:56.676 A:middle
人脸检测 API

00:04:57.736 --> 00:04:58.656 A:middle
当然 如果 API

00:04:58.656 --> 00:05:00.276 A:middle
不适用于该 macOS 支持的

00:04:58.656 --> 00:05:00.276 A:middle
不适用于该 macOS 支持的

00:05:00.276 --> 00:05:02.146 A:middle
先前配置目标

00:05:02.146 --> 00:05:03.406 A:middle
编译器

00:05:03.406 --> 00:05:04.696 A:middle
依然会发出警告

00:05:04.986 --> 00:05:08.786 A:middle
所以你需要检查一下

00:05:10.066 --> 00:05:11.166 A:middle
一旦你开始使用

00:05:11.166 --> 00:05:12.756 A:middle
可用性这个功能

00:05:12.756 --> 00:05:14.476 A:middle
你会发现

00:05:14.476 --> 00:05:16.536 A:middle
编写一个只能在 iOS 11

00:05:16.846 --> 00:05:18.956 A:middle
或更新系统上调用的一整套方法

00:05:18.956 --> 00:05:19.726 A:middle
真的非常有用

00:05:19.786 --> 00:05:23.236 A:middle
你可以使用全新的

00:05:23.236 --> 00:05:25.056 A:middle
API 可用性宏

00:05:25.056 --> 00:05:25.516 A:middle
注释这些方法

00:05:26.936 --> 00:05:29.316 A:middle
然后 在这个方法中

00:05:29.316 --> 00:05:31.216 A:middle
无须使用 @available

00:05:31.216 --> 00:05:33.356 A:middle
检查可用性

00:05:33.356 --> 00:05:35.386 A:middle
但是调用该方法的人

00:05:35.386 --> 00:05:36.166 A:middle
需要使用 @available

00:05:36.526 --> 00:05:37.366 A:middle
否则 他们会收到一个

00:05:37.366 --> 00:05:37.776 A:middle
警告

00:05:38.136 --> 00:05:42.026 A:middle
你还可以把这个功能应用于

00:05:42.026 --> 00:05:42.886 A:middle
整个类

00:05:43.476 --> 00:05:44.216 A:middle
而且 你无须

00:05:44.216 --> 00:05:46.266 A:middle
在该类中使用 @available

00:05:46.266 --> 00:05:48.046 A:middle
但实例化该类的人

00:05:48.046 --> 00:05:48.766 A:middle
都需要使用 @available

00:05:52.756 --> 00:05:54.446 A:middle
现在 可用性检查

00:05:54.446 --> 00:05:55.946 A:middle
不仅仅用于 Objective-C 中

00:05:56.706 --> 00:05:59.286 A:middle
通过内建可用性查询

00:05:59.286 --> 00:06:00.916 A:middle
我们还支持 C 和 C++

00:05:59.286 --> 00:06:00.916 A:middle
我们还支持 C 和 C++

00:06:01.856 --> 00:06:03.456 A:middle
这里的用法和

00:06:03.456 --> 00:06:04.346 A:middle
@available 完全一样

00:06:04.656 --> 00:06:05.786 A:middle
它们有一样的语法

00:06:06.356 --> 00:06:07.576 A:middle
只是名称不同

00:06:07.746 --> 00:06:08.926 A:middle
且名称与 C 和 C++

00:06:08.926 --> 00:06:09.626 A:middle
兼容

00:06:10.156 --> 00:06:13.176 A:middle
你还可以

00:06:13.176 --> 00:06:15.196 A:middle
在 C 中使用 API 可用性宏

00:06:15.196 --> 00:06:16.366 A:middle
但须要包括

00:06:16.366 --> 00:06:18.836 A:middle
<os/availability.h> 头文件 才能

00:06:18.836 --> 00:06:19.646 A:middle
访问

00:06:20.096 --> 00:06:23.186 A:middle
你甚至可以对你的

00:06:23.186 --> 00:06:24.756 A:middle
C++ 类的定义进行注释

00:06:24.756 --> 00:06:28.396 A:middle
那么 我们具体

00:06:28.716 --> 00:06:31.716 A:middle
应该要怎样做呢

00:06:31.716 --> 00:06:33.736 A:middle
对于现有的工程

00:06:33.736 --> 00:06:35.566 A:middle
我们不建议一开始就使用

00:06:35.566 --> 00:06:38.816 A:middle
iOS 11  Apple TVOS 11

00:06:38.816 --> 00:06:41.396 A:middle
macOS 10.13 和 watchOS 4 引入的 API

00:06:42.496 --> 00:06:45.226 A:middle
老版本 SDK 的 API

00:06:45.226 --> 00:06:46.406 A:middle
在编译时不会被检查

00:06:47.676 --> 00:06:48.866 A:middle
也就是说你无须

00:06:48.866 --> 00:06:51.576 A:middle
改变任何现有代码

00:06:51.576 --> 00:06:53.596 A:middle
但如果你决定采用

00:06:53.596 --> 00:06:55.856 A:middle
新的 API 你需要使用

00:06:55.856 --> 00:06:57.466 A:middle
@available 检查新的 API

00:06:58.656 --> 00:06:59.726 A:middle
我们认为这是最佳

00:06:59.726 --> 00:07:00.726 A:middle
也是最安全的

00:06:59.726 --> 00:07:00.726 A:middle
也是最安全的

00:07:00.726 --> 00:07:02.386 A:middle
可用性检查方法 所以我们强烈

00:07:02.386 --> 00:07:03.966 A:middle
推荐大家使用

00:07:05.726 --> 00:07:08.896 A:middle
对于新项目 所有 API

00:07:08.896 --> 00:07:10.196 A:middle
都会在编译时被检查

00:07:11.026 --> 00:07:12.376 A:middle
也就是说你在配置目标

00:07:12.376 --> 00:07:13.986 A:middle
下面引入的所有 API

00:07:13.986 --> 00:07:15.976 A:middle
都需要使用

00:07:16.376 --> 00:07:16.566 A:middle
@available

00:07:17.736 --> 00:07:20.036 A:middle
现有项目也可以选择

00:07:20.036 --> 00:07:22.316 A:middle
这种全 API 行为

00:07:22.316 --> 00:07:23.686 A:middle
前往构建设置

00:07:23.686 --> 00:07:25.926 A:middle
在“Unguarded availability”一栏

00:07:25.926 --> 00:07:27.036 A:middle
选择“Yes (All Versions)”

00:07:27.036 --> 00:07:27.386 A:middle
即可实现

00:07:28.186 --> 00:07:30.006 A:middle
这个方法使

00:07:30.006 --> 00:07:31.846 A:middle
在旧的系统中安全配置 App

00:07:31.846 --> 00:07:33.326 A:middle
变得更加简单

00:07:33.886 --> 00:07:36.376 A:middle
以上就是关于可用性检查的介绍

00:07:36.726 --> 00:07:37.606 A:middle
你可以说它现在在

00:07:37.606 --> 00:07:40.506 A:middle
C C++ 和 Objective-C 中

00:07:40.506 --> 00:07:41.156 A:middle
都“@available（可用）”了

00:07:42.516 --> 00:07:47.686 A:middle
[掌声]

00:07:48.186 --> 00:07:49.896 A:middle
好的 我们继续来看

00:07:49.896 --> 00:07:50.716 A:middle
静态分析器

00:07:52.096 --> 00:07:54.976 A:middle
这个分析器擅长

00:07:54.976 --> 00:07:56.426 A:middle
捕捉难以重现的

00:07:56.526 --> 00:07:58.706 A:middle
极端情况 Bug 甚至可以

00:07:58.706 --> 00:07:59.876 A:middle
展示导致 Bug 的

00:07:59.876 --> 00:08:01.936 A:middle
极端事件的

00:07:59.876 --> 00:08:01.936 A:middle
极端事件的

00:08:02.016 --> 00:08:03.276 A:middle
序列

00:08:03.556 --> 00:08:04.406 A:middle
今天 我会向大家

00:08:04.406 --> 00:08:05.656 A:middle
介绍三种

00:08:05.656 --> 00:08:07.926 A:middle
我们添加至该分析器的新的检查方法

00:08:07.926 --> 00:08:09.426 A:middle
NSNumber 可疑比较检查

00:08:09.426 --> 00:08:11.466 A:middle
实例变量中

00:08:11.466 --> 00:08:12.756 A:middle
dispatch_once() 使用

00:08:12.756 --> 00:08:14.546 A:middle
检查 以及 NSMutable 中

00:08:14.546 --> 00:08:16.346 A:middle
自动综合的

00:08:16.636 --> 00:08:18.346 A:middle
copy 属性检查

00:08:20.756 --> 00:08:24.596 A:middle
有一个致命的 Bug 是

00:08:24.596 --> 00:08:26.506 A:middle
错误地将

00:08:26.506 --> 00:08:28.396 A:middle
NSNumber 指针值

00:08:28.396 --> 00:08:30.836 A:middle
与标量“0”相比较 因为

00:08:31.036 --> 00:08:33.486 A:middle
这个操作实际上是将指针值与 nil 相比较

00:08:33.486 --> 00:08:34.976 A:middle
而不是 NSNumber 实例的“0”

00:08:36.025 --> 00:08:37.006 A:middle
我给大家举个例子说明为什么

00:08:37.006 --> 00:08:37.936 A:middle
这个问题很严重

00:08:39.116 --> 00:08:40.885 A:middle
在 hasPhotos 方法中

00:08:40.885 --> 00:08:43.706 A:middle
编程者想要返回“no”

00:08:43.856 --> 00:08:45.156 A:middle
如果相册是空的

00:08:46.136 --> 00:08:47.236 A:middle
但是因为他们

00:08:47.236 --> 00:08:49.866 A:middle
将照片数量计为“nil” 这个结果

00:08:49.866 --> 00:08:52.216 A:middle
实际上将返回“yes” 即使

00:08:52.216 --> 00:08:54.266 A:middle
照片数量

00:08:54.316 --> 00:08:55.356 A:middle
在 NSNumber 实例中计为“0”

00:08:56.036 --> 00:08:57.206 A:middle
所以这时分析器

00:08:57.206 --> 00:08:59.876 A:middle
会发出警告

00:09:00.106 --> 00:09:02.336 A:middle
你可以通过

00:09:02.336 --> 00:09:03.986 A:middle
调用 integerValue 属性

00:09:03.986 --> 00:09:06.196 A:middle
进行整数之间的比较

00:09:06.196 --> 00:09:06.756 A:middle
来纠正这个错误

00:09:07.106 --> 00:09:07.686 A:middle
这个方法很安全

00:09:08.236 --> 00:09:11.626 A:middle
布尔运算的隐式变换

00:09:11.626 --> 00:09:14.056 A:middle
有一个类似的问题

00:09:14.446 --> 00:09:16.466 A:middle
因为也是检查“nil”

00:09:16.496 --> 00:09:17.746 A:middle
而不是数字“0”

00:09:18.276 --> 00:09:20.956 A:middle
这个方法计算

00:09:21.046 --> 00:09:23.286 A:middle
一张照片上出现的人脸数量 鉴于这项

00:09:23.286 --> 00:09:24.966 A:middle
操作成本较高

00:09:24.966 --> 00:09:26.576 A:middle
如果已经计算过数量

00:09:26.576 --> 00:09:27.216 A:middle
那么值会及早返回

00:09:28.276 --> 00:09:29.776 A:middle
但是读到这个代码的人

00:09:30.066 --> 00:09:31.436 A:middle
可能会觉得它有歧义

00:09:32.356 --> 00:09:33.546 A:middle
如果人脸数量不是“nil”或“0”

00:09:33.546 --> 00:09:35.656 A:middle
编程者是否打算

00:09:35.656 --> 00:09:37.806 A:middle
提前返回

00:09:38.806 --> 00:09:40.396 A:middle
分析器现在可以

00:09:40.396 --> 00:09:41.546 A:middle
针对这类歧义发出警告

00:09:41.976 --> 00:09:44.446 A:middle
在这种情况下 编程者

00:09:44.446 --> 00:09:47.386 A:middle
如果想让结果为非 nil  她可以

00:09:47.476 --> 00:09:49.136 A:middle
将她的想法直接在代码中表达出来

00:09:49.136 --> 00:09:51.126 A:middle
并沉默分析器的警告

00:09:51.126 --> 00:09:53.476 A:middle
这可以通过明确地添加比较

00:09:53.476 --> 00:09:54.896 A:middle
来实现

00:09:55.456 --> 00:09:59.106 A:middle
你可以在构建设置中

00:09:59.106 --> 00:10:00.316 A:middle
控制检查

00:09:59.106 --> 00:10:00.316 A:middle
控制检查

00:10:00.316 --> 00:10:00.656 A:middle
等级

00:10:01.486 --> 00:10:02.956 A:middle
如果选择“Yes (Aggressive)”

00:10:03.606 --> 00:10:05.566 A:middle
那么分析器在不确定你是否犯错时

00:10:05.566 --> 00:10:06.786 A:middle
就会生成警告

00:10:06.786 --> 00:10:08.486 A:middle
但是它不认为你的

00:10:08.486 --> 00:10:09.326 A:middle
代码是有歧义的

00:10:09.946 --> 00:10:13.696 A:middle
接下来我们介绍 dispatch_once()

00:10:16.076 --> 00:10:17.776 A:middle
多线程优化技术（GCD）提供

00:10:17.866 --> 00:10:20.896 A:middle
了一个非常棒的 API  dispatch_once()

00:10:21.096 --> 00:10:22.306 A:middle
它保证了一个块

00:10:22.306 --> 00:10:24.256 A:middle
会被调用一次 并且只有一次

00:10:24.896 --> 00:10:27.276 A:middle
它对于安全地

00:10:27.276 --> 00:10:28.436 A:middle
初始化共享全局状态

00:10:28.436 --> 00:10:28.836 A:middle
非常有用

00:10:29.946 --> 00:10:31.576 A:middle
在这个例子中 编程者

00:10:32.186 --> 00:10:34.186 A:middle
利用它加载和初始化

00:10:34.186 --> 00:10:36.136 A:middle
一个共享照片数列

00:10:37.616 --> 00:10:39.516 A:middle
dispatch_once() 的第一个参数

00:10:39.516 --> 00:10:41.336 A:middle
是对一个特殊变量

00:10:41.336 --> 00:10:43.176 A:middle
的声明

00:10:43.506 --> 00:10:44.696 A:middle
dispatch_once_t

00:10:45.546 --> 00:10:46.846 A:middle
GCD 利用这一点

00:10:47.156 --> 00:10:48.926 A:middle
确保代码块

00:10:48.926 --> 00:10:51.606 A:middle
只被调用一次

00:10:51.686 --> 00:10:53.846 A:middle
有一点很重要

00:10:53.846 --> 00:10:56.046 A:middle
就是该变量要么是静态变量

00:10:56.266 --> 00:10:57.276 A:middle
要么是全局变量

00:10:58.276 --> 00:10:59.756 A:middle
这是因为 如果出现

00:10:59.756 --> 00:11:01.556 A:middle
该变量

00:10:59.756 --> 00:11:01.556 A:middle
该变量

00:11:01.556 --> 00:11:03.266 A:middle
过去的值是非零的情况

00:11:04.086 --> 00:11:05.206 A:middle
GCD 可能无法保证

00:11:05.426 --> 00:11:06.916 A:middle
在多线代码中进行

00:11:06.916 --> 00:11:09.006 A:middle
有且只有一次

00:11:09.006 --> 00:11:09.986 A:middle
的执行

00:11:10.506 --> 00:11:14.356 A:middle
也就是说

00:11:14.576 --> 00:11:17.306 A:middle
在实例变量

00:11:17.306 --> 00:11:19.146 A:middle
或其他任何可能

00:11:19.146 --> 00:11:21.696 A:middle
被复用过的堆内存中

00:11:22.156 --> 00:11:23.316 A:middle
使用 dispatch_once_t 是不安全的

00:11:23.986 --> 00:11:25.056 A:middle
所以分析器现在会

00:11:25.056 --> 00:11:26.486 A:middle
因此生成警告

00:11:27.296 --> 00:11:29.686 A:middle
为了解决这个问题 你可以使用你

00:11:29.786 --> 00:11:31.496 A:middle
最爱的非递归锁

00:11:32.306 --> 00:11:34.076 A:middle
这里我使用 NSLock 但你

00:11:34.076 --> 00:11:35.916 A:middle
可以使用 OSUnfairLock 或

00:11:35.916 --> 00:11:37.016 A:middle
pthread_mutex

00:11:38.416 --> 00:11:41.316 A:middle
获取锁后 检查

00:11:41.316 --> 00:11:42.346 A:middle
数据是否已经

00:11:42.346 --> 00:11:43.506 A:middle
初始化 如果没有

00:11:43.506 --> 00:11:46.336 A:middle
对数据进行初始化 不要

00:11:46.406 --> 00:11:48.346 A:middle
忘了释放锁

00:11:49.236 --> 00:11:50.706 A:middle
这样能确保

00:11:50.706 --> 00:11:52.376 A:middle
数据初始化有且只有一次

00:11:52.376 --> 00:11:54.056 A:middle
完全符合你的预期

00:11:54.416 --> 00:12:00.026 A:middle
最后 我向大家

00:11:54.416 --> 00:12:00.026 A:middle
最后 我向大家

00:12:00.026 --> 00:12:01.576 A:middle
介绍我们添加至

00:12:01.876 --> 00:12:03.786 A:middle
NSMutable 类自动综合的

00:12:03.786 --> 00:12:05.766 A:middle
copy 属性的检查

00:12:07.236 --> 00:12:09.066 A:middle
copy 属性利用传入值调用其 setter 的

00:12:09.066 --> 00:12:11.096 A:middle
copy 方法

00:12:11.096 --> 00:12:12.976 A:middle
来构建一个 copy

00:12:14.006 --> 00:12:16.736 A:middle
但是调用 copy 可变数组

00:12:16.736 --> 00:12:18.916 A:middle
会导致 copy

00:12:18.916 --> 00:12:19.346 A:middle
不可变

00:12:20.416 --> 00:12:21.166 A:middle
我来解释一下为什么

00:12:21.166 --> 00:12:21.676 A:middle
这是一个问题

00:12:22.606 --> 00:12:25.296 A:middle
这个方法试图

00:12:25.296 --> 00:12:27.306 A:middle
重置照片属性

00:12:27.306 --> 00:12:29.406 A:middle
通过将其设置为一个空的可变数组

00:12:29.406 --> 00:12:31.896 A:middle
然后添加一张单独的照片来实现

00:12:33.196 --> 00:12:34.866 A:middle
但是 这会导致

00:12:34.866 --> 00:12:37.236 A:middle
运行时出现意外

00:12:37.236 --> 00:12:39.856 A:middle
因为你无法

00:12:39.856 --> 00:12:41.766 A:middle
将一个对象添加至不可变数组

00:12:42.596 --> 00:12:43.496 A:middle
你会获得一个异常

00:12:44.056 --> 00:12:46.826 A:middle
这时分析器会发出警告

00:12:46.826 --> 00:12:48.166 A:middle
告知你这些属性

00:12:48.216 --> 00:12:50.156 A:middle
帮助你防止运行

00:12:50.156 --> 00:12:50.666 A:middle
异常

00:12:51.216 --> 00:12:53.666 A:middle
解决方法很简单

00:12:54.116 --> 00:12:55.716 A:middle
你只须明确写出 setter

00:12:55.716 --> 00:12:57.516 A:middle
使其调用

00:12:57.516 --> 00:12:58.626 A:middle
mutableCopy

00:12:59.426 --> 00:13:00.326 A:middle
这可以确保你的

00:12:59.426 --> 00:13:00.326 A:middle
这可以确保你的

00:13:00.326 --> 00:13:02.946 A:middle
属性始终是可变

00:13:02.946 --> 00:13:03.000 A:middle
数组

00:13:06.236 --> 00:13:07.706 A:middle
以上介绍的就是

00:13:07.706 --> 00:13:08.736 A:middle
今年我们添加至

00:13:08.736 --> 00:13:09.746 A:middle
分析器的 3 种新的检查方法

00:13:10.606 --> 00:13:11.776 A:middle
你应该在代码中些运行一下试试

00:13:11.776 --> 00:13:13.186 A:middle
它们会帮助你找到 Bug

00:13:14.556 --> 00:13:16.656 A:middle
为了使用这个功能 大家可以从

00:13:16.656 --> 00:13:17.626 A:middle
Xcode 的“Product（产品） ”菜单中选择“Analyze（分析）”

00:13:19.086 --> 00:13:20.606 A:middle
你甚至可以让 Xcode 在每次编译中运行

00:13:20.606 --> 00:13:23.566 A:middle
分析器 可以通过

00:13:23.566 --> 00:13:25.186 A:middle
前往构建设置

00:13:25.186 --> 00:13:27.096 A:middle
选择“Analyze During ‘Build’”来实现

00:13:27.096 --> 00:13:29.086 A:middle
这可以帮助你

00:13:29.086 --> 00:13:30.336 A:middle
及早并时常捕捉 Bug

00:13:30.976 --> 00:13:33.136 A:middle
如果你对其他

00:13:33.136 --> 00:13:34.626 A:middle
发现 Bug 的工具感兴趣

00:13:34.956 --> 00:13:36.496 A:middle
我强烈推荐在线观看

00:13:36.496 --> 00:13:38.266 A:middle
“Finding Bugs Using Xcode Runtime Tools

00:13:38.266 --> 00:13:39.566 A:middle
（使用 Xcode 运行时工具寻找 Bug）”

00:13:39.566 --> 00:13:41.916 A:middle
以上介绍的就是我们

00:13:41.916 --> 00:13:42.466 A:middle
在分析器方面的新功能

00:13:42.916 --> 00:13:44.616 A:middle
接下来我把时间交给

00:13:44.616 --> 00:13:46.266 A:middle
Duncan 他会向大家介绍

00:13:46.266 --> 00:13:47.316 A:middle
新的编译器警告功能

00:13:48.516 --> 00:13:54.046 A:middle
[掌声]

00:13:54.546 --> 00:13:57.766 A:middle
&gt;&gt;  谢谢你 Devin

00:13:58.576 --> 00:14:00.986 A:middle
Xcode 9 新增了 100 多个

00:13:58.576 --> 00:14:00.986 A:middle
Xcode 9 新增了 100 多个

00:14:00.986 --> 00:14:02.526 A:middle
错误和警告

00:14:02.526 --> 00:14:03.426 A:middle
来帮助在代码中发现 Bug

00:14:03.746 --> 00:14:05.626 A:middle
接下来我们来说说

00:14:05.626 --> 00:14:06.466 A:middle
两个对 Objective-C 很重要的

00:14:06.466 --> 00:14:07.166 A:middle
警告

00:14:09.686 --> 00:14:11.896 A:middle
在 ARC 中 在块中捕捉大多数参数

00:14:11.896 --> 00:14:13.346 A:middle
都很安全

00:14:13.876 --> 00:14:16.356 A:middle
在这个例子中

00:14:16.356 --> 00:14:18.256 A:middle
validateDictionary(usingChecker)

00:14:18.256 --> 00:14:21.036 A:middle
方法使用了 NSDictionary 并

00:14:21.036 --> 00:14:22.716 A:middle
通过调用

00:14:22.716 --> 00:14:24.256 A:middle
enumerateKeysAndObjectsUsingBlock

00:14:24.256 --> 00:14:24.886 A:middle
访问每个条目

00:14:26.336 --> 00:14:28.216 A:middle
块捕捉 checker

00:14:28.216 --> 00:14:28.746 A:middle
参数

00:14:29.466 --> 00:14:30.846 A:middle
这个方法很安全 而且十分

00:14:30.846 --> 00:14:31.096 A:middle
有效

00:14:32.906 --> 00:14:34.796 A:middle
注意 checkObject forKey

00:14:35.066 --> 00:14:35.536 A:middle
可能会失败

00:14:36.376 --> 00:14:38.856 A:middle
块将 stop 设置为“YES”

00:14:38.856 --> 00:14:40.226 A:middle
提前中止枚举

00:14:41.576 --> 00:14:43.546 A:middle
因为这是一个验证

00:14:43.546 --> 00:14:45.016 A:middle
方法 所以应返回

00:14:45.016 --> 00:14:46.546 A:middle
BOOL 并生成一个 NSError

00:14:47.116 --> 00:14:48.066 A:middle
我们来改一下

00:14:49.636 --> 00:14:52.006 A:middle
一起来看一下这个代码

00:14:52.356 --> 00:14:54.196 A:middle
在枚举之前 将 isValid

00:14:54.196 --> 00:14:54.896 A:middle
设置为“YES”

00:14:55.586 --> 00:14:57.716 A:middle
块运行检查器 并

00:14:57.716 --> 00:14:58.856 A:middle
返回成功

00:14:59.906 --> 00:15:02.326 A:middle
如果检查器失效 isValid

00:14:59.906 --> 00:15:02.326 A:middle
如果检查器失效 isValid

00:15:02.326 --> 00:15:04.356 A:middle
设置为“NO” 一个 NSError

00:15:04.356 --> 00:15:04.796 A:middle
将会产生

00:15:06.236 --> 00:15:08.616 A:middle
枚举后 isValid

00:15:08.616 --> 00:15:10.916 A:middle
返回 但这里有一个

00:15:10.916 --> 00:15:11.156 A:middle
Bug

00:15:12.596 --> 00:15:14.626 A:middle
输出参数 比如错误

00:15:14.626 --> 00:15:16.066 A:middle
是隐性自动发布的

00:15:16.676 --> 00:15:18.826 A:middle
在块中为它们赋值

00:15:19.566 --> 00:15:20.316 A:middle
是不安全的

00:15:20.926 --> 00:15:22.266 A:middle
enumerateKeysAndObjectsUsingBlock

00:15:22.266 --> 00:15:24.236 A:middle
调用自动发布池

00:15:24.236 --> 00:15:25.586 A:middle
中的块

00:15:26.536 --> 00:15:28.476 A:middle
当返回时 NSError

00:15:28.476 --> 00:15:29.696 A:middle
同时会被销毁

00:15:30.416 --> 00:15:31.796 A:middle
这个方法不安全

00:15:32.316 --> 00:15:36.336 A:middle
在 Xcode 9 中 这个不安全捕捉

00:15:36.336 --> 00:15:37.266 A:middle
会触发警告

00:15:38.496 --> 00:15:40.696 A:middle
最简单的解决方案是使

00:15:40.696 --> 00:15:41.866 A:middle
输出参数变成

00:15:41.866 --> 00:15:42.496 A:middle
强引用

00:15:43.156 --> 00:15:44.576 A:middle
这样方法能使值

00:15:44.816 --> 00:15:46.606 A:middle
在任何自动发布池中一直存在

00:15:47.856 --> 00:15:49.286 A:middle
这个方法能一直奏效 只要

00:15:49.286 --> 00:15:50.876 A:middle
validateDictionaryUsingChecker 的所有调用器

00:15:50.876 --> 00:15:52.496 A:middle
在使用 ARC

00:15:54.026 --> 00:15:55.556 A:middle
另一个选择是使用

00:15:55.556 --> 00:15:56.756 A:middle
本地块变量

00:15:57.836 --> 00:16:00.036 A:middle
在这个方法中 strongError（强错误）被初始化为

00:15:57.836 --> 00:16:00.036 A:middle
在这个方法中 strongError（强错误）被初始化为

00:16:00.036 --> 00:16:00.406 A:middle
“nil”

00:16:01.126 --> 00:16:03.316 A:middle
如果枚举很早结束

00:16:03.566 --> 00:16:05.886 A:middle
strongError 会安全地存储

00:16:05.886 --> 00:16:06.226 A:middle
NSError

00:16:07.466 --> 00:16:09.186 A:middle
然后 输出参数

00:16:09.186 --> 00:16:11.056 A:middle
在枚举完成之后

00:16:11.056 --> 00:16:11.516 A:middle
完成升级

00:16:12.006 --> 00:16:14.816 A:middle
这是第一个警告

00:16:15.656 --> 00:16:16.676 A:middle
接下来我们介绍第二个警告

00:16:17.976 --> 00:16:19.786 A:middle
在这个例子中 foo() 函数

00:16:19.786 --> 00:16:21.476 A:middle
声明没有任何

00:16:21.476 --> 00:16:22.106 A:middle
参数

00:16:23.686 --> 00:16:25.876 A:middle
在 C 和 Objective-C 中 这意味着

00:16:25.876 --> 00:16:27.296 A:middle
foo() 可以和

00:16:27.296 --> 00:16:28.976 A:middle
任何数或参数类调用

00:16:30.026 --> 00:16:31.236 A:middle
参数列表为空的函数

00:16:31.236 --> 00:16:32.696 A:middle
叫做

00:16:32.696 --> 00:16:34.366 A:middle
非原型声明

00:16:35.646 --> 00:16:36.926 A:middle
这个行为可以追溯至

00:16:36.996 --> 00:16:38.886 A:middle
C 语言早期 当时参数

00:16:38.886 --> 00:16:40.256 A:middle
只列在函数

00:16:40.256 --> 00:16:41.716 A:middle
定义里 但是这个

00:16:41.716 --> 00:16:43.496 A:middle
声明对于类来说并不安全

00:16:44.026 --> 00:16:45.416 A:middle
这绝对不会是

00:16:45.416 --> 00:16:45.766 A:middle
你想要的

00:16:46.446 --> 00:16:47.406 A:middle
不匹配定义的调用

00:16:47.406 --> 00:16:49.826 A:middle
会导致运行时崩溃

00:16:50.796 --> 00:16:52.866 A:middle
在 Xcode 9 中 编译器带有一个

00:16:52.866 --> 00:16:54.416 A:middle
新的警告 加强严格

00:16:54.416 --> 00:16:55.026 A:middle
原型

00:16:57.696 --> 00:17:00.126 A:middle
通常 解决方法是添加空

00:16:57.696 --> 00:17:00.126 A:middle
通常 解决方法是添加空

00:17:00.806 --> 00:17:02.656 A:middle
也就是“0”

00:17:02.656 --> 00:17:03.366 A:middle
参数

00:17:03.766 --> 00:17:05.496 A:middle
任何带有参数的调用都会

00:17:05.496 --> 00:17:06.116 A:middle
引发错误

00:17:07.656 --> 00:17:08.965 A:middle
由于函数指针和块

00:17:08.965 --> 00:17:10.756 A:middle
对于函数有

00:17:10.756 --> 00:17:12.796 A:middle
公用声明语法函数

00:17:12.796 --> 00:17:14.086 A:middle
如果你有以块作为

00:17:14.086 --> 00:17:15.896 A:middle
参数的函数或者方法

00:17:15.896 --> 00:17:16.976 A:middle
你也会看到这个

00:17:18.236 --> 00:17:19.836 A:middle
解决方法和

00:17:19.836 --> 00:17:20.955 A:middle
函数声明一样

00:17:21.445 --> 00:17:23.715 A:middle
添加空 明确规定“0”

00:17:23.715 --> 00:17:24.496 A:middle
参数

00:17:25.346 --> 00:17:26.846 A:middle
这样 如果你输入

00:17:26.846 --> 00:17:28.566 A:middle
错误类的块 你就会得到一个

00:17:29.456 --> 00:17:29.566 A:middle
错误

00:17:30.256 --> 00:17:32.286 A:middle
Xcode 的现代化项目

00:17:32.366 --> 00:17:33.826 A:middle
会在构建设置中开启这些警告

00:17:33.826 --> 00:17:35.816 A:middle
或者你可以

00:17:35.846 --> 00:17:37.356 A:middle
随后通过选择项目

00:17:37.356 --> 00:17:39.026 A:middle
在“Editor（编辑器）”菜单中选择

00:17:39.026 --> 00:17:40.346 A:middle
“Validate Settings（验证设置）”进行升级

00:17:40.916 --> 00:17:43.816 A:middle
你还可以

00:17:43.816 --> 00:17:45.486 A:middle
通过在构建设置中

00:17:45.676 --> 00:17:47.266 A:middle
选择“Yes (Error)”

00:17:47.266 --> 00:17:47.716 A:middle
升级新的错误警告

00:17:49.196 --> 00:17:50.146 A:middle
以上就是今天关于新的

00:17:50.146 --> 00:17:50.706 A:middle
警告功能的介绍

00:17:52.146 --> 00:17:53.516 A:middle
接下来我们介绍 C++

00:17:55.036 --> 00:17:57.466 A:middle
今年 我们做了很多工作

00:17:57.466 --> 00:17:59.286 A:middle
来改善

00:17:59.286 --> 00:18:00.426 A:middle
Xcode 中的 C++ 体验

00:17:59.286 --> 00:18:00.426 A:middle
Xcode 中的 C++ 体验

00:18:01.856 --> 00:18:02.996 A:middle
包括重构

00:18:02.996 --> 00:18:03.426 A:middle
支持

00:18:04.106 --> 00:18:05.866 A:middle
我们支持很多操作

00:18:06.406 --> 00:18:08.286 A:middle
我带领大家简单了解一下

00:18:08.286 --> 00:18:10.536 A:middle
利用 Xcode 重构 LLVM 的流程

00:18:10.536 --> 00:18:13.976 A:middle
这是一个大型 C++ 代码库

00:18:13.976 --> 00:18:15.076 A:middle
这个是其引擎

00:18:16.336 --> 00:18:18.316 A:middle
但即使你不是一个 C++

00:18:18.316 --> 00:18:19.796 A:middle
开发人员 你仍然可以

00:18:19.796 --> 00:18:21.596 A:middle
了解 Xcode 重构

00:18:21.626 --> 00:18:23.096 A:middle
如何能够改善你的

00:18:23.096 --> 00:18:23.336 A:middle
工作流

00:18:23.906 --> 00:18:27.136 A:middle
我以 InstCombiner 类的

00:18:27.136 --> 00:18:28.646 A:middle
一个成员函数定义

00:18:28.646 --> 00:18:29.146 A:middle
开始

00:18:30.276 --> 00:18:31.746 A:middle
这是组合指令的一个

00:18:31.746 --> 00:18:32.466 A:middle
实用程序

00:18:33.766 --> 00:18:35.546 A:middle
我一直不喜欢

00:18:35.546 --> 00:18:37.376 A:middle
指令的缩写形式 Inst  所以我

00:18:37.376 --> 00:18:39.026 A:middle
在 Xcode 里按住 Command 键点按它

00:18:39.026 --> 00:18:39.796 A:middle
并选择“Rename（重命名）”

00:18:41.686 --> 00:18:43.576 A:middle
即使我不是在类声明中

00:18:43.576 --> 00:18:44.746 A:middle
这个方法依然有效

00:18:46.446 --> 00:18:48.026 A:middle
我觉得指令组合这个名称

00:18:48.026 --> 00:18:48.516 A:middle
更加清楚

00:18:50.416 --> 00:18:52.406 A:middle
Xcode 更新了一个合适的名称

00:18:52.406 --> 00:18:53.856 A:middle
让我节省了很多

00:18:53.856 --> 00:18:54.096 A:middle
寻找的时间

00:18:54.726 --> 00:18:57.096 A:middle
我再次确认了类

00:18:57.096 --> 00:18:57.736 A:middle
声明

00:18:58.266 --> 00:18:59.266 A:middle
它也升级了

00:19:00.346 --> 00:19:02.846 A:middle
它在 CRTP 基类中的使用也升级了

00:19:02.846 --> 00:19:04.216 A:middle
变成了 InstVisitor

00:19:05.556 --> 00:19:07.496 A:middle
InstVisitor 使用一样的

00:19:07.496 --> 00:19:08.746 A:middle
缩写

00:19:08.806 --> 00:19:10.036 A:middle
InstCombineWorklist 也是

00:19:10.636 --> 00:19:11.726 A:middle
但是这方面我最好留待

00:19:11.726 --> 00:19:12.336 A:middle
下一次再介绍

00:19:14.216 --> 00:19:15.796 A:middle
鉴于我们可以改变一个类的

00:19:15.796 --> 00:19:17.046 A:middle
成员函数的名称

00:19:17.046 --> 00:19:18.766 A:middle
我接着操作

00:19:18.796 --> 00:19:19.856 A:middle
更加复杂的流程

00:19:20.596 --> 00:19:21.556 A:middle
这是一个模板

00:19:21.556 --> 00:19:23.176 A:middle
特化的简化类

00:19:23.176 --> 00:19:26.026 A:middle
一个用于智能

00:19:26.026 --> 00:19:27.646 A:middle
指针和自定义迭代器上的实用程序

00:19:28.156 --> 00:19:30.746 A:middle
我认为 getSimplifiedValue()

00:19:30.816 --> 00:19:32.956 A:middle
函数的命名

00:19:32.956 --> 00:19:33.406 A:middle
是错误的

00:19:34.066 --> 00:19:35.626 A:middle
它应该使用 STL 命名

00:19:35.626 --> 00:19:37.396 A:middle
惯例 正如它的类的名称一样

00:19:38.416 --> 00:19:39.526 A:middle
我再次选择“Rename”

00:19:40.886 --> 00:19:42.056 A:middle
从项目中将模板特化

00:19:42.056 --> 00:19:43.826 A:middle
绑到一起

00:19:43.826 --> 00:19:46.146 A:middle
很复杂 但是

00:19:46.146 --> 00:19:47.586 A:middle
Xcode 可以处理

00:19:48.256 --> 00:19:50.466 A:middle
这个特化

00:19:50.466 --> 00:19:52.656 A:middle
之前升级过

00:19:52.656 --> 00:19:53.846 A:middle
主要模板声明也升级过

00:19:54.996 --> 00:19:56.326 A:middle
这下面还有另一个特化

00:19:56.326 --> 00:19:58.246 A:middle
也经过了

00:19:58.926 --> 00:19:59.000 A:middle
修正

00:20:01.396 --> 00:20:03.386 A:middle
接下来 我们来到 Constants.h

00:20:03.676 --> 00:20:04.856 A:middle
这里有个类叫做

00:20:04.896 --> 00:20:06.556 A:middle
ConstantInt 代表

00:20:06.736 --> 00:20:07.616 A:middle
常量整数

00:20:08.736 --> 00:20:09.816 A:middle
这个类拥有便利

00:20:09.816 --> 00:20:11.476 A:middle
函数 能够得到真值和

00:20:11.476 --> 00:20:12.466 A:middle
假值

00:20:13.666 --> 00:20:15.516 A:middle
我给 getMax() 函数

00:20:15.516 --> 00:20:17.406 A:middle
添加了声明 以得到

00:20:17.406 --> 00:20:18.816 A:middle
最大整数值

00:20:20.296 --> 00:20:21.976 A:middle
然后我按住 Command 键并点按

00:20:21.976 --> 00:20:23.146 A:middle
为它们生成缺失的

00:20:23.146 --> 00:20:26.086 A:middle
函数定义

00:20:26.686 --> 00:20:28.476 A:middle
这时它们在 Constants.cpp 中

00:20:29.576 --> 00:20:31.486 A:middle
我喜欢它的地方在于

00:20:31.486 --> 00:20:32.666 A:middle
函数显示在

00:20:32.666 --> 00:20:33.076 A:middle
文件夹中的位置

00:20:34.276 --> 00:20:35.556 A:middle
我的新定义

00:20:35.556 --> 00:20:37.356 A:middle
在上一个成员

00:20:37.356 --> 00:20:38.926 A:middle
函数定义为同一类 ConstantInt 之后生成

00:20:38.926 --> 00:20:42.186 A:middle
但在成员函数

00:20:42.186 --> 00:20:43.476 A:middle
定义为另一个类之前

00:20:43.476 --> 00:20:44.196 A:middle
生成

00:20:45.496 --> 00:20:46.996 A:middle
这也正是我想要的

00:20:46.996 --> 00:20:47.196 A:middle
结果

00:20:48.516 --> 00:20:53.826 A:middle
[掌声]

00:20:54.326 --> 00:20:56.006 A:middle
LLVM 有很多代表整数

00:20:56.006 --> 00:20:57.076 A:middle
的代码

00:20:57.626 --> 00:20:58.896 A:middle
我看了下这个最大

00:20:58.896 --> 00:21:00.636 A:middle
公约数函数 然后

00:20:58.896 --> 00:21:00.636 A:middle
公约数函数 然后

00:21:00.636 --> 00:21:02.996 A:middle
注意到一个本地变量 Pow2

00:21:02.996 --> 00:21:03.916 A:middle
它的计算

00:21:03.916 --> 00:21:04.466 A:middle
非常复杂

00:21:05.836 --> 00:21:07.686 A:middle
这个计算真的应该归入

00:21:07.686 --> 00:21:08.546 A:middle
它自己的函数

00:21:10.346 --> 00:21:11.856 A:middle
我挑了一些代码 打开

00:21:11.856 --> 00:21:13.566 A:middle
上下文菜单

00:21:13.566 --> 00:21:15.276 A:middle
点按“Extract Function（提取函数）”

00:21:15.276 --> 00:21:17.156 A:middle
挑选过程比较马虎

00:21:17.156 --> 00:21:19.016 A:middle
但是 Xcode 很聪明

00:21:19.016 --> 00:21:20.136 A:middle
还是奏效了

00:21:21.466 --> 00:21:23.116 A:middle
这样我就直接进入了

00:21:23.116 --> 00:21:24.266 A:middle
屏幕底部的

00:21:24.266 --> 00:21:24.656 A:middle
重命名

00:21:25.466 --> 00:21:27.976 A:middle
我选择 countCommonPowersOf2

00:21:29.276 --> 00:21:30.496 A:middle
我们向上滚动 看一下这个

00:21:30.496 --> 00:21:31.036 A:middle
定义

00:21:31.776 --> 00:21:33.886 A:middle
这个关键就是

00:21:33.886 --> 00:21:35.626 A:middle
参数 A 和 B

00:21:35.656 --> 00:21:36.926 A:middle
是自动

00:21:36.926 --> 00:21:37.626 A:middle
被引用捕捉的

00:21:38.696 --> 00:21:40.286 A:middle
这一点很重要因为它们

00:21:40.286 --> 00:21:41.046 A:middle
正在被修改

00:21:41.826 --> 00:21:45.206 A:middle
提取函数纠正了这个问题

00:21:45.856 --> 00:21:47.336 A:middle
提取这个函数是一个

00:21:47.336 --> 00:21:49.336 A:middle
利用提前返回

00:21:49.336 --> 00:21:50.996 A:middle
清理代码的好机会

00:21:53.496 --> 00:21:55.466 A:middle
我很开心

00:21:55.466 --> 00:21:56.996 A:middle
我在循环展开的

00:21:56.996 --> 00:21:58.386 A:middle
优化程序中发现了

00:21:58.386 --> 00:21:58.866 A:middle
这个代码

00:21:59.976 --> 00:22:02.666 A:middle
我在一个 if 语句中

00:21:59.976 --> 00:22:02.666 A:middle
我在一个 if 语句中

00:22:02.736 --> 00:22:03.686 A:middle
发现了 getLoopFor() 的调用

00:22:05.066 --> 00:22:06.586 A:middle
这个相同的函数再次被调用

00:22:06.586 --> 00:22:08.696 A:middle
为相同的参数 就在下面的

00:22:08.696 --> 00:22:11.206 A:middle
一个 while 循环中

00:22:11.776 --> 00:22:13.446 A:middle
getLoopFor 做了一个散列表

00:22:13.446 --> 00:22:14.786 A:middle
查询 这并不容易

00:22:15.596 --> 00:22:17.146 A:middle
因为 while 循环不

00:22:17.146 --> 00:22:18.816 A:middle
改变散列表

00:22:18.816 --> 00:22:20.446 A:middle
我按住 Command 键点击它 选择

00:22:20.546 --> 00:22:22.356 A:middle
“Extract Repeated Expression（提取重复表达）”

00:22:24.286 --> 00:22:25.526 A:middle
这个方法将

00:22:25.526 --> 00:22:27.056 A:middle
函数调用的结果存储在本地

00:22:27.056 --> 00:22:28.896 A:middle
变量中 所以只调用

00:22:28.896 --> 00:22:30.636 A:middle
一次 接着我马上使用

00:22:30.636 --> 00:22:31.676 A:middle
重命名

00:22:32.286 --> 00:22:35.036 A:middle
我选择了 LoopLatch 这个名称

00:22:35.606 --> 00:22:37.566 A:middle
很简单

00:22:38.066 --> 00:22:39.856 A:middle
提取和重命名

00:22:39.856 --> 00:22:40.256 A:middle
放在一起很清晰

00:22:42.676 --> 00:22:44.706 A:middle
重构之后 我

00:22:44.706 --> 00:22:45.846 A:middle
觉得我需要写一些新的代码

00:22:47.266 --> 00:22:48.856 A:middle
ArrayRef 是一个

00:22:48.856 --> 00:22:50.526 A:middle
连续值的泛化引用

00:22:50.996 --> 00:22:52.776 A:middle
无论是在 STL 矢量中

00:22:52.886 --> 00:22:54.806 A:middle
还是在 LLVM 自定义数据

00:22:54.806 --> 00:22:55.466 A:middle
结构中

00:22:56.466 --> 00:22:58.016 A:middle
注意 ArrayRef

00:22:58.016 --> 00:22:59.886 A:middle
数组中数值类的

00:22:59.886 --> 00:23:00.286 A:middle
模版化

00:22:59.886 --> 00:23:00.286 A:middle
模版化

00:23:01.356 --> 00:23:03.116 A:middle
我认为

00:23:03.116 --> 00:23:04.626 A:middle
比较两组 ArrayRefs 应该是有用的

00:23:05.486 --> 00:23:06.886 A:middle
为什么不执行一个

00:23:06.886 --> 00:23:07.476 A:middle
字符串一样的比较呢

00:23:08.466 --> 00:23:09.896 A:middle
我需要从零循环至

00:23:09.896 --> 00:23:11.416 A:middle
左右之间

00:23:11.416 --> 00:23:12.766 A:middle
的最小值

00:23:13.586 --> 00:23:14.756 A:middle
当我点击

00:23:14.756 --> 00:23:16.796 A:middle
左边后面的点时 代码完成

00:23:16.796 --> 00:23:17.276 A:middle
开始生效

00:23:18.286 --> 00:23:20.666 A:middle
请记住 左边是

00:23:20.706 --> 00:23:21.886 A:middle
<T> 的模板化

00:23:22.366 --> 00:23:24.866 A:middle
很酷

00:23:25.626 --> 00:23:27.676 A:middle
代码完成可以利用

00:23:27.676 --> 00:23:29.716 A:middle
模板 这是 Xcode 9 的新功能

00:23:30.516 --> 00:23:36.226 A:middle
[掌声]

00:23:36.726 --> 00:23:38.526 A:middle
这就是 Xcode 的 C++ 重构和

00:23:38.526 --> 00:23:39.966 A:middle
代码完成

00:23:40.316 --> 00:23:43.226 A:middle
接下来我们来谈一谈

00:23:43.226 --> 00:23:44.926 A:middle
C++17 标准的新特点

00:23:45.436 --> 00:23:49.056 A:middle
我会从 STL 的元组开始

00:23:49.056 --> 00:23:51.476 A:middle
这个类来自于 C++11 非常有用

00:23:51.476 --> 00:23:53.166 A:middle
它支持多个返回值

00:23:54.126 --> 00:23:55.536 A:middle
但是对它进行分解很麻烦

00:23:56.386 --> 00:23:58.176 A:middle
分解需要

00:23:58.176 --> 00:24:00.706 A:middle
变量连结 类型

00:23:58.176 --> 00:24:00.706 A:middle
变量连结 类型

00:24:00.706 --> 00:24:02.716 A:middle
无法推理

00:24:02.716 --> 00:24:03.856 A:middle
变量的名称需要

00:24:03.856 --> 00:24:04.486 A:middle
复制

00:24:05.746 --> 00:24:07.906 A:middle
C++17 通过

00:24:07.906 --> 00:24:10.136 A:middle
结构化绑定解决了这个问题

00:24:10.136 --> 00:24:11.676 A:middle
它将名称直接和

00:24:11.836 --> 00:24:12.886 A:middle
返回元组元素绑定

00:24:14.666 --> 00:24:16.066 A:middle
这个功能很棒

00:24:16.226 --> 00:24:17.436 A:middle
有了这个方法

00:24:17.436 --> 00:24:18.126 A:middle
利用元组将变得容易得多

00:24:18.706 --> 00:24:20.016 A:middle
结构化绑定可以运用在

00:24:20.016 --> 00:24:21.526 A:middle
很多方面

00:24:22.246 --> 00:24:23.976 A:middle
它还可以以创新的方法

00:24:24.016 --> 00:24:25.316 A:middle
运用在旧式数据类上 比如

00:24:25.416 --> 00:24:25.676 A:middle
Point

00:24:26.726 --> 00:24:28.476 A:middle
语法和

00:24:28.476 --> 00:24:29.316 A:middle
元组完全一样

00:24:29.596 --> 00:24:32.486 A:middle
以上是结构化绑定

00:24:33.136 --> 00:24:35.656 A:middle
另一个功能是

00:24:35.656 --> 00:24:36.586 A:middle
if 语句中的初始化

00:24:38.216 --> 00:24:39.006 A:middle
这里举个例子

00:24:39.806 --> 00:24:41.656 A:middle
初始化程序

00:24:41.656 --> 00:24:43.176 A:middle
在路径字符串中找到了最后的斜杠

00:24:43.876 --> 00:24:45.616 A:middle
斜杠变量范围

00:24:45.616 --> 00:24:46.906 A:middle
限定在 if 语句中

00:24:48.626 --> 00:24:50.016 A:middle
接着 条件检查

00:24:50.176 --> 00:24:51.456 A:middle
斜杠是否被找到

00:24:52.926 --> 00:24:55.296 A:middle
如果找到的话 斜杠将被用于

00:24:55.296 --> 00:24:57.556 A:middle
切分路径

00:24:58.036 --> 00:24:59.086 A:middle
这个功能也一样适用于

00:24:59.086 --> 00:24:59.906 A:middle
switch 语句

00:25:01.406 --> 00:25:02.786 A:middle
最小化斜杠变量

00:25:02.786 --> 00:25:04.946 A:middle
的范围有助于防止

00:25:04.946 --> 00:25:05.406 A:middle
Bug

00:25:06.136 --> 00:25:07.656 A:middle
如果函数继续

00:25:07.896 --> 00:25:09.606 A:middle
如果我们尝试复用斜杠变量

00:25:09.666 --> 00:25:11.086 A:middle
会得到一个错误

00:25:11.926 --> 00:25:13.866 A:middle
这是好事 因为逻辑上这

00:25:13.866 --> 00:25:14.506 A:middle
是不相关的

00:25:15.026 --> 00:25:18.756 A:middle
接下来我们介绍

00:25:18.756 --> 00:25:19.806 A:middle
模板化函数的一个功能

00:25:21.556 --> 00:25:23.356 A:middle
Advance 是一个简单的

00:25:23.356 --> 00:25:24.736 A:middle
先行迭代器的模板

00:25:24.736 --> 00:25:25.226 A:middle
算法

00:25:26.006 --> 00:25:27.446 A:middle
它已经配置在 STL 中很长时间了

00:25:27.446 --> 00:25:29.546 A:middle
今天我们把它作为

00:25:29.546 --> 00:25:30.076 A:middle
一个例子

00:25:31.166 --> 00:25:32.616 A:middle
一个大于 0 的 n 它推动

00:25:32.616 --> 00:25:35.086 A:middle
迭代器向前 一个小于 0 的 n

00:25:35.086 --> 00:25:36.076 A:middle
它使

00:25:36.076 --> 00:25:37.566 A:middle
迭代器后退

00:25:38.776 --> 00:25:40.536 A:middle
比如 你有时候可能想

00:25:40.536 --> 00:25:42.376 A:middle
在一张链表中

00:25:42.376 --> 00:25:43.036 A:middle
预先查看 5 个节点

00:25:43.766 --> 00:25:45.546 A:middle
Advance 会一个一个

00:25:45.546 --> 00:25:46.026 A:middle
向前计数

00:25:47.936 --> 00:25:50.406 A:middle
相同的代码也可以用来得到

00:25:50.406 --> 00:25:51.706 A:middle
一个字符串的第五个字符

00:25:52.346 --> 00:25:53.826 A:middle
用相同的接口

00:25:53.826 --> 00:25:55.496 A:middle
在两个数据结构中先行

00:25:55.496 --> 00:25:56.276 A:middle
效果很好

00:25:57.486 --> 00:25:59.656 A:middle
但是这个代码

00:25:59.656 --> 00:26:00.236 A:middle
在字符串中运行很慢

00:25:59.656 --> 00:26:00.236 A:middle
在字符串中运行很慢

00:26:00.676 --> 00:26:02.156 A:middle
对于有随机访问迭代器的

00:26:02.156 --> 00:26:03.976 A:middle
数组字符串

00:26:03.976 --> 00:26:04.616 A:middle
我们不需要循环

00:26:05.416 --> 00:26:06.946 A:middle
Operator + 会跳转到

00:26:06.946 --> 00:26:07.636 A:middle
概念时

00:26:08.186 --> 00:26:11.516 A:middle
但是添加一个简单的 if 语句

00:26:11.516 --> 00:26:13.116 A:middle
没有效果 因为它只是一个

00:26:13.156 --> 00:26:14.076 A:middle
运行时检查

00:26:15.196 --> 00:26:17.146 A:middle
它的主体需要

00:26:17.146 --> 00:26:19.166 A:middle
为所有模板实例化进行编译

00:26:19.506 --> 00:26:21.016 A:middle
但是链表迭代器不能

00:26:21.016 --> 00:26:22.516 A:middle
配置 Operator +

00:26:23.016 --> 00:26:25.766 A:middle
我们面临一个问题

00:26:27.246 --> 00:26:29.246 A:middle
Advance 需要一个通用接口

00:26:29.246 --> 00:26:30.906 A:middle
为链表和字符串

00:26:31.696 --> 00:26:34.386 A:middle
和数组的快速路径

00:26:34.566 --> 00:26:34.666 A:middle
进行编译

00:26:34.966 --> 00:26:36.206 A:middle
经典解决方法是

00:26:36.206 --> 00:26:37.666 A:middle
一种叫做编译时

00:26:37.666 --> 00:26:39.366 A:middle
派发的技术 其逻辑被

00:26:39.366 --> 00:26:40.686 A:middle
分解成过载帮助函数

00:26:40.686 --> 00:26:42.436 A:middle
且 Advance 基于

00:26:42.436 --> 00:26:44.146 A:middle
编译时类特性调用

00:26:44.146 --> 00:26:45.426 A:middle
合适的过载

00:26:45.946 --> 00:26:48.496 A:middle
编译时派发是有效的

00:26:48.866 --> 00:26:50.566 A:middle
它也是 C++ 库的作者们

00:26:50.566 --> 00:26:51.656 A:middle
努力工作了几十年的成果

00:26:52.816 --> 00:26:54.236 A:middle
即使这是一个很先进的技术

00:26:54.536 --> 00:26:55.986 A:middle
我们要做的却

00:26:56.036 --> 00:26:56.566 A:middle
非常简单

00:26:58.276 --> 00:27:00.376 A:middle
原先无效的代码

00:26:58.276 --> 00:27:00.376 A:middle
原先无效的代码

00:27:00.586 --> 00:27:01.746 A:middle
其实也很容易理解

00:27:03.016 --> 00:27:06.876 A:middle
在 C++17 中 constexpr if 可以让

00:27:06.876 --> 00:27:08.076 A:middle
你很自然地表达这个

00:27:08.316 --> 00:27:08.906 A:middle
逻辑

00:27:10.826 --> 00:27:12.796 A:middle
constexpr if 在实例化模板时

00:27:12.796 --> 00:27:14.276 A:middle
删除了不用的路径

00:27:14.276 --> 00:27:16.256 A:middle
所以链表代码

00:27:16.256 --> 00:27:18.896 A:middle
会继续编译 但是 Advance

00:27:18.896 --> 00:27:20.276 A:middle
会使用字符串和数组的

00:27:20.276 --> 00:27:22.586 A:middle
快速路径

00:27:23.266 --> 00:27:25.616 A:middle
constexpr if 使得阅读和

00:27:25.616 --> 00:27:27.636 A:middle
书写通用代码

00:27:27.636 --> 00:27:28.006 A:middle
变得更加简单

00:27:30.956 --> 00:27:32.726 A:middle
最后在结束之前 我们介绍一个新的

00:27:32.726 --> 00:27:34.016 A:middle
字符串程序库功能

00:27:35.276 --> 00:27:38.146 A:middle
STL 字符串类有着丰富的

00:27:38.146 --> 00:27:40.136 A:middle
API 但它并不一直是

00:27:40.136 --> 00:27:40.656 A:middle
合适的工具

00:27:41.716 --> 00:27:43.136 A:middle
这个例子可能看起来

00:27:43.136 --> 00:27:43.636 A:middle
有点眼熟

00:27:44.486 --> 00:27:46.456 A:middle
这个函数切分用于寻找

00:27:46.456 --> 00:27:48.036 A:middle
路径参数的最后一个

00:27:48.036 --> 00:27:48.456 A:middle
斜杠

00:27:48.996 --> 00:27:51.816 A:middle
如果它找到斜杠 它会将

00:27:51.816 --> 00:27:53.686 A:middle
路径切分为目录和

00:27:53.686 --> 00:27:54.236 A:middle
文件名

00:27:55.556 --> 00:27:57.116 A:middle
当没有斜杠时 它会将

00:27:57.116 --> 00:27:58.466 A:middle
完整路径返回至文件名

00:27:59.996 --> 00:28:02.436 A:middle
由于字符串的 API

00:27:59.996 --> 00:28:02.436 A:middle
由于字符串的 API

00:28:02.436 --> 00:28:04.386 A:middle
这个代码很容易编写

00:28:04.866 --> 00:28:06.126 A:middle
但是有性能方面的

00:28:06.126 --> 00:28:06.436 A:middle
问题

00:28:07.836 --> 00:28:09.986 A:middle
切分返回了

00:28:09.986 --> 00:28:10.386 A:middle
字符串的 copy

00:28:11.586 --> 00:28:12.986 A:middle
大量使用函数 比如 split()

00:28:12.986 --> 00:28:15.046 A:middle
可能引发昂贵的

00:28:15.046 --> 00:28:15.776 A:middle
配置问题

00:28:17.686 --> 00:28:20.206 A:middle
C++17 有一个

00:28:20.206 --> 00:28:21.266 A:middle
引用字符串的新功能

00:28:22.206 --> 00:28:23.106 A:middle
叫做字符串视图

00:28:24.396 --> 00:28:26.076 A:middle
字符串视图封装未处理的

00:28:26.076 --> 00:28:27.266 A:middle
const char * 和

00:28:27.266 --> 00:28:27.876 A:middle
size_t

00:28:29.066 --> 00:28:30.666 A:middle
它有丰富的 API

00:28:30.666 --> 00:28:32.486 A:middle
就像字符串一样 所以很方便用于

00:28:32.486 --> 00:28:33.426 A:middle
字符串处理

00:28:34.856 --> 00:28:36.476 A:middle
而且顾名思义

00:28:36.506 --> 00:28:37.046 A:middle
它只是一个视图

00:28:37.936 --> 00:28:40.106 A:middle
它没有任何存储

00:28:40.106 --> 00:28:43.036 A:middle
所以永远无法生成 copy

00:28:43.486 --> 00:28:44.706 A:middle
字符串视图

00:28:44.706 --> 00:28:46.286 A:middle
性能很好 但是

00:28:46.286 --> 00:28:48.866 A:middle
有一个问题 字符串并不永远

00:28:48.866 --> 00:28:49.406 A:middle
都是安全的

00:28:51.156 --> 00:28:52.306 A:middle
因为它没有自己的

00:28:52.306 --> 00:28:54.426 A:middle
存储 在原始字符串破坏或修改后

00:28:54.456 --> 00:28:56.036 A:middle
使用字符串视图

00:28:56.036 --> 00:28:58.206 A:middle
可能引发

00:28:58.206 --> 00:28:59.236 A:middle
UAF 问题

00:29:01.336 --> 00:29:02.876 A:middle
引用原始字符串文字 如“resources/images”

00:29:02.946 --> 00:29:05.936 A:middle
一直很安全

00:29:05.936 --> 00:29:08.396 A:middle
因为原始字符串文字

00:29:08.426 --> 00:29:09.306 A:middle
有程序生命

00:29:09.306 --> 00:29:09.826 A:middle
周期

00:29:12.036 --> 00:29:13.146 A:middle
将字符串视图

00:29:13.146 --> 00:29:15.556 A:middle
作为参数是安全的 但是需要避免

00:29:15.556 --> 00:29:16.956 A:middle
越过函数返回

00:29:17.086 --> 00:29:18.336 A:middle
存储字符串视图参数

00:29:21.056 --> 00:29:23.286 A:middle
注意返回值

00:29:23.826 --> 00:29:25.466 A:middle
如果字符串视图来自

00:29:25.466 --> 00:29:26.916 A:middle
一个参数 那么使用它很安全

00:29:26.916 --> 00:29:28.406 A:middle
只要参数

00:29:28.576 --> 00:29:30.046 A:middle
不改变或不受到损坏

00:29:31.186 --> 00:29:32.956 A:middle
在这个例子里 使用目录和

00:29:32.956 --> 00:29:35.446 A:middle
文件名十分安全 只要

00:29:35.446 --> 00:29:38.236 A:middle
路径保持不变

00:29:38.236 --> 00:29:38.616 A:middle
保持有效

00:29:39.126 --> 00:29:42.546 A:middle
但如果我们用计算字符串代替路径

00:29:42.546 --> 00:29:44.806 A:middle
那么访问

00:29:44.916 --> 00:29:46.666 A:middle
目录或文件

00:29:46.746 --> 00:29:48.216 A:middle
都会引起 UAF 问题

00:29:49.816 --> 00:29:52.226 A:middle
根本原因在于切分

00:29:52.226 --> 00:29:53.476 A:middle
越过了临时对象

00:29:54.136 --> 00:29:56.006 A:middle
切分调用之后临时对象被损坏

00:29:56.006 --> 00:29:57.566 A:middle
而且其引用

00:29:57.566 --> 00:29:59.116 A:middle
变得无效

00:30:01.156 --> 00:30:03.276 A:middle
访问临时对象会引起

00:30:03.276 --> 00:30:04.316 A:middle
不明确的行为

00:30:05.156 --> 00:30:06.696 A:middle
AddressSanitizer 可以捕捉这个

00:30:06.746 --> 00:30:06.966 A:middle
Bug

00:30:08.176 --> 00:30:09.706 A:middle
大家可以观看“Understanding Undefined Behavior”

00:30:09.706 --> 00:30:11.226 A:middle
了解更多关于这种 Bug 的信息

00:30:11.226 --> 00:30:13.196 A:middle
还可以观看

00:30:13.196 --> 00:30:15.236 A:middle
“Finding Bugs Using Xcode Runtime Tools”

00:30:15.236 --> 00:30:16.656 A:middle
了解处理 Bug 的

00:30:16.916 --> 00:30:17.000 A:middle
工具

00:30:18.476 --> 00:30:20.386 A:middle
字符串视图是我今天

00:30:20.386 --> 00:30:21.526 A:middle
和大家分享的 C++17 的最后一个功能

00:30:22.656 --> 00:30:26.426 A:middle
为了测试 C++17

00:30:26.426 --> 00:30:27.996 A:middle
在你的构建设置中

00:30:27.996 --> 00:30:28.456 A:middle
设置 C++ 语言

00:30:29.236 --> 00:30:32.086 A:middle
C++17 为你提供

00:30:32.086 --> 00:30:33.786 A:middle
没有扩展名的标准化语言

00:30:34.646 --> 00:30:37.056 A:middle
GNU++17 添加了常用的

00:30:37.056 --> 00:30:37.716 A:middle
拓展名

00:30:38.216 --> 00:30:40.726 A:middle
现在 我快速地给大家介绍一下

00:30:40.726 --> 00:30:41.766 A:middle
关于链接时优化的更新

00:30:43.136 --> 00:30:45.196 A:middle
链接时优化 或简称 LTO

00:30:45.826 --> 00:30:47.576 A:middle
在链接时间内优化

00:30:47.576 --> 00:30:49.386 A:middle
可执行文件模糊

00:30:49.386 --> 00:30:50.716 A:middle
源文件之间的界限

00:30:50.716 --> 00:30:52.106 A:middle
支持优化最大化

00:30:53.076 --> 00:30:54.516 A:middle
去年我们介绍的

00:30:54.516 --> 00:30:55.996 A:middle
增量式 LTO

00:30:55.996 --> 00:30:56.866 A:middle
已经代表了目前的最新技术水平

00:30:57.766 --> 00:30:59.636 A:middle
想要了解更多信息 请观看去年

00:30:59.636 --> 00:31:01.176 A:middle
“What’s New in LLVM”的相关视频

00:30:59.636 --> 00:31:01.176 A:middle
“What’s New in LLVM”的相关视频

00:31:02.146 --> 00:31:06.036 A:middle
过去 在大型 C++ 程序中

00:31:06.036 --> 00:31:08.346 A:middle
使用 LTO 时 我们推荐更改

00:31:08.346 --> 00:31:10.476 A:middle
Debug Info Level Build

00:31:10.476 --> 00:31:12.906 A:middle
设置为

00:31:12.906 --> 00:31:13.746 A:middle
Line Tables Only

00:31:14.846 --> 00:31:16.306 A:middle
但是在 Xcode 9 中 我们将

00:31:16.306 --> 00:31:17.946 A:middle
增量式 LTO 的技术

00:31:17.946 --> 00:31:18.356 A:middle
提升到了一个新的水平

00:31:19.666 --> 00:31:20.926 A:middle
我们一起来看看链接

00:31:20.996 --> 00:31:23.296 A:middle
Apple LLVM 编译器所需要的时间

00:31:24.166 --> 00:31:26.716 A:middle
在 Xcode 8 中 一个有着完整调试信息的干净链接

00:31:26.716 --> 00:31:28.596 A:middle
需要 6 分钟

00:31:28.596 --> 00:31:29.056 A:middle
的时间

00:31:29.706 --> 00:31:30.796 A:middle
Line Tables Only 快了

00:31:30.796 --> 00:31:32.296 A:middle
3.5 分钟

00:31:33.706 --> 00:31:35.506 A:middle
Xcode 9 中配备完整调试信息

00:31:35.506 --> 00:31:38.266 A:middle
的增量式 LTO

00:31:38.266 --> 00:31:38.566 A:middle
的速度快了 35%

00:31:39.406 --> 00:31:40.616 A:middle
Line Tables Only 还是更快

00:31:40.616 --> 00:31:42.756 A:middle
但是现在只需要

00:31:42.756 --> 00:31:44.036 A:middle
90 秒

00:31:44.516 --> 00:31:46.906 A:middle
这是干净的链接

00:31:47.616 --> 00:31:50.006 A:middle
增量式 LTO 的真正作用

00:31:50.006 --> 00:31:52.236 A:middle
在于其快速的增量式

00:31:52.236 --> 00:31:52.776 A:middle
创建

00:31:53.356 --> 00:31:55.446 A:middle
当只有一个文件夹改变时

00:31:55.446 --> 00:31:56.346 A:middle
链接不会重复

00:31:56.346 --> 00:31:58.206 A:middle
不必要的优化

00:31:59.456 --> 00:32:01.426 A:middle
在 Xcode 8 中 一个 Apple LLVM 编译器

00:31:59.456 --> 00:32:01.426 A:middle
在 Xcode 8 中 一个 Apple LLVM 编译器

00:32:01.426 --> 00:32:02.816 A:middle
配备有完整调试信息的

00:32:02.816 --> 00:32:05.716 A:middle
增量式链接

00:32:05.716 --> 00:32:08.126 A:middle
只需要 21 秒

00:32:08.126 --> 00:32:09.526 A:middle
比 Line Tables Only 快了 2 倍多

00:32:10.376 --> 00:32:12.436 A:middle
这也是我们过去建议

00:32:12.436 --> 00:32:14.186 A:middle
改变调试信息水平

00:32:15.096 --> 00:32:16.746 A:middle
的原因

00:32:16.916 --> 00:32:18.236 A:middle
但是在 Xcode 9 中 相同的

00:32:18.236 --> 00:32:19.456 A:middle
增量式链接

00:32:19.506 --> 00:32:21.046 A:middle
的速度快了 2.5 倍

00:32:21.556 --> 00:32:23.186 A:middle
只需要 8 秒

00:32:23.186 --> 00:32:24.816 A:middle
它甚至比

00:32:24.816 --> 00:32:26.116 A:middle
去年的 Line Tables Only 模式还快

00:32:26.986 --> 00:32:28.716 A:middle
如果你过去考虑过增量式 LTO

00:32:28.716 --> 00:32:30.226 A:middle
但是没想过改变你的

00:32:30.226 --> 00:32:32.236 A:middle
调试信息水平

00:32:32.236 --> 00:32:32.746 A:middle
那么现在是时候再次考虑了

00:32:33.516 --> 00:32:39.156 A:middle
[掌声]

00:32:39.656 --> 00:32:40.876 A:middle
我们建议

00:32:40.906 --> 00:32:43.806 A:middle
今天就开启增量式 LTO 即使

00:32:43.806 --> 00:32:45.246 A:middle
你已经正在使用完整信息调试

00:32:45.846 --> 00:32:49.366 A:middle
以上就是“What’s New In LLVM”的全部内容

00:32:50.596 --> 00:32:52.876 A:middle
使用 @available 确保

00:32:52.876 --> 00:32:54.986 A:middle
在支持旧的 OS 时安全使用新的 API

00:32:55.816 --> 00:32:57.146 A:middle
创建时运行

00:32:57.146 --> 00:32:57.616 A:middle
静态分析器

00:32:58.916 --> 00:33:00.846 A:middle
使用 Xcode 重构代码

00:32:58.916 --> 00:33:00.846 A:middle
使用 Xcode 重构代码

00:33:01.906 --> 00:33:03.326 A:middle
试试 C++17 的

00:33:03.326 --> 00:33:04.556 A:middle
新功能

00:33:05.336 --> 00:33:07.656 A:middle
开启增量式 LTO

00:33:07.656 --> 00:33:09.116 A:middle
升级性能 而不用

00:33:09.116 --> 00:33:10.766 A:middle
牺牲增量式创建

00:33:10.766 --> 00:33:11.046 A:middle
时间

00:33:12.126 --> 00:33:13.796 A:middle
想要了解更多信息 请登录

00:33:13.796 --> 00:33:14.296 A:middle
我们的网站

00:33:15.406 --> 00:33:16.516 A:middle
我建议各位观看我们的

00:33:16.516 --> 00:33:17.446 A:middle
相关会议

00:33:18.246 --> 00:33:18.576 A:middle
谢谢大家

00:33:19.516 --> 00:33:22.500 A:middle
[掌声]
