WEBVTT

00:00:08.516 --> 00:00:16.500 A:middle
[背景杂音]

00:00:24.056 --> 00:00:24.606 A:middle
&gt;&gt; 早上好

00:00:26.576 --> 00:00:28.376 A:middle
欢迎来到主题为

00:00:28.376 --> 00:00:30.936 A:middle
理解未定义行为讲解的会议

00:00:31.286 --> 00:00:33.076 A:middle
我知道大家都已经

00:00:33.076 --> 00:00:34.886 A:middle
在调试 Bug 上花费了无数时间

00:00:34.886 --> 00:00:36.466 A:middle
但当你从发布模式

00:00:36.466 --> 00:00:38.036 A:middle
切换到调试模式时

00:00:38.036 --> 00:00:38.756 A:middle
这些 Bug 可能就消失了

00:00:39.296 --> 00:00:40.946 A:middle
你甚至还会因为

00:00:41.306 --> 00:00:42.566 A:middle
无法重现只出现在

00:00:42.566 --> 00:00:43.916 A:middle
用户设备上的 Bug

00:00:43.916 --> 00:00:44.616 A:middle
而丢失用户

00:00:45.366 --> 00:00:46.786 A:middle
这些问题反映出

00:00:46.786 --> 00:00:48.246 A:middle
在你的代码中

00:00:48.246 --> 00:00:48.500 A:middle
可能存在未定义行为

00:00:49.956 --> 00:00:51.676 A:middle
我是 Fred

00:00:51.676 --> 00:00:53.626 A:middle
在客户编译器团队工作

00:00:53.626 --> 00:00:55.266 A:middle
今天首先为大家讲解一下

00:00:55.266 --> 00:00:57.176 A:middle
什么是未定义行为

00:00:57.176 --> 00:00:57.846 A:middle
及其存在的原因

00:00:58.586 --> 00:00:59.526 A:middle
然后我们会深入探讨

00:00:59.526 --> 00:01:01.026 A:middle
编译器并看看它是如何

00:00:59.526 --> 00:01:01.026 A:middle
编译器并看看它是如何

00:01:01.026 --> 00:01:02.636 A:middle
与那些导致细微 Bug

00:01:02.636 --> 00:01:04.215 A:middle
的为定义行为

00:01:04.215 --> 00:01:04.726 A:middle
相互作用的

00:01:05.596 --> 00:01:08.496 A:middle
这些 Bug 不仅可能会

00:01:08.496 --> 00:01:09.936 A:middle
浪费你很多的调试时间

00:01:10.446 --> 00:01:11.456 A:middle
还可能会有一些

00:01:11.456 --> 00:01:12.166 A:middle
安全隐患

00:01:12.756 --> 00:01:14.596 A:middle
来自安全团队的 Ryan

00:01:14.896 --> 00:01:16.156 A:middle
将为您讲解更多这方面的内容

00:01:16.346 --> 00:01:18.656 A:middle
并教您如何使用我们的工具

00:01:18.656 --> 00:01:19.666 A:middle
避免这些问题

00:01:20.896 --> 00:01:22.506 A:middle
最后 我的同事 Anna

00:01:22.506 --> 00:01:23.856 A:middle
会上台讲解

00:01:23.856 --> 00:01:25.366 A:middle
Swift 如何解决

00:01:25.366 --> 00:01:25.806 A:middle
这些问题

00:01:27.616 --> 00:01:30.336 A:middle
那么 什么是未定义行为呢

00:01:32.076 --> 00:01:34.846 A:middle
当你的代码语法正确

00:01:34.846 --> 00:01:36.856 A:middle
但其行为

00:01:36.856 --> 00:01:39.376 A:middle
却超出了语言允许范围时

00:01:39.496 --> 00:01:43.286 A:middle
未定义行为就会

00:01:43.866 --> 00:01:44.046 A:middle
出现

00:01:45.336 --> 00:01:48.106 A:middle
C 语言和 C++ 语言

00:01:48.106 --> 00:01:49.926 A:middle
在标准上

00:01:49.926 --> 00:01:52.166 A:middle
对未定义行为

00:01:52.166 --> 00:01:52.616 A:middle
有着非常相似的定义

00:01:53.106 --> 00:01:54.006 A:middle
让我们看看

00:01:54.006 --> 00:01:55.216 A:middle
C++ 语言标准是怎么定义的

00:01:57.396 --> 00:02:00.126 A:middle
未定义行为是指

00:01:57.396 --> 00:02:00.126 A:middle
未定义行为是指

00:02:00.126 --> 00:02:01.496 A:middle
此国际标准

00:02:01.496 --> 00:02:03.216 A:middle
没有规定的

00:02:03.216 --> 00:02:04.006 A:middle
行为

00:02:04.926 --> 00:02:06.556 A:middle
这个解释不太有用 是吧

00:02:07.286 --> 00:02:11.436 A:middle
但其实后面还跟着

00:02:11.546 --> 00:02:12.846 A:middle
一个注解和更多细节

00:02:12.876 --> 00:02:14.066 A:middle
但实在太长 就没有放在屏幕上

00:02:14.336 --> 00:02:15.176 A:middle
这里是一个总结

00:02:17.706 --> 00:02:18.986 A:middle
那么 编译器能够做什么呢

00:02:19.266 --> 00:02:20.606 A:middle
如果你参加会议前就知道

00:02:20.606 --> 00:02:22.176 A:middle
未定义行为

00:02:22.176 --> 00:02:23.996 A:middle
那么你也许听说过

00:02:23.996 --> 00:02:25.146 A:middle
如果遇到了未定义

00:02:25.146 --> 00:02:26.986 A:middle
行为 编译器就会

00:02:26.986 --> 00:02:28.276 A:middle
被允许抹掉你的磁盘

00:02:29.066 --> 00:02:30.676 A:middle
我保证这种问题

00:02:30.676 --> 00:02:31.046 A:middle
不会出现

00:02:31.916 --> 00:02:32.726 A:middle
那我能做什么呢

00:02:33.766 --> 00:02:35.116 A:middle
编译器可以选择

00:02:35.116 --> 00:02:37.286 A:middle
给出警告或提示错误

00:02:37.286 --> 00:02:38.526 A:middle
来诊断问题

00:02:39.186 --> 00:02:41.076 A:middle
这是目前为止我们

00:02:41.076 --> 00:02:42.516 A:middle
最倾向于使用的解决方式

00:02:42.516 --> 00:02:43.976 A:middle
它对开发人员来说非常可行

00:02:43.976 --> 00:02:44.826 A:middle
可以避免问题

00:02:44.826 --> 00:02:45.296 A:middle
并规避问题来源

00:02:45.606 --> 00:02:48.866 A:middle
编译器还可以选择

00:02:48.866 --> 00:02:50.416 A:middle
以文本形式诊断问题

00:02:51.106 --> 00:02:52.806 A:middle
基本上 是选择

00:02:52.976 --> 00:02:54.086 A:middle
定义那些标准所未定义

00:02:54.086 --> 00:02:54.696 A:middle
的行为

00:02:55.416 --> 00:02:57.466 A:middle
我们并不常用这个方法

00:02:57.466 --> 00:02:58.376 A:middle
但是有一些

00:02:58.376 --> 00:02:59.936 A:middle
未定义行为

00:02:59.936 --> 00:03:01.496 A:middle
是常见的不支持行为

00:02:59.936 --> 00:03:01.496 A:middle
是常见的不支持行为

00:03:04.286 --> 00:03:05.916 A:middle
最后 编译器可能会产生

00:03:05.916 --> 00:03:07.846 A:middle
不可预料的结果

00:03:08.336 --> 00:03:09.826 A:middle
这会是我们今天

00:03:09.826 --> 00:03:10.836 A:middle
讨论的重点

00:03:12.056 --> 00:03:14.216 A:middle
注意 这些不可预料的结果

00:03:16.606 --> 00:03:18.526 A:middle
包括你意图的行为 这就是为什么

00:03:18.526 --> 00:03:19.486 A:middle
某些 Bug 很难被发现

00:03:20.616 --> 00:03:23.606 A:middle
在 C 族语言中

00:03:23.606 --> 00:03:25.036 A:middle
存在大量的

00:03:25.036 --> 00:03:25.546 A:middle
未定义行为

00:03:26.226 --> 00:03:27.596 A:middle
下面是一个简单的例子

00:03:28.866 --> 00:03:30.746 A:middle
C 语言标准在

00:03:30.796 --> 00:03:32.996 A:middle
Annex J 中有一系列未定义行为

00:03:32.996 --> 00:03:33.966 A:middle
的已知来源

00:03:33.966 --> 00:03:37.506 A:middle
大概有 200 种

00:03:37.756 --> 00:03:39.016 A:middle
讲到这里 你可能会

00:03:39.016 --> 00:03:41.486 A:middle
奇怪 为什么未定义行为

00:03:41.486 --> 00:03:42.796 A:middle
也能成为一个问题

00:03:42.966 --> 00:03:44.316 A:middle
为什么不能在标准中

00:03:44.316 --> 00:03:45.006 A:middle
全部定义了呢

00:03:45.006 --> 00:03:46.426 A:middle
是因为人们很懒吗

00:03:46.426 --> 00:03:47.546 A:middle
他们不想定义

00:03:47.546 --> 00:03:48.006 A:middle
所有的行为吗

00:03:49.066 --> 00:03:49.846 A:middle
当然不是

00:03:50.686 --> 00:03:51.836 A:middle
这是一个折衷的选择

00:03:52.656 --> 00:03:55.366 A:middle
C 语言的设计旨在

00:03:55.706 --> 00:03:58.096 A:middle
提高性能 可负担性和

00:03:58.096 --> 00:03:59.506 A:middle
易于实施的

00:03:59.506 --> 00:04:00.016 A:middle
安全性

00:03:59.506 --> 00:04:00.016 A:middle
安全性

00:04:01.666 --> 00:04:03.316 A:middle
C 族语言

00:04:03.316 --> 00:04:04.806 A:middle
继承了这些折衷的选择

00:04:06.136 --> 00:04:08.026 A:middle
这些选择都是有意的

00:04:08.246 --> 00:04:09.316 A:middle
并且在今天的很多情况下

00:04:09.316 --> 00:04:10.946 A:middle
仍然起着很大

00:04:10.946 --> 00:04:11.286 A:middle
的作用

00:04:12.266 --> 00:04:16.886 A:middle
我们的 OS 因此运行的很快

00:04:16.886 --> 00:04:18.745 A:middle
但就像每个折衷方案一样

00:04:18.776 --> 00:04:20.416 A:middle
总是需要付出一些代价

00:04:20.416 --> 00:04:22.005 A:middle
在这个案例中 就需要各位

00:04:22.005 --> 00:04:24.196 A:middle
开发人员来付出代价

00:04:24.586 --> 00:04:25.896 A:middle
所以让大家

00:04:25.896 --> 00:04:27.466 A:middle
了解未定义行为的存在

00:04:27.466 --> 00:04:29.926 A:middle
以及如何处理是至关重要的

00:04:30.496 --> 00:04:33.586 A:middle
就像我说的

00:04:33.586 --> 00:04:35.466 A:middle
未定义行为种类太多

00:04:35.546 --> 00:04:37.056 A:middle
没办法全部提及

00:04:37.436 --> 00:04:38.836 A:middle
但是我们可以看看

00:04:38.836 --> 00:04:39.816 A:middle
一些例子 确保

00:04:39.816 --> 00:04:43.136 A:middle
我们达成共识

00:04:43.336 --> 00:04:45.426 A:middle
第一个例子是使用

00:04:45.426 --> 00:04:46.936 A:middle
未初始化的值

00:04:47.646 --> 00:04:49.326 A:middle
在这个函数里 我们有一个

00:04:49.326 --> 00:04:50.396 A:middle
局部变量值

00:04:51.016 --> 00:04:52.386 A:middle
它在 return 语句中使用

00:04:52.386 --> 00:04:55.536 A:middle
但只有在 if 块的条件

00:04:55.536 --> 00:04:57.596 A:middle
为真时

00:04:57.596 --> 00:04:58.346 A:middle
才会被初始化

00:04:59.316 --> 00:05:01.346 A:middle
如果你将任何正数

00:04:59.316 --> 00:05:01.346 A:middle
如果你将任何正数

00:05:01.346 --> 00:05:02.986 A:middle
传递给此函数 它将调用

00:05:02.986 --> 00:05:05.136 A:middle
未定义行为 因为变量值将会

00:05:05.136 --> 00:05:06.626 A:middle
被使用和初始化

00:05:07.986 --> 00:05:09.386 A:middle
在这个简单的案例中

00:05:09.386 --> 00:05:10.646 A:middle
编译器将捕捉到问题

00:05:10.646 --> 00:05:11.376 A:middle
并发出警告

00:05:12.816 --> 00:05:14.416 A:middle
静态分析也会提供

00:05:14.416 --> 00:05:15.976 A:middle
这些信息 并且能

00:05:15.976 --> 00:05:18.156 A:middle
发现更复杂的

00:05:18.316 --> 00:05:21.026 A:middle
同类问题

00:05:22.426 --> 00:05:23.786 A:middle
第二个例子是

00:05:23.786 --> 00:05:24.906 A:middle
指针偏差

00:05:25.256 --> 00:05:28.136 A:middle
在这个函数中 我们使用一个

00:05:28.136 --> 00:05:29.656 A:middle
字符指针作为参数

00:05:30.796 --> 00:05:32.836 A:middle
但在函数内部 我们将它

00:05:32.836 --> 00:05:34.076 A:middle
用作整数指针

00:05:34.786 --> 00:05:36.976 A:middle
但问题是 并非每个

00:05:36.976 --> 00:05:38.376 A:middle
字符指针都是一个

00:05:38.376 --> 00:05:39.236 A:middle
有效整数指针

00:05:40.746 --> 00:05:42.606 A:middle
整数必须

00:05:42.606 --> 00:05:43.076 A:middle
正确对齐

00:05:43.416 --> 00:05:44.886 A:middle
通常这意味着 它们的地址

00:05:44.886 --> 00:05:46.166 A:middle
需要是 4 的整数倍

00:05:47.406 --> 00:05:48.836 A:middle
当在不同架构之间

00:05:48.836 --> 00:05:50.606 A:middle
移植代码时 这种代码

00:05:50.606 --> 00:05:52.086 A:middle
通常会导致问题

00:05:52.206 --> 00:05:53.896 A:middle
这些架构在硬件层面上

00:05:53.896 --> 00:05:55.156 A:middle
具有不同的

00:05:55.526 --> 00:05:56.046 A:middle
对齐约束

00:05:56.856 --> 00:05:58.816 A:middle
今年 我们在 Xcode 9 中

00:05:58.816 --> 00:06:00.246 A:middle
引入了新的运行时工具

00:05:58.816 --> 00:06:00.246 A:middle
引入了新的运行时工具

00:06:00.356 --> 00:06:01.366 A:middle
叫做“未定义行为杀毒器”

00:06:01.366 --> 00:06:02.796 A:middle
它可以

00:06:02.796 --> 00:06:03.660 A:middle
捕捉到这个问题

00:06:07.646 --> 00:06:09.906 A:middle
最后一个例子是

00:06:09.906 --> 00:06:10.516 A:middle
生命周期

00:06:11.706 --> 00:06:13.926 A:middle
变量仅在

00:06:13.926 --> 00:06:15.296 A:middle
作用域内定义 也就是说

00:06:15.416 --> 00:06:17.116 A:middle
我们的变量仅在其定义的

00:06:17.116 --> 00:06:18.436 A:middle
作用域内被赋值

00:06:19.336 --> 00:06:20.946 A:middle
在这里 我们使用变量

00:06:20.946 --> 00:06:22.056 A:middle
默认值的地址

00:06:23.166 --> 00:06:25.416 A:middle
默认值在 if 块内定义

00:06:25.416 --> 00:06:27.556 A:middle
且只存在于该块

00:06:28.036 --> 00:06:29.946 A:middle
但是我们可以通过在块外部

00:06:30.336 --> 00:06:32.116 A:middle
使用这个指针

00:06:32.116 --> 00:06:33.026 A:middle
来调用未定义行为

00:06:34.776 --> 00:06:37.476 A:middle
同样的 我们的工具

00:06:37.476 --> 00:06:37.696 A:middle
也会捕捉到这个问题

00:06:38.606 --> 00:06:42.236 A:middle
对于我们正在谈论的问题

00:06:42.236 --> 00:06:44.366 A:middle
我们现在有了更好的解决方法

00:06:44.366 --> 00:06:46.526 A:middle
让我们看一下

00:06:46.526 --> 00:06:47.816 A:middle
未定义行为是如何与

00:06:49.506 --> 00:06:50.876 A:middle
编译器互相作用 以及如何

00:06:50.876 --> 00:06:51.676 A:middle
产生了那些意外的 Bug

00:06:52.576 --> 00:06:55.546 A:middle
首先来看一下

00:06:55.546 --> 00:06:56.776 A:middle
编译器 未定义行为

00:06:56.776 --> 00:06:58.376 A:middle
对于编译器来说意味着什么

00:06:59.266 --> 00:07:01.556 A:middle
编译器并不会主动

00:06:59.266 --> 00:07:01.556 A:middle
编译器并不会主动

00:07:01.556 --> 00:07:03.976 A:middle
寻找未定义行为 并以奇怪的

00:07:03.976 --> 00:07:04.386 A:middle
方式转化它

00:07:04.776 --> 00:07:05.706 A:middle
这不会发生

00:07:06.306 --> 00:07:07.616 A:middle
但是编译器会

00:07:07.616 --> 00:07:09.356 A:middle
假定在你的代码中

00:07:09.356 --> 00:07:11.116 A:middle
是没有未定义行为的

00:07:11.556 --> 00:07:12.976 A:middle
否则你代码的

00:07:12.976 --> 00:07:14.086 A:middle
语义就不会被

00:07:14.086 --> 00:07:14.556 A:middle
很好地定义

00:07:15.656 --> 00:07:17.696 A:middle
通过作出这一假设

00:07:17.696 --> 00:07:20.216 A:middle
编译器会收集信息

00:07:20.456 --> 00:07:21.616 A:middle
来更好地优化你的代码

00:07:21.716 --> 00:07:24.756 A:middle
给大家举几个例子

00:07:26.416 --> 00:07:28.296 A:middle
由于未定义为溢出

00:07:28.296 --> 00:07:30.346 A:middle
分配的整数 如果 X

00:07:30.346 --> 00:07:31.986 A:middle
被分配整数 则编译器

00:07:31.986 --> 00:07:33.976 A:middle
可以假设 X 低于

00:07:33.976 --> 00:07:34.616 A:middle
X + 1

00:07:35.386 --> 00:07:37.326 A:middle
这是一个非常简单但

00:07:37.326 --> 00:07:38.696 A:middle
非常强大的假设

00:07:38.696 --> 00:07:40.226 A:middle
比如说 在处理循环优化时

00:07:40.226 --> 00:07:41.036 A:middle
就可以作此假设

00:07:42.836 --> 00:07:45.826 A:middle
就像我说过的

00:07:45.826 --> 00:07:46.296 A:middle
指针需要对齐

00:07:47.136 --> 00:07:48.416 A:middle
通过作出假设

00:07:48.416 --> 00:07:49.916 A:middle
编译器可以

00:07:49.916 --> 00:07:52.056 A:middle
使用更强大的内存访问指令

00:07:52.056 --> 00:07:53.396 A:middle
如向量指令

00:07:53.396 --> 00:07:55.046 A:middle
使你的代码

00:07:55.046 --> 00:07:55.786 A:middle
更快地运行

00:07:56.356 --> 00:08:00.736 A:middle
最后一个例子是

00:07:56.356 --> 00:08:00.736 A:middle
最后一个例子是

00:08:00.736 --> 00:08:02.246 A:middle
未定义解引用另一指针

00:08:02.246 --> 00:08:03.986 A:middle
所以编译器可以

00:08:03.986 --> 00:08:05.596 A:middle
假设每一个被解引用的

00:08:05.596 --> 00:08:08.456 A:middle
指针都不是现在的

00:08:08.456 --> 00:08:09.976 A:middle
并使用这些信息来进一步

00:08:09.976 --> 00:08:10.696 A:middle
优化你的代码

00:08:12.946 --> 00:08:14.526 A:middle
让我们更具体一些

00:08:14.526 --> 00:08:16.496 A:middle
看看编译器是

00:08:16.496 --> 00:08:17.416 A:middle
如何工作的

00:08:18.346 --> 00:08:19.856 A:middle
编译器会从很高层级

00:08:19.856 --> 00:08:21.336 A:middle
输入你的源代码

00:08:22.236 --> 00:08:23.466 A:middle
并将其转换成

00:08:23.466 --> 00:08:24.666 A:middle
中间代码

00:08:24.996 --> 00:08:27.466 A:middle
然后应用优化

00:08:27.466 --> 00:08:29.016 A:middle
流水线

00:08:29.016 --> 00:08:30.316 A:middle
来生成

00:08:30.676 --> 00:08:30.846 A:middle
二进制文件

00:08:30.846 --> 00:08:32.765 A:middle
这中间的每一次优化

00:08:32.765 --> 00:08:35.076 A:middle
都有一个目标 那就是

00:08:35.076 --> 00:08:37.265 A:middle
将输入的信息生成

00:08:37.265 --> 00:08:39.106 A:middle
更有效的代码 同时

00:08:39.106 --> 00:08:39.796 A:middle
保留语义

00:08:40.326 --> 00:08:44.265 A:middle
但是大会开始时

00:08:44.426 --> 00:08:45.726 A:middle
我讲了那些在

00:08:45.796 --> 00:08:47.376 A:middle
发布模式下会再现

00:08:47.416 --> 00:08:48.386 A:middle
在调试模式下会消失的 Bug

00:08:48.386 --> 00:08:49.526 A:middle
那么 这种行为

00:08:49.526 --> 00:08:50.226 A:middle
是如何保留的呢

00:08:51.266 --> 00:08:52.916 A:middle
我们来看一个简单的例子

00:08:54.056 --> 00:08:55.716 A:middle
上面是我们的

00:08:55.716 --> 00:08:56.066 A:middle
编译器

00:08:57.506 --> 00:08:58.946 A:middle
它只有一种优化

00:08:59.266 --> 00:09:00.416 A:middle
死代码删除

00:08:59.266 --> 00:09:00.416 A:middle
死代码删除

00:09:01.066 --> 00:09:03.886 A:middle
死代码删除会查找

00:09:03.886 --> 00:09:06.666 A:middle
无法执行的代码

00:09:06.666 --> 00:09:08.156 A:middle
或者对程序运行结果

00:09:08.156 --> 00:09:10.186 A:middle
没有任何影响的代码

00:09:10.186 --> 00:09:11.526 A:middle
并将其删除 从而

00:09:11.526 --> 00:09:13.326 A:middle
使你的 App 变得更小

00:09:14.786 --> 00:09:16.166 A:middle
让我们将这个编译器

00:09:16.166 --> 00:09:17.236 A:middle
应用到一个简单的函数中

00:09:18.276 --> 00:09:19.636 A:middle
这个函数只有两个语句

00:09:19.636 --> 00:09:20.916 A:middle
一个变量赋值

00:09:20.916 --> 00:09:22.576 A:middle
和一个 return

00:09:22.576 --> 00:09:23.006 A:middle
语句

00:09:23.636 --> 00:09:26.906 A:middle
我们运行死代码删除

00:09:27.896 --> 00:09:29.876 A:middle
并没有使用变量

00:09:29.986 --> 00:09:32.426 A:middle
让我们去掉它

00:09:32.686 --> 00:09:34.616 A:middle
看看这里 我们得到了什么

00:09:35.546 --> 00:09:37.216 A:middle
如果我们将另一个指针传递给

00:09:37.216 --> 00:09:38.236 A:middle
这个函数 会发生什么情况

00:09:38.776 --> 00:09:40.646 A:middle
未优化版本会崩溃

00:09:40.646 --> 00:09:42.936 A:middle
而优化版本将

00:09:42.936 --> 00:09:44.346 A:middle
顺利地返回 42

00:09:44.996 --> 00:09:46.476 A:middle
所以 它们的行为

00:09:46.476 --> 00:09:46.956 A:middle
有差异

00:09:47.936 --> 00:09:49.576 A:middle
但是 通过传递 null 给

00:09:49.576 --> 00:09:51.496 A:middle
此函数 你调用了未定义行为

00:09:51.496 --> 00:09:53.756 A:middle
也就是 未定义解引用

00:09:53.756 --> 00:09:54.966 A:middle
另一个指针

00:09:56.156 --> 00:09:57.756 A:middle
我再说一遍

00:09:57.756 --> 00:09:59.566 A:middle
未定义解引用

00:09:59.566 --> 00:10:00.226 A:middle
另一个指针

00:09:59.566 --> 00:10:00.226 A:middle
另一个指针

00:10:00.276 --> 00:10:02.056 A:middle
它没有被定义为崩溃

00:10:03.216 --> 00:10:05.116 A:middle
如果解引用另一个指针

00:10:05.116 --> 00:10:07.456 A:middle
被定义为崩溃 或者如果

00:10:07.456 --> 00:10:08.826 A:middle
由于某些其他原因 编译器

00:10:08.826 --> 00:10:10.166 A:middle
无法假定该解引用指针

00:10:10.546 --> 00:10:12.236 A:middle
是有效的 那么

00:10:12.236 --> 00:10:14.796 A:middle
在内存访问上进行

00:10:14.796 --> 00:10:16.306 A:middle
任何转换都是

00:10:16.306 --> 00:10:17.236 A:middle
非常困难的

00:10:17.396 --> 00:10:19.066 A:middle
比如说 不能重新排序

00:10:19.066 --> 00:10:21.086 A:middle
不能合并

00:10:21.086 --> 00:10:22.206 A:middle
不能删除无用的部分

00:10:22.206 --> 00:10:23.296 A:middle
就像我们刚才看到的那样

00:10:26.166 --> 00:10:27.696 A:middle
处理内存访问是

00:10:27.796 --> 00:10:29.346 A:middle
编译器工作的一个重要部分

00:10:30.586 --> 00:10:31.896 A:middle
所以 这个例子就告诉大家

00:10:32.026 --> 00:10:34.306 A:middle
未定义行为是如何

00:10:34.306 --> 00:10:35.546 A:middle
在未优化代码和

00:10:35.546 --> 00:10:37.046 A:middle
优化代码间

00:10:37.046 --> 00:10:37.816 A:middle
改变程序行为的

00:10:38.436 --> 00:10:39.426 A:middle
但我还想给大家

00:10:39.426 --> 00:10:39.616 A:middle
展示更多的例子

00:10:40.186 --> 00:10:41.536 A:middle
让我们看一个稍微

00:10:41.536 --> 00:10:42.526 A:middle
复杂的例子

00:10:44.136 --> 00:10:45.956 A:middle
我们再次把编译器

00:10:45.956 --> 00:10:47.856 A:middle
放在上面 把源代码

00:10:47.856 --> 00:10:48.276 A:middle
放在下面

00:10:49.206 --> 00:10:51.246 A:middle
这个例子实际上来源于

00:10:51.506 --> 00:10:53.106 A:middle
一个真实问题

00:10:53.106 --> 00:10:54.536 A:middle
发生在几年前的

00:10:54.716 --> 00:10:55.746 A:middle
开放源代码活动中

00:10:55.976 --> 00:10:57.586 A:middle
所以 不要把它当作

00:10:57.586 --> 00:10:58.926 A:middle
纯理论而忽略它

00:11:00.786 --> 00:11:02.426 A:middle
当你有一个很大的函数

00:11:02.616 --> 00:11:03.996 A:middle
由很多个人在很长

00:11:04.076 --> 00:11:05.566 A:middle
一段时间内修改

00:11:05.566 --> 00:11:07.896 A:middle
就会很容易最后变成

00:11:07.896 --> 00:11:09.426 A:middle
和过去一样的东西

00:11:09.426 --> 00:11:10.786 A:middle
就像这个函数顶端没有使用过的

00:11:10.786 --> 00:11:11.406 A:middle
变量一样

00:11:12.606 --> 00:11:14.786 A:middle
现在 让我们来编译这个代码

00:11:15.296 --> 00:11:16.596 A:middle
我们的新编译器多了

00:11:16.596 --> 00:11:17.336 A:middle
一种优化

00:11:17.986 --> 00:11:19.226 A:middle
冗余空检查

00:11:19.226 --> 00:11:19.976 A:middle
删除

00:11:20.916 --> 00:11:22.186 A:middle
这是死代码删除

00:11:22.186 --> 00:11:23.796 A:middle
的一个专用

00:11:23.796 --> 00:11:24.526 A:middle
版本

00:11:24.976 --> 00:11:26.436 A:middle
它会查找与现在相比

00:11:26.436 --> 00:11:28.596 A:middle
的指针 并尝试确定

00:11:28.626 --> 00:11:30.536 A:middle
静态时在程序的

00:11:30.576 --> 00:11:33.336 A:middle
这一点 是否可以证明

00:11:33.726 --> 00:11:36.316 A:middle
指针是空

00:11:36.316 --> 00:11:37.456 A:middle
还是非空

00:11:38.776 --> 00:11:40.296 A:middle
当可以这样做时

00:11:40.296 --> 00:11:41.526 A:middle
它就会删除永远无法

00:11:41.526 --> 00:11:42.366 A:middle
执行的代码

00:11:43.316 --> 00:11:46.626 A:middle
在这种情况下 p

00:11:46.626 --> 00:11:47.846 A:middle
在函数的第一行将会被

00:11:47.846 --> 00:11:48.356 A:middle
解引用

00:11:48.426 --> 00:11:49.856 A:middle
所以 指针当然

00:11:49.856 --> 00:11:50.206 A:middle
不能为空

00:11:50.806 --> 00:11:51.776 A:middle
让我们把空检查删掉

00:11:52.396 --> 00:11:56.376 A:middle
然后我们来看一下第二种

00:11:56.376 --> 00:11:57.066 A:middle
优化

00:11:57.416 --> 00:11:58.656 A:middle
我们已经知道了死代码

00:11:58.656 --> 00:11:59.396 A:middle
删除

00:12:00.116 --> 00:12:01.066 A:middle
未使用的代码未被使用

00:12:01.616 --> 00:12:02.296 A:middle
会被去掉

00:12:03.846 --> 00:12:05.796 A:middle
这就是我们的

00:12:05.796 --> 00:12:06.396 A:middle
编译结果

00:12:07.716 --> 00:12:10.006 A:middle
现在 让我们进行同样的操作

00:12:10.006 --> 00:12:11.596 A:middle
如果我们将 null 传递给

00:12:11.596 --> 00:12:12.166 A:middle
这个函数会怎么样呢

00:12:12.876 --> 00:12:14.956 A:middle
未优化版本将

00:12:14.956 --> 00:12:15.446 A:middle
崩溃

00:12:16.306 --> 00:12:18.356 A:middle
优化后的版本

00:12:18.356 --> 00:12:18.576 A:middle
也会崩溃

00:12:19.436 --> 00:12:20.806 A:middle
但请注意 它们崩溃的地方

00:12:20.806 --> 00:12:21.476 A:middle
是不同的

00:12:21.946 --> 00:12:23.296 A:middle
未优化版本会在

00:12:23.296 --> 00:12:24.086 A:middle
第一行上崩溃

00:12:24.506 --> 00:12:26.116 A:middle
优化后的版本在

00:12:26.116 --> 00:12:26.916 A:middle
最后一行上崩溃

00:12:27.706 --> 00:12:29.296 A:middle
这中间可能差了

00:12:29.296 --> 00:12:30.376 A:middle
成千上万行

00:12:31.226 --> 00:12:32.996 A:middle
这对于了解

00:12:32.996 --> 00:12:34.236 A:middle
未定义行为

00:12:34.236 --> 00:12:34.766 A:middle
是非常重要的

00:12:35.356 --> 00:12:37.786 A:middle
当未定义行为引起问题时

00:12:37.786 --> 00:12:39.996 A:middle
无论是另一个引用

00:12:39.996 --> 00:12:42.136 A:middle
整数溢出

00:12:42.136 --> 00:12:44.126 A:middle
由于超出限制访问的

00:12:44.126 --> 00:12:45.686 A:middle
内存损坏 或任何

00:12:45.686 --> 00:12:47.336 A:middle
其他类型的未定义行为

00:12:47.336 --> 00:12:49.106 A:middle
你看到的症状通常

00:12:49.106 --> 00:12:50.526 A:middle
与问题的根本原因

00:12:50.526 --> 00:12:51.336 A:middle
相差甚远

00:12:53.566 --> 00:12:54.806 A:middle
还有一件事我想

00:12:54.806 --> 00:12:55.306 A:middle
展示给大家看

00:12:56.096 --> 00:12:58.606 A:middle
我们用一个稍微

00:12:58.606 --> 00:12:59.606 A:middle
不同的编译器

00:12:59.606 --> 00:13:00.056 A:middle
重新启动编译

00:12:59.606 --> 00:13:00.056 A:middle
重新启动编译

00:13:01.136 --> 00:13:02.496 A:middle
如你所见 我们只是

00:13:02.646 --> 00:13:03.656 A:middle
交换了两种优化

00:13:04.386 --> 00:13:05.556 A:middle
我们再次编译相同

00:13:05.556 --> 00:13:05.906 A:middle
的代码

00:13:08.366 --> 00:13:10.266 A:middle
死代码删除 未使用的代码

00:13:10.266 --> 00:13:10.906 A:middle
仍未使用

00:13:10.906 --> 00:13:12.056 A:middle
它消失了

00:13:13.696 --> 00:13:15.736 A:middle
现在我们尝试应用

00:13:15.736 --> 00:13:17.330 A:middle
冗余空检查删除

00:13:18.186 --> 00:13:19.846 A:middle
对于 p 指针的值

00:13:19.846 --> 00:13:21.266 A:middle
没有任何理由进行处理

00:13:21.266 --> 00:13:22.786 A:middle
所以优化

00:13:22.786 --> 00:13:24.136 A:middle
并没有什么

00:13:24.136 --> 00:13:24.656 A:middle
作用

00:13:25.176 --> 00:13:27.886 A:middle
这是我们第二次编译

00:13:28.046 --> 00:13:29.366 A:middle
相同代码的

00:13:29.366 --> 00:13:29.616 A:middle
结果

00:13:30.446 --> 00:13:33.036 A:middle
请注意 在这种情况下

00:13:33.036 --> 00:13:34.726 A:middle
如果将空指针传递到

00:13:34.726 --> 00:13:36.466 A:middle
优化后的版本 则不会

00:13:36.886 --> 00:13:37.000 A:middle
崩溃

00:13:39.036 --> 00:13:41.816 A:middle
现在 假设你的 App

00:13:41.816 --> 00:13:43.726 A:middle
代码在左边

00:13:43.726 --> 00:13:44.946 A:middle
开发人员在这个函数中的某个点

00:13:44.946 --> 00:13:46.116 A:middle
添加了一个空的检查功能

00:13:46.116 --> 00:13:48.836 A:middle
并添加了另一个

00:13:48.836 --> 00:13:50.146 A:middle
函数的参数的一些使用

00:13:51.186 --> 00:13:52.586 A:middle
你可能从来没有意识到

00:13:52.586 --> 00:13:54.136 A:middle
这是一个问题

00:13:54.136 --> 00:13:55.566 A:middle
因为你的编译器就像编译器 2

00:13:55.566 --> 00:13:55.846 A:middle
一样

00:13:56.826 --> 00:13:58.646 A:middle
但是不能保证在将来

00:13:58.646 --> 00:14:00.396 A:middle
它不会出现像编译器 1 中

00:13:58.646 --> 00:14:00.396 A:middle
它不会出现像编译器 1 中

00:14:00.396 --> 00:14:02.206 A:middle
那样的行为 并破坏你的

00:14:02.206 --> 00:14:02.486 A:middle
代码

00:14:03.726 --> 00:14:05.356 A:middle
这可能是关于未定义行为

00:14:05.356 --> 00:14:06.606 A:middle
需要记住的

00:14:06.606 --> 00:14:07.476 A:middle
最重要的事情

00:14:07.716 --> 00:14:09.466 A:middle
你今天没有问题

00:14:09.466 --> 00:14:11.226 A:middle
并不意味着编译器中的

00:14:11.226 --> 00:14:12.806 A:middle
这种变化不会

00:14:12.806 --> 00:14:13.866 A:middle
导致它在

00:14:13.866 --> 00:14:14.276 A:middle
将来崩溃

00:14:15.786 --> 00:14:17.266 A:middle
你的编译器可能

00:14:17.266 --> 00:14:18.686 A:middle
会比你想象中的

00:14:18.686 --> 00:14:18.996 A:middle
更多变

00:14:20.966 --> 00:14:22.796 A:middle
在一天之内 每次

00:14:22.796 --> 00:14:24.046 A:middle
你在调试和发布模式之间

00:14:24.046 --> 00:14:25.796 A:middle
切换时 或者每次

00:14:25.796 --> 00:14:26.776 A:middle
更改优化设置时

00:14:26.776 --> 00:14:29.026 A:middle
都会运行不同的

00:14:29.026 --> 00:14:30.396 A:middle
编译器实例 并将一组

00:14:30.396 --> 00:14:31.476 A:middle
非常不同的转换

00:14:31.476 --> 00:14:32.786 A:middle
应用到你的

00:14:32.786 --> 00:14:33.136 A:middle
代码中

00:14:35.016 --> 00:14:36.996 A:middle
也许更令人惊讶的是

00:14:36.996 --> 00:14:38.086 A:middle
每次你从真实设备

00:14:38.086 --> 00:14:39.776 A:middle
切换到模拟器 或者反过来

00:14:39.776 --> 00:14:42.196 A:middle
你都会定向至

00:14:42.196 --> 00:14:43.746 A:middle
不同的架构

00:14:43.746 --> 00:14:45.566 A:middle
这可能会对未定义行为

00:14:45.566 --> 00:14:46.496 A:middle
产生不同的反应

00:14:47.076 --> 00:14:50.746 A:middle
当然 每次

00:14:50.746 --> 00:14:52.656 A:middle
将 Xcode 升级到一个新的

00:14:52.656 --> 00:14:54.656 A:middle
主要版本时 你都会得到一个

00:14:54.656 --> 00:14:55.176 A:middle
全新的编译器

00:14:55.176 --> 00:14:58.176 A:middle
而且我们一直在努力

00:14:58.176 --> 00:14:59.356 A:middle
使编译器生成更好

00:14:59.476 --> 00:15:01.136 A:middle
更快和更小的代码

00:14:59.476 --> 00:15:01.136 A:middle
更快和更小的代码

00:15:02.126 --> 00:15:05.296 A:middle
许多这些改进

00:15:05.296 --> 00:15:06.656 A:middle
都可能在你的代码中引发

00:15:06.656 --> 00:15:07.500 A:middle
未定义行为

00:15:09.336 --> 00:15:12.336 A:middle
在继续之前

00:15:12.616 --> 00:15:13.996 A:middle
让我来总结一下我们

00:15:13.996 --> 00:15:14.886 A:middle
了解到了哪些关于未定义行为的

00:15:14.886 --> 00:15:15.336 A:middle
信息

00:15:17.486 --> 00:15:19.836 A:middle
未定义行为不会

00:15:19.836 --> 00:15:21.176 A:middle
总是触发 Bug

00:15:22.016 --> 00:15:23.406 A:middle
可能你的一个配置

00:15:23.406 --> 00:15:24.936 A:middle
正在工作时 另一个就

00:15:24.936 --> 00:15:25.416 A:middle
中断了

00:15:26.746 --> 00:15:28.706 A:middle
当未定义行为出现

00:15:28.956 --> 00:15:31.166 A:middle
并中断代码时

00:15:31.166 --> 00:15:33.136 A:middle
你所看到的症状可能

00:15:33.296 --> 00:15:35.106 A:middle
距离问题的根本原因

00:15:35.106 --> 00:15:37.316 A:middle
有数千行之远

00:15:37.946 --> 00:15:39.356 A:middle
或者甚至间隔了几个小时的执行

00:15:39.356 --> 00:15:39.886 A:middle
时间

00:15:40.456 --> 00:15:41.486 A:middle
如果你没有

00:15:41.486 --> 00:15:42.676 A:middle
做好准备的话

00:15:42.676 --> 00:15:43.026 A:middle
这可能真的很难调试

00:15:45.076 --> 00:15:48.336 A:middle
最后一点是

00:15:48.336 --> 00:15:50.586 A:middle
你今天没有任何

00:15:50.586 --> 00:15:52.496 A:middle
已知晓的错误，并不意味着

00:15:52.496 --> 00:15:54.036 A:middle
你不会遇到任何由未定义行为

00:15:54.036 --> 00:15:54.886 A:middle
引起的错误

00:15:55.266 --> 00:15:56.556 A:middle
如果存在未定义行为

00:15:56.556 --> 00:15:58.796 A:middle
就会在将来的

00:15:58.796 --> 00:15:59.646 A:middle
某个时间引发中断

00:16:01.016 --> 00:16:03.106 A:middle
当它引发中断时 可能会

00:16:03.106 --> 00:16:04.776 A:middle
花费你很多的调试时间

00:16:04.776 --> 00:16:06.246 A:middle
但也可能会使你的用户数据处于危险之中

00:16:06.246 --> 00:16:07.036 A:middle
处于危险之中

00:16:08.076 --> 00:16:09.516 A:middle
这是Ryan 他会为你讲解更多的

00:16:09.516 --> 00:16:11.096 A:middle
关于未定义行为的

00:16:11.096 --> 00:16:12.206 A:middle
安全隐患

00:16:14.516 --> 00:16:18.896 A:middle
[掌声]

00:16:19.396 --> 00:16:19.816 A:middle
&gt;&gt; 谢谢 Fred

00:16:21.616 --> 00:16:23.276 A:middle
那么 大家有谁还记得

00:16:23.276 --> 00:16:24.496 A:middle
几年前的“心脏出血“

00:16:24.496 --> 00:16:25.126 A:middle
安全漏洞吗

00:16:26.096 --> 00:16:26.916 A:middle
如果你像我一样

00:16:26.916 --> 00:16:27.866 A:middle
可能不得不会去

00:16:27.866 --> 00:16:29.356 A:middle
100 个不同的网站

00:16:29.356 --> 00:16:31.246 A:middle
修改密码 或者也许

00:16:31.486 --> 00:16:33.026 A:middle
为你自己的后台服务器

00:16:33.026 --> 00:16:33.516 A:middle
打补丁

00:16:34.486 --> 00:16:35.446 A:middle
“心脏出血”是一种

00:16:35.446 --> 00:16:37.216 A:middle
在广泛使用的

00:16:37.216 --> 00:16:38.556 A:middle
OpenSSL 的密码库中的

00:16:38.556 --> 00:16:39.506 A:middle
越界读取

00:16:40.196 --> 00:16:41.906 A:middle
通过向受影响的服务器

00:16:41.906 --> 00:16:43.686 A:middle
发送一个数据包 攻击者

00:16:43.686 --> 00:16:44.926 A:middle
就会收到服务器

00:16:44.926 --> 00:16:46.056 A:middle
进程堆内存的

00:16:46.056 --> 00:16:48.136 A:middle
几千字节 这引发了

00:16:48.136 --> 00:16:51.796 A:middle
相当严重的隐私泄漏

00:16:52.056 --> 00:16:53.586 A:middle
和安全问题

00:16:55.696 --> 00:16:58.826 A:middle
“心脏出血”的越界读取

00:16:58.826 --> 00:17:00.236 A:middle
就是一个未定义行为

00:16:58.826 --> 00:17:00.236 A:middle
就是一个未定义行为

00:17:00.236 --> 00:17:01.956 A:middle
的例子 而事实证明

00:17:01.956 --> 00:17:03.316 A:middle
未定义行为是

00:17:03.316 --> 00:17:04.346 A:middle
许多不同类型的

00:17:04.346 --> 00:17:05.026 A:middle
安全漏洞的

00:17:05.026 --> 00:17:05.626 A:middle
核心

00:17:06.465 --> 00:17:08.185 A:middle
仅举几个例子 你就可以

00:17:08.185 --> 00:17:11.556 A:middle
想到缓冲区溢出

00:17:11.556 --> 00:17:14.016 A:middle
未初始化变量的使用

00:17:14.016 --> 00:17:16.766 A:middle
和 Heat Misuse Bug

00:17:16.766 --> 00:17:17.465 A:middle
比如 Use-After-Free 和 Double Free

00:17:18.086 --> 00:17:19.526 A:middle
还有竞争条件漏洞

00:17:22.296 --> 00:17:24.215 A:middle
所以 请记住 你的用户

00:17:24.415 --> 00:17:27.316 A:middle
信任你的 App  并且可能会

00:17:27.526 --> 00:17:29.026 A:middle
留有他们的个人信息

00:17:29.026 --> 00:17:30.926 A:middle
比如照片或

00:17:30.926 --> 00:17:31.766 A:middle
私人信息

00:17:32.196 --> 00:17:32.996 A:middle
所以你应该尽一切可能

00:17:32.996 --> 00:17:34.146 A:middle
来确保你的 App

00:17:34.146 --> 00:17:35.746 A:middle
的安全

00:17:35.746 --> 00:17:36.226 A:middle
和可靠

00:17:37.376 --> 00:17:38.286 A:middle
如果你是框架

00:17:38.286 --> 00:17:39.686 A:middle
开发人员 就需要记住

00:17:39.686 --> 00:17:41.236 A:middle
你的 App 客户端

00:17:41.236 --> 00:17:42.286 A:middle
会继承所有 Bug

00:17:42.286 --> 00:17:43.706 A:middle
就像所有这些网站都继承了

00:17:43.706 --> 00:17:44.676 A:middle
“心脏出血”漏洞一样

00:17:45.256 --> 00:17:48.516 A:middle
但好消息是

00:17:48.516 --> 00:17:49.506 A:middle
有些工具可以帮助你

00:17:50.296 --> 00:17:52.396 A:middle
目前 开发人员往往

00:17:52.396 --> 00:17:54.616 A:middle
只有在 Bug 以某些方式显现的

00:17:54.616 --> 00:17:55.876 A:middle
情况下才会使用

00:17:55.876 --> 00:17:56.166 A:middle
我们的工具

00:17:56.166 --> 00:17:57.326 A:middle
比如 Bug 出现在了用户的

00:17:57.326 --> 00:17:58.066 A:middle
崩溃日志中

00:17:58.836 --> 00:18:00.566 A:middle
但如果在早期以及

00:17:58.836 --> 00:18:00.566 A:middle
但如果在早期以及

00:18:00.566 --> 00:18:02.636 A:middle
整个开发过程中就运行工具

00:18:02.636 --> 00:18:03.956 A:middle
我们就可以在它们

00:18:03.956 --> 00:18:05.476 A:middle
发展成问题并影响用户之前

00:18:05.476 --> 00:18:08.416 A:middle
就捕捉到这些问题

00:18:08.416 --> 00:18:11.326 A:middle
我想举一个例子

00:18:11.326 --> 00:18:12.826 A:middle
告诉你们 作为这些工具之一的

00:18:12.826 --> 00:18:15.636 A:middle
“地址杀毒器”是如何拯救

00:18:15.636 --> 00:18:16.096 A:middle
macOS Yosemite 的

00:18:17.536 --> 00:18:19.246 A:middle
在 macOS Yosemite

00:18:19.246 --> 00:18:20.856 A:middle
公开发布前一个月左右

00:18:21.236 --> 00:18:22.396 A:middle
许多新的崩溃开始

00:18:22.396 --> 00:18:23.916 A:middle
出现在整个系统中

00:18:24.446 --> 00:18:26.166 A:middle
我们预感在一个

00:18:26.166 --> 00:18:28.766 A:middle
低层系统框架中

00:18:28.766 --> 00:18:30.796 A:middle
存在一个堆腐败

00:18:30.796 --> 00:18:31.346 A:middle
Bug

00:18:31.966 --> 00:18:32.836 A:middle
我们当时费了很大力气

00:18:32.836 --> 00:18:34.226 A:middle
重现这个问题

00:18:34.846 --> 00:18:35.676 A:middle
但并没有成功

00:18:35.676 --> 00:18:36.776 A:middle
也没有确切的证据

00:18:36.776 --> 00:18:38.436 A:middle
能够指出一个

00:18:38.436 --> 00:18:39.886 A:middle
特定的函数导致了

00:18:39.886 --> 00:18:40.876 A:middle
堆腐败

00:18:41.966 --> 00:18:43.646 A:middle
所以我们转而使用

00:18:43.646 --> 00:18:46.516 A:middle
一种名为“地址杀毒器”的工具

00:18:46.516 --> 00:18:48.096 A:middle
这在当时是非常新的工具

00:18:48.096 --> 00:18:49.256 A:middle
我们认为它可以捕捉到

00:18:49.256 --> 00:18:50.246 A:middle
这个堆腐败错误

00:18:50.366 --> 00:18:51.676 A:middle
所以 我们测试了一些

00:18:51.676 --> 00:18:53.256 A:middle
系统框架 并加载了

00:18:53.256 --> 00:18:53.626 A:middle
这个工具

00:18:53.626 --> 00:18:54.656 A:middle
当然 “地址杀毒器”

00:18:54.656 --> 00:18:55.726 A:middle
完美地解决了

00:18:55.726 --> 00:18:57.516 A:middle
问题 锁定了

00:18:57.516 --> 00:18:59.486 A:middle
这片代码

00:18:59.576 --> 00:19:01.476 A:middle
总结一下就是

00:18:59.576 --> 00:19:01.476 A:middle
总结一下就是

00:19:03.196 --> 00:19:04.886 A:middle
我们有一个 CF 字符串

00:19:04.886 --> 00:19:07.026 A:middle
并正在构建用户库

00:19:07.026 --> 00:19:09.146 A:middle
缓存目录中的一个

00:19:09.146 --> 00:19:10.056 A:middle
文件路径

00:19:11.056 --> 00:19:12.106 A:middle
然后我们将这个 C 字符串

00:19:12.106 --> 00:19:14.026 A:middle
抱歉 将这个 CF 字符串

00:19:14.026 --> 00:19:15.676 A:middle
转换成一个 C 字符串

00:19:16.186 --> 00:19:17.406 A:middle
所以 我的意思是说 这是

00:19:17.406 --> 00:19:18.176 A:middle
一个非常简单的事情 对吧

00:19:18.176 --> 00:19:19.526 A:middle
我们必须测量 CF 字符串

00:19:19.526 --> 00:19:22.206 A:middle
的长度 然后再将缓冲区

00:19:22.206 --> 00:19:23.106 A:middle
分配到这个有许多

00:19:23.106 --> 00:19:25.766 A:middle
字符的堆上 并将字节

00:19:25.766 --> 00:19:26.196 A:middle
拷贝进去

00:19:27.186 --> 00:19:28.876 A:middle
而且 对了

00:19:28.876 --> 00:19:30.376 A:middle
我们忘了一件事 就是

00:19:30.376 --> 00:19:31.706 A:middle
C 字符串需要被

00:19:31.706 --> 00:19:32.216 A:middle
空终止

00:19:32.966 --> 00:19:35.816 A:middle
所以我们也要补充这一点

00:19:36.046 --> 00:19:38.236 A:middle
但是我们犯了一个错误

00:19:38.236 --> 00:19:38.796 A:middle
“大小差一”错误

00:19:38.856 --> 00:19:40.026 A:middle
因为当我们计算

00:19:40.026 --> 00:19:41.696 A:middle
所需分配大小时

00:19:41.696 --> 00:19:43.036 A:middle
没有包含这个

00:19:43.036 --> 00:19:43.436 A:middle
空字节

00:19:44.706 --> 00:19:46.496 A:middle
所以实际上我们

00:19:46.496 --> 00:19:46.966 A:middle
溢出了缓冲区

00:19:47.566 --> 00:19:50.606 A:middle
但大部分情况下这对

00:19:50.606 --> 00:19:52.006 A:middle
用户没有任何影响

00:19:52.616 --> 00:19:54.266 A:middle
那是因为堆会

00:19:54.266 --> 00:19:55.756 A:middle
扩大分配

00:19:55.756 --> 00:19:56.436 A:middle
尺寸

00:19:56.436 --> 00:19:57.866 A:middle
在这种情况下 假设我们

00:19:57.866 --> 00:19:58.866 A:middle
将其向上舍入到

00:19:58.866 --> 00:20:00.226 A:middle
16 个字节的下一个倍数

00:19:58.866 --> 00:20:00.226 A:middle
16 个字节的下一个倍数

00:20:01.066 --> 00:20:02.176 A:middle
然后 当我们最后将

00:20:02.176 --> 00:20:04.296 A:middle
空字节写入未使用

00:20:04.296 --> 00:20:05.776 A:middle
空间时 就不会有

00:20:05.776 --> 00:20:06.576 A:middle
任何后果了 对吧

00:20:08.436 --> 00:20:11.146 A:middle
但是让我们看看

00:20:11.816 --> 00:20:13.476 A:middle
当缓冲区中的一个变量

00:20:13.476 --> 00:20:15.216 A:middle
发生变化时会发生什么

00:20:15.216 --> 00:20:15.806 A:middle
那就是用户名

00:20:17.166 --> 00:20:19.286 A:middle
如果用户名的长度

00:20:19.286 --> 00:20:20.926 A:middle
改变了 未使用的

00:20:20.926 --> 00:20:22.446 A:middle
空间量也会改变

00:20:22.856 --> 00:20:23.866 A:middle
而事实证明

00:20:23.866 --> 00:20:27.246 A:middle
如果用户的用户名长度正好是

00:20:27.246 --> 00:20:28.986 A:middle
11个字符 则不会有

00:20:28.986 --> 00:20:30.606 A:middle
任何未使用的空间，那我们最终

00:20:30.606 --> 00:20:32.286 A:middle
会破坏堆上的

00:20:32.286 --> 00:20:33.546 A:middle
相邻对象 导致

00:20:33.546 --> 00:20:34.786 A:middle
代码的其他部分

00:20:34.786 --> 00:20:35.246 A:middle
崩溃

00:20:36.076 --> 00:20:37.246 A:middle
所以这就是为什么

00:20:37.246 --> 00:20:39.256 A:middle
用正常方法捕捉

00:20:39.576 --> 00:20:41.886 A:middle
不到问题 但是“地址杀毒器”

00:20:41.886 --> 00:20:43.016 A:middle
却能够马上

00:20:43.016 --> 00:20:43.396 A:middle
找到它

00:20:44.806 --> 00:20:47.056 A:middle
在这种情况下 这个

00:20:47.056 --> 00:20:48.796 A:middle
缓冲溢出错误可能没有

00:20:48.796 --> 00:20:49.996 A:middle
导致很多安全性后果

00:20:50.466 --> 00:20:54.216 A:middle
但许多其他类似的 Bug

00:20:54.396 --> 00:20:55.856 A:middle
可能会导致可利用的

00:20:55.856 --> 00:20:56.566 A:middle
漏洞

00:20:57.326 --> 00:20:58.736 A:middle
请记住 安全漏洞

00:20:59.066 --> 00:21:00.946 A:middle
通常只有在被利用的时候

00:20:59.066 --> 00:21:00.946 A:middle
通常只有在被利用的时候

00:21:01.026 --> 00:21:02.196 A:middle
才会显现出来

00:21:03.146 --> 00:21:04.576 A:middle
因此 在早期和整个开发过程中

00:21:04.576 --> 00:21:06.006 A:middle
运行的类似于“地址杀毒器”

00:21:06.076 --> 00:21:07.596 A:middle
的工具 可以帮助你

00:21:07.596 --> 00:21:09.166 A:middle
在这些错误到达

00:21:09.166 --> 00:21:10.686 A:middle
客户设备之前将其捕捉

00:21:13.676 --> 00:21:15.956 A:middle
那么 让我们来谈谈

00:21:16.256 --> 00:21:17.546 A:middle
你所掌握的用来捕捉

00:21:17.576 --> 00:21:19.416 A:middle
未定义行为的工具

00:21:20.146 --> 00:21:22.616 A:middle
首先 我们将讨论编译器

00:21:22.616 --> 00:21:26.176 A:middle
Xcode 中的静态分析器

00:21:26.206 --> 00:21:29.576 A:middle
以及杀毒器

00:21:29.776 --> 00:21:31.596 A:middle
“地址杀毒器”“线程杀毒器”

00:21:31.596 --> 00:21:33.406 A:middle
和“未定义行为

00:21:33.406 --> 00:21:34.296 A:middle
杀毒器”

00:21:35.236 --> 00:21:36.026 A:middle
我们先从编译器

00:21:36.026 --> 00:21:36.416 A:middle
开始

00:21:37.066 --> 00:21:39.906 A:middle
编译器会提醒你

00:21:39.906 --> 00:21:41.686 A:middle
部分代码可能有些可疑

00:21:41.686 --> 00:21:43.136 A:middle
并以编译器警告

00:21:43.136 --> 00:21:44.226 A:middle
的形式

00:21:44.226 --> 00:21:44.586 A:middle
提醒你

00:21:45.296 --> 00:21:46.286 A:middle
信不信由你

00:21:46.286 --> 00:21:47.196 A:middle
它们不只是在烦你

00:21:48.756 --> 00:21:50.446 A:middle
Xcode 的每个版本都有

00:21:50.536 --> 00:21:51.936 A:middle
更好的警告功能和

00:21:51.936 --> 00:21:53.506 A:middle
很好的功能 比如 Fixit

00:21:53.506 --> 00:21:54.486 A:middle
所以你只需点按一下

00:21:54.486 --> 00:21:54.786 A:middle
即可解决问题

00:21:55.866 --> 00:21:57.366 A:middle
如果想要了解今年

00:21:57.366 --> 00:21:58.766 A:middle
编译器的新功能

00:21:58.766 --> 00:22:00.336 A:middle
你可以听一下今天下午关于 LLDM

00:21:58.766 --> 00:22:00.336 A:middle
你可以听一下今天下午关于 LLDM

00:22:00.726 --> 00:22:01.836 A:middle
新功能的演讲

00:22:02.406 --> 00:22:05.786 A:middle
现在 你可能会想

00:22:05.786 --> 00:22:07.286 A:middle
我的项目是否已经

00:22:07.586 --> 00:22:08.606 A:middle
启用了一组推荐的

00:22:08.606 --> 00:22:09.086 A:middle
警告呢

00:22:09.706 --> 00:22:10.656 A:middle
其实 每次你升级 Xcode 时

00:22:10.656 --> 00:22:12.236 A:middle
都有机会使你的项目

00:22:12.236 --> 00:22:13.396 A:middle
更加的

00:22:13.396 --> 00:22:13.946 A:middle
先进

00:22:14.286 --> 00:22:15.376 A:middle
你也可以随时使用

00:22:15.376 --> 00:22:17.356 A:middle
验证设置选项

00:22:17.426 --> 00:22:19.186 A:middle
进行此操作 这将有助于

00:22:19.306 --> 00:22:20.406 A:middle
系统再次处于良好状态

00:22:21.756 --> 00:22:22.556 A:middle
还有一个我认为

00:22:22.556 --> 00:22:23.946 A:middle
你应该了解的

00:22:23.946 --> 00:22:25.296 A:middle
构建设置是

00:22:25.296 --> 00:22:26.646 A:middle
将警告视为错误

00:22:27.806 --> 00:22:29.086 A:middle
它会像它名字所说的那样

00:22:29.086 --> 00:22:29.406 A:middle
行动

00:22:29.816 --> 00:22:31.796 A:middle
如果你的项目已经编译了

00:22:31.796 --> 00:22:33.146 A:middle
相对较少的警告

00:22:33.426 --> 00:22:34.906 A:middle
那么请考虑开启

00:22:34.906 --> 00:22:36.646 A:middle
这个设置 并强化它的自律

00:22:36.646 --> 00:22:38.000 A:middle
以保持较低的最大并行编译数

00:22:41.836 --> 00:22:43.076 A:middle
现在 我们来谈谈

00:22:43.076 --> 00:22:43.526 A:middle
静态分析仪

00:22:44.226 --> 00:22:45.326 A:middle
你可以将静态分析仪

00:22:45.326 --> 00:22:46.646 A:middle
看作是编译器警告的

00:22:46.646 --> 00:22:48.136 A:middle
加强版本

00:22:48.186 --> 00:22:50.546 A:middle
它会探索你的代码

00:22:50.616 --> 00:22:52.556 A:middle
并发现只有在非常特殊的

00:22:52.556 --> 00:22:54.606 A:middle
条件下才会出现的 Bug

00:22:54.606 --> 00:22:55.966 A:middle
可能在你通常测试

00:22:56.066 --> 00:22:58.026 A:middle
应用程序时都不会遇到的条件

00:22:58.776 --> 00:23:01.066 A:middle
所以我们建议在每次

00:22:58.776 --> 00:23:01.066 A:middle
所以我们建议在每次

00:23:01.066 --> 00:23:02.636 A:middle
编译的过程中进行分析

00:23:03.416 --> 00:23:04.386 A:middle
它有一个专门的构建设置

00:23:04.466 --> 00:23:06.416 A:middle
开启后 在你每次构建

00:23:06.416 --> 00:23:08.276 A:middle
项目时  Xcode 都将运行

00:23:08.446 --> 00:23:09.236 A:middle
一个快速的

00:23:09.236 --> 00:23:09.636 A:middle
分析传递

00:23:10.716 --> 00:23:13.116 A:middle
这可以确保你能

00:23:13.256 --> 00:23:14.566 A:middle
尽快找到

00:23:14.566 --> 00:23:16.356 A:middle
刚刚引入的

00:23:16.356 --> 00:23:16.786 A:middle
Bug

00:23:17.936 --> 00:23:19.136 A:middle
但是分析仪还有一个

00:23:19.416 --> 00:23:21.026 A:middle
更深的模式 可以

00:23:21.026 --> 00:23:23.006 A:middle
随时使用

00:23:23.326 --> 00:23:24.136 A:middle
也是我们建议

00:23:24.136 --> 00:23:25.596 A:middle
在持续集成下

00:23:25.596 --> 00:23:27.056 A:middle
使用的模式 从而

00:23:27.056 --> 00:23:28.846 A:middle
充分利用

00:23:28.846 --> 00:23:29.976 A:middle
静态分析仪的

00:23:29.976 --> 00:23:30.676 A:middle
错误查找功能

00:23:34.456 --> 00:23:38.166 A:middle
接下来我要谈谈

00:23:38.776 --> 00:23:39.566 A:middle
杀毒器

00:23:40.656 --> 00:23:43.976 A:middle
但首先要注意的是

00:23:43.976 --> 00:23:45.456 A:middle
杀毒器是运行时工具

00:23:45.456 --> 00:23:47.346 A:middle
与编译器或静态分析仪不同

00:23:47.346 --> 00:23:49.296 A:middle
为了充分利用

00:23:49.296 --> 00:23:51.136 A:middle
杀毒器 你需要

00:23:51.136 --> 00:23:52.446 A:middle
实际运行一个

00:23:52.446 --> 00:23:54.226 A:middle
只能在实际执行的代码中

00:23:55.166 --> 00:23:56.526 A:middle
找到 Bug 的

00:23:56.526 --> 00:23:57.136 A:middle
练习代码

00:23:57.466 --> 00:23:58.196 A:middle
请记住这一点

00:23:59.316 --> 00:24:03.166 A:middle
它们提供了高度的

00:23:59.316 --> 00:24:03.166 A:middle
它们提供了高度的

00:24:03.216 --> 00:24:04.766 A:middle
错误查找能力

00:24:05.076 --> 00:24:07.996 A:middle
首先 如前所述

00:24:07.996 --> 00:24:09.116 A:middle
我们有“地址杀毒器”

00:24:09.766 --> 00:24:11.376 A:middle
现在 “地址杀毒器”可以捕获

00:24:11.376 --> 00:24:12.936 A:middle
诸如缓冲区溢出

00:24:13.006 --> 00:24:14.286 A:middle
和 Use-After-Free

00:24:14.286 --> 00:24:15.156 A:middle
之类的内存损坏 Bug

00:24:15.636 --> 00:24:16.526 A:middle
而这些与

00:24:16.526 --> 00:24:17.396 A:middle
安全漏洞

00:24:17.396 --> 00:24:18.000 A:middle
高度相关

00:24:21.216 --> 00:24:22.956 A:middle
然后是“线程消毒器”

00:24:23.456 --> 00:24:24.796 A:middle
它可以捕获数据竞争

00:24:24.896 --> 00:24:26.026 A:middle
因此 在你的多线程 App 中

00:24:26.706 --> 00:24:28.296 A:middle
如果两个线程尝试访问

00:24:28.356 --> 00:24:30.226 A:middle
同一片内存 而没有

00:24:30.266 --> 00:24:31.716 A:middle
进行正确的同步 则会发生

00:24:31.716 --> 00:24:32.316 A:middle
数据竞争

00:24:33.226 --> 00:24:34.166 A:middle
但是 “线程消毒器”的一个

00:24:34.166 --> 00:24:36.276 A:middle
好酷地方是 它甚至可以

00:24:36.276 --> 00:24:37.556 A:middle
捕捉到潜在的数据竞争

00:24:38.236 --> 00:24:40.056 A:middle
所以 即使在执行

00:24:40.056 --> 00:24:41.486 A:middle
App 时一切看起来似乎

00:24:41.486 --> 00:24:43.526 A:middle
都很好的情况下“线程消毒器”

00:24:43.526 --> 00:24:45.406 A:middle
都可能会告诉你 两个操作

00:24:45.406 --> 00:24:46.526 A:middle
是否有可能会

00:24:46.526 --> 00:24:48.106 A:middle
以不同的顺序发生 并导致

00:24:48.106 --> 00:24:49.000 A:middle
你的 App 行为不当

00:24:52.066 --> 00:24:54.206 A:middle
Xcode 9 中新增的是

00:24:54.206 --> 00:24:55.726 A:middle
“未定义行为杀毒器”

00:24:56.686 --> 00:24:58.726 A:middle
它可以捕获超过 15 种

00:24:58.726 --> 00:25:01.196 A:middle
不同类型的未定义行为

00:24:58.726 --> 00:25:01.196 A:middle
不同类型的未定义行为

00:25:01.196 --> 00:25:02.566 A:middle
扩展了“地址杀毒器”

00:25:02.566 --> 00:25:04.776 A:middle
或“线程杀毒器”的功能

00:25:04.776 --> 00:25:06.206 A:middle
以便你获得强的 Bug

00:25:06.206 --> 00:25:06.516 A:middle
查找能力

00:25:07.236 --> 00:25:08.516 A:middle
因此 它捕获的一些这些类型的

00:25:08.516 --> 00:25:09.736 A:middle
未定义行为包括

00:25:09.736 --> 00:25:11.576 A:middle
分配整数溢出和

00:25:11.576 --> 00:25:13.366 A:middle
紧密匹配 Bug

00:25:13.426 --> 00:25:15.076 A:middle
这也与某些

00:25:15.076 --> 00:25:16.426 A:middle
环境下的

00:25:16.426 --> 00:25:17.496 A:middle
安全漏洞

00:25:17.496 --> 00:25:17.976 A:middle
有关

00:25:17.976 --> 00:25:21.846 A:middle
所有的杀毒器

00:25:21.846 --> 00:25:23.136 A:middle
都为你提供了丰富而且

00:25:23.136 --> 00:25:25.086 A:middle
富含信息的诊断程序

00:25:25.086 --> 00:25:26.936 A:middle
帮助你锁定 Bug 出现的

00:25:26.936 --> 00:25:27.646 A:middle
根本原因

00:25:28.306 --> 00:25:29.776 A:middle
你可以在“运行时问题

00:25:29.776 --> 00:25:30.886 A:middle
导航器”中找到很多

00:25:30.886 --> 00:25:32.956 A:middle
非常有用的信息

00:25:32.956 --> 00:25:36.026 A:middle
例如在 Bug 执行期间

00:25:36.026 --> 00:25:39.756 A:middle
重要部分的

00:25:39.926 --> 00:25:40.266 A:middle
堆栈回溯信息

00:25:40.436 --> 00:25:41.736 A:middle
所以 我们建议在开发过程中

00:25:41.736 --> 00:25:43.736 A:middle
启动杀毒器

00:25:44.066 --> 00:25:45.036 A:middle
你可以在诊断选项卡下的

00:25:45.036 --> 00:25:46.236 A:middle
Scheme 编辑器中

00:25:46.236 --> 00:25:46.486 A:middle
执行此操作

00:25:47.636 --> 00:25:48.576 A:middle
你也可以在这里

00:25:48.576 --> 00:25:50.816 A:middle
将它启动 来运行你的

00:25:50.816 --> 00:25:51.216 A:middle
单元测试

00:25:51.506 --> 00:25:53.356 A:middle
记住 杀毒器需要

00:25:53.636 --> 00:25:55.386 A:middle
良好的代码覆盖 以便

00:25:55.436 --> 00:25:56.926 A:middle
在整个程序中

00:25:56.926 --> 00:25:58.126 A:middle
查找 Bug  这是

00:25:58.126 --> 00:25:59.366 A:middle
你的单元测试可以提供的

00:25:59.956 --> 00:26:02.836 A:middle
你可以在“使用 Xcode 运行时工具

00:25:59.956 --> 00:26:02.836 A:middle
你可以在“使用 Xcode 运行时工具

00:26:02.836 --> 00:26:04.546 A:middle
查找错误”讲座中

00:26:04.546 --> 00:26:05.626 A:middle
了解更多关于 Xcode

00:26:05.626 --> 00:26:07.686 A:middle
今年新的杀毒器和

00:26:07.686 --> 00:26:09.966 A:middle
其他的运行时工具

00:26:12.416 --> 00:26:15.756 A:middle
所以 这些是你可以用来

00:26:15.756 --> 00:26:16.936 A:middle
追踪未定义行为的

00:26:16.936 --> 00:26:19.056 A:middle
五个强大工具 还可以

00:26:19.056 --> 00:26:21.116 A:middle
用来解决未定义行为

00:26:21.116 --> 00:26:22.786 A:middle
可能产生的一些

00:26:23.246 --> 00:26:23.886 A:middle
安全漏洞

00:26:24.886 --> 00:26:26.026 A:middle
但在继续之前

00:26:26.026 --> 00:26:27.156 A:middle
还有一件事我想

00:26:27.206 --> 00:26:28.786 A:middle
谈一下 那就是

00:26:28.786 --> 00:26:29.536 A:middle
语言本身

00:26:29.536 --> 00:26:33.066 A:middle
你可以将语言的

00:26:33.066 --> 00:26:34.736 A:middle
使用作为编写

00:26:34.736 --> 00:26:36.426 A:middle
安全可靠代码的

00:26:36.426 --> 00:26:37.026 A:middle
第一道防线

00:26:37.816 --> 00:26:39.406 A:middle
考虑到这一点

00:26:39.406 --> 00:26:41.126 A:middle
你应该更注重

00:26:41.126 --> 00:26:43.076 A:middle
库和语言为你提供的

00:26:43.076 --> 00:26:44.186 A:middle
安全结构

00:26:45.086 --> 00:26:47.246 A:middle
例如  Objective C 中的

00:26:47.246 --> 00:26:48.566 A:middle
自动引用

00:26:48.566 --> 00:26:48.996 A:middle
计数

00:26:49.396 --> 00:26:53.036 A:middle
或者 C++ 中的智能指针

00:26:53.036 --> 00:26:54.206 A:middle
可以将你从繁重的手动内存

00:26:54.206 --> 00:26:56.176 A:middle
管理中解脱出来

00:26:56.176 --> 00:26:57.746 A:middle
从而避免 Bug

00:26:58.796 --> 00:27:00.956 A:middle
如果你的标准库

00:26:58.796 --> 00:27:00.956 A:middle
如果你的标准库

00:27:00.956 --> 00:27:02.116 A:middle
为你提供容器类

00:27:02.116 --> 00:27:03.906 A:middle
例如基础的 NSarray

00:27:03.906 --> 00:27:06.436 A:middle
它们会自动

00:27:06.436 --> 00:27:07.666 A:middle
检查其边界 则不必

00:27:07.666 --> 00:27:08.746 A:middle
太过担心

00:27:08.746 --> 00:27:09.526 A:middle
缓冲区溢出

00:27:10.086 --> 00:27:13.446 A:middle
但是 了解你的语言

00:27:13.446 --> 00:27:14.706 A:middle
在安全和保障方面

00:27:14.706 --> 00:27:16.836 A:middle
所做的折衷

00:27:16.836 --> 00:27:17.966 A:middle
才是关键所在

00:27:18.596 --> 00:27:20.316 A:middle
当在你的代码中这些是

00:27:20.316 --> 00:27:21.876 A:middle
非常重要的因素时

00:27:22.506 --> 00:27:24.936 A:middle
请考虑使用 Swift

00:27:24.936 --> 00:27:25.956 A:middle
这种语言从最开始

00:27:25.956 --> 00:27:28.186 A:middle
设计时就消除了

00:27:28.186 --> 00:27:30.126 A:middle
所有类别的

00:27:30.126 --> 00:27:30.536 A:middle
未定义行为

00:27:31.496 --> 00:27:32.676 A:middle
为了向你们介绍更多相关内容

00:27:33.256 --> 00:27:34.086 A:middle
我想邀请我的

00:27:34.086 --> 00:27:35.786 A:middle
同事 Anna 来为大家继续讲解

00:27:37.516 --> 00:27:41.566 A:middle
[掌声]

00:27:42.066 --> 00:27:42.796 A:middle
&gt;&gt; 谢谢你 Ryan

00:27:44.066 --> 00:27:46.816 A:middle
现在让我们来谈谈

00:27:46.876 --> 00:27:49.076 A:middle
未定义行为和 Swift

00:27:49.296 --> 00:27:50.446 A:middle
你可以在 Swift 中

00:27:50.446 --> 00:27:52.986 A:middle
编写适合性能的代码

00:27:52.986 --> 00:27:54.226 A:middle
这种语言会

00:27:54.226 --> 00:27:55.756 A:middle
进行不同的权衡

00:27:55.756 --> 00:27:57.316 A:middle
同时它被设计在默认的情况下

00:27:57.316 --> 00:27:57.816 A:middle
更加安全

00:27:57.976 --> 00:28:00.056 A:middle
从前面的例子可以看出

00:27:57.976 --> 00:28:00.056 A:middle
从前面的例子可以看出

00:28:00.056 --> 00:28:02.426 A:middle
未定义行为可以

00:28:02.506 --> 00:28:04.956 A:middle
引入非常微妙的错误

00:28:04.956 --> 00:28:07.186 A:middle
从而导致

00:28:07.186 --> 00:28:07.786 A:middle
安全漏洞

00:28:08.406 --> 00:28:10.236 A:middle
这在来自 Swift.org 的这段代码中

00:28:10.236 --> 00:28:11.586 A:middle
进行了简单总结

00:28:12.276 --> 00:28:14.116 A:middle
未定义行为是

00:28:14.116 --> 00:28:14.776 A:middle
安全的敌人

00:28:16.076 --> 00:28:17.966 A:middle
Swift 的安全性

00:28:17.966 --> 00:28:18.666 A:middle
在很多层面都很重要

00:28:19.136 --> 00:28:20.846 A:middle
让我们看看针对 Ryan

00:28:20.846 --> 00:28:22.606 A:middle
和 Fred 谈到的一些

00:28:22.896 --> 00:28:24.526 A:middle
未定义行为的主要来源

00:28:24.756 --> 00:28:26.246 A:middle
如何使用 Swift 中的

00:28:26.246 --> 00:28:27.156 A:middle
不同技术进行解决

00:28:27.606 --> 00:28:29.366 A:middle
更严格的类型系统给了

00:28:29.366 --> 00:28:31.426 A:middle
我们可选的类型

00:28:31.516 --> 00:28:33.546 A:middle
这静态地预防了解引用

00:28:33.546 --> 00:28:34.426 A:middle
空点

00:28:35.216 --> 00:28:36.606 A:middle
初始化变量的使用

00:28:36.606 --> 00:28:38.746 A:middle
通过明确的初始化

00:28:38.746 --> 00:28:40.216 A:middle
被消除了

00:28:40.816 --> 00:28:42.466 A:middle
缓冲区和整数溢出

00:28:42.466 --> 00:28:44.776 A:middle
将会在运行时被检查 就像

00:28:44.776 --> 00:28:46.586 A:middle
Objective C  一样

00:28:46.586 --> 00:28:48.336 A:middle
自动引用计数

00:28:48.336 --> 00:28:51.166 A:middle
是冻结后  Swift 作出的响应

00:28:51.296 --> 00:28:52.736 A:middle
它允许开发人员

00:28:52.736 --> 00:28:54.106 A:middle
不专注于手动管理

00:28:54.106 --> 00:28:54.946 A:middle
内存的问题

00:28:55.816 --> 00:28:57.336 A:middle
让我们更详细地

00:28:57.336 --> 00:28:58.026 A:middle
研究一下

00:28:59.546 --> 00:29:01.876 A:middle
可选类型是 Swift

00:28:59.546 --> 00:29:01.876 A:middle
可选类型是 Swift

00:29:01.876 --> 00:29:03.186 A:middle
对解引用空点的响应

00:29:03.556 --> 00:29:05.396 A:middle
Swift 有两种类型

00:29:05.986 --> 00:29:07.726 A:middle
这里 我们有一个不可选的蛋糕

00:29:08.376 --> 00:29:09.806 A:middle
和一个可选的蛋糕 你可以

00:29:09.806 --> 00:29:11.636 A:middle
认为后者中有蛋糕

00:29:11.636 --> 00:29:13.246 A:middle
或认为它只是一个空

00:29:13.246 --> 00:29:13.656 A:middle
盒子

00:29:14.566 --> 00:29:16.286 A:middle
现在 作为 Swift 工具

00:29:16.286 --> 00:29:18.176 A:middle
我可以向你保证 不确定盒子中是否有蛋糕

00:29:18.176 --> 00:29:20.196 A:middle
这样的 Bug 绝对不会像

00:29:20.196 --> 00:29:22.106 A:middle
这个美味的三层巧克力蛋糕

00:29:22.106 --> 00:29:22.926 A:middle
一样令人愉悦

00:29:23.376 --> 00:29:26.676 A:middle
所以 在使用可选类型的值

00:29:26.676 --> 00:29:28.136 A:middle
之前 须先进行

00:29:28.136 --> 00:29:28.396 A:middle
检查

00:29:29.106 --> 00:29:30.346 A:middle
假设我们有一个函数叫做

00:29:30.346 --> 00:29:32.656 A:middle
接收包 声明将返回

00:29:32.656 --> 00:29:34.356 A:middle
一个可选的

00:29:34.356 --> 00:29:34.966 A:middle
蛋糕类型

00:29:36.126 --> 00:29:37.966 A:middle
不要高兴的太早

00:29:37.966 --> 00:29:40.526 A:middle
除非你已经检查并确定

00:29:40.526 --> 00:29:41.636 A:middle
它不会返回为 nil

00:29:42.436 --> 00:29:44.000 A:middle
有可能蛋糕是个谎言

00:29:47.536 --> 00:29:49.636 A:middle
请注意  Swift 的语法提供了

00:29:49.636 --> 00:29:51.466 A:middle
可以轻松检查可选类型

00:29:51.466 --> 00:29:53.796 A:middle
的功能 特别是能

00:29:53.796 --> 00:29:55.356 A:middle
减轻开发人员

00:29:55.356 --> 00:29:56.506 A:middle
使用此类型的负担

00:29:57.846 --> 00:30:00.256 A:middle
另一个重要的提醒是

00:29:57.846 --> 00:30:00.256 A:middle
另一个重要的提醒是

00:30:00.256 --> 00:30:01.776 A:middle
你不应该滥用第四个

00:30:01.776 --> 00:30:04.246 A:middle
解包操作符

00:30:04.246 --> 00:30:05.376 A:middle
对于这种操作符 如果值为 nil

00:30:05.376 --> 00:30:06.726 A:middle
则会停止该程序的执行

00:30:07.556 --> 00:30:09.376 A:middle
如果 API 已经声明

00:30:09.376 --> 00:30:11.306 A:middle
将返回一个可选类型

00:30:11.586 --> 00:30:12.966 A:middle
就意味着它可能返回 nil

00:30:12.966 --> 00:30:14.656 A:middle
所以要先进行检查

00:30:14.946 --> 00:30:16.336 A:middle
第四个解包操作符

00:30:16.336 --> 00:30:18.716 A:middle
只能在极少数情况下使用

00:30:18.716 --> 00:30:20.766 A:middle
就是当开发人员确定

00:30:20.766 --> 00:30:22.266 A:middle
并且可以保证返回值

00:30:22.266 --> 00:30:23.616 A:middle
永远不会为 nil 的时候

00:30:23.906 --> 00:30:25.416 A:middle
然而 它不能在

00:30:25.416 --> 00:30:26.356 A:middle
类型系统中被编码

00:30:27.076 --> 00:30:28.436 A:middle
举个例子 当你从

00:30:28.436 --> 00:30:29.886 A:middle
App 数据包中

00:30:29.956 --> 00:30:30.906 A:middle
加载图像资源时

00:30:33.016 --> 00:30:34.866 A:middle
Swift 还有一个

00:30:34.866 --> 00:30:36.796 A:middle
隐含解开的可选类型的

00:30:36.796 --> 00:30:37.086 A:middle
概念

00:30:37.836 --> 00:30:39.576 A:middle
此类型与可选类型

00:30:39.576 --> 00:30:40.216 A:middle
类似

00:30:40.426 --> 00:30:41.966 A:middle
然而 在这里编译器并不强制

00:30:41.966 --> 00:30:45.996 A:middle
使用这些值

00:30:46.076 --> 00:30:48.736 A:middle
在使用之前会

00:30:48.736 --> 00:30:50.066 A:middle
先检查这些值

00:30:50.066 --> 00:30:51.226 A:middle
不保证编译时间

00:30:52.736 --> 00:30:54.266 A:middle
请注意 这种类型

00:30:54.266 --> 00:30:55.836 A:middle
仍然比 C 指针类型

00:30:55.836 --> 00:30:58.746 A:middle
安全得多 因为使用它的是

00:30:58.746 --> 00:30:59.776 A:middle
已定义行为

00:31:00.536 --> 00:31:02.016 A:middle
如果值为 nil  那么程序就会

00:31:02.016 --> 00:31:04.216 A:middle
停止执行

00:31:04.766 --> 00:31:07.306 A:middle
这使得该模型更加

00:31:07.306 --> 00:31:07.926 A:middle
安全

00:31:08.496 --> 00:31:11.216 A:middle
现在 此类型应该在

00:31:11.276 --> 00:31:12.216 A:middle
确定有值的属性中

00:31:12.216 --> 00:31:13.606 A:middle
使用

00:31:13.976 --> 00:31:15.096 A:middle
然而 它们不能在

00:31:15.096 --> 00:31:16.536 A:middle
构造函数中被初始化

00:31:17.266 --> 00:31:18.796 A:middle
你们中的一些人可能会把它用于

00:31:18.796 --> 00:31:19.906 A:middle
IB 输出口

00:31:20.766 --> 00:31:22.656 A:middle
然而 隐含解开的可选类型

00:31:22.656 --> 00:31:24.166 A:middle
的另一个来源是

00:31:24.436 --> 00:31:26.306 A:middle
来自 Objective C 和

00:31:26.306 --> 00:31:28.076 A:middle
C 的 API 的指针类型

00:31:29.056 --> 00:31:31.096 A:middle
这个来源颠覆了

00:31:31.096 --> 00:31:32.786 A:middle
Swift 可选类型的类型安全性

00:31:33.136 --> 00:31:34.206 A:middle
那我们能做什么呢

00:31:34.816 --> 00:31:37.506 A:middle
在 Swift 发布的时候

00:31:37.506 --> 00:31:38.936 A:middle
我们还向 Apple LLDM

00:31:38.936 --> 00:31:40.686 A:middle
编译器添加了

00:31:40.686 --> 00:31:41.246 A:middle
可空性注解

00:31:41.856 --> 00:31:43.946 A:middle
在 C 语言中

00:31:44.246 --> 00:31:46.536 A:middle
这个注释传达了

00:31:46.536 --> 00:31:48.096 A:middle
API 的意图 但也用于

00:31:48.096 --> 00:31:49.806 A:middle
增强 Swift 的接口

00:31:50.536 --> 00:31:52.626 A:middle
它们允许我们将不安全的

00:31:52.656 --> 00:31:54.206 A:middle
C 指针映射到可选

00:31:54.206 --> 00:31:54.636 A:middle
类型

00:31:55.406 --> 00:31:56.716 A:middle
我们来看这个例子

00:31:57.306 --> 00:31:58.936 A:middle
我们在 NSview 中

00:31:58.966 --> 00:32:00.376 A:middle
有一个 ancestorSharedWithView 方法

00:31:58.966 --> 00:32:00.376 A:middle
有一个 ancestorSharedWithView 方法

00:32:00.376 --> 00:32:02.936 A:middle
如你所见 它需要一个

00:32:02.936 --> 00:32:04.836 A:middle
非空的参数 因为

00:32:04.836 --> 00:32:06.766 A:middle
在 nil 和某个值之间

00:32:06.766 --> 00:32:09.166 A:middle
寻找祖先是没有

00:32:09.166 --> 00:32:09.626 A:middle
意义的

00:32:10.416 --> 00:32:11.956 A:middle
另一方面 它的

00:32:11.956 --> 00:32:13.496 A:middle
返回值为空 因为

00:32:13.496 --> 00:32:15.416 A:middle
两个视图可能没有

00:32:15.416 --> 00:32:16.646 A:middle
相同的祖先

00:32:18.526 --> 00:32:20.676 A:middle
现在 你可以在这里看到

00:32:20.846 --> 00:32:22.626 A:middle
可空性直接映射到

00:32:22.626 --> 00:32:23.706 A:middle
Swift 界面

00:32:24.066 --> 00:32:25.276 A:middle
非空映射到

00:32:25.276 --> 00:32:27.326 A:middle
非可选值 可空

00:32:27.326 --> 00:32:29.416 A:middle
映射到可选值

00:32:29.936 --> 00:32:32.296 A:middle
好消息是 大多数

00:32:32.296 --> 00:32:34.606 A:middle
Apple API 已经通过

00:32:34.606 --> 00:32:35.956 A:middle
可空性注解进行了

00:32:35.956 --> 00:32:36.626 A:middle
审核和注释

00:32:37.666 --> 00:32:40.076 A:middle
但是 如果你有 API 或

00:32:40.076 --> 00:32:42.046 A:middle
只是 C 或 Objective C 代码

00:32:42.046 --> 00:32:44.196 A:middle
与 Swift 进行互操作 你也可以

00:32:44.196 --> 00:32:45.216 A:middle
从这些注解中

00:32:45.216 --> 00:32:45.906 A:middle
受益

00:32:46.846 --> 00:32:48.716 A:middle
此外 你可以使用

00:32:48.966 --> 00:32:50.026 A:middle
静态分析器

00:32:50.026 --> 00:32:51.996 A:middle
警告和

00:32:51.996 --> 00:32:53.546 A:middle
“未定义行为消毒器”等工具

00:32:53.546 --> 00:32:55.746 A:middle
来找到在你的 C

00:32:55.746 --> 00:32:57.226 A:middle
或 Objective C 代码中的

00:32:57.226 --> 00:32:59.106 A:middle
注解方式不一致的地方

00:32:59.766 --> 00:33:01.706 A:middle
我真的非常喜欢下面这个

00:32:59.766 --> 00:33:01.706 A:middle
我真的非常喜欢下面这个

00:33:01.706 --> 00:33:03.626 A:middle
例子 因为它突出

00:33:03.626 --> 00:33:05.256 A:middle
了 LLDM 编译器，

00:33:05.256 --> 00:33:07.716 A:middle
Swift 编译器和

00:33:07.716 --> 00:33:09.796 A:middle
框架三者如何一起合作的改进

00:33:09.796 --> 00:33:12.000 A:middle
进一步使整个生态系统受益

00:33:15.126 --> 00:33:17.106 A:middle
Swift 明确初始化是基于

00:33:17.106 --> 00:33:18.906 A:middle
深层代码分析的

00:33:18.906 --> 00:33:19.966 A:middle
诊断功能

00:33:20.746 --> 00:33:23.226 A:middle
Swift 的编译器保证

00:33:23.226 --> 00:33:26.276 A:middle
使用值之前

00:33:26.276 --> 00:33:27.266 A:middle
将它们初始化

00:33:28.236 --> 00:33:30.206 A:middle
这个检查是通过

00:33:30.206 --> 00:33:32.166 A:middle
你整个程序的所有分支

00:33:32.166 --> 00:33:32.606 A:middle
完成的

00:33:33.096 --> 00:33:34.406 A:middle
我们来看一下这个例子

00:33:34.976 --> 00:33:36.746 A:middle
在这里 编译器将会检查

00:33:36.786 --> 00:33:39.246 A:middle
我的实例是否在

00:33:39.586 --> 00:33:42.276 A:middle
此代码段的 if 和 else

00:33:42.736 --> 00:33:44.446 A:middle
分支上初始化

00:33:44.736 --> 00:33:47.056 A:middle
然后才允许你继续

00:33:47.056 --> 00:33:49.646 A:middle
使用此值

00:33:49.646 --> 00:33:51.246 A:middle
现在 我们来谈谈缓冲区和

00:33:51.246 --> 00:33:52.886 A:middle
整数溢出 这是

00:33:52.886 --> 00:33:55.196 A:middle
安全问题的最大

00:33:55.196 --> 00:33:55.506 A:middle
来源

00:33:56.526 --> 00:33:58.166 A:middle
溢出只需要增加一个整数

00:33:58.286 --> 00:34:00.596 A:middle
Swift 就会终止

00:33:58.286 --> 00:34:00.596 A:middle
Swift 就会终止

00:34:00.596 --> 00:34:01.246 A:middle
程序的执行

00:34:02.826 --> 00:34:04.126 A:middle
你可能会问

00:34:04.346 --> 00:34:05.866 A:middle
为什么运行时检查没有问题呢

00:34:05.946 --> 00:34:07.926 A:middle
如果出现 Bug 且

00:34:07.926 --> 00:34:10.766 A:middle
你的缓冲区溢出了

00:34:10.766 --> 00:34:12.706 A:middle
尽管你的程序会停止运行时检查也会好于

00:34:12.706 --> 00:34:14.186 A:middle
运行时检查也会好于

00:34:14.186 --> 00:34:14.815 A:middle
它

00:34:15.496 --> 00:34:17.516 A:middle
Swift 中的行为

00:34:17.516 --> 00:34:20.005 A:middle
比 C 中的更加

00:34:20.005 --> 00:34:21.315 A:middle
一致并具有更高的可调试性

00:34:21.315 --> 00:34:23.376 A:middle
最重要的是它提供了非常高的

00:34:23.376 --> 00:34:24.876 A:middle
安全性保证

00:34:25.476 --> 00:34:26.946 A:middle
缓冲区溢出是不可

00:34:26.946 --> 00:34:27.746 A:middle
利用的

00:34:28.536 --> 00:34:30.096 A:middle
它不会导致攻击者

00:34:30.096 --> 00:34:31.946 A:middle
获得你的程序的

00:34:31.946 --> 00:34:33.255 A:middle
执行控制能力

00:34:34.775 --> 00:34:36.235 A:middle
注意 如果你需要用到

00:34:36.235 --> 00:34:38.005 A:middle
整数包装行为

00:34:38.005 --> 00:34:41.065 A:middle
仍然可以使用

00:34:41.065 --> 00:34:43.356 A:middle
溢出操作符 这也是安全的

00:34:43.356 --> 00:34:44.806 A:middle
而且只是执行

00:34:44.806 --> 00:34:45.255 A:middle
模数运算

00:34:45.696 --> 00:34:49.926 A:middle
现在 大家

00:34:49.926 --> 00:34:51.525 A:middle
可能想到的一个问题是

00:34:51.525 --> 00:34:53.585 A:middle
Swift 中存在

00:34:53.585 --> 00:34:54.000 A:middle
未定义行为吗

00:34:55.275 --> 00:34:57.085 A:middle
答案是肯定的 但是这种

00:34:57.085 --> 00:35:00.216 A:middle
情况是非常罕见的 并且通常情况下我们

00:34:57.085 --> 00:35:00.216 A:middle
情况是非常罕见的 并且通常情况下我们

00:35:00.216 --> 00:35:01.876 A:middle
知道自己在选择不安全的

00:35:01.876 --> 00:35:02.876 A:middle
行为

00:35:03.396 --> 00:35:06.676 A:middle
例如我们需要 C 的

00:35:06.676 --> 00:35:07.656 A:middle
互操作性

00:35:07.656 --> 00:35:09.226 A:middle
我们需要与这些类型进行

00:35:09.226 --> 00:35:09.906 A:middle
数据通信

00:35:10.306 --> 00:35:12.276 A:middle
不安全的指针 不安全的

00:35:12.276 --> 00:35:13.476 A:middle
可变原始缓冲指针

00:35:14.256 --> 00:35:15.946 A:middle
注意 你可以仅仅通过查看

00:35:15.946 --> 00:35:17.726 A:middle
它们的名字就知道

00:35:17.726 --> 00:35:18.786 A:middle
它们是不安全的

00:35:18.786 --> 00:35:22.336 A:middle
所以 如果你的应用程序使用 C

00:35:22.546 --> 00:35:24.746 A:middle
或 Objective C

00:35:24.746 --> 00:35:25.916 A:middle
其他用到这些类型的方式

00:35:25.916 --> 00:35:27.296 A:middle
我强烈推荐使用

00:35:27.296 --> 00:35:28.336 A:middle
“地址杀毒器”

00:35:28.576 --> 00:35:30.926 A:middle
它会发现这种不安全

00:35:31.226 --> 00:35:33.296 A:middle
可能会给你的代码带来的

00:35:33.296 --> 00:35:34.176 A:middle
内存损坏

00:35:34.436 --> 00:35:38.266 A:middle
现在  另一个 Swift

00:35:38.326 --> 00:35:39.566 A:middle
不安全的例子是

00:35:39.606 --> 00:35:40.366 A:middle
同时访问

00:35:40.956 --> 00:35:42.676 A:middle
Swift 正在通过强制执行

00:35:42.676 --> 00:35:44.006 A:middle
独占内存访问

00:35:44.006 --> 00:35:45.666 A:middle
将这个典型固定在

00:35:45.666 --> 00:35:46.136 A:middle
本版本中

00:35:46.846 --> 00:35:48.126 A:middle
为了更清楚地理解

00:35:48.126 --> 00:35:49.566 A:middle
让我们来看一个非常简单的

00:35:49.566 --> 00:35:50.276 A:middle
例子

00:35:50.276 --> 00:35:54.006 A:middle
在这里我们有一个函数

00:35:54.006 --> 00:35:55.726 A:middle
含有两个 inout 参数

00:35:56.306 --> 00:35:57.676 A:middle
inout 表示该函数

00:35:57.676 --> 00:35:58.886 A:middle
可能会更改这些

00:35:58.886 --> 00:35:59.446 A:middle
参数的值

00:36:00.216 --> 00:36:02.206 A:middle
调用此函数并

00:36:02.206 --> 00:36:04.066 A:middle
将两个指向相同内存的值

00:36:04.066 --> 00:36:06.436 A:middle
传递给它 可能会导致

00:36:06.436 --> 00:36:07.826 A:middle
不可预测的行为

00:36:09.176 --> 00:36:10.846 A:middle
对于你们当中

00:36:10.846 --> 00:36:12.396 A:middle
熟悉 C 中的 restrict 的人

00:36:12.396 --> 00:36:14.266 A:middle
这是非常相似的

00:36:14.446 --> 00:36:16.666 A:middle
但是在 Swift 中 此行为

00:36:16.666 --> 00:36:17.256 A:middle
是默认开启的

00:36:17.736 --> 00:36:20.646 A:middle
接下来是一个关于这个问题的

00:36:20.646 --> 00:36:23.116 A:middle
非常简单抽象

00:36:23.116 --> 00:36:23.716 A:middle
的例子

00:36:23.716 --> 00:36:25.046 A:middle
我非常推荐大家

00:36:25.046 --> 00:36:26.716 A:middle
去看“Swift 新特性”讲座

00:36:26.716 --> 00:36:28.596 A:middle
以获得更多的例子

00:36:28.596 --> 00:36:30.706 A:middle
了解在代码中这些问题是如何可见的

00:36:30.706 --> 00:36:32.766 A:middle
以及它们与代码的关联

00:36:33.716 --> 00:36:36.206 A:middle
为了解决这个问题 Swift

00:36:36.396 --> 00:36:38.336 A:middle
可以选择将其声明为

00:36:38.336 --> 00:36:39.986 A:middle
未定义行为

00:36:41.036 --> 00:36:43.716 A:middle
然而 Swift 并

00:36:43.716 --> 00:36:44.766 A:middle
没有改变 因为

00:36:44.766 --> 00:36:46.376 A:middle
未定义行为是

00:36:46.376 --> 00:36:47.546 A:middle
语言中安全性和可实施解决方案

00:36:47.546 --> 00:36:49.246 A:middle
这些提供强有力保障手段

00:36:49.276 --> 00:36:50.976 A:middle
的一个敌人

00:36:51.456 --> 00:36:54.506 A:middle
在这里 找到正确的

00:36:54.506 --> 00:36:55.736 A:middle
解决方案是一种

00:36:55.736 --> 00:36:55.986 A:middle
平衡的举动

00:36:56.436 --> 00:36:58.036 A:middle
最好是静态地诊断一切

00:36:58.036 --> 00:37:00.156 A:middle
但是通常情况下

00:36:58.036 --> 00:37:00.156 A:middle
但是通常情况下

00:37:00.156 --> 00:37:01.606 A:middle
都会造成

00:37:01.606 --> 00:37:03.436 A:middle
类型系统很难使用

00:37:04.126 --> 00:37:05.506 A:middle
另一个解决方案是运行时

00:37:05.506 --> 00:37:05.976 A:middle
检查

00:37:05.976 --> 00:37:07.986 A:middle
然而 语言运行时

00:37:07.986 --> 00:37:09.146 A:middle
必须是高性能

00:37:09.716 --> 00:37:10.836 A:middle
且高效的

00:37:10.976 --> 00:37:12.576 A:middle
任何额外检查的系统

00:37:12.576 --> 00:37:13.906 A:middle
都不能占用过高的系统资源

00:37:14.446 --> 00:37:17.366 A:middle
因此 Swift 项目提出的

00:37:17.366 --> 00:37:19.626 A:middle
解决方案包括

00:37:19.756 --> 00:37:20.986 A:middle
紧实语言

00:37:20.986 --> 00:37:22.876 A:middle
遵循更严格的规则

00:37:23.576 --> 00:37:24.856 A:middle
以及结合使用

00:37:24.856 --> 00:37:27.176 A:middle
静态和动态检查

00:37:27.176 --> 00:37:29.876 A:middle
确保在同一个

00:37:29.876 --> 00:37:31.436 A:middle
线程中不会发生

00:37:31.866 --> 00:37:32.000 A:middle
意外共享

00:37:34.296 --> 00:37:35.666 A:middle
遗憾的是

00:37:35.666 --> 00:37:37.606 A:middle
在线程之间检查访问独占性

00:37:37.606 --> 00:37:39.566 A:middle
成本太高

00:37:40.146 --> 00:37:41.276 A:middle
这里所做的折衷

00:37:41.276 --> 00:37:43.196 A:middle
是依靠工具

00:37:43.586 --> 00:37:45.116 A:middle
特别是“线程杀毒器”

00:37:45.396 --> 00:37:47.306 A:middle
以捕捉涉及

00:37:47.306 --> 00:37:50.326 A:middle
多线程访问的违规行为

00:37:50.496 --> 00:37:51.736 A:middle
一般来说 使用“线程消毒器”

00:37:51.736 --> 00:37:53.366 A:middle
对你的 Swift 代码

00:37:53.366 --> 00:37:55.346 A:middle
非常有益 因为数据竞争

00:37:55.346 --> 00:37:57.686 A:middle
和访问竞争是 Swift 中的未定义行为

00:37:57.686 --> 00:37:59.406 A:middle
并且可能

00:37:59.406 --> 00:38:00.596 A:middle
导致内存损坏

00:37:59.406 --> 00:38:00.596 A:middle
导致内存损坏

00:38:01.196 --> 00:38:02.846 A:middle
有关此工具的更多信息

00:38:02.846 --> 00:38:05.106 A:middle
请观看“使用 Xcode 运行时工具查找 Bug”

00:38:05.316 --> 00:38:06.986 A:middle
的演讲

00:38:07.386 --> 00:38:10.626 A:middle
总之 安全是 Swift 的一个设计

00:38:10.626 --> 00:38:11.156 A:middle
选择

00:38:11.396 --> 00:38:12.716 A:middle
该语言提供了许多

00:38:12.716 --> 00:38:14.426 A:middle
解决方案来避免未定义行为

00:38:14.426 --> 00:38:16.466 A:middle
并阻止开发人员

00:38:16.466 --> 00:38:18.836 A:middle
引入微妙和

00:38:18.836 --> 00:38:19.906 A:middle
可利用的 Bug

00:38:20.596 --> 00:38:24.266 A:middle
今天我们讨论了未定义行为

00:38:24.266 --> 00:38:25.906 A:middle
以及不同的语言如何

00:38:25.906 --> 00:38:26.986 A:middle
解决这个问题

00:38:27.536 --> 00:38:29.866 A:middle
C 语言使用未定义行为

00:38:30.036 --> 00:38:31.916 A:middle
进行轻量化和

00:38:31.916 --> 00:38:32.806 A:middle
优化

00:38:33.436 --> 00:38:34.736 A:middle
然而 我们已经看到了

00:38:34.736 --> 00:38:36.486 A:middle
这可能会导致非常微妙和

00:38:36.486 --> 00:38:38.306 A:middle
难以调试的 Bug  甚至会

00:38:38.306 --> 00:38:39.806 A:middle
引入安全漏洞

00:38:40.366 --> 00:38:42.386 A:middle
Swift 选择遵循不同的

00:38:42.606 --> 00:38:44.116 A:middle
路径 并且被设计成

00:38:44.116 --> 00:38:45.176 A:middle
在默认情况下更安全

00:38:46.596 --> 00:38:48.036 A:middle
最后 无论你

00:38:48.036 --> 00:38:49.646 A:middle
选择哪种语言 请使用所有

00:38:49.646 --> 00:38:51.156 A:middle
可用的工具作为

00:38:51.156 --> 00:38:52.516 A:middle
应用程序发布和测试过程的

00:38:52.516 --> 00:38:52.946 A:middle
一部分

00:38:53.416 --> 00:38:55.076 A:middle
这将使你的应用程序更加

00:38:55.076 --> 00:38:57.000 A:middle
安全可靠

00:39:00.086 --> 00:39:01.136 A:middle
这里是我们

00:39:01.136 --> 00:39:02.226 A:middle
今天提到的一些

00:39:02.226 --> 00:39:02.636 A:middle
相关会议

00:39:03.176 --> 00:39:04.896 A:middle
非常感谢 祝你

00:39:04.896 --> 00:39:06.660 A:middle
愉快地度过今天接下来的时间

00:39:07.516 --> 00:39:10.500 A:middle
[掌声]
