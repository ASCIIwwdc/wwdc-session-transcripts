WEBVTT

00:00:17.551 --> 00:00:19.353 align:middle line:10%
<c.magenta>（使用Xcode运行时工具发现漏洞）</c>

00:00:19.486 --> 00:00:20.320 align:middle line:90%,end
<c.magenta>大家好</c>

00:00:24.191 --> 00:00:28.562 align:middle line:90%,end
<c.magenta>欢迎参加“使用Xcode运行时工具</c>
<c.magenta>发现漏洞”演讲</c>

00:00:30.397 --> 00:00:33.734 align:middle line:90%,end
<c.magenta>我是库巴</c>
<c.magenta>是开发工具部门的</c>

00:00:33.967 --> 00:00:35.169 align:middle line:90%,end
<c.magenta>程序分析团队工程师</c>

00:00:35.602 --> 00:00:38.672 align:middle line:90%,end
<c.magenta>今天 我们讨论</c>

00:00:39.173 --> 00:00:41.675 align:middle line:90%,end
<c.magenta>在程序运行时使用工具发现漏洞</c>

00:00:42.176 --> 00:00:43.010 align:middle line:90%,end
<c.magenta>让我们开始</c>

00:00:44.745 --> 00:00:46.780 align:middle line:90%,end
<c.magenta>Xcode通过多种方法</c>

00:00:46.847 --> 00:00:49.183 align:middle line:90%,end
<c.magenta>显示程序中的漏洞</c>

00:00:49.316 --> 00:00:51.552 align:middle line:90%,end
<c.magenta>例如 通过编辑器错误消息</c>

00:00:52.052 --> 00:00:53.020 align:middle line:90%,end
<c.magenta>编译器警告</c>

00:00:53.687 --> 00:00:54.655 align:middle line:90%,end
<c.magenta>分析器警告</c>

00:00:55.289 --> 00:00:56.190 align:middle line:90%,end
<c.magenta>或测试错误等</c>

00:00:57.191 --> 00:00:58.592 align:middle line:90%,end
<c.magenta>去年 在Xcode 8中</c>

00:00:58.659 --> 00:01:02.462 align:middle line:90%,end
<c.magenta>我们增加一个全新的类别</c>
<c.magenta>其名称为Runtime Issues</c>

00:00:58.659 --> 00:01:02.462 align:middle line:90%,end
<c.magenta>我们增加一个全新的类别</c>
<c.magenta>其名称为Runtime Issues</c>

00:01:03.497 --> 00:01:05.966 align:middle line:90%,end
<c.magenta>这些问题是在程序运行时</c>

00:01:06.200 --> 00:01:07.467 align:middle line:90%,end
<c.magenta>使用多个不同的工具发现的</c>

00:01:09.303 --> 00:01:12.339 align:middle line:90%,end
<c.magenta>当你像以前一样运行和调试程序时</c>

00:01:12.439 --> 00:01:15.309 align:middle line:90%,end
<c.magenta>这些工具在运行时发现和检测漏洞</c>

00:01:15.375 --> 00:01:19.313 align:middle line:90%,end
<c.magenta>然后在Xcode运行时问题导航器中</c>
<c.magenta>显示这些漏洞</c>

00:01:20.314 --> 00:01:23.984 align:middle line:90%,end
<c.magenta>如果你没有注意到这个导航器</c>

00:01:24.051 --> 00:01:27.187 align:middle line:10%
<c.magenta>Xcode会指示它发现一些运行时问题</c>

00:01:27.721 --> 00:01:30.757 align:middle line:10%
<c.magenta>显示这个紫色警告图标</c>

00:01:33.060 --> 00:01:35.929 align:middle line:90%,end
<c.magenta>你可以在导航器中点击这些问题</c>

00:01:36.096 --> 00:01:40.267 align:middle line:90%,end
<c.magenta>编辑器将会告诉你</c>
<c.magenta>哪些代码行含有漏洞</c>

00:01:42.069 --> 00:01:43.770 align:middle line:90%,end
<c.magenta>漏洞来源可能各不相同</c>

00:01:43.837 --> 00:01:46.473 align:middle line:90%,end
<c.magenta>因为不同的工具报告不同类型的漏洞</c>

00:01:46.974 --> 00:01:47.808 align:middle line:90%,end
<c.magenta>今天我们的演讲中</c>

00:01:47.875 --> 00:01:50.010 align:middle line:90%,end
<c.magenta>讨论的所有这些工具</c>

00:01:50.143 --> 00:01:52.980 align:middle line:90%,end
<c.magenta>可以在方案编辑器的诊断阶段找到它们</c>

00:01:53.514 --> 00:01:56.350 align:middle line:90%,end
<c.magenta>在Xcode 9中</c>
<c.magenta>现在加入一些新功能</c>

00:01:56.783 --> 00:01:59.786 align:middle line:90%,end
<c.magenta>你们可以看到</c>
<c.magenta>现在增加了Address Sanitizer、</c>

00:02:00.087 --> 00:02:03.390 align:middle line:90%,end
<c.magenta>Threat Sanitizer、</c>
<c.magenta>Undefined Behavior Sanitizer</c>

00:02:03.524 --> 00:02:05.192 align:middle line:90%,end
<c.magenta>和Main Thread Checker</c>

00:02:05.726 --> 00:02:09.496 align:middle line:90%,end
<c.magenta>这些工具在程序运行时发现漏洞</c>

00:02:10.062 --> 00:02:12.633 align:middle line:90%,end
<c.magenta>今天我们将会讨论这些工具</c>

00:02:13.200 --> 00:02:15.469 align:middle line:90%,end
<c.magenta>首先 我们来看</c>
<c.magenta>Main Thread Checker</c>

00:02:15.536 --> 00:02:17.571 align:middle line:90%,end
<c.magenta>它是Xcode 9中的全新工具</c>

00:02:19.072 --> 00:02:22.276 align:middle line:90%,end
<c.magenta>然后我会讨论Address Sanitizer</c>
<c.magenta>和Thread Sanitizer</c>

00:02:22.342 --> 00:02:25.479 align:middle line:90%,end
<c.magenta>以及今年我们对这些工具所做的改进</c>

00:02:26.647 --> 00:02:29.016 align:middle line:90%,end
<c.magenta>我们将会介绍另外一个全新工具</c>

00:02:29.116 --> 00:02:30.851 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>

00:02:31.785 --> 00:02:34.621 align:middle line:90%,end
<c.magenta>最后 我们介绍一些小技巧</c>
<c.magenta>和最佳实践</c>

00:02:35.122 --> 00:02:37.024 align:middle line:90%,end
<c.magenta>让你们能够高效率地使用这些工具</c>

00:02:38.058 --> 00:02:38.992 align:middle line:90%,end
<c.magenta>让我们开始</c>

00:02:41.128 --> 00:02:44.364 align:middle line:90%,end
<c.magenta>Main Thread Checker</c>
<c.magenta>是Xcode 9中的全新工具</c>

00:02:44.431 --> 00:02:48.135 align:middle line:90%,end
<c.magenta>它检查一些常用API的违规</c>

00:02:49.136 --> 00:02:52.739 align:middle line:90%,end
<c.magenta>重点检查UI更新和多线程</c>

00:02:53.740 --> 00:02:57.878 align:middle line:90%,end
<c.magenta>一些API要求你仅在主线程中使用它们</c>

00:02:58.745 --> 00:03:01.415 align:middle line:90%,end
<c.magenta>例如 AppKit和UIKit框架中的</c>

00:02:58.745 --> 00:03:01.415 align:middle line:90%,end
<c.magenta>例如 AppKit和UIKit框架中的</c>

00:03:01.481 --> 00:03:03.417 align:middle line:10%
<c.magenta>许多API都这样做</c>

00:03:04.084 --> 00:03:07.421 align:middle line:10%
<c.magenta>大多数macOS和iOS图形应用程序</c>
<c.magenta>都会使用这些API</c>

00:03:07.754 --> 00:03:10.057 align:middle line:10%
<c.magenta>假设你使用这些框架</c>

00:03:10.457 --> 00:03:12.426 align:middle line:10%
<c.magenta>就应该知道这些限制</c>

00:03:12.559 --> 00:03:14.862 align:middle line:10%
<c.magenta>即 必须在主线程中调用这些API</c>

00:03:15.562 --> 00:03:17.764 align:middle line:90%,end
<c.magenta>这很容易做到</c>

00:03:17.831 --> 00:03:20.167 align:middle line:90%,end
<c.magenta>我们只需要确保</c>
<c.magenta>在主线程上调用这些API就可以了</c>

00:03:21.502 --> 00:03:22.769 align:middle line:90%,end
<c.magenta>但是 有一些任务</c>

00:03:22.836 --> 00:03:25.172 align:middle line:90%,end
<c.magenta>你并不想在主线程上执行它们</c>

00:03:25.372 --> 00:03:27.441 align:middle line:90%,end
<c.magenta>比如下载 这时你需要等待数据到达</c>

00:03:27.508 --> 00:03:29.276 align:middle line:90%,end
<c.magenta>另外还有图像处理任务</c>

00:03:29.343 --> 00:03:32.112 align:middle line:90%,end
<c.magenta>通常需要大量的计算</c>

00:03:33.247 --> 00:03:36.149 align:middle line:90%,end
<c.magenta>因此应该将这些任务移出主线程</c>

00:03:36.350 --> 00:03:38.085 align:middle line:90%,end
<c.magenta>使UI保持快速响应</c>

00:03:38.151 --> 00:03:41.255 align:middle line:90%,end
<c.magenta>而且不会阻止应用中的用户交互</c>

00:03:42.222 --> 00:03:45.826 align:middle line:90%,end
<c.magenta>但是 这些任务也需要触发UI更新</c>

00:03:46.760 --> 00:03:50.831 align:middle line:90%,end
<c.magenta>如果这些UI更新调用</c>
<c.magenta>AppKit或UIKit API</c>

00:03:51.532 --> 00:03:53.467 align:middle line:90%,end
<c.magenta>将需要在主线程中进行更新</c>

00:03:53.567 --> 00:03:55.435 align:middle line:90%,end
<c.magenta>很容易犯的错误是</c>

00:03:55.502 --> 00:03:58.372 align:middle line:90%,end
<c.magenta>在不合适的线程中</c>
<c.magenta>意外调用这些UI更新</c>

00:03:59.139 --> 00:04:00.874 align:middle line:90%,end
<c.magenta>这可能会造成严重后果</c>

00:03:59.139 --> 00:04:00.874 align:middle line:90%,end
<c.magenta>这可能会造成严重后果</c>

00:04:01.175 --> 00:04:04.811 align:middle line:90%,end
<c.magenta>如果UI更新缺失</c>
<c.magenta>会造成UI完全不更新</c>

00:04:05.145 --> 00:04:06.480 align:middle line:90%,end
<c.magenta>或者其它显示错误</c>

00:04:06.914 --> 00:04:09.816 align:middle line:90%,end
<c.magenta>甚至可能发生更严重的问题</c>
<c.magenta>比如数据损坏或程序崩溃</c>

00:04:10.350 --> 00:04:11.752 align:middle line:90%,end
<c.magenta>因此 为了避免这些问题</c>

00:04:12.085 --> 00:04:15.556 align:middle line:90%,end
<c.magenta>我们需要确保 仅在主线程中</c>
<c.magenta>进行UI更新</c>

00:04:16.623 --> 00:04:19.392 align:middle line:90%,end
<c.magenta>为此 我想为大家介绍</c>
<c.magenta>Main Thread Checker</c>

00:04:19.459 --> 00:04:21.128 align:middle line:90%,end
<c.magenta>我为大家进行展示</c>

00:04:30.771 --> 00:04:32.806 align:middle line:90%,end
<c.magenta>这里一个简单的应用程序</c>

00:04:32.873 --> 00:04:34.942 align:middle line:90%,end
<c.magenta>它从互联网下载一些数据</c>

00:04:35.375 --> 00:04:38.846 align:middle line:90%,end
<c.magenta>从这个长URL下载一个文件</c>

00:04:38.912 --> 00:04:40.981 align:middle line:90%,end
<c.magenta>这个网站是</c>
<c.magenta>developer.apple.com</c>

00:04:41.281 --> 00:04:44.651 align:middle line:90%,end
<c.magenta>要下载的文件是</c>
<c.magenta>2013年Apple发布的一些示例代码</c>

00:04:45.052 --> 00:04:46.119 align:middle line:90%,end
<c.magenta>它是一个zip文件</c>

00:04:46.186 --> 00:04:48.155 align:middle line:90%,end
<c.magenta>几兆大小</c>

00:04:48.222 --> 00:04:50.657 align:middle line:90%,end
<c.magenta>它是一个示例下载文件</c>

00:04:51.692 --> 00:04:55.762 align:middle line:90%,end
<c.magenta>为了下载这个文件</c>
<c.magenta>我将用名称为URLSession的类</c>

00:04:55.829 --> 00:04:57.064 align:middle line:90%,end
<c.magenta>这是一个Foundation类</c>

00:04:57.130 --> 00:04:59.533 align:middle line:90%,end
<c.magenta>是一种方便的文件下载方法</c>

00:05:02.069 --> 00:05:04.304 align:middle line:90%,end
<c.magenta>应用的UI非常简单</c>

00:05:05.272 --> 00:05:08.542 align:middle line:90%,end
<c.magenta>含有一个按钮和一个进度条</c>

00:05:08.609 --> 00:05:12.713 align:middle line:90%,end
<c.magenta>我们可以实现</c>
<c.magenta>URLSession进度回调</c>

00:05:12.779 --> 00:05:16.116 align:middle line:90%,end
<c.magenta>在这个回调中</c>
<c.magenta>我更新进度条的值</c>

00:05:16.350 --> 00:05:17.985 align:middle line:90%,end
<c.magenta>让我们运行这个程序</c>

00:05:18.118 --> 00:05:22.523 align:middle line:10%
<c.magenta>看它是否显示下载进度</c>

00:05:22.890 --> 00:05:25.726 align:middle line:90%,end
<c.magenta>点击按钮开始下载</c>

00:05:26.126 --> 00:05:28.295 align:middle line:90%,end
<c.magenta>可以看到</c>
<c.magenta>有点不正常</c>

00:05:28.462 --> 00:05:31.198 align:middle line:90%,end
<c.magenta>因为进度条在开始位置卡住了</c>

00:05:31.632 --> 00:05:34.801 align:middle line:90%,end
<c.magenta>现在 因为某种原因</c>
<c.magenta>它直接跳到末尾</c>

00:05:35.969 --> 00:05:39.206 align:middle line:90%,end
<c.magenta>因此我想</c>
<c.magenta>我的程序可能存在漏洞</c>

00:05:39.273 --> 00:05:41.808 align:middle line:90%,end
<c.magenta>或者URLSession工作不正常</c>

00:05:42.543 --> 00:05:43.577 align:middle line:90%,end
<c.magenta>此功能的最大好处是</c>

00:05:43.644 --> 00:05:45.679 align:middle line:90%,end
<c.magenta>我不需要猜测哪里出了问题</c>

00:05:45.846 --> 00:05:47.614 align:middle line:90%,end
<c.magenta>Xcode已经找到问题</c>

00:05:48.182 --> 00:05:50.317 align:middle line:90%,end
<c.magenta>我们返回Xcode</c>

00:05:50.551 --> 00:05:54.521 align:middle line:90%,end
<c.magenta>它告诉我们</c>
<c.magenta>发现一个运行时问题</c>

00:05:55.589 --> 00:05:57.991 align:middle line:90%,end
<c.magenta>让我们点击这个运行时问题</c>
<c.magenta>查看详情</c>

00:05:58.058 --> 00:06:00.360 align:middle line:90%,end
<c.magenta>你会看到导航器</c>

00:05:58.058 --> 00:06:00.360 align:middle line:90%,end
<c.magenta>你会看到导航器</c>

00:06:00.661 --> 00:06:02.262 align:middle line:90%,end
<c.magenta>没有切换到Runtime Issues导航器</c>

00:06:02.996 --> 00:06:03.897 align:middle line:90%,end
<c.magenta>它告诉我</c>

00:06:03.964 --> 00:06:07.301 align:middle line:90%,end
<c.magenta>我在后台线程中调用一些UI API</c>

00:06:08.769 --> 00:06:10.103 align:middle line:90%,end
<c.magenta>我点击问题</c>

00:06:10.170 --> 00:06:13.874 align:middle line:90%,end
<c.magenta>查看含有无效API代码的代码块</c>

00:06:14.441 --> 00:06:15.342 align:middle line:90%,end
<c.magenta>在本例中</c>

00:06:15.676 --> 00:06:18.512 align:middle line:90%,end
<c.magenta>我们在后台线程中</c>

00:06:18.579 --> 00:06:21.215 align:middle line:90%,end
<c.magenta>为进度指示条设置一个新值</c>

00:06:21.515 --> 00:06:23.550 align:middle line:90%,end
<c.magenta>而这应该是在主线程中完成的</c>

00:06:25.786 --> 00:06:26.854 align:middle line:90%,end
<c.magenta>因此这是一个异常</c>

00:06:26.920 --> 00:06:30.057 align:middle line:90%,end
<c.magenta>因为我想要在后台线程中执行这个代码</c>

00:06:30.324 --> 00:06:32.860 align:middle line:90%,end
<c.magenta>实际上 我没有在代码中</c>
<c.magenta>进行任何线程处理</c>

00:06:34.061 --> 00:06:36.597 align:middle line:90%,end
<c.magenta>因此实际问题是</c>
<c.magenta>当我调用URLSession对象时</c>

00:06:36.663 --> 00:06:40.200 align:middle line:90%,end
<c.magenta>犯了错误</c>

00:06:40.667 --> 00:06:43.504 align:middle line:90%,end
<c.magenta>在这一行</c>
<c.magenta>我创建URLSession</c>

00:06:43.804 --> 00:06:47.875 align:middle line:90%,end
<c.magenta>指定用于进度回调</c>

00:06:47.941 --> 00:06:50.611 align:middle line:90%,end
<c.magenta>和下载完成回调的视图</c>

00:06:51.078 --> 00:06:53.914 align:middle line:90%,end
<c.magenta>我没有提供队列</c>
<c.magenta>而是指定nil</c>

00:06:54.014 --> 00:06:56.116 align:middle line:90%,end
<c.magenta>这意味着我并不关心</c>

00:06:56.183 --> 00:06:59.653 align:middle line:90%,end
<c.magenta>URLSession可能会在后台队列中</c>
<c.magenta>进行这些调用</c>

00:07:01.722 --> 00:07:05.993 align:middle line:90%,end
<c.magenta>现在 我们知道</c>
<c.magenta>为什么在后台线程中进行调用</c>

00:07:06.293 --> 00:07:08.795 align:middle line:90%,end
<c.magenta>为了解决这个问题 我可能使用GCD</c>

00:07:08.862 --> 00:07:11.598 align:middle line:90%,end
<c.magenta>将UI更新操作</c>
<c.magenta>分配回给主线程</c>

00:07:12.165 --> 00:07:15.335 align:middle line:90%,end
<c.magenta>在本例中</c>
<c.magenta>我可以要求URLSession</c>

00:07:15.402 --> 00:07:18.038 align:middle line:90%,end
<c.magenta>直接在主队列上进行回调</c>

00:07:18.105 --> 00:07:19.273 align:middle line:90%,end
<c.magenta>我们将会这样做</c>

00:07:20.507 --> 00:07:24.211 align:middle line:90%,end
<c.magenta>我要求它在主队列上进行回调</c>

00:07:24.478 --> 00:07:26.580 align:middle line:90%,end
<c.magenta>让我们多次运行程序</c>

00:07:26.647 --> 00:07:28.515 align:middle line:90%,end
<c.magenta>查看这是否会解决我们的问题</c>

00:07:29.716 --> 00:07:31.285 align:middle line:90%,end
<c.magenta>点击按钮</c>

00:07:31.552 --> 00:07:33.687 align:middle line:90%,end
<c.magenta>会看到进度条平滑地行进</c>

00:07:33.754 --> 00:07:35.989 align:middle line:90%,end
<c.magenta>表示正在下载</c>

00:07:40.060 --> 00:07:40.894 align:middle line:90%,end
<c.magenta>谢谢</c>

00:07:43.530 --> 00:07:45.032 align:middle line:90%,end
<c.magenta>现在我切换到幻灯片</c>

00:07:49.069 --> 00:07:49.903 align:middle line:90%,end
<c.magenta>在这里</c>

00:07:51.605 --> 00:07:54.374 align:middle line:90%,end
<c.magenta>我们看到一个例子</c>

00:07:54.441 --> 00:07:58.111 align:middle line:90%,end
<c.magenta>显示Main Thread Checker</c>
<c.magenta>如何帮助我们发现并修复漏洞</c>

00:07:58.245 --> 00:08:00.247 align:middle line:90%,end
<c.magenta>因为我们在错误线程中调用一些API</c>
<c.magenta>而造成这个漏洞</c>

00:07:58.245 --> 00:08:00.247 align:middle line:90%,end
<c.magenta>因为我们在错误线程中调用一些API</c>
<c.magenta>而造成这个漏洞</c>

00:08:00.881 --> 00:08:03.984 align:middle line:90%,end
<c.magenta>请注意 我并没有启用这两个选项</c>

00:08:04.117 --> 00:08:06.119 align:middle line:90%,end
<c.magenta>因为在你使用Xcode调试器时</c>

00:08:06.253 --> 00:08:08.155 align:middle line:90%,end
<c.magenta>默认已经启用它们</c>

00:08:10.457 --> 00:08:12.526 align:middle line:90%,end
<c.magenta>如果想要在Xcode中找到这个代码</c>

00:08:13.327 --> 00:08:16.530 align:middle line:90%,end
<c.magenta>可以在诊断步骤看到它</c>

00:08:16.997 --> 00:08:19.132 align:middle line:90%,end
<c.magenta>你会注意到 在Xcode 9中</c>

00:08:19.266 --> 00:08:21.835 align:middle line:90%,end
<c.magenta>有一个复选项 其名称为</c>
<c.magenta>Main Thread Checker</c>

00:08:22.603 --> 00:08:25.205 align:middle line:90%,end
<c.magenta>在这里</c>
<c.magenta>可以启用或关闭这两个选项</c>

00:08:26.306 --> 00:08:30.210 align:middle line:90%,end
<c.magenta>如果想要调试器停止</c>
<c.magenta>检查违规</c>

00:08:30.644 --> 00:08:32.746 align:middle line:90%,end
<c.magenta>可以选择“Pause on Issues”复选框</c>

00:08:33.280 --> 00:08:36.183 align:middle line:90%,end
<c.magenta>然后调试器将会在检查到问题后停止</c>

00:08:36.250 --> 00:08:38.818 align:middle line:90%,end
<c.magenta>你可以查看当前的程序状态</c>

00:08:39.318 --> 00:08:40.687 align:middle line:90%,end
<c.magenta>分析发生了什么问题</c>

00:08:42.289 --> 00:08:43.457 align:middle line:90%,end
<c.magenta>（常见问题）</c>

00:08:43.524 --> 00:08:45.792 align:middle line:90%,end
<c.magenta>现在 我们来讨论一些常见的问题</c>

00:08:46.860 --> 00:08:48.695 align:middle line:90%,end
<c.magenta>这些问题让</c>
<c.magenta>Main Thread Checker检测到漏洞</c>

00:08:49.496 --> 00:08:50.764 align:middle line:90%,end
<c.magenta>在演示中可以看到</c>

00:08:51.031 --> 00:08:57.037 align:middle line:90%,end
<c.magenta>后台线程中</c>

00:08:57.237 --> 00:08:58.405 align:middle line:90%,end
<c.magenta>经常会进行网络回调</c>

00:08:59.239 --> 00:09:02.342 align:middle line:90%,end
<c.magenta>你们需要注意</c>
<c.magenta>应该在主线程中</c>

00:08:59.239 --> 00:09:02.342 align:middle line:90%,end
<c.magenta>你们需要注意</c>
<c.magenta>应该在主线程中</c>

00:09:02.576 --> 00:09:03.710 align:middle line:90%,end
<c.magenta>进行UI更新</c>

00:09:04.645 --> 00:09:05.913 align:middle line:90%,end
<c.magenta>另外 当你创建和销毁</c>

00:09:05.979 --> 00:09:09.249 align:middle line:90%,end
<c.magenta>NSView或UIView对象时</c>
<c.magenta>也容易产生问题</c>

00:09:09.349 --> 00:09:11.952 align:middle line:90%,end
<c.magenta>也需要在主线程中完成这些工作</c>

00:09:13.887 --> 00:09:16.523 align:middle line:90%,end
<c.magenta>如果你在编写库或框架</c>

00:09:16.657 --> 00:09:19.126 align:middle line:90%,end
<c.magenta>提供一些异步API</c>

00:09:19.660 --> 00:09:22.095 align:middle line:90%,end
<c.magenta>当设计这些API时</c>
<c.magenta>应该非常注意</c>

00:09:22.496 --> 00:09:23.330 align:middle line:90%,end
<c.magenta>让我们来看看</c>

00:09:26.033 --> 00:09:27.701 align:middle line:90%,end
<c.magenta>假设我们想要设计一个API</c>

00:09:27.768 --> 00:09:30.470 align:middle line:90%,end
<c.magenta>用于执行长时间和高密度的计算</c>

00:09:30.537 --> 00:09:33.207 align:middle line:90%,end
<c.magenta>它以异步方式运行</c>

00:09:34.575 --> 00:09:38.846 align:middle line:90%,end
<c.magenta>API的调用函数需要</c>
<c.magenta>提供API结束处理程序</c>

00:09:38.912 --> 00:09:41.481 align:middle line:90%,end
<c.magenta>这个收尾程序将用作</c>
<c.magenta>完成处理程序</c>

00:09:41.548 --> 00:09:43.150 align:middle line:90%,end
<c.magenta>因此 当任务完成时</c>

00:09:43.617 --> 00:09:46.486 align:middle line:90%,end
<c.magenta>API将调用</c>
<c.magenta>提供的收尾处理程序</c>

00:09:47.387 --> 00:09:49.556 align:middle line:90%,end
<c.magenta>但是 这个代码示例中</c>
<c.magenta>并没有明确地指定</c>

00:09:49.923 --> 00:09:52.459 align:middle line:90%,end
<c.magenta>哪个队列或线程</c>
<c.magenta>将会用于这个收尾处理</c>

00:09:53.227 --> 00:09:55.195 align:middle line:90%,end
<c.magenta>在不合适的线程中处理这些代码时</c>

00:09:55.262 --> 00:09:57.664 align:middle line:90%,end
<c.magenta>很容易产生错误</c>

00:10:01.568 --> 00:10:04.805 align:middle line:90%,end
<c.magenta>良好的API应该要求甚至强制用户</c>

00:10:05.038 --> 00:10:08.509 align:middle line:90%,end
<c.magenta>规定哪个视图应该用于完成处理程序</c>

00:10:08.575 --> 00:10:10.544 align:middle line:90%,end
<c.magenta>如果你阅读这段代码示例</c>

00:10:10.878 --> 00:10:14.014 align:middle line:90%,end
<c.magenta>很容易看到</c>
<c.magenta>将在提供的队列上调用收尾处理程序</c>

00:10:14.081 --> 00:10:15.582 align:middle line:90%,end
<c.magenta>不需要阅读API文档</c>

00:10:15.649 --> 00:10:17.618 align:middle line:90%,end
<c.magenta>就可以知道这一点</c>

00:10:20.187 --> 00:10:21.021 align:middle line:90%,end
<c.magenta>前面我说过</c>

00:10:21.221 --> 00:10:24.625 align:middle line:90%,end
<c.magenta>Main Thread Checker检测</c>
<c.magenta>API线程处理规则违规</c>

00:10:25.259 --> 00:10:27.895 align:middle line:90%,end
<c.magenta>它支持AppKit、UIKit和WebKit</c>

00:10:27.961 --> 00:10:30.163 align:middle line:90%,end
<c.magenta>它们是最常用的三个框架</c>

00:10:30.230 --> 00:10:33.867 align:middle line:90%,end
<c.magenta>而且它们的许多API</c>

00:10:33.934 --> 00:10:35.569 align:middle line:90%,end
<c.magenta>都具有相同的主线程要求</c>

00:10:36.770 --> 00:10:39.473 align:middle line:90%,end
<c.magenta>我们的工具支持Swift和C语言</c>

00:10:39.773 --> 00:10:43.043 align:middle line:90%,end
<c.magenta>与其它工具相比</c>
<c.magenta>今天我们讨论的工具</c>

00:10:43.610 --> 00:10:45.412 align:middle line:90%,end
<c.magenta>并不需要重新编译</c>

00:10:46.013 --> 00:10:48.081 align:middle line:90%,end
<c.magenta>你甚至可以它们用于</c>
<c.magenta>已有的二进制代码</c>

00:10:49.716 --> 00:10:52.519 align:middle line:90%,end
<c.magenta>其最大的好处是</c>
<c.magenta>已经默认启用</c>

00:10:52.586 --> 00:10:53.954 align:middle line:90%,end
<c.magenta>你不需要做任何事情</c>

00:10:54.021 --> 00:10:55.856 align:middle line:90%,end
<c.magenta>就可以通过工具获得警告信息</c>

00:10:55.923 --> 00:10:58.525 align:middle line:90%,end
<c.magenta>当你使用Xcode调试器时</c>
<c.magenta>就会启用此工具</c>

00:10:59.660 --> 00:11:01.195 align:middle line:90%,end
<c.magenta>这就是Main Thread Checker</c>

00:10:59.660 --> 00:11:01.195 align:middle line:90%,end
<c.magenta>这就是Main Thread Checker</c>

00:11:01.428 --> 00:11:03.297 align:middle line:90%,end
<c.magenta>Xcode 9包含的一个全新工具</c>

00:11:12.072 --> 00:11:16.844 align:middle line:90%,end
<c.magenta>接下来 我们讨论</c>
<c.magenta>另一个方面的问题 内存问题</c>

00:11:17.411 --> 00:11:20.948 align:middle line:90%,end
<c.magenta>接下来我们讨论Address Sanitizer</c>
<c.magenta>这个工具发现内存问题</c>

00:11:22.182 --> 00:11:26.286 align:middle line:90%,end
<c.magenta>两年前 Address Sanitizer</c>
<c.magenta>被引入Xcode 7</c>

00:11:26.353 --> 00:11:28.288 align:middle line:90%,end
<c.magenta>实践证明它是一个很不错的工具</c>

00:11:28.355 --> 00:11:30.557 align:middle line:10%
<c.magenta>因为它能够发现严重的安全问题</c>

00:11:30.691 --> 00:11:33.627 align:middle line:10%
<c.magenta>例如 内存释放后使用问题</c>
<c.magenta>和缓冲区溢出</c>

00:11:34.695 --> 00:11:35.963 align:middle line:10%
<c.magenta>另外 当尝试诊断</c>

00:11:36.029 --> 00:11:38.498 align:middle line:10%
<c.magenta>难以重现的崩溃问题时</c>
<c.magenta>此工具有十分有用</c>

00:11:38.565 --> 00:11:41.568 align:middle line:10%
<c.magenta>因为它确定崩溃原因</c>

00:11:41.969 --> 00:11:45.038 align:middle line:10%
<c.magenta>在发生崩溃时</c>

00:11:45.105 --> 00:11:46.206 align:middle line:10%
<c.magenta>发现内存异常问题</c>

00:11:46.273 --> 00:11:48.642 align:middle line:10%
<c.magenta>确定哪些相关代码</c>
<c.magenta>受到内存崩溃的影响</c>

00:11:49.643 --> 00:11:51.678 align:middle line:10%
<c.magenta>如果你想知道</c>
<c.magenta>此工具如何工作</c>

00:11:51.745 --> 00:11:53.680 align:middle line:90%,end
<c.magenta>以及它可以发现哪些漏洞</c>

00:11:53.747 --> 00:11:56.884 align:middle line:90%,end
<c.magenta>建议你们观看</c>
<c.magenta>两年前的WWDC演讲</c>

00:11:57.084 --> 00:11:59.920 align:middle line:90%,end
<c.magenta>其名称为“高级调试技术</c>
<c.magenta>与Address Sanitizer”</c>

00:12:00.654 --> 00:12:02.489 align:middle line:90%,end
<c.magenta>在那个演讲中</c>
<c.magenta>我们介绍这个工具</c>

00:12:02.556 --> 00:12:05.359 align:middle line:90%,end
<c.magenta>并讨论其底层工作原理</c>

00:12:06.994 --> 00:12:11.231 align:middle line:90%,end
<c.magenta>Address Sanitizer集成到</c>
<c.magenta>Xcode UI和调试器中</c>

00:12:11.465 --> 00:12:12.299 align:middle line:90%,end
<c.magenta>让我们来看看</c>

00:12:12.499 --> 00:12:14.434 align:middle line:90%,end
<c.magenta>如果你想要使用Address Sanitizer</c>

00:12:14.535 --> 00:12:16.570 align:middle line:90%,end
<c.magenta>需要做的是</c>
<c.magenta>再次进入方案编辑器</c>

00:12:16.637 --> 00:12:19.873 align:middle line:90%,end
<c.magenta>你会发现有一个复选框</c>
<c.magenta>名称为“Address Sanitizer”</c>

00:12:20.307 --> 00:12:21.842 align:middle line:90%,end
<c.magenta>选中后将会启用此工具</c>

00:12:22.809 --> 00:12:25.345 align:middle line:90%,end
<c.magenta>在Xcode 9中有另外一个复选框</c>

00:12:25.512 --> 00:12:29.416 align:middle line:90%,end
<c.magenta>名称为</c>
<c.magenta>“Use of stack after return”</c>

00:12:29.650 --> 00:12:31.185 align:middle line:90%,end
<c.magenta>后面我将会介绍这个功能</c>

00:12:31.952 --> 00:12:33.053 align:middle line:90%,end
<c.magenta>你还会注意到</c>

00:12:33.320 --> 00:12:35.789 align:middle line:90%,end
<c.magenta>我们增加了</c>
<c.magenta>Malloc Scribble兼容功能</c>

00:12:35.856 --> 00:12:38.659 align:middle line:90%,end
<c.magenta>因此可以同时启用这两个工具</c>

00:12:41.094 --> 00:12:43.430 align:middle line:90%,end
<c.magenta>然后 你可以运行和调试你的应用</c>

00:12:43.497 --> 00:12:44.665 align:middle line:90%,end
<c.magenta>就像以前一样</c>

00:12:45.165 --> 00:12:48.569 align:middle line:90%,end
<c.magenta>如果程序没有任何内存问题</c>

00:12:48.635 --> 00:12:52.206 align:middle line:90%,end
<c.magenta>没有发生内存违规</c>
<c.magenta>那么一切正常</c>

00:12:52.773 --> 00:12:55.108 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>不会中断你的工作</c>

00:12:55.475 --> 00:12:58.745 align:middle line:90%,end
<c.magenta>但是如果发现问题</c>
<c.magenta>将会停止程序</c>

00:12:58.812 --> 00:13:00.280 align:middle line:90%,end
<c.magenta>并描述问题是什么</c>

00:12:58.812 --> 00:13:00.280 align:middle line:90%,end
<c.magenta>并描述问题是什么</c>

00:13:00.347 --> 00:13:01.481 align:middle line:90%,end
<c.magenta>在本例中</c>

00:13:01.882 --> 00:13:04.551 align:middle line:90%,end
<c.magenta>我们意外地使用</c>
<c.magenta>一些已释放的内存</c>

00:13:05.052 --> 00:13:06.186 align:middle line:90%,end
<c.magenta>这是一个严重的漏洞</c>

00:13:07.054 --> 00:13:09.056 align:middle line:90%,end
<c.magenta>当Address Sanitizer发现漏洞时</c>

00:13:09.223 --> 00:13:12.025 align:middle line:90%,end
<c.magenta>将会显示</c>

00:13:12.192 --> 00:13:14.027 align:middle line:10%
<c.magenta>关于所访问的内存的详细信息</c>

00:13:14.461 --> 00:13:16.496 align:middle line:10%
<c.magenta>我们不仅会看到内存地址</c>

00:13:16.830 --> 00:13:18.665 align:middle line:10%
<c.magenta>还会看到描述信息</c>

00:13:18.866 --> 00:13:20.767 align:middle line:10%
<c.magenta>比如内存堆区有多大</c>

00:13:20.934 --> 00:13:23.170 align:middle line:10%
<c.magenta>访问了哪些超范围字节</c>

00:13:23.704 --> 00:13:27.207 align:middle line:10%
<c.magenta>还会获得内存分配和</c>
<c.magenta>释放回溯信息</c>

00:13:27.441 --> 00:13:30.043 align:middle line:10%
<c.magenta>描述内存的分配和释放方式</c>

00:13:30.544 --> 00:13:31.845 align:middle line:10%
<c.magenta>当你处理内存释放后使用问题时</c>

00:13:31.912 --> 00:13:34.081 align:middle line:10%
<c.magenta>这些都是非常有用的信息</c>

00:13:34.448 --> 00:13:37.251 align:middle line:90%,end
<c.magenta>因为它们可以帮助你诊断问题</c>

00:13:39.753 --> 00:13:42.222 align:middle line:90%,end
<c.magenta>我们已经对</c>
<c.magenta>Address Sanitizer有所了解</c>

00:13:42.289 --> 00:13:43.924 align:middle line:90%,end
<c.magenta>现在来看我们今年</c>

00:13:43.991 --> 00:13:45.325 align:middle line:90%,end
<c.magenta>增加的一些新功能</c>

00:13:45.559 --> 00:13:47.961 align:middle line:90%,end
<c.magenta>此工具检查两类新漏洞</c>

00:13:48.161 --> 00:13:50.197 align:middle line:90%,end
<c.magenta>即use-after-scope</c>
<c.magenta>和use-after-return</c>

00:13:50.264 --> 00:13:52.799 align:middle line:90%,end
<c.magenta>此工具还兼容Malloc Scribble</c>

00:13:52.966 --> 00:13:54.401 align:middle line:90%,end
<c.magenta>让我们来看一些例子</c>

00:13:56.837 --> 00:13:58.071 align:middle line:90%,end
<c.magenta>在代码示例中</c>

00:13:58.539 --> 00:14:01.074 align:middle line:90%,end
<c.magenta>假设我们在if表达式语句中</c>

00:13:58.539 --> 00:14:01.074 align:middle line:90%,end
<c.magenta>假设我们在if表达式语句中</c>

00:14:01.141 --> 00:14:02.976 align:middle line:90%,end
<c.magenta>定义一个变量</c>

00:14:04.478 --> 00:14:07.181 align:middle line:90%,end
<c.magenta>有一个指针指向这个变量</c>

00:14:07.981 --> 00:14:10.717 align:middle line:90%,end
<c.magenta>然后 在if语句之外</c>

00:14:11.118 --> 00:14:13.587 align:middle line:90%,end
<c.magenta>我们使用这个指针保存一个新值</c>

00:14:14.221 --> 00:14:17.491 align:middle line:90%,end
<c.magenta>这是一个新值</c>
<c.magenta>在这里指针不再有效</c>

00:14:17.658 --> 00:14:19.760 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>能够检测</c>

00:14:19.993 --> 00:14:21.495 align:middle line:90%,end
<c.magenta>并且描述问题</c>

00:14:24.097 --> 00:14:28.035 align:middle line:90%,end
<c.magenta>另一种类型的漏洞发生在</c>
<c.magenta>返回时</c>

00:14:28.302 --> 00:14:30.103 align:middle line:90%,end
<c.magenta>使用指针时</c>

00:14:30.170 --> 00:14:31.772 align:middle line:90%,end
<c.magenta>从函数中返回之后</c>

00:14:31.839 --> 00:14:35.609 align:middle line:90%,end
<c.magenta>在本例中</c>
<c.magenta>函数返回一个指向其本地变量的指针</c>

00:14:36.376 --> 00:14:38.478 align:middle line:90%,end
<c.magenta>这意味着</c>
<c.magenta>函数返回之后</c>

00:14:38.745 --> 00:14:40.414 align:middle line:90%,end
<c.magenta>指针已经不再有效</c>

00:14:40.814 --> 00:14:42.115 align:middle line:90%,end
<c.magenta>如果尝试使用这个指针</c>

00:14:42.482 --> 00:14:44.318 align:middle line:90%,end
<c.magenta>就会访问垃圾内存</c>

00:14:44.484 --> 00:14:46.320 align:middle line:90%,end
<c.magenta>这时Address Sanitizer</c>
<c.magenta>能够检测这个错误</c>

00:14:46.386 --> 00:14:48.255 align:middle line:90%,end
<c.magenta>并描述错误信息</c>

00:14:48.789 --> 00:14:51.491 align:middle line:90%,end
<c.magenta>但是这种检查并不是默认启用的</c>

00:14:51.558 --> 00:14:53.527 align:middle line:90%,end
<c.magenta>因为它会占用一些额外开销</c>

00:14:53.594 --> 00:14:54.761 align:middle line:90%,end
<c.magenta>你应该启用此功能</c>

00:14:54.995 --> 00:14:58.165 align:middle line:90%,end
<c.magenta>为此 你应该选中</c>
<c.magenta>前面我提到过的</c>

00:14:58.298 --> 00:14:59.967 align:middle line:90%,end
<c.magenta>方案编辑器中的复选框</c>

00:15:02.703 --> 00:15:04.338 align:middle line:90%,end
<c.magenta>（ADDRESS SANITIZER与SWIFT）</c>

00:15:04.404 --> 00:15:07.074 align:middle line:90%,end
<c.magenta>现在 如果使用Swift开发项目</c>

00:15:07.407 --> 00:15:08.642 align:middle line:90%,end
<c.magenta>你可能会想</c>

00:15:08.809 --> 00:15:10.844 align:middle line:90%,end
<c.magenta>我什么要使用Address Sanitizer？</c>

00:15:12.012 --> 00:15:13.714 align:middle line:90%,end
<c.magenta>Swift是一种更安全的语言</c>

00:15:13.814 --> 00:15:16.216 align:middle line:90%,end
<c.magenta>但是现实情况是</c>
<c.magenta>许多项目使用混合语言</c>

00:15:16.283 --> 00:15:18.886 align:middle line:90%,end
<c.magenta>它们的C和Objective-C代码</c>
<c.magenta>可能含有漏洞</c>

00:15:19.052 --> 00:15:21.989 align:middle line:90%,end
<c.magenta>对于C和 Objective-C代码</c>

00:15:22.456 --> 00:15:24.491 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>仍然是一个非常有效的工具</c>

00:15:24.558 --> 00:15:26.360 align:middle line:90%,end
<c.magenta>它会发现这些部分的</c>

00:15:26.426 --> 00:15:27.661 align:middle line:90%,end
<c.magenta>代码中的内存问题</c>

00:15:29.096 --> 00:15:31.832 align:middle line:90%,end
<c.magenta>你们一些人可能使用不安全的指针类型</c>

00:15:32.366 --> 00:15:33.934 align:middle line:90%,end
<c.magenta>这意味着</c>

00:15:34.868 --> 00:15:35.736 align:middle line:90%,end
<c.magenta>会产生内存安全问题</c>

00:15:35.802 --> 00:15:37.504 align:middle line:90%,end
<c.magenta>当使用这些指针时</c>
<c.magenta>必须十分注意</c>

00:15:37.738 --> 00:15:39.139 align:middle line:90%,end
<c.magenta>让我们来看代码示例</c>

00:15:40.440 --> 00:15:43.076 align:middle line:90%,end
<c.magenta>在这个代码中 有一个字符串</c>
<c.magenta>“Hello, World!”</c>

00:15:43.143 --> 00:15:47.247 align:middle line:90%,end
<c.magenta>我要将它转换成为</c>
<c.magenta>C样式的字符串</c>

00:15:47.614 --> 00:15:48.682 align:middle line:90%,end
<c.magenta>使用不安全的窗口</c>

00:15:50.217 --> 00:15:53.921 align:middle line:90%,end
<c.magenta>我要做的是调用</c>
<c.magenta>这个名称为withCString的字符串</c>

00:15:54.087 --> 00:15:56.456 align:middle line:90%,end
<c.magenta>这将会为我</c>
<c.magenta>创建一个不安全的指针</c>

00:15:58.025 --> 00:16:00.093 align:middle line:90%,end
<c.magenta>为我提供一个不安全的指针</c>

00:15:58.025 --> 00:16:00.093 align:middle line:90%,end
<c.magenta>为我提供一个不安全的指针</c>

00:16:00.160 --> 00:16:02.229 align:middle line:90%,end
<c.magenta>在这个结束处理中</c>
<c.magenta>我会传递这个指针</c>

00:16:03.297 --> 00:16:06.466 align:middle line:90%,end
<c.magenta>如果在处理程序之外</c>
<c.magenta>保存这个指针</c>

00:16:06.800 --> 00:16:08.702 align:middle line:90%,end
<c.magenta>就违反了C字符串规则</c>

00:16:08.769 --> 00:16:13.974 align:middle line:90%,end
<c.magenta>这意味着 我尝试使用</c>
<c.magenta>这个内存泄漏不安全指针</c>

00:16:14.141 --> 00:16:15.909 align:middle line:90%,end
<c.magenta>也就是说 我在尝试访问无效的内容</c>

00:16:15.976 --> 00:16:18.812 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>能够检测到这样的</c>

00:16:18.879 --> 00:16:21.248 align:middle line:90%,end
<c.magenta>无效地使用不安全指针的情况</c>
<c.magenta>即使在Swift代码中</c>

00:16:25.118 --> 00:16:26.453 align:middle line:90%,end
<c.magenta>为了修复这个问题 我们需要确保</c>

00:16:26.520 --> 00:16:29.223 align:middle line:90%,end
<c.magenta>仅在结束处理程序之内</c>
<c.magenta>使用这个传递C字符串的</c>

00:16:29.723 --> 00:16:32.059 align:middle line:90%,end
<c.magenta>不安全指针</c>

00:16:32.125 --> 00:16:35.162 align:middle line:90%,end
<c.magenta>因此 我们进入结束处理代码</c>

00:16:35.362 --> 00:16:37.364 align:middle line:90%,end
<c.magenta>修复问题</c>

00:16:37.898 --> 00:16:39.766 align:middle line:90%,end
<c.magenta>我们可以进一步简化代码</c>

00:16:39.833 --> 00:16:42.236 align:middle line:90%,end
<c.magenta>完全移除本地变量</c>

00:16:42.870 --> 00:16:44.271 align:middle line:90%,end
<c.magenta>一个良好的做法是</c>

00:16:44.738 --> 00:16:48.475 align:middle line:90%,end
<c.magenta>始终不要将不安全的指针</c>
<c.magenta>存储到本地变量或属性之中</c>

00:16:49.877 --> 00:16:53.046 align:middle line:90%,end
<c.magenta>因此 如果要在Swift项目中</c>
<c.magenta>使用不安全的指针</c>

00:16:53.380 --> 00:16:55.916 align:middle line:90%,end
<c.magenta>我强烈建议你</c>
<c.magenta>在项目中启用Address Sanitizer</c>

00:16:55.983 --> 00:16:57.551 align:middle line:90%,end
<c.magenta>以确保</c>

00:16:57.618 --> 00:17:00.120 align:middle line:90%,end
<c.magenta>不会错误地使用不安全的指针</c>

00:16:57.618 --> 00:17:00.120 align:middle line:90%,end
<c.magenta>不会错误地使用不安全的指针</c>

00:17:03.423 --> 00:17:08.028 align:middle line:90%,end
<c.magenta>我们已经了解Address Sanitizer</c>
<c.magenta>如何帮助你发和修复漏洞</c>

00:17:08.395 --> 00:17:12.098 align:middle line:90%,end
<c.magenta>但是 对于一般性调试</c>
<c.magenta>它也是一个非常有用的工具</c>

00:17:13.200 --> 00:17:16.403 align:middle line:90%,end
<c.magenta>因为当你调试项目时</c>

00:17:16.470 --> 00:17:20.207 align:middle line:90%,end
<c.magenta>你可能会想要知道</c>
<c.magenta>内存分配情况</c>

00:17:20.874 --> 00:17:22.209 align:middle line:90%,end
<c.magenta>我有一个好消息要告诉你</c>

00:17:22.409 --> 00:17:24.278 align:middle line:90%,end
<c.magenta>如果你运行Address Sanitizer</c>

00:17:24.744 --> 00:17:27.915 align:middle line:90%,end
<c.magenta>这将能够告诉你</c>
<c.magenta>所查询的任何内存块的</c>

00:17:27.981 --> 00:17:29.383 align:middle line:90%,end
<c.magenta>分配回溯信息</c>

00:17:30.184 --> 00:17:32.586 align:middle line:90%,end
<c.magenta>另外 还提供已经释放的内存的</c>

00:17:32.653 --> 00:17:34.488 align:middle line:90%,end
<c.magenta>释放回溯信息</c>

00:17:35.255 --> 00:17:36.423 align:middle line:90%,end
<c.magenta>此外 它还会告知</c>

00:17:36.490 --> 00:17:38.825 align:middle line:90%,end
<c.magenta>哪些内存字节是有效和无效的</c>

00:17:40.027 --> 00:17:40.861 align:middle line:90%,end
<c.magenta>让我们来看看</c>

00:17:41.328 --> 00:17:44.331 align:middle line:90%,end
<c.magenta>这次的例子不是内存崩溃</c>

00:17:44.498 --> 00:17:47.067 align:middle line:90%,end
<c.magenta>这是一个普通调试会话</c>

00:17:47.267 --> 00:17:49.403 align:middle line:90%,end
<c.magenta>我进入一个函数的代码行</c>

00:17:50.804 --> 00:17:53.941 align:middle line:10%
<c.magenta>我可以控制点击变量视图中的任何变量</c>

00:17:54.608 --> 00:17:58.912 align:middle line:10%
<c.magenta>如果变量是一个指针</c>
<c.magenta>可以选择“View Memory of…”</c>

00:18:01.114 --> 00:18:03.617 align:middle line:10%
<c.magenta>通常这会提供一个视图</c>

00:18:03.717 --> 00:18:05.786 align:middle line:10%
<c.magenta>显示内存对象字节信息</c>

00:18:06.687 --> 00:18:08.889 align:middle line:90%,end
<c.magenta>但若启用Address Sanitizer</c>

00:18:09.056 --> 00:18:12.226 align:middle line:10%
<c.magenta>可以在导航器中查看内存项目</c>

00:18:12.693 --> 00:18:15.195 align:middle line:10%
<c.magenta>将会显示该内存的分配</c>

00:18:15.262 --> 00:18:16.129 align:middle line:10%
<c.magenta>和释放线程跟踪</c>

00:18:18.398 --> 00:18:21.168 align:middle line:10%
<c.magenta>在这个内在视图中 你还会注意到</c>

00:18:21.235 --> 00:18:23.504 align:middle line:90%,end
<c.magenta>一些字节显示为灰色</c>
<c.magenta>一些字节显示为黑色</c>

00:18:24.605 --> 00:18:27.407 align:middle line:90%,end
<c.magenta>灰色字节表示无效内存</c>

00:18:27.541 --> 00:18:29.776 align:middle line:90%,end
<c.magenta>是禁止访问的内存</c>

00:18:30.077 --> 00:18:33.013 align:middle line:90%,end
<c.magenta>意味着你的程序不能访问这些字节</c>

00:18:33.146 --> 00:18:34.781 align:middle line:90%,end
<c.magenta>如果访问 就会产生错误</c>

00:18:34.915 --> 00:18:37.017 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>将会发现并检测到这些错误</c>

00:18:39.186 --> 00:18:42.122 align:middle line:90%,end
<c.magenta>还可以在lldb文本控制台上</c>

00:18:42.189 --> 00:18:44.057 align:middle line:90%,end
<c.magenta>访问内存对象的分配</c>

00:18:44.258 --> 00:18:45.659 align:middle line:90%,end
<c.magenta>和释放信息</c>

00:18:45.926 --> 00:18:48.262 align:middle line:90%,end
<c.magenta>我们可以使用这个指令调用内存历史</c>

00:18:48.428 --> 00:18:51.365 align:middle line:90%,end
<c.magenta>将它作为表达式进行传递</c>
<c.magenta>表达式的求值结果是一个指针</c>

00:18:52.633 --> 00:18:55.636 align:middle line:90%,end
<c.magenta>在本例中 我们直接使用这个指针值</c>

00:18:55.836 --> 00:18:57.504 align:middle line:90%,end
<c.magenta>文本控制台将会在文本输出中</c>

00:18:57.938 --> 00:19:00.641 align:middle line:90%,end
<c.magenta>打印分配和释放线程跟踪信息</c>

00:18:57.938 --> 00:19:00.641 align:middle line:90%,end
<c.magenta>打印分配和释放线程跟踪信息</c>

00:19:04.044 --> 00:19:05.546 align:middle line:90%,end
<c.magenta>我希望你们知道</c>

00:19:05.679 --> 00:19:08.515 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>是一个非常有用的工具</c>

00:19:08.582 --> 00:19:10.851 align:middle line:90%,end
<c.magenta>适用于C语言和Swift</c>

00:19:11.318 --> 00:19:13.720 align:middle line:90%,end
<c.magenta>帮助处理内存损坏和崩溃问题</c>

00:19:14.254 --> 00:19:17.624 align:middle line:90%,end
<c.magenta>这是一个非常有用的工具</c>
<c.magenta>可用于常规调试</c>

00:19:18.625 --> 00:19:20.294 align:middle line:90%,end
<c.magenta>现在 让我们来看</c>

00:19:20.460 --> 00:19:24.665 align:middle line:90%,end
<c.magenta>另一种类型的崩溃和</c>
<c.magenta>疑难性内存错误</c>

00:19:24.731 --> 00:19:25.933 align:middle line:90%,end
<c.magenta>即多线程问题</c>

00:19:26.733 --> 00:19:29.770 align:middle line:90%,end
<c.magenta>Thread Sanitizer</c>
<c.magenta>能够发现这些问题</c>

00:19:32.439 --> 00:19:35.843 align:middle line:90%,end
<c.magenta>前面我说过Thread Sanitizer</c>
<c.magenta>能够发现多线程问题</c>

00:19:35.943 --> 00:19:37.477 align:middle line:90%,end
<c.magenta>例如数据争用</c>

00:19:38.612 --> 00:19:41.114 align:middle line:90%,end
<c.magenta>这些多线程问题</c>

00:19:41.548 --> 00:19:44.251 align:middle line:90%,end
<c.magenta>通常具有时间敏感性</c>

00:19:44.618 --> 00:19:47.821 align:middle line:90%,end
<c.magenta>这意味着</c>
<c.magenta>它们非常难以重现</c>

00:19:49.289 --> 00:19:52.059 align:middle line:90%,end
<c.magenta>Thread Sanitizer</c>
<c.magenta>不仅能够发现数据争用</c>

00:19:52.192 --> 00:19:54.328 align:middle line:90%,end
<c.magenta>即两个内存访问发生冲突</c>

00:19:54.461 --> 00:19:57.731 align:middle line:90%,end
<c.magenta>而且能够发现特定程序运行期间</c>

00:19:57.798 --> 00:19:59.666 align:middle line:90%,end
<c.magenta>并不明显的数据争用</c>

00:20:01.034 --> 00:20:05.038 align:middle line:90%,end
<c.magenta>即使竞争内存访问发生在不同的时间</c>

00:20:05.172 --> 00:20:07.174 align:middle line:90%,end
<c.magenta>但是它们之间不是同步的</c>

00:20:07.341 --> 00:20:08.408 align:middle line:90%,end
<c.magenta>仍然是竞争的</c>

00:20:08.575 --> 00:20:10.611 align:middle line:90%,end
<c.magenta>Thread Sanitizer能够发现这个问题</c>

00:20:11.512 --> 00:20:14.648 align:middle line:90%,end
<c.magenta>那是因为下次运行程序时</c>

00:20:15.349 --> 00:20:16.850 align:middle line:90%,end
<c.magenta>时间将会发生错位</c>

00:20:16.917 --> 00:20:19.720 align:middle line:90%,end
<c.magenta>可能会产生内存错误</c>

00:20:20.187 --> 00:20:23.357 align:middle line:90%,end
<c.magenta>Thread Sanitizer能够发现内存争用</c>
<c.magenta>即使此问题没有明确的表现</c>

00:20:25.592 --> 00:20:28.962 align:middle line:90%,end
<c.magenta>这个工具适用于64位macOS</c>
<c.magenta>和64位仿真器</c>

00:20:29.029 --> 00:20:31.698 align:middle line:90%,end
<c.magenta>如果想要更多了解底层技术</c>

00:20:31.765 --> 00:20:36.003 align:middle line:90%,end
<c.magenta>建议你们观看去年的WWDC演讲</c>

00:20:36.069 --> 00:20:38.172 align:middle line:90%,end
<c.magenta>名称为“Thread Sanitizer</c>
<c.magenta>与静态分析”</c>

00:20:41.108 --> 00:20:42.476 align:middle line:90%,end
<c.magenta>前面我说过“数据争用”</c>

00:20:42.910 --> 00:20:44.077 align:middle line:90%,end
<c.magenta>让我们来看它们是什么</c>

00:20:46.046 --> 00:20:47.414 align:middle line:90%,end
<c.magenta>任何共享数据</c>

00:20:47.781 --> 00:20:50.384 align:middle line:90%,end
<c.magenta>任何在多线程之间共享的可变数据</c>

00:20:50.651 --> 00:20:52.219 align:middle line:90%,end
<c.magenta>都需要同步访问</c>

00:20:52.853 --> 00:20:56.190 align:middle line:90%,end
<c.magenta>如果共享可变变量未能同步</c>

00:20:56.590 --> 00:20:57.858 align:middle line:90%,end
<c.magenta>就意味着发生数据争用</c>

00:20:57.991 --> 00:21:00.027 align:middle line:90%,end
<c.magenta>数据争用是未定义的行为</c>

00:20:57.991 --> 00:21:00.027 align:middle line:90%,end
<c.magenta>数据争用是未定义的行为</c>

00:21:01.328 --> 00:21:02.796 align:middle line:90%,end
<c.magenta>存在数据争用时</c>

00:21:02.863 --> 00:21:05.299 align:middle line:90%,end
<c.magenta>程序可能发生内存错误和崩溃</c>

00:21:05.566 --> 00:21:07.768 align:middle line:90%,end
<c.magenta>不仅C语言</c>

00:21:07.835 --> 00:21:09.503 align:middle line:90%,end
<c.magenta>且Swift代码也存在这些问题</c>

00:21:10.103 --> 00:21:11.839 align:middle line:90%,end
<c.magenta>让我们来看Swift中的例子</c>

00:21:14.074 --> 00:21:17.344 align:middle line:90%,end
<c.magenta>在本例中 有一个名称为EventLog的类</c>

00:21:17.711 --> 00:21:20.948 align:middle line:90%,end
<c.magenta>它有一个简单的函数</c>
<c.magenta>名称为log</c>

00:21:21.315 --> 00:21:23.717 align:middle line:90%,end
<c.magenta>打印一些文本信息到输出</c>

00:21:24.484 --> 00:21:25.719 align:middle line:90%,end
<c.magenta>此函数还跟踪</c>

00:21:26.119 --> 00:21:29.523 align:middle line:90%,end
<c.magenta>调用此log函数的lastEventSource</c>

00:21:30.023 --> 00:21:31.592 align:middle line:90%,end
<c.magenta>将这些信息</c>

00:21:31.692 --> 00:21:34.695 align:middle line:90%,end
<c.magenta>保存到一个共享属性</c>
<c.magenta>其名称为lastEventSource</c>

00:21:35.262 --> 00:21:38.899 align:middle line:90%,end
<c.magenta>这是一个可选属性</c>
<c.magenta>其初始值是nil</c>

00:21:38.966 --> 00:21:40.801 align:middle line:90%,end
<c.magenta>当用户调用log函数时</c>

00:21:41.101 --> 00:21:45.272 align:middle line:90%,end
<c.magenta>将会加入此特定的日志源</c>

00:21:46.006 --> 00:21:47.608 align:middle line:90%,end
<c.magenta>假设我们有两个线程</c>

00:21:47.908 --> 00:21:51.178 align:middle line:90%,end
<c.magenta>两个线程都同时调用log函数</c>

00:21:51.445 --> 00:21:54.214 align:middle line:90%,end
<c.magenta>假设线程一是网络子线程</c>

00:21:54.281 --> 00:21:56.183 align:middle line:90%,end
<c.magenta>它记录某些下载完成情况</c>

00:21:56.750 --> 00:21:57.851 align:middle line:90%,end
<c.magenta>第二个线程</c>

00:21:58.118 --> 00:22:00.020 align:middle line:10%
<c.magenta>代表我们的数据子系统</c>

00:21:58.118 --> 00:22:00.020 align:middle line:10%
<c.magenta>代表我们的数据子系统</c>

00:22:00.087 --> 00:22:02.022 align:middle line:10%
<c.magenta>记录查询完成情况</c>

00:22:03.290 --> 00:22:04.458 align:middle line:90%,end
<c.magenta>这就是数据争用</c>

00:22:05.359 --> 00:22:08.795 align:middle line:90%,end
<c.magenta>因为两个线程同时访问同一内存位置</c>

00:22:09.963 --> 00:22:11.832 align:middle line:90%,end
<c.magenta>Thread Sanitizer对此发出警告</c>

00:22:13.534 --> 00:22:14.501 align:middle line:90%,end
<c.magenta>为了修复这个问题</c>

00:22:15.903 --> 00:22:17.371 align:middle line:90%,end
<c.magenta>我们需要引入同步机制</c>

00:22:17.504 --> 00:22:21.141 align:middle line:90%,end
<c.magenta>最简单的方法</c>
<c.magenta>是使用DispatchQueue</c>

00:22:21.808 --> 00:22:23.844 align:middle line:90%,end
<c.magenta>因此队列是串行的</c>

00:22:24.144 --> 00:22:27.014 align:middle line:90%,end
<c.magenta>一次仅执行一个工作项目</c>

00:22:28.315 --> 00:22:29.249 align:middle line:90%,end
<c.magenta>如果我们将log函数主体</c>

00:22:30.384 --> 00:22:33.387 align:middle line:90%,end
<c.magenta>封装到queue.async之中</c>

00:22:34.288 --> 00:22:36.056 align:middle line:90%,end
<c.magenta>这将提供正确的同步</c>

00:22:36.423 --> 00:22:38.425 align:middle line:90%,end
<c.magenta>你们会发现 这里我使用async</c>

00:22:38.492 --> 00:22:40.093 align:middle line:90%,end
<c.magenta>因为我们并不需要等待</c>

00:22:40.160 --> 00:22:42.129 align:middle line:90%,end
<c.magenta>此函数完成</c>

00:22:42.196 --> 00:22:44.831 align:middle line:90%,end
<c.magenta>因为此函数并不提供任何结果</c>

00:22:44.898 --> 00:22:46.366 align:middle line:90%,end
<c.magenta>因此并不需要等待</c>

00:22:46.767 --> 00:22:50.037 align:middle line:90%,end
<c.magenta>这不仅会修复争用问题</c>
<c.magenta>而且提升性能</c>

00:22:50.871 --> 00:22:53.073 align:middle line:90%,end
<c.magenta>因为现在无论任何人调用log函数</c>

00:22:53.340 --> 00:22:55.742 align:middle line:90%,end
<c.magenta>将不需要等待打印函数结束</c>

00:22:58.378 --> 00:23:01.281 align:middle line:90%,end
<c.magenta>这样确保整个类的线程安全</c>

00:22:58.378 --> 00:23:01.281 align:middle line:90%,end
<c.magenta>这样确保整个类的线程安全</c>

00:23:01.381 --> 00:23:03.116 align:middle line:90%,end
<c.magenta>我们可以从多线程调用log函数</c>

00:23:05.285 --> 00:23:08.789 align:middle line:10%
<c.magenta>Grand Central Dispatch</c>
<c.magenta>（简称GCD）提供的</c>

00:23:08.856 --> 00:23:10.190 align:middle line:10%
<c.magenta>分派队列</c>

00:23:10.657 --> 00:23:11.925 align:middle line:10%
<c.magenta>可以在Swift中使用</c>

00:23:11.992 --> 00:23:14.328 align:middle line:10%
<c.magenta>应该成为首选的同步方法</c>

00:23:14.828 --> 00:23:18.532 align:middle line:10%
<c.magenta>即使有其它同步机制</c>

00:23:18.699 --> 00:23:21.902 align:middle line:10%
<c.magenta>GCD是轻量级的</c>
<c.magenta>很容易在Swift中使用</c>

00:23:22.769 --> 00:23:26.740 align:middle line:10%
<c.magenta>一个良好的做法是将数据</c>
<c.magenta>与串行分派队列相关联</c>

00:23:26.974 --> 00:23:29.076 align:middle line:10%
<c.magenta>仅从这些队列访问数据</c>

00:23:29.776 --> 00:23:32.646 align:middle line:90%,end
<c.magenta>这将保证仅以同步方法</c>

00:23:32.713 --> 00:23:33.947 align:middle line:90%,end
<c.magenta>使用你的数据</c>

00:23:34.681 --> 00:23:38.452 align:middle line:90%,end
<c.magenta>如果你想了解</c>
<c.magenta>如何使用GCD进行并发处理</c>

00:23:38.585 --> 00:23:41.955 align:middle line:90%,end
<c.magenta>我建议你们</c>
<c.magenta>观看去年的WWDC演讲</c>

00:23:42.022 --> 00:23:44.658 align:middle line:90%,end
<c.magenta>名称为“GCD和Swift 3并发程序设计”</c>

00:23:47.094 --> 00:23:48.695 align:middle line:90%,end
<c.magenta>让我们来看</c>

00:23:48.762 --> 00:23:51.598 align:middle line:90%,end
<c.magenta>Xcode 9中增加的</c>
<c.magenta>Thread Sanitizer新功能</c>

00:23:52.132 --> 00:23:54.568 align:middle line:90%,end
<c.magenta>此工具能够检测集合争用</c>

00:23:54.935 --> 00:23:57.938 align:middle line:90%,end
<c.magenta>和Swift代码特有的</c>

00:23:58.005 --> 00:24:00.140 align:middle line:90%,end
<c.magenta>新漏洞类</c>

00:23:58.005 --> 00:24:00.140 align:middle line:90%,end
<c.magenta>新漏洞类</c>

00:24:02.409 --> 00:24:06.013 align:middle line:90%,end
<c.magenta>在以前Thread Sanitizer</c>
<c.magenta>仅能发现</c>

00:24:06.213 --> 00:24:07.648 align:middle line:90%,end
<c.magenta>原始内存访问争用</c>

00:24:07.814 --> 00:24:09.316 align:middle line:90%,end
<c.magenta>类似于前面的例子</c>

00:24:09.383 --> 00:24:12.286 align:middle line:90%,end
<c.magenta>在上例中 我们直接访问某些存储属性</c>

00:24:13.420 --> 00:24:16.390 align:middle line:90%,end
<c.magenta>但是 对于大型数据结构</c>
<c.magenta>通常需要同步处理</c>

00:24:16.456 --> 00:24:17.658 align:middle line:90%,end
<c.magenta>例如集合数据</c>

00:24:18.225 --> 00:24:20.127 align:middle line:90%,end
<c.magenta>请考虑这个示例代码</c>

00:24:20.661 --> 00:24:24.498 align:middle line:90%,end
<c.magenta>在Objective-C中我们使用</c>
<c.magenta>一个NSMutableDictionary实例</c>

00:24:25.065 --> 00:24:27.167 align:middle line:90%,end
<c.magenta>这两个线程使用相同的实例</c>

00:24:27.234 --> 00:24:30.437 align:middle line:90%,end
<c.magenta>假设线程一查找词典中的值</c>

00:24:30.604 --> 00:24:32.940 align:middle line:90%,end
<c.magenta>第二个线程尝试写入词典</c>

00:24:33.707 --> 00:24:36.109 align:middle line:90%,end
<c.magenta>现在Xcode 9中的新功能</c>

00:24:36.176 --> 00:24:38.212 align:middle line:90%,end
<c.magenta>能够检测此争用问题</c>

00:24:41.548 --> 00:24:43.917 align:middle line:90%,end
<c.magenta>集合争用是一个常见的错误</c>

00:24:44.985 --> 00:24:48.989 align:middle line:90%,end
<c.magenta>在Xcode 9中我们能够检测</c>
<c.magenta>Objective-C 和Swift中的</c>

00:24:49.056 --> 00:24:49.890 align:middle line:90%,end
<c.magenta>这些问题</c>

00:24:50.290 --> 00:24:51.425 align:middle line:90%,end
<c.magenta>请注意 这要求</c>

00:24:51.491 --> 00:24:54.294 align:middle line:90%,end
<c.magenta>你们使用macOS、</c>
<c.magenta>High Sierra和iOS 11</c>

00:24:54.461 --> 00:24:56.997 align:middle line:90%,end
<c.magenta>我们能够检测</c>
<c.magenta>NSMutableArray</c>

00:24:57.064 --> 00:25:00.767 align:middle line:90%,end
<c.magenta>和NSMutableDictionary以及</c>
<c.magenta>Swift数组和Swift词典争用</c>

00:24:57.064 --> 00:25:00.767 align:middle line:90%,end
<c.magenta>和NSMutableDictionary以及</c>
<c.magenta>Swift数组和Swift词典争用</c>

00:25:01.668 --> 00:25:04.505 align:middle line:90%,end
<c.magenta>在这方面 我想要展示实际运行原理</c>

00:25:20.521 --> 00:25:22.789 align:middle line:90%,end
<c.magenta>我获得采用Swift代码之前的</c>

00:25:23.123 --> 00:25:26.326 align:middle line:90%,end
<c.magenta>旧版本WWDC应用</c>

00:25:26.393 --> 00:25:28.362 align:middle line:90%,end
<c.magenta>的源代码</c>

00:25:28.462 --> 00:25:30.130 align:middle line:90%,end
<c.magenta>这个版本是</c>

00:25:30.197 --> 00:25:32.199 align:middle line:90%,end
<c.magenta>完全用Objective-C编写的</c>

00:25:32.399 --> 00:25:34.701 align:middle line:90%,end
<c.magenta>你可以看到</c>
<c.magenta>从这个版权标题中看到这一点</c>

00:25:34.768 --> 00:25:37.004 align:middle line:90%,end
<c.magenta>此程序是在2011年编写的</c>

00:25:38.405 --> 00:25:41.108 align:middle line:90%,end
<c.magenta>是几年前编写的</c>

00:25:41.175 --> 00:25:43.043 align:middle line:90%,end
<c.magenta>使用一些过时的概念</c>

00:25:43.110 --> 00:25:46.246 align:middle line:90%,end
<c.magenta>比如显式线程同步 而不是使用GCD</c>

00:25:46.446 --> 00:25:49.183 align:middle line:90%,end
<c.magenta>但是我想展示给你们看</c>
<c.magenta>Thread Sanitizer工作良好</c>

00:25:49.249 --> 00:25:51.518 align:middle line:90%,end
<c.magenta>即使配合其它同步机制</c>

00:25:53.787 --> 00:25:55.556 align:middle line:90%,end
<c.magenta>我展示给你们看的文件</c>

00:25:55.956 --> 00:25:58.959 align:middle line:90%,end
<c.magenta>实现一个类 名称为</c>
<c.magenta>WWDCURLConnection</c>

00:25:59.026 --> 00:26:00.627 align:middle line:90%,end
<c.magenta>它用作基类</c>

00:25:59.026 --> 00:26:00.627 align:middle line:90%,end
<c.magenta>它用作基类</c>

00:26:00.694 --> 00:26:03.230 align:middle line:90%,end
<c.magenta>以便在此应用中完成所有网络处理</c>

00:26:03.897 --> 00:26:07.901 align:middle line:90%,end
<c.magenta>我所做的是</c>
<c.magenta>在这个代码中植入一个多线程漏洞</c>

00:26:08.368 --> 00:26:10.938 align:middle line:90%,end
<c.magenta>让我们来看</c>
<c.magenta>Thread Sanitizer是否能发现此漏洞</c>

00:26:12.005 --> 00:26:14.541 align:middle line:90%,end
<c.magenta>首先 转到“产品”方案</c>
<c.magenta>编辑方案</c>

00:26:14.608 --> 00:26:17.778 align:middle line:90%,end
<c.magenta>确保启用</c>
<c.magenta>Thread Sanitizer</c>

00:26:18.345 --> 00:26:21.381 align:middle line:90%,end
<c.magenta>调出方案编辑</c>

00:26:21.448 --> 00:26:24.318 align:middle line:90%,end
<c.magenta>你们可以看到</c>
<c.magenta>我启用Thread Sanitizer</c>

00:26:24.918 --> 00:26:27.487 align:middle line:90%,end
<c.magenta>现在我在这个模拟器中运行这个应用</c>

00:26:29.990 --> 00:26:32.626 align:middle line:90%,end
<c.magenta>应用在模拟器中启动时</c>

00:26:32.693 --> 00:26:35.729 align:middle line:90%,end
<c.magenta>将会启动多个网络连接</c>

00:26:36.997 --> 00:26:40.367 align:middle line:90%,end
<c.magenta>因此 它将会使用这个文件</c>

00:26:41.101 --> 00:26:42.636 align:middle line:90%,end
<c.magenta>你们注意到</c>

00:26:42.703 --> 00:26:46.540 align:middle line:90%,end
<c.magenta>Xcode在问题导航器中报告争用情况</c>

00:26:47.908 --> 00:26:49.977 align:middle line:90%,end
<c.magenta>这个问题报告一个争用问题</c>

00:26:50.043 --> 00:26:52.613 align:middle line:90%,end
<c.magenta>让我们点击这个问题</c>

00:26:52.679 --> 00:26:54.314 align:middle line:90%,end
<c.magenta>进入含有这个争用问题的代码行</c>

00:26:54.481 --> 00:26:58.919 align:middle line:90%,end
<c.magenta>在这个例子中 可以看到</c>
<c.magenta>我们添加一些对象到可变数据组中</c>

00:27:00.287 --> 00:27:03.390 align:middle line:90%,end
<c.magenta>此代码的目标是</c>

00:27:03.457 --> 00:27:04.658 align:middle line:90%,end
<c.magenta>维护一个活跃连接列表</c>

00:27:04.725 --> 00:27:07.327 align:middle line:90%,end
<c.magenta>我们跟踪监测这个列表</c>
<c.magenta>是为了用于调试目的</c>

00:27:08.629 --> 00:27:11.532 align:middle line:90%,end
<c.magenta>在创建一些新URL连接之后</c>

00:27:11.598 --> 00:27:13.000 align:middle line:90%,end
<c.magenta>我们将它添加到列表</c>

00:27:14.067 --> 00:27:15.536 align:middle line:90%,end
<c.magenta>可以在任何线程中完成这些工作</c>

00:27:15.702 --> 00:27:18.238 align:middle line:90%,end
<c.magenta>任何线程可以创建新URL连接</c>

00:27:18.839 --> 00:27:20.641 align:middle line:90%,end
<c.magenta>如果我们在导航器中</c>

00:27:20.707 --> 00:27:22.242 align:middle line:90%,end
<c.magenta>再次查看问题详情</c>

00:27:22.376 --> 00:27:23.610 align:middle line:90%,end
<c.magenta>我们可以看到</c>

00:27:23.677 --> 00:27:27.047 align:middle line:90%,end
<c.magenta>有个线程三调用addObject</c>

00:27:27.481 --> 00:27:30.250 align:middle line:90%,end
<c.magenta>另外线程五</c>
<c.magenta>也尝试对相同的可变数据</c>

00:27:30.484 --> 00:27:32.452 align:middle line:90%,end
<c.magenta>调用addObject</c>

00:27:33.253 --> 00:27:36.223 align:middle line:90%,end
<c.magenta>如果查看API调用函数</c>

00:27:36.290 --> 00:27:40.227 align:middle line:90%,end
<c.magenta>我们将会看到</c>
<c.magenta>它们指向相同的代码行</c>

00:27:41.061 --> 00:27:44.531 align:middle line:90%,end
<c.magenta>因此这是一个问题</c>
<c.magenta>我们在多线程中</c>

00:27:44.765 --> 00:27:46.800 align:middle line:90%,end
<c.magenta>访问这个可变数组</c>
<c.magenta>而不存在任何异步</c>

00:27:47.868 --> 00:27:50.604 align:middle line:90%,end
<c.magenta>我可以轻松地解决这个问题</c>

00:27:50.671 --> 00:27:54.208 align:middle line:90%,end
<c.magenta>因为我注意到</c>
<c.magenta>这行后面的代码</c>

00:27:54.274 --> 00:27:56.009 align:middle line:90%,end
<c.magenta>在进行某种同步处理</c>

00:27:56.076 --> 00:27:58.545 align:middle line:90%,end
<c.magenta>它使用这个名称为</c>
<c.magenta>performBlock的API</c>

00:27:59.012 --> 00:28:01.715 align:middle line:90%,end
<c.magenta>分派相同的工作到特定线程</c>

00:27:59.012 --> 00:28:01.715 align:middle line:90%,end
<c.magenta>分派相同的工作到特定线程</c>

00:28:01.849 --> 00:28:03.851 align:middle line:90%,end
<c.magenta>在本例中</c>
<c.magenta>此线程名为connectionThread</c>

00:28:04.351 --> 00:28:07.421 align:middle line:90%,end
<c.magenta>这个显式线程</c>
<c.magenta>用于同步处理</c>

00:28:07.855 --> 00:28:09.489 align:middle line:90%,end
<c.magenta>这是一个单线程</c>

00:28:09.556 --> 00:28:13.560 align:middle line:90%,end
<c.magenta>进行串行工作的同步处理</c>

00:28:13.861 --> 00:28:16.730 align:middle line:90%,end
<c.magenta>因为这是一个单线程</c>
<c.magenta>并没有多线程处理</c>

00:28:17.331 --> 00:28:21.735 align:middle line:90%,end
<c.magenta>为了解决这个问题</c>
<c.magenta>我可以将这个addObject调用</c>

00:28:22.035 --> 00:28:24.371 align:middle line:90%,end
<c.magenta>转移到同步处理代码块 比如这个</c>

00:28:25.005 --> 00:28:26.206 align:middle line:90%,end
<c.magenta>这应该能够解决这个争用问题</c>

00:28:26.273 --> 00:28:30.811 align:middle line:90%,end
<c.magenta>因为现在我们只能够</c>
<c.magenta>在串行执行的同步代码块内</c>

00:28:31.044 --> 00:28:34.081 align:middle line:90%,end
<c.magenta>访问活跃连接数组</c>

00:28:34.314 --> 00:28:37.251 align:middle line:90%,end
<c.magenta>现在 我们再次在模拟器中运行应用</c>

00:28:37.417 --> 00:28:39.419 align:middle line:90%,end
<c.magenta>让我们查看这是否会修复争用问题</c>

00:28:40.888 --> 00:28:42.489 align:middle line:90%,end
<c.magenta>应用再次启用时</c>

00:28:42.589 --> 00:28:45.325 align:middle line:90%,end
<c.magenta>将会触发多个网络连接</c>

00:28:45.626 --> 00:28:48.929 align:middle line:90%,end
<c.magenta>现在程序运行时</c>
<c.magenta>我们看到Xcode</c>

00:28:48.996 --> 00:28:51.565 align:middle line:90%,end
<c.magenta>不再报告任何运行时问题</c>

00:28:55.102 --> 00:28:58.405 align:middle line:90%,end
<c.magenta>（演示 - THREAD SANITIZER</c>
<c.magenta>和NSMutableArray争用）</c>

00:29:01.508 --> 00:29:03.877 align:middle line:90%,end
<c.magenta>你已经看到</c>
<c.magenta>Thread Sanitizer能够看到</c>

00:29:03.944 --> 00:29:05.779 align:middle line:90%,end
<c.magenta>Objective-C代码中的争用问题</c>

00:29:06.446 --> 00:29:07.281 align:middle line:90%,end
<c.magenta>那么Swift又如何呢？</c>

00:29:08.482 --> 00:29:10.817 align:middle line:90%,end
<c.magenta>同样的检测功能也适用于Swift代码</c>

00:29:11.018 --> 00:29:13.320 align:middle line:90%,end
<c.magenta>在本例中 如果我们有一个字符串数组</c>

00:29:13.987 --> 00:29:15.455 align:middle line:90%,end
<c.magenta>而且有两个线程</c>

00:29:15.522 --> 00:29:17.958 align:middle line:90%,end
<c.magenta>一个线程查找数组中的值</c>

00:29:18.058 --> 00:29:20.227 align:middle line:90%,end
<c.magenta>另一个线程写入数组</c>

00:29:20.961 --> 00:29:23.897 align:middle line:90%,end
<c.magenta>Thread Sanitizer会发现争用问题</c>

00:29:25.265 --> 00:29:28.836 align:middle line:90%,end
<c.magenta>解决这个问题需要</c>
<c.magenta>使用一个串行DispatchQueue</c>

00:29:29.236 --> 00:29:33.006 align:middle line:90%,end
<c.magenta>确保仅在相同的同步代码块内</c>

00:29:33.340 --> 00:29:34.875 align:middle line:90%,end
<c.magenta>访问数组</c>

00:29:34.942 --> 00:29:38.712 align:middle line:90%,end
<c.magenta>在本例中 线程一</c>
<c.magenta>将使用queue.sync</c>

00:29:40.681 --> 00:29:41.782 align:middle line:90%,end
<c.magenta>在本例中必须使用此队列</c>

00:29:41.849 --> 00:29:45.953 align:middle line:90%,end
<c.magenta>因为我们需要从计算处理中输出值</c>
<c.magenta>以继续执行程序</c>

00:29:46.019 --> 00:29:49.056 align:middle line:90%,end
<c.magenta>需要在字典中查找值</c>

00:29:49.122 --> 00:29:50.724 align:middle line:90%,end
<c.magenta>因此我们需要等待结果</c>

00:29:50.791 --> 00:29:52.392 align:middle line:90%,end
<c.magenta>这里我使用queue.sync</c>

00:29:52.659 --> 00:29:55.195 align:middle line:90%,end
<c.magenta>但是对于第二线程</c>
<c.magenta>可以使用queue.async</c>

00:29:55.262 --> 00:29:58.398 align:middle line:90%,end
<c.magenta>因为代码块不提供任何输出</c>

00:29:58.465 --> 00:30:00.033 align:middle line:90%,end
<c.magenta>因此不需要等待代码完成</c>

00:29:58.465 --> 00:30:00.033 align:middle line:90%,end
<c.magenta>因此不需要等待代码完成</c>

00:30:03.303 --> 00:30:05.672 align:middle line:90%,end
<c.magenta>因此 你可能注意到</c>
<c.magenta>在前面的例子中</c>

00:30:05.739 --> 00:30:08.008 align:middle line:90%,end
<c.magenta>我没有将这个问题称为数据争用</c>

00:30:08.509 --> 00:30:11.578 align:middle line:90%,end
<c.magenta>相反 警告信息说</c>
<c.magenta>这是Swift访问竞争</c>

00:30:13.013 --> 00:30:16.884 align:middle line:90%,end
<c.magenta>Swift访问竞争</c>
<c.magenta>是违反通用规则的行为</c>

00:30:17.284 --> 00:30:18.952 align:middle line:90%,end
<c.magenta>这些规则适用于所有数据结构</c>

00:30:19.086 --> 00:30:21.588 align:middle line:90%,end
<c.magenta>不仅适用于数组和词典</c>
<c.magenta>而且适用于所有数据结构</c>

00:30:21.655 --> 00:30:22.956 align:middle line:90%,end
<c.magenta>甚至自定义的数据类型</c>

00:30:23.624 --> 00:30:26.527 align:middle line:90%,end
<c.magenta>因此 这是Swift 4中的新规则</c>

00:30:27.261 --> 00:30:31.164 align:middle line:90%,end
<c.magenta>此规则要求</c>
<c.magenta>数据结构变更方法</c>

00:30:31.632 --> 00:30:34.401 align:middle line:90%,end
<c.magenta>独占性地访问整个结构</c>

00:30:35.769 --> 00:30:37.004 align:middle line:90%,end
<c.magenta>这并不适用于类</c>

00:30:37.070 --> 00:30:39.173 align:middle line:90%,end
<c.magenta>因为类并没有变更方法</c>

00:30:39.406 --> 00:30:42.543 align:middle line:90%,end
<c.magenta>任何类方法都可以更改属性</c>

00:30:42.609 --> 00:30:45.512 align:middle line:90%,end
<c.magenta>仅需要排它性访问</c>

00:30:45.579 --> 00:30:47.981 align:middle line:90%,end
<c.magenta>此方法所更改的属性</c>

00:30:49.683 --> 00:30:52.719 align:middle line:90%,end
<c.magenta>因此 编译器强制要求</c>

00:30:53.187 --> 00:30:55.289 align:middle line:90%,end
<c.magenta>将新规则应用于数据结构</c>

00:30:55.355 --> 00:30:58.659 align:middle line:90%,end
<c.magenta>要求在编译器时间</c>
<c.magenta>和运行时动态地执行规则</c>

00:30:59.660 --> 00:31:02.663 align:middle line:90%,end
<c.magenta>但是这种强制要求仅适用于单线程违规</c>

00:30:59.660 --> 00:31:02.663 align:middle line:90%,end
<c.magenta>但是这种强制要求仅适用于单线程违规</c>

00:31:02.996 --> 00:31:06.066 align:middle line:90%,end
<c.magenta>Thread Sanitizer</c>
<c.magenta>帮助你处理多线程问题</c>

00:31:06.633 --> 00:31:09.269 align:middle line:90%,end
<c.magenta>如果想要详细了解Swift 4中的</c>
<c.magenta>这些新规则</c>

00:31:09.336 --> 00:31:12.406 align:middle line:90%,end
<c.magenta>我建议你们观看</c>
<c.magenta>“Swift新特性”演讲</c>

00:31:13.307 --> 00:31:17.211 align:middle line:90%,end
<c.magenta>有一个部分名为“独占性内存访问”</c>

00:31:17.277 --> 00:31:19.046 align:middle line:90%,end
<c.magenta>讲述这些新规则</c>

00:31:19.246 --> 00:31:21.748 align:middle line:90%,end
<c.magenta>并讨论所需要执行的要求</c>

00:31:22.716 --> 00:31:24.518 align:middle line:90%,end
<c.magenta>让我们来看另外一个例子</c>

00:31:25.619 --> 00:31:29.756 align:middle line:90%,end
<c.magenta>假设有个朋友要求我</c>
<c.magenta>为他的太空飞船编写软件</c>

00:31:30.624 --> 00:31:31.792 align:middle line:90%,end
<c.magenta>我们设计这个数据结构</c>

00:31:31.859 --> 00:31:34.027 align:middle line:90%,end
<c.magenta>它描述这个太空飞船的位置</c>

00:31:34.394 --> 00:31:36.063 align:middle line:90%,end
<c.magenta>另外有一些存储属性</c>

00:31:36.363 --> 00:31:40.067 align:middle line:90%,end
<c.magenta>描述空间和时间坐标</c>

00:31:40.734 --> 00:31:43.537 align:middle line:90%,end
<c.magenta>有一些方法调用此结构</c>

00:31:43.871 --> 00:31:46.507 align:middle line:90%,end
<c.magenta>因为太空飞船</c>
<c.magenta>可以飞行到不同的星球</c>

00:31:46.740 --> 00:31:49.109 align:middle line:90%,end
<c.magenta>还可以飞行到相同星球的不同城市</c>

00:31:49.710 --> 00:31:51.278 align:middle line:90%,end
<c.magenta>当然 也可以进行时空旅行</c>

00:31:53.113 --> 00:31:55.682 align:middle line:90%,end
<c.magenta>因此这些方法更改坐标</c>

00:31:55.849 --> 00:31:57.417 align:middle line:90%,end
<c.magenta>它们应该是变更方法</c>

00:31:57.751 --> 00:31:58.952 align:middle line:90%,end
<c.magenta>这意味着我刚才讲到的规则</c>

00:31:59.019 --> 00:32:00.988 align:middle line:90%,end
<c.magenta>适用于所有这些方法</c>

00:31:59.019 --> 00:32:00.988 align:middle line:90%,end
<c.magenta>适用于所有这些方法</c>

00:32:01.488 --> 00:32:02.489 align:middle line:90%,end
<c.magenta>如果有两个线程</c>

00:32:02.556 --> 00:32:06.226 align:middle line:90%,end
<c.magenta>尝试更改太空飞船的位置</c>

00:32:06.293 --> 00:32:08.529 align:middle line:90%,end
<c.magenta>假设线程一</c>
<c.magenta>尝试将太空飞船</c>

00:32:08.595 --> 00:32:09.730 align:middle line:90%,end
<c.magenta>运送到不同的星球</c>

00:32:10.330 --> 00:32:12.666 align:middle line:90%,end
<c.magenta>第二个线程进行太空飞船的时间旅行</c>

00:32:13.233 --> 00:32:15.135 align:middle line:90%,end
<c.magenta>这是Swift访问竞争问题</c>

00:32:16.637 --> 00:32:19.072 align:middle line:90%,end
<c.magenta>请注意</c>

00:32:19.273 --> 00:32:22.209 align:middle line:90%,end
<c.magenta>哪些函数和方法</c>
<c.magenta>访问或更改存储的属性</c>

00:32:22.342 --> 00:32:24.745 align:middle line:90%,end
<c.magenta>并不重要</c>

00:32:25.245 --> 00:32:28.015 align:middle line:10%
<c.magenta>即使时空旅行更改X、Y和Z</c>

00:32:28.215 --> 00:32:30.584 align:middle line:10%
<c.magenta>其它方法仅更改时间</c>

00:32:31.118 --> 00:32:32.686 align:middle line:10%
<c.magenta>这仍然是Swift访问竞争</c>

00:32:33.220 --> 00:32:36.590 align:middle line:10%
<c.magenta>这些规则仅要求</c>
<c.magenta>当调用变更函数时</c>

00:32:36.757 --> 00:32:39.426 align:middle line:90%,end
<c.magenta>必须独占性地</c>

00:32:39.493 --> 00:32:40.627 align:middle line:90%,end
<c.magenta>访问整个数据结构</c>

00:32:43.263 --> 00:32:46.767 align:middle line:90%,end
<c.magenta>很重要的一点是</c>
<c.magenta>通过对数据结构进行同步处理</c>

00:32:47.067 --> 00:32:50.470 align:middle line:90%,end
<c.magenta>如果我们尝试修复这个问题</c>

00:32:50.737 --> 00:32:53.073 align:middle line:90%,end
<c.magenta>我们尝试</c>
<c.magenta>在这个数据结构中</c>

00:32:53.140 --> 00:32:55.142 align:middle line:90%,end
<c.magenta>使用DispatchQueue</c>

00:32:55.209 --> 00:32:59.546 align:middle line:90%,end
<c.magenta>保护变更函数的主体</c>

00:32:59.713 --> 00:33:01.915 align:middle line:90%,end
<c.magenta>这并不是正确的修复方法</c>

00:32:59.713 --> 00:33:01.915 align:middle line:90%,end
<c.magenta>这并不是正确的修复方法</c>

00:33:01.982 --> 00:33:04.852 align:middle line:90%,end
<c.magenta>仍然是一个违规</c>
<c.magenta>和Swift访问竞争问题</c>

00:33:05.252 --> 00:33:07.988 align:middle line:90%,end
<c.magenta>因为我们必须独占性访问数据结构</c>

00:33:08.522 --> 00:33:10.524 align:middle line:90%,end
<c.magenta>以调用变更函数</c>

00:33:10.657 --> 00:33:14.428 align:middle line:90%,end
<c.magenta>在函数内引入同步机制并不足够</c>

00:33:17.030 --> 00:33:19.700 align:middle line:90%,end
<c.magenta>正确的修复方法是</c>
<c.magenta>将同步机制应用于</c>

00:33:19.766 --> 00:33:22.302 align:middle line:90%,end
<c.magenta>这些变更方法的调用函数</c>

00:33:23.036 --> 00:33:26.607 align:middle line:90%,end
<c.magenta>假设有一个类描述整个太空飞船</c>

00:33:27.774 --> 00:33:29.409 align:middle line:90%,end
<c.magenta>正确的方法是在这里使用一个类</c>

00:33:29.476 --> 00:33:32.546 align:middle line:90%,end
<c.magenta>因为这个太空飞船有一个身份</c>

00:33:32.613 --> 00:33:34.248 align:middle line:90%,end
<c.magenta>复制这个身份并不合适</c>

00:33:34.815 --> 00:33:36.416 align:middle line:90%,end
<c.magenta>因此在本例中 太空飞船</c>

00:33:36.483 --> 00:33:40.387 align:middle line:90%,end
<c.magenta>可以使用队列保护位置存储属性</c>

00:33:40.687 --> 00:33:44.825 align:middle line:90%,end
<c.magenta>如果我们确保这些方法</c>

00:33:45.259 --> 00:33:48.161 align:middle line:90%,end
<c.magenta>仅在同步代码块内访问数据结构</c>
<c.magenta>例如这里的queue.sync</c>

00:33:48.428 --> 00:33:50.330 align:middle line:90%,end
<c.magenta>这让整个类线程变得安全</c>

00:33:53.467 --> 00:33:56.336 align:middle line:90%,end
<c.magenta>我们已经知道</c>

00:33:56.670 --> 00:33:58.338 align:middle line:90%,end
<c.magenta>你需要同步对共享可变更变量的访问</c>

00:33:58.672 --> 00:34:00.374 align:middle line:90%,end
<c.magenta>可以使用GCD来完成此任务</c>

00:33:58.672 --> 00:34:00.374 align:middle line:90%,end
<c.magenta>可以使用GCD来完成此任务</c>

00:34:00.774 --> 00:34:01.708 align:middle line:90%,end
<c.magenta>这通常比较简单</c>

00:34:01.775 --> 00:34:04.511 align:middle line:90%,end
<c.magenta>类似于将数据与某些串行队列进行关联</c>

00:34:04.578 --> 00:34:07.381 align:middle line:90%,end
<c.magenta>然后仅在队列中访问数据</c>

00:34:08.514 --> 00:34:11.752 align:middle line:90%,end
<c.magenta>Thread Sanitizer是一个很有用的工具</c>
<c.magenta>帮助你发现</c>

00:34:11.818 --> 00:34:13.687 align:middle line:90%,end
<c.magenta>未进行同步的代码块</c>

00:34:14.054 --> 00:34:16.857 align:middle line:90%,end
<c.magenta>这个问题比较容易解决</c>

00:34:18.625 --> 00:34:21.962 align:middle line:90%,end
<c.magenta>我很高兴告诉你们</c>

00:34:22.029 --> 00:34:25.632 align:middle line:90%,end
<c.magenta>今年我们引入另外一个Sanitizer</c>
<c.magenta>帮助你们发现更多类型的漏洞</c>

00:34:25.732 --> 00:34:27.701 align:middle line:90%,end
<c.magenta>接下来沃顿将会为大家进行介绍</c>

00:34:33.473 --> 00:34:34.308 align:middle line:90%,end
<c.magenta>请沃顿上台</c>

00:34:37.744 --> 00:34:42.014 align:middle line:90%,end
<c.magenta>我是沃顿</c>
<c.magenta>负责编译器开发</c>

00:34:42.081 --> 00:34:45.918 align:middle line:90%,end
<c.magenta>我很高兴告诉你们</c>
<c.magenta>今年在Xcode 9中</c>

00:34:45.985 --> 00:34:49.289 align:middle line:90%,end
<c.magenta>我们发布了一个新工具</c>
<c.magenta>名为Undefined Behavior Sanitizer</c>

00:34:49.389 --> 00:34:52.726 align:middle line:90%,end
<c.magenta>我们帮助你发现更多漏洞</c>

00:34:54.094 --> 00:34:57.831 align:middle line:90%,end
<c.magenta>什么是</c>
<c.magenta>Undefined Behavior Sanitizer？</c>

00:34:58.632 --> 00:35:01.869 align:middle line:90%,end
<c.magenta>与其它运行时工具一样</c>

00:34:58.632 --> 00:35:01.869 align:middle line:90%,end
<c.magenta>与其它运行时工具一样</c>

00:35:01.935 --> 00:35:03.904 align:middle line:10%
<c.magenta>它是一个运行时漏洞排查器</c>

00:35:04.404 --> 00:35:06.607 align:middle line:10%
<c.magenta>如其名称所示</c>

00:35:06.673 --> 00:35:10.744 align:middle line:10%
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>检查未定义的行为</c>

00:35:11.378 --> 00:35:15.883 align:middle line:10%
<c.magenta>与Address Sanitizer和</c>
<c.magenta>Thread Sanitizer一样</c>

00:35:17.150 --> 00:35:20.053 align:middle line:10%
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>的独特之处在于</c>

00:35:20.153 --> 00:35:23.056 align:middle line:10%
<c.magenta>它专注于检查</c>

00:35:23.123 --> 00:35:24.658 align:middle line:10%
<c.magenta>C语言中的不安全构造</c>

00:35:26.059 --> 00:35:28.529 align:middle line:90%,end
<c.magenta>它兼容其它运行时工具</c>

00:35:28.595 --> 00:35:30.831 align:middle line:90%,end
<c.magenta>能够在我们的所有设备和平台上运行</c>

00:35:31.331 --> 00:35:34.768 align:middle line:90%,end
<c.magenta>如果你想要更详细地了解</c>
<c.magenta>未定义的行为</c>

00:35:34.835 --> 00:35:38.772 align:middle line:90%,end
<c.magenta>我强烈建议你们观看</c>
<c.magenta>明天上午9点的演讲</c>

00:35:38.872 --> 00:35:42.209 align:middle line:90%,end
<c.magenta>此演讲介绍如何理解未定义的行为</c>

00:35:42.543 --> 00:35:45.812 align:middle line:90%,end
<c.magenta>介绍什么是未定义的行为</c>

00:35:46.613 --> 00:35:49.683 align:middle line:90%,end
<c.magenta>它为什么存在 如何影响你的应用</c>

00:35:52.319 --> 00:35:53.787 align:middle line:90%,end
<c.magenta>现在我们有些好消息告诉你们</c>

00:35:57.591 --> 00:35:59.092 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>

00:35:59.159 --> 00:36:02.563 align:middle line:90%,end
<c.magenta>可以检查15种以上</c>
<c.magenta>不同类型的新问题</c>

00:35:59.159 --> 00:36:02.563 align:middle line:90%,end
<c.magenta>可以检查15种以上</c>
<c.magenta>不同类型的新问题</c>

00:36:03.463 --> 00:36:07.334 align:middle line:90%,end
<c.magenta>这将帮助提高生产力</c>

00:36:07.401 --> 00:36:08.836 align:middle line:90%,end
<c.magenta>但是此演讲仅简单介绍</c>

00:36:08.902 --> 00:36:13.106 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>可以发现哪些问题 以及它如何工作</c>

00:36:13.173 --> 00:36:15.209 align:middle line:90%,end
<c.magenta>我们重点关注三个问题</c>

00:36:15.342 --> 00:36:20.347 align:middle line:90%,end
<c.magenta>整型溢出 对齐违规</c>
<c.magenta>和nonnull返回值违规</c>

00:36:22.449 --> 00:36:24.017 align:middle line:90%,end
<c.magenta>让我们先从整型溢出开始</c>

00:36:25.619 --> 00:36:29.122 align:middle line:90%,end
<c.magenta>当算法表达式的结果值过大</c>

00:36:29.256 --> 00:36:32.226 align:middle line:90%,end
<c.magenta>而无法放入变量时</c>
<c.magenta>就会发生整型溢出</c>

00:36:32.960 --> 00:36:36.496 align:middle line:90%,end
<c.magenta>如果在索引表达式中发生这种漏洞</c>

00:36:36.763 --> 00:36:39.166 align:middle line:90%,end
<c.magenta>比如 对缓冲进行索引</c>

00:36:39.399 --> 00:36:42.769 align:middle line:90%,end
<c.magenta>或在用于计算缓冲区</c>
<c.magenta>的表达式中进行索引</c>

00:36:42.970 --> 00:36:46.874 align:middle line:90%,end
<c.magenta>可能会造成严重的安全问题</c>
<c.magenta>而且可能会被利用</c>

00:36:48.308 --> 00:36:51.979 align:middle line:90%,end
<c.magenta>有时候整形溢出会造成意想不到的结果</c>

00:36:52.312 --> 00:36:54.915 align:middle line:90%,end
<c.magenta>比如 你可能会</c>

00:36:54.982 --> 00:36:57.017 align:middle line:90%,end
<c.magenta>进行大量的加法运算</c>

00:36:57.684 --> 00:36:59.019 align:middle line:90%,end
<c.magenta>举例来说</c>

00:36:59.186 --> 00:37:01.555 align:middle line:90%,end
<c.magenta>你有一个最大整数值 然后对它加1</c>

00:36:59.186 --> 00:37:01.555 align:middle line:90%,end
<c.magenta>你有一个最大整数值 然后对它加1</c>

00:37:01.622 --> 00:37:04.725 align:middle line:90%,end
<c.magenta>你可能会并不得到真正的结果</c>

00:37:04.791 --> 00:37:07.127 align:middle line:90%,end
<c.magenta>这会让你感到困惑</c>

00:37:08.462 --> 00:37:12.432 align:middle line:90%,end
<c.magenta>现在 并非所有类型的整型溢出</c>
<c.magenta>都是未定义的行为</c>

00:37:12.499 --> 00:37:16.236 align:middle line:90%,end
<c.magenta>事实上 一些类型的溢出</c>
<c.magenta>具有已定义的语义</c>

00:37:16.303 --> 00:37:18.539 align:middle line:90%,end
<c.magenta>比如无符号整型溢出</c>

00:37:19.473 --> 00:37:23.277 align:middle line:90%,end
<c.magenta>但是 无符号整型溢出</c>
<c.magenta>也可能造成意想不到的结果</c>

00:37:23.343 --> 00:37:26.480 align:middle line:90%,end
<c.magenta>我们强烈建议你</c>
<c.magenta>进行这方面的检查</c>

00:37:27.381 --> 00:37:29.449 align:middle line:90%,end
<c.magenta>在本主题末尾部分</c>
<c.magenta>我将介绍如何这样做</c>

00:37:31.285 --> 00:37:34.588 align:middle line:90%,end
<c.magenta>让我们首先来看一个演示</c>

00:37:35.322 --> 00:37:38.258 align:middle line:90%,end
<c.magenta>这里有一个函数</c>

00:37:38.325 --> 00:37:40.727 align:middle line:90%,end
<c.magenta>我们可能经常编写这样的函数</c>

00:37:40.827 --> 00:37:41.895 align:middle line:90%,end
<c.magenta>这是一个求平均值函数</c>

00:37:42.262 --> 00:37:45.432 align:middle line:90%,end
<c.magenta>它接受一个数组和长度值</c>

00:37:45.832 --> 00:37:47.134 align:middle line:90%,end
<c.magenta>设置累加器</c>

00:37:47.301 --> 00:37:50.704 align:middle line:90%,end
<c.magenta>对数据组进行迭代</c>
<c.magenta>累加所有数组元素 然后除以个数</c>

00:37:50.971 --> 00:37:52.406 align:middle line:90%,end
<c.magenta>得出平均值</c>

00:37:53.207 --> 00:37:54.908 align:middle line:90%,end
<c.magenta>我们想进行测试</c>

00:37:54.975 --> 00:37:57.344 align:middle line:90%,end
<c.magenta>以验证其行为是否正确</c>

00:37:58.111 --> 00:38:00.581 align:middle line:90%,end
<c.magenta>让我们来看测试</c>

00:37:58.111 --> 00:38:00.581 align:middle line:90%,end
<c.magenta>让我们来看测试</c>

00:38:01.381 --> 00:38:03.217 align:middle line:90%,end
<c.magenta>TestNonNegativeAverage</c>

00:38:04.218 --> 00:38:05.219 align:middle line:90%,end
<c.magenta>这个测试非常简单</c>

00:38:05.319 --> 00:38:08.222 align:middle line:90%,end
<c.magenta>我们将会创建一个数组</c>
<c.magenta>可容纳10,000个整数</c>

00:38:09.056 --> 00:38:13.527 align:middle line:90%,end
<c.magenta>在数组中放入伪随机非负整数</c>

00:38:13.760 --> 00:38:16.363 align:middle line:90%,end
<c.magenta>然后进行健全性检查</c>

00:38:16.697 --> 00:38:20.000 align:middle line:90%,end
<c.magenta>我们检查所获取的平均值是否为非负数</c>

00:38:20.133 --> 00:38:22.102 align:middle line:10%
<c.magenta>这里有一个断言</c>

00:38:24.104 --> 00:38:25.739 align:middle line:10%
<c.magenta>让我们运行测试</c>

00:38:25.939 --> 00:38:27.975 align:middle line:10%
<c.magenta>我们转到这里</c>

00:38:28.041 --> 00:38:30.477 align:middle line:10%
<c.magenta>成功地进行生成</c>

00:38:31.578 --> 00:38:33.647 align:middle line:10%
<c.magenta>我们并没有看到什么</c>

00:38:33.714 --> 00:38:36.216 align:middle line:10%
<c.magenta>程序运行结束</c>
<c.magenta>断言顺利通过</c>

00:38:36.416 --> 00:38:37.451 align:middle line:90%,end
<c.magenta>似乎一切顺利</c>

00:38:38.352 --> 00:38:41.221 align:middle line:90%,end
<c.magenta>我们进行细小的改动</c>

00:38:41.321 --> 00:38:43.757 align:middle line:90%,end
<c.magenta>将会向我们描述</c>
<c.magenta>为什么未定义的行为</c>

00:38:43.824 --> 00:38:46.093 align:middle line:90%,end
<c.magenta>和整型溢出实际上非常微妙</c>

00:38:46.393 --> 00:38:47.828 align:middle line:90%,end
<c.magenta>让我们改变数据长度</c>

00:38:48.061 --> 00:38:50.631 align:middle line:90%,end
<c.magenta>从10,000变为10,001</c>

00:38:51.265 --> 00:38:53.700 align:middle line:90%,end
<c.magenta>保存 然后返回</c>

00:38:54.935 --> 00:38:56.069 align:middle line:10%
<c.magenta>运行程序</c>

00:38:59.506 --> 00:39:02.476 align:middle line:10%
<c.magenta>断言失败</c>

00:38:59.506 --> 00:39:02.476 align:middle line:10%
<c.magenta>断言失败</c>

00:39:02.876 --> 00:39:03.911 align:middle line:10%
<c.magenta>这让人感到困惑</c>

00:39:03.977 --> 00:39:06.446 align:middle line:10%
<c.magenta>你知道</c>
<c.magenta>数组元素都是非负整数</c>

00:39:06.813 --> 00:39:10.017 align:middle line:10%
<c.magenta>我编写的函数也很简单</c>

00:39:10.083 --> 00:39:11.652 align:middle line:10%
<c.magenta>只是累加这些整数</c>

00:39:11.785 --> 00:39:14.021 align:middle line:10%
<c.magenta>但是突然之间发生这种错误</c>

00:39:14.087 --> 00:39:16.290 align:middle line:10%
<c.magenta>导致测试未能通过</c>

00:39:17.424 --> 00:39:20.694 align:middle line:90%,end
<c.magenta>在这些情况下可以使用</c>
<c.magenta>Undefined Behavior Sanitizer</c>

00:39:20.761 --> 00:39:22.930 align:middle line:90%,end
<c.magenta>弄清楚真正的问题是什么</c>

00:39:23.430 --> 00:39:25.566 align:middle line:90%,end
<c.magenta>因此我启用这个工具</c>
<c.magenta>就像刚才库巴展示的那样</c>

00:39:25.666 --> 00:39:29.536 align:middle line:90%,end
<c.magenta>我进入Scheme Editor</c>
<c.magenta>这里有一个“Diagnostics”选项卡</c>

00:39:30.938 --> 00:39:32.272 align:middle line:90%,end
<c.magenta>选中这个复选框</c>

00:39:33.407 --> 00:39:34.308 align:middle line:90%,end
<c.magenta>然后继续</c>

00:39:35.209 --> 00:39:37.477 align:middle line:90%,end
<c.magenta>再次点击“Run” 重新生成</c>

00:39:37.544 --> 00:39:39.746 align:middle line:90%,end
<c.magenta>这时Undefined Behavior Sanitizer</c>
<c.magenta>已经启用</c>

00:39:41.081 --> 00:39:41.915 align:middle line:90%,end
<c.magenta>我们看这里</c>

00:39:42.583 --> 00:39:46.019 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>为我们突出显示</c>

00:39:46.086 --> 00:39:48.856 align:middle line:90%,end
<c.magenta>准确的问题原因</c>

00:39:48.989 --> 00:39:51.191 align:middle line:90%,end
<c.magenta>非常直观地告诉我们</c>

00:39:51.325 --> 00:39:53.327 align:middle line:90%,end
<c.magenta>问题是</c>

00:39:53.560 --> 00:39:54.962 align:middle line:90%,end
<c.magenta>无符号整型溢出</c>

00:39:55.128 --> 00:39:57.464 align:middle line:90%,end
<c.magenta>为我们显示发生溢出的值</c>

00:39:57.598 --> 00:39:59.766 align:middle line:90%,end
<c.magenta>可以看到 数据非常大</c>

00:39:59.833 --> 00:40:02.736 align:middle line:90%,end
<c.magenta>这两个值或它们之和</c>

00:39:59.833 --> 00:40:02.736 align:middle line:90%,end
<c.magenta>这两个值或它们之和</c>

00:40:02.803 --> 00:40:04.638 align:middle line:90%,end
<c.magenta>无法放入32位整数</c>

00:40:04.705 --> 00:40:08.675 align:middle line:90%,end
<c.magenta>其结果是我们获得的</c>

00:40:09.443 --> 00:40:11.011 align:middle line:90%,end
<c.magenta>任何无效结果</c>

00:40:11.078 --> 00:40:13.947 align:middle line:90%,end
<c.magenta>使用其完整表示</c>
<c.magenta>而成为负数</c>

00:40:15.182 --> 00:40:18.519 align:middle line:90%,end
<c.magenta>可以通过多种方法解决这个问题</c>

00:40:18.752 --> 00:40:21.088 align:middle line:90%,end
<c.magenta>我建议的两个方法是</c>

00:40:21.154 --> 00:40:23.757 align:middle line:90%,end
<c.magenta>使用不同的算法来计算平均值</c>

00:40:24.157 --> 00:40:26.627 align:middle line:90%,end
<c.magenta>或者在平均值函数中设置约束</c>

00:40:26.693 --> 00:40:29.963 align:middle line:90%,end
<c.magenta>从而避免这个问题</c>

00:40:31.665 --> 00:40:36.003 align:middle line:90%,end
<c.magenta>然后 让我们返回幻灯片</c>

00:40:36.403 --> 00:40:39.239 align:middle line:90%,end
<c.magenta>希望你们发现</c>
<c.magenta>Undefined Behavior Sanitizer</c>

00:40:39.306 --> 00:40:44.311 align:middle line:90%,end
<c.magenta>能够让你轻松地发现这些</c>

00:40:44.378 --> 00:40:46.213 align:middle line:90%,end
<c.magenta>导致运行时错误的微妙问题</c>

00:40:47.681 --> 00:40:48.515 align:middle line:90%,end
<c.magenta>好的</c>

00:40:50.117 --> 00:40:53.420 align:middle line:90%,end
<c.magenta>让我们来看</c>

00:40:53.820 --> 00:40:55.122 align:middle line:90%,end
<c.magenta>第二种类型的问题</c>

00:40:55.189 --> 00:40:57.758 align:middle line:90%,end
<c.magenta>它们是内存对齐违规问题</c>

00:40:58.892 --> 00:41:01.828 align:middle line:90%,end
<c.magenta>C语言中的所有类型都有大小</c>

00:40:58.892 --> 00:41:01.828 align:middle line:90%,end
<c.magenta>C语言中的所有类型都有大小</c>

00:41:01.962 --> 00:41:04.198 align:middle line:90%,end
<c.magenta>而且要求进行内存对齐</c>

00:41:05.666 --> 00:41:08.402 align:middle line:90%,end
<c.magenta>如果未对齐地加载或存储到内存块</c>

00:41:08.468 --> 00:41:12.840 align:middle line:90%,end
<c.magenta>程序将发生内存对齐违规</c>

00:41:14.041 --> 00:41:18.378 align:middle line:90%,end
<c.magenta>这是非常难以发现的细微漏洞</c>

00:41:18.512 --> 00:41:21.715 align:middle line:90%,end
<c.magenta>在日常开发工作中</c>

00:41:21.782 --> 00:41:24.985 align:middle line:90%,end
<c.magenta>你可能不会发现这样的问题</c>

00:41:25.085 --> 00:41:27.721 align:middle line:90%,end
<c.magenta>假设你们大多数在Xcode中</c>

00:41:27.788 --> 00:41:30.457 align:middle line:90%,end
<c.magenta>开发应用和框架</c>
<c.magenta>进行调试配置</c>

00:41:30.991 --> 00:41:33.060 align:middle line:90%,end
<c.magenta>当你最终进行应用分发时</c>

00:41:33.393 --> 00:41:35.462 align:middle line:90%,end
<c.magenta>将需要进行发行配置</c>

00:41:35.963 --> 00:41:36.964 align:middle line:90%,end
<c.magenta>问题在于</c>

00:41:37.097 --> 00:41:39.299 align:middle line:90%,end
<c.magenta>因为编辑器期望</c>

00:41:39.366 --> 00:41:42.569 align:middle line:90%,end
<c.magenta>不发生对齐违规问题</c>

00:41:43.203 --> 00:41:46.573 align:middle line:90%,end
<c.magenta>优化器通常会优化你的代码</c>

00:41:46.707 --> 00:41:50.844 align:middle line:90%,end
<c.magenta>当启用这些优化时</c>
<c.magenta>会造成你的应用发行配置</c>

00:41:50.911 --> 00:41:52.613 align:middle line:90%,end
<c.magenta>在运行时崩溃</c>

00:41:54.047 --> 00:41:57.117 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>帮助你发现这些问题</c>

00:41:57.251 --> 00:41:59.753 align:middle line:90%,end
<c.magenta>甚至提前在调试配置中</c>
<c.magenta>发现问题</c>

00:41:59.820 --> 00:42:00.787 align:middle line:90%,end
<c.magenta>这样 就不会造成</c>

00:41:59.820 --> 00:42:00.787 align:middle line:90%,end
<c.magenta>这样 就不会造成</c>

00:42:00.888 --> 00:42:03.257 align:middle line:90%,end
<c.magenta>在以后出现难以调试的错误</c>

00:42:04.424 --> 00:42:07.294 align:middle line:90%,end
<c.magenta>在持续性存储中</c>

00:42:07.361 --> 00:42:10.163 align:middle line:90%,end
<c.magenta>进行数据串行化或反串行化的代码</c>
<c.magenta>特别容易</c>

00:42:10.230 --> 00:42:11.632 align:middle line:90%,end
<c.magenta>发生这种类型的错误</c>

00:42:12.199 --> 00:42:16.303 align:middle line:90%,end
<c.magenta>让我们来认真看一个例子</c>

00:42:19.039 --> 00:42:21.041 align:middle line:90%,end
<c.magenta>在本例中</c>

00:42:21.141 --> 00:42:24.311 align:middle line:90%,end
<c.magenta>我想编写一个自定义网络协议</c>

00:42:24.378 --> 00:42:26.079 align:middle line:90%,end
<c.magenta>将它用于我正在开发的聊天程序</c>

00:42:27.214 --> 00:42:30.551 align:middle line:90%,end
<c.magenta>此网络协议的一个基本功能是</c>

00:42:30.717 --> 00:42:33.053 align:middle line:90%,end
<c.magenta>定义一个数据包结构</c>

00:42:34.221 --> 00:42:36.356 align:middle line:90%,end
<c.magenta>此数据包结构包含三个部分</c>

00:42:36.857 --> 00:42:40.027 align:middle line:90%,end
<c.magenta>一个magic字段 表示所使用的协议</c>

00:42:41.295 --> 00:42:43.697 align:middle line:90%,end
<c.magenta>一个payloadLength字段</c>

00:42:43.764 --> 00:42:46.133 align:middle line:90%,end
<c.magenta>说明数据包内的消息长度</c>

00:42:46.567 --> 00:42:48.235 align:middle line:90%,end
<c.magenta>最后是payload本身</c>

00:42:48.902 --> 00:42:50.671 align:middle line:90%,end
<c.magenta>从本例的目的来说</c>

00:42:50.737 --> 00:42:53.740 align:middle line:90%,end
<c.magenta>我假设int是一个四字节整数</c>

00:42:54.141 --> 00:42:55.909 align:middle line:90%,end
<c.magenta>现在 我们需要专注于</c>

00:42:56.944 --> 00:42:58.912 align:middle line:90%,end
<c.magenta>两个方面</c>

00:42:58.979 --> 00:43:02.416 align:middle line:90%,end
<c.magenta>以确保自定义网络协议工作正常</c>

00:42:58.979 --> 00:43:02.416 align:middle line:90%,end
<c.magenta>以确保自定义网络协议工作正常</c>

00:43:02.616 --> 00:43:04.284 align:middle line:90%,end
<c.magenta>它们是发送器和接收器</c>

00:43:04.551 --> 00:43:06.520 align:middle line:90%,end
<c.magenta>我们先来看接收器</c>

00:43:07.154 --> 00:43:09.323 align:middle line:90%,end
<c.magenta>接收器有一个网络缓冲区</c>

00:43:09.423 --> 00:43:11.992 align:middle line:90%,end
<c.magenta>它在这个缓冲区内组装其数据包</c>

00:43:12.726 --> 00:43:13.727 align:middle line:90%,end
<c.magenta>准备好这些数据包</c>

00:43:13.827 --> 00:43:14.962 align:middle line:90%,end
<c.magenta>使数据负载准备就绪</c>

00:43:15.295 --> 00:43:18.498 align:middle line:90%,end
<c.magenta>然后通过网络发送</c>
<c.magenta>使接收器能够接收</c>

00:43:19.233 --> 00:43:22.169 align:middle line:90%,end
<c.magenta>从演示的角度来说</c>

00:43:22.436 --> 00:43:25.272 align:middle line:90%,end
<c.magenta>我已经将网络缓冲区的内存</c>

00:43:25.339 --> 00:43:28.342 align:middle line:90%,end
<c.magenta>分割成为多个四字节块</c>
<c.magenta>你们很快就知道原因</c>

00:43:29.877 --> 00:43:32.479 align:middle line:90%,end
<c.magenta>现在我已很想念库巴</c>

00:43:32.613 --> 00:43:35.516 align:middle line:90%,end
<c.magenta>可是他早就下台了</c>

00:43:36.650 --> 00:43:40.020 align:middle line:90%,end
<c.magenta>我想发送给库巴的第一条信息是</c>
<c.magenta>“Hey Kuba!”</c>

00:43:40.754 --> 00:43:44.024 align:middle line:90%,end
<c.magenta>为此 我首先使用一个magic值</c>

00:43:46.426 --> 00:43:49.429 align:middle line:90%,end
<c.magenta>然后指定消息的长度</c>

00:43:49.496 --> 00:43:50.831 align:middle line:90%,end
<c.magenta>里面共有9个字符</c>

00:43:51.798 --> 00:43:52.633 align:middle line:90%,end
<c.magenta>让我们开始</c>

00:43:54.234 --> 00:43:59.139 align:middle line:90%,end
<c.magenta>最后我指定消息内容</c>
<c.magenta>即“Hey Kuba!”</c>

00:44:00.774 --> 00:44:03.610 align:middle line:90%,end
<c.magenta>现在我们来看接收器的功能</c>

00:44:05.279 --> 00:44:08.949 align:middle line:90%,end
<c.magenta>它接收一个指向</c>
<c.magenta>网络字节流缓存区的指针</c>

00:44:09.383 --> 00:44:12.386 align:middle line:90%,end
<c.magenta>然后将这个指针转换成为</c>
<c.magenta>指向数据包结构的指针</c>

00:44:14.121 --> 00:44:17.457 align:middle line:90%,end
<c.magenta>然后查找数据包内部</c>

00:44:18.125 --> 00:44:19.660 align:middle line:90%,end
<c.magenta>找到magic字段的值</c>

00:44:19.726 --> 00:44:22.930 align:middle line:10%
<c.magenta>确保它是正确的值</c>
<c.magenta>让我们使用正确的协议</c>

00:44:23.330 --> 00:44:25.132 align:middle line:10%
<c.magenta>然后查看数据负载</c>

00:44:26.567 --> 00:44:29.369 align:middle line:10%
<c.magenta>这是第一个数据包</c>
<c.magenta>到目前还没有问题</c>

00:44:30.270 --> 00:44:31.138 align:middle line:90%,end
<c.magenta>让我们来看第二条消息</c>

00:44:32.840 --> 00:44:35.509 align:middle line:10%
<c.magenta>第二条消息的内容是</c>
<c.magenta>“How's it going?”</c>

00:44:36.043 --> 00:44:37.411 align:middle line:90%,end
<c.magenta>我们进行同样的操作</c>

00:44:39.079 --> 00:44:41.582 align:middle line:90%,end
<c.magenta>找到magic字段值</c>

00:44:43.050 --> 00:44:45.919 align:middle line:90%,end
<c.magenta>放入消息长度 15个字符</c>

00:44:46.520 --> 00:44:47.988 align:middle line:90%,end
<c.magenta>然后是消息本身</c>

00:44:49.289 --> 00:44:51.592 align:middle line:90%,end
<c.magenta>然后转到接收器端</c>

00:44:51.859 --> 00:44:54.261 align:middle line:10%
<c.magenta>我们可以看到问题清单</c>

00:44:55.229 --> 00:44:59.800 align:middle line:10%
<c.magenta>查看网络字节流中的索引17</c>

00:45:00.534 --> 00:45:03.937 align:middle line:90%,end
<c.magenta>当我们查找</c>

00:45:04.004 --> 00:45:05.606 align:middle line:90%,end
<c.magenta>数据包内的magic值时</c>

00:45:06.406 --> 00:45:08.475 align:middle line:90%,end
<c.magenta>发生内存对齐违规</c>

00:45:10.644 --> 00:45:12.145 align:middle line:90%,end
<c.magenta>这里可以看到</c>

00:45:12.412 --> 00:45:14.848 align:middle line:90%,end
<c.magenta>第二个数据包的magic字段</c>

00:45:14.982 --> 00:45:17.150 align:middle line:90%,end
<c.magenta>没有对齐为四字节边界</c>

00:45:17.451 --> 00:45:20.621 align:middle line:10%
<c.magenta>因此在网络字节流中</c>
<c.magenta>直接取消引用它</c>

00:45:20.687 --> 00:45:21.989 align:middle line:90%,end
<c.magenta>会造成内存对齐违规</c>

00:45:22.289 --> 00:45:24.525 align:middle line:10%
<c.magenta>Undefined Behavior Sanitizer</c>

00:45:24.625 --> 00:45:26.560 align:middle line:90%,end
<c.magenta>可以非常准确地诊断出这个问题</c>

00:45:30.697 --> 00:45:31.732 align:middle line:90%,end
<c.magenta>如何解决这个问题呢？</c>

00:45:31.965 --> 00:45:33.867 align:middle line:90%,end
<c.magenta>接下我们会讨论两种方法</c>

00:45:34.401 --> 00:45:36.870 align:middle line:90%,end
<c.magenta>第一种方法是</c>

00:45:36.937 --> 00:45:39.206 align:middle line:90%,end
<c.magenta>在网络数据包结构定义</c>
<c.magenta>或你已经串行化处理的任何结构中</c>

00:45:39.273 --> 00:45:41.808 align:middle line:90%,end
<c.magenta>使用packed属性</c>

00:45:42.709 --> 00:45:44.411 align:middle line:90%,end
<c.magenta>让我们来看这是如何工作的</c>

00:45:45.946 --> 00:45:47.181 align:middle line:90%,end
<c.magenta>你添加packed属性</c>

00:45:47.247 --> 00:45:49.683 align:middle line:90%,end
<c.magenta>这会更改所有结构内的</c>

00:45:49.750 --> 00:45:50.851 align:middle line:90%,end
<c.magenta>所有字段对齐</c>

00:45:51.151 --> 00:45:53.987 align:middle line:90%,end
<c.magenta>这是你所能够获得的</c>

00:45:54.621 --> 00:45:57.124 align:middle line:90%,end
<c.magenta>最低可能性对齐</c>

00:45:57.391 --> 00:46:01.361 align:middle line:90%,end
<c.magenta>这意味着该字段的任何后续加载或存储</c>

00:45:57.391 --> 00:46:01.361 align:middle line:90%,end
<c.magenta>这意味着该字段的任何后续加载或存储</c>

00:46:01.428 --> 00:46:02.863 align:middle line:90%,end
<c.magenta>始终会对齐</c>

00:46:03.597 --> 00:46:06.633 align:middle line:90%,end
<c.magenta>你可能会想</c>
<c.magenta>这听上去非常方便</c>

00:46:06.733 --> 00:46:08.669 align:middle line:90%,end
<c.magenta>我想对所有项目使用packed属性</c>

00:46:09.169 --> 00:46:10.737 align:middle line:90%,end
<c.magenta>但是你应该注意</c>

00:46:11.071 --> 00:46:12.673 align:middle line:90%,end
<c.magenta>使用packed属性</c>

00:46:12.739 --> 00:46:15.042 align:middle line:90%,end
<c.magenta>将会更改结构的布局</c>

00:46:16.143 --> 00:46:17.978 align:middle line:90%,end
<c.magenta>很多情况下 它会消除</c>

00:46:18.045 --> 00:46:19.780 align:middle line:90%,end
<c.magenta>编译器自动插入到</c>

00:46:19.847 --> 00:46:20.948 align:middle line:90%,end
<c.magenta>数据结构中的填充</c>

00:46:21.615 --> 00:46:24.618 align:middle line:90%,end
<c.magenta>这可能会降低应用性能</c>

00:46:25.452 --> 00:46:28.956 align:middle line:90%,end
<c.magenta>如果你发现</c>

00:46:29.022 --> 00:46:31.158 align:middle line:90%,end
<c.magenta>packed属性并不适合你的处理</c>

00:46:31.358 --> 00:46:32.559 align:middle line:90%,end
<c.magenta>还有另外一种方法</c>

00:46:34.828 --> 00:46:37.497 align:middle line:90%,end
<c.magenta>你可以使用memcpy函数</c>

00:46:37.998 --> 00:46:42.002 align:middle line:90%,end
<c.magenta>将网络字节流</c>

00:46:42.069 --> 00:46:44.137 align:middle line:90%,end
<c.magenta>或者已经去串行化的数据块</c>

00:46:44.872 --> 00:46:47.574 align:middle line:90%,end
<c.magenta>复制到对齐变量之中</c>

00:46:47.641 --> 00:46:49.409 align:middle line:90%,end
<c.magenta>对齐变量可能位于堆栈或堆之中</c>

00:46:50.210 --> 00:46:54.081 align:middle line:90%,end
<c.magenta>memcpy是安全的</c>
<c.magenta>许多情况下 编译器可以进行优化</c>

00:46:54.147 --> 00:46:59.086 align:middle line:90%,end
<c.magenta>使访问速度与未对齐访问一样快速</c>

00:46:59.419 --> 00:47:01.288 align:middle line:90%,end
<c.magenta>这是原始未对齐访问所无法企及的</c>

00:46:59.419 --> 00:47:01.288 align:middle line:90%,end
<c.magenta>这是原始未对齐访问所无法企及的</c>

00:47:04.057 --> 00:47:07.461 align:middle line:90%,end
<c.magenta>这就是Undefined Behavior Sanitizer</c>
<c.magenta>的对齐违规检测功能</c>

00:47:09.363 --> 00:47:12.332 align:middle line:90%,end
<c.magenta>让我们来看第三种类型的漏洞</c>

00:47:13.333 --> 00:47:15.369 align:middle line:90%,end
<c.magenta>即nonnull返回值违规</c>

00:47:17.371 --> 00:47:20.174 align:middle line:90%,end
<c.magenta>当函数的返回值</c>

00:47:20.240 --> 00:47:23.610 align:middle line:90%,end
<c.magenta>使用nonnull属性注解时</c>

00:47:24.611 --> 00:47:25.812 align:middle line:90%,end
<c.magenta>将发生这种问题</c>

00:47:26.880 --> 00:47:29.016 align:middle line:90%,end
<c.magenta>但是 函数破坏</c>

00:47:29.750 --> 00:47:33.620 align:middle line:90%,end
<c.magenta>注解所使用的协定</c>

00:47:33.754 --> 00:47:35.989 align:middle line:90%,end
<c.magenta>并且返回nil值</c>

00:47:36.657 --> 00:47:40.360 align:middle line:90%,end
<c.magenta>如果使用Objective-C API</c>
<c.magenta>将会导致崩溃</c>

00:47:40.460 --> 00:47:43.263 align:middle line:90%,end
<c.magenta>因为这违反</c>
<c.magenta>Swift代码的</c>

00:47:44.031 --> 00:47:44.865 align:middle line:90%,end
<c.magenta>返回值注解规则</c>

00:47:45.566 --> 00:47:47.467 align:middle line:90%,end
<c.magenta>这还会导致其他问题</c>

00:47:47.534 --> 00:47:49.303 align:middle line:90%,end
<c.magenta>如果你使用的</c>
<c.magenta>Objective-C API</c>

00:47:49.436 --> 00:47:52.539 align:middle line:90%,end
<c.magenta>更严格地依赖于</c>

00:47:54.441 --> 00:47:55.275 align:middle line:90%,end
<c.magenta>空属性关联纠错</c>

00:47:56.577 --> 00:47:58.812 align:middle line:90%,end
<c.magenta>因此我们强烈建议你进行这种检查</c>

00:47:58.879 --> 00:48:01.748 align:middle line:90%,end
<c.magenta>如果你的应用</c>
<c.magenta>使用空属性注解</c>

00:47:58.879 --> 00:48:01.748 align:middle line:90%,end
<c.magenta>如果你的应用</c>
<c.magenta>使用空属性注解</c>

00:48:03.283 --> 00:48:06.553 align:middle line:90%,end
<c.magenta>让我们来看一个</c>

00:48:07.588 --> 00:48:09.156 align:middle line:90%,end
<c.magenta>nonnull返回值违规例子</c>

00:48:10.490 --> 00:48:14.228 align:middle line:90%,end
<c.magenta>在本例中</c>
<c.magenta>我是一名业余天文爱好者</c>

00:48:14.461 --> 00:48:16.396 align:middle line:90%,end
<c.magenta>我有一个太阳系模型</c>

00:48:17.598 --> 00:48:19.867 align:middle line:90%,end
<c.magenta>首先我想要做的是</c>

00:48:19.933 --> 00:48:21.969 align:middle line:90%,end
<c.magenta>建模太阳系中的卫星</c>

00:48:22.035 --> 00:48:23.203 align:middle line:90%,end
<c.magenta>我们开始</c>

00:48:23.337 --> 00:48:24.671 align:middle line:90%,end
<c.magenta>这是行星地球</c>

00:48:24.805 --> 00:48:28.308 align:middle line:90%,end
<c.magenta>地球的最大卫星是月亮</c>

00:48:28.542 --> 00:48:31.879 align:middle line:90%,end
<c.magenta>然后还有火星</c>
<c.magenta>我们按照直径</c>

00:48:31.945 --> 00:48:34.348 align:middle line:90%,end
<c.magenta>对这个列表进行降序排序</c>

00:48:34.615 --> 00:48:36.350 align:middle line:90%,end
<c.magenta>火卫一是火星的最大卫星</c>

00:48:36.416 --> 00:48:37.651 align:middle line:90%,end
<c.magenta>火卫二是第二大卫星</c>

00:48:37.718 --> 00:48:40.254 align:middle line:90%,end
<c.magenta>很好</c>

00:48:41.321 --> 00:48:43.724 align:middle line:90%,end
<c.magenta>看起来这里的一个输入</c>

00:48:43.790 --> 00:48:45.559 align:middle line:90%,end
<c.magenta>是错误的</c>

00:48:47.027 --> 00:48:48.695 align:middle line:90%,end
<c.magenta>这让人尴尬</c>

00:48:49.596 --> 00:48:50.531 align:middle line:90%,end
<c.magenta>最好删除它</c>

00:48:50.964 --> 00:48:52.432 align:middle line:90%,end
<c.magenta>这样好多了</c>

00:48:52.766 --> 00:48:56.603 align:middle line:90%,end
<c.magenta>我删除例中的遗留代码</c>

00:48:57.437 --> 00:48:59.339 align:middle line:90%,end
<c.magenta>现在列表看上去正确了</c>

00:49:00.541 --> 00:49:01.808 align:middle line:90%,end
<c.magenta>让我们继续</c>

00:49:02.009 --> 00:49:03.143 align:middle line:90%,end
<c.magenta>好的</c>

00:49:04.578 --> 00:49:07.314 align:middle line:90%,end
<c.magenta>我想做的事情是</c>

00:49:07.447 --> 00:49:09.850 align:middle line:90%,end
<c.magenta>获得一个列表</c>

00:49:09.917 --> 00:49:11.518 align:middle line:90%,end
<c.magenta>列出太阳系所有行星的最大卫星</c>

00:49:12.553 --> 00:49:16.890 align:middle line:90%,end
<c.magenta>我要做的事情是</c>
<c.magenta>构造一个NSMutableArray</c>

00:49:17.691 --> 00:49:21.628 align:middle line:90%,end
<c.magenta>然后添加每个行星的最大卫星</c>
<c.magenta>到这个数组之中</c>

00:49:22.296 --> 00:49:24.298 align:middle line:90%,end
<c.magenta>这里的问题是</c>

00:49:24.364 --> 00:49:26.033 align:middle line:90%,end
<c.magenta>我已经查询木星的最大卫星</c>

00:49:26.366 --> 00:49:29.469 align:middle line:90%,end
<c.magenta>但是我创建的NS词典中没有这个条目</c>

00:49:29.703 --> 00:49:30.637 align:middle line:90%,end
<c.magenta>因此我获取返回值nil</c>

00:49:31.872 --> 00:49:35.209 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>可以为你诊断这个问题</c>

00:49:37.611 --> 00:49:41.114 align:middle line:90%,end
<c.magenta>让我们来看</c>

00:49:41.181 --> 00:49:43.450 align:middle line:90%,end
<c.magenta>Undefined Behavior Sanitizer</c>
<c.magenta>可以为你发现什么样的问题</c>

00:49:43.617 --> 00:49:44.952 align:middle line:90%,end
<c.magenta>并了解它的运行原理</c>

00:49:45.853 --> 00:49:47.421 align:middle line:90%,end
<c.magenta>我将为你们展示</c>

00:49:47.721 --> 00:49:51.191 align:middle line:90%,end
<c.magenta>如何启用这些检查功能</c>

00:49:51.959 --> 00:49:53.727 align:middle line:90%,end
<c.magenta>这是一个项目生成设置编辑器</c>

00:49:54.294 --> 00:49:57.998 align:middle line:90%,end
<c.magenta>在这里 可以启用</c>
<c.magenta>无符号整型溢出检测功能</c>

00:49:58.198 --> 00:50:01.268 align:middle line:90%,end
<c.magenta>和空属性注解检查功能</c>

00:49:58.198 --> 00:50:01.268 align:middle line:90%,end
<c.magenta>和空属性注解检查功能</c>

00:50:02.769 --> 00:50:05.839 align:middle line:90%,end
<c.magenta>这是Undefined Behavior Sanitizer</c>
<c.magenta>Xcode 9中的新工具</c>

00:50:16.650 --> 00:50:19.720 align:middle line:90%,end
<c.magenta>我们已经了解Xcode中</c>
<c.magenta>的许多运行时工具</c>

00:50:19.887 --> 00:50:21.188 align:middle line:90%,end
<c.magenta>一些是新工具 一些经过改进</c>

00:50:21.321 --> 00:50:23.223 align:middle line:90%,end
<c.magenta>让我们回过头来</c>

00:50:23.757 --> 00:50:25.659 align:middle line:90%,end
<c.magenta>思考软件质量本身</c>

00:50:25.893 --> 00:50:28.562 align:middle line:90%,end
<c.magenta>如何有效地使用这些工具？</c>

00:50:31.465 --> 00:50:32.633 align:middle line:90%,end
<c.magenta>这需要从两个方面着手</c>

00:50:33.500 --> 00:50:36.837 align:middle line:90%,end
<c.magenta>你需要更多地练习</c>
<c.magenta>使用这些工具检查你的代码</c>

00:50:37.437 --> 00:50:39.106 align:middle line:90%,end
<c.magenta>另外应该综合性地使用这些工具</c>

00:50:40.073 --> 00:50:40.908 align:middle line:90%,end
<c.magenta>让我们来了解</c>

00:50:42.776 --> 00:50:44.344 align:middle line:90%,end
<c.magenta>（代码检查练习）</c>

00:50:44.411 --> 00:50:48.081 align:middle line:90%,end
<c.magenta>当你运行含有漏洞的代码时</c>

00:50:48.215 --> 00:50:50.951 align:middle line:90%,end
<c.magenta>运行时工具帮助你发现这些漏洞</c>

00:50:51.285 --> 00:50:52.686 align:middle line:90%,end
<c.magenta>也许[听不清]</c>
<c.magenta>这不是最好的方法</c>

00:50:52.753 --> 00:50:57.858 align:middle line:90%,end
<c.magenta>但是你必须运行含有漏洞的代码行</c>

00:50:57.925 --> 00:50:59.893 align:middle line:90%,end
<c.magenta>才能获得</c>

00:50:59.960 --> 00:51:02.262 align:middle line:90%,end
<c.magenta>有价值的漏洞诊断信息</c>

00:50:59.960 --> 00:51:02.262 align:middle line:90%,end
<c.magenta>有价值的漏洞诊断信息</c>

00:51:02.462 --> 00:51:03.497 align:middle line:90%,end
<c.magenta>因此</c>

00:51:04.097 --> 00:51:06.133 align:middle line:90%,end
<c.magenta>为了使用更多的代码进行练习</c>

00:51:06.200 --> 00:51:08.168 align:middle line:90%,end
<c.magenta>发现尽可能多的问题</c>

00:51:09.203 --> 00:51:12.673 align:middle line:90%,end
<c.magenta>我们建议你</c>
<c.magenta>在日常开发工作中使得这些运行时工具</c>

00:51:13.574 --> 00:51:15.475 align:middle line:90%,end
<c.magenta>我们建议你</c>
<c.magenta>至少在每次软件发布之前</c>

00:51:15.542 --> 00:51:18.145 align:middle line:90%,end
<c.magenta>启用一次这些工具</c>

00:51:18.212 --> 00:51:19.980 align:middle line:90%,end
<c.magenta>以避免传播漏洞</c>

00:51:20.047 --> 00:51:22.749 align:middle line:90%,end
<c.magenta>和可能的安全漏洞</c>

00:51:25.385 --> 00:51:27.054 align:middle line:90%,end
<c.magenta>使用持续性集成</c>

00:51:27.254 --> 00:51:29.923 align:middle line:90%,end
<c.magenta>让使用运行时工具变得更简单</c>

00:51:30.390 --> 00:51:32.893 align:middle line:90%,end
<c.magenta>而且 在启用这些工具之后</c>

00:51:32.993 --> 00:51:34.261 align:middle line:90%,end
<c.magenta>代码检查工作</c>

00:51:34.328 --> 00:51:35.863 align:middle line:90%,end
<c.magenta>变得更加容易</c>

00:51:36.997 --> 00:51:38.699 align:middle line:90%,end
<c.magenta>可以确保</c>

00:51:38.866 --> 00:51:41.435 align:middle line:90%,end
<c.magenta>在检查代码时</c>

00:51:41.502 --> 00:51:42.803 align:middle line:90%,end
<c.magenta>尽快地发现程序中的漏洞</c>

00:51:43.904 --> 00:51:46.773 align:middle line:90%,end
<c.magenta>帮助你跟踪程序中的代码检查情况</c>

00:51:46.840 --> 00:51:49.710 align:middle line:90%,end
<c.magenta>让你能够了解</c>
<c.magenta>每次进行持续性集成时</c>

00:51:49.943 --> 00:51:52.145 align:middle line:90%,end
<c.magenta>对多少代码进行了检查</c>

00:51:53.413 --> 00:51:55.782 align:middle line:90%,end
<c.magenta>如果你想要了解</c>
<c.magenta>Xcode中的持续性集成</c>

00:51:55.849 --> 00:51:57.651 align:middle line:90%,end
<c.magenta>和代码检查工作原理</c>

00:51:57.851 --> 00:52:01.922 align:middle line:90%,end
<c.magenta>建议你们观看</c>
<c.magenta>WWDC 2015相关主题演讲</c>

00:51:57.851 --> 00:52:01.922 align:middle line:90%,end
<c.magenta>建议你们观看</c>
<c.magenta>WWDC 2015相关主题演讲</c>

00:52:05.826 --> 00:52:08.395 align:middle line:90%,end
<c.magenta>确保有效地使用运行时工具的</c>
<c.magenta>另一个重要因素是</c>

00:52:08.462 --> 00:52:09.963 align:middle line:90%,end
<c.magenta>综合性地使用这些工具</c>

00:52:10.497 --> 00:52:13.667 align:middle line:90%,end
<c.magenta>启用的工具越多</c>
<c.magenta>能够发现的问题就越多</c>

00:52:14.935 --> 00:52:15.769 align:middle line:90%,end
<c.magenta>有一个例外</c>

00:52:15.836 --> 00:52:18.238 align:middle line:90%,end
<c.magenta>Address Sanitizer</c>
<c.magenta>和Thread Sanitizer</c>

00:52:18.305 --> 00:52:19.706 align:middle line:90%,end
<c.magenta>互相不兼容</c>

00:52:19.806 --> 00:52:21.675 align:middle line:90%,end
<c.magenta>不能同时启用这两个工具</c>

00:52:21.742 --> 00:52:23.477 align:middle line:90%,end
<c.magenta>但是可以同时启用其它工具</c>

00:52:24.478 --> 00:52:27.848 align:middle line:90%,end
<c.magenta>前面我们讲过</c>
<c.magenta>进入Xcode的方案编辑器</c>

00:52:27.915 --> 00:52:30.817 align:middle line:90%,end
<c.magenta>点击“诊断”选项卡</c>

00:52:30.884 --> 00:52:32.519 align:middle line:90%,end
<c.magenta>可以启用所有这些工具</c>

00:52:33.887 --> 00:52:37.124 align:middle line:90%,end
<c.magenta>你可能会想</c>
<c.magenta>这些工具会产生很大的开销</c>

00:52:38.725 --> 00:52:39.993 align:middle line:90%,end
<c.magenta>实际上并不是这样的</c>

00:52:40.861 --> 00:52:43.096 align:middle line:90%,end
<c.magenta>至少我的经验告诉我不是这样的</c>

00:52:43.197 --> 00:52:46.300 align:middle line:90%,end
<c.magenta>关于这些工具的执行和内存开销</c>

00:52:46.366 --> 00:52:48.068 align:middle line:90%,end
<c.magenta>我们有一些数据</c>

00:52:48.802 --> 00:52:51.839 align:middle line:10%
<c.magenta>我发现</c>

00:52:51.972 --> 00:52:55.275 align:middle line:10%
<c.magenta>在调试整个Xcode程序时</c>

00:52:55.342 --> 00:52:57.377 align:middle line:10%
<c.magenta>我可以同时启用多个运行时工具</c>

00:52:57.644 --> 00:52:59.246 align:middle line:10%
<c.magenta>UI依然反应灵敏</c>

00:53:00.214 --> 00:53:03.116 align:middle line:10%
<c.magenta>希望这些信息能够帮助你更好地决定</c>

00:53:03.183 --> 00:53:04.585 align:middle line:10%
<c.magenta>应该在你的本地设置及持续性集成中</c>

00:53:04.718 --> 00:53:07.321 align:middle line:10%
<c.magenta>启用哪些工具</c>

00:53:07.988 --> 00:53:10.691 align:middle line:10%
<c.magenta>我希望你认识到</c>

00:53:10.757 --> 00:53:13.794 align:middle line:10%
<c.magenta>所有这些工具都非常有价值</c>

00:53:13.961 --> 00:53:16.563 align:middle line:90%,end
<c.magenta>它们为你发现不同的漏洞</c>

00:53:16.830 --> 00:53:20.000 align:middle line:90%,end
<c.magenta>必要时应该启用它们</c>

00:53:23.237 --> 00:53:24.371 align:middle line:90%,end
<c.magenta>让我们进行总结</c>

00:53:24.605 --> 00:53:27.608 align:middle line:90%,end
<c.magenta>Xcode 9增加新工具</c>
<c.magenta>和经过改进的工具</c>

00:53:27.674 --> 00:53:29.710 align:middle line:90%,end
<c.magenta>帮助你在应用和程序中</c>

00:53:30.377 --> 00:53:32.045 align:middle line:90%,end
<c.magenta>发现更多的严重漏洞</c>

00:53:33.213 --> 00:53:35.449 align:middle line:90%,end
<c.magenta>我真心希望</c>
<c.magenta>你们尽早地、经常地使用它们</c>

00:53:35.749 --> 00:53:38.685 align:middle line:90%,end
<c.magenta>以节省调试时间</c>
<c.magenta>并确保用户安全性</c>

00:53:38.852 --> 00:53:41.922 align:middle line:90%,end
<c.magenta>希望你们使用这些工具</c>
<c.magenta>发现并且消除漏洞</c>

00:53:42.322 --> 00:53:44.391 align:middle line:90%,end
<c.magenta>如果你需要本演讲的更多信息</c>

00:53:44.625 --> 00:53:47.694 align:middle line:90%,end
<c.magenta>请访问我们的网站</c>
<c.magenta>此网站提供大量的有用链接</c>

00:53:48.529 --> 00:53:50.364 align:middle line:90%,end
<c.magenta>另外 一些相关的演讲</c>
<c.magenta>即将举行</c>

00:53:50.564 --> 00:53:53.634 align:middle line:90%,end
<c.magenta>它们是“Swift新特性”和</c>
<c.magenta>“Xcode 9调试功能”演讲</c>

00:53:53.934 --> 00:53:55.769 align:middle line:90%,end
<c.magenta>另外还有GCD演讲</c>

00:53:57.538 --> 00:54:00.707 align:middle line:90%,end
<c.magenta>以及“LLVM新特性”演讲</c>

00:53:57.538 --> 00:54:00.707 align:middle line:90%,end
<c.magenta>以及“LLVM新特性”演讲</c>

00:54:00.774 --> 00:54:04.011 align:middle line:90%,end
<c.magenta>可以帮助你们了解</c>
<c.magenta>这些运行时工具的</c>

00:54:05.479 --> 00:54:07.014 align:middle line:90%,end
<c.magenta>底层Sanitizer技术</c>

00:54:08.248 --> 00:54:10.651 align:middle line:90%,end
<c.magenta>感谢你们参加本演讲</c>

00:54:10.918 --> 00:54:12.653 align:middle line:90%,end
<c.magenta>希望你们有所收获</c>
