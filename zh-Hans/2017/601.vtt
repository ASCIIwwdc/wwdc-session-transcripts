WEBVTT

00:00:21.516 --> 00:00:27.956 A:middle
[ 掌声 ]

00:00:28.456 --> 00:00:28.916 A:middle
&gt;&gt; 欢迎

00:00:29.436 --> 00:00:30.996 A:middle
我们结合 Metal 2

00:00:30.996 --> 00:00:32.576 A:middle
推出了许多

00:00:32.856 --> 00:00:34.846 A:middle
新的技术 能让你们制作

00:00:35.116 --> 00:00:36.896 A:middle
更好 更快

00:00:36.896 --> 00:00:37.706 A:middle
更有效率的应用

00:00:38.206 --> 00:00:39.396 A:middle
我是 Michal

00:00:39.396 --> 00:00:40.856 A:middle
我和我的同事 Richard

00:00:40.856 --> 00:00:42.756 A:middle
今天将给大家介绍三个主题

00:00:44.546 --> 00:00:46.546 A:middle
通过使用 Metal2

00:00:46.756 --> 00:00:48.656 A:middle
我们将继续减少

00:00:48.656 --> 00:00:50.526 A:middle
高代价操作的发生

00:00:50.526 --> 00:00:52.266 A:middle
并确保

00:00:52.266 --> 00:00:54.376 A:middle
常用的操作

00:00:54.376 --> 00:00:55.176 A:middle
只花费很少的代价

00:00:55.656 --> 00:00:57.356 A:middle
历年来 我们介绍过

00:00:57.646 --> 00:01:00.226 A:middle
预编译着色器

00:00:57.646 --> 00:01:00.226 A:middle
预编译着色器

00:01:00.226 --> 00:01:02.286 A:middle
渲染状态对象和去年的 Metal 堆

00:01:02.286 --> 00:01:04.566 A:middle
以保证你能将

00:01:04.566 --> 00:01:06.416 A:middle
高代价的操作

00:01:06.576 --> 00:01:08.796 A:middle
移除出你的

00:01:09.346 --> 00:01:09.446 A:middle
主要应用循环

00:01:10.096 --> 00:01:13.836 A:middle
通过将 open GL 换成 Metal

00:01:13.836 --> 00:01:15.886 A:middle
我们能给你提供 10 倍多的

00:01:16.206 --> 00:01:16.696 A:middle
绘图调用

00:01:17.616 --> 00:01:18.996 A:middle
今年 我们将介绍

00:01:18.996 --> 00:01:21.496 A:middle
新的绑定 API

00:01:21.496 --> 00:01:22.866 A:middle
它能为你提供更多的功能

00:01:22.866 --> 00:01:24.426 A:middle
因此我们将

00:01:24.426 --> 00:01:24.946 A:middle
进一步介绍它

00:01:26.446 --> 00:01:29.006 A:middle
通过 GPU 驱动流水线

00:01:29.006 --> 00:01:32.016 A:middle
我们将进一步把 GPU 放在

00:01:32.016 --> 00:01:32.856 A:middle
驱动的位置

00:01:33.426 --> 00:01:35.326 A:middle
而通过在现代 GPU 上使用 Metal 2

00:01:35.326 --> 00:01:37.966 A:middle
你将可以创造新的算法

00:01:37.966 --> 00:01:40.316 A:middle
新的绘制技术

00:01:40.926 --> 00:01:43.276 A:middle
并获得完全独一无二的

00:01:43.276 --> 00:01:45.176 A:middle
体验

00:01:45.546 --> 00:01:46.366 A:middle
当然 说到体验

00:01:46.366 --> 00:01:49.096 A:middle
我们在 Metal 里

00:01:49.096 --> 00:01:50.306 A:middle
增加了很多新功能

00:01:50.306 --> 00:01:51.726 A:middle
同时我们还有其他三个会议

00:01:51.726 --> 00:01:52.746 A:middle
我非常希望大家能参加

00:01:53.586 --> 00:01:56.786 A:middle
Mac 在今年迎来了 VR 技术

00:01:56.786 --> 00:01:58.986 A:middle
通过新的 iMac  我们将

00:01:58.986 --> 00:02:01.486 A:middle
为你提供非常强大的 GPU

00:01:58.986 --> 00:02:01.486 A:middle
为你提供非常强大的 GPU

00:02:01.976 --> 00:02:04.056 A:middle
即将登陆 MacBook Pro 的

00:02:04.106 --> 00:02:05.646 A:middle
外部 GPU 也将给你同样

00:02:05.646 --> 00:02:06.006 A:middle
强大的功能

00:02:06.726 --> 00:02:09.166 A:middle
这些都能让你的用户和

00:02:09.515 --> 00:02:11.566 A:middle
你的内容创作者

00:02:11.566 --> 00:02:14.156 A:middle
获得前所未有的

00:02:14.156 --> 00:02:14.936 A:middle
VR 体验

00:02:15.576 --> 00:02:17.746 A:middle
明天的会议将向你展示

00:02:18.486 --> 00:02:22.136 A:middle
如何使用我们的

00:02:22.136 --> 00:02:23.876 A:middle
直接显示技术

00:02:23.876 --> 00:02:25.996 A:middle
来使你的内容快速并且

00:02:25.996 --> 00:02:26.846 A:middle
低延迟地到达 HMD

00:02:28.176 --> 00:02:29.906 A:middle
你将学到新的

00:02:29.906 --> 00:02:32.066 A:middle
为了 VR 制作的 Metal API 版和新的

00:02:32.066 --> 00:02:33.066 A:middle
工具版

00:02:35.856 --> 00:02:38.266 A:middle
机器学习正非常迅速地

00:02:38.266 --> 00:02:40.296 A:middle
在很多应用中成为

00:02:40.296 --> 00:02:42.076 A:middle
我们设备的

00:02:42.076 --> 00:02:42.976 A:middle
关键功能

00:02:42.976 --> 00:02:45.056 A:middle
你可以用通过 Metal 2

00:02:45.056 --> 00:02:47.786 A:middle
来使用 Metal 性能着色器

00:02:47.876 --> 00:02:49.726 A:middle
并利用 GPU 的能力

00:02:49.726 --> 00:02:53.446 A:middle
在测试中和

00:02:53.546 --> 00:02:54.536 A:middle
移动设备上进行机器学习

00:02:55.376 --> 00:02:56.786 A:middle
你可能正盯着

00:02:56.916 --> 00:02:58.256 A:middle
我身后的图片

00:02:58.256 --> 00:02:59.486 A:middle
在想 “这是怎么做到的？”

00:02:59.776 --> 00:03:01.316 A:middle
我们有一个会议

00:02:59.776 --> 00:03:01.316 A:middle
我们有一个会议

00:03:01.316 --> 00:03:03.776 A:middle
将在周四举行

00:03:03.776 --> 00:03:05.416 A:middle
从中你能学到这个以及

00:03:05.416 --> 00:03:07.256 A:middle
机器学习原语

00:03:07.256 --> 00:03:08.796 A:middle
也就是我们的

00:03:09.036 --> 00:03:10.966 A:middle
Metal 性能着色器里面的

00:03:10.966 --> 00:03:11.506 A:middle
图像处理原语

00:03:13.036 --> 00:03:15.576 A:middle
最后 在 Metal 2 引擎下

00:03:15.576 --> 00:03:17.566 A:middle
我们的工具已经取得了

00:03:17.566 --> 00:03:18.146 A:middle
重大的提升

00:03:18.256 --> 00:03:19.856 A:middle
你将可以快速的

00:03:19.856 --> 00:03:21.006 A:middle
对你的应用进行故障排查

00:03:21.556 --> 00:03:23.266 A:middle
你能更容易的发现问题

00:03:23.686 --> 00:03:26.796 A:middle
我们还将曝光一些东西

00:03:26.796 --> 00:03:28.226 A:middle
例如 GPU 性能计数器

00:03:28.226 --> 00:03:29.866 A:middle
以确保你能

00:03:29.866 --> 00:03:33.566 A:middle
找到你的热点

00:03:33.566 --> 00:03:36.126 A:middle
你的程序也将运行的更快

00:03:37.416 --> 00:03:39.786 A:middle
好了 我希望我已经使你们

00:03:40.056 --> 00:03:41.946 A:middle
为未来几天感到兴奋

00:03:41.946 --> 00:03:44.076 A:middle
现在我们回到

00:03:44.076 --> 00:03:45.336 A:middle
今天会议的

00:03:45.336 --> 00:03:45.866 A:middle
内容

00:03:51.426 --> 00:03:53.576 A:middle
我们将从参数缓冲器开始

00:03:53.576 --> 00:03:55.946 A:middle
这也可能是我们今年

00:03:55.996 --> 00:03:57.686 A:middle
在核心框架上增加的

00:03:57.686 --> 00:03:57.916 A:middle
最重要的内容

00:03:58.716 --> 00:04:00.756 A:middle
参数缓冲器能提供一个

00:03:58.716 --> 00:04:00.756 A:middle
参数缓冲器能提供一个

00:04:00.756 --> 00:04:03.426 A:middle
全新的高效方式来

00:04:03.426 --> 00:04:05.946 A:middle
配置缓冲器 纹理和

00:04:06.416 --> 00:04:07.986 A:middle
采样器  使你的应用能够使用

00:04:07.986 --> 00:04:11.356 A:middle
被释放出来的

00:04:11.356 --> 00:04:13.246 A:middle
可观的 CPU 资源

00:04:13.246 --> 00:04:15.026 A:middle
并能使 GPU

00:04:15.026 --> 00:04:16.366 A:middle
真正同时运行

00:04:16.366 --> 00:04:17.086 A:middle
全新的计划

00:04:18.196 --> 00:04:20.726 A:middle
下面我们来谈谈光栅顺序组

00:04:20.726 --> 00:04:22.966 A:middle
一种新的片段着色器

00:04:22.966 --> 00:04:24.516 A:middle
同步原语

00:04:25.006 --> 00:04:26.856 A:middle
它能让你

00:04:26.856 --> 00:04:28.566 A:middle
精确的控制

00:04:28.786 --> 00:04:30.426 A:middle
片段着色器接入公共存储器的顺序

00:04:30.426 --> 00:04:33.026 A:middle
使得你能够使用

00:04:33.026 --> 00:04:34.726 A:middle
例如

00:04:35.286 --> 00:04:37.186 A:middle
MacOS 上的可编程混合

00:04:37.246 --> 00:04:41.466 A:middle
或者体素化

00:04:41.516 --> 00:04:42.626 A:middle
顺序无关的半透明渲染

00:04:43.466 --> 00:04:44.866 A:middle
然后我们将话题转到

00:04:44.866 --> 00:04:46.656 A:middle
显示上来  我们将谈到

00:04:46.656 --> 00:04:48.396 A:middle
iPad 上全新的 ProMotion 显示器

00:04:48.396 --> 00:04:50.496 A:middle
以及如何使用 Metal

00:04:50.496 --> 00:04:51.526 A:middle
去运行它

00:04:51.526 --> 00:04:54.396 A:middle
我们也将简要重述

00:04:54.446 --> 00:04:57.376 A:middle
如何用最快的速度

00:04:57.376 --> 00:04:58.876 A:middle
以及最少的延迟

00:04:58.876 --> 00:05:02.606 A:middle
使你的内容

00:04:58.876 --> 00:05:02.606 A:middle
使你的内容

00:05:02.606 --> 00:05:04.046 A:middle
从渲染目标

00:05:04.046 --> 00:05:04.996 A:middle
传递到眼镜上

00:05:05.576 --> 00:05:07.686 A:middle
最后我们将以一个

00:05:08.106 --> 00:05:10.036 A:middle
关于所有其他

00:05:10.036 --> 00:05:12.316 A:middle
被我们加入到 iOS 和 MacOS 平台里

00:05:12.566 --> 00:05:15.436 A:middle
以配合 Metal 生态系统的 Metal 功能调查

00:05:15.786 --> 00:05:16.976 A:middle
结束今天的会议

00:05:22.336 --> 00:05:26.186 A:middle
好的 关于参数缓冲器

00:05:26.536 --> 00:05:28.556 A:middle
让我们来看看它们是什么

00:05:28.716 --> 00:05:29.266 A:middle
以及它们如何运作的

00:05:29.316 --> 00:05:30.806 A:middle
我将需要举个例子

00:05:30.806 --> 00:05:33.776 A:middle
让我们想象一个简单的材料

00:05:33.776 --> 00:05:36.166 A:middle
一个那些写过

00:05:36.166 --> 00:05:39.456 A:middle
3D 渲染程序的人

00:05:39.456 --> 00:05:40.046 A:middle
都会明白的材料

00:05:40.466 --> 00:05:42.326 A:middle
在你的材料里有

00:05:42.326 --> 00:05:44.936 A:middle
大量的数值常量

00:05:45.106 --> 00:05:46.236 A:middle
大量的纹理

00:05:46.236 --> 00:05:47.416 A:middle
以及多于每天两个的

00:05:47.466 --> 00:05:48.016 A:middle
汇编程序

00:05:48.686 --> 00:05:53.196 A:middle
而这就是你需要发送给

00:05:53.196 --> 00:05:54.726 A:middle
GPU 来

00:05:54.726 --> 00:05:56.056 A:middle
渲染你的原语的东西

00:05:56.516 --> 00:05:58.566 A:middle
纹理对象很有趣

00:05:59.456 --> 00:06:01.026 A:middle
因为他们

00:05:59.456 --> 00:06:01.026 A:middle
因为他们

00:06:01.166 --> 00:06:03.506 A:middle
不仅包含了纹理属性 例如

00:06:03.506 --> 00:06:06.626 A:middle
宽 高 甚至还有像素格式

00:06:06.626 --> 00:06:08.866 A:middle
它同时还包含了一个

00:06:08.866 --> 00:06:10.176 A:middle
容纳所有美丽像素的

00:06:10.176 --> 00:06:11.196 A:middle
内存的指针

00:06:11.196 --> 00:06:13.896 A:middle
不幸的是 我们今天的会议

00:06:13.896 --> 00:06:14.766 A:middle
对那些像素

00:06:14.766 --> 00:06:15.926 A:middle
不是很感兴趣

00:06:15.926 --> 00:06:18.636 A:middle
所以我们会放下它

00:06:18.636 --> 00:06:20.426 A:middle
而仅仅讨论乏味的

00:06:20.426 --> 00:06:20.916 A:middle
纹理状态

00:06:22.156 --> 00:06:24.456 A:middle
传统的参数模型

00:06:24.456 --> 00:06:26.566 A:middle
允许你将所有的

00:06:26.566 --> 00:06:29.106 A:middle
常量放在 Metal 缓存器中

00:06:29.106 --> 00:06:30.216 A:middle
然后我们创建这个

00:06:30.216 --> 00:06:32.126 A:middle
间接方式 这样你能轻松的

00:06:32.126 --> 00:06:33.846 A:middle
使用它 同时它还可以

00:06:33.846 --> 00:06:36.136 A:middle
在 GPU 未过滤的情况下

00:06:36.136 --> 00:06:37.926 A:middle
直接接入所有的数据

00:06:39.136 --> 00:06:41.166 A:middle
但是 当面对类似

00:06:41.166 --> 00:06:43.386 A:middle
纹理或者采样器时

00:06:43.386 --> 00:06:44.446 A:middle
你还是需要

00:06:44.446 --> 00:06:46.266 A:middle
通过一个 API

00:06:46.266 --> 00:06:47.686 A:middle
在你的渲染循环中

00:06:47.686 --> 00:06:50.066 A:middle
设置缓存器 所有的纹理

00:06:50.676 --> 00:06:52.146 A:middle
以及采样器 只有如此

00:06:52.146 --> 00:06:53.396 A:middle
你才能最终开始绘制工作

00:06:53.446 --> 00:06:55.676 A:middle
即使 Metal 已经

00:06:55.676 --> 00:06:57.676 A:middle
被高度优化了 这里还是存在

00:06:57.676 --> 00:06:59.336 A:middle
一小部分 API 代码

00:06:59.336 --> 00:07:00.286 A:middle
如果你将每一帧要渲染的对象数量

00:06:59.336 --> 00:07:00.286 A:middle
如果你将每一帧要渲染的对象数量

00:07:00.286 --> 00:07:02.766 A:middle
和它相乘

00:07:02.766 --> 00:07:04.046 A:middle
而事实上你确实需要

00:07:04.046 --> 00:07:06.156 A:middle
对每一帧都做这些工作

00:07:06.156 --> 00:07:09.026 A:middle
实际这在某种程度上限制了

00:07:09.026 --> 00:07:10.136 A:middle
你能放在屏幕上的

00:07:10.136 --> 00:07:13.826 A:middle
对象数量

00:07:13.826 --> 00:07:17.126 A:middle
通过使用参数缓冲器

00:07:17.126 --> 00:07:19.076 A:middle
我们希望拓展

00:07:19.486 --> 00:07:21.476 A:middle
这种对常量来说方便的间接取值

00:07:21.786 --> 00:07:23.026 A:middle
使它能应用于

00:07:23.026 --> 00:07:23.626 A:middle
所有的东西

00:07:23.626 --> 00:07:26.046 A:middle
事实上你可以将纹理状态

00:07:26.046 --> 00:07:28.226 A:middle
采样器以及指向另一个缓存器的指针

00:07:28.226 --> 00:07:29.696 A:middle
都放入一个参数缓存器中

00:07:29.696 --> 00:07:31.456 A:middle
这可以很大程度上

00:07:31.456 --> 00:07:34.036 A:middle
简化你的渲染流水线

00:07:34.036 --> 00:07:35.656 A:middle
因为突然间

00:07:35.656 --> 00:07:37.956 A:middle
你要做的唯一一件事

00:07:37.956 --> 00:07:40.386 A:middle
就是设置缓存器

00:07:41.426 --> 00:07:41.806 A:middle
然后绘制

00:07:42.016 --> 00:07:43.316 A:middle
你可能发现了

00:07:43.316 --> 00:07:46.196 A:middle
因为更少的 API 调用

00:07:46.196 --> 00:07:47.126 A:middle
你可以在屏幕上放置更多对象了

00:07:47.126 --> 00:07:49.996 A:middle
正如你将看到的那样

00:07:50.236 --> 00:07:51.726 A:middle
事实上 你可以使用参数缓存器

00:07:51.726 --> 00:07:54.006 A:middle
做到更好

00:07:54.656 --> 00:07:55.536 A:middle
好了 我们已经做了很多

00:07:55.536 --> 00:07:58.746 A:middle
基准测试 并在

00:07:58.746 --> 00:07:59.976 A:middle
我们的设备上运行了参数缓冲器

00:08:04.426 --> 00:08:05.886 A:middle
这是你将在 iPhone 7 上

00:08:05.886 --> 00:08:07.616 A:middle
看到的例子

00:08:08.196 --> 00:08:10.196 A:middle
使用传统的模型

00:08:10.526 --> 00:08:13.546 A:middle
一点都不令人惊讶

00:08:13.646 --> 00:08:16.366 A:middle
在你的绘制调用中

00:08:16.366 --> 00:08:17.756 A:middle
用到的资源会很庞大

00:08:18.246 --> 00:08:22.016 A:middle
而使用参数缓存器

00:08:22.016 --> 00:08:25.096 A:middle
这个代价会很低

00:08:25.096 --> 00:08:26.736 A:middle
甚至没有

00:08:26.736 --> 00:08:29.976 A:middle
这已经证明了

00:08:29.976 --> 00:08:31.436 A:middle
通过一个简单的着色器

00:08:31.436 --> 00:08:33.496 A:middle
两个资源

00:08:33.496 --> 00:08:35.956 A:middle
以及纹理和一个缓存器

00:08:36.126 --> 00:08:37.785 A:middle
或者两个纹理

00:08:37.785 --> 00:08:39.535 A:middle
你将获得 7 倍的

00:08:39.535 --> 00:08:40.135 A:middle
性能提升

00:08:40.135 --> 00:08:42.186 A:middle
有 8 个纹理或者 8 个资源

00:08:42.186 --> 00:08:45.146 A:middle
如果你希望能

00:08:45.146 --> 00:08:47.286 A:middle
将他们混合起来

00:08:47.286 --> 00:08:48.996 A:middle
你将在 iPhone 7 上获得 18 倍的性能提升

00:08:48.996 --> 00:08:50.966 A:middle
显然 他能在16 个资源的时候

00:08:50.966 --> 00:08:52.696 A:middle
运行的更好

00:08:55.106 --> 00:08:58.116 A:middle
好了 性能方面

00:08:58.116 --> 00:08:58.896 A:middle
我就讲到这里

00:08:58.986 --> 00:09:01.316 A:middle
接下来我将介绍一个新功能

00:08:58.986 --> 00:09:01.316 A:middle
接下来我将介绍一个新功能

00:09:01.316 --> 00:09:01.906 A:middle
新的使用计划

00:09:01.906 --> 00:09:04.486 A:middle
我们稍后会

00:09:04.486 --> 00:09:04.866 A:middle
谈到它

00:09:05.066 --> 00:09:06.456 A:middle
最后一个要点

00:09:06.456 --> 00:09:08.166 A:middle
最后一个我想讲到的

00:09:08.166 --> 00:09:09.616 A:middle
参数缓存器的好处

00:09:09.616 --> 00:09:10.376 A:middle
是使用的方便性

00:09:10.976 --> 00:09:13.856 A:middle
这是因为

00:09:13.856 --> 00:09:15.546 A:middle
参数缓存器实际上

00:09:15.716 --> 00:09:16.686 A:middle
是一个缓存器的扩展

00:09:16.686 --> 00:09:17.966 A:middle
所以你能

00:09:17.966 --> 00:09:19.406 A:middle
例如 提前把它准备好

00:09:19.406 --> 00:09:21.116 A:middle
比如当你的游戏正在缓冲

00:09:21.116 --> 00:09:23.426 A:middle
而你不需要

00:09:23.476 --> 00:09:25.216 A:middle
在你的渲染循环时再担心它

00:09:25.216 --> 00:09:26.386 A:middle
这将进一步

00:09:26.556 --> 00:09:27.836 A:middle
提升你的性能

00:09:28.786 --> 00:09:30.356 A:middle
或者你可以将它们

00:09:30.356 --> 00:09:31.606 A:middle
与一个传统的混合模型结合

00:09:31.606 --> 00:09:33.866 A:middle
比如在一个

00:09:34.066 --> 00:09:36.376 A:middle
单一的绘制调用中

00:09:36.376 --> 00:09:38.186 A:middle
这意味着你可以简单的

00:09:38.366 --> 00:09:39.746 A:middle
用我们的工具

00:09:39.746 --> 00:09:40.986 A:middle
来判断哪些是你应用里

00:09:41.256 --> 00:09:43.626 A:middle
代价最高的循环

00:09:43.626 --> 00:09:44.946 A:middle
你可以优化它

00:09:44.946 --> 00:09:46.526 A:middle
然后你可以在剩下的一年中处理余下的问题

00:09:46.526 --> 00:09:49.626 A:middle
在你有时间的时候

00:09:49.746 --> 00:09:52.936 A:middle
最后 参数缓存器

00:09:52.936 --> 00:09:55.246 A:middle
支持所有的

00:09:55.246 --> 00:09:55.786 A:middle
Metal 设备

00:09:55.786 --> 00:09:57.986 A:middle
所以 只要你使用了它

00:09:57.986 --> 00:09:59.356 A:middle
你会拥有它所有的性能

00:09:59.356 --> 00:10:00.956 A:middle
你也可以在所有的 Metal 设备上

00:09:59.356 --> 00:10:00.956 A:middle
你也可以在所有的 Metal 设备上

00:10:00.956 --> 00:10:02.556 A:middle
继续使用它

00:10:02.986 --> 00:10:04.076 A:middle
使用的方便性 事实上

00:10:04.076 --> 00:10:05.796 A:middle
也很好的应用在了

00:10:05.796 --> 00:10:06.426 A:middle
着色器上

00:10:06.426 --> 00:10:07.836 A:middle
我们将在本次会议中

00:10:07.836 --> 00:10:10.666 A:middle
谈到一点关于

00:10:10.666 --> 00:10:12.576 A:middle
着色器的内容

00:10:12.576 --> 00:10:14.806 A:middle
这是我在会议开始时给大家

00:10:14.806 --> 00:10:15.676 A:middle
提出的例子

00:10:16.666 --> 00:10:19.266 A:middle
你可以看到

00:10:19.266 --> 00:10:21.596 A:middle
采样器中的纹理是

00:10:21.596 --> 00:10:23.366 A:middle
结构的一部分

00:10:23.366 --> 00:10:24.746 A:middle
这也是你们要从这里学到的主要内容

00:10:25.296 --> 00:10:28.616 A:middle
那就是参数缓存器

00:10:28.616 --> 00:10:29.976 A:middle
只是一个在着色器里的结构

00:10:29.976 --> 00:10:31.316 A:middle
你可以使用处理器里的

00:10:31.686 --> 00:10:33.066 A:middle
所有语言

00:10:33.066 --> 00:10:35.266 A:middle
去创造嵌入结构

00:10:35.266 --> 00:10:38.856 A:middle
去组织你的数据 使用删除

00:10:38.856 --> 00:10:39.576 A:middle
或者指针

00:10:39.766 --> 00:10:40.976 A:middle
它能运行的很好

00:10:42.216 --> 00:10:44.486 A:middle
现在让我们看看

00:10:44.766 --> 00:10:46.216 A:middle
参数缓存器的三个主要的新功能

00:10:46.216 --> 00:10:47.586 A:middle
第一个就是

00:10:47.676 --> 00:10:48.946 A:middle
动态索引

00:10:50.276 --> 00:10:53.346 A:middle
一个非常好的例子

00:10:53.346 --> 00:10:53.826 A:middle
就是批量渲染

00:10:53.826 --> 00:10:56.056 A:middle
如果你最近玩了

00:10:56.056 --> 00:10:57.436 A:middle
一些开放世界游戏 你会看到

00:10:57.436 --> 00:11:00.686 A:middle
这些游戏试图渲染

00:10:57.436 --> 00:11:00.686 A:middle
这些游戏试图渲染

00:11:00.686 --> 00:11:02.506 A:middle
大量特殊的

00:11:02.986 --> 00:11:05.036 A:middle
不同角色 来创造一个

00:11:05.036 --> 00:11:07.546 A:middle
美丽的 拟真的

00:11:07.606 --> 00:11:08.166 A:middle
世界

00:11:08.696 --> 00:11:10.116 A:middle
事实上

00:11:10.116 --> 00:11:12.246 A:middle
如果你需要进行这么多绘制调用

00:11:12.246 --> 00:11:13.706 A:middle
是一件代价很高的事情

00:11:15.076 --> 00:11:16.936 A:middle
我们提到过 使用参数缓存器

00:11:16.936 --> 00:11:19.416 A:middle
我们可以将所有的

00:11:19.416 --> 00:11:20.876 A:middle
所需属性 比如

00:11:20.876 --> 00:11:22.096 A:middle
一个人物

00:11:22.096 --> 00:11:24.006 A:middle
放入一个单独的参数缓存器  绑定它

00:11:24.006 --> 00:11:25.566 A:middle
这可以节省所有的 CPU 性能

00:11:25.566 --> 00:11:27.686 A:middle
不过我们可以

00:11:27.686 --> 00:11:27.966 A:middle
做的更好

00:11:27.966 --> 00:11:30.246 A:middle
例如 我们可以

00:11:30.416 --> 00:11:32.236 A:middle
创建一个参数缓存器队列

00:11:32.546 --> 00:11:35.266 A:middle
其中每个元素代表一个

00:11:35.266 --> 00:11:35.726 A:middle
字符

00:11:36.306 --> 00:11:37.476 A:middle
然后 这会变得非常简单

00:11:37.476 --> 00:11:38.696 A:middle
因为你需要做的

00:11:38.696 --> 00:11:40.856 A:middle
就是设置这个大的缓存器

00:11:40.856 --> 00:11:44.016 A:middle
这是第一次的 API 调用

00:11:44.126 --> 00:11:46.046 A:middle
它可以处理单一的绘制调用实例

00:11:46.046 --> 00:11:47.646 A:middle
比如说 1000 个实例

00:11:47.646 --> 00:11:49.126 A:middle
因为我希望有 1000 个人物

00:11:49.126 --> 00:11:49.496 A:middle
显示在屏幕上

00:11:50.096 --> 00:11:51.186 A:middle
这是第二次 API 调用

00:11:51.256 --> 00:11:53.626 A:middle
完成之后

00:11:53.626 --> 00:11:54.176 A:middle
它就都在 GPU 上了

00:11:54.176 --> 00:11:55.576 A:middle
在顶点着色里

00:11:55.576 --> 00:11:57.426 A:middle
你可以用实例 ID 从队列中

00:11:57.426 --> 00:12:00.926 A:middle
选择正确的元素

00:11:57.426 --> 00:12:00.926 A:middle
选择正确的元素

00:12:00.926 --> 00:12:02.266 A:middle
获得人物并将他

00:12:02.266 --> 00:12:03.036 A:middle
放置在世界里需要他的地方

00:12:03.036 --> 00:12:04.496 A:middle
给他正确的姿势

00:12:04.496 --> 00:12:05.646 A:middle
假如是步行周期中间

00:12:05.646 --> 00:12:07.766 A:middle
在片段着色器中

00:12:07.766 --> 00:12:10.176 A:middle
你再一次使用

00:12:10.176 --> 00:12:12.146 A:middle
实例 ID 然后选择正确的材料

00:12:12.146 --> 00:12:13.516 A:middle
正确的发色来

00:12:13.516 --> 00:12:14.446 A:middle
完成这个人物的外貌

00:12:14.716 --> 00:12:17.056 A:middle
所以 我们能很快将

00:12:17.576 --> 00:12:19.916 A:middle
成千上万的绘制调用

00:12:19.916 --> 00:12:22.316 A:middle
变成单一的一次调用

00:12:22.636 --> 00:12:24.156 A:middle
而且它能在 CPU 中运行的更快

00:12:24.246 --> 00:12:25.386 A:middle
在 GPU 中也更快

00:12:26.036 --> 00:12:29.466 A:middle
在着色中

00:12:29.466 --> 00:12:30.036 A:middle
它看上去就是如此简单

00:12:31.166 --> 00:12:33.066 A:middle
很大程度上你的参数缓存器

00:12:33.066 --> 00:12:35.516 A:middle
成为了一队列的结构

00:12:36.966 --> 00:12:40.156 A:middle
你可以使用内置的实例 ID

00:12:40.156 --> 00:12:41.506 A:middle
来选择正确的元素

00:12:41.506 --> 00:12:42.856 A:middle
然后你可以 比如

00:12:42.856 --> 00:12:44.526 A:middle
选择指针 然后将它传递给你的

00:12:44.526 --> 00:12:46.176 A:middle
辅助方法或者任何

00:12:46.226 --> 00:12:49.176 A:middle
处理数据所需的方法

00:12:49.256 --> 00:12:51.496 A:middle
参数缓存器的第二个优秀功能

00:12:51.536 --> 00:12:53.206 A:middle
是 GPU 设置资源

00:12:53.806 --> 00:12:56.436 A:middle
的能力

00:12:56.436 --> 00:12:57.656 A:middle
事实上我们为它

00:12:57.656 --> 00:12:58.546 A:middle
创造了一个例子

00:12:59.486 --> 00:13:01.586 A:middle
我们创造了一个

00:12:59.486 --> 00:13:01.586 A:middle
我们创造了一个

00:13:01.586 --> 00:13:03.876 A:middle
完全在 GPU 上运行的粒子仿真

00:13:04.466 --> 00:13:06.036 A:middle
让我来告诉你我们怎么做的

00:13:06.036 --> 00:13:08.216 A:middle
我们将看到

00:13:08.216 --> 00:13:09.506 A:middle
我们一会儿将看到它运行

00:13:10.256 --> 00:13:11.836 A:middle
所以我们创建了一队

00:13:12.086 --> 00:13:13.316 A:middle
参数缓存器 他们中每一个

00:13:13.366 --> 00:13:16.296 A:middle
元素是一个单个的粒子

00:13:16.296 --> 00:13:17.756 A:middle
我猜你已经看到了

00:13:17.756 --> 00:13:19.196 A:middle
这里的趋势

00:13:19.766 --> 00:13:23.716 A:middle
随后我们的仿真核将

00:13:24.596 --> 00:13:26.696 A:middle
每线程的对一个粒子进行仿真

00:13:26.696 --> 00:13:28.796 A:middle
但是我们想要

00:13:28.796 --> 00:13:29.966 A:middle
走得更远

00:13:29.966 --> 00:13:32.906 A:middle
我们希望使 GPU

00:13:32.906 --> 00:13:36.416 A:middle
在核心中

00:13:36.416 --> 00:13:37.006 A:middle
也能创造粒子

00:13:37.006 --> 00:13:39.106 A:middle
所以 为了实现这个目标

00:13:39.106 --> 00:13:41.316 A:middle
给予它正确的材料

00:13:41.316 --> 00:13:43.016 A:middle
我们也有

00:13:43.076 --> 00:13:44.686 A:middle
我们希望粒子拥有的

00:13:44.686 --> 00:13:45.806 A:middle
所有不同材质的

00:13:45.806 --> 00:13:46.176 A:middle
参数缓存器

00:13:46.906 --> 00:13:48.896 A:middle
我们的仿真核

00:13:49.386 --> 00:13:50.866 A:middle
每一次你想在样本里做一个动作时

00:13:51.186 --> 00:13:53.826 A:middle
这个仿真核就会

00:13:53.826 --> 00:13:54.776 A:middle
观察环境

00:13:54.776 --> 00:13:57.066 A:middle
看看哪些是

00:13:57.806 --> 00:13:59.446 A:middle
正确的 合适的

00:13:59.446 --> 00:13:59.906 A:middle
材料

00:14:00.056 --> 00:14:01.596 A:middle
打个比方 如果你在

00:14:01.596 --> 00:14:04.126 A:middle
一片森林里 我们选择苔藓

00:14:04.286 --> 00:14:05.786 A:middle
作为一块岩石最正确合适的材料

00:14:05.786 --> 00:14:08.696 A:middle
然后将它复制到

00:14:09.126 --> 00:14:10.126 A:middle
粒子上

00:14:11.366 --> 00:14:13.226 A:middle
如果你在岩石上

00:14:13.226 --> 00:14:14.106 A:middle
我们选择岩石材料

00:14:14.106 --> 00:14:15.946 A:middle
在山上我们选择草

00:14:16.826 --> 00:14:18.506 A:middle
像这样 所有东西都在 GPU 上

00:14:18.506 --> 00:14:22.796 A:middle
它的着色真的就和

00:14:22.796 --> 00:14:24.206 A:middle
我描述的一样

00:14:24.206 --> 00:14:24.946 A:middle
那么简单

00:14:25.336 --> 00:14:26.756 A:middle
如果你想在你的 GPU 上

00:14:26.756 --> 00:14:30.156 A:middle
修改数据 你可以将它作为设备缓存器捆绑

00:14:30.156 --> 00:14:31.486 A:middle
然后像你以前一样

00:14:31.486 --> 00:14:33.866 A:middle
开始赋值

00:14:33.866 --> 00:14:34.986 A:middle
但是这次你要

00:14:34.986 --> 00:14:37.146 A:middle
复制纹理或者复制整个的

00:14:37.146 --> 00:14:38.676 A:middle
结构

00:14:38.676 --> 00:14:38.966 A:middle
这非常简单

00:14:40.106 --> 00:14:42.346 A:middle
我想介绍的

00:14:42.346 --> 00:14:44.576 A:middle
最后一个参数缓存器的

00:14:44.576 --> 00:14:47.116 A:middle
优秀功能是

00:14:47.116 --> 00:14:48.116 A:middle
它可以引用另外一个参数缓存器

00:14:48.116 --> 00:14:50.106 A:middle
这样你可以

00:14:50.106 --> 00:14:52.936 A:middle
创建一个可重复使用的

00:14:53.026 --> 00:14:55.816 A:middle
复杂对象层级

00:14:55.816 --> 00:14:59.076 A:middle
就像 C++ Swift

00:14:59.296 --> 00:15:00.046 A:middle
和 Objective-C 一样

00:14:59.296 --> 00:15:00.046 A:middle
和 Objective-C 一样

00:15:00.566 --> 00:15:03.676 A:middle
打个比方 在我们的渲染器的例子中

00:15:04.376 --> 00:15:06.496 A:middle
如果你有大量的对象

00:15:06.536 --> 00:15:09.076 A:middle
但你可能只有

00:15:09.726 --> 00:15:11.046 A:middle
很少的材料 你可以做的是

00:15:11.046 --> 00:15:14.556 A:middle
从每个对象引用材料

00:15:14.556 --> 00:15:15.866 A:middle
省下一些内存

00:15:15.866 --> 00:15:18.336 A:middle
或者你可以

00:15:18.336 --> 00:15:19.716 A:middle
将布景图构建成二进制树形网络

00:15:19.716 --> 00:15:21.566 A:middle
在这里 当你需要时 你可以指向

00:15:21.566 --> 00:15:25.186 A:middle
对象和树的节点

00:15:25.186 --> 00:15:26.436 A:middle
就像你原来

00:15:26.436 --> 00:15:27.526 A:middle
在 CPU 里使用一样

00:15:27.906 --> 00:15:29.396 A:middle
你也可以和 CPU 分享

00:15:29.396 --> 00:15:30.086 A:middle
这些数据

00:15:31.536 --> 00:15:32.846 A:middle
这些就是主要的功能

00:15:32.846 --> 00:15:34.526 A:middle
现在让我们来看看

00:15:34.526 --> 00:15:35.026 A:middle
支持矩阵

00:15:35.596 --> 00:15:37.036 A:middle
我们有两个层级

00:15:37.266 --> 00:15:39.796 A:middle
层级一是被所有

00:15:39.796 --> 00:15:42.466 A:middle
Metal 设备支持的

00:15:42.466 --> 00:15:43.386 A:middle
你也可以提升 CPU

00:15:43.386 --> 00:15:43.926 A:middle
的性能

00:15:43.926 --> 00:15:44.866 A:middle
你可以得到新的

00:15:44.866 --> 00:15:45.276 A:middle
计划语言

00:15:45.766 --> 00:15:49.096 A:middle
但是因为 GPU 的限制

00:15:49.096 --> 00:15:52.296 A:middle
这个层级

00:15:52.896 --> 00:15:54.526 A:middle
不能够像我之前提到的

00:15:55.016 --> 00:15:56.486 A:middle
通过利用 GPU 驱动

00:15:56.486 --> 00:15:57.346 A:middle
来使用用例

00:15:57.776 --> 00:15:58.916 A:middle
但是如果使用层级二

00:15:58.916 --> 00:16:00.586 A:middle
你可以得到所有的

00:15:58.916 --> 00:16:00.586 A:middle
你可以得到所有的

00:16:00.586 --> 00:16:02.396 A:middle
所有的新用例

00:16:02.396 --> 00:16:04.126 A:middle
我们也同样

00:16:04.126 --> 00:16:05.736 A:middle
大幅提高了你能接入的

00:16:05.736 --> 00:16:06.176 A:middle
资源

00:16:06.176 --> 00:16:07.416 A:middle
你的渲染器能接入

00:16:07.466 --> 00:16:10.406 A:middle
50 万的纹理和缓存器

00:16:10.406 --> 00:16:11.676 A:middle
让你能做这些

00:16:11.676 --> 00:16:12.806 A:middle
新的算法

00:16:13.696 --> 00:16:15.696 A:middle
尽管层级一在所有设备上

00:16:15.986 --> 00:16:18.526 A:middle
都被支持  层级二是

00:16:18.526 --> 00:16:19.826 A:middle
你需要查询得到的

00:16:20.306 --> 00:16:22.216 A:middle
但是不用担心 这个支持

00:16:22.216 --> 00:16:22.846 A:middle
非常广泛

00:16:23.556 --> 00:16:25.016 A:middle
所有拥有这三个 GPU 的 Mac

00:16:25.016 --> 00:16:26.166 A:middle
都有层级二

00:16:26.626 --> 00:16:28.436 A:middle
所有新的 MacBook Pro

00:16:28.436 --> 00:16:29.676 A:middle
最新的 MacBook 最后层级的 MacBook Pro

00:16:29.676 --> 00:16:31.586 A:middle
都有层级二

00:16:31.586 --> 00:16:33.316 A:middle
所以你大可以

00:16:33.416 --> 00:16:33.586 A:middle
玩得高兴

00:16:34.106 --> 00:16:35.546 A:middle
现在 让我们来看看

00:16:35.546 --> 00:16:36.136 A:middle
我承诺过给你们的样本

00:16:36.226 --> 00:16:39.116 A:middle
我们将展示三个视频

00:16:39.426 --> 00:16:41.416 A:middle
其中包含三个不同功能

00:16:41.986 --> 00:16:43.936 A:middle
这个被实时渲染的地形

00:16:44.136 --> 00:16:45.846 A:middle
有动态变化的材料

00:16:45.846 --> 00:16:48.346 A:middle
我们利用 GPU 在地形上

00:16:48.346 --> 00:16:50.616 A:middle
放置一些植物

00:16:50.616 --> 00:16:51.716 A:middle
来让它更有趣

00:16:52.116 --> 00:16:53.326 A:middle
我们也有这些我

00:16:53.326 --> 00:16:56.076 A:middle
之前提到过的漂亮的

00:16:56.076 --> 00:16:56.436 A:middle
粒子

00:16:56.656 --> 00:16:59.516 A:middle
所以 就像你看到的

00:17:00.006 --> 00:17:01.246 A:middle
我们在地形上绘制高度

00:17:01.246 --> 00:17:02.496 A:middle
我们可以改变地表侵蚀

00:17:02.496 --> 00:17:03.466 A:middle
随后材料也会

00:17:03.466 --> 00:17:04.326 A:middle
跟着变化

00:17:04.626 --> 00:17:05.796 A:middle
这就是参数缓存器优秀的地方

00:17:05.796 --> 00:17:08.425 A:middle
因为它们

00:17:08.425 --> 00:17:10.965 A:middle
能让我们创建一个大的

00:17:11.665 --> 00:17:13.506 A:middle
参数缓存器

00:17:13.506 --> 00:17:16.406 A:middle
所有的可用材料和层级都在里面

00:17:16.406 --> 00:17:18.455 A:middle
当我们在一个像素着色器中

00:17:18.455 --> 00:17:20.576 A:middle
渲染地形时

00:17:20.576 --> 00:17:21.736 A:middle
我们看到的是

00:17:22.076 --> 00:17:24.846 A:middle
地形的高度 坡度

00:17:25.116 --> 00:17:27.406 A:middle
有多少阳光到达特定的

00:17:27.606 --> 00:17:29.166 A:middle
像素 基于这些属性

00:17:29.166 --> 00:17:30.976 A:middle
和其他属性

00:17:30.976 --> 00:17:33.866 A:middle
我们能判断什么是用于

00:17:34.026 --> 00:17:35.446 A:middle
这个像素上的最好的

00:17:35.446 --> 00:17:36.466 A:middle
和最适合的材料

00:17:36.896 --> 00:17:38.046 A:middle
这些都是

00:17:38.046 --> 00:17:40.746 A:middle
实时发生的  在以前我们可能需要

00:17:40.746 --> 00:17:42.436 A:middle
在线下

00:17:42.436 --> 00:17:44.316 A:middle
将地形拆成小块

00:17:44.766 --> 00:17:47.466 A:middle
分析哪些小块

00:17:47.466 --> 00:17:49.206 A:middle
需要哪些纹理

00:17:49.206 --> 00:17:50.676 A:middle
以使它最优化

00:17:51.236 --> 00:17:53.166 A:middle
然后才能渲染它

00:17:53.166 --> 00:17:55.386 A:middle
所以我们将一个

00:17:55.456 --> 00:17:56.546 A:middle
预处理的步骤

00:17:56.546 --> 00:17:58.366 A:middle
一个繁重的非实时的

00:17:58.366 --> 00:18:00.496 A:middle
修改操作 变成了一个

00:17:58.366 --> 00:18:00.496 A:middle
修改操作 变成了一个

00:18:00.496 --> 00:18:02.226 A:middle
实时的 抱歉

00:18:02.286 --> 00:18:04.716 A:middle
不需要处理的

00:18:04.716 --> 00:18:05.626 A:middle
完全动态的步骤

00:18:08.976 --> 00:18:11.986 A:middle
我们在上面加上植被

00:18:12.296 --> 00:18:14.086 A:middle
你可以看到植被

00:18:14.086 --> 00:18:16.196 A:middle
也是环境敏感的

00:18:17.026 --> 00:18:18.766 A:middle
你看沙滩上的

00:18:18.766 --> 00:18:19.136 A:middle
棕榈树

00:18:19.136 --> 00:18:20.826 A:middle
你看山丘上

00:18:20.826 --> 00:18:21.816 A:middle
小小的苹果树

00:18:23.446 --> 00:18:25.536 A:middle
植被本身还是一个

00:18:25.536 --> 00:18:28.176 A:middle
非常传统的实例渲染

00:18:28.176 --> 00:18:29.776 A:middle
参数缓存器在这里

00:18:29.776 --> 00:18:32.396 A:middle
能做到的是

00:18:32.396 --> 00:18:34.086 A:middle
它使我们能将

00:18:34.416 --> 00:18:36.006 A:middle
所有的相同属性

00:18:36.006 --> 00:18:37.846 A:middle
分享给同样的地形材料

00:18:37.846 --> 00:18:39.646 A:middle
并在完全分离的

00:18:40.126 --> 00:18:41.486 A:middle
代码中间进行

00:18:41.486 --> 00:18:43.446 A:middle
同样的地形分析功能

00:18:43.676 --> 00:18:45.246 A:middle
当地形渲染器用

00:18:45.246 --> 00:18:47.326 A:middle
所有这些数据去渲染像素时

00:18:47.326 --> 00:18:48.796 A:middle
放置几何形状

00:18:48.796 --> 00:18:50.316 A:middle
和植被的电脑

00:18:50.686 --> 00:18:51.956 A:middle
事实上分析了相同的

00:18:51.956 --> 00:18:53.786 A:middle
材料以判断

00:18:53.786 --> 00:18:56.266 A:middle
最合适放置在指定地点上的

00:18:56.266 --> 00:18:57.026 A:middle
是哪一种树

00:18:57.486 --> 00:18:58.616 A:middle
这非常简单因为

00:18:58.616 --> 00:18:59.836 A:middle
每次我们在做改变的时候

00:19:00.166 --> 00:19:01.566 A:middle
我们的代码事实上没有任何变化

00:19:01.566 --> 00:19:02.686 A:middle
我们只是增加了新的

00:19:02.686 --> 00:19:04.516 A:middle
层级或者改变了我们的分析

00:19:04.516 --> 00:19:06.806 A:middle
功能  可能从前我们需要

00:19:06.806 --> 00:19:08.526 A:middle
在两个完全分离的

00:19:08.526 --> 00:19:10.226 A:middle
代码中间处理大概 70 个纹理

00:19:10.226 --> 00:19:11.776 A:middle
以使他们能

00:19:11.816 --> 00:19:17.036 A:middle
同步的运行

00:19:17.216 --> 00:19:19.406 A:middle
最后 我们有粒子

00:19:19.406 --> 00:19:22.226 A:middle
我希望你们注意到

00:19:22.226 --> 00:19:25.146 A:middle
他们已经找到了

00:19:25.146 --> 00:19:25.916 A:middle
地形的材料

00:19:26.876 --> 00:19:28.606 A:middle
我之前没有提到的是

00:19:28.606 --> 00:19:30.866 A:middle
这些全都是被

00:19:31.126 --> 00:19:32.816 A:middle
单个的绘制调用渲染的

00:19:32.816 --> 00:19:34.756 A:middle
我们这里使用单个的绘制调用

00:19:35.086 --> 00:19:38.006 A:middle
渲染了 16000 个粒子

00:19:38.006 --> 00:19:39.776 A:middle
这个过程中完全没有

00:19:39.816 --> 00:19:41.586 A:middle
CPU 的参与

00:19:42.406 --> 00:19:44.486 A:middle
而且粒子不只是有

00:19:44.826 --> 00:19:46.316 A:middle
特殊的材料 它们事实上

00:19:46.316 --> 00:19:47.486 A:middle
还有特殊的形状 因为

00:19:47.766 --> 00:19:48.876 A:middle
参数缓存器

00:19:48.936 --> 00:19:50.176 A:middle
允许你在每个

00:19:50.176 --> 00:19:52.166 A:middle
绘制调用里

00:19:52.166 --> 00:19:52.466 A:middle
改变你的顶点缓存

00:19:53.526 --> 00:19:56.076 A:middle
如果你试着不用

00:19:56.076 --> 00:19:58.466 A:middle
参数缓存器去处理它

00:19:58.466 --> 00:20:01.956 A:middle
我们需要创建一个

00:19:58.466 --> 00:20:01.956 A:middle
我们需要创建一个

00:20:01.956 --> 00:20:04.496 A:middle
复杂的控件

00:20:04.496 --> 00:20:06.856 A:middle
在负责模仿的 GPU 和

00:20:06.856 --> 00:20:08.036 A:middle
试图得到最佳

00:20:08.036 --> 00:20:09.866 A:middle
绘制调用组的 CPU 之间

00:20:09.866 --> 00:20:11.356 A:middle
来代表所有的这些变量

00:20:11.776 --> 00:20:13.396 A:middle
有了参数缓存器

00:20:13.396 --> 00:20:17.116 A:middle
这将变得非常非常简单

00:20:18.346 --> 00:20:21.706 A:middle
好了 看够了美丽的图片

00:20:22.296 --> 00:20:25.226 A:middle
让我们以一些

00:20:25.226 --> 00:20:28.406 A:middle
API 和一些实践例子

00:20:28.406 --> 00:20:29.716 A:middle
来结束我的部分

00:20:29.986 --> 00:20:33.426 A:middle
就像我提到的那样

00:20:33.426 --> 00:20:34.926 A:middle
参数缓存器是 Metal 缓存器的

00:20:34.926 --> 00:20:37.426 A:middle
延伸 这意味着

00:20:37.426 --> 00:20:39.286 A:middle
所有与缓存器有关的 API

00:20:39.286 --> 00:20:39.776 A:middle
都能运行

00:20:39.776 --> 00:20:40.946 A:middle
你可以找一个

00:20:40.946 --> 00:20:42.196 A:middle
参数缓存器 将它复制到

00:20:42.196 --> 00:20:43.456 A:middle
别的地方 你可以将它

00:20:43.456 --> 00:20:44.976 A:middle
放到 CPU 和 GPU 中间

00:20:45.826 --> 00:20:48.106 A:middle
尽管参数缓存器

00:20:48.106 --> 00:20:51.266 A:middle
看起来像渲染器在 GPU 里的结构

00:20:51.266 --> 00:20:54.796 A:middle
在 CPU 里你将用到

00:20:54.796 --> 00:20:56.816 A:middle
MTLArgumentEncoder 对象去

00:20:56.816 --> 00:20:57.716 A:middle
填充内容

00:20:58.676 --> 00:21:02.196 A:middle
这样的抽象能让 Metal

00:20:58.676 --> 00:21:02.196 A:middle
这样的抽象能让 Metal

00:21:02.196 --> 00:21:04.696 A:middle
为任何

00:21:05.186 --> 00:21:06.686 A:middle
实际运行的特定 GPU 上的

00:21:06.686 --> 00:21:08.316 A:middle
指定参数缓存器

00:21:08.316 --> 00:21:09.376 A:middle
创建一个最优化的

00:21:09.376 --> 00:21:09.716 A:middle
内存表征

00:21:10.206 --> 00:21:11.506 A:middle
这样你就可以得到最好的性能

00:21:11.896 --> 00:21:13.266 A:middle
作为一个研发者

00:21:13.266 --> 00:21:14.686 A:middle
它同时也将把你

00:21:15.646 --> 00:21:19.956 A:middle
从焦虑的细节中解放出来

00:21:19.956 --> 00:21:21.956 A:middle
例如 每个 GPU 如何体现

00:21:22.096 --> 00:21:22.966 A:middle
什么是纹理

00:21:22.966 --> 00:21:23.986 A:middle
它在存储器中应该放在什么位置

00:21:24.616 --> 00:21:26.746 A:middle
所有这些从平台到平台的变化

00:21:26.886 --> 00:21:28.776 A:middle
我们将它们隐藏在

00:21:28.776 --> 00:21:31.356 A:middle
简单的界面之间

00:21:31.356 --> 00:21:32.616 A:middle
这样你就可以写出非常简单的

00:21:32.616 --> 00:21:33.826 A:middle
有效率的应用了

00:21:34.506 --> 00:21:37.106 A:middle
希望你们没有

00:21:37.106 --> 00:21:38.006 A:middle
为了我前面提到的

00:21:38.006 --> 00:21:38.376 A:middle
编码器感到发愁

00:21:38.376 --> 00:21:39.886 A:middle
它真的用起来非常非常

00:21:39.886 --> 00:21:40.286 A:middle
简单

00:21:41.346 --> 00:21:42.396 A:middle
举个例子 如果你想要

00:21:42.396 --> 00:21:43.856 A:middle
为这个参数缓存器创建一个 参数编码器

00:21:43.856 --> 00:21:46.386 A:middle
你只需要

00:21:46.386 --> 00:21:49.886 A:middle
让你的 Metal 使用

00:21:49.886 --> 00:21:51.386 A:middle
参数缓存器功能

00:21:51.386 --> 00:21:53.736 A:middle
然后让 Metal 功能

00:21:53.736 --> 00:21:55.386 A:middle
调用编码器

00:21:55.386 --> 00:21:56.116 A:middle
就行了

00:21:56.116 --> 00:21:57.386 A:middle
这就是你要做的全部了

00:21:57.386 --> 00:21:59.526 A:middle
你得到一个对象 你开始

00:21:59.526 --> 00:22:02.066 A:middle
使用一个熟悉的纹理

00:21:59.526 --> 00:22:02.066 A:middle
使用一个熟悉的纹理

00:22:02.486 --> 00:22:04.586 A:middle
或者像你在

00:22:04.586 --> 00:22:05.906 A:middle
Metal 里使用

00:22:05.906 --> 00:22:08.666 A:middle
命令编码器一样

00:22:08.666 --> 00:22:09.016 A:middle
去填满 API

00:22:09.016 --> 00:22:11.916 A:middle
这对我提到过的

00:22:11.916 --> 00:22:15.116 A:middle
过渡和使用的便捷性

00:22:15.116 --> 00:22:15.846 A:middle
也有效

00:22:16.866 --> 00:22:18.736 A:middle
还有很多创建编码器的

00:22:18.736 --> 00:22:20.546 A:middle
方法

00:22:20.546 --> 00:22:21.786 A:middle
你可以使描述符

00:22:21.786 --> 00:22:22.686 A:middle
更精确 但是

00:22:22.686 --> 00:22:24.706 A:middle
如果你需要的话

00:22:24.876 --> 00:22:26.036 A:middle
你可能要去查找

00:22:26.036 --> 00:22:27.326 A:middle
参考资料

00:22:27.326 --> 00:22:28.956 A:middle
我们建议你

00:22:29.566 --> 00:22:30.866 A:middle
直接从着色器里获得

00:22:30.866 --> 00:22:31.386 A:middle
参数编码器

00:22:33.846 --> 00:22:36.706 A:middle
现在 有了这些交互

00:22:36.706 --> 00:22:38.396 A:middle
GPU 可以介入

00:22:38.396 --> 00:22:40.436 A:middle
修改参数缓存器

00:22:41.036 --> 00:22:42.286 A:middle
或者动态的索引

00:22:42.286 --> 00:22:44.356 A:middle
以及 50 万个纹理 如果这些全部混合起来

00:22:44.356 --> 00:22:47.526 A:middle
Metal 不太可能

00:22:47.906 --> 00:22:49.366 A:middle
去分辨

00:22:49.366 --> 00:22:50.466 A:middle
例如在渲染的时候

00:22:50.466 --> 00:22:52.226 A:middle
应该使用

00:22:52.226 --> 00:22:55.396 A:middle
哪些纹理和缓存器

00:22:55.396 --> 00:22:57.006 A:middle
但幸运的是 作为一个开发者

00:22:57.006 --> 00:22:58.916 A:middle
你对此有

00:22:58.916 --> 00:22:59.126 A:middle
很好的解决方法

00:22:59.126 --> 00:23:01.276 A:middle
所以我们要求你

00:22:59.126 --> 00:23:01.276 A:middle
所以我们要求你

00:23:01.276 --> 00:23:02.716 A:middle
对参数缓存器

00:23:02.716 --> 00:23:03.066 A:middle
尽量的熟悉

00:23:04.266 --> 00:23:05.776 A:middle
如果你在使用堆

00:23:06.646 --> 00:23:08.336 A:middle
当然你需要使用堆

00:23:08.336 --> 00:23:09.896 A:middle
在你的平台上获得

00:23:09.896 --> 00:23:12.506 A:middle
最佳的性能

00:23:12.506 --> 00:23:13.766 A:middle
以及组织数据的最佳方式

00:23:14.366 --> 00:23:15.586 A:middle
你唯一要做的事

00:23:15.586 --> 00:23:16.936 A:middle
就是告诉 Metal 你想要用一个堆

00:23:16.936 --> 00:23:18.886 A:middle
或者多个堆

00:23:18.886 --> 00:23:19.816 A:middle
这由你来决定

00:23:19.816 --> 00:23:22.356 A:middle
这保证了

00:23:22.356 --> 00:23:24.196 A:middle
在渲染循环中

00:23:24.196 --> 00:23:25.546 A:middle
纹理是

00:23:25.546 --> 00:23:27.696 A:middle
可用的

00:23:27.696 --> 00:23:29.066 A:middle
如果你想做到更具体

00:23:29.066 --> 00:23:30.076 A:middle
比如你想要

00:23:30.076 --> 00:23:32.586 A:middle
从一个内部的着色器

00:23:32.586 --> 00:23:34.556 A:middle
写入渲染目标 或者你

00:23:34.556 --> 00:23:35.626 A:middle
想从一个 dev 缓存器进行读取

00:23:35.626 --> 00:23:38.466 A:middle
你可以使用一个更加具体的 API

00:23:38.466 --> 00:23:40.466 A:middle
然后告诉 Metal

00:23:40.466 --> 00:23:42.476 A:middle
你想要用

00:23:43.476 --> 00:23:44.516 A:middle
特殊的方式改变资源

00:23:44.516 --> 00:23:46.076 A:middle
再一次的

00:23:46.076 --> 00:23:46.166 A:middle
就是这样简单

00:23:46.166 --> 00:23:46.836 A:middle
任何其他的事

00:23:46.836 --> 00:23:46.976 A:middle
你都不用做

00:23:50.506 --> 00:23:52.196 A:middle
让我们开始讲讲

00:23:52.196 --> 00:23:53.116 A:middle
几个最佳的实践例子

00:23:53.116 --> 00:23:55.986 A:middle
我想如果你了解 Metal

00:23:55.986 --> 00:23:58.076 A:middle
它和我们向你介绍的

00:23:58.076 --> 00:24:00.076 A:middle
Metal 缓存器

00:23:58.076 --> 00:24:00.076 A:middle
Metal 缓存器

00:24:00.076 --> 00:24:00.716 A:middle
十分相似

00:24:01.156 --> 00:24:02.586 A:middle
组织你的数据的最佳

00:24:02.586 --> 00:24:04.706 A:middle
方式是用 使用模式

00:24:04.706 --> 00:24:05.856 A:middle
你可能有很多属性

00:24:05.856 --> 00:24:08.406 A:middle
它们不会随着

00:24:08.686 --> 00:24:09.306 A:middle
每个帧进行变化

00:24:09.396 --> 00:24:10.536 A:middle
所以 将它们放入

00:24:10.536 --> 00:24:11.956 A:middle
参数缓存器 将它和所有的

00:24:11.956 --> 00:24:13.166 A:middle
对象共享

00:24:13.166 --> 00:24:13.536 A:middle
这样你将节省内存

00:24:14.286 --> 00:24:16.076 A:middle
同样的 另一方面

00:24:16.076 --> 00:24:17.756 A:middle
你可能有很多

00:24:17.756 --> 00:24:19.566 A:middle
属性 它们也确实随着每个

00:24:19.566 --> 00:24:21.106 A:middle
对象进行变化

00:24:21.106 --> 00:24:23.496 A:middle
你需要在每一帧下

00:24:23.496 --> 00:24:24.346 A:middle
对它们进行管理

00:24:24.346 --> 00:24:26.946 A:middle
对于这个问题 我认为

00:24:26.946 --> 00:24:28.066 A:middle
最好的方式是

00:24:28.066 --> 00:24:29.226 A:middle
将它们发给不同的参数缓存器

00:24:29.226 --> 00:24:30.396 A:middle
这样你可对它进行双重缓存

00:24:30.396 --> 00:24:32.056 A:middle
或者对任何你的管理计划

00:24:32.056 --> 00:24:34.786 A:middle
进行两次运行 你不用

00:24:34.786 --> 00:24:36.576 A:middle
通过其他的复制

00:24:36.576 --> 00:24:37.266 A:middle
来使所有的数据存在里面

00:24:37.706 --> 00:24:39.186 A:middle
然后你会有

00:24:39.186 --> 00:24:41.326 A:middle
一些完全不会

00:24:41.786 --> 00:24:43.286 A:middle
改变的参数缓存器

00:24:43.286 --> 00:24:44.456 A:middle
比如材料 或者

00:24:45.026 --> 00:24:46.816 A:middle
一些其他的属性

00:24:46.966 --> 00:24:49.296 A:middle
对于它们 你可以

00:24:49.296 --> 00:24:50.296 A:middle
在应用的初始化里创建它们

00:24:50.296 --> 00:24:53.826 A:middle
然后继续应用它们

00:24:54.026 --> 00:24:57.576 A:middle
和 Metal 缓存器相似

00:24:57.576 --> 00:24:59.816 A:middle
想想你的数据位置 以及

00:24:59.816 --> 00:25:01.566 A:middle
你将如何使用

00:24:59.816 --> 00:25:01.566 A:middle
你将如何使用

00:25:01.566 --> 00:25:01.916 A:middle
你的参数缓存器

00:25:02.246 --> 00:25:03.816 A:middle
假如你有

00:25:03.816 --> 00:25:06.076 A:middle
3 个纹理 接入了着色器

00:25:06.076 --> 00:25:08.776 A:middle
一个接一个

00:25:09.316 --> 00:25:10.836 A:middle
这时你能做的最好的事就是

00:25:10.836 --> 00:25:12.046 A:middle
在参数缓存器里将这些

00:25:12.046 --> 00:25:13.216 A:middle
纹理放置在相距很近的地方

00:25:13.216 --> 00:25:14.566 A:middle
这样你才能最大化

00:25:14.566 --> 00:25:16.466 A:middle
GPU 的缓存

00:25:17.376 --> 00:25:18.146 A:middle
就像我在会议开始时提到的

00:25:18.146 --> 00:25:20.736 A:middle
传统的参数模型

00:25:20.736 --> 00:25:23.716 A:middle
不能运用到每个地方

00:25:23.716 --> 00:25:25.576 A:middle
你要合理使用它

00:25:25.576 --> 00:25:26.776 A:middle
并且在能使情况更方便的时候

00:25:26.776 --> 00:25:28.116 A:middle
将它和参数缓存器

00:25:28.116 --> 00:25:28.786 A:middle
混合使用

00:25:29.296 --> 00:25:30.626 A:middle
比方说你需要对

00:25:30.626 --> 00:25:32.256 A:middle
改变每个对象的单个纹理

00:25:33.376 --> 00:25:35.786 A:middle
比如一个立方体的倒影

00:25:35.786 --> 00:25:37.606 A:middle
只为这个创建一个

00:25:37.606 --> 00:25:38.786 A:middle
参数缓存器然后

00:25:38.786 --> 00:25:40.096 A:middle
每一帧都上载它 可能是一个

00:25:40.096 --> 00:25:40.896 A:middle
系统开销

00:25:40.896 --> 00:25:42.826 A:middle
所以 在这里我们

00:25:42.826 --> 00:25:43.526 A:middle
使用传统的模型

00:25:43.656 --> 00:25:46.216 A:middle
这就是

00:25:46.216 --> 00:25:46.576 A:middle
关于参数缓存器的内容

00:25:46.576 --> 00:25:50.256 A:middle
我真诚的希望大家能使用

00:25:50.256 --> 00:25:52.516 A:middle
我们的新 API 并创新性的

00:25:52.806 --> 00:25:53.596 A:middle
使用它

00:25:54.136 --> 00:25:57.456 A:middle
请大家欢迎 Richard

00:25:57.546 --> 00:25:59.156 A:middle
他将为大家介绍

00:25:59.156 --> 00:25:59.506 A:middle
光栅顺序组

00:26:00.556 --> 00:26:02.556 A:middle
[ 掌声 ]

00:26:02.596 --> 00:26:03.016 A:middle
&gt;&gt; 谢谢

00:26:05.046 --> 00:26:06.686 A:middle
大家好 谢谢你 Michal

00:26:06.826 --> 00:26:07.776 A:middle
我将带领大家度过

00:26:07.776 --> 00:26:08.436 A:middle
下面的展示时间

00:26:08.436 --> 00:26:10.006 A:middle
让我们从

00:26:10.046 --> 00:26:10.936 A:middle
光栅顺序组开始

00:26:12.476 --> 00:26:14.196 A:middle
这是个新的功能

00:26:14.196 --> 00:26:16.636 A:middle
它能让你控制 GPU 的

00:26:16.726 --> 00:26:17.866 A:middle
线性调度

00:26:18.196 --> 00:26:19.686 A:middle
以有序的运行

00:26:19.746 --> 00:26:20.086 A:middle
片段射击线

00:26:20.686 --> 00:26:22.096 A:middle
这让重叠的片段射击线

00:26:22.096 --> 00:26:23.266 A:middle
能够通过存储器进行沟通

00:26:23.266 --> 00:26:24.876 A:middle
在这之前

00:26:24.876 --> 00:26:27.366 A:middle
大多数情况下

00:26:27.366 --> 00:26:28.286 A:middle
是实现不了的

00:26:28.646 --> 00:26:30.246 A:middle
所以 这开启了一个

00:26:30.246 --> 00:26:31.266 A:middle
全新的图像算法

00:26:31.266 --> 00:26:32.956 A:middle
如果只写入了对你的

00:26:33.156 --> 00:26:34.206 A:middle
帧缓存器的接口或者

00:26:34.206 --> 00:26:36.196 A:middle
接入设备存储器

00:26:36.196 --> 00:26:37.216 A:middle
这是很难实现的

00:26:38.476 --> 00:26:40.986 A:middle
举个例子

00:26:40.986 --> 00:26:42.226 A:middle
我们的关键应用中的一个

00:26:42.306 --> 00:26:43.156 A:middle
是顺序无关的

00:26:43.156 --> 00:26:43.926 A:middle
透明渲染

00:26:44.746 --> 00:26:46.106 A:middle
我们今天已经谈了很多

00:26:46.106 --> 00:26:47.476 A:middle
如何降低你的 Metal 应用

00:26:47.476 --> 00:26:48.596 A:middle
的 CPU 使用量的问题

00:26:48.596 --> 00:26:50.356 A:middle
这个功能

00:26:50.356 --> 00:26:52.006 A:middle
让你创建一个算法

00:26:52.476 --> 00:26:54.456 A:middle
以实现前后颠倒的混合

00:26:54.456 --> 00:26:56.116 A:middle
而不用为

00:26:56.116 --> 00:26:57.526 A:middle
三角水平筛选

00:26:57.526 --> 00:26:57.896 A:middle
而消耗 CPU

00:26:59.536 --> 00:27:00.736 A:middle
这里有很多针对

00:26:59.536 --> 00:27:00.736 A:middle
这里有很多针对

00:27:00.736 --> 00:27:01.836 A:middle
类似

00:27:01.836 --> 00:27:03.176 A:middle
双层的 G-buffer

00:27:03.396 --> 00:27:04.236 A:middle
的先进技术的研究

00:27:04.236 --> 00:27:05.946 A:middle
这种缓存器能

00:27:05.946 --> 00:27:07.596 A:middle
极大的提升 后处理结果 或者用

00:27:07.596 --> 00:27:08.846 A:middle
GPU 的光栅器

00:27:08.846 --> 00:27:10.196 A:middle
来像素化三角形网格

00:27:11.056 --> 00:27:12.716 A:middle
对于这些存储器

00:27:12.716 --> 00:27:13.826 A:middle
的前端接口

00:27:13.826 --> 00:27:15.336 A:middle
在他们通往高效应用的路上

00:27:15.336 --> 00:27:16.516 A:middle
还有很大的阻碍

00:27:17.296 --> 00:27:18.976 A:middle
可能对于这个功能而言

00:27:18.976 --> 00:27:20.566 A:middle
最简单最通俗的应用

00:27:20.566 --> 00:27:21.836 A:middle
是执行

00:27:21.836 --> 00:27:22.776 A:middle
定制混合方程

00:27:23.656 --> 00:27:25.076 A:middle
iOS 的硬件能很自然的

00:27:25.076 --> 00:27:27.336 A:middle
支持这样做

00:27:27.336 --> 00:27:29.406 A:middle
但是

00:27:29.406 --> 00:27:31.066 A:middle
这不是传统的台式机

00:27:31.066 --> 00:27:31.686 A:middle
的硬件能够做到的

00:27:32.656 --> 00:27:33.906 A:middle
所以我们将定制混合

00:27:33.906 --> 00:27:34.986 A:middle
作为一个范例应用

00:27:34.986 --> 00:27:36.076 A:middle
来介绍

00:27:36.076 --> 00:27:36.346 A:middle
这个功能

00:27:38.076 --> 00:27:40.086 A:middle
三角混合的经典例子

00:27:40.126 --> 00:27:41.316 A:middle
是一个三角在

00:27:41.316 --> 00:27:41.836 A:middle
另一个之上

00:27:42.776 --> 00:27:45.036 A:middle
几乎所有现代的 GPU API

00:27:45.036 --> 00:27:46.386 A:middle
都能保证在绘制调用命令中

00:27:46.386 --> 00:27:47.426 A:middle
可以进行混合

00:27:47.566 --> 00:27:48.856 A:middle
它能证明

00:27:48.926 --> 00:27:50.416 A:middle
这个简便的

00:27:50.416 --> 00:27:50.946 A:middle
串行执行的假想

00:27:51.796 --> 00:27:53.376 A:middle
但是 事实上在幕后

00:27:53.376 --> 00:27:54.586 A:middle
发生的事是

00:27:54.676 --> 00:27:56.026 A:middle
GPU 硬件是高度并行的

00:27:56.026 --> 00:27:57.056 A:middle
它将

00:27:57.056 --> 00:27:58.256 A:middle
同时运行多个线程

00:27:58.836 --> 00:28:00.296 A:middle
只有这个固定功能的

00:27:58.836 --> 00:28:00.296 A:middle
只有这个固定功能的

00:28:00.296 --> 00:28:01.786 A:middle
混合步骤最后能

00:28:01.786 --> 00:28:03.046 A:middle
延迟到所有东西

00:28:03.046 --> 00:28:05.776 A:middle
都重新有序排列之后

00:28:05.776 --> 00:28:06.876 A:middle
在混合步骤之前

00:28:06.876 --> 00:28:08.906 A:middle
有一个隐式等待

00:28:10.476 --> 00:28:12.686 A:middle
事情可能会随着顺序改变

00:28:12.686 --> 00:28:13.616 A:middle
如果我们不是需要在

00:28:13.616 --> 00:28:14.766 A:middle
片段射击的最后

00:28:14.766 --> 00:28:16.326 A:middle
将事情排序 而是

00:28:16.416 --> 00:28:18.066 A:middle
在正中间 因为如果这样

00:28:18.066 --> 00:28:20.156 A:middle
三角一号想要在存储器里

00:28:20.156 --> 00:28:21.316 A:middle
写东西 三角二号

00:28:21.316 --> 00:28:22.596 A:middle
可以进行

00:28:22.596 --> 00:28:23.026 A:middle
读取

00:28:23.306 --> 00:28:25.016 A:middle
如果我们希望三角二号

00:28:25.016 --> 00:28:26.236 A:middle
能够在其上增加 以及

00:28:26.236 --> 00:28:28.026 A:middle
自定义三角一号的数据

00:28:28.026 --> 00:28:28.906 A:middle
我们需要回到那个排序

00:28:29.646 --> 00:28:32.366 A:middle
这基本上就是

00:28:32.366 --> 00:28:33.576 A:middle
光栅顺序组可以提供的功能

00:28:34.706 --> 00:28:37.116 A:middle
现在我要讲到

00:28:37.206 --> 00:28:38.156 A:middle
着色器代码的例子

00:28:39.806 --> 00:28:41.116 A:middle
如果我想要执行

00:28:41.116 --> 00:28:42.466 A:middle
自定义的混合 一个无效

00:28:42.636 --> 00:28:44.456 A:middle
初期的尝试

00:28:44.456 --> 00:28:45.726 A:middle
将会替换我经典的

00:28:45.726 --> 00:28:46.696 A:middle
图像帧缓存器

00:28:46.696 --> 00:28:47.996 A:middle
为一个读写纹理

00:28:47.996 --> 00:28:49.696 A:middle
它会直接对这个纹理

00:28:49.696 --> 00:28:50.636 A:middle
执行渲染

00:28:50.636 --> 00:28:50.956 A:middle
和混合

00:28:51.776 --> 00:28:53.976 A:middle
当然如果我混合的线程

00:28:53.976 --> 00:28:55.206 A:middle
还没有执行

00:28:55.206 --> 00:28:56.416 A:middle
或者正在执行

00:28:56.416 --> 00:28:59.066 A:middle
这整个

00:28:59.166 --> 00:29:00.596 A:middle
修改编写顺序

00:28:59.166 --> 00:29:00.596 A:middle
修改编写顺序

00:29:00.596 --> 00:29:01.546 A:middle
会创建一个竞争条件

00:29:02.076 --> 00:29:03.876 A:middle
所以我们如何使用光栅顺序组

00:29:03.876 --> 00:29:05.146 A:middle
去修复它呢

00:29:05.316 --> 00:29:07.416 A:middle
这非常非常简单

00:29:08.626 --> 00:29:10.146 A:middle
我要做的就是

00:29:10.276 --> 00:29:12.996 A:middle
在有冲突访问的存储器上

00:29:12.996 --> 00:29:14.086 A:middle
添加一个新的属性

00:29:14.866 --> 00:29:16.906 A:middle
这时 编译程序和硬件

00:29:16.906 --> 00:29:17.636 A:middle
会开始

00:29:17.636 --> 00:29:18.876 A:middle
合作

00:29:18.876 --> 00:29:20.616 A:middle
使整个一系列的着色器

00:29:20.866 --> 00:29:21.806 A:middle
接入存储器

00:29:21.806 --> 00:29:22.996 A:middle
从一开始

00:29:22.996 --> 00:29:24.176 A:middle
到最后全部接入

00:29:24.176 --> 00:29:25.386 A:middle
然后在屏幕后面将它

00:29:25.386 --> 00:29:26.366 A:middle
转变成一个

00:29:26.366 --> 00:29:26.836 A:middle
临界区

00:29:28.806 --> 00:29:29.826 A:middle
你也可以将

00:29:29.826 --> 00:29:31.296 A:middle
这个属性应用于普通的

00:29:31.296 --> 00:29:33.846 A:middle
设备存储器指针上

00:29:34.536 --> 00:29:34.886 A:middle
而不仅仅在纹理上

00:29:34.886 --> 00:29:37.606 A:middle
所以通过这样做 我们得到了

00:29:37.606 --> 00:29:38.536 A:middle
我们想要的线性调度

00:29:39.216 --> 00:29:40.406 A:middle
线程一将继续运行

00:29:40.406 --> 00:29:42.116 A:middle
和写入内存 而线程二号

00:29:42.116 --> 00:29:43.526 A:middle
将停止 直到

00:29:43.526 --> 00:29:46.046 A:middle
线程一的写入完成

00:29:46.046 --> 00:29:47.916 A:middle
并给我们一个对

00:29:47.916 --> 00:29:51.576 A:middle
存储器的几乎无冲突接入

00:29:51.926 --> 00:29:53.096 A:middle
有一个

00:29:53.096 --> 00:29:54.106 A:middle
非常重要的话题

00:29:54.106 --> 00:29:56.016 A:middle
线程是

00:29:56.016 --> 00:29:57.266 A:middle
相互同步的

00:29:57.706 --> 00:29:59.656 A:middle
当然 GPU 硬件

00:29:59.656 --> 00:30:00.486 A:middle
将要运行不止两个

00:29:59.656 --> 00:30:00.486 A:middle
将要运行不止两个

00:30:00.486 --> 00:30:02.296 A:middle
而是同时运行

00:30:02.296 --> 00:30:05.146 A:middle
成千上万个线程

00:30:05.246 --> 00:30:06.396 A:middle
事实上它可能

00:30:06.436 --> 00:30:07.746 A:middle
从这些三角中

00:30:07.746 --> 00:30:09.136 A:middle
同时运行

00:30:09.616 --> 00:30:12.056 A:middle
所以 所有这些成千上万的

00:30:12.056 --> 00:30:12.816 A:middle
线程

00:30:12.816 --> 00:30:13.966 A:middle
哪个是彼此

00:30:13.966 --> 00:30:14.176 A:middle
同步的

00:30:15.836 --> 00:30:17.786 A:middle
我在这里高亮了像素

00:30:17.786 --> 00:30:18.986 A:middle
因为这是这个问题的

00:30:18.986 --> 00:30:19.586 A:middle
答案

00:30:20.356 --> 00:30:21.876 A:middle
你 这个功能

00:30:21.876 --> 00:30:22.846 A:middle
只能和其他线程同步

00:30:22.846 --> 00:30:23.986 A:middle
即那些当下与你的

00:30:23.986 --> 00:30:25.526 A:middle
片段射击线程重叠的

00:30:25.526 --> 00:30:27.516 A:middle
那些线程

00:30:27.596 --> 00:30:29.106 A:middle
对准同样的帧缓存的

00:30:29.106 --> 00:30:31.146 A:middle
xy 位置的线程  对准同样的

00:30:31.146 --> 00:30:32.886 A:middle
多样本的位置的线程

00:30:33.196 --> 00:30:34.306 A:middle
对准同样的

00:30:34.306 --> 00:30:34.786 A:middle
渲染目标指数的线程

00:30:36.726 --> 00:30:37.776 A:middle
如果我希望

00:30:37.776 --> 00:30:39.096 A:middle
它没有具体提供

00:30:39.136 --> 00:30:40.756 A:middle
任何的保证

00:30:40.756 --> 00:30:41.836 A:middle
让你能安全的

00:30:41.836 --> 00:30:43.376 A:middle
由相邻像素写入的

00:30:43.376 --> 00:30:44.276 A:middle
内存

00:30:45.366 --> 00:30:46.816 A:middle
如果你的确需要这样的

00:30:46.816 --> 00:30:48.496 A:middle
区域或者影响区域

00:30:48.496 --> 00:30:49.726 A:middle
这样的算法

00:30:50.096 --> 00:30:51.156 A:middle
你就需要回去使用

00:30:51.156 --> 00:30:52.326 A:middle
绘制调用之间的完整内存屏障

00:30:52.356 --> 00:30:53.736 A:middle
或者绘制调用或

00:30:53.736 --> 00:30:54.916 A:middle
渲染通道之间的

00:30:54.916 --> 00:30:55.666 A:middle
完整 API 屏障

00:30:56.376 --> 00:30:57.846 A:middle
但是这会导致更加高的性能代价

00:30:57.846 --> 00:30:59.656 A:middle
它也不能在

00:30:59.656 --> 00:31:00.876 A:middle
你的三角与单个的

00:30:59.656 --> 00:31:00.876 A:middle
你的三角与单个的

00:31:00.876 --> 00:31:02.236 A:middle
绘制调用重叠时

00:31:02.236 --> 00:31:02.696 A:middle
使用

00:31:03.336 --> 00:31:05.256 A:middle
但是对于这些常用算法

00:31:05.256 --> 00:31:06.806 A:middle
你只需要重叠

00:31:06.806 --> 00:31:08.206 A:middle
只需要同步

00:31:08.836 --> 00:31:09.976 A:middle
光栅顺序组能在

00:31:09.976 --> 00:31:11.286 A:middle
大幅减少性能代价的情况下

00:31:11.286 --> 00:31:13.866 A:middle
完成任务

00:31:13.866 --> 00:31:15.486 A:middle
这是很简单的

00:31:15.676 --> 00:31:16.716 A:middle
对于这个问题  这真的是

00:31:16.716 --> 00:31:17.356 A:middle
我要说的全部了

00:31:17.396 --> 00:31:19.546 A:middle
光栅顺序组让你

00:31:19.546 --> 00:31:21.246 A:middle
高效的等待重叠

00:31:21.516 --> 00:31:24.046 A:middle
并且只让重叠的线程来

00:31:24.046 --> 00:31:25.136 A:middle
结束它们对存储器的访问

00:31:25.806 --> 00:31:27.586 A:middle
这能让

00:31:27.586 --> 00:31:28.736 A:middle
之前的一部分

00:31:28.736 --> 00:31:30.026 A:middle
太没有效率的 GPU 算法

00:31:30.026 --> 00:31:31.296 A:middle
在 GPU 硬件上被很好的使用

00:31:33.516 --> 00:31:35.766 A:middle
着色器中间线程的

00:31:35.766 --> 00:31:37.076 A:middle
总结是最新的

00:31:37.076 --> 00:31:38.556 A:middle
GPU 硬件的功能

00:31:38.556 --> 00:31:39.286 A:middle
你真的需要运行它来

00:31:39.286 --> 00:31:40.426 A:middle
试试看

00:31:41.106 --> 00:31:42.446 A:middle
特别的是

00:31:42.446 --> 00:31:43.896 A:middle
它被最新的 这一周刚发布的

00:31:43.896 --> 00:31:45.256 A:middle
AMD Vega GPU 支持 并且

00:31:45.256 --> 00:31:46.356 A:middle
也被过去几年的 Intel GPU

00:31:46.356 --> 00:31:47.216 A:middle
所支持

00:31:49.136 --> 00:31:50.196 A:middle
这就要提到

00:31:50.196 --> 00:31:51.286 A:middle
第二个功能 那就是

00:31:51.286 --> 00:31:52.616 A:middle
新的 iPad Pro 的 ProMotion

00:31:52.616 --> 00:31:52.966 A:middle
显示器

00:32:01.056 --> 00:32:02.486 A:middle
ProMotion 对

00:32:02.616 --> 00:32:04.006 A:middle
图形和游戏开发者来说

00:32:04.006 --> 00:32:05.186 A:middle
是一个很优秀的功能

00:32:05.186 --> 00:32:06.226 A:middle
我非常想向大家展示

00:32:06.226 --> 00:32:07.626 A:middle
我能用它干什么

00:32:07.946 --> 00:32:10.466 A:middle
这是第一个序列

00:32:10.466 --> 00:32:11.606 A:middle
的时间线图

00:32:11.606 --> 00:32:13.946 A:middle
我将向你们展示

00:32:13.946 --> 00:32:15.606 A:middle
它展示了当 GPU 开始和结束

00:32:15.606 --> 00:32:16.916 A:middle
制作帧 以及当

00:32:16.916 --> 00:32:18.056 A:middle
同样的帧

00:32:18.056 --> 00:32:19.256 A:middle
最终到达眼镜 使用户能够看到

00:32:19.256 --> 00:32:19.526 A:middle
的时间

00:32:20.646 --> 00:32:22.116 A:middle
ProMotion 做的第一件也是最明显的事

00:32:22.116 --> 00:32:23.356 A:middle
是使我们现在能

00:32:23.356 --> 00:32:25.146 A:middle
以每秒 120 帧

00:32:25.146 --> 00:32:25.556 A:middle
进行渲染

00:32:27.316 --> 00:32:28.896 A:middle
这对任何要求

00:32:28.896 --> 00:32:29.896 A:middle
高速动画制作的东西

00:32:29.896 --> 00:32:31.616 A:middle
对任何要求

00:32:31.616 --> 00:32:32.796 A:middle
严苛延迟的东西

00:32:32.796 --> 00:32:34.096 A:middle
例如对用户触摸的追踪或者铅笔输入

00:32:34.096 --> 00:32:34.756 A:middle
都非常好用

00:32:35.576 --> 00:32:37.876 A:middle
它确实有很多抓取

00:32:37.876 --> 00:32:40.336 A:middle
对于每个帧 你当然只有

00:32:40.336 --> 00:32:42.146 A:middle
一半的 CPU 和 GPU 时间能够用

00:32:42.146 --> 00:32:43.596 A:middle
所以你需要

00:32:43.596 --> 00:32:44.356 A:middle
花很多精力去

00:32:44.356 --> 00:32:46.196 A:middle
优化它

00:32:46.196 --> 00:32:47.276 A:middle
这也会增加整个系统的

00:32:47.276 --> 00:32:47.836 A:middle
能量消耗

00:32:48.816 --> 00:32:49.546 A:middle
但是如果你得到了正确的内容

00:32:49.546 --> 00:32:51.506 A:middle
在它起作用的地方

00:32:51.506 --> 00:32:52.686 A:middle
它会回报在

00:32:52.686 --> 00:32:53.576 A:middle
用户体验上

00:32:55.006 --> 00:32:56.566 A:middle
但是 ProMotion 做到的

00:32:56.566 --> 00:32:58.096 A:middle
每秒渲染 120 帧

00:32:58.096 --> 00:32:58.436 A:middle
还要多

00:32:59.176 --> 00:33:01.626 A:middle
它同样为

00:32:59.176 --> 00:33:01.626 A:middle
它同样为

00:33:01.626 --> 00:33:03.496 A:middle
何时调换下一个图像到眼镜上

00:33:03.496 --> 00:33:04.546 A:middle
提供更多的

00:33:04.546 --> 00:33:05.016 A:middle
灵活性

00:33:05.726 --> 00:33:07.776 A:middle
我们没有限制 每秒渲染 120 帧

00:33:07.776 --> 00:33:09.906 A:middle
30 帧或者 60 帧

00:33:10.486 --> 00:33:12.816 A:middle
当你的应用执行

00:33:12.816 --> 00:33:14.056 A:middle
上下移动时

00:33:14.056 --> 00:33:15.446 A:middle
相比于

00:33:15.716 --> 00:33:16.756 A:middle
固定帧率的显示器

00:33:16.756 --> 00:33:17.166 A:middle
ProMotion 表现的更好

00:33:18.376 --> 00:33:21.186 A:middle
举个例子 我这里有

00:33:21.226 --> 00:33:22.586 A:middle
一个时间线图 它有点

00:33:22.586 --> 00:33:23.926 A:middle
你懂的

00:33:23.926 --> 00:33:24.986 A:middle
只是为了

00:33:24.986 --> 00:33:26.356 A:middle
达到每秒 60 帧消耗了太多 GPU

00:33:26.516 --> 00:33:27.226 A:middle
你知道他们

00:33:27.226 --> 00:33:28.906 A:middle
每 21 毫秒制作一个帧

00:33:28.906 --> 00:33:30.366 A:middle
或者说 1 秒制作

00:33:30.366 --> 00:33:30.836 A:middle
48 帧

00:33:31.576 --> 00:33:33.466 A:middle
GPU 很乐意这样做

00:33:33.466 --> 00:33:35.526 A:middle
但是在显示器这一边

00:33:35.526 --> 00:33:37.076 A:middle
我们只能每 16 毫秒刷新一次

00:33:37.076 --> 00:33:38.176 A:middle
最后我们只能得到

00:33:38.176 --> 00:33:38.976 A:middle
一个跳跃模式

00:33:39.046 --> 00:33:40.126 A:middle
这种不顺畅就使得

00:33:40.126 --> 00:33:41.866 A:middle
用户在眼镜上感觉到

00:33:41.866 --> 00:33:42.916 A:middle
有些帧

00:33:42.916 --> 00:33:43.356 A:middle
比其他的要慢得多

00:33:44.056 --> 00:33:47.006 A:middle
这一点也不好

00:33:47.306 --> 00:33:48.866 A:middle
基本上全世界

00:33:48.866 --> 00:33:49.846 A:middle
在这种情况下通用的做法

00:33:49.846 --> 00:33:50.586 A:middle
就是

00:33:50.586 --> 00:33:51.976 A:middle
人为的将帧率

00:33:51.976 --> 00:33:53.776 A:middle
降低到

00:33:53.776 --> 00:33:56.336 A:middle
每秒 30 帧

00:33:56.336 --> 00:33:57.686 A:middle
他们基本上是

00:33:57.686 --> 00:33:59.036 A:middle
将峰顶的帧率交换出去

00:33:59.036 --> 00:33:59.926 A:middle
以换得一定程度的

00:33:59.926 --> 00:34:00.556 A:middle
连续性

00:33:59.926 --> 00:34:00.556 A:middle
连续性

00:34:02.176 --> 00:34:04.146 A:middle
ProMotion 在这里做的好很多

00:34:04.616 --> 00:34:05.636 A:middle
如果我用

00:34:05.636 --> 00:34:06.596 A:middle
相同的应用

00:34:06.596 --> 00:34:09.126 A:middle
将它移动到一个 ProMotion 显示器上

00:34:09.126 --> 00:34:09.755 A:middle
它会对我们的时间线造成这样的影响

00:34:10.826 --> 00:34:12.036 A:middle
现在 我们

00:34:12.036 --> 00:34:13.596 A:middle
每 4 毫秒有了一个刷新点

00:34:13.596 --> 00:34:14.356 A:middle
而不是每 16 毫秒

00:34:15.266 --> 00:34:16.646 A:middle
我们赚得了时间

00:34:16.866 --> 00:34:18.286 A:middle
尽管 GPU 做着

00:34:18.286 --> 00:34:19.286 A:middle
和以前一样的工作

00:34:19.906 --> 00:34:21.976 A:middle
现在这个显示器

00:34:21.976 --> 00:34:23.626 A:middle
持续的

00:34:23.626 --> 00:34:24.136 A:middle
每秒显示 48 帧

00:34:24.985 --> 00:34:26.466 A:middle
用户现在既能

00:34:26.466 --> 00:34:28.176 A:middle
有最好的帧率

00:34:28.176 --> 00:34:30.156 A:middle
又能体验最佳的

00:34:30.156 --> 00:34:30.545 A:middle
持续性

00:34:31.186 --> 00:34:32.116 A:middle
我们以前做的交换

00:34:32.116 --> 00:34:33.056 A:middle
已经完全不需要了

00:34:34.246 --> 00:34:37.096 A:middle
此外 第二个例子是

00:34:37.096 --> 00:34:38.996 A:middle
这次 应用想要

00:34:38.996 --> 00:34:41.295 A:middle
制作每秒 60 帧

00:34:41.295 --> 00:34:42.936 A:middle
但是一帧运行的时间

00:34:42.936 --> 00:34:44.666 A:middle
稍微久了一点

00:34:44.666 --> 00:34:48.295 A:middle
我们做过了最后期限

00:34:48.295 --> 00:34:49.886 A:middle
在一个固定帧率的显示器上

00:34:49.886 --> 00:34:50.826 A:middle
在显示器这一边

00:34:50.826 --> 00:34:51.856 A:middle
我们可能会运用

00:34:51.856 --> 00:34:53.126 A:middle
与之前看到的相同的模式

00:34:54.585 --> 00:34:56.416 A:middle
ProMotion 同样可以修复这个问题

00:34:57.576 --> 00:34:58.626 A:middle
一号帧一旦在眼镜上

00:34:58.626 --> 00:34:59.866 A:middle
它将不会

00:34:59.866 --> 00:35:01.336 A:middle
被扩展到 16 毫秒

00:34:59.866 --> 00:35:01.336 A:middle
被扩展到 16 毫秒

00:35:01.336 --> 00:35:02.666 A:middle
而只是现在的 4 毫秒

00:35:03.126 --> 00:35:04.526 A:middle
用户感觉到的断断续续

00:35:04.526 --> 00:35:06.446 A:middle
会被极大程度的减少

00:35:06.446 --> 00:35:09.066 A:middle
二号帧和三号帧

00:35:09.066 --> 00:35:11.336 A:middle
他们的延迟被

00:35:11.336 --> 00:35:12.286 A:middle
拉回到

00:35:12.286 --> 00:35:12.796 A:middle
之前到位置

00:35:13.426 --> 00:35:14.736 A:middle
系统立刻

00:35:14.736 --> 00:35:15.886 A:middle
回到时间线上

00:35:16.336 --> 00:35:19.136 A:middle
延迟被提高

00:35:19.136 --> 00:35:20.446 A:middle
你的应用可以继续执行了

00:35:20.516 --> 00:35:21.306 A:middle
我们正好回到了

00:35:21.306 --> 00:35:22.756 A:middle
我们希望到达的位置

00:35:23.416 --> 00:35:26.126 A:middle
所以总结起来

00:35:26.126 --> 00:35:27.816 A:middle
它将动画变得

00:35:27.816 --> 00:35:29.136 A:middle
更坚定 更稳固

00:35:29.136 --> 00:35:30.786 A:middle
无论发生什么

00:35:31.906 --> 00:35:33.816 A:middle
那么你到底该

00:35:33.816 --> 00:35:35.116 A:middle
如何运用这些优势呢

00:35:35.756 --> 00:35:38.576 A:middle
对于一般的 UIKit 动画而言

00:35:38.576 --> 00:35:39.546 A:middle
例如 滚动观看目录或者视图

00:35:39.546 --> 00:35:41.506 A:middle
iOS 将完全以新的方式

00:35:41.506 --> 00:35:42.516 A:middle
来完成

00:35:43.016 --> 00:35:44.506 A:middle
它将在适合的时候

00:35:44.506 --> 00:35:45.456 A:middle
每秒渲染 120 帧

00:35:45.526 --> 00:35:47.606 A:middle
它也将在适合的时候

00:35:47.696 --> 00:35:48.466 A:middle
运用灵活的显示时间

00:35:50.206 --> 00:35:51.256 A:middle
Metal 应用

00:35:51.256 --> 00:35:52.286 A:middle
对时间更加敏感

00:35:52.286 --> 00:35:53.466 A:middle
所以对我们已经完成的功能

00:35:53.466 --> 00:35:54.446 A:middle
这是一个功能的选择

00:35:55.766 --> 00:35:57.886 A:middle
这个选择非常简单

00:35:57.886 --> 00:35:59.186 A:middle
你只需要在 bundle 目录下

00:35:59.186 --> 00:36:00.106 A:middle
的 info.plist 里添加一个

00:35:59.186 --> 00:36:00.106 A:middle
的 info.plist 里添加一个

00:36:00.106 --> 00:36:00.866 A:middle
新的入口

00:36:01.596 --> 00:36:03.206 A:middle
一旦你做了这个计时的行为

00:36:03.206 --> 00:36:04.616 A:middle
我们的三个 Metal 显示的

00:36:04.616 --> 00:36:06.266 A:middle
API 会出现

00:36:06.266 --> 00:36:06.536 A:middle
小的变化

00:36:06.536 --> 00:36:07.536 A:middle
我将为你们

00:36:07.536 --> 00:36:08.846 A:middle
介绍这三个 API 以及

00:36:08.846 --> 00:36:09.456 A:middle
他们如何改变的

00:36:10.226 --> 00:36:12.066 A:middle
我们的第一个

00:36:12.066 --> 00:36:14.046 A:middle
Metal 展示 API

00:36:14.466 --> 00:36:14.966 A:middle
正在进行

00:36:15.616 --> 00:36:18.216 A:middle
它即将

00:36:18.216 --> 00:36:20.156 A:middle
在 GPU 结束之后的下一个

00:36:20.156 --> 00:36:21.206 A:middle
可以使用的刷新点上

00:36:21.206 --> 00:36:22.676 A:middle
把我的图像

00:36:22.726 --> 00:36:24.306 A:middle
显示在眼镜上

00:36:25.376 --> 00:36:26.596 A:middle
在固定帧率的硬件上

00:36:26.596 --> 00:36:28.566 A:middle
这是 16 毫秒

00:36:28.566 --> 00:36:29.956 A:middle
在 iPad Pro 上

00:36:29.956 --> 00:36:30.626 A:middle
现在是 4 毫秒

00:36:31.296 --> 00:36:32.866 A:middle
这是使用最简单的 API

00:36:32.866 --> 00:36:33.726 A:middle
因为它不需要运行

00:36:33.726 --> 00:36:35.046 A:middle
因此它也是在这个房间里的

00:36:35.046 --> 00:36:35.966 A:middle
大部分人都在使用的

00:36:35.966 --> 00:36:36.296 A:middle
API

00:36:37.416 --> 00:36:38.476 A:middle
这也是让你以

00:36:38.476 --> 00:36:40.056 A:middle
最低延迟

00:36:40.056 --> 00:36:40.466 A:middle
接入显示屏的 API

00:36:41.296 --> 00:36:43.236 A:middle
它一样能工作在我们的

00:36:43.236 --> 00:36:44.596 A:middle
固定帧率以及 ProMotion

00:36:44.596 --> 00:36:46.636 A:middle
硬件上 一旦你选择它

00:36:46.636 --> 00:36:47.486 A:middle
它将以非常好的粒度

00:36:47.486 --> 00:36:47.976 A:middle
进行工作

00:36:51.646 --> 00:36:53.116 A:middle
我们的第二个

00:36:53.116 --> 00:36:54.996 A:middle
Metal 展示 API

00:36:54.996 --> 00:36:56.036 A:middle
可以显示最短时间

00:36:56.806 --> 00:36:59.236 A:middle
图像无论何时

00:36:59.236 --> 00:37:00.766 A:middle
登陆眼镜

00:36:59.236 --> 00:37:00.766 A:middle
登陆眼镜

00:37:00.766 --> 00:37:01.836 A:middle
它将能使它固定在眼镜里

00:37:01.836 --> 00:37:02.486 A:middle
一段时间

00:37:03.046 --> 00:37:03.956 A:middle
如果我的图片在眼镜里

00:37:03.956 --> 00:37:04.966 A:middle
被放了在这里

00:37:04.966 --> 00:37:06.076 A:middle
它将持续 33 微秒

00:37:06.076 --> 00:37:08.176 A:middle
如果我的开始时间变化了

00:37:08.176 --> 00:37:08.896 A:middle
结束时间也会相应变化

00:37:09.576 --> 00:37:11.116 A:middle
如果你想要

00:37:11.116 --> 00:37:12.386 A:middle
帧与帧之间

00:37:12.386 --> 00:37:13.796 A:middle
有完美的连续性的帧率 这就是你要的 API

00:37:14.416 --> 00:37:16.146 A:middle
它在每秒 30 帧的时候

00:37:16.146 --> 00:37:17.616 A:middle
在每秒 60 帧的显示屏上

00:37:17.856 --> 00:37:19.406 A:middle
尤其有效

00:37:19.406 --> 00:37:20.316 A:middle
虽然它有时候在

00:37:20.316 --> 00:37:21.446 A:middle
ProMotion 上也很有效

00:37:22.416 --> 00:37:24.706 A:middle
而我们第三个展示的

00:37:24.706 --> 00:37:25.916 A:middle
变化是

00:37:25.916 --> 00:37:26.386 A:middle
目前最有趣的

00:37:26.596 --> 00:37:28.406 A:middle
它会在特定的时间显示

00:37:28.736 --> 00:37:30.486 A:middle
它做的事情和它听起来

00:37:30.486 --> 00:37:30.996 A:middle
一样

00:37:31.736 --> 00:37:33.106 A:middle
如果 GPU 在设定时间之前

00:37:33.106 --> 00:37:34.436 A:middle
就早早完成了 显示器会

00:37:34.436 --> 00:37:34.836 A:middle
等候

00:37:35.196 --> 00:37:36.556 A:middle
如果 GPU 超过了你的

00:37:36.556 --> 00:37:37.966 A:middle
时间限制 显示器会

00:37:37.966 --> 00:37:39.606 A:middle
在下一个可用的点将它

00:37:39.606 --> 00:37:40.536 A:middle
取出

00:37:41.666 --> 00:37:44.256 A:middle
如果你想创建一个完全

00:37:44.256 --> 00:37:45.376 A:middle
定制的动画和时间循环

00:37:45.376 --> 00:37:46.596 A:middle
这就是关键的 API

00:37:47.286 --> 00:37:49.036 A:middle
这个 API 的展示和时间

00:37:49.116 --> 00:37:50.656 A:middle
和 ProMotion 显示器相结合

00:37:51.096 --> 00:37:52.286 A:middle
基本上可以让你抛弃

00:37:52.286 --> 00:37:53.446 A:middle
固定帧率的概念

00:37:53.446 --> 00:37:54.696 A:middle
在用户将要

00:37:54.696 --> 00:37:56.206 A:middle
看到内容的时候

00:37:56.206 --> 00:37:57.196 A:middle
再进行渲染

00:37:58.006 --> 00:37:59.296 A:middle
如果你想要你的 Metal 视图

00:37:59.296 --> 00:38:00.516 A:middle
和其他正在系统里发生的东西

00:37:59.296 --> 00:38:00.516 A:middle
和其他正在系统里发生的东西

00:38:00.516 --> 00:38:01.416 A:middle
完全同步

00:38:01.416 --> 00:38:03.386 A:middle
例如音频 或者你想要

00:38:03.386 --> 00:38:04.236 A:middle
为所有的外观提供

00:38:04.236 --> 00:38:05.476 A:middle
零延时

00:38:05.476 --> 00:38:06.606 A:middle
然后在你的用户

00:38:06.606 --> 00:38:07.766 A:middle
将要看到内容的时候

00:38:07.766 --> 00:38:09.176 A:middle
再推进对象

00:38:09.176 --> 00:38:11.036 A:middle
这是能让你实现这些

00:38:11.036 --> 00:38:11.846 A:middle
的工具

00:38:13.266 --> 00:38:14.116 A:middle
当然在这里的技巧

00:38:14.116 --> 00:38:15.326 A:middle
是在下一个显示时间

00:38:15.326 --> 00:38:15.896 A:middle
执行对象

00:38:15.896 --> 00:38:16.596 A:middle
这就是你的功能

00:38:17.616 --> 00:38:18.776 A:middle
为了实现它 你需要一些

00:38:18.776 --> 00:38:19.986 A:middle
来自系统的反馈

00:38:19.986 --> 00:38:21.146 A:middle
来帮助你抉择

00:38:21.146 --> 00:38:22.166 A:middle
你真正执行的是什么

00:38:22.196 --> 00:38:23.356 A:middle
现在我们也把它加上了

00:38:24.646 --> 00:38:26.966 A:middle
所以 Metal 可绘制对象

00:38:26.966 --> 00:38:28.156 A:middle
是一个暂时的对象

00:38:28.156 --> 00:38:29.496 A:middle
它可以在显示系统里

00:38:29.496 --> 00:38:30.746 A:middle
追踪一个被你渲染的图像

00:38:30.746 --> 00:38:31.516 A:middle
的一生

00:38:31.736 --> 00:38:34.896 A:middle
现在它可以在特定的

00:38:34.896 --> 00:38:36.426 A:middle
图像显示在眼镜上时被查询到

00:38:36.426 --> 00:38:37.606 A:middle
当这件事发生时

00:38:37.606 --> 00:38:38.346 A:middle
你也可以获得一个

00:38:38.346 --> 00:38:38.866 A:middle
回调函数

00:38:39.906 --> 00:38:41.466 A:middle
所以现在你可以知道你的图片

00:38:41.466 --> 00:38:42.696 A:middle
什么时候会显示在眼镜上

00:38:43.076 --> 00:38:44.656 A:middle
以及它们被移除的时间

00:38:44.656 --> 00:38:45.696 A:middle
你有关键的信号 能够使你知道

00:38:45.696 --> 00:38:47.356 A:middle
什么时候你在获得

00:38:47.356 --> 00:38:48.436 A:middle
你预期中的时间

00:38:48.436 --> 00:38:49.876 A:middle
什么时候你没有

00:38:49.876 --> 00:38:51.156 A:middle
然后给你一个信号

00:38:51.156 --> 00:38:51.706 A:middle
以调整未来的帧

00:38:54.176 --> 00:38:56.146 A:middle
这就是 ProMotion 的故事

00:38:56.146 --> 00:38:57.276 A:middle
你将在未来

00:38:57.276 --> 00:38:58.296 A:middle
在新的 iPad Pro 上

00:38:58.296 --> 00:38:59.326 A:middle
使用它

00:38:59.936 --> 00:39:01.566 A:middle
在应用中几乎没有代码改变

00:38:59.936 --> 00:39:01.566 A:middle
在应用中几乎没有代码改变

00:39:01.566 --> 00:39:02.706 A:middle
的情况下

00:39:02.706 --> 00:39:05.256 A:middle
要想获得更多的连续性和

00:39:05.256 --> 00:39:06.496 A:middle
更高的帧率是

00:39:06.496 --> 00:39:07.246 A:middle
非常容易的

00:39:07.646 --> 00:39:10.306 A:middle
从这里开始 它将给你一个选项菜单

00:39:10.306 --> 00:39:11.606 A:middle
让你选择哪一个

00:39:11.606 --> 00:39:12.766 A:middle
显示时间模型会

00:39:12.766 --> 00:39:13.906 A:middle
对你的 app

00:39:13.906 --> 00:39:14.126 A:middle
产生更多好处

00:39:14.976 --> 00:39:16.356 A:middle
一个非常非常快的

00:39:16.406 --> 00:39:18.216 A:middle
Twitch 电子游戏或者

00:39:18.216 --> 00:39:19.986 A:middle
需要对触摸和铅笔输入进行追踪的应用

00:39:19.986 --> 00:39:21.286 A:middle
可能需要达到

00:39:21.286 --> 00:39:22.036 A:middle
每秒 120 帧

00:39:22.646 --> 00:39:24.386 A:middle
一个非常高端的渲染标题

00:39:24.386 --> 00:39:25.766 A:middle
可能需要保持

00:39:25.836 --> 00:39:27.156 A:middle
每秒 30 帧到 60 帧

00:39:27.156 --> 00:39:28.176 A:middle
或者这之间的一个数

00:39:28.176 --> 00:39:30.456 A:middle
以享受稳定连续的优势

00:39:31.136 --> 00:39:32.266 A:middle
一些想要

00:39:32.266 --> 00:39:33.166 A:middle
完全掌控它们的

00:39:33.166 --> 00:39:34.506 A:middle
时间循环的应用在这里

00:39:34.506 --> 00:39:35.546 A:middle
有全新的功能

00:39:36.776 --> 00:39:37.956 A:middle
无论你的 app 是什么

00:39:37.956 --> 00:39:39.966 A:middle
ProMotion 给予你这个

00:39:39.966 --> 00:39:41.186 A:middle
强大的新工具

00:39:41.186 --> 00:39:42.446 A:middle
去支持它特定的

00:39:42.446 --> 00:39:42.726 A:middle
动画需求

00:39:42.726 --> 00:39:45.306 A:middle
这就是 ProMotion

00:39:46.016 --> 00:39:48.846 A:middle
接下来 我有一个完全不同的

00:39:48.936 --> 00:39:50.346 A:middle
显示话题要谈一谈

00:39:50.346 --> 00:39:51.256 A:middle
那就是我们称为直接显示的

00:39:51.256 --> 00:39:52.326 A:middle
功能

00:39:54.236 --> 00:39:56.206 A:middle
所以在你的 GPU

00:39:56.206 --> 00:39:58.036 A:middle
完成渲染你的

00:39:58.036 --> 00:39:59.306 A:middle
内容和显示之后

00:39:59.306 --> 00:40:00.426 A:middle
发生的事情会变的

00:39:59.306 --> 00:40:00.426 A:middle
发生的事情会变的

00:40:00.426 --> 00:40:01.066 A:middle
复杂一些

00:40:01.116 --> 00:40:02.886 A:middle
然后你的图像有两条

00:40:02.886 --> 00:40:04.836 A:middle
可以通往显示屏的路径

00:40:04.836 --> 00:40:07.016 A:middle
由 GPU 组合

00:40:08.116 --> 00:40:08.306 A:middle
然后直接放到显示屏上显示

00:40:08.426 --> 00:40:10.256 A:middle
它们中的第一个是

00:40:10.256 --> 00:40:11.956 A:middle
你的经典用户界面场景

00:40:12.486 --> 00:40:13.446 A:middle
我会在这里获得一系列的

00:40:13.446 --> 00:40:15.086 A:middle
视图 层级 和窗口

00:40:15.086 --> 00:40:17.426 A:middle
然后这个时候

00:40:17.426 --> 00:40:18.376 A:middle
系统会将

00:40:18.376 --> 00:40:19.136 A:middle
它们统统取出

00:40:19.136 --> 00:40:19.496 A:middle
然后将它们组合起来

00:40:19.636 --> 00:40:20.776 A:middle
它将缩放任何内容的比例

00:40:20.776 --> 00:40:21.396 A:middle
以适应显示屏

00:40:21.396 --> 00:40:21.906 A:middle
它将展示

00:40:21.906 --> 00:40:22.796 A:middle
色彩和空间的变换

00:40:22.796 --> 00:40:23.746 A:middle
它将进行

00:40:23.746 --> 00:40:24.776 A:middle
任何核心的图像过滤或者

00:40:24.776 --> 00:40:26.056 A:middle
混合 然后它将

00:40:26.056 --> 00:40:27.516 A:middle
产生一个用户看到的

00:40:27.516 --> 00:40:28.636 A:middle
最终的组合图像

00:40:30.776 --> 00:40:32.436 A:middle
这对于功能完善的

00:40:32.436 --> 00:40:33.676 A:middle
用户界面

00:40:33.676 --> 00:40:34.586 A:middle
是非常关键的抽象

00:40:35.106 --> 00:40:38.136 A:middle
但是它也全部是在 GPU 上完成

00:40:38.136 --> 00:40:39.186 A:middle
而且它会消耗一些时间和

00:40:39.186 --> 00:40:39.706 A:middle
内存

00:40:40.436 --> 00:40:41.746 A:middle
如果我们创建一个

00:40:41.746 --> 00:40:42.646 A:middle
全屏幕的应用

00:40:42.646 --> 00:40:44.046 A:middle
这对它来说

00:40:44.046 --> 00:40:45.136 A:middle
就有点过度了

00:40:45.136 --> 00:40:46.316 A:middle
这就是直接显示模式

00:40:46.316 --> 00:40:48.106 A:middle
介入的时候了

00:40:48.256 --> 00:40:49.236 A:middle
如果这些操作都没有被要求

00:40:49.236 --> 00:40:51.496 A:middle
我们可以

00:40:51.496 --> 00:40:52.936 A:middle
直接让显示器硬件指向你

00:40:52.976 --> 00:40:54.216 A:middle
刚刚渲染过的内存

00:40:54.586 --> 00:40:55.856 A:middle
而不需要任何

00:40:55.856 --> 00:40:55.986 A:middle
中间人

00:40:57.646 --> 00:40:59.026 A:middle
我们怎么做到的呢

00:40:59.406 --> 00:41:01.196 A:middle
事实证明 其实没有一个

00:40:59.406 --> 00:41:01.196 A:middle
事实证明 其实没有一个

00:41:01.196 --> 00:41:02.716 A:middle
API 能够直接

00:41:02.716 --> 00:41:03.146 A:middle
指向显示器

00:41:03.916 --> 00:41:05.566 A:middle
这个模式实际上是

00:41:05.566 --> 00:41:06.796 A:middle
任何需要 GPU 组合器

00:41:06.796 --> 00:41:08.166 A:middle
介入的遗漏

00:41:08.836 --> 00:41:10.386 A:middle
当组合器看到你的

00:41:10.386 --> 00:41:11.596 A:middle
场景设置 然后发现

00:41:11.596 --> 00:41:13.026 A:middle
这里没有需要它做的

00:41:13.026 --> 00:41:14.686 A:middle
这时候

00:41:14.686 --> 00:41:15.626 A:middle
它将离开

00:41:16.426 --> 00:41:18.176 A:middle
所以 你应该怎样设置你的场景

00:41:18.176 --> 00:41:20.726 A:middle
以使合成器

00:41:20.726 --> 00:41:22.756 A:middle
直接离开

00:41:23.216 --> 00:41:23.706 A:middle
其实这是

00:41:23.706 --> 00:41:24.916 A:middle
非常直观的感受

00:41:24.966 --> 00:41:26.166 A:middle
我的内容是否需要任何

00:41:26.166 --> 00:41:27.106 A:middle
非重要过程

00:41:27.106 --> 00:41:27.846 A:middle
语音处理就是一个

00:41:27.846 --> 00:41:29.336 A:middle
非常直观的开始

00:41:30.066 --> 00:41:31.146 A:middle
但更具体来说

00:41:31.146 --> 00:41:32.166 A:middle
你希望你的层级是不透明的

00:41:32.726 --> 00:41:33.756 A:middle
我不希望它与任何东西

00:41:33.756 --> 00:41:34.096 A:middle
混合

00:41:34.716 --> 00:41:36.616 A:middle
我们不想运用任何

00:41:36.616 --> 00:41:37.716 A:middle
需要核心动画或者

00:41:37.716 --> 00:41:38.666 A:middle
窗口服务器

00:41:38.916 --> 00:41:39.946 A:middle
来修改我们的像素

00:41:39.946 --> 00:41:40.836 A:middle
我们不想在我们的视图里

00:41:40.836 --> 00:41:42.406 A:middle
或者遮蔽或者过滤器这一类的东西

00:41:42.406 --> 00:41:44.326 A:middle
放置圆角控件

00:41:45.656 --> 00:41:46.896 A:middle
我们想创建一个全屏幕

00:41:47.226 --> 00:41:49.496 A:middle
如果你的内容

00:41:49.496 --> 00:41:51.256 A:middle
不完全符合

00:41:51.256 --> 00:41:52.436 A:middle
屏幕的纵横比例

00:41:52.436 --> 00:41:53.896 A:middle
你可以用全屏的 不透明的 黑色的

00:41:53.896 --> 00:41:55.016 A:middle
背景层来给予

00:41:55.016 --> 00:41:56.396 A:middle
黑色菜单栏一类的效果

00:41:56.396 --> 00:41:57.216 A:middle
但是最终我们还是希望

00:41:57.216 --> 00:41:58.516 A:middle
能模糊所有的东西

00:42:01.456 --> 00:42:02.656 A:middle
我们希望选择一个

00:42:02.656 --> 00:42:03.636 A:middle
能匹配本来面板的

00:42:03.636 --> 00:42:04.306 A:middle
渲染分辨率

00:42:05.176 --> 00:42:06.416 A:middle
这是有一点技巧性的

00:42:06.416 --> 00:42:07.616 A:middle
因为我们所有的

00:42:07.616 --> 00:42:09.056 A:middle
在 macOS 和 iOS 上搭载的

00:42:09.056 --> 00:42:10.556 A:middle
硬件都是有

00:42:10.556 --> 00:42:12.446 A:middle
虚拟桌面模式或者分辨率模式

00:42:12.446 --> 00:42:13.696 A:middle
它们都比真实的物理面板

00:42:13.696 --> 00:42:14.676 A:middle
要大

00:42:14.766 --> 00:42:16.216 A:middle
我们想做的最后一件事

00:42:16.216 --> 00:42:17.356 A:middle
是花时间去渲染很多的

00:42:17.356 --> 00:42:18.256 A:middle
像素 其实只要

00:42:18.286 --> 00:42:19.456 A:middle
在 GPU 上花时间然后再把时间

00:42:19.456 --> 00:42:19.976 A:middle
缩减回来就行了

00:42:24.466 --> 00:42:25.846 A:middle
最后 你想选择

00:42:25.846 --> 00:42:26.976 A:middle
颜色 空间 像素帧

00:42:26.976 --> 00:42:28.046 A:middle
那些显示硬件

00:42:28.046 --> 00:42:29.186 A:middle
会很高兴的直接读取的内容

00:42:30.116 --> 00:42:31.126 A:middle
在这里

00:42:31.126 --> 00:42:32.216 A:middle
这里有无限组合数

00:42:32.216 --> 00:42:33.986 A:middle
所以在这里我想

00:42:33.986 --> 00:42:34.656 A:middle
给你们一个

00:42:34.656 --> 00:42:35.986 A:middle
关于一些特殊

00:42:35.986 --> 00:42:36.916 A:middle
和高效组合数

00:42:36.916 --> 00:42:37.576 A:middle
的白名单

00:42:39.926 --> 00:42:41.596 A:middle
在最上方是我们的

00:42:41.596 --> 00:42:44.556 A:middle
老朋友 SRGB8888

00:42:44.556 --> 00:42:45.496 A:middle
这基本上是绝大多数应用

00:42:45.496 --> 00:42:46.986 A:middle
通用的像素格式

00:42:46.986 --> 00:42:48.806 A:middle
也是所有硬件都

00:42:48.806 --> 00:42:50.626 A:middle
乐于读取的

00:42:50.626 --> 00:42:51.776 A:middle
对于大多数人来说

00:42:51.776 --> 00:42:52.196 A:middle
这就是他们需要的全部了

00:42:53.666 --> 00:42:55.876 A:middle
但是我们已经在

00:42:55.876 --> 00:42:58.096 A:middle
macOS 和 iOS 硬件上都

00:42:58.096 --> 00:43:00.806 A:middle
搭载了广色域的 P3 显示器

00:42:58.096 --> 00:43:00.806 A:middle
搭载了广色域的 P3 显示器

00:43:01.106 --> 00:43:02.246 A:middle
如果你的应用

00:43:02.246 --> 00:43:03.766 A:middle
希望开始运用这个功能

00:43:03.766 --> 00:43:04.926 A:middle
来显示更多的颜色

00:43:04.926 --> 00:43:06.016 A:middle
你需要

00:43:06.016 --> 00:43:06.396 A:middle
注意一下这里

00:43:06.396 --> 00:43:09.676 A:middle
在这里 iOS 和 macOS 两者的概念

00:43:09.676 --> 00:43:11.086 A:middle
是一样的

00:43:11.086 --> 00:43:11.996 A:middle
虽然在细节上

00:43:11.996 --> 00:43:13.316 A:middle
有所不同

00:43:13.316 --> 00:43:14.686 A:middle
在这两者中 我们都希望

00:43:14.686 --> 00:43:15.846 A:middle
渲染加入像素格式

00:43:17.266 --> 00:43:20.106 A:middle
但是请注意 如果你

00:43:20.106 --> 00:43:21.566 A:middle
在 P3 显示器上

00:43:21.566 --> 00:43:23.286 A:middle
渲染 P3 的内容 那没有问题

00:43:23.286 --> 00:43:25.686 A:middle
但如果你渲染了 P3 内容

00:43:25.686 --> 00:43:28.166 A:middle
然后在 SRGB 的系统里去显示

00:43:28.166 --> 00:43:29.266 A:middle
那么 GPU 合成器可能会

00:43:29.266 --> 00:43:30.326 A:middle
参与进来并将色域

00:43:30.326 --> 00:43:31.426 A:middle
压缩以适应

00:43:31.426 --> 00:43:31.796 A:middle
显示器

00:43:32.706 --> 00:43:34.206 A:middle
所以 P3

00:43:34.206 --> 00:43:34.816 A:middle
不是你在任何时间

00:43:34.816 --> 00:43:35.996 A:middle
都想要做的

00:43:36.106 --> 00:43:37.166 A:middle
你最好看一看

00:43:37.226 --> 00:43:39.466 A:middle
当下的显示器是什么

00:43:39.466 --> 00:43:40.616 A:middle
然后在现有条件下工作

00:43:40.986 --> 00:43:43.356 A:middle
最后  为了完整性

00:43:43.356 --> 00:43:44.726 A:middle
我也要列出 RGBA float 16

00:43:44.726 --> 00:43:45.866 A:middle
它基本上是

00:43:45.866 --> 00:43:48.116 A:middle
普遍适应的 宽色域

00:43:48.116 --> 00:43:49.406 A:middle
高动态范围的像素格式

00:43:49.956 --> 00:43:52.086 A:middle
虽然

00:43:52.086 --> 00:43:53.266 A:middle
这对 macOS 的

00:43:53.266 --> 00:43:54.466 A:middle
扩展数据范围功能也很必要

00:43:55.196 --> 00:43:56.076 A:middle
值得注意的是

00:43:56.076 --> 00:43:57.476 A:middle
它也确实需要在所有情况下

00:43:57.476 --> 00:43:57.976 A:middle
运行组成 GPU 组合

00:44:01.646 --> 00:44:02.566 A:middle
所以就像我提到的

00:44:02.566 --> 00:44:03.776 A:middle
如果你编写了一个

00:44:03.776 --> 00:44:04.716 A:middle
广色域识别的应用

00:44:04.716 --> 00:44:05.586 A:middle
你确实需要考虑条件

00:44:06.376 --> 00:44:07.776 A:middle
幸运的是 UIKit 和

00:44:07.776 --> 00:44:08.596 A:middle
AppKit 都提供了非常

00:44:08.596 --> 00:44:08.976 A:middle
简便的 API 检查方式

00:44:13.256 --> 00:44:14.786 A:middle
所以 最后一步是 你怎么知道

00:44:14.786 --> 00:44:16.056 A:middle
你是否在

00:44:16.056 --> 00:44:17.646 A:middle
定向显示路径上

00:44:17.646 --> 00:44:18.676 A:middle
这张截屏显示的是

00:44:18.676 --> 00:44:19.966 A:middle
Metal 系统的

00:44:19.966 --> 00:44:20.566 A:middle
追踪工具

00:44:20.676 --> 00:44:23.376 A:middle
Metal 系统追踪是

00:44:23.426 --> 00:44:25.006 A:middle
一个能给你实时的

00:44:25.006 --> 00:44:26.656 A:middle
CPU 和 GPU 显示器时间轴的

00:44:26.656 --> 00:44:27.886 A:middle
开发工具

00:44:28.216 --> 00:44:30.106 A:middle
这基本上是

00:44:30.106 --> 00:44:30.996 A:middle
我之前给大家展示过的

00:44:30.996 --> 00:44:31.636 A:middle
图像的

00:44:31.636 --> 00:44:32.236 A:middle
真实版本

00:44:33.396 --> 00:44:35.216 A:middle
所以在这里

00:44:35.216 --> 00:44:36.596 A:middle
我要将渲染过的三个帧

00:44:36.596 --> 00:44:37.016 A:middle
高亮显示出来

00:44:37.546 --> 00:44:39.106 A:middle
这个有颜色的时间间隔是我

00:44:39.106 --> 00:44:40.126 A:middle
自己的应用渲染

00:44:41.296 --> 00:44:42.716 A:middle
这个灰色的间隔是

00:44:42.716 --> 00:44:44.446 A:middle
GPU 里的其他过程

00:44:44.496 --> 00:44:46.806 A:middle
我能在窗口底部

00:44:46.806 --> 00:44:47.666 A:middle
获得更多细节

00:44:47.666 --> 00:44:48.306 A:middle
我也能从背板 D 上看到它

00:44:48.306 --> 00:44:50.836 A:middle
这是 iOS 合成

00:44:50.836 --> 00:44:51.406 A:middle
的过程

00:44:51.596 --> 00:44:52.606 A:middle
这是我的应用

00:44:52.606 --> 00:44:53.676 A:middle
到 GPU 合成路径上的

00:44:53.676 --> 00:44:55.946 A:middle
例子

00:44:55.946 --> 00:44:56.896 A:middle
回到之前 重新访问

00:44:56.896 --> 00:44:59.166 A:middle
一些我们的最佳实践例子

00:44:59.166 --> 00:45:00.486 A:middle
会将它们从图片上移除

00:44:59.166 --> 00:45:00.486 A:middle
会将它们从图片上移除

00:45:00.486 --> 00:45:02.116 A:middle
现在我可以返还我的 Metal 系统追踪

00:45:02.556 --> 00:45:04.026 A:middle
我有一个时间轴

00:45:04.026 --> 00:45:05.626 A:middle
可以通过它看到我已经

00:45:05.716 --> 00:45:06.616 A:middle
完全的

00:45:06.616 --> 00:45:06.976 A:middle
拥有了 GPU

00:45:10.046 --> 00:45:12.006 A:middle
这就是

00:45:12.146 --> 00:45:12.756 A:middle
直接显示

00:45:12.756 --> 00:45:14.086 A:middle
我们的系统合成器可以

00:45:14.086 --> 00:45:15.406 A:middle
在屏幕后制造很多魔法

00:45:15.406 --> 00:45:16.746 A:middle
以使全功能的

00:45:16.746 --> 00:45:18.626 A:middle
用户界面成为可能

00:45:18.626 --> 00:45:19.706 A:middle
但是这会产生性能消耗

00:45:19.706 --> 00:45:20.976 A:middle
因为要使用 GPU 来

00:45:20.976 --> 00:45:21.426 A:middle
做到它

00:45:22.396 --> 00:45:23.456 A:middle
通过了解

00:45:23.456 --> 00:45:24.036 A:middle
你在要求

00:45:24.036 --> 00:45:25.536 A:middle
合成器做什么 或者

00:45:25.536 --> 00:45:26.896 A:middle
更重要的是 别问

00:45:26.896 --> 00:45:28.186 A:middle
你没让合成器做的事

00:45:28.186 --> 00:45:30.046 A:middle
它就能不使用 GPU

00:45:30.046 --> 00:45:31.816 A:middle
从而离开

00:45:31.816 --> 00:45:32.766 A:middle
并返还给你一些时间

00:45:33.496 --> 00:45:35.536 A:middle
iOS 和 Tos 一直

00:45:35.536 --> 00:45:37.046 A:middle
支持直接显示

00:45:37.046 --> 00:45:39.056 A:middle
这对 macOS High Sierra 的

00:45:39.056 --> 00:45:40.356 A:middle
Metal 应用来说是

00:45:40.356 --> 00:45:40.976 A:middle
全新的

00:45:45.366 --> 00:45:46.536 A:middle
所以 讲到它 我想提到今天的

00:45:46.536 --> 00:45:48.136 A:middle
最后一个话题和

00:45:48.136 --> 00:45:50.576 A:middle
一些其他的东西

00:45:50.616 --> 00:45:51.716 A:middle
我们为 Metal 2

00:45:51.716 --> 00:45:52.826 A:middle
在核心结构和设计语言上

00:45:52.826 --> 00:45:54.056 A:middle
做了很多添加

00:45:54.056 --> 00:45:55.306 A:middle
所以现在我不打算

00:45:55.306 --> 00:45:56.226 A:middle
深入的讲这些东西

00:45:56.226 --> 00:45:56.896 A:middle
但是我想先给你们一个

00:45:56.896 --> 00:45:57.236 A:middle
调查

00:45:57.716 --> 00:46:01.036 A:middle
我们很快的添加了

00:45:57.716 --> 00:46:01.036 A:middle
我们很快的添加了

00:46:01.036 --> 00:46:02.026 A:middle
新的 API 使它能够

00:46:02.026 --> 00:46:03.916 A:middle
质询 GPU

00:46:03.916 --> 00:46:05.316 A:middle
为每个缓存器

00:46:05.316 --> 00:46:06.446 A:middle
每个纹理 每个堆分配了多少内存

00:46:06.736 --> 00:46:08.996 A:middle
这将屏幕后

00:46:08.996 --> 00:46:09.576 A:middle
发生的事情

00:46:09.576 --> 00:46:10.666 A:middle
考虑在了其中

00:46:10.666 --> 00:46:12.496 A:middle
例如对齐和多种填充

00:46:13.156 --> 00:46:13.996 A:middle
这能为你究竟

00:46:13.996 --> 00:46:15.356 A:middle
使用了多少 GPU 内存

00:46:15.356 --> 00:46:16.586 A:middle
提供一个更准确的视角

00:46:16.586 --> 00:46:19.466 A:middle
我们在 Metal 设备上也有

00:46:19.466 --> 00:46:22.006 A:middle
一个折叠查询

00:46:22.006 --> 00:46:23.766 A:middle
它是你整个处理过程的

00:46:23.766 --> 00:46:24.786 A:middle
GPU 内存使用情况

00:46:25.106 --> 00:46:26.716 A:middle
这是尤其显著的

00:46:26.716 --> 00:46:28.616 A:middle
因为它包括了

00:46:28.616 --> 00:46:29.616 A:middle
所有对你不可见的

00:46:29.616 --> 00:46:30.966 A:middle
由驱动程序分配的内存

00:46:30.966 --> 00:46:33.156 A:middle
类似于

00:46:33.156 --> 00:46:34.676 A:middle
放置着色器代码的内存

00:46:34.676 --> 00:46:35.686 A:middle
命令缓存器或者其他类似的

00:46:35.686 --> 00:46:36.076 A:middle
东西

00:46:36.576 --> 00:46:37.516 A:middle
这能让你知道你

00:46:37.516 --> 00:46:38.216 A:middle
在哪里是关联的

00:46:38.216 --> 00:46:38.946 A:middle
你知道所有东西的

00:46:38.946 --> 00:46:39.976 A:middle
内存使用目标

00:46:43.736 --> 00:46:44.666 A:middle
我们有几个

00:46:44.666 --> 00:46:45.586 A:middle
面向计算机的添加

00:46:46.026 --> 00:46:47.246 A:middle
我们第一个添加的

00:46:47.246 --> 00:46:48.276 A:middle
是一系列着色语言功能

00:46:48.276 --> 00:46:49.636 A:middle
以帮助

00:46:49.636 --> 00:46:50.826 A:middle
你能够在 SIMD 组的

00:46:50.826 --> 00:46:51.976 A:middle
线程之间转换

00:46:52.176 --> 00:46:54.306 A:middle
如果你还不熟悉的话

00:46:54.306 --> 00:46:55.526 A:middle
GPU 硬件获得一个

00:46:55.746 --> 00:46:57.606 A:middle
单个顶点片段

00:46:57.606 --> 00:46:59.586 A:middle
然后计算着色器线程进入

00:46:59.586 --> 00:47:00.756 A:middle
SIMD 组 然后一起执行它们

00:46:59.586 --> 00:47:00.756 A:middle
SIMD 组 然后一起执行它们

00:47:00.756 --> 00:47:01.986 A:middle
以获得更好的效率

00:47:02.536 --> 00:47:04.266 A:middle
它们也被称为

00:47:04.266 --> 00:47:04.726 A:middle
wayfrencer warp

00:47:05.766 --> 00:47:07.386 A:middle
在一个组里 这些线程

00:47:07.386 --> 00:47:08.506 A:middle
有能力不加载或者

00:47:08.506 --> 00:47:09.756 A:middle
储存内存

00:47:09.756 --> 00:47:10.796 A:middle
直接进行对话

00:47:11.386 --> 00:47:13.126 A:middle
它们可以从一个

00:47:13.126 --> 00:47:14.226 A:middle
线程的寄存器读取值然后

00:47:14.226 --> 00:47:15.096 A:middle
将它们写入另一个

00:47:15.096 --> 00:47:15.666 A:middle
线程寄存器

00:47:15.796 --> 00:47:16.516 A:middle
这些就是

00:47:16.516 --> 00:47:17.506 A:middle
新的标准库

00:47:17.506 --> 00:47:17.816 A:middle
允许的内容

00:47:18.916 --> 00:47:21.516 A:middle
这里的广播意味着

00:47:21.516 --> 00:47:22.756 A:middle
我能直接从线程零的寄存器

00:47:22.856 --> 00:47:24.226 A:middle
读取数据

00:47:24.226 --> 00:47:25.526 A:middle
直接读取数据域

00:47:25.526 --> 00:47:26.406 A:middle
然后直接将它写进

00:47:26.406 --> 00:47:27.866 A:middle
正好同属于这一个组里的

00:47:27.866 --> 00:47:28.796 A:middle
其他 16 个线程的

00:47:28.796 --> 00:47:28.976 A:middle
寄存器

00:47:33.146 --> 00:47:34.606 A:middle
我们第二个增加

00:47:34.606 --> 00:47:35.776 A:middle
让你根据你的线程组大小

00:47:35.776 --> 00:47:37.086 A:middle
获得更多灵活性

00:47:37.936 --> 00:47:39.576 A:middle
例如 如果我有一个

00:47:39.576 --> 00:47:40.556 A:middle
像素鸟 我想要运行

00:47:40.556 --> 00:47:41.916 A:middle
一些漂亮的经典图像的

00:47:41.916 --> 00:47:44.866 A:middle
处理内核

00:47:44.866 --> 00:47:45.936 A:middle
但是我已经将计算内核

00:47:45.936 --> 00:47:47.666 A:middle
所有地方都写成了 4 乘 4 的

00:47:47.716 --> 00:47:48.516 A:middle
线程组

00:47:49.906 --> 00:47:50.936 A:middle
好吧 这导致了一些问题

00:47:50.936 --> 00:47:52.246 A:middle
因为

00:47:52.246 --> 00:47:53.716 A:middle
如果我的图片不是我的线程组的

00:47:53.716 --> 00:47:55.056 A:middle
数倍

00:47:55.056 --> 00:47:56.066 A:middle
我会产生

00:47:56.066 --> 00:47:56.396 A:middle
很多偏离线程

00:47:57.056 --> 00:47:59.766 A:middle
我想这意味着

00:47:59.766 --> 00:48:01.726 A:middle
我需要对它进行深入了解

00:47:59.766 --> 00:48:01.726 A:middle
我需要对它进行深入了解

00:48:01.726 --> 00:48:02.546 A:middle
然后当我真的要编写代码的时候

00:48:02.546 --> 00:48:03.466 A:middle
我必须要谨慎

00:48:03.466 --> 00:48:04.326 A:middle
我越界了吗

00:48:04.326 --> 00:48:05.146 A:middle
我需要用特殊的方法

00:48:05.146 --> 00:48:05.736 A:middle
来处理它

00:48:05.736 --> 00:48:07.136 A:middle
这是可行的 但是令人恼火

00:48:07.976 --> 00:48:09.006 A:middle
这基本是意味着

00:48:09.006 --> 00:48:10.126 A:middle
我们只是在浪费 GPU 循环

00:48:10.646 --> 00:48:12.926 A:middle
所以非一致线程组的大小

00:48:12.926 --> 00:48:14.536 A:middle
除非你声明

00:48:14.536 --> 00:48:15.476 A:middle
在不放大线程组大小的情况下

00:48:15.476 --> 00:48:16.896 A:middle
你想要在哪种维度上

00:48:16.896 --> 00:48:18.136 A:middle
进行你的核心运行

00:48:18.736 --> 00:48:20.156 A:middle
所以那些困难的工作

00:48:20.156 --> 00:48:21.766 A:middle
在我的网格边缘的较小的

00:48:21.766 --> 00:48:23.536 A:middle
线程组上

00:48:23.536 --> 00:48:24.466 A:middle
为了去掉

00:48:24.466 --> 00:48:26.006 A:middle
不必要的工作

00:48:26.096 --> 00:48:28.456 A:middle
它不仅提升了 GPU 的性能

00:48:28.456 --> 00:48:29.556 A:middle
而且还让你的核心变得更

00:48:29.556 --> 00:48:29.976 A:middle
容易编写

00:48:34.236 --> 00:48:35.206 A:middle
我们已经加入了

00:48:35.206 --> 00:48:35.896 A:middle
对视图端口队列的支持

00:48:36.206 --> 00:48:37.736 A:middle
现在你可以设置最多 16 个

00:48:37.736 --> 00:48:39.396 A:middle
同步的视图端口

00:48:39.396 --> 00:48:41.146 A:middle
而你的顶点着色器可以选择

00:48:41.146 --> 00:48:42.776 A:middle
每个三角想向哪一个视图端口

00:48:42.776 --> 00:48:43.916 A:middle
进行呈现

00:48:44.626 --> 00:48:45.596 A:middle
在这里我就不多讲了

00:48:45.596 --> 00:48:46.256 A:middle
因为明天的 Metal 2

00:48:46.256 --> 00:48:48.026 A:middle
VR 会议将会讲到关于它的

00:48:48.026 --> 00:48:49.176 A:middle
细节

00:48:49.546 --> 00:48:50.546 A:middle
这对左右眼的

00:48:50.546 --> 00:48:51.346 A:middle
有效渲染是非常

00:48:51.346 --> 00:48:51.976 A:middle
有价值的

00:48:56.666 --> 00:48:57.476 A:middle
我们已经加入了一项能力

00:48:57.476 --> 00:48:59.126 A:middle
它可以选择在每个像素上

00:48:59.126 --> 00:49:00.076 A:middle
你的多个实例位置

00:48:59.126 --> 00:49:00.076 A:middle
你的多个实例位置

00:49:00.076 --> 00:49:00.606 A:middle
在哪里被支持

00:49:01.566 --> 00:49:02.776 A:middle
这让你能做一些

00:49:02.776 --> 00:49:04.356 A:middle
有趣的事情 包括

00:49:04.356 --> 00:49:05.366 A:middle
每隔一帧切换

00:49:05.366 --> 00:49:07.256 A:middle
你的实例位置

00:49:07.256 --> 00:49:08.396 A:middle
并给你一些新的 你知道

00:49:08.396 --> 00:49:09.376 A:middle
将一些有价值的输入加入到

00:49:09.376 --> 00:49:10.386 A:middle
一些随机采样抗锯齿

00:49:10.386 --> 00:49:11.066 A:middle
算法里

00:49:15.716 --> 00:49:17.206 A:middle
为了努力保持

00:49:17.266 --> 00:49:18.726 A:middle
使我们的平台能跟得上时代

00:49:18.726 --> 00:49:19.756 A:middle
让他们在任何时候

00:49:19.806 --> 00:49:20.816 A:middle
都有相同的功能设置

00:49:20.816 --> 00:49:21.856 A:middle
我们用了

00:49:21.856 --> 00:49:23.356 A:middle
我们在去年的 iOS 10

00:49:23.356 --> 00:49:25.586 A:middle
以及今年的 macOS High Sierra 上

00:49:25.586 --> 00:49:26.366 A:middle
搭载的资源堆

00:49:26.616 --> 00:49:28.826 A:middle
在这里我要

00:49:28.826 --> 00:49:29.926 A:middle
做一下刷新

00:49:29.926 --> 00:49:32.196 A:middle
因为好好使用

00:49:32.196 --> 00:49:33.906 A:middle
堆

00:49:33.906 --> 00:49:34.816 A:middle
对于很好的利用参数缓存器

00:49:34.816 --> 00:49:35.246 A:middle
很重要

00:49:36.606 --> 00:49:37.986 A:middle
堆使我们能

00:49:37.986 --> 00:49:38.896 A:middle
预先分配很多

00:49:38.896 --> 00:49:40.786 A:middle
内存  而不是

00:49:40.786 --> 00:49:42.416 A:middle
去到内核然后说

00:49:42.506 --> 00:49:43.926 A:middle
我要纹理 a 的内存

00:49:43.926 --> 00:49:45.046 A:middle
我要纹理 b 的内存

00:49:45.046 --> 00:49:45.416 A:middle
等等

00:49:45.826 --> 00:49:46.896 A:middle
我可以去内核

00:49:46.896 --> 00:49:49.036 A:middle
预先分配内存

00:49:49.036 --> 00:49:50.626 A:middle
增减纹理和缓存器的同时

00:49:50.626 --> 00:49:51.556 A:middle
不需要

00:49:51.556 --> 00:49:52.906 A:middle
回到

00:49:52.976 --> 00:49:55.396 A:middle
系统中去

00:49:55.466 --> 00:49:56.766 A:middle
这样做有一些好处

00:49:56.946 --> 00:49:58.206 A:middle
这意味着我能

00:49:58.206 --> 00:49:59.116 A:middle
在这个堆中更高效的

00:49:59.116 --> 00:49:59.726 A:middle
混合所有东西

00:49:59.916 --> 00:50:00.666 A:middle
这样会减少很多

00:49:59.916 --> 00:50:00.666 A:middle
这样会减少很多

00:50:00.666 --> 00:50:01.026 A:middle
软件开销

00:50:01.786 --> 00:50:02.966 A:middle
这意味着我们可以

00:50:02.966 --> 00:50:03.936 A:middle
经常将内存

00:50:03.936 --> 00:50:04.466 A:middle
压缩的更紧密一些

00:50:04.466 --> 00:50:05.536 A:middle
我们可以减少一些边距

00:50:05.536 --> 00:50:06.686 A:middle
和队列 为你省下

00:50:06.686 --> 00:50:07.056 A:middle
一些内存

00:50:08.096 --> 00:50:10.116 A:middle
这意味着当我们删除内存时

00:50:10.426 --> 00:50:11.816 A:middle
我们不会将内存

00:50:11.816 --> 00:50:12.236 A:middle
返还给系统

00:50:12.576 --> 00:50:13.296 A:middle
这是好事也是坏事

00:50:13.996 --> 00:50:15.666 A:middle
这意味着当我们分配

00:50:15.666 --> 00:50:16.526 A:middle
新内存时

00:50:16.526 --> 00:50:17.676 A:middle
当我们分配新的纹理时

00:50:17.676 --> 00:50:18.656 A:middle
我们不用回到系统

00:50:18.656 --> 00:50:18.976 A:middle
去索取新的内存

00:50:22.476 --> 00:50:23.386 A:middle
这也意味着你可以

00:50:23.386 --> 00:50:24.916 A:middle
选择对这些纹理

00:50:24.916 --> 00:50:25.476 A:middle
进行重命名

00:50:26.256 --> 00:50:27.606 A:middle
如果我有

00:50:27.606 --> 00:50:29.456 A:middle
渲染目标 或者

00:50:29.456 --> 00:50:31.126 A:middle
在渲染图形的不同通道上对

00:50:31.126 --> 00:50:32.666 A:middle
渲染图像进行调整

00:50:33.076 --> 00:50:34.176 A:middle
这意味着

00:50:34.176 --> 00:50:34.886 A:middle
如果我有两个中间结构

00:50:34.886 --> 00:50:36.616 A:middle
它们不用同时出现

00:50:36.616 --> 00:50:37.966 A:middle
我可以

00:50:37.966 --> 00:50:38.926 A:middle
为他们设置相互命名

00:50:38.926 --> 00:50:43.416 A:middle
我可以像这样

00:50:44.096 --> 00:50:46.066 A:middle
省下很多内存

00:50:46.866 --> 00:50:47.906 A:middle
这是一个对堆的快速调查

00:50:47.996 --> 00:50:50.196 A:middle
我们在 iOS 到 macOS 里都

00:50:50.386 --> 00:50:52.056 A:middle
添加了线性纹理

00:50:52.296 --> 00:50:53.366 A:middle
线性纹理能使你直接从

00:50:53.366 --> 00:50:55.146 A:middle
Metal 缓存器里创建纹理

00:50:55.146 --> 00:50:56.736 A:middle
而不用做任何的

00:50:56.786 --> 00:50:57.216 A:middle
复制工作

00:50:59.306 --> 00:51:00.266 A:middle
我们也扩展了

00:50:59.306 --> 00:51:00.266 A:middle
我们也扩展了

00:51:00.266 --> 00:51:01.736 A:middle
我们功能的稳定性

00:51:01.736 --> 00:51:02.766 A:middle
一个快速的刷新

00:51:02.766 --> 00:51:03.656 A:middle
稳定功能让你

00:51:03.656 --> 00:51:04.886 A:middle
用代码进行特殊化

00:51:05.026 --> 00:51:05.926 A:middle
当你在线下做完了

00:51:05.926 --> 00:51:07.466 A:middle
你的前端编译

00:51:07.466 --> 00:51:08.636 A:middle
你能够在产生最终的

00:51:08.636 --> 00:51:09.886 A:middle
机器代码之前就

00:51:10.106 --> 00:51:11.296 A:middle
对超着色器 bi-code 进行一些

00:51:11.296 --> 00:51:11.856 A:middle
调整和自定义

00:51:12.716 --> 00:51:14.046 A:middle
如果你有经典的

00:51:14.046 --> 00:51:15.156 A:middle
超着色器 它能为你省下

00:51:15.156 --> 00:51:16.206 A:middle
为每个单独序列

00:51:16.206 --> 00:51:17.836 A:middle
都配置一个前端编译器的

00:51:17.836 --> 00:51:18.726 A:middle
开销

00:51:19.806 --> 00:51:21.016 A:middle
所以我们已经将它变得

00:51:21.016 --> 00:51:22.546 A:middle
更灵活 也添加了一些

00:51:22.546 --> 00:51:25.136 A:middle
能特殊化参数的

00:51:25.246 --> 00:51:26.286 A:middle
功能

00:51:28.046 --> 00:51:29.106 A:middle
我们也增加了一些额外的

00:51:29.106 --> 00:51:29.796 A:middle
顶点数组格式

00:51:29.826 --> 00:51:31.196 A:middle
我们遗漏了一个或两个

00:51:31.196 --> 00:51:32.396 A:middle
组件顶点格式

00:51:32.546 --> 00:51:34.366 A:middle
我们还增加了 BGRA 顶点

00:51:34.366 --> 00:51:34.916 A:middle
格式

00:51:37.576 --> 00:51:38.616 A:middle
我们从 macOS 到 iOS 都

00:51:38.616 --> 00:51:40.306 A:middle
有 iOS 的

00:51:40.436 --> 00:51:40.846 A:middle
表面纹理支持

00:51:40.846 --> 00:51:42.716 A:middle
我们也在 iOS 上加入了

00:51:42.716 --> 00:51:44.156 A:middle
双源混合

00:51:44.446 --> 00:51:46.666 A:middle
这在很多延迟渲染场景下

00:51:46.666 --> 00:51:47.926 A:middle
尤其有用

00:51:50.706 --> 00:51:52.756 A:middle
这就是我关于 Metal 2

00:51:52.756 --> 00:51:56.086 A:middle
介绍的最后内容

00:51:56.166 --> 00:51:57.586 A:middle
我的同事 Michal

00:51:57.586 --> 00:51:58.976 A:middle
在开始的时候

00:51:58.976 --> 00:52:00.266 A:middle
向你们介绍了 Metal 2 的

00:51:58.976 --> 00:52:00.266 A:middle
向你们介绍了 Metal 2 的

00:52:00.266 --> 00:52:00.806 A:middle
总体范围

00:52:01.126 --> 00:52:03.686 A:middle
从 VR 到外部 GPU

00:52:04.056 --> 00:52:05.206 A:middle
到机器学习

00:52:05.206 --> 00:52:06.886 A:middle
到新的研发者工具和

00:52:07.306 --> 00:52:08.026 A:middle
性能分析

00:52:08.026 --> 00:52:08.986 A:middle
我们今天介绍的

00:52:08.986 --> 00:52:10.936 A:middle
这些内容

00:52:10.936 --> 00:52:12.456 A:middle
极大地的推动了

00:52:12.576 --> 00:52:13.926 A:middle
通过使用参数缓存器

00:52:13.926 --> 00:52:14.386 A:middle
来减少 CPU 开销

00:52:15.006 --> 00:52:16.506 A:middle
参数缓存器也解锁了

00:52:16.506 --> 00:52:17.856 A:middle
GPU 的能力

00:52:17.886 --> 00:52:18.956 A:middle
使它在配置

00:52:18.956 --> 00:52:19.866 A:middle
着色器参数时

00:52:19.866 --> 00:52:21.126 A:middle
掌握一些它自己的命运

00:52:21.126 --> 00:52:22.536 A:middle
这也少了一个

00:52:22.536 --> 00:52:24.676 A:middle
让它回到 CPU 去的理由

00:52:25.586 --> 00:52:27.356 A:middle
光栅顺序组让我们

00:52:27.356 --> 00:52:28.666 A:middle
在基本的东西以外

00:52:28.666 --> 00:52:30.186 A:middle
使用光栅器来进行混合

00:52:31.356 --> 00:52:32.476 A:middle
我们现在可以开始

00:52:32.476 --> 00:52:34.056 A:middle
利用最新的硬件能力去做到

00:52:34.056 --> 00:52:36.566 A:middle
你知道的

00:52:36.566 --> 00:52:38.386 A:middle
vox slice 三角网络或者

00:52:38.616 --> 00:52:40.316 A:middle
设置有序或独立的

00:52:40.316 --> 00:52:41.226 A:middle
透明混合

00:52:41.296 --> 00:52:42.216 A:middle
它们都是

00:52:42.216 --> 00:52:42.816 A:middle
这让它们都变成可能

00:52:44.016 --> 00:52:46.656 A:middle
对于新的 iPad Pros ProMotion

00:52:46.656 --> 00:52:47.726 A:middle
能让你对于

00:52:47.726 --> 00:52:49.126 A:middle
动画如何呈现给用户

00:52:49.126 --> 00:52:50.226 A:middle
拥有一个细粒度程度的控制

00:52:50.226 --> 00:52:51.886 A:middle
让你有能力既

00:52:51.886 --> 00:52:53.656 A:middle
得到峰顶的帧率

00:52:53.656 --> 00:52:54.736 A:middle
又得到最少的延迟

00:52:55.136 --> 00:52:57.736 A:middle
直接显示通过发现我们的

00:52:57.736 --> 00:52:59.116 A:middle
合成器代表你做了什么

00:52:59.116 --> 00:53:00.436 A:middle
来为你提供

00:52:59.116 --> 00:53:00.436 A:middle
来为你提供

00:53:00.526 --> 00:53:01.706 A:middle
重新声明 GPU 执行路径的

00:53:01.706 --> 00:53:02.956 A:middle
能力

00:53:06.336 --> 00:53:07.536 A:middle
你可以在

00:53:07.536 --> 00:53:08.426 A:middle
WWDC2017 的网站上看到

00:53:08.426 --> 00:53:11.216 A:middle
今天会议的幻灯片和视频

00:53:11.876 --> 00:53:15.096 A:middle
我们今年还有

00:53:15.096 --> 00:53:15.996 A:middle
其他三个关于 Metal 2 的会议

00:53:16.596 --> 00:53:18.536 A:middle
特别要提到的是

00:53:18.536 --> 00:53:19.456 A:middle
明天下午

00:53:19.456 --> 00:53:20.696 A:middle
我们的会议将集中讨论

00:53:20.696 --> 00:53:21.136 A:middle
VR 和 Metal 2

00:53:21.326 --> 00:53:22.886 A:middle
会议将

00:53:22.886 --> 00:53:24.706 A:middle
深入讲解你的应用

00:53:24.706 --> 00:53:26.456 A:middle
需要做什么 以及如何

00:53:26.456 --> 00:53:28.426 A:middle
做 VR 渲染的概念性简介

00:53:28.426 --> 00:53:30.056 A:middle
深入讲解

00:53:30.056 --> 00:53:32.106 A:middle
如何用 Metal 2 和 Steam VR toolkit

00:53:32.106 --> 00:53:34.076 A:middle
的组合来做 VR

00:53:34.076 --> 00:53:36.086 A:middle
它也将通过外部的

00:53:36.086 --> 00:53:37.326 A:middle
GPU 硬件

00:53:37.326 --> 00:53:37.736 A:middle
来使用 Metal

00:53:39.666 --> 00:53:40.376 A:middle
在周四 我们将有

00:53:40.376 --> 00:53:42.286 A:middle
连续两场会议 以 Metal 2

00:53:42.286 --> 00:53:43.676 A:middle
的优化和故障排查开始

00:53:43.996 --> 00:53:45.716 A:middle
会议将介绍

00:53:45.716 --> 00:53:46.726 A:middle
新的研发项目

00:53:46.726 --> 00:53:48.106 A:middle
和性能工具

00:53:48.106 --> 00:53:49.376 A:middle
以及所有的

00:53:49.376 --> 00:53:50.086 A:middle
帮助你创建尽可能完美应用

00:53:50.086 --> 00:53:51.076 A:middle
的工作流

00:53:51.286 --> 00:53:52.826 A:middle
接下去的会议

00:53:52.826 --> 00:53:54.336 A:middle
将会介绍

00:53:54.336 --> 00:53:55.276 A:middle
使用 Metal 2 进行计算

00:53:55.656 --> 00:53:57.126 A:middle
这将是

00:53:57.126 --> 00:53:58.896 A:middle
今年的重大关注点

00:53:58.896 --> 00:54:00.206 A:middle
使用 GPU 来做机器学习

00:53:58.896 --> 00:54:00.206 A:middle
使用 GPU 来做机器学习

00:54:00.206 --> 00:54:00.916 A:middle
应用

00:54:00.916 --> 00:54:01.946 A:middle
我们今年做了非常多的

00:54:01.946 --> 00:54:03.806 A:middle
添加 我们也希望

00:54:03.806 --> 00:54:05.166 A:middle
向大家展示我们做了哪些事

00:54:07.206 --> 00:54:08.386 A:middle
我想给大家介绍

00:54:08.426 --> 00:54:10.206 A:middle
几个去年的 WWDC 会议

00:54:11.286 --> 00:54:12.626 A:middle
第一个是  Metal 的新鲜事

00:54:12.626 --> 00:54:14.186 A:middle
第一部分 我们深入的讲解了

00:54:14.186 --> 00:54:15.786 A:middle
资源堆

00:54:16.196 --> 00:54:17.146 A:middle
如果你想要得到

00:54:17.146 --> 00:54:18.026 A:middle
参数缓存器的最好性能

00:54:18.026 --> 00:54:19.836 A:middle
参数缓存器和堆

00:54:19.836 --> 00:54:20.936 A:middle
是密不可分的

00:54:20.936 --> 00:54:22.716 A:middle
所以我非常鼓励

00:54:22.716 --> 00:54:23.836 A:middle
大家去看看视频

00:54:23.836 --> 00:54:26.336 A:middle
真的 你可以

00:54:26.436 --> 00:54:28.416 A:middle
通过一起使用这两项

00:54:28.416 --> 00:54:29.326 A:middle
来计划

00:54:29.326 --> 00:54:29.686 A:middle
制作你的应用

00:54:29.756 --> 00:54:31.196 A:middle
那个视频里比今天的会议

00:54:31.196 --> 00:54:32.516 A:middle
多讲了很多细节

00:54:34.056 --> 00:54:36.016 A:middle
第二 如果你对

00:54:36.016 --> 00:54:38.076 A:middle
直接显示和广色域

00:54:38.076 --> 00:54:39.436 A:middle
有兴趣

00:54:39.436 --> 00:54:40.996 A:middle
我们在去年有

00:54:40.996 --> 00:54:41.916 A:middle
一次会议全程

00:54:41.916 --> 00:54:43.066 A:middle
都在深入探讨

00:54:43.066 --> 00:54:44.066 A:middle
它背后的概念

00:54:44.066 --> 00:54:44.656 A:middle
和特殊性

00:54:45.706 --> 00:54:47.676 A:middle
在这里 我们今天的会议

00:54:47.676 --> 00:54:47.796 A:middle
到此结束

00:54:47.796 --> 00:54:48.886 A:middle
感谢大家的到来

00:54:48.886 --> 00:54:49.596 A:middle
希望大家

00:54:49.596 --> 00:54:50.266 A:middle
享受本周剩下的几天

00:54:50.266 --> 00:54:50.906 A:middle
谢谢大家

00:54:51.516 --> 00:54:55.500 A:middle
[ 掌声 ]
