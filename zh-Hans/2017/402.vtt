WEBVTT

00:00:18.046 --> 00:00:18.756 A:middle
&gt;&gt;  大家下午好

00:00:19.516 --> 00:00:23.796 A:middle
[掌声]

00:00:24.296 --> 00:00:24.606 A:middle
谢谢大家

00:00:25.186 --> 00:00:26.516 A:middle
欢迎来到 Swift 新品发布会

00:00:27.256 --> 00:00:28.206 A:middle
我是 Doug Gregor

00:00:28.436 --> 00:00:29.296 A:middle
在这里 我和 Swift 团队的

00:00:29.296 --> 00:00:30.446 A:middle
同事将一起来聊聊

00:00:30.696 --> 00:00:32.286 A:middle
我们在 Swift 4

00:00:32.286 --> 00:00:33.866 A:middle
里带来的一些

00:00:33.866 --> 00:00:34.246 A:middle
新改变

00:00:35.276 --> 00:00:38.866 A:middle
现在 如果你关注了

00:00:38.866 --> 00:00:40.576 A:middle
iOS Developer 或是

00:00:40.576 --> 00:00:41.486 A:middle
Ole Begemann 其实你早就知道

00:00:41.486 --> 00:00:42.356 A:middle
Swift 4 有什么新功能了

00:00:43.606 --> 00:00:45.046 A:middle
这便是我如此热爱

00:00:45.046 --> 00:00:46.896 A:middle
Swift 社区的理由

00:00:47.296 --> 00:00:49.726 A:middle
Ole 把所有关于

00:00:49.726 --> 00:00:50.886 A:middle
Swift 4 里应该有什么

00:00:50.886 --> 00:00:53.036 A:middle
的提议都看了一遍

00:00:53.036 --> 00:00:53.366 A:middle
接下来他做了什么

00:00:53.366 --> 00:00:54.996 A:middle
他建了一个平台来演示

00:00:54.996 --> 00:00:56.346 A:middle
这些功能是如何实现的

00:00:56.346 --> 00:00:57.926 A:middle
并与世界分享

00:00:57.926 --> 00:00:58.996 A:middle
这样我们就能从中

00:00:58.996 --> 00:00:59.386 A:middle
得知都发生了什么

00:01:00.136 --> 00:01:00.996 A:middle
这简直太棒了

00:01:01.896 --> 00:01:03.986 A:middle
并且这是可行的

00:01:03.986 --> 00:01:05.426 A:middle
因为在任何时间你都可以

00:01:05.426 --> 00:01:07.086 A:middle
来到 Swift.org 我们的开源社区

00:01:07.086 --> 00:01:09.276 A:middle
下载最新最强大的

00:01:09.276 --> 00:01:10.766 A:middle
Swift 编译器

00:01:10.766 --> 00:01:11.336 A:middle
的快照

00:01:12.046 --> 00:01:13.626 A:middle
这个快照是一种工具链

00:01:13.626 --> 00:01:16.016 A:middle
你可以把它安装到 Xcode 里

00:01:16.926 --> 00:01:18.576 A:middle
它提供了新的编译器 调试器

00:01:18.576 --> 00:01:19.646 A:middle
源码包等等

00:01:19.646 --> 00:01:20.696 A:middle
所以你可以依靠最新的工具

00:01:20.696 --> 00:01:21.906 A:middle
来编写你的 App

00:01:22.126 --> 00:01:23.026 A:middle
试试一些新功能吧

00:01:23.026 --> 00:01:24.466 A:middle
看看我们是否修复了

00:01:24.466 --> 00:01:25.226 A:middle
你最喜欢的 Bug

00:01:25.336 --> 00:01:27.766 A:middle
当然 这全都建立在

00:01:27.766 --> 00:01:29.286 A:middle
Swift 开源的基础上

00:01:29.286 --> 00:01:30.426 A:middle
我们在 GitHub 上

00:01:30.426 --> 00:01:32.406 A:middle
公开了源码

00:01:32.406 --> 00:01:33.116 A:middle
以便你可以持续跟进

00:01:33.526 --> 00:01:34.746 A:middle
如果你感兴趣

00:01:34.746 --> 00:01:35.346 A:middle
当然可以加入我们

00:01:36.266 --> 00:01:38.706 A:middle
另外 Swift 的发展

00:01:38.706 --> 00:01:40.226 A:middle
比如标准函数库 编程语言

00:01:40.226 --> 00:01:42.206 A:middle
都是通过这个开放的

00:01:42.206 --> 00:01:43.926 A:middle
发展过程得来的 即通过

00:01:44.076 --> 00:01:46.036 A:middle
评估个人提议来完善 Swift

00:01:46.396 --> 00:01:48.116 A:middle
提高他们以改进 Swift

00:01:48.116 --> 00:01:49.846 A:middle
让 Swift 对每个开发者

00:01:49.846 --> 00:01:51.156 A:middle
都更加友好

00:01:52.346 --> 00:01:54.036 A:middle
你没听错 接下来是

00:01:54.036 --> 00:01:56.256 A:middle
Xcode 9 对 Swift

00:01:56.256 --> 00:01:57.846 A:middle
重构支持的介绍

00:01:58.516 --> 00:02:01.736 A:middle
[掌声]

00:01:58.516 --> 00:02:01.736 A:middle
[掌声]

00:02:02.236 --> 00:02:05.256 A:middle
好的 所有的为重构 Swift 工作的

00:02:05.256 --> 00:02:07.176 A:middle
语言级位都是

00:02:07.176 --> 00:02:08.846 A:middle
以 Swift 项目

00:02:08.846 --> 00:02:09.576 A:middle
为基础的

00:02:09.576 --> 00:02:10.716 A:middle
届时我们将

00:02:10.716 --> 00:02:11.226 A:middle
完全开源

00:02:11.546 --> 00:02:12.746 A:middle
最激动人心的事情是

00:02:12.746 --> 00:02:14.516 A:middle
那时你可以查阅并编写

00:02:14.516 --> 00:02:16.286 A:middle
Swift 源码

00:02:16.286 --> 00:02:17.826 A:middle
通过我刚刚介绍的工具链

00:02:17.826 --> 00:02:19.226 A:middle
进行你自己的重构

00:02:19.226 --> 00:02:20.626 A:middle
试着在 Xcode 里

00:02:20.626 --> 00:02:21.626 A:middle
编译他们

00:02:22.026 --> 00:02:22.866 A:middle
总之 这是一种能让你真正的

00:02:22.866 --> 00:02:23.896 A:middle
与开发工具

00:02:23.896 --> 00:02:24.356 A:middle
融为一体的方法

00:02:26.186 --> 00:02:27.786 A:middle
如今 作为开源生态系统

00:02:27.786 --> 00:02:29.266 A:middle
一部分的还有

00:02:29.306 --> 00:02:30.126 A:middle
Swift Package Manager

00:02:30.456 --> 00:02:31.626 A:middle
在 GitHub 上 它为超过

00:02:31.626 --> 00:02:33.726 A:middle
7000 个包提供支持

00:02:33.726 --> 00:02:34.866 A:middle
并不断完善着生态系统

00:02:35.376 --> 00:02:36.996 A:middle
这对于进程端的 Swift 而言

00:02:36.996 --> 00:02:38.936 A:middle
十分受欢迎

00:02:38.936 --> 00:02:41.666 A:middle
Swift PM 可以 在 Linux 上

00:02:41.666 --> 00:02:42.706 A:middle
轻易地获取需要构建

00:02:42.706 --> 00:02:44.526 A:middle
服务器端 Swift 应用程序

00:02:44.526 --> 00:02:45.536 A:middle
所需的服务器组件

00:02:46.056 --> 00:02:47.416 A:middle
今年 Swift Package Manager

00:02:47.416 --> 00:02:49.126 A:middle
相较以往

00:02:49.156 --> 00:02:49.756 A:middle
有了很大的提升

00:02:49.936 --> 00:02:51.366 A:middle
为了更好的体现 API 的用途

00:02:51.786 --> 00:02:53.586 A:middle
更好的用于开发 workflow 等等

00:02:53.586 --> 00:02:55.796 A:middle
并且为了实现最终的目标

00:02:55.796 --> 00:02:57.586 A:middle
我们已经取得了长足的进步

00:02:57.586 --> 00:02:59.316 A:middle
这包括在 Xcode IDE 中

00:02:59.316 --> 00:03:01.446 A:middle
为 Swift Package 提供了

00:02:59.316 --> 00:03:01.446 A:middle
为 Swift Package 提供了

00:03:01.446 --> 00:03:01.516 A:middle
一流的支持

00:03:01.516 --> 00:03:03.896 A:middle
随着 Swift PM 作为

00:03:03.896 --> 00:03:05.396 A:middle
函数库的使用

00:03:05.396 --> 00:03:07.256 A:middle
我们也越来越接近这个目标

00:03:07.256 --> 00:03:08.926 A:middle
当然 新的 Xcode 构建系统

00:03:08.926 --> 00:03:11.126 A:middle
完全建立在 Swift 的基础上

00:03:12.276 --> 00:03:13.516 A:middle
因此 我们今天要

00:03:13.516 --> 00:03:13.836 A:middle
涉及到许多方面的内容

00:03:14.616 --> 00:03:16.306 A:middle
在我们深入探讨

00:03:16.306 --> 00:03:17.916 A:middle
源兼容性之前

00:03:17.916 --> 00:03:19.616 A:middle
我将讨论一些

00:03:20.126 --> 00:03:21.376 A:middle
对语言本身的小改进和补充

00:03:21.376 --> 00:03:22.736 A:middle
我们将探讨

00:03:23.016 --> 00:03:23.866 A:middle
如何在 Swift 4 和 Xcode 9

00:03:23.866 --> 00:03:25.256 A:middle
环境下充分利用你在

00:03:25.256 --> 00:03:27.266 A:middle
Swift 中构建的

00:03:27.266 --> 00:03:28.736 A:middle
所有代码

00:03:29.646 --> 00:03:31.056 A:middle
在 Ben 深入到字符串 集合

00:03:31.056 --> 00:03:32.466 A:middle
以及 Swift 的

00:03:32.466 --> 00:03:34.366 A:middle
一些通用特性之前

00:03:34.366 --> 00:03:36.526 A:middle
我的同事 Bob

00:03:36.526 --> 00:03:37.686 A:middle
将讨论 Swift 工具

00:03:37.686 --> 00:03:38.046 A:middle
和性能的提升

00:03:38.676 --> 00:03:40.316 A:middle
最后 John 将谈到

00:03:40.316 --> 00:03:41.586 A:middle
独占访问内存的问题

00:03:41.906 --> 00:03:43.306 A:middle
这是一种语义限制

00:03:43.306 --> 00:03:44.576 A:middle
我们将把它引入到

00:03:44.576 --> 00:03:46.316 A:middle
未来 Swift 语言的

00:03:46.316 --> 00:03:46.716 A:middle
构建之中

00:03:47.606 --> 00:03:50.356 A:middle
那我们就从

00:03:50.356 --> 00:03:52.016 A:middle
触手可及的未来开始吧

00:03:53.366 --> 00:03:54.646 A:middle
访问控制

00:03:54.746 --> 00:03:56.206 A:middle
这里我定义了一些

00:03:56.206 --> 00:03:57.216 A:middle
简单的数据结构

00:03:57.906 --> 00:03:59.206 A:middle
这与 Fundation

00:03:59.206 --> 00:03:59.876 A:middle
中的十分类似

00:03:59.906 --> 00:04:00.666 A:middle
它把 secondsSinceReferenceDate

00:03:59.906 --> 00:04:00.666 A:middle
它把 secondsSinceReferenceDate

00:04:00.666 --> 00:04:02.436 A:middle
作为一个内部引用

00:04:02.436 --> 00:04:03.896 A:middle
但我把它私有化了

00:04:03.896 --> 00:04:05.146 A:middle
因为我认为它

00:04:05.146 --> 00:04:07.276 A:middle
并不是一个可以向

00:04:07.276 --> 00:04:07.996 A:middle
我的用户们公开的 API

00:04:08.516 --> 00:04:09.656 A:middle
我希望他成为一种

00:04:09.656 --> 00:04:11.706 A:middle
优秀的值类型

00:04:11.706 --> 00:04:13.066 A:middle
兼具公平性与可比性

00:04:13.506 --> 00:04:14.776 A:middle
但是这段代码

00:04:14.776 --> 00:04:15.706 A:middle
已经有一丝的

00:04:15.706 --> 00:04:16.125 A:middle
混乱了

00:04:16.125 --> 00:04:17.776 A:middle
我真的应该把它分解成

00:04:18.216 --> 00:04:20.086 A:middle
单独的扩展

00:04:20.086 --> 00:04:21.305 A:middle
每个任务对应一个 对吧

00:04:21.305 --> 00:04:23.316 A:middle
这是 Swift 的一个很好的编码风格

00:04:23.716 --> 00:04:25.226 A:middle
但是 Swift 3 并没有做到

00:04:25.226 --> 00:04:26.456 A:middle
很好地支持它

00:04:26.456 --> 00:04:28.376 A:middle
因为你会得到这样一个错误

00:04:28.376 --> 00:04:30.256 A:middle
那就是无法跨越另一个词法范围

00:04:30.256 --> 00:04:31.296 A:middle
来做出私有声明

00:04:32.206 --> 00:04:33.196 A:middle
如今我们可以使用

00:04:33.196 --> 00:04:34.036 A:middle
Fileprivate 来解决这个问题

00:04:34.446 --> 00:04:35.706 A:middle
但这意味着此定义

00:04:35.706 --> 00:04:38.546 A:middle
在整个文件中都可以

00:04:38.546 --> 00:04:39.356 A:middle
被检索到 这并不好

00:04:39.356 --> 00:04:40.326 A:middle
范围太广了

00:04:40.786 --> 00:04:43.416 A:middle
因此 我们对 Swift 4

00:04:43.416 --> 00:04:45.706 A:middle
进行了改进

00:04:45.706 --> 00:04:48.736 A:middle
扩展了私有定义的范围

00:04:48.886 --> 00:04:51.246 A:middle
覆盖同一源文件中

00:04:51.246 --> 00:04:52.706 A:middle
特定类型的

00:04:52.706 --> 00:04:53.566 A:middle
所有扩展的声明

00:04:53.936 --> 00:04:55.316 A:middle
这与使用拓展

00:04:55.316 --> 00:04:57.316 A:middle
来组建代码的概念

00:04:57.316 --> 00:04:57.976 A:middle
更加吻合

00:04:58.516 --> 00:05:01.546 A:middle
[掌声]

00:04:58.516 --> 00:05:01.546 A:middle
[掌声]

00:05:02.046 --> 00:05:03.336 A:middle
有了这种变化

00:05:03.336 --> 00:05:05.176 A:middle
就让我们忘掉

00:05:05.176 --> 00:05:05.626 A:middle
访问控制这种说法吧

00:05:06.516 --> 00:05:09.546 A:middle
笑声

00:05:10.046 --> 00:05:11.016 A:middle
其次 我想谈谈

00:05:11.016 --> 00:05:12.536 A:middle
组合类和协议

00:05:13.006 --> 00:05:14.676 A:middle
针对 UI 的部分

00:05:14.786 --> 00:05:16.186 A:middle
这里我引入了一个

00:05:16.186 --> 00:05:17.656 A:middle
可以调整的协议

00:05:17.656 --> 00:05:18.866 A:middle
这足以带给我们惊喜

00:05:18.866 --> 00:05:19.486 A:middle
并吸引我们的目光

00:05:20.106 --> 00:05:21.826 A:middle
我已经扩展了来

00:05:21.826 --> 00:05:23.846 A:middle
一些 UIKit 类

00:05:24.296 --> 00:05:25.526 A:middle
从而提供这个

00:05:25.526 --> 00:05:26.306 A:middle
调整功能

00:05:26.306 --> 00:05:27.466 A:middle
现在我想写一些

00:05:27.466 --> 00:05:28.756 A:middle
看起来很简单的东西

00:05:28.796 --> 00:05:30.336 A:middle
我只是想写一个函数

00:05:30.506 --> 00:05:32.046 A:middle
它需要一系列的控件

00:05:32.046 --> 00:05:33.556 A:middle
这些控件是可调用的

00:05:33.556 --> 00:05:34.926 A:middle
并且可以调用那些

00:05:34.926 --> 00:05:36.186 A:middle
吸引他们注意力的控件

00:05:36.996 --> 00:05:38.486 A:middle
在这个数组中

00:05:38.876 --> 00:05:39.546 A:middle
我该如何定义类型

00:05:40.696 --> 00:05:41.866 A:middle
这很不讨人喜欢

00:05:41.866 --> 00:05:42.196 A:middle
非常棘手

00:05:42.616 --> 00:05:44.206 A:middle
所以我试着用用

00:05:44.206 --> 00:05:44.746 A:middle
UI 控件

00:05:44.746 --> 00:05:46.146 A:middle
但并不是所有的

00:05:46.146 --> 00:05:47.156 A:middle
UI 控件都是可调整的

00:05:48.006 --> 00:05:49.846 A:middle
我可以试着调整 但不是所有

00:05:49.846 --> 00:05:51.536 A:middle
可调整的部分都是 UI 控件

00:05:51.536 --> 00:05:52.496 A:middle
在 Swift 3 中 我没有办法

00:05:52.496 --> 00:05:54.506 A:middle
去很好的展示这些东西

00:05:54.916 --> 00:05:56.986 A:middle
Swift 4 里引入了

00:05:57.386 --> 00:06:00.266 A:middle
使用任意数量的协议

00:05:57.386 --> 00:06:00.266 A:middle
使用任意数量的协议

00:06:00.266 --> 00:06:01.326 A:middle
来编写类的概念

00:06:02.516 --> 00:06:07.696 A:middle
[掌声]

00:06:08.196 --> 00:06:09.716 A:middle
这是一个小功能

00:06:09.716 --> 00:06:11.046 A:middle
但它与 Swift 的

00:06:11.046 --> 00:06:12.476 A:middle
整体设置非常吻合

00:06:12.526 --> 00:06:13.826 A:middle
如果你之前使用

00:06:13.826 --> 00:06:15.376 A:middle
Objective-C 进行编程

00:06:15.376 --> 00:06:16.196 A:middle
那么您应该对这些功能

00:06:16.196 --> 00:06:17.246 A:middle
了如指掌

00:06:17.246 --> 00:06:18.456 A:middle
因为很早之前

00:06:18.456 --> 00:06:19.746 A:middle
Objective-C 就已经有了

00:06:19.746 --> 00:06:20.156 A:middle
这项功能

00:06:20.616 --> 00:06:22.446 A:middle
这里是一个 Touch Bar API

00:06:22.446 --> 00:06:24.836 A:middle
客户端在 NSView 中

00:06:24.876 --> 00:06:26.906 A:middle
它也符合 NSTextInputClient

00:06:27.426 --> 00:06:29.386 A:middle
在 Swift 3 中 我们实际上不

00:06:29.386 --> 00:06:30.586 A:middle
能表示那种类型 所以我们将它

00:06:30.586 --> 00:06:31.996 A:middle
作为 NSView 来引入

00:06:32.166 --> 00:06:33.386 A:middle
这真的不是个明智的做法

00:06:34.326 --> 00:06:36.716 A:middle
因此 Swift 4 改进了这一点

00:06:36.716 --> 00:06:38.186 A:middle
现在我们可以使用

00:06:38.186 --> 00:06:41.016 A:middle
NSTextInputClient 的 NSView

00:06:41.046 --> 00:06:43.346 A:middle
来导入类型 这可以完美匹配

00:06:43.346 --> 00:06:44.526 A:middle
所有的 API

00:06:46.516 --> 00:06:49.546 A:middle
[掌声]

00:06:50.046 --> 00:06:51.366 A:middle
接下来我们还要

00:06:51.366 --> 00:06:52.216 A:middle
谈到它很多

00:06:52.216 --> 00:06:53.046 A:middle
过人之处

00:06:53.316 --> 00:06:54.366 A:middle
我想让大家看看我们

00:06:54.366 --> 00:06:55.566 A:middle
在改进 Cocoa idioms

00:06:55.566 --> 00:06:57.106 A:middle
KeyPaths，Key-Value Coding

00:06:57.106 --> 00:06:58.156 A:middle
Archival & Serialization 领域中

00:06:58.196 --> 00:07:00.096 A:middle
引出的一些新特性

00:06:58.196 --> 00:07:00.096 A:middle
引出的一些新特性

00:07:00.476 --> 00:07:02.736 A:middle
这些都是 Swift 的重大新特性

00:07:02.736 --> 00:07:04.136 A:middle
我们将在周三的

00:07:04.216 --> 00:07:05.916 A:middle
《基础新特性》的讲座上

00:07:05.916 --> 00:07:06.896 A:middle
对它进行

00:07:06.896 --> 00:07:08.576 A:middle
详细的讨论

00:07:09.856 --> 00:07:12.656 A:middle
这些新特性

00:07:12.756 --> 00:07:14.586 A:middle
可以很好的与

00:07:14.586 --> 00:07:14.936 A:middle
Swift 值类型兼容

00:07:14.936 --> 00:07:16.596 A:middle
所以你可以在

00:07:16.596 --> 00:07:17.666 A:middle
所有的 Swift 代码中

00:07:19.056 --> 00:07:20.136 A:middle
使用他们 在这个部分

00:07:20.136 --> 00:07:21.706 A:middle
他们还将回答一个古老的问题

00:07:22.096 --> 00:07:24.496 A:middle
如何在 Swift 中解析 JSON

00:07:26.806 --> 00:07:28.346 A:middle
好的 那我们就来谈谈

00:07:28.346 --> 00:07:29.176 A:middle
源码兼容性

00:07:30.036 --> 00:07:32.916 A:middle
从本质上来说

00:07:32.916 --> 00:07:34.306 A:middle
Swift 4 在很大程度上

00:07:34.306 --> 00:07:35.126 A:middle
与 Swift 3 兼容

00:07:35.676 --> 00:07:37.416 A:middle
原因是语言本身没有

00:07:37.566 --> 00:07:39.806 A:middle
太大的改变 我们只是

00:07:39.996 --> 00:07:41.426 A:middle
做出了一些改进

00:07:41.426 --> 00:07:42.986 A:middle
这就像对轴孔的改变一样（细微）

00:07:43.396 --> 00:07:44.626 A:middle
我们做了一些补充

00:07:44.896 --> 00:07:46.486 A:middle
就像对类和协议

00:07:46.486 --> 00:07:47.506 A:middle
组合的更改一样

00:07:48.156 --> 00:07:49.436 A:middle
此外 SDK 图中

00:07:49.436 --> 00:07:51.906 A:middle
现有的 API 接入 Swift 的

00:07:51.936 --> 00:07:53.806 A:middle
方式也有了一些改进

00:07:53.806 --> 00:07:55.566 A:middle
现今我们提供了比以往更好的

00:07:55.566 --> 00:07:57.086 A:middle
Swift API

00:07:57.426 --> 00:07:59.566 A:middle
但这种改变的规模

00:07:59.566 --> 00:08:01.276 A:middle
远小于从 Swift 2 到 3

00:07:59.566 --> 00:08:01.276 A:middle
远小于从 Swift 2 到 3

00:08:01.276 --> 00:08:03.126 A:middle
甚至是

00:08:03.126 --> 00:08:03.556 A:middle
Swift 1 到 2

00:08:04.136 --> 00:08:06.956 A:middle
因此 从 Swift 3 到 4

00:08:06.956 --> 00:08:08.626 A:middle
并没有像之前那样

00:08:08.706 --> 00:08:10.026 A:middle
对代码的基础有很大的影响

00:08:10.436 --> 00:08:11.316 A:middle
我们谈到的很多特性

00:08:11.316 --> 00:08:12.386 A:middle
都只是纯粹的

00:08:12.386 --> 00:08:12.866 A:middle
补充条款

00:08:13.116 --> 00:08:14.536 A:middle
所以他们在一些

00:08:14.536 --> 00:08:15.476 A:middle
新的句法空间里

00:08:15.476 --> 00:08:17.166 A:middle
我们不会以牺牲源码

00:08:17.166 --> 00:08:18.566 A:middle
为代价来引入这些新特性

00:08:19.586 --> 00:08:21.426 A:middle
这就是说

00:08:21.426 --> 00:08:22.176 A:middle
我们要平稳的迁移

00:08:22.626 --> 00:08:24.166 A:middle
所以我们还要引入

00:08:24.366 --> 00:08:25.106 A:middle
Swift 3.2

00:08:26.146 --> 00:08:27.456 A:middle
关于 Swift 3.2

00:08:27.456 --> 00:08:29.496 A:middle
最重要的一点是它不是

00:08:29.496 --> 00:08:30.836 A:middle
一个独立的编译器或是

00:08:30.836 --> 00:08:31.486 A:middle
一个不同的工具链

00:08:32.246 --> 00:08:34.066 A:middle
这是 Swift 4 编译器的

00:08:34.066 --> 00:08:36.166 A:middle
编译模式

00:08:36.216 --> 00:08:37.316 A:middle
它可以模拟 Swift 3 的做法

00:08:37.926 --> 00:08:39.285 A:middle
因此 如果从

00:08:39.285 --> 00:08:41.256 A:middle
Swift 3 到 4 的

00:08:41.256 --> 00:08:43.756 A:middle
语法语义发生了变化

00:08:43.756 --> 00:08:44.275 A:middle
它将提供 Swift 3 的做法

00:08:45.226 --> 00:08:47.016 A:middle
此外 它还可以解释

00:08:47.016 --> 00:08:48.736 A:middle
新 SDK 中

00:08:48.846 --> 00:08:50.006 A:middle
所做的更改

00:08:50.006 --> 00:08:51.236 A:middle
因此 如果一个 API 项目

00:08:51.236 --> 00:08:53.156 A:middle
在 Swift 4 中和 Swift 3中

00:08:53.156 --> 00:08:55.406 A:middle
不一样

00:08:55.556 --> 00:08:57.176 A:middle
则它会将这些不同

00:08:57.176 --> 00:08:58.156 A:middle
退回到 Swift 3 视图中呈现

00:08:59.446 --> 00:09:01.726 A:middle
这最终的结果结果就是

00:08:59.446 --> 00:09:01.726 A:middle
这最终的结果结果就是

00:09:01.726 --> 00:09:03.196 A:middle
当你在 Xcode 9 中打开

00:09:03.606 --> 00:09:05.096 A:middle
Swift 3 项目并使用

00:09:05.096 --> 00:09:07.406 A:middle
Swift 3.2 构建它时

00:09:07.436 --> 00:09:09.176 A:middle
几乎所有的东西

00:09:09.176 --> 00:09:10.586 A:middle
都像以前那样构建和工作

00:09:11.306 --> 00:09:14.026 A:middle
这为采用 Swift 4 的新特性

00:09:14.026 --> 00:09:15.906 A:middle
提供了绝佳的途径

00:09:15.906 --> 00:09:17.886 A:middle
因为它们中的大多数

00:09:17.886 --> 00:09:20.176 A:middle
都可以在 Swift 3.2 中使用

00:09:20.596 --> 00:09:22.506 A:middle
也可以在今年的

00:09:22.506 --> 00:09:25.696 A:middle
SDK 中使用所有

00:09:25.736 --> 00:09:28.036 A:middle
新的 API 和框架

00:09:28.266 --> 00:09:29.866 A:middle
现在 你可以随时迁移到 Swift 4 平台

00:09:29.866 --> 00:09:31.826 A:middle
在之前的几年里

00:09:31.826 --> 00:09:33.376 A:middle
我们提供一个 migrator

00:09:33.376 --> 00:09:35.676 A:middle
来把 Swift 3 中的代码

00:09:35.676 --> 00:09:39.186 A:middle
迁移到

00:09:39.186 --> 00:09:39.766 A:middle
Swift 4 里

00:09:40.526 --> 00:09:42.336 A:middle
现在 与前些年不同的是

00:09:42.596 --> 00:09:45.226 A:middle
这种迁移不会阻碍世界发展的脚步

00:09:45.226 --> 00:09:46.836 A:middle
这项工作直至

00:09:46.836 --> 00:09:48.656 A:middle
所有的一切都被迁移过去

00:09:48.656 --> 00:09:49.546 A:middle
才算结束

00:09:50.656 --> 00:09:52.636 A:middle
原因是 Swift3.2 和 Swift 4

00:09:52.636 --> 00:09:55.466 A:middle
可以在同一个

00:09:55.466 --> 00:09:56.246 A:middle
应用里共存

00:09:57.606 --> 00:09:58.726 A:middle
因此你可以设置

00:09:58.726 --> 00:09:59.216 A:middle
你需要的版本

00:10:00.516 --> 00:10:04.226 A:middle
[掌声]

00:10:04.726 --> 00:10:06.506 A:middle
你可以在每个目标的

00:10:06.506 --> 00:10:08.006 A:middle
基础上设置要使用的

00:10:08.006 --> 00:10:09.426 A:middle
语言版本

00:10:10.046 --> 00:10:10.846 A:middle
因此 如果你想要迁移到

00:10:10.846 --> 00:10:12.096 A:middle
Swift 4 你可以先迁移目标 App

00:10:12.096 --> 00:10:13.866 A:middle
但是框架和所有其他

00:10:13.866 --> 00:10:14.686 A:middle
附属项依然保留

00:10:14.686 --> 00:10:16.226 A:middle
Swift 3.2 的版本

00:10:16.466 --> 00:10:16.936 A:middle
这是没有问题的

00:10:17.516 --> 00:10:18.766 A:middle
当你的附属项

00:10:18.766 --> 00:10:20.006 A:middle
更新并升级到 Swift 4 时

00:10:20.006 --> 00:10:21.516 A:middle
那就太好了

00:10:21.666 --> 00:10:22.906 A:middle
它们能很好的适应你的 App

00:10:22.906 --> 00:10:24.426 A:middle
无论是 Swift 3.2 还是 Swift 4

00:10:25.196 --> 00:10:26.996 A:middle
Swift Package Manager

00:10:26.996 --> 00:10:27.966 A:middle
同样能做到这点

00:10:28.456 --> 00:10:29.756 A:middle
并且它将使用用于

00:10:29.756 --> 00:10:31.246 A:middle
开发包的工具版本

00:10:31.246 --> 00:10:33.536 A:middle
来构建包

00:10:33.536 --> 00:10:34.946 A:middle
如果一个包支持

00:10:34.946 --> 00:10:36.116 A:middle
多个 Swift 语言版本

00:10:36.116 --> 00:10:37.076 A:middle
它会被标注出来

00:10:37.076 --> 00:10:38.696 A:middle
因此 Swift Package Manage

00:10:38.696 --> 00:10:39.696 A:middle
总是会做出正确的选择

00:10:40.756 --> 00:10:42.466 A:middle
现在 我们在认为

00:10:42.466 --> 00:10:44.316 A:middle
Swift 3.2 和 Swift 4

00:10:44.376 --> 00:10:45.776 A:middle
共存的情况下

00:10:46.046 --> 00:10:48.336 A:middle
只需一点点的改变

00:10:48.396 --> 00:10:50.766 A:middle
你就可以轻易地

00:10:50.766 --> 00:10:52.526 A:middle
把代码从 Swift 3

00:10:52.526 --> 00:10:52.776 A:middle
迁移到 Swift 4

00:10:54.086 --> 00:10:55.376 A:middle
我们就先到这

00:10:55.376 --> 00:10:56.166 A:middle
下面有请 BOB 来谈谈

00:10:56.166 --> 00:10:56.966 A:middle
改进的构建

00:10:57.516 --> 00:11:03.046 A:middle
[掌声]

00:10:57.516 --> 00:11:03.046 A:middle
[掌声]

00:11:03.546 --> 00:11:05.256 A:middle
&gt;&gt;  随着 Swift App 的

00:11:05.256 --> 00:11:07.016 A:middle
规模和复杂度不断增加

00:11:07.016 --> 00:11:08.996 A:middle
我们一直在投资于

00:11:08.996 --> 00:11:10.556 A:middle
系统的改进

00:11:10.556 --> 00:11:12.036 A:middle
以期跟上这种增长

00:11:13.826 --> 00:11:15.826 A:middle
Xcode 9 有一个

00:11:15.826 --> 00:11:17.186 A:middle
全新的

00:11:17.256 --> 00:11:17.636 A:middle
构建系统

00:11:18.006 --> 00:11:19.686 A:middle
当然 这是用 Swift 编写的

00:11:19.976 --> 00:11:21.246 A:middle
它是在开源的 LLBuild

00:11:21.246 --> 00:11:23.606 A:middle
引擎上构建的

00:11:24.326 --> 00:11:26.476 A:middle
在计算构建的不同

00:11:26.476 --> 00:11:28.046 A:middle
步骤之间的依赖关系时

00:11:28.046 --> 00:11:29.536 A:middle
它的速度非常快

00:11:30.246 --> 00:11:31.396 A:middle
你很可能会在进行

00:11:31.446 --> 00:11:32.896 A:middle
进行大型项目的

00:11:32.896 --> 00:11:34.736 A:middle
增量构建时注意到这一点

00:11:35.886 --> 00:11:37.866 A:middle
这是 Xcode 9 中的

00:11:37.996 --> 00:11:38.616 A:middle
一个技术预览

00:11:38.846 --> 00:11:40.206 A:middle
我们诚挚的邀请你

00:11:40.206 --> 00:11:40.636 A:middle
去尝试一下

00:11:40.876 --> 00:11:42.656 A:middle
所以 找到文件菜单中的

00:11:42.656 --> 00:11:44.486 A:middle
项目或工作空间设置

00:11:44.486 --> 00:11:46.796 A:middle
并选择

00:11:47.506 --> 00:11:47.686 A:middle
新建系统

00:11:48.936 --> 00:11:50.916 A:middle
除了拥有一个更快的

00:11:50.976 --> 00:11:53.026 A:middle
构建系统之外

00:11:53.026 --> 00:11:54.876 A:middle
另外一个高效使用

00:11:54.876 --> 00:11:56.656 A:middle
系统的方法是避免多余的工作

00:11:57.186 --> 00:11:58.896 A:middle
Xcode 9 可以通过

00:11:58.896 --> 00:12:00.366 A:middle
很多途径来实现这个目的

00:11:58.896 --> 00:12:00.366 A:middle
很多途径来实现这个目的

00:12:01.296 --> 00:12:03.816 A:middle
预编译的桥接头

00:12:04.156 --> 00:12:05.956 A:middle
加速了大型混合源

00:12:06.066 --> 00:12:07.506 A:middle
项目的构建

00:12:08.246 --> 00:12:10.056 A:middle
桥接头描述了 Objective-C

00:12:10.056 --> 00:12:11.116 A:middle
中的接口

00:12:11.116 --> 00:12:13.116 A:middle
这样一来它们就可以

00:12:13.116 --> 00:12:14.676 A:middle
在你的 Swift 代码中使用

00:12:15.516 --> 00:12:16.476 A:middle
如果你有很多的 Objective-C

00:12:16.476 --> 00:12:18.556 A:middle
那么桥接头会非常大

00:12:18.556 --> 00:12:20.496 A:middle
编译速度

00:12:20.496 --> 00:12:21.446 A:middle
也会很慢

00:12:21.996 --> 00:12:23.656 A:middle
对于每个 Swift 文件来说

00:12:23.656 --> 00:12:25.706 A:middle
反复解析头文件的内容

00:12:25.706 --> 00:12:27.786 A:middle
是十分浪费的

00:12:29.326 --> 00:12:31.256 A:middle
Apple LLVM 编译器

00:12:31.256 --> 00:12:32.506 A:middle
有一个很好的解决方案

00:12:33.196 --> 00:12:34.426 A:middle
就是预先编译好头文件

00:12:35.916 --> 00:12:38.046 A:middle
Xcode 9 现在会使用

00:12:38.096 --> 00:12:39.886 A:middle
一个预编译版本的

00:12:39.886 --> 00:12:41.846 A:middle
桥接头 这样它只需

00:12:41.846 --> 00:12:43.256 A:middle
解析一次就足够了

00:12:45.166 --> 00:12:47.416 A:middle
Apple Music 是一个很好的例子

00:12:47.416 --> 00:12:49.666 A:middle
Xcode 9 极大地优化了它

00:12:49.866 --> 00:12:51.676 A:middle
音乐是一项非常大的工程

00:12:51.676 --> 00:12:53.126 A:middle
就编程语言来说 Objective-C

00:12:53.186 --> 00:12:54.846 A:middle
和 Swift 平分秋色

00:12:55.886 --> 00:12:57.446 A:middle
Xcode 9 的默认设置是

00:12:57.446 --> 00:12:59.156 A:middle
使用预编译的桥接头

00:12:59.236 --> 00:13:01.396 A:middle
在调试音乐时 这大约

00:12:59.236 --> 00:13:01.396 A:middle
在调试音乐时 这大约

00:13:01.396 --> 00:13:03.666 A:middle
可以节省 40% 的时间

00:13:04.426 --> 00:13:09.326 A:middle
另一个有力的工具是代码覆盖率测试

00:13:09.326 --> 00:13:11.846 A:middle
但在 Xcode 8 里

00:13:11.846 --> 00:13:13.576 A:middle
它很可能是

00:13:13.576 --> 00:13:14.586 A:middle
多余工作量的来源

00:13:15.616 --> 00:13:16.996 A:middle
设想一个常见的场景

00:13:16.996 --> 00:13:18.206 A:middle
你对代码进行了一些更改

00:13:18.206 --> 00:13:20.276 A:middle
把它用于构建

00:13:20.276 --> 00:13:21.126 A:middle
并尝试使用

00:13:21.196 --> 00:13:22.226 A:middle
覆盖测试

00:13:23.356 --> 00:13:24.586 A:middle
这是 Xcode

00:13:24.586 --> 00:13:25.986 A:middle
报表显示器中的样子

00:13:27.166 --> 00:13:29.046 A:middle
注意到那儿有一个额外的构建

00:13:29.686 --> 00:13:30.746 A:middle
它为什么会在那儿

00:13:32.046 --> 00:13:33.796 A:middle
覆盖测试是在编译器

00:13:33.796 --> 00:13:35.556 A:middle
中来实现的

00:13:35.556 --> 00:13:37.746 A:middle
它通过允许额外的插装代码

00:13:37.746 --> 00:13:39.086 A:middle
来计算每段代码

00:13:39.086 --> 00:13:40.226 A:middle
运行的次数

00:13:41.296 --> 00:13:43.106 A:middle
在 Xcode 8 中

00:13:43.106 --> 00:13:44.356 A:middle
普通的构建

00:13:44.356 --> 00:13:45.176 A:middle
不包括那个工具

00:13:45.176 --> 00:13:46.336 A:middle
因此 在进行

00:13:46.426 --> 00:13:48.396 A:middle
覆盖测试之前

00:13:48.396 --> 00:13:49.986 A:middle
整个项目需要进行重建

00:13:50.596 --> 00:13:54.896 A:middle
在 Xcode 9 中

00:13:54.896 --> 00:13:55.596 A:middle
我们整合了这些重建

00:13:56.016 --> 00:13:57.726 A:middle
如果你启用了

00:13:57.726 --> 00:14:00.126 A:middle
覆盖测试

00:13:57.726 --> 00:14:00.126 A:middle
覆盖测试

00:14:00.126 --> 00:14:01.456 A:middle
那么正常的构建

00:14:02.246 --> 00:14:03.736 A:middle
将包含检测仪表

00:14:03.736 --> 00:14:03.946 A:middle
这得稍微付出点成本

00:14:04.276 --> 00:14:06.246 A:middle
我们所检测的项目

00:14:06.246 --> 00:14:06.926 A:middle
的内容不到 3%

00:14:07.876 --> 00:14:10.076 A:middle
但你会得到巨大的收益

00:14:10.146 --> 00:14:11.226 A:middle
因为现在再

00:14:11.226 --> 00:14:12.866 A:middle
构建项目只需

00:14:12.866 --> 00:14:13.406 A:middle
一次即可

00:14:15.856 --> 00:14:18.426 A:middle
这对你来说的改变不是

00:14:18.426 --> 00:14:19.776 A:middle
能够让你更快的构建

00:14:20.646 --> 00:14:21.826 A:middle
而是要让你

00:14:24.036 --> 00:14:24.306 A:middle
彻底的杜绝它

00:14:25.516 --> 00:14:29.016 A:middle
[掌声]

00:14:29.516 --> 00:14:30.676 A:middle
索引是很棒的功能

00:14:30.816 --> 00:14:32.496 A:middle
就像是在全局中重命名重构一样

00:14:32.496 --> 00:14:33.956 A:middle
这是 Xcode 里一些最关键的

00:14:33.956 --> 00:14:35.746 A:middle
强大功能

00:14:36.676 --> 00:14:38.236 A:middle
但是后台索引

00:14:38.586 --> 00:14:39.446 A:middle
则毫无意义

00:14:40.886 --> 00:14:42.476 A:middle
无论何时构建项目

00:14:42.856 --> 00:14:44.226 A:middle
编译器都需要查找

00:14:44.226 --> 00:14:45.956 A:middle
符号索引所需要的

00:14:46.216 --> 00:14:47.476 A:middle
所有相同的

00:14:47.476 --> 00:14:47.926 A:middle
符号信息

00:14:48.306 --> 00:14:50.606 A:middle
正基于此 现在在

00:14:50.606 --> 00:14:52.456 A:middle
Xcode 9 中 需要构建项目时

00:14:52.506 --> 00:14:54.176 A:middle
我们会自动更新索引

00:14:54.796 --> 00:14:56.486 A:middle
在构建的时候

00:14:56.486 --> 00:14:58.566 A:middle
会付出一点点成本

00:14:58.566 --> 00:15:00.016 A:middle
但是没有必要

00:14:58.566 --> 00:15:00.016 A:middle
但是没有必要

00:15:00.016 --> 00:15:01.686 A:middle
在后台重复进行

00:15:01.686 --> 00:15:02.306 A:middle
所有的工作

00:15:02.946 --> 00:15:05.776 A:middle
所以 我们有了一个新的

00:15:05.866 --> 00:15:07.606 A:middle
构建系统和几种不同的

00:15:07.606 --> 00:15:08.796 A:middle
高效使用的方法

00:15:08.796 --> 00:15:10.806 A:middle
我们觉得这对那些

00:15:10.806 --> 00:15:12.116 A:middle
使用 Swift 构建

00:15:12.116 --> 00:15:13.906 A:middle
大型项目的人

00:15:13.906 --> 00:15:14.836 A:middle
尤为有用

00:15:16.256 --> 00:15:17.656 A:middle
现在让我们来看看

00:15:17.656 --> 00:15:18.966 A:middle
运行时间性能

00:15:20.276 --> 00:15:22.406 A:middle
提供高质量的代码

00:15:22.406 --> 00:15:24.266 A:middle
一直是 Swift 的

00:15:24.266 --> 00:15:25.356 A:middle
主要目标之一

00:15:25.446 --> 00:15:26.786 A:middle
每一个 Swift 新版本的发布

00:15:26.786 --> 00:15:28.266 A:middle
都意味着性能的

00:15:28.266 --> 00:15:28.906 A:middle
极大提升

00:15:29.776 --> 00:15:31.806 A:middle
下一步是使性能

00:15:31.806 --> 00:15:33.306 A:middle
变得更可预测

00:15:33.366 --> 00:15:34.066 A:middle
更稳定

00:15:35.736 --> 00:15:37.146 A:middle
让我们来看看一个

00:15:37.146 --> 00:15:37.746 A:middle
使用 Swift 3 的例子

00:15:38.736 --> 00:15:40.956 A:middle
我这里有一个简单的协议

00:15:40.956 --> 00:15:42.266 A:middle
它用一个比较函数来排序

00:15:42.266 --> 00:15:44.366 A:middle
另一个函数将通过对

00:15:44.706 --> 00:15:46.186 A:middle
一个值数组的排序

00:15:46.306 --> 00:15:47.696 A:middle
来进行测试

00:15:48.026 --> 00:15:49.146 A:middle
整个代码

00:15:50.006 --> 00:15:51.696 A:middle
非常的

00:15:51.696 --> 00:15:52.546 A:middle
简单易懂

00:15:52.616 --> 00:15:54.256 A:middle
它必须对所有

00:15:54.256 --> 00:15:55.806 A:middle
符合有序协议的值

00:15:55.806 --> 00:15:56.606 A:middle
都适用

00:15:57.236 --> 00:15:58.476 A:middle
即使数组中的

00:15:58.476 --> 00:15:59.436 A:middle
不同元素也可能

00:15:59.436 --> 00:16:00.366 A:middle
是不同的类型

00:15:59.436 --> 00:16:00.366 A:middle
是不同的类型

00:16:01.546 --> 00:16:02.766 A:middle
让我们来看看

00:16:02.816 --> 00:16:02.976 A:middle
它是如何工作的

00:16:04.756 --> 00:16:06.436 A:middle
这个图表以秒位单位展示了

00:16:06.486 --> 00:16:09.236 A:middle
对 100000 个 每个有 100 个元素

00:16:09.236 --> 00:16:10.506 A:middle
的数组进行排序所花费的时间

00:16:10.936 --> 00:16:12.466 A:middle
它测量的是不同

00:16:12.466 --> 00:16:13.966 A:middle
大小的数组元素

00:16:14.166 --> 00:16:16.846 A:middle
因此 对于一个单一结构体

00:16:16.846 --> 00:16:18.006 A:middle
完成这些排序需要

00:16:18.006 --> 00:16:19.576 A:middle
花费不到 2 秒的时间

00:16:20.576 --> 00:16:22.286 A:middle
如果由于某种原因

00:16:22.286 --> 00:16:24.236 A:middle
值的大小增加到双字

00:16:24.986 --> 00:16:26.656 A:middle
时间也只会

00:16:26.746 --> 00:16:27.176 A:middle
稍微增加一点点

00:16:27.176 --> 00:16:29.626 A:middle
如何值的大小增加到 3 字

00:16:30.136 --> 00:16:31.456 A:middle
跟刚才

00:16:31.456 --> 00:16:32.146 A:middle
也没什么不同

00:16:33.506 --> 00:16:34.586 A:middle
但一旦

00:16:34.586 --> 00:16:35.416 A:middle
增加到 4 字

00:16:36.846 --> 00:16:38.156 A:middle
那可就大事不妙了

00:16:38.566 --> 00:16:40.236 A:middle
这会比之前慢上九倍

00:16:41.566 --> 00:16:43.326 A:middle
怎么去解释刚刚发生的事情呢

00:16:44.756 --> 00:16:46.586 A:middle
要弄清楚这一点

00:16:46.586 --> 00:16:48.326 A:middle
我们需要深入了解 Swift

00:16:48.326 --> 00:16:49.736 A:middle
的实现机制

00:16:50.106 --> 00:16:51.316 A:middle
如果你对此感兴趣

00:16:51.316 --> 00:16:52.206 A:middle
我建议你看看

00:16:52.306 --> 00:16:53.866 A:middle
去年的

00:16:53.966 --> 00:16:54.726 A:middle
Understanding Swift Performance

00:16:55.306 --> 00:16:57.606 A:middle
现在 我来给你做一个

00:16:57.606 --> 00:16:57.976 A:middle
简单的总结

00:16:58.756 --> 00:17:01.246 A:middle
为了表示未知类型的值

00:16:58.756 --> 00:17:01.246 A:middle
为了表示未知类型的值

00:17:01.246 --> 00:17:03.496 A:middle
编译器使用了

00:17:03.496 --> 00:17:04.536 A:middle
我们现在所说的

00:17:04.536 --> 00:17:05.756 A:middle
存在容器的数据结构

00:17:06.695 --> 00:17:08.506 A:middle
在存在容器内部

00:17:08.896 --> 00:17:10.306 A:middle
有一个内嵌缓冲区

00:17:10.306 --> 00:17:11.566 A:middle
来存放较小的值

00:17:13.215 --> 00:17:14.506 A:middle
我们目前正在

00:17:14.576 --> 00:17:15.766 A:middle
重新评估缓冲区的大小

00:17:15.766 --> 00:17:18.086 A:middle
但是对于 Swift 4

00:17:18.086 --> 00:17:19.195 A:middle
来说 仍向往常一样

00:17:19.195 --> 00:17:19.566 A:middle
默认它是 3 个字长

00:17:21.386 --> 00:17:23.266 A:middle
如果该值太大

00:17:23.266 --> 00:17:25.226 A:middle
则无法与内联缓冲区匹配

00:17:25.226 --> 00:17:26.465 A:middle
那么它就会在堆中分配

00:17:27.435 --> 00:17:29.556 A:middle
而用堆存储的成本

00:17:29.556 --> 00:17:30.116 A:middle
十分高昂

00:17:31.016 --> 00:17:32.136 A:middle
这就是我们刚刚

00:17:32.136 --> 00:17:33.486 A:middle
看到大事不妙的

00:17:33.536 --> 00:17:33.906 A:middle
原因

00:17:35.216 --> 00:17:36.266 A:middle
那我们能做些什么呢

00:17:37.696 --> 00:17:39.586 A:middle
答案是 cow （牛）缓冲

00:17:40.076 --> 00:17:41.586 A:middle
存在的 cow （牛）缓冲

00:17:41.821 --> 00:17:43.821 A:middle
笑声

00:17:44.056 --> 00:17:45.276 A:middle
不是你们想的那种牛

00:17:45.756 --> 00:17:47.736 A:middle
COW 是 Copy On Right 的

00:17:47.736 --> 00:17:48.016 A:middle
首字母缩写

00:17:48.446 --> 00:17:49.646 A:middle
你可能听我们

00:17:49.646 --> 00:17:51.006 A:middle
之前讨论过这个问题

00:17:51.006 --> 00:17:52.886 A:middle
因为使用值语意

00:17:52.966 --> 00:17:53.446 A:middle
是提高性能的关键

00:17:55.506 --> 00:17:57.796 A:middle
在 Swift 4 里 如果一个值太大

00:17:57.796 --> 00:17:59.836 A:middle
与內联缓冲区不匹配

00:18:00.286 --> 00:18:02.326 A:middle
它就会和

00:18:02.326 --> 00:18:03.396 A:middle
一个引用计数一起在堆中被分配

00:18:04.096 --> 00:18:05.976 A:middle
只要保证是只读状态

00:18:06.026 --> 00:18:07.796 A:middle
多个存在容器

00:18:07.796 --> 00:18:08.936 A:middle
可以共享相同的

00:18:08.936 --> 00:18:09.246 A:middle
缓冲区

00:18:09.636 --> 00:18:11.186 A:middle
这样就避免了很多

00:18:11.186 --> 00:18:12.936 A:middle
冗余的堆分配

00:18:13.926 --> 00:18:15.326 A:middle
只有在有多个

00:18:15.326 --> 00:18:16.736 A:middle
引用的情况下

00:18:16.736 --> 00:18:19.186 A:middle
缓冲区才需要

00:18:19.406 --> 00:18:20.546 A:middle
被单独的

00:18:20.546 --> 00:18:21.386 A:middle
复制

00:18:22.076 --> 00:18:23.336 A:middle
Swift 现在就能

00:18:23.336 --> 00:18:24.566 A:middle
完全自动的为你

00:18:24.566 --> 00:18:25.856 A:middle
管理这些复杂的东西

00:18:27.356 --> 00:18:28.246 A:middle
这对性能

00:18:28.246 --> 00:18:28.866 A:middle
有什么影响

00:18:30.166 --> 00:18:31.436 A:middle
当然是变得更加稳定

00:18:32.246 --> 00:18:34.256 A:middle
相较于之前用超过 18 秒

00:18:34.326 --> 00:18:35.946 A:middle
的时间来对这些前结构

00:18:35.946 --> 00:18:37.726 A:middle
进行排序 现在只需要

00:18:37.726 --> 00:18:38.926 A:middle
4 秒多一点

00:18:39.536 --> 00:18:41.266 A:middle
这是一个平缓的过程

00:18:41.266 --> 00:18:42.146 A:middle
而不是一蹴而就

00:18:42.806 --> 00:18:45.846 A:middle
这种改进适用于

00:18:45.846 --> 00:18:46.946 A:middle
编译器处理

00:18:46.946 --> 00:18:48.216 A:middle
那些根本不清楚

00:18:48.216 --> 00:18:49.536 A:middle
类型的值的情况

00:18:50.246 --> 00:18:51.616 A:middle
但是类似的问题

00:18:51.616 --> 00:18:53.156 A:middle
出现在通用代码中

00:18:53.156 --> 00:18:54.586 A:middle
他的类型是参数

00:18:55.266 --> 00:18:56.366 A:middle
让我们来看看

00:18:58.316 --> 00:18:59.806 A:middle
在许多情况下

00:18:59.806 --> 00:19:01.486 A:middle
编译器能够通过

00:18:59.806 --> 00:19:01.486 A:middle
编译器能够通过

00:19:01.976 --> 00:19:03.696 A:middle
为特定类型使用

00:19:04.096 --> 00:19:05.206 A:middle
专门的版本来快速地实现通用代码

00:19:05.896 --> 00:19:07.176 A:middle
但是有时编译器不能

00:19:07.176 --> 00:19:09.026 A:middle
识别特定的类型

00:19:09.106 --> 00:19:10.746 A:middle
然后它需要使用

00:19:10.746 --> 00:19:12.336 A:middle
非专用的通用代码

00:19:13.206 --> 00:19:14.896 A:middle
这就慢的多了

00:19:15.306 --> 00:19:16.526 A:middle
这是那种大事不妙的

00:19:16.526 --> 00:19:17.436 A:middle
另一种表现形式

00:19:18.676 --> 00:19:20.656 A:middle
到目前为止 Swift已经在

00:19:20.656 --> 00:19:22.546 A:middle
非专用代码中使用了

00:19:22.546 --> 00:19:23.866 A:middle
通用缓冲区的堆分配

00:19:24.156 --> 00:19:25.946 A:middle
正如我们刚刚看到的

00:19:25.946 --> 00:19:27.866 A:middle
堆分配的速度非常慢

00:19:28.776 --> 00:19:31.236 A:middle
Swift 4 现在使用的是

00:19:31.236 --> 00:19:32.136 A:middle
堆栈分配的通用缓冲区

00:19:32.486 --> 00:19:34.166 A:middle
因此 对于非专用的

00:19:34.446 --> 00:19:37.906 A:middle
通用代码 我们进行了

00:19:38.136 --> 00:19:39.886 A:middle
类似的改进

00:19:39.976 --> 00:19:41.846 A:middle
让 Swift 的性能得到持续优化

00:19:41.846 --> 00:19:42.226 A:middle
需要我们共同的努力

00:19:42.756 --> 00:19:45.056 A:middle
Swift 4 已经

00:19:45.346 --> 00:19:46.596 A:middle
在处理棘手问题上

00:19:46.596 --> 00:19:49.576 A:middle
取得了巨大的进步

00:19:50.176 --> 00:19:51.736 A:middle
性能的另一个考核度

00:19:51.996 --> 00:19:52.576 A:middle
是大小

00:19:54.196 --> 00:19:56.006 A:middle
随着你的 App 越来越大

00:19:56.006 --> 00:19:58.446 A:middle
代码大小也变得

00:19:58.516 --> 00:19:59.786 A:middle
越来越重要

00:20:01.096 --> 00:20:02.656 A:middle
使代码缩小的一个例子是

00:20:02.656 --> 00:20:05.376 A:middle
避免未使用的代码

00:20:06.606 --> 00:20:08.166 A:middle
让我们回到 Doug

00:20:08.166 --> 00:20:09.566 A:middle
一个日期结构体的例子

00:20:10.126 --> 00:20:11.656 A:middle
与任何值类型一样

00:20:11.656 --> 00:20:13.536 A:middle
让它符合平等的

00:20:13.536 --> 00:20:14.956 A:middle
可比较的协议

00:20:14.956 --> 00:20:15.516 A:middle
是一个好主意

00:20:16.476 --> 00:20:17.766 A:middle
但如果你的 App 中

00:20:17.766 --> 00:20:19.216 A:middle
没有使用其中任何一个

00:20:19.216 --> 00:20:19.466 A:middle
那该怎么办

00:20:20.196 --> 00:20:21.656 A:middle
你不该为不用的代码

00:20:21.686 --> 00:20:25.366 A:middle
浪费资源

00:20:25.556 --> 00:20:27.966 A:middle
在 Swift 4 中

00:20:27.966 --> 00:20:30.536 A:middle
编译器会自动优化

00:20:30.536 --> 00:20:32.146 A:middle
所使用的内容

00:20:32.146 --> 00:20:33.336 A:middle
这样你就不必

00:20:33.336 --> 00:20:33.616 A:middle
再多费力气

00:20:34.296 --> 00:20:35.686 A:middle
请注意 这与其他优化

00:20:35.686 --> 00:20:37.336 A:middle
如反虚拟化

00:20:37.336 --> 00:20:39.186 A:middle
和内连进行了交互

00:20:39.496 --> 00:20:41.616 A:middle
这些优化将为编译器

00:20:41.616 --> 00:20:42.946 A:middle
消除不需要的代码

00:20:42.946 --> 00:20:44.086 A:middle
提供一些更多的方法

00:20:44.746 --> 00:20:47.326 A:middle
这就是编译器

00:20:47.326 --> 00:20:48.876 A:middle
可以完全自动

00:20:48.876 --> 00:20:49.596 A:middle
完成的优化

00:20:50.436 --> 00:20:51.816 A:middle
当然这并不总是可行的

00:20:52.646 --> 00:20:54.466 A:middle
让我们来看看另一个例子

00:20:55.456 --> 00:20:57.956 A:middle
这里我简单定义一个类

00:20:57.956 --> 00:20:58.776 A:middle
它有两个函数

00:20:59.816 --> 00:21:01.156 A:middle
编译器将生成这些函数

00:20:59.816 --> 00:21:01.156 A:middle
编译器将生成这些函数

00:21:01.156 --> 00:21:05.126 A:middle
因为在 Swift 3 中

00:21:05.126 --> 00:21:07.316 A:middle
这是 NSObject 的一个子类

00:21:08.106 --> 00:21:10.536 A:middle
语言会自行判断

00:21:10.536 --> 00:21:12.716 A:middle
编译器也会推断

00:21:12.716 --> 00:21:14.036 A:middle
Objc 的属性

00:21:15.416 --> 00:21:16.806 A:middle
这意味着

00:21:16.806 --> 00:21:18.226 A:middle
这些函数可以从

00:21:18.226 --> 00:21:19.366 A:middle
Objective-C 中访问

00:21:20.376 --> 00:21:22.066 A:middle
因此

00:21:22.066 --> 00:21:24.506 A:middle
编译器会生成

00:21:24.506 --> 00:21:25.566 A:middle
与 Ojective-C

00:21:25.566 --> 00:21:27.146 A:middle
函数兼容的换函数

00:21:27.196 --> 00:21:29.056 A:middle
并把它推送至 Swift 函数

00:21:30.756 --> 00:21:32.756 A:middle
现在 Swift 中的函数

00:21:32.756 --> 00:21:33.846 A:middle
仍然可以被直接调用

00:21:34.176 --> 00:21:36.016 A:middle
在我的示例中

00:21:36.766 --> 00:21:37.996 A:middle
show 调用 print

00:21:37.996 --> 00:21:39.576 A:middle
这就意味着

00:21:39.576 --> 00:21:40.426 A:middle
这些换函数经常被闲置

00:21:41.026 --> 00:21:44.646 A:middle
但是因为他们被计算在

00:21:44.646 --> 00:21:45.956 A:middle
Objective-C 的运行时间里

00:21:45.956 --> 00:21:47.846 A:middle
编译器无法告诉你

00:21:47.846 --> 00:21:48.416 A:middle
他们是有没有被使用的

00:21:49.036 --> 00:21:51.196 A:middle
解决这个问题需要

00:21:51.196 --> 00:21:52.126 A:middle
改变语言模型

00:21:53.256 --> 00:21:55.806 A:middle
因此 在 Swift 4 中

00:21:55.806 --> 00:21:57.846 A:middle
Objc 属性只在

00:21:57.906 --> 00:21:59.306 A:middle
有需要的情况下

00:21:59.306 --> 00:21:59.626 A:middle
才会被推断出来

00:21:59.686 --> 00:22:00.936 A:middle
比如当你重写

00:21:59.686 --> 00:22:00.936 A:middle
比如当你重写

00:22:00.936 --> 00:22:02.426 A:middle
Objective-C 的方法

00:22:02.426 --> 00:22:03.966 A:middle
或者统一 Objective-C

00:22:04.016 --> 00:22:04.776 A:middle
协议时

00:22:05.656 --> 00:22:08.036 A:middle
这种改变避免了许多

00:22:08.036 --> 00:22:09.286 A:middle
未使用的换函数

00:22:10.796 --> 00:22:12.536 A:middle
当我们在 Apple Music 中

00:22:12.536 --> 00:22:14.026 A:middle
采用这一功能时

00:22:14.076 --> 00:22:14.976 A:middle
代码几乎减少了 6%

00:22:19.566 --> 00:22:21.266 A:middle
当你有了一组

00:22:21.616 --> 00:22:23.106 A:middle
想要访问的函数

00:22:23.106 --> 00:22:25.136 A:middle
和 Objective-C 时

00:22:25.196 --> 00:22:26.126 A:middle
我们建议你把它们放在一个

00:22:26.126 --> 00:22:28.336 A:middle
放在一个扩展中

00:22:28.336 --> 00:22:29.546 A:middle
然后用 Objc 属性标记扩展

00:22:30.026 --> 00:22:31.436 A:middle
这保证了

00:22:31.436 --> 00:22:32.696 A:middle
所有这些函数都可以

00:22:32.696 --> 00:22:33.866 A:middle
用在 Objective-C 代码中

00:22:34.416 --> 00:22:35.846 A:middle
如果因为某些原因

00:22:35.846 --> 00:22:38.436 A:middle
导致不能成功运行

00:22:38.436 --> 00:22:38.976 A:middle
编译器会向你报错

00:22:41.556 --> 00:22:43.316 A:middle
那么采取这种改变

00:22:43.316 --> 00:22:43.976 A:middle
需要些什么呢

00:22:44.476 --> 00:22:45.906 A:middle
Doug 提到了迁移工具

00:22:45.906 --> 00:22:47.186 A:middle
这可以帮你吧代码

00:22:47.186 --> 00:22:47.886 A:middle
迁移到 Swift 4

00:22:48.506 --> 00:22:50.486 A:middle
Objc 推理迁移工具

00:22:50.486 --> 00:22:51.416 A:middle
提供了一个选择

00:22:52.046 --> 00:22:53.336 A:middle
如果你不关心

00:22:53.336 --> 00:22:55.246 A:middle
代码的大小

00:22:55.246 --> 00:22:57.056 A:middle
那么迁移工具可以轻松地

00:22:57.056 --> 00:22:59.056 A:middle
匹配 Swift 3 的行为

00:22:59.056 --> 00:23:00.816 A:middle
只需将 Objc 属性插入到

00:22:59.056 --> 00:23:00.816 A:middle
只需将 Objc 属性插入到

00:23:00.816 --> 00:23:02.276 A:middle
先前推断的地方即可

00:23:03.156 --> 00:23:04.496 A:middle
只需一点点改动

00:23:04.496 --> 00:23:06.206 A:middle
利用最小的推断

00:23:06.206 --> 00:23:08.226 A:middle
就可以享受

00:23:08.226 --> 00:23:09.766 A:middle
代码改善的乐趣

00:23:10.316 --> 00:23:13.206 A:middle
如果你使用该选项

00:23:13.206 --> 00:23:15.256 A:middle
进行最小推断

00:23:15.256 --> 00:23:17.456 A:middle
那么迁移工具将首先

00:23:17.456 --> 00:23:18.956 A:middle
找到确定需要

00:23:18.956 --> 00:23:20.786 A:middle
Objc 属性的

00:23:20.786 --> 00:23:21.216 A:middle
所有位置

00:23:21.216 --> 00:23:22.646 A:middle
它会这样做

00:23:22.646 --> 00:23:23.886 A:middle
并且自动插入

00:23:24.966 --> 00:23:26.386 A:middle
这可能还不够

00:23:26.816 --> 00:23:28.416 A:middle
因为迁移工具

00:23:28.416 --> 00:23:30.626 A:middle
无法单独的在 Swift 模块或

00:23:30.626 --> 00:23:32.226 A:middle
Object-C 代码中

00:23:32.226 --> 00:23:33.246 A:middle
检测到问题

00:23:34.106 --> 00:23:35.496 A:middle
因此为了帮你

00:23:35.496 --> 00:23:38.736 A:middle
找到这些位置

00:23:38.736 --> 00:23:39.776 A:middle
迁移工具将标记那些

00:23:39.776 --> 00:23:42.046 A:middle
被推断为过时的换函数

00:23:42.766 --> 00:23:44.166 A:middle
然后你可以构建代码

00:23:44.166 --> 00:23:45.466 A:middle
并运行代码

00:23:45.466 --> 00:23:46.516 A:middle
查找弃用警告

00:23:47.806 --> 00:23:49.306 A:middle
让我们更仔细的看一下

00:23:50.336 --> 00:23:51.936 A:middle
下面是一个构建

00:23:51.936 --> 00:23:52.236 A:middle
警告的例子

00:23:53.246 --> 00:23:55.266 A:middle
我有一个 Swift 函数

00:23:55.266 --> 00:23:56.596 A:middle
来显示我视图控制器

00:23:56.596 --> 00:23:57.116 A:middle
的状态

00:23:57.576 --> 00:23:58.786 A:middle
我正在从 Objective-C

00:23:58.786 --> 00:23:59.806 A:middle
代码中调用这个

00:24:00.226 --> 00:24:01.706 A:middle
但因为我仍然依赖于

00:24:01.706 --> 00:24:03.236 A:middle
Objc 推论 所以我

00:24:03.236 --> 00:24:04.666 A:middle
得到了被弃用的

00:24:04.666 --> 00:24:05.356 A:middle
警告

00:24:05.906 --> 00:24:08.216 A:middle
为了解决这个问题

00:24:08.306 --> 00:24:09.976 A:middle
我需要在 Swift 代码中

00:24:09.976 --> 00:24:11.356 A:middle
找到这个位置 在这个代码中

00:24:11.986 --> 00:24:13.756 A:middle
定义了函数并添加 Objc 属性

00:24:14.256 --> 00:24:19.076 A:middle
有些问题可能在

00:24:19.076 --> 00:24:20.326 A:middle
构建初显现不出来

00:24:20.366 --> 00:24:22.026 A:middle
在 Objective-C 中 我们

00:24:22.026 --> 00:24:24.156 A:middle
可以用一种无法在运行前

00:24:24.156 --> 00:24:26.136 A:middle
检测到的方式来引用函数

00:24:26.876 --> 00:24:28.466 A:middle
因此 出于这个原因

00:24:28.466 --> 00:24:30.756 A:middle
常跑代码 常做测试

00:24:30.956 --> 00:24:32.626 A:middle
尽可能多地练习写代码

00:24:32.626 --> 00:24:34.176 A:middle
多看 Xcode 调试区中的控制台

00:24:34.726 --> 00:24:36.336 A:middle
所给出的提示信息

00:24:36.526 --> 00:24:38.486 A:middle
这都是很

00:24:38.486 --> 00:24:39.246 A:middle
重要的事情

00:24:39.336 --> 00:24:40.556 A:middle
这告诉你需要

00:24:40.556 --> 00:24:41.626 A:middle
添加 OBjc 属性

00:24:42.506 --> 00:24:45.586 A:middle
注意 这里的消息

00:24:45.586 --> 00:24:46.886 A:middle
向你显示了

00:24:46.886 --> 00:24:48.546 A:middle
函数定义的

00:24:48.596 --> 00:24:49.056 A:middle
确切源位置

00:24:49.056 --> 00:24:50.366 A:middle
因此 你可以直接到

00:24:50.366 --> 00:24:53.826 A:middle
那个位置并添加属性

00:24:53.926 --> 00:24:55.336 A:middle
一旦你修复了所有的

00:24:55.336 --> 00:24:57.736 A:middle
构建和运行警告

00:24:57.736 --> 00:24:59.226 A:middle
就去为项目进行构建设置

00:24:59.566 --> 00:25:01.276 A:middle
更改 Swift 3 Objc 设置

00:24:59.566 --> 00:25:01.276 A:middle
更改 Swift 3 Objc 设置

00:25:01.276 --> 00:25:03.286 A:middle
设置为默认设置

00:25:03.286 --> 00:25:05.146 A:middle
这样就完成了

00:25:05.216 --> 00:25:05.516 A:middle
迁移的过程

00:25:06.166 --> 00:25:07.486 A:middle
这真的不是那么难

00:25:08.086 --> 00:25:09.486 A:middle
我们为 Apple Music

00:25:09.686 --> 00:25:11.886 A:middle
做了同样的事情

00:25:11.886 --> 00:25:13.706 A:middle
在一个很大的项目中

00:25:13.706 --> 00:25:15.696 A:middle
只有大约 40 处需要

00:25:15.696 --> 00:25:16.946 A:middle
添加 Objc 属性的地方

00:25:17.476 --> 00:25:19.446 A:middle
其中超过 30 个

00:25:19.446 --> 00:25:20.566 A:middle
可以由迁移工具

00:25:20.566 --> 00:25:22.316 A:middle
自动完成

00:25:22.806 --> 00:25:26.136 A:middle
这种更改限制了 Objc

00:25:26.136 --> 00:25:27.796 A:middle
推论 以及消除

00:25:27.796 --> 00:25:30.066 A:middle
为使用协议的优化

00:25:30.066 --> 00:25:32.316 A:middle
这两种方法都有助于

00:25:32.316 --> 00:25:33.436 A:middle
减少代码的大小

00:25:33.436 --> 00:25:36.016 A:middle
现在我来告诉你

00:25:36.016 --> 00:25:37.686 A:middle
另外一个改变

00:25:37.686 --> 00:25:39.406 A:middle
它对你 App 的整体

00:25:39.406 --> 00:25:41.106 A:middle
大小有更大的影响

00:25:42.076 --> 00:25:44.486 A:middle
除了组成一个编译

00:25:44.486 --> 00:25:45.846 A:middle
Swift 应用的 指令和

00:25:45.936 --> 00:25:48.176 A:middle
数据外 Swift框架中的

00:25:48.176 --> 00:25:50.816 A:middle
符号表占据了

00:25:50.886 --> 00:25:51.266 A:middle
大量的空间

00:25:52.366 --> 00:25:54.726 A:middle
Swift 使用了很多的符号

00:25:54.726 --> 00:25:58.016 A:middle
而且名字通常都很长

00:25:58.206 --> 00:26:01.376 A:middle
比如 在 Swift 3.1 中

00:25:58.206 --> 00:26:01.376 A:middle
比如 在 Swift 3.1 中

00:26:01.456 --> 00:26:03.476 A:middle
几乎一半的标准库

00:26:03.516 --> 00:26:04.866 A:middle
都是由符号组成的

00:26:05.186 --> 00:26:06.736 A:middle
就像这里深蓝色

00:26:06.736 --> 00:26:06.966 A:middle
柱状图显示的那样

00:26:08.016 --> 00:26:10.776 A:middle
在 Swift 4 中

00:26:10.776 --> 00:26:11.676 A:middle
符号所需的空间要小得多

00:26:11.676 --> 00:26:12.996 A:middle
所以 尽管标准库

00:26:12.996 --> 00:26:14.306 A:middle
中有了更多的

00:26:14.306 --> 00:26:14.836 A:middle
内容

00:26:15.346 --> 00:26:17.166 A:middle
总大小实际上

00:26:17.166 --> 00:26:17.626 A:middle
是减小的

00:26:19.146 --> 00:26:20.496 A:middle
我们通过使名字变短

00:26:20.496 --> 00:26:22.956 A:middle
同时去掉符号来

00:26:22.956 --> 00:26:24.576 A:middle
实现这个目标

00:26:25.286 --> 00:26:28.526 A:middle
静态链接器和动态链接器

00:26:28.526 --> 00:26:30.316 A:middle
都使用单独的

00:26:30.316 --> 00:26:32.096 A:middle
Trie 数据结构

00:26:32.096 --> 00:26:32.946 A:middle
来快速查找符号

00:26:33.956 --> 00:26:35.286 A:middle
因此 这意味着

00:26:35.286 --> 00:26:37.156 A:middle
在符号表中

00:26:37.156 --> 00:26:38.616 A:middle
很少需要 Swift 符号

00:26:39.706 --> 00:26:41.596 A:middle
Xcode 9 有一个新的构建设置

00:26:41.796 --> 00:26:44.156 A:middle
即去掉默认启用的

00:26:44.156 --> 00:26:45.366 A:middle
Swift 符号

00:26:46.646 --> 00:26:47.986 A:middle
如果他对你的

00:26:47.986 --> 00:26:49.176 A:middle
工作流程带来问题

00:26:49.176 --> 00:26:49.736 A:middle
那么你可以选择关闭它

00:26:50.676 --> 00:26:52.926 A:middle
但是 Xcode 通常把

00:26:52.926 --> 00:26:55.726 A:middle
符号剥离作为

00:26:55.726 --> 00:26:57.266 A:middle
归档项目的一部分

00:26:57.566 --> 00:26:59.336 A:middle
因此 这个特性对

00:26:59.336 --> 00:27:00.746 A:middle
开发的早期阶段

00:26:59.336 --> 00:27:00.746 A:middle
开发的早期阶段

00:27:00.746 --> 00:27:01.306 A:middle
没有影响

00:27:01.306 --> 00:27:02.896 A:middle
特别是 它不应该

00:27:02.896 --> 00:27:04.516 A:middle
干扰正常的

00:27:04.516 --> 00:27:05.266 A:middle
调试或分析

00:27:05.856 --> 00:27:09.176 A:middle
如果出于某种原因

00:27:09.176 --> 00:27:10.466 A:middle
你想要检查二进制文件中

00:27:10.506 --> 00:27:12.196 A:middle
被分离后

00:27:12.236 --> 00:27:12.796 A:middle
依然存在的符号

00:27:13.296 --> 00:27:15.616 A:middle
你可以使用带导出选项的

00:27:15.906 --> 00:27:17.836 A:middle
DYLD 信息查看工具

00:27:17.836 --> 00:27:18.936 A:middle
来查看导出的符号

00:27:19.586 --> 00:27:22.776 A:middle
这个构建设置适用于

00:27:22.776 --> 00:27:24.486 A:middle
你在项目中

00:27:24.486 --> 00:27:25.076 A:middle
构建的代码

00:27:26.186 --> 00:27:27.786 A:middle
Swift 标准库

00:27:27.786 --> 00:27:28.706 A:middle
是被分开处理的

00:27:29.426 --> 00:27:31.086 A:middle
他们作为 App Thinning

00:27:31.206 --> 00:27:31.486 A:middle
的一部分被分离

00:27:32.716 --> 00:27:33.896 A:middle
理解这一点很重要

00:27:33.896 --> 00:27:34.876 A:middle
因为如果你想测量

00:27:34.876 --> 00:27:36.216 A:middle
App 的大小

00:27:36.806 --> 00:27:37.926 A:middle
你需要回顾 Xcode 的分布式

00:27:37.926 --> 00:27:39.956 A:middle
工作流程

00:27:40.356 --> 00:27:41.586 A:middle
并导出 App

00:27:42.086 --> 00:27:43.796 A:middle
当你这样做时

00:27:43.796 --> 00:27:45.056 A:middle
就会看到一个新的设置

00:27:45.056 --> 00:27:46.646 A:middle
你可以用它来控制

00:27:46.646 --> 00:27:48.866 A:middle
是否需要从标准库中

00:27:48.866 --> 00:27:49.836 A:middle
去除符号

00:27:51.126 --> 00:27:52.966 A:middle
你可以选择关闭这项功能

00:27:52.966 --> 00:27:54.816 A:middle
但在大多数情况下

00:27:54.816 --> 00:27:55.976 A:middle
我们建议保留

00:27:56.056 --> 00:27:57.726 A:middle
因为他会大大

00:27:57.726 --> 00:27:59.276 A:middle
减少你 App 的

00:28:00.026 --> 00:28:00.106 A:middle
大小

00:28:00.716 --> 00:28:02.836 A:middle
接下来 Ben

00:28:02.956 --> 00:28:04.026 A:middle
会讲到字符串

00:28:04.026 --> 00:28:05.126 A:middle
集合和泛型

00:28:05.126 --> 00:28:05.676 A:middle
的更新

00:28:06.516 --> 00:28:11.236 A:middle
[掌声]

00:28:11.736 --> 00:28:12.106 A:middle
&gt;&gt;  谢谢你 Bob

00:28:13.066 --> 00:28:14.356 A:middle
在这个新版本中

00:28:14.356 --> 00:28:15.646 A:middle
我们在标准库和泛型

00:28:15.646 --> 00:28:16.816 A:middle
中有一些非常棒的特性

00:28:16.816 --> 00:28:18.316 A:middle
我将从字符串

00:28:18.376 --> 00:28:18.746 A:middle
说起

00:28:19.946 --> 00:28:21.506 A:middle
Swift 4 中的字符串

00:28:21.546 --> 00:28:23.446 A:middle
使处理字符的速度

00:28:23.446 --> 00:28:25.326 A:middle
更快 更容易

00:28:25.326 --> 00:28:27.226 A:middle
但他们的共同目标都是

00:28:27.226 --> 00:28:28.786 A:middle
帮你编写 Unicode

00:28:28.786 --> 00:28:29.386 A:middle
形式下正确的代码

00:28:29.386 --> 00:28:32.506 A:middle
那什么叫做 Unicode

00:28:32.506 --> 00:28:32.826 A:middle
形式下的正确呢

00:28:33.986 --> 00:28:34.896 A:middle
这绝大部分是源于

00:28:34.896 --> 00:28:36.246 A:middle
我们谈论的

00:28:36.246 --> 00:28:36.886 A:middle
叫字符的东西

00:28:38.186 --> 00:28:39.476 A:middle
在大多数的编程语言中

00:28:39.476 --> 00:28:42.276 A:middle
字符只是一个数字

00:28:42.276 --> 00:28:42.916 A:middle
或是一些编码

00:28:43.716 --> 00:28:44.866 A:middle
在比较老的系统中

00:28:44.996 --> 00:28:45.236 A:middle
可能是 ASCII 码

00:28:45.756 --> 00:28:46.746 A:middle
现在 它可能是 Unicode

00:28:46.746 --> 00:28:47.856 A:middle
编码中的一种

00:28:48.916 --> 00:28:50.816 A:middle
可是为什么这很重要

00:28:50.816 --> 00:28:53.896 A:middle
让我们来看一个例子

00:28:54.496 --> 00:28:58.456 A:middle
在 Unicode 中

00:28:58.456 --> 00:29:01.286 A:middle
有突出重音的单个字母 e

00:28:58.456 --> 00:29:01.286 A:middle
有突出重音的单个字母 e

00:29:01.286 --> 00:29:02.426 A:middle
可以使用两种不同的

00:29:02.426 --> 00:29:02.716 A:middle
方式来进行编码

00:29:04.076 --> 00:29:06.766 A:middle
一种方法是使用单一的

00:29:06.766 --> 00:29:08.356 A:middle
Unicode 标量 E 9

00:29:09.576 --> 00:29:11.236 A:middle
另一种方法是

00:29:11.236 --> 00:29:13.426 A:middle
单纯使用字母 E

00:29:13.426 --> 00:29:15.106 A:middle
和灵敏重音修饰符

00:29:16.346 --> 00:29:17.456 A:middle
这两种对相同字母

00:29:17.456 --> 00:29:18.976 A:middle
的不同编码方式

00:29:18.976 --> 00:29:20.366 A:middle
正是 Unicode 所说的等同规范

00:29:21.196 --> 00:29:22.006 A:middle
无需任何改变

00:29:22.126 --> 00:29:23.926 A:middle
你就可以使用其中

00:29:23.926 --> 00:29:24.486 A:middle
的任何一个

00:29:25.706 --> 00:29:27.746 A:middle
所以 这在代码中意味着什么呢

00:29:28.656 --> 00:29:30.076 A:middle
当一种语言

00:29:30.076 --> 00:29:31.736 A:middle
默认查看代码的方式

00:29:32.026 --> 00:29:33.106 A:middle
是查看各个字符串

00:29:33.106 --> 00:29:34.256 A:middle
中的代码单元时

00:29:34.256 --> 00:29:35.386 A:middle
你就会发现

00:29:35.446 --> 00:29:35.916 A:middle
一些奇怪的行为

00:29:36.876 --> 00:29:38.216 A:middle
这是一个在 Ruby 中的例子

00:29:38.216 --> 00:29:39.806 A:middle
但是在其它语言中

00:29:39.806 --> 00:29:41.146 A:middle
比如 Java 或 C 中 也通用

00:29:42.016 --> 00:29:43.676 A:middle
我们可以用两种不同的

00:29:43.676 --> 00:29:45.306 A:middle
方式创建两个字符串

00:29:45.346 --> 00:29:46.376 A:middle
他们应当是完全相同的

00:29:46.866 --> 00:29:48.556 A:middle
对用户来说他们看起来是一样的

00:29:50.026 --> 00:29:51.256 A:middle
但当我们去计算

00:29:51.586 --> 00:29:53.646 A:middle
字符的数量时

00:29:53.646 --> 00:29:54.276 A:middle
就会得到不同的结果

00:29:55.026 --> 00:29:56.926 A:middle
如果我们使用的是

00:29:56.926 --> 00:29:58.636 A:middle
默认的比较运算

00:29:58.636 --> 00:29:59.236 A:middle
他们就不是相等的

00:30:00.416 --> 00:30:01.636 A:middle
这可能会导致一些

00:30:01.636 --> 00:30:02.806 A:middle
难以理解和

00:30:02.806 --> 00:30:03.256 A:middle
诊断的问题

00:30:03.986 --> 00:30:05.296 A:middle
这就是为什么 Swift

00:30:05.406 --> 00:30:06.426 A:middle
采用的方法

00:30:06.426 --> 00:30:06.866 A:middle
略有不同

00:30:08.136 --> 00:30:10.516 A:middle
在 Swift 中

00:30:10.516 --> 00:30:12.036 A:middle
字符是为字形所冷却的

00:30:13.046 --> 00:30:14.486 A:middle
当用户在屏幕上

00:30:14.486 --> 00:30:15.456 A:middle
看到一个字形时

00:30:15.456 --> 00:30:16.866 A:middle
大多数用户

00:30:16.866 --> 00:30:17.376 A:middle
会认为那是一个字符

00:30:18.576 --> 00:30:20.256 A:middle
在 Swift 中 无论你

00:30:20.256 --> 00:30:21.636 A:middle
如何组合一个特定的

00:30:22.096 --> 00:30:24.266 A:middle
字形 它都是一个字符

00:30:24.266 --> 00:30:25.556 A:middle
两个不同组成却相对等的

00:30:25.556 --> 00:30:26.986 A:middle
字形相比较起来也是相等的

00:30:27.586 --> 00:30:30.866 A:middle
将字符串拆分

00:30:30.866 --> 00:30:32.426 A:middle
成字形的逻辑

00:30:32.476 --> 00:30:33.366 A:middle
可能相当复杂

00:30:34.156 --> 00:30:36.146 A:middle
例如 家庭表情符号

00:30:36.146 --> 00:30:38.036 A:middle
是由成人表情符号

00:30:38.246 --> 00:30:39.026 A:middle
和儿童表情符号组合而成的

00:30:40.426 --> 00:30:41.846 A:middle
在 Swift 4 中

00:30:41.846 --> 00:30:43.256 A:middle
因为我们使用的

00:30:43.256 --> 00:30:44.296 A:middle
是在操作系统中

00:30:44.296 --> 00:30:45.906 A:middle
构建的 Unicode 9

00:30:45.906 --> 00:30:46.606 A:middle
图形 所以把它记为一个字符

00:30:47.226 --> 00:30:50.406 A:middle
但这种复杂的逻辑

00:30:50.406 --> 00:30:50.906 A:middle
也来之不易

00:30:51.206 --> 00:30:52.266 A:middle
在之前版本的 Swift 中

00:30:52.266 --> 00:30:53.526 A:middle
你为每一个处理过的

00:30:53.556 --> 00:30:55.346 A:middle
字符都付出了

00:30:55.346 --> 00:30:55.826 A:middle
成本

00:30:55.986 --> 00:30:56.886 A:middle
即使是简单字符也是如此

00:30:57.926 --> 00:30:59.296 A:middle
在这个版本中

00:30:59.296 --> 00:31:00.866 A:middle
我们为许多

00:30:59.296 --> 00:31:00.866 A:middle
我们为许多

00:31:00.866 --> 00:31:02.446 A:middle
不同语言的简单字符

00:31:02.446 --> 00:31:02.886 A:middle
添加了快速通道

00:31:04.216 --> 00:31:05.826 A:middle
这意味着在字符串中

00:31:05.826 --> 00:31:07.266 A:middle
处理这些简单字符

00:31:07.266 --> 00:31:08.656 A:middle
所需要的时间

00:31:08.656 --> 00:31:10.156 A:middle
只有之前版本的

00:31:10.216 --> 00:31:11.316 A:middle
三分之一

00:31:11.806 --> 00:31:14.206 A:middle
这些快速通道

00:31:14.206 --> 00:31:16.636 A:middle
处理复杂字符串

00:31:16.636 --> 00:31:17.146 A:middle
十分得心应手

00:31:17.506 --> 00:31:18.676 A:middle
打个比方

00:31:18.676 --> 00:31:19.866 A:middle
如果你在社交媒体上

00:31:19.866 --> 00:31:22.326 A:middle
处理消息 那基本是

00:31:22.326 --> 00:31:24.266 A:middle
最简单的纯文本

00:31:24.266 --> 00:31:25.776 A:middle
还可能加上一些表情符号

00:31:25.776 --> 00:31:26.996 A:middle
我们在处理表情符号时

00:31:26.996 --> 00:31:28.226 A:middle
用的是更慢更复杂的方法

00:31:28.226 --> 00:31:31.466 A:middle
现在 让我们再来看看

00:31:31.466 --> 00:31:33.476 A:middle
这个 emoji 的例子

00:31:33.776 --> 00:31:34.956 A:middle
有两件事情

00:31:34.956 --> 00:31:35.316 A:middle
值得注意

00:31:36.636 --> 00:31:38.996 A:middle
第一件事是

00:31:38.996 --> 00:31:39.826 A:middle
字形宽度可调

00:31:40.186 --> 00:31:41.616 A:middle
所以我们显然不能

00:31:41.616 --> 00:31:43.196 A:middle
随机访问一个字符串中

00:31:43.196 --> 00:31:43.696 A:middle
特定的代码单元

00:31:44.416 --> 00:31:45.716 A:middle
我们可以对特定的

00:31:45.716 --> 00:31:47.026 A:middle
代码单元进行随机访问

00:31:47.026 --> 00:31:48.306 A:middle
当然你仍然可以使用

00:31:48.306 --> 00:31:48.676 A:middle
Swift 字符串进行访问

00:31:50.336 --> 00:31:51.346 A:middle
但这意味着什么

00:31:51.346 --> 00:31:52.376 A:middle
在这个例子中

00:31:52.376 --> 00:31:54.096 A:middle
它并不意味着

00:31:54.096 --> 00:31:54.416 A:middle
访问第五个代码单元

00:31:54.766 --> 00:31:55.676 A:middle
这肯定不是

00:31:55.676 --> 00:31:56.096 A:middle
第五个字符

00:31:57.566 --> 00:31:58.826 A:middle
另一件需要注意的事情

00:31:58.826 --> 00:32:00.296 A:middle
是这里有一些

00:31:58.826 --> 00:32:00.296 A:middle
是这里有一些

00:32:00.296 --> 00:32:00.746 A:middle
不寻常的行为

00:32:00.746 --> 00:32:03.566 A:middle
我们把六个项目

00:32:03.566 --> 00:32:04.866 A:middle
加到一个字符串里

00:32:05.126 --> 00:32:06.206 A:middle
但当我们结束时 计数并没有增加

00:32:06.206 --> 00:32:07.926 A:middle
这通常不是像数组

00:32:07.926 --> 00:32:09.816 A:middle
这样的其他集合

00:32:09.816 --> 00:32:11.056 A:middle
所期望的

00:32:11.056 --> 00:32:13.696 A:middle
正是因为存在这样的特殊情况

00:32:13.696 --> 00:32:15.106 A:middle
我们才发现

00:32:15.106 --> 00:32:16.536 A:middle
在之前的版本中

00:32:16.536 --> 00:32:19.296 A:middle
字符串不应该是集合

00:32:19.456 --> 00:32:21.116 A:middle
相反的 过去必须访问

00:32:21.116 --> 00:32:24.366 A:middle
作为字符串中

00:32:24.366 --> 00:32:25.816 A:middle
字符属性

00:32:25.816 --> 00:32:26.886 A:middle
的集合

00:32:28.856 --> 00:32:30.676 A:middle
但这实际上

00:32:30.676 --> 00:32:32.046 A:middle
没有帮助任何人

00:32:32.046 --> 00:32:33.556 A:middle
去理解这个问题

00:32:33.906 --> 00:32:35.176 A:middle
他所做的

00:32:35.176 --> 00:32:35.576 A:middle
一切都让代码变得混乱

00:32:35.576 --> 00:32:37.366 A:middle
它阻止人们从

00:32:37.366 --> 00:32:38.786 A:middle
字符的角度

00:32:39.096 --> 00:32:40.306 A:middle
思考和使用标准库

00:32:40.306 --> 00:32:41.496 A:middle
来进行

00:32:41.496 --> 00:32:41.986 A:middle
字符串处理

00:32:42.986 --> 00:32:45.006 A:middle
当然在 Swift 4 中

00:32:45.006 --> 00:32:45.946 A:middle
字符串是字符的集合

00:32:45.946 --> 00:32:47.116 A:middle
很大程度上可以帮助我们

00:32:47.116 --> 00:32:48.346 A:middle
清理代码 就像现在这样

00:32:49.516 --> 00:32:54.696 A:middle
[掌声]

00:32:55.196 --> 00:32:56.076 A:middle
还有一件事情我们

00:32:56.076 --> 00:32:56.966 A:middle
可以简化一下

00:32:57.126 --> 00:32:58.166 A:middle
在字符串处理中

00:32:58.206 --> 00:32:59.806 A:middle
想要按照索引分割

00:32:59.806 --> 00:33:01.666 A:middle
字符串是很常见的做法

00:32:59.806 --> 00:33:01.666 A:middle
字符串是很常见的做法

00:33:03.026 --> 00:33:04.276 A:middle
在 Swift 4 中

00:33:04.276 --> 00:33:04.936 A:middle
有一个简写

00:33:05.036 --> 00:33:06.156 A:middle
在你分割集合的

00:33:06.156 --> 00:33:07.306 A:middle
任何时间 你都可以

00:33:07.306 --> 00:33:08.956 A:middle
跳出这个集合

00:33:08.956 --> 00:33:10.146 A:middle
这意味着从索引

00:33:10.146 --> 00:33:10.656 A:middle
到集合的结束

00:33:10.656 --> 00:33:12.526 A:middle
从一开始

00:33:12.526 --> 00:33:15.976 A:middle
到索引结束

00:33:16.336 --> 00:33:16.546 A:middle
有着类似的语法

00:33:16.546 --> 00:33:18.096 A:middle
制作字符串集合

00:33:18.096 --> 00:33:19.146 A:middle
意味着你可以在

00:33:19.146 --> 00:33:19.916 A:middle
其它集合中

00:33:19.916 --> 00:33:21.286 A:middle
使用它们的全部功能

00:33:21.286 --> 00:33:23.106 A:middle
因此 你可以压缩 映射

00:33:23.106 --> 00:33:23.256 A:middle
搜索或过滤他们

00:33:24.196 --> 00:33:25.396 A:middle
这使得构建字符串

00:33:25.396 --> 00:33:26.606 A:middle
处理变得更为简单

00:33:27.626 --> 00:33:28.496 A:middle
我们来看一个例子

00:33:30.016 --> 00:33:31.266 A:middle
假设你想要检测你的

00:33:31.506 --> 00:33:33.486 A:middle
应用的信息中

00:33:33.746 --> 00:33:34.976 A:middle
是否有国旗

00:33:34.976 --> 00:33:37.086 A:middle
来触发一些逻辑

00:33:38.436 --> 00:33:40.506 A:middle
Unicode 里的国旗

00:33:40.506 --> 00:33:41.926 A:middle
是由一对对特殊的区域

00:33:41.926 --> 00:33:43.296 A:middle
指示器组成的 这些

00:33:43.296 --> 00:33:44.656 A:middle
区域指示器将显示出

00:33:44.746 --> 00:33:45.066 A:middle
国旗的 ISO 国家代码

00:33:45.356 --> 00:33:46.376 A:middle
举个例子 日本国旗的

00:33:46.376 --> 00:33:47.316 A:middle
ISO 代码是 JNP.

00:33:47.316 --> 00:33:49.626 A:middle
我们可以为 Unicode

00:33:49.626 --> 00:33:51.066 A:middle
定标器添加一个拓展

00:33:51.066 --> 00:33:52.256 A:middle
以便能够检测到它是否是

00:33:52.256 --> 00:33:53.586 A:middle
这些特殊区域指示器之一

00:33:54.266 --> 00:33:58.276 A:middle
接下来我们可以

00:33:58.276 --> 00:34:00.116 A:middle
拓展字符以检测

00:33:58.276 --> 00:34:00.116 A:middle
拓展字符以检测

00:34:00.116 --> 00:34:01.306 A:middle
字符是否为国旗

00:34:02.276 --> 00:34:03.426 A:middle
这是 Swift 4 中

00:34:03.426 --> 00:34:04.746 A:middle
可供使用的新特性

00:34:04.746 --> 00:34:06.146 A:middle
这允许你访问构成

00:34:06.146 --> 00:34:07.736 A:middle
图形底层的

00:34:07.736 --> 00:34:08.156 A:middle
Unicode 标量

00:34:08.726 --> 00:34:10.686 A:middle
如果你想了解

00:34:10.686 --> 00:34:11.976 A:middle
Unicode 是如何工作的

00:34:11.976 --> 00:34:13.065 A:middle
特别是在 Swift 平台上

00:34:13.065 --> 00:34:14.606 A:middle
他是如何运作的

00:34:14.606 --> 00:34:15.406 A:middle
这是一件十分有意思的事情

00:34:18.295 --> 00:34:19.335 A:middle
现在有了 Swift 4

00:34:19.335 --> 00:34:20.545 A:middle
我们可以用它来使用

00:34:20.886 --> 00:34:21.795 A:middle
所有熟悉的 API 集合

00:34:21.996 --> 00:34:23.656 A:middle
因此我们可以搜索一个字符串

00:34:23.656 --> 00:34:24.516 A:middle
是否含有特定标志

00:34:25.376 --> 00:34:27.226 A:middle
或者我们可以见这些标志

00:34:27.226 --> 00:34:28.676 A:middle
过滤后形成一个新字符串

00:34:28.835 --> 00:34:32.726 A:middle
现在这些字符串是集合了

00:34:32.726 --> 00:34:34.136 A:middle
你可能会注意到

00:34:34.136 --> 00:34:35.295 A:middle
他们有了一个新的方法

00:34:35.536 --> 00:34:35.916 A:middle
分割

00:34:36.136 --> 00:34:37.275 A:middle
这是一个现有的

00:34:37.275 --> 00:34:37.735 A:middle
收集方法

00:34:38.976 --> 00:34:41.106 A:middle
他将一个一个字符串

00:34:41.106 --> 00:34:42.116 A:middle
分割包含多段的数组

00:34:42.966 --> 00:34:44.775 A:middle
但如果你在 Swift 上运行它

00:34:44.835 --> 00:34:46.166 A:middle
你会注意到它

00:34:46.166 --> 00:34:47.516 A:middle
不会返回一个

00:34:47.516 --> 00:34:47.956 A:middle
字符串数组

00:34:49.556 --> 00:34:50.996 A:middle
用于 字符串的 Swift 4

00:34:50.996 --> 00:34:52.726 A:middle
段类型是子字符串

00:34:53.946 --> 00:34:54.815 A:middle
那么我们为什么

00:34:54.815 --> 00:34:55.536 A:middle
要给他一个不同的类型呢

00:34:56.786 --> 00:34:58.346 A:middle
在决定如何对集合进行

00:34:58.346 --> 00:34:59.446 A:middle
分段时 需要进行

00:34:59.446 --> 00:35:01.526 A:middle
一些基本的

00:34:59.446 --> 00:35:01.526 A:middle
一些基本的

00:35:01.526 --> 00:35:02.726 A:middle
工程权衡

00:35:04.536 --> 00:35:05.306 A:middle
当你对一个集合

00:35:05.306 --> 00:35:06.586 A:middle
进行分段时

00:35:06.636 --> 00:35:08.126 A:middle
它是否应该对正在

00:35:08.126 --> 00:35:10.896 A:middle
分段的内容创建一个副本

00:35:11.136 --> 00:35:13.316 A:middle
或者是否应该将

00:35:13.426 --> 00:35:14.586 A:middle
一个视图返回到

00:35:14.586 --> 00:35:17.556 A:middle
原始集合的内部存储中

00:35:17.556 --> 00:35:19.616 A:middle
从性能的角度来看

00:35:19.616 --> 00:35:20.396 A:middle
共享存储显然要快得多

00:35:21.326 --> 00:35:22.366 A:middle
正如 Bob 前面所提到的

00:35:22.426 --> 00:35:24.686 A:middle
分配和跟踪堆内容

00:35:24.686 --> 00:35:26.196 A:middle
可能会非常昂贵

00:35:26.516 --> 00:35:27.926 A:middle
你可能会至少花费

00:35:27.926 --> 00:35:29.326 A:middle
一半的时间在类似

00:35:29.326 --> 00:35:31.116 A:middle
分类 制作副本的操作中

00:35:32.116 --> 00:35:34.456 A:middle
而且 如果分段需要

00:35:34.456 --> 00:35:35.866 A:middle
线性时间 因为我们复制

00:35:35.866 --> 00:35:37.166 A:middle
内容的副本

00:35:37.816 --> 00:35:39.786 A:middle
执行分段操作

00:35:39.786 --> 00:35:40.926 A:middle
的循环可能意外

00:35:40.926 --> 00:35:42.226 A:middle
需要二次方时间

00:35:42.496 --> 00:35:43.786 A:middle
而不是在你期望的

00:35:43.866 --> 00:35:44.986 A:middle
线性时间

00:35:46.526 --> 00:35:47.756 A:middle
这就是在连续的时间里

00:35:47.756 --> 00:35:49.426 A:middle
对 Swift 中需要的

00:35:49.426 --> 00:35:50.596 A:middle
任何集合进行分段

00:35:52.476 --> 00:35:53.906 A:middle
但是我们所采用的

00:35:53.906 --> 00:35:55.636 A:middle
共享存储方法

00:35:55.636 --> 00:35:56.116 A:middle
同样也有缺点

00:35:56.246 --> 00:35:57.516 A:middle
为了弄明白这是什么

00:35:58.056 --> 00:35:59.056 A:middle
让我们来看看字符串

00:35:59.056 --> 00:36:00.406 A:middle
的内部实现

00:35:59.056 --> 00:36:00.406 A:middle
的内部实现

00:36:01.876 --> 00:36:04.856 A:middle
所以 当前 Swift

00:36:04.856 --> 00:36:06.026 A:middle
字符串内部

00:36:06.026 --> 00:36:06.506 A:middle
由三个属性组成

00:36:07.646 --> 00:36:08.766 A:middle
他们有一个指向

00:36:08.766 --> 00:36:09.196 A:middle
缓冲区开始处的指针

00:36:10.076 --> 00:36:11.066 A:middle
他们有缓冲区中

00:36:11.066 --> 00:36:12.476 A:middle
代码单元的数量

00:36:12.606 --> 00:36:14.086 A:middle
并且他们有一个

00:36:14.086 --> 00:36:14.836 A:middle
指向所有者对象的引用

00:36:15.696 --> 00:36:17.196 A:middle
所有者对象负责

00:36:17.196 --> 00:36:18.526 A:middle
跟踪和管理

00:36:18.526 --> 00:36:18.846 A:middle
缓冲区

00:36:18.966 --> 00:36:20.216 A:middle
在其他的集合上

00:36:20.216 --> 00:36:21.316 A:middle
作也采用

00:36:21.316 --> 00:36:22.376 A:middle
类似的模式

00:36:24.306 --> 00:36:25.826 A:middle
当原始的字符串

00:36:25.826 --> 00:36:28.946 A:middle
结构被破坏时

00:36:28.946 --> 00:36:30.116 A:middle
引用计数和所有者对象

00:36:30.166 --> 00:36:31.896 A:middle
会降为零 类中的

00:36:31.896 --> 00:36:33.696 A:middle
存储也会释放缓存区

00:36:35.276 --> 00:36:36.626 A:middle
现在让我们来看看

00:36:36.626 --> 00:36:37.816 A:middle
创建子字符串时

00:36:37.926 --> 00:36:38.396 A:middle
会发生什么

00:36:39.066 --> 00:36:42.066 A:middle
假设我们把 well 这个词

00:36:42.066 --> 00:36:43.456 A:middle
从原来的字符串

00:36:43.456 --> 00:36:43.736 A:middle
中切掉了

00:36:45.176 --> 00:36:47.546 A:middle
子字符串有一个

00:36:47.546 --> 00:36:49.446 A:middle
指向 W 的开始

00:36:49.446 --> 00:36:51.656 A:middle
他的计数范围是 5

00:36:51.656 --> 00:36:53.136 A:middle
并且所有者是对原始

00:36:53.136 --> 00:36:54.146 A:middle
字符串所有者的共享引用

00:36:55.506 --> 00:36:56.486 A:middle
现在来看看当原始

00:36:56.486 --> 00:36:58.576 A:middle
字符串溢出时

00:36:59.496 --> 00:36:59.706 A:middle
会发生什么

00:37:00.526 --> 00:37:01.796 A:middle
所有者的引用计数

00:37:01.796 --> 00:37:03.636 A:middle
会被减少 但不会遭到

00:37:03.636 --> 00:37:04.546 A:middle
破坏 因为它是由

00:37:04.546 --> 00:37:05.526 A:middle
子字符串共享的

00:37:05.526 --> 00:37:06.806 A:middle
因此 缓存区并没有被释放

00:37:07.156 --> 00:37:08.496 A:middle
这样就很棒 因为

00:37:08.496 --> 00:37:09.556 A:middle
子字符串依赖于

00:37:09.556 --> 00:37:09.756 A:middle
缓冲区

00:37:09.756 --> 00:37:12.236 A:middle
但是整个缓冲区

00:37:12.236 --> 00:37:12.606 A:middle
依然存在

00:37:12.816 --> 00:37:14.296 A:middle
不是只有这个部分

00:37:14.296 --> 00:37:14.946 A:middle
它所依赖的子字符串也是这样

00:37:16.436 --> 00:37:17.496 A:middle
现在这种情况

00:37:17.496 --> 00:37:18.516 A:middle
没什么大不了的

00:37:18.516 --> 00:37:19.006 A:middle
这只是几个字符

00:37:19.696 --> 00:37:20.846 A:middle
但这真的是个问题

00:37:22.886 --> 00:37:24.626 A:middle
假设你从网上下载了

00:37:24.626 --> 00:37:25.816 A:middle
一个巨大的文本

00:37:26.596 --> 00:37:28.046 A:middle
然后对其中的一小部分

00:37:28.046 --> 00:37:29.636 A:middle
分段 并将其分配

00:37:29.636 --> 00:37:31.796 A:middle
给一些长期的变量

00:37:32.126 --> 00:37:33.116 A:middle
比如 UI 标签

00:37:34.216 --> 00:37:35.496 A:middle
这看起来更像是

00:37:35.496 --> 00:37:36.116 A:middle
内存泄漏

00:37:36.716 --> 00:37:38.046 A:middle
因为原始文件

00:37:38.046 --> 00:37:39.686 A:middle
的缓冲区

00:37:39.686 --> 00:37:40.066 A:middle
永远不会被释放

00:37:41.166 --> 00:37:42.206 A:middle
这是 JAVA 中存在的

00:37:42.206 --> 00:37:43.456 A:middle
一个大问题 他们在几年前

00:37:43.456 --> 00:37:45.036 A:middle
改变了对字符串进行

00:37:45.036 --> 00:37:47.346 A:middle
分段的方法

00:37:47.346 --> 00:37:48.236 A:middle
以方便它进行复制

00:37:49.566 --> 00:37:50.676 A:middle
但正如我们看到的那样

00:37:50.676 --> 00:37:51.806 A:middle
这有一个性能上的缺点

00:37:51.806 --> 00:37:52.916 A:middle
我们并不一定要做出

00:37:53.006 --> 00:37:53.706 A:middle
这样的牺牲

00:37:54.646 --> 00:37:55.896 A:middle
在 Swift 中这样的

00:37:55.896 --> 00:37:57.686 A:middle
问题解决方案

00:37:57.776 --> 00:37:58.446 A:middle
是使用类型

00:37:59.166 --> 00:38:00.746 A:middle
这就是为什么子字符串

00:37:59.166 --> 00:38:00.746 A:middle
这就是为什么子字符串

00:38:00.746 --> 00:38:01.856 A:middle
是字符串的不同类型

00:38:02.866 --> 00:38:04.486 A:middle
现在 当你在原始的

00:38:04.486 --> 00:38:06.086 A:middle
大字符串上执行分段操作时

00:38:06.086 --> 00:38:07.896 A:middle
你最终会想

00:38:07.896 --> 00:38:09.316 A:middle
将一个子字符串

00:38:09.356 --> 00:38:10.986 A:middle
分配给一个字符串

00:38:10.986 --> 00:38:12.186 A:middle
编译器会告诉你它的情况

00:38:13.456 --> 00:38:14.686 A:middle
如果你是用修复程序

00:38:14.686 --> 00:38:16.736 A:middle
它会建议并新建一个

00:38:16.736 --> 00:38:18.836 A:middle
新的字符串

00:38:18.836 --> 00:38:20.216 A:middle
这只会复制你分段的

00:38:20.216 --> 00:38:21.246 A:middle
部分缓冲区

00:38:22.286 --> 00:38:23.556 A:middle
这允许原缓冲区

00:38:23.556 --> 00:38:25.916 A:middle
溢出并

00:38:26.896 --> 00:38:27.666 A:middle
释放

00:38:28.516 --> 00:38:33.286 A:middle
[掌声]

00:38:33.786 --> 00:38:35.706 A:middle
现在我们有两种

00:38:35.706 --> 00:38:36.056 A:middle
不同的类型

00:38:36.056 --> 00:38:37.056 A:middle
你可能会问我一个问题

00:38:37.056 --> 00:38:38.606 A:middle
那就是什么时候该在我的代码中

00:38:38.606 --> 00:38:38.736 A:middle
使用子字符串

00:38:38.736 --> 00:38:40.856 A:middle
回答是 我无法告诉你

00:38:40.856 --> 00:38:42.756 A:middle
具体的情况

00:38:43.306 --> 00:38:45.596 A:middle
在定义接口 比如

00:38:45.596 --> 00:38:47.216 A:middle
类型或属性的方式时

00:38:47.686 --> 00:38:49.096 A:middle
你应该偏向使用字符串

00:38:49.856 --> 00:38:51.126 A:middle
既避免了我们刚刚谈到的

00:38:51.126 --> 00:38:52.696 A:middle
内存泄漏的问题

00:38:52.696 --> 00:38:54.336 A:middle
同时也是因为字符串

00:38:54.336 --> 00:38:55.796 A:middle
是我们所谓的通用类型

00:38:56.036 --> 00:38:56.916 A:middle
这是每个人都希望

00:38:56.916 --> 00:38:58.446 A:middle
在 API 中看到的类型

00:39:00.076 --> 00:39:01.386 A:middle
大部分情况下

00:39:01.386 --> 00:39:03.176 A:middle
你遇到子字符串类型

00:39:03.176 --> 00:39:04.676 A:middle
的唯一可能性是

00:39:04.676 --> 00:39:05.566 A:middle
执行分段操作时

00:39:06.076 --> 00:39:07.726 A:middle
因为 Swift 使用

00:39:07.786 --> 00:39:09.186 A:middle
类型推断 你并不会为

00:39:09.186 --> 00:39:10.596 A:middle
所有的子类型命名

00:39:12.196 --> 00:39:13.706 A:middle
子字符串有许多

00:39:13.706 --> 00:39:14.856 A:middle
普通字符串相同的

00:39:14.856 --> 00:39:15.586 A:middle
方式和属性

00:39:15.936 --> 00:39:17.666 A:middle
所以即使你没有

00:39:17.666 --> 00:39:19.606 A:middle
命名类型为一个子字符串

00:39:19.686 --> 00:39:20.806 A:middle
大部分的代码在运行时

00:39:20.896 --> 00:39:22.686 A:middle
依然会把它当作

00:39:22.686 --> 00:39:23.056 A:middle
字符串来处理

00:39:24.066 --> 00:39:25.196 A:middle
如果你只进行

00:39:25.196 --> 00:39:26.036 A:middle
本地操作 那么你

00:39:26.036 --> 00:39:26.836 A:middle
实际上不需要创建字符串

00:39:26.836 --> 00:39:28.336 A:middle
那么这种情况

00:39:28.336 --> 00:39:29.296 A:middle
就可以被完全避免掉

00:39:31.866 --> 00:39:32.656 A:middle
好的 这差不多就是

00:39:32.656 --> 00:39:33.026 A:middle
我想讲的关于字符串的内容

00:39:33.386 --> 00:39:34.526 A:middle
我还想再谈谈

00:39:34.526 --> 00:39:34.976 A:middle
最后一个特性

00:39:34.976 --> 00:39:36.266 A:middle
那就是

00:39:36.266 --> 00:39:36.656 A:middle
多行字符串

00:39:37.616 --> 00:39:38.916 A:middle
之前 写这些东西

00:39:38.916 --> 00:39:39.586 A:middle
真的很痛苦

00:39:39.726 --> 00:39:41.256 A:middle
你必须去写一个

00:39:41.256 --> 00:39:42.776 A:middle
又大又长的字符串

00:39:42.846 --> 00:39:43.516 A:middle
在最后以斜线结尾

00:39:44.606 --> 00:39:46.606 A:middle
Swift 4 引入了

00:39:46.606 --> 00:39:47.426 A:middle
三引号语法

00:39:48.676 --> 00:39:49.876 A:middle
你可以使用三引号语法

00:39:49.876 --> 00:39:50.556 A:middle
来编写多行字符串

00:39:51.516 --> 00:39:56.906 A:middle
[掌声]

00:39:57.406 --> 00:39:58.416 A:middle
然后你用

00:39:58.416 --> 00:39:58.946 A:middle
三个引号结束它

00:39:59.606 --> 00:40:01.316 A:middle
结束三引号

00:39:59.606 --> 00:40:01.316 A:middle
结束三引号

00:40:01.316 --> 00:40:02.966 A:middle
的缩进决定了

00:40:03.446 --> 00:40:04.936 A:middle
多行字符串

00:40:04.936 --> 00:40:05.976 A:middle
每一行的缩进

00:40:06.546 --> 00:40:08.856 A:middle
在这里可以看到的是

00:40:08.856 --> 00:40:09.996 A:middle
因为我们把文字

00:40:09.996 --> 00:40:10.866 A:middle
放入了一个函数中

00:40:10.866 --> 00:40:12.086 A:middle
我希望它能够很好的缩进

00:40:12.086 --> 00:40:13.596 A:middle
来匹配我们代码

00:40:13.596 --> 00:40:13.716 A:middle
其余部分的格式

00:40:14.586 --> 00:40:15.706 A:middle
这里的规则是

00:40:15.706 --> 00:40:16.956 A:middle
无论你在结束引号中

00:40:16.996 --> 00:40:18.576 A:middle
使用什么缩进

00:40:18.576 --> 00:40:20.136 A:middle
你必须在字符串的

00:40:20.136 --> 00:40:21.936 A:middle
每一行中都保持

00:40:21.936 --> 00:40:22.266 A:middle
同样的缩进

00:40:23.076 --> 00:40:24.596 A:middle
然后当代码

00:40:25.546 --> 00:40:27.356 A:middle
编译完成时

00:40:28.236 --> 00:40:28.326 A:middle
就会去掉缩进

00:40:29.436 --> 00:40:30.806 A:middle
这真是一个很棒的特征

00:40:30.806 --> 00:40:31.636 A:middle
其中一件很酷的事情

00:40:31.636 --> 00:40:33.006 A:middle
就是他是由 Swift

00:40:33.006 --> 00:40:35.696 A:middle
开源社区的

00:40:35.696 --> 00:40:36.896 A:middle
外部成员

00:40:36.896 --> 00:40:38.036 A:middle
提出和实施的

00:40:39.516 --> 00:40:45.106 A:middle
[掌声]

00:40:45.606 --> 00:40:46.396 A:middle
这就是对字符串的介绍

00:40:46.396 --> 00:40:47.326 A:middle
现在让我们来探讨一些

00:40:47.326 --> 00:40:48.366 A:middle
新的泛型特征

00:40:49.516 --> 00:40:50.756 A:middle
在 Swift 的每一个版本中

00:40:50.756 --> 00:40:52.506 A:middle
我你们都在改进

00:40:52.576 --> 00:40:52.916 A:middle
通用系统

00:40:53.136 --> 00:40:54.406 A:middle
它不仅仅变得更强大

00:40:55.116 --> 00:40:56.766 A:middle
而且用途更广

00:40:56.936 --> 00:40:57.606 A:middle
更易操作

00:40:57.986 --> 00:40:59.396 A:middle
例如在 Swift 2 中

00:40:59.396 --> 00:41:00.356 A:middle
推出的协议拓展

00:40:59.396 --> 00:41:00.356 A:middle
推出的协议拓展

00:41:01.576 --> 00:41:03.616 A:middle
在这个版本中

00:41:03.616 --> 00:41:04.866 A:middle
我们将介绍

00:41:05.556 --> 00:41:06.846 A:middle
两个特性

00:41:06.846 --> 00:41:09.466 A:middle
即关联类型和通用子脚本的子句

00:41:10.016 --> 00:41:10.806 A:middle
我将向你们展示

00:41:10.806 --> 00:41:12.176 A:middle
几个例子 有关

00:41:12.176 --> 00:41:13.016 A:middle
我们如何在标准库中

00:41:13.016 --> 00:41:14.356 A:middle
使用它们 以及

00:41:14.356 --> 00:41:15.376 A:middle
在你们的代码中

00:41:15.406 --> 00:41:17.006 A:middle
应当如何使用他们

00:41:18.256 --> 00:41:20.386 A:middle
所以 假设你想要

00:41:20.386 --> 00:41:22.176 A:middle
检测一个序列的

00:41:22.176 --> 00:41:24.276 A:middle
每一个元素是否

00:41:24.276 --> 00:41:25.106 A:middle
等于一个特定的值

00:41:26.166 --> 00:41:27.806 A:middle
你可以使用一个

00:41:27.806 --> 00:41:28.946 A:middle
已经包含在序列中的

00:41:28.946 --> 00:41:29.366 A:middle
方式来完成这个操作

00:41:29.716 --> 00:41:31.486 A:middle
但是这段代码有些笨拙

00:41:31.876 --> 00:41:33.546 A:middle
你写的这个序列

00:41:33.726 --> 00:41:35.766 A:middle
不可以包含任何

00:41:35.766 --> 00:41:36.536 A:middle
不等于这个值的元素

00:41:37.656 --> 00:41:38.676 A:middle
如果你一次又一次的

00:41:38.676 --> 00:41:39.506 A:middle
重写它 那这可能会

00:41:39.506 --> 00:41:41.036 A:middle
非常恼人 所以

00:41:41.036 --> 00:41:42.526 A:middle
协议拓展给你提供了

00:41:42.526 --> 00:41:44.146 A:middle
一种很好的方式

00:41:44.146 --> 00:41:46.046 A:middle
封装代码 就像现在这样

00:41:46.046 --> 00:41:46.846 A:middle
这会使你的代码变得整洁

00:41:47.996 --> 00:41:49.786 A:middle
因此 我们可以将这段代码

00:41:49.786 --> 00:41:51.686 A:middle
封装在一个序列的拓展中

00:41:51.686 --> 00:41:52.706 A:middle
这样我们就可以

00:41:52.706 --> 00:41:53.566 A:middle
更容易的调用它了

00:41:55.026 --> 00:41:56.796 A:middle
现在当你像这样

00:41:56.796 --> 00:41:58.326 A:middle
拓展序列时 有一件事情

00:41:58.326 --> 00:41:59.536 A:middle
有些不讨人喜欢

00:41:59.536 --> 00:42:01.056 A:middle
过去你需要

00:41:59.536 --> 00:42:01.056 A:middle
过去你需要

00:42:01.086 --> 00:42:03.146 A:middle
写一个迭代器元素

00:42:03.146 --> 00:42:04.266 A:middle
来说明

00:42:04.266 --> 00:42:05.256 A:middle
序列元素的类型

00:42:06.306 --> 00:42:08.116 A:middle
在 Swift 4 中

00:42:08.116 --> 00:42:08.506 A:middle
你可以不用迭代器了

00:42:08.506 --> 00:42:10.796 A:middle
因为序列有它

00:42:10.856 --> 00:42:11.706 A:middle
自己的元素类型

00:42:13.006 --> 00:42:13.786 A:middle
这似乎是我们

00:42:13.786 --> 00:42:15.356 A:middle
添加的一个非常

00:42:15.356 --> 00:42:15.486 A:middle
简单的特性

00:42:15.486 --> 00:42:16.706 A:middle
但是如果没有

00:42:17.016 --> 00:42:18.506 A:middle
约束相关类型的能力

00:42:18.506 --> 00:42:19.466 A:middle
我们实际上是我无法做到的

00:42:19.516 --> 00:42:20.396 A:middle
我将告诉你该怎么做

00:42:22.026 --> 00:42:23.626 A:middle
因此 在 Swift 3 中

00:42:23.626 --> 00:42:25.576 A:middle
我们有一个协议序列

00:42:25.576 --> 00:42:26.916 A:middle
它又有一个与之相关的类型迭代器

00:42:27.526 --> 00:42:28.756 A:middle
迭代器为元素提供了

00:42:28.756 --> 00:42:30.136 A:middle
一个相关的类型

00:42:30.816 --> 00:42:33.856 A:middle
在 Swift 4 中 我们添加了

00:42:33.856 --> 00:42:36.736 A:middle
相关联的类型元素

00:42:37.246 --> 00:42:38.856 A:middle
然后在迭代器关联类型中

00:42:38.856 --> 00:42:40.916 A:middle
添加 where 子句

00:42:40.916 --> 00:42:43.026 A:middle
以要求其元素

00:42:43.106 --> 00:42:44.536 A:middle
与序列元素相同

00:42:45.366 --> 00:42:46.336 A:middle
否则他们就会失去同步

00:42:46.336 --> 00:42:47.426 A:middle
并由此产生一些

00:42:47.426 --> 00:42:47.976 A:middle
问题

00:42:49.276 --> 00:42:50.326 A:middle
我们已经在标准库中的

00:42:50.326 --> 00:42:51.656 A:middle
几个地方使用过这个了

00:42:52.396 --> 00:42:54.366 A:middle
例如 以前没有保证

00:42:54.366 --> 00:42:55.996 A:middle
子序列的元素

00:42:55.996 --> 00:42:58.006 A:middle
与序列元素

00:42:58.006 --> 00:42:59.266 A:middle
的类型

00:42:59.266 --> 00:42:59.736 A:middle
是相同的

00:43:00.646 --> 00:43:01.896 A:middle
没有人想要写一个

00:43:01.896 --> 00:43:03.006 A:middle
不是案例的

00:43:03.006 --> 00:43:03.336 A:middle
序列

00:43:03.666 --> 00:43:05.026 A:middle
这根本不能用

00:43:05.286 --> 00:43:06.746 A:middle
但我们的编译器无法保证

00:43:06.746 --> 00:43:08.356 A:middle
这种事情不会发生

00:43:08.356 --> 00:43:09.846 A:middle
因为我们无法用

00:43:09.846 --> 00:43:10.376 A:middle
编程语言来表述它

00:43:11.146 --> 00:43:12.806 A:middle
现在 有了相关类型的

00:43:12.806 --> 00:43:14.596 A:middle
where 子句 我们就可以

00:43:14.596 --> 00:43:15.276 A:middle
做出这个保证了

00:43:16.826 --> 00:43:18.016 A:middle
那么这对你的代码

00:43:18.016 --> 00:43:18.256 A:middle
意味着什么呢

00:43:19.866 --> 00:43:21.056 A:middle
如果你已经拓展了

00:43:21.086 --> 00:43:22.436 A:middle
序列或者集合

00:43:22.436 --> 00:43:23.936 A:middle
你可能会发现

00:43:23.936 --> 00:43:25.016 A:middle
你不得不把这些看似

00:43:25.016 --> 00:43:26.736 A:middle
不必要的 where 子句

00:43:26.736 --> 00:43:29.156 A:middle
添加到你的扩展中去

00:43:29.156 --> 00:43:30.196 A:middle
这为了保证它能够被翻译

00:43:30.196 --> 00:43:31.696 A:middle
因为代码本身

00:43:31.696 --> 00:43:33.736 A:middle
依靠的是协议不能

00:43:33.846 --> 00:43:34.606 A:middle
保证的东西

00:43:35.966 --> 00:43:37.966 A:middle
现在 我们做了前几页

00:43:37.966 --> 00:43:38.686 A:middle
幻灯片中所做的事情

00:43:38.686 --> 00:43:40.546 A:middle
所以它现在可以

00:43:40.546 --> 00:43:41.206 A:middle
得到保证

00:43:41.206 --> 00:43:43.496 A:middle
因此 你会得到警告

00:43:43.796 --> 00:43:44.816 A:middle
告诉你现在存在

00:43:44.876 --> 00:43:45.986 A:middle
多余的约束

00:43:47.096 --> 00:43:48.726 A:middle
这些在 Swift 3

00:43:48.726 --> 00:43:50.276 A:middle
和 Swift 4 模式下都只是警告

00:43:50.276 --> 00:43:51.616 A:middle
他们只是告诉你这些

00:43:51.616 --> 00:43:53.176 A:middle
都是不必要的

00:43:53.676 --> 00:43:55.126 A:middle
你可以用自己的方式

00:43:55.126 --> 00:43:56.926 A:middle
来使你的代码变得更整洁

00:43:58.056 --> 00:43:59.326 A:middle
现在 关于我们添加的

00:43:59.326 --> 00:44:00.666 A:middle
这些新约束 还有几件事情

00:43:59.326 --> 00:44:00.666 A:middle
这些新约束 还有几件事情

00:44:00.666 --> 00:44:01.186 A:middle
需要我们来了解一下

00:44:01.276 --> 00:44:02.746 A:middle
在 Swift 3.2 模式中

00:44:02.746 --> 00:44:04.476 A:middle
这是少数几件

00:44:04.476 --> 00:44:05.896 A:middle
没有向后兼容的

00:44:05.896 --> 00:44:06.796 A:middle
事情

00:44:07.436 --> 00:44:09.036 A:middle
因为协议特性

00:44:09.116 --> 00:44:10.186 A:middle
必须在整个流程中

00:44:10.186 --> 00:44:11.186 A:middle
保持一致

00:44:12.546 --> 00:44:13.566 A:middle
因此 如果你编写了

00:44:13.566 --> 00:44:15.216 A:middle
自定义的集合类型

00:44:15.546 --> 00:44:17.186 A:middle
这可能会有悖

00:44:17.186 --> 00:44:18.786 A:middle
一些约束 那么在

00:44:18.846 --> 00:44:20.266 A:middle
使用新的编译器之前

00:44:20.266 --> 00:44:21.236 A:middle
你必须首先

00:44:21.236 --> 00:44:21.746 A:middle
解决这个问题

00:44:22.686 --> 00:44:24.076 A:middle
我们认为这种事情

00:44:24.146 --> 00:44:24.846 A:middle
发生的几率不高

00:44:25.086 --> 00:44:26.666 A:middle
这通常是由疏忽导致的

00:44:26.666 --> 00:44:28.136 A:middle
而且也很容易解决

00:44:28.166 --> 00:44:29.346 A:middle
但是如果不是因为疏忽

00:44:29.346 --> 00:44:31.006 A:middle
那就值得警惕了

00:44:32.716 --> 00:44:34.296 A:middle
最后 我们来谈一谈

00:44:34.296 --> 00:44:35.166 A:middle
一般的子脚本

00:44:36.076 --> 00:44:37.516 A:middle
在之前 我们看到了一个

00:44:37.516 --> 00:44:38.876 A:middle
单项范围语法的例子

00:44:39.666 --> 00:44:40.536 A:middle
那么我们是如何在

00:44:40.536 --> 00:44:41.896 A:middle
标准库内部

00:44:41.896 --> 00:44:42.676 A:middle
来实现这个的呢

00:44:42.676 --> 00:44:47.376 A:middle
首先 有一个新的

00:44:47.566 --> 00:44:48.596 A:middle
类型部分范围

00:44:49.116 --> 00:44:50.106 A:middle
它看起来像是

00:44:50.106 --> 00:44:51.696 A:middle
一个普通的范围

00:44:51.696 --> 00:44:51.996 A:middle
但它边界较低

00:44:52.646 --> 00:44:55.956 A:middle
接下来有一个

00:44:55.956 --> 00:44:57.636 A:middle
协议范围表达式

00:44:57.636 --> 00:44:59.206 A:middle
我们用它来统一所有

00:44:59.206 --> 00:45:00.036 A:middle
不同种类的范围类型

00:44:59.206 --> 00:45:00.036 A:middle
不同种类的范围类型

00:45:00.776 --> 00:45:01.856 A:middle
它有一种方式

00:45:01.856 --> 00:45:03.996 A:middle
那就是用一个集合

00:45:03.996 --> 00:45:05.586 A:middle
将任何范围内的表达式

00:45:05.586 --> 00:45:07.176 A:middle
转化为可供分段的

00:45:07.176 --> 00:45:08.006 A:middle
具体范围类型

00:45:08.626 --> 00:45:11.936 A:middle
例如 部分从

00:45:12.096 --> 00:45:13.776 A:middle
使用集合开始

00:45:14.006 --> 00:45:15.376 A:middle
一直到填充

00:45:15.376 --> 00:45:15.716 A:middle
缺失上界结束

00:45:16.426 --> 00:45:19.586 A:middle
现在有了这个协议之后

00:45:19.776 --> 00:45:21.566 A:middle
我们可以用一个

00:45:21.566 --> 00:45:23.876 A:middle
通用的子脚本扩展字符串

00:45:23.956 --> 00:45:25.656 A:middle
它将接受任何类型的

00:45:25.656 --> 00:45:27.406 A:middle
范围表达式 并用它

00:45:27.406 --> 00:45:28.526 A:middle
来对子字符串进行分段

00:45:30.346 --> 00:45:31.316 A:middle
现在字符串是集合了

00:45:31.316 --> 00:45:33.176 A:middle
实际上我们可以把

00:45:33.176 --> 00:45:34.776 A:middle
这个特性直接

00:45:34.776 --> 00:45:35.276 A:middle
放在集合上

00:45:35.276 --> 00:45:37.026 A:middle
这可能包含了

00:45:37.026 --> 00:45:38.066 A:middle
你编写的任意自定义集合

00:45:38.066 --> 00:45:39.456 A:middle
我们可以通过协议

00:45:39.686 --> 00:45:41.386 A:middle
来自动使用这个功能

00:45:43.006 --> 00:45:44.016 A:middle
事实上我们可以用

00:45:44.016 --> 00:45:45.366 A:middle
这种方式来清理

00:45:45.366 --> 00:45:46.696 A:middle
标准库中的许多代码

00:45:46.696 --> 00:45:47.636 A:middle
因为我们可以将所有

00:45:47.636 --> 00:45:49.446 A:middle
重复的分段操作移除

00:45:49.446 --> 00:45:50.806 A:middle
因为我们需要为

00:45:50.806 --> 00:45:51.906 A:middle
每个不同的范围类型硬编码

00:45:51.906 --> 00:45:53.426 A:middle
因为我们希望用一个

00:45:53.426 --> 00:45:54.926 A:middle
通用的子脚本替换它们

00:45:55.496 --> 00:45:56.746 A:middle
我们也希望你可以

00:45:56.746 --> 00:45:58.356 A:middle
找到类似的方法

00:45:58.356 --> 00:46:01.176 A:middle
来清理你的代码

00:45:58.356 --> 00:46:01.176 A:middle
来清理你的代码

00:46:01.676 --> 00:46:02.396 A:middle
其实还有一些

00:46:02.396 --> 00:46:03.506 A:middle
我今天来不及介绍的

00:46:03.506 --> 00:46:04.866 A:middle
新功能 比如一些

00:46:04.866 --> 00:46:05.796 A:middle
新的数字协议

00:46:06.156 --> 00:46:06.956 A:middle
还有一些对

00:46:06.956 --> 00:46:08.116 A:middle
字典类型

00:46:08.186 --> 00:46:08.386 A:middle
非常棒的改进

00:46:09.506 --> 00:46:11.086 A:middle
我们添加到东西之一

00:46:11.086 --> 00:46:12.866 A:middle
是一个集合的新形式

00:46:12.866 --> 00:46:14.206 A:middle
允许你在集合中

00:46:14.386 --> 00:46:16.006 A:middle
交换两个元素

00:46:16.006 --> 00:46:17.296 A:middle
给定两个索引

00:46:17.296 --> 00:46:18.966 A:middle
而不是使用全局函数

00:46:18.966 --> 00:46:19.736 A:middle
将两个参数输出

00:46:21.046 --> 00:46:22.376 A:middle
这是为了支持一个

00:46:22.376 --> 00:46:24.206 A:middle
新的独占访问内存

00:46:24.206 --> 00:46:25.526 A:middle
的功能

00:46:25.526 --> 00:46:26.276 A:middle
John 下面会详细介绍

00:46:27.516 --> 00:46:34.266 A:middle
[掌声]

00:46:34.766 --> 00:46:35.486 A:middle
&gt;&gt; 谢谢你 Ben

00:46:36.026 --> 00:46:37.316 A:middle
谢谢

00:46:38.616 --> 00:46:40.556 A:middle
对内存的独占访问是

00:46:40.556 --> 00:46:42.126 A:middle
我们在 Swift 4 中

00:46:42.126 --> 00:46:42.966 A:middle
添加的一条新规则

00:46:43.636 --> 00:46:46.896 A:middle
这实际上是我们

00:46:46.896 --> 00:46:48.556 A:middle
称之为所有权的

00:46:48.716 --> 00:46:49.236 A:middle
更大特征的一部分

00:46:49.946 --> 00:46:51.666 A:middle
所有权的目的是

00:46:51.666 --> 00:46:53.196 A:middle
为了让你更容易

00:46:53.196 --> 00:46:54.986 A:middle
理解程序的性能

00:46:55.826 --> 00:46:57.296 A:middle
这将使你更容易

00:46:57.296 --> 00:46:59.106 A:middle
优化程序

00:46:59.106 --> 00:47:01.206 A:middle
消除不必要的副本

00:46:59.106 --> 00:47:01.206 A:middle
消除不必要的副本

00:47:01.206 --> 00:47:03.066 A:middle
并在你需要时保留它

00:47:03.216 --> 00:47:04.966 A:middle
但是在一些情况下

00:47:05.126 --> 00:47:07.336 A:middle
这能让我们在默认设置下

00:47:07.636 --> 00:47:08.836 A:middle
更迅速地使用 Swift

00:47:09.726 --> 00:47:11.426 A:middle
最终 它将启用一些

00:47:11.426 --> 00:47:13.936 A:middle
非常强大的新语言

00:47:13.936 --> 00:47:15.986 A:middle
特性来创建

00:47:16.126 --> 00:47:18.156 A:middle
安全和有效的

00:47:18.156 --> 00:47:20.356 A:middle
抽象 但在我们做事前

00:47:20.356 --> 00:47:22.396 A:middle
我们必须让理解内存

00:47:22.476 --> 00:47:23.976 A:middle
更容易

00:47:24.326 --> 00:47:26.116 A:middle
这意味着

00:47:26.146 --> 00:47:27.916 A:middle
独占访问内存

00:47:28.976 --> 00:47:30.186 A:middle
所以我的意思是

00:47:31.486 --> 00:47:32.576 A:middle
让我们来看看一个例子

00:47:33.606 --> 00:47:35.086 A:middle
通常情况下 我像这样

00:47:35.246 --> 00:47:37.046 A:middle
集合上进行迭代

00:47:37.126 --> 00:47:38.766 A:middle
我想修改我看到

00:47:38.766 --> 00:47:39.776 A:middle
的每一个元素

00:47:40.616 --> 00:47:42.166 A:middle
这是一个常见的模式

00:47:42.166 --> 00:47:43.856 A:middle
那么我将把它

00:47:43.856 --> 00:47:45.746 A:middle
变成一个方法

00:47:46.486 --> 00:47:49.096 A:middle
现在我有了这个方法

00:47:49.666 --> 00:47:51.376 A:middle
我得到了一个

00:47:51.546 --> 00:47:53.346 A:middle
通用的操作 这可以

00:47:53.346 --> 00:47:54.466 A:middle
用来修改任何可变的元素

00:47:54.976 --> 00:47:58.956 A:middle
每次一个元素

00:47:59.156 --> 00:48:01.966 A:middle
这个操作是在迭代

00:47:59.156 --> 00:48:01.966 A:middle
这个操作是在迭代

00:48:01.966 --> 00:48:03.676 A:middle
开始时捕获的

00:48:03.726 --> 00:48:07.386 A:middle
一组索引上

00:48:07.386 --> 00:48:08.176 A:middle
进行迭代

00:48:09.226 --> 00:48:11.256 A:middle
这只会在下面

00:48:11.256 --> 00:48:13.286 A:middle
这种情况下起作用

00:48:13.636 --> 00:48:15.186 A:middle
那就是该操作实际上

00:48:15.186 --> 00:48:16.976 A:middle
不通过添加或删除

00:48:16.976 --> 00:48:18.186 A:middle
集合中的元素来修改索引

00:48:19.356 --> 00:48:21.456 A:middle
但我实际上看得很清楚

00:48:21.556 --> 00:48:22.816 A:middle
这个方法中没有任何

00:48:22.816 --> 00:48:23.786 A:middle
一种操作实际上

00:48:23.786 --> 00:48:24.286 A:middle
修改了集合

00:48:24.416 --> 00:48:28.186 A:middle
是不是这样呢

00:48:28.186 --> 00:48:30.056 A:middle
我调用这个被传入的闭包

00:48:30.056 --> 00:48:31.726 A:middle
闭包是任意的代码

00:48:32.386 --> 00:48:34.406 A:middle
但是 我再看一下这个方式

00:48:34.406 --> 00:48:37.726 A:middle
我想没问题啊

00:48:37.856 --> 00:48:39.646 A:middle
我只是让这个闭包

00:48:39.646 --> 00:48:41.816 A:middle
访问一个集合的

00:48:41.816 --> 00:48:43.196 A:middle
特定元素 而不是

00:48:43.196 --> 00:48:44.216 A:middle
整个集合

00:48:44.616 --> 00:48:47.126 A:middle
因此我应该知道的是

00:48:47.126 --> 00:48:48.406 A:middle
在这个操作正在进行时

00:48:48.406 --> 00:48:50.336 A:middle
没有任何东西

00:48:50.336 --> 00:48:50.986 A:middle
可以修改集合

00:48:52.376 --> 00:48:54.526 A:middle
不幸的是 在 Swift 3 中

00:48:54.626 --> 00:48:55.586 A:middle
这不是语言的

00:48:55.586 --> 00:48:56.196 A:middle
工作方式

00:48:57.546 --> 00:48:59.086 A:middle
让我们回到我

00:48:59.086 --> 00:49:01.026 A:middle
调用方式的那个

00:48:59.086 --> 00:49:01.026 A:middle
调用方式的那个

00:49:01.026 --> 00:49:01.486 A:middle
代码那里

00:49:02.236 --> 00:49:03.106 A:middle
我们试试

00:49:03.106 --> 00:49:06.026 A:middle
把元素乘二

00:49:06.476 --> 00:49:08.296 A:middle
并试试去访问

00:49:08.296 --> 00:49:08.976 A:middle
数字变量

00:49:09.976 --> 00:49:11.276 A:middle
没有什么会

00:49:11.276 --> 00:49:11.766 A:middle
阻止我这么做

00:49:12.076 --> 00:49:14.756 A:middle
当我在另一个

00:49:14.756 --> 00:49:17.336 A:middle
方式中迭代它的时候

00:49:17.336 --> 00:49:20.106 A:middle
我可以在这个

00:49:20.106 --> 00:49:21.756 A:middle
闭包的任意点上

00:49:21.756 --> 00:49:23.176 A:middle
给变量移除或添加一些东西

00:49:23.796 --> 00:49:26.466 A:middle
当我这么做的时候

00:49:26.466 --> 00:49:27.866 A:middle
我突然想起了一件事

00:49:28.326 --> 00:49:30.216 A:middle
想推理出这个

00:49:30.256 --> 00:49:32.376 A:middle
数组中发生了什么

00:49:32.376 --> 00:49:33.106 A:middle
真的太难了

00:49:33.106 --> 00:49:36.456 A:middle
以前的情况是

00:49:36.826 --> 00:49:38.456 A:middle
这样的 我可以在

00:49:38.456 --> 00:49:39.996 A:middle
我的程序中查看

00:49:39.996 --> 00:49:41.786 A:middle
每个单独的函数

00:49:41.986 --> 00:49:44.186 A:middle
然后考虑它对每个

00:49:44.306 --> 00:49:46.106 A:middle
变量做了什么

00:49:46.736 --> 00:49:47.596 A:middle
这非常棒

00:49:47.896 --> 00:49:49.086 A:middle
这是我们所说的

00:49:49.156 --> 00:49:50.976 A:middle
值语义的

00:49:50.976 --> 00:49:51.416 A:middle
最好属性之一

00:49:51.416 --> 00:49:52.836 A:middle
你在你的程序 程序中的

00:49:52.896 --> 00:49:55.226 A:middle
每个部分都存在

00:49:55.266 --> 00:49:56.286 A:middle
这种隔离

00:49:56.786 --> 00:49:58.706 A:middle
所有的东西都组合在了一起

00:49:58.866 --> 00:50:00.206 A:middle
你也不必立马解释

00:49:58.866 --> 00:50:00.206 A:middle
你也不必立马解释

00:50:00.256 --> 00:50:01.836 A:middle
清楚所有的事情

00:50:03.136 --> 00:50:05.586 A:middle
但不幸的是

00:50:05.586 --> 00:50:07.476 A:middle
正因为我们可以

00:50:07.556 --> 00:50:09.966 A:middle
做这样的事情 我们得到了

00:50:09.966 --> 00:50:11.936 A:middle
一种参考语义

00:50:11.936 --> 00:50:13.556 A:middle
为了理解现在在发生了什么

00:50:13.636 --> 00:50:15.336 A:middle
你不得不理解你的

00:50:15.336 --> 00:50:16.676 A:middle
整个程序

00:50:17.646 --> 00:50:19.076 A:middle
这里当我做这些

00:50:19.176 --> 00:50:21.056 A:middle
事情的时候 我将会

00:50:21.116 --> 00:50:21.876 A:middle
查阅整个数组

00:50:22.686 --> 00:50:24.836 A:middle
对我来说尝试修复

00:50:24.836 --> 00:50:26.876 A:middle
我的代码并不困难

00:50:26.876 --> 00:50:29.566 A:middle
通过在集合开始时

00:50:29.856 --> 00:50:31.006 A:middle
迭代一组索引

00:50:31.006 --> 00:50:32.356 A:middle
我将每次重新

00:50:32.416 --> 00:50:34.636 A:middle
加载索引

00:50:34.636 --> 00:50:37.066 A:middle
然后比较

00:50:37.066 --> 00:50:38.986 A:middle
这两种方法

00:50:38.986 --> 00:50:40.486 A:middle
如果我从最后移过来一点东西

00:50:40.486 --> 00:50:41.416 A:middle
一切又都运行的非常正常

00:50:41.936 --> 00:50:46.266 A:middle
哦对了 其实

00:50:46.296 --> 00:50:46.456 A:middle
还有另一种方法

00:50:46.656 --> 00:50:47.336 A:middle
一种更好的方法

00:50:47.966 --> 00:50:50.076 A:middle
因为我的代码

00:50:50.076 --> 00:50:51.946 A:middle
有些丑

00:50:51.946 --> 00:50:52.556 A:middle
还运行得很慢

00:50:52.856 --> 00:50:54.376 A:middle
然而如果它足够好

00:50:54.376 --> 00:50:55.896 A:middle
那确实是个不错的

00:50:55.956 --> 00:50:57.226 A:middle
权衡之道 对吗

00:50:57.846 --> 00:50:59.486 A:middle
你知道吗 如果能让

00:50:59.486 --> 00:51:00.886 A:middle
你的性能

00:50:59.486 --> 00:51:00.886 A:middle
你的性能

00:51:00.886 --> 00:51:03.826 A:middle
变得更加优秀

00:51:04.036 --> 00:51:06.376 A:middle
牺牲一点美观度

00:51:06.376 --> 00:51:06.806 A:middle
也无可厚非

00:51:08.336 --> 00:51:09.466 A:middle
但在这里还

00:51:09.466 --> 00:51:09.986 A:middle
不够好

00:51:10.686 --> 00:51:11.986 A:middle
那让我们再回到

00:51:11.986 --> 00:51:12.306 A:middle
这个闭包上去

00:51:12.856 --> 00:51:14.966 A:middle
如果不是在循环

00:51:15.016 --> 00:51:19.126 A:middle
结束时移除一个东西

00:51:19.126 --> 00:51:20.796 A:middle
如果在我

00:51:20.846 --> 00:51:22.576 A:middle
访问元素之前

00:51:22.666 --> 00:51:23.216 A:middle
就擦除整个数组

00:51:23.826 --> 00:51:26.436 A:middle
现在它现在访问的

00:51:26.496 --> 00:51:27.036 A:middle
是什么

00:51:27.466 --> 00:51:28.686 A:middle
它要去哪里

00:51:29.516 --> 00:51:31.276 A:middle
我其实正在分配

00:51:31.276 --> 00:51:32.856 A:middle
一些根本不存在的东西

00:51:33.076 --> 00:51:34.246 A:middle
因为数组中没有

00:51:34.246 --> 00:51:35.706 A:middle
任何元素

00:51:37.016 --> 00:51:38.806 A:middle
这是一个非常好的

00:51:38.836 --> 00:51:40.116 A:middle
问题 为了回答这个问题

00:51:40.116 --> 00:51:41.076 A:middle
我们需要深入

00:51:41.076 --> 00:51:42.756 A:middle
研究数组的

00:51:43.336 --> 00:51:43.576 A:middle
实现方式

00:51:43.576 --> 00:51:45.846 A:middle
数组是一个写值类型的拷贝

00:51:45.846 --> 00:51:47.156 A:middle
它用一个引用计数

00:51:47.266 --> 00:51:49.166 A:middle
缓存区来实现

00:51:49.916 --> 00:51:52.626 A:middle
在循环开始时

00:51:53.956 --> 00:51:57.026 A:middle
数字正指向

00:51:57.076 --> 00:51:58.846 A:middle
该缓存区

00:51:59.036 --> 00:52:00.866 A:middle
为了保证性能 Swift

00:51:59.036 --> 00:52:00.866 A:middle
为了保证性能 Swift

00:52:00.866 --> 00:52:02.836 A:middle
希望将直接传递到

00:52:03.066 --> 00:52:05.816 A:middle
闭包中的元素变量

00:52:05.816 --> 00:52:08.316 A:middle
绑定到该缓存区

00:52:08.316 --> 00:52:09.296 A:middle
的内存之中

00:52:10.106 --> 00:52:11.706 A:middle
这就产生了一个问题

00:52:11.966 --> 00:52:12.886 A:middle
因为当我们分配时

00:52:12.886 --> 00:52:16.056 A:middle
数字不再

00:52:16.056 --> 00:52:17.746 A:middle
指向那个缓冲区

00:52:17.746 --> 00:52:19.026 A:middle
这意味着不再

00:52:19.026 --> 00:52:19.536 A:middle
维持它的活动

00:52:20.736 --> 00:52:23.026 A:middle
Swift 是一种安全的语言

00:52:23.266 --> 00:52:24.826 A:middle
我们并不想让它

00:52:24.826 --> 00:52:26.236 A:middle
成为一个危险因素

00:52:26.646 --> 00:52:28.256 A:middle
所以 我们必须做些事情

00:52:28.256 --> 00:52:30.226 A:middle
来保证这个缓存区是活动的

00:52:30.226 --> 00:52:31.646 A:middle
这样才不会导致

00:52:31.646 --> 00:52:32.216 A:middle
程序崩溃

00:52:32.986 --> 00:52:33.786 A:middle
这是如何工作的呢

00:52:34.616 --> 00:52:37.006 A:middle
在子脚本操作的时候

00:52:37.096 --> 00:52:39.556 A:middle
Swift 实际上

00:52:39.556 --> 00:52:41.986 A:middle
悄悄地创建了

00:52:41.986 --> 00:52:43.976 A:middle
一个模糊的对缓存区的引用

00:52:43.976 --> 00:52:45.206 A:middle
这就是它的工作方式

00:52:46.226 --> 00:52:48.886 A:middle
这使程序免于崩溃

00:52:49.386 --> 00:52:50.926 A:middle
但这会浪费额外的

00:52:50.926 --> 00:52:53.266 A:middle
性能 我们希望优化器

00:52:53.266 --> 00:52:55.096 A:middle
在每次将

00:52:55.146 --> 00:52:57.486 A:middle
脚本放入

00:52:57.706 --> 00:52:59.136 A:middle
数组时都可以

00:52:59.136 --> 00:52:59.346 A:middle
清理掉它们

00:52:59.946 --> 00:53:03.906 A:middle
这种对内存的

00:52:59.946 --> 00:53:03.906 A:middle
这种对内存的

00:53:03.906 --> 00:53:05.456 A:middle
非独占访问内存

00:53:05.456 --> 00:53:07.446 A:middle
会在多个层面产生问题

00:53:07.676 --> 00:53:09.166 A:middle
比如程序中的

00:53:09.206 --> 00:53:09.716 A:middle
级联问题

00:53:10.166 --> 00:53:11.766 A:middle
这让整件事情变得

00:53:11.766 --> 00:53:12.136 A:middle
更难理解

00:53:12.516 --> 00:53:14.356 A:middle
这是你的代码并不那么通用

00:53:14.676 --> 00:53:16.236 A:middle
证明正确性时也更复杂

00:53:17.206 --> 00:53:18.566 A:middle
当你试图去优化这些

00:53:18.566 --> 00:53:20.486 A:middle
一般的数据结构时

00:53:20.486 --> 00:53:22.946 A:middle
他会在你的程序

00:53:22.946 --> 00:53:24.756 A:middle
和 Swift 中产生

00:53:24.756 --> 00:53:26.086 A:middle
性能问题

00:53:27.156 --> 00:53:28.826 A:middle
解决方案是我们必须

00:53:28.826 --> 00:53:31.276 A:middle
拥有对内存的独占访问权

00:53:31.806 --> 00:53:35.336 A:middle
我所谓的独占性是什么意思

00:53:35.496 --> 00:53:39.016 A:middle
程序中有两个不用的

00:53:39.016 --> 00:53:40.086 A:middle
部分在同一时间从

00:53:40.086 --> 00:53:41.356 A:middle
同一个变量中读取

00:53:41.356 --> 00:53:42.656 A:middle
这是没问题的

00:53:44.286 --> 00:53:45.326 A:middle
但是 当我在为变量

00:53:45.326 --> 00:53:46.926 A:middle
写入一些东西的时候

00:53:47.266 --> 00:53:48.946 A:middle
很重要的一点就是

00:53:48.946 --> 00:53:50.476 A:middle
什么都不能访问

00:53:50.946 --> 00:53:52.166 A:middle
写入变量的东西

00:53:52.166 --> 00:53:53.866 A:middle
应该是独占的

00:53:54.736 --> 00:53:55.246 A:middle
就是这样

00:53:55.726 --> 00:53:56.616 A:middle
这就是规则

00:53:56.616 --> 00:53:58.006 A:middle
这既是我们在

00:53:58.066 --> 00:53:59.526 A:middle
Swift 4 中添加的新规则

00:54:00.186 --> 00:54:04.166 A:middle
那么我们该如何实施呢

00:54:04.796 --> 00:54:08.896 A:middle
在大多数情况下 就像我们

00:54:08.896 --> 00:54:10.896 A:middle
最初执行的例子一样

00:54:10.896 --> 00:54:12.676 A:middle
Swift 其实能在编译时

00:54:12.676 --> 00:54:15.846 A:middle
执行这一过程

00:54:16.056 --> 00:54:18.136 A:middle
这里我调用了一个

00:54:18.136 --> 00:54:19.736 A:middle
关于数字的突变方法

00:54:19.986 --> 00:54:22.046 A:middle
在调用期间

00:54:22.046 --> 00:54:23.166 A:middle
赋予了它权限

00:54:23.166 --> 00:54:27.306 A:middle
当我在这个调用后面

00:54:27.306 --> 00:54:29.576 A:middle
入手并调用另一个

00:54:29.576 --> 00:54:30.876 A:middle
正在运行的方法时

00:54:31.496 --> 00:54:33.226 A:middle
我就得到了一个

00:54:33.636 --> 00:54:34.856 A:middle
有违规则的权限冲突

00:54:35.346 --> 00:54:36.596 A:middle
在编译时发生

00:54:36.596 --> 00:54:38.486 A:middle
这种事情

00:54:38.796 --> 00:54:39.806 A:middle
Swift 会立刻

00:54:39.856 --> 00:54:40.576 A:middle
告诉你

00:54:41.166 --> 00:54:44.036 A:middle
一般来说 在大多数

00:54:44.036 --> 00:54:46.726 A:middle
值语义情况下

00:54:46.796 --> 00:54:48.336 A:middle
这都是正确的

00:54:49.346 --> 00:54:50.906 A:middle
但在某些情况下

00:54:51.966 --> 00:54:54.236 A:middle
这是不可能的

00:54:54.816 --> 00:54:56.176 A:middle
通常是由于

00:54:56.176 --> 00:54:57.276 A:middle
某种参考语义

00:54:57.446 --> 00:54:59.106 A:middle
要么是全局变量

00:54:59.106 --> 00:55:01.116 A:middle
要么是像类属型

00:54:59.106 --> 00:55:01.116 A:middle
要么是像类属型

00:55:01.116 --> 00:55:02.126 A:middle
这样的共享内存

00:55:03.486 --> 00:55:04.526 A:middle
那么 让我们回到

00:55:04.526 --> 00:55:05.446 A:middle
之前的例子

00:55:05.976 --> 00:55:08.206 A:middle
这里 数字

00:55:08.206 --> 00:55:08.776 A:middle
代表一个局部变量

00:55:09.266 --> 00:55:12.396 A:middle
但如果它是一个

00:55:13.616 --> 00:55:15.726 A:middle
类属性呢

00:55:15.816 --> 00:55:17.486 A:middle
嗯 情况基本上

00:55:17.486 --> 00:55:20.186 A:middle
还是一样的

00:55:20.386 --> 00:55:22.106 A:middle
这里 我调用了一个

00:55:22.106 --> 00:55:23.936 A:middle
类属性的变异方法

00:55:25.076 --> 00:55:27.326 A:middle
在闭包中

00:55:27.326 --> 00:55:29.616 A:middle
我在同一个类属性中

00:55:30.166 --> 00:55:31.366 A:middle
调用了同一个变异方法

00:55:32.266 --> 00:55:34.336 A:middle
但是他们是在对象上的

00:55:34.336 --> 00:55:36.816 A:middle
编译器无法判断

00:55:36.816 --> 00:55:38.446 A:middle
他们是否在同一个对象上

00:55:39.596 --> 00:55:42.036 A:middle
一般来说 类类型

00:55:42.286 --> 00:55:44.486 A:middle
的特点是你可以移动

00:55:44.486 --> 00:55:46.496 A:middle
复制 并在整个程序

00:55:46.496 --> 00:55:47.666 A:middle
中共享它们

00:55:48.306 --> 00:55:51.186 A:middle
在你喜欢的地方使用它们

00:55:51.736 --> 00:55:54.116 A:middle
但是 这意味着编译器

00:55:54.116 --> 00:55:55.746 A:middle
不能确切地告诉你

00:55:55.856 --> 00:55:58.136 A:middle
是否每个特定的函数

00:55:58.136 --> 00:56:00.456 A:middle
或者像这样的访问

00:55:58.136 --> 00:56:00.456 A:middle
或者像这样的访问

00:56:00.456 --> 00:56:02.936 A:middle
实际上是在

00:56:02.936 --> 00:56:04.396 A:middle
访问同一个对象

00:56:05.116 --> 00:56:06.226 A:middle
因此 编译器必须是

00:56:06.226 --> 00:56:06.976 A:middle
保守的

00:56:07.536 --> 00:56:09.556 A:middle
现在 如果我们一直

00:56:09.556 --> 00:56:11.606 A:middle
禁止这样的事情

00:56:11.676 --> 00:56:12.816 A:middle
是不太可能的

00:56:12.816 --> 00:56:14.486 A:middle
所以我们要做

00:56:14.586 --> 00:56:15.486 A:middle
动态检查

00:56:16.256 --> 00:56:17.366 A:middle
这意味着在运行时

00:56:17.366 --> 00:56:20.286 A:middle
我们会得到这样的错误

00:56:20.896 --> 00:56:22.986 A:middle
但前提是他们实际上

00:56:22.986 --> 00:56:23.696 A:middle
是同一对象

00:56:23.846 --> 00:56:24.806 A:middle
当然 如果它们是

00:56:24.806 --> 00:56:27.116 A:middle
不同的对象

00:56:27.256 --> 00:56:29.076 A:middle
那么它们会被认为是

00:56:29.076 --> 00:56:30.776 A:middle
两个类属性及不同的内存

00:56:31.346 --> 00:56:32.316 A:middle
这里并没有冲突

00:56:32.846 --> 00:56:37.726 A:middle
出于性能因素考虑

00:56:38.776 --> 00:56:40.936 A:middle
我们在做的这个强制执行

00:56:40.936 --> 00:56:42.486 A:middle
只在一个线程内完成

00:56:43.116 --> 00:56:45.476 A:middle
然而 我们在 Xcode 中

00:56:45.476 --> 00:56:47.406 A:middle
提供的线程杀毒工具

00:56:47.486 --> 00:56:49.226 A:middle
即使在不同的线程中

00:56:49.266 --> 00:56:50.906 A:middle
也可以捕捉到这些问题

00:56:51.716 --> 00:56:53.016 A:middle
本周晚些时候

00:56:53.016 --> 00:56:53.546 A:middle
会有个很棒的会议

00:56:53.866 --> 00:56:55.486 A:middle
我强烈建议你们

00:56:55.486 --> 00:56:57.706 A:middle
每个人都在 Xcode 中

00:56:57.776 --> 00:56:59.326 A:middle
找找像这样的 bug

00:57:03.216 --> 00:57:05.226 A:middle
这就是 Swift 4 的规则

00:57:06.636 --> 00:57:08.066 A:middle
就像我们昨天在发布会上

00:57:08.306 --> 00:57:12.596 A:middle
说的那样 Swift 3.2 是允许

00:57:12.596 --> 00:57:15.466 A:middle
你现有的代码

00:57:15.466 --> 00:57:16.896 A:middle
继续工作的

00:57:17.606 --> 00:57:19.526 A:middle
因此 在 Swift 3.2 中

00:57:19.586 --> 00:57:19.886 A:middle
这仅仅会作为警告存在

00:57:20.716 --> 00:57:23.436 A:middle
但是 因为 Swift 4 和

00:57:23.436 --> 00:57:27.356 A:middle
Swift 3 需要在 Xcode

00:57:27.356 --> 00:57:30.066 A:middle
的未来版本中进行交互操作

00:57:30.066 --> 00:57:31.676 A:middle
所以即使在 Swift 3 模式下

00:57:31.726 --> 00:57:33.496 A:middle
我们也会以错误这一形式显示

00:57:34.236 --> 00:57:36.066 A:middle
所以我们强烈建议

00:57:36.216 --> 00:57:37.846 A:middle
你能注意到这些警告

00:57:38.316 --> 00:57:39.086 A:middle
并修复它们

00:57:39.456 --> 00:57:40.496 A:middle
因为他们只是警告

00:57:40.536 --> 00:57:41.776 A:middle
所以你可以在

00:57:41.856 --> 00:57:42.226 A:middle
任意时间去修复它们

00:57:42.226 --> 00:57:44.116 A:middle
你可以按照你自己的节奏来

00:57:44.116 --> 00:57:45.486 A:middle
但是你需要认真的对待它们了

00:57:52.076 --> 00:57:53.966 A:middle
我们非常期待

00:57:54.006 --> 00:57:55.196 A:middle
它所能够带来

00:57:55.196 --> 00:57:55.576 A:middle
的影响

00:57:55.866 --> 00:57:57.066 A:middle
这使得代码

00:57:57.136 --> 00:58:00.126 A:middle
更易理解

00:57:57.136 --> 00:58:00.126 A:middle
更易理解

00:58:00.126 --> 00:58:03.716 A:middle
在库和编译器中

00:58:03.716 --> 00:58:05.376 A:middle
它都启用了

00:58:05.616 --> 00:58:07.416 A:middle
许多非常棒

00:58:07.416 --> 00:58:08.106 A:middle
的优化

00:58:08.416 --> 00:58:09.776 A:middle
而且他也提供一些

00:58:10.386 --> 00:58:12.076 A:middle
很易上手的工具

00:58:12.076 --> 00:58:14.666 A:middle
使用这些工具

00:58:15.016 --> 00:58:18.496 A:middle
你可以以你自己的方式

00:58:18.496 --> 00:58:20.256 A:middle
去优化代码

00:58:20.256 --> 00:58:21.236 A:middle
这是非常棒的

00:58:22.386 --> 00:58:23.626 A:middle
如果你对我们

00:58:23.626 --> 00:58:25.116 A:middle
准备用它来做什么

00:58:25.116 --> 00:58:26.796 A:middle
感兴趣 在 Swift 官网上

00:58:26.946 --> 00:58:28.736 A:middle
有一个开发者宣言

00:58:28.736 --> 00:58:30.476 A:middle
你可以去

00:58:30.476 --> 00:58:32.946 A:middle
看一下

00:58:33.216 --> 00:58:34.546 A:middle
现在 有一个警告你需要知道

00:58:34.706 --> 00:58:36.276 A:middle
这周我们已经给出了

00:58:36.276 --> 00:58:38.186 A:middle
开发者预览版

00:58:38.186 --> 00:58:39.826 A:middle
有些功能还在实现中

00:58:40.226 --> 00:58:41.396 A:middle
在发布说明中

00:58:41.396 --> 00:58:42.296 A:middle
有很多信息

00:58:42.556 --> 00:58:43.766 A:middle
我真的希望你们能自己

00:58:43.816 --> 00:58:44.256 A:middle
去阅读一下

00:58:44.846 --> 00:58:46.406 A:middle
我希望你们自己去探索

00:58:46.406 --> 00:58:48.496 A:middle
所有的这些东西

00:58:48.496 --> 00:58:49.426 A:middle
确保每一项功能都能得到实现

00:58:49.486 --> 00:58:50.646 A:middle
如果你遇到了任何困难

00:58:50.646 --> 00:58:50.976 A:middle
请与我们沟通

00:58:54.086 --> 00:58:55.676 A:middle
这就是今天

00:58:55.746 --> 00:58:56.076 A:middle
Swift 的新版本发布会

00:58:56.836 --> 00:58:58.306 A:middle
除了库和语言之外

00:58:58.306 --> 00:59:00.506 A:middle
我们还做了

00:58:58.306 --> 00:59:00.506 A:middle
我们还做了

00:59:00.506 --> 00:59:03.416 A:middle
许多的改进

00:59:04.036 --> 00:59:05.676 A:middle
我们已经有了一个

00:59:06.146 --> 00:59:07.436 A:middle
很棒的 Swift

00:59:07.436 --> 00:59:07.896 A:middle
并对很多东西进行了优化

00:59:08.606 --> 00:59:10.186 A:middle
我们真的在工作上

00:59:10.186 --> 00:59:12.306 A:middle
投入了许多精力和时间

00:59:12.306 --> 00:59:13.526 A:middle
这足以使你提高代码性能

00:59:13.526 --> 00:59:14.276 A:middle
并压缩代码大小

00:59:14.366 --> 00:59:17.496 A:middle
希望你们享受 WWDC

00:59:17.586 --> 00:59:18.626 A:middle
再此感谢大家能够

00:59:18.626 --> 00:59:18.816 A:middle
亲临现场

00:59:19.516 --> 00:59:23.500 A:middle
[掌声]
