WEBVTT

00:00:17.551 --> 00:00:22.055 align:middle line:10%
<c.magenta>（高级触控条 演讲222）</c>

00:00:23.156 --> 00:00:23.991 align:middle line:90%,end
<c.magenta>大家好</c>

00:00:27.394 --> 00:00:29.396 align:middle line:90%,end
<c.magenta>我是唐娜·汤姆</c>
<c.magenta>我是一名TextKit工程师</c>

00:00:29.997 --> 00:00:32.499 align:middle line:90%,end
<c.magenta>今天我的同事AppKit工程师</c>

00:00:33.100 --> 00:00:34.902 align:middle line:90%,end
<c.magenta>杰夫·纳多和泰勒·凯利</c>
<c.magenta>将和我一起为大家演讲</c>

00:00:34.968 --> 00:00:36.770 align:middle line:90%,end
<c.magenta>我们非常激动能跟大家谈谈</c>

00:00:36.837 --> 00:00:38.338 align:middle line:90%,end
<c.magenta>触控条的高级概念</c>

00:00:39.473 --> 00:00:41.708 align:middle line:90%,end
<c.magenta>但愿你们观看了</c>

00:00:41.775 --> 00:00:43.844 align:middle line:90%,end
<c.magenta>或参加了今天早些时候的</c>
<c.magenta>Fundamental演讲</c>

00:00:44.077 --> 00:00:46.847 align:middle line:90%,end
<c.magenta>如果你没有在家关注那场演讲</c>
<c.magenta>现在可以看一下</c>

00:00:47.648 --> 00:00:48.815 align:middle line:90%,end
<c.magenta>若你现已在此</c>
<c.magenta>请留下来</c>

00:00:50.984 --> 00:00:52.619 align:middle line:90%,end
<c.magenta>那是一场很棒的演讲</c>
<c.magenta>我真的推荐你们</c>

00:00:52.686 --> 00:00:54.221 align:middle line:90%,end
<c.magenta>如果有时间就看一下视频</c>

00:00:55.155 --> 00:00:57.958 align:middle line:90%,end
<c.magenta>你可以了解如何</c>
<c.magenta>创建你自己的NSTouchBars</c>

00:00:58.025 --> 00:00:59.593 align:middle line:90%,end
<c.magenta>以及如何使用它的输入功能</c>

00:00:59.660 --> 00:01:01.895 align:middle line:90%,end
<c.magenta>来提升你应用的用户体验</c>

00:00:59.660 --> 00:01:01.895 align:middle line:90%,end
<c.magenta>来提升你应用的用户体验</c>

00:01:02.963 --> 00:01:04.464 align:middle line:90%,end
<c.magenta>而且你可以方便地利用触控条</c>

00:01:04.531 --> 00:01:07.000 align:middle line:90%,end
<c.magenta>就通过你在那场Fundamental演讲中</c>
<c.magenta>所学到的东西就够了</c>

00:01:08.268 --> 00:01:10.370 align:middle line:90%,end
<c.magenta>但你们参加这场演讲的原因</c>
<c.magenta>很可能是因为你想要更多</c>

00:01:10.437 --> 00:01:11.905 align:middle line:90%,end
<c.magenta>来提升你的应用</c>

00:01:12.339 --> 00:01:14.241 align:middle line:90%,end
<c.magenta>也许你想自定义</c>
<c.magenta>由触控件提供的标准栏</c>

00:01:14.308 --> 00:01:15.976 align:middle line:90%,end
<c.magenta>如邮件应用的</c>

00:01:16.043 --> 00:01:17.611 align:middle line:90%,end
<c.magenta>邮件自动完成项</c>

00:01:18.612 --> 00:01:20.681 align:middle line:90%,end
<c.magenta>或者也许你想给你的应用</c>
<c.magenta>添加一个拖动器</c>

00:01:20.981 --> 00:01:23.217 align:middle line:90%,end
<c.magenta>以便用户可以快速滚动并选择内容</c>

00:01:23.617 --> 00:01:24.985 align:middle line:90%,end
<c.magenta>比如日历的日期选择器</c>

00:01:26.019 --> 00:01:29.590 align:middle line:90%,end
<c.magenta>或者也许你甚至希望添加</c>
<c.magenta>你自己的完全自定义控件</c>

00:01:29.957 --> 00:01:31.191 align:middle line:90%,end
<c.magenta>比如系统颜色选择器</c>

00:01:31.925 --> 00:01:32.993 align:middle line:90%,end
<c.magenta>那么在本场演讲中</c>

00:01:33.060 --> 00:01:35.329 align:middle line:90%,end
<c.magenta>我们会向大家介绍如何创建这些东西</c>

00:01:35.395 --> 00:01:37.798 align:middle line:90%,end
<c.magenta>我们会深入到技术点和最佳范例</c>

00:01:38.198 --> 00:01:40.033 align:middle line:90%,end
<c.magenta>来自定义标准组件</c>

00:01:40.200 --> 00:01:42.002 align:middle line:90%,end
<c.magenta>以及创建你自己的自定义控件</c>

00:01:42.069 --> 00:01:45.472 align:middle line:90%,end
<c.magenta>让你有能力、灵活地来为用户</c>
<c.magenta>创建丰富的体验</c>

00:01:47.207 --> 00:01:49.910 align:middle line:90%,end
<c.magenta>那么首先是自定义TextBars</c>

00:01:51.845 --> 00:01:53.881 align:middle line:90%,end
<c.magenta>我们要从标准项开始讲</c>

00:01:54.481 --> 00:01:56.149 align:middle line:90%,end
<c.magenta>然后会讲</c>

00:01:56.216 --> 00:01:58.986 align:middle line:90%,end
<c.magenta>如何禁用标准项</c>
<c.magenta>以及如何添加你自己的自定义项</c>

00:01:59.920 --> 00:02:02.055 align:middle line:90%,end
<c.magenta>最后我们要了解补充列表项</c>

00:01:59.920 --> 00:02:02.055 align:middle line:90%,end
<c.magenta>最后我们要了解补充列表项</c>

00:02:02.389 --> 00:02:04.758 align:middle line:90%,end
<c.magenta>而且我们会看一下</c>
<c.magenta>如何创建邮件自动完成项</c>

00:02:04.825 --> 00:02:06.393 align:middle line:90%,end
<c.magenta>类似于你在Mail应用中看到的那样</c>

00:02:10.964 --> 00:02:12.733 align:middle line:90%,end
<c.magenta>那么让我们从标准项开始讲吧</c>

00:02:13.600 --> 00:02:16.503 align:middle line:90%,end
<c.magenta>现在我们给标准TextBars</c>
<c.magenta>创建了很多不错的功能</c>

00:02:16.737 --> 00:02:19.540 align:middle line:90%,end
<c.magenta>如果你使用TextView或TextField</c>
<c.magenta>你猜怎么样？</c>

00:02:19.940 --> 00:02:22.709 align:middle line:90%,end
<c.magenta>这些组件在方框外也支持NSTouchBar</c>

00:02:22.776 --> 00:02:23.744 align:middle line:90%,end
<c.magenta>（标准项）</c>

00:02:23.810 --> 00:02:25.546 align:middle line:90%,end
<c.magenta>现在当TextView或TextField</c>

00:02:26.079 --> 00:02:29.216 align:middle line:90%,end
<c.magenta>是你应用的第一响应器时</c>
<c.magenta>它将会自动获得一个触控条</c>

00:02:29.283 --> 00:02:30.784 align:middle line:90%,end
<c.magenta>填充由控件属性</c>

00:02:30.851 --> 00:02:32.686 align:middle line:90%,end
<c.magenta>和内容驱动的触控项</c>

00:02:33.287 --> 00:02:34.888 align:middle line:90%,end
<c.magenta>那么默认情况是这样的</c>

00:02:36.890 --> 00:02:39.459 align:middle line:90%,end
<c.magenta>QuickType建议</c>
<c.magenta>可以展开和折叠</c>

00:02:39.526 --> 00:02:41.195 align:middle line:90%,end
<c.magenta>通过使用左侧的小尖括号</c>

00:02:41.962 --> 00:02:43.997 align:middle line:90%,end
<c.magenta>上边的触控条显示的是折叠时的样子</c>

00:02:44.298 --> 00:02:46.733 align:middle line:90%,end
<c.magenta>而下边的触控条显示的是展开时的样子</c>

00:02:48.135 --> 00:02:51.271 align:middle line:90%,end
<c.magenta>你还会得到一个表情选择器</c>
<c.magenta>可以使用全部这些很棒的表情</c>

00:02:51.338 --> 00:02:52.339 align:middle line:90%,end
<c.magenta>（表情选择器）</c>

00:02:52.406 --> 00:02:55.943 align:middle line:90%,end
<c.magenta>如果启用了富文本</c>
<c.magenta>你还会得到一个颜色选择器</c>

00:02:56.009 --> 00:02:57.678 align:middle line:90%,end
<c.magenta>（颜色选择器）</c>

00:02:57.744 --> 00:02:58.745 align:middle line:90%,end
<c.magenta>格式控件</c>

00:02:58.812 --> 00:02:59.980 align:middle line:90%,end
<c.magenta>（格式）</c>

00:03:00.047 --> 00:03:02.149 align:middle line:90%,end
<c.magenta>以及对齐和列表控件</c>

00:03:02.983 --> 00:03:06.620 align:middle line:90%,end
<c.magenta>当你使用NSTextView或NSTextField时</c>
<c.magenta>你会免费得到全部这些东西</c>

00:03:06.820 --> 00:03:08.789 align:middle line:90%,end
<c.magenta>你不用写一行代码</c>

00:03:10.457 --> 00:03:12.492 align:middle line:90%,end
<c.magenta>但是这些到底是如何工作的呢？</c>

00:03:13.160 --> 00:03:13.994 align:middle line:90%,end
<c.magenta>嗯</c>

00:03:14.895 --> 00:03:17.564 align:middle line:90%,end
<c.magenta>NSTextView和NSTouchBar的整合</c>
<c.magenta>非常紧密</c>

00:03:17.631 --> 00:03:19.633 align:middle line:90%,end
<c.magenta>以便提供很棒的功能</c>

00:03:20.567 --> 00:03:23.203 align:middle line:90%,end
<c.magenta>因为触控条中的触控项</c>
<c.magenta>可能需要修改</c>

00:03:23.270 --> 00:03:25.038 align:middle line:90%,end
<c.magenta>根据所输入文本的内容</c>

00:03:25.439 --> 00:03:27.641 align:middle line:90%,end
<c.magenta>NSTextView实际上将自己作为了</c>

00:03:27.708 --> 00:03:30.244 align:middle line:90%,end
<c.magenta>它自己的NSTouchBar实例委托</c>

00:03:31.211 --> 00:03:35.182 align:middle line:90%,end
<c.magenta>如果你使用NSTextField</c>
<c.magenta>请记住NSTextView实例</c>

00:03:35.249 --> 00:03:37.618 align:middle line:90%,end
<c.magenta>的作用是当前激活的</c>
<c.magenta>TextField的字段编辑器</c>

00:03:38.519 --> 00:03:40.821 align:middle line:90%,end
<c.magenta>那么当你在TextField</c>
<c.magenta>触控条中放东西时</c>

00:03:41.121 --> 00:03:44.491 align:middle line:90%,end
<c.magenta>这与包含NSTouchBar</c>
<c.magenta>标准触控项的实例不一样</c>

00:03:46.059 --> 00:03:49.029 align:middle line:90%,end
<c.magenta>字段编辑器的触控条</c>
<c.magenta>是包含标准触控项的那个</c>

00:03:50.230 --> 00:03:52.299 align:middle line:90%,end
<c.magenta>就字段编辑器这个话题</c>

00:03:52.666 --> 00:03:55.869 align:middle line:90%,end
<c.magenta>请记住字段编辑器是在窗口中的</c>
<c.magenta>全部文本字段中共享的</c>

00:03:56.236 --> 00:03:58.639 align:middle line:90%,end
<c.magenta>所以如果你修改字段编辑器的触控条</c>

00:03:58.972 --> 00:04:02.242 align:middle line:90%,end
<c.magenta>这些修改同样也会影响</c>
<c.magenta>窗口中的全部文本字段</c>

00:03:58.972 --> 00:04:02.242 align:middle line:90%,end
<c.magenta>这些修改同样也会影响</c>
<c.magenta>窗口中的全部文本字段</c>

00:04:02.476 --> 00:04:04.478 align:middle line:90%,end
<c.magenta>这是一个需要时刻谨记的重要概念</c>

00:04:04.545 --> 00:04:05.779 align:middle line:90%,end
<c.magenta>尤其当你处理文本字段时</c>

00:04:05.846 --> 00:04:07.381 align:middle line:90%,end
<c.magenta>（标准触控项</c>
<c.magenta>字段编辑器小贴士）</c>

00:04:07.848 --> 00:04:11.285 align:middle line:90%,end
<c.magenta>那么现在我们了解了更多关于</c>
<c.magenta>这些组件是如何共同工作的</c>

00:04:11.351 --> 00:04:13.287 align:middle line:90%,end
<c.magenta>让我们谈谈如何禁用标注触控项</c>

00:04:13.353 --> 00:04:14.354 align:middle line:90%,end
<c.magenta>（禁用标准触控项）</c>

00:04:14.421 --> 00:04:15.656 align:middle line:90%,end
<c.magenta>其实非常简单</c>

00:04:15.856 --> 00:04:18.024 align:middle line:90%,end
<c.magenta>你所要做的就是设置相应的属性</c>

00:04:18.225 --> 00:04:19.860 align:middle line:90%,end
<c.magenta>在textView或textField上</c>

00:04:20.861 --> 00:04:22.162 align:middle line:90%,end
<c.magenta>当你设置这些属性时</c>

00:04:22.663 --> 00:04:24.531 align:middle line:90%,end
<c.magenta>textView会自动得到一个通知</c>

00:04:24.831 --> 00:04:27.801 align:middle line:90%,end
<c.magenta>说它的触控条项需要更新</c>
<c.magenta>所以你不需要做什么</c>

00:04:29.503 --> 00:04:32.773 align:middle line:90%,end
<c.magenta>QuickType和表情选择器</c>
<c.magenta>都是由自己的属性控制的</c>

00:04:33.440 --> 00:04:36.543 align:middle line:90%,end
<c.magenta>其余的标准触控项都是文本样式控件</c>

00:04:37.244 --> 00:04:41.648 align:middle line:90%,end
<c.magenta>并且只有在文本字段</c>
<c.magenta>启用富文本时才会出现这些</c>

00:04:41.715 --> 00:04:44.551 align:middle line:90%,end
<c.magenta>如果没有启用富文本</c>
<c.magenta>那么你就不会得到这些触控项</c>

00:04:46.153 --> 00:04:49.256 align:middle line:90%,end
<c.magenta>在你在全部文本控件中</c>
<c.magenta>禁用QuickType之前</c>

00:04:49.523 --> 00:04:51.024 align:middle line:90%,end
<c.magenta>请考虑一下你的用户</c>

00:04:53.527 --> 00:04:55.863 align:middle line:90%,end
<c.magenta>我知道你们中有一些人</c>
<c.magenta>可能不想使用QuickType项</c>

00:04:56.263 --> 00:04:59.766 align:middle line:90%,end
<c.magenta>但我想强调的是你们的用户</c>
<c.magenta>可能与你的偏好不一样</c>

00:05:00.267 --> 00:05:04.371 align:middle line:90%,end
<c.magenta>事实上 你的用户可以</c>
<c.magenta>自己禁用QuickType建议</c>

00:05:04.705 --> 00:05:07.307 align:middle line:90%,end
<c.magenta>可以通过这里显示的系统偏好窗格</c>

00:05:07.374 --> 00:05:10.043 align:middle line:90%,end
<c.magenta>或通过自定义他们的触控条实现</c>

00:05:10.444 --> 00:05:12.412 align:middle line:90%,end
<c.magenta>所以请考虑</c>
<c.magenta>将QuickType设为启用状态</c>

00:05:12.479 --> 00:05:15.148 align:middle line:90%,end
<c.magenta>并允许你的用户自己决定是否使用</c>

00:05:17.451 --> 00:05:19.520 align:middle line:90%,end
<c.magenta>那么现在我们了解了</c>
<c.magenta>如何禁用标准触控项</c>

00:05:19.586 --> 00:05:21.588 align:middle line:90%,end
<c.magenta>让我们来谈谈如何</c>
<c.magenta>添加你自己的自定义触控项</c>

00:05:22.823 --> 00:05:23.891 align:middle line:90%,end
<c.magenta>（添加自定义触控项）</c>

00:05:23.957 --> 00:05:25.359 align:middle line:90%,end
<c.magenta>那么这里是一些示例触控项</c>

00:05:25.425 --> 00:05:28.295 align:middle line:90%,end
<c.magenta>在TextBar中添加到了</c>
<c.magenta>标准触控项旁边</c>

00:05:29.429 --> 00:05:32.466 align:middle line:90%,end
<c.magenta>若你观看了Fundamentals演讲视频</c>
<c.magenta>上边的触控条可能看起来有点眼熟</c>

00:05:32.533 --> 00:05:35.302 align:middle line:90%,end
<c.magenta>左侧一直有一个发送邮件按钮</c>

00:05:36.003 --> 00:05:37.704 align:middle line:90%,end
<c.magenta>下边的触控条有一个全选按钮</c>

00:05:37.771 --> 00:05:39.806 align:middle line:90%,end
<c.magenta>就位于表情选择器右边</c>

00:05:40.040 --> 00:05:43.310 align:middle line:90%,end
<c.magenta>那么我要如何在我的TextBar中</c>
<c.magenta>添加像这样的按钮呢？</c>

00:05:45.479 --> 00:05:48.282 align:middle line:90%,end
<c.magenta>嗯 你可能会很想</c>
<c.magenta>在ViewDidLoad中实现</c>

00:05:49.349 --> 00:05:50.784 align:middle line:90%,end
<c.magenta>抓住你textField的触控条</c>

00:05:51.785 --> 00:05:54.021 align:middle line:90%,end
<c.magenta>给defaultItemIdentifiers附加新按钮</c>

00:05:54.688 --> 00:05:55.689 align:middle line:90%,end
<c.magenta>就是这样 对吗？</c>

00:05:56.623 --> 00:05:59.226 align:middle line:90%,end
<c.magenta>不 请不要这样做</c>

00:05:59.660 --> 00:06:01.195 align:middle line:90%,end
<c.magenta>你一定会获得一种很糟糕的体验</c>

00:05:59.660 --> 00:06:01.195 align:middle line:90%,end
<c.magenta>你一定会获得一种很糟糕的体验</c>

00:06:01.929 --> 00:06:03.864 align:middle line:90%,end
<c.magenta>为什么？因为文本视图</c>

00:06:04.464 --> 00:06:08.235 align:middle line:90%,end
<c.magenta>需要能基于当前配置</c>
<c.magenta>重设其触控条的触控项</c>

00:06:09.803 --> 00:06:11.238 align:middle line:90%,end
<c.magenta>你将会得到这样的东西</c>

00:06:11.705 --> 00:06:13.574 align:middle line:90%,end
<c.magenta>你会得到一个这样的触控条</c>

00:06:13.640 --> 00:06:16.410 align:middle line:90%,end
<c.magenta>当你添加新按钮之后</c>
<c.magenta>看起来跟你预期的一样</c>

00:06:17.077 --> 00:06:20.447 align:middle line:90%,end
<c.magenta>但如果用户在你的应用运行时</c>
<c.magenta>禁用富文本</c>

00:06:21.248 --> 00:06:22.850 align:middle line:90%,end
<c.magenta>那么文本视图将收到通知</c>

00:06:22.916 --> 00:06:25.052 align:middle line:90%,end
<c.magenta>说需要重设其触控项</c>

00:06:25.619 --> 00:06:28.121 align:middle line:90%,end
<c.magenta>那么它会通过移除现有触控项来实现</c>

00:06:28.355 --> 00:06:31.525 align:middle line:90%,end
<c.magenta>并基于当前配置</c>
<c.magenta>重新创建所需要的触控项</c>

00:06:32.893 --> 00:06:34.962 align:middle line:90%,end
<c.magenta>但是请记住</c>
<c.magenta>TextView是它自己的</c>

00:06:35.362 --> 00:06:36.864 align:middle line:90%,end
<c.magenta>NSTouchBar实例委托</c>

00:06:37.064 --> 00:06:38.432 align:middle line:90%,end
<c.magenta>所以它会重新创建这些触控项</c>

00:06:38.498 --> 00:06:41.401 align:middle line:90%,end
<c.magenta>通过调用它自己的</c>
<c.magenta>makeItemForIdentifier实施</c>

00:06:42.102 --> 00:06:43.937 align:middle line:90%,end
<c.magenta>因此它会重新创建QuickType项</c>

00:06:46.139 --> 00:06:47.474 align:middle line:90%,end
<c.magenta>它会重新创建表情选择器</c>

00:06:50.010 --> 00:06:53.080 align:middle line:90%,end
<c.magenta>但它并不知道如何</c>
<c.magenta>重新创建你的自定义触控项</c>

00:06:53.747 --> 00:06:55.516 align:middle line:90%,end
<c.magenta>所以它就不会</c>
<c.magenta>重新创建你的自定义项</c>

00:06:56.683 --> 00:06:57.751 align:middle line:90%,end
<c.magenta>为了避免这个问题</c>

00:06:57.818 --> 00:06:59.553 align:middle line:90%,end
<c.magenta>你需要一个能应对TextView的方法</c>

00:06:59.620 --> 00:07:01.288 align:middle line:90%,end
<c.magenta>有许多不同的实现方式</c>

00:06:59.620 --> 00:07:01.288 align:middle line:90%,end
<c.magenta>有许多不同的实现方式</c>

00:07:02.956 --> 00:07:05.526 align:middle line:90%,end
<c.magenta>第一种方式是</c>
<c.magenta>使用较高等级的响应器</c>

00:07:05.826 --> 00:07:06.994 align:middle line:90%,end
<c.magenta>来提供自定义触控项</c>

00:07:07.594 --> 00:07:08.896 align:middle line:90%,end
<c.magenta>这是一个好方法</c>

00:07:08.962 --> 00:07:11.698 align:middle line:90%,end
<c.magenta>当你的触控项出现在</c>
<c.magenta>一个以上的情境中时</c>

00:07:11.765 --> 00:07:13.400 align:middle line:90%,end
<c.magenta>（方法#1：</c>
<c.magenta>使用较高等级的响应器）</c>

00:07:13.800 --> 00:07:16.503 align:middle line:90%,end
<c.magenta>而我们之前讲的那个发送邮件的</c>
<c.magenta>触控条就是个很好的例子</c>

00:07:17.070 --> 00:07:18.705 align:middle line:90%,end
<c.magenta>那么在这里</c>
<c.magenta>我们有一个发送邮件按钮</c>

00:07:18.939 --> 00:07:22.009 align:middle line:90%,end
<c.magenta>最理想的是把这个按钮放在触控条中</c>

00:07:22.209 --> 00:07:23.744 align:middle line:90%,end
<c.magenta>当写邮件窗口打开时</c>

00:07:24.211 --> 00:07:26.713 align:middle line:90%,end
<c.magenta>那个窗口内的</c>
<c.magenta>哪个TextView或哪个TextField</c>

00:07:27.114 --> 00:07:28.815 align:middle line:90%,end
<c.magenta>是第一响应器并不重要</c>

00:07:28.882 --> 00:07:30.717 align:middle line:90%,end
<c.magenta>无论是哪个</c>
<c.magenta>我们只想显示这个按钮</c>

00:07:31.385 --> 00:07:34.821 align:middle line:90%,end
<c.magenta>那么这种情况下最好是</c>
<c.magenta>使用较高等级的响应器</c>

00:07:35.022 --> 00:07:36.990 align:middle line:90%,end
<c.magenta>比如ViewController来提供自定义项</c>

00:07:39.092 --> 00:07:40.260 align:middle line:90%,end
<c.magenta>这是你可能会得到的结果</c>

00:07:40.694 --> 00:07:42.129 align:middle line:90%,end
<c.magenta>在这里我们有ViewController</c>

00:07:43.597 --> 00:07:44.965 align:middle line:90%,end
<c.magenta>我们要覆盖makeTouchBar</c>

00:07:47.968 --> 00:07:51.538 align:middle line:90%,end
<c.magenta>我们要创建我们自己的自定义触控项</c>
<c.magenta>并将其视图设置为发送按钮</c>

00:07:54.141 --> 00:07:58.679 align:middle line:90%,end
<c.magenta>然后我们要创建我们的触控条</c>
<c.magenta>我们用自定义触控项进行配置</c>

00:07:58.946 --> 00:07:59.947 align:middle line:90%,end
<c.magenta>然后我们就返回它</c>

00:08:01.348 --> 00:08:03.417 align:middle line:90%,end
<c.magenta>现在请注意这里使用的</c>
<c.magenta>otherItemsProxy</c>

00:08:03.717 --> 00:08:05.953 align:middle line:90%,end
<c.magenta>这将会嵌套字段编辑器中的触控项</c>

00:08:06.019 --> 00:08:08.121 align:middle line:90%,end
<c.magenta>从而使它们出现在</c>
<c.magenta>我们自定义触控项的旁边</c>

00:08:09.556 --> 00:08:12.426 align:middle line:90%,end
<c.magenta>这就是如何使用较高等级响应器</c>

00:08:12.626 --> 00:08:15.062 align:middle line:90%,end
<c.magenta>在标准触控项基础上</c>
<c.magenta>提供自定义触控项的基础示例</c>

00:08:16.830 --> 00:08:19.533 align:middle line:90%,end
<c.magenta>现在让我们看第二种方式</c>
<c.magenta>子类化NSTextView</c>

00:08:20.200 --> 00:08:22.970 align:middle line:90%,end
<c.magenta>这是一个好方法 如果你有一个触控项</c>

00:08:23.036 --> 00:08:25.839 align:middle line:90%,end
<c.magenta>你想让它出现在触控条中</c>

00:08:26.173 --> 00:08:28.141 align:middle line:90%,end
<c.magenta>而当你的TextView</c>
<c.magenta>是第一响应器时</c>

00:08:28.509 --> 00:08:29.443 align:middle line:90%,end
<c.magenta>（子类化NSTextView）</c>

00:08:30.010 --> 00:08:32.913 align:middle line:90%,end
<c.magenta>要知道我是什么意思</c>
<c.magenta>让我们看看之前的一个例子</c>

00:08:33.246 --> 00:08:34.515 align:middle line:90%,end
<c.magenta>这里我们有一个全选按钮</c>

00:08:34.581 --> 00:08:36.549 align:middle line:90%,end
<c.magenta>可以选中TextView中的</c>
<c.magenta>全部文本</c>

00:08:37.451 --> 00:08:39.886 align:middle line:90%,end
<c.magenta>那么在本例中</c>
<c.magenta>我们只想当TextView</c>

00:08:40.153 --> 00:08:41.488 align:middle line:90%,end
<c.magenta>是第一响应器时显示这个按钮</c>

00:08:41.554 --> 00:08:43.924 align:middle line:90%,end
<c.magenta>因为全选按钮在那儿</c>
<c.magenta>实际上不会有太大的意义</c>

00:08:43.991 --> 00:08:46.927 align:middle line:90%,end
<c.magenta>如果没有人编辑任何文本</c>

00:08:48.262 --> 00:08:51.598 align:middle line:90%,end
<c.magenta>因此 这种情况</c>
<c.magenta>最好使用子类化NSTextView</c>

00:08:51.865 --> 00:08:54.301 align:middle line:90%,end
<c.magenta>将按钮放在与标准触控项相同的</c>

00:08:54.368 --> 00:08:55.569 align:middle line:90%,end
<c.magenta>同一个NSTouchBar实例中</c>

00:08:58.038 --> 00:08:59.606 align:middle line:90%,end
<c.magenta>并且要覆盖</c>

00:08:59.673 --> 00:09:00.974 align:middle line:90%,end
<c.magenta>TextView子类中的两个方法</c>

00:08:59.673 --> 00:09:00.974 align:middle line:90%,end
<c.magenta>TextView子类中的两个方法</c>

00:09:01.775 --> 00:09:04.278 align:middle line:90%,end
<c.magenta>一个是updateTouchBar</c>
<c.magenta>ItemIdentifiers</c>

00:09:04.678 --> 00:09:06.046 align:middle line:90%,end
<c.magenta>你要覆盖这个方法</c>

00:09:06.280 --> 00:09:09.616 align:middle line:90%,end
<c.magenta>是因为每次当TextView的触控条的状态</c>
<c.magenta>需要变更时都会调用这个方法</c>

00:09:10.384 --> 00:09:13.387 align:middle line:90%,end
<c.magenta>并且这个方法是你实际</c>
<c.magenta>要添加文本条的方法</c>

00:09:13.453 --> 00:09:14.788 align:middle line:90%,end
<c.magenta>来显示你的自定义项</c>

00:09:16.156 --> 00:09:17.925 align:middle line:90%,end
<c.magenta>添加到defaultItemIdentifiers数组</c>

00:09:18.692 --> 00:09:20.460 align:middle line:90%,end
<c.magenta>第二个要覆盖的方法</c>

00:09:20.527 --> 00:09:23.130 align:middle line:90%,end
<c.magenta>是委托方法makeItemForIdentifier</c>

00:09:23.630 --> 00:09:26.366 align:middle line:90%,end
<c.magenta>你要覆盖这个方法</c>
<c.magenta>是因为这是TextView用来</c>

00:09:26.433 --> 00:09:28.268 align:middle line:90%,end
<c.magenta>创建其触控项的方法</c>

00:09:28.869 --> 00:09:32.372 align:middle line:90%,end
<c.magenta>并且这个方法是你创建</c>
<c.magenta>和配置你自定义触控项的方法</c>

00:09:34.007 --> 00:09:36.376 align:middle line:90%,end
<c.magenta>现在有了这两个方法你就可以确保</c>

00:09:36.677 --> 00:09:38.712 align:middle line:90%,end
<c.magenta>调用超类实施</c>

00:09:38.779 --> 00:09:41.348 align:middle line:90%,end
<c.magenta>在做与自定义触控项相关的工作之前</c>

00:09:41.748 --> 00:09:44.651 align:middle line:90%,end
<c.magenta>通过这种方式</c>
<c.magenta>你可以确保你的自定义触控项</c>

00:09:44.718 --> 00:09:47.020 align:middle line:90%,end
<c.magenta>将与标准触控项一起被重新创建</c>

00:09:47.521 --> 00:09:49.323 align:middle line:90%,end
<c.magenta>无论何时TextView</c>
<c.magenta>需要重设其触控条时</c>

00:09:52.426 --> 00:09:54.728 align:middle line:90%,end
<c.magenta>并且那也包含了</c>
<c.magenta>添加自定义触控项的两个方式</c>

00:09:55.095 --> 00:09:57.231 align:middle line:90%,end
<c.magenta>让我们转过来看一下</c>
<c.magenta>补充列表触控项</c>

00:09:58.832 --> 00:10:00.901 align:middle line:90%,end
<c.magenta>补充列表触控项是一个极好的控件</c>

00:09:58.832 --> 00:10:00.901 align:middle line:90%,end
<c.magenta>补充列表触控项是一个极好的控件</c>

00:10:01.168 --> 00:10:04.171 align:middle line:90%,end
<c.magenta>为你的用户</c>
<c.magenta>提供一个可选择的情境列表</c>

00:10:04.238 --> 00:10:05.472 align:middle line:90%,end
<c.magenta>（补充列表触控项）</c>

00:10:05.539 --> 00:10:07.841 align:middle line:90%,end
<c.magenta>我们把这些推荐作为补充</c>

00:10:10.410 --> 00:10:13.280 align:middle line:90%,end
<c.magenta>这个触控项也是</c>
<c.magenta>与NSTextView紧密整合在一起的</c>

00:10:13.814 --> 00:10:16.917 align:middle line:90%,end
<c.magenta>因此在触控条中 每个TextView</c>
<c.magenta>都有一个对补充列表触控项的引用</c>

00:10:17.017 --> 00:10:19.953 align:middle line:90%,end
<c.magenta>可以通过candidateListTouchBarItem</c>
<c.magenta>属性进行访问</c>

00:10:20.954 --> 00:10:22.856 align:middle line:90%,end
<c.magenta>请记住你看到的</c>

00:10:22.923 --> 00:10:24.091 align:middle line:90%,end
<c.magenta>带有TextField的补充列表</c>

00:10:24.157 --> 00:10:27.127 align:middle line:90%,end
<c.magenta>实际上是在触控条中与窗口的</c>
<c.magenta>字段编辑器关联在一起</c>

00:10:28.695 --> 00:10:29.696 align:middle line:90%,end
<c.magenta>（补充来源）</c>

00:10:29.763 --> 00:10:32.432 align:middle line:90%,end
<c.magenta>补充数据通常有这三种来源</c>

00:10:33.333 --> 00:10:35.402 align:middle line:90%,end
<c.magenta>在QuickType例子中 补充数据</c>

00:10:35.469 --> 00:10:36.970 align:middle line:90%,end
<c.magenta>是由NSSpellChecker提供的</c>

00:10:37.871 --> 00:10:40.874 align:middle line:90%,end
<c.magenta>但你可以配置控件</c>
<c.magenta>显示其它来源的补充数据</c>

00:10:41.441 --> 00:10:42.609 align:middle line:90%,end
<c.magenta>比如系统输入方法</c>

00:10:42.943 --> 00:10:46.413 align:middle line:90%,end
<c.magenta>允许你键入中文、日语</c>
<c.magenta>韩语或印度语</c>

00:10:46.480 --> 00:10:47.681 align:middle line:90%,end
<c.magenta>通过一个拉丁语系键盘</c>

00:10:48.549 --> 00:10:50.284 align:middle line:90%,end
<c.magenta>但你们绝大部分人可能感兴趣的是</c>

00:10:50.350 --> 00:10:53.086 align:middle line:90%,end
<c.magenta>可以提供你自己的完全自定义补充列表</c>

00:10:53.453 --> 00:10:55.956 align:middle line:90%,end
<c.magenta>要实现这个目标有两种不同的方式</c>

00:10:58.091 --> 00:10:59.826 align:middle line:90%,end
<c.magenta>第一种方式是使用委托方法</c>

00:11:00.561 --> 00:11:01.929 align:middle line:90%,end
<c.magenta>这个方法的好处</c>

00:11:01.995 --> 00:11:04.464 align:middle line:90%,end
<c.magenta>是它是最简单的 因为TextField</c>
<c.magenta>会为你承担绝大部分工作</c>

00:11:06.834 --> 00:11:09.636 align:middle line:90%,end
<c.magenta>那么要使用这种方式</c>
<c.magenta>你需要实施一个委托方法</c>

00:11:09.803 --> 00:11:13.006 align:middle line:90%,end
<c.magenta>candidatesForSelectedRange</c>
<c.magenta>在你的TextField或TextView中</c>

00:11:13.674 --> 00:11:17.444 align:middle line:90%,end
<c.magenta>并且你会获得原始文本控件</c>
<c.magenta>字段编辑器（如果适用的话）</c>

00:11:18.045 --> 00:11:19.479 align:middle line:90%,end
<c.magenta>以及文本范围</c>

00:11:19.680 --> 00:11:21.682 align:middle line:90%,end
<c.magenta>你可以用来决定你的补充列表</c>

00:11:22.216 --> 00:11:24.885 align:middle line:90%,end
<c.magenta>那么你可以简单地返回一个</c>
<c.magenta>包含你自定义补充的数组</c>

00:11:24.952 --> 00:11:26.987 align:middle line:90%,end
<c.magenta>就会在标准的补充列表中</c>
<c.magenta>显示你的自定义补充</c>

00:11:27.654 --> 00:11:29.690 align:middle line:90%,end
<c.magenta>现在因为这种方式使用了标准列表</c>

00:11:30.290 --> 00:11:32.926 align:middle line:90%,end
<c.magenta>因此你不需要做什么操作</c>
<c.magenta>TextView会帮你做剩余的工作</c>

00:11:35.362 --> 00:11:36.296 align:middle line:90%,end
<c.magenta>第二种方式</c>

00:11:36.363 --> 00:11:37.664 align:middle line:90%,end
<c.magenta>是使用较高等级的响应器</c>

00:11:38.632 --> 00:11:41.668 align:middle line:90%,end
<c.magenta>这种方式的好处是</c>
<c.magenta>允许你使用模型对象</c>

00:11:41.735 --> 00:11:43.437 align:middle line:90%,end
<c.magenta>而不是字符串</c>

00:11:45.372 --> 00:11:47.474 align:middle line:10%
<c.magenta>那么这个类似于较高等级响应器方式</c>

00:11:47.541 --> 00:11:50.544 align:middle line:10%
<c.magenta>我们稍早些时候在向触控条中</c>
<c.magenta>添加自定义触控项时讲到过</c>

00:11:50.911 --> 00:11:53.280 align:middle line:10%
<c.magenta>在这里你需要使用一个</c>
<c.magenta>视图控制器或其它对象</c>

00:11:53.514 --> 00:11:57.017 align:middle line:10%
<c.magenta>来创建你自己的</c>
<c.magenta>NSCandidateListTouchBarItem实例</c>

00:11:57.084 --> 00:11:58.986 align:middle line:10%
<c.magenta>并用那个取代标准触控项</c>

00:11:59.052 --> 00:12:00.387 align:middle line:10%
<c.magenta>（使用较高等级响应器）</c>

00:11:59.052 --> 00:12:00.387 align:middle line:10%
<c.magenta>（使用较高等级响应器）</c>

00:12:00.454 --> 00:12:03.023 align:middle line:10%
<c.magenta>现在这个方式比委托方法那个</c>
<c.magenta>要复杂一些</c>

00:12:03.090 --> 00:12:04.758 align:middle line:10%
<c.magenta>但这个方式是非常有帮助的</c>

00:12:04.825 --> 00:12:08.495 align:middle line:10%
<c.magenta>若你想在补充中使用</c>
<c.magenta>模型对象而不是字符串</c>

00:12:09.730 --> 00:12:12.099 align:middle line:90%,end
<c.magenta>我们稍后再详细谈这个方式</c>

00:12:13.700 --> 00:12:16.069 align:middle line:90%,end
<c.magenta>现在让我们看一个简单版本</c>

00:12:16.136 --> 00:12:17.437 align:middle line:90%,end
<c.magenta>实施邮件自动完成触控项</c>

00:12:17.704 --> 00:12:19.640 align:middle line:90%,end
<c.magenta>自这场演讲一开始</c>
<c.magenta>我们就拿这个调侃你们</c>

00:12:20.707 --> 00:12:22.509 align:middle line:90%,end
<c.magenta>我们要使用委托方式</c>

00:12:22.576 --> 00:12:23.844 align:middle line:90%,end
<c.magenta>（示例：邮件自动完成）</c>

00:12:25.045 --> 00:12:26.346 align:middle line:90%,end
<c.magenta>但我们在这里有一点问题</c>

00:12:26.713 --> 00:12:30.017 align:middle line:90%,end
<c.magenta>现在 因为我们的文本字段</c>
<c.magenta>是为邮箱地址准备的</c>

00:12:30.083 --> 00:12:31.385 align:middle line:90%,end
<c.magenta>在这里添加表情或富文本</c>

00:12:31.451 --> 00:12:33.854 align:middle line:90%,end
<c.magenta>真的意义不大</c>

00:12:34.855 --> 00:12:36.623 align:middle line:90%,end
<c.magenta>但如果我们关闭触控条上的那些属性</c>

00:12:36.690 --> 00:12:39.259 align:middle line:90%,end
<c.magenta>请看当我们把补充列表</c>
<c.magenta>折叠起来时会发生什么</c>

00:12:39.793 --> 00:12:42.329 align:middle line:90%,end
<c.magenta>你可能会得到这么一个</c>
<c.magenta>诡异的空触控条</c>

00:12:42.763 --> 00:12:45.566 align:middle line:90%,end
<c.magenta>看起来一点都不好</c>
<c.magenta>所以我们不想发生这样的情况</c>

00:12:47.000 --> 00:12:49.203 align:middle line:90%,end
<c.magenta>我们要阻止这种情况的发生</c>

00:12:49.937 --> 00:12:52.172 align:middle line:90%,end
<c.magenta>通过关闭折叠功能</c>

00:12:52.239 --> 00:12:54.842 align:middle line:90%,end
<c.magenta>使用allowsCollapsing属性</c>

00:12:55.776 --> 00:12:56.910 align:middle line:90%,end
<c.magenta>当我们设置这个属性时</c>

00:12:57.611 --> 00:12:59.346 align:middle line:90%,end
<c.magenta>左边的那个小尖括号就不见了</c>

00:12:59.646 --> 00:13:01.949 align:middle line:90%,end
<c.magenta>然后你就再也不能折叠列表了</c>

00:12:59.646 --> 00:13:01.949 align:middle line:90%,end
<c.magenta>然后你就再也不能折叠列表了</c>

00:13:03.617 --> 00:13:04.585 align:middle line:90%,end
<c.magenta>（不可折叠！）</c>

00:13:05.886 --> 00:13:07.321 align:middle line:90%,end
<c.magenta>但现在我们面临着另一个问题</c>

00:13:09.089 --> 00:13:12.759 align:middle line:90%,end
<c.magenta>我们在字段编辑器的补充列表项中</c>

00:13:13.727 --> 00:13:14.728 align:middle line:90%,end
<c.magenta>设置了那个属性</c>

00:13:15.262 --> 00:13:18.098 align:middle line:90%,end
<c.magenta>并且字段编辑器是与窗口中的全部</c>
<c.magenta>文本字段共享的</c>

00:13:18.565 --> 00:13:21.134 align:middle line:90%,end
<c.magenta>如果我们设置allowsCollapsing属性</c>

00:13:21.468 --> 00:13:23.337 align:middle line:90%,end
<c.magenta>在这个字段编辑器的补充列表中</c>

00:13:23.637 --> 00:13:25.572 align:middle line:90%,end
<c.magenta>它会影响全部这些文本字段</c>

00:13:25.639 --> 00:13:26.840 align:middle line:90%,end
<c.magenta>这并不是我们想看到的结果</c>

00:13:27.941 --> 00:13:30.978 align:middle line:90%,end
<c.magenta>我们要解决这个问题</c>
<c.magenta>通过为我们的邮件</c>

00:13:31.378 --> 00:13:34.882 align:middle line:90%,end
<c.magenta>TextField提供我们自己的字段编辑器</c>
<c.magenta>那样的话 当我们修改其属性时</c>

00:13:35.215 --> 00:13:36.650 align:middle line:90%,end
<c.magenta>它就不会影响共享编辑器</c>

00:13:38.352 --> 00:13:40.220 align:middle line:90%,end
<c.magenta>那么要创建自定义字段编辑器</c>

00:13:40.287 --> 00:13:42.422 align:middle line:90%,end
<c.magenta>我们要子类化NSTextFieldCell</c>

00:13:44.324 --> 00:13:47.394 align:middle line:90%,end
<c.magenta>在我们的子类中</c>
<c.magenta>我们要用controlView覆盖fieldEditor</c>

00:13:50.130 --> 00:13:52.366 align:middle line:90%,end
<c.magenta>然后我们要创建一个</c>
<c.magenta>fieldEditor并将其返回</c>

00:13:52.833 --> 00:13:55.669 align:middle line:90%,end
<c.magenta>就是这样 完成了</c>
<c.magenta>我们不需要添加任何自定义行为</c>

00:13:55.736 --> 00:13:58.505 align:middle line:90%,end
<c.magenta>我们只是提供了自己的</c>
<c.magenta>stock NSTextView的实例</c>

00:13:59.306 --> 00:14:00.574 align:middle line:90%,end
<c.magenta>用作字段编辑器</c>

00:13:59.306 --> 00:14:00.574 align:middle line:90%,end
<c.magenta>用作字段编辑器</c>

00:14:00.641 --> 00:14:03.210 align:middle line:90%,end
<c.magenta>无论何时当某人想要编辑</c>
<c.magenta>我们的文本字段的内容时</c>

00:14:04.077 --> 00:14:07.381 align:middle line:90%,end
<c.magenta>请不要忘记设置你的TextField</c>
<c.magenta>使其使用你的新子类</c>

00:14:07.447 --> 00:14:09.683 align:middle line:90%,end
<c.magenta>可以通过界面创建器或编程实现</c>

00:14:11.451 --> 00:14:14.054 align:middle line:90%,end
<c.magenta>那么现在 我们可以实施</c>
<c.magenta>我们的textField委托方法了</c>

00:14:14.121 --> 00:14:16.957 align:middle line:90%,end
<c.magenta>在这里 我们关闭了</c>
<c.magenta>字段编辑器的折叠行为</c>

00:14:17.024 --> 00:14:18.892 align:middle line:90%,end
<c.magenta>并返回到我们的自定义补充数组</c>

00:14:19.259 --> 00:14:21.628 align:middle line:90%,end
<c.magenta>这是邮件自动完成的一个简单的实施</c>

00:14:21.695 --> 00:14:22.963 align:middle line:90%,end
<c.magenta>通过补充列表项</c>

00:14:25.299 --> 00:14:27.434 align:middle line:90%,end
<c.magenta>刚才我们提到了一个</c>
<c.magenta>更加复杂的方法</c>

00:14:27.501 --> 00:14:28.969 align:middle line:90%,end
<c.magenta>用于返回自定义补充</c>

00:14:29.036 --> 00:14:32.105 align:middle line:90%,end
<c.magenta>通过提供你自己的拥有较高等级</c>
<c.magenta>响应器的补充列表触控项</c>

00:14:32.706 --> 00:14:35.342 align:middle line:90%,end
<c.magenta>如果你需要获得补充列表触控项的</c>
<c.magenta>良好的粒度控制</c>

00:14:35.409 --> 00:14:36.443 align:middle line:90%,end
<c.magenta>你可以采用这种方式</c>

00:14:36.510 --> 00:14:39.213 align:middle line:90%,end
<c.magenta>如果你想采用这种方式</c>
<c.magenta>你需要这样做</c>

00:14:41.448 --> 00:14:44.318 align:middle line:90%,end
<c.magenta>首先你要禁用文本字段</c>
<c.magenta>或视图的QuickType</c>

00:14:44.885 --> 00:14:47.020 align:middle line:90%,end
<c.magenta>因为你要提供你自己的补充列表</c>

00:14:47.087 --> 00:14:48.622 align:middle line:90%,end
<c.magenta>就不再需要标准的补充列表了</c>

00:14:51.692 --> 00:14:54.995 align:middle line:90%,end
<c.magenta>第二 要实施NSTouchBar委托方法</c>

00:14:55.062 --> 00:14:56.430 align:middle line:90%,end
<c.magenta>makeItemForIdentifier</c>

00:14:56.997 --> 00:15:00.534 align:middle line:90%,end
<c.magenta>这个方法是你要创建</c>
<c.magenta>自定义补充列表触控项的方法</c>

00:14:56.997 --> 00:15:00.534 align:middle line:90%,end
<c.magenta>这个方法是你要创建</c>
<c.magenta>自定义补充列表触控项的方法</c>

00:15:01.702 --> 00:15:04.037 align:middle line:90%,end
<c.magenta>如果你将模型对象用作补充</c>

00:15:04.104 --> 00:15:06.406 align:middle line:90%,end
<c.magenta>这个方法还是你要把模型对象映射到</c>

00:15:06.473 --> 00:15:09.710 align:middle line:90%,end
<c.magenta>能在补充列表触控项中显示的</c>
<c.magenta>字符串表示中的方法</c>

00:15:10.878 --> 00:15:13.680 align:middle line:90%,end
<c.magenta>那么 要实现这个目的</c>
<c.magenta>你需要使用这个block属性</c>

00:15:13.847 --> 00:15:15.315 align:middle line:90%,end
<c.magenta>attributedStringForCandidate</c>

00:15:19.353 --> 00:15:22.055 align:middle line:90%,end
<c.magenta>第三 如果你使用要在委托方法</c>

00:15:24.258 --> 00:15:29.162 align:middle line:90%,end
<c.magenta>endSelectingCandidateAt索引中</c>

00:15:29.229 --> 00:15:30.964 align:middle line:90%,end
<c.magenta>实施的模型对象补充</c>

00:15:31.031 --> 00:15:34.701 align:middle line:90%,end
<c.magenta>这就是你要提供其它方向映射的方式</c>

00:15:35.035 --> 00:15:38.205 align:middle line:90%,end
<c.magenta>从用户的补充选择</c>
<c.magenta>到你模型对象的实例</c>

00:15:40.674 --> 00:15:43.911 align:middle line:90%,end
<c.magenta>最后你要更新补充</c>

00:15:43.977 --> 00:15:47.214 align:middle line:90%,end
<c.magenta>当某人向你的文本字段</c>
<c.magenta>或视图中键入文本时</c>

00:15:47.614 --> 00:15:50.150 align:middle line:90%,end
<c.magenta>实现方法是覆盖controlTextDidChange</c>

00:15:50.551 --> 00:15:53.587 align:middle line:90%,end
<c.magenta>然后给所选范围和字符串</c>
<c.magenta>调用setCandidates</c>

00:15:53.654 --> 00:15:55.923 align:middle line:90%,end
<c.magenta>在你的自定义补充列表触控项中</c>

00:15:58.158 --> 00:16:00.127 align:middle line:90%,end
<c.magenta>这也包含了自定义文本栏</c>

00:15:58.158 --> 00:16:00.127 align:middle line:90%,end
<c.magenta>这也包含了自定义文本栏</c>

00:16:00.594 --> 00:16:03.997 align:middle line:90%,end
<c.magenta>那么让我们回顾一下</c>
<c.magenta>我们提到了两种在文本栏中</c>

00:16:04.064 --> 00:16:07.100 align:middle line:90%,end
<c.magenta>添加自定义触控项的方式</c>
<c.magenta>和两种在补充条中</c>

00:16:07.167 --> 00:16:08.202 align:middle line:90%,end
<c.magenta>提供自定义补充的方式</c>

00:16:08.368 --> 00:16:11.138 align:middle line:90%,end
<c.magenta>我鼓励你们大家尝试自定义文本栏</c>

00:16:11.205 --> 00:16:13.173 align:middle line:90%,end
<c.magenta>通过我们今天推荐给大家的方式</c>

00:16:15.008 --> 00:16:18.011 align:middle line:90%,end
<c.magenta>接下来我要邀请杰夫·纳多上台</c>
<c.magenta>谈谈NSScrubber</c>

00:16:18.078 --> 00:16:20.347 align:middle line:90%,end
<c.magenta>一个专门为NS触控条创建的控件</c>

00:16:20.414 --> 00:16:21.248 align:middle line:90%,end
<c.magenta>杰夫？</c>

00:16:25.118 --> 00:16:26.220 align:middle line:90%,end
<c.magenta>好的 谢谢</c>

00:16:26.653 --> 00:16:29.323 align:middle line:90%,end
<c.magenta>那么正如唐娜刚才所说的</c>
<c.magenta>NSScrubber是我们第一个Cocoa控件</c>

00:16:29.389 --> 00:16:32.993 align:middle line:90%,end
<c.magenta>是我们专为触控条环境设计的</c>

00:16:33.660 --> 00:16:37.164 align:middle line:90%,end
<c.magenta>这个控件的中心主题是</c>
<c.magenta>获取你应用的内容</c>

00:16:37.231 --> 00:16:40.400 align:middle line:90%,end
<c.magenta>并便利地将其送到你的指尖下</c>

00:16:40.834 --> 00:16:41.869 align:middle line:90%,end
<c.magenta>（NSScrubber）</c>

00:16:41.935 --> 00:16:45.372 align:middle line:90%,end
<c.magenta>现在给大家看一些例子 现在展示的</c>
<c.magenta>是一个不错的日历时间轴</c>

00:16:45.439 --> 00:16:48.075 align:middle line:90%,end
<c.magenta>作为NSScrubber的一个例子</c>
<c.magenta>但事实 我们在整个操作系统的</c>

00:16:48.141 --> 00:16:49.343 align:middle line:90%,end
<c.magenta>许多地方都要用到它</c>

00:16:49.776 --> 00:16:52.813 align:middle line:90%,end
<c.magenta>还有两个分别是</c>
<c.magenta>Safari的标签选择器</c>

00:16:53.514 --> 00:16:58.452 align:middle line:90%,end
<c.magenta>以及Keynote的滑动导航器</c>
<c.magenta>当你在Keynote中做演示时会出现</c>

00:16:58.519 --> 00:16:59.520 align:middle line:90%,end
<c.magenta>（触控条的通用控件）</c>

00:16:59.586 --> 00:17:01.622 align:middle line:90%,end
<c.magenta>把这些摆在一起 你就可以说</c>

00:16:59.586 --> 00:17:01.622 align:middle line:90%,end
<c.magenta>把这些摆在一起 你就可以说</c>

00:17:01.688 --> 00:17:03.323 align:middle line:90%,end
<c.magenta>这个控件是非常通用的</c>

00:17:03.390 --> 00:17:07.594 align:middle line:90%,end
<c.magenta>可以表达多种视觉和交互设计</c>

00:17:07.661 --> 00:17:09.730 align:middle line:90%,end
<c.magenta>（Keynote幻灯片）</c>

00:17:09.796 --> 00:17:12.733 align:middle line:90%,end
<c.magenta>但在我们深入讲解任意API之前</c>
<c.magenta>我们应该</c>

00:17:12.799 --> 00:17:14.768 align:middle line:90%,end
<c.magenta>回答这个问题：什么是NSScrubber？</c>

00:17:15.002 --> 00:17:16.336 align:middle line:90%,end
<c.magenta>它是一个类似于集合的控件</c>

00:17:16.970 --> 00:17:19.640 align:middle line:90%,end
<c.magenta>作用是安排你应用的内容列表</c>

00:17:19.705 --> 00:17:22.576 align:middle line:90%,end
<c.magenta>然后提供基于触摸手势的</c>
<c.magenta>内容高亮和内容选择</c>

00:17:22.643 --> 00:17:25.412 align:middle line:90%,end
<c.magenta>通过轻触和拖拽手势</c>

00:17:26.413 --> 00:17:30.517 align:middle line:90%,end
<c.magenta>如果你之前用过NSCollectionView</c>
<c.magenta>那么你肯定会感觉熟悉这个API</c>

00:17:30.584 --> 00:17:34.588 align:middle line:90%,end
<c.magenta>然而它却进行了改进和调整</c>
<c.magenta>针对独特的触控条环境</c>

00:17:37.224 --> 00:17:41.028 align:middle line:90%,end
<c.magenta>与NSCollectionView一样</c>
<c.magenta>NSScrubber有一个组合式界面</c>

00:17:41.094 --> 00:17:44.765 align:middle line:90%,end
<c.magenta>意思是它将其许多功能</c>
<c.magenta>都委托给了其它对象</c>

00:17:44.998 --> 00:17:47.868 align:middle line:90%,end
<c.magenta>最好的理解方式就是实际分解控件</c>

00:17:47.935 --> 00:17:49.937 align:middle line:90%,end
<c.magenta>并挨个查看每一个部分</c>

00:17:51.171 --> 00:17:54.675 align:middle line:90%,end
<c.magenta>首先 我们有控件视图自身</c>
<c.magenta>NSScrubber</c>

00:17:54.741 --> 00:17:57.010 align:middle line:90%,end
<c.magenta>它通过控件管理全部的用户交互</c>

00:17:57.344 --> 00:17:59.847 align:middle line:90%,end
<c.magenta>它还提供一些很棒的外观属性</c>

00:17:59.913 --> 00:18:02.449 align:middle line:90%,end
<c.magenta>比如背景和其它类似的东西</c>

00:17:59.913 --> 00:18:02.449 align:middle line:90%,end
<c.magenta>比如背景和其它类似的东西</c>

00:18:03.884 --> 00:18:06.453 align:middle line:90%,end
<c.magenta>接下来我们还有选择框</c>

00:18:06.520 --> 00:18:08.755 align:middle line:90%,end
<c.magenta>这些是视图 用于表明</c>

00:18:08.822 --> 00:18:11.391 align:middle line:90%,end
<c.magenta>已选择了一些内容</c>

00:18:12.960 --> 00:18:15.963 align:middle line:90%,end
<c.magenta>我们有一个专用的布局对象</c>
<c.magenta>抽象地定义</c>

00:18:16.029 --> 00:18:18.398 align:middle line:90%,end
<c.magenta>如何安排控制器的内容</c>

00:18:19.132 --> 00:18:20.968 align:middle line:90%,end
<c.magenta>然后当然了 我们就获取了你的内容</c>

00:18:21.034 --> 00:18:23.170 align:middle line:90%,end
<c.magenta>是通过数据源模型提供的</c>

00:18:25.305 --> 00:18:27.374 align:middle line:90%,end
<c.magenta>现在我们要逐个查看每一个部分</c>

00:18:27.875 --> 00:18:31.345 align:middle line:90%,end
<c.magenta>然而我们应该先看一下我们可以在</c>
<c.magenta>控件视图自身中可以进行哪些配置</c>

00:18:32.746 --> 00:18:35.115 align:middle line:90%,end
<c.magenta>第一点也是最重要的一点</c>
<c.magenta>就是交互模式</c>

00:18:35.182 --> 00:18:38.352 align:middle line:90%,end
<c.magenta>是通过模式属性控制的</c>

00:18:38.752 --> 00:18:41.221 align:middle line:90%,end
<c.magenta>NSScrubber</c>
<c.magenta>有两种主要交互模式</c>

00:18:41.788 --> 00:18:43.357 align:middle line:90%,end
<c.magenta>第一个叫作“fixed”</c>

00:18:44.291 --> 00:18:47.794 align:middle line:90%,end
<c.magenta>提供基于触摸的选择</c>

00:18:47.861 --> 00:18:49.463 align:middle line:90%,end
<c.magenta>可以直接选择</c>

00:18:49.530 --> 00:18:51.431 align:middle line:90%,end
<c.magenta>并高亮你触摸的项</c>

00:18:52.165 --> 00:18:54.902 align:middle line:90%,end
<c.magenta>第二个叫作“free”</c>
<c.magenta>是一种像飞轮一样的东西</c>

00:18:54.968 --> 00:18:58.505 align:middle line:90%,end
<c.magenta>你可以自由滚动 就像其它</c>
<c.magenta>触摸驱动的滚动视图那样</c>

00:18:59.740 --> 00:19:03.911 align:middle line:90%,end
<c.magenta>选择两个模式中的一种之后</c>
<c.magenta>还有一个连续性属性</c>

00:18:59.740 --> 00:19:03.911 align:middle line:90%,end
<c.magenta>选择两个模式中的一种之后</c>
<c.magenta>还有一个连续性属性</c>

00:19:04.878 --> 00:19:07.347 align:middle line:90%,end
<c.magenta>这个名字很熟悉</c>
<c.magenta>来自其它的Cocoa控件</c>

00:19:07.414 --> 00:19:11.718 align:middle line:90%,end
<c.magenta>我们用这个名字表示一个</c>
<c.magenta>连续响应用户交互的控件</c>

00:19:11.785 --> 00:19:15.289 align:middle line:90%,end
<c.magenta>正在更新其值或发送其行动</c>

00:19:15.355 --> 00:19:17.858 align:middle line:90%,end
<c.magenta>（连续性选择）</c>

00:19:17.925 --> 00:19:21.395 align:middle line:90%,end
<c.magenta>现在如果连续性属性为假</c>
<c.magenta>在NSScrubber中</c>

00:19:21.828 --> 00:19:25.632 align:middle line:90%,end
<c.magenta>你可以看到轻触和拖拽</c>
<c.magenta>会高亮某一触控项</c>

00:19:25.699 --> 00:19:28.168 align:middle line:90%,end
<c.magenta>但会一直保持选择状态</c>
<c.magenta>直到我们完成手势</c>

00:19:28.235 --> 00:19:29.636 align:middle line:90%,end
<c.magenta>并提交新选择</c>

00:19:30.671 --> 00:19:34.374 align:middle line:90%,end
<c.magenta>但若我们将其设为真 我们可以看到</c>
<c.magenta>它的效果 比如在Safari中查看</c>

00:19:34.875 --> 00:19:38.245 align:middle line:90%,end
<c.magenta>我们在标签之间拖拽</c>
<c.magenta>随着你的触摸划过每一个触控项</c>

00:19:38.312 --> 00:19:40.214 align:middle line:90%,end
<c.magenta>该触控项就会立即被选中</c>

00:19:41.882 --> 00:19:43.684 align:middle line:90%,end
<c.magenta>还有自由式拖动器</c>

00:19:43.750 --> 00:19:46.086 align:middle line:90%,end
<c.magenta>比如我们刚才看到过的</c>
<c.magenta>Keynote滑动导航器</c>

00:19:46.420 --> 00:19:50.390 align:middle line:90%,end
<c.magenta>我们可以在这里滑动 看什么呢</c>
<c.magenta>你知道的 导航内容</c>

00:19:50.457 --> 00:19:52.559 align:middle line:90%,end
<c.magenta>然后我们可以轻触那个触控项选中它</c>

00:19:53.660 --> 00:19:58.165 align:middle line:90%,end
<c.magenta>但如果我们将连续性属性设为真</c>
<c.magenta>只有滚动动作</c>

00:19:58.398 --> 00:20:03.203 align:middle line:90%,end
<c.magenta>会在内容内部流动地</c>
<c.magenta>连续地更新选择</c>

00:19:58.398 --> 00:20:03.203 align:middle line:90%,end
<c.magenta>会在内容内部流动地</c>
<c.magenta>连续地更新选择</c>

00:20:04.104 --> 00:20:06.707 align:middle line:90%,end
<c.magenta>这就给了我们一个非常明显的区别</c>

00:20:06.773 --> 00:20:10.511 align:middle line:90%,end
<c.magenta>连续性属性为假</c>
<c.magenta>选择就是一件非常慎重的事</c>

00:20:10.577 --> 00:20:13.113 align:middle line:90%,end
<c.magenta>可能会很适合某种重量级动作</c>

00:20:13.313 --> 00:20:16.850 align:middle line:90%,end
<c.magenta>连续属性为真</c>
<c.magenta>导航和选择指示器内容</c>

00:20:16.917 --> 00:20:18.018 align:middle line:90%,end
<c.magenta>会很快、很流畅</c>

00:20:18.085 --> 00:20:20.854 align:middle line:90%,end
<c.magenta>可能适合高亮交互</c>

00:20:23.490 --> 00:20:26.460 align:middle line:90%,end
<c.magenta>一旦我们确定想要哪种</c>
<c.magenta>或想如何选择触控项</c>

00:20:26.793 --> 00:20:29.396 align:middle line:90%,end
<c.magenta>我们就需要决定</c>
<c.magenta>那种选择是什么样子的</c>

00:20:29.463 --> 00:20:31.899 align:middle line:90%,end
<c.magenta>这是由selectionBackgroundStyle</c>

00:20:31.965 --> 00:20:33.400 align:middle line:90%,end
<c.magenta>和OverlayStyle属性控制的</c>

00:20:34.201 --> 00:20:38.005 align:middle line:10%
<c.magenta>我们提供两种自带样式</c>
<c.magenta>我们有outlineOverlay样式</c>

00:20:38.071 --> 00:20:41.842 align:middle line:10%
<c.magenta>就是你曾在我们多个示例中</c>
<c.magenta>看到过的白色加粗框</c>

00:20:42.176 --> 00:20:44.211 align:middle line:10%
<c.magenta>然后我们还有一种</c>
<c.magenta>roundedBackground样式</c>

00:20:44.278 --> 00:20:46.046 align:middle line:10%
<c.magenta>作为文本触控项的背景看起来很不错</c>

00:20:47.548 --> 00:20:50.050 align:middle line:10%
<c.magenta>现在如果你善于观察</c>
<c.magenta>你可能会注意到</c>

00:20:50.117 --> 00:20:52.419 align:middle line:10%
<c.magenta>NSScrubber选择样式声明</c>

00:20:52.486 --> 00:20:55.088 align:middle line:10%
<c.magenta>并不是一个闭合的枚举</c>
<c.magenta>它其实不是一个类</c>

00:20:55.155 --> 00:20:58.759 align:middle line:10%
<c.magenta>所以你可以子类化这个并定义</c>
<c.magenta>你自己的选择样式 如果你喜欢的话</c>

00:21:01.061 --> 00:21:03.130 align:middle line:90%,end
<c.magenta>关于选择的另一个有趣的外观选项</c>

00:21:03.197 --> 00:21:05.232 align:middle line:90%,end
<c.magenta>就是这个floatSelectionViews属性</c>

00:21:05.299 --> 00:21:06.333 align:middle line:90%,end
<c.magenta>（浮动选择）</c>

00:21:06.400 --> 00:21:09.870 align:middle line:90%,end
<c.magenta>当它为假时 变更选择看起来</c>
<c.magenta>很符合你的预期</c>

00:21:09.937 --> 00:21:12.940 align:middle line:90%,end
<c.magenta>老旧的选择样式不见了</c>
<c.magenta>然后立即显示成了新的样式</c>

00:21:13.473 --> 00:21:15.042 align:middle line:90%,end
<c.magenta>但如果我们将其设为真</c>

00:21:15.108 --> 00:21:19.513 align:middle line:90%,end
<c.magenta>我们实际上会得到一个很棒</c>
<c.magenta>很流畅的浮动和滑动式选择</c>

00:21:19.580 --> 00:21:21.849 align:middle line:90%,end
<c.magenta>这是一种很酷的效果</c>

00:21:24.484 --> 00:21:27.487 align:middle line:90%,end
<c.magenta>在我们的例子中</c>
<c.magenta>你们可能还注意到了另一个花招：</c>

00:21:28.355 --> 00:21:31.525 align:middle line:90%,end
<c.magenta>有些控件 当你滚动、滑动或拖拽时</c>

00:21:31.592 --> 00:21:35.762 align:middle line:90%,end
<c.magenta>总是会很顺畅地滑动 因此有些触控项</c>
<c.magenta>总是能灵巧地着陆在同一个位置</c>

00:21:35.829 --> 00:21:36.964 align:middle line:90%,end
<c.magenta>在本例中是中心位置</c>

00:21:37.297 --> 00:21:39.733 align:middle line:90%,end
<c.magenta>这是通过itemAlignment属性控制的</c>

00:21:40.100 --> 00:21:42.503 align:middle line:90%,end
<c.magenta>现在默认值是无 意思是我们不会</c>

00:21:42.569 --> 00:21:44.304 align:middle line:90%,end
<c.magenta>对你的滚动做出任何调整</c>

00:21:44.371 --> 00:21:46.507 align:middle line:90%,end
<c.magenta>但如果你将其设为居首、居尾或居中</c>

00:21:46.707 --> 00:21:50.177 align:middle line:90%,end
<c.magenta>在滚动事件发生后</c>
<c.magenta>滑动、拖拽、惯性之类的</c>

00:21:50.577 --> 00:21:53.680 align:middle line:90%,end
<c.magenta>将总是会调整它</c>
<c.magenta>因此某些触控项是恰好对齐的</c>

00:21:53.747 --> 00:21:56.650 align:middle line:90%,end
<c.magenta>可以是居首、居尾或中心对齐</c>

00:21:58.452 --> 00:21:59.453 align:middle line:90%,end
<c.magenta>（外观）</c>

00:21:59.620 --> 00:22:02.389 align:middle line:90%,end
<c.magenta>最后 NSScrubber有一些</c>
<c.magenta>很不错的外观选项</c>

00:21:59.620 --> 00:22:02.389 align:middle line:90%,end
<c.magenta>最后 NSScrubber有一些</c>
<c.magenta>很不错的外观选项</c>

00:22:02.456 --> 00:22:05.626 align:middle line:90%,end
<c.magenta>适用于内容的背景区 包括背景颜色</c>

00:22:05.692 --> 00:22:08.228 align:middle line:90%,end
<c.magenta>或者如果你想拉动你喜欢的 你可以</c>

00:22:08.295 --> 00:22:09.429 align:middle line:90%,end
<c.magenta>在内容后面放一个视图</c>

00:22:10.631 --> 00:22:13.300 align:middle line:90%,end
<c.magenta>而且我们也在NSColor中</c>
<c.magenta>提供一个命名颜色</c>

00:22:13.367 --> 00:22:15.335 align:middle line:90%,end
<c.magenta>叫作scrubberTexturedBackground颜色</c>

00:22:16.170 --> 00:22:17.871 align:middle line:90%,end
<c.magenta>在backgroundColor属性中效果不错</c>

00:22:17.938 --> 00:22:21.108 align:middle line:90%,end
<c.magenta>用于提供这种很酷的垂直纹理外观</c>

00:22:21.175 --> 00:22:23.410 align:middle line:90%,end
<c.magenta>你可能会在应用中见过</c>
<c.magenta>比如日历应用</c>

00:22:25.112 --> 00:22:27.948 align:middle line:90%,end
<c.magenta>现在看起来有很多属性</c>
<c.magenta>但如果我们把它们归结在一起</c>

00:22:28.015 --> 00:22:31.018 align:middle line:90%,end
<c.magenta>我们只需要写几行代码</c>
<c.magenta>就能完全配置NSScrubber了</c>

00:22:32.386 --> 00:22:35.289 align:middle line:90%,end
<c.magenta>那么我们创建了控件</c>
<c.magenta>然后我们给它分配了一个布局</c>

00:22:35.355 --> 00:22:36.757 align:middle line:90%,end
<c.magenta>一个委托和一个dataSource</c>

00:22:36.823 --> 00:22:39.059 align:middle line:90%,end
<c.magenta>我们并没有仔细研究这些</c>
<c.magenta>但我保证我们</c>

00:22:39.126 --> 00:22:40.327 align:middle line:90%,end
<c.magenta>稍后会逐个讲到每一个</c>

00:22:41.195 --> 00:22:43.463 align:middle line:90%,end
<c.magenta>我们要决定如何与控件交互</c>

00:22:43.830 --> 00:22:46.567 align:middle line:90%,end
<c.magenta>在本例中</c>
<c.magenta>我们想要一个可以自由滚动</c>

00:22:46.633 --> 00:22:48.268 align:middle line:90%,end
<c.magenta>但在滚动时</c>
<c.magenta>拥有连续性选择的效果</c>

00:22:48.802 --> 00:22:51.104 align:middle line:90%,end
<c.magenta>然后我们还想</c>
<c.magenta>将itemAlignment设为居中对齐</c>

00:22:51.171 --> 00:22:54.675 align:middle line:90%,end
<c.magenta>以便在滚动后某些触控项</c>
<c.magenta>能恰好着陆在中心位置</c>

00:22:55.909 --> 00:22:58.011 align:middle line:90%,end
<c.magenta>然后我们要选择选中效果</c>

00:22:58.078 --> 00:23:00.447 align:middle line:90%,end
<c.magenta>在本例中我们要应用两种自带效果</c>

00:22:58.078 --> 00:23:00.447 align:middle line:90%,end
<c.magenta>在本例中我们要应用两种自带效果</c>

00:23:00.614 --> 00:23:02.416 align:middle line:90%,end
<c.magenta>我们要打开那个很不错的浮动选择</c>

00:23:02.482 --> 00:23:05.886 align:middle line:90%,end
<c.magenta>因此当选择变更时 它会在视图间浮动</c>

00:23:06.954 --> 00:23:09.623 align:middle line:90%,end
<c.magenta>最后我们要应用那个</c>
<c.magenta>很酷的纹理背景颜色</c>

00:23:09.890 --> 00:23:12.826 align:middle line:90%,end
<c.magenta>仅通过这几行代码</c>
<c.magenta>我们就恰好生成了</c>

00:23:12.893 --> 00:23:16.330 align:middle line:90%,end
<c.magenta>日历拖动器的蓝图</c>
<c.magenta>是我们一直在看的日历应用</c>

00:23:18.799 --> 00:23:21.802 align:middle line:90%,end
<c.magenta>现在我们已按照我们的想法</c>
<c.magenta>配置好了控件</c>

00:23:22.069 --> 00:23:23.637 align:middle line:90%,end
<c.magenta>我们需要布局这些触控项</c>

00:23:24.137 --> 00:23:26.373 align:middle line:90%,end
<c.magenta>这是通过NSScrubberLayout类实现的</c>

00:23:27.174 --> 00:23:30.277 align:middle line:90%,end
<c.magenta>这个类定义了控件内部</c>
<c.magenta>全部内容的布局</c>

00:23:30.344 --> 00:23:31.178 align:middle line:90%,end
<c.magenta>且它是</c>

00:23:31.245 --> 00:23:34.114 align:middle line:90%,end
<c.magenta>通过NSScrubberLayoutAttributes</c>
<c.magenta>对象抽象地实现的</c>

00:23:34.181 --> 00:23:37.684 align:middle line:90%,end
<c.magenta>这个对象实质上</c>
<c.magenta>是itemIndex中捆绑的值类型</c>

00:23:37.751 --> 00:23:42.256 align:middle line:90%,end
<c.magenta>它应该在其内容的坐标控件内布局</c>

00:23:43.590 --> 00:23:47.027 align:middle line:90%,end
<c.magenta>我们提供一些自带布局</c>
<c.magenta>你们只需要拉出来就能用</c>

00:23:47.094 --> 00:23:50.130 align:middle line:90%,end
<c.magenta>如果你喜欢的话 你知道的</c>
<c.magenta>只是一些入门的布局</c>

00:23:50.197 --> 00:23:52.199 align:middle line:90%,end
<c.magenta>其中包括流式布局</c>

00:23:52.266 --> 00:23:55.169 align:middle line:90%,end
<c.magenta>与NSCollectionView流式布局有可比性</c>

00:23:55.402 --> 00:23:58.372 align:middle line:90%,end
<c.magenta>但如果你想定义你自己的布局</c>
<c.magenta>也不是那么难</c>

00:23:58.438 --> 00:24:01.408 align:middle line:90%,end
<c.magenta>其实你只需要实施三个关键方法</c>

00:23:58.438 --> 00:24:01.408 align:middle line:90%,end
<c.magenta>其实你只需要实施三个关键方法</c>

00:24:01.875 --> 00:24:03.877 align:middle line:90%,end
<c.magenta>第一个是scrubberContentSize</c>

00:24:03.944 --> 00:24:06.446 align:middle line:90%,end
<c.magenta>定义了控件内一切组件的整体尺寸</c>

00:24:07.047 --> 00:24:10.217 align:middle line:90%,end
<c.magenta>也定义了我们在全部内容内</c>
<c.magenta>可以滚动多远</c>

00:24:11.518 --> 00:24:14.221 align:middle line:90%,end
<c.magenta>长方框里是layoutAttributesForItems</c>

00:24:14.288 --> 00:24:17.257 align:middle line:90%,end
<c.magenta>为指定长方框内的每一触控项</c>

00:24:17.324 --> 00:24:19.159 align:middle line:90%,end
<c.magenta>提供一组完整属性</c>

00:24:19.459 --> 00:24:21.495 align:middle line:90%,end
<c.magenta>可能是当前这个可见的长方框</c>

00:24:21.562 --> 00:24:23.397 align:middle line:90%,end
<c.magenta>或可能是用户要滚动到的一个长方框</c>

00:24:23.463 --> 00:24:25.399 align:middle line:90%,end
<c.magenta>你想要准备好展示一切</c>

00:24:26.633 --> 00:24:28.869 align:middle line:90%,end
<c.magenta>那么最后是索引中的</c>
<c.magenta>layoutAttributesForItem</c>

00:24:28.936 --> 00:24:32.539 align:middle line:90%,end
<c.magenta>如果需要的话</c>
<c.magenta>我们可以决定某些指定项的布局</c>

00:24:35.442 --> 00:24:38.345 align:middle line:90%,end
<c.magenta>布局生命周期的另一半是无效的</c>

00:24:38.412 --> 00:24:39.446 align:middle line:90%,end
<c.magenta>（布局无效）</c>

00:24:39.513 --> 00:24:44.218 align:middle line:90%,end
<c.magenta>InvalidateLayout控制的是</c>
<c.magenta>布局已修改且需要刷新</c>

00:24:44.284 --> 00:24:47.287 align:middle line:90%,end
<c.magenta>以从NSScrubber布局中</c>
<c.magenta>获取新布局信息的控件</c>

00:24:48.655 --> 00:24:51.024 align:middle line:90%,end
<c.magenta>现在如果你的布局取决于指定信息</c>
<c.magenta>比如选择高亮</c>

00:24:51.091 --> 00:24:54.261 align:middle line:90%,end
<c.magenta>或可见长方框 你想在选择时</c>

00:24:54.328 --> 00:24:56.597 align:middle line:90%,end
<c.magenta>所选内容比其它项大一倍</c>

00:24:56.663 --> 00:24:57.965 align:middle line:90%,end
<c.magenta>你可以按情况请求</c>

00:24:58.031 --> 00:25:01.301 align:middle line:90%,end
<c.magenta>自动无效 当那些东西发生变更时</c>

00:24:58.031 --> 00:25:01.301 align:middle line:90%,end
<c.magenta>自动无效 当那些东西发生变更时</c>

00:25:01.535 --> 00:25:04.338 align:middle line:90%,end
<c.magenta>并且这会防止你自己追踪那个信息</c>

00:25:04.404 --> 00:25:06.340 align:middle line:90%,end
<c.magenta>并手动调用无效布局</c>

00:25:07.975 --> 00:25:10.410 align:middle line:90%,end
<c.magenta>最后在你的布局无效之后</c>

00:25:10.711 --> 00:25:13.947 align:middle line:90%,end
<c.magenta>在我们做进一步的布局传递之前</c>
<c.magenta>我们会调用Prepare方法</c>

00:25:14.014 --> 00:25:15.215 align:middle line:90%,end
<c.magenta>在你的布局对象中</c>

00:25:15.449 --> 00:25:17.251 align:middle line:90%,end
<c.magenta>基础实施不会做任何事</c>

00:25:17.317 --> 00:25:21.421 align:middle line:90%,end
<c.magenta>但这是一个很好的机会</c>
<c.magenta>可以让你的子类运行一些计算</c>

00:25:21.488 --> 00:25:23.257 align:middle line:90%,end
<c.magenta>做一些测量并准备一些缓存</c>

00:25:23.323 --> 00:25:25.592 align:middle line:90%,end
<c.magenta>从而使随后的外部调用变得非常迅速</c>

00:25:27.895 --> 00:25:29.863 align:middle line:90%,end
<c.magenta>这就是你组织布局所需要做的一切</c>

00:25:30.998 --> 00:25:32.766 align:middle line:90%,end
<c.magenta>现在我们已经配置了我们的控件</c>
<c.magenta>我们想…</c>

00:25:32.833 --> 00:25:34.735 align:middle line:90%,end
<c.magenta>我们知道想如何布局全部内容</c>

00:25:34.801 --> 00:25:38.005 align:middle line:90%,end
<c.magenta>我们首先需要把内容放到控件中</c>

00:25:39.606 --> 00:25:42.309 align:middle line:10%
<c.magenta>NSScrubber中的内容</c>
<c.magenta>是通过简单视图和</c>

00:25:42.376 --> 00:25:44.912 align:middle line:10%
<c.magenta>NSScrubberItemView类的子类呈现的</c>

00:25:45.245 --> 00:25:47.514 align:middle line:10%
<c.magenta>这与NSTableCellView具有可比性</c>

00:25:48.916 --> 00:25:52.052 align:middle line:10%
<c.magenta>就像NSTableCell</c>
<c.magenta>或者像NSTable和NSCollectionView</c>

00:25:52.486 --> 00:25:56.190 align:middle line:10%
<c.magenta>NSScrubber提供一种重复使用的队列</c>
<c.magenta>以便你可以有效循环视图</c>

00:25:56.256 --> 00:25:57.758 align:middle line:10%
<c.magenta>当它们在控件外循环时</c>

00:25:58.192 --> 00:26:01.061 align:middle line:10%
<c.magenta>而不是每次请求时都分配一个新视图</c>

00:25:58.192 --> 00:26:01.061 align:middle line:10%
<c.magenta>而不是每次请求时都分配一个新视图</c>

00:26:02.262 --> 00:26:05.332 align:middle line:10%
<c.magenta>NSScrubber的dataSource协议</c>
<c.magenta>其实非常简单</c>

00:26:05.399 --> 00:26:08.068 align:middle line:10%
<c.magenta>你只需要实施两个方法</c>

00:26:08.135 --> 00:26:10.737 align:middle line:10%
<c.magenta>整体控件中的numberOfItems</c>
<c.magenta>然后你只需要</c>

00:26:10.804 --> 00:26:14.107 align:middle line:10%
<c.magenta>准备一个代表指定触控项的视图即可</c>

00:26:15.709 --> 00:26:19.479 align:middle line:10%
<c.magenta>为了帮助你完成这个任务 我们有两个</c>
<c.magenta>自带NSScrubberItemView子类</c>

00:26:19.546 --> 00:26:22.883 align:middle line:90%,end
<c.magenta>有TextItem 你所需要做的就是提供</c>
<c.magenta>一个你想要呈现的字符串</c>

00:26:22.950 --> 00:26:25.018 align:middle line:90%,end
<c.magenta>并且我们会以一种</c>
<c.magenta>与整个操作系统中的</c>

00:26:25.085 --> 00:26:28.522 align:middle line:90%,end
<c.magenta>其它控件一致的方式呈现它</c>

00:26:28.989 --> 00:26:33.861 align:middle line:90%,end
<c.magenta>然后我们还有一个图片视图类</c>
<c.magenta>提供图片的填充</c>

00:26:33.927 --> 00:26:37.531 align:middle line:90%,end
<c.magenta>除此之外 还允许你指定一种对齐方式</c>

00:26:38.565 --> 00:26:40.901 align:middle line:90%,end
<c.magenta>现在如果这些都不是你想要的东西</c>

00:26:41.168 --> 00:26:45.239 align:middle line:90%,end
<c.magenta>你还可以子类化NSScrubberItemView</c>
<c.magenta>并拉动你自己的布局</c>

00:26:45.906 --> 00:26:48.408 align:middle line:90%,end
<c.magenta>绘制自己的布局时</c>
<c.magenta>你可以获得一些不错的属性</c>

00:26:48.475 --> 00:26:50.277 align:middle line:90%,end
<c.magenta>比如isSelected和isHighlighted</c>

00:26:50.344 --> 00:26:52.613 align:middle line:90%,end
<c.magenta>你可以用来修改那个状态下的拉动内容</c>

00:26:52.980 --> 00:26:55.048 align:middle line:90%,end
<c.magenta>并且你拉动的内容将会自动无效</c>

00:26:55.115 --> 00:26:57.251 align:middle line:90%,end
<c.magenta>当这些发生变更时</c>
<c.magenta>因此你不需要自己观察它们</c>

00:26:57.951 --> 00:27:01.188 align:middle line:90%,end
<c.magenta>并且你还可以</c>
<c.magenta>覆盖applyLayoutAttributes方法</c>

00:26:57.951 --> 00:27:01.188 align:middle line:90%,end
<c.magenta>并且你还可以</c>
<c.magenta>覆盖applyLayoutAttributes方法</c>

00:27:01.522 --> 00:27:04.224 align:middle line:90%,end
<c.magenta>这就允许你检验和诠释属性</c>

00:27:04.291 --> 00:27:06.360 align:middle line:90%,end
<c.magenta>由布局对象生成的</c>

00:27:08.195 --> 00:27:09.663 align:middle line:90%,end
<c.magenta>这就是如何提供内容方式</c>

00:27:10.297 --> 00:27:11.164 align:middle line:90%,end
<c.magenta>最终</c>

00:27:11.231 --> 00:27:14.101 align:middle line:90%,end
<c.magenta>我们假设用户要使用这个控件</c>

00:27:14.168 --> 00:27:15.903 align:middle line:90%,end
<c.magenta>那么我们需要作出响应</c>

00:27:16.570 --> 00:27:18.672 align:middle line:90%,end
<c.magenta>这是通过一个委托协议实现的</c>

00:27:19.139 --> 00:27:21.108 align:middle line:90%,end
<c.magenta>你可以收到通知 当所选内容</c>

00:27:21.175 --> 00:27:22.276 align:middle line:90%,end
<c.magenta>高亮内容</c>

00:27:22.342 --> 00:27:24.945 align:middle line:90%,end
<c.magenta>以及控件中的可见触控项范围</c>

00:27:25.012 --> 00:27:26.780 align:middle line:90%,end
<c.magenta>由于滚动或布局原因而发生变更时</c>

00:27:28.348 --> 00:27:31.752 align:middle line:90%,end
<c.magenta>当交互开始、结束或被取消时</c>
<c.magenta>你也可以收到通知</c>

00:27:32.019 --> 00:27:35.088 align:middle line:90%,end
<c.magenta>这可能适用于 比如用控件</c>

00:27:35.155 --> 00:27:37.658 align:middle line:90%,end
<c.magenta>在单一交互中创建一个取消分组</c>

00:27:37.724 --> 00:27:40.093 align:middle line:90%,end
<c.magenta>那么因为用户会很迅速地拖动</c>

00:27:40.160 --> 00:27:43.897 align:middle line:90%,end
<c.magenta>你可以将全部这些变更</c>
<c.magenta>打包到一个单一取消分组中</c>

00:27:47.401 --> 00:27:50.170 align:middle line:90%,end
<c.magenta>这就是你要做自己的NSScrubber</c>
<c.magenta>所需要做的全部操作</c>

00:27:50.237 --> 00:27:53.473 align:middle line:90%,end
<c.magenta>我希望你已经</c>
<c.magenta>你已经了解了这些很棒的想法</c>

00:27:53.540 --> 00:27:56.276 align:middle line:90%,end
<c.magenta>关于你应用中的内容 你可以通过</c>
<c.magenta>这些控件实现一些基本的东西</c>

00:27:58.712 --> 00:27:59.546 align:middle line:90%,end
<c.magenta>但是…</c>

00:28:00.113 --> 00:28:03.050 align:middle line:90%,end
<c.magenta>我们…在Fundamentals演讲</c>
<c.magenta>和本场演讲之间</c>

00:28:03.550 --> 00:28:06.553 align:middle line:90%,end
<c.magenta>花了大量的时间解释</c>
<c.magenta>如何使用AppKit的自带控件</c>

00:28:06.620 --> 00:28:09.223 align:middle line:90%,end
<c.magenta>和类来打造你的触控条体验</c>

00:28:10.057 --> 00:28:12.893 align:middle line:90%,end
<c.magenta>但如果你想真正发挥你的创造力</c>

00:28:12.960 --> 00:28:14.461 align:middle line:90%,end
<c.magenta>并创建一个真正自定义的控件</c>

00:28:14.862 --> 00:28:16.864 align:middle line:90%,end
<c.magenta>你需要留下来听下一部分的内容</c>

00:28:16.930 --> 00:28:20.167 align:middle line:90%,end
<c.magenta>泰勒会跟大家逐步分享…</c>

00:28:20.334 --> 00:28:22.703 align:middle line:90%,end
<c.magenta>为触控条实现完全自定义控件</c>

00:28:23.770 --> 00:28:24.605 align:middle line:90%,end
<c.magenta>谢谢</c>

00:28:27.374 --> 00:28:28.208 align:middle line:90%,end
<c.magenta>来吧</c>

00:28:31.378 --> 00:28:32.212 align:middle line:90%,end
<c.magenta>大家好</c>

00:28:34.448 --> 00:28:37.284 align:middle line:90%,end
<c.magenta>那么提到为触控条创建自定义控件</c>

00:28:37.451 --> 00:28:39.953 align:middle line:90%,end
<c.magenta>你需要记住四点</c>

00:28:40.120 --> 00:28:42.990 align:middle line:90%,end
<c.magenta>第一点是处理进来的触摸事件</c>

00:28:43.624 --> 00:28:47.494 align:middle line:90%,end
<c.magenta>第二点是调整视图的样式</c>
<c.magenta>使其在触控条中看起来没什么不一样</c>

00:28:48.028 --> 00:28:50.697 align:middle line:90%,end
<c.magenta>第三点是确保尺寸正确</c>

00:28:50.764 --> 00:28:52.132 align:middle line:90%,end
<c.magenta>并将其放在其它控件之中</c>

00:28:52.566 --> 00:28:54.768 align:middle line:90%,end
<c.magenta>最后一点是将一切捆绑在一起</c>

00:28:54.835 --> 00:28:56.537 align:middle line:90%,end
<c.magenta>通过应用一些动画</c>

00:28:57.204 --> 00:28:59.106 align:middle line:90%,end
<c.magenta>让我们从事件处理开始讲</c>

00:28:59.773 --> 00:29:03.477 align:middle line:90%,end
<c.magenta>现在很明显的一件事是</c>
<c.magenta>我们可以在Mac上直接触摸</c>

00:28:59.773 --> 00:29:03.477 align:middle line:90%,end
<c.magenta>现在很明显的一件事是</c>
<c.magenta>我们可以在Mac上直接触摸</c>

00:29:04.044 --> 00:29:05.412 align:middle line:90%,end
<c.magenta>我真的很想阐述一下</c>

00:29:05.479 --> 00:29:07.681 align:middle line:90%,end
<c.magenta>直接触摸与非直接触摸之间的区别</c>

00:29:08.448 --> 00:29:09.283 align:middle line:90%,end
<c.magenta>你们</c>

00:29:09.349 --> 00:29:12.753 align:middle line:90%,end
<c.magenta>可能是iList开发人员</c>
<c.magenta>已经熟悉了这种区别</c>

00:29:12.819 --> 00:29:15.389 align:middle line:90%,end
<c.magenta>当你直接触摸时 你会直接操纵</c>

00:29:15.455 --> 00:29:17.257 align:middle line:90%,end
<c.magenta>iPhone或iPad上的内容</c>

00:29:17.591 --> 00:29:21.361 align:middle line:90%,end
<c.magenta>相反 非直接触摸</c>
<c.magenta>是在Siri Remote的触摸表面上</c>

00:29:21.562 --> 00:29:24.531 align:middle line:90%,end
<c.magenta>你可以远程与电视上的内容进行交互</c>

00:29:25.299 --> 00:29:28.902 align:middle line:90%,end
<c.magenta>在新MacBook Pro中</c>
<c.magenta>一台设备上同时拥有这两种触摸</c>

00:29:29.536 --> 00:29:33.073 align:middle line:90%,end
<c.magenta>触摸轨迹板上已经有了非直接触摸</c>

00:29:33.273 --> 00:29:36.476 align:middle line:90%,end
<c.magenta>你可以在轨迹板上获取单一触摸</c>

00:29:37.611 --> 00:29:40.414 align:middle line:90%,end
<c.magenta>现在通过触控条 我们支持直接触摸</c>

00:29:40.480 --> 00:29:43.383 align:middle line:90%,end
<c.magenta>你可以直接操纵屏幕上的内容</c>

00:29:44.785 --> 00:29:47.754 align:middle line:90%,end
<c.magenta>因此我们现在扩展了NSTouch类</c>

00:29:47.821 --> 00:29:51.491 align:middle line:90%,end
<c.magenta>添加了一个TouchType来描述</c>
<c.magenta>是直接或间接触摸</c>

00:29:52.426 --> 00:29:53.427 align:middle line:90%,end
<c.magenta>对于直接触摸</c>

00:29:53.493 --> 00:29:56.296 align:middle line:90%,end
<c.magenta>你现在可以获取那个触摸的位置</c>
<c.magenta>提供一些视图</c>

00:29:56.630 --> 00:29:58.932 align:middle line:90%,end
<c.magenta>提供那个视图是非常重要的</c>

00:29:58.999 --> 00:30:02.236 align:middle line:90%,end
<c.magenta>因为它提供了</c>
<c.magenta>相对于哪个点的坐标空间</c>

00:29:58.999 --> 00:30:02.236 align:middle line:90%,end
<c.magenta>因为它提供了</c>
<c.magenta>相对于哪个点的坐标空间</c>

00:30:03.003 --> 00:30:06.073 align:middle line:90%,end
<c.magenta>举个例子 当用户滚动滑块时</c>

00:30:06.340 --> 00:30:10.010 align:middle line:90%,end
<c.magenta>我们想获取那个触摸的位置</c>
<c.magenta>相对于滑块这个整体的位置</c>

00:30:10.410 --> 00:30:13.113 align:middle line:90%,end
<c.magenta>而且我们要获取那个位移</c>
<c.magenta>并按全宽进行划分</c>

00:30:13.447 --> 00:30:14.448 align:middle line:90%,end
<c.magenta>以获取新值</c>

00:30:14.982 --> 00:30:16.183 align:middle line:90%,end
<c.magenta>非常简单直接</c>

00:30:17.351 --> 00:30:18.185 align:middle line:90%,end
<c.magenta>现在</c>

00:30:18.252 --> 00:30:21.121 align:middle line:90%,end
<c.magenta>NSTouch和UITouch的一个</c>
<c.magenta>非常重要的不同点</c>

00:30:21.388 --> 00:30:23.724 align:middle line:90%,end
<c.magenta>是对于UITouch这个长期存在的对象</c>

00:30:23.790 --> 00:30:25.893 align:middle line:90%,end
<c.magenta>它的位置会随着时间更新</c>

00:30:25.959 --> 00:30:29.062 align:middle line:90%,end
<c.magenta>而NSTouch实质上是</c>
<c.magenta>那个触摸的值类型的一个快照</c>

00:30:29.563 --> 00:30:32.599 align:middle line:90%,end
<c.magenta>…那个手势中适时的某一点</c>

00:30:33.233 --> 00:30:34.902 align:middle line:90%,end
<c.magenta>你可以用identify属性</c>

00:30:34.968 --> 00:30:37.838 align:middle line:90%,end
<c.magenta>将一系列触摸捆绑到一起</c>
<c.magenta>然后就形成了一个手势</c>

00:30:38.605 --> 00:30:41.008 align:middle line:90%,end
<c.magenta>那么因为事件是通过触控条进入的</c>

00:30:41.074 --> 00:30:44.811 align:middle line:90%,end
<c.magenta>每个事件都将包含一个或多个触摸</c>

00:30:45.612 --> 00:30:47.681 align:middle line:90%,end
<c.magenta>并且每个触摸都是唯一实例</c>

00:30:47.748 --> 00:30:51.351 align:middle line:90%,end
<c.magenta>因此再一次 你将它们捆绑在一起的</c>
<c.magenta>方式是通过查看那个identity属性</c>

00:30:52.152 --> 00:30:54.655 align:middle line:90%,end
<c.magenta>那么甚至当用户用多个手指触摸时</c>

00:30:54.721 --> 00:30:57.457 align:middle line:90%,end
<c.magenta>我们也可以区分</c>
<c.magenta>到底哪个是我们要追踪的那个</c>

00:30:57.658 --> 00:31:01.028 align:middle line:90%,end
<c.magenta>通过与我们所追踪的触摸</c>
<c.magenta>比较identity属性</c>

00:30:57.658 --> 00:31:01.028 align:middle line:90%,end
<c.magenta>通过与我们所追踪的触摸</c>
<c.magenta>比较identity属性</c>

00:31:02.062 --> 00:31:04.164 align:middle line:10%
<c.magenta>我们可以通过一些代码</c>
<c.magenta>使这个看起来更具体</c>

00:31:04.431 --> 00:31:07.734 align:middle line:10%
<c.magenta>那么我们想保留一个变量</c>
<c.magenta>使其抓紧那个迟钝的identity对象</c>

00:31:08.335 --> 00:31:10.304 align:middle line:10%
<c.magenta>当我们第一次</c>
<c.magenta>在视图中获得一些触摸时</c>

00:31:10.370 --> 00:31:12.973 align:middle line:10%
<c.magenta>我们要检查这些触摸</c>
<c.magenta>并选择第一个触摸</c>

00:31:13.040 --> 00:31:15.342 align:middle line:10%
<c.magenta>然后保存它的identity属性</c>
<c.magenta>作为我们要追踪的触摸</c>

00:31:15.843 --> 00:31:19.546 align:middle line:10%
<c.magenta>稍后 当越来越多的触摸进入之后</c>
<c.magenta>我们要检查发生变更的触摸</c>

00:31:20.180 --> 00:31:21.548 align:middle line:10%
<c.magenta>并将每一个触摸的identity属性</c>

00:31:21.615 --> 00:31:24.184 align:middle line:10%
<c.magenta>与我们要追踪的那个触摸的identity</c>
<c.magenta>属性相比较 从而发现新触摸</c>

00:31:24.251 --> 00:31:27.788 align:middle line:10%
<c.magenta>我们现在可以使用那个新位置</c>
<c.magenta>来更新视图中的任意事件了</c>

00:31:29.122 --> 00:31:31.158 align:middle line:10%
<c.magenta>现在 这些事件和触摸从哪儿来呢？</c>

00:31:31.792 --> 00:31:34.595 align:middle line:10%
<c.magenta>嗯 其中一个来源是</c>
<c.magenta>这些现有的NSResponder方法</c>

00:31:34.661 --> 00:31:37.431 align:middle line:10%
<c.magenta>touchesBegan、Moved、Ended</c>
<c.magenta>和Cancelled</c>

00:31:37.497 --> 00:31:39.967 align:middle line:10%
<c.magenta>将会在视图的整个生命周期中</c>
<c.magenta>进行回调</c>

00:31:40.634 --> 00:31:43.103 align:middle line:10%
<c.magenta>我们可以选择接收它们</c>
<c.magenta>通过将allowedTouchTypes设置为</c>

00:31:43.170 --> 00:31:45.205 align:middle line:10%
<c.magenta>包含直接或非直接触摸</c>

00:31:45.272 --> 00:31:47.174 align:middle line:10%
<c.magenta>但一旦你链接Sierra SDK</c>

00:31:47.241 --> 00:31:50.177 align:middle line:10%
<c.magenta>你将自动选择接收直接触摸</c>

00:31:51.345 --> 00:31:54.014 align:middle line:90%,end
<c.magenta>这里的一个非常重要的方法是</c>
<c.magenta>touchesCancelled</c>

00:31:54.715 --> 00:31:57.885 align:middle line:90%,end
<c.magenta>其实并没有取消鼠标追踪事件的概念</c>

00:31:57.951 --> 00:31:59.987 align:middle line:90%,end
<c.magenta>这对于触控条来说非常重要</c>

00:32:00.053 --> 00:32:01.688 align:middle line:90%,end
<c.magenta>因为它对情境非常敏感</c>

00:32:02.322 --> 00:32:05.259 align:middle line:90%,end
<c.magenta>随着用户切换激活的应用或激活的窗口</c>

00:32:05.592 --> 00:32:08.161 align:middle line:90%,end
<c.magenta>触控条中的内容将会随着更新</c>
<c.magenta>以反映那个操作</c>

00:32:08.228 --> 00:32:10.898 align:middle line:90%,end
<c.magenta>并且如果用户在当时</c>
<c.magenta>正与任意视图进行交互</c>

00:32:10.964 --> 00:32:14.234 align:middle line:90%,end
<c.magenta>我们将发送touchesCancelled</c>
<c.magenta>从而清除任何事件处理</c>

00:32:14.301 --> 00:32:16.703 align:middle line:90%,end
<c.magenta>但是用户抬起手指就会把那个</c>
<c.magenta>从用户那儿分离出来</c>

00:32:18.172 --> 00:32:20.674 align:middle line:10%
<c.magenta>然而 在极大程度上</c>
<c.magenta>其实你不需要担心这个</c>

00:32:20.741 --> 00:32:22.676 align:middle line:10%
<c.magenta>你可以使用gestureRecognizers</c>

00:32:23.210 --> 00:32:25.312 align:middle line:10%
<c.magenta>这些已经拥有全部这些相同的方法</c>

00:32:25.379 --> 00:32:27.881 align:middle line:10%
<c.magenta>可供子类实施</c>
<c.magenta>因此它们可以处理触摸</c>

00:32:27.948 --> 00:32:29.416 align:middle line:10%
<c.magenta>并拥有同样的选择方法</c>

00:32:29.483 --> 00:32:32.553 align:middle line:10%
<c.magenta>唯一的不同点是你得明确选择加入</c>

00:32:32.619 --> 00:32:34.021 align:middle line:10%
<c.magenta>因为没有自动链接检验</c>

00:32:35.189 --> 00:32:37.491 align:middle line:90%,end
<c.magenta>你几乎可以使用</c>
<c.magenta>全部自带GestureRecognizers</c>

00:32:37.558 --> 00:32:39.092 align:middle line:90%,end
<c.magenta>现在在触控条中也能用了</c>

00:32:39.560 --> 00:32:43.564 align:middle line:90%,end
<c.magenta>比如说颜色选择器使用了一个</c>
<c.magenta>按和缩放识别器的组合</c>

00:32:43.630 --> 00:32:45.399 align:middle line:90%,end
<c.magenta>用来实施全部事件处理</c>

00:32:45.599 --> 00:32:47.067 align:middle line:90%,end
<c.magenta>它不必做任何额外的工作</c>

00:32:48.135 --> 00:32:49.636 align:middle line:90%,end
<c.magenta>但有一点很重要请谨记 即便是这些</c>

00:32:49.703 --> 00:32:52.840 align:middle line:90%,end
<c.magenta>你仍然需要选择接收直接触摸</c>

00:32:52.906 --> 00:32:54.508 align:middle line:90%,end
<c.magenta>当你在触控条中使用它们时</c>

00:32:56.109 --> 00:32:58.846 align:middle line:10%
<c.magenta>现在提到事件处理</c>
<c.magenta>有一个非常有趣的情境</c>

00:32:58.912 --> 00:33:00.714 align:middle line:10%
<c.magenta>在按住弹出框内</c>

00:32:58.912 --> 00:33:00.714 align:middle line:10%
<c.magenta>在按住弹出框内</c>

00:33:01.281 --> 00:33:03.250 align:middle line:10%
<c.magenta>在Fundamentals演讲中</c>
<c.magenta>你了解了如何设置</c>

00:33:03.317 --> 00:33:05.485 align:middle line:10%
<c.magenta>NSTouchBar的按住触控条</c>

00:33:06.153 --> 00:33:08.689 align:middle line:10%
<c.magenta>从而当用户长按按钮时出现</c>

00:33:08.755 --> 00:33:11.925 align:middle line:10%
<c.magenta>它会立即呈现一些很简单的列表</c>
<c.magenta>如UI</c>

00:33:12.593 --> 00:33:17.197 align:middle line:10%
<c.magenta>你可以在那里放自己的自定义视图</c>
<c.magenta>随着用户继续该手势并缩放视图</c>

00:33:17.264 --> 00:33:21.668 align:middle line:10%
<c.magenta>你将调用touchesBegan、Moved</c>
<c.magenta>如果他们退出视图就调用Cancelled</c>

00:33:21.735 --> 00:33:24.671 align:middle line:10%
<c.magenta>最后一旦用户抬起手指</c>
<c.magenta>触控条将被遣散</c>

00:33:25.305 --> 00:33:27.808 align:middle line:10%
<c.magenta>然而 因为这个非常独特的</c>
<c.magenta>事件处理模型</c>

00:33:27.875 --> 00:33:30.177 align:middle line:10%
<c.magenta>这个情境不支持GestureRecognizers</c>

00:33:30.244 --> 00:33:32.546 align:middle line:10%
<c.magenta>所以你要使用那些NSResponder方法</c>

00:33:33.113 --> 00:33:35.482 align:middle line:10%
<c.magenta>然而 在按住弹出框外部</c>

00:33:35.549 --> 00:33:38.118 align:middle line:10%
<c.magenta>就变得简单多了</c>
<c.magenta>用GestureRecognizers就可以了</c>

00:33:39.453 --> 00:33:41.788 align:middle line:90%,end
<c.magenta>关于触控条 有一个很有意思的方面</c>

00:33:41.855 --> 00:33:43.490 align:middle line:90%,end
<c.magenta>就是关于事件形态</c>

00:33:44.258 --> 00:33:47.060 align:middle line:90%,end
<c.magenta>因为触控条是这个输入设备</c>
<c.magenta>类似于键盘</c>

00:33:47.127 --> 00:33:48.629 align:middle line:90%,end
<c.magenta>它应该一直保持响应性</c>

00:33:48.795 --> 00:33:50.998 align:middle line:90%,end
<c.magenta>正因为如此</c>
<c.magenta>如果用户在屏幕上拖拽什么东西</c>

00:33:51.064 --> 00:33:52.833 align:middle line:90%,end
<c.magenta>并不意味着你的键盘停止了工作</c>

00:33:53.534 --> 00:33:56.436 align:middle line:90%,end
<c.magenta>那么即便你之前有一个</c>
<c.magenta>模态事件追踪循环</c>

00:33:56.837 --> 00:34:00.774 align:middle line:90%,end
<c.magenta>触控条仍然要保持响应性</c>
<c.magenta>并仍能发布状态变更</c>

00:33:56.837 --> 00:34:00.774 align:middle line:90%,end
<c.magenta>触控条仍然要保持响应性</c>
<c.magenta>并仍能发布状态变更</c>

00:34:01.341 --> 00:34:03.877 align:middle line:90%,end
<c.magenta>那么你可能想返回去</c>
<c.magenta>查看那些事件追踪循环</c>

00:34:03.944 --> 00:34:06.480 align:middle line:90%,end
<c.magenta>从而确保它们可以处理</c>
<c.magenta>可能会发生的状态变更类型</c>

00:34:07.781 --> 00:34:10.617 align:middle line:90%,end
<c.magenta>此外 触控条自身也能多点触控</c>

00:34:10.984 --> 00:34:13.820 align:middle line:90%,end
<c.magenta>因此 当用户与其中一个控件交互时</c>

00:34:13.887 --> 00:34:16.123 align:middle line:90%,end
<c.magenta>他们可以与另一个控件</c>
<c.magenta>开始和结束交互</c>

00:34:16.590 --> 00:34:19.259 align:middle line:90%,end
<c.magenta>你要确保你可以处理</c>
<c.magenta>那些状态变更</c>

00:34:20.694 --> 00:34:21.929 align:middle line:90%,end
<c.magenta>然而一旦你那样做了</c>

00:34:21.995 --> 00:34:25.331 align:middle line:90%,end
<c.magenta>你就提供了大量的</c>
<c.magenta>很有意思的交互机会</c>

00:34:25.399 --> 00:34:28.668 align:middle line:90%,end
<c.magenta>通过结合存在于此台设备上的</c>
<c.magenta>全部输入设备</c>

00:34:29.369 --> 00:34:32.438 align:middle line:90%,end
<c.magenta>你可以为用户创建很高级的流程</c>

00:34:32.505 --> 00:34:34.208 align:middle line:90%,end
<c.magenta>或这种令人愉悦的体验</c>

00:34:34.274 --> 00:34:36.510 align:middle line:90%,end
<c.magenta>用户可能会在四处闲逛时发现</c>

00:34:37.377 --> 00:34:39.913 align:middle line:90%,end
<c.magenta>比如在自定义UI中</c>

00:34:39.980 --> 00:34:43.317 align:middle line:90%,end
<c.magenta>我们给每一个触控项添加了</c>
<c.magenta>单一缩放识别器</c>

00:34:43.382 --> 00:34:45.719 align:middle line:90%,end
<c.magenta>因此用户可以用多个手指轻触</c>

00:34:45.786 --> 00:34:47.621 align:middle line:90%,end
<c.magenta>然后就会同时记录多个项</c>

00:34:49.056 --> 00:34:49.956 align:middle line:90%,end
<c.magenta>类似地</c>

00:34:50.023 --> 00:34:53.927 align:middle line:90%,end
<c.magenta>颜色选择器的每个单一滑块上</c>
<c.magenta>都有长按识别器</c>

00:34:53.994 --> 00:34:56.597 align:middle line:90%,end
<c.magenta>因此你可以同时编辑多个组件</c>

00:34:56.663 --> 00:34:58.298 align:middle line:90%,end
<c.magenta>或当你编辑那个颜色时</c>

00:34:58.365 --> 00:35:00.834 align:middle line:90%,end
<c.magenta>你可以同时将其保存为你的偏爱颜色</c>

00:34:58.365 --> 00:35:00.834 align:middle line:90%,end
<c.magenta>你可以同时将其保存为你的偏爱颜色</c>

00:35:01.668 --> 00:35:03.170 align:middle line:90%,end
<c.magenta>这就是多点触控的使用</c>

00:35:03.370 --> 00:35:05.172 align:middle line:90%,end
<c.magenta>一旦你将其与键盘或轨迹板相结合</c>

00:35:05.239 --> 00:35:07.174 align:middle line:90%,end
<c.magenta>你就升了一级</c>

00:35:07.474 --> 00:35:11.078 align:middle line:10%
<c.magenta>比如可以在键入文本时编辑文本颜色</c>

00:35:11.144 --> 00:35:14.414 align:middle line:10%
<c.magenta>或当移动游标时编辑其属性</c>

00:35:15.482 --> 00:35:17.484 align:middle line:10%
<c.magenta>因此 我鼓励你们考虑一下要如何</c>

00:35:17.551 --> 00:35:19.019 align:middle line:90%,end
<c.magenta>利用gestureRecognizers</c>

00:35:19.086 --> 00:35:21.622 align:middle line:90%,end
<c.magenta>为你的应用添加事件处理支持</c>

00:35:21.688 --> 00:35:24.525 align:middle line:90%,end
<c.magenta>并同时处理这些同时发生的状态变更</c>

00:35:25.559 --> 00:35:27.928 align:middle line:90%,end
<c.magenta>接下来让我们看看样式和外观</c>

00:35:28.562 --> 00:35:31.632 align:middle line:90%,end
<c.magenta>那么很明显 触控条内的样式</c>

00:35:31.698 --> 00:35:34.601 align:middle line:90%,end
<c.magenta>与Apple主显示屏上很不同</c>

00:35:35.202 --> 00:35:37.004 align:middle line:90%,end
<c.magenta>我要提到其中几点</c>

00:35:37.070 --> 00:35:39.706 align:middle line:90%,end
<c.magenta>但我想从你们可能甚至</c>
<c.magenta>都没有注意到的一点开始</c>

00:35:40.174 --> 00:35:42.910 align:middle line:90%,end
<c.magenta>这是你能看到的唯一的东西</c>
<c.magenta>当把你的MacBook Pro</c>

00:35:42.976 --> 00:35:44.278 align:middle line:90%,end
<c.magenta>带到不同的环境中时</c>

00:35:44.845 --> 00:35:46.647 align:middle line:90%,end
<c.magenta>那么我们的标准存档照片</c>
<c.magenta>看起来是这样的</c>

00:35:46.713 --> 00:35:48.315 align:middle line:90%,end
<c.magenta>就算是光线也非常棒</c>

00:35:48.382 --> 00:35:50.217 align:middle line:90%,end
<c.magenta>如果你使用它</c>
<c.magenta>在明亮的工作室环境中</c>

00:35:50.284 --> 00:35:53.187 align:middle line:90%,end
<c.magenta>或也许甚至是在室外</c>
<c.magenta>它可能会像这样</c>

00:35:53.754 --> 00:35:56.190 align:middle line:90%,end
<c.magenta>如果你跟我一样</c>
<c.magenta>你可能主要在黑暗环境中使用它</c>

00:35:56.256 --> 00:36:00.494 align:middle line:90%,end
<c.magenta>OLED显示屏上的黑色消失后</c>
<c.magenta>看起来很酷</c>

00:35:56.256 --> 00:36:00.494 align:middle line:90%,end
<c.magenta>OLED显示屏上的黑色消失后</c>
<c.magenta>看起来很酷</c>

00:36:01.195 --> 00:36:02.196 align:middle line:90%,end
<c.magenta>最后</c>

00:36:02.262 --> 00:36:04.698 align:middle line:90%,end
<c.magenta>如果你感到很累</c>
<c.magenta>总是会在晚上感到疲劳</c>

00:36:04.765 --> 00:36:07.334 align:middle line:90%,end
<c.magenta>你可以打开键盘背光灯</c>
<c.magenta>并得到那个很棒的光晕</c>

00:36:08.135 --> 00:36:11.171 align:middle line:90%,end
<c.magenta>MacBook Pro外观看起来</c>
<c.magenta>很不一样</c>

00:36:11.238 --> 00:36:14.308 align:middle line:90%,end
<c.magenta>当处于这些不同的环境中时</c>
<c.magenta>触控条内容实际上也会随着调节</c>

00:36:14.942 --> 00:36:19.213 align:middle line:90%,end
<c.magenta>不同控件的边框颜色</c>
<c.magenta>随着环境的亮度调节</c>

00:36:19.613 --> 00:36:21.782 align:middle line:90%,end
<c.magenta>即便是控件内的符号</c>

00:36:21.849 --> 00:36:25.352 align:middle line:90%,end
<c.magenta>也会对键盘背光灯的参照白点</c>
<c.magenta>变更做出反应</c>

00:36:26.220 --> 00:36:28.822 align:middle line:90%,end
<c.magenta>因此 如果你实施自己的自定义控件</c>

00:36:28.889 --> 00:36:30.390 align:middle line:90%,end
<c.magenta>你需要确保你可以实现同样的功能</c>

00:36:31.091 --> 00:36:34.027 align:middle line:90%,end
<c.magenta>幸亏这个实现非常简单</c>
<c.magenta>可以使用系统颜色实现</c>

00:36:34.561 --> 00:36:36.163 align:middle line:90%,end
<c.magenta>这些是现有的命名颜色</c>

00:36:36.230 --> 00:36:38.765 align:middle line:90%,end
<c.magenta>并且有如何使用它们的语义描述</c>

00:36:39.132 --> 00:36:40.901 align:middle line:90%,end
<c.magenta>一旦你决定使用它们</c>

00:36:40.968 --> 00:36:43.971 align:middle line:90%,end
<c.magenta>它们会动态地相互对抗当前情境</c>

00:36:44.037 --> 00:36:46.139 align:middle line:90%,end
<c.magenta>以决定要拉动哪种颜色</c>

00:36:46.406 --> 00:36:49.743 align:middle line:90%,end
<c.magenta>并考虑是否正在触控条</c>
<c.magenta>还是Aqua界面中使用</c>

00:36:49.810 --> 00:36:52.513 align:middle line:90%,end
<c.magenta>以及参考白点</c>
<c.magenta>或亮度是否发生变更</c>

00:36:53.981 --> 00:36:57.784 align:middle line:90%,end
<c.magenta>此外 High Sierra新特性是</c>
<c.magenta>这个极具表现力的调色板</c>

00:36:57.851 --> 00:37:01.989 align:middle line:90%,end
<c.magenta>你可以用来匹配系统UI</c>
<c.magenta>已针对外发光外观和触控条</c>

00:36:57.851 --> 00:37:01.989 align:middle line:90%,end
<c.magenta>你可以用来匹配系统UI</c>
<c.magenta>已针对外发光外观和触控条</c>

00:37:02.055 --> 00:37:04.057 align:middle line:90%,end
<c.magenta>进行了特别设计</c>

00:37:07.294 --> 00:37:10.230 align:middle line:90%,end
<c.magenta>那么 你要记住的一个重点是</c>
<c.magenta>如何拉动这些颜色</c>

00:37:10.297 --> 00:37:11.598 align:middle line:90%,end
<c.magenta>以利用</c>

00:37:11.665 --> 00:37:13.033 align:middle line:90%,end
<c.magenta>全部的情境敏感性</c>

00:37:14.468 --> 00:37:16.336 align:middle line:90%,end
<c.magenta>那么如果你正在通过层来拉动视图</c>

00:37:16.403 --> 00:37:20.741 align:middle line:90%,end
<c.magenta>你可能会尝试用框架进行初始化</c>
<c.magenta>ViewDidLoad或立即响应</c>

00:37:20.807 --> 00:37:23.844 align:middle line:90%,end
<c.magenta>事件处理、立即更新层的属性</c>

00:37:24.411 --> 00:37:27.181 align:middle line:90%,end
<c.magenta>但你不希望这样做</c>
<c.magenta>因为当你获得那个CG颜色</c>

00:37:27.247 --> 00:37:28.448 align:middle line:90%,end
<c.magenta>并将其设置在层上时</c>

00:37:28.515 --> 00:37:30.651 align:middle line:90%,end
<c.magenta>那会立即解决那些RGB值</c>

00:37:30.717 --> 00:37:32.953 align:middle line:90%,end
<c.magenta>无论当前情境是什么</c>

00:37:33.720 --> 00:37:35.856 align:middle line:90%,end
<c.magenta>那么随着参考白点或亮度的变更</c>

00:37:36.156 --> 00:37:39.059 align:middle line:90%,end
<c.magenta>你的层将保持</c>
<c.magenta>与当前状态相同的状态</c>

00:37:40.093 --> 00:37:41.261 align:middle line:90%,end
<c.magenta>那么我们该怎么做呢？</c>

00:37:41.628 --> 00:37:43.730 align:middle line:90%,end
<c.magenta>嗯 我们可以覆盖这个叫作</c>
<c.magenta>updateLayer的方法</c>

00:37:43.797 --> 00:37:45.766 align:middle line:90%,end
<c.magenta>然后从那儿升级我们的层</c>

00:37:46.366 --> 00:37:49.369 align:middle line:90%,end
<c.magenta>这将会被自动调用</c>
<c.magenta>当显示你的视图时</c>

00:37:49.436 --> 00:37:51.038 align:middle line:90%,end
<c.magenta>就像它第一次显示在屏幕上</c>

00:37:51.104 --> 00:37:53.240 align:middle line:90%,end
<c.magenta>或窗口中时</c>
<c.magenta>所发生的参考白点或亮度变更</c>

00:37:54.041 --> 00:37:56.610 align:middle line:90%,end
<c.magenta>如果你有一个想要设置的动态颜色</c>

00:37:56.810 --> 00:37:59.813 align:middle line:90%,end
<c.magenta>你将那个颜色</c>
<c.magenta>作为NSColor保持住这点很重要</c>

00:38:00.147 --> 00:38:02.916 align:middle line:90%,end
<c.magenta>因为再一次 这会维持颜色的语义性质</c>

00:38:03.116 --> 00:38:04.852 align:middle line:90%,end
<c.magenta>及其情境敏感性</c>

00:38:05.786 --> 00:38:08.622 align:middle line:90%,end
<c.magenta>无论何时当颜色变更时</c>
<c.magenta>你只需要将needsDisplay设为真</c>

00:38:08.689 --> 00:38:10.324 align:middle line:90%,end
<c.magenta>然后我们就会替你回调这个方法</c>

00:38:12.025 --> 00:38:15.429 align:middle line:90%,end
<c.magenta>同样的方法可以用于</c>
<c.magenta>使用DrawRectBasedViews时</c>

00:38:15.495 --> 00:38:17.998 align:middle line:90%,end
<c.magenta>唯一的不同点是你按照当前情境</c>

00:38:18.065 --> 00:38:19.399 align:middle line:90%,end
<c.magenta>设置颜色</c>

00:38:21.235 --> 00:38:24.137 align:middle line:90%,end
<c.magenta>那么这就是如何利用自定义颜色</c>
<c.magenta>以及你自己的自定义拉动</c>

00:38:24.905 --> 00:38:27.841 align:middle line:90%,end
<c.magenta>然而 我们的许多控件支持颜色自定义</c>

00:38:27.908 --> 00:38:29.176 align:middle line:90%,end
<c.magenta>在方框外</c>

00:38:29.843 --> 00:38:32.246 align:middle line:90%,end
<c.magenta>你现在可以设置NS按钮的边框颜色</c>

00:38:32.312 --> 00:38:35.782 align:middle line:90%,end
<c.magenta>选中部分的颜色</c>
<c.magenta>甚至是滑块的填充颜色</c>

00:38:36.416 --> 00:38:39.286 align:middle line:90%,end
<c.magenta>你可以使用自带的系统颜色</c>
<c.magenta>或你自己的定制颜色</c>

00:38:39.353 --> 00:38:40.954 align:middle line:90%,end
<c.magenta>如果你有整体的应用主题的话</c>

00:38:41.688 --> 00:38:42.789 align:middle line:90%,end
<c.magenta>这里有一点很酷</c>

00:38:42.856 --> 00:38:46.460 align:middle line:90%,end
<c.magenta>就是这些控件内的文本和图片效果</c>
<c.magenta>实际上是</c>

00:38:46.527 --> 00:38:48.295 align:middle line:90%,end
<c.magenta>根据你所设置的颜色亮度进行调节的</c>

00:38:48.729 --> 00:38:50.731 align:middle line:90%,end
<c.magenta>你其实不必做任何工作</c>
<c.magenta>就能得到那种结果</c>

00:38:52.733 --> 00:38:54.468 align:middle line:90%,end
<c.magenta>整个系统中 你可能注意到一件事</c>

00:38:54.535 --> 00:38:56.603 align:middle line:90%,end
<c.magenta>就是这些默认按钮的蓝色</c>

00:38:57.304 --> 00:38:58.972 align:middle line:90%,end
<c.magenta>一定要注意这并不是</c>

00:38:59.039 --> 00:39:01.742 align:middle line:90%,end
<c.magenta>通过将systemBlue颜色</c>
<c.magenta>设置为bezelColor实现的</c>

00:38:59.039 --> 00:39:01.742 align:middle line:90%,end
<c.magenta>通过将systemBlue颜色</c>
<c.magenta>设置为bezelColor实现的</c>

00:39:02.009 --> 00:39:04.611 align:middle line:90%,end
<c.magenta>其实这些之间稍微有一些</c>
<c.magenta>颜色上的不同</c>

00:39:04.678 --> 00:39:07.814 align:middle line:90%,end
<c.magenta>你可以通过将keyEquivalent</c>
<c.magenta>作为返回键实现</c>

00:39:08.048 --> 00:39:09.716 align:middle line:90%,end
<c.magenta>就像你在主显示屏上做过的那样</c>

00:39:12.019 --> 00:39:14.955 align:middle line:90%,end
<c.magenta>在我们之前看到的这些幻灯片中</c>
<c.magenta>你可能还注意到了一件事</c>

00:39:15.022 --> 00:39:17.291 align:middle line:90%,end
<c.magenta>就是这个完成按钮替换了Esc键</c>

00:39:17.658 --> 00:39:19.026 align:middle line:90%,end
<c.magenta>实现方式非常简单</c>

00:39:19.092 --> 00:39:21.662 align:middle line:90%,end
<c.magenta>通过设置escapeKeyReplacement</c>
<c.magenta>ItemIdentifier</c>

00:39:21.728 --> 00:39:23.697 align:middle line:90%,end
<c.magenta>在你当前的NSTouchBar上</c>

00:39:23.931 --> 00:39:27.534 align:middle line:90%,end
<c.magenta>无论是哪个控件</c>
<c.magenta>那个引用都将被放在Esc键的区域</c>

00:39:28.535 --> 00:39:31.605 align:middle line:90%,end
<c.magenta>然而考虑何时使用这个是非常重要的</c>

00:39:32.039 --> 00:39:33.140 align:middle line:90%,end
<c.magenta>它其实只能用于</c>

00:39:33.207 --> 00:39:35.809 align:middle line:90%,end
<c.magenta>当用户进入某些模态情境</c>

00:39:35.876 --> 00:39:38.846 align:middle line:90%,end
<c.magenta>且他们可以使用那个控件</c>
<c.magenta>来退出该情境时</c>

00:39:39.580 --> 00:39:42.316 align:middle line:90%,end
<c.magenta>他们在这个情境中所执行的任何行动</c>
<c.magenta>都是不可撤销的</c>

00:39:42.382 --> 00:39:46.720 align:middle line:90%,end
<c.magenta>因此如果我编辑这里的照片并轻触完成</c>
<c.magenta>我稍后仍可以撤销那个变更</c>

00:39:47.688 --> 00:39:50.591 align:middle line:90%,end
<c.magenta>最后 你不需要给这个按钮</c>
<c.magenta>添加明确的约束条件</c>

00:39:50.657 --> 00:39:53.026 align:middle line:90%,end
<c.magenta>来尝试使其符合Esc键的标准尺寸</c>

00:39:53.360 --> 00:39:56.463 align:middle line:90%,end
<c.magenta>我们会自动应用度量</c>
<c.magenta>从而使其符合标准尺寸</c>

00:39:56.797 --> 00:39:59.666 align:middle line:90%,end
<c.magenta>甚至会调节文本四周的边距</c>

00:39:59.733 --> 00:40:01.368 align:middle line:90%,end
<c.magenta>使其尽可能地适合大部分字符</c>

00:39:59.733 --> 00:40:01.368 align:middle line:90%,end
<c.magenta>使其尽可能地适合大部分字符</c>

00:40:02.369 --> 00:40:05.038 align:middle line:90%,end
<c.magenta>因此 比如说我们发现完成按钮的</c>
<c.magenta>最长的翻译是</c>

00:40:05.105 --> 00:40:06.206 align:middle line:90%,end
<c.magenta>Gotowe</c>

00:40:06.273 --> 00:40:09.109 align:middle line:90%,end
<c.magenta>即便是Gotowe也能适用</c>
<c.magenta>这些经过调节的度量</c>

00:40:10.010 --> 00:40:12.813 align:middle line:90%,end
<c.magenta>然而还有最后一招</c>
<c.magenta>我们将允许这个控件的</c>

00:40:12.880 --> 00:40:16.350 align:middle line:90%,end
<c.magenta>尺寸变大</c>
<c.magenta>以防万一出现情有可原的情况</c>

00:40:18.051 --> 00:40:20.420 align:middle line:90%,end
<c.magenta>现在关于触控条中的样式的</c>
<c.magenta>另一个重要方面是</c>

00:40:20.487 --> 00:40:21.688 align:middle line:90%,end
<c.magenta>字体</c>

00:40:22.556 --> 00:40:25.392 align:middle line:90%,end
<c.magenta>现在你可能注意到Aqua</c>
<c.magenta>主显示屏上的</c>

00:40:25.459 --> 00:40:27.427 align:middle line:90%,end
<c.magenta>触控条的字体发生了变化</c>

00:40:27.494 --> 00:40:30.831 align:middle line:90%,end
<c.magenta>我们用了San Francisco UI的标准字体</c>
<c.magenta>字号为13</c>

00:40:31.298 --> 00:40:34.101 align:middle line:90%,end
<c.magenta>在触控条中</c>
<c.magenta>我们用了与Watch非常类似的东西</c>

00:40:34.168 --> 00:40:36.403 align:middle line:90%,end
<c.magenta>San Francisco Condensed字体 字号15</c>

00:40:36.904 --> 00:40:38.839 align:middle line:90%,end
<c.magenta>那么字体和字号都变了</c>

00:40:39.439 --> 00:40:41.909 align:middle line:90%,end
<c.magenta>你们中跟随Mac字体过渡的人</c>

00:40:41.975 --> 00:40:45.445 align:middle line:90%,end
<c.magenta>也许从Chicago</c>
<c.magenta>一直跟随到Charcoal、Lucida</c>

00:40:45.512 --> 00:40:47.414 align:middle line:90%,end
<c.magenta>Helvetica、San Francisco</c>

00:40:47.481 --> 00:40:50.250 align:middle line:90%,end
<c.magenta>你们知道你们不应该在应用中</c>
<c.magenta>硬编码这些字体</c>

00:40:50.751 --> 00:40:53.287 align:middle line:90%,end
<c.magenta>相反 你可以使用systemFont</c>
<c.magenta>字号为0</c>

00:40:53.353 --> 00:40:56.190 align:middle line:90%,end
<c.magenta>这将会返回给你这个动态字体</c>

00:40:56.256 --> 00:40:58.692 align:middle line:90%,end
<c.magenta>使用时会根据当前情境决定</c>

00:40:58.759 --> 00:41:02.296 align:middle line:90%,end
<c.magenta>就像那些系统颜色一样</c>
<c.magenta>选择合适的字体和字号</c>

00:40:58.759 --> 00:41:02.296 align:middle line:90%,end
<c.magenta>就像那些系统颜色一样</c>
<c.magenta>选择合适的字体和字号</c>

00:41:03.030 --> 00:41:06.400 align:middle line:90%,end
<c.magenta>此外 还有一个权重变化</c>
<c.magenta>你可以获得加粗或正常字体</c>

00:41:07.367 --> 00:41:09.837 align:middle line:90%,end
<c.magenta>关于字体还有另一个有意思的事</c>
<c.magenta>你可能没有注意到</c>

00:41:09.903 --> 00:41:13.207 align:middle line:90%,end
<c.magenta>就是这些在像AVKit Player</c>

00:41:13.273 --> 00:41:16.076 align:middle line:90%,end
<c.magenta>甚至是滑块的组件值中使用的等宽数位</c>

00:41:16.610 --> 00:41:17.911 align:middle line:90%,end
<c.magenta>即便是值改变了</c>

00:41:17.978 --> 00:41:20.547 align:middle line:90%,end
<c.magenta>那些数字也不会像度量调节一样</c>
<c.magenta>极速变化</c>

00:41:20.614 --> 00:41:21.682 align:middle line:90%,end
<c.magenta>它们是等宽的</c>

00:41:22.249 --> 00:41:23.083 align:middle line:90%,end
<c.magenta>那么你可以</c>

00:41:23.150 --> 00:41:26.053 align:middle line:90%,end
<c.magenta>通过尺寸权重的</c>
<c.magenta>monospacedDigitSystemFont</c>

00:41:26.687 --> 00:41:27.921 align:middle line:90%,end
<c.magenta>来获得同样的效果</c>

00:41:28.822 --> 00:41:31.758 align:middle line:90%,end
<c.magenta>现在 其实有许多有意思的排版功能</c>

00:41:31.825 --> 00:41:33.293 align:middle line:90%,end
<c.magenta>提到San Francisco</c>

00:41:33.360 --> 00:41:35.729 align:middle line:90%,end
<c.magenta>并且过去几年中也有一些相关演讲</c>

00:41:35.796 --> 00:41:38.599 align:middle line:90%,end
<c.magenta>如果你有兴趣了解更多</c>
<c.magenta>我建议你们参考那些演讲的视频</c>

00:41:39.633 --> 00:41:41.435 align:middle line:90%,end
<c.magenta>然而 触控条中符号的另一个重要类型</c>

00:41:41.502 --> 00:41:43.704 align:middle line:90%,end
<c.magenta>当然是图片了</c>

00:41:45.005 --> 00:41:49.209 align:middle line:90%,end
<c.magenta>而且因为触控条是</c>
<c.magenta>这个P3视网膜显示屏</c>

00:41:49.276 --> 00:41:52.412 align:middle line:90%,end
<c.magenta>你所要提供的就是为那里使用的图片</c>
<c.magenta>提供2x资产</c>

00:41:53.013 --> 00:41:55.916 align:middle line:90%,end
<c.magenta>然而 它们应该是专为触控条设计的</c>

00:41:56.216 --> 00:41:58.685 align:middle line:90%,end
<c.magenta>你不应该仅仅是采用工具栏的图标</c>
<c.magenta>然后把它放在这里</c>

00:41:59.586 --> 00:42:01.388 align:middle line:90%,end
<c.magenta>此外 你应该使用模板渲染</c>

00:41:59.586 --> 00:42:01.388 align:middle line:90%,end
<c.magenta>此外 你应该使用模板渲染</c>

00:42:01.455 --> 00:42:03.590 align:middle line:90%,end
<c.magenta>来利用那些参考白点和亮度调节</c>

00:42:03.657 --> 00:42:04.758 align:middle line:90%,end
<c.magenta>我之前提到过的</c>

00:42:05.826 --> 00:42:08.529 align:middle line:90%,end
<c.magenta>举例说明 假如我们正在做一个</c>
<c.magenta>自定义亮灯按钮</c>

00:42:09.096 --> 00:42:11.365 align:middle line:90%,end
<c.magenta>我们已经专为触控条做了很好的设计</c>

00:42:11.431 --> 00:42:14.201 align:middle line:90%,end
<c.magenta>并且我们会与其它标准图标一起使用</c>

00:42:14.601 --> 00:42:16.170 align:middle line:10%
<c.magenta>总体上看起来很不错</c>

00:42:16.503 --> 00:42:19.873 align:middle line:10%
<c.magenta>除了在夜晚 我们把它带回家</c>
<c.magenta>然后打开计算机背光灯</c>

00:42:19.940 --> 00:42:21.375 align:middle line:10%
<c.magenta>它看起来是这样的</c>

00:42:21.942 --> 00:42:25.879 align:middle line:10%
<c.magenta>其它图标都会自动调节</c>
<c.magenta>而我们的图标却显得特别扎眼</c>

00:42:26.580 --> 00:42:27.748 align:middle line:10%
<c.magenta>那么我们不要这样做</c>

00:42:29.616 --> 00:42:30.884 align:middle line:10%
<c.magenta>相反 我们可以使用的是</c>

00:42:30.951 --> 00:42:33.654 align:middle line:10%
<c.magenta>提供一个通过阿尔法通道</c>

00:42:33.720 --> 00:42:36.757 align:middle line:10%
<c.magenta>能与其形状通讯的图片</c>
<c.magenta>并使用模板渲染</c>

00:42:36.823 --> 00:42:41.161 align:middle line:10%
<c.magenta>以便AppKit可以获取</c>
<c.magenta>那个图片可能会存在的全部不同样式</c>

00:42:41.228 --> 00:42:42.296 align:middle line:10%
<c.magenta>比如白色</c>

00:42:42.362 --> 00:42:44.998 align:middle line:10%
<c.magenta>甚至是蓝色样式</c>
<c.magenta>当调节参考白点时</c>

00:42:46.433 --> 00:42:49.837 align:middle line:10%
<c.magenta>现在 在你让设计师动身专为触控条</c>
<c.magenta>创建一群很棒的图标</c>

00:42:49.903 --> 00:42:52.806 align:middle line:10%
<c.magenta>以利用模板渲染之前</c>

00:42:53.140 --> 00:42:55.008 align:middle line:90%,end
<c.magenta>请一定要确保查看</c>

00:42:55.075 --> 00:42:56.510 align:middle line:90%,end
<c.magenta>系统已经提供了的全部标准图标</c>

00:42:56.910 --> 00:42:59.213 align:middle line:90%,end
<c.magenta>真的有很多 你从人性化接口指南中</c>

00:42:59.279 --> 00:43:00.447 align:middle line:90%,end
<c.magenta>可以看到全部标准图标</c>

00:42:59.279 --> 00:43:00.447 align:middle line:90%,end
<c.magenta>可以看到全部标准图标</c>

00:43:00.781 --> 00:43:04.117 align:middle line:90%,end
<c.magenta>非常酷的是这些全部都是</c>
<c.magenta>由NSImage提供的公共常量</c>

00:43:04.184 --> 00:43:06.720 align:middle line:90%,end
<c.magenta>因此你可以非常方便地</c>
<c.magenta>在你的应用中采用</c>

00:43:06.787 --> 00:43:08.188 align:middle line:90%,end
<c.magenta>工作量真的很小</c>

00:43:09.556 --> 00:43:10.390 align:middle line:90%,end
<c.magenta>那么</c>

00:43:10.457 --> 00:43:12.359 align:middle line:90%,end
<c.magenta>这些是设计外观的一些注意点</c>

00:43:12.426 --> 00:43:14.127 align:middle line:90%,end
<c.magenta>很酷的是对于最主要的部分</c>

00:43:14.194 --> 00:43:15.963 align:middle line:90%,end
<c.magenta>你可以仅采用系统标准技巧</c>

00:43:16.029 --> 00:43:17.731 align:middle line:90%,end
<c.magenta>然后免费获得许多这样的行为</c>

00:43:19.032 --> 00:43:20.834 align:middle line:90%,end
<c.magenta>接下来让我们谈谈布局</c>

00:43:21.502 --> 00:43:22.769 align:middle line:90%,end
<c.magenta>在Fundamentals演讲中</c>

00:43:22.836 --> 00:43:25.973 align:middle line:90%,end
<c.magenta>你了解了标准触控项布局的方式是</c>
<c.magenta>在触控条内将这些触控项</c>

00:43:26.039 --> 00:43:27.207 align:middle line:90%,end
<c.magenta>逐个堆在一起</c>

00:43:27.674 --> 00:43:30.711 align:middle line:90%,end
<c.magenta>你可以使用弹性空间为你的触控项</c>
<c.magenta>提供一点呼吸的空间</c>

00:43:31.078 --> 00:43:34.581 align:middle line:90%,end
<c.magenta>或者你可以使用主要触控项</c>
<c.magenta>来居中显示一个或多个触控项</c>

00:43:35.516 --> 00:43:39.119 align:middle line:90%,end
<c.magenta>现在 NSTouchBar中的布局</c>
<c.magenta>跟NSStackView中的布局类似</c>

00:43:39.653 --> 00:43:42.356 align:middle line:90%,end
<c.magenta>触控项自身就提供自己的尺寸信息</c>

00:43:42.556 --> 00:43:45.459 align:middle line:90%,end
<c.magenta>然后NSTouchBar基于那个尺寸</c>
<c.magenta>摆放它的位置</c>

00:43:46.360 --> 00:43:47.861 align:middle line:90%,end
<c.magenta>提到描述那个尺寸</c>

00:43:47.928 --> 00:43:50.764 align:middle line:90%,end
<c.magenta>与在触控条外时一模一样</c>

00:43:52.232 --> 00:43:55.068 align:middle line:90%,end
<c.magenta>比如你覆盖了intrinsicContentSize</c>
<c.magenta>并计算了</c>

00:43:55.135 --> 00:43:57.404 align:middle line:90%,end
<c.magenta>你的控件尺寸</c>
<c.magenta>那你只需返回那个尺寸就可以了</c>

00:43:58.305 --> 00:44:01.341 align:middle line:90%,end
<c.magenta>如果发生任何状态变更</c>
<c.magenta>比如按钮的标题变更</c>

00:43:58.305 --> 00:44:01.341 align:middle line:90%,end
<c.magenta>如果发生任何状态变更</c>
<c.magenta>比如按钮的标题变更</c>

00:44:01.608 --> 00:44:04.611 align:middle line:90%,end
<c.magenta>并且当你需要记录</c>
<c.magenta>intrinsicContentSize已经变更时</c>

00:44:04.945 --> 00:44:07.347 align:middle line:90%,end
<c.magenta>你可以调用</c>
<c.magenta>invalidateIntrinsicContentSize</c>

00:44:07.414 --> 00:44:09.449 align:middle line:90%,end
<c.magenta>NSTouchBar将会输出一切</c>

00:44:10.751 --> 00:44:12.553 align:middle line:90%,end
<c.magenta>你以前可能用过的另一个方法是</c>

00:44:12.786 --> 00:44:15.355 align:middle line:90%,end
<c.magenta>向控件中添加一个明确的</c>
<c.magenta>widthConstraint</c>

00:44:15.422 --> 00:44:17.124 align:middle line:90%,end
<c.magenta>然后随时间更新那个常量</c>

00:44:17.624 --> 00:44:19.426 align:middle line:90%,end
<c.magenta>这样也可以 同样地</c>

00:44:19.493 --> 00:44:22.162 align:middle line:90%,end
<c.magenta>NSTouchBar也会输出一切</c>

00:44:24.932 --> 00:44:26.400 align:middle line:90%,end
<c.magenta>当你创建自定义控件时</c>

00:44:26.466 --> 00:44:28.702 align:middle line:90%,end
<c.magenta>你也可能拥有弹性尺寸的控件</c>

00:44:28.769 --> 00:44:30.904 align:middle line:90%,end
<c.magenta>类似NSSlider或NSScrubber</c>

00:44:31.338 --> 00:44:34.608 align:middle line:90%,end
<c.magenta>在这里</c>
<c.magenta>唯一的不同点是那个没有宽限制</c>

00:44:34.675 --> 00:44:37.611 align:middle line:90%,end
<c.magenta>或拥有noIntrinsicMetric的</c>
<c.magenta>固有内容宽度</c>

00:44:38.579 --> 00:44:41.815 align:middle line:90%,end
<c.magenta>NSTouch Bar将利用触控条中的</c>
<c.magenta>全部可用空间</c>

00:44:41.882 --> 00:44:44.251 align:middle line:90%,end
<c.magenta>并将其划分给这些有弹性宽度的控件</c>

00:44:44.885 --> 00:44:45.886 align:middle line:90%,end
<c.magenta>在本例中</c>

00:44:45.953 --> 00:44:47.487 align:middle line:90%,end
<c.magenta>滑块是那里的唯一控件</c>

00:44:47.554 --> 00:44:49.523 align:middle line:90%,end
<c.magenta>所以它占据了整个可用区域</c>

00:44:50.424 --> 00:44:53.160 align:middle line:10%
<c.magenta>现在如果我们想给它限定一个</c>
<c.magenta>最小和最大尺寸</c>

00:44:53.493 --> 00:44:57.564 align:middle line:10%
<c.magenta>我们只需要添加不等式约束即可</c>
<c.magenta>就像我们在触控条外做的那样</c>

00:44:58.332 --> 00:45:00.601 align:middle line:10%
<c.magenta>NSTouchBar也会按那样做</c>

00:44:58.332 --> 00:45:00.601 align:middle line:10%
<c.magenta>NSTouchBar也会按那样做</c>

00:45:01.502 --> 00:45:03.837 align:middle line:10%
<c.magenta>拥有这种弹性的真正好处是</c>

00:45:03.937 --> 00:45:06.406 align:middle line:10%
<c.magenta>当用户自定义一个附加触控项时</c>

00:45:06.707 --> 00:45:09.710 align:middle line:10%
<c.magenta>它们仍会在控件能有多大方面</c>
<c.magenta>有一定的弹性</c>

00:45:09.776 --> 00:45:12.479 align:middle line:10%
<c.magenta>而且用户可以真正最大限度地</c>
<c.magenta>利用他们的触控条</c>

00:45:14.181 --> 00:45:17.484 align:middle line:10%
<c.magenta>那么这就是如何自定义</c>
<c.magenta>单一项的尺寸和布局</c>

00:45:17.551 --> 00:45:20.454 align:middle line:10%
<c.magenta>但你可能还想要协调一群项之间的布局</c>

00:45:21.755 --> 00:45:23.257 align:middle line:90%,end
<c.magenta>High Sierra中新增的一个东西是</c>

00:45:23.323 --> 00:45:26.026 align:middle line:90%,end
<c.magenta>prefersEqualWidths属性</c>
<c.magenta>在GroupTouchBarItem上</c>

00:45:26.093 --> 00:45:28.161 align:middle line:90%,end
<c.magenta>你可以在那个群中包含全部的触控项</c>

00:45:28.228 --> 00:45:29.396 align:middle line:90%,end
<c.magenta>最好是等宽的</c>

00:45:30.130 --> 00:45:32.666 align:middle line:90%,end
<c.magenta>很酷的是这也适用于用户自定义</c>

00:45:32.799 --> 00:45:34.134 align:middle line:90%,end
<c.magenta>因此用户不仅可自定义触控项</c>

00:45:34.201 --> 00:45:36.470 align:middle line:90%,end
<c.magenta>在这个同等尺寸的群内和群外</c>

00:45:36.537 --> 00:45:39.406 align:middle line:90%,end
<c.magenta>而且同等尺寸只能影响</c>

00:45:39.473 --> 00:45:41.308 align:middle line:90%,end
<c.magenta>那些在触控条中实际存在的触控项</c>

00:45:41.375 --> 00:45:44.244 align:middle line:90%,end
<c.magenta>它与用户可能会添加的触控项无关</c>

00:45:45.379 --> 00:45:47.481 align:middle line:90%,end
<c.magenta>这个对于本地化来说也非常好用</c>

00:45:47.915 --> 00:45:50.584 align:middle line:90%,end
<c.magenta>假如其中一个按钮</c>
<c.magenta>在本地化时变得非常长</c>

00:45:50.651 --> 00:45:54.288 align:middle line:90%,end
<c.magenta>我们会选择打破那个等宽</c>
<c.magenta>而不是溢出触控条</c>

00:45:54.454 --> 00:45:56.456 align:middle line:90%,end
<c.magenta>导致那个触控项被隐藏起来</c>

00:45:57.624 --> 00:46:00.194 align:middle line:90%,end
<c.magenta>然而 有时候仍可能会发生溢出</c>

00:45:57.624 --> 00:46:00.194 align:middle line:90%,end
<c.magenta>然而 有时候仍可能会发生溢出</c>

00:46:00.961 --> 00:46:03.397 align:middle line:90%,end
<c.magenta>此时就要用到可见性优先级</c>

00:46:04.731 --> 00:46:08.168 align:middle line:90%,end
<c.magenta>在这里你可以看到一些开始窗口的UI</c>
<c.magenta>在英文版中看起来很好</c>

00:46:08.235 --> 00:46:11.471 align:middle line:90%,end
<c.magenta>但是如果我们最初以德语版运行</c>
<c.magenta>它就会变成这样</c>

00:46:12.005 --> 00:46:15.075 align:middle line:90%,end
<c.magenta>没有任何剪裁</c>
<c.magenta>而New Collection按钮失踪了</c>

00:46:15.642 --> 00:46:17.644 align:middle line:90%,end
<c.magenta>原因是触控条中的全部触控项</c>

00:46:17.711 --> 00:46:19.746 align:middle line:90%,end
<c.magenta>不能嵌入我们所分配的空间</c>

00:46:19.813 --> 00:46:22.349 align:middle line:90%,end
<c.magenta>所以NSTouchBar就溢出了</c>
<c.magenta>那个New Collection按钮</c>

00:46:22.416 --> 00:46:23.417 align:middle line:90%,end
<c.magenta>然后将它隐藏起来</c>

00:46:23.984 --> 00:46:27.421 align:middle line:90%,end
<c.magenta>在本例中</c>
<c.magenta>我们可能会想隐藏那个书签按钮</c>

00:46:27.487 --> 00:46:28.989 align:middle line:90%,end
<c.magenta>而不是这个New Collection按钮</c>

00:46:29.156 --> 00:46:32.392 align:middle line:90%,end
<c.magenta>我们可以通过将它</c>
<c.magenta>的visibilityPriority</c>

00:46:32.459 --> 00:46:33.460 align:middle line:90%,end
<c.magenta>设置得比其它项低实现</c>

00:46:33.927 --> 00:46:36.630 align:middle line:90%,end
<c.magenta>NSTouchBar将首先分离较低的一个项</c>

00:46:37.364 --> 00:46:38.932 align:middle line:10%
<c.magenta>这次 我们会得到这样的东西</c>

00:46:38.999 --> 00:46:43.203 align:middle line:10%
<c.magenta>看起来好多了 但隐藏任何触控项</c>
<c.magenta>都不是一种很好的用户体验</c>

00:46:43.937 --> 00:46:46.340 align:middle line:10%
<c.magenta>因此在本例中 我们很可能会做得更好</c>

00:46:46.740 --> 00:46:50.377 align:middle line:90%,end
<c.magenta>我们可以通过High Sierra中</c>
<c.magenta>新增加的压缩行为实现</c>

00:46:51.512 --> 00:46:54.481 align:middle line:90%,end
<c.magenta>那么在本例中</c>
<c.magenta>我们可以记录完全传达它们</c>

00:46:54.548 --> 00:46:56.884 align:middle line:90%,end
<c.magenta>所拥有效果的不同按钮标题</c>

00:46:57.384 --> 00:47:01.688 align:middle line:90%,end
<c.magenta>并且我们不会随意丢弃触控项</c>
<c.magenta>我们会丢弃那些隐藏的图片</c>

00:46:57.384 --> 00:47:01.688 align:middle line:90%,end
<c.magenta>并且我们不会随意丢弃触控项</c>
<c.magenta>我们会丢弃那些隐藏的图片</c>

00:47:02.589 --> 00:47:04.992 align:middle line:90%,end
<c.magenta>我们可以把这个群的优先压缩选项</c>

00:47:05.058 --> 00:47:07.728 align:middle line:90%,end
<c.magenta>设定为hideImages</c>
<c.magenta>现在当我们运行德语版时</c>

00:47:07.794 --> 00:47:09.129 align:middle line:90%,end
<c.magenta>看起来就是这样的</c>

00:47:09.663 --> 00:47:11.732 align:middle line:90%,end
<c.magenta>很酷的是这是自动发生的</c>

00:47:12.199 --> 00:47:14.735 align:middle line:90%,end
<c.magenta>我们再也不会让一半按钮有图</c>
<c.magenta>而另一半按钮没图了</c>

00:47:14.801 --> 00:47:16.370 align:middle line:90%,end
<c.magenta>要么就都有 要么就都没有</c>

00:47:16.837 --> 00:47:18.739 align:middle line:90%,end
<c.magenta>这里真的有很多的弹性</c>

00:47:19.039 --> 00:47:22.342 align:middle line:90%,end
<c.magenta>我们可以思考一下我们的图标</c>
<c.magenta>是否具有足够的描述性</c>

00:47:22.609 --> 00:47:25.879 align:middle line:10%
<c.magenta>并且如果出现本例中的情况</c>
<c.magenta>会选择隐藏文本</c>

00:47:26.747 --> 00:47:29.383 align:middle line:10%
<c.magenta>你甚至可以走得更远</c>
<c.magenta>如果你有自己的自定义方式</c>

00:47:29.449 --> 00:47:31.485 align:middle line:10%
<c.magenta>你的自定义控件可以压缩的</c>

00:47:31.885 --> 00:47:35.189 align:middle line:10%
<c.magenta>你可以给这些优先选项添加附加选项</c>

00:47:35.455 --> 00:47:38.325 align:middle line:10%
<c.magenta>用于描述你的自定义控件应该</c>

00:47:38.492 --> 00:47:39.693 align:middle line:10%
<c.magenta>以不同的方式进行压缩</c>

00:47:40.894 --> 00:47:44.264 align:middle line:90%,end
<c.magenta>那么这些是你可以</c>
<c.magenta>用不同的群触控项属性</c>

00:47:44.331 --> 00:47:46.066 align:middle line:90%,end
<c.magenta>来控制触控项群布局的几种方式</c>

00:47:46.700 --> 00:47:50.037 align:middle line:90%,end
<c.magenta>然而 你在触控条外使用的容器视图</c>

00:47:50.103 --> 00:47:51.471 align:middle line:90%,end
<c.magenta>也可以在触控条内使用</c>

00:47:52.639 --> 00:47:54.308 align:middle line:90%,end
<c.magenta>今天稍早些时候有一场很棒的演讲</c>

00:47:54.374 --> 00:47:55.843 align:middle line:90%,end
<c.magenta>“选择正确的Cocoa容器视图”</c>

00:47:55.909 --> 00:47:58.145 align:middle line:90%,end
<c.magenta>讨论了一些在触控条外部使用的</c>

00:47:58.212 --> 00:47:59.746 align:middle line:90%,end
<c.magenta>容器视图的不同点</c>

00:47:59.947 --> 00:48:02.850 align:middle line:90%,end
<c.magenta>但我想强调几种</c>
<c.magenta>可以在触控条内使用的方式</c>

00:47:59.947 --> 00:48:02.850 align:middle line:90%,end
<c.magenta>但我想强调几种</c>
<c.magenta>可以在触控条内使用的方式</c>

00:48:03.917 --> 00:48:06.520 align:middle line:90%,end
<c.magenta>你可以使用NSStackView</c>
<c.magenta>实现非常精确的控制</c>

00:48:06.587 --> 00:48:10.224 align:middle line:90%,end
<c.magenta>对触控项的空间或尺寸</c>
<c.magenta>就像这里的这个日历一样</c>

00:48:10.290 --> 00:48:13.560 align:middle line:90%,end
<c.magenta>它们完全去除了这两个按钮之间的空间</c>

00:48:14.828 --> 00:48:17.064 align:middle line:90%,end
<c.magenta>你还可以</c>
<c.magenta>把StackView放到ScrollView中</c>

00:48:17.130 --> 00:48:21.401 align:middle line:90%,end
<c.magenta>用于启动触控条内右侧的</c>
<c.magenta>小列表触控项的滚动特性</c>

00:48:23.003 --> 00:48:25.706 align:middle line:90%,end
<c.magenta>杰夫刚才说过如何使用NSScrubber</c>

00:48:25.772 --> 00:48:27.908 align:middle line:90%,end
<c.magenta>当你拥有这些不受控制的列表触控项时</c>

00:48:27.975 --> 00:48:30.444 align:middle line:90%,end
<c.magenta>你可以保持一个选择</c>

00:48:30.511 --> 00:48:33.881 align:middle line:90%,end
<c.magenta>并受益于那个拖动器</c>
<c.magenta>可以提供的其它优点</c>

00:48:35.249 --> 00:48:37.985 align:middle line:10%
<c.magenta>最后 你可以一直在触控条中</c>
<c.magenta>使用NSCollectionView</c>

00:48:38.051 --> 00:48:41.722 align:middle line:10%
<c.magenta>以真正地拥有对布局</c>

00:48:42.089 --> 00:48:43.624 align:middle line:10%
<c.magenta>或完全自定义交互的精确控制</c>

00:48:43.924 --> 00:48:46.159 align:middle line:10%
<c.magenta>正如颜色选择器中的偏好列表一样</c>

00:48:49.329 --> 00:48:50.230 align:middle line:90%,end
<c.magenta>那么这就是布局</c>

00:48:50.864 --> 00:48:52.332 align:middle line:90%,end
<c.magenta>很酷的是在极大程度上</c>

00:48:52.399 --> 00:48:55.068 align:middle line:90%,end
<c.magenta>布局跟在触控条外部一模一样</c>

00:48:55.135 --> 00:48:58.338 align:middle line:90%,end
<c.magenta>因此 你以前使用的任何概念</c>
<c.magenta>现在都可以在触控条内使用</c>

00:48:58.472 --> 00:48:59.439 align:middle line:90%,end
<c.magenta>（动画）</c>

00:48:59.506 --> 00:49:01.708 align:middle line:90%,end
<c.magenta>最后 让我们谈谈如何使用布局</c>

00:48:59.506 --> 00:49:01.708 align:middle line:90%,end
<c.magenta>最后 让我们谈谈如何使用布局</c>

00:49:01.775 --> 00:49:03.343 align:middle line:90%,end
<c.magenta>将全部这些真正地捆绑在一起</c>

00:49:04.178 --> 00:49:05.913 align:middle line:90%,end
<c.magenta>在此之前 我很想重申一下</c>

00:49:05.979 --> 00:49:09.216 align:middle line:90%,end
<c.magenta>触控条是一个输入设备</c>
<c.magenta>而不是这种额外的显示器</c>

00:49:09.650 --> 00:49:12.686 align:middle line:90%,end
<c.magenta>这不是炫耀</c>
<c.magenta>与众不同的动画技能的正确场所</c>

00:49:12.753 --> 00:49:14.421 align:middle line:90%,end
<c.magenta>动画可能会分散</c>

00:49:14.521 --> 00:49:17.424 align:middle line:90%,end
<c.magenta>正在试着专注于主显示屏的</c>
<c.magenta>用户的注意力</c>

00:49:18.091 --> 00:49:21.762 align:middle line:90%,end
<c.magenta>你所添加的任何动画应该一直</c>
<c.magenta>与用户输入的内容相关</c>

00:49:22.296 --> 00:49:24.765 align:middle line:90%,end
<c.magenta>因为用户的输入内容会随时变化</c>

00:49:25.132 --> 00:49:27.467 align:middle line:90%,end
<c.magenta>你的动画也应该是可中断的和可更新的</c>

00:49:28.769 --> 00:49:30.470 align:middle line:90%,end
<c.magenta>那么 要制作动画</c>
<c.magenta>其中很明显的一点</c>

00:49:30.537 --> 00:49:32.873 align:middle line:90%,end
<c.magenta>就是触控项的尺寸</c>
<c.magenta>因为它们会随时改变</c>

00:49:33.640 --> 00:49:36.743 align:middle line:90%,end
<c.magenta>我们之前了解了</c>
<c.magenta>如何添加明确的宽度约束</c>

00:49:36.810 --> 00:49:37.978 align:middle line:90%,end
<c.magenta>来控制那个尺寸</c>

00:49:38.312 --> 00:49:41.348 align:middle line:90%,end
<c.magenta>并且很棒的是要给那个尺寸变更</c>
<c.magenta>添加动画效果</c>

00:49:41.415 --> 00:49:44.318 align:middle line:90%,end
<c.magenta>我们所需要做的就是</c>
<c.magenta>使用那个常量上的animator代理</c>

00:49:44.418 --> 00:49:46.119 align:middle line:90%,end
<c.magenta>并更新其常量</c>

00:49:46.420 --> 00:49:48.856 align:middle line:90%,end
<c.magenta>并且我们拥有</c>
<c.magenta>你们所期待的全部动画效果</c>

00:49:49.356 --> 00:49:52.426 align:middle line:90%,end
<c.magenta>比如同步动画 甚至还有可中断性</c>

00:49:52.492 --> 00:49:53.827 align:middle line:90%,end
<c.magenta>仅仅通过这个修改</c>

00:49:55.429 --> 00:49:57.965 align:middle line:10%
<c.magenta>如果我们选择使用</c>
<c.magenta>intrinsicContentSize</c>

00:49:58.031 --> 00:49:59.566 align:middle line:10%
<c.magenta>来表达触控项的尺寸</c>

00:49:59.766 --> 00:50:02.503 align:middle line:10%
<c.magenta>那么invalidateIntrinsicContentSize</c>
<c.magenta>就表明了尺寸的改变</c>

00:49:59.766 --> 00:50:02.503 align:middle line:10%
<c.magenta>那么invalidateIntrinsicContentSize</c>
<c.magenta>就表明了尺寸的改变</c>

00:50:02.870 --> 00:50:05.639 align:middle line:10%
<c.magenta>我们所要做的就是</c>
<c.magenta>把那个包含在一个动画群中</c>

00:50:06.006 --> 00:50:09.409 align:middle line:10%
<c.magenta>将allowsImplicitAnimation设为真</c>
<c.magenta>然后调用layoutIfNeeded</c>

00:50:09.910 --> 00:50:12.179 align:middle line:10%
<c.magenta>我们再次得到了同样的动画效果</c>

00:50:12.246 --> 00:50:13.914 align:middle line:10%
<c.magenta>与我们之前</c>
<c.magenta>在另一个方法中看过的一样</c>

00:50:15.215 --> 00:50:17.050 align:middle line:10%
<c.magenta>还有一些其它的东西</c>
<c.magenta>我们想要让它动起来</c>

00:50:17.117 --> 00:50:19.119 align:middle line:10%
<c.magenta>就是无论触控项是否为弹性尺寸</c>

00:50:19.186 --> 00:50:22.890 align:middle line:90%,end
<c.magenta>那么我们在这里看到因为触控项</c>
<c.magenta>占据了全部可用空间</c>

00:50:23.490 --> 00:50:27.227 align:middle line:90%,end
<c.magenta>我们可以在这里采用</c>
<c.magenta>与使用那个动画群一样的技巧</c>

00:50:27.561 --> 00:50:29.396 align:middle line:90%,end
<c.magenta>唯一的不同点也跟以前一样</c>

00:50:29.496 --> 00:50:31.832 align:middle line:90%,end
<c.magenta>就是当触控项是弹性尺寸时</c>

00:50:31.899 --> 00:50:35.903 align:middle line:90%,end
<c.magenta>它的宽度为noIntrinsicMetric的</c>
<c.magenta>intrinsicContentSize</c>

00:50:37.237 --> 00:50:40.874 align:middle line:90%,end
<c.magenta>现在我们可以把这些捆绑在一起</c>
<c.magenta>并开始创建与颜色选择器类似的东西</c>

00:50:41.175 --> 00:50:43.043 align:middle line:90%,end
<c.magenta>你可以修改激活的触控项</c>

00:50:43.143 --> 00:50:45.312 align:middle line:90%,end
<c.magenta>它会增长并占据全部可用空间</c>

00:50:45.379 --> 00:50:47.614 align:middle line:90%,end
<c.magenta>而其它触控项就会缩水</c>

00:50:48.882 --> 00:50:51.852 align:middle line:90%,end
<c.magenta>那么我们</c>
<c.magenta>从定义这个自定义AccordionView开始</c>

00:50:52.452 --> 00:50:55.489 align:middle line:90%,end
<c.magenta>它有一个激活状态</c>
<c.magenta>并定义了一个intrinsicContentSize</c>

00:50:56.456 --> 00:50:59.760 align:middle line:90%,end
<c.magenta>当它处于非激活状态时</c>
<c.magenta>它的尺寸为这个小的固定尺寸</c>

00:51:00.561 --> 00:51:02.196 align:middle line:90%,end
<c.magenta>然而 一旦我们将其设为激活状态</c>

00:51:02.462 --> 00:51:06.099 align:middle line:90%,end
<c.magenta>我们希望它拥有那个可以占据</c>
<c.magenta>全部可用空间的弹性尺寸</c>

00:51:06.366 --> 00:51:09.002 align:middle line:90%,end
<c.magenta>我们可以用noIntrinsicMetric来实现</c>

00:51:10.170 --> 00:51:12.739 align:middle line:90%,end
<c.magenta>现在我们在触控条中堆叠了一些触控项</c>

00:51:12.906 --> 00:51:15.676 align:middle line:90%,end
<c.magenta>并且我们给每一个</c>
<c.magenta>都添加了pressRecognizers</c>

00:51:16.910 --> 00:51:19.513 align:middle line:90%,end
<c.magenta>当用户轻触其中一个可折叠视图时</c>

00:51:19.913 --> 00:51:24.084 align:middle line:90%,end
<c.magenta>我们可以处理那个按压</c>
<c.magenta>然后获取oldActiveAccordionView</c>

00:51:24.618 --> 00:51:28.121 align:middle line:90%,end
<c.magenta>并将其设为非激活状态</c>
<c.magenta>以便获得小的固定尺寸</c>

00:51:28.922 --> 00:51:31.758 align:middle line:90%,end
<c.magenta>获取newActiveAccordionView并激活它</c>

00:51:32.626 --> 00:51:34.895 align:middle line:90%,end
<c.magenta>最后用那个allowsImplicitAnimations</c>

00:51:34.962 --> 00:51:36.230 align:middle line:90%,end
<c.magenta>列出那个修改的布局</c>

00:51:37.164 --> 00:51:39.333 align:middle line:90%,end
<c.magenta>我们完全得到了你们所期待的结果</c>

00:51:39.499 --> 00:51:40.834 align:middle line:90%,end
<c.magenta>非常简单易用</c>

00:51:42.402 --> 00:51:44.338 align:middle line:90%,end
<c.magenta>那么这就是如何给不同的</c>
<c.magenta>触控项尺寸做动画</c>

00:51:44.404 --> 00:51:47.040 align:middle line:90%,end
<c.magenta>但你可能还想给触控项内的内容做动画</c>

00:51:47.508 --> 00:51:49.843 align:middle line:90%,end
<c.magenta>比如不同拖动器内的内容</c>

00:51:50.577 --> 00:51:53.180 align:middle line:90%,end
<c.magenta>现在如果你使用常量或高于一切的布局</c>

00:51:53.247 --> 00:51:55.349 align:middle line:90%,end
<c.magenta>并在那里设置框架或更新属性</c>

00:51:55.415 --> 00:51:57.618 align:middle line:90%,end
<c.magenta>最棒的是不需要额外工作</c>

00:51:57.684 --> 00:51:58.685 align:middle line:90%,end
<c.magenta>就能实现</c>

00:51:59.152 --> 00:52:01.688 align:middle line:90%,end
<c.magenta>随着我们用动画重新调整</c>
<c.magenta>这个自定义触控项的尺寸</c>

00:51:59.152 --> 00:52:01.688 align:middle line:90%,end
<c.magenta>随着我们用动画重新调整</c>
<c.magenta>这个自定义触控项的尺寸</c>

00:52:01.922 --> 00:52:06.660 align:middle line:90%,end
<c.magenta>你可以看到拖动器的触控项的尺寸</c>
<c.magenta>很灵活地变小了 很流畅地变小了</c>

00:52:07.194 --> 00:52:09.663 align:middle line:90%,end
<c.magenta>甚至其中的图片尺寸也很漂亮地变大了</c>

00:52:10.864 --> 00:52:13.634 align:middle line:90%,end
<c.magenta>很酷的是我不需要做任何额外工作</c>

00:52:13.700 --> 00:52:15.903 align:middle line:90%,end
<c.magenta>也可以通过NSScrubber</c>
<c.magenta>来实现这种效果</c>

00:52:16.470 --> 00:52:19.806 align:middle line:90%,end
<c.magenta>因为NSScrubber覆盖了布局</c>
<c.magenta>来实现其全部布局</c>

00:52:19.873 --> 00:52:21.508 align:middle line:90%,end
<c.magenta>和视图属性</c>

00:52:22.042 --> 00:52:23.877 align:middle line:90%,end
<c.magenta>而且这些全都是完全免费的</c>

00:52:26.113 --> 00:52:29.249 align:middle line:90%,end
<c.magenta>你经常在触控条中使用的另一种</c>
<c.magenta>内容类型是按钮</c>

00:52:29.683 --> 00:52:30.851 align:middle line:90%,end
<c.magenta>现在因为你的状态改变了</c>

00:52:30.984 --> 00:52:33.487 align:middle line:90%,end
<c.magenta>以前你可能升级了这些按钮的属性</c>

00:52:33.687 --> 00:52:36.089 align:middle line:90%,end
<c.magenta>但你可能需要实现一些</c>
<c.magenta>类似于FaceTime中的一样的东西</c>

00:52:36.156 --> 00:52:38.425 align:middle line:90%,end
<c.magenta>它实际上会给那些属性修改添加动画</c>

00:52:39.059 --> 00:52:42.629 align:middle line:90%,end
<c.magenta>在High Sierra中有一个新功能</c>
<c.magenta>即能在这些按钮上使用animator代理</c>

00:52:42.696 --> 00:52:44.097 align:middle line:90%,end
<c.magenta>并在那里升级你的属性</c>

00:52:44.298 --> 00:52:46.967 align:middle line:90%,end
<c.magenta>你会完全免费获得这些动画</c>

00:52:48.602 --> 00:52:50.771 align:middle line:90%,end
<c.magenta>如果你关注那个Remind Me Later按钮</c>

00:52:50.838 --> 00:52:53.106 align:middle line:90%,end
<c.magenta>你会注意到随着图片位置的改变</c>

00:52:53.173 --> 00:52:55.242 align:middle line:90%,end
<c.magenta>触控条的整体布局也会随之改变</c>

00:52:55.442 --> 00:52:57.010 align:middle line:10%
<c.magenta>我们可以结合这些</c>

00:52:57.077 --> 00:52:59.379 align:middle line:10%
<c.magenta>针对animator</c>
<c.magenta>设置imagePosition的方法</c>

00:52:59.479 --> 00:53:01.281 align:middle line:10%
<c.magenta>然后使用allowsImplicitAnimations</c>

00:52:59.479 --> 00:53:01.281 align:middle line:10%
<c.magenta>然后使用allowsImplicitAnimations</c>

00:53:01.448 --> 00:53:04.551 align:middle line:10%
<c.magenta>来同时应用这两种动画</c>

00:53:06.119 --> 00:53:08.555 align:middle line:10%
<c.magenta>现在 提到创建你自己的自定义控件</c>

00:53:08.622 --> 00:53:10.691 align:middle line:10%
<c.magenta>你可能还想完全自定义动画</c>

00:53:10.757 --> 00:53:13.827 align:middle line:10%
<c.magenta>触控项尺寸或许甚至是独立的</c>

00:53:14.194 --> 00:53:18.365 align:middle line:10%
<c.magenta>比如当你激活这些滑块时发生的</c>
<c.magenta>重新调整不固定旋钮的尺寸</c>

00:53:19.466 --> 00:53:21.869 align:middle line:10%
<c.magenta>现在你可以在这里</c>
<c.magenta>使用一些不同的方法</c>

00:53:22.069 --> 00:53:25.038 align:middle line:10%
<c.magenta>比如在你的自定义视图上</c>
<c.magenta>使用animator代理</c>

00:53:25.305 --> 00:53:28.542 align:middle line:10%
<c.magenta>来给自带的视图属性</c>
<c.magenta>或你自己的自定义属性创建动画</c>

00:53:29.176 --> 00:53:31.411 align:middle line:10%
<c.magenta>你还可以获取明确的CAAnimations</c>

00:53:31.478 --> 00:53:34.114 align:middle line:10%
<c.magenta>并将其添加到那个视图的内容中</c>

00:53:34.515 --> 00:53:38.819 align:middle line:10%
<c.magenta>或如果你可以在布局覆盖中</c>
<c.magenta>将这个表达为状态改变</c>

00:53:39.486 --> 00:53:41.288 align:middle line:10%
<c.magenta>就是你更新视图属性的地方</c>

00:53:41.355 --> 00:53:44.091 align:middle line:90%,end
<c.magenta>你可以再一次利用那个</c>
<c.magenta>allowsImplicitAnimation调用</c>

00:53:44.191 --> 00:53:47.628 align:middle line:90%,end
<c.magenta>然后实际上你就不需要做其它额外操作</c>
<c.magenta>随着其中一些动画的变更</c>

00:53:49.029 --> 00:53:50.397 align:middle line:90%,end
<c.magenta>几年前有一场演讲</c>

00:53:50.464 --> 00:53:53.200 align:middle line:90%,end
<c.magenta>很具体地描述了这三种不同的方法</c>

00:53:53.267 --> 00:53:56.436 align:middle line:90%,end
<c.magenta>及其利弊：“Cocoa动画的最佳范例”</c>

00:53:56.737 --> 00:53:59.072 align:middle line:90%,end
<c.magenta>如果你们想了解更多信息</c>
<c.magenta>我建议你们查看那个视频</c>

00:54:00.707 --> 00:54:03.677 align:middle line:90%,end
<c.magenta>那么我们今天讲了各种各样的内容</c>

00:54:04.011 --> 00:54:06.313 align:middle line:90%,end
<c.magenta>我希望你们从中获得一些灵感</c>

00:54:06.380 --> 00:54:08.882 align:middle line:90%,end
<c.magenta>回去之后开始为你的应用</c>
<c.magenta>创建非常丰富的触控条内容</c>

00:54:08.949 --> 00:54:12.152 align:middle line:90%,end
<c.magenta>并真正打造一种非常了不起的用户体验</c>

00:54:12.452 --> 00:54:14.955 align:middle line:90%,end
<c.magenta>比如在补充列表项中自定义补充数据</c>

00:54:15.322 --> 00:54:17.057 align:middle line:90%,end
<c.magenta>创建你自己的拖动器布局</c>

00:54:17.157 --> 00:54:20.027 align:middle line:90%,end
<c.magenta>或结合gestureRecognizers</c>
<c.magenta>以一种很独特的方式</c>

00:54:20.093 --> 00:54:22.596 align:middle line:90%,end
<c.magenta>让你的UI变得非常有意思</c>

00:54:23.130 --> 00:54:24.631 align:middle line:90%,end
<c.magenta>要获取更多信息 请查看这个网站</c>

00:54:24.698 --> 00:54:27.935 align:middle line:90%,end
<c.magenta>那里有文档链接和</c>
<c.magenta>Human Interface Guidelines</c>

00:54:28.602 --> 00:54:31.438 align:middle line:90%,end
<c.magenta>与之相关的大部分演讲</c>
<c.magenta>都已经过去了</c>

00:54:31.505 --> 00:54:34.041 align:middle line:90%,end
<c.magenta>但明天同一时间还有一场</c>

00:54:34.274 --> 00:54:36.143 align:middle line:90%,end
<c.magenta>“创建可视化的丰富用户体验”</c>

00:54:36.210 --> 00:54:39.279 align:middle line:90%,end
<c.magenta>我会提出一些</c>
<c.magenta>关于使用Core Animation</c>

00:54:39.346 --> 00:54:41.415 align:middle line:90%,end
<c.magenta>实现其中一些很有意思的效果的</c>
<c.magenta>几点小贴士和小诀窍</c>

00:54:41.481 --> 00:54:43.750 align:middle line:90%,end
<c.magenta>与在触控条中所应用的一样</c>

00:54:45.185 --> 00:54:46.053 align:middle line:90%,end
<c.magenta>好了 演讲到此结束</c>

00:54:46.153 --> 00:54:48.455 align:middle line:90%,end
<c.magenta>希望大家度过一个美好的WWDC</c>

00:54:48.822 --> 00:54:49.656 align:middle line:90%,end
<c.magenta>谢谢大家</c>
