WEBVTT

00:00:19.353 --> 00:00:23.090 align:middle
Apple TV游戏输入控制

00:00:27.094 --> 00:00:27.928 align:middle
谢谢大家

00:00:27.995 --> 00:00:32.366 align:middle
大家好 欢迎参加Apple TV
游戏输入控制研讨会

00:00:32.900 --> 00:00:36.103 align:middle
我是JJ Cwik
游戏技术软件工程师

00:00:38.305 --> 00:00:41.241 align:middle
我们在去年九月
重新引入了Apple TV

00:00:41.308 --> 00:00:43.644 align:middle
并且提到了10英尺体验

00:00:44.244 --> 00:00:46.947 align:middle
这作为一种共享的公众体验

00:00:47.381 --> 00:00:50.584 align:middle
是真正适合游戏设置中
较长的会话的体验

00:00:51.385 --> 00:00:52.719 align:middle
事实是

00:00:52.786 --> 00:00:55.455 align:middle
人们就喜欢在客厅玩儿游戏

00:00:56.156 --> 00:00:57.824 align:middle
Apple TV无疑是理想选择

00:00:58.358 --> 00:01:00.194 align:middle
Apple TV为你提供所需工具

00:00:58.358 --> 00:01:00.194 align:middle
Apple TV为你提供所需工具

00:01:00.260 --> 00:01:02.696 align:middle
创建引人注目的游戏体验

00:01:03.597 --> 00:01:07.334 align:middle
今天 我很高兴地跟大家
一起探讨Siri Remote、

00:01:07.734 --> 00:01:11.805 align:middle
MFi游戏控制器以及如何完美地
将两者整合到游戏中

00:01:13.373 --> 00:01:18.078 align:middle
在我开始为大家剧透之前 先来看看
tvOS 10里增加了什么新特性

00:01:18.679 --> 00:01:20.013 align:middle
正如你们在本周一所了解的

00:01:20.981 --> 00:01:25.686 align:middle
有些游戏不是Siri Remote
支持的高级游戏机制

00:01:26.019 --> 00:01:33.026 align:middle
这些游戏可以把需要游戏控制器
的需求选择性地包含进来

00:01:34.661 --> 00:01:38.899 align:middle
现在 我们最多能支持四个
MFi游戏控制器

00:01:39.166 --> 00:01:41.535 align:middle
这对于多玩家游戏来说
无疑是个好消息

00:01:42.903 --> 00:01:46.740 align:middle
我们还在本周一发布了一个
Apple TV遥控器应用

00:01:47.207 --> 00:01:49.610 align:middle
用于控制Apple TV

00:01:50.077 --> 00:01:52.412 align:middle
并充当游戏输入设备

00:01:53.146 --> 00:01:55.649 align:middle
我将在本场研讨会中逐一谈到以上几点

00:01:55.716 --> 00:01:56.750 align:middle
好了 让我们开始吧

00:01:58.752 --> 00:02:00.687 align:middle line:1
tvOS上的应用

00:01:58.752 --> 00:02:00.687 align:middle line:1
tvOS上的应用

00:02:01.655 --> 00:02:04.091 align:middle line:1
一般是从聚焦引擎 获取输入数据

00:02:05.225 --> 00:02:09.696 align:middle line:1
或从触摸和手势中

00:02:10.464 --> 00:02:12.533 align:middle
但还有第三种方式

00:02:12.599 --> 00:02:15.936 align:middle
即从Siri遥控器 直接读取输入

00:02:16.003 --> 00:02:19.006 align:middle
和使用游戏控制器框架的游戏控制器上

00:02:20.774 --> 00:02:24.044 align:middle
现在我简要描述一下游戏控制器框架

00:02:24.111 --> 00:02:25.913 align:middle
你们中可能有人没接触过它

00:02:26.647 --> 00:02:29.116 align:middle
游戏控制器框架最初

00:02:29.183 --> 00:02:32.452 align:middle
用于将第三方游戏控制器植入到游戏中

00:02:33.020 --> 00:02:36.423 align:middle
我们把这些兼容的游戏控制器
叫做MFi控制器

00:02:37.391 --> 00:02:39.193 align:middle
自从框架更新后

00:02:39.259 --> 00:02:41.461 align:middle
框架也支持Siri遥控器了

00:02:43.564 --> 00:02:47.768 align:middle
游戏控制器框架是一个标准化的
简单API

00:02:47.835 --> 00:02:52.873 align:middle
可以获取所有控制器并使用
相同的API调用

00:02:52.940 --> 00:02:55.409 align:middle
而无论控制器的供应商是谁

00:02:56.743 --> 00:02:59.046 align:middle
它使控制器的检测变得标准化

00:03:00.047 --> 00:03:03.183 align:middle
它会 无缝处理控制器的连接和断开

00:03:03.250 --> 00:03:04.618 align:middle
在游戏运行时

00:03:05.552 --> 00:03:08.021 align:middle
并允许你控制输入

00:03:08.088 --> 00:03:10.591 align:middle
更确切地说是从控制器中读取输入

00:03:10.657 --> 00:03:12.960 align:middle
用轮询或事件驱动模型

00:03:14.194 --> 00:03:18.932 align:middle
这在tvOS、iOS和
MacOS上都能用

00:03:19.666 --> 00:03:22.736 align:middle
所以 虽然这场演讲是面向tvOS的

00:03:22.803 --> 00:03:27.307 align:middle
但是大量代码和概念
都能用在iOS和macOS上

00:03:29.343 --> 00:03:32.079 align:middle
现在你应该对框架有了大概的了解

00:03:32.145 --> 00:03:34.615 align:middle
我再具体说一下

00:03:35.716 --> 00:03:36.984 align:middle
有一个核心类

00:03:37.050 --> 00:03:39.553 align:middle
在游戏控制器框架中
叫GCController

00:03:39.853 --> 00:03:41.755 align:middle
这代表着实物控制器...

00:03:42.389 --> 00:03:44.591 align:middle
Siri遥控器 也是用这个类

00:03:44.658 --> 00:03:46.260 align:middle
和MFi游戏控制器

00:03:48.061 --> 00:03:51.231 align:middle
在应用中 你最想做的第一件事可能

00:03:51.632 --> 00:03:54.268 align:middle
就是获得一份当前所有
已连接的控制器的列表

00:03:54.635 --> 00:03:59.072 align:middle
你就得在GCController中
使用控制器的类方法

00:03:59.606 --> 00:04:02.709 align:middle
这会返回一份当前已连接的控制器列表

00:03:59.606 --> 00:04:02.709 align:middle
这会返回一份当前已连接的控制器列表

00:04:02.776 --> 00:04:05.078 align:middle
是GCController实例数组

00:04:05.779 --> 00:04:08.215 align:middle
如果没有的话 就返回一个空数组

00:04:10.717 --> 00:04:13.987 align:middle
控制器连接和断开是常事儿

00:04:14.054 --> 00:04:15.455 align:middle
在应用运行时

00:04:16.690 --> 00:04:19.793 align:middle
要想知道什么时候连接和断开
就需要 添加观察者

00:04:19.860 --> 00:04:23.830 align:middle
给GCCcontrollerDidConnect
Notification

00:04:23.897 --> 00:04:26.533 align:middle
和GCControllerDidDisconnect
Notification

00:04:27.568 --> 00:04:29.102 align:middle
理想位置是在

00:04:29.169 --> 00:04:32.172 align:middle
应用的Did Finish Launching
with Options中添加

00:04:34.241 --> 00:04:36.310 align:middle
我们现已知道哪些控制器已连接

00:04:36.376 --> 00:04:39.012 align:middle
我要把重心转移到Siri遥控器上来

00:04:39.546 --> 00:04:43.317 align:middle
Siri遥控器 作为游戏控制器
充当游戏触摸表面

00:04:43.383 --> 00:04:45.786 align:middle
通过我刚提到的
GCController类

00:04:47.120 --> 00:04:50.858 align:middle
在游戏控制器框架中
有这种profile的概念

00:04:50.924 --> 00:04:54.127 align:middle
以及profiles集合的常见功能

00:04:54.561 --> 00:04:56.730 align:middle
Siri遥控器支持
这两种profile

00:04:57.397 --> 00:05:00.367 align:middle
第一个profile
叫GCMicroGamepad

00:04:57.397 --> 00:05:00.367 align:middle
第一个profile
叫GCMicroGamepad

00:05:00.868 --> 00:05:03.537 align:middle
用于操作触摸表面

00:05:03.604 --> 00:05:05.672 align:middle
和Siri 遥控器上的按钮

00:05:07.074 --> 00:05:12.045 align:middle
Siri遥控器支持的第二个
profile叫GCMotion

00:05:12.579 --> 00:05:15.082 align:middle
用于 获得陀螺仪

00:05:15.148 --> 00:05:17.251 align:middle
和加速计 在Siri 遥控器上

00:05:18.118 --> 00:05:21.655 align:middle
请注意 跟iOS上的习惯不一样

00:05:21.989 --> 00:05:24.525 align:middle
在iOS上 动作通过
CoreMotion框架表达

00:05:25.726 --> 00:05:29.062 align:middle
而在tvOS上 动作通过
游戏控制器框架表达

00:05:30.297 --> 00:05:32.633 align:middle
那么 让我们依次看一下
每种profile

00:05:33.166 --> 00:05:35.502 align:middle
首先是GCMicroGamepad

00:05:37.971 --> 00:05:40.274 align:middle
Siri遥控器上的触摸表面

00:05:40.340 --> 00:05:44.011 align:middle
会作为各种虚拟DPAD
在游戏中体现出来

00:05:44.645 --> 00:05:49.850 align:middle
你可以用模拟表示法来
查询DPAD的值

00:05:49.917 --> 00:05:51.652 align:middle
是一个XY坐标对

00:05:52.152 --> 00:05:57.524 align:middle
或一种数码输入 基本上有四个按钮
分别是上、下、左、右

00:06:00.994 --> 00:06:04.097 align:middle
GCMicroGamepad
profile还有一A按钮

00:06:04.164 --> 00:06:06.433 align:middle
相当于点击遥控器

00:06:07.000 --> 00:06:10.537 align:middle
这个非常适合作为游戏的原始动作

00:06:10.604 --> 00:06:13.574 align:middle
尤其是当竖着拿着遥控器时

00:06:16.009 --> 00:06:18.212 align:middle
并且这个profile
还有一个X按钮

00:06:18.812 --> 00:06:21.615 align:middle
这个作为游戏中的第二个
动作很有帮助

00:06:22.316 --> 00:06:25.853 align:middle
而且当遥控器朝侧面倾斜
很自然地

00:06:25.919 --> 00:06:29.923 align:middle
和横向拿着时 大拇指一般会
放在触摸表面上

00:06:29.990 --> 00:06:31.992 align:middle
并且另一个大拇指会
放在X按钮上

00:06:33.794 --> 00:06:36.797 align:middle
请注意 这个遥控器上还有一个
菜单按钮

00:06:37.231 --> 00:06:39.166 align:middle
我们稍后会再谈

00:06:39.867 --> 00:06:43.403 align:middle
遥控器上的其它按钮将留作
系统使用

00:06:46.673 --> 00:06:48.876 align:middle
这里有段示例代码 演示有多么简单

00:06:48.942 --> 00:06:50.711 align:middle
从按钮中读取数据

00:06:51.411 --> 00:06:55.415 align:middle
在这里 我们看到
已经连接了一个控制器

00:06:55.983 --> 00:06:59.019 align:middle
这样我们就可以从MicroGamepad
profile中读取数据了

00:06:59.786 --> 00:07:02.956 align:middle
MicroGamepad profile存储了
A按钮和X按钮属性

00:06:59.786 --> 00:07:02.956 align:middle
MicroGamepad profile存储了
A按钮和X按钮属性

00:07:03.257 --> 00:07:05.959 align:middle
我们只看一下isPressed属性

00:07:06.026 --> 00:07:08.762 align:middle
这个属性将确定是否按了
这些按钮

00:07:10.030 --> 00:07:12.299 align:middle
我们还支持一种事件驱动模型

00:07:12.733 --> 00:07:14.001 align:middle
所以 如果你想得知

00:07:14.067 --> 00:07:17.604 align:middle
是什么时候按下按钮的 若不想做轮询
你可以使用事件驱动模型

00:07:19.006 --> 00:07:21.275 align:middle
这些叫做pressedChangeHandler

00:07:21.708 --> 00:07:25.479 align:middle
这个代码块会在按钮变更状态时运行

00:07:26.246 --> 00:07:29.016 align:middle
通常来说按下按钮的通知会被调用两次

00:07:29.082 --> 00:07:31.985 align:middle
一次是按下去 一次是弹起来

00:07:33.387 --> 00:07:34.555 align:middle
以上说的是按钮

00:07:34.621 --> 00:07:35.956 align:middle
现在让我们来看DPAD

00:07:36.823 --> 00:07:40.994 align:middle
我刚才说过 DPAD可读取四个按钮
分别是上、下、左、右

00:07:41.061 --> 00:07:43.530 align:middle
有意思的是 还有另外种陈述

00:07:43.597 --> 00:07:46.266 align:middle
是两个坐标轴 X轴和Y轴

00:07:46.600 --> 00:07:47.668 align:middle
现在让我们来看一下

00:07:49.436 --> 00:07:52.406 align:middle
你可看到MicroGamepad上
有一个DPAD属性

00:07:52.873 --> 00:07:55.409 align:middle
有X轴和Y轴两个属性

00:07:55.909 --> 00:07:57.711 align:middle
我们可以读取这两个属性的值

00:07:57.778 --> 00:08:02.049 align:middle
并返回一个浮动的标准值在0或 抱歉

00:07:57.778 --> 00:08:02.049 align:middle
并返回一个浮动的标准值在0或 抱歉

00:08:02.115 --> 00:08:05.018 align:middle
在负1和正1之间的标准值

00:08:06.620 --> 00:08:09.556 align:middle
正如你所期待的那样
我们还有个事件回调可用

00:08:09.623 --> 00:08:13.460 align:middle
请注意 在这种情况下
我们使用了值变更处理器

00:08:13.527 --> 00:08:15.062 align:middle
或我们提供了一值变更处理器

00:08:15.128 --> 00:08:18.732 align:middle
在DPAD上 而不是在X轴和Y轴上

00:08:18.899 --> 00:08:23.537 align:middle
这是因为我们想在任何一个轴
发生变化时都得到通知

00:08:26.206 --> 00:08:29.743 align:middle
DAPD遥控器有一些很有意思的地方

00:08:29.810 --> 00:08:31.445 align:middle
我想具体谈一下

00:08:38.452 --> 00:08:40.921 align:middle
第一个是DPAD开窗

00:08:41.621 --> 00:08:43.490 align:middle
这是什么呢 这实际是定义

00:08:43.557 --> 00:08:47.027 align:middle
DAPD的X轴和Y轴的原点

00:08:48.095 --> 00:08:51.198 align:middle
现在你可能会想
原点不应该总是在中心吗

00:08:51.265 --> 00:08:54.401 align:middle
很多时候 这个问题的答案是
不见得

00:08:54.935 --> 00:08:57.671 align:middle
很多时候 玩家并不会太关注

00:08:57.738 --> 00:09:01.175 align:middle
他们在触摸表面上正在触摸的精确位置

00:08:57.738 --> 00:09:01.175 align:middle
他们在触摸表面上正在触摸的精确位置

00:09:01.241 --> 00:09:04.178 align:middle
他们只是想把大拇指放在
触摸表面上并相对 移动

00:09:04.244 --> 00:09:05.846 align:middle
于他们最开始触摸的地方

00:09:06.346 --> 00:09:08.248 align:middle
DAPD开窗允许你

00:09:08.315 --> 00:09:11.018 align:middle
作为游戏开发者去挖掘这个相对动作

00:09:11.451 --> 00:09:15.422 align:middle
因此会在触摸表面上的
初始触摸点创建一个原点

00:09:15.489 --> 00:09:20.093 align:middle
然后 从那之后的进一步移动
会有一个DAPD值报告给

00:09:20.160 --> 00:09:22.196 align:middle
相对于原点的 游戏

00:09:22.863 --> 00:09:24.298 align:middle
让我们举例解释一下

00:09:25.399 --> 00:09:28.235 align:middle
这是触摸表面
我把我的大拇指按在这儿

00:09:28.435 --> 00:09:31.305 align:middle
请注意 我并没按在触摸表面的正中央

00:09:32.005 --> 00:09:34.041 align:middle
但启用DPAD开窗以后

00:09:34.675 --> 00:09:39.079 align:middle
这里将作为X轴和Y轴的原点

00:09:39.680 --> 00:09:42.883 align:middle
请注意 有一个虚构的DPAD窗口

00:09:42.950 --> 00:09:45.586 align:middle
位于以原点为中心的区域的外部

00:09:46.386 --> 00:09:49.323 align:middle
请看 当我的拇指划过
触摸表面时会发生什么

00:09:51.391 --> 00:09:54.761 align:middle
报告给游戏的值是相对于这个原点的

00:09:54.828 --> 00:09:57.197 align:middle
并跟窗口的尺寸成一定比例

00:09:57.898 --> 00:10:01.502 align:middle
现在 我继续在触摸表面移动拇指

00:09:57.898 --> 00:10:01.502 align:middle
现在 我继续在触摸表面移动拇指

00:10:01.568 --> 00:10:05.005 align:middle
会同时拖动窗口和两个轴一起移动

00:10:06.306 --> 00:10:09.009 align:middle
现在 我们已经建立了一个新原点

00:10:09.076 --> 00:10:11.845 align:middle
在触摸表面上的进一步的移动

00:10:11.912 --> 00:10:15.482 align:middle
都会有相对于这个新原点的
DPAD值报告给游戏

00:10:16.116 --> 00:10:17.518 align:middle
这就是DPAD开窗

00:10:18.652 --> 00:10:21.588 align:middle
如果你想始终接收DPAD的绝对值

00:10:21.655 --> 00:10:26.059 align:middle
你可以使用
reportsAbsoluteDpadValues属性

00:10:26.593 --> 00:10:27.928 align:middle
将它设为真

00:10:28.762 --> 00:10:30.564 align:middle
这样我们总是能将原点

00:10:30.631 --> 00:10:33.300 align:middle
定位在触摸表面的正中央

00:10:34.034 --> 00:10:37.337 align:middle
然后 我按下拇指并在触摸表面上移动

00:10:37.404 --> 00:10:39.573 align:middle
所有值都是相对于

00:10:39.640 --> 00:10:41.742 align:middle
触摸表面的正中心的

00:10:43.143 --> 00:10:44.511 align:middle
那么这就是DPAD开窗

00:10:49.249 --> 00:10:50.651 align:middle
下一个讲旋转

00:10:51.852 --> 00:10:54.454 align:middle
游戏的DPAD值

00:10:54.521 --> 00:10:59.793 align:middle
是以纵向为前提的 意思就是
当X轴向右 Y轴向上时

00:11:00.827 --> 00:11:02.296 align:middle
但是 这可能会导致一个问题

00:11:02.362 --> 00:11:05.165 align:middle
如果玩家想横向玩儿呢？

00:11:05.699 --> 00:11:09.303 align:middle
在这种情况下
你的游戏就需要调换这些值

00:11:09.703 --> 00:11:11.805 align:middle
使游戏在横向时也能正常运行

00:11:12.673 --> 00:11:16.210 align:middle
但是 如果用户朝相反方向倾斜
遥控器会怎么样呢

00:11:16.276 --> 00:11:19.279 align:middle
你就需要将这些值调换为
相反方向时的值

00:11:20.514 --> 00:11:21.849 align:middle
那么 要如何实现呢

00:11:21.915 --> 00:11:24.351 align:middle
要么就强制用户

00:11:24.418 --> 00:11:26.753 align:middle
始终按指定方位玩儿游戏

00:11:27.221 --> 00:11:29.456 align:middle
要么就得读取加速计数据

00:11:29.523 --> 00:11:31.525 align:middle
并追踪方位变更

00:11:31.925 --> 00:11:33.694 align:middle
但你并不想这么做

00:11:34.161 --> 00:11:37.531 align:middle
所以我们提供了一个叫
allowsRotation的属性

00:11:37.898 --> 00:11:40.300 align:middle
这个属性的默认设置为假

00:11:40.701 --> 00:11:44.638 align:middle
如果把它设为真
那么报告给游戏的DPAD值

00:11:45.005 --> 00:11:48.575 align:middle
会匹配遥控器的任何一种方位

00:11:49.109 --> 00:11:52.546 align:middle
当这个属性设为真
并当遥控器为纵向方位时

00:11:52.613 --> 00:11:54.915 align:middle
X轴向右 Y轴向上

00:11:56.116 --> 00:11:59.486 align:middle
在左横向方位时
X轴向右 Y轴向上

00:12:00.554 --> 00:12:05.192 align:middle
在右横向方位时 你猜对了
X轴向右 Y轴向上

00:12:06.126 --> 00:12:10.097 align:middle
所以 如果你的游戏要允许玩家
在横向方位玩儿游戏

00:12:10.163 --> 00:12:12.065 align:middle
就要把允许旋转设为真

00:12:12.432 --> 00:12:14.835 align:middle
这样你就不用担心方位变更

00:12:14.902 --> 00:12:16.603 align:middle
或需要自己旋转DPAD值了

00:12:18.005 --> 00:12:19.139 align:middle
那么这就是旋转

00:12:19.673 --> 00:12:20.874 align:middle
下一个讲动作

00:12:22.075 --> 00:12:24.945 align:middle
我前面提到过 第二个profile

00:12:25.012 --> 00:12:27.848 align:middle
Siri遥控器支持的
叫GCMotion

00:12:28.882 --> 00:12:31.919 align:middle
当用户移动遥控器时 重力

00:12:31.985 --> 00:12:36.690 align:middle
由GCMotion profile提供
用户加速度矢量中的 就会被更新

00:12:38.091 --> 00:12:41.428 align:middle
请注意 这些值在接触游戏
之前已经被过滤了

00:12:41.695 --> 00:12:43.597 align:middle
那么 如果你有一个tvOS游戏

00:12:43.864 --> 00:12:46.967 align:middle
并且你正在做动作过滤
我们建议你把它移除

00:12:47.034 --> 00:12:50.137 align:middle
这样就不会给游戏造成
任何不必要的滞后

00:12:51.905 --> 00:12:56.176 align:middle
另外 这是混合动作数据
我的意思是

00:12:56.243 --> 00:12:59.947 align:middle
加速计和陀螺仪会 加强

00:13:00.013 --> 00:13:01.114 align:middle
相互 和矫正

00:13:01.682 --> 00:13:05.586 align:middle
就像在iPhone上一样
重力矢量

00:13:05.652 --> 00:13:09.957 align:middle
加速计中的
会矫正陀螺仪中的漂移

00:13:10.757 --> 00:13:12.459 align:middle
并且陀螺仪数据会

00:13:12.526 --> 00:13:15.362 align:middle
使加速计中的值保持顺畅

00:13:15.929 --> 00:13:17.197 align:middle
它们相互增强

00:13:18.098 --> 00:13:20.734 align:middle
实际上
剧烈运动会淹没这种作用

00:13:21.168 --> 00:13:25.405 align:middle
正因为如此 我们建议你
在游戏中避免创建 情境

00:13:25.472 --> 00:13:28.675 align:middle
需要用户剧烈摇动遥控器的

00:13:29.309 --> 00:13:31.912 align:middle
因为这会使数据很难
保持准确性

00:13:31.979 --> 00:13:34.314 align:middle
直到传感器能够找到机会固定下来

00:13:37.050 --> 00:13:39.920 align:middle
接下来 我想说一下菜单按钮

00:13:43.423 --> 00:13:46.159 align:middle
现在 tvOS支持的所有控制器

00:13:46.226 --> 00:13:48.562 align:middle
在游戏控制器框架中
都有一个菜单按钮

00:13:49.162 --> 00:13:52.799 align:middle
跟Siri遥控器 菜单按钮一样
行为也一样

00:13:52.866 --> 00:13:54.902 align:middle
和MFi游戏控制器上的

00:13:58.872 --> 00:14:01.875 align:middle
在tvOS的app中

00:13:58.872 --> 00:14:01.875 align:middle
在tvOS的app中

00:14:01.942 --> 00:14:06.046 align:middle
当按下菜单按钮时 行为变更

00:14:06.113 --> 00:14:07.514 align:middle
是由情境因素决定的

00:14:08.015 --> 00:14:11.351 align:middle
有时候按菜单按钮会最小化应用

00:14:11.785 --> 00:14:13.921 align:middle
并返回Apple TV主屏幕

00:14:15.489 --> 00:14:17.824 align:middle
通常是在游戏的主菜单中实现的

00:14:18.692 --> 00:14:22.663 align:middle
而其他时候按菜单按钮会返回 上一级

00:14:22.729 --> 00:14:25.632 align:middle
应用菜单级的

00:14:25.699 --> 00:14:27.668 align:middle
通常是在子菜单中实现的

00:14:30.237 --> 00:14:33.874 align:middle
最后 有时候按菜单按钮会暂停

00:14:33.941 --> 00:14:35.976 align:middle
或重新开始激活的游戏设置

00:14:38.979 --> 00:14:43.650 align:middle
非游戏应用完全是在UIKit中
进行编码的

00:14:44.084 --> 00:14:47.888 align:middle
在很大程度上 会毫不费力地得到
前两种行为 而不用做任何额外的工作

00:14:48.889 --> 00:14:54.428 align:middle
但是对于大多数游戏来说 由于有
自定义UI 必须做一些额外的工作

00:14:54.494 --> 00:14:56.396 align:middle
来向系统传达它们的意图

00:14:57.164 --> 00:14:58.131 align:middle
让我具体解释一下

00:15:00.667 --> 00:15:05.439 align:middle line:1
在UIKit中
当按下UIKit应用的菜单按钮时

00:15:05.506 --> 00:15:08.141 align:middle line:1
会使子视图控制器突然离开堆栈

00:15:08.408 --> 00:15:11.478 align:middle line:1
这就使你返回菜单的上一级

00:15:12.546 --> 00:15:16.884 align:middle line:1
你可以依次执行 每次按下菜单按钮

00:15:16.950 --> 00:15:19.386 align:middle line:1
使子视图控制器突然离开堆栈

00:15:19.453 --> 00:15:22.356 align:middle line:1
然后在某一时刻
你只有一个视图控制器了

00:15:22.422 --> 00:15:24.491 align:middle
就是你的根视图控制器
它会留在堆栈中

00:15:25.526 --> 00:15:27.995 align:middle line:1
当堆栈中只有一个视图控制器时

00:15:28.061 --> 00:15:30.898 align:middle line:1
下一次按下菜单按钮时
会最小化应用

00:15:30.964 --> 00:15:33.433 align:middle line:1
并使你返回Apple TV的主屏幕

00:15:35.002 --> 00:15:38.405 align:middle line:1
相比之下
大部分游戏的结构都不一样

00:15:38.739 --> 00:15:42.543 align:middle line:1
通常游戏中的UI都是自定义的
这并不是在UIKit中进行编码的

00:15:43.243 --> 00:15:45.646 align:middle line:1
并且游戏一般有 场景转换

00:15:45.712 --> 00:15:49.917 align:middle line:1
不同部分之间的
这也不能在UIKit中进行编码

00:15:52.119 --> 00:15:55.155 align:middle line:1
正因为如此 它们一般能 被释放

00:15:55.222 --> 00:15:57.925 align:middle line:1
通过只剩一个视图控制器
即根视图控制器

00:15:57.991 --> 00:15:59.760 align:middle line:1
在游戏的整个持续过程中

00:16:00.294 --> 00:16:02.162 align:middle line:1
但按照我们刚说的规则

00:16:02.229 --> 00:16:06.133 align:middle line:1
因为在堆栈中只有一个视图控制器
那么在游戏的各个层面上

00:16:06.200 --> 00:16:08.936 align:middle
按菜单按钮将默认弹回

00:16:09.002 --> 00:16:10.270 align:middle
Apple TV主屏幕

00:16:10.871 --> 00:16:13.707 align:middle
那么你就需要某种方式向系统传达

00:16:13.774 --> 00:16:15.943 align:middle
何时按菜单按钮

00:16:16.009 --> 00:16:19.379 align:middle
返回Apple TV主屏幕及何时
按菜单按钮不返回Apple TV主屏幕

00:16:21.014 --> 00:16:23.483 align:middle
进入GCEventViewController

00:16:28.055 --> 00:16:31.692 align:middle
这是一个为单一玩家
创建的特殊视图控制器

00:16:31.758 --> 00:16:35.696 align:middle
或更准确地说 是为有单一视图
控制器的游戏控制器游戏

00:16:36.997 --> 00:16:38.866 align:middle
如果你正在做的就是这种游戏

00:16:39.199 --> 00:16:42.603 align:middle
你应该把这个特殊视图控制器
设为你的根视图控制器

00:16:44.271 --> 00:16:46.540 align:middle
这个视图控制器有一个属性叫

00:16:46.607 --> 00:16:48.775 align:middle
controllerUserInteractionEnabled

00:16:48.842 --> 00:16:51.245 align:middle
这是控制 的关键

00:16:51.311 --> 00:16:54.815 align:middle
什么时候按菜单按钮返回主屏幕的

00:16:56.717 --> 00:16:59.419 align:middle
当它的值为假时
这个视图控制器会有效地

00:16:59.486 --> 00:17:01.088 align:middle
截止按下菜单按钮这个行为

00:16:59.486 --> 00:17:01.088 align:middle
截止按下菜单按钮这个行为

00:17:01.154 --> 00:17:03.824 align:middle
并阻止它们建立响应链

00:17:03.891 --> 00:17:05.692 align:middle
从而有效地让你继续待在应用中

00:17:07.728 --> 00:17:11.131 align:middle
偶尔也可用来调用控制器暂停处理器

00:17:11.198 --> 00:17:12.699 align:middle
我们稍后会讲到

00:17:13.634 --> 00:17:15.801 align:middle
当这个值设为真时

00:17:17.137 --> 00:17:19.740 align:middle
菜单按钮事件就会 继续建立

00:17:19.806 --> 00:17:21.842 align:middle
响应链 像平常一样

00:17:22.709 --> 00:17:24.344 align:middle
这时应用会被最小化

00:17:24.411 --> 00:17:26.480 align:middle
并返回Apple TV主屏幕

00:17:27.414 --> 00:17:30.450 align:middle
你作为游戏开发者
你的工作是管理 状态

00:17:30.517 --> 00:17:32.553 align:middle
controllerUser
InteractionEnabled的

00:17:32.619 --> 00:17:35.556 align:middle
当用户在游戏的不同部分
后退和前进时

00:17:36.190 --> 00:17:37.824 align:middle
我要给你们看一个方块图

00:17:38.125 --> 00:17:40.994 align:middle
那么在Apple TV的主屏幕
我们启动应用

00:17:41.495 --> 00:17:45.232 align:middle
有些游戏有启动画面
而有些则是游戏介绍

00:17:45.299 --> 00:17:49.870 align:middle
但最终 很多游戏都会在
游戏内部的主菜单着陆

00:17:50.470 --> 00:17:53.373 align:middle
无论是哪一种 用户的期望是

00:17:53.440 --> 00:17:55.676 align:middle
当按菜单按钮时 它们会立即返回

00:17:55.742 --> 00:17:57.578 align:middle
Apple TV的主屏幕

00:17:58.245 --> 00:18:01.448 align:middle
因此 要把controller
UserInteractionEnabled设为真

00:17:58.245 --> 00:18:01.448 align:middle
因此 要把controller
UserInteractionEnabled设为真

00:18:02.382 --> 00:18:04.852 align:middle
当用户继续游戏的其他部分时

00:18:04.918 --> 00:18:07.321 align:middle
比如激活的游戏设置或在子菜单中

00:18:07.821 --> 00:18:10.757 align:middle
用户的期望是按菜单按钮后

00:18:10.824 --> 00:18:13.560 align:middle
不返回Apple TV的主屏幕

00:18:13.627 --> 00:18:14.561 align:middle
那么在这些情况下

00:18:14.628 --> 00:18:17.364 align:middle
就把controllerUser
InteractionEnabled设为假

00:18:17.998 --> 00:18:21.235 align:middle
如果用户再回到
游戏内部的主菜单

00:18:21.301 --> 00:18:23.270 align:middle
要记得把这个值再设为真

00:18:25.205 --> 00:18:26.874 align:middle
这就是我们的第一个行为

00:18:26.940 --> 00:18:30.010 align:middle
即何时返回Apple TV主屏幕
及何时不返回Apple TV主屏幕

00:18:30.344 --> 00:18:32.012 align:middle
我们还有另外两个行为

00:18:32.079 --> 00:18:35.082 align:middle
我们需要考虑返回子菜单

00:18:35.148 --> 00:18:37.150 align:middle
以及暂停和重新开始激活的游戏设置

00:18:37.518 --> 00:18:40.120 align:middle
基本上就是这个图解中颜色较暗的框

00:18:41.121 --> 00:18:45.225 align:middle
好消息是 这些都是在
controllerPausedHandler中得到处理的

00:18:46.360 --> 00:18:50.230 align:middle
controllerPausedHandler
是一个代码块 你要提供给

00:18:50.764 --> 00:18:54.168 align:middle
控制器
或者不如说是每个控制器

00:18:54.334 --> 00:18:57.104 align:middle
这个代码块会在
按菜单按钮时运行

00:18:57.171 --> 00:18:59.973 align:middle
并不会把你带回
Apple TV主屏幕

00:19:00.807 --> 00:19:04.344 align:middle
用这个代码块检测是个很简单的事儿

00:19:04.411 --> 00:19:08.949 align:middle
你是否在子菜单中需要返回上一级菜单

00:19:09.550 --> 00:19:12.352 align:middle
如果你在激活的游戏设置中
就触发暂停状态

00:19:13.320 --> 00:19:17.624 align:middle
就这么简单 现在
按菜单按钮的行为处理地都很得当了

00:19:17.691 --> 00:19:19.526 align:middle
无论是在游戏的哪个位置

00:19:25.032 --> 00:19:27.568 align:middle
现在让我们来谈谈
MFi游戏控制器

00:19:28.268 --> 00:19:31.471 align:middle
有些游戏可以充分利用
扩展控制

00:19:31.538 --> 00:19:34.174 align:middle
由无线扩展手柄提供的

00:19:34.575 --> 00:19:37.177 align:middle
并且这些是玩家
可能会持有的可选附件

00:19:38.011 --> 00:19:42.015 align:middle
说到扩展 我们指的是控制布局

00:19:42.082 --> 00:19:44.418 align:middle
而且很可能是你已经
很熟悉的布局

00:19:44.885 --> 00:19:46.820 align:middle
左侧有一个DPAD

00:19:47.087 --> 00:19:48.755 align:middle
四个面板按钮

00:19:48.822 --> 00:19:51.992 align:middle
以A、B、X、Y出现在这些位置

00:19:52.059 --> 00:19:53.760 align:middle
右侧有 菱形布局

00:19:54.428 --> 00:19:57.231 align:middle
控制器的前方有两个摇杆

00:19:57.631 --> 00:20:00.100 align:middle
顶部有两个肩部按钮和两个触发器

00:19:57.631 --> 00:20:00.100 align:middle
顶部有两个肩部按钮和两个触发器

00:20:01.134 --> 00:20:03.570 align:middle
目前我提到的所有按钮

00:20:04.004 --> 00:20:06.840 align:middle
都是压敏性按钮 我稍后再详细解释

00:20:07.641 --> 00:20:10.944 align:middle
还有刚讨论过的菜单按钮

00:20:11.011 --> 00:20:13.180 align:middle
以及四盏LED玩家指示器

00:20:14.982 --> 00:20:19.119 align:middle
就像Siri遥控器支持
GCMicroGamepad一样

00:20:20.420 --> 00:20:24.491 align:middle
扩展游戏控制器支持
GCExtendedGamepad profile

00:20:25.158 --> 00:20:28.662 align:middle
你会注意到
左侧有一个表列出了所有属性

00:20:29.496 --> 00:20:33.033 align:middle
还要注意数据类型
GCControllerDirectionPad

00:20:33.100 --> 00:20:35.202 align:middle
和GCControllerButtonInput

00:20:35.269 --> 00:20:38.038 align:middle
这两个跟你在Siri遥控器上
所使用的数据类型相同

00:20:39.106 --> 00:20:41.742 align:middle
有一点我想单独说一下
就是DPAD

00:20:41.808 --> 00:20:44.745 align:middle
和按钮以及这个表上的
任何一个输入

00:20:44.811 --> 00:20:46.780 align:middle
实际上都是压敏性的

00:20:47.314 --> 00:20:52.052 align:middle
所以 即使我们通常认为这些按钮
和输入只是一些数字

00:20:52.419 --> 00:20:54.521 align:middle
在你可能见过的其它控制器中

00:20:54.588 --> 00:20:57.457 align:middle
像DPAD和面板按钮以及肩部按钮

00:20:57.958 --> 00:20:59.493 align:middle
都是压敏性的

00:20:59.560 --> 00:21:02.429 align:middle
因此可以从模拟感应器
和数字感应器中读取

00:20:59.560 --> 00:21:02.429 align:middle
因此可以从模拟感应器
和数字感应器中读取

00:21:03.664 --> 00:21:06.633 align:middle
让我们看一下那个模拟数字对偶的代码

00:21:07.234 --> 00:21:09.603 align:middle
以A按钮为例 第一行是

00:21:09.670 --> 00:21:13.373 align:middle
获取是否按了按钮的数字状态

00:21:13.740 --> 00:21:16.543 align:middle
所以如果你的游戏只在指定情况下

00:21:16.610 --> 00:21:19.513 align:middle
关注是否按了一个按钮
你可以使用这行代码来解决

00:21:21.114 --> 00:21:24.151 align:middle
然而 若你关注用了多大力度去按按钮

00:21:24.785 --> 00:21:26.653 align:middle
那就要使用值属性了

00:21:27.287 --> 00:21:29.890 align:middle
这可以给你的游戏添加
更多的细微控制 效果很好

00:21:30.424 --> 00:21:32.292 align:middle
也许你正在创建一款运动游戏

00:21:32.359 --> 00:21:35.429 align:middle
并且允许玩家改变传递的速度

00:21:35.495 --> 00:21:38.699 align:middle
从轻轻地传递到快速地传递

00:21:38.765 --> 00:21:41.969 align:middle
你可以通过读取按按钮的力度来实现

00:21:42.035 --> 00:21:43.170 align:middle
值属性

00:21:44.838 --> 00:21:47.808 align:middle
正如你所期待的
我们还提供事件回调函数

00:21:48.275 --> 00:21:50.277 align:middle
请注意有一个
pressedChangeHandler

00:21:50.344 --> 00:21:52.446 align:middle
是响应按压属性的

00:21:52.513 --> 00:21:55.249 align:middle
用于变更布尔状态或数字状态

00:21:55.816 --> 00:21:59.119 align:middle
还有一个值变更属性用于响应值或

00:21:59.620 --> 00:22:03.457 align:middle
抱歉 一个值变更处理器
用于响应值属性

00:21:59.620 --> 00:22:03.457 align:middle
抱歉 一个值变更处理器
用于响应值属性

00:22:04.625 --> 00:22:09.296 align:middle
一般来说 按一次按钮
会多次调用值变更处理器

00:22:09.363 --> 00:22:13.333 align:middle
因为按钮要被按下去
然后再弹回来

00:22:14.368 --> 00:22:15.869 align:middle
而对于想寻求指导的你们来说

00:22:15.936 --> 00:22:18.372 align:middle
是否使用轮询或事件回调

00:22:18.939 --> 00:22:23.010 align:middle
并没有硬性规定 但轮询有利于

00:22:23.076 --> 00:22:27.347 align:middle
读取那些在较长时间内持续变更的输入

00:22:27.748 --> 00:22:30.184 align:middle
也许就像赛车游戏中的加速器

00:22:30.250 --> 00:22:32.586 align:middle
被关联到按钮触发器

00:22:32.653 --> 00:22:35.022 align:middle
或游戏控制器的触发器上

00:22:36.523 --> 00:22:39.826 align:middle
事件回调有利于

00:22:40.360 --> 00:22:42.963 align:middle
处理按钮的边缘过度

00:22:43.163 --> 00:22:46.567 align:middle
比如你有一款冒险游戏
玩家挥舞自己的宝剑

00:22:47.034 --> 00:22:49.336 align:middle
如果你想 激活挥舞宝剑的动画

00:22:49.403 --> 00:22:50.971 align:middle
在按按钮的瞬间

00:22:51.071 --> 00:22:52.673 align:middle
那就要用到事件回调了
非常好用

00:22:55.976 --> 00:22:58.745 align:middle
在这点上 你可能大概了解了

00:22:58.812 --> 00:23:03.450 align:middle
连接和读取输入的机制

00:22:58.812 --> 00:23:03.450 align:middle
连接和读取输入的机制

00:23:03.517 --> 00:23:05.519 align:middle
从Siri遥控器和游戏控制器中

00:23:06.253 --> 00:23:07.454 align:middle
且你很可能会开始思考

00:23:07.521 --> 00:23:10.023 align:middle
你的游戏要支持哪种控制类型

00:23:10.757 --> 00:23:12.526 align:middle
要不要只支持Siri遥控器

00:23:13.827 --> 00:23:17.364 align:middle
还是Siri遥控器
和MFi游戏控制器都支持？

00:23:19.533 --> 00:23:21.101 align:middle
如你们在本周一所了解到的信息

00:23:21.768 --> 00:23:26.373 align:middle
Siri遥控器不支持的
高级游戏机制的游戏

00:23:26.874 --> 00:23:29.543 align:middle
可以要求使用游戏控制器

00:23:39.052 --> 00:23:42.990 align:middle
那么指定游戏支持哪种控制器类型

00:23:43.056 --> 00:23:44.224 align:middle
是在Xcode中实现

00:23:45.826 --> 00:23:48.962 align:middle
在你的目标设定中有个功能选项卡

00:23:49.196 --> 00:23:51.498 align:middle
能在这个选项卡中发现游戏控制器功能

00:23:51.832 --> 00:23:53.333 align:middle
启用这个功能

00:23:53.901 --> 00:23:56.904 align:middle
并选择游戏所支持的控制器类型

00:23:58.038 --> 00:24:01.642 align:middle
与这个GUI的交互将改变键和值

00:23:58.038 --> 00:24:01.642 align:middle
与这个GUI的交互将改变键和值

00:24:01.708 --> 00:24:04.344 align:middle
相应info.plist文件中的

00:24:06.213 --> 00:24:08.749 align:middle
这对于应用介绍页面来说很重要
因为 所有游戏

00:24:08.815 --> 00:24:11.919 align:middle
链接了游戏控制器框架的 都会

00:24:13.153 --> 00:24:15.923 align:middle
更精确地说
都会在应用介绍页面中找到这些键

00:24:15.989 --> 00:24:18.192 align:middle
链接了游戏控制器框架的所有游戏的

00:24:19.259 --> 00:24:22.129 align:middle
真正涉及到的是App Store

00:24:22.196 --> 00:24:25.899 align:middle
因为你的用户们将在
App Store中获知

00:24:25.966 --> 00:24:28.836 align:middle
游戏是否支持游戏控制器

00:24:28.902 --> 00:24:30.604 align:middle
或需要游戏控制器

00:24:31.638 --> 00:24:35.375 align:middle
此外 用户可能会收到警告
如果他们尝试

00:24:35.442 --> 00:24:38.145 align:middle
下载一款需要游戏控制器的游戏

00:24:39.813 --> 00:24:43.250 align:middle
并且之前没有在那台Apple TV
上配对过游戏控制器的话

00:24:44.484 --> 00:24:46.753 align:middle
请注意 这只是一种保障措施

00:24:47.287 --> 00:24:49.857 align:middle
因为很可能 的游戏

00:24:49.923 --> 00:24:52.926 align:middle
需要游戏控制器 可能仍会启动

00:24:53.427 --> 00:24:55.596 align:middle
就算没有检测到已连接的游戏控制器

00:24:57.331 --> 00:24:59.933 align:middle
这种情况是你需要说明和处理的

00:25:01.034 --> 00:25:03.370 align:middle
很可能用户只不过是忘记

00:25:03.437 --> 00:25:04.938 align:middle
打开游戏控制器

00:25:05.572 --> 00:25:08.876 align:middle
那么在这种情况下 就要通知玩家

00:25:09.243 --> 00:25:12.846 align:middle
没有检测到任何游戏控制器
并要求他们连接一个游戏控制器

00:25:14.915 --> 00:25:18.952 align:middle
否则 用户可能会觉得奇怪
为什么不能控制游戏

00:25:20.721 --> 00:25:22.656 align:middle
还有一个问题你要考虑

00:25:22.723 --> 00:25:24.858 align:middle
就是以这种方式通知用户

00:25:24.925 --> 00:25:26.827 align:middle
只适用于控制器断开连接的情况

00:25:27.060 --> 00:25:29.329 align:middle
这是因为控制器

00:25:30.130 --> 00:25:33.033 align:middle
或者更精确地说是可用的控制器
可能会通过你的初步检测

00:25:33.100 --> 00:25:36.170 align:middle
但是在应用运行过程时

00:25:36.236 --> 00:25:38.305 align:middle
其中一个游戏控制器可能会断开连接

00:25:38.505 --> 00:25:41.108 align:middle
如果这是唯一可用的游戏控制器

00:25:41.608 --> 00:25:44.778 align:middle
那么此时 游戏就不能再继续了
因为至少需要一个游戏控制器

00:25:44.845 --> 00:25:47.247 align:middle
此时 也需要告知用户

00:25:52.986 --> 00:25:56.356 align:middle
要了解更多信息 请查看tvOS设计

00:25:56.590 --> 00:26:00.093 align:middle
会话802
获得更多游戏控制器的信息

00:25:56.590 --> 00:26:00.093 align:middle
会话802
获得更多游戏控制器的信息

00:26:06.967 --> 00:26:09.903 align:middle
现在让我们谈点儿新东西
Apple TV遥控器应用

00:26:10.737 --> 00:26:13.073 align:middle
正如你在本周一所了解到的信息
这是个新应用

00:26:13.540 --> 00:26:16.777 align:middle
可以从developer.apple.com上
下载beta版

00:26:17.778 --> 00:26:20.581 align:middle
这个应用可控制你的Apple TV

00:26:20.647 --> 00:26:23.650 align:middle
在屏幕中央有一大片触摸表面

00:26:24.017 --> 00:26:27.855 align:middle
而屏幕上的按钮
跟Siri遥控器上的按钮相同

00:26:29.523 --> 00:26:33.327 align:middle
重点是 它可以充当游戏输入设备

00:26:35.896 --> 00:26:38.999 align:middle
在tvOS上的实现方式是

00:26:39.600 --> 00:26:42.903 align:middle
以一种非常熟悉的方式
通过游戏控制器框架充当游戏触摸表面

00:26:43.337 --> 00:26:45.706 align:middle
实际上是一个仿真的Siri遥控器

00:26:46.340 --> 00:26:48.909 align:middle
因此它显示为一个
GCController实例

00:26:50.043 --> 00:26:52.246 align:middle
并支持GCMicroGamepad

00:26:52.312 --> 00:26:55.082 align:middle
GCMotion profiles
就跟Siri遥控器一样

00:26:55.983 --> 00:26:57.951 align:middle
事实上 它是不可辨别的

00:26:58.018 --> 00:27:00.687 align:middle
在Siri遥控器的游戏控制器框架中

00:26:58.018 --> 00:27:00.687 align:middle
在Siri遥控器的游戏控制器框架中

00:27:02.155 --> 00:27:05.659 align:middle
因此你为Siri遥控器写的代码
也可以用在tvOS上

00:27:07.628 --> 00:27:12.266 align:middle
这些遥控器默认为合并

00:27:12.733 --> 00:27:16.069 align:middle
因此 如果你有一个Siri遥控器
和一个TV遥控器应用

00:27:16.136 --> 00:27:20.607 align:middle
默认会在控制器数组中
作为一个游戏控制器出现

00:27:21.575 --> 00:27:25.012 align:middle
意思就是 任何一个的按钮输入
都会体现在游戏中

00:27:25.078 --> 00:27:26.647 align:middle
就像来自同一个控制器一样

00:27:27.414 --> 00:27:29.349 align:middle
DPAD输入也一样

00:27:30.417 --> 00:27:33.921 align:middle
但是对于动作
我们并不希望让动作输入形成

00:27:33.987 --> 00:27:36.557 align:middle
覆盖并跟另一个动作输入冲突

00:27:36.623 --> 00:27:39.193 align:middle
所以我们从一个控制器中
取出动作 或 抱歉

00:27:39.259 --> 00:27:40.861 align:middle
一次只从一个遥控器中取出一个动作

00:27:43.030 --> 00:27:44.898 align:middle
我们所取动作的遥控器是

00:27:44.965 --> 00:27:48.101 align:middle
最后接收用户输入的遥控器无论是滑动

00:27:48.168 --> 00:27:50.771 align:middle
在触摸表面
还是按下A或X按钮

00:27:52.072 --> 00:27:55.676 align:middle
如果你想选择性地分开这些遥控器

00:27:55.742 --> 00:27:58.045 align:middle
并 把它们显示为不同的实例

00:27:58.111 --> 00:27:59.446 align:middle
在控制器数组中

00:28:00.247 --> 00:28:01.148 align:middle
你需要

00:28:02.049 --> 00:28:03.851 align:middle
进入info.plist文件

00:28:03.917 --> 00:28:07.955 align:middle
添加布尔键
GCSupportsMultipleMicroGamepads

00:28:08.355 --> 00:28:14.094 align:middle
并把它设为是 现在Siri控制器和
Apple TV控制器应用将显示为

00:28:14.161 --> 00:28:17.931 align:middle
在数组中 不同的控制器实例

00:28:22.002 --> 00:28:26.940 align:middle
现在我想谈一下Apple TV
遥控器应用内部的一个特殊模式

00:28:27.007 --> 00:28:28.442 align:middle
叫游戏控制器模式

00:28:28.509 --> 00:28:32.045 align:middle
在此模式下 用户可以随意切换出入

00:28:32.112 --> 00:28:34.882 align:middle
在连接了游戏控制器框架的游戏中

00:28:37.084 --> 00:28:41.788 align:middle
这个应用是横向的 同样地

00:28:41.855 --> 00:28:46.593 align:middle
DPAD值被旋转了90度
甚至在它们进入应用之前就旋转了

00:28:47.194 --> 00:28:51.665 align:middle
那么你的应用并不需要做任何
设置或修改来使用这种模式

00:28:53.066 --> 00:28:56.470 align:middle
但是请注意
若游戏是手动把DPAD值旋转90度

00:28:56.537 --> 00:29:00.474 align:middle
那么你实际上是做了两次旋转

00:28:56.537 --> 00:29:00.474 align:middle
那么你实际上是做了两次旋转

00:29:01.241 --> 00:29:04.611 align:middle
所以我们的建议是

00:29:04.678 --> 00:29:07.414 align:middle
如果允许玩家 横向地玩儿游戏

00:29:07.481 --> 00:29:10.083 align:middle
用Siri遥控器和游戏控制器模式

00:29:10.150 --> 00:29:11.852 align:middle
就在Apple TV遥控器应用上

00:29:12.653 --> 00:29:16.590 align:middle
allowsRotation设为真
就像我们刚才谈到的那样

00:29:17.491 --> 00:29:20.794 align:middle
然后让我们为你处理方位
和DPAD的变更

00:29:22.663 --> 00:29:23.964 align:middle
还有一点要注意

00:29:24.198 --> 00:29:26.967 align:middle
Apple TV遥控器应用的
游戏控制器模式

00:29:27.034 --> 00:29:29.870 align:middle
会把触摸表面和A按钮分离开

00:29:31.605 --> 00:29:33.707 align:middle
这点跟Siri遥控器不一样

00:29:33.774 --> 00:29:37.144 align:middle
Siri遥控器是
点击触摸表面激活A按钮

00:29:37.845 --> 00:29:40.247 align:middle
但这并不会造成任何麻烦

00:29:40.981 --> 00:29:44.151 align:middle
用户仍然可以在两者上同步输入

00:29:44.218 --> 00:29:47.654 align:middle
并且你的游戏代码仍然会
检测在两者上的同步输入

00:29:48.522 --> 00:29:51.825 align:middle
但关键点是
如果你的游戏代码假设

00:29:51.892 --> 00:29:55.729 align:middle
按下A按钮会同时激活触摸表面

00:29:55.796 --> 00:29:58.832 align:middle
那么这跟
游戏控制器模式上的实现方式不一样

00:29:58.899 --> 00:30:00.300 align:middle
Apple TV遥控器应用的

00:29:58.899 --> 00:30:00.300 align:middle
Apple TV遥控器应用的

00:30:10.277 --> 00:30:13.080 align:middle
最后 我想谈一下多控制器

00:30:14.081 --> 00:30:17.751 align:middle
总是有人会问Apple TV
能支持多少个控制器

00:30:18.652 --> 00:30:23.423 align:middle
答案是在新版tvOS 10中
能支持一个Siri遥控器

00:30:23.490 --> 00:30:28.195 align:middle
和四个MFi游戏控制器
以及Apple TV遥控器应用

00:30:29.596 --> 00:30:32.866 align:middle
一般来说 会在多玩家游戏的
情境中提出这个问题

00:30:33.400 --> 00:30:38.572 align:middle
在tvOS 10中增加为
四个MFi游戏控制器

00:30:38.639 --> 00:30:40.807 align:middle
这对于多玩家游戏来说无疑是个好消息

00:30:42.042 --> 00:30:44.611 align:middle
最初可能并不明显

00:30:44.678 --> 00:30:47.714 align:middle
但这对于单一玩家游戏来说也很重要

00:30:48.282 --> 00:30:49.216 align:middle
让我解释一下

00:30:49.983 --> 00:30:51.451 align:middle
当应用启动时

00:30:52.319 --> 00:30:55.889 align:middle
你不确定你是否只发现
一个已连接的Siri遥控器

00:30:57.224 --> 00:31:00.427 align:middle
或也许你会发现一个
已连接的游戏控制器

00:30:57.224 --> 00:31:00.427 align:middle
或也许你会发现一个
已连接的游戏控制器

00:31:01.662 --> 00:31:03.230 align:middle
或者各发现了一个

00:31:04.565 --> 00:31:06.500 align:middle
或者也许你会发现一个Siri遥控器

00:31:06.567 --> 00:31:08.969 align:middle
多个游戏控制器和TV遥控器应用

00:31:09.169 --> 00:31:10.204 align:middle
了解这种情况吧？

00:31:10.270 --> 00:31:12.806 align:middle
那么此时关键点在Apple TV上

00:31:12.873 --> 00:31:16.777 align:middle
从多个控制器上接收输入很常见

00:31:16.844 --> 00:31:18.378 align:middle
即使是一个单一玩家的游戏

00:31:18.812 --> 00:31:21.448 align:middle
重要的是 你提前不知道

00:31:21.515 --> 00:31:24.084 align:middle
用户打算使用哪个控制器

00:31:24.818 --> 00:31:28.922 align:middle
你不能假设控制器的数组下标为零的

00:31:28.989 --> 00:31:30.691 align:middle
即为玩家想要使用的
那个控制器

00:31:31.158 --> 00:31:32.426 align:middle
那么 我们该如何处理？

00:31:33.393 --> 00:31:35.195 align:middle
嗯 关键是

00:31:35.262 --> 00:31:38.398 align:middle
玩家可以随时切换控制器

00:31:38.799 --> 00:31:40.367 align:middle
也许他们启动了应用

00:31:41.068 --> 00:31:43.170 align:middle
浏览了游戏菜单

00:31:43.237 --> 00:31:45.839 align:middle
然后启动了角色
这过程一直都用Siri遥控器控制

00:31:46.173 --> 00:31:48.108 align:middle
然后 他们切换到MFi游戏控制器

00:31:48.175 --> 00:31:50.444 align:middle
来实际开始控制角色

00:31:53.280 --> 00:31:58.852 align:middle
允许玩家 自由和灵活地切换

00:31:58.919 --> 00:32:02.389 align:middle
在不同的控制器之间而无需提示用户

00:31:58.919 --> 00:32:02.389 align:middle
在不同的控制器之间而无需提示用户

00:32:02.456 --> 00:32:05.192 align:middle
用不必要的确认对话

00:32:05.259 --> 00:32:07.794 align:middle
或无需要求用户退出游戏设置

00:32:07.861 --> 00:32:10.497 align:middle
再使用一个不同的控制器
重新进入游戏设置的游戏

00:32:11.031 --> 00:32:14.234 align:middle
将会打造一种真正了不起的无缝体验

00:32:15.302 --> 00:32:16.470 align:middle
我们该如何实现呢？

00:32:17.604 --> 00:32:20.474 align:middle
嗯 一种方式是把

00:32:20.541 --> 00:32:23.877 align:middle
输入所有控制器的
都作为单一玩家游戏的有效输入

00:32:24.778 --> 00:32:27.514 align:middle
所以 如果你有个角色
在DPAD屏幕上移动

00:32:27.581 --> 00:32:30.584 align:middle
并且允许接入所有已连接的控制器

00:32:30.651 --> 00:32:33.086 align:middle
那么 将允许它们的DPAD
控制角色移动

00:32:34.087 --> 00:32:38.458 align:middle
按钮也一样 如果角色 跳跃

00:32:38.825 --> 00:32:41.495 align:middle
通过按A按钮
那么就要允许 所有A按钮

00:32:41.562 --> 00:32:44.531 align:middle
所有已连接的控制器上的控制角色

00:32:45.632 --> 00:32:50.871 align:middle
如果某个控制器在游戏过程中接入

00:32:50.938 --> 00:32:53.373 align:middle
那么你也可开始悄悄地追踪那个控制器

00:32:53.440 --> 00:32:55.642 align:middle
并允许它的输入控制角色

00:32:57.277 --> 00:32:58.645 align:middle
现在 运行起来很顺畅了

00:32:58.712 --> 00:33:02.649 align:middle
我们要给玩家一个认知

00:32:58.712 --> 00:33:02.649 align:middle
我们要给玩家一个认知

00:33:02.716 --> 00:33:05.419 align:middle
即他们可以在多个控制器之间来回切换

00:33:05.485 --> 00:33:08.455 align:middle
这实际上是一个手动合并策略

00:33:08.522 --> 00:33:10.190 align:middle
我们从Siri遥控器 获取输入

00:33:10.257 --> 00:33:13.760 align:middle
和游戏控制器上
并全部提供给我们的单一玩家体验

00:33:15.896 --> 00:33:19.433 align:middle
但是 我在这里还要说一个极端情况
就是动作

00:33:19.700 --> 00:33:21.235 align:middle
我举例解释一下

00:33:22.636 --> 00:33:24.938 align:middle
如果你的游戏使用了动作

00:33:25.005 --> 00:33:29.543 align:middle
比如用Siri遥控器
控制飞机在空中飞行的姿势

00:33:30.277 --> 00:33:34.581 align:middle
你还可以把那个控制转移给摇杆
用摇杆控制飞机

00:33:34.648 --> 00:33:36.850 align:middle
若玩家正在用游戏控制器玩儿游戏的话

00:33:36.917 --> 00:33:38.986 align:middle
这完全没问题 很好用

00:33:40.454 --> 00:33:43.790 align:middle
关键顾虑是 当你正在手动合并
Siri遥控器和游戏控制器时

00:33:43.857 --> 00:33:47.227 align:middle
你不想让控制飞机的游戏杆

00:33:47.294 --> 00:33:51.331 align:middle
被任何可能
来自Siri遥控器的动作数据覆盖

00:33:51.398 --> 00:33:53.133 align:middle
当你正在手动合并Siri遥控器
和游戏控制器时

00:33:53.567 --> 00:33:57.704 align:middle
那么在这种情况下
游戏中控制飞机姿势的代码

00:33:57.771 --> 00:34:00.607 align:middle
应该检测该信息是取自

00:33:57.771 --> 00:34:00.607 align:middle
应该检测该信息是取自

00:34:00.674 --> 00:34:02.776 align:middle
动作还是取自摇杆

00:34:03.443 --> 00:34:05.212 align:middle
然后再返回来看我们的例子

00:34:05.279 --> 00:34:07.948 align:middle
当我用Siri遥控器控制飞机时

00:34:08.014 --> 00:34:09.815 align:middle
如果我换成游戏控制器

00:34:10.217 --> 00:34:13.152 align:middle
那么那个游戏控制器上的任何用户输入

00:34:13.219 --> 00:34:17.056 align:middle
无论DPAD还是摇杆或触发器或按钮

00:34:17.123 --> 00:34:20.594 align:middle
都将开始忽略来自Siri遥控器动作

00:34:20.893 --> 00:34:22.663 align:middle
并使用正确的摇杆来控制

00:34:22.728 --> 00:34:25.933 align:middle
飞机姿势 反过来也一样

00:34:25.998 --> 00:34:29.469 align:middle
如果我换成Siri遥控器
用户输入

00:34:29.536 --> 00:34:33.373 align:middle
也就是滑动触摸表面
或按下A或X按钮

00:34:33.841 --> 00:34:37.811 align:middle
将在那一刻起
听从来自Siri遥控器的动作

00:34:37.878 --> 00:34:38.911 align:middle
并切换到Siri遥控器

00:34:39.913 --> 00:34:44.117 align:middle
通过这个 我们制定了控制方案
对玩家来说非常灵活

00:34:44.184 --> 00:34:46.753 align:middle
可以实现尽可能无缝地切换

00:34:48.155 --> 00:34:52.592 align:middle
在研讨会结束之前 我想说

00:34:52.659 --> 00:34:55.395 align:middle
我在这里向你们演示的技术

00:34:55.462 --> 00:34:57.264 align:middle
可以直接用在你的游戏中

00:34:58.165 --> 00:35:01.602 align:middle
或者也许它们是个良好的开端
你可以进行调整

00:34:58.165 --> 00:35:01.602 align:middle
或者也许它们是个良好的开端
你可以进行调整

00:35:01.668 --> 00:35:04.738 align:middle
和自定义
使它们完美地适合你的游戏环境

00:35:05.572 --> 00:35:08.141 align:middle
但无论如何 我真的鼓励你们

00:35:08.208 --> 00:35:12.112 align:middle
超越控制器的连接 机制

00:35:12.179 --> 00:35:15.115 align:middle
和断开 以及读取按钮值

00:35:15.883 --> 00:35:18.585 align:middle
真正思考你要如何

00:35:18.652 --> 00:35:20.787 align:middle
把游戏控制器整合到你的游戏中去

00:35:21.355 --> 00:35:22.856 align:middle
因为 如果处理得当

00:35:22.923 --> 00:35:26.293 align:middle
站在玩家的立场上
用户就会对游戏控制器视而不见

00:35:26.660 --> 00:35:29.696 align:middle
并真正忘情地投入到游戏中来

00:35:29.763 --> 00:35:33.500 align:middle
享受你所努力营造的游戏体验

00:35:34.134 --> 00:35:35.702 align:middle
这才是游戏的真谛

00:35:38.572 --> 00:35:40.240 align:middle
好了 我们今天说了很多

00:35:40.407 --> 00:35:41.775 align:middle
总结一下

00:35:41.842 --> 00:35:46.513 align:middle
我们谈到了Siri遥控器如何
支持GCMicroGamepad profile

00:35:46.580 --> 00:35:48.248 align:middle
GCMotion profile中

00:35:48.815 --> 00:35:51.685 align:middle
我谈到了DPAD开窗
和allowsRotation

00:35:52.886 --> 00:35:54.454 align:middle
我还谈到了菜单按钮

00:35:54.521 --> 00:35:57.958 align:middle
以及在Apple TV上
所预期的行为如何进行改变

00:35:58.025 --> 00:35:59.760 align:middle
根据你的应用的情境

00:36:00.494 --> 00:36:02.930 align:middle
以及如何使用
GCEventViewController

00:36:03.030 --> 00:36:06.200 align:middle
和控制或暂停处理器来控制行为

00:36:07.634 --> 00:36:10.204 align:middle
我还谈到了MFi游戏控制器

00:36:10.804 --> 00:36:13.907 align:middle
这些控制器使用
GCExtendedGamepad profile

00:36:13.974 --> 00:36:16.043 align:middle
并引入压敏性

00:36:16.844 --> 00:36:20.781 align:middle
并且现在可以在游戏中
要求作为控制器使用了

00:36:22.950 --> 00:36:24.885 align:middle
我还谈到了TV遥控器应用

00:36:25.586 --> 00:36:27.354 align:middle
它其实是个仿真的Siri遥控器

00:36:27.421 --> 00:36:29.556 align:middle
从游戏控制器框架角度来说

00:36:29.923 --> 00:36:33.093 align:middle
而且我还谈到了Apple TV
遥控器应用的游戏控制器模式

00:36:33.527 --> 00:36:35.028 align:middle
和设计注意事项

00:36:35.095 --> 00:36:40.033 align:middle
以便你的游戏如你所期待的那样
能使用Apple TV遥控器应用

00:36:41.001 --> 00:36:44.338 align:middle
最后 结束时 我谈了多控制器

00:36:44.638 --> 00:36:46.840 align:middle
及其对多玩家游戏的重要性

00:36:46.907 --> 00:36:50.611 align:middle
但同样重要的是
也要考虑到单一玩家游戏

00:36:50.878 --> 00:36:54.014 align:middle
也就是说 允许玩家在游戏中
尽可能无缝地切换控制器

00:36:54.081 --> 00:36:56.083 align:middle
在游戏中尽可能无缝地

00:36:58.819 --> 00:37:01.622 align:middle
这是本场研讨会的URL

00:36:58.819 --> 00:37:01.622 align:middle
这是本场研讨会的URL

00:37:01.722 --> 00:37:05.092 align:middle
你们可以从这儿观看视频、
查看文档和示例代码

00:37:05.392 --> 00:37:07.127 align:middle
这场是607会话

00:37:08.562 --> 00:37:12.099 align:middle
其他相关的会话还有
“掌握tvOS上的UIKit

00:37:12.165 --> 00:37:14.067 align:middle
和tvOS设计”

00:37:14.301 --> 00:37:17.371 align:middle
还有tvOS实验室
可以解答你的一般疑问

00:37:18.572 --> 00:37:21.909 align:middle
非常感谢你们的关注 祝你们在
接下来的演讲中度过一段美好的时光
