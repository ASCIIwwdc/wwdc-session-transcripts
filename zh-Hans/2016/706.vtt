WEBVTT

00:00:19.319 --> 00:00:24.124 align:middle
安全的新特性

00:00:24.324 --> 00:00:25.259 align:middle
下午好！

00:00:27.628 --> 00:00:28.862 align:middle
欢迎大家

00:00:28.929 --> 00:00:32.098 align:middle
感谢各位前来听
安全的新特性

00:00:32.399 --> 00:00:36.637 align:middle
我叫Lucia Ballard
我管理Apple的安全传输团队

00:00:36.970 --> 00:00:38.739 align:middle
与我的同事Simon一起

00:00:38.805 --> 00:00:42.943 align:middle
我们将向大家讲讲我们
一直从事于的大量新内容

00:00:43.043 --> 00:00:45.812 align:middle
来帮助你为客户提升安全

00:00:46.246 --> 00:00:49.416 align:middle
所以 我希望在座的很多人
之前已经听过Evone的演讲

00:00:49.616 --> 00:00:52.719 align:middle
那个演讲非常好地概述了
我们这么做的原因和内容

00:00:53.020 --> 00:00:56.190 align:middle
而且是我们系统安全
的根本性支柱

00:00:56.623 --> 00:00:58.859 align:middle
这里我们会深入到
更多的详细信息

00:01:00.360 --> 00:01:01.828 align:middle
所以内容会有这些

00:01:04.998 --> 00:01:09.269 align:middle
首先 我们会谈谈iOS中
关于网络安全的一些变更

00:01:10.938 --> 00:01:14.508 align:middle
之后我们会讨论几个
对我们加密API的更新

00:01:16.009 --> 00:01:19.580 align:middle
然后Simon会谈谈
macOS上的平台安全

00:01:21.915 --> 00:01:24.017 align:middle
所以 直接进入网络安全

00:01:24.418 --> 00:01:26.553 align:middle
如果你用手机像我一样频繁

00:01:26.787 --> 00:01:29.590 align:middle
你就会知道手机
积累了数量惊人的信息

00:01:29.656 --> 00:01:31.158 align:middle
关于你的私人生活

00:01:31.225 --> 00:01:33.093 align:middle
而且很多是通过网络传递的

00:01:33.160 --> 00:01:37.030 align:middle
无论是你在阅读的文章
或是给朋友发送的消息

00:01:37.898 --> 00:01:41.835 align:middle
所有这些点点滴滴的信息
即使从单个看起来无关紧要

00:01:41.902 --> 00:01:45.405 align:middle
但累积起来 可以
非常惊人地描述出这个人

00:01:45.672 --> 00:01:47.341 align:middle
所以在Apple
我们有理由认为

00:01:47.741 --> 00:01:51.311 align:middle
所有这些信息都
应该默认得到保护

00:01:52.546 --> 00:01:55.516 align:middle
我们认为HTTPS
是新的HTTP

00:01:55.716 --> 00:01:58.385 align:middle
所以对于每个
通过网络加载的资源

00:01:58.652 --> 00:02:02.256 align:middle
你应该为你的用户
提供机密性和数据完整性

00:01:58.652 --> 00:02:02.256 align:middle
你应该为你的用户
提供机密性和数据完整性

00:02:04.825 --> 00:02:09.062 align:middle
另一个关键点是
并非每个HTTPS都是平等的

00:02:10.264 --> 00:02:15.335 align:middle
HTTPS基于SSL
或按现代的说法是TLS

00:02:15.969 --> 00:02:20.440 align:middle
并非这个协议的所有版本
都会提供足够的安全保护

00:02:20.674 --> 00:02:23.110 align:middle
给你的用户来抵抗攻击

00:02:24.678 --> 00:02:26.313 align:middle
所以基于这些原则

00:02:26.780 --> 00:02:29.683 align:middle
去年我们推出了
App Transport Security

00:02:30.517 --> 00:02:31.718 align:middle
App Transport Security

00:02:33.153 --> 00:02:37.891 align:middle
指的是你做的所有加载
使用NSURLSession

00:02:38.025 --> 00:02:41.228 align:middle
或甚至是更旧的
NSURLConnection API

00:02:41.562 --> 00:02:46.633 align:middle
你需要使用最顶级
牢靠的TLS连接

00:02:47.568 --> 00:02:52.272 align:middle
首先 这意味着TLS版本1.2
该版本推出有一段时间了

00:02:52.673 --> 00:02:55.542 align:middle
但只有该版本能够完全抵抗

00:02:55.642 --> 00:02:59.580 align:middle
我们所知的一切漏洞
像是BEAST攻击

00:02:59.646 --> 00:03:02.883 align:middle
或者POODLE攻击
或其他名字可怕的漏洞攻击

00:02:59.646 --> 00:03:02.883 align:middle
或者POODLE攻击
或其他名字可怕的漏洞攻击

00:03:04.852 --> 00:03:07.221 align:middle
这也意味着你必须
使用强大的加密方法

00:03:07.554 --> 00:03:11.091 align:middle
像是AES-128或更强大的密码

00:03:11.491 --> 00:03:14.094 align:middle
以及有SHA-2签名的证书

00:03:14.294 --> 00:03:17.297 align:middle
因为有SHA-1签名的证书
很容易受到攻击

00:03:19.299 --> 00:03:21.401 align:middle
最后 这还意味着正向保密

00:03:21.835 --> 00:03:25.372 align:middle
这种方法可以在服务器
和客户端之间交换密钥

00:03:25.606 --> 00:03:30.744 align:middle
这会带来十分惊人的属性
意味着哪怕将来那个证书...

00:03:31.144 --> 00:03:33.113 align:middle
那个服务器证书被盗取了

00:03:33.514 --> 00:03:35.349 align:middle
你无法显示出来

00:03:35.616 --> 00:03:38.185 align:middle
过去发生的任何通信内容

00:03:39.319 --> 00:03:41.088 align:middle
所以把这些都结合在一起

00:03:41.288 --> 00:03:43.924 align:middle
我们认为 你就有了
一个安全的连接

00:03:43.991 --> 00:03:45.893 align:middle
可以保护客户的数据

00:03:47.294 --> 00:03:50.597 align:middle
现在 我们知道
这需要一段时间来赶上

00:03:50.664 --> 00:03:54.168 align:middle
App Transport Security
的步伐 所以我们还推出了特例

00:03:54.501 --> 00:03:55.903 align:middle
你可以全局关闭

00:03:56.203 --> 00:03:59.072 align:middle
或你可以为
特定域名设置特例

00:03:59.239 --> 00:04:01.775 align:middle
你知道那个域名
无法快速转成TLS

00:03:59.239 --> 00:04:01.775 align:middle
你知道那个域名
无法快速转成TLS

00:04:02.976 --> 00:04:06.480 align:middle
现在我想知道在座的
有多少人在思考 “没错

00:04:06.580 --> 00:04:08.315 align:middle
我去年设置了那个特例

00:04:08.682 --> 00:04:13.220 align:middle
之后就没再考虑了”
好吧 现在是重新考虑的时候了

00:04:14.288 --> 00:04:16.890 align:middle
因为今年
我们会开始在

00:04:16.957 --> 00:04:19.593 align:middle
App Store上
施行App Transport Security

00:04:21.195 --> 00:04:23.664 align:middle
这会在2016年底开始生效

00:04:24.865 --> 00:04:26.934 align:middle
这意味着对于大多数特例

00:04:27.334 --> 00:04:29.770 align:middle
你需要提供正当的理由

00:04:30.204 --> 00:04:31.638 align:middle
所以 对于所有这些特例

00:04:31.705 --> 00:04:34.508 align:middle
真正关闭了
App Transport Security

00:04:34.575 --> 00:04:38.212 align:middle
或其关键属性
像是使用TLS 1.2

00:04:38.412 --> 00:04:42.850 align:middle
你首先需要说明
你要使用该特例的理由

00:04:43.617 --> 00:04:45.886 align:middle
对于其他特例
像是正向保密

00:04:45.953 --> 00:04:49.489 align:middle
我们意识到
对它们的支持并非完全通用

00:04:49.656 --> 00:04:52.659 align:middle
所以目前会
自动授予这些特例

00:04:52.726 --> 00:04:54.428 align:middle
不需要任何理由

00:04:56.897 --> 00:05:00.200 align:middle
例如 如果你在使用
一个伙伴服务器

00:04:56.897 --> 00:05:00.200 align:middle
例如 如果你在使用
一个伙伴服务器

00:05:00.267 --> 00:05:04.037 align:middle
而且你无法控制
他们提供的加密套件

00:05:04.538 --> 00:05:07.808 align:middle
我们能够让你
继续和那个服务器对话

00:05:13.046 --> 00:05:17.117 align:middle
我们还添加了一些
新的特例来使其易于采用

00:05:18.352 --> 00:05:20.988 align:middle
例如 如果你在使用
Streaming Media

00:05:21.154 --> 00:05:23.724 align:middle
而且那个媒体文件
已经批量加密了

00:05:24.224 --> 00:05:27.294 align:middle
我们可以能够通过
AV Foundation提供特例

00:05:27.361 --> 00:05:30.063 align:middle
让你不需连接TLS
就能加载那个媒体文件

00:05:30.464 --> 00:05:32.999 align:middle
我想说清楚
我们还是认为正确的做法

00:05:33.200 --> 00:05:35.102 align:middle
是将TLS用于一切上面

00:05:35.435 --> 00:05:38.839 align:middle
但有些情况下
我们可以提供特例

00:05:39.072 --> 00:05:40.807 align:middle
来帮助你更顺利地过渡

00:05:43.010 --> 00:05:45.312 align:middle
我们还提供
网页内容特例

00:05:45.746 --> 00:05:49.683 align:middle
这里有时候你的应用需要
加载网页上的任意内容

00:05:49.750 --> 00:05:53.420 align:middle
当然 你无法保证
那是使用HTTPS的

00:05:53.987 --> 00:05:56.723 align:middle
所以如果你用
WKWebView

00:05:57.124 --> 00:06:00.561 align:middle
那你可以将这个密钥
设置在应用的Info.plist里面

00:05:57.124 --> 00:06:00.561 align:middle
那你可以将这个密钥
设置在应用的Info.plist里面

00:06:01.261 --> 00:06:05.866 align:middle
NSAllowsArbitraryLoads
inWebContentKey

00:06:06.433 --> 00:06:08.702 align:middle
之后所有的这些
加载都会免去

00:06:08.769 --> 00:06:10.971 align:middle
App Transport Security要求

00:06:11.171 --> 00:06:12.906 align:middle
但你应用所做的其他事

00:06:13.040 --> 00:06:15.843 align:middle
像是和你自己的服务器对话
这还是会得到保护的

00:06:19.913 --> 00:06:21.982 align:middle
所以这是
App Transport Security

00:06:23.183 --> 00:06:25.919 align:middle
但我们还在整个系统
上为TLS做变更

00:06:26.720 --> 00:06:30.123 align:middle
因为加密套件不断进化

00:06:30.190 --> 00:06:34.127 align:middle
与抵御攻击相比 发起
攻击的能力不断变得越加高效

00:06:34.728 --> 00:06:37.598 align:middle
所以无论你的ATS设置是什么

00:06:38.065 --> 00:06:42.870 align:middle
我们现在为所有使用我们
网络API的人默认禁用了RC4

00:06:45.005 --> 00:06:48.242 align:middle
我们还在Secure Transport
中禁用了SSLv3

00:06:48.342 --> 00:06:51.211 align:middle
所以即使你下入到
我们的底层API

00:06:51.278 --> 00:06:53.347 align:middle
你还是无法使用SSLv3

00:06:54.214 --> 00:06:57.017 align:middle
研究已经远远超越
这两项技术了

00:06:57.084 --> 00:07:00.687 align:middle
我们不认为它们能为我们的
用户提供有效的安全

00:06:57.084 --> 00:07:00.687 align:middle
我们不认为它们能为我们的
用户提供有效的安全

00:07:03.490 --> 00:07:04.825 align:middle
所以被禁用了

00:07:05.359 --> 00:07:07.661 align:middle
其他的算法也开始过时了

00:07:07.728 --> 00:07:13.233 align:middle
特别的 SHA-1变得
越来越容易受到攻击

00:07:13.367 --> 00:07:14.568 align:middle
3DES也是

00:07:15.235 --> 00:07:18.839 align:middle
所以 如果你知道
你依赖于这些算法

00:07:20.107 --> 00:07:21.475 align:middle
现在该放弃它们了

00:07:22.242 --> 00:07:25.145 align:middle
而且我发现在场的
很多人是应用开发者

00:07:25.245 --> 00:07:27.414 align:middle
而且不负责自己的后端

00:07:27.648 --> 00:07:29.183 align:middle
所以你需要联系

00:07:29.249 --> 00:07:32.319 align:middle
你公司或其他
负责托管后端的那些人

00:07:32.386 --> 00:07:34.655 align:middle
来确保他们放弃

00:07:34.922 --> 00:07:38.458 align:middle
对这些老旧算法的依赖
因为这些算法要被弃用了

00:07:39.259 --> 00:07:42.729 align:middle
现在非常适合你去
检查加载内容的状态

00:07:42.796 --> 00:07:47.267 align:middle
使用HTTPS 并且确保你能
使用App Transport Security

00:07:47.801 --> 00:07:49.803 align:middle
然后你就能快速
通过应用审核了

00:07:53.240 --> 00:07:55.275 align:middle
所以这就是
App Transport Security

00:07:55.976 --> 00:07:58.779 align:middle
确保一切都是用
牢靠的TLS进行加载的

00:07:58.979 --> 00:08:01.381 align:middle
不过牢靠的TLS是不够的

00:07:58.979 --> 00:08:01.381 align:middle
不过牢靠的TLS是不够的

00:08:02.850 --> 00:08:08.322 align:middle
你还需要确保你用来验证
TLS连接的证书

00:08:08.555 --> 00:08:10.724 align:middle
能表示正确的服务器

00:08:11.625 --> 00:08:14.061 align:middle
所以我想谈谈几个不同的技术

00:08:14.361 --> 00:08:18.198 align:middle
我们今天使用它们
来帮助你确保你是真正

00:08:18.365 --> 00:08:20.634 align:middle
连接到正确的服务器上

00:08:20.801 --> 00:08:23.370 align:middle
当你在建立这些
安全通信的时候

00:08:25.606 --> 00:08:26.707 align:middle
所以首先我们回来

00:08:26.840 --> 00:08:29.409 align:middle
来稍微谈谈当今
证书的工作原理

00:08:32.746 --> 00:08:34.548 align:middle line:1
所以如果你要连接一个服务器

00:08:34.615 --> 00:08:38.719 align:middle line:1
那个服务器一定要有一个
由证书权威机构发放的证书

00:08:38.784 --> 00:08:40.621 align:middle line:1
那个权威机构会验证主机名

00:08:40.687 --> 00:08:43.957 align:middle line:1
然后说 “没错 挺好的
你确实是example.com

00:08:44.024 --> 00:08:45.592 align:middle line:1
这是你的密码证明”

00:08:46.693 --> 00:08:49.396 align:middle line:1
当你连接的时候
服务器会发来那个证书

00:08:52.999 --> 00:08:56.236 align:middle
但这不总是完美的机制

00:08:57.337 --> 00:09:01.575 align:middle
如果有攻击者设法
得到了你主机名的证书

00:08:57.337 --> 00:09:01.575 align:middle
如果有攻击者设法
得到了你主机名的证书

00:09:02.209 --> 00:09:04.178 align:middle
那他们就能提供那个证书

00:09:04.244 --> 00:09:06.780 align:middle line:1
而客户端无法分辨出

00:09:06.847 --> 00:09:08.849 align:middle line:1
攻击者的服务器
和你自己的服务器

00:09:09.516 --> 00:09:12.352 align:middle line:1
如果证书权威机构
出错的话 这就会发生

00:09:12.419 --> 00:09:13.954 align:middle line:1
或更糟的情况

00:09:14.021 --> 00:09:16.256 align:middle line:1
这个证书权威机构被入侵了

00:09:16.390 --> 00:09:18.959 align:middle line:1
有其他人使用他们的
私人密钥来进行签名

00:09:21.728 --> 00:09:24.565 align:middle
所以今天我很自豪地宣布
我们将加入到

00:09:24.698 --> 00:09:26.333 align:middle
证书透明度的工作中去

00:09:27.201 --> 00:09:29.770 align:middle
证书透明度是一种技术

00:09:29.837 --> 00:09:33.674 align:middle
使用了已发布证书的
公开可验证日志

00:09:34.441 --> 00:09:37.277 align:middle
这些日志从各种源中收集证书

00:09:37.344 --> 00:09:39.980 align:middle
所以有很多
证书权威机构参与进来

00:09:40.047 --> 00:09:42.015 align:middle
但事实上
任何人都可以提交日志

00:09:43.717 --> 00:09:46.954 align:middle
之后 这些日志会发布密码证明

00:09:47.087 --> 00:09:50.457 align:middle
表明这个证书已被记录
然后客户端可以检查那个证明

00:09:50.724 --> 00:09:52.459 align:middle
这里的做法有很多

00:09:52.593 --> 00:09:54.695 align:middle
证明可以嵌入到证书中

00:09:54.761 --> 00:09:57.764 align:middle
或可以在TLS握手中交出

00:09:58.432 --> 00:10:02.402 align:middle
或可以通过OCSP装订传输
这一点我过会再细说

00:09:58.432 --> 00:10:02.402 align:middle
或可以通过OCSP装订传输
这一点我过会再细说

00:10:04.638 --> 00:10:07.040 align:middle
所以这是其工作原理的简单概述

00:10:09.076 --> 00:10:11.311 align:middle
首先 证书权威机构

00:10:12.679 --> 00:10:15.182 align:middle line:1
不仅向服务器发行证书

00:10:15.482 --> 00:10:19.419 align:middle line:1
还将证书发送到日志那里
然后添加到公开日志上

00:10:20.721 --> 00:10:24.558 align:middle line:1
之后日志会发送一个有签名的证明
表明这个证书已被包括进去

00:10:25.325 --> 00:10:28.829 align:middle line:1
然后服务器将它和原始证书一起

00:10:29.096 --> 00:10:30.330 align:middle line:1
交给客户端

00:10:30.831 --> 00:10:33.100 align:middle line:1
这意味着你可以
一同验证这一对

00:10:36.069 --> 00:10:39.873 align:middle line:1
所以证书透明度
使发起攻击变的更加困难

00:10:41.608 --> 00:10:43.510 align:middle line:1
基本上这让攻击者身处困境

00:10:43.710 --> 00:10:48.315 align:middle line:1
如果攻击者可以从未参与的
权威机构那里得到一个证书

00:10:48.916 --> 00:10:51.885 align:middle line:1
他们无法得到那个密码证明

00:10:52.119 --> 00:10:54.588 align:middle line:1
因为那个日志中包括着证书

00:10:55.022 --> 00:10:58.225 align:middle line:1
所以他们只能交出证书
然后客户端就可以拒绝

00:10:59.993 --> 00:11:00.961 align:middle line:1
或者

00:10:59.993 --> 00:11:00.961 align:middle line:1
或者

00:11:01.895 --> 00:11:04.865 align:middle line:1
如果他们使用
参与的证书权威机构

00:11:05.499 --> 00:11:07.768 align:middle line:1
那么那个被感染的证书会被记录

00:11:07.835 --> 00:11:10.704 align:middle line:1
然后可以公开查看
这就让你有机会

00:11:10.771 --> 00:11:13.574 align:middle line:1
在证书权威机构级别撤销证书

00:11:15.142 --> 00:11:17.311 align:middle
所以我们认为这是
一种至关重要的技术

00:11:18.011 --> 00:11:22.149 align:middle
来让你确认与你对话的那个证书

00:11:22.282 --> 00:11:24.718 align:middle
的确是你要对话的那个证书

00:11:27.654 --> 00:11:29.356 align:middle
所以你可以这样试试

00:11:30.591 --> 00:11:32.559 align:middle
你可以使用
相同的info.plist

00:11:32.626 --> 00:11:35.729 align:middle
你用它设置了
应用的传输安全配置

00:11:36.330 --> 00:11:38.532 align:middle
这是新的关键字
所以对于每个例子

00:11:38.899 --> 00:11:42.336 align:middle
有一个参与的证书
你设置上关键字

00:11:42.536 --> 00:11:44.771 align:middle
然后你的客户端会拒绝任何

00:11:44.838 --> 00:11:47.074 align:middle
无法证明其有公开日志的证书

00:11:50.177 --> 00:11:52.379 align:middle line:1
我们当前的策略大概要求

00:11:52.446 --> 00:11:54.715 align:middle line:1
你需要有至少来自
两个日志的证明

00:11:55.749 --> 00:11:59.586 align:middle line:1
这些日志...我们会将
认证的新日志添加上去

00:11:59.786 --> 00:12:03.223 align:middle line:1
若你的证书能用在Chromium上
基本上在我们这里也能行

00:11:59.786 --> 00:12:03.223 align:middle line:1
若你的证书能用在Chromium上
基本上在我们这里也能行

00:12:04.024 --> 00:12:05.626 align:middle
有更多的信息

00:12:05.692 --> 00:12:09.663 align:middle
关于通用技术的
在certificatetransparency.org

00:12:09.796 --> 00:12:11.532 align:middle
所以我鼓励你去查看一下

00:12:15.269 --> 00:12:19.006 align:middle
证书透明度是这个
生态系统中的一个重要部分

00:12:19.106 --> 00:12:21.241 align:middle
当它无法完全代替吊销

00:12:21.375 --> 00:12:23.877 align:middle
这还有最后一步
当你发现了

00:12:23.944 --> 00:12:28.081 align:middle
证书由于某种原因出现缺陷
你必须要终止对其的信任

00:12:29.349 --> 00:12:31.051 align:middle
所以我想花几分钟时间

00:12:31.118 --> 00:12:33.554 align:middle
来谈谈我们推荐的做法

00:12:33.687 --> 00:12:35.289 align:middle
这叫做OCSP装订

00:12:35.989 --> 00:12:38.859 align:middle
这种标准已经推出很多年了

00:12:39.092 --> 00:12:41.028 align:middle
但是我们认为现在是时候

00:12:41.094 --> 00:12:43.764 align:middle
让大家转移过去
真正开始采用它

00:12:44.164 --> 00:12:46.600 align:middle
因为现在对它的支持
已非常广泛了

00:12:47.701 --> 00:12:51.905 align:middle
OCSP装订是对
在线证书状态协议的增强

00:12:51.972 --> 00:12:53.674 align:middle
并且解决了大量的问题

00:12:55.843 --> 00:12:58.712 align:middle line:1
所以回顾一下
这就是OCSP的工作原理

00:12:59.046 --> 00:13:00.247 align:middle line:1
我们有同样的设置

00:12:59.046 --> 00:13:00.247 align:middle line:1
我们有同样的设置

00:13:00.314 --> 00:13:03.917 align:middle line:1
证书权威机构向
服务器发放证书

00:13:05.219 --> 00:13:07.454 align:middle line:1
每一次客户端
连接那个服务器

00:13:07.521 --> 00:13:11.091 align:middle line:1
客户端就会看到那个证书
并且想知道证书是否仍然有效

00:13:12.059 --> 00:13:14.461 align:middle line:1
所以它会请求证书权威机构

00:13:14.528 --> 00:13:16.663 align:middle line:1
就在TLS握手过程中间

00:13:17.264 --> 00:13:18.899 align:middle line:1
然后证书权威机构说

00:13:18.966 --> 00:13:22.970 align:middle line:1
“是的 证书仍然有效” 或者
“不是 抱歉证书无效的 不要相信”

00:13:24.805 --> 00:13:25.906 align:middle line:1
这有一些问题

00:13:26.707 --> 00:13:28.475 align:middle line:1
其中之一是速度慢

00:13:28.542 --> 00:13:31.879 align:middle line:1
你处在获得资源的握手过程中

00:13:31.945 --> 00:13:35.182 align:middle
你不想等待一些其他
实体来进行连接

00:13:35.649 --> 00:13:38.819 align:middle
尤其是当那个服务器关闭了
你可能要等待一段时间

00:13:40.087 --> 00:13:42.956 align:middle
另一个重大问题是
这会稍微泄露出

00:13:43.023 --> 00:13:45.459 align:middle
关于你在线活动的信息

00:13:45.826 --> 00:13:49.229 align:middle
你的证书权威机构会看
你连接了哪些主机名

00:13:49.296 --> 00:13:52.633 align:middle
因为每次你连接的时候
你都发送一个响应

00:13:55.936 --> 00:13:58.705 align:middle line:1
OCSP装订
解决了很多这些担忧

00:13:58.872 --> 00:14:00.674 align:middle line:1
所以工作原理基本上是这样

00:13:58.872 --> 00:14:00.674 align:middle line:1
所以工作原理基本上是这样

00:14:01.475 --> 00:14:06.013 align:middle line:1
进行请求的不是客户端
而是服务器请求证书权威机构

00:14:07.481 --> 00:14:11.018 align:middle line:1
证书权威机构将一个
有签名的响应交回服务器

00:14:11.118 --> 00:14:13.187 align:middle line:1
由证书权威机构签名

00:14:13.453 --> 00:14:14.788 align:middle line:1
这样就可以信任它了

00:14:16.056 --> 00:14:19.393 align:middle line:1
之后服务器将这个证书和承诺一并

00:14:19.459 --> 00:14:23.630 align:middle line:1
发给客户端 表明证书是有效的
全部一致 全部是同一个握手过程

00:14:27.201 --> 00:14:28.168 align:middle
所以这意味着

00:14:28.235 --> 00:14:32.105 align:middle
你的吊销信息会
可靠迅速地送达过来

00:14:32.172 --> 00:14:34.942 align:middle
没有多余的等待
没有任何担忧

00:14:36.009 --> 00:14:37.911 align:middle
而且会保护用户的隐私

00:14:37.978 --> 00:14:40.981 align:middle
因为他们唯一建立的
就是返回你服务器的连接

00:14:42.950 --> 00:14:46.486 align:middle
你可能注意到这个图表
看起来和证书透明度的图表相似

00:14:46.553 --> 00:14:48.622 align:middle
那是因为你可以
使用相同的机制

00:14:48.689 --> 00:14:50.891 align:middle
来传递证书透明度证明

00:14:51.258 --> 00:14:54.194 align:middle
只要你的证书
权威机构参与进来

00:14:54.461 --> 00:14:57.631 align:middle
你可以在一次握手中
一同发出所有的信息

00:15:00.200 --> 00:15:03.770 align:middle
如我所说 OCSP装订
广泛地支持于

00:15:03.837 --> 00:15:06.840 align:middle
多种操作系统
而且还能向后兼容

00:15:06.907 --> 00:15:10.177 align:middle
所以你今天就可以启用
在Apache上 在GenX上

00:15:10.244 --> 00:15:12.913 align:middle
你的后端托管
在什么地方都行

00:15:13.180 --> 00:15:16.216 align:middle
而且现在完全支持
所有的Apple平台

00:15:19.753 --> 00:15:21.588 align:middle
所以如果可以回顾

00:15:21.655 --> 00:15:24.124 align:middle
总结我们在网络安全上的进展

00:15:24.591 --> 00:15:29.229 align:middle
现在是时候前进到
应用传输安全标准上了

00:15:29.296 --> 00:15:34.101 align:middle
这是牢靠的算法
和牢靠的密码 TLS 1.2

00:15:34.268 --> 00:15:36.737 align:middle
正向保密和SHA-2证书

00:15:38.772 --> 00:15:43.343 align:middle
还有 现在是时候开始对证书
透明度进行试验了

00:15:43.544 --> 00:15:46.413 align:middle
寻找参与的证书权威机构

00:15:46.647 --> 00:15:49.550 align:middle
然后整合到这个生态系统中

00:15:51.251 --> 00:15:53.954 align:middle
还有 一定要启用OCSP装订

00:15:54.021 --> 00:15:57.958 align:middle
这样我们就万无一失了
而且要知道你可以确保

00:15:58.058 --> 00:16:00.594 align:middle
建立安全的返回服务器连接

00:15:58.058 --> 00:16:00.594 align:middle
建立安全的返回服务器连接

00:16:01.929 --> 00:16:03.297 align:middle
所以这就是网络安全

00:16:05.999 --> 00:16:10.037 align:middle
现在我想花几分钟时间
来谈谈一些加密改进

00:16:12.005 --> 00:16:16.076 align:middle
所以 首先是SecKey
SecKey是我们的算法

00:16:16.210 --> 00:16:20.981 align:middle
不好意思 是我们用于
非对称加密操作的API

00:16:21.281 --> 00:16:25.485 align:middle
在这次版本中 我们统一了
macOS和iOS上面的API

00:16:26.353 --> 00:16:31.191 align:middle
SecKey现在支持所有的常见操作
用非对称密钥

00:16:31.692 --> 00:16:33.193 align:middle
RSA 和 ACC 进行的操作

00:16:33.493 --> 00:16:37.030 align:middle
所以这是用非对称密钥
进行签名和验证

00:16:38.398 --> 00:16:44.571 align:middle
这意味着SecKey完全替代了
在macOS上被弃用的CDSA调用

00:16:45.339 --> 00:16:48.675 align:middle
而且它还替代了你可能
使用的SecTransform

00:16:48.876 --> 00:16:52.179 align:middle
来用非对称密钥进行加密

00:16:52.546 --> 00:16:55.015 align:middle
所以我们强烈推荐
前进到SecKey上

00:16:57.084 --> 00:17:01.088 align:middle
我们还将它嵌入到新工具包中
叫做CryptoTokenKit

00:16:57.084 --> 00:17:01.088 align:middle
我们还将它嵌入到新工具包中
叫做CryptoTokenKit

00:17:01.788 --> 00:17:05.592 align:middle
CryptoTokenKit是对
加密设备的系统支持

00:17:05.759 --> 00:17:08.662 align:middle
所以那张你用来
证明身份的小卡片

00:17:08.729 --> 00:17:11.964 align:middle
在企业中用的那种
或者是USB token

00:17:13.300 --> 00:17:16.203 align:middle
现在我们直接整合了这些

00:17:16.603 --> 00:17:18.672 align:middle
而且它们可以
整合到系统服务中

00:17:18.739 --> 00:17:23.010 align:middle
所以这意味着这些Token内容
可以在keychain中获得

00:17:23.210 --> 00:17:24.344 align:middle
如你所料

00:17:24.411 --> 00:17:29.049 align:middle
而且Token操作可以通过
使用SecKey API实现

00:17:29.950 --> 00:17:33.420 align:middle
这是一个复杂的话题
其中有很多的深层内容

00:17:33.820 --> 00:17:35.956 align:middle
所以请到
security lab见我们

00:17:36.023 --> 00:17:38.025 align:middle
我们可以详细讨论你的使用案例

00:17:40.394 --> 00:17:43.430 align:middle
所以感谢大家的关注
接下来我将交给Simon

00:17:43.497 --> 00:17:45.566 align:middle
来谈谈在平台安全
上的新内容

00:17:50.737 --> 00:17:52.072 align:middle
非常感谢你 Lucia

00:17:53.207 --> 00:17:56.910 align:middle
大家好 我是Simon Cooper
我负责管理信任工程团队

00:17:58.011 --> 00:17:59.880 align:middle
我将谈谈安全上的新内容

00:18:00.981 --> 00:18:03.483 align:middle
但首先我想谈谈...
稍微谈谈

00:18:04.051 --> 00:18:06.153 align:middle
软件是如何传输到Mac上的

00:18:07.454 --> 00:18:09.389 align:middle
稍微谈谈Developer ID

00:18:10.490 --> 00:18:12.259 align:middle line:1
然后我会谈谈Gatekeeper

00:18:12.359 --> 00:18:14.761 align:middle line:1
和围绕Gatekeeper
的一些打包问题

00:18:15.229 --> 00:18:18.332 align:middle
我们先开始谈谈
软件是如何传输到

00:18:18.398 --> 00:18:20.701 align:middle
我们几个平台上的

00:18:22.736 --> 00:18:25.839 align:middle
所以对于iOS 你可以从
App Store上获取应用

00:18:27.207 --> 00:18:33.180 align:middle
你能使用Xcode来创建并运行应用
然后将它们安装在你自己的设备上

00:18:34.581 --> 00:18:36.383 align:middle
这有一些Enterprise Program

00:18:36.450 --> 00:18:40.320 align:middle
允许你将内容传输
到设备上并进行管理

00:18:41.522 --> 00:18:43.991 align:middle
你会发现所有这些安装机制

00:18:44.057 --> 00:18:46.360 align:middle
都是由iOS平台
在背后处理完成的

00:18:47.427 --> 00:18:49.630 align:middle
所以现在我想
稍微谈谈macOS

00:18:52.432 --> 00:18:55.269 align:middle
所以你还可以通过
Mac App Store获得应用

00:18:55.969 --> 00:18:57.905 align:middle
而且这种获取应用
的方法十分不错

00:18:59.840 --> 00:19:03.644 align:middle
你还可以得到有
Developer ID签名的应用

00:18:59.840 --> 00:19:03.644 align:middle
你还可以得到有
Developer ID签名的应用

00:19:06.680 --> 00:19:08.248 align:middle
你还可以使用Xcode

00:19:08.482 --> 00:19:12.152 align:middle
来创建你自己的应用
然后使用传统命令行UNIX工具

00:19:12.219 --> 00:19:14.388 align:middle
来以普通的UNIX方式创建内容

00:19:17.858 --> 00:19:21.328 align:middle
所以我们回来稍微
谈谈Developer ID

00:19:25.165 --> 00:19:27.034 align:middle
所以什么是Developer ID？

00:19:30.103 --> 00:19:33.674 align:middle
Developer ID允许你
在App Store之外传输应用

00:19:35.876 --> 00:19:38.979 align:middle
这些应用通常使用
网页浏览器下载完成的

00:19:41.915 --> 00:19:46.119 align:middle
Developer ID Program会
发放给你一个Developer ID签名身份

00:19:48.822 --> 00:19:52.926 align:middle
当你以该身份给应用签名时
应用会得到Gatekeeper的特别对待

00:19:55.195 --> 00:19:57.831 align:middle
实际上 在Xcode 8中
有一些改进的流程

00:19:57.998 --> 00:20:01.768 align:middle
允许你正确地导出有
Developer ID签名的应用

00:19:57.998 --> 00:20:01.768 align:middle
允许你正确地导出有
Developer ID签名的应用

00:20:08.475 --> 00:20:12.479 align:middle
所以我们要做的是改变
Developer ID Program

00:20:12.546 --> 00:20:13.847 align:middle
昨天已经宣布了

00:20:13.914 --> 00:20:17.351 align:middle
我们允许Developer ID
和iCloud协同使用

00:20:19.786 --> 00:20:22.689 align:middle
所以Developer ID现在
可以使用iCloud的功能

00:20:22.756 --> 00:20:26.193 align:middle
这包括iCloud Drive
iCloud Keychain

00:20:26.627 --> 00:20:29.062 align:middle
Push Notifications和VPN

00:20:32.266 --> 00:20:33.367 align:middle
所以这意味着什么？

00:20:34.201 --> 00:20:37.037 align:middle
这意味着你可以传输
iCloud驱动的应用

00:20:37.237 --> 00:20:39.373 align:middle
在App Store之外

00:20:40.007 --> 00:20:42.976 align:middle
你现可使用Developer ID
将数据分享给

00:20:43.043 --> 00:20:45.612 align:middle
你的iCloud驱动的iOS应用

00:20:46.680 --> 00:20:51.919 align:middle
你能将新的Developer ID
应用部署回macOS 10.9

00:20:52.553 --> 00:20:55.722 align:middle
所以大家一定想知道
何时能够做到如此

00:20:57.124 --> 00:21:00.394 align:middle
你今天可开始
iCloud Development测试

00:20:57.124 --> 00:21:00.394 align:middle
你今天可开始
iCloud Development测试

00:21:00.594 --> 00:21:02.796 align:middle
使用Xcode 8工具

00:21:06.433 --> 00:21:10.070 align:middle
你肯定也注意到了
当你在做iCloud测试的时候

00:21:10.137 --> 00:21:12.573 align:middle
这有一个开发和生产环境

00:21:13.073 --> 00:21:16.510 align:middle
当你在部署
你的iCloud应用时

00:21:16.677 --> 00:21:19.079 align:middle
你要在生产环境中部署

00:21:19.146 --> 00:21:20.814 align:middle
然后要等待即将发布的seed

00:21:20.881 --> 00:21:22.482 align:middle
这样才能开始测试

00:21:24.685 --> 00:21:28.755 align:middle
当你那么做的时候
请使用Xcode 8中的新流程

00:21:28.889 --> 00:21:32.926 align:middle
因为这会确保你是在
生产服务器中进行部署

00:21:34.494 --> 00:21:36.997 align:middle
Xcode团队还让我提醒大家

00:21:37.164 --> 00:21:41.301 align:middle
除非你使用GM工具
否则请不要发布应用

00:21:45.339 --> 00:21:49.710 align:middle
所以Developer ID的
另一边是Gatekeeper

00:21:50.477 --> 00:21:54.381 align:middle
Gatekeeper允许我们控制
哪些应用可以在你的机器上运行

00:21:55.582 --> 00:21:59.319 align:middle
然后这是
Preference Panel

00:21:59.486 --> 00:22:01.889 align:middle
在El Capitan中的
Preference Panel上面

00:21:59.486 --> 00:22:01.889 align:middle
在El Capitan中的
Preference Panel上面

00:22:01.955 --> 00:22:05.425 align:middle
有这些选项 你可以运行来自
Mac App Store的应用

00:22:06.126 --> 00:22:09.796 align:middle
可运行Mac App Store
和未识别开发者的应用

00:22:09.897 --> 00:22:11.732 align:middle
或者你可以运行
来自任何地方的应用

00:22:13.267 --> 00:22:18.038 align:middle
当你第一次运行应用时
Gatekeeper会运行前提示你

00:22:19.940 --> 00:22:22.376 align:middle
其实我们在Gatekeeper
上做了些更改

00:22:22.442 --> 00:22:27.114 align:middle
而且我们对Sierra中的
Gatekeeper UI也做更改

00:22:28.549 --> 00:22:32.386 align:middle
我们改变了默认选项
而且那些默认选项会是

00:22:32.452 --> 00:22:34.354 align:middle
你可以运行
Mac App Store的应用

00:22:34.688 --> 00:22:37.324 align:middle
你可运行Mac App Store
和未识别开发者的应用

00:22:38.725 --> 00:22:41.728 align:middle
现在如果Gatekeeper
出于某种原因拒绝你的应用

00:22:42.095 --> 00:22:45.299 align:middle
这通常在这个Preference Pane中
会出现一个按钮

00:22:45.365 --> 00:22:48.969 align:middle
让你打开...
继续打开

00:22:50.604 --> 00:22:54.074 align:middle
不幸的是 在seed版本中
这项功能并不起作用

00:22:54.141 --> 00:22:56.343 align:middle
但会在之后的seed
版本中得到修复

00:22:57.744 --> 00:23:00.614 align:middle
我还想说
我们没有改变

00:22:57.744 --> 00:23:00.614 align:middle
我还想说
我们没有改变

00:23:00.681 --> 00:23:04.151 align:middle
基本机制和策略的工作方式

00:23:04.351 --> 00:23:06.553 align:middle
所以如果你已经完成管理配置

00:23:06.620 --> 00:23:09.823 align:middle
或者使用命令行工具和策略工具

00:23:09.923 --> 00:23:12.259 align:middle
你可以重新启用
Allow Anywhere

00:23:18.765 --> 00:23:22.002 align:middle
我想稍微谈谈Gatekeeper
上的其他一些变更

00:23:22.202 --> 00:23:25.005 align:middle
但是我首先要谈谈
重新打包问题

00:23:25.639 --> 00:23:29.209 align:middle
和为解决该问题而
开发的Gatekeeper加强的地方

00:23:30.143 --> 00:23:32.679 align:middle
现在重新打包成为了一个问题

00:23:32.913 --> 00:23:34.882 align:middle
是由于某些应用编写的方法

00:23:36.149 --> 00:23:37.651 align:middle line:1
有一些类型的应用

00:23:37.985 --> 00:23:42.356 align:middle line:1
在编写的时候
延伸到了其本身之外

00:23:42.422 --> 00:23:44.224 align:middle line:1
并且使用了外部资源

00:23:46.827 --> 00:23:51.164 align:middle line:1
这些应用可能
以多种方式传输

00:23:53.700 --> 00:23:55.969 align:middle line:1
而且它们可能
确实有正确的签名

00:23:57.104 --> 00:24:01.475 align:middle line:1
但是它们所延伸的
外部资源可能没有签名

00:23:57.104 --> 00:24:01.475 align:middle line:1
但是它们所延伸的
外部资源可能没有签名

00:24:02.376 --> 00:24:04.411 align:middle line:1
它们可以是代码或是等价代码

00:24:04.511 --> 00:24:06.947 align:middle line:1
可以是库
可以是插件

00:24:07.214 --> 00:24:08.982 align:middle line:1
甚至可以是HTML内容

00:24:09.283 --> 00:24:11.785 align:middle line:1
你可能没注意到
本地的HTML内容

00:24:11.885 --> 00:24:15.856 align:middle line:1
如果含有JavaScript
这就可以访问你的整个系统

00:24:19.159 --> 00:24:23.030 align:middle
这些资源还可以是Lua Scripts
或Python Scripts

00:24:23.297 --> 00:24:24.765 align:middle
或甚至是Apple Scripts

00:24:27.234 --> 00:24:28.435 align:middle
所以问题在哪？

00:24:29.570 --> 00:24:32.806 align:middle
如果你将这两个东西
一起放入容器中

00:24:32.873 --> 00:24:37.177 align:middle
然后以这种方式传输应用
可能通过压缩文件或磁盘镜像

00:24:37.244 --> 00:24:42.282 align:middle
或者使用ISO镜像
然后你将应用放入容器中

00:24:44.551 --> 00:24:46.820 align:middle
然后你将资源放在应用旁边

00:24:48.822 --> 00:24:52.226 align:middle
当应用运作并和外部资源对话时

00:24:53.560 --> 00:24:56.830 align:middle
它就会加载这些
有潜在危险的东西

00:24:57.297 --> 00:25:00.167 align:middle
你会发现这里的
应用有绿色的边框

00:24:57.297 --> 00:25:00.167 align:middle
你会发现这里的
应用有绿色的边框

00:25:00.234 --> 00:25:01.668 align:middle
表明有签名

00:25:02.236 --> 00:25:05.072 align:middle line:1
它延伸到了外面
到签名的外面

00:25:05.272 --> 00:25:08.408 align:middle line:1
并尝试接触这些潜在资源

00:25:10.210 --> 00:25:12.913 align:middle line:1
所以如果我将
那个应用重新打包

00:25:13.280 --> 00:25:16.583 align:middle line:1
我不是将它和外部资源一同打包

00:25:16.850 --> 00:25:19.186 align:middle line:1
那是你们开发者想放入的内容

00:25:20.387 --> 00:25:22.222 align:middle line:1
我是将恶意内容放进去

00:25:22.789 --> 00:25:24.358 align:middle line:1
之后当用户运行应用

00:25:24.591 --> 00:25:26.760 align:middle line:1
他们不会得到你的体验

00:25:26.827 --> 00:25:30.797 align:middle line:1
他们体验到的是恶意代码

00:25:31.431 --> 00:25:34.301 align:middle
如果那个恶意代码
是一个动态库

00:25:34.368 --> 00:25:37.204 align:middle
比如你可能把它放入
一个插件目录里了

00:25:37.604 --> 00:25:40.574 align:middle
那这几乎可以肯定
你的应用将不会

00:25:40.707 --> 00:25:42.042 align:middle
执行你所预期的事情

00:25:48.582 --> 00:25:50.851 align:middle
所以我们将其
称为重新打包问题

00:25:52.186 --> 00:25:56.390 align:middle
有一些内容并非直接
受到打包问题的影响

00:25:56.990 --> 00:26:00.093 align:middle
那些内容是从Mac App
Store中传输过来的应用

00:25:56.990 --> 00:26:00.093 align:middle
那些内容是从Mac App
Store中传输过来的应用

00:26:00.794 --> 00:26:02.563 align:middle
这是获取应用的最佳方式

00:26:04.331 --> 00:26:05.966 align:middle
其他内容

00:26:07.868 --> 00:26:10.237 align:middle
可以不受直接影响的

00:26:10.404 --> 00:26:14.107 align:middle
是你使用带有签名的Apple
Installer Package来安装应用

00:26:14.942 --> 00:26:17.644 align:middle
这不意味着说
一旦应用安装完成

00:26:17.711 --> 00:26:20.848 align:middle
就无法重新打包
并传输到另一个机制中

00:26:20.914 --> 00:26:23.083 align:middle
但实际的Apple Installer Package

00:26:23.150 --> 00:26:26.653 align:middle
在延伸到外部资源的
方面是没有问题的

00:26:30.858 --> 00:26:32.593 align:middle
有些内容是会受到影响的

00:26:32.693 --> 00:26:36.530 align:middle
前提是你传输应用的方法
是用压缩文件或磁盘镜像

00:26:37.364 --> 00:26:39.666 align:middle
或者如果你将内容组合在

00:26:39.733 --> 00:26:43.570 align:middle
ISO镜像中
以及其他任何一种存档格式

00:26:46.173 --> 00:26:48.742 align:middle
还有可能的是
如果在你的磁盘镜像

00:26:48.842 --> 00:26:52.813 align:middle
的结构中
你组装应用的方式

00:26:53.180 --> 00:26:57.851 align:middle
是使用一种组合
将各处的资源

00:26:58.051 --> 00:27:01.555 align:middle
组合到一起
那你也可能受到影响

00:26:58.051 --> 00:27:01.555 align:middle
组合到一起
那你也可能受到影响

00:27:07.327 --> 00:27:09.329 align:middle
所以在此问题上
我们需要你们的帮助

00:27:12.733 --> 00:27:15.636 align:middle
由于这个问题
我们还需要保护我们客户

00:27:18.472 --> 00:27:19.540 align:middle
我们需要做什么？

00:27:20.207 --> 00:27:21.909 align:middle
如果你传输某些内容

00:27:21.975 --> 00:27:24.311 align:middle
其中有带签名的应用
和一些外部资源

00:27:24.378 --> 00:27:29.283 align:middle
你可能通过压缩文件
或磁盘镜像 或ISO镜像来做

00:27:30.117 --> 00:27:33.620 align:middle
我们要请求你们
换成使用磁盘镜像

00:27:35.689 --> 00:27:40.194 align:middle
我们请求你们这样做的原因是
我们现在可以给磁盘镜像签名了

00:27:43.096 --> 00:27:48.669 align:middle
你可以用macOS 10.11.5
来给磁盘镜像签名

00:27:48.869 --> 00:27:51.872 align:middle
这是El Capitan的当前版本

00:27:52.439 --> 00:27:55.342 align:middle
或所有之后发布的OS X

00:27:58.011 --> 00:28:00.814 align:middle
你可以使用共同签署工具
来给应用签名...

00:27:58.011 --> 00:28:00.814 align:middle
你可以使用共同签署工具
来给应用签名...

00:28:01.548 --> 00:28:03.450 align:middle
来给磁盘镜像签名
不好意思

00:28:03.884 --> 00:28:06.353 align:middle
这基本上会将

00:28:06.453 --> 00:28:08.956 align:middle
外部资源和应用绑定在一起

00:28:10.290 --> 00:28:12.860 align:middle
这些签名实际上
嵌入在磁盘镜像中

00:28:12.993 --> 00:28:14.328 align:middle
并随着磁盘镜像附带

00:28:15.128 --> 00:28:19.933 align:middle
而且这个有签名的磁盘镜像
与旧的OS版本相兼容

00:28:22.936 --> 00:28:25.072 align:middle
现在我想说一些打包建议

00:28:25.839 --> 00:28:28.242 align:middle
避免打包问题的一种方法是...

00:28:28.308 --> 00:28:30.744 align:middle
重新打包方法
就是完全避开它

00:28:31.078 --> 00:28:33.480 align:middle
将你的资源放入应用捆绑包中

00:28:33.714 --> 00:28:35.215 align:middle
之后给整个内容签名

00:28:40.854 --> 00:28:42.990 align:middle
如果你只发布
单个应用捆绑包

00:28:43.257 --> 00:28:46.226 align:middle
你应该考虑通过
Mac App Store传输

00:28:47.861 --> 00:28:49.596 align:middle
你一定要给应用签名

00:28:50.597 --> 00:28:52.666 align:middle
或许在压缩文档中打包

00:28:52.766 --> 00:28:56.236 align:middle
不过请在发布前
验证那个签名

00:28:57.504 --> 00:28:59.373 align:middle
或者 如果你有复杂的安装

00:28:59.673 --> 00:29:02.276 align:middle
你可使用带签名的Apple
Installer Package

00:28:59.673 --> 00:29:02.276 align:middle
你可使用带签名的Apple
Installer Package

00:29:02.876 --> 00:29:04.211 align:middle
对于容器

00:29:05.045 --> 00:29:07.481 align:middle
还有应用和资源
还有磁盘镜像

00:29:07.781 --> 00:29:10.384 align:middle
请使用并换成
有签名的磁盘镜像

00:29:11.218 --> 00:29:13.987 align:middle
容器中的所有内容都要签名

00:29:14.121 --> 00:29:17.191 align:middle
所以其内部的应用
也应该签上名

00:29:18.358 --> 00:29:19.927 align:middle
而且你应该给磁盘镜像签名

00:29:20.627 --> 00:29:23.597 align:middle
并请在发布前
验证所有的签名

00:29:27.401 --> 00:29:29.203 align:middle
关于打包的最后几点

00:29:31.004 --> 00:29:34.608 align:middle
如果你将个性化和
许可信息添加到你的应用上

00:29:34.675 --> 00:29:36.009 align:middle
在下载的时候

00:29:36.577 --> 00:29:39.847 align:middle
请在应用的捆绑包
路径上使用扩展属性

00:29:40.447 --> 00:29:42.883 align:middle
这是描述该做法的技术说明

00:29:43.083 --> 00:29:45.419 align:middle
那就是Tech Note 2206

00:29:45.586 --> 00:29:48.789 align:middle
你也可以通过给个性化
磁盘镜像签名来做到这一点

00:29:51.391 --> 00:29:53.894 align:middle
这里有一些
你一定不要做的事

00:29:55.028 --> 00:29:57.297 align:middle line:1
给应用签完名之后
不应进行修改

00:29:57.364 --> 00:29:58.999 align:middle line:1
因为这会破坏代码签名

00:29:59.066 --> 00:30:03.203 align:middle line:1
当Gatekeeper来验证
你的应用时 就会出现问题

00:29:59.066 --> 00:30:03.203 align:middle line:1
当Gatekeeper来验证
你的应用时 就会出现问题

00:30:03.770 --> 00:30:06.273 align:middle line:1
你绝对不可以传输
签名被破坏的应用

00:30:06.607 --> 00:30:10.143 align:middle line:1
然后请不要传输ISO镜像了

00:30:10.844 --> 00:30:14.348 align:middle
现在我想谈谈
Gatekeeper增强

00:30:14.481 --> 00:30:17.484 align:middle
这是我们为攻克这一
问题而开发出来的

00:30:18.252 --> 00:30:20.721 align:middle
这重点是为了保护客户

00:30:22.256 --> 00:30:26.059 align:middle
这个机制我们称之为
Gatekeeper Path Randomization

00:30:28.195 --> 00:30:33.033 align:middle
它补充了所有
现有的Gatekeeper保护

00:30:34.668 --> 00:30:37.738 align:middle
而且对于Mac App Store
的应用没有任何变更

00:30:41.508 --> 00:30:44.211 align:middle
当你升级Sierra时
也没有任何变更

00:30:44.411 --> 00:30:47.748 align:middle
对于任何之前在你
系统里运行的应用

00:30:50.651 --> 00:30:55.322 align:middle
这个机制对任何
新下载的应用起作用

00:30:56.723 --> 00:31:01.094 align:middle
并且适用于
无签名磁盘镜像上的应用

00:30:56.723 --> 00:31:01.094 align:middle
并且适用于
无签名磁盘镜像上的应用

00:31:03.330 --> 00:31:06.200 align:middle
我来描述一下究竟
这种机制是如何生效的

00:31:09.903 --> 00:31:11.839 align:middle line:1
这是一个复杂对象

00:31:12.239 --> 00:31:14.174 align:middle line:1
这可能在你的下载文件夹里

00:31:14.241 --> 00:31:15.642 align:middle line:1
而且可能是一个解压缩文件

00:31:16.243 --> 00:31:18.412 align:middle line:1
或者可能是一个
已装载的磁盘镜像

00:31:18.612 --> 00:31:21.715 align:middle line:1
包含你的应用和那些额外资源

00:31:26.920 --> 00:31:29.022 align:middle
所以 当你双击应用时

00:31:32.059 --> 00:31:36.396 align:middle
当应用运行后
它会被重新转移

00:31:37.898 --> 00:31:39.066 align:middle
通过一些技巧

00:31:39.533 --> 00:31:42.102 align:middle
放到文件系统里的一个随机位置

00:31:42.903 --> 00:31:45.739 align:middle line:1
而且它不能访问资源

00:31:49.843 --> 00:31:52.045 align:middle line:1
所以 这会终止重新打包攻击

00:31:54.815 --> 00:31:58.785 align:middle
所以在一些情况下
这种重新转移是不会发生的

00:32:00.687 --> 00:32:04.424 align:middle
如果用户明确地移动应用
只是移动应用本身

00:32:04.491 --> 00:32:07.127 align:middle
如果他们将应用
和其他东西一同移动

00:32:07.427 --> 00:32:10.097 align:middle
那这个机制不会关闭

00:32:10.764 --> 00:32:14.668 align:middle
如果用户只移动应用本身
可能移动到/Applications

00:32:15.369 --> 00:32:17.237 align:middle
那这个机制会被关闭

00:32:19.573 --> 00:32:23.343 align:middle
如果给磁盘镜像签名
那这就不会发生

00:32:23.911 --> 00:32:26.246 align:middle
所以任何从带有签名的
磁盘镜像运行的应用

00:32:26.313 --> 00:32:28.248 align:middle
这个机制将不会得到应用

00:32:31.318 --> 00:32:33.420 align:middle
这种机制也不会起作用

00:32:33.520 --> 00:32:37.157 align:middle
若你使用带签名的Apple
Installer Package安装软件

00:32:40.561 --> 00:32:43.564 align:middle
这也不会应用于任何来自
Mac App Store的应用

00:32:49.403 --> 00:32:52.773 align:middle
所以简要来说
本次演讲中的两个收获是

00:32:53.140 --> 00:32:56.810 align:middle
给你传输的内容进行签名
然后检查内容是否有效

00:32:59.780 --> 00:33:02.416 align:middle
所以关于本次演讲的
更多信息可以在这里找到
