WEBVTT

00:00:19.887 --> 00:00:24.591 align:middle
<c.magenta>Xcode下可视化调试工具</c>

00:00:29.796 --> 00:00:30.864 align:middle
<c.magenta>大家下午好</c>

00:00:31.632 --> 00:00:34.201 align:middle
<c.magenta>欢迎来到</c>
<c.magenta>“Xcode下可视化调试工具”演讲</c>

00:00:35.169 --> 00:00:38.172 align:middle
<c.magenta>我是Chris</c>
<c.magenta>在Xcode调试工具UI小组工作</c>

00:00:39.373 --> 00:00:43.210 align:middle
<c.magenta>众所周知 调试工具存在已久</c>

00:00:44.611 --> 00:00:46.180 align:middle
<c.magenta>就在不久以前</c>

00:00:46.246 --> 00:00:48.715 align:middle
<c.magenta>调试工具看上去还是这个样子</c>

00:00:51.418 --> 00:00:53.820 align:middle
<c.magenta>此后不久 UI进行了改进</c>

00:00:53.887 --> 00:00:56.757 align:middle
<c.magenta>调试工具开始看上去像这个样子</c>

00:00:59.259 --> 00:01:00.661 align:middle
<c.magenta>但是快进到今天</c>

00:00:59.259 --> 00:01:00.661 align:middle
<c.magenta>但是快进到今天</c>

00:01:00.727 --> 00:01:03.530 align:middle
<c.magenta>调试工具变得更加强大</c>

00:01:03.597 --> 00:01:06.066 align:middle
<c.magenta>同时也更容易操作</c>

00:01:06.567 --> 00:01:09.736 align:middle
<c.magenta>其中大部分要归功于它变得更为可视化</c>

00:01:09.803 --> 00:01:12.940 align:middle
<c.magenta>这帮助我们更为快速</c>
<c.magenta>更为直观地解决问题</c>

00:01:13.874 --> 00:01:16.076 align:middle
<c.magenta>今天 我将和同事们一起讲解</c>

00:01:16.143 --> 00:01:18.979 align:middle
<c.magenta>Xcode中最新的可视化调试工具</c>

00:01:22.583 --> 00:01:24.284 align:middle
<c.magenta>首先 快速概述一下讲座的内容</c>

00:01:25.219 --> 00:01:27.621 align:middle
<c.magenta>我们将会讲解Xcode的新功能</c>

00:01:27.688 --> 00:01:31.625 align:middle
<c.magenta>能报告工具发现的运行时问题</c>

00:01:32.626 --> 00:01:35.229 align:middle
<c.magenta>我们还将讲解最新的增强功能</c>

00:01:35.295 --> 00:01:37.197 align:middle
<c.magenta>对Xcode的视图调试工具所作的</c>

00:01:37.264 --> 00:01:40.601 align:middle
<c.magenta>以及如何把自动布局调试</c>
<c.magenta>变得前所未有地简单</c>

00:01:41.735 --> 00:01:44.838 align:middle
<c.magenta>我们还将讲解一个新功能</c>
<c.magenta>可以可视化调试</c>

00:01:44.905 --> 00:01:47.674 align:middle
<c.magenta>就是状态机 以及做出的增强</c>

00:01:47.741 --> 00:01:51.812 align:middle
<c.magenta>在FPS性能测量方面</c>
<c.magenta>从而更好帮助调试SpriteKit</c>

00:01:51.879 --> 00:01:53.514 align:middle
<c.magenta>以及SceneKit帧率问题</c>

00:01:54.548 --> 00:01:58.151 align:middle
<c.magenta>最后 将讲解Xcode的一个新功能</c>

00:01:58.218 --> 00:01:59.820 align:middle
<c.magenta>可视化内存图形调试工具</c>

00:02:03.857 --> 00:02:05.926 align:middle
<c.magenta>首先来看问题</c>

00:02:08.862 --> 00:02:12.332 align:middle
<c.magenta>我们都知道 编译时发生的问题</c>
<c.magenta>比如编译器警告 错误</c>

00:02:12.399 --> 00:02:15.469 align:middle
<c.magenta>和静态分析问题 都已经得到了</c>

00:02:15.536 --> 00:02:20.307 align:middle
<c.magenta>Xcode用户界面充分支持</c>
<c.magenta>和测试时发现的问题相同</c>

00:02:21.408 --> 00:02:24.077 align:middle
<c.magenta>然而 不能同理可证</c>

00:02:24.144 --> 00:02:27.681 align:middle
<c.magenta>调试和分析工具的扩展组件</c>
<c.magenta>发现的运行时问题</c>

00:02:28.348 --> 00:02:32.452 align:middle
<c.magenta>这些工具都已经被遗忘</c>

00:02:32.519 --> 00:02:36.757 align:middle
<c.magenta>最多会被用来在控制台上记录输出结果</c>

00:02:37.124 --> 00:02:38.292 align:middle
<c.magenta>不是最好的体验</c>

00:02:38.792 --> 00:02:40.561 align:middle
<c.magenta>我们认为可以做得更好</c>

00:02:42.396 --> 00:02:45.199 align:middle line:1
<c.magenta>在Xcode 8</c>
<c.magenta>我们引进了运行时问题</c>

00:02:52.239 --> 00:02:55.943 align:middle
<c.magenta>运行时问题</c>
<c.magenta>把工具在运行时发现的问题上升</c>

00:02:56.543 --> 00:03:00.514 align:middle
<c.magenta>和UI里传统编译时问题同等地位</c>

00:02:56.543 --> 00:03:00.514 align:middle
<c.magenta>和UI里传统编译时问题同等地位</c>

00:03:02.950 --> 00:03:05.619 align:middle
<c.magenta>活动查看器会如此显示</c>

00:03:05.686 --> 00:03:09.523 align:middle
<c.magenta>当发现任何运行时问题时</c>
<c.magenta>并报告问题数量</c>

00:03:12.025 --> 00:03:15.095 align:middle
<c.magenta>我们增强了问题浏览器</c>
<c.magenta>包含新的运行时范围</c>

00:03:15.362 --> 00:03:17.664 align:middle
<c.magenta>这区分了运行时问题</c>

00:03:17.731 --> 00:03:19.499 align:middle
<c.magenta>和传统的编译时问题</c>

00:03:19.566 --> 00:03:22.636 align:middle
<c.magenta>比如编译器警告 错误和静态分析问题</c>

00:03:26.440 --> 00:03:29.810 align:middle
<c.magenta>在运行时 会看到什么样的问题呢？</c>

00:03:30.477 --> 00:03:33.013 align:middle
<c.magenta>在Xcode 8 我们处理三个范围</c>

00:03:33.580 --> 00:03:36.316 align:middle
<c.magenta>首先 线程问题</c>

00:03:37.017 --> 00:03:38.886 align:middle
<c.magenta>我们全新的</c>
<c.magenta>"Thread Sanitizer线程检查工具"</c>

00:03:38.952 --> 00:03:43.390 align:middle
<c.magenta>可检测线程问题在应用中 在运行时</c>

00:03:45.692 --> 00:03:46.894 align:middle
<c.magenta>UI布局问题</c>

00:03:46.994 --> 00:03:49.396 align:middle
<c.magenta>我们扩展了Xcode的视图调试工具</c>

00:03:49.463 --> 00:03:52.165 align:middle
<c.magenta>来自动检测模糊的布局问题</c>

00:03:52.232 --> 00:03:53.534 align:middle
<c.magenta>在应用中 在运行时</c>

00:03:55.903 --> 00:03:56.837 align:middle
<c.magenta>以及 内存问题</c>

00:03:57.237 --> 00:03:59.139 align:middle
<c.magenta>全新的内存图形调试工具</c>

00:03:59.206 --> 00:04:01.241 align:middle
<c.magenta>一会儿我们会详细解释</c>

00:03:59.206 --> 00:04:01.241 align:middle
<c.magenta>一会儿我们会详细解释</c>

00:04:01.308 --> 00:04:03.977 align:middle
<c.magenta>它可以自动检测内存泄漏</c>

00:04:04.044 --> 00:04:05.612 align:middle
<c.magenta>在应用中 在运行时</c>

00:04:09.783 --> 00:04:11.118 align:middle
<c.magenta>所以 如你在周一所听到的</c>

00:04:11.185 --> 00:04:13.287 align:middle
<c.magenta>Xcode最新的运行时的检查工具</c>

00:04:13.353 --> 00:04:14.821 align:middle
<c.magenta>就是"Thread Sanitizer线程检查工具"</c>

00:04:15.422 --> 00:04:19.892 align:middle
<c.magenta>"Thread Sanitizer线程检查工具"</c>
<c.magenta>帮助我们检测和更好地理解线程问题</c>

00:04:19.959 --> 00:04:21.962 align:middle
<c.magenta>在应用中 在运行时</c>

00:04:22.629 --> 00:04:25.032 align:middle
<c.magenta>它可以检测到的问题有 数据竞争</c>

00:04:25.098 --> 00:04:28.368 align:middle
<c.magenta>使用为初始化的互斥锁</c>
<c.magenta>来自错误线程的解锁</c>

00:04:28.836 --> 00:04:31.471 align:middle
<c.magenta>线程泄漏及信号处理器的不安全调用等</c>

00:04:32.172 --> 00:04:36.176 align:middle
<c.magenta>发现以上任何一种问题</c>
<c.magenta>都会被报告为运行时问题</c>

00:04:37.244 --> 00:04:40.180 align:middle
<c.magenta>"Thread Sanitizer线程检查工具"</c>
<c.magenta>是一个强大的全新的运行时分析工具</c>

00:04:40.247 --> 00:04:43.083 align:middle
<c.magenta>为了更充分地理解它可以观看</c>
<c.magenta>关于"Thread Sanitizer线程检查工具"</c>

00:04:43.150 --> 00:04:44.551 align:middle
<c.magenta>以及静态分析演讲</c>

00:04:50.591 --> 00:04:52.559 align:middle
<c.magenta>视图调试是一个非常优秀的范例</c>

00:04:52.626 --> 00:04:55.495 align:middle
<c.magenta>在Xcode的调试工具中</c>
<c.magenta>变得越来越可视化</c>

00:04:56.063 --> 00:05:00.901 align:middle
<c.magenta>仅仅在过去几年 关于UI调试问题</c>

00:04:56.063 --> 00:05:00.901 align:middle
<c.magenta>仅仅在过去几年 关于UI调试问题</c>

00:05:00.968 --> 00:05:04.071 align:middle
<c.magenta>我们从必须要读取调试输出</c>

00:05:04.137 --> 00:05:07.407 align:middle
<c.magenta>到一个像这样的工具台 变成这样</c>

00:05:08.008 --> 00:05:11.245 align:middle
<c.magenta>Xcode的可视化视图调试工具</c>
<c.magenta>有非常好的用户体验</c>

00:05:11.445 --> 00:05:14.414 align:middle
<c.magenta>对于调试和理解可视化UI问题</c>

00:05:15.449 --> 00:05:16.783 align:middle
<c.magenta>如果你还从未使用过</c>

00:05:17.484 --> 00:05:19.319 align:middle
<c.magenta>当应用在运行Xcode时</c>

00:05:20.053 --> 00:05:24.291 align:middle
<c.magenta>只需点击调试工具条下方的</c>
<c.magenta>“调试视图层次结构”按钮</c>

00:05:25.526 --> 00:05:27.594 align:middle
<c.magenta>Xcode将会快照你的应用</c>

00:05:28.529 --> 00:05:29.930 align:middle
<c.magenta>快照你的视图层次结构</c>

00:05:29.997 --> 00:05:32.766 align:middle
<c.magenta>把它在一可互动的3D场景里分解出来</c>

00:05:33.600 --> 00:05:38.071 align:middle
<c.magenta>在那里</c>
<c.magenta>你可以在3D画布里检查视图层次结构</c>

00:05:38.672 --> 00:05:40.541 align:middle
<c.magenta>还可以在分级视图里</c>

00:05:40.774 --> 00:05:44.545 align:middle
<c.magenta>你可以检查所有视图和限制的属性</c>

00:05:44.611 --> 00:05:45.846 align:middle
<c.magenta>利用检查器</c>

00:05:48.916 --> 00:05:52.386 align:middle
<c.magenta>在Xcode 8</c>
<c.magenta>我们让视图调试——</c>

00:05:53.554 --> 00:05:54.988 align:middle
<c.magenta>你猜？比过去任何时候都更好</c>

00:06:02.963 --> 00:06:05.365 align:middle
<c.magenta>快照现在比过去快了近70％</c>

00:06:05.432 --> 00:06:07.201 align:middle
<c.magenta>所以你可以从运行应用</c>

00:06:07.267 --> 00:06:09.570 align:middle
<c.magenta>切换到调试UI问题 前所未有的快</c>

00:06:15.542 --> 00:06:17.110 align:middle
<c.magenta>渲染复杂布局</c>

00:06:17.177 --> 00:06:20.581 align:middle
<c.magenta>和转换视图在Xcode 8里更准确</c>

00:06:20.681 --> 00:06:24.184 align:middle
<c.magenta>谈到准确</c>
<c.magenta>Xcode现可渲染模糊视图</c>

00:06:24.251 --> 00:06:26.987 align:middle
<c.magenta>比如画布上带高保真视觉效果的视图</c>

00:06:27.621 --> 00:06:30.357 align:middle
<c.magenta>因此在Xcode的</c>
<c.magenta>视图调试工具所见到的</c>

00:06:30.424 --> 00:06:32.459 align:middle
<c.magenta>更为准确地反应了在设备上所见到的</c>

00:06:33.026 --> 00:06:35.429 align:middle
<c.magenta>在beta 2</c>
<c.magenta>将会看到改进的模糊渲染</c>

00:06:36.930 --> 00:06:39.132 align:middle
<c.magenta>我们添加了便利性 比如可以直接跳转</c>

00:06:39.199 --> 00:06:41.101 align:middle
<c.magenta>从视图类到源代码</c>

00:06:41.168 --> 00:06:43.904 align:middle
<c.magenta>只需在对象检查器上点击跳转按钮</c>

00:06:45.706 --> 00:06:48.442 align:middle
<c.magenta>浏览过滤也变得更为强大了</c>

00:06:48.842 --> 00:06:53.514 align:middle
<c.magenta>可以通过任何标签上的文本</c>
<c.magenta>或按钮标题上的文本进行过滤</c>

00:06:54.448 --> 00:06:58.719 align:middle
<c.magenta>或者你可以通过类名进行过滤</c>
<c.magenta>也包括超类名</c>

00:06:58.852 --> 00:07:02.656 align:middle
<c.magenta>比如 如果通过UI标签进行过滤</c>
<c.magenta>将会返回</c>

00:06:58.852 --> 00:07:02.656 align:middle
<c.magenta>比如 如果通过UI标签进行过滤</c>
<c.magenta>将会返回</c>

00:07:02.723 --> 00:07:05.559 align:middle
<c.magenta>所有视图层次结构中</c>
<c.magenta>该UI标签的所有子类</c>

00:07:06.193 --> 00:07:07.895 align:middle
<c.magenta>甚至可以通过内存地址进行过滤</c>

00:07:08.061 --> 00:07:10.230 align:middle
<c.magenta>这样可以迅速找到特定的视图</c>

00:07:10.297 --> 00:07:11.999 align:middle
<c.magenta>只需知道其内存地址</c>

00:07:17.171 --> 00:07:20.240 align:middle
<c.magenta>自动布局调试也进步显著</c>

00:07:20.741 --> 00:07:24.378 align:middle
<c.magenta>检查器可以显示更多</c>
<c.magenta>和自动布局相关的属性</c>

00:07:25.045 --> 00:07:27.915 align:middle
<c.magenta>限制在画布上表现得更好</c>

00:07:28.582 --> 00:07:30.484 align:middle
<c.magenta>我们用标记渲染限制</c>

00:07:30.551 --> 00:07:33.654 align:middle
<c.magenta>来代表不平等或长宽比关系</c>

00:07:33.987 --> 00:07:37.057 align:middle
<c.magenta>我们还用虚线渲染非必须限制</c>

00:07:37.124 --> 00:07:39.393 align:middle
<c.magenta>所以你可以很容易分辨</c>

00:07:39.459 --> 00:07:41.562 align:middle
<c.magenta>画布上的必须限制和非必须限制</c>

00:07:42.696 --> 00:07:45.399 align:middle
<c.magenta>但是我最欣赏的自动布局调试的新功能</c>

00:07:45.465 --> 00:07:47.601 align:middle
<c.magenta>是它结合了运行时问题</c>

00:07:49.436 --> 00:07:52.773 align:middle
<c.magenta>Xcode现可自动检测模糊布局问题</c>

00:07:52.840 --> 00:07:55.142 align:middle
<c.magenta>在视图层次结构里 在运行时</c>

00:08:01.648 --> 00:08:02.816 align:middle
<c.magenta>它是怎么运作的？</c>

00:08:03.150 --> 00:08:04.885 align:middle
<c.magenta>当快照视图层次结构时</c>

00:08:04.952 --> 00:08:09.223 align:middle
<c.magenta>Xcode将会检查每一个视图</c>
<c.magenta>并将准确决定</c>

00:08:09.289 --> 00:08:11.758 align:middle
<c.magenta>其中任何一个视图是否存在模糊布局</c>

00:08:11.825 --> 00:08:13.760 align:middle
<c.magenta>以及模糊原因</c>

00:08:14.595 --> 00:08:20.434 align:middle
<c.magenta>如果检测到任何布局问题</c>
<c.magenta>将会作为运行时问题报告</c>

00:08:21.134 --> 00:08:23.270 align:middle
<c.magenta>所以可以看见它们显示在活动查看器里</c>

00:08:23.604 --> 00:08:26.507 align:middle
<c.magenta>还可以看见它们在运行时</c>
<c.magenta>被列在问题浏览器里</c>

00:08:28.075 --> 00:08:31.645 align:middle
<c.magenta>此外 视图层次结构一览将会标记</c>

00:08:31.712 --> 00:08:34.847 align:middle
<c.magenta>任何有布局问题的视图</c>
<c.magenta>因此可以轻易找到它们</c>

00:08:34.914 --> 00:08:37.150 align:middle
<c.magenta>在整个布局层次结构下</c>

00:08:39.318 --> 00:08:42.956 align:middle
<c.magenta>对于一个选中的视图</c>
<c.magenta>尺寸检查器将会包含</c>

00:08:43.023 --> 00:08:46.326 align:middle
<c.magenta>任何布局问题的细节 以及所有</c>

00:08:46.393 --> 00:08:48.529 align:middle
<c.magenta>参与该视图布局的限制</c>

00:08:49.830 --> 00:08:51.999 align:middle
<c.magenta>我们对Xcode新功能感到十分激动</c>

00:08:52.065 --> 00:08:54.902 align:middle
<c.magenta>它可以在运行时自动检测模糊布局问题</c>

00:08:55.202 --> 00:08:56.603 align:middle
<c.magenta>我想为你们做一个演示</c>

00:08:59.273 --> 00:09:02.442 align:middle
<c.magenta>我有一个iPhone连在Mac上</c>

00:08:59.273 --> 00:09:02.442 align:middle
<c.magenta>我有一个iPhone连在Mac上</c>

00:09:02.743 --> 00:09:05.946 align:middle
<c.magenta>Xcode已经启动</c>
<c.magenta>正运行一个叫DemoBots的项目</c>

00:09:06.013 --> 00:09:10.484 align:middle
<c.magenta>这是我们今年更新Swift 3中的</c>
<c.magenta>示例代码项目之一</c>

00:09:11.385 --> 00:09:13.287 align:middle
<c.magenta>在右边 我正使用</c>
<c.magenta>QuickTime Player</c>

00:09:13.353 --> 00:09:16.290 align:middle
<c.magenta>把手机屏幕映射在桌面上</c>
<c.magenta>大家才都可以看见</c>

00:09:17.024 --> 00:09:20.027 align:middle
<c.magenta>我们的团队的任务是</c>
<c.magenta>把一个游戏指导说明书</c>

00:09:20.093 --> 00:09:22.629 align:middle
<c.magenta>添加到DemoBots</c>
<c.magenta>所以做了一个“如何开始游戏”界面</c>

00:09:23.197 --> 00:09:26.300 align:middle
<c.magenta>然而 在演讲前我们发现了一些问题</c>

00:09:26.400 --> 00:09:28.869 align:middle
<c.magenta>现在是调试这些问题的好机会</c>

00:09:29.603 --> 00:09:30.637 align:middle
<c.magenta>点击“如何开始游戏”</c>

00:09:30.971 --> 00:09:32.406 align:middle
<c.magenta>这就是“如何开始游戏”界面</c>

00:09:32.806 --> 00:09:33.740 align:middle
<c.magenta>不怎么样是吧？</c>

00:09:34.374 --> 00:09:36.577 align:middle
<c.magenta>显然 存在一些问题 来看一下</c>

00:09:36.643 --> 00:09:39.146 align:middle
<c.magenta>可以看到DemoBots图标在后面</c>

00:09:39.213 --> 00:09:41.615 align:middle
<c.magenta>上方有一些错位的文本</c>

00:09:41.982 --> 00:09:44.284 align:middle
<c.magenta>我们需要来调试 从哪儿开始？</c>

00:09:45.118 --> 00:09:46.420 align:middle
<c.magenta>给你们一点提示</c>

00:09:46.920 --> 00:09:50.023 align:middle
<c.magenta>DemoBots是一款用</c>
<c.magenta>SpriteKit编写的街机小游戏</c>

00:09:50.090 --> 00:09:53.093 align:middle
<c.magenta>但该屏幕是</c>
<c.magenta>用UIKit和自动布局产生的</c>

00:09:53.660 --> 00:09:55.929 align:middle
<c.magenta>所以最好的开始的地方是在</c>

00:09:55.996 --> 00:09:59.867 align:middle
<c.magenta>在视图层次和布局结构上</c>

00:09:59.933 --> 00:10:01.034 align:middle
<c.magenta>我们一起来操作</c>

00:09:59.933 --> 00:10:01.034 align:middle
<c.magenta>我们一起来操作</c>

00:10:01.835 --> 00:10:03.136 align:middle
<c.magenta>回到Xcode</c>

00:10:04.571 --> 00:10:05.539 align:middle
<c.magenta>最底部</c>

00:10:06.206 --> 00:10:08.342 align:middle
<c.magenta>找到“调试视图层次”按钮</c>

00:10:09.610 --> 00:10:10.711 align:middle
<c.magenta>点击</c>

00:10:10.777 --> 00:10:14.047 align:middle
<c.magenta>它将暂停应用 快照整个视图结构</c>

00:10:14.948 --> 00:10:15.816 align:middle
<c.magenta>在编辑器里</c>

00:10:16.350 --> 00:10:19.853 align:middle
<c.magenta>我们返回了刚才屏幕上所见的准确表达</c>

00:10:20.721 --> 00:10:22.956 align:middle
<c.magenta>为了查看内部结构</c>

00:10:23.023 --> 00:10:24.892 align:middle
<c.magenta>我们只需把它拖进画布</c>

00:10:24.958 --> 00:10:28.495 align:middle
<c.magenta>把完整的视图结构开拓成3D视图</c>

00:10:33.867 --> 00:10:37.204 align:middle
<c.magenta>在这里 可看到构成该屏幕的所有视图</c>

00:10:37.271 --> 00:10:38.539 align:middle
<c.magenta>后面的视窗</c>

00:10:38.672 --> 00:10:40.707 align:middle
<c.magenta>容器视图 视觉效果视图</c>

00:10:40.774 --> 00:10:43.644 align:middle
<c.magenta>及构成“如何开始游戏”说明书的视图</c>

00:10:43.944 --> 00:10:45.112 align:middle
<c.magenta>放大看一下</c>

00:10:45.579 --> 00:10:47.481 align:middle
<c.magenta>我们看到DemoBots图标在后面</c>

00:10:47.548 --> 00:10:49.383 align:middle
<c.magenta>还有很多标签和图像</c>

00:10:49.716 --> 00:10:53.086 align:middle
<c.magenta>我们迅速可以了解 通过旋转</c>

00:10:53.153 --> 00:10:55.055 align:middle
<c.magenta>找出屏幕上的一团乱的原因</c>

00:10:55.322 --> 00:10:57.925 align:middle
<c.magenta>所有这些视图都彼此叠加</c>

00:10:58.225 --> 00:10:59.526 align:middle
<c.magenta>所以我们的布局有问题</c>

00:11:00.127 --> 00:11:02.629 align:middle
<c.magenta>传统的工作流程是</c>

00:11:02.696 --> 00:11:04.565 align:middle
<c.magenta>检测每一个视图及其限制</c>

00:11:04.631 --> 00:11:07.034 align:middle
<c.magenta>然后试着确定产生布局问题的原因</c>

00:11:07.367 --> 00:11:10.304 align:middle
<c.magenta>但在Xcode 8</c>
<c.magenta>我们有一些额外的可用信息</c>

00:11:10.871 --> 00:11:13.874 align:middle
<c.magenta>注意上方的活动查看器Xcode报告</c>

00:11:13.941 --> 00:11:15.676 align:middle
<c.magenta>我们有运行时问题</c>

00:11:16.577 --> 00:11:18.545 align:middle
<c.magenta>可以点击它</c>

00:11:18.779 --> 00:11:21.481 align:middle
<c.magenta>将会打开问题浏览器</c>

00:11:21.982 --> 00:11:24.952 align:middle
<c.magenta>但你可能也注意到了左边这里</c>

00:11:25.018 --> 00:11:26.553 align:middle
<c.magenta>在调试浏览器里</c>

00:11:27.487 --> 00:11:29.423 align:middle
<c.magenta>Xcode标记出一些视图</c>

00:11:29.690 --> 00:11:31.859 align:middle
<c.magenta>它告诉我们 这些视图有布局问题</c>

00:11:31.925 --> 00:11:33.227 align:middle
<c.magenta>直接来看这里</c>

00:11:34.228 --> 00:11:35.662 align:middle
<c.magenta>如果选中第一个视图</c>

00:11:36.263 --> 00:11:38.365 align:middle
<c.magenta>画布中高亮显示</c>

00:11:38.665 --> 00:11:41.735 align:middle
<c.magenta>然后打开该视图的尺寸检查器</c>
<c.magenta>右边这里</c>

00:11:42.970 --> 00:11:46.139 align:middle
<c.magenta>在这里 我们可以在限制中</c>
<c.magenta>找出布局问题的原因</c>

00:11:46.507 --> 00:11:49.343 align:middle
<c.magenta>该视图有一个模糊垂直位置</c>

00:11:50.077 --> 00:11:52.579 align:middle
<c.magenta>也就是说自动布局没有足够的信息</c>

00:11:52.646 --> 00:11:56.083 align:middle
<c.magenta>在垂直维度明确定位该视图</c>

00:11:56.984 --> 00:11:58.685 align:middle
<c.magenta>很典型 限制缺失</c>

00:12:00.354 --> 00:12:01.722 align:middle
<c.magenta>来看下一个视图</c>

00:12:02.256 --> 00:12:04.658 align:middle
<c.magenta>有着一样的问题 垂直位置模糊</c>

00:12:05.292 --> 00:12:06.827 align:middle
<c.magenta>下一个视图也是</c>

00:12:06.894 --> 00:12:08.095 align:middle
<c.magenta>若我随机点击一些别的</c>

00:12:08.161 --> 00:12:09.796 align:middle
<c.magenta>似乎它们都有同样的问题</c>

00:12:10.264 --> 00:12:13.467 align:middle
<c.magenta>我很好奇 这个列表的第一个子视图</c>

00:12:13.934 --> 00:12:15.135 align:middle
<c.magenta>并没被标记显示有问题</c>

00:12:15.202 --> 00:12:17.304 align:middle
<c.magenta>可能是查看布局代码时的一个线索</c>

00:12:17.905 --> 00:12:18.972 align:middle
<c.magenta>现在我们来看一下</c>

00:12:19.239 --> 00:12:20.674 align:middle
<c.magenta>如果选中父视图</c>

00:12:21.241 --> 00:12:23.710 align:middle
<c.magenta>类名是</c>
<c.magenta>InstructionsLayoutView</c>

00:12:23.777 --> 00:12:26.713 align:middle
<c.magenta>这就是负责显示</c>
<c.magenta>“如何开始游戏”屏幕的视图</c>

00:12:27.581 --> 00:12:29.383 align:middle
<c.magenta>来看看它的源代码</c>

00:12:29.917 --> 00:12:32.686 align:middle
<c.magenta>一种简单的方法就是选中视图</c>

00:12:32.753 --> 00:12:34.021 align:middle
<c.magenta>右边这里</c>

00:12:34.087 --> 00:12:36.290 align:middle
<c.magenta>可以找到 对象检查器</c>

00:12:36.657 --> 00:12:39.927 align:middle
<c.magenta>该按钮可以直接跳转到视图源代码</c>

00:12:40.627 --> 00:12:41.728 align:middle
<c.magenta>如此操作</c>

00:12:41.795 --> 00:12:43.797 align:middle
<c.magenta>关上检查器 多留出一点空间</c>

00:12:44.031 --> 00:12:46.667 align:middle
<c.magenta>我们来看看</c>
<c.magenta>InstructionsLayoutView的源代码</c>

00:12:48.202 --> 00:12:50.838 align:middle
<c.magenta>首先开始循环</c>

00:12:50.904 --> 00:12:53.140 align:middle
<c.magenta>说明书的每一个部分 都是模块对象</c>

00:12:53.207 --> 00:12:57.678 align:middle
<c.magenta>描述了页眉部分 段落部分 和图片</c>

00:12:58.212 --> 00:13:00.914 align:middle
<c.magenta>代码把它们从上到下显示</c>

00:12:58.212 --> 00:13:00.914 align:middle
<c.magenta>代码把它们从上到下显示</c>

00:13:01.582 --> 00:13:04.785 align:middle
<c.magenta>对于每一个部分 修复视图</c>
<c.magenta>把它添加到视图层次结构</c>

00:13:05.152 --> 00:13:07.354 align:middle
<c.magenta>然后是水平布局的源代码</c>

00:13:07.487 --> 00:13:09.323 align:middle
<c.magenta>但在水平布局中没有发现任何问题</c>

00:13:09.389 --> 00:13:11.525 align:middle
<c.magenta>所以略过此处 到垂直布局</c>

00:13:12.526 --> 00:13:14.228 align:middle
<c.magenta>这里 有两条通路</c>

00:13:14.595 --> 00:13:17.130 align:middle
<c.magenta>第一条是 对于第一个子视图</c>

00:13:17.197 --> 00:13:18.198 align:middle
<c.magenta>把它限制到容器顶端</c>

00:13:18.866 --> 00:13:22.569 align:middle
<c.magenta>我们已经注意到 第一个子视图</c>

00:13:22.636 --> 00:13:23.871 align:middle
<c.magenta>并未报告含有任何问题</c>

00:13:24.071 --> 00:13:26.406 align:middle
<c.magenta>所以 该限制我们认为是设置正确的</c>

00:13:26.473 --> 00:13:28.642 align:middle
<c.magenta>来看看条件的另一面</c>

00:13:29.510 --> 00:13:32.713 align:middle
<c.magenta>这里 查找可选的</c>
<c.magenta>previousPartView</c>

00:13:32.779 --> 00:13:36.016 align:middle
<c.magenta>如果找到了</c>
<c.magenta>就把它指定给上面的局部变量</c>

00:13:36.383 --> 00:13:39.620 align:middle
<c.magenta>然后可把每个视图限制到它上面的视图</c>

00:13:40.020 --> 00:13:41.855 align:middle
<c.magenta>看上去这就是缺失的限制</c>

00:13:42.389 --> 00:13:46.760 align:middle
<c.magenta>让我们来看看为什么该条件不为真</c>

00:13:47.461 --> 00:13:50.864 align:middle
<c.magenta>选中previousPartView</c>
<c.magenta>我们从它开始</c>

00:13:50.931 --> 00:13:55.335 align:middle
<c.magenta>我将使用Command-A选中</c>
<c.magenta>Command-F跳出搜索栏</c>

00:13:56.069 --> 00:13:57.771 align:middle
<c.magenta>检查该变量的实例</c>

00:13:58.272 --> 00:13:59.907 align:middle
<c.magenta>可以看到其在顶端被定义</c>

00:14:00.107 --> 00:14:02.409 align:middle
<c.magenta>它被指定为nil 在for循环之前</c>

00:14:02.843 --> 00:14:04.211 align:middle
<c.magenta>在下方这里也检查</c>

00:14:04.645 --> 00:14:06.747 align:middle
<c.magenta>在外循环外又检查一次</c>

00:14:06.813 --> 00:14:08.615 align:middle
<c.magenta>来处理底部限制</c>

00:14:08.682 --> 00:14:10.717 align:middle
<c.magenta>但看上去我们从未指定给它</c>

00:14:10.918 --> 00:14:12.219 align:middle
<c.magenta>快速修复一下</c>

00:14:13.053 --> 00:14:15.422 align:middle
<c.magenta>在循环结尾 我们可把</c>
<c.magenta>previousPartView</c>

00:14:16.023 --> 00:14:17.257 align:middle
<c.magenta>设定给当前的partView</c>

00:14:17.624 --> 00:14:21.028 align:middle
<c.magenta>然后在每一个循环中</c>
<c.magenta>前一个视图都可用</c>

00:14:21.094 --> 00:14:23.497 align:middle
<c.magenta>都将指定给上面的视图</c>

00:14:23.564 --> 00:14:26.567 align:middle
<c.magenta>我们将从视图到其上面的视图</c>
<c.magenta>之间建立一个限制</c>

00:14:27.234 --> 00:14:29.169 align:middle
<c.magenta>停止 重新运行 看看结果</c>

00:14:29.903 --> 00:14:31.305 align:middle
<c.magenta>我把QuickTime移到前面</c>

00:14:32.105 --> 00:14:34.241 align:middle
<c.magenta>请注意Xcode能给提供多少信息</c>

00:14:34.308 --> 00:14:36.510 align:middle
<c.magenta>甚至在看到代码之前</c>

00:14:36.977 --> 00:14:39.279 align:middle
<c.magenta>{\an2用视图调试器查看结构内部</c>

00:14:39.346 --> 00:14:40.881 align:middle
<c.magenta>看看有什么问题</c>

00:14:41.181 --> 00:14:43.350 align:middle
<c.magenta>更重要的 Xcode会主动告诉我们</c>

00:14:43.417 --> 00:14:46.486 align:middle
<c.magenta>应用里的某些布局问题</c>

00:14:46.787 --> 00:14:50.190 align:middle
<c.magenta>哪个视图有问题 尤其是什么样的问题</c>

00:14:50.457 --> 00:14:53.093 align:middle
<c.magenta>这在我们查看代码之前就有了很多信息</c>

00:14:53.160 --> 00:14:56.463 align:middle
<c.magenta>因此我们可以迅速锁定</c>
<c.magenta>需要查看的代码部分</c>

00:14:57.698 --> 00:15:00.033 align:middle
<c.magenta>现在应用正在运行</c>
<c.magenta>点击“如何开始游戏”</c>

00:14:57.698 --> 00:15:00.033 align:middle
<c.magenta>现在应用正在运行</c>
<c.magenta>点击“如何开始游戏”</c>

00:15:01.034 --> 00:15:02.236 align:middle
<c.magenta>看上去好多了</c>

00:15:02.302 --> 00:15:03.971 align:middle
<c.magenta>我们有了一个美观的说明页面</c>

00:15:11.211 --> 00:15:16.083 align:middle
<c.magenta>现在Xcode可以报告运行时错误</c>

00:15:16.149 --> 00:15:19.253 align:middle
<c.magenta>采用和检测编译时问题时一样的UI</c>

00:15:20.587 --> 00:15:23.423 align:middle
<c.magenta>今年 Xcode的视图调试器</c>
<c.magenta>也有了显著的改进</c>

00:15:23.790 --> 00:15:27.494 align:middle
<c.magenta>包括更为迅速的快照和更为准确的渲染</c>

00:15:27.561 --> 00:15:30.297 align:middle
<c.magenta>在复杂布局和模糊视图方面</c>

00:15:31.598 --> 00:15:34.401 align:middle
<c.magenta>在自动调试方面也有了显著的改进</c>

00:15:34.468 --> 00:15:36.370 align:middle
<c.magenta>尤其是 Xcode现在可以</c>

00:15:36.436 --> 00:15:40.040 align:middle
<c.magenta>在运行时自动检测模糊布局问题</c>

00:15:40.674 --> 00:15:43.043 align:middle
<c.magenta>Xcode的视图调试器支持各种UI</c>

00:15:43.110 --> 00:15:45.679 align:middle
<c.magenta>在Mac OS iOS和tvOS上</c>

00:15:46.146 --> 00:15:47.247 align:middle
<c.magenta>在你的项目中试一下</c>

00:15:47.314 --> 00:15:50.918 align:middle
<c.magenta>我们很乐意得到反馈</c>
<c.magenta>关于它如何在调试流程中给你带来帮助</c>

00:15:53.120 --> 00:15:54.855 align:middle
<c.magenta>下面 我想把讲台让给Tyler</c>

00:15:54.922 --> 00:15:58.659 align:middle
<c.magenta>他将为我们讲解</c>
<c.magenta>调试状态机和帧速率问题</c>

00:15:58.926 --> 00:15:59.760 align:middle
<c.magenta>谢谢大家</c>

00:16:04.865 --> 00:16:05.799 align:middle
<c.magenta>谢谢Chris</c>

00:16:06.500 --> 00:16:09.336 align:middle
<c.magenta>今天 我将为大家演示</c>
<c.magenta>一种增强调试体验的新方法</c>

00:16:09.403 --> 00:16:10.771 align:middle
<c.magenta>利用状态机快速查看</c>

00:16:10.838 --> 00:16:14.274 align:middle
<c.magenta>及Xcode 8中FPS性能检测的</c>
<c.magenta>内部机理</c>

00:16:15.909 --> 00:16:17.444 align:middle
<c.magenta>今天有很多有用的快速查看</c>

00:16:17.511 --> 00:16:19.580 align:middle
<c.magenta>已经在Xcode 7里可用</c>

00:16:19.847 --> 00:16:23.183 align:middle
<c.magenta>这些为你提供了</c>
<c.magenta>实时查看各种对象的可能</c>

00:16:23.250 --> 00:16:24.318 align:middle
<c.magenta>在调试过程中</c>

00:16:24.718 --> 00:16:27.020 align:middle
<c.magenta>你甚至可以自定义快速查看</c>

00:16:27.087 --> 00:16:28.889 align:middle
<c.magenta>来检查应用内部对象</c>

00:16:29.656 --> 00:16:30.991 align:middle
<c.magenta>现在在Xcode 8</c>

00:16:31.058 --> 00:16:34.294 align:middle
<c.magenta>我们扩展了内置的快速查看</c>
<c.magenta>包含了状态机</c>

00:16:35.195 --> 00:16:37.397 align:middle
<c.magenta>首先我们来看状态机到底是什么</c>

00:16:37.464 --> 00:16:39.066 align:middle
<c.magenta>以及如何在应用内部使用</c>

00:16:41.168 --> 00:16:43.737 align:middle
<c.magenta>你们当中一定有很多人已对</c>
<c.magenta>GKStateMachine很熟悉</c>

00:16:43.804 --> 00:16:46.139 align:middle
<c.magenta>去年它是</c>
<c.magenta>GameplayKit的一部分</c>

00:16:46.206 --> 00:16:49.376 align:middle
<c.magenta>可用于</c>
<c.magenta>Mac OS iOS和tvOS</c>

00:16:50.277 --> 00:16:53.146 align:middle
<c.magenta>状态机允许你更为简单地定义复杂行为</c>

00:16:53.213 --> 00:16:55.382 align:middle
<c.magenta>通过把它构建成为一个有向图</c>

00:16:55.816 --> 00:16:57.017 align:middle
<c.magenta>在状态机内</c>

00:16:57.084 --> 00:16:59.486 align:middle
<c.magenta>你为每一个状态提供一个离散行为</c>

00:17:00.220 --> 00:17:02.723 align:middle
<c.magenta>可以像播放一个动画这么简单</c>

00:17:02.789 --> 00:17:05.459 align:middle
<c.magenta>或者更复杂的 比如一个AI</c>

00:17:06.460 --> 00:17:08.929 align:middle
<c.magenta>然后对每一个状态定义条件</c>

00:17:08.996 --> 00:17:12.266 align:middle
<c.magenta>状态机可以据此</c>
<c.magenta>从一个状态转换到另一个状态</c>

00:17:13.834 --> 00:17:17.637 align:middle
<c.magenta>组装完成后</c>
<c.magenta>状态机可以产生极其复杂的行为</c>

00:17:17.704 --> 00:17:21.308 align:middle
<c.magenta>然而 在代码里它们也会变得很难辨识</c>

00:17:21.375 --> 00:17:22.943 align:middle
<c.magenta>由于它们复杂度的增加</c>

00:17:23.377 --> 00:17:26.914 align:middle
<c.magenta>简单的状态机可以迅速进化得更为详细</c>

00:17:28.615 --> 00:17:31.118 align:middle
<c.magenta>在Xcode 7.3</c>
<c.magenta>对调试状态机的支持</c>

00:17:31.185 --> 00:17:34.087 align:middle
<c.magenta>只局限在当前状态和它的转换</c>

00:17:34.454 --> 00:17:36.156 align:middle
<c.magenta>而现在在Xcode 8</c>

00:17:36.223 --> 00:17:38.725 align:middle
<c.magenta>我们可以可视化完整的状态机</c>

00:17:38.792 --> 00:17:40.594 align:middle
<c.magenta>因此可以一目了然当前状态</c>

00:17:41.728 --> 00:17:43.764 align:middle
<c.magenta>这非常有用 不论你正在</c>

00:17:43.830 --> 00:17:46.767 align:middle
<c.magenta>操作简单的状态机 还是你在操作</c>

00:17:46.834 --> 00:17:49.469 align:middle
<c.magenta>更为复杂的状态机</c>

00:17:50.003 --> 00:17:53.207 align:middle
<c.magenta>利用快速查看</c>
<c.magenta>你可以迅速调试潜在问题</c>

00:17:53.273 --> 00:17:56.343 align:middle
<c.magenta>并且准确评估状态机的当前情况</c>

00:17:59.246 --> 00:18:01.582 align:middle
<c.magenta>现在我们把焦点转到性能</c>

00:17:59.246 --> 00:18:01.582 align:middle
<c.magenta>现在我们把焦点转到性能</c>

00:18:02.282 --> 00:18:04.751 align:middle
<c.magenta>任何时候新建任何形式的</c>
<c.magenta>游戏或视觉应用</c>

00:18:04.885 --> 00:18:06.620 align:middle
<c.magenta>保证良好性能都是关键</c>

00:18:06.987 --> 00:18:09.690 align:middle
<c.magenta>在Xcode 8</c>
<c.magenta>我们扩大了FPS性能测量</c>

00:18:09.756 --> 00:18:10.824 align:middle
<c.magenta>在这方面进行帮助</c>

00:18:12.526 --> 00:18:14.027 align:middle
<c.magenta>你们当中很多人应该已很熟悉</c>

00:18:14.094 --> 00:18:16.530 align:middle
<c.magenta>Xcode 7的FPS性能测量</c>

00:18:16.830 --> 00:18:18.632 align:middle
<c.magenta>在报告一开始</c>

00:18:18.699 --> 00:18:20.667 align:middle
<c.magenta>可以看到实时状态的数据</c>

00:18:21.535 --> 00:18:22.703 align:middle
<c.magenta>这包括了帧速率</c>

00:18:22.769 --> 00:18:25.172 align:middle
<c.magenta>即当前每秒被渲染的帧数</c>

00:18:26.006 --> 00:18:27.541 align:middle
<c.magenta>以及GPU利用率</c>

00:18:27.608 --> 00:18:30.143 align:middle
<c.magenta>可以看到哪部分的GPU利用率最高</c>

00:18:30.611 --> 00:18:33.580 align:middle
<c.magenta>以及CPU和GPU的帧时间</c>

00:18:34.147 --> 00:18:37.818 align:middle
<c.magenta>可以帮助表明</c>
<c.magenta>是CPU绑定还是GPU绑定</c>

00:18:39.953 --> 00:18:41.922 align:middle
<c.magenta>现在 除了实时数据</c>

00:18:41.989 --> 00:18:44.791 align:middle
<c.magenta>Xcode 8还提供了时间线历史</c>

00:18:44.858 --> 00:18:47.261 align:middle
<c.magenta>SpriteKit和</c>
<c.magenta>SceneKit帧时间</c>

00:18:47.327 --> 00:18:49.129 align:middle
<c.magenta>为CPU和GPU两者</c>

00:18:49.563 --> 00:18:51.665 align:middle
<c.magenta>在iOS和watchOS都可用</c>

00:18:52.165 --> 00:18:55.135 align:middle
<c.magenta>这里很棒的一点是</c>
<c.magenta>我们分解了CPU的帧时间</c>

00:18:55.202 --> 00:18:56.904 align:middle
<c.magenta>以及CPU的各个部分</c>

00:18:56.970 --> 00:18:58.572 align:middle
<c.magenta>所以可很清楚地看到有多少时间</c>

00:18:58.639 --> 00:19:01.141 align:middle
<c.magenta>用于渲染 或运行更新循环</c>

00:18:58.639 --> 00:19:01.141 align:middle
<c.magenta>用于渲染 或运行更新循环</c>

00:19:01.208 --> 00:19:04.611 align:middle
<c.magenta>评估行动和物理</c>
<c.magenta>甚至多少时间是空闲的</c>

00:19:06.046 --> 00:19:07.548 align:middle
<c.magenta>当应用暂停时</c>

00:19:07.614 --> 00:19:10.284 align:middle
<c.magenta>可以滚动查看所有性能历史</c>

00:19:10.350 --> 00:19:12.953 align:middle
<c.magenta>就可看到它随着应用的运行如何变化</c>

00:19:13.854 --> 00:19:16.123 align:middle
<c.magenta>如果有某一个特别感兴趣的地方</c>

00:19:16.190 --> 00:19:19.293 align:middle
<c.magenta>你可以深入检查更多的细节</c>

00:19:19.660 --> 00:19:21.495 align:middle
<c.magenta>查看确切时间点</c>

00:19:23.864 --> 00:19:26.300 align:middle
<c.magenta>来看一下如何在应用里应用</c>

00:19:43.116 --> 00:19:45.853 align:middle
<c.magenta>我们找到了布局问题</c>

00:19:45.953 --> 00:19:48.989 align:middle
<c.magenta>在“如何开始游戏”菜单</c>
<c.magenta>点进游戏本身</c>

00:19:51.058 --> 00:19:54.294 align:middle
<c.magenta>这个游戏的目标是</c>
<c.magenta>把所有的损坏的机器人</c>

00:19:54.361 --> 00:19:56.463 align:middle
<c.magenta>变成好的机器人</c>

00:19:57.064 --> 00:19:59.466 align:middle
<c.magenta>要达成目标 我有一道光束 射向它们</c>

00:19:59.533 --> 00:20:01.768 align:middle
<c.magenta>就可以把它们重置为好机器人</c>

00:19:59.533 --> 00:20:01.768 align:middle
<c.magenta>就可以把它们重置为好机器人</c>

00:20:02.202 --> 00:20:05.339 align:middle
<c.magenta>我们看到这里有一个坏机器人在追我</c>

00:20:05.405 --> 00:20:07.374 align:middle
<c.magenta>我用光束射向它</c>

00:20:11.578 --> 00:20:14.715 align:middle
<c.magenta>可看到它变成好机器人了 显示为绿色</c>

00:20:15.415 --> 00:20:18.218 align:middle
<c.magenta>但是我看到还有光束</c>

00:20:18.285 --> 00:20:20.654 align:middle
<c.magenta>显示在机器人上面 不该有这样的情况</c>

00:20:21.388 --> 00:20:24.892 align:middle
<c.magenta>既然我们用状态机来管理光束行为</c>

00:20:25.225 --> 00:20:26.627 align:middle
<c.magenta>这是一个很好的对象</c>

00:20:26.693 --> 00:20:29.796 align:middle
<c.magenta>来使用状态机快速查看这里是怎么回事</c>

00:20:31.365 --> 00:20:35.169 align:middle
<c.magenta>我将会暂停应用</c>
<c.magenta>浏览BeamComponent</c>

00:20:36.203 --> 00:20:39.473 align:middle
<c.magenta>我们用BeamComponent</c>
<c.magenta>来新建和更新</c>

00:20:39.540 --> 00:20:41.608 align:middle
<c.magenta>管理光束行为的状态机</c>

00:20:41.975 --> 00:20:44.178 align:middle
<c.magenta>在更新循环里添加一个断点</c>

00:20:44.244 --> 00:20:47.080 align:middle
<c.magenta>继续游戏 马上进入断点</c>

00:20:48.081 --> 00:20:50.450 align:middle
<c.magenta>因为应用已经暂停 可以进入调试区</c>

00:20:50.517 --> 00:20:52.553 align:middle
<c.magenta>找到状态机的实例</c>

00:20:52.953 --> 00:20:54.087 align:middle
<c.magenta>快速查看它</c>

00:20:55.088 --> 00:20:57.424 align:middle
<c.magenta>在这里 我们看到整个状态机</c>

00:20:58.058 --> 00:21:01.895 align:middle
<c.magenta>蓝色是当前所处状态</c>
<c.magenta>即BeamFiringState</c>

00:20:58.058 --> 00:21:01.895 align:middle
<c.magenta>蓝色是当前所处状态</c>
<c.magenta>即BeamFiringState</c>

00:21:01.962 --> 00:21:04.264 align:middle
<c.magenta>灰色是所有</c>

00:21:04.331 --> 00:21:05.866 align:middle
<c.magenta>组成状态机的其余状态</c>

00:21:06.767 --> 00:21:09.403 align:middle
<c.magenta>我们还可以看到每个状态之间的转换</c>

00:21:09.570 --> 00:21:12.773 align:middle
<c.magenta>我立即注意到的是有很多转换条件</c>

00:21:12.840 --> 00:21:16.143 align:middle
<c.magenta>指向BeamFiringState</c>
<c.magenta>但没有转换指出去</c>

00:21:16.810 --> 00:21:18.745 align:middle
<c.magenta>也就是说 一旦进入到开火模式</c>

00:21:18.812 --> 00:21:20.080 align:middle
<c.magenta>就没办法离开</c>

00:21:20.681 --> 00:21:22.716 align:middle
<c.magenta>来检查</c>
<c.magenta>BeamFiringState</c>

00:21:22.783 --> 00:21:24.051 align:middle
<c.magenta>看到底是怎么回事</c>

00:21:24.918 --> 00:21:27.754 align:middle
<c.magenta>删除断点 关闭调试区</c>

00:21:27.821 --> 00:21:29.423 align:middle
<c.magenta>切换到</c>
<c.magenta>BeamFiringState</c>

00:21:31.491 --> 00:21:33.126 align:middle
<c.magenta>现在来看更新循环</c>

00:21:33.193 --> 00:21:36.096 align:middle
<c.magenta>这里可以看到有一些转换逻辑</c>

00:21:36.163 --> 00:21:38.599 align:middle
<c.magenta>既指向CoolingState</c>
<c.magenta>又指向IdleState</c>

00:21:39.466 --> 00:21:40.667 align:middle
<c.magenta>但在下面的方法里</c>

00:21:40.734 --> 00:21:44.304 align:middle
<c.magenta>检查我们要转换的状态是否有效</c>

00:21:44.371 --> 00:21:45.806 align:middle
<c.magenta>总是返回假</c>

00:21:45.873 --> 00:21:47.908 align:middle
<c.magenta>这是不正确的 因为我们想要转换到</c>

00:21:47.975 --> 00:21:49.176 align:middle
<c.magenta>冷却状态或者空闲状态</c>

00:21:50.177 --> 00:21:51.712 align:middle
<c.magenta>现在修复该问题</c>

00:21:51.778 --> 00:21:53.714 align:middle
<c.magenta>通过检查想要转换到的状态</c>

00:21:53.780 --> 00:21:55.415 align:middle
<c.magenta>是否是两个有效的状态之一</c>

00:21:55.816 --> 00:21:57.217 align:middle
<c.magenta>回到游戏当中</c>

00:21:57.284 --> 00:21:59.553 align:middle
<c.magenta>检查这是否是我们看到的问题</c>

00:22:00.754 --> 00:22:04.625 align:middle
<c.magenta>当我们转换到FiringState</c>
<c.magenta>满足条件退出时</c>

00:22:04.691 --> 00:22:07.828 align:middle
<c.magenta>我们应该可转换回IdleState</c>

00:22:09.830 --> 00:22:10.931 align:middle
<c.magenta>进入游戏</c>

00:22:10.998 --> 00:22:14.301 align:middle
<c.magenta>向坏机器人开火</c>

00:22:14.368 --> 00:22:15.736 align:middle
<c.magenta>把它变为好机器人</c>

00:22:16.036 --> 00:22:20.073 align:middle
<c.magenta>可以看到光束已经不在游戏者头上了</c>

00:22:20.140 --> 00:22:21.775 align:middle
<c.magenta>看来问题已经解决了</c>

00:22:23.076 --> 00:22:25.679 align:middle
<c.magenta>我们还发现了游戏存在性能问题</c>

00:22:26.013 --> 00:22:28.682 align:middle
<c.magenta>底部有很多地面机器人</c>

00:22:28.749 --> 00:22:31.018 align:middle
<c.magenta>我发现如果游戏者被机器人袭击</c>

00:22:31.084 --> 00:22:33.020 align:middle
<c.magenta>性能会急剧下降</c>

00:22:33.987 --> 00:22:35.756 align:middle
<c.magenta>我将切换到FPS性能测量</c>

00:22:35.822 --> 00:22:39.059 align:middle
<c.magenta>这样就可以在运行时实时看到性能数据</c>

00:22:39.693 --> 00:22:42.963 align:middle
<c.magenta>可以看到在这里 显示的是目标帧时间</c>

00:22:43.263 --> 00:22:45.966 align:middle
<c.magenta>本例中 是16.6毫秒</c>

00:22:46.133 --> 00:22:49.303 align:middle
<c.magenta>也就是保持每秒60帧的帧速率</c>

00:22:50.838 --> 00:22:53.674 align:middle
<c.magenta>可以看到一部分时间被用在渲染的时间</c>

00:22:53.740 --> 00:22:55.442 align:middle
<c.magenta>以及用在运行客户更新的时间</c>

00:22:55.776 --> 00:22:58.512 align:middle
<c.magenta>还有CPU空闲时间的回旋余地</c>

00:22:59.947 --> 00:23:02.115 align:middle
<c.magenta>回到游戏 移到右边</c>

00:22:59.947 --> 00:23:02.115 align:middle
<c.magenta>回到游戏 移到右边</c>

00:23:02.182 --> 00:23:04.852 align:middle
<c.magenta>有一个敌人机器人 我会让它袭击我</c>

00:23:04.918 --> 00:23:07.221 align:middle
<c.magenta>试着重现性能问题</c>

00:23:08.088 --> 00:23:09.857 align:middle
<c.magenta>现在切换回性能测量</c>

00:23:09.923 --> 00:23:11.725 align:middle
<c.magenta>看看更新循环里是怎么回事</c>

00:23:12.326 --> 00:23:15.395 align:middle
<c.magenta>我发现很长一段时间被用于评估操作上</c>

00:23:15.462 --> 00:23:18.131 align:middle
<c.magenta>事实上 现在帧速率大幅下降</c>

00:23:18.899 --> 00:23:20.367 align:middle
<c.magenta>暂停应用</c>

00:23:20.434 --> 00:23:22.703 align:middle
<c.magenta>来看看其中的问题所在</c>

00:23:23.837 --> 00:23:26.306 align:middle
<c.magenta>既然已经暂停 我可以及时滚动</c>

00:23:26.373 --> 00:23:27.808 align:middle
<c.magenta>回到帧分解</c>

00:23:27.875 --> 00:23:30.244 align:middle
<c.magenta>看看应用里之前的帧时间</c>

00:23:30.711 --> 00:23:33.313 align:middle
<c.magenta>可以看到在主菜单</c>

00:23:33.380 --> 00:23:35.115 align:middle
<c.magenta>只有小部分时间用于渲染</c>

00:23:35.182 --> 00:23:36.583 align:middle
<c.magenta>大部分时间都在空闲</c>

00:23:36.950 --> 00:23:39.219 align:middle
<c.magenta>游戏中的分解部分也是如此</c>

00:23:39.586 --> 00:23:41.655 align:middle
<c.magenta>我们已经找出了性能问题</c>

00:23:41.722 --> 00:23:44.424 align:middle
<c.magenta>可以点击 然后按住来查看细节</c>

00:23:44.491 --> 00:23:46.727 align:middle
<c.magenta>对于我们发现的性能问题</c>

00:23:47.227 --> 00:23:51.665 align:middle
<c.magenta>在这里 我看到帧时间是36.2毫秒</c>

00:23:51.732 --> 00:23:54.902 align:middle
<c.magenta>71%都用于评估操作</c>

00:23:55.802 --> 00:23:59.039 align:middle
<c.magenta>也就是说在游戏中</c>
<c.magenta>可能存在一个或两个问题</c>

00:23:59.473 --> 00:24:01.241 align:middle
<c.magenta>我们可能在场景中有一个操作</c>

00:23:59.473 --> 00:24:01.241 align:middle
<c.magenta>我们可能在场景中有一个操作</c>

00:24:01.308 --> 00:24:04.444 align:middle
<c.magenta>占用了非常长的时间来评估</c>

00:24:04.845 --> 00:24:08.215 align:middle
<c.magenta>或者 可能会有很多操作</c>
<c.magenta>造成更新循环产生瓶颈</c>

00:24:08.916 --> 00:24:12.386 align:middle
<c.magenta>现在已经知道更新循环里哪里有问题</c>

00:24:16.056 --> 00:24:18.225 align:middle
<c.magenta>我们知道该如何利用状态机快速查看</c>

00:24:18.292 --> 00:24:20.627 align:middle
<c.magenta>来调试游戏中碰到的问题</c>

00:24:20.994 --> 00:24:23.130 align:middle
<c.magenta>以及FPS性能测量如何显示</c>

00:24:23.197 --> 00:24:25.866 align:middle
<c.magenta>更新循环的具体哪里出了问题</c>

00:24:26.800 --> 00:24:28.602 align:middle
<c.magenta>现邀请Daniel Delwood</c>

00:24:28.669 --> 00:24:30.838 align:middle
<c.magenta>上台为大家讲解全新的内存图形调试器</c>

00:24:30.904 --> 00:24:32.439 align:middle
<c.magenta>我们用来确定</c>

00:24:32.506 --> 00:24:35.642 align:middle
<c.magenta>操作问题从哪里产生</c>
<c.magenta>然后可以对其进行修复</c>

00:24:43.350 --> 00:24:44.284 align:middle
<c.magenta>谢谢你 Tyler</c>

00:24:44.985 --> 00:24:46.086 align:middle
<c.magenta>我很激动能够为大家讲解</c>

00:24:46.153 --> 00:24:48.722 align:middle
<c.magenta>Xcode 8里</c>
<c.magenta>全新的内存图形调试器</c>

00:24:48.789 --> 00:24:51.391 align:middle
<c.magenta>我很喜欢视图调试器</c>

00:24:51.625 --> 00:24:53.961 align:middle
<c.magenta>它是可以更好理解应用的工具</c>

00:24:54.127 --> 00:24:57.464 align:middle
<c.magenta>如同视图调试器了解视图层次结构</c>

00:24:57.531 --> 00:25:00.367 align:middle
<c.magenta>内存图形调试器可以帮助了解内存</c>

00:24:57.531 --> 00:25:00.367 align:middle
<c.magenta>内存图形调试器可以帮助了解内存</c>

00:25:00.434 --> 00:25:02.069 align:middle
<c.magenta>以及内存之间如何互相引用</c>

00:25:02.469 --> 00:25:06.073 align:middle
<c.magenta>它想回答的一个核心问题是</c>

00:25:06.340 --> 00:25:09.076 align:middle
<c.magenta>为什么某些对象还存在于堆里？</c>

00:25:10.010 --> 00:25:12.179 align:middle
<c.magenta>对象互相引用</c>

00:25:12.246 --> 00:25:16.583 align:middle
<c.magenta>你知道 现在引用</c>

00:25:16.650 --> 00:25:19.920 align:middle
<c.magenta>和注释已经成为</c>
<c.magenta>自动引用指南世界的重要问题</c>

00:25:20.721 --> 00:25:24.791 align:middle
<c.magenta>我们该如何解决存在</c>

00:25:24.858 --> 00:25:27.528 align:middle
<c.magenta>不需要的对象 泄漏的对象</c>
<c.magenta>或遗弃的对象的问题</c>

00:25:28.195 --> 00:25:31.398 align:middle
<c.magenta>有一些命令行工具 比如Heap</c>

00:25:32.065 --> 00:25:35.135 align:middle
<c.magenta>Heap将快照你的进程</c>

00:25:35.202 --> 00:25:37.804 align:middle
<c.magenta>遍历检查 找出不同类型的摘要</c>

00:25:37.871 --> 00:25:41.108 align:middle
<c.magenta>以及进程中对象数量</c>

00:25:41.175 --> 00:25:45.579 align:middle
<c.magenta>你甚至可以使用“地址”标记</c>
<c.magenta>来寻找特定类型的对象</c>

00:25:45.646 --> 00:25:47.748 align:middle
<c.magenta>获取实例列表</c>

00:25:48.315 --> 00:25:50.684 align:middle
<c.magenta>一旦对某个实例感兴趣</c>

00:25:51.185 --> 00:25:54.188 align:middle
<c.magenta>可以用leaks中</c>
<c.magenta>寻找关于连接问题的信息</c>

00:25:54.254 --> 00:25:56.423 align:middle
<c.magenta>是否未被引用？是否存在泄漏？</c>

00:25:56.790 --> 00:25:59.860 align:middle
<c.magenta>是不是从全局位置有一条通路</c>

00:25:59.927 --> 00:26:03.830 align:middle
<c.magenta>在应用中一直指向该对象？</c>

00:25:59.927 --> 00:26:03.830 align:middle
<c.magenta>在应用中一直指向该对象？</c>

00:26:05.065 --> 00:26:08.802 align:middle
<c.magenta>在任何此类调查时</c>
<c.magenta>你都可能需要进一步的细节</c>

00:26:08.869 --> 00:26:10.504 align:middle
<c.magenta>比如栈分配追踪</c>

00:26:10.804 --> 00:26:12.372 align:middle
<c.magenta>可以用</c>
<c.magenta>malloc_history获得</c>

00:26:12.906 --> 00:26:15.442 align:middle
<c.magenta>而这些都不是可视化体验</c>

00:26:15.509 --> 00:26:18.579 align:middle
<c.magenta>这就是我们为何要把这三个工具集成到</c>

00:26:18.645 --> 00:26:20.280 align:middle
<c.magenta>内存图形调试器的IDE</c>

00:26:20.681 --> 00:26:24.218 align:middle
<c.magenta>快速浏览一下它的构成</c>

00:26:24.484 --> 00:26:27.921 align:middle
<c.magenta>左边 浏览器中显示堆类型信息</c>

00:26:27.988 --> 00:26:29.256 align:middle
<c.magenta>用来开始分析</c>

00:26:29.957 --> 00:26:31.792 align:middle
<c.magenta>中间的编辑器</c>

00:26:31.859 --> 00:26:33.894 align:middle
<c.magenta>显示连接问题</c>

00:26:34.328 --> 00:26:37.564 align:middle
<c.magenta>右边 我们用来显示</c>

00:26:37.631 --> 00:26:40.501 align:middle
<c.magenta>通过检查器显示栈分配追踪</c>

00:26:40.868 --> 00:26:43.403 align:middle
<c.magenta>讲完以上 回到演示例子</c>

00:26:44.104 --> 00:26:46.507 align:middle
<c.magenta>从Tyler讲到的地方开始</c>
<c.magenta>看看我们是否</c>

00:26:46.573 --> 00:26:48.575 align:middle
<c.magenta>能看到他所看到的操作问题</c>

00:26:48.842 --> 00:26:49.710 align:middle
<c.magenta>好</c>

00:26:50.010 --> 00:26:54.748 align:middle
<c.magenta>现在我们在FPS性能测量</c>

00:26:54.815 --> 00:26:59.520 align:middle
<c.magenta>看到那些应用里可能出错的动作</c>

00:26:59.953 --> 00:27:01.655 align:middle
<c.magenta>我们可以直接查看</c>

00:26:59.953 --> 00:27:01.655 align:middle
<c.magenta>我们可以直接查看</c>

00:27:01.722 --> 00:27:04.858 align:middle
<c.magenta>通过选择内存图形调试器按钮</c>

00:27:05.058 --> 00:27:07.561 align:middle
<c.magenta>在调试菜单栏</c>

00:27:08.061 --> 00:27:10.030 align:middle
<c.magenta>左边这里</c>

00:27:10.564 --> 00:27:15.569 align:middle
<c.magenta>浏览器显示了我的应用中所有不同类型</c>

00:27:15.636 --> 00:27:17.004 align:middle
<c.magenta>分配在应用中的</c>

00:27:17.237 --> 00:27:21.775 align:middle
<c.magenta>它们按照模式被分解 然后按照类型</c>

00:27:21.842 --> 00:27:24.178 align:middle
<c.magenta>每一个对象 都有一个实例</c>

00:27:25.212 --> 00:27:29.983 align:middle
<c.magenta>在本例中 我对搜索堆感兴趣</c>

00:27:30.184 --> 00:27:31.251 align:middle
<c.magenta>这很容易做到</c>

00:27:31.318 --> 00:27:34.655 align:middle
<c.magenta>在过滤器里打字 搜索“操作”</c>

00:27:36.290 --> 00:27:38.725 align:middle
<c.magenta>出现了</c>
<c.magenta>在SpriteKit里出现所有类型</c>

00:27:38.792 --> 00:27:42.829 align:middle
<c.magenta>我们看到有很多操作——559个</c>

00:27:43.197 --> 00:27:45.532 align:middle
<c.magenta>应该是操作太多了的问题</c>

00:27:45.599 --> 00:27:49.036 align:middle
<c.magenta>而不是只有一个一直在运行的操作</c>

00:27:50.637 --> 00:27:52.406 align:middle
<c.magenta>选择其中一个对象</c>

00:27:53.040 --> 00:27:57.444 align:middle
<c.magenta>编辑器显示问题的答案</c>

00:27:57.511 --> 00:27:59.613 align:middle
<c.magenta>即为什么这个对象还存在</c>

00:28:00.013 --> 00:28:02.149 align:middle
<c.magenta>在这里 它显示了根操作图形</c>

00:28:02.216 --> 00:28:06.653 align:middle
<c.magenta>可以追踪选中的对象</c>

00:28:06.720 --> 00:28:09.523 align:middle
<c.magenta>回到左边 回到应用根目录</c>

00:28:09.890 --> 00:28:14.061 align:middle
<c.magenta>可以看到它被一个SKC序列反复引用</c>

00:28:14.127 --> 00:28:15.696 align:middle
<c.magenta>还带有一个数组</c>

00:28:15.796 --> 00:28:18.232 align:middle
<c.magenta>我还可以发现更多问题</c>

00:28:18.932 --> 00:28:22.236 align:middle
<c.magenta>这里有带一些操作的SKNode</c>

00:28:22.302 --> 00:28:25.172 align:middle
<c.magenta>这是该SKNode的部分操作列表</c>

00:28:25.439 --> 00:28:28.642 align:middle
<c.magenta>可以点击 然后快速查看</c>

00:28:29.209 --> 00:28:34.147 align:middle
<c.magenta>如果想查看关于该操作更多的信息</c>

00:28:34.214 --> 00:28:37.117 align:middle
<c.magenta>我可以选中它 拉出检查器</c>

00:28:38.719 --> 00:28:40.888 align:middle
<c.magenta>检查器将显示一些内存细节</c>

00:28:40.954 --> 00:28:44.625 align:middle
<c.magenta>比如类名 地址 层次结构</c>

00:28:44.691 --> 00:28:47.628 align:middle
<c.magenta>如果是其它对象的子类</c>

00:28:48.228 --> 00:28:50.631 align:middle
<c.magenta>我想知道该操作是在哪里新建的</c>

00:28:50.697 --> 00:28:51.798 align:middle
<c.magenta>这样就可以找到该位置</c>

00:28:52.599 --> 00:28:57.905 align:middle
<c.magenta>折叠该栈追踪 进入代码</c>

00:28:58.872 --> 00:29:02.109 align:middle
<c.magenta>这里有一个函数</c>
<c.magenta>refreshHurtAction</c>

00:28:58.872 --> 00:29:02.109 align:middle
<c.magenta>这里有一个函数</c>
<c.magenta>refreshHurtAction</c>

00:29:03.010 --> 00:29:06.180 align:middle
<c.magenta>一个HurtAction在运行</c>

00:29:06.246 --> 00:29:11.552 align:middle
<c.magenta>可以用快速帮助看到该操作已经添加到</c>

00:29:11.618 --> 00:29:14.087 align:middle
<c.magenta>结点的操作列表当中</c>

00:29:15.556 --> 00:29:18.492 align:middle
<c.magenta>但实际上我只想有一个单机操作</c>

00:29:18.559 --> 00:29:21.195 align:middle
<c.magenta>并确保它取代之前的操作</c>

00:29:21.261 --> 00:29:22.529 align:middle
<c.magenta>所以修复很简单</c>

00:29:22.596 --> 00:29:25.465 align:middle
<c.magenta>我将使用withKey变量</c>

00:29:25.532 --> 00:29:28.035 align:middle
<c.magenta>取代“playerAction”</c>

00:29:31.772 --> 00:29:35.042 align:middle
<c.magenta>快速帮助将会显示</c>
<c.magenta>是的 这就是我想要的</c>

00:29:35.108 --> 00:29:37.177 align:middle
<c.magenta>如果一个操作在使用正运行的统一键值</c>

00:29:37.244 --> 00:29:38.946 align:middle
<c.magenta>它将会在该操作加进来之前被移除</c>

00:29:39.012 --> 00:29:40.013 align:middle
<c.magenta>很好</c>

00:29:40.881 --> 00:29:46.420 align:middle
<c.magenta>这是一种非常简单的方法</c>
<c.magenta>对某个特定类型进行调查</c>

00:29:46.753 --> 00:29:47.888 align:middle
<c.magenta>但是我还注意到另外一点</c>

00:29:47.955 --> 00:29:50.791 align:middle
<c.magenta>当我点击内存图像调试按钮时</c>

00:29:50.858 --> 00:29:55.062 align:middle
<c.magenta>运行时问题浏览器提醒我有一些问题</c>

00:29:55.295 --> 00:29:56.363 align:middle
<c.magenta>点击该提醒</c>

00:29:56.430 --> 00:30:00.367 align:middle
<c.magenta>来到新的运行时问题浏览器</c>

00:29:56.430 --> 00:30:00.367 align:middle
<c.magenta>来到新的运行时问题浏览器</c>

00:30:00.868 --> 00:30:04.171 align:middle
<c.magenta>显示在应用里有很多泄漏</c>

00:30:05.372 --> 00:30:09.276 align:middle
<c.magenta>我先从模式里定义的一个类型开始</c>

00:30:09.343 --> 00:30:11.378 align:middle
<c.magenta>比如这个LoadSceneOperation</c>

00:30:12.546 --> 00:30:16.116 align:middle
<c.magenta>选中它 图形没有显示同样的风格</c>

00:30:16.183 --> 00:30:18.719 align:middle
<c.magenta>它显示了一个引用周期</c>

00:30:19.219 --> 00:30:21.889 align:middle
<c.magenta>它是一个泄漏的对象</c>

00:30:21.955 --> 00:30:24.892 align:middle
<c.magenta>从应用里的位置无法访问它</c>

00:30:25.392 --> 00:30:28.061 align:middle
<c.magenta>需要找出哪些</c>

00:30:28.128 --> 00:30:30.898 align:middle
<c.magenta>泄漏的对象正在彼此引用</c>

00:30:31.765 --> 00:30:33.100 align:middle
<c.magenta>快速来看这一点</c>

00:30:33.433 --> 00:30:36.803 align:middle
<c.magenta>有一个带有内部状态的操作</c>

00:30:37.070 --> 00:30:39.106 align:middle
<c.magenta>它在引用一个完成块</c>

00:30:39.606 --> 00:30:43.944 align:middle
<c.magenta>作为该块的一部分 有一些捕捉</c>

00:30:44.011 --> 00:30:46.213 align:middle
<c.magenta>正在强力引用LoadSceneOperation</c>

00:30:46.613 --> 00:30:47.481 align:middle
<c.magenta>有意思</c>

00:30:48.315 --> 00:30:51.418 align:middle
<c.magenta>如果点击该模块 我可以看到回溯轨迹</c>

00:30:51.485 --> 00:30:52.686 align:middle
<c.magenta>马上去那里</c>

00:30:54.855 --> 00:30:56.323 align:middle
<c.magenta>在这里</c>

00:30:56.623 --> 00:30:58.458 align:middle
<c.magenta>我的LoadSceneOperation的完成块</c>

00:30:58.525 --> 00:31:01.461 align:middle
<c.magenta>我甚至有一个“unowned self”捕捉列表</c>

00:30:58.525 --> 00:31:01.461 align:middle
<c.magenta>我甚至有一个“unowned self”捕捉列表</c>

00:31:02.029 --> 00:31:04.631 align:middle
<c.magenta>但是图形显示该self没有问题</c>

00:31:04.698 --> 00:31:07.467 align:middle
<c.magenta>问题是LoadSceneOperation</c>
<c.magenta>正在捕捉自己</c>

00:31:08.268 --> 00:31:09.770 align:middle
<c.magenta>就在该模块中</c>

00:31:11.471 --> 00:31:13.407 align:middle
<c.magenta>此处修复也非常简单</c>

00:31:13.674 --> 00:31:17.477 align:middle
<c.magenta>只需要捕捉unowned</c>

00:31:18.245 --> 00:31:21.181 align:middle
<c.magenta>就可以继续了 但是</c>

00:31:23.917 --> 00:31:26.653 align:middle
<c.magenta>可惜的是 这不是真正的解决方案</c>

00:31:26.987 --> 00:31:31.091 align:middle
<c.magenta>因为是整个模块 我的</c>
<c.magenta>LoadSceneOperation已要结束了</c>

00:31:31.558 --> 00:31:33.760 align:middle
<c.magenta>如果它执行了该模块</c>

00:31:34.194 --> 00:31:36.830 align:middle
<c.magenta>LoadSceneOperation将会结束其生命周期</c>

00:31:36.897 --> 00:31:38.599 align:middle
<c.magenta>不会存在很长时间</c>

00:31:38.966 --> 00:31:41.401 align:middle
<c.magenta>也就是说</c>
<c.magenta>如果用dispatch_async回到主队列</c>

00:31:42.536 --> 00:31:44.972 align:middle
<c.magenta>该LoadSceneOperation</c>
<c.magenta>可能已经不可用</c>

00:31:45.038 --> 00:31:46.240 align:middle
<c.magenta>系统将会崩溃</c>

00:31:46.807 --> 00:31:50.944 align:middle
<c.magenta>只是想告诉大家</c>
<c.magenta>有时这些捕捉会有点复杂</c>

00:31:51.245 --> 00:31:54.214 align:middle
<c.magenta>需要一点调查</c>

00:31:54.581 --> 00:31:56.450 align:middle
<c.magenta>希望内存图形调试器</c>

00:31:56.517 --> 00:31:58.986 align:middle
<c.magenta>也能够帮助你检查问题</c>

00:32:06.326 --> 00:32:10.397 align:middle
<c.magenta>现在我们再来讲讲泄漏和废弃内存</c>

00:32:10.964 --> 00:32:14.535 align:middle
<c.magenta>内存图形调试器是一个调试模式</c>

00:32:14.601 --> 00:32:17.471 align:middle
<c.magenta>它会暂停 开始对目标应用进行检查</c>

00:32:17.738 --> 00:32:20.607 align:middle
<c.magenta>这样应用就不会继续运行并改变状态</c>

00:32:20.674 --> 00:32:22.843 align:middle
<c.magenta>可以有一个恒定的视图</c>

00:32:22.910 --> 00:32:25.879 align:middle
<c.magenta>也可以让你做一些诸如快速查看的操作</c>
<c.magenta>或者PO不同的对象</c>

00:32:25.946 --> 00:32:27.681 align:middle
<c.magenta>在你进行调查时</c>

00:32:27.748 --> 00:32:30.184 align:middle
<c.magenta>而且在所有平台上都可用</c>

00:32:31.018 --> 00:32:33.987 align:middle
<c.magenta>如我所演示的</c>
<c.magenta>共有两种不同的图形风格</c>

00:32:34.054 --> 00:32:37.491 align:middle
<c.magenta>第一种是 根路径图形风格</c>

00:32:37.558 --> 00:32:39.426 align:middle
<c.magenta>它将显示引用过的内存</c>

00:32:39.493 --> 00:32:40.594 align:middle
<c.magenta>也许你废弃了它</c>

00:32:41.028 --> 00:32:45.299 align:middle
<c.magenta>应用中不同的根 比如全局变量</c>

00:32:45.365 --> 00:32:47.968 align:middle
<c.magenta>和正在运行的线程</c>
<c.magenta>是如何引用该内存的</c>

00:32:48.502 --> 00:32:50.103 align:middle
<c.magenta>利用渐进展开模式</c>

00:32:50.170 --> 00:32:54.708 align:middle
<c.magenta>它让你从对象开始回溯不同的中间对象</c>

00:32:54.775 --> 00:32:57.411 align:middle
<c.magenta>找到那些不应该存在的引用</c>

00:32:58.679 --> 00:33:02.716 align:middle
<c.magenta>对未引用或泄露的内存来说</c>
<c.magenta>第二种风格是周期视图</c>

00:32:58.679 --> 00:33:02.716 align:middle
<c.magenta>对未引用或泄露的内存来说</c>
<c.magenta>第二种风格是周期视图</c>

00:33:02.783 --> 00:33:08.989 align:middle
<c.magenta>其目标是帮助显示正强引用自身的对象</c>

00:33:09.056 --> 00:33:11.992 align:middle
<c.magenta>会再一次找出引用问题</c>

00:33:14.127 --> 00:33:18.465 align:middle
<c.magenta>在查看器里看到的栈记录集成</c>

00:33:20.467 --> 00:33:24.438 align:middle
<c.magenta>它无法自由记录所有的分配和释放</c>

00:33:24.505 --> 00:33:27.007 align:middle
<c.magenta>这是一种需要选择加入的诊断</c>

00:33:28.709 --> 00:33:31.879 align:middle
<c.magenta>进入方案编辑器 选中“分配栈记录”</c>

00:33:31.945 --> 00:33:34.448 align:middle
<c.magenta>在“诊断”标签</c>

00:33:34.815 --> 00:33:38.252 align:middle
<c.magenta>它将记录所有的磁盘分配和释放</c>

00:33:38.318 --> 00:33:39.653 align:middle
<c.magenta>方便之后的查询</c>

00:33:40.521 --> 00:33:42.189 align:middle
<c.magenta>但是对于内存图形调试</c>

00:33:42.256 --> 00:33:44.591 align:middle
<c.magenta>你不真正需要所有的分配和释放</c>

00:33:44.658 --> 00:33:49.329 align:middle
<c.magenta>之前的分配模块通常也没什么用</c>

00:33:49.796 --> 00:33:56.236 align:middle
<c.magenta>所以在最新的OS中有一个新特性</c>
<c.magenta>“实时只分配模式”</c>

00:33:56.303 --> 00:33:59.206 align:middle
<c.magenta>这样做开销较低</c>

00:33:59.673 --> 00:34:02.910 align:middle
<c.magenta>它还让你获得这些有用的信息</c>

00:33:59.673 --> 00:34:02.910 align:middle
<c.magenta>它还让你获得这些有用的信息</c>

00:34:02.976 --> 00:34:04.378 align:middle
<c.magenta>在进行内存图形调试时</c>

00:34:04.645 --> 00:34:09.183 align:middle
<c.magenta>它将把“分配栈记录”</c>
<c.magenta>标识为“lite”</c>

00:34:09.248 --> 00:34:10.884 align:middle
<c.magenta>在目标环境下</c>

00:34:13.320 --> 00:34:18.492 align:middle
<c.magenta>关于内存图形调试</c>
<c.magenta>你们还可能喜欢的一点</c>

00:34:18.559 --> 00:34:21.295 align:middle
<c.magenta>我们引入.memgraph文件类型</c>

00:34:21.762 --> 00:34:23.830 align:middle
<c.magenta>当在调试某个问题时</c>

00:34:23.897 --> 00:34:26.867 align:middle
<c.magenta>你并没有时间去好好研究</c>

00:34:27.234 --> 00:34:28.768 align:middle
<c.magenta>你想把它存下来</c>

00:34:28.835 --> 00:34:31.438 align:middle
<c.magenta>或者让团队里的其他工程师也来看看</c>

00:34:32.105 --> 00:34:35.141 align:middle
<c.magenta>在Xcode里</c>
<c.magenta>你可以点击“文件”菜单</c>

00:34:35.208 --> 00:34:37.277 align:middle
<c.magenta>选择“导出内存图形”</c>

00:34:37.710 --> 00:34:39.246 align:middle
<c.magenta>这将保存所有</c>

00:34:39.313 --> 00:34:41.815 align:middle
<c.magenta>连接信息和堆信息</c>

00:34:41.882 --> 00:34:45.452 align:middle
<c.magenta>以及一些VM数据 到一个文件</c>

00:34:45.853 --> 00:34:47.920 align:middle
<c.magenta>之后某个时间 你可以双击它</c>

00:34:47.987 --> 00:34:52.259 align:middle
<c.magenta>加载到Xcode 看一看内存图形</c>

00:34:52.960 --> 00:34:55.094 align:middle
<c.magenta>但是用这种方法 调试器里没有进程</c>

00:34:55.161 --> 00:34:58.999 align:middle
<c.magenta>所以你无法回溯 也无法快速查看对象</c>
<c.magenta>无法PO对象</c>

00:34:59.333 --> 00:35:03.504 align:middle
<c.magenta>但这仍然是出错后分析应用的</c>
<c.magenta>一项非常强大技术</c>

00:34:59.333 --> 00:35:03.504 align:middle
<c.magenta>但这仍然是出错后分析应用的</c>
<c.magenta>一项非常强大技术</c>

00:35:04.638 --> 00:35:08.642 align:middle
<c.magenta>如果你想持续集成</c>

00:35:09.576 --> 00:35:11.645 align:middle
<c.magenta>在命令行中有一些选项</c>

00:35:12.279 --> 00:35:16.316 align:middle
<c.magenta>只要运行leaks-outputGraph</c>
<c.magenta>选择一个路径</c>

00:35:16.383 --> 00:35:18.819 align:middle
<c.magenta>保存到一个.memgraph文件</c>
<c.magenta>以便之后使用</c>

00:35:20.020 --> 00:35:24.391 align:middle
<c.magenta>leaks vmmap heap</c>
<c.magenta>都可以读这个文件</c>

00:35:31.398 --> 00:35:33.133 align:middle
<c.magenta>好了 到了有趣的部分</c>

00:35:33.200 --> 00:35:34.801 align:middle
<c.magenta>我们来讲讲有用的小技巧</c>

00:35:34.868 --> 00:35:37.704 align:middle
<c.magenta>这一切都建立在泄漏结构上</c>

00:35:38.338 --> 00:35:40.507 align:middle
<c.magenta>说明图形是保守的</c>

00:35:41.108 --> 00:35:46.213 align:middle
<c.magenta>我们非常非常小心</c>
<c.magenta>避免在对象没有泄漏时报告其泄漏</c>

00:35:46.280 --> 00:35:50.350 align:middle
<c.magenta>避免误报</c>

00:35:50.918 --> 00:35:53.387 align:middle
<c.magenta>在图形里可能会看到多余的引用</c>

00:35:54.354 --> 00:35:59.026 align:middle
<c.magenta>这些引用将被显示为灰色 表示未知</c>

00:35:59.092 --> 00:36:01.061 align:middle
<c.magenta>可能是有效引用 可能不是</c>

00:35:59.092 --> 00:36:01.061 align:middle
<c.magenta>可能是有效引用 可能不是</c>

00:36:01.361 --> 00:36:04.364 align:middle
<c.magenta>可能不止提供元数据给工具</c>

00:36:04.731 --> 00:36:10.170 align:middle
<c.magenta>当你查看这些图形时 要多多注意</c>

00:36:10.671 --> 00:36:13.173 align:middle
<c.magenta>提高准确度的一个方法是</c>

00:36:13.240 --> 00:36:14.441 align:middle
<c.magenta>就是开启“内存涂鸦”</c>

00:36:14.508 --> 00:36:16.944 align:middle
<c.magenta>该方案下的另一个诊断工具</c>

00:36:17.311 --> 00:36:20.347 align:middle
<c.magenta>它的作用是当分配自由</c>

00:36:20.714 --> 00:36:23.851 align:middle
<c.magenta>它将把内存写入 你就不用了</c>

00:36:23.917 --> 00:36:27.721 align:middle
<c.magenta>未初始化的内存写入新的模块</c>

00:36:29.590 --> 00:36:31.325 align:middle
<c.magenta>对于那些已知的强引用来说</c>

00:36:31.391 --> 00:36:33.427 align:middle
<c.magenta>在图形里会粗体显示</c>

00:36:33.493 --> 00:36:39.233 align:middle
<c.magenta>Swift 3实际上有</c>
<c.magenta>很多可用反射元数据</c>

00:36:39.600 --> 00:36:43.804 align:middle
<c.magenta>我推荐大家使用</c>

00:36:44.571 --> 00:36:46.940 align:middle
<c.magenta>因为它绝对更为准确</c>

00:36:47.007 --> 00:36:49.476 align:middle
<c.magenta>在理解捕捉和引用方面</c>

00:36:50.511 --> 00:36:53.113 align:middle
<c.magenta>最后 我应该关掉内存图形调试器</c>

00:36:53.180 --> 00:36:55.716 align:middle
<c.magenta>暂时关闭所有检查工具</c>

00:36:55.782 --> 00:36:58.785 align:middle
<c.magenta>比如地址检查工具</c>
<c.magenta>或"Thread Sanitizer线程检查工具"</c>

00:37:00.087 --> 00:37:01.588 align:middle
<c.magenta>有很多的信息</c>

00:37:02.222 --> 00:37:04.591 align:middle
<c.magenta>这是不是一个开始编写应用的好地方？</c>

00:37:05.092 --> 00:37:07.294 align:middle
<c.magenta>验证你的期待吧</c>

00:37:07.794 --> 00:37:10.564 align:middle
<c.magenta>还有别的某种类型的对象要期待吗？</c>

00:37:11.164 --> 00:37:13.934 align:middle
<c.magenta>对象是不是在你想要时被释放？</c>

00:37:14.601 --> 00:37:17.938 align:middle
<c.magenta>你的类型还有没有泄漏？</c>

00:37:18.672 --> 00:37:21.375 align:middle
<c.magenta>如果你对某一个对象很感兴趣</c>

00:37:21.909 --> 00:37:24.378 align:middle
<c.magenta>目标就是找到一条不应该</c>

00:37:24.444 --> 00:37:25.646 align:middle
<c.magenta>连到对象上的路径</c>

00:37:26.079 --> 00:37:29.950 align:middle
<c.magenta>还有两种常见模式</c>

00:37:30.017 --> 00:37:32.619 align:middle
<c.magenta>来自块和闭包的强捕捉</c>

00:37:33.287 --> 00:37:39.026 align:middle
<c.magenta>或图形中潜在的向上引用</c>

00:37:39.359 --> 00:37:41.361 align:middle
<c.magenta>这些需要被标示为</c>
<c.magenta>“weak”或“unowned”</c>

00:37:42.629 --> 00:37:45.532 align:middle
<c.magenta>讲了很多信息</c>

00:37:46.066 --> 00:37:50.704 align:middle
<c.magenta>我非常感谢你们的倾听</c>

00:37:50.771 --> 00:37:54.641 align:middle
<c.magenta>Xcode 8中</c>
<c.magenta>全新改进的可视化工具</c>

00:37:54.842 --> 00:37:56.176 align:middle
<c.magenta>我们对此非常激动</c>

00:37:56.243 --> 00:38:00.047 align:middle
<c.magenta>如更好的可视化调试 用视图调试器</c>

00:37:56.243 --> 00:38:00.047 align:middle
<c.magenta>如更好的可视化调试 用视图调试器</c>

00:38:00.314 --> 00:38:03.750 align:middle
<c.magenta>用FPS测量以及内存图形调试器</c>

00:38:03.984 --> 00:38:08.455 align:middle
<c.magenta>今天就在应用中放手一试</c>
<c.magenta>多多解决问题吧</c>
