WEBVTT

00:00:19.853 --> 00:00:23.891
CloudKit新特性
分享无限渴望

00:00:29.830 --> 00:00:32.499
下午好 欢迎来到第226场演讲

00:00:32.566 --> 00:00:33.734
CloudKit新特性

00:00:34.334 --> 00:00:35.569
我是Paul Seligman

00:00:35.636 --> 00:00:37.738
CloudKit客户小组的工程师

00:00:38.038 --> 00:00:40.340
我今天很高兴能跟你们在一起

00:00:40.407 --> 00:00:41.742
聊一聊最新的消息

00:00:41.808 --> 00:00:43.977
和新的特性
关于CloudKit的生态系统

00:00:44.411 --> 00:00:46.113
我们今天讲什么？

00:00:46.213 --> 00:00:49.716
今天首先我们要
简单了解一下什么是CloudKit

00:00:50.050 --> 00:00:52.819
然后我们换个话题
讲一讲Telemetry

00:00:52.886 --> 00:00:55.556
这是一个新特性
可以让你想象

00:00:55.622 --> 00:00:58.258
CloudKit支持的应用如何工作

00:00:58.992 --> 00:01:02.629
我们会讲到
API的改进和可用性

00:00:58.992 --> 00:01:02.629
我们会讲到
API的改进和可用性

00:01:03.964 --> 00:01:05.632
我们还会讲到Sharing

00:01:05.699 --> 00:01:07.634
这是个新功能
可以让用户

00:01:07.701 --> 00:01:09.203
能够分享数据

00:01:09.403 --> 00:01:12.206
但同时又能完全控制
他人的访问权限

00:01:15.309 --> 00:01:16.910
什么是CloudKit？

00:01:17.444 --> 00:01:20.013
CloudKit是一种技术
让你能够

00:01:20.080 --> 00:01:22.716
使应用数据和用户数据

00:01:22.783 --> 00:01:24.351
随时随地可用

00:01:25.352 --> 00:01:29.223
CloudKit是一个框架
给你访问iCloud数据库的权限

00:01:30.691 --> 00:01:33.327
CloudKit被大量使用于
Apple产品

00:01:33.393 --> 00:01:36.129
它让你们相信我们努力的贡献

00:01:36.230 --> 00:01:38.332
它让我们自信
能够连接到

00:01:38.398 --> 00:01:40.033
数千万用户

00:01:41.802 --> 00:01:44.338
CloudKit可用于
所有Apple平台

00:01:47.741 --> 00:01:50.410
现在 我简明扼要地
介绍一下CloudKit

00:01:50.477 --> 00:01:53.814
就是过去几年我们为
引进CloudKit所做的几个方面

00:01:54.348 --> 00:01:56.550
我建议你们去听听
下一场演讲

00:01:56.617 --> 00:01:59.319
如果你想要更多的
了解生态系统

00:01:59.887 --> 00:02:01.588
我还要推荐这几场演讲

00:01:59.887 --> 00:02:01.588
我还要推荐这几场演讲

00:02:01.655 --> 00:02:04.691
他们更详细地
讲解了CloudKit的具体方面

00:02:04.858 --> 00:02:07.728
通过这些方法
你可以让你和你的应用

00:02:07.794 --> 00:02:09.562
利用CloudKit的优点

00:02:10.130 --> 00:02:12.399
现在 所有的演讲都已发布到网上
且相互关联

00:02:12.466 --> 00:02:15.235
developer.apple.com/CloudKit

00:02:18.071 --> 00:02:19.540
这里所列的东西

00:02:19.606 --> 00:02:22.609
是使用CloudKit的开发者
必须要熟悉的东西

00:02:23.010 --> 00:02:25.646
我们一个个讲
先从Container开始吧

00:02:26.480 --> 00:02:30.050
Container是一个机制
通过它可以上传数据到iCloud

00:02:30.517 --> 00:02:32.719
所以 Notes会用到Container

00:02:32.786 --> 00:02:34.321
照片会用到Container

00:02:34.388 --> 00:02:36.857
当应用在CloudKit创建时

00:02:36.924 --> 00:02:39.026
它也需要有自己的Container

00:02:40.093 --> 00:02:44.231
如果我们看看Container内部
就会发现它里面装的都是数据库

00:02:45.165 --> 00:02:47.267
直到上周
这就是我们的数据模型

00:02:47.634 --> 00:02:50.704
Container有两个数据库
一个公用的和一个个人的

00:02:51.638 --> 00:02:55.042
引进了分享后
我们就用了第三个数据库类型

00:02:55.108 --> 00:02:56.143
分享数据库

00:02:56.610 --> 00:02:58.078
这个之后细讲

00:03:00.214 --> 00:03:03.217
存储的基本单位在CloudKit里
是一个record（记录）

00:03:03.417 --> 00:03:05.552
它是一组键值对

00:03:05.819 --> 00:03:09.790
通常映射到一个目标模型
不对 是数据模型中的一个目标

00:03:10.591 --> 00:03:13.393
现在 我们不会把记录
松散的存储在数据库里

00:03:13.527 --> 00:03:16.630
而是将它们封装在
Record Zones（记录区）

00:03:17.531 --> 00:03:19.867
一个记录区可以存很多个记录

00:03:20.501 --> 00:03:23.136
一个数据库可以有很多个记录区

00:03:24.271 --> 00:03:27.474
不同的数据库
支持不同类型的记录区

00:03:28.275 --> 00:03:31.044
公用的和个人的数据库
都有一个默认的记录区

00:03:31.378 --> 00:03:34.882
这是你所有记录的归属
除非你特别指定另外一个

00:03:35.682 --> 00:03:38.619
个人数据库也可以
包括自定义的记录区

00:03:38.886 --> 00:03:42.689
这是由你的应用创建并上传到数据库

00:03:43.490 --> 00:03:47.227
最后 新的分享数据库
由分享类记录区组成

00:03:49.663 --> 00:03:53.467
有了分享功能后
这个列表上就多了一个新的核心概念

00:03:53.534 --> 00:03:54.768
就是Share的概念

00:03:55.602 --> 00:03:58.739
Share是record的子类
并同样地

00:03:58.805 --> 00:04:01.408
与Records一起
存在记录区里

00:03:58.805 --> 00:04:01.408
与Records一起
存在记录区里

00:04:01.808 --> 00:04:05.112
你可以把Record想成
你想要分享的东西

00:04:05.479 --> 00:04:07.614
Share代表的就是你如何分享它们

00:04:07.681 --> 00:04:09.850
比如参与者和许可

00:04:10.284 --> 00:04:13.387
同样 这个一会儿再说
现在只要知道有这么个东西

00:04:16.023 --> 00:04:18.959
我们在Apple的很多系统中
使用CloudKit

00:04:19.026 --> 00:04:21.995
所以我想花点时间
来着重介绍我们的几个客户

00:04:22.863 --> 00:04:26.266
在公用数据库里
有一些应用可能是你用过的

00:04:26.333 --> 00:04:28.368
WWDC应用和News应用

00:04:29.303 --> 00:04:32.472
特别是News应用
它要将文章内容和图片等

00:04:32.539 --> 00:04:33.707
保存到公用数据库里

00:04:33.907 --> 00:04:36.009
这是公用数据库
最大的好处

00:04:36.109 --> 00:04:39.680
它存的数据
是你希望所有用户都能访问的

00:04:40.581 --> 00:04:43.083
与之相对的
就是个人数据库

00:04:43.417 --> 00:04:47.020
个人数据库是
你存储用户私人数据的地方

00:04:47.521 --> 00:04:49.790
这里面有几个
是Apple的应用

00:04:49.857 --> 00:04:52.459
包括iCloud Backup和iCloud Drive

00:04:52.526 --> 00:04:54.494
iCloud Photo Library和Notes

00:04:56.396 --> 00:04:59.166
我很高兴地跟大家宣布
两个新功能

00:04:59.233 --> 00:05:01.602
Notes Collaboration
和Activity Sharing

00:04:59.233 --> 00:05:01.602
Notes Collaboration
和Activity Sharing

00:05:01.668 --> 00:05:03.871
都是创建于CloudKit Sharing之上

00:05:04.271 --> 00:05:07.241
因此
Notes和Activity应用

00:05:07.307 --> 00:05:09.009
是使用分享数据库的应用

00:05:13.280 --> 00:05:16.717
2年前 我们引入了CloudKit
通过提供两个本地框架

00:05:16.783 --> 00:05:18.886
一个是iOS 另一个是macOS

00:05:19.820 --> 00:05:21.655
去年我们这个家庭扩大了

00:05:21.722 --> 00:05:23.824
新添了tvOS数据库框架

00:05:24.024 --> 00:05:25.459
还有两个网络框架

00:05:25.526 --> 00:05:28.161
CloudKit JS
和CloudKit网络服务

00:05:29.129 --> 00:05:32.332
网络框架可以让用户
访问CloudKit数据

00:05:32.399 --> 00:05:33.634
无论是在网上

00:05:33.700 --> 00:05:36.970
还是在没有其他本地框架的平台上

00:05:38.172 --> 00:05:40.908
今年我们继续扩大
来完善这个家庭

00:05:40.974 --> 00:05:43.310
就是添加了watchOS本地框架

00:05:45.245 --> 00:05:47.814
我们这就有了一个
可用的CloudKit本地框架

00:05:47.881 --> 00:05:49.550
覆盖所有Apple平台

00:05:50.584 --> 00:05:51.852
那么现在我们来慢慢了解

00:05:51.919 --> 00:05:55.088
今年的一些
值得注意的针对平台的改进

00:05:55.155 --> 00:05:56.723
从macOS开始吧

00:05:57.958 --> 00:05:59.626
我们要与你们分享的
这个大好消息

00:05:59.693 --> 00:06:03.463
就是你不再需要通过Mac
App Store来分发应用

00:05:59.693 --> 00:06:03.463
就是你不再需要通过Mac
App Store来分发应用

00:06:03.530 --> 00:06:05.465
只要好好利用CloudKit

00:06:10.537 --> 00:06:13.073
使用iCloud for
Developer ID新特性

00:06:13.140 --> 00:06:15.609
你可以直接
授权应用使用CloudKit

00:06:15.676 --> 00:06:18.979
和其他iCloud服务
通过你的许可配置

00:06:20.480 --> 00:06:22.716
接下来我要讲的是
服务器对服务器

00:06:23.083 --> 00:06:26.119
这个功能已经
推出了几个月了

00:06:26.386 --> 00:06:28.255
它让你能够

00:06:28.322 --> 00:06:31.425
使你的服务器
直接与CloudKit服务器对话

00:06:31.491 --> 00:06:32.860
就像管理用户一样

00:06:33.994 --> 00:06:36.163
你的服务器
可向CloudKit验证自己

00:06:36.230 --> 00:06:37.931
通过使用一个公用/个人的密钥对

00:06:37.998 --> 00:06:40.834
是你已在CloudKit
Dashboard建好的

00:06:41.802 --> 00:06:43.937
你可以设置你的服务器

00:06:44.004 --> 00:06:46.507
让他们有完全权限改写公用数据库

00:06:48.141 --> 00:06:52.079
这是个很好的方法让你从服务器
导入数据给CloudKit

00:06:52.346 --> 00:06:55.349
或者从CloudKit
导出数据到服务器

00:06:55.782 --> 00:06:59.620
或者让两套数据更新
保持服务器和CloudKit一致

00:07:03.156 --> 00:07:06.493
CloudKit作为watchOS的本地框架
被引入后

00:07:06.560 --> 00:07:09.062
你就有了另一个机制
让你的Watch应用

00:07:09.129 --> 00:07:10.998
和iOS应用进行更新

00:07:11.865 --> 00:07:14.334
这样一来你可以将
CloudKit想成一个代替

00:07:14.401 --> 00:07:16.203
watch连接性框架的选项

00:07:16.370 --> 00:07:18.705
CloudKit有一个亮点

00:07:18.772 --> 00:07:20.741
就是独立功能性

00:07:22.075 --> 00:07:24.845
CloudKit使用
NSURLsession

00:07:24.912 --> 00:07:27.614
我们的网络连接
使用最好的可用界面

00:07:27.748 --> 00:07:29.850
如果你的watch是
连接到iOS设备

00:07:30.017 --> 00:07:31.985
我们会将通过iOS设备通信

00:07:32.486 --> 00:07:35.889
但是watch同时也可以
直接与CloudKit服务器对话

00:07:35.956 --> 00:07:37.090
只要有Wi-Fi

00:07:38.959 --> 00:07:43.797
现在我们来展示
完整版本的CloudKit API

00:07:44.898 --> 00:07:48.001
引进了CloudKit
作为watchOS的本地框架

00:07:48.068 --> 00:07:51.738
你就可以写出差不多的
使用CloudKit的应用代码

00:07:51.805 --> 00:07:53.607
在所有的Apple平台上

00:07:55.275 --> 00:07:57.244
比如Activity应用就使用了它

00:07:57.311 --> 00:08:01.081
写出CloudKit相似代码
用于iOS和watchOS

00:07:57.311 --> 00:08:01.081
写出CloudKit相似代码
用于iOS和watchOS

00:08:01.148 --> 00:08:03.150
来开展活动
“分享明天”

00:08:04.218 --> 00:08:07.221
注意我说的是相似代码
不是一样的代码

00:08:07.287 --> 00:08:10.624
当你编写代码
并部署给各种Apple平台

00:08:10.691 --> 00:08:14.094
你要记住
每个平台的优势和限制

00:08:14.728 --> 00:08:17.965
也就是说
有时你会打破资源的上限

00:08:18.365 --> 00:08:20.701
你必须要时刻记得
CPU的特性

00:08:20.767 --> 00:08:22.302
存储空间

00:08:22.369 --> 00:08:25.506
网络特点
比如延迟和吞吐量

00:08:26.707 --> 00:08:30.110
你可以用这些决定
与服务器对话的频率

00:08:30.177 --> 00:08:32.712
以及想要传送的数据量

00:08:33.647 --> 00:08:38.519
同样 测试仍是最好的办法
来调整你的应用去适应平台

00:08:38.784 --> 00:08:42.121
保证用户
能获得最佳的体验

00:08:45.259 --> 00:08:47.895
现在我来换个话题
讲讲Telemetry

00:08:48.128 --> 00:08:49.897
Telemetry是一个新功能

00:08:50.230 --> 00:08:51.832
让你可以形象化

00:08:51.899 --> 00:08:54.535
CloudKit应用的运行情况

00:08:55.469 --> 00:08:56.503
Telemetry表现为

00:08:56.570 --> 00:08:59.907
一系列图表 可见于
CloudKit Dashboard

00:09:01.241 --> 00:09:04.845
你可以通过它们看到
你在公用数据库中的行为

00:09:04.978 --> 00:09:08.549
或者是你在不同的用户个人数据库里
行为的集合

00:09:09.783 --> 00:09:10.984
你可以观察这些图表

00:09:11.051 --> 00:09:14.688
这样就能了解
每时每天每周每月的数据

00:09:15.589 --> 00:09:18.458
你可以选择
查看整个应用

00:09:18.759 --> 00:09:21.662
也可以集中观察
某一种操作

00:09:23.130 --> 00:09:24.831
那现在就看看它长什么样

00:09:26.300 --> 00:09:29.703
这就是CloudKit Dashboard
你可能很熟悉

00:09:29.770 --> 00:09:33.207
我请你们看看
左下角这个新的UI元素

00:09:33.273 --> 00:09:34.308
性能标签

00:09:35.375 --> 00:09:37.010
当你选择性能标签

00:09:37.077 --> 00:09:39.112
你可以访问一系列图表

00:09:39.179 --> 00:09:41.682
告诉你
你的客户都在做什么

00:09:41.748 --> 00:09:43.317
它们分两类

00:09:44.017 --> 00:09:47.354
第一个是性能图
表示的信息有

00:09:47.421 --> 00:09:50.357
每秒的操作量

00:09:50.724 --> 00:09:52.593
以及你的请求的平均大小

00:09:53.293 --> 00:09:57.264
你可以通过观察它
想象公用或个人数据库中的数据

00:09:57.331 --> 00:09:59.099
在不同时段的情况

00:09:59.433 --> 00:10:02.002
也可根据
不同操作类型观察

00:09:59.433 --> 00:10:02.002
也可根据
不同操作类型观察

00:10:03.370 --> 00:10:06.640
现在显示的这个图
我们叫做正确性图表

00:10:07.107 --> 00:10:10.110
我要你们注意的
是客户端错误

00:10:10.878 --> 00:10:14.481
它告诉你
你发出的请求中有百分之多少

00:10:14.548 --> 00:10:16.116
导致了客户端错误

00:10:17.150 --> 00:10:18.452
那么 客户端错误

00:10:18.519 --> 00:10:21.788
是一种错误的子集
是CKOperation可能会产生的报错

00:10:22.322 --> 00:10:23.624
正是这个子集

00:10:23.690 --> 00:10:26.927
才使你的应用
能解决错误并采取行动

00:10:27.394 --> 00:10:30.163
比如
你可能要保存一个记录

00:10:30.230 --> 00:10:32.966
但是服务器上
有一个与之冲突的记录改变

00:10:33.534 --> 00:10:35.269
又或者你试图获取更改

00:10:35.335 --> 00:10:37.638
从一个记录区
但服务器不知道

00:10:38.172 --> 00:10:41.308
这两种情况都会认作客户端错误
从而显示在这张图里

00:10:42.910 --> 00:10:45.479
通过形象化你的错误趋势

00:10:45.879 --> 00:10:49.082
我们希望
你可以利用它来发现

00:10:49.149 --> 00:10:52.486
客户发现异常频繁的
错误数量的情况

00:10:53.687 --> 00:10:54.955
我们之前说过

00:10:55.022 --> 00:10:58.492
错误处理很重要
特别是对CloudKit支持的应用

00:10:59.426 --> 00:11:01.995
区别能正确处理错误的应用

00:10:59.426 --> 00:11:01.995
区别能正确处理错误的应用

00:11:02.062 --> 00:11:04.264
和不能正确处理错误的应用

00:11:04.331 --> 00:11:07.601
就在于区别
功能性应用和非功能性应用

00:11:07.868 --> 00:11:11.605
重要的是它是编写
基于CloudKit的应用的一部分

00:11:12.072 --> 00:11:13.807
所以我们希望
你能好好用这些图

00:11:13.874 --> 00:11:16.343
来发现你需要检查的地方

00:11:16.410 --> 00:11:18.545
看看你的客户
是如何处理错误的

00:11:19.179 --> 00:11:21.849
要了解更多
如何处理错误的知识

00:11:21.915 --> 00:11:25.252
我推荐你们参加明天的一个演讲
CloudKit的最佳操作

00:11:25.485 --> 00:11:28.422
我们会拿出一部分时间
深入探讨正确的错误处理

00:11:30.791 --> 00:11:33.760
接下来我要说说
API的一些改进

00:11:33.994 --> 00:11:36.463
这些都是上届 WWDC后
新出的

00:11:37.030 --> 00:11:40.067
实际上我要讲四点
希望你们能仔细听

00:11:40.200 --> 00:11:42.503
首先是长时间操作

00:11:43.770 --> 00:11:47.474
长时间操作是一个机制
让你不需要重复

00:11:47.541 --> 00:11:49.610
你已经对服务器
完成的工作

00:11:50.377 --> 00:11:54.081
所以按照现在的情况
应用关闭 操作就停止

00:11:54.147 --> 00:11:57.518
所有它执行的未完成操作
也会关闭

00:11:57.851 --> 00:12:00.654
即使这个操作
马上就能完成了

00:11:57.851 --> 00:12:00.654
即使这个操作
马上就能完成了

00:12:02.623 --> 00:12:04.124
通过延长
你的操作时长

00:12:04.191 --> 00:12:07.294
操作的时长
可以超过应用的生存期

00:12:08.562 --> 00:12:11.565
它们会继续运行
CloudKit也会继续缓存

00:12:11.632 --> 00:12:14.001
本地缓存服务器的反馈

00:12:14.935 --> 00:12:18.105
当应用再次运行的时候
操作又继续运行

00:12:18.172 --> 00:12:22.176
那么我们只要返回给你
本地缓存中的缓存就可以

00:12:22.743 --> 00:12:25.112
在很多情况下
这个可以完全消除

00:12:25.179 --> 00:12:27.181
网络连接再一次往返

00:12:27.915 --> 00:12:30.717
关于创时间操作的更多细节
我们明天再讨论

00:12:30.784 --> 00:12:33.353
最佳操作 9点
欢迎你来参与

00:12:35.088 --> 00:12:38.592
下一个我想讲的话题
是从我们的开发者那里听来的

00:12:38.659 --> 00:12:42.596
是关于不良连接下
CKOperation的行为

00:12:43.096 --> 00:12:46.200
我想为你们描述的场景是
我们有一台设备

00:12:46.333 --> 00:12:48.368
设备的网络
假设可用

00:12:48.435 --> 00:12:51.138
但是我们收不到任何流量
两个方向都没有

00:12:51.605 --> 00:12:55.075
另外提一下
你实际可以模拟这个场景

00:12:55.142 --> 00:12:56.710
通过使用网络连接调节器

00:12:56.777 --> 00:13:00.113
这是一个很棒的开发者工具
可以模拟类似的情况

00:12:56.777 --> 00:13:00.113
这是一个很棒的开发者工具
可以模拟类似的情况

00:13:01.615 --> 00:13:04.585
现在 CKOperation
是NS操作的子类

00:13:04.651 --> 00:13:07.020
因此它有QualityOfService属性

00:13:07.754 --> 00:13:11.225
如果操作被标记为
用户互动或用户发起

00:13:11.291 --> 00:13:12.593
那么在不良网络环境下

00:13:12.659 --> 00:13:15.696
我们会在1分钟后停止
并给出连接超时的报错

00:13:16.597 --> 00:13:18.932
如果你的操作有任意一个
其他的QualityOfServices

00:13:18.999 --> 00:13:21.869
我们会继续尝试
最多七天

00:13:22.336 --> 00:13:23.871
这大概不是你理想的状态

00:13:24.438 --> 00:13:26.139
另外 如果你选择不设置

00:13:26.206 --> 00:13:28.709
一个明确的QualityOfService
在你的CKOperation中

00:13:28.775 --> 00:13:31.211
我们会帮你选一个
就是utility

00:13:32.279 --> 00:13:35.315
所以如果都算上
很多开发者报告说

00:13:35.382 --> 00:13:38.252
“都5天了
怎么我的操作还没完成”

00:13:38.652 --> 00:13:39.920
所以我们要解决这个问题

00:13:40.320 --> 00:13:43.056
解决办法
是两个新的API

00:13:44.024 --> 00:13:46.360
第一个用来解决
网络无活动

00:13:46.426 --> 00:13:50.631
我们视它为CKOperation的
TimeoutIntervalForRequest属性

00:13:51.465 --> 00:13:52.799
默认为1分钟

00:13:52.966 --> 00:13:56.837
这个时间
是我们等待封装传送的时间

00:13:57.471 --> 00:14:00.440
如果在这段时间内
我们没有看到任何流量进出

00:13:57.471 --> 00:14:00.440
如果在这段时间内
我们没有看到任何流量进出

00:14:00.507 --> 00:14:03.477
我们会停止操作
并告诉你网络连接超时

00:14:04.578 --> 00:14:07.514
我们还会设置
一个端到端超时

00:14:07.581 --> 00:14:11.652
表现为CKOperation的
timeoutIntervalForResource属性

00:14:12.486 --> 00:14:15.255
这个默认时长为7天
这一段时间是用来

00:14:15.322 --> 00:14:17.324
等待整个网络往返一次

00:14:17.391 --> 00:14:20.994
也就是从你的设备到服务器
然后再返回

00:14:21.828 --> 00:14:25.699
我要提醒大家一个CKOperation
可能发出多个网络请求

00:14:25.766 --> 00:14:27.201
去完成它的任务

00:14:27.768 --> 00:14:30.671
因此一个CKOperation
所需时间会超过你的预期

00:14:30.737 --> 00:14:33.040
只要有所进展
能传递就可以

00:14:36.176 --> 00:14:38.712
下面来讲讲
如何有效地获取

00:14:38.779 --> 00:14:40.047
一系列记录更改

00:14:40.113 --> 00:14:42.482
当服务器里
有很多记录区的时候

00:14:42.916 --> 00:14:46.787
我们在研究分享功能的时候发现
客户会看到更多的记录区

00:14:46.854 --> 00:14:48.255
比你过去见过的要多

00:14:49.523 --> 00:14:51.124
以前你的解决方法是

00:14:51.191 --> 00:14:54.561
从数据库中
截取一整列记录区

00:14:54.628 --> 00:14:56.763
通过使用
CKFetchRecordZonesOperation

00:14:57.931 --> 00:14:58.932
但是这会产生几个问题

00:14:58.999 --> 00:15:01.168
我们不想轮询
也不想去截取

00:14:58.999 --> 00:15:01.168
我们不想轮询
也不想去截取

00:15:01.235 --> 00:15:03.637
一整列记录区
然后从服务器上下载

00:15:03.737 --> 00:15:06.340
所以我们不再建议
使用这种方法

00:15:06.406 --> 00:15:08.542
我们用两个新的概念
代替了它

00:15:09.309 --> 00:15:11.745
第一 CKDatabaseSubscription

00:15:12.446 --> 00:15:14.181
这个新类型可以被激发

00:15:14.248 --> 00:15:16.750
当数据库里
出现任何更改的时候

00:15:17.050 --> 00:15:19.820
即便是在
一个你不曾了解的记录区

00:15:20.687 --> 00:15:24.224
第二个就是
CKFetchDatabaseChanges操作

00:15:24.758 --> 00:15:26.960
这是一种操作
让你可以请求服务器

00:15:27.027 --> 00:15:29.596
给出一列记录区
里面包含了未完成更改

00:15:29.663 --> 00:15:31.532
从过去的某个节点开始

00:15:33.967 --> 00:15:37.104
那么现在你有了一列记录区
你想从中截取更改

00:15:37.171 --> 00:15:38.472
如何做到呢？

00:15:39.106 --> 00:15:43.210
以前的方法是
发出CKFetchRecordChanges操作

00:15:43.277 --> 00:15:46.647
传递单一记录区
从这个区里获取更改

00:15:47.514 --> 00:15:51.351
我们不想让你逐个枚举
所有的记录区

00:15:51.418 --> 00:15:53.587
所以我们立刻
弃用了这个操作

00:15:54.454 --> 00:15:57.958
取而代之的是一个全新的操作
名字听上去差不多

00:15:58.192 --> 00:16:00.994
CKFetchRecordZoneChangesOperation

00:15:58.192 --> 00:16:00.994
CKFetchRecordZoneChangesOperation

00:16:02.462 --> 00:16:06.633
它实际上是个批次接口
覆盖了以前的操作

00:16:06.700 --> 00:16:07.835
让你可以

00:16:07.901 --> 00:16:10.537
从多个记录区
获取记录更改信息

00:16:10.604 --> 00:16:12.105
只要一个网络往返
就能完成

00:16:12.940 --> 00:16:14.808
那么我们就来切实看一下

00:16:16.577 --> 00:16:18.512
这是一个数据库
几个记录区

00:16:18.579 --> 00:16:20.547
每个记录区
都有一系列记录

00:16:20.781 --> 00:16:23.784
而客户更新过了
所有更改

00:16:23.851 --> 00:16:26.253
现在又出现了
几个新记录

00:16:27.187 --> 00:16:31.325
你的客户
由于已经存了CKDatabaseSubscription

00:16:31.825 --> 00:16:35.462
会造成服务器生成推送
并发给客户

00:16:36.196 --> 00:16:39.666
然后 使用
CKFetchDatabaseChangesOperation

00:16:40.033 --> 00:16:43.203
你可以向服务器请求
一列包含未完成更改的记录区

00:16:43.270 --> 00:16:45.172
这个例子里
就是第一个和第三个

00:16:46.707 --> 00:16:48.742
有了这个记录区列表

00:16:49.042 --> 00:16:51.945
你可以发起
CKFetchRecordZoneChangesOperation

00:16:52.212 --> 00:16:55.249
请求所有的记录
和所有更改的记录区

00:16:55.315 --> 00:16:56.817
完成在一个网络往返中

00:17:01.455 --> 00:17:04.790
最后我要讲讲
如何快速的获取更改

00:17:04.858 --> 00:17:07.694
在多个记录存在
一个服务器的记录区的情况下

00:17:08.829 --> 00:17:12.199
如果你以前
用过CloudKit获取记录

00:17:12.598 --> 00:17:14.734
那你会比较熟悉
moreComing标识

00:17:14.800 --> 00:17:17.704
它定义在
CKFetchRecordChangesOperation

00:17:17.771 --> 00:17:20.807
用来告诉你
这里不仅有我们给你的更改

00:17:20.874 --> 00:17:23.242
服务器上还有更多
你能获取的更改

00:17:23.310 --> 00:17:25.979
需要随后发起
CKFetchRecordChangesOperation

00:17:27.414 --> 00:17:29.283
这个方法
有几个问题

00:17:29.349 --> 00:17:32.920
第一就是
我们已经发出了检查标识的逻辑

00:17:32.986 --> 00:17:35.656
并且发起了另一个操作
对所有其他客户

00:17:36.023 --> 00:17:37.824
这有可能再次失败

00:17:38.725 --> 00:17:42.596
第二就是在你考虑
要不要获取并尾接新的操作

00:17:42.663 --> 00:17:43.964
通过尾接指令的时候

00:17:44.264 --> 00:17:45.899
CloudKit是空闲状态

00:17:46.600 --> 00:17:48.202
我们想把两个问题都解决

00:17:48.268 --> 00:17:51.038
所以我们利用了我们创建的全新操作

00:17:51.104 --> 00:17:54.341
CKFetchRecordChangesOperation
来改变这个模型

00:17:54.975 --> 00:17:57.978
不再是我们告诉你
这里有更多可用的更改

00:17:58.045 --> 00:17:59.880
而是你告诉我们

00:17:59.947 --> 00:18:02.783
你想通过新的
fetchAllChanges属性做什么

00:17:59.947 --> 00:18:02.783
你想通过新的
fetchAllChanges属性做什么

00:18:04.384 --> 00:18:05.552
它的定义为真时

00:18:05.786 --> 00:18:08.188
CloudKit会从服务器
获取一批更改

00:18:08.255 --> 00:18:09.656
交给我们的客户

00:18:09.723 --> 00:18:12.860
然后立刻返回服务器
获取下一批更改

00:18:13.493 --> 00:18:15.429
这就让运转持续进行

00:18:15.495 --> 00:18:18.298
一边开始拉取网络数据
一边是你的处理进程

00:18:19.366 --> 00:18:21.969
我们认为这应该是个常见的行为

00:18:22.035 --> 00:18:25.038
所以将它设定为这一新类的默认行为

00:18:26.507 --> 00:18:29.476
因此 新的
CKFetchRecordZoneChangesOperation

00:18:29.543 --> 00:18:32.045
默认的是
获取整个记录

00:18:32.112 --> 00:18:33.447
从指定的记录区

00:18:36.850 --> 00:18:38.819
你可能会想
如果你有了一个大记录区

00:18:38.886 --> 00:18:41.855
比如说服务器上
用户的iCloud Photo Library

00:18:41.922 --> 00:18:45.726
这就意味着后续的操作
就要获取记录区中的所有记录

00:18:45.792 --> 00:18:47.861
需要很长一段时间完成

00:18:48.629 --> 00:18:50.330
所以我们想能迅速恢复

00:18:50.397 --> 00:18:52.799
如果操作中途失败的话

00:18:52.866 --> 00:18:56.570
我们不想重新下载
已经从服务器上获取的批

00:18:57.104 --> 00:18:59.506
因此我们给这个新类
添加了新的回调

00:19:00.407 --> 00:19:03.110
RecordZoneChangeTokensUpdatedBlock

00:19:03.544 --> 00:19:05.212
在给出一批更改之后

00:19:05.279 --> 00:19:08.248
我们会告诉你
一个最新的服务器更改token

00:19:08.982 --> 00:19:12.419
那么你写的代码
要做到两件事

00:19:13.053 --> 00:19:14.655
首先你要commit

00:19:14.721 --> 00:19:18.091
每个你从服务器获得的
记录的更改

00:19:19.026 --> 00:19:22.563
第二要缓存
这个服务器token

00:19:23.864 --> 00:19:25.999
如果操作
在未来某个节点失败了

00:19:26.066 --> 00:19:29.770
你可以发起一个新的
CKFetchRecordZoneChangesOperation

00:19:30.103 --> 00:19:32.806
传递给已经本地缓存好的
服务器token

00:19:32.873 --> 00:19:35.209
然后直接从断掉的地方
继续操作

00:19:35.309 --> 00:19:39.012
不需要重新下载
已经从服务器下载过的批数据

00:19:40.681 --> 00:19:43.951
这4个API的改进功能
是我们希望你们能好好利用的

00:19:44.017 --> 00:19:47.688
如果你正在编写
基于CloudKit的应用

00:19:48.689 --> 00:19:50.457
接下来 我要换一个话题了

00:19:50.524 --> 00:19:53.627
让我们有请Jacob Farkas上台
来为我们讲解Sharing UI

00:19:54.127 --> 00:19:58.866
SHARING UI
你和我的分享空间

00:20:00.968 --> 00:20:01.802
谢谢你 Paul

00:20:02.469 --> 00:20:05.939
我是Jacob Farkas
是CloudKit小组的工程师

00:20:06.006 --> 00:20:07.441
今天我要讲的是

00:20:07.508 --> 00:20:10.544
如何将CloudKit分享界面
添加到你的应用中

00:20:10.611 --> 00:20:12.613
而且只需要写几行代码

00:20:15.415 --> 00:20:18.485
我们已介绍了CloudKit新类型
就是CKShare

00:20:18.785 --> 00:20:20.854
这是CKRecord的子类

00:20:21.021 --> 00:20:24.057
它负责存储两种重要的信息

00:20:24.625 --> 00:20:26.293
第一 分享的信息

00:20:26.693 --> 00:20:30.264
第二 分享给谁

00:20:31.565 --> 00:20:33.333
那么我们来看个例子

00:20:33.400 --> 00:20:34.902
这是个人数据库

00:20:34.968 --> 00:20:36.937
这里有一个备注
在个人数据库里

00:20:37.271 --> 00:20:38.438
我们想分享它

00:20:39.840 --> 00:20:42.109
因此 我们要创建CKShare

00:20:43.410 --> 00:20:46.280
并把那个记录作为root record（根记录）
来对它初始化

00:20:47.214 --> 00:20:49.783
创建Share
必须使用根记录

00:20:49.850 --> 00:20:51.885
所以Share里必须有内容

00:20:53.854 --> 00:20:56.423
接下来我们要保存
这个Share和根记录

00:20:56.490 --> 00:20:57.991
要同时存到服务器

00:20:58.725 --> 00:21:02.296
这么做是因为
CKRecord有一个新属性

00:20:58.725 --> 00:21:02.296
这么做是因为
CKRecord有一个新属性

00:21:02.362 --> 00:21:04.665
就是我们正在创建的Share
的一个引用

00:21:04.865 --> 00:21:07.501
通过同时保存根记录和Share

00:21:08.068 --> 00:21:10.737
这个引用会与
你刚刚创建的Share联系起来

00:21:14.174 --> 00:21:16.677
我们不仅要定义分享什么

00:21:16.743 --> 00:21:19.279
也需要定义分享给谁

00:21:20.080 --> 00:21:23.083
因此我们在CloudKit里创建了
新的lookup服务

00:21:24.585 --> 00:21:27.554
这个lookup服务
会利用一个电子邮箱

00:21:28.055 --> 00:21:30.791
然后转给
一个CKShare使用者

00:21:31.124 --> 00:21:33.493
你可在Share上
设置这个Share使用者

00:21:33.827 --> 00:21:35.329
将Share存到服务器

00:21:35.395 --> 00:21:38.699
现在他的iCloud账户
就可以访问Share了

00:21:40.601 --> 00:21:43.203
我们也支持
通过电话号码寻找用户

00:21:43.270 --> 00:21:45.138
或者通过CloudKit用户记录ID

00:21:48.342 --> 00:21:52.513
现在我们希望用户可以控制
他们分享数据库里的动态

00:21:52.579 --> 00:21:55.449
不想让这些记录反复不停地出现

00:21:55.782 --> 00:21:58.118
用户需要能控制它
这样才能

00:21:58.185 --> 00:22:00.220
接受这个Share并加入它

00:21:58.185 --> 00:22:00.220
接受这个Share并加入它

00:22:01.054 --> 00:22:03.457
这就是说我们需要一个方法
去告诉其他用户

00:22:03.524 --> 00:22:05.459
我们分享了东西给他们
并邀请他们

00:22:05.526 --> 00:22:06.894
并且告诉他们需要加入

00:22:07.461 --> 00:22:09.196
这个就是通过URL来实现

00:22:10.931 --> 00:22:14.201
每一个分享都带一个URL
作为它唯一的身份

00:22:15.102 --> 00:22:19.973
如果用户在iOS按一下这个URL
或者macOS上点击它

00:22:20.307 --> 00:22:22.142
接受UI会显示出来

00:22:22.376 --> 00:22:24.611
询问他们是否要加入这个Share

00:22:25.045 --> 00:22:27.080
如果是 会跳转到应用

00:22:27.147 --> 00:22:28.982
他们会看到这个Share的内容

00:22:30.551 --> 00:22:34.488
URL最好的一点就是
如果用户使用比较老的平台

00:22:34.555 --> 00:22:36.590
或者是不支持分享的平台

00:22:37.024 --> 00:22:38.625
它会转到iCloud.com

00:22:38.692 --> 00:22:41.028
这样我们也能
让他们看到Share的内容

00:22:41.195 --> 00:22:43.830
告诉他们
如何接受并加入这个Share

00:22:45.599 --> 00:22:48.435
那么就把这个URL放进电子邮件

00:22:48.735 --> 00:22:51.338
然后发送给
我们邀请的其他参与者

00:22:52.506 --> 00:22:55.342
他们会收到这封邮件 点击它

00:22:55.776 --> 00:22:57.344
然后在他们的分享数据库里

00:22:57.411 --> 00:23:00.747
就可看到这个Share和Note
是我们创建并分享给他们的

00:22:57.411 --> 00:23:00.747
就可看到这个Share和Note
是我们创建并分享给他们的

00:23:02.449 --> 00:23:05.018
这里最精彩的就是
这个分享数据库

00:23:05.085 --> 00:23:08.021
实际上是个视图
可以看到用户的个人数据库

00:23:08.288 --> 00:23:11.558
所以 如果另一个用户
有权限访问Share

00:23:12.025 --> 00:23:13.260
并且更新了这个Note

00:23:13.660 --> 00:23:16.930
我们会看到同样的更改
出现在我们的个人数据库中

00:23:17.931 --> 00:23:20.501
那么我们来看一看
UI里这个是什么样子

00:23:29.076 --> 00:23:32.312
好 我们做了Note
并添加了分享

00:23:32.379 --> 00:23:34.147
平台是macOS X Sierra

00:23:35.883 --> 00:23:39.987
通过使用我们今天发布的
CloudKit分享API

00:23:40.821 --> 00:23:44.458
就会看到一个新的Share Add
Person按钮出现在上方

00:23:44.691 --> 00:23:46.059
点击它

00:23:47.327 --> 00:23:50.697
会收到一个新的菜单
选择如何分享URL

00:23:52.566 --> 00:23:53.567
当我们点击分享

00:23:54.234 --> 00:23:57.171
系统UI会调令Notes...

00:23:57.638 --> 00:23:59.740
告诉Notes
要存下这个Share

00:23:59.806 --> 00:24:01.441
以及根记录
给服务器

00:23:59.806 --> 00:24:01.441
以及根记录
给服务器

00:24:02.376 --> 00:24:05.445
一旦成功
系统UI会跳出一个写邮件的窗口

00:24:05.512 --> 00:24:07.147
这里可以邀请其他用户

00:24:08.148 --> 00:24:09.283
点击发送

00:24:09.850 --> 00:24:12.686
系统UI就会将这个Share
存到服务器

00:24:12.753 --> 00:24:14.188
寻找参与者

00:24:14.621 --> 00:24:16.723
然后再把邮件转发给其他用户

00:24:18.292 --> 00:24:20.761
那么换到iPad看看
这里另一个用户

00:24:20.827 --> 00:24:22.296
我们看到了刚发出去的邮件

00:24:23.130 --> 00:24:24.932
我们可以点这个URL

00:24:25.766 --> 00:24:27.968
然后会询问我们
是否要加入这个Share

00:24:29.603 --> 00:24:31.605
如果选是
我们会直接跳转到Notes

00:24:31.672 --> 00:24:33.540
Share会显示
Note开始下载

00:24:33.607 --> 00:24:36.109
现在我们就把这个Note
分享给其他用户了

00:24:37.311 --> 00:24:39.713
如果对Note进行更改
在发起人的界面

00:24:39.980 --> 00:24:42.416
比如说我取消选择列表上的牛油果

00:24:42.482 --> 00:24:44.852
添加青柠为
另外要买的东西

00:24:45.586 --> 00:24:48.522
我们会看到
分享给我们的note也变了

00:24:56.530 --> 00:24:58.398
那么现在看看
背后的代码

00:25:01.735 --> 00:25:04.071
你们现在可能已经
很熟悉CloudKit框架了

00:25:04.137 --> 00:25:07.608
也就是CKRecord
和新的CKShare目标存在的地方

00:25:08.275 --> 00:25:10.511
如果要使用
新的系统分享UI

00:25:10.577 --> 00:25:13.447
你可以在
macOS下的AppKit里

00:25:13.881 --> 00:25:15.949
和iOS下的UIKit里找到

00:25:20.053 --> 00:25:22.689
首先我们来看iOS分享API

00:25:24.458 --> 00:25:28.295
在调出UI之前
当然要先创建一个Share

00:25:28.362 --> 00:25:30.564
我们就用这个根记录创建Share

00:25:31.498 --> 00:25:35.002
我们会设置几个属性
让UI显示这个Share

00:25:35.969 --> 00:25:37.404
标题和缩略图

00:25:38.539 --> 00:25:43.043
然后我们接着创建
UI云分享控制器

00:25:44.344 --> 00:25:48.148
我们用刚建的Share对它初始化
然后传递给他一个准备处理器

00:25:49.016 --> 00:25:51.185
这个准备处理器会被调出

00:25:51.251 --> 00:25:53.820
当要把这个分享记录
保存到服务器时

00:25:54.221 --> 00:25:57.691
这个处理器会创建
一个CKModifyRecordsOperation

00:25:58.158 --> 00:26:00.060
保存记录和Share到服务器

00:25:58.158 --> 00:26:00.060
保存记录和Share到服务器

00:26:00.594 --> 00:26:03.330
完成之后
就会调出完成处理器

00:26:06.633 --> 00:26:10.737
下面我们就要设置一个属性
给这个UI云分享控制器

00:26:11.738 --> 00:26:14.541
其中一个属性就是
available permissions

00:26:14.608 --> 00:26:17.678
我们可以选择
是只公开分享这个Share

00:26:17.744 --> 00:26:21.181
还是只给参与者
读或写的许可

00:26:21.815 --> 00:26:25.953
我们还要设置
presentation controller源视图

00:26:26.019 --> 00:26:30.357
让添加朋友的弹窗出现在
我们点击按钮的地方

00:26:31.725 --> 00:26:33.293
我们定义自己为代理

00:26:33.360 --> 00:26:36.230
这样我们就可以收到
UI活动的返回

00:26:36.797 --> 00:26:39.566
最后调出Present
这时

00:26:39.633 --> 00:26:42.102
跳出一个这样的弹窗

00:26:43.470 --> 00:26:45.973
这时 如果你已经保存了
这个Share到服务器

00:26:46.039 --> 00:26:49.109
就可以只用Share
调出UI云分享控制器

00:26:49.676 --> 00:26:51.812
然后它会显示
一个被邀请用户的列表

00:26:51.879 --> 00:26:53.981
让他们管理Share上的用户

00:26:54.047 --> 00:26:55.849
也可以按他们的意愿停止分享

00:26:55.916 --> 00:26:58.852
所有的事情
系统UI都为你考虑好了

00:27:02.222 --> 00:27:04.224
macOS分享API
跟这个十分相似

00:27:04.291 --> 00:27:07.094
所以我们就快速过一下
着重讲一下不同之处

00:27:09.196 --> 00:27:11.598
首先创建一个
NSItem provider

00:27:11.665 --> 00:27:14.134
用它注册
CloudKit Share

00:27:14.701 --> 00:27:16.737
这个处理器看上去
跟我们之前看到的一样

00:27:16.803 --> 00:27:19.039
你要把记录里的Share
保存到服务器

00:27:19.106 --> 00:27:21.308
完成后 调出完成处理器

00:27:22.843 --> 00:27:25.479
接下来你要创建一个
NSSharingService

00:27:26.213 --> 00:27:29.550
这个分享服务的代理
就是你自己

00:27:29.616 --> 00:27:30.717
然后调出perform

00:27:30.784 --> 00:27:33.253
通过刚刚创建的
NSItem provider

00:27:36.523 --> 00:27:39.893
最后 NSSharingService可以回调

00:27:39.960 --> 00:27:43.430
所以 如果你设置
Share的可操作选项

00:27:43.697 --> 00:27:46.533
你就要回调
Share选项

00:27:49.136 --> 00:27:52.105
macOS上
Share创建的UI是这个样子

00:27:52.539 --> 00:27:56.276
如果要在Share上修改参与者
界面是这样

00:27:59.313 --> 00:28:02.449
如果一个用户
接受你的应用的分享

00:27:59.313 --> 00:28:02.449
如果一个用户
接受你的应用的分享

00:28:02.850 --> 00:28:04.518
你的应用就会发布

00:28:04.585 --> 00:28:08.956
然后收到这个回调
ApplicationuserAcceptedCloudKitShare

00:28:09.456 --> 00:28:13.360
回调中包含Share元数据
是根记录中的Share

00:28:13.427 --> 00:28:14.828
是用户刚刚同意的

00:28:15.729 --> 00:28:17.231
这个iOS的操作很像

00:28:17.297 --> 00:28:20.834
除了用的是UIApplication
而非NSApplication

00:28:23.570 --> 00:28:27.708
最后 你要告诉系统
你的应用支持CloudKit分享

00:28:28.008 --> 00:28:30.544
这要通过
CKSharingSupported key实现

00:28:30.611 --> 00:28:31.912
就在info P list里

00:28:34.314 --> 00:28:37.217
我们还要高兴地宣布
我们已经把完全分享支持添加到了

00:28:37.284 --> 00:28:39.286
CloudKit JavaScript库

00:28:39.353 --> 00:28:42.789
这样只要你在网上
就可以创建和接受Share

00:28:42.856 --> 00:28:47.194
而且我们已经提供了一些UI
让你可以用来管理Share

00:28:47.861 --> 00:28:50.731
你现在就可以
在CloudKit目录里试试看

00:28:51.899 --> 00:28:54.301
现在我要将舞台
转交给我的同事Vanessa

00:28:54.368 --> 00:28:57.137
她会为你们
深入讲解分享

00:29:02.276 --> 00:29:03.143
谢谢你 Jacob

00:29:04.144 --> 00:29:05.679
嗨 下午好

00:29:06.446 --> 00:29:07.548
我叫Vanessa Hong

00:29:07.614 --> 00:29:09.983
我是CloudKit
服务器小组的工程师

00:29:11.218 --> 00:29:15.989
今天我们要深入了解分享
通过展示一些常见的使用场景

00:29:18.158 --> 00:29:20.327
首先从被分享的数据讲起吧

00:29:20.394 --> 00:29:22.196
之后我们会逐步深入

00:29:22.262 --> 00:29:24.431
讲解CKShare对象中的
internal

00:29:25.165 --> 00:29:28.402
之后我们讲讲
如何调出分享API

00:29:28.468 --> 00:29:30.404
如果你想创建
自定义的UI的话

00:29:31.238 --> 00:29:33.907
最后结尾讲一些
特别需要注意的事项

00:29:34.374 --> 00:29:35.475
现在就开始吧

00:29:38.545 --> 00:29:40.814
Jacob展示了
如何分享一个单一记录

00:29:41.181 --> 00:29:45.752
但是用户想分享的
有时不只是一个单一的记录

00:29:46.019 --> 00:29:48.322
可能是很多记录

00:29:48.655 --> 00:29:51.158
可能已经连接了
CKReferences

00:29:52.593 --> 00:29:57.130
但是你的应用只想让参与者
看到这个记录的一部分

00:29:57.898 --> 00:30:00.934
这就是为什么我们要在
CKRecord上引进新的域

00:29:57.898 --> 00:30:00.934
这就是为什么我们要在
CKRecord上引进新的域

00:30:01.001 --> 00:30:02.669
叫Parent Reference

00:30:04.004 --> 00:30:05.138
设置
Parent Reference

00:30:05.205 --> 00:30:08.475
可以在任何
你想在包含于分享结构层的记录上

00:30:09.142 --> 00:30:12.613
这个设置甚至可以
在用户决定分享之前完成

00:30:16.083 --> 00:30:17.251
当用户确实要分享

00:30:17.317 --> 00:30:20.153
你可以只用根记录
创建CKShare

00:30:20.587 --> 00:30:22.322
之后所有产生的记录

00:30:22.389 --> 00:30:25.592
都会通过Parent Reference
链接到这个根记录

00:30:25.826 --> 00:30:28.462
并且自动
存入分享结构层

00:30:29.129 --> 00:30:31.932
那么来看看
在分享数据库里是什么样子

00:30:34.168 --> 00:30:38.172
一个分享数据库只是一个视图
可以看到用户的个人数据库

00:30:38.739 --> 00:30:41.074
所以它不包含
任何具体的记录

00:30:42.843 --> 00:30:47.447
当一个参与者接受了一个Share
他们只能看到分享给他们的内容

00:30:47.514 --> 00:30:49.216
所以他们看到是分享的那个层次

00:30:50.417 --> 00:30:54.054
也就是说这些记录没有复制

00:30:54.121 --> 00:30:57.658
只有一套数据
并存在所有者的个人数据库中

00:30:58.192 --> 00:31:01.295
也就是说
所有者和所有的参与者

00:30:58.192 --> 00:31:01.295
也就是说
所有者和所有的参与者

00:31:01.361 --> 00:31:03.964
都通过同一套记录互动

00:31:04.631 --> 00:31:07.835
这种争用
最后可能会导致冲突

00:31:09.036 --> 00:31:10.671
要学习如何处理冲突

00:31:10.737 --> 00:31:12.039
我推荐你们

00:31:12.105 --> 00:31:16.109
2014年 WWDC的一场
“高级CloudKit”演讲

00:31:17.778 --> 00:31:22.583
现在 可读/写参与者
就可以修改 删除和添加记录了

00:31:24.551 --> 00:31:27.788
但是我们又不想
让他们随意添加东西

00:31:27.855 --> 00:31:29.356
到别人的数据库里

00:31:30.057 --> 00:31:33.126
比如他们不能随意添加根记录

00:31:34.228 --> 00:31:37.664
也不能添加没有
Parent Reference的记录

00:31:37.731 --> 00:31:40.601
即便是它能连接到
分享结构层

00:31:41.802 --> 00:31:47.441
所以要通过分享数据库
正确的添加新纪录

00:31:48.375 --> 00:31:52.379
就要设置Parent Reference
并连接到分享结构层

00:31:54.114 --> 00:31:58.185
这样即便你添加
新的记录给参与者

00:31:58.252 --> 00:31:59.887
通过分享数据库

00:32:00.254 --> 00:32:03.090
新的记录只存在
所有者个人数据库里

00:32:03.790 --> 00:32:05.025
这就意味着

00:32:05.325 --> 00:32:09.930
所有参与者添加的记录
都不计入所有者的配额

00:32:10.564 --> 00:32:15.402
因此创建的份额不受影响
开发者的份额也不受影响

00:32:17.104 --> 00:32:20.841
所有者的个人数据库是
唯一保存这些记录的地方

00:32:20.908 --> 00:32:23.410
所以我们只能让他们
不影响所有者的份额

00:32:24.678 --> 00:32:26.680
这就是如何分享多个记录

00:32:28.248 --> 00:32:31.084
我们来近距离研究下
分享数据库

00:32:33.687 --> 00:32:37.724
这里我们有两个Share
来自两个不同的所有者

00:32:38.225 --> 00:32:41.028
但是两个Shares名字一样
那怎么区分？

00:32:41.962 --> 00:32:44.665
我们忽略了
一个十分重要的细节

00:32:44.731 --> 00:32:48.435
就是所有CloudKit的记录
都存在记录区里

00:32:48.969 --> 00:32:52.239
而这个区是由CKRecord
Zone ID定义的

00:32:54.308 --> 00:32:55.309
这个区的名字

00:32:55.375 --> 00:32:58.011
是你创建的
自定义的区的名字

00:32:58.412 --> 00:32:59.680
其所有者的个人数据库中

00:33:00.848 --> 00:33:03.817
所有者的名字
就是所有者的用户记录名字

00:33:04.651 --> 00:33:08.322
这个例子中的两个区 有同样的名字
但是属于不同的所有者

00:33:08.956 --> 00:33:12.693
假设第一个所有者分享了一些东西
但是在不同的区

00:33:13.293 --> 00:33:16.063
那么当你调出
FetchDatabaseChanges API时

00:33:16.129 --> 00:33:17.764
这个新的区会出现

00:33:17.831 --> 00:33:21.001
之后当你调出
FetchRecordZoneChanges

00:33:21.068 --> 00:33:23.003
你会看到新的记录和Share

00:33:24.605 --> 00:33:28.876
假设第二个所有者
分享的东西在现有的区里

00:33:30.077 --> 00:33:32.079
这个区已经存在
所以不需要再建新的

00:33:32.145 --> 00:33:33.146
我们只要再利用

00:33:33.981 --> 00:33:35.482
当调出
FetchChanges API时

00:33:35.549 --> 00:33:38.952
你会看到这个区发生了变化
新的记录出现了

00:33:40.854 --> 00:33:42.422
这就是我们的分享数据库

00:33:43.323 --> 00:33:46.727
那么再深入一层
看看CKShare对象

00:33:49.730 --> 00:33:53.734
在所有者创建Share之前
得有要分享的东西

00:33:54.034 --> 00:33:56.436
因此 记录代表了Share的内容

00:33:57.938 --> 00:34:01.208
CKShare代表了如何分享

00:33:57.938 --> 00:34:01.208
CKShare代表了如何分享

00:34:02.075 --> 00:34:03.644
我们要讲的是
如何分享

00:34:05.712 --> 00:34:07.047
就像Jacob说的

00:34:07.114 --> 00:34:11.284
每个CKShare都是一个CKRecord
但有附加属性

00:34:11.918 --> 00:34:16.123
我们之前讲过了这些属性
如何应用于Share的生存期

00:34:16.190 --> 00:34:20.060
所以如果重头开始
所有者就要创建一个Share

00:34:21.995 --> 00:34:25.465
还要决定Share的
publicPermission如何

00:34:25.766 --> 00:34:27.768
这个例子里
所有者决定是none

00:34:27.835 --> 00:34:30.003
因为他想要邀请参与者

00:34:30.771 --> 00:34:32.873
假设他邀请了两个参与者

00:34:33.172 --> 00:34:35.409
他们的状态是自动接受邀请

00:34:36.310 --> 00:34:39.813
之后所有者就要考虑
给每个邀请者什么样的权限

00:34:41.715 --> 00:34:45.152
然后所有者保存Share后
就会收到Share的URL

00:34:45.985 --> 00:34:47.888
这里会发生两件事

00:34:47.987 --> 00:34:50.690
第一是这个Share有一个声明

00:34:50.958 --> 00:34:52.059
声明说

00:34:52.125 --> 00:34:54.795
只有两个参与者
可以接受这个Share

00:34:55.596 --> 00:34:57.231
所有者是唯一知道该URL的人

00:34:57.297 --> 00:35:00.734
只有他能
将这个URL告诉其他人

00:34:57.297 --> 00:35:00.734
只有他能
将这个URL告诉其他人

00:35:01.802 --> 00:35:04.338
所以即使他把这个URL
告诉了100个人

00:35:04.404 --> 00:35:06.974
还是只有两个人
可以接受这个Share

00:35:08.141 --> 00:35:12.646
当一个参与者通过URL
接受了这个Share

00:35:15.382 --> 00:35:18.452
接受之后
他们的接受状态就会变成已接受

00:35:19.319 --> 00:35:22.623
然后Share的权限
就是所有者给予他们的权限

00:35:23.657 --> 00:35:27.194
假设所有者
想要创建一个更加开放的分享

00:35:27.427 --> 00:35:28.729
就让我们重头开始

00:35:31.832 --> 00:35:33.433
所有者设立一个Share

00:35:34.935 --> 00:35:38.605
将公用权限设置为
只读或者是可读/写

00:35:39.773 --> 00:35:42.576
他没有邀请任何人
只是保存这个Share

00:35:43.043 --> 00:35:44.978
之后他获得了这个分享的URL

00:35:45.779 --> 00:35:47.247
这时仍然有两件事会发生

00:35:47.314 --> 00:35:51.919
第一是Share有一个声明
说任何人都可以参加

00:35:52.452 --> 00:35:53.987
所有者还是唯一知道URL的人

00:35:54.721 --> 00:35:57.291
他负责告诉其他人

00:35:57.424 --> 00:36:00.894
假如他告诉了100个人
那么所有这100个人都能参加

00:35:57.424 --> 00:36:00.894
假如他告诉了100个人
那么所有这100个人都能参加

00:36:02.029 --> 00:36:04.464
他们也要
通过这个URL参加

00:36:04.531 --> 00:36:08.569
然后出现在Share里的参与者
状态变为已接受

00:36:09.603 --> 00:36:13.373
他们的权限来自于Share的
publicPermissionfield

00:36:15.876 --> 00:36:18.111
这就是你如何创立一个分享
和接受一个分享

00:36:19.079 --> 00:36:23.717
Share的第二个阶段
就是当参与者退出时

00:36:25.919 --> 00:36:27.988
当然参与者可以退出分享

00:36:28.055 --> 00:36:31.925
通过删除
分享数据库里的CKShare对象

00:36:33.493 --> 00:36:36.964
这同时会删除
分享数据库里的分享记录

00:36:37.264 --> 00:36:39.600
要明确的是
CKShare仍然存在

00:36:39.666 --> 00:36:42.269
它在所有者的个人数据库里

00:36:42.336 --> 00:36:44.037
只是这个参与者

00:36:44.404 --> 00:36:47.007
不再出现在Share里
也不再是被邀请的状态

00:36:48.942 --> 00:36:51.812
但是所有者
对他的Share有完全掌控

00:36:52.646 --> 00:36:54.281
他可以删除任何一个人

00:36:55.983 --> 00:36:57.918
假设他想把所有人都删了

00:36:59.119 --> 00:37:01.755
他就要删除CKShared对象

00:36:59.119 --> 00:37:01.755
他就要删除CKShared对象

00:37:01.822 --> 00:37:03.323
从他的个人数据库里清除

00:37:04.057 --> 00:37:07.261
这会删除
Share根记录的pointer

00:37:09.396 --> 00:37:12.633
这时所有者就回到初始状态
就是未分享状态

00:37:15.235 --> 00:37:19.006
接着我们来讲讲
CKShareParticipant对象

00:37:19.573 --> 00:37:21.775
如果你见过这个对象
在生存期开始之前

00:37:21.842 --> 00:37:24.211
你会看到接受状态和许可

00:37:24.444 --> 00:37:26.680
但是现在看一看
UserIdentity类

00:37:27.648 --> 00:37:29.049
这有lookupInfo

00:37:29.550 --> 00:37:33.120
是指参与者是如何
被邀请到Share的

00:37:33.554 --> 00:37:36.924
所以这里会有他们的邮箱
电话或者用户记录ID

00:37:37.958 --> 00:37:40.027
名字分为
姓和名

00:37:40.093 --> 00:37:43.564
它会在参与者接受
这个Share的时候弹出

00:37:46.533 --> 00:37:49.803
每个CKShareParticipant
会分到一个iCloud账户

00:37:50.470 --> 00:37:53.173
那么假设
所有者邀请了4个人

00:37:53.240 --> 00:37:56.376
我们能找到
前两个人的iCloud账户

00:37:57.311 --> 00:37:59.646
但是后两个人没有

00:37:59.947 --> 00:38:01.114
但是这没什么问题

00:37:59.947 --> 00:38:01.114
但是这没什么问题

00:38:01.415 --> 00:38:04.151
CloudKit
会创建一个临时占位符

00:38:04.218 --> 00:38:05.619
给第三个和第四个人

00:38:06.286 --> 00:38:09.823
而且只有第3和第4个参与者

00:38:10.123 --> 00:38:11.525
需要证明

00:38:11.592 --> 00:38:13.994
他们持有的
邮箱地址和电话号码

00:38:14.328 --> 00:38:17.831
是所有者邀请他们时提供的
这就是验证过程

00:38:18.765 --> 00:38:21.535
这个过程会将
邮箱或者电话与账户联系在一起

00:38:21.602 --> 00:38:24.705
这样就不需要
再走一遍验证过程

00:38:27.107 --> 00:38:29.576
这就是我们现在
在分享中的所有对象

00:38:29.676 --> 00:38:32.679
那么接下来
我们聊聊分享API

00:38:34.681 --> 00:38:36.850
如果你想创建自定义UI

00:38:36.917 --> 00:38:40.354
你可以调出我们的API
有两种方法

00:38:40.854 --> 00:38:43.991
代表所有者
你可以帮他们设立一个Share

00:38:44.691 --> 00:38:48.028
代表参与者
你可以帮他们接受一个Share

00:38:48.862 --> 00:38:52.399
watchOS和tvOS
没有内置的系统UI

00:38:53.100 --> 00:38:54.468
所以你可以让你的用户

00:38:54.535 --> 00:38:57.738
用另一个平台
建立和接受一个Share

00:38:57.804 --> 00:39:01.375
之后这个Share的数据
在所有平台上就都可用了

00:38:57.804 --> 00:39:01.375
之后这个Share的数据
在所有平台上就都可用了

00:39:02.342 --> 00:39:05.712
或者你也可以调出
我们的分享API

00:39:05.779 --> 00:39:06.947
你要这么做

00:39:09.816 --> 00:39:12.686
代表所有者
你要帮他们添加参与者

00:39:13.654 --> 00:39:16.990
你需要寻找他们
通过邮件 电话或者用户记录ID

00:39:17.257 --> 00:39:20.160
然后转换成
CKShareParticipant对象

00:39:21.662 --> 00:39:23.897
一旦获得了
CKShareParticipant对象

00:39:23.964 --> 00:39:25.566
就要添加到分享里

00:39:26.667 --> 00:39:30.337
然后调出CKModifyRecordsOperation
来保存这个分享

00:39:30.904 --> 00:39:34.441
现在你的应用
就获得了这个分享的URL

00:39:35.042 --> 00:39:38.679
当然你可以决定
是应用还是所有者

00:39:38.745 --> 00:39:40.414
来把这个URL告诉别人

00:39:41.849 --> 00:39:45.085
当一个参与者接受一个分享
第一步都是从URL开始

00:39:47.354 --> 00:39:50.858
首先要将URL转换成
CKShareMetadata对象

00:39:50.924 --> 00:39:55.095
然后将这个元数据传递给
CKAcceptSharesOperation

00:39:56.330 --> 00:39:59.700
现在 参与者就会显示在分享中
并且是已接受的状态

00:40:01.268 --> 00:40:04.671
这个已接受的API
也有一些限制

00:40:05.639 --> 00:40:09.243
从隐私角度来说
我们无法返回他们的姓名组件

00:40:09.309 --> 00:40:11.478
那么验证程序不可用

00:40:11.778 --> 00:40:13.347
如果你收到这个报错

00:40:13.780 --> 00:40:16.650
或者iCloud账户的
Boolean为假

00:40:17.551 --> 00:40:20.420
那么你要让你的用户
亲自打开这个URL

00:40:20.487 --> 00:40:23.657
这样可以触发系统或者网络

00:40:24.124 --> 00:40:26.159
让他们通过验证过程

00:40:28.262 --> 00:40:29.663
以上就是分享API

00:40:30.430 --> 00:40:32.733
现在我们再来说说
你的用户

00:40:35.736 --> 00:40:39.339
应用的用户可以邀请
任何他们想邀请的人

00:40:39.973 --> 00:40:42.709
通过邮件或者电话

00:40:43.210 --> 00:40:44.578
这就意味着

00:40:45.179 --> 00:40:50.017
应用的潜在用户
要远远多于现在的用户群

00:40:50.918 --> 00:40:54.288
这些被邀请人可能没有安装
最新的操作系统

00:40:54.354 --> 00:40:56.156
他们甚至可能没有Apple的产品

00:40:56.223 --> 00:41:00.394
所以当他们点击这个URL
我们会把他们转到网页

00:40:56.223 --> 00:41:00.394
所以当他们点击这个URL
我们会把他们转到网页

00:41:01.528 --> 00:41:04.331
以Notes为例
这就是他们看到的画面

00:41:05.299 --> 00:41:09.603
他们会被要求加入分享
然后他们就可以看到分享的内容

00:41:11.371 --> 00:41:14.341
他们可以与这个Note互动
就像在设备上一样

00:41:15.175 --> 00:41:19.012
但是这是个Note网页应用
存在于iCloud.com

00:41:19.079 --> 00:41:21.148
你的应用如何呢？

00:41:21.682 --> 00:41:24.852
默认的情况下
你的用户会看到这样一个界面

00:41:25.619 --> 00:41:29.122
这里有你的应用的图标
并要求你的用户使用最近使用的设备

00:41:29.623 --> 00:41:32.659
这不是最理想的用户体验

00:41:33.160 --> 00:41:35.395
所以我有一些好消息要告诉你

00:41:36.230 --> 00:41:40.567
你可以到CloudKit Dashboard
设置一个fallback URL

00:41:41.602 --> 00:41:45.339
如果被邀请人点击了
这个分享给他们的URL

00:41:46.073 --> 00:41:49.009
我们会把他们
重新导向你的fallback URL

00:41:49.776 --> 00:41:53.580
我们会在后面添加token
代表Share的唯一URL

00:41:54.047 --> 00:41:56.884
这样你就可以
立刻让他们接受share

00:41:56.950 --> 00:41:58.652
然后显示分享的数据

00:42:00.287 --> 00:42:02.890
现在我希望
你们都等不及要开始分享了

00:42:03.524 --> 00:42:05.726
这是最后一点
你们要知道的

00:42:07.027 --> 00:42:09.596
CKShare是最新的记录类型

00:42:09.663 --> 00:42:13.967
这种类型
与CloudKit其他类型一样

00:42:14.701 --> 00:42:17.704
可以在上面创建自定义域
你可以运行查询指令

00:42:18.338 --> 00:42:22.376
你也可以第一个
在开发环境下创建新记录

00:42:22.976 --> 00:42:25.512
创建的最简单的方法

00:42:26.013 --> 00:42:28.649
就是使用用户身份
登录开发环境

00:42:28.715 --> 00:42:31.151
然后从你的个人数据库
分享点什么

00:42:32.419 --> 00:42:34.888
这样就会触发
记录类型的创建

00:42:35.022 --> 00:42:38.425
然后去CloudKit Dashboard
部署scheme给production

00:42:38.926 --> 00:42:40.260
如果不这么做

00:42:40.561 --> 00:42:44.398
那么用户在production环境下
创建分享时就会出错

00:42:44.464 --> 00:42:46.934
因为记录类型还没成立

00:42:49.102 --> 00:42:50.103
这就是最后我要讲的

00:42:51.405 --> 00:42:52.906
那么 今天你们了解了

00:42:52.973 --> 00:42:56.043
CloudKit可用于所有平台
包括watchOS

00:42:56.109 --> 00:42:59.713
它也可用于网络
通过CloudKit JS

00:43:01.682 --> 00:43:05.152
Telemetry在CloudKit
Dashboard可用

00:43:05.219 --> 00:43:08.121
这是个很好的办法
来视觉化你的应用的行为

00:43:08.188 --> 00:43:09.823
包括错误趋势

00:43:10.557 --> 00:43:14.194
API有了很多改进
包括长时间操作

00:43:14.795 --> 00:43:17.464
QualityOfService
还有最新fetch changes APIs

00:43:18.265 --> 00:43:21.001
现在你也全面了解了
我们的新功能 分享

00:43:21.535 --> 00:43:22.970
你看到了这个系统UI

00:43:23.737 --> 00:43:26.340
你知道了
如何创建自定义UI

00:43:26.406 --> 00:43:28.008
通过调出我们的分享API

00:43:28.475 --> 00:43:30.677
你也看过了所有
我们用在分享中的对象

00:43:31.245 --> 00:43:32.946
包括分享者的存在周期

00:43:33.480 --> 00:43:36.416
我打赌你们回去后
会设置这些fallback URL

00:43:38.151 --> 00:43:41.021
那么 感谢你们
与我们分享这样的体验

00:43:42.856 --> 00:43:45.225
我想请大家关注这场演讲
“CloudKit的最佳操作”

00:43:45.292 --> 00:43:46.693
就在明天早上九点

00:43:46.760 --> 00:43:49.730
这场演讲很精彩
让你了解如何能有效率地使用CloudKit

00:43:50.597 --> 00:43:54.434
谢谢你们的到来
希望你们享受 WWDC 的其他会议
