WEBVTT

00:00:19.586 --> 00:00:24.291 align:middle
<c.magenta>UIkit 动画和过渡的新进展</c>

00:00:29.830 --> 00:00:30.931 align:middle
<c.magenta>下午好</c>

00:00:32.299 --> 00:00:33.734 align:middle
<c.magenta>我是Bruce Nilo</c>

00:00:33.834 --> 00:00:36.470 align:middle
<c.magenta>我是UIKit的一名工程经理</c>

00:00:36.870 --> 00:00:41.575 align:middle
<c.magenta>今天 我和我的同伴</c>
<c.magenta>Mike Turner都非常兴奋</c>

00:00:41.808 --> 00:00:44.645 align:middle
<c.magenta>我们会介绍一些新的动画API</c>

00:00:44.711 --> 00:00:47.848 align:middle
<c.magenta>在iOS 10中的UIKit</c>
<c.magenta>将会包含这些新特性</c>

00:00:48.448 --> 00:00:51.752 align:middle
<c.magenta>我们相信这些API将会让你更简单的</c>

00:00:51.818 --> 00:00:54.888 align:middle
<c.magenta>创建自然的 顺畅的</c>

00:00:54.955 --> 00:01:00.060 align:middle
<c.magenta>和可响应的应用</c>

00:00:54.955 --> 00:01:00.060 align:middle
<c.magenta>和可响应的应用</c>

00:01:00.961 --> 00:01:04.598 align:middle
<c.magenta>今天我们会先快速重温一下</c>

00:01:04.965 --> 00:01:09.837 align:middle
<c.magenta>UIKit中已有的</c>
<c.magenta>一些隐式动画API</c>

00:01:10.504 --> 00:01:12.840 align:middle
<c.magenta>然后我们会深入的介绍一个全新的类</c>

00:01:12.906 --> 00:01:16.410 align:middle
<c.magenta>我们叫它UIViewPropertyAnimator</c>

00:01:17.511 --> 00:01:21.782 align:middle
<c.magenta>我们还会介绍一些</c>
<c.magenta>用于视图控制器切换的扩展</c>

00:01:21.949 --> 00:01:24.818 align:middle
<c.magenta>以便于你们更好的使用这些新类</c>

00:01:26.386 --> 00:01:31.024 align:middle
<c.magenta>Mike将上台给大家一个很棒的展示</c>
<c.magenta>展示如何使用这些新的API</c>

00:01:31.091 --> 00:01:33.594 align:middle
<c.magenta>还有一个全新的图片应用的例子</c>

00:01:33.660 --> 00:01:35.929 align:middle
<c.magenta>不久你就可以下载到</c>

00:01:36.964 --> 00:01:40.100 align:middle
<c.magenta>我们还会讨论一些细微的问题</c>

00:01:40.167 --> 00:01:43.337 align:middle
<c.magenta>关于这些新类的触摸处理和点击测试</c>

00:01:43.904 --> 00:01:45.839 align:middle
<c.magenta>和该如何使用这些新的类</c>

00:01:45.906 --> 00:01:49.276 align:middle
<c.magenta>来创建甚至可以被中断的关键帧动画</c>

00:01:51.078 --> 00:01:54.948 align:middle
<c.magenta>UIKit中的隐式属性动画</c>

00:01:55.415 --> 00:01:59.219 align:middle
<c.magenta>基本上是为了</c>

00:01:59.920 --> 00:02:04.625 align:middle
<c.magenta>让你可以创建动态的内容</c>

00:01:59.920 --> 00:02:04.625 align:middle
<c.magenta>让你可以创建动态的内容</c>

00:02:04.691 --> 00:02:10.163 align:middle
<c.magenta>你可以通过设置视图的属性</c>
<c.magenta>并让动画在一段时间内发生</c>

00:02:12.999 --> 00:02:18.672 align:middle
<c.magenta>它是隐式的</c>
<c.magenta>因为UIKit为你创建了动画</c>

00:02:18.739 --> 00:02:21.208 align:middle
<c.magenta>值变化时会被记下来</c>

00:02:21.275 --> 00:02:25.879 align:middle
<c.magenta>用原始值和最后的值做个差值</c>

00:02:25.946 --> 00:02:29.983 align:middle
<c.magenta>这个值会在你指定的时间段上</c>

00:02:30.050 --> 00:02:34.821 align:middle
<c.magenta>用一个可选的定时函数决定</c>
<c.magenta>这个动画的节奏</c>

00:02:36.290 --> 00:02:37.991 align:middle
<c.magenta>我们再具体的介绍下</c>

00:02:38.759 --> 00:02:41.128 align:middle
<c.magenta>这里有一个非常简单的动画</c>

00:02:41.595 --> 00:02:44.898 align:middle
<c.magenta>今天的展示中我们会一直使用这个例子</c>

00:02:44.965 --> 00:02:48.035 align:middle
<c.magenta>我们有个圆基本就是从左到右来运动</c>

00:02:48.836 --> 00:02:51.538 align:middle
<c.magenta>通过设置视图的中心属性来让其运动</c>

00:02:51.605 --> 00:02:55.742 align:middle
<c.magenta>在这个图中我们看到一个虚线圆形</c>

00:02:55.809 --> 00:02:57.845 align:middle
<c.magenta>或者是一个虚线正方形</c>
<c.magenta>它代表了视图</c>

00:02:57.911 --> 00:02:59.880 align:middle
<c.magenta>在实际动画中你看到的样子</c>

00:03:00.247 --> 00:03:03.383 align:middle
<c.magenta>而实线形状代表目标值</c>

00:03:03.450 --> 00:03:06.887 align:middle
<c.magenta>我们也分别把它们叫做模型值和展示值</c>

00:03:07.921 --> 00:03:12.626 align:middle
<c.magenta>我们开始这个动画</c>
<c.magenta>然后它以一定的速度进行</c>

00:03:12.693 --> 00:03:15.762 align:middle
<c.magenta>实际上你会注意到这个速度是恒定的</c>

00:03:16.630 --> 00:03:18.665 align:middle
<c.magenta>问题是今天我们将要怎么做</c>

00:03:19.099 --> 00:03:20.534 align:middle
<c.magenta>今天的实现将会很简单</c>

00:03:21.468 --> 00:03:25.239 align:middle
<c.magenta>你们中大部分可能熟悉</c>
<c.magenta>animateWithDuration API</c>

00:03:26.139 --> 00:03:30.177 align:middle
<c.magenta>在这个例子中 我们指定在X轴上</c>

00:03:30.244 --> 00:03:33.180 align:middle
<c.magenta>圆的中心应该从0移动到100</c>

00:03:35.916 --> 00:03:39.586 align:middle
<c.magenta>现在定时函数可设置为.linear</c>

00:03:39.653 --> 00:03:42.022 align:middle
<c.magenta>简单来说它表示一个特性函数</c>

00:03:42.089 --> 00:03:45.392 align:middle
<c.magenta>我们快速介绍下在UIKit中</c>
<c.magenta>什么是定时函数</c>

00:03:45.759 --> 00:03:52.232 align:middle
<c.magenta>它是一个三次函数</c>
<c.magenta>映射"0到1"到"0到1"</c>

00:03:52.366 --> 00:03:53.901 align:middle
<c.magenta>同时有两个约束</c>

00:03:53.967 --> 00:03:56.170 align:middle
<c.magenta>就是说 在动画开始的时候</c>

00:03:56.236 --> 00:03:58.572 align:middle
<c.magenta>即在一开始时</c>

00:03:58.772 --> 00:04:03.377 align:middle
<c.magenta>动画进行的速度值就是这个开始值</c>

00:03:58.772 --> 00:04:03.377 align:middle
<c.magenta>动画进行的速度值就是这个开始值</c>

00:04:03.810 --> 00:04:05.479 align:middle
<c.magenta>结束的时候 就是结束值</c>

00:04:06.313 --> 00:04:13.020 align:middle
<c.magenta>现在定时函数不定义你的动画速度了</c>

00:04:13.320 --> 00:04:19.125 align:middle
<c.magenta>现在通过这个夸大的渐入定时函数</c>
<c.magenta>可以很容易的实现</c>

00:04:19.692 --> 00:04:22.796 align:middle
<c.magenta>你会注意到动画进行到一半时</c>

00:04:23.330 --> 00:04:25.632 align:middle
<c.magenta>它的进度移动很少</c>

00:04:25.999 --> 00:04:28.702 align:middle
<c.magenta>它真的时进行的相当的慢</c>

00:04:29.403 --> 00:04:32.406 align:middle
<c.magenta>我们差不多离完成有90%了</c>

00:04:32.773 --> 00:04:34.374 align:middle
<c.magenta>但我们还是只到了一半的位置</c>

00:04:34.908 --> 00:04:37.811 align:middle
<c.magenta>在你指定时间的最后10%里</c>

00:04:37.878 --> 00:04:39.680 align:middle
<c.magenta>我们将会完成剩下的距离</c>

00:04:39.746 --> 00:04:41.748 align:middle
<c.magenta>简单说 它会加速</c>

00:04:41.982 --> 00:04:46.787 align:middle
<c.magenta>从速度非常慢到非常快直到最后</c>

00:04:47.054 --> 00:04:49.022 align:middle
<c.magenta>这就是定时函数的作用</c>

00:04:50.490 --> 00:04:55.395 align:middle
<c.magenta>现在UIKit有四个定时函数</c>

00:04:55.629 --> 00:04:58.398 align:middle
<c.magenta>这些是特定的三次贝塞尔函数实例</c>

00:04:58.465 --> 00:05:00.767 align:middle
<c.magenta>这是我们以前看到的特定函数</c>

00:04:58.465 --> 00:05:00.767 align:middle
<c.magenta>这是我们以前看到的特定函数</c>

00:05:01.001 --> 00:05:02.402 align:middle
<c.magenta>这是渐入渐出</c>

00:05:03.804 --> 00:05:06.807 align:middle
<c.magenta>这是渐入</c>

00:05:08.442 --> 00:05:11.578 align:middle
<c.magenta>最后 这是渐出</c>

00:05:12.746 --> 00:05:15.282 align:middle line:1
<c.magenta>这些是我们提供的非常细微的函数</c>

00:05:15.349 --> 00:05:19.052 align:middle line:1
<c.magenta>将会影响一部分动画的感觉</c>

00:05:22.022 --> 00:05:23.423 align:middle line:1
<c.magenta>关于回弹会有什么呢</c>

00:05:24.091 --> 00:05:27.995 align:middle
<c.magenta>我们也有隐式的动画API</c>
<c.magenta>提供给你来设置一个回弹</c>

00:05:28.529 --> 00:05:30.764 align:middle
<c.magenta>我们不会否认如果你想说</c>

00:05:30.831 --> 00:05:32.499 align:middle
<c.magenta>"那不是实际的插值</c>

00:05:32.566 --> 00:05:36.170 align:middle
<c.magenta>我们把这个值做得</c>
<c.magenta>有点过并且有点回弹"</c>

00:05:36.970 --> 00:05:40.474 align:middle
<c.magenta>然而 接下来 大家可以都</c>

00:05:40.541 --> 00:05:43.877 align:middle
<c.magenta>想一下把回弹作为</c>
<c.magenta>另一种类型的定时函数</c>

00:05:44.411 --> 00:05:46.113 align:middle
<c.magenta>现在看看我们为什么能这么做</c>

00:05:46.580 --> 00:05:48.916 align:middle
<c.magenta>来看看这个简单的应用</c>

00:05:48.982 --> 00:05:51.618 align:middle
<c.magenta>我们让一个方块从左面移动到了右面</c>

00:05:54.388 --> 00:05:57.758 align:middle
<c.magenta>我们绘制了位置移动图</c>

00:05:57.824 --> 00:06:01.595 align:middle
<c.magenta>在方块移动的过程中</c>

00:05:57.824 --> 00:06:01.595 align:middle
<c.magenta>在方块移动的过程中</c>

00:06:01.662 --> 00:06:03.764 align:middle
<c.magenta>它有点像定时函数</c>

00:06:03.830 --> 00:06:05.365 align:middle
<c.magenta>实际上它不是立方函数</c>

00:06:05.632 --> 00:06:07.835 align:middle
<c.magenta>我们过度设置了它的值</c>

00:06:07.901 --> 00:06:12.406 align:middle
<c.magenta>但我们仍可认为</c>
<c.magenta>它是可以影响动画的速度的</c>

00:06:12.539 --> 00:06:16.877 align:middle
<c.magenta>接下来的API中</c>
<c.magenta>我们将会对回弹动画进行分类</c>

00:06:18.545 --> 00:06:22.783 align:middle
<c.magenta>现在在iOS 8中有另一个重要的</c>
<c.magenta>用来制造动画的版本</c>

00:06:23.283 --> 00:06:24.685 align:middle
<c.magenta>我告诉你这些</c>

00:06:24.751 --> 00:06:27.487 align:middle
<c.magenta>因为稍后我们还会谈到它</c>

00:06:28.555 --> 00:06:34.194 align:middle
<c.magenta>简单说 考虑一个动画</c>
<c.magenta>在动画进行的中间改变</c>

00:06:34.261 --> 00:06:36.029 align:middle line:1
<c.magenta>所以你将从一个位置到另一个位置</c>

00:06:36.096 --> 00:06:37.731 align:middle line:1
<c.magenta>到一半的时候 你变了</c>

00:06:37.931 --> 00:06:44.204 align:middle line:1
<c.magenta>在iOS 8以前 如果你这么做</c>
<c.magenta>你的动画将会有一个中断</c>

00:06:44.438 --> 00:06:46.640 align:middle line:1
<c.magenta>除非制定了一个特别的配置</c>

00:06:46.707 --> 00:06:50.911 align:middle line:1
<c.magenta>UIViewAnimationOption</c>
<c.magenta>BeginFromCurrentState</c>

00:06:51.278 --> 00:06:53.947 align:middle line:1
<c.magenta>如果你这么做了</c>
<c.magenta>将会看起来好一点</c>

00:06:54.681 --> 00:06:56.683 align:middle line:1
<c.magenta>将不会有间断和跳跃</c>

00:06:56.950 --> 00:06:58.418 align:middle line:1
<c.magenta>但是仍然不会顺滑</c>

00:06:58.485 --> 00:07:01.054 align:middle line:1
<c.magenta>速度变化的很突然</c>

00:06:58.485 --> 00:07:01.054 align:middle line:1
<c.magenta>速度变化的很突然</c>

00:07:02.055 --> 00:07:07.528 align:middle line:1
<c.magenta>在iOS 8中</c>
<c.magenta>我们做了一个重大改变</c>

00:07:07.895 --> 00:07:10.464 align:middle line:1
<c.magenta>动画中的特定的属性被渐进的完成</c>

00:07:10.531 --> 00:07:13.600 align:middle line:1
<c.magenta>我们没有移除之前的动画</c>
<c.magenta>我们把后来的加了上去</c>

00:07:13.667 --> 00:07:16.370 align:middle line:1
<c.magenta>这样能平滑处理速度的变化</c>

00:07:17.538 --> 00:07:22.809 align:middle line:1
<c.magenta>通过使用新的UIViewPropertyAnimator</c>
<c.magenta>第一种情况就不会再存在了</c>

00:07:25.345 --> 00:07:29.983 align:middle
<c.magenta>好的 现在我们看看新的类</c>
<c.magenta>我们已经快速浏览了</c>

00:07:31.718 --> 00:07:32.719 align:middle
<c.magenta>它的一些特性</c>

00:07:32.786 --> 00:07:33.787 align:middle
<c.magenta>我们已经很熟悉了</c>

00:07:34.054 --> 00:07:38.825 align:middle
<c.magenta>如果你熟悉以前的</c>
<c.magenta>animateWithDuration配套的API</c>

00:07:38.892 --> 00:07:41.962 align:middle
<c.magenta>新的API你也不会陌生</c>

00:07:42.396 --> 00:07:43.430 align:middle
<c.magenta>它是可以被中断的</c>

00:07:43.497 --> 00:07:46.200 align:middle
<c.magenta>这意味着你可以暂停和停止动画</c>

00:07:46.834 --> 00:07:50.137 align:middle
<c.magenta>你可以打磨它们</c>
<c.magenta>意思就是说你可以让它前进后退</c>

00:07:50.204 --> 00:07:53.640 align:middle
<c.magenta>用你喜欢的方式</c>
<c.magenta>基于这个可编程的API</c>

00:07:54.308 --> 00:07:55.275 align:middle
<c.magenta>你可以反转它们</c>

00:07:55.342 --> 00:07:57.778 align:middle
<c.magenta>你可以说</c>
<c.magenta>别担心 往回走</c>

00:07:58.445 --> 00:08:01.548 align:middle
<c.magenta>我们将会介绍一整套定时函数</c>

00:07:58.445 --> 00:08:01.548 align:middle
<c.magenta>我们将会介绍一整套定时函数</c>

00:08:01.615 --> 00:08:03.784 align:middle
<c.magenta>而不仅仅是以前的那四个</c>

00:08:03.851 --> 00:08:08.755 align:middle
<c.magenta>通过回弹动画的一种小的子集</c>

00:08:09.723 --> 00:08:11.358 align:middle
<c.magenta>最后 当动画运行时</c>

00:08:11.425 --> 00:08:15.162 align:middle
<c.magenta>往上添加动画将会非常简单</c>

00:08:16.763 --> 00:08:20.767 align:middle
<c.magenta>但是介绍这些API有点困难</c>

00:08:20.834 --> 00:08:24.972 align:middle
<c.magenta>所以我不打算做这挠头的事</c>

00:08:25.205 --> 00:08:28.108 align:middle
<c.magenta>让我们大体看一下</c>
<c.magenta>这些API是什么样子</c>

00:08:28.342 --> 00:08:32.145 align:middle
<c.magenta>在所有这些新类的中心是</c>
<c.magenta>UIViewPropertyAnimator</c>

00:08:32.645 --> 00:08:36.416 align:middle
<c.magenta>它实现了两个新的协议</c>

00:08:37.484 --> 00:08:40.453 align:middle
<c.magenta>把它们作为协议实现的原因</c>

00:08:40.520 --> 00:08:43.890 align:middle
<c.magenta>或实现这两个新的协议</c>
<c.magenta>我们将会看到它会非常有用</c>

00:08:43.957 --> 00:08:46.527 align:middle
<c.magenta>当我们把它</c>
<c.magenta>和视图控制器切换放在一起使用时</c>

00:08:48.095 --> 00:08:49.663 align:middle line:1
<c.magenta>当你创建一个属性动画生成器</c>

00:08:49.730 --> 00:08:51.598 align:middle line:1
<c.magenta>你将会创建一个新的对象类型</c>

00:08:51.665 --> 00:08:54.735 align:middle line:1
<c.magenta>这会高效的指定定时函数</c>

00:08:54.801 --> 00:08:57.337 align:middle line:1
<c.magenta>将会使用在你的动画中</c>

00:08:57.437 --> 00:09:00.340 align:middle line:1
<c.magenta>我们提供了两个新的具体的类来实现</c>

00:08:57.437 --> 00:09:00.340 align:middle line:1
<c.magenta>我们提供了两个新的具体的类来实现</c>

00:09:01.208 --> 00:09:04.545 align:middle
<c.magenta>我们已经引入了一些新的枚举</c>

00:09:04.811 --> 00:09:07.614 align:middle
<c.magenta>以供协议中的方法使用</c>

00:09:07.681 --> 00:09:13.053 align:middle
<c.magenta>例如 动画生成器的状态可以为非活动</c>
<c.magenta>活动或者停止</c>

00:09:13.253 --> 00:09:15.856 align:middle
<c.magenta>一会我们再讨论这些</c>

00:09:16.557 --> 00:09:18.659 align:middle
<c.magenta>我们也引入了位置</c>

00:09:18.959 --> 00:09:21.795 align:middle
<c.magenta>即动画停止的地方</c>

00:09:21.862 --> 00:09:24.731 align:middle
<c.magenta>动画会遍历所有我们设定的地方么</c>

00:09:24.798 --> 00:09:26.800 align:middle
<c.magenta>我们是通过反转它来回到开始位置么</c>

00:09:26.867 --> 00:09:31.004 align:middle
<c.magenta>或者我们可能打断了它</c>
<c.magenta>还有可能其他的实现</c>

00:09:31.805 --> 00:09:32.673 align:middle
<c.magenta>好的</c>

00:09:34.541 --> 00:09:37.845 align:middle
<c.magenta>我们先来集中在这个图的中间部分</c>

00:09:38.745 --> 00:09:42.015 align:middle line:1
<c.magenta>然后我们会简要说下</c>
<c.magenta>所有的这些新的定时函数</c>

00:09:43.584 --> 00:09:47.688 align:middle
<c.magenta>那么我们来看看这个角上的API</c>

00:09:47.754 --> 00:09:50.624 align:middle
<c.magenta>它被定义在UIViewAnimating协议中</c>

00:09:50.691 --> 00:09:52.025 align:middle
<c.magenta>有趣的地方都在这</c>

00:09:52.092 --> 00:09:53.427 align:middle
<c.magenta>实际上这非常的简单</c>

00:09:53.493 --> 00:09:56.630 align:middle
<c.magenta>有几个属性你可以获得和设置</c>

00:09:57.598 --> 00:09:59.867 align:middle
<c.magenta>比如 你可以设置</c>
<c.magenta>fractionComplete</c>

00:09:59.933 --> 00:10:01.468 align:middle
<c.magenta>你可以让动画开始</c>

00:09:59.933 --> 00:10:01.468 align:middle
<c.magenta>你可以让动画开始</c>

00:10:01.535 --> 00:10:03.237 align:middle
<c.magenta>你可以暂停 停止 完成动画</c>

00:10:03.303 --> 00:10:04.838 align:middle
<c.magenta>这些都不用过多解释</c>

00:10:06.240 --> 00:10:10.711 align:middle
<c.magenta>下一个协议给这个动画生成器增加了</c>
<c.magenta>隐式的特征</c>

00:10:10.777 --> 00:10:14.314 align:middle
<c.magenta>比如你想在哪里设置块和目标值</c>

00:10:14.381 --> 00:10:16.884 align:middle
<c.magenta>给这个设置动画的属性</c>

00:10:17.184 --> 00:10:21.588 align:middle
<c.magenta>这里同时有个有意思的方法</c>
<c.magenta>叫做continueAnimation</c>

00:10:21.655 --> 00:10:24.925 align:middle
<c.magenta>能让一个暂停的动画</c>

00:10:25.158 --> 00:10:28.295 align:middle
<c.magenta>和一个完全不同的结束时间一起处理</c>

00:10:28.495 --> 00:10:30.764 align:middle
<c.magenta>甚至是一个不同的定时函数</c>

00:10:33.800 --> 00:10:37.304 align:middle
<c.magenta>UIViewPropertyAnimator</c>
<c.magenta>有几个构造方法</c>

00:10:37.371 --> 00:10:40.407 align:middle
<c.magenta>也有一些属性用来处理触摸事件</c>

00:10:40.474 --> 00:10:42.709 align:middle
<c.magenta>我们会在最后讨论它</c>

00:10:44.411 --> 00:10:48.949 align:middle
<c.magenta>首先我们讨论下</c>
<c.magenta>如何使用这些基本的东西</c>

00:10:49.249 --> 00:10:52.219 align:middle
<c.magenta>我们将会讨论一些不是那么明显的细节</c>

00:10:52.286 --> 00:10:55.556 align:middle
<c.magenta>你可能会在暂停和刷新</c>
<c.magenta>一个动画的时候遇到</c>

00:10:56.356 --> 00:10:58.358 align:middle
<c.magenta>同时也有一些有趣的可能</c>

00:10:58.425 --> 00:11:00.427 align:middle
<c.magenta>取决于你如何反转一个动画</c>

00:10:58.425 --> 00:11:00.427 align:middle
<c.magenta>取决于你如何反转一个动画</c>

00:11:02.062 --> 00:11:06.099 align:middle
<c.magenta>最后 我们会介绍所有的定时提供者</c>

00:11:07.167 --> 00:11:09.303 align:middle
<c.magenta>让我们从一个实际的简单的动画开始</c>

00:11:10.504 --> 00:11:12.339 align:middle
<c.magenta>同时我让这个例子变得更有趣了一些</c>

00:11:12.406 --> 00:11:15.576 align:middle
<c.magenta>为了教学目的 稍后你会看到</c>

00:11:16.176 --> 00:11:17.945 align:middle
<c.magenta>我来问个问题</c>

00:11:18.812 --> 00:11:21.448 align:middle
<c.magenta>“你将怎么样使用属性</c>
<c.magenta>动画生成器来完成它”</c>

00:11:21.882 --> 00:11:23.350 align:middle
<c.magenta>它非常非常简单</c>

00:11:23.650 --> 00:11:26.053 align:middle
<c.magenta>第一步需要创建一个定时对象</c>

00:11:26.320 --> 00:11:32.759 align:middle
<c.magenta>就像以前用的</c>
<c.magenta>枚举.easeInOut</c>

00:11:33.227 --> 00:11:37.364 align:middle
<c.magenta>你需要指定持续时间</c>
<c.magenta>来实例化其中的一个对象</c>

00:11:37.865 --> 00:11:39.233 align:middle
<c.magenta>和这个定时对象</c>

00:11:40.400 --> 00:11:43.270 align:middle
<c.magenta>通过使用闭包添加动画</c>

00:11:43.337 --> 00:11:46.206 align:middle
<c.magenta>更新你想设置动画的属性</c>

00:11:46.740 --> 00:11:48.575 align:middle
<c.magenta>你可添加一个可选的完成后执行函数</c>

00:11:48.876 --> 00:11:52.846 align:middle
<c.magenta>这个例子中</c>
<c.magenta>这个函数把背景色变成了橘色</c>

00:11:53.413 --> 00:11:55.482 align:middle
<c.magenta>然后你可以在任何时候开始这个动画</c>

00:11:56.483 --> 00:12:00.187 align:middle
<c.magenta>是的 相对于旧的API有点繁琐</c>

00:11:56.483 --> 00:12:00.187 align:middle
<c.magenta>是的 相对于旧的API有点繁琐</c>

00:12:00.254 --> 00:12:02.022 align:middle
<c.magenta>但现在你有了个对象</c>

00:12:02.089 --> 00:12:04.124 align:middle
<c.magenta>你可以用它来做所有的事情</c>

00:12:04.191 --> 00:12:06.059 align:middle
<c.magenta>这和以前有点不同</c>

00:12:07.327 --> 00:12:13.700 align:middle
<c.magenta>让我们看下UIViewPropertyAnimator</c>
<c.magenta>一些其他可用的属性</c>

00:12:13.767 --> 00:12:15.269 align:middle
<c.magenta>其中有三个比较有意思</c>

00:12:15.335 --> 00:12:17.905 align:middle
<c.magenta>有状态 有是否在运行</c>

00:12:17.971 --> 00:12:21.108 align:middle
<c.magenta>和是在正向还是反向在运行</c>

00:12:21.441 --> 00:12:24.778 align:middle
<c.magenta>这些都是KVO中可观察的属性</c>

00:12:26.213 --> 00:12:28.081 align:middle
<c.magenta>第一步你需要做的是添加一个动画</c>

00:12:28.148 --> 00:12:30.918 align:middle
<c.magenta>我们将会让这个圆再一次从左移动到右</c>

00:12:31.118 --> 00:12:34.888 align:middle
<c.magenta>一旦你开始你应该添加一个动画闭包</c>

00:12:35.389 --> 00:12:37.057 align:middle
<c.magenta>你可以开始这个动画</c>

00:12:37.391 --> 00:12:40.894 align:middle
<c.magenta>然后你开始这个动画</c>
<c.magenta>动画的状态会改变 变成运行</c>

00:12:41.228 --> 00:12:44.965 align:middle
<c.magenta>现在这个视图实际的值开始改变</c>

00:12:45.032 --> 00:12:48.035 align:middle
<c.magenta>有一个目标值你可以在屏幕上看到</c>

00:12:48.702 --> 00:12:50.604 align:middle
<c.magenta>然后动画开始运行</c>

00:12:50.671 --> 00:12:55.075 align:middle
<c.magenta>现在不同的是</c>
<c.magenta>我可以在动画运行的时候暂停</c>

00:12:55.309 --> 00:12:58.245 align:middle
<c.magenta>我可以通过让动画生成器暂停实现</c>

00:12:59.346 --> 00:13:02.783 align:middle
<c.magenta>我还可以让它从相反的方向再来一次</c>

00:12:59.346 --> 00:13:02.783 align:middle
<c.magenta>我还可以让它从相反的方向再来一次</c>

00:13:03.083 --> 00:13:06.086 align:middle
<c.magenta>现在动画还是在在暂停中</c>
<c.magenta>你可以注意状态的变化</c>

00:13:07.154 --> 00:13:08.188 align:middle
<c.magenta>然后我开始</c>

00:13:09.056 --> 00:13:11.158 align:middle
<c.magenta>动画开始运行从相反的方向</c>

00:13:12.426 --> 00:13:15.629 align:middle
<c.magenta>现在我再改变 动画接着向前运行</c>

00:13:16.230 --> 00:13:17.431 align:middle
<c.magenta>当完成的时候</c>

00:13:18.165 --> 00:13:20.934 align:middle
<c.magenta>将会调用你注册的完成处理函数</c>

00:13:21.201 --> 00:13:24.238 align:middle
<c.magenta>这次我们通过.end来调用</c>

00:13:24.304 --> 00:13:27.875 align:middle
<c.magenta>我们一直用这种方式来初始化</c>

00:13:28.108 --> 00:13:30.477 align:middle
<c.magenta>如果在动画运行时</c>
<c.magenta>我们没有再一次反转它</c>

00:13:30.744 --> 00:13:33.080 align:middle
<c.magenta>我们将会调用.start来完成动画</c>

00:13:33.146 --> 00:13:37.584 align:middle
<c.magenta>这样 你的结束处理函数</c>
<c.magenta>能知道动画实际是在哪儿结束的</c>

00:13:39.553 --> 00:13:40.420 align:middle
<c.magenta>好的</c>

00:13:40.487 --> 00:13:44.391 align:middle
<c.magenta>除了暂停动画还有其他你可以做</c>

00:13:44.625 --> 00:13:46.293 align:middle
<c.magenta>你可以停止动画</c>

00:13:46.560 --> 00:13:47.628 align:middle
<c.magenta>这是什么意思呢</c>

00:13:47.895 --> 00:13:50.264 align:middle
<c.magenta>首先你会注意到的是 立刻</c>

00:13:50.330 --> 00:13:53.200 align:middle
<c.magenta>这个圆在中间停住了</c>

00:13:53.567 --> 00:13:57.237 align:middle
<c.magenta>在屏幕中间可以看到我们明显提示了</c>

00:13:57.304 --> 00:14:01.141 align:middle
<c.magenta>动画视图的实际模式数值</c>

00:13:57.304 --> 00:14:01.141 align:middle
<c.magenta>动画视图的实际模式数值</c>

00:14:01.775 --> 00:14:04.478 align:middle
<c.magenta>这时你可以对这个圆做任何操作</c>

00:14:04.845 --> 00:14:08.649 align:middle
<c.magenta>但我们传了个false参数来停止</c>

00:14:08.715 --> 00:14:10.417 align:middle
<c.magenta>表示不要立即跳到</c>

00:14:10.484 --> 00:14:13.520 align:middle
<c.magenta>非活动状态 保持在准完成状态</c>

00:14:13.987 --> 00:14:15.956 align:middle
<c.magenta>它表示在未来某个时候</c>

00:14:16.023 --> 00:14:18.592 align:middle
<c.magenta>你将调用</c>
<c.magenta>finishAnimation</c>

00:14:18.659 --> 00:14:23.764 align:middle line:1
<c.magenta>同时你将指定一个动画实际结束的位置</c>

00:14:23.830 --> 00:14:27.734 align:middle line:1
<c.magenta>在这个例子中 我们既不会在开始完成</c>
<c.magenta>也不会在结束完成</c>

00:14:28.135 --> 00:14:31.171 align:middle line:1
<c.magenta>你的完成函数</c>
<c.magenta>将会在这个位置被调用</c>

00:14:31.638 --> 00:14:34.241 align:middle
<c.magenta>现若你调用了stopAnimation</c>
<c.magenta>并传入了true参数</c>

00:14:34.308 --> 00:14:36.410 align:middle
<c.magenta>我们将不会调用你的结束函数</c>

00:14:36.476 --> 00:14:39.580 align:middle
<c.magenta>它将会在那个点完成</c>

00:14:40.180 --> 00:14:44.651 align:middle
<c.magenta>现在我们看看如果你调用</c>
<c.magenta>finishWithADifferentPosition会发生什么</c>

00:14:44.952 --> 00:14:47.154 align:middle
<c.magenta>若调用</c>
<c.magenta>finishWithTheEnd</c>

00:14:48.355 --> 00:14:52.860 align:middle
<c.magenta>它将会直接跳到动画的起始位置</c>

00:14:53.393 --> 00:14:56.196 align:middle
<c.magenta>你可能回想</c>
<c.magenta>“为什么需要这么做”</c>

00:14:56.630 --> 00:14:59.733 align:middle
<c.magenta>实际上这给了你很多可能</c>

00:14:59.800 --> 00:15:03.036 align:middle
<c.magenta>比如 想象下你将要暂停这个圆</c>

00:14:59.800 --> 00:15:03.036 align:middle
<c.magenta>比如 想象下你将要暂停这个圆</c>

00:15:03.170 --> 00:15:05.772 align:middle
<c.magenta>或者在你触摸它的时候来暂停动画</c>

00:15:06.206 --> 00:15:07.875 align:middle
<c.magenta>然后你可以拽这个圆来回转动</c>

00:15:07.941 --> 00:15:10.844 align:middle
<c.magenta>也许你设置了一些</c>
<c.magenta>UIKit的临时行为</c>

00:15:10.911 --> 00:15:14.281 align:middle
<c.magenta>在结束位置或者目标位置</c>

00:15:14.481 --> 00:15:17.718 align:middle
<c.magenta>当你释放它 根据你手势的速度</c>

00:15:17.885 --> 00:15:20.387 align:middle
<c.magenta>它可能卡入那些相对位置</c>

00:15:20.587 --> 00:15:23.557 align:middle
<c.magenta>一旦到达了那里就可调用</c>
<c.magenta>finishAnimation</c>

00:15:23.757 --> 00:15:25.726 align:middle
<c.magenta>通过.end和.begin</c>

00:15:25.926 --> 00:15:27.561 align:middle
<c.magenta>然后你可以做一些有意思的事情</c>

00:15:27.628 --> 00:15:30.764 align:middle
<c.magenta>来种植你开启的动画</c>

00:15:40.274 --> 00:15:42.609 align:middle
<c.magenta>好的 暂停和刷新</c>

00:15:43.310 --> 00:15:44.845 align:middle
<c.magenta>不是很多 对么</c>

00:15:45.479 --> 00:15:46.947 align:middle
<c.magenta>这有点意思</c>

00:15:47.014 --> 00:15:50.517 align:middle
<c.magenta>这里有个样例程序</c>

00:15:51.351 --> 00:15:53.887 align:middle
<c.magenta>我们给这个方块设置了一些手势识别</c>

00:15:53.954 --> 00:15:56.023 align:middle
<c.magenta>在那个绿色进度条上</c>

00:15:56.957 --> 00:16:00.594 align:middle
<c.magenta>我们可以刷那个进度条</c>

00:15:56.957 --> 00:16:00.594 align:middle
<c.magenta>我们可以刷那个进度条</c>

00:16:00.661 --> 00:16:03.096 align:middle
<c.magenta>我们用方块的位置更新它的值</c>

00:16:03.163 --> 00:16:04.998 align:middle
<c.magenta>然后我们继续操作方块</c>

00:16:05.632 --> 00:16:09.736 align:middle
<c.magenta>你会发现移动的时候方块的位置</c>

00:16:09.803 --> 00:16:12.206 align:middle
<c.magenta>在图中看起来有奇怪的突起</c>

00:16:12.272 --> 00:16:14.041 align:middle
<c.magenta>这里我们简单的说下</c>

00:16:15.509 --> 00:16:18.478 align:middle
<c.magenta>在介绍之前 我们看看这些手势识别</c>

00:16:18.545 --> 00:16:21.915 align:middle
<c.magenta>在方块上 我们添加了轻触手势识别</c>

00:16:22.115 --> 00:16:24.751 align:middle
<c.magenta>来检查动画是否是活动的</c>

00:16:25.018 --> 00:16:28.155 align:middle
<c.magenta>如果是活动的 它将会检查是否在运行</c>

00:16:28.522 --> 00:16:30.224 align:middle
<c.magenta>如果它在运行 将会暂停它</c>

00:16:30.290 --> 00:16:32.359 align:middle
<c.magenta>如果不是 它将会重新开始</c>

00:16:32.693 --> 00:16:33.760 align:middle
<c.magenta>相当直观</c>

00:16:34.995 --> 00:16:38.699 align:middle
<c.magenta>在进度条上</c>
<c.magenta>我们设置了一个平移手势</c>

00:16:38.932 --> 00:16:41.802 align:middle
<c.magenta>我们会根据位置计算一个分数</c>

00:16:41.869 --> 00:16:46.807 align:middle
<c.magenta>我们在平移时</c>

00:16:46.874 --> 00:16:50.244 align:middle
<c.magenta>相对整个进度条的边界</c>

00:16:50.310 --> 00:16:52.346 align:middle
<c.magenta>根据我们计算的分数</c>

00:16:52.513 --> 00:16:56.817 align:middle
<c.magenta>我们将同时更新动画生成器和</c>
<c.magenta>进度条作为fractionComplete</c>

00:17:00.554 --> 00:17:01.388 align:middle
<c.magenta>好的</c>

00:17:01.622 --> 00:17:04.590 align:middle
<c.magenta>那么 这个图怎么了</c>

00:17:08.896 --> 00:17:11.498 align:middle
<c.magenta>有些有意思的事情在发生</c>

00:17:14.167 --> 00:17:17.069 align:middle
<c.magenta>方便解释它</c>
<c.magenta>我将会回到之前类似的</c>

00:17:17.137 --> 00:17:19.573 align:middle
<c.magenta>夸大的渐入曲线</c>

00:17:20.307 --> 00:17:23.944 align:middle
<c.magenta>这次 进入了50%</c>

00:17:24.011 --> 00:17:26.780 align:middle
<c.magenta>我们暂停了动画</c>
<c.magenta>现在我们想刷信它</c>

00:17:29.116 --> 00:17:31.852 align:middle
<c.magenta>需要重点注意的是</c>
<c.magenta>fractionComplete</c>

00:17:32.119 --> 00:17:35.422 align:middle
<c.magenta>实际上你的设置和时间无关</c>

00:17:35.489 --> 00:17:37.024 align:middle
<c.magenta>我们刚暂停了动画</c>

00:17:37.090 --> 00:17:42.629 align:middle
<c.magenta>你设置的是相对于终点值的小数</c>

00:17:42.930 --> 00:17:46.166 align:middle
<c.magenta>在这种情况下 我们不会有任何进展</c>

00:17:46.633 --> 00:17:48.969 align:middle
<c.magenta>现在我们将会刷新这条线</c>

00:17:49.036 --> 00:17:50.637 align:middle
<c.magenta>我们将会继续来一次</c>

00:17:51.138 --> 00:17:56.243 align:middle
<c.magenta>我们不想跳到能看出位置</c>

00:17:56.543 --> 00:17:58.345 align:middle
<c.magenta>这个正在设置动画的视图</c>

00:17:58.779 --> 00:18:02.115 align:middle
<c.magenta>所以 实际上 我们是把时间映射回</c>

00:17:58.779 --> 00:18:02.115 align:middle
<c.magenta>所以 实际上 我们是把时间映射回</c>

00:18:02.182 --> 00:18:04.585 align:middle
<c.magenta>定时函数开始的位置</c>

00:18:04.918 --> 00:18:08.956 align:middle
<c.magenta>就是说当我们继续这个特殊的例子的话</c>

00:18:09.857 --> 00:18:11.859 align:middle
<c.magenta>这个动画将会快速的完成</c>

00:18:12.759 --> 00:18:16.063 align:middle
<c.magenta>所以当我们回到刚才看到的曲线</c>

00:18:16.129 --> 00:18:18.398 align:middle
<c.magenta>你会发现我们有点往回跳</c>

00:18:18.465 --> 00:18:22.169 align:middle
<c.magenta>到渐入渐出定时函数</c>

00:18:22.636 --> 00:18:25.205 align:middle
<c.magenta>并且注意到这很重要</c>
<c.magenta>当暂停和刷新的时候</c>

00:18:25.272 --> 00:18:29.309 align:middle
<c.magenta>根据任何UI提示你可能需要这么做</c>

00:18:29.409 --> 00:18:33.847 align:middle
<c.magenta>你可能会看到这些不连续性</c>
<c.magenta>并且需要做些补偿</c>

00:18:35.015 --> 00:18:36.984 align:middle
<c.magenta>好的 让我们谈下反转</c>

00:18:37.885 --> 00:18:40.921 align:middle
<c.magenta>有三种方式你可以用来反转</c>

00:18:41.421 --> 00:18:46.527 align:middle
<c.magenta>一个是你可以暂停反转 比如需要交互</c>

00:18:46.894 --> 00:18:48.095 align:middle
<c.magenta>需要再来一遍</c>

00:18:48.662 --> 00:18:52.699 align:middle
<c.magenta>你会发现你是字面上的直接反转回来</c>

00:18:52.799 --> 00:18:55.402 align:middle
<c.magenta>通过你指定的定时函数</c>

00:18:55.836 --> 00:18:57.571 align:middle
<c.magenta>你可以在任何时候反转</c>

00:18:58.038 --> 00:18:59.973 align:middle
<c.magenta>就是说 即使在动画运行时</c>

00:19:00.040 --> 00:19:01.208 align:middle
<c.magenta>你也可以来让动画反转</c>

00:19:01.275 --> 00:19:03.377 align:middle
<c.magenta>这有点像打一堵墙</c>

00:19:03.710 --> 00:19:07.080 align:middle
<c.magenta>再一次</c>
<c.magenta>这将会导致速度上的很大的不连续性</c>

00:19:07.414 --> 00:19:12.219 align:middle
<c.magenta>这将可能是你想要的</c>

00:19:12.286 --> 00:19:15.389 align:middle
<c.magenta>如果你想要一个完美的非弹性碰撞</c>
<c.magenta>或者类似的东西</c>

00:19:15.989 --> 00:19:18.959 align:middle
<c.magenta>如果你不想这样或者</c>
<c.magenta>你想让它更顺滑些</c>

00:19:19.193 --> 00:19:21.195 align:middle
<c.magenta>你可以累加的使用动画</c>

00:19:21.628 --> 00:19:24.965 align:middle
<c.magenta>在这个例子中 我们将会反转动画</c>

00:19:25.065 --> 00:19:27.134 align:middle line:1
<c.magenta>不是通过修改反转属性</c>

00:19:27.568 --> 00:19:31.905 align:middle line:1
<c.magenta>二是通过实际的修改值到</c>
<c.magenta>原始的位置</c>

00:19:32.573 --> 00:19:34.741 align:middle line:1
<c.magenta>它们的不同是</c>

00:19:34.808 --> 00:19:36.877 align:middle line:1
<c.magenta>结束的时候处理函数的调用</c>

00:19:36.944 --> 00:19:38.979 align:middle line:1
<c.magenta>.end函数将会被调用</c>

00:19:39.213 --> 00:19:41.014 align:middle line:1
<c.magenta>你已经改变了目标</c>

00:19:41.081 --> 00:19:46.687 align:middle line:1
<c.magenta>你将不会回到初始的目标</c>

00:19:46.753 --> 00:19:50.190 align:middle
<c.magenta>你将会回到你刚才指定的目标</c>

00:19:51.825 --> 00:19:54.361 align:middle
<c.magenta>好的 有些有意思的</c>

00:19:55.329 --> 00:20:01.468 align:middle
<c.magenta>定时对象可以用</c>

00:19:55.329 --> 00:20:01.468 align:middle
<c.magenta>定时对象可以用</c>

00:20:02.503 --> 00:20:05.639 align:middle
<c.magenta>第一个是UICubicTimingParameter类</c>

00:20:05.706 --> 00:20:08.141 align:middle
<c.magenta>如果创建这一类时不设定任何参数</c>

00:20:08.208 --> 00:20:11.778 align:middle
<c.magenta>你将得到默认的core animation时间曲线</c>

00:20:11.845 --> 00:20:14.848 align:middle
<c.magenta>这之前在UIKit层面并不可用</c>

00:20:15.482 --> 00:20:17.584 align:middle
<c.magenta>第二 构造函数变量</c>

00:20:17.651 --> 00:20:23.357 align:middle
<c.magenta>本质上是现有的canned动画曲线</c>

00:20:23.423 --> 00:20:27.494 align:middle
<c.magenta>最后我们开放了所有l</c>
<c.magenta>可用的贝赛尔曲线</c>

00:20:27.761 --> 00:20:29.830 align:middle
<c.magenta>供你在这个单位正方形内使用</c>

00:20:30.030 --> 00:20:32.299 align:middle
<c.magenta>举个你可能会做的事情为例</c>

00:20:32.366 --> 00:20:34.968 align:middle
<c.magenta>这个特殊的贝塞尔曲线</c>
<c.magenta>如果给它个名字</c>

00:20:35.035 --> 00:20:36.737 align:middle
<c.magenta>就叫“快进 快出”</c>

00:20:37.004 --> 00:20:40.974 align:middle
<c.magenta>你一定会欣喜若狂 当你看到想要用来</c>
<c.magenta>创建时间函数的贝塞尔曲线</c>

00:20:47.581 --> 00:20:52.119 align:middle
<c.magenta>我们已经为你们提供了更多方法</c>
<c.magenta>去做比如弹跳这样的动画</c>

00:20:52.219 --> 00:20:56.657 align:middle
<c.magenta>而且再来想一下我们认为</c>
<c.magenta>弹跳现在会影响时间</c>

00:20:56.924 --> 00:21:01.128 align:middle
<c.magenta>如果创建UISpringTimingParameter对象时</c>
<c.magenta>不设定引值</c>

00:20:56.924 --> 00:21:01.128 align:middle
<c.magenta>如果创建UISpringTimingParameter对象时</c>
<c.magenta>不设定引值</c>

00:21:01.195 --> 00:21:03.864 align:middle
<c.magenta>你会获得一个临界阻尼的弹跳动画</c>

00:21:03.931 --> 00:21:05.432 align:middle
<c.magenta>这是很多人想要的动画</c>

00:21:05.699 --> 00:21:10.938 align:middle
<c.magenta>比如我们就会用这个动画</c>
<c.magenta>在导航控制上进行推入或调出</c>

00:21:16.476 --> 00:21:22.482 align:middle
<c.magenta>第二个变量很像现有的</c>
<c.magenta>UIKit弹跳动画应用编程接口</c>

00:21:22.549 --> 00:21:25.052 align:middle
<c.magenta>但是还是点小区别</c>
<c.magenta>我马上就会讲到</c>

00:21:25.919 --> 00:21:27.120 align:middle
<c.magenta>但在讲这个之前</c>

00:21:27.521 --> 00:21:30.290 align:middle
<c.magenta>我们以为你打开了一个弹跳方程</c>

00:21:30.357 --> 00:21:33.560 align:middle
<c.magenta>你可以定义任何你想要的系数</c>

00:21:33.627 --> 00:21:36.830 align:middle
<c.magenta>我们也会切实重视这些系数</c>

00:21:37.364 --> 00:21:38.565 align:middle
<c.magenta>但这里有个问题</c>

00:21:38.632 --> 00:21:44.104 align:middle
<c.magenta>就是你定义的时长</c>
<c.magenta>被忽略了</c>

00:21:44.171 --> 00:21:48.041 align:middle
<c.magenta>我们对这个时长的计算是根据</c>
<c.magenta>弹跳方程的解法</c>

00:21:48.275 --> 00:21:49.810 align:middle
<c.magenta>举这样一个例子</c>

00:21:53.680 --> 00:21:54.948 align:middle
<c.magenta>我说过他们之间有区别</c>

00:21:55.015 --> 00:21:58.252 align:middle
<c.magenta>你会发现初始的速率</c>
<c.magenta>现在变成了矢量</c>

00:21:58.418 --> 00:21:59.720 align:middle
<c.magenta>而不是标量</c>

00:22:00.721 --> 00:22:02.890 align:middle
<c.magenta>很多时候我们不会注意</c>

00:22:02.956 --> 00:22:04.958 align:middle
<c.magenta>这个矢量的y分量</c>

00:22:05.359 --> 00:22:09.563 align:middle
<c.magenta>但是如果你在视图中心做动画</c>

00:22:09.863 --> 00:22:14.034 align:middle
<c.magenta>那么这个矢量的x和y分量</c>
<c.magenta>必须都要注意</c>

00:22:14.101 --> 00:22:16.904 align:middle
<c.magenta>原因就用这个应用程序实例说明</c>

00:22:17.304 --> 00:22:19.740 align:middle
<c.magenta>我们将正这个方形拖离中心</c>

00:22:20.073 --> 00:22:22.276 align:middle
<c.magenta>并在松手的时候要让它</c>

00:22:22.342 --> 00:22:24.845 align:middle
<c.magenta>根据手势的速率</c>
<c.magenta>弹回中心</c>

00:22:25.779 --> 00:22:31.418 align:middle
<c.magenta>直至现在这个速率</c>
<c.magenta>始终沿着一条线</c>

00:22:31.485 --> 00:22:34.888 align:middle
<c.magenta>就是两个正方形之间的连线</c>
<c.magenta>这不是件好事</c>

00:22:34.955 --> 00:22:39.026 align:middle
<c.magenta>因为我的手势可能</c>
<c.magenta>在平面的任何地方结束</c>

00:22:39.092 --> 00:22:42.062 align:middle
<c.magenta>而我们事实上并没有</c>
<c.magenta>实际考虑到这一点</c>

00:22:42.996 --> 00:22:44.431 align:middle
<c.magenta>但现在我们想到了</c>

00:22:44.498 --> 00:22:46.166 align:middle
<c.magenta>所以我们来看一下这个小视频</c>

00:22:46.233 --> 00:22:50.504 align:middle
<c.magenta>展示了我们现在是怎样</c>
<c.magenta>让正方形弹回中心</c>

00:22:50.571 --> 00:22:54.508 align:middle
<c.magenta>并将二维矢量位置都考虑在内</c>

00:22:54.741 --> 00:22:56.243 align:middle
<c.magenta>你会看到</c>
<c.magenta>在我们开始做时</c>

00:22:56.310 --> 00:22:58.645 align:middle
<c.magenta>会同时考虑到</c>
<c.magenta>x和y分量</c>

00:22:58.912 --> 00:22:59.913 align:middle
<c.magenta>这很简单</c>

00:23:06.954 --> 00:23:08.856 align:middle
<c.magenta>现在我们有了这个</c>
<c.magenta>很好的属性动画</c>

00:23:08.922 --> 00:23:09.957 align:middle
<c.magenta>那么如何呢？</c>

00:23:10.190 --> 00:23:13.961 align:middle
<c.magenta>我想要利用它实现</c>
<c.magenta>自定义视图控制器转换</c>

00:23:14.027 --> 00:23:16.330 align:middle
<c.magenta>而且我希望它们也是可中断的</c>

00:23:17.331 --> 00:23:21.335 align:middle
<c.magenta>三年前</c>
<c.magenta>我就此做了一整场演讲</c>

00:23:21.401 --> 00:23:23.036 align:middle
<c.magenta>所以它的确有些复杂</c>

00:23:23.103 --> 00:23:26.573 align:middle
<c.magenta>如果你不熟悉自定义视图控制器转换</c>

00:23:26.640 --> 00:23:28.408 align:middle
<c.magenta>请参考之前的演讲</c>

00:23:28.475 --> 00:23:32.579 align:middle
<c.magenta>但我会快速地概述一下</c>
<c.magenta>打个基础</c>

00:23:32.646 --> 00:23:34.982 align:middle
<c.magenta>准备讲解我们如何拓展这些协议</c>

00:23:35.182 --> 00:23:39.019 align:middle
<c.magenta>视图控制器转换一般是</c>
<c.magenta>一组连锁协议</c>

00:23:39.086 --> 00:23:43.524 align:middle
<c.magenta>其中两个包括</c>
<c.magenta>交互转换和动画转换</c>

00:23:43.590 --> 00:23:46.894 align:middle
<c.magenta>他们是你创建对象时</c>
<c.magenta>需要符合的协议</c>

00:23:47.427 --> 00:23:49.563 align:middle
<c.magenta>好吧 是你创建的对象</c>
<c.magenta>要符合的协议</c>

00:23:50.664 --> 00:23:53.767 align:middle
<c.magenta>系统会创建另一个对象并传递给</c>

00:23:53.834 --> 00:23:57.171 align:middle
<c.magenta>该协议的方法</c>

00:23:57.237 --> 00:23:58.772 align:middle
<c.magenta>这个稍后我们会讲清楚</c>

00:23:59.473 --> 00:24:01.375 align:middle
<c.magenta>但是要记得我们为什么想这么做</c>

00:23:59.473 --> 00:24:01.375 align:middle
<c.magenta>但是要记得我们为什么想这么做</c>

00:24:01.441 --> 00:24:04.545 align:middle
<c.magenta>假设你有一个应用程序</c>
<c.magenta>带导航控制器</c>

00:24:06.180 --> 00:24:08.215 align:middle
<c.magenta>而且pop看上去挺正常</c>

00:24:08.282 --> 00:24:11.852 align:middle
<c.magenta>它是个不错的</c>
<c.magenta>临界阻尼弹跳动画</c>

00:24:12.219 --> 00:24:14.321 align:middle
<c.magenta>但是你的应用</c>
<c.magenta>需要点不一样的东西</c>

00:24:14.655 --> 00:24:18.559 align:middle
<c.magenta>它需要的是</c>
<c.magenta>完全不一样的外观</c>

00:24:18.625 --> 00:24:22.362 align:middle
<c.magenta>它可以爆炸式弹出</c>
<c.magenta>或许下面还带模糊效果</c>

00:24:22.829 --> 00:24:25.699 align:middle
<c.magenta>这就是自定义视图控制器转换</c>
<c.magenta>让你能做到的事情</c>

00:24:25.832 --> 00:24:29.303 align:middle
<c.magenta>而且它还可以让你的编写</c>
<c.magenta>和驱动更有交互性</c>

00:24:30.504 --> 00:24:33.407 align:middle
<c.magenta>要得到这些符合协议的对象</c>

00:24:33.473 --> 00:24:35.375 align:middle
<c.magenta>只需要通过一个代理</c>

00:24:35.475 --> 00:24:37.678 align:middle
<c.magenta>它可以是导航控制器代理</c>

00:24:37.744 --> 00:24:40.514 align:middle
<c.magenta>也可以是视图控制器的转换代理</c>

00:24:41.381 --> 00:24:42.916 align:middle
<c.magenta>我们要问这个代理</c>

00:24:42.983 --> 00:24:45.953 align:middle
<c.magenta>“你是否都有符合动画转换的对象</c>

00:24:46.019 --> 00:24:49.022 align:middle
<c.magenta>可以在任何时候显示</c>
<c.magenta>推入或者弹出？”</c>

00:24:49.590 --> 00:24:53.227 align:middle
<c.magenta>如果有 我们将</c>
<c.magenta>绕过内置转换</c>

00:24:53.594 --> 00:24:56.563 align:middle
<c.magenta>我们要创建其中一个</c>
<c.magenta>转换context对象</c>

00:24:56.630 --> 00:24:58.599 align:middle
<c.magenta>它可以给你所有你需要的信息</c>

00:24:58.665 --> 00:25:00.868 align:middle
<c.magenta>去实现转场动画</c>

00:24:58.665 --> 00:25:00.868 align:middle
<c.magenta>去实现转场动画</c>

00:25:01.101 --> 00:25:05.205 align:middle
<c.magenta>我们会命令animateTransition</c>
<c.magenta>将context传递给你"</c>

00:25:07.040 --> 00:25:08.475 align:middle
<c.magenta>那如何让这个流程可中断？</c>

00:25:08.976 --> 00:25:14.748 align:middle
<c.magenta>我们所做的是添加了新的方法</c>
<c.magenta>叫interruptibleAnimator(using</c>

00:25:15.082 --> 00:25:18.151 align:middle
<c.magenta>如果要执行它</c>
<c.magenta>你需要返回一个对象</c>

00:25:18.218 --> 00:25:20.954 align:middle
<c.magenta>符合UIViewImplicitlyAnimating</c>

00:25:21.021 --> 00:25:23.357 align:middle
<c.magenta>他可以是一个UIViewPropertyAnimator</c>

00:25:23.657 --> 00:25:24.858 align:middle
<c.magenta>但不是必须的</c>

00:25:24.925 --> 00:25:28.095 align:middle
<c.magenta>它也可以是另一种动画</c>

00:25:28.161 --> 00:25:34.001 align:middle
<c.magenta>即你的执行可以根据UIKit动态</c>
<c.magenta>或者其他动画策略</c>

00:25:36.670 --> 00:25:41.675 align:middle
<c.magenta>如果你不执行交互控制器</c>

00:25:42.409 --> 00:25:44.778 align:middle
<c.magenta>意思是你只执行了</c>
<c.magenta>自定义动画控制器</c>

00:25:44.845 --> 00:25:46.980 align:middle
<c.magenta>那么你需要执行</c>
<c.magenta>animateTransition</c>

00:25:47.047 --> 00:25:50.918 align:middle
<c.magenta>这个十分简单</c>
<c.magenta>只要你用这个方法</c>

00:25:50.984 --> 00:25:54.188 align:middle
<c.magenta>你只要接收可中断的</c>
<c.magenta>animator然后返回值</c>

00:25:54.621 --> 00:25:56.290 align:middle
<c.magenta>然后只要给一个开始命令</c>

00:25:56.623 --> 00:25:59.726 align:middle
<c.magenta>这就是执行animateTransition的所有步骤了</c>

00:26:01.461 --> 00:26:05.032 align:middle
<c.magenta>但是我们建议你使用交互控制器</c>

00:26:05.098 --> 00:26:06.800 align:middle
<c.magenta>如果你想让它变成可中断</c>

00:26:07.434 --> 00:26:11.972 align:middle
<c.magenta>重申一下首要的事</c>
<c.magenta>就是要符合</c>

00:26:12.172 --> 00:26:15.876 align:middle
<c.magenta>是说返回的对象要符合</c>
<c.magenta>转场动画的协议</c>

00:26:15.943 --> 00:26:19.646 align:middle
<c.magenta>然后我们会要你提供一个</c>
<c.magenta>符合交互转场的对象</c>

00:26:19.713 --> 00:26:22.716 align:middle
<c.magenta>并且会传递</c>
<c.magenta>之前返回给我们的对象</c>

00:26:22.783 --> 00:26:24.952 align:middle
<c.magenta>是作为一个参数来传递</c>

00:26:26.086 --> 00:26:29.489 align:middle
<c.magenta>很多时候</c>
<c.magenta>你希望这个交互控制器</c>

00:26:29.556 --> 00:26:32.860 align:middle
<c.magenta>可以真正驱动动画控制器</c>

00:26:36.096 --> 00:26:38.899 align:middle
<c.magenta>若是如此 我们就不用调出</c>
<c.magenta>animateTransition</c>

00:26:38.966 --> 00:26:41.134 align:middle
<c.magenta>而是调出</c>
<c.magenta>startInteractiveTransition</c>

00:26:41.201 --> 00:26:42.936 align:middle
<c.magenta>传递的context是完全一样</c>

00:26:43.003 --> 00:26:45.305 align:middle
<c.magenta>用animateTransition也是这样</c>

00:26:47.941 --> 00:26:50.577 align:middle
<c.magenta>我们会提供一个具体的类</c>
<c.magenta>你可以直接使用</c>

00:26:50.644 --> 00:26:52.513 align:middle
<c.magenta>这样操作起来就十分简单</c>

00:26:53.914 --> 00:26:57.050 align:middle
<c.magenta>在此之前还有一个限制</c>

00:26:57.117 --> 00:27:00.721 align:middle
<c.magenta>若要执行UIPercentDriven</c>
<c.magenta>InteractiveTransition</c>

00:26:57.117 --> 00:27:00.721 align:middle
<c.magenta>若要执行UIPercentDriven</c>
<c.magenta>InteractiveTransition</c>

00:27:00.787 --> 00:27:04.157 align:middle
<c.magenta>那么animateTransition方法</c>

00:27:04.224 --> 00:27:07.661 align:middle
<c.magenta>在动画控制器中的执行就要按照</c>

00:27:07.728 --> 00:27:10.564 align:middle
<c.magenta>现有的UIKit动画应用编程接口执行</c>

00:27:11.498 --> 00:27:14.868 align:middle
<c.magenta>但是现在有了可中断的animator</c>

00:27:14.935 --> 00:27:18.238 align:middle
<c.magenta>UIPercentDriven InteractiveTransition</c>
<c.magenta>根本就不需要在意这个接口</c>

00:27:18.305 --> 00:27:23.944 align:middle
<c.magenta>只要使用</c>
<c.magenta>UIViewImplicitlyAnimating定义的协议</c>

00:27:24.077 --> 00:27:25.646 align:middle
<c.magenta>就这些了</c>

00:27:25.712 --> 00:27:27.948 align:middle
<c.magenta>这样你就可以真正创造一个</c>
<c.magenta>全然不同的动画</c>

00:27:28.015 --> 00:27:30.918 align:middle
<c.magenta>由UIPercentDriven</c>
<c.magenta>I交互转场驱动</c>

00:27:31.451 --> 00:27:32.452 align:middle
<c.magenta>这是不是很酷</c>

00:27:34.021 --> 00:27:36.423 align:middle
<c.magenta>假设你已经有了一个这样的动画</c>

00:27:36.490 --> 00:27:37.891 align:middle
<c.magenta>也有了一个自定义转场</c>

00:27:37.958 --> 00:27:38.992 align:middle
<c.magenta>如何将他们合并呢？</c>

00:27:39.426 --> 00:27:41.828 align:middle
<c.magenta>一种方法从表面上来讲</c>

00:27:41.895 --> 00:27:46.233 align:middle
<c.magenta>将animateTransition方法</c>
<c.magenta>重命名为myAnimateTransition</c>

00:27:46.300 --> 00:27:49.303 align:middle
<c.magenta>再用同样的方法</c>
<c.magenta>创建可中断的animator</c>

00:27:49.636 --> 00:27:52.873 align:middle
<c.magenta>你就只要添加这个任务方法到</c>

00:27:54.208 --> 00:27:56.276 align:middle
<c.magenta>animator中</c>
<c.magenta>一个动画上就可以了</c>

00:27:56.643 --> 00:27:57.711 align:middle
<c.magenta>这不难</c>

00:28:00.314 --> 00:28:04.685 align:middle
<c.magenta>我们的确要拓展</c>
<c.magenta>协议中的某些对象</c>

00:28:04.751 --> 00:28:09.056 align:middle
<c.magenta>比如现在的context转场中就添加了</c>
<c.magenta>pauseInteractiveTransition</c>

00:28:09.423 --> 00:28:13.193 align:middle
<c.magenta>现在这就是进入交互状态的方法</c>

00:28:13.493 --> 00:28:17.998 align:middle
<c.magenta>在这之前要先启动交互</c>
<c.magenta>并关闭非交互式</c>

00:28:18.098 --> 00:28:19.700 align:middle
<c.magenta>现在你就可以来回移动了</c>

00:28:19.766 --> 00:28:25.205 align:middle
<c.magenta>移动要通过调用pauseInteractive</c>
<c.magenta>结束或取消也一样</c>

00:28:27.174 --> 00:28:30.377 align:middle
<c.magenta>同样isInteractive属性</c>
<c.magenta>以及</c>

00:28:30.444 --> 00:28:34.047 align:middle
<c.magenta>transitionWasCancelled</c>
<c.magenta>就可以随着你的前后移动</c>

00:28:34.114 --> 00:28:37.784 align:middle
<c.magenta>在交互和非交互中切换</c>

00:28:40.053 --> 00:28:42.990 align:middle
<c.magenta>我们添加了一个变量</c>
<c.magenta>叫wantsInteractiveStart</c>

00:28:43.056 --> 00:28:44.925 align:middle
<c.magenta>既然已经可以前后移动</c>

00:28:45.459 --> 00:28:49.630 align:middle
<c.magenta>那你也许想要交互控制器</c>
<c.magenta>从非交互式出发</c>

00:28:49.863 --> 00:28:52.232 align:middle
<c.magenta>此变量就控制这一行为</c>

00:28:54.902 --> 00:29:00.140 align:middle
<c.magenta>最后我们更新</c>
<c.magenta>UIPercentDriven交互转场</c>

00:28:54.902 --> 00:29:00.140 align:middle
<c.magenta>最后我们更新</c>
<c.magenta>UIPercentDriven交互转场</c>

00:29:01.308 --> 00:29:02.342 align:middle
<c.magenta>这有几点规定</c>

00:29:02.409 --> 00:29:05.078 align:middle
<c.magenta>如果执行InterruptibleAnimator</c>

00:29:05.212 --> 00:29:07.781 align:middle
<c.magenta>我们希望它能真正有用</c>

00:29:08.048 --> 00:29:09.650 align:middle
<c.magenta>就是说不做其他事情</c>

00:29:09.716 --> 00:29:11.084 align:middle
<c.magenta>系统可能会很不高兴</c>

00:29:11.451 --> 00:29:13.053 align:middle
<c.magenta>我们会始终调用</c>
<c.magenta>animateTransition</c>

00:29:13.120 --> 00:29:15.088 align:middle
<c.magenta>并最先启动startInteractiveTransition</c>

00:29:15.389 --> 00:29:17.391 align:middle
<c.magenta>这样就有很大的空间</c>

00:29:17.457 --> 00:29:20.727 align:middle
<c.magenta>去创建可中断的animator</c>
<c.magenta>因为它将在</c>

00:29:20.794 --> 00:29:23.163 align:middle
<c.magenta>之后编写中被重复调出</c>
<c.magenta>用同样的context</c>

00:29:23.230 --> 00:29:28.168 align:middle
<c.magenta>我们也希望返回值能</c>
<c.magenta>一直是同一个</c>

00:29:28.769 --> 00:29:32.272 align:middle
<c.magenta>最后animator的时长</c>
<c.magenta>可以涵盖整个转场时长</c>

00:29:32.439 --> 00:29:36.343 align:middle
<c.magenta>在整个转场结束之前</c>
<c.magenta>它必须处于活动状态</c>

00:29:37.244 --> 00:29:40.981 align:middle
<c.magenta>现在请Mike上台为大家展示</c>
<c.magenta>如何在应用程序中使用应用编程接口</c>

00:29:42.783 --> 00:29:44.017 align:middle
<c.magenta>没给你留多少时间</c>

00:29:48.589 --> 00:29:49.756 align:middle
<c.magenta>谢谢你 Bruce</c>

00:29:52.926 --> 00:29:53.794 align:middle
<c.magenta>不客气</c>

00:29:55.429 --> 00:29:57.664 align:middle
<c.magenta>首先来看这个演示应用</c>

00:29:58.198 --> 00:30:02.603 align:middle
<c.magenta>这个应用使用UIViewPropertyAnimator</c>

00:29:58.198 --> 00:30:02.603 align:middle
<c.magenta>这个应用使用UIViewPropertyAnimator</c>

00:30:02.669 --> 00:30:05.572 align:middle
<c.magenta>和UIViewController</c>
<c.magenta>转场的添加函数</c>

00:30:06.907 --> 00:30:10.143 align:middle
<c.magenta>在基本应用中创建</c>
<c.magenta>完美的可中断自定义转场</c>

00:30:10.410 --> 00:30:13.814 align:middle
<c.magenta>第一 应用要使用UINavigationController</c>

00:30:14.348 --> 00:30:15.916 align:middle
<c.magenta>并且内置有一个集合视图控制器</c>

00:30:15.983 --> 00:30:17.951 align:middle
<c.magenta>这是个照片格子</c>
<c.magenta>可以拉动浏览</c>

00:30:18.519 --> 00:30:19.820 align:middle
<c.magenta>当我们点击其中一张照片</c>

00:30:20.120 --> 00:30:22.422 align:middle
<c.magenta>它会推进导航栈上</c>
<c.magenta>其他视图控制器</c>

00:30:23.123 --> 00:30:26.059 align:middle
<c.magenta>让你的图片视图</c>
<c.magenta>更加清晰具体</c>

00:30:26.126 --> 00:30:28.595 align:middle
<c.magenta>如果我们点击返回键</c>
<c.magenta>这个视图就弹回导航栈</c>

00:30:28.962 --> 00:30:31.965 align:middle
<c.magenta>另外我们可以滑动屏幕</c>
<c.magenta>从左向右</c>

00:30:32.332 --> 00:30:34.201 align:middle
<c.magenta>实现交互转场返回</c>

00:30:34.268 --> 00:30:37.704 align:middle
<c.magenta>这些在UINavigationController基本都免费</c>

00:30:38.539 --> 00:30:41.842 align:middle
<c.magenta>就像Bruce刚才所说</c>
<c.magenta>我们还有很多套应用编程接口</c>

00:30:41.909 --> 00:30:43.911 align:middle
<c.magenta>能让你自定义转场</c>

00:30:44.178 --> 00:30:45.946 align:middle
<c.magenta>如果我们想放大照片</c>

00:30:46.013 --> 00:30:49.316 align:middle
<c.magenta>让他铺满页面</c>
<c.magenta>我们也可以做到 这很酷</c>

00:30:49.383 --> 00:30:51.418 align:middle
<c.magenta>点击返回键</c>
<c.magenta>照片就缩小回去</c>

00:30:51.818 --> 00:30:53.320 align:middle
<c.magenta>这些在此之前都只是设想</c>

00:30:53.820 --> 00:30:56.023 align:middle
<c.magenta>另外你也可以向下拖拽</c>

00:30:56.089 --> 00:30:58.926 align:middle
<c.magenta>来启动交互转场</c>
<c.magenta>再转动几下</c>

00:30:59.092 --> 00:31:01.128 align:middle
<c.magenta>让整个动作以动画方式完成</c>

00:30:59.092 --> 00:31:01.128 align:middle
<c.magenta>让整个动作以动画方式完成</c>

00:31:01.762 --> 00:31:03.964 align:middle
<c.magenta>我想向你们展示的是</c>
<c.magenta>我们如何做到这样</c>

00:31:04.031 --> 00:31:05.732 align:middle
<c.magenta>通过使用UIViewPropertyAnimator</c>

00:31:12.739 --> 00:31:15.409 align:middle
<c.magenta>首先你做的就是告诉系统</c>

00:31:15.475 --> 00:31:16.910 align:middle
<c.magenta>这里应该说是导航控制器</c>

00:31:17.110 --> 00:31:19.913 align:middle
<c.magenta>你要提供一个自定义转场</c>

00:31:19.980 --> 00:31:22.716 align:middle
<c.magenta>那么这里我们就要符合</c>
<c.magenta>导航控制器的代理</c>

00:31:23.050 --> 00:31:25.519 align:middle
<c.magenta>通过AssetTransitionController来实现</c>

00:31:25.586 --> 00:31:29.790 align:middle
<c.magenta>这是我们创建的对象</c>
<c.magenta>可以执行这些转场协议</c>

00:31:30.490 --> 00:31:32.626 align:middle
<c.magenta>这里我们要注意</c>
<c.magenta>两种十分重要的方法</c>

00:31:32.693 --> 00:31:34.962 align:middle
<c.magenta>第一个是调出动画控制器</c>

00:31:35.395 --> 00:31:37.464 align:middle
<c.magenta>通过一个特定操作</c>
<c.magenta>推入或弹出</c>

00:31:37.664 --> 00:31:40.067 align:middle
<c.magenta>我们要保存该操作</c>
<c.magenta>然后返回值给自己</c>

00:31:40.133 --> 00:31:41.635 align:middle
<c.magenta>因为我们就是动画控制器</c>

00:31:42.469 --> 00:31:44.938 align:middle
<c.magenta>然后当我们将对象</c>
<c.magenta>从那个接口返回后</c>

00:31:45.205 --> 00:31:47.407 align:middle
<c.magenta>系统将调出一个交互控制器</c>

00:31:48.041 --> 00:31:50.077 align:middle
<c.magenta>在这里我们还是返回值给自己</c>

00:31:50.143 --> 00:31:51.912 align:middle
<c.magenta>因为我们也要扮演交互控制器</c>

00:31:52.212 --> 00:31:54.581 align:middle
<c.magenta>完成之后</c>
<c.magenta>系统就会知道</c>

00:31:54.648 --> 00:31:55.916 align:middle
<c.magenta>这里会有一个交互转场</c>

00:31:56.717 --> 00:32:00.354 align:middle
<c.magenta>现在来看一下UIViewController</c>
<c.magenta>InteractiveTransitioning</c>

00:31:56.717 --> 00:32:00.354 align:middle
<c.magenta>现在来看一下UIViewController</c>
<c.magenta>InteractiveTransitioning</c>

00:32:01.221 --> 00:32:04.358 align:middle
<c.magenta>这里系统会调出</c>
<c.magenta>startInteractiveTransition</c>

00:32:04.424 --> 00:32:06.660 align:middle
<c.magenta>并以转场context调出</c>
<c.magenta>我们的对象</c>

00:32:06.727 --> 00:32:08.295 align:middle
<c.magenta>这会包含所有有关信息</c>

00:32:08.362 --> 00:32:11.164 align:middle
<c.magenta>对于我们开始自定义转场十分必要</c>

00:32:12.132 --> 00:32:14.268 align:middle
<c.magenta>这里我们将创建一个辅助对象</c>

00:32:14.334 --> 00:32:16.703 align:middle
<c.magenta>一会儿我们会看到更多</c>

00:32:16.937 --> 00:32:21.275 align:middle
<c.magenta>这个对象将会</c>
<c.magenta>创建我们的转场动画</c>

00:32:21.341 --> 00:32:24.411 align:middle
<c.magenta>我们要将context传递给</c>
<c.magenta>我们之前所保存的操作</c>

00:32:24.478 --> 00:32:28.348 align:middle
<c.magenta>同时也要传给panGestureRecognizer</c>
<c.magenta>就是之前用于启动交互转场的程序</c>

00:32:28.849 --> 00:32:32.319 align:middle
<c.magenta>IOS10允许交互转场</c>

00:32:32.386 --> 00:32:35.656 align:middle
<c.magenta>分两个进程开始</c>
<c.magenta>动画进程和交互进程</c>

00:32:35.923 --> 00:32:38.192 align:middle
<c.magenta>若从panGestureRecognizer开始</c>

00:32:38.258 --> 00:32:41.161 align:middle
<c.magenta>就要设initiallyInteractive变量</c>

00:32:41.228 --> 00:32:42.963 align:middle
<c.magenta>为真</c>
<c.magenta>以便系统知道</c>

00:32:43.030 --> 00:32:45.832 align:middle
<c.magenta>我们正在开始这个交互转场</c>

00:32:48.001 --> 00:32:51.471 align:middle
<c.magenta>下面看一下动画转场的执行</c>

00:32:51.738 --> 00:32:54.842 align:middle
<c.magenta>这里我们不太在意</c>
<c.magenta>动画方法</c>

00:32:54.908 --> 00:32:57.611 align:middle
<c.magenta>就像布鲁斯提到那样</c>
<c.magenta>我们使用的是交互控制器</c>

00:32:57.678 --> 00:32:59.580 align:middle
<c.magenta>它会调出startInteractiveTransition</c>

00:32:59.646 --> 00:33:01.648 align:middle
<c.magenta>相对于animateTransition</c>

00:32:59.646 --> 00:33:01.648 align:middle
<c.magenta>相对于animateTransition</c>

00:33:01.715 --> 00:33:04.751 align:middle
<c.magenta>但iOS10里</c>
<c.magenta>新的可中断动画接口</c>

00:33:04.818 --> 00:33:06.286 align:middle
<c.magenta>才是我们真正的兴趣所在</c>

00:33:06.753 --> 00:33:07.921 align:middle
<c.magenta>这里是我们的辅助对象</c>

00:33:07.988 --> 00:33:11.625 align:middle
<c.magenta>一会儿会看到它创建了一个</c>
<c.magenta>UIViewPropertyAnimator</c>

00:33:11.692 --> 00:33:13.460 align:middle
<c.magenta>并且将它的值返回了系统</c>

00:33:13.827 --> 00:33:17.364 align:middle
<c.magenta>所以这里就是系统</c>
<c.magenta>添加任何并列动画的地方</c>

00:33:17.431 --> 00:33:20.767 align:middle
<c.magenta>在这个演示中你会看到</c>
<c.magenta>顶部的导航条</c>

00:33:20.834 --> 00:33:22.402 align:middle
<c.magenta>跟着我们的转场一起在动</c>

00:33:22.469 --> 00:33:26.406 align:middle
<c.magenta>系统会利用这个animator</c>
<c.magenta>来添加这些动画</c>

00:33:27.040 --> 00:33:29.877 align:middle
<c.magenta>现在看看转场驱动</c>
<c.magenta>辅助对象有多快</c>

00:33:31.545 --> 00:33:35.382 align:middle
<c.magenta>在此 startInteractiveTransition</c>
<c.magenta>初始化了这个对象</c>

00:33:36.783 --> 00:33:39.019 align:middle
<c.magenta>这就会联通</c>
<c.magenta>抱歉</c>

00:33:40.387 --> 00:33:41.288 align:middle
<c.magenta>是这里</c>

00:33:41.355 --> 00:33:44.024 align:middle
<c.magenta>这就可以联通这个辅助方法</c>

00:33:44.091 --> 00:33:45.759 align:middle
<c.magenta>和一些动画</c>
<c.magenta>然后它会设定一些</c>

00:33:45.826 --> 00:33:47.995 align:middle
<c.magenta>背景动画给这个转场</c>

00:33:48.662 --> 00:33:50.163 align:middle
<c.magenta>视觉效果就是动态的</c>

00:33:50.230 --> 00:33:52.399 align:middle
<c.magenta>这两个视图控制器和alpha</c>
<c.magenta>也是动态的</c>

00:33:52.699 --> 00:33:56.603 align:middle
<c.magenta>我们稍后再讲</c>
<c.magenta>图片边框切换</c>

00:33:57.037 --> 00:34:00.274 align:middle
<c.magenta>它会传递完成关闭指令</c>
<c.magenta>也会帮助清理</c>

00:33:57.037 --> 00:34:00.274 align:middle
<c.magenta>它会传递完成关闭指令</c>
<c.magenta>也会帮助清理</c>

00:34:00.340 --> 00:34:01.542 align:middle
<c.magenta>一些背景视图</c>

00:34:01.608 --> 00:34:04.144 align:middle
<c.magenta>但是这里的重点是</c>
<c.magenta>我们如何创建这个属性动画</c>

00:34:04.211 --> 00:34:06.780 align:middle
<c.magenta>并返回到interruptibleAnimator接口</c>

00:34:07.114 --> 00:34:09.516 align:middle
<c.magenta>首先我们从辅助函数中</c>
<c.magenta>获得一个转场时长</c>

00:34:09.583 --> 00:34:11.150 align:middle
<c.magenta>我们也是过会儿再看这个</c>

00:34:11.485 --> 00:34:13.954 align:middle
<c.magenta>创建PropertyAnimator</c>
<c.magenta>并选择时长</c>

00:34:14.021 --> 00:34:15.322 align:middle
<c.magenta>以及easeOut曲线</c>

00:34:15.621 --> 00:34:18.025 align:middle
<c.magenta>我们会在收到的动画间传递</c>

00:34:18.692 --> 00:34:20.327 align:middle
<c.magenta>并在这里创建一个完成处理</c>

00:34:21.061 --> 00:34:23.730 align:middle
<c.magenta>然后调出这些传给我们的</c>
<c.magenta>完成命令</c>

00:34:23.797 --> 00:34:25.299 align:middle
<c.magenta>重要的是我们要调出</c>

00:34:25.364 --> 00:34:28.001 align:middle
<c.magenta>转场context</c>
<c.magenta>在动画结束时</c>

00:34:28.368 --> 00:34:31.103 align:middle
<c.magenta>告诉系统</c>
<c.magenta>“嘿 我们的转场完成了”</c>

00:34:31.505 --> 00:34:33.206 align:middle
<c.magenta>然后到了...</c>

00:34:33.273 --> 00:34:34.141 align:middle
<c.magenta>抱歉</c>

00:34:34.208 --> 00:34:36.777 align:middle
<c.magenta>completionTransition接口有一个博尔值</c>

00:34:37.710 --> 00:34:39.847 align:middle
<c.magenta>让我们可以得到</c>
<c.magenta>应该传递的值</c>

00:34:39.913 --> 00:34:42.382 align:middle
<c.magenta>所以从这个接口传递“yes”</c>

00:34:42.449 --> 00:34:43.951 align:middle
<c.magenta>这就意味着</c>
<c.magenta>我们要结束这个转场</c>

00:34:44.016 --> 00:34:46.320 align:middle
<c.magenta>如果传递“no”</c>
<c.magenta>意思就是取消转场</c>

00:34:47.221 --> 00:34:52.492 align:middle
<c.magenta>在我接着讲转场动画</c>
<c.magenta>辅助对象之前</c>

00:34:52.826 --> 00:34:54.895 align:middle
<c.magenta>我想再展示这个演示应用的</c>
<c.magenta>一些其他特点</c>

00:34:54.962 --> 00:34:57.931 align:middle
<c.magenta>都由UIViewPropertyAnimator实现</c>

00:35:02.302 --> 00:35:06.273 align:middle
<c.magenta>回到演示应用</c>
<c.magenta>我之前展示了如何放大图片</c>

00:35:06.340 --> 00:35:08.942 align:middle
<c.magenta>和通过点击返回键缩小屏幕</c>

00:35:09.009 --> 00:35:11.812 align:middle
<c.magenta>但我没有展示</c>
<c.magenta>你可以在半空中暂停</c>

00:35:12.379 --> 00:35:14.882 align:middle
<c.magenta>现在我们正在动画进程</c>
<c.magenta>但是暂停动画</c>

00:35:15.048 --> 00:35:16.650 align:middle
<c.magenta>然后进入交互进程</c>

00:35:16.984 --> 00:35:19.186 align:middle
<c.magenta>这样与照片的交互</c>
<c.magenta>就在转场中途开始</c>

00:35:19.253 --> 00:35:21.588 align:middle
<c.magenta>当我们松开手</c>
<c.magenta>动画会继续</c>

00:35:21.655 --> 00:35:22.656 align:middle
<c.magenta>然后可以再次中断</c>

00:35:22.723 --> 00:35:25.893 align:middle
<c.magenta>这样我们可以自由来回</c>
<c.magenta>往返于动画进程</c>

00:35:25.993 --> 00:35:28.061 align:middle
<c.magenta>和交互进程之间</c>

00:35:28.295 --> 00:35:29.329 align:middle
<c.magenta>这真的很炫</c>

00:35:30.964 --> 00:35:33.634 align:middle
<c.magenta>在返回代码</c>
<c.magenta>告诉你我们如何做到之前</c>

00:35:33.700 --> 00:35:35.002 align:middle
<c.magenta>通过用新视图控制器接口</c>

00:35:35.502 --> 00:35:38.305 align:middle
<c.magenta>我想用具体的场景来帮助大家</c>

00:35:38.372 --> 00:35:40.107 align:middle
<c.magenta>理解这些代码是做什么的</c>

00:35:40.407 --> 00:35:41.808 align:middle
<c.magenta>假设我们正在开始</c>

00:35:41.875 --> 00:35:43.944 align:middle
<c.magenta>用panGestureRecognizer</c>
<c.magenta>向下拉动视图</c>

00:35:44.011 --> 00:35:45.712 align:middle
<c.magenta>从而开始一个交互式转场</c>

00:35:46.346 --> 00:35:48.081 align:middle
<c.magenta>然后我们从屏幕上拿起手指</c>

00:35:48.148 --> 00:35:50.584 align:middle
<c.magenta>开始动画进程</c>
<c.magenta>在动画播放时</c>

00:35:50.684 --> 00:35:53.820 align:middle
<c.magenta>我们在中途暂停</c>
<c.magenta>然后再次回到动画</c>

00:35:53.887 --> 00:35:56.256 align:middle
<c.magenta>然后取消转场</c>
<c.magenta>直接向上拉回</c>

00:35:56.823 --> 00:35:58.926 align:middle
<c.magenta>这就是我要描述的场景</c>

00:35:58.992 --> 00:36:00.360 align:middle
<c.magenta>对照下面这段代码</c>

00:35:58.992 --> 00:36:00.360 align:middle
<c.magenta>对照下面这段代码</c>

00:36:04.731 --> 00:36:08.468 align:middle
<c.magenta>我将这个示例应用分成了四个方法</c>

00:36:09.036 --> 00:36:12.039 align:middle
<c.magenta>updateInteraction</c>
<c.magenta>是手势识别处理</c>

00:36:12.105 --> 00:36:14.808 align:middle
<c.magenta>用来更新交互转场</c>

00:36:15.108 --> 00:36:16.310 align:middle
<c.magenta>当抬起手指</c>

00:36:16.376 --> 00:36:18.278 align:middle
<c.magenta>调出endInteraction函数</c>

00:36:18.979 --> 00:36:21.014 align:middle
<c.magenta>然后调出动画函数添加动画</c>

00:36:21.081 --> 00:36:22.583 align:middle
<c.magenta>在开始或者结束位置</c>

00:36:23.250 --> 00:36:25.152 align:middle
<c.magenta>然后当我们中断动画</c>

00:36:25.219 --> 00:36:26.887 align:middle
<c.magenta>最后调出pauseAnimation</c>

00:36:26.954 --> 00:36:31.491 align:middle
<c.magenta>这个可以在转场时长中</c>
<c.magenta>多次循环</c>

00:36:31.558 --> 00:36:33.060 align:middle
<c.magenta>想做多少次都可以</c>

00:36:33.160 --> 00:36:35.128 align:middle
<c.magenta>这里我们只做了两次</c>

00:36:36.063 --> 00:36:37.965 align:middle
<c.magenta>然后是</c>
<c.magenta>updateInteraction</c>

00:36:38.031 --> 00:36:39.766 align:middle
<c.magenta>这是手势识别处理</c>

00:36:39.967 --> 00:36:43.370 align:middle
<c.magenta>当它调出</c>
<c.magenta>“状态开始”或者“状态改变”时</c>

00:36:43.437 --> 00:36:45.873 align:middle
<c.magenta>我们会看到手势识别的翻译</c>

00:36:45.939 --> 00:36:48.976 align:middle
<c.magenta>我们就会用这个去计算</c>
<c.magenta>要添加的进程步骤</c>

00:36:49.042 --> 00:36:51.411 align:middle
<c.magenta>把他们作为fractionComplete</c>
<c.magenta>添加到转场动画</c>

00:36:52.412 --> 00:36:54.681 align:middle
<c.magenta>之后要在背景中</c>
<c.magenta>擦除这些动画</c>

00:36:54.748 --> 00:36:57.985 align:middle
<c.magenta>就像chrome导航条的</c>
<c.magenta>背景视觉效果</c>

00:36:58.051 --> 00:36:59.019 align:middle
<c.magenta>这个很简单</c>

00:36:59.086 --> 00:37:01.255 align:middle
<c.magenta>就跟在转场动画里</c>
<c.magenta>设定fractionComplete一样</c>

00:36:59.086 --> 00:37:01.255 align:middle
<c.magenta>就跟在转场动画里</c>
<c.magenta>设定fractionComplete一样</c>

00:37:01.321 --> 00:37:04.825 align:middle
<c.magenta>这就可以基本免费</c>
<c.magenta>擦除所有动画</c>

00:37:05.526 --> 00:37:07.227 align:middle
<c.magenta>再调出transitionContext</c>

00:37:07.294 --> 00:37:09.530 align:middle
<c.magenta>来更新交互转场percentComplete</c>

00:37:10.330 --> 00:37:12.766 align:middle
<c.magenta>最后我们的图片</c>
<c.magenta>就可以在屏幕上移动了</c>

00:37:12.933 --> 00:37:15.002 align:middle
<c.magenta>当处于转场的</c>
<c.magenta>交互进程时</c>

00:37:15.068 --> 00:37:17.104 align:middle
<c.magenta>我们要手动设定边框</c>

00:37:17.171 --> 00:37:18.906 align:middle
<c.magenta>因此我们要做一个小的辅助函数</c>

00:37:20.174 --> 00:37:23.310 align:middle
<c.magenta>最后我们重新设定</c>
<c.magenta>这个手势识别的翻译</c>

00:37:23.744 --> 00:37:26.580 align:middle
<c.magenta>当我们收到指令时</c>
<c.magenta>手指离开屏幕</c>

00:37:26.647 --> 00:37:30.484 align:middle
<c.magenta>手势识别会出现“状态结束”</c>
<c.magenta>然后调出endInteraction</c>

00:37:31.118 --> 00:37:32.819 align:middle
<c.magenta>研究endInteraction时</c>

00:37:32.886 --> 00:37:35.722 align:middle
<c.magenta>第一只看我们的转场context</c>
<c.magenta>是否是交互的</c>

00:37:35.789 --> 00:37:38.959 align:middle
<c.magenta>我们要保证它是在我们</c>
<c.magenta>离开交互进程之前完成</c>

00:37:39.593 --> 00:37:41.028 align:middle
<c.magenta>然后调出小辅助函数</c>

00:37:41.094 --> 00:37:42.829 align:middle
<c.magenta>它告诉我们</c>
<c.magenta>这个完成是在</c>

00:37:42.896 --> 00:37:45.599 align:middle
<c.magenta>动画的开始位置</c>
<c.magenta>或者结束位置</c>

00:37:46.066 --> 00:37:47.634 align:middle
<c.magenta>如果在结束位置完成</c>

00:37:47.701 --> 00:37:49.236 align:middle
<c.magenta>调出context以表明</c>

00:37:49.303 --> 00:37:51.505 align:middle
<c.magenta>“嘿 交互转场在这里结束</c>

00:37:51.772 --> 00:37:53.240 align:middle
<c.magenta>我们要进入动画进程了”</c>

00:37:53.807 --> 00:37:55.709 align:middle
<c.magenta>如果在开始位置完成</c>

00:37:55.776 --> 00:37:57.711 align:middle
<c.magenta>意思就是我们取消了这个交互进程</c>

00:37:57.778 --> 00:37:59.346 align:middle
<c.magenta>将要进入动画进程</c>

00:37:59.646 --> 00:38:00.581 align:middle
<c.magenta>然后只要做动画就好</c>

00:37:59.646 --> 00:38:00.581 align:middle
<c.magenta>然后只要做动画就好</c>

00:38:00.914 --> 00:38:02.749 align:middle
<c.magenta>现在来看动画方法</c>

00:38:04.351 --> 00:38:07.521 align:middle
<c.magenta>之前我告诉你们</c>
<c.magenta>转场动画转换的是</c>

00:38:07.588 --> 00:38:10.791 align:middle
<c.magenta>背景chrome和alpha通道</c>

00:38:11.291 --> 00:38:13.594 align:middle
<c.magenta>但这里我们要创建一个</c>
<c.magenta>二级propertyAnimator</c>

00:38:13.660 --> 00:38:15.696 align:middle
<c.magenta>我们要使用它来绘制边框动画</c>

00:38:15.762 --> 00:38:17.531 align:middle
<c.magenta>让图片可以在屏幕上移动</c>

00:38:17.598 --> 00:38:20.300 align:middle
<c.magenta>我们之所以这么做</c>
<c.magenta>是希望有些动画</c>

00:38:20.367 --> 00:38:23.804 align:middle
<c.magenta>能有不一样的时间函数</c>
<c.magenta>相较于背景动画而言</c>

00:38:23.937 --> 00:38:25.405 align:middle
<c.magenta>一会儿就来讲看这个</c>

00:38:25.472 --> 00:38:27.474 align:middle
<c.magenta>这里我们要做的只是插入动画</c>

00:38:27.875 --> 00:38:30.043 align:middle
<c.magenta>具体定义结束位置</c>

00:38:30.110 --> 00:38:33.046 align:middle
<c.magenta>或者只是定义目标</c>
<c.magenta>或者是图片的初始边框</c>

00:38:33.380 --> 00:38:35.182 align:middle
<c.magenta>随后开始这个属性动画</c>

00:38:35.249 --> 00:38:36.250 align:middle
<c.magenta>并实时记录</c>

00:38:36.817 --> 00:38:38.919 align:middle
<c.magenta>要记住我们还有一个转场动画</c>

00:38:38.986 --> 00:38:42.756 align:middle
<c.magenta>时长与我们之前返回系统的</c>
<c.magenta>转场时长一样</c>

00:38:43.423 --> 00:38:46.393 align:middle
<c.magenta>我们只要确保</c>
<c.magenta>这个动画的方向是正确的</c>

00:38:46.460 --> 00:38:48.795 align:middle
<c.magenta>如果我们定义一个toPosition值为“开始”</c>

00:38:48.862 --> 00:38:50.597 align:middle
<c.magenta>我们需要推翻该animator</c>

00:38:51.398 --> 00:38:55.736 align:middle
<c.magenta>最后 如果这是第一次</c>
<c.magenta>联通这个动画</c>

00:38:55.802 --> 00:38:58.539 align:middle
<c.magenta>转场动画就会处于</c>
<c.magenta>非活动状态</c>

00:38:58.739 --> 00:39:00.841 align:middle
<c.magenta>所以我们要做的就是</c>
<c.magenta>开始这个转场动画</c>

00:38:58.739 --> 00:39:00.841 align:middle
<c.magenta>所以我们要做的就是</c>
<c.magenta>开始这个转场动画</c>

00:39:00.908 --> 00:39:02.509 align:middle
<c.magenta>然后就进入动画进程</c>

00:39:03.577 --> 00:39:06.647 align:middle
<c.magenta>另外 如果程序开始后</c>
<c.magenta>又暂停了</c>

00:39:06.947 --> 00:39:08.148 align:middle
<c.magenta>我们要用不一样的东西</c>

00:39:08.582 --> 00:39:10.350 align:middle
<c.magenta>调出continueAnimation</c>

00:39:11.018 --> 00:39:13.587 align:middle
<c.magenta>withTimingParameters和durationFactor</c>

00:39:13.654 --> 00:39:17.157 align:middle
<c.magenta>continueAnimation</c>
<c.magenta>让你可以暂停一个动画</c>

00:39:17.224 --> 00:39:19.793 align:middle
<c.magenta>根据不同时间参数</c>
<c.magenta>和不同的时长</c>

00:39:19.860 --> 00:39:21.295 align:middle
<c.magenta>和剩余时长</c>
<c.magenta>随你喜好</c>

00:39:21.628 --> 00:39:22.829 align:middle
<c.magenta>这里要传递“nil”</c>

00:39:22.896 --> 00:39:25.098 align:middle
<c.magenta>表示我们要用的时间参数</c>

00:39:25.165 --> 00:39:27.768 align:middle
<c.magenta>是在初始化这个转场动画时</c>
<c.magenta>就已经输入过的</c>

00:39:28.068 --> 00:39:32.139 align:middle
<c.magenta>但是我们需要改变</c>
<c.magenta>后续动画的durationFactor</c>

00:39:32.206 --> 00:39:34.541 align:middle
<c.magenta>这使得我们能使时长同步</c>

00:39:34.608 --> 00:39:37.010 align:middle
<c.magenta>让新创建的itemFrameAnimator时长</c>

00:39:37.077 --> 00:39:39.880 align:middle
<c.magenta>与这个转场动画的剩余时长一致</c>

00:39:40.180 --> 00:39:42.082 align:middle
<c.magenta>durationFactor</c>
<c.magenta>从而定义为</c>

00:39:42.149 --> 00:39:46.186 align:middle
<c.magenta>1.0等同于之前设定的初始时长</c>

00:39:46.253 --> 00:39:47.955 align:middle
<c.magenta>在创建转场动画时</c>

00:39:48.589 --> 00:39:51.325 align:middle
<c.magenta>这就是开始动画进程</c>
<c.magenta>要做的所有事情</c>

00:39:51.391 --> 00:39:52.593 align:middle
<c.magenta>循环的最后一步</c>

00:39:52.659 --> 00:39:54.795 align:middle
<c.magenta>看一下pauseAnimation</c>

00:39:54.928 --> 00:39:58.465 align:middle
<c.magenta>这发生在动画进程中</c>
<c.magenta>但是暂停了</c>

00:39:58.532 --> 00:40:00.200 align:middle
<c.magenta>把手指放在图片视图下方</c>

00:39:58.532 --> 00:40:00.200 align:middle
<c.magenta>把手指放在图片视图下方</c>

00:40:00.267 --> 00:40:03.670 align:middle
<c.magenta>然后只要设置一个手势识别</c>
<c.magenta>在这个示例应用中的图片视图</c>

00:40:03.904 --> 00:40:05.239 align:middle
<c.magenta>现在这都是免费的了</c>

00:40:05.305 --> 00:40:09.009 align:middle
<c.magenta>因为UIViewPropertyAnimator会</c>
<c.magenta>自动点击测试动画视图</c>

00:40:09.910 --> 00:40:12.579 align:middle
<c.magenta>在刚刚创建的itemFrameAnimator里</c>

00:40:12.646 --> 00:40:15.849 align:middle
<c.magenta>我们要完全停止这个动画</c>
<c.magenta>就要设参数值为“真”</c>

00:40:15.916 --> 00:40:20.521 align:middle
<c.magenta>告诉系统我们不想</c>
<c.magenta>再继续此动画</c>

00:40:20.587 --> 00:40:22.823 align:middle
<c.magenta>而且我们要直接写模态值</c>

00:40:24.157 --> 00:40:27.127 align:middle
<c.magenta>应该是显示值直接返回模式</c>

00:40:27.628 --> 00:40:31.164 align:middle
<c.magenta>之后回到转场动画</c>
<c.magenta>调出pauseAnimation</c>

00:40:31.231 --> 00:40:34.501 align:middle
<c.magenta>就像updateInteraction里</c>
<c.magenta>看到的一样 我们会擦除动画</c>

00:40:34.568 --> 00:40:36.036 align:middle
<c.magenta>在我们与图片互动的时候</c>

00:40:36.336 --> 00:40:38.672 align:middle
<c.magenta>最后我们会告诉</c>
<c.magenta>转场context</c>

00:40:38.739 --> 00:40:43.510 align:middle
<c.magenta>我们要离开动画进程</c>
<c.magenta>回到交互进程</c>

00:40:44.578 --> 00:40:46.880 align:middle
<c.magenta>我再给大家展示另一个</c>
<c.magenta>技能和诀窍</c>

00:40:47.748 --> 00:40:49.483 align:middle
<c.magenta>也是这个演示应用的一个小细节</c>

00:40:51.652 --> 00:40:56.156 align:middle
<c.magenta>我们看到现在这个时间很慢</c>
<c.magenta>这是出于展示的目的</c>

00:40:57.057 --> 00:40:59.426 align:middle
<c.magenta>但你可能想要</c>
<c.magenta>更自然的感觉</c>

00:40:59.493 --> 00:41:01.161 align:middle
<c.magenta>再更生动一点</c>

00:40:59.493 --> 00:41:01.161 align:middle
<c.magenta>再更生动一点</c>

00:41:01.795 --> 00:41:04.698 align:middle
<c.magenta>所以如果我们要</c>
<c.magenta>更改弹跳的时间</c>

00:41:04.798 --> 00:41:06.366 align:middle
<c.magenta>让它跳出页面</c>

00:41:06.667 --> 00:41:09.570 align:middle
<c.magenta>而且只让图片跳出页面</c>

00:41:09.636 --> 00:41:11.538 align:middle
<c.magenta>而这些背景动画还是继续</c>

00:41:11.605 --> 00:41:13.941 align:middle
<c.magenta>按照我们定义的</c>
<c.magenta>easeOut曲线运行</c>

00:41:14.608 --> 00:41:16.577 align:middle
<c.magenta>其实我们可以实现这个变化</c>

00:41:16.643 --> 00:41:19.813 align:middle
<c.magenta>让视觉更加生动</c>
<c.magenta>只用一行代码就可以</c>

00:41:19.880 --> 00:41:21.448 align:middle
<c.magenta>而且在非中断时</c>
<c.magenta>还可以继续互动</c>

00:41:21.515 --> 00:41:23.217 align:middle
<c.magenta>那么快速看一下这行代码</c>

00:41:27.487 --> 00:41:28.856 align:middle
<c.magenta>回到演示应用</c>

00:41:28.922 --> 00:41:31.592 align:middle
<c.magenta>看看propertyAnimator的方便方法</c>

00:41:31.959 --> 00:41:34.528 align:middle
<c.magenta>注意我们正在定义</c>
<c.magenta>一个属性动画</c>

00:41:34.595 --> 00:41:36.630 align:middle
<c.magenta>其时间参数在这里为线性</c>

00:41:36.964 --> 00:41:39.066 align:middle
<c.magenta>这也就是为什么感觉</c>
<c.magenta>动画很机械</c>

00:41:39.533 --> 00:41:41.401 align:middle
<c.magenta>我的一个同事留下了这个</c>
<c.magenta>伟大的注释</c>

00:41:41.468 --> 00:41:44.104 align:middle
<c.magenta>来定义某些SpringTimingParameters</c>

00:41:44.171 --> 00:41:48.675 align:middle
<c.magenta>并使用大规模数据 强度</c>
<c.magenta>阻尼和初始速率</c>

00:41:48.742 --> 00:41:50.677 align:middle
<c.magenta>这样就完整的定义了这个弹跳</c>

00:41:51.178 --> 00:41:53.614 align:middle
<c.magenta>当在创建</c>
<c.magenta>propertyAnimator</c>

00:41:53.680 --> 00:41:56.483 align:middle
<c.magenta>我们正在传递的时长</c>
<c.magenta>其实并不使用</c>

00:41:56.750 --> 00:41:58.619 align:middle
<c.magenta>而是会被计算</c>

00:41:58.685 --> 00:42:00.821 align:middle
<c.magenta>根据我们在弹跳时间中</c>
<c.magenta>所提供的属性</c>

00:41:58.685 --> 00:42:00.821 align:middle
<c.magenta>根据我们在弹跳时间中</c>
<c.magenta>所提供的属性</c>

00:42:01.421 --> 00:42:05.425 align:middle
<c.magenta>因此我们需要有一个</c>
<c.magenta>动画时长辅助函数</c>

00:42:05.492 --> 00:42:08.161 align:middle
<c.magenta>它只用propertyAnimator应用程序接口</c>

00:42:08.228 --> 00:42:11.598 align:middle
<c.magenta>就是下面这个</c>
<c.magenta>来计算时长</c>

00:42:11.665 --> 00:42:13.934 align:middle
<c.magenta>基本上它就为我们</c>
<c.magenta>解开了这个弹跳方程</c>

00:42:14.001 --> 00:42:17.371 align:middle
<c.magenta>我们可以用这个去匹配</c>
<c.magenta>转场动画的其他时长</c>

00:42:18.372 --> 00:42:19.873 align:middle
<c.magenta>这都超级简单</c>

00:42:19.940 --> 00:42:23.310 align:middle
<c.magenta>这个代码看上去</c>
<c.magenta>是有点复杂</c>

00:42:23.377 --> 00:42:25.112 align:middle
<c.magenta>但也确实只要</c>
<c.magenta>几百行而已</c>

00:42:25.312 --> 00:42:28.115 align:middle
<c.magenta>UIViewPropertyAnimator</c>
<c.magenta>使一切成为可能</c>

00:42:28.415 --> 00:42:31.218 align:middle
<c.magenta>就这样</c>
<c.magenta>让我们请回布鲁斯</c>

00:42:36.056 --> 00:42:36.924 align:middle
<c.magenta>谢谢你 Mike</c>

00:42:39.092 --> 00:42:39.960 align:middle
<c.magenta>好的</c>

00:42:40.661 --> 00:42:43.197 align:middle
<c.magenta>我得讲快点了</c>
<c.magenta>时间所剩无几</c>

00:42:44.932 --> 00:42:47.034 align:middle
<c.magenta>我们要来讲一点</c>
<c.magenta>点击测试</c>

00:42:48.836 --> 00:42:52.840 align:middle
<c.magenta>假定UserInteractionEnabled</c>
<c.magenta>值为真</c>

00:42:52.906 --> 00:42:55.475 align:middle
<c.magenta>我们实际上就可以</c>
<c.magenta>点击测试我们的视图</c>

00:42:55.542 --> 00:42:58.212 align:middle
<c.magenta>如果值为“假”</c>
<c.magenta>我们将吃掉所有触摸事件</c>

00:42:58.745 --> 00:43:01.815 align:middle
<c.magenta>我们将这个属性叫做</c>
<c.magenta>isManualHitTestingEnabled</c>

00:42:58.745 --> 00:43:01.815 align:middle
<c.magenta>我们将这个属性叫做</c>
<c.magenta>isManualHitTestingEnabled</c>

00:43:01.882 --> 00:43:03.217 align:middle
<c.magenta>并定义为“假”</c>

00:43:03.650 --> 00:43:05.185 align:middle
<c.magenta>默认值为“假”的原因是</c>

00:43:05.252 --> 00:43:08.922 align:middle
<c.magenta>我们想能够</c>
<c.magenta>点击测试我们的视图</c>

00:43:09.189 --> 00:43:12.292 align:middle
<c.magenta>如果值为“真”</c>
<c.magenta>也就是现在的系统活动</c>

00:43:12.459 --> 00:43:15.596 align:middle
<c.magenta>当你要触摸</c>
<c.magenta>这个视图下面的位置</c>

00:43:15.662 --> 00:43:17.297 align:middle
<c.magenta>就会发现我们无法点击测试</c>

00:43:17.798 --> 00:43:21.802 align:middle
<c.magenta>令人迷惑的是</c>
<c.magenta>好像只在它运动方向上开始点击测试</c>

00:43:22.069 --> 00:43:25.839 align:middle
<c.magenta>我们不想要这样的结果</c>
<c.magenta>尤其是对可中断的属性动画</c>

00:43:26.106 --> 00:43:29.142 align:middle
<c.magenta>在这个演讲下方</c>
<c.magenta>我想你们推荐</c>

00:43:29.510 --> 00:43:32.746 align:middle
<c.magenta>一个技能</c>
<c.magenta>让你们可以重写点击测试</c>

00:43:32.813 --> 00:43:35.749 align:middle
<c.magenta>做一些计算来绕过</c>
<c.magenta>显示层面</c>

00:43:35.816 --> 00:43:39.286 align:middle
<c.magenta>调令“super”</c>
<c.magenta>来点击测试一个移动视图</c>

00:43:40.320 --> 00:43:41.822 align:middle
<c.magenta>这个技术依然生效</c>

00:43:41.889 --> 00:43:45.225 align:middle
<c.magenta>但是现在有了propertyAnimators</c>
<c.magenta>如果你有移动视图</c>

00:43:45.292 --> 00:43:48.095 align:middle
<c.magenta>默认的手动</c>
<c.magenta>点击测试值为假</c>

00:43:48.161 --> 00:43:50.898 align:middle
<c.magenta>我们实际上就在</c>
<c.magenta>点击测试这个视图</c>

00:43:51.498 --> 00:43:53.667 align:middle
<c.magenta>所以这很酷炫</c>
<c.magenta>也很轻松</c>

00:43:53.734 --> 00:43:56.904 align:middle
<c.magenta>事实上 这个舞台上</c>
<c.magenta>我们看到的所有东西</c>

00:43:56.970 --> 00:43:58.238 align:middle
<c.magenta>之前都是好用的</c>

00:43:58.805 --> 00:44:00.307 align:middle
<c.magenta>现在出了些问题</c>

00:43:58.805 --> 00:44:00.307 align:middle
<c.magenta>现在出了些问题</c>

00:44:00.374 --> 00:44:02.509 align:middle
<c.magenta>如果你有深层的视图层</c>
<c.magenta>或者其他</c>

00:44:02.576 --> 00:44:04.244 align:middle
<c.magenta>我们就无法正确运行</c>

00:44:04.578 --> 00:44:08.949 align:middle
<c.magenta>这时你可能就要用其他技术</c>
<c.magenta>可能在其他演讲中有提过</c>

00:44:10.250 --> 00:44:11.084 align:middle
<c.magenta>好的</c>

00:44:11.151 --> 00:44:14.321 align:middle
<c.magenta>我们今天讲了关键帧动画</c>
<c.magenta>所用的整个应用程序接口</c>

00:44:14.388 --> 00:44:16.590 align:middle
<c.magenta>这是UIKit现在所有的接口</c>

00:44:16.790 --> 00:44:18.592 align:middle
<c.magenta>如果让它可中断？</c>

00:44:18.825 --> 00:44:20.727 align:middle
<c.magenta>要重调</c>
<c.magenta>关键帧动画</c>

00:44:20.794 --> 00:44:24.565 align:middle
<c.magenta>作为一个常用动画</c>
<c.magenta>除非你定义一个路径</c>

00:44:24.631 --> 00:44:27.201 align:middle
<c.magenta>来导入你想要的动画</c>

00:44:29.236 --> 00:44:31.471 align:middle
<c.magenta>我们也想让他们</c>
<c.magenta>变成可中断的</c>

00:44:32.439 --> 00:44:36.343 align:middle
<c.magenta>事实上我们想要做的</c>
<c.magenta>跟现在视频上看到的是一样的</c>

00:44:36.410 --> 00:44:37.845 align:middle
<c.magenta>我们要暂停它 擦除它</c>

00:44:38.245 --> 00:44:40.380 align:middle
<c.magenta>这应该都是意料之中</c>

00:44:40.447 --> 00:44:41.982 align:middle
<c.magenta>而且 你可以做到</c>

00:44:42.182 --> 00:44:43.383 align:middle
<c.magenta>这很简单</c>

00:44:43.450 --> 00:44:45.252 align:middle
<c.magenta>使用现有的接口</c>

00:44:45.319 --> 00:44:50.190 align:middle
<c.magenta>封装动画控制器的动画</c>

00:44:50.457 --> 00:44:54.194 align:middle
<c.magenta>从而你的关键帧动画</c>
<c.magenta>也是可中断的了</c>

00:44:58.732 --> 00:45:00.734 align:middle
<c.magenta>我再说最后一点</c>
<c.magenta>虽然听上去是在撒谎</c>

00:44:58.732 --> 00:45:00.734 align:middle
<c.magenta>我再说最后一点</c>
<c.magenta>虽然听上去是在撒谎</c>

00:45:01.268 --> 00:45:03.337 align:middle
<c.magenta>互动PopGestureRecognizers</c>

00:45:03.403 --> 00:45:05.906 align:middle
<c.magenta>这是内置的导航弹出视图</c>

00:45:06.340 --> 00:45:08.876 align:middle
<c.magenta>现在如果你有</c>
<c.magenta>一个交互控制器</c>

00:45:09.443 --> 00:45:10.777 align:middle
<c.magenta>你就无法使用这个</c>

00:45:11.445 --> 00:45:14.948 align:middle
<c.magenta>但是新的iOS 10里</c>
<c.magenta>如果你输入一个错误请求</c>

00:45:15.048 --> 00:45:17.951 align:middle
<c.magenta>给手势识别或者你自己</c>

00:45:18.318 --> 00:45:22.322 align:middle
<c.magenta>那么内置的弹出</c>
<c.magenta>手势识别就可以识别了</c>

00:45:22.389 --> 00:45:28.462 align:middle
<c.magenta>使用内置导航转场</c>
<c.magenta>要与你自定义的互动一起</c>

00:45:30.964 --> 00:45:32.199 align:middle
<c.magenta>总的来说</c>

00:45:33.300 --> 00:45:37.471 align:middle
<c.magenta>我们学习了如何使用UIViewPropertyAnimator</c>
<c.magenta>创建可中断动画</c>

00:45:38.372 --> 00:45:42.075 align:middle
<c.magenta>你可以用到很多全新的</c>
<c.magenta>时间函数</c>

00:45:42.843 --> 00:45:45.746 align:middle
<c.magenta>你可以使用可中断的</c>
<c.magenta>propertyAnimators</c>

00:45:45.812 --> 00:45:48.882 align:middle
<c.magenta>去创建可中断的</c>
<c.magenta>视图控制器转场</c>

00:45:49.750 --> 00:45:52.319 align:middle
<c.magenta>更多信息请浏览这个网址</c>

00:45:52.753 --> 00:45:54.588 align:middle
<c.magenta>这里有其他有关UIKit的演讲</c>

00:45:54.655 --> 00:45:57.858 align:middle
<c.magenta>他们讲的是动画的其他种类</c>
<c.magenta>其中两个就在明天</c>

00:45:57.925 --> 00:45:59.359 align:middle
<c.magenta>我希望你们听一听 看一看</c>

00:45:59.860 --> 00:46:00.827 align:middle
<c.magenta>谢谢</c>
