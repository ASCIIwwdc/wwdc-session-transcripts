WEBVTT

00:00:19.453 --> 00:00:24.491 align:middle
<c.magenta>SWIFT API设计准则</c>
<c.magenta>GRAND RENAMING</c>

00:00:30.330 --> 00:00:31.298 align:middle
<c.magenta>谢谢</c>

00:00:32.999 --> 00:00:34.935 align:middle
<c.magenta>欢迎 我是Doug Gregor</c>

00:00:35.035 --> 00:00:37.471 align:middle
<c.magenta>在这里 我要跟同事</c>
<c.magenta>Michael Ilseman</c>

00:00:37.571 --> 00:00:38.672 align:middle
<c.magenta>谈论关于设计的问题</c>

00:00:39.406 --> 00:00:42.442 align:middle
<c.magenta>因为好的设计能提高效率</c>

00:00:42.910 --> 00:00:46.813 align:middle
<c.magenta>而好的API设计</c>
<c.magenta>能帮助我们使用Swift语言</c>

00:00:46.980 --> 00:00:49.149 align:middle
<c.magenta>写出</c>
<c.magenta>清晰 简练 优美的代码</c>

00:00:49.583 --> 00:00:52.419 align:middle
<c.magenta>这一点完全正确</c>
<c.magenta>无论是当你在为上百万</c>

00:00:52.486 --> 00:00:54.321 align:middle
<c.magenta>其他开发者编写API时</c>

00:00:54.388 --> 00:00:57.057 align:middle
<c.magenta>还是你在自己的应用里</c>
<c.magenta>为自己写代码时</c>

00:00:57.524 --> 00:00:59.459 align:middle
<c.magenta>因为好的设计</c>
<c.magenta>真的很重要</c>

00:01:00.527 --> 00:01:01.361 align:middle
<c.magenta>所以...</c>

00:01:02.629 --> 00:01:05.566 align:middle
<c.magenta>今天我们将介绍</c>
<c.magenta>Swift API设计准则</c>

00:01:05.632 --> 00:01:08.468 align:middle
<c.magenta>这些是我们要介绍的</c>
<c.magenta>Swift 3的新准则</c>

00:01:09.269 --> 00:01:11.872 align:middle
<c.magenta>我们将介绍这些准则</c>
<c.magenta>背后的原则</c>

00:01:11.939 --> 00:01:13.874 align:middle
<c.magenta>对其中一些准则进行讨论</c>
<c.magenta>从而了解</c>

00:01:13.941 --> 00:01:16.743 align:middle
<c.magenta>如何构建优质的Swift API</c>

00:01:18.345 --> 00:01:22.649 align:middle
<c.magenta>然后 我们会讨论下</c>
<c.magenta>Grand Renaming</c>

00:01:23.217 --> 00:01:26.053 align:middle
<c.magenta>我们将用这个名词</c>
<c.magenta>来指代这些准则</c>

00:01:26.119 --> 00:01:28.922 align:middle
<c.magenta>在你日常所有API中的应用</c>

00:01:29.223 --> 00:01:30.557 align:middle
<c.magenta>包括Swift标准库</c>

00:01:30.624 --> 00:01:32.693 align:middle
<c.magenta>Cocoa和Cocoa Touch API</c>

00:01:32.893 --> 00:01:36.330 align:middle
<c.magenta>现在 这个Grand Renaming</c>
<c.magenta>将影响你的很多代码</c>

00:01:37.798 --> 00:01:39.600 align:middle
<c.magenta>基本上使用Swift 2语言的</c>
<c.magenta>所有代码</c>

00:01:39.666 --> 00:01:41.902 align:middle
<c.magenta>在Swift 3中都将</c>
<c.magenta>有一定程度的改变</c>

00:01:42.436 --> 00:01:44.004 align:middle
<c.magenta>所以...没错！</c>

00:01:46.740 --> 00:01:48.876 align:middle
<c.magenta>所以 我们将讨论下</c>
<c.magenta>这对你的代码意味着什么</c>

00:01:49.776 --> 00:01:53.347 align:middle
<c.magenta>以及如何应对</c>
<c.magenta>开始适应Swift 3的思维</c>

00:01:54.715 --> 00:01:58.085 align:middle
<c.magenta>最后 我们将讨论下</c>
<c.magenta>我们的一些新工具和技巧</c>

00:01:58.418 --> 00:02:01.121 align:middle
<c.magenta>以便将</c>
<c.magenta>C和Objective-C API</c>

00:01:58.418 --> 00:02:01.121 align:middle
<c.magenta>以便将</c>
<c.magenta>C和Objective-C API</c>

00:02:01.188 --> 00:02:03.690 align:middle
<c.magenta>映射到优美的Swift API</c>

00:02:05.425 --> 00:02:07.728 align:middle
<c.magenta>这可涉及大量的</c>
<c.magenta>概念和原因解释啊</c>

00:02:08.127 --> 00:02:11.632 align:middle
<c.magenta>你关于准则的</c>
<c.magenta>最大疑问可能是:</c>

00:02:12.332 --> 00:02:13.166 align:middle
<c.magenta>为什么？</c>

00:02:14.635 --> 00:02:16.703 align:middle
<c.magenta>为什么在使用Swift两年后</c>

00:02:16.770 --> 00:02:19.840 align:middle
<c.magenta>我们要改变你日常工作</c>
<c.magenta>接触的所有API</c>

00:02:21.008 --> 00:02:24.111 align:middle
<c.magenta>答案可以归结为语言的特点</c>

00:02:24.178 --> 00:02:27.848 align:middle
<c.magenta>因为每种编程语言</c>
<c.magenta>都有自己鲜明的特点</c>

00:02:28.215 --> 00:02:30.150 align:middle
<c.magenta>都有自己的句法风格</c>

00:02:31.251 --> 00:02:33.387 align:middle
<c.magenta>但这又不光是句法</c>

00:02:33.453 --> 00:02:35.355 align:middle
<c.magenta>也是一种语言选择做出的</c>

00:02:35.422 --> 00:02:37.191 align:middle
<c.magenta>一种折衷</c>

00:02:37.291 --> 00:02:40.260 align:middle
<c.magenta>它是倾向于安全</c>
<c.magenta>还是性能？</c>

00:02:41.028 --> 00:02:43.564 align:middle
<c.magenta>你是更喜欢数学的精炼性</c>

00:02:43.630 --> 00:02:46.967 align:middle
<c.magenta>还是更喜欢</c>
<c.magenta>清晰易读的东西？</c>

00:02:47.835 --> 00:02:51.605 align:middle
<c.magenta>你看一下Swift代码</c>
<c.magenta>就能马上读懂代码</c>

00:02:53.640 --> 00:02:56.910 align:middle
<c.magenta>这里 你能够看到Swift</c>
<c.magenta>呈现出关于特定事物的观点</c>

00:02:57.077 --> 00:02:58.879 align:middle
<c.magenta>它使用结尾闭包</c>

00:02:58.946 --> 00:03:02.683 align:middle
<c.magenta>所以控制流能很好地</c>
<c.magenta>用于库和API</c>

00:02:58.946 --> 00:03:02.683 align:middle
<c.magenta>所以控制流能很好地</c>
<c.magenta>用于库和API</c>

00:03:03.217 --> 00:03:07.187 align:middle
<c.magenta>它有可能选项 所以</c>
<c.magenta>你必须时刻记住零值的可能性</c>

00:03:07.254 --> 00:03:10.524 align:middle
<c.magenta>而不能简单忽略</c>
<c.magenta>这种可能性的存在</c>

00:03:11.291 --> 00:03:15.095 align:middle
<c.magenta>这样 使用Swift语言时</c>
<c.magenta>你会有Swift的感觉</c>

00:03:15.729 --> 00:03:18.165 align:middle
<c.magenta>但这不光是语言引起的</c>

00:03:18.232 --> 00:03:21.301 align:middle
<c.magenta>而实际上是</c>
<c.magenta>你日夜使用的API引起的</c>

00:03:21.635 --> 00:03:25.239 align:middle
<c.magenta>而且API必须</c>
<c.magenta>与语言的特征融合</c>

00:03:25.506 --> 00:03:29.409 align:middle
<c.magenta>这样 你才能得到优美的</c>
<c.magenta>Swift代码带来的一致全面的体验</c>

00:03:31.211 --> 00:03:34.781 align:middle
<c.magenta>这里是一些</c>
<c.magenta>Cocoa和Cocoa Touch API</c>

00:03:35.616 --> 00:03:40.220 align:middle
<c.magenta>这些API的设计基于</c>
<c.magenta>针对Cocoa的编码准则</c>

00:03:41.255 --> 00:03:43.156 align:middle
<c.magenta>你可能之前读过这些准则</c>
<c.magenta>希望你读过</c>

00:03:43.590 --> 00:03:46.894 align:middle
<c.magenta>这些准则</c>
<c.magenta>提倡在API设计中</c>

00:03:47.361 --> 00:03:48.929 align:middle
<c.magenta>注重清晰度和一致性</c>

00:03:49.263 --> 00:03:53.267 align:middle
<c.magenta>而过去十多年</c>
<c.magenta>我们已将这些准则</c>

00:03:53.333 --> 00:03:54.868 align:middle
<c.magenta>应用到成千上万的API</c>

00:03:55.235 --> 00:03:57.704 align:middle
<c.magenta>用于开发Cocoa和</c>
<c.magenta>Cocoa Touch平台</c>

00:03:57.771 --> 00:03:59.239 align:middle
<c.magenta>以及我们使用的绝妙的API</c>

00:03:59.806 --> 00:04:02.109 align:middle
<c.magenta>现在 而这些准则针对</c>

00:03:59.806 --> 00:04:02.109 align:middle
<c.magenta>现在 而这些准则针对</c>

00:04:02.709 --> 00:04:05.646 align:middle
<c.magenta>具有不同特征的另一种语言</c>
<c.magenta>设计</c>

00:04:08.282 --> 00:04:11.285 align:middle
<c.magenta>所以 当你将</c>
<c.magenta>为Objective-C写的</c>

00:04:11.351 --> 00:04:15.422 align:middle
<c.magenta>所有API</c>
<c.magenta>毫不修改地放到Swift中</c>

00:04:16.290 --> 00:04:18.725 align:middle
<c.magenta>就会看起来个性不合</c>

00:04:18.791 --> 00:04:21.228 align:middle
<c.magenta>这些API不怎么Swifty</c>

00:04:22.429 --> 00:04:23.697 align:middle
<c.magenta>这又意味着什么呢？</c>

00:04:24.164 --> 00:04:25.465 align:middle
<c.magenta>不Swifty？</c>

00:04:26.133 --> 00:04:27.167 align:middle
<c.magenta>你听到很多人这么说</c>

00:04:27.901 --> 00:04:32.306 align:middle
<c.magenta>不过 本质上</c>
<c.magenta>这就是为什么在成千上万</c>

00:04:32.372 --> 00:04:36.076 align:middle
<c.magenta>开发者使用Swift平台</c>
<c.magenta>两年后</c>

00:04:36.343 --> 00:04:38.478 align:middle
<c.magenta>现在是进行重新评估的时候</c>

00:04:38.779 --> 00:04:41.515 align:middle
<c.magenta>因为我们拥有更广大的</c>
<c.magenta>开发者社区经验</c>

00:04:41.582 --> 00:04:44.518 align:middle
<c.magenta>可以了解在Swift代码中</c>
<c.magenta>什么是有效的</c>

00:04:45.352 --> 00:04:49.289 align:middle
<c.magenta>所以我们开始设计</c>
<c.magenta>API设计准则</c>

00:04:50.591 --> 00:04:53.660 align:middle
<c.magenta>尝试规定 怎样算是构建具有</c>
<c.magenta>Swift特征 即Swifty的API</c>

00:04:53.994 --> 00:04:57.130 align:middle
<c.magenta>以及帮助所有人</c>
<c.magenta>使用我们喜爱的语言</c>

00:04:57.197 --> 00:04:58.932 align:middle
<c.magenta>构建更加一致和清晰的API</c>

00:05:00.400 --> 00:05:03.971 align:middle
<c.magenta>现在</c>
<c.magenta>你在左下方能看到SE-0023</c>

00:05:04.071 --> 00:05:06.340 align:middle
<c.magenta>这是Swift的演变提案编号</c>

00:05:06.507 --> 00:05:09.543 align:middle
<c.magenta>其中包含所有的</c>
<c.magenta>API设计准则</c>

00:05:09.643 --> 00:05:12.145 align:middle
<c.magenta>在整个演讲过程</c>
<c.magenta>你将看到这些提案编号</c>

00:05:12.212 --> 00:05:14.014 align:middle
<c.magenta>此外 你可访问Swift.org</c>

00:05:14.081 --> 00:05:16.416 align:middle
<c.magenta>查找这个提案代码</c>
<c.magenta>了解关于Swift语言</c>

00:05:16.483 --> 00:05:20.053 align:middle
<c.magenta>这一特定变化的详细信息</c>

00:05:20.621 --> 00:05:23.524 align:middle
<c.magenta>不过现在</c>
<c.magenta>让我们讨论下准则本身</c>

00:05:24.992 --> 00:05:27.761 align:middle
<c.magenta>Swift API 设计准则的</c>
<c.magenta>主要原则是</c>

00:05:28.195 --> 00:05:31.031 align:middle
<c.magenta>在使用时清晰明了</c>

00:05:31.098 --> 00:05:34.401 align:middle
<c.magenta>就是你的API在他人代码中</c>
<c.magenta>显示时能够清晰明了</c>

00:05:36.236 --> 00:05:38.172 align:middle
<c.magenta>我们喜欢简练的代码</c>

00:05:38.572 --> 00:05:40.874 align:middle
<c.magenta>但清晰明了</c>
<c.magenta>是最重要的方面</c>

00:05:40.941 --> 00:05:43.310 align:middle
<c.magenta>这比写出简练的代码</c>
<c.magenta>要更重要</c>

00:05:44.444 --> 00:05:47.080 align:middle
<c.magenta>虽然如此 Swift中确实</c>
<c.magenta>也有简练的代码</c>

00:05:47.381 --> 00:05:49.316 align:middle
<c.magenta>Swift代码确实会</c>
<c.magenta>更简练</c>

00:05:49.383 --> 00:05:50.817 align:middle
<c.magenta>看到Swift语言时</c>
<c.magenta>我们能感到该简练性</c>

00:05:50.884 --> 00:05:53.420 align:middle
<c.magenta>而在讨论各种导入Swift</c>
<c.magenta>或使用Swift写的应用时</c>

00:05:53.487 --> 00:05:56.823 align:middle
<c.magenta>我们可以实际衡量</c>
<c.magenta>这种简练性</c>

00:05:57.758 --> 00:06:00.494 align:middle
<c.magenta>不过这要源于</c>
<c.magenta>使用正确的语境线索</c>

00:05:57.758 --> 00:06:00.494 align:middle
<c.magenta>不过这要源于</c>
<c.magenta>使用正确的语境线索</c>

00:06:00.994 --> 00:06:04.298 align:middle
<c.magenta>让我们更深入地了解下</c>
<c.magenta>这些准则并看一下一些API</c>

00:06:05.165 --> 00:06:07.668 align:middle
<c.magenta>现在 我们先讨论下使用</c>

00:06:09.336 --> 00:06:10.971 align:middle
<c.magenta>为什么要关注使用站点呢？</c>

00:06:11.238 --> 00:06:13.173 align:middle
<c.magenta>嗯 一方面</c>
<c.magenta>这不过是简单的数字游戏</c>

00:06:13.240 --> 00:06:15.042 align:middle
<c.magenta>你写你的API只要一次</c>

00:06:15.576 --> 00:06:17.678 align:middle
<c.magenta>而人们会多次看你的API代码</c>

00:06:17.845 --> 00:06:21.048 align:middle
<c.magenta>或者API文档</c>

00:06:21.481 --> 00:06:25.018 align:middle
<c.magenta>但API真正重要的</c>
<c.magenta>大多情况下</c>

00:06:25.085 --> 00:06:28.655 align:middle
<c.magenta>API被看到次数最多的时候</c>
<c.magenta>将是处在上下文语境中</c>

00:06:28.956 --> 00:06:30.324 align:middle
<c.magenta>周围有大量其它代码</c>

00:06:30.891 --> 00:06:32.659 align:middle
<c.magenta>当你处在这样的语境中</c>

00:06:32.726 --> 00:06:35.863 align:middle
<c.magenta>你就拥有所有额外</c>
<c.magenta>丰富的语境信息</c>

00:06:36.430 --> 00:06:40.601 align:middle
<c.magenta>你拥有局部变量</c>
<c.magenta>及其名称和类型</c>

00:06:41.235 --> 00:06:43.203 align:middle
<c.magenta>你拥有相关API的使用</c>

00:06:43.403 --> 00:06:46.173 align:middle
<c.magenta>而你的API的目的</c>
<c.magenta>不是站起来说：</c>

00:06:46.440 --> 00:06:49.076 align:middle
<c.magenta>“嗨 我在这儿</c>
<c.magenta>我信誉好 名号大”</c>

00:06:49.510 --> 00:06:52.880 align:middle
<c.magenta>你的API的目的是</c>
<c.magenta>适应其它代码</c>

00:06:53.180 --> 00:06:54.882 align:middle
<c.magenta>从而产生完美的结果</c>

00:06:56.116 --> 00:06:59.686 align:middle
<c.magenta>那么 当你关注用例时</c>
<c.magenta>一定要避免</c>

00:07:00.387 --> 00:07:02.122 align:middle
<c.magenta>去针对不好的代码进行优化</c>

00:07:03.290 --> 00:07:05.759 align:middle
<c.magenta>这一点绝对会发生</c>
<c.magenta>有的人写代码</c>

00:07:05.826 --> 00:07:08.462 align:middle
<c.magenta>会对所有的变量</c>
<c.magenta>使用A、B和C这样的名字</c>

00:07:08.695 --> 00:07:10.831 align:middle
<c.magenta>这样的代码不再清晰</c>

00:07:13.433 --> 00:07:16.670 align:middle
<c.magenta>而仅凭API并不能改善</c>
<c.magenta>这种不好的代码</c>

00:07:18.005 --> 00:07:21.742 align:middle
<c.magenta>你能做的就只是</c>
<c.magenta>让其它代码更啰嗦或更不清楚</c>

00:07:22.976 --> 00:07:25.345 align:middle
<c.magenta>所以请关注适当的用例</c>

00:07:25.412 --> 00:07:28.248 align:middle
<c.magenta>关注好的代码</c>
<c.magenta>针对好的代码去调整API</c>

00:07:30.184 --> 00:07:32.286 align:middle
<c.magenta>这里 让我们实际</c>
<c.magenta>看一个具体的例子</c>

00:07:32.486 --> 00:07:34.354 align:middle
<c.magenta>那么 让我们首先看一个API</c>

00:07:35.255 --> 00:07:37.224 align:middle
<c.magenta>从集合中删除一个项目</c>

00:07:38.458 --> 00:07:40.627 align:middle
<c.magenta>首先 我们将它命名为</c>
<c.magenta>“removeItem”</c>

00:07:41.261 --> 00:07:43.697 align:middle
<c.magenta>听起来不错</c>
<c.magenta>但这是我犯的第一个错误</c>

00:07:43.797 --> 00:07:45.465 align:middle
<c.magenta>这不是用例</c>

00:07:45.532 --> 00:07:47.467 align:middle
<c.magenta>这只是简要的名称</c>

00:07:48.001 --> 00:07:51.004 align:middle
<c.magenta>那么 让我们显示今天</c>
<c.magenta>我想到的一个用例</c>

00:07:51.638 --> 00:07:52.472 align:middle
<c.magenta>不要问为什么</c>

00:07:52.706 --> 00:07:56.944 align:middle
<c.magenta>他知道 将项目“ted”</c>
<c.magenta>从好友列表中删除</c>

00:07:57.811 --> 00:08:00.514 align:middle
<c.magenta>现在 你会注意到</c>
<c.magenta>该用例中实际有两个东西</c>

00:07:57.811 --> 00:08:00.514 align:middle
<c.magenta>现在 你会注意到</c>
<c.magenta>该用例中实际有两个东西</c>

00:08:00.581 --> 00:08:03.617 align:middle
<c.magenta>指示参数是什么</c>

00:08:03.684 --> 00:08:05.485 align:middle
<c.magenta>这两个东西都试图</c>
<c.magenta>对参数进行描述</c>

00:08:05.552 --> 00:08:07.721 align:middle
<c.magenta>其中一个是单词“item”</c>
<c.magenta>也是名称的一部分</c>

00:08:08.722 --> 00:08:10.324 align:middle
<c.magenta>另一个是参数“ted”</c>

00:08:10.390 --> 00:08:12.526 align:middle
<c.magenta>即一定类型的某个局部变量</c>

00:08:12.926 --> 00:08:18.332 align:middle
<c.magenta>这两个符号中 变量</c>
<c.magenta>“ted”实际能更好地描述</c>

00:08:18.398 --> 00:08:19.533 align:middle
<c.magenta>参数是什么</c>

00:08:19.900 --> 00:08:21.101 align:middle
<c.magenta>它是处在语境中的</c>

00:08:21.168 --> 00:08:24.505 align:middle
<c.magenta>在语境中读取此调用时</c>
<c.magenta>你会知道这个局部变量是什么</c>

00:08:24.571 --> 00:08:26.673 align:middle
<c.magenta>它表示一定意义</c>
<c.magenta>它具备强类型</c>

00:08:28.008 --> 00:08:29.810 align:middle
<c.magenta>所以这里的问题</c>
<c.magenta>实际可能是</c>

00:08:30.177 --> 00:08:33.280 align:middle
<c.magenta>单词“item”</c>
<c.magenta>描述性不够强</c>

00:08:33.714 --> 00:08:35.315 align:middle
<c.magenta>也许改为</c>
<c.magenta>“removeObject”</c>

00:08:35.381 --> 00:08:36.950 align:middle
<c.magenta>我们会觉得舒服点</c>

00:08:38.085 --> 00:08:39.553 align:middle
<c.magenta>不过</c>
<c.magenta>也许事实也不是这样</c>

00:08:39.620 --> 00:08:41.822 align:middle
<c.magenta>因为无论如何</c>
<c.magenta>我们很可能用的是值类型</c>

00:08:41.889 --> 00:08:43.657 align:middle
<c.magenta>所以这只是活跃性的错误</c>

00:08:44.057 --> 00:08:46.460 align:middle
<c.magenta>我们可以改为</c>
<c.magenta>“removeElement”</c>

00:08:46.894 --> 00:08:49.696 align:middle
<c.magenta>好 Swift语言的集合</c>
<c.magenta>也使用element术语</c>

00:08:50.597 --> 00:08:52.900 align:middle
<c.magenta>不过 这样也不起作用</c>

00:08:53.667 --> 00:08:56.670 align:middle
<c.magenta>而且 如果我们开始</c>
<c.magenta>写下不同的用例</c>

00:08:56.870 --> 00:08:59.339 align:middle
<c.magenta>实际上可能会更不清晰</c>

00:09:00.374 --> 00:09:02.009 align:middle
<c.magenta>我想将“caffeine”</c>

00:09:02.075 --> 00:09:03.844 align:middle
<c.magenta>这个元素从有机化合物</c>
<c.magenta>列表中移除</c>

00:09:04.411 --> 00:09:05.846 align:middle
<c.magenta>这是误导性的</c>
<c.magenta>错误的</c>

00:09:05.913 --> 00:09:07.181 align:middle
<c.magenta>“咖啡因”不是元素</c>

00:09:07.481 --> 00:09:09.082 align:middle
<c.magenta>它是元素组成的化合物</c>

00:09:09.550 --> 00:09:12.186 align:middle
<c.magenta>所以 这里我们试图使用</c>
<c.magenta>一些无伤大雅的词</c>

00:09:12.252 --> 00:09:16.590 align:middle
<c.magenta>来描述参数 这实际让我们</c>
<c.magenta>写出了更模糊的用例</c>

00:09:18.225 --> 00:09:19.059 align:middle
<c.magenta>好</c>

00:09:19.660 --> 00:09:22.329 align:middle
<c.magenta>所以 可能问题是</c>
<c.magenta>我们应该停止</c>

00:09:22.396 --> 00:09:24.665 align:middle
<c.magenta>将这些看似无伤大雅的</c>
<c.magenta>概括词用在那里</c>

00:09:24.731 --> 00:09:26.266 align:middle
<c.magenta>我们应该特别具体</c>

00:09:26.433 --> 00:09:28.836 align:middle
<c.magenta>将“ted”这个人</c>
<c.magenta>从好友列表中移除</c>

00:09:30.337 --> 00:09:31.872 align:middle
<c.magenta>这句英语有点怪</c>

00:09:32.439 --> 00:09:34.575 align:middle
<c.magenta>我不会这么说 我只会说</c>
<c.magenta>“remove(ted)”移除ted</c>

00:09:35.209 --> 00:09:36.343 align:middle
<c.magenta>不过进一步讲</c>

00:09:37.444 --> 00:09:40.180 align:middle
<c.magenta>如果我这么做了</c>
<c.magenta>如果对这种一般性的API</c>

00:09:41.281 --> 00:09:44.985 align:middle
<c.magenta>我做到了特别具体 那么</c>
<c.magenta>我会期待任何时候都很具体</c>

00:09:45.819 --> 00:09:48.956 align:middle
<c.magenta>现在 有一个概念性的API</c>
<c.magenta>即 只是将某个项目</c>

00:09:49.022 --> 00:09:52.492 align:middle
<c.magenta>从集合中移除 而该项目</c>
<c.magenta>在源数据库基中有不同的名称</c>

00:09:53.660 --> 00:09:55.295 align:middle
<c.magenta>这样就更难理解了</c>

00:09:55.362 --> 00:09:56.997 align:middle
<c.magenta>很难识别出</c>
<c.magenta>我们实际说的</c>

00:09:57.064 --> 00:09:59.299 align:middle
<c.magenta>是在不同语境中的</c>
<c.magenta>同一样东西</c>

00:09:59.666 --> 00:10:03.403 align:middle
<c.magenta>所以 Swift API设计准则</c>
<c.magenta>采取了不同的方法</c>

00:09:59.666 --> 00:10:03.403 align:middle
<c.magenta>所以 Swift API设计准则</c>
<c.magenta>采取了不同的方法</c>

00:10:05.172 --> 00:10:07.341 align:middle
<c.magenta>略去不必要的单词</c>

00:10:09.243 --> 00:10:13.113 align:middle
<c.magenta>如果一个单词</c>
<c.magenta>不能使使用站点更清晰</c>

00:10:13.280 --> 00:10:14.548 align:middle
<c.magenta>就不用这个单词</c>

00:10:15.115 --> 00:10:17.017 align:middle
<c.magenta>所以我们可以只是说</c>
<c.magenta>从好友列表中“remove(ted)”</c>

00:10:17.084 --> 00:10:18.385 align:middle
<c.magenta>这样读起来很顺</c>

00:10:18.852 --> 00:10:21.822 align:middle
<c.magenta>这种做法之所以在Swift中</c>
<c.magenta>如此出色地实现</c>

00:10:22.656 --> 00:10:25.959 align:middle
<c.magenta>原因之一是 Swift有</c>
<c.magenta>强大的静态类型系统</c>

00:10:27.227 --> 00:10:30.797 align:middle
<c.magenta>可以确保你不会写出</c>
<c.magenta>无意义的代码</c>

00:10:30.864 --> 00:10:32.266 align:middle
<c.magenta>或者对代码解释错误</c>

00:10:32.332 --> 00:10:35.269 align:middle
<c.magenta>所以 强大的</c>
<c.magenta>静态类型系统能确保</c>

00:10:35.335 --> 00:10:37.304 align:middle
<c.magenta>你允许移除的参数</c>

00:10:37.538 --> 00:10:40.207 align:middle
<c.magenta>是相应集合中的元素</c>

00:10:41.308 --> 00:10:43.911 align:middle
<c.magenta>如果你要做出</c>
<c.magenta>任何失策的举动</c>

00:10:43.977 --> 00:10:47.714 align:middle
<c.magenta>比如 试图从好友列表中</c>
<c.magenta>移除“caffeine”咖啡因</c>

00:10:48.582 --> 00:10:52.019 align:middle
<c.magenta>你会收到编译器发出的错误消息</c>
<c.magenta>告诉你代码不符合逻辑</c>

00:10:54.621 --> 00:10:58.258 align:middle
<c.magenta>所以 我们讨论了</c>
<c.magenta>使用站点的可读性</c>

00:10:59.359 --> 00:11:01.695 align:middle
<c.magenta>我们排除了很多的单词</c>

00:10:59.359 --> 00:11:01.695 align:middle
<c.magenta>我们排除了很多的单词</c>

00:11:01.828 --> 00:11:05.232 align:middle
<c.magenta>你可能因此觉得</c>
<c.magenta>我们追求的是简练的代码</c>

00:11:06.066 --> 00:11:07.935 align:middle
<c.magenta>事实并非如此</c>
<c.magenta>我们想要清晰的代码</c>

00:11:08.936 --> 00:11:09.770 align:middle
<c.magenta>不过...</c>

00:11:10.304 --> 00:11:13.173 align:middle
<c.magenta>清晰的代码</c>
<c.magenta>也需要达到适当的平衡</c>

00:11:13.240 --> 00:11:16.076 align:middle
<c.magenta>不能过短或过长</c>

00:11:16.510 --> 00:11:19.146 align:middle
<c.magenta>如果想知道</c>
<c.magenta>什么代码过长</c>

00:11:19.213 --> 00:11:23.750 align:middle
<c.magenta>过长的代码是</c>
<c.magenta>包含不必要额外信息的代码</c>

00:11:25.085 --> 00:11:27.654 align:middle
<c.magenta>过长的代码</c>
<c.magenta>实际会影响清晰度</c>

00:11:27.855 --> 00:11:31.491 align:middle
<c.magenta>因为 在读这种冗长代码时</c>
<c.magenta>你的脑子在做什么？</c>

00:11:32.159 --> 00:11:35.462 align:middle
<c.magenta>它在努力筛除</c>
<c.magenta>所有额外的噪声</c>

00:11:35.529 --> 00:11:37.831 align:middle
<c.magenta>筛除所有冗余的</c>
<c.magenta>不必要的东西</c>

00:11:37.898 --> 00:11:39.533 align:middle
<c.magenta>从而找到代码中</c>
<c.magenta>实际的信息</c>

00:11:40.868 --> 00:11:43.136 align:middle
<c.magenta>而这个平衡的另一端</c>
<c.magenta>也不可取</c>

00:11:43.203 --> 00:11:44.838 align:middle
<c.magenta>如果你的代码过于简练</c>

00:11:45.138 --> 00:11:47.274 align:middle
<c.magenta>那么你可能遗漏必要的信息</c>

00:11:47.608 --> 00:11:50.377 align:middle
<c.magenta>以致使代码难以理解</c>

00:11:51.345 --> 00:11:54.448 align:middle
<c.magenta>什么表明代码过于简练</c>

00:11:54.681 --> 00:11:57.351 align:middle
<c.magenta>如果你在读代码</c>
<c.magenta>你发现自己会总是参考</c>

00:11:57.417 --> 00:11:59.520 align:middle
<c.magenta>API文档</c>
<c.magenta>因为API本身描述不够清楚</c>

00:11:59.686 --> 00:12:02.656 align:middle
<c.magenta>则说明代码过于简练</c>

00:11:59.686 --> 00:12:02.656 align:middle
<c.magenta>则说明代码过于简练</c>

00:12:03.757 --> 00:12:06.159 align:middle
<c.magenta>所以我们要找到</c>
<c.magenta>中间最佳的平衡点</c>

00:12:06.460 --> 00:12:08.462 align:middle
<c.magenta>使代码既清晰</c>

00:12:09.730 --> 00:12:11.164 align:middle
<c.magenta>又简练</c>

00:12:11.298 --> 00:12:14.201 align:middle
<c.magenta>这样 了解API和API工作</c>
<c.magenta>方式需要的所有信息</c>

00:12:14.268 --> 00:12:17.671 align:middle
<c.magenta>都在语境信息中</c>

00:12:18.372 --> 00:12:21.008 align:middle
<c.magenta>这实际上是</c>
<c.magenta>Swift语言本身的原则</c>

00:12:21.074 --> 00:12:23.110 align:middle
<c.magenta>所以 这里我提供</c>
<c.magenta>一些代码</c>

00:12:24.511 --> 00:12:27.881 align:middle line:1
<c.magenta>在这些代码中</c>
<c.magenta>实际存在</c>

00:12:28.382 --> 00:12:30.517 align:middle line:1
<c.magenta>Swift中不需要的</c>
<c.magenta>冗长信息</c>

00:12:30.784 --> 00:12:34.154 align:middle line:1
<c.magenta>就是这些</c>
<c.magenta>直白的类型注解</c>

00:12:34.922 --> 00:12:36.957 align:middle line:1
<c.magenta>这些注解</c>
<c.magenta>没有增强代码的可读性</c>

00:12:37.925 --> 00:12:40.827 align:middle line:1
<c.magenta>仅通过读API</c>
<c.magenta>你就可以了解这些类型是什么</c>

00:12:41.061 --> 00:12:44.231 align:middle line:1
<c.magenta>实际上 在Swift中</c>
<c.magenta>你很可能不会这样写代码</c>

00:12:44.364 --> 00:12:46.900 align:middle line:1
<c.magenta>你可能会匹配这种类型信息</c>

00:12:46.967 --> 00:12:48.502 align:middle line:1
<c.magenta>让静态类型trebicore</c>

00:12:48.602 --> 00:12:51.238 align:middle line:1
<c.magenta>帮你作注解</c>
<c.magenta>从而使代码更简练</c>

00:12:51.405 --> 00:12:53.607 align:middle line:1
<c.magenta>也仍然清晰可读</c>

00:12:54.474 --> 00:12:56.243 align:middle line:1
<c.magenta>当然 类型很重要</c>

00:12:56.310 --> 00:12:57.578 align:middle line:1
<c.magenta>类型就在那里</c>

00:12:57.644 --> 00:13:00.280 align:middle line:1
<c.magenta>如果你需要确定</c>
<c.magenta>特定的类型是什么</c>

00:12:57.644 --> 00:13:00.280 align:middle line:1
<c.magenta>如果你需要确定</c>
<c.magenta>特定的类型是什么</c>

00:13:00.347 --> 00:13:01.715 align:middle line:1
<c.magenta>而这样能有助于你理解</c>

00:13:01.782 --> 00:13:05.152 align:middle line:1
<c.magenta>当然 你可以选择获取答案</c>
<c.magenta>只需在Xcode内单击</c>

00:13:07.888 --> 00:13:09.489 align:middle
<c.magenta>那么 让我们看一下</c>
<c.magenta>另一个API</c>

00:13:09.556 --> 00:13:13.660 align:middle
<c.magenta>并讨论下什么时候</c>
<c.magenta>实际需要一个单词</c>

00:13:13.894 --> 00:13:15.829 align:middle
<c.magenta>才有助于描述参数</c>

00:13:16.797 --> 00:13:19.733 align:middle
<c.magenta>我们以这个小API为例</c>
<c.magenta>即 将“子视图”</c>

00:13:20.200 --> 00:13:23.537 align:middle
<c.magenta>添加到某个“主视图”中的</c>
<c.magenta>某个特定点</c>

00:13:24.104 --> 00:13:25.439 align:middle
<c.magenta>因此 我们写出用例</c>

00:13:25.539 --> 00:13:26.974 align:middle
<c.magenta>记住始终从用例开始</c>

00:13:27.040 --> 00:13:29.476 align:middle
<c.magenta>想一下用来描述</c>
<c.magenta>参数的词</c>

00:13:29.610 --> 00:13:32.713 align:middle
<c.magenta>在第一种情况下</c>
<c.magenta>单词“child”用在了</c>

00:13:32.779 --> 00:13:35.315 align:middle
<c.magenta>这个“视图”参数中</c>
<c.magenta>也就是我们第一参数</c>

00:13:36.049 --> 00:13:37.918 align:middle
<c.magenta>“child” 表达了什么信息吗?</c>

00:13:38.051 --> 00:13:39.586 align:middle
<c.magenta>嗯 从静态类型系统中</c>
<c.magenta>我们知道</c>

00:13:39.653 --> 00:13:42.422 align:middle
<c.magenta>边栏会是</c>
<c.magenta>某种视图</c>

00:13:44.758 --> 00:13:47.494 align:middle
<c.magenta>但单词“child”可以说明操作中</c>

00:13:47.561 --> 00:13:49.463 align:middle
<c.magenta>此参数的作用</c>

00:13:49.530 --> 00:13:53.200 align:middle
<c.magenta>它表明了</c>
<c.magenta>这里的参数将成为“child”</c>

00:13:53.333 --> 00:13:55.002 align:middle
<c.magenta>它建立了层次结构</c>

00:13:55.202 --> 00:13:59.706 align:middle
<c.magenta>这确实是很重要的信息</c>
<c.magenta>便于我们了解这个API的作用</c>

00:14:02.543 --> 00:14:07.414 align:middle
<c.magenta>现在 第二个参数中</c>
<c.magenta>存在“atPoint”和“origin”</c>

00:14:07.681 --> 00:14:10.684 align:middle
<c.magenta>“origin”会是什么？</c>
<c.magenta>嗯 它将会是CGPoint</c>

00:14:10.751 --> 00:14:12.452 align:middle
<c.magenta>这个API会使用CGPoint</c>

00:14:12.519 --> 00:14:15.289 align:middle
<c.magenta>这里除了CGPoint</c>
<c.magenta>你也提供不了什么</c>

00:14:16.957 --> 00:14:18.992 align:middle
<c.magenta>所以这个单词</c>
<c.magenta>不能表示实际意义</c>

00:14:19.059 --> 00:14:21.395 align:middle
<c.magenta>它只是在重复说明</c>
<c.magenta>强静态类型系统中</c>

00:14:21.461 --> 00:14:24.464 align:middle
<c.magenta>已经存在</c>
<c.magenta>并将被Swift语言</c>

00:14:24.631 --> 00:14:26.233 align:middle
<c.magenta>实施的信息</c>

00:14:26.800 --> 00:14:28.368 align:middle
<c.magenta>所以去掉这个词</c>
<c.magenta>你不需要它</c>

00:14:29.002 --> 00:14:30.771 align:middle
<c.magenta>现在看看</c>
<c.magenta>这里调用站点的样子</c>

00:14:30.838 --> 00:14:35.042 align:middle
<c.magenta>如果大声读出来</c>
<c.magenta>你在“origin”添加“child”边栏</c>

00:14:36.443 --> 00:14:37.678 align:middle
<c.magenta>读起来语法很对</c>

00:14:38.779 --> 00:14:39.847 align:middle
<c.magenta>这是这种</c>

00:14:39.913 --> 00:14:43.550 align:middle
<c.magenta>特定API设计准则的</c>
<c.magenta>原则之一</c>

00:14:43.717 --> 00:14:47.020 align:middle
<c.magenta>即 我们力争达到</c>
<c.magenta>使用点通顺并语法正确</c>

00:14:47.688 --> 00:14:50.224 align:middle
<c.magenta>这里的例子 从我们的</c>
<c.magenta>好友列表中移除“remove(ted)”</c>

00:14:50.724 --> 00:14:51.959 align:middle
<c.magenta>就具备这种特点</c>

00:14:52.593 --> 00:14:54.661 align:middle
<c.magenta>现在 让我们看看</c>
<c.magenta>一个非常相关的API</c>

00:14:54.761 --> 00:14:57.731 align:middle
<c.magenta>这个API</c>
<c.magenta>是要移除特定的元素</c>

00:14:58.131 --> 00:15:01.902 align:middle
<c.magenta>如果我们看 比如</c>
<c.magenta>移除特定位置某项目的API</c>

00:14:58.131 --> 00:15:01.902 align:middle
<c.magenta>如果我们看 比如</c>
<c.magenta>移除特定位置某项目的API</c>

00:15:02.069 --> 00:15:02.936 align:middle
<c.magenta>读出来</c>

00:15:03.203 --> 00:15:06.974 align:middle
<c.magenta>从集合中移除</c>
<c.magenta>之前好友的位置</c>

00:15:07.241 --> 00:15:08.108 align:middle
<c.magenta>读起来不对</c>

00:15:08.175 --> 00:15:10.511 align:middle
<c.magenta>这不是位置的集合</c>

00:15:10.777 --> 00:15:12.179 align:middle
<c.magenta>而是人的集合</c>

00:15:13.814 --> 00:15:18.218 align:middle
<c.magenta>让这句话实际读起来</c>
<c.magenta>符合逻辑 我们要说“remove at”</c>

00:15:19.720 --> 00:15:20.654 align:middle
<c.magenta>让我们读出来：</c>

00:15:20.721 --> 00:15:23.457 align:middle
<c.magenta>在之前好友的位置移除</c>

00:15:23.991 --> 00:15:27.594 align:middle
<c.magenta>请注意我们</c>
<c.magenta>澄清API行为的方法</c>

00:15:28.929 --> 00:15:31.999 align:middle
<c.magenta>是放入第一个</c>
<c.magenta>参数标签 以描述</c>

00:15:32.065 --> 00:15:34.801 align:middle
<c.magenta>参数与该方法的关系</c>

00:15:36.703 --> 00:15:39.406 align:middle
<c.magenta>这就涉及命名</c>
<c.magenta>和命名的概念</c>

00:15:39.640 --> 00:15:43.143 align:middle
<c.magenta>所以 在Swift中</c>
<c.magenta>一个函数的名称包括</c>

00:15:43.210 --> 00:15:47.080 align:middle
<c.magenta>所谓的基名称在这两个API中</c>
<c.magenta>即“remove”</c>

00:15:47.414 --> 00:15:51.218 align:middle
<c.magenta>以及参数的</c>
<c.magenta>所有参数标签</c>

00:15:51.451 --> 00:15:55.055 align:middle
<c.magenta>所以这两个相关的API</c>
<c.magenta>它们有相同的基名称</c>

00:15:55.122 --> 00:15:57.824 align:middle
<c.magenta>即“remove” 因为它们属于</c>
<c.magenta>相同操作方法系列</c>

00:15:57.891 --> 00:15:59.526 align:middle
<c.magenta>即从集合中移除某项目</c>

00:15:59.860 --> 00:16:01.762 align:middle
<c.magenta>但它们的</c>
<c.magenta>参数标签不同</c>

00:15:59.860 --> 00:16:01.762 align:middle
<c.magenta>但它们的</c>
<c.magenta>参数标签不同</c>

00:16:02.229 --> 00:16:04.364 align:middle
<c.magenta>因为它们</c>
<c.magenta>做的事情不同</c>

00:16:04.431 --> 00:16:07.367 align:middle
<c.magenta>一个是按照身份</c>
<c.magenta>移除元素</c>

00:16:07.601 --> 00:16:11.805 align:middle
<c.magenta>另一个是基于</c>
<c.magenta>在系列中的位置移除元素</c>

00:16:12.739 --> 00:16:15.075 align:middle
<c.magenta>所以略微不同的API</c>
<c.magenta>拥有不同的名称</c>

00:16:15.375 --> 00:16:19.413 align:middle
<c.magenta>现在 你可以</c>
<c.magenta>基于类型信息进行重载</c>

00:16:19.646 --> 00:16:22.683 align:middle line:1
<c.magenta>如果两个API</c>
<c.magenta>拥有同一复合名称</c>

00:16:23.150 --> 00:16:24.852 align:middle line:1
<c.magenta>但只有当API的语义</c>

00:16:25.285 --> 00:16:28.222 align:middle line:1
<c.magenta>相同时你才能这样做</c>

00:16:28.522 --> 00:16:30.557 align:middle line:1
<c.magenta>所以这里你可以重载</c>

00:16:30.624 --> 00:16:32.993 align:middle line:1
<c.magenta>没有参数标签的附加名称</c>
<c.magenta>从而将字符</c>

00:16:33.060 --> 00:16:34.294 align:middle line:1
<c.magenta>或字符串附加到</c>
<c.magenta>某些文本</c>

00:16:34.528 --> 00:16:36.897 align:middle line:1
<c.magenta>因为它们根本上</c>
<c.magenta>属于相同的操作</c>

00:16:36.964 --> 00:16:39.633 align:middle line:1
<c.magenta>它们只是出于方便起见</c>
<c.magenta>被重载到不同的类型上</c>

00:16:41.235 --> 00:16:43.704 align:middle line:1
<c.magenta>现在</c>
<c.magenta>写出第一参数标签后</c>

00:16:43.770 --> 00:16:47.641 align:middle
<c.magenta>同样 你需要保证</c>
<c.magenta>用例读起来符合语法规则</c>

00:16:47.708 --> 00:16:49.810 align:middle
<c.magenta>这包括方法的基名称</c>

00:16:49.910 --> 00:16:51.678 align:middle
<c.magenta>以及参数标签</c>

00:16:52.212 --> 00:16:56.283 align:middle
<c.magenta>所以这是我第一个API：</c>
<c.magenta>removeBoxes (withLabel:WWDC)</c>

00:16:57.117 --> 00:16:58.318 align:middle
<c.magenta>注意这读起来顺不顺</c>

00:16:58.585 --> 00:17:02.623 align:middle
<c.magenta>注意 这个API内</c>
<c.magenta>有一个介词短语</c>

00:16:58.585 --> 00:17:02.623 align:middle
<c.magenta>注意 这个API内</c>
<c.magenta>有一个介词短语</c>

00:17:03.257 --> 00:17:06.393 align:middle
<c.magenta>所以这有点像英语语法</c>
<c.magenta>本质上这个短语是“withLabel”</c>

00:17:06.460 --> 00:17:09.596 align:middle
<c.magenta>它描述参数</c>
<c.magenta>与移除方框的实际操作</c>

00:17:10.097 --> 00:17:12.699 align:middle
<c.magenta>之间的关系</c>

00:17:12.766 --> 00:17:14.835 align:middle
<c.magenta>当存在</c>
<c.magenta>这些介词短语中之一时</c>

00:17:14.902 --> 00:17:17.905 align:middle
<c.magenta>将它放在第一参数标签上</c>
<c.magenta>以描述第一个参数</c>

00:17:19.540 --> 00:17:21.340 align:middle
<c.magenta>如果你根本</c>
<c.magenta>无法构成符合语法规则的短语</c>

00:17:21.407 --> 00:17:23.777 align:middle
<c.magenta>也可以使用第一参数标签</c>

00:17:23.844 --> 00:17:25.212 align:middle
<c.magenta>因为如果</c>
<c.magenta>将第一参数放在那儿</c>

00:17:25.279 --> 00:17:26.914 align:middle
<c.magenta>具有一定误导性</c>

00:17:26.980 --> 00:17:30.150 align:middle
<c.magenta>所以这里 我们有“viewController”</c>
<c.magenta>我们说“dismiss(true)”</c>

00:17:31.451 --> 00:17:34.521 align:middle
<c.magenta>那是什么？我不能</c>
<c.magenta>把布尔常数到处乱放</c>

00:17:35.989 --> 00:17:38.158 align:middle
<c.magenta>所以 要让这句</c>
<c.magenta>符合语法规则</c>

00:17:38.325 --> 00:17:40.260 align:middle
<c.magenta>我需要在那儿</c>
<c.magenta>放上一个参数标签</c>

00:17:40.561 --> 00:17:41.995 align:middle
<c.magenta>解除“viewController”</c>

00:17:42.262 --> 00:17:44.064 align:middle
<c.magenta>变成动画</c>
<c.magenta>Animated为真</c>

00:17:44.231 --> 00:17:46.400 align:middle
<c.magenta>所以这是</c>
<c.magenta>附带的额外信息</c>

00:17:46.466 --> 00:17:50.370 align:middle
<c.magenta>第一参数标签将它分解开</c>
<c.magenta>所以读起来很顺</c>

00:17:50.671 --> 00:17:54.508 align:middle
<c.magenta>而且很清楚 我们解除的</c>
<c.magenta>就是实际的视图控制器</c>

00:17:55.375 --> 00:17:58.111 align:middle
<c.magenta>你可以访问Swift.org</c>
<c.magenta>阅读其它若干规则</c>

00:17:58.212 --> 00:18:02.516 align:middle
<c.magenta>但本质上 你仍会在某些</c>
<c.magenta>情况下略去第一参数标签</c>

00:17:58.212 --> 00:18:02.516 align:middle
<c.magenta>但本质上 你仍会在某些</c>
<c.magenta>情况下略去第一参数标签</c>

00:18:02.683 --> 00:18:05.986 align:middle line:1
<c.magenta>这些情况下</c>
<c.magenta>在API中仅仅是有自变量</c>

00:18:06.053 --> 00:18:07.387 align:middle line:1
<c.magenta>就读着很顺：</c>

00:18:07.454 --> 00:18:10.490 align:middle line:1
<c.magenta>在好友的</c>
<c.magenta>起始索引处插入“michael”</c>

00:18:11.458 --> 00:18:12.292 align:middle line:1
<c.magenta>这读起来很顺</c>

00:18:12.359 --> 00:18:14.795 align:middle line:1
<c.magenta>我们不需要第一参数标签</c>
<c.magenta>使它读起来通顺</c>

00:18:14.862 --> 00:18:15.896 align:middle line:1
<c.magenta>所以我们将标签省略</c>

00:18:18.532 --> 00:18:19.566 align:middle
<c.magenta>好</c>

00:18:20.234 --> 00:18:23.070 align:middle
<c.magenta>在继续之前</c>
<c.magenta>我们稍稍再介绍下命名</c>

00:18:23.537 --> 00:18:27.941 align:middle
<c.magenta>在对方法进行命名时</c>
<c.magenta>基于方法的副作用命名</c>

00:18:28.242 --> 00:18:31.011 align:middle
<c.magenta>所以 请使用英语动词</c>
<c.magenta>和命令</c>

00:18:31.078 --> 00:18:33.881 align:middle
<c.magenta>告诉接收方“做某事”</c>

00:18:34.815 --> 00:18:37.317 align:middle
<c.magenta>所以这里 我们可能说</c>
<c.magenta>我们有好友集合</c>

00:18:37.384 --> 00:18:39.987 align:middle
<c.magenta>对它进行反转</c>
<c.magenta>“viewController”　请显示</c>

00:18:40.053 --> 00:18:42.189 align:middle
<c.magenta>“Organic compounds”</c>
<c.magenta>请附加</c>

00:18:42.623 --> 00:18:44.258 align:middle
<c.magenta>对吧？这些是采取的操作</c>

00:18:44.458 --> 00:18:46.126 align:middle
<c.magenta>我们基于采取的操作命名</c>

00:18:46.760 --> 00:18:50.531 align:middle
<c.magenta>现在 我们有一些方法</c>
<c.magenta>其主要作用就仅仅是</c>

00:18:50.664 --> 00:18:52.266 align:middle
<c.magenta>返回某值</c>

00:18:54.434 --> 00:18:55.903 align:middle
<c.magenta>我们使用名词</c>

00:18:55.969 --> 00:18:58.906 align:middle
<c.magenta>描述返回的东西</c>

00:18:59.373 --> 00:19:02.142 align:middle
<c.magenta>所以 这里我们可以</c>
<c.magenta>要求获取按钮的背景标题</c>

00:18:59.373 --> 00:19:02.142 align:middle
<c.magenta>所以 这里我们可以</c>
<c.magenta>要求获取按钮的背景标题</c>

00:19:02.209 --> 00:19:04.378 align:middle
<c.magenta>或者好友阵列的后缀</c>

00:19:07.147 --> 00:19:09.283 align:middle
<c.magenta>当你在处理值类型时</c>

00:19:10.551 --> 00:19:12.819 align:middle
<c.magenta>有时情况是这样的</c>
<c.magenta>你拥有本质上相同操作的</c>

00:19:12.886 --> 00:19:16.123 align:middle
<c.magenta>转变和未转变形式</c>

00:19:16.423 --> 00:19:17.691 align:middle
<c.magenta>这里我们喜欢称作</c>

00:19:17.758 --> 00:19:20.194 align:middle
<c.magenta>使用我们喜欢称作</c>
<c.magenta>“ed/ing规则”的东西</c>

00:19:21.562 --> 00:19:24.565 align:middle
<c.magenta>这来自英语语法</c>

00:19:24.631 --> 00:19:27.301 align:middle
<c.magenta>基本上你要从动词形式开始</c>

00:19:27.634 --> 00:19:29.603 align:middle
<c.magenta>所以这里 我们有</c>
<c.magenta>“reverse a collection”</c>

00:19:29.670 --> 00:19:31.905 align:middle
<c.magenta>你命令X</c>
<c.magenta>自身反转</c>

00:19:33.473 --> 00:19:36.276 align:middle
<c.magenta>而对于</c>
<c.magenta>更像是名词的其他形式</c>

00:19:36.410 --> 00:19:37.511 align:middle
<c.magenta>使用“ed规则”</c>

00:19:37.678 --> 00:19:39.913 align:middle
<c.magenta>我们要求X被反转</c>

00:19:40.514 --> 00:19:43.217 align:middle
<c.magenta>我们描述我们想要的结果</c>

00:19:43.584 --> 00:19:45.586 align:middle
<c.magenta>这就与转变形式对应</c>

00:19:46.220 --> 00:19:47.721 align:middle line:1
<c.magenta>而“ed规则”不适用时</c>

00:19:47.788 --> 00:19:49.590 align:middle line:1
<c.magenta>一般适用“ing规则”</c>

00:19:50.290 --> 00:19:52.392 align:middle line:1
<c.magenta>通常这时</c>
<c.magenta>这里有一个参数</c>

00:19:52.459 --> 00:19:53.760 align:middle line:1
<c.magenta>我们有一个文档目录</c>

00:19:53.827 --> 00:19:55.495 align:middle line:1
<c.magenta>我们可以对目录</c>
<c.magenta>附加路径组件</c>

00:19:55.896 --> 00:19:58.298 align:middle line:1
<c.magenta>这就是转变</c>
<c.magenta>我们告诉它附加这个</c>

00:19:59.299 --> 00:20:00.701 align:middle
<c.magenta>现在我们有未转变形式</c>

00:19:59.299 --> 00:20:00.701 align:middle
<c.magenta>现在我们有未转变形式</c>

00:20:00.767 --> 00:20:04.438 align:middle
<c.magenta>给我这个文档目录</c>
<c.magenta>附加这个特定的路径组件</c>

00:20:06.006 --> 00:20:10.711 align:middle
<c.magenta>所以这些规则 以及许多</c>
<c.magenta>其他规则 在Swift.org上</c>

00:20:10.777 --> 00:20:13.013 align:middle
<c.magenta>作为API设计准则文档的</c>
<c.magenta>一部分 都有描述</c>

00:20:13.313 --> 00:20:14.848 align:middle
<c.magenta>强烈推荐大家</c>
<c.magenta>进行阅读</c>

00:20:15.549 --> 00:20:17.551 align:middle
<c.magenta>并努力在自己的API中应用</c>

00:20:19.019 --> 00:20:20.954 align:middle
<c.magenta>不过 当然</c>

00:20:21.421 --> 00:20:24.525 align:middle
<c.magenta>只有实际广泛应用了</c>
<c.magenta>这些准则才会变得有趣</c>

00:20:25.025 --> 00:20:28.161 align:middle
<c.magenta>所以我们要进行</c>
<c.magenta>Grand Renaming</c>

00:20:28.729 --> 00:20:31.798 align:middle
<c.magenta>就是将这些准则</c>

00:20:32.165 --> 00:20:34.034 align:middle
<c.magenta>应用于Swift标准库</c>

00:20:34.501 --> 00:20:36.904 align:middle
<c.magenta>应用于Cocoa</c>
<c.magenta>和Cocoa Touch API</c>

00:20:37.371 --> 00:20:39.072 align:middle
<c.magenta>以及应用于指向性地</c>

00:20:39.306 --> 00:20:41.875 align:middle
<c.magenta>改进API 如Core Graphics</c>
<c.magenta>以及Grand Central Dispatch</c>

00:20:41.942 --> 00:20:45.646 align:middle
<c.magenta>这些准则可用在所有情况下</c>
<c.magenta>让这些API经过Swifty整容</c>

00:20:45.712 --> 00:20:47.014 align:middle
<c.magenta>从而在Swift中更美观</c>

00:20:48.482 --> 00:20:50.851 align:middle
<c.magenta>我之前稍微提到</c>
<c.magenta>Grand Renaming的规模</c>

00:20:50.918 --> 00:20:53.353 align:middle
<c.magenta>所以 这是一个</c>
<c.magenta>小Swift应用的截屏</c>

00:20:53.720 --> 00:20:57.357 align:middle
<c.magenta>应用叫做Lister</c>
<c.magenta>这个应用已经发售几年了</c>

00:20:57.424 --> 00:21:02.429 align:middle
<c.magenta>在从Swift 2迁移到Swift 3时</c>
<c.magenta>Lister是样本应用之一</c>

00:20:57.424 --> 00:21:02.429 align:middle
<c.magenta>在从Swift 2迁移到Swift 3时</c>
<c.magenta>Lister是样本应用之一</c>

00:21:02.963 --> 00:21:05.832 align:middle
<c.magenta>大家可以看到左边</c>
<c.magenta>有很多.swift文件</c>

00:21:06.533 --> 00:21:09.770 align:middle
<c.magenta>基本上 整个项目中</c>
<c.magenta>每一个Swift文件</c>

00:21:09.837 --> 00:21:12.339 align:middle
<c.magenta>都因为从Swift 2到</c>
<c.magenta>Swift 3的过渡而改变了</c>

00:21:13.106 --> 00:21:16.844 align:middle
<c.magenta>如果你们留意这里</c>
<c.magenta>中间和右侧窗格中的一些细节</c>

00:21:17.411 --> 00:21:21.081 align:middle
<c.magenta>你们可能发现</c>
<c.magenta>这些Cocoa API名称都变了</c>

00:21:23.016 --> 00:21:26.019 align:middle
<c.magenta>所以 这里有很多改变</c>
<c.magenta>我们将就此进行介绍</c>

00:21:26.386 --> 00:21:30.457 align:middle
<c.magenta>不过 非常有趣的是</c>
<c.magenta>这些你们可能</c>

00:21:30.524 --> 00:21:33.493 align:middle
<c.magenta>已使用很长时间的Cocoa API</c>
<c.magenta>这些API是一样的</c>

00:21:33.560 --> 00:21:36.763 align:middle
<c.magenta>但现在 一个特定的API</c>
<c.magenta>有两个不同的名称</c>

00:21:37.731 --> 00:21:40.000 align:middle
<c.magenta>一个名称适用于</c>
<c.magenta>Objective-C</c>

00:21:40.701 --> 00:21:42.970 align:middle
<c.magenta>另一个名称适用于Swift</c>

00:21:45.005 --> 00:21:48.742 align:middle
<c.magenta>作为Swift程序员</c>
<c.magenta>大多时候你不必在意这一点</c>

00:21:49.243 --> 00:21:52.145 align:middle
<c.magenta>你完全可以</c>
<c.magenta>在Swift名称下工作</c>

00:21:52.479 --> 00:21:54.515 align:middle
<c.magenta>使用你生成的界面和文档</c>

00:21:54.581 --> 00:21:57.251 align:middle
<c.magenta>所有材料都将显示Swift名称</c>
<c.magenta>Swift名称就是你要应对的</c>

00:21:57.317 --> 00:21:59.786 align:middle
<c.magenta>不过 有时你跟系统交互</c>
<c.magenta>这种情况下</c>

00:22:00.387 --> 00:22:02.155 align:middle
<c.magenta>你实际上</c>
<c.magenta>确实需要Objective-C名称</c>

00:22:02.222 --> 00:22:04.591 align:middle
<c.magenta>比如 如果你</c>
<c.magenta>要激活目标操作</c>

00:22:04.791 --> 00:22:06.527 align:middle
<c.magenta>所以 这里我们实际需要</c>

00:22:06.593 --> 00:22:08.862 align:middle
<c.magenta>为目标操作提供选择器</c>

00:22:09.096 --> 00:22:10.797 align:middle
<c.magenta>我们有这个字符串参数</c>

00:22:11.431 --> 00:22:12.466 align:middle
<c.magenta>在这里写什么呢？</c>

00:22:13.767 --> 00:22:16.170 align:middle
<c.magenta>我不知道</c>
<c.magenta>你可以看看生成的界面</c>

00:22:16.303 --> 00:22:19.339 align:middle
<c.magenta>或者在Twitter之类网站上</c>
<c.magenta>问你的Swift编程朋友</c>

00:22:19.473 --> 00:22:21.542 align:middle
<c.magenta>你能得到答案</c>
<c.magenta>这没问题</c>

00:22:21.675 --> 00:22:23.477 align:middle
<c.magenta>但是 请不要这样做</c>

00:22:24.244 --> 00:22:26.647 align:middle
<c.magenta>因为这个链接</c>
<c.magenta>非常非常薄弱</c>

00:22:27.114 --> 00:22:29.883 align:middle
<c.magenta>这个字符串参数</c>
<c.magenta>非常容易输错</c>

00:22:30.184 --> 00:22:32.719 align:middle
<c.magenta>它跟上面你实际想要</c>
<c.magenta>调用的方法之间的链接很薄弱</c>

00:22:33.253 --> 00:22:37.124 align:middle
<c.magenta>为此 在Swift 2.2中</c>
<c.magenta>我们引入了#selector</c>

00:22:38.292 --> 00:22:40.794 align:middle
<c.magenta>#selector非常简单</c>
<c.magenta>就是一个表达式</c>

00:22:41.128 --> 00:22:43.997 align:middle
<c.magenta>它接收Swift方法的名称</c>

00:22:44.731 --> 00:22:47.100 align:middle
<c.magenta>然后产生该方法的</c>
<c.magenta>Objective-C名称</c>

00:22:47.167 --> 00:22:49.603 align:middle
<c.magenta>你不需关心</c>
<c.magenta>Objective-C名称是什么</c>

00:22:49.670 --> 00:22:51.071 align:middle
<c.magenta>编译器会搞清楚</c>

00:22:51.271 --> 00:22:52.840 align:middle
<c.magenta>当然 这一点最棒的是</c>

00:22:52.906 --> 00:22:55.142 align:middle
<c.magenta>Swift确保存在该方法</c>

00:22:55.542 --> 00:22:57.744 align:middle
<c.magenta>确保该方法</c>
<c.magenta>向Objective-C公开</c>

00:22:58.145 --> 00:22:59.479 align:middle
<c.magenta>并计算出正确的名称</c>

00:22:59.580 --> 00:23:01.815 align:middle
<c.magenta>当然</c>
<c.magenta>这可防止重构</c>

00:22:59.580 --> 00:23:01.815 align:middle
<c.magenta>当然</c>
<c.magenta>这可防止重构</c>

00:23:01.982 --> 00:23:03.250 align:middle
<c.magenta>可以使用代码补全</c>

00:23:03.350 --> 00:23:05.319 align:middle
<c.magenta>让你享受</c>
<c.magenta>更舒适的开发体验</c>

00:23:05.385 --> 00:23:08.021 align:middle
<c.magenta>这意味着你无需担心</c>
<c.magenta>Objective-C名称</c>

00:23:08.822 --> 00:23:11.959 align:middle
<c.magenta>在Swift 3中 对此进行了</c>
<c.magenta>延伸 你也可以参考属性的</c>

00:23:12.025 --> 00:23:13.327 align:middle
<c.magenta>接受方和设置方</c>

00:23:13.560 --> 00:23:14.595 align:middle
<c.magenta>所以我们完成了</c>

00:23:14.661 --> 00:23:17.164 align:middle
<c.magenta>实际能计算的</c>
<c.magenta>Objective-C方法名设置</c>

00:23:17.364 --> 00:23:18.532 align:middle
<c.magenta>这使用起来非常简单</c>

00:23:18.599 --> 00:23:21.134 align:middle
<c.magenta>你只需输入参数标签</c>
<c.magenta>设置方或接受方</c>

00:23:21.201 --> 00:23:23.337 align:middle
<c.magenta>就可以分别获得</c>
<c.magenta>设置方或接受方</c>

00:23:23.504 --> 00:23:25.706 align:middle
<c.magenta>然后参看</c>
<c.magenta>Objective-C属性</c>

00:23:26.240 --> 00:23:28.108 align:middle
<c.magenta>当然</c>
<c.magenta>编译器会验证</c>

00:23:28.175 --> 00:23:30.944 align:middle
<c.magenta>该属性是否存在</c>
<c.magenta>并向Objective-C公开</c>

00:23:31.011 --> 00:23:33.413 align:middle
<c.magenta>为该属性获取</c>
<c.magenta>正确Objective-C名称</c>

00:23:34.915 --> 00:23:37.985 align:middle
<c.magenta>现在 提到Objective-C方法名</c>

00:23:38.051 --> 00:23:40.053 align:middle
<c.magenta>选择器并不是</c>
<c.magenta>唯一字符串类的东西</c>

00:23:40.320 --> 00:23:43.824 align:middle
<c.magenta>我们也有项路径</c>
<c.magenta>当作为字符串参数</c>

00:23:44.825 --> 00:23:48.028 align:middle
<c.magenta>编写而没有任何验证时</c>
<c.magenta>项路径是出了名的难写对</c>

00:23:48.562 --> 00:23:52.733 align:middle
<c.magenta>所以在Swift 3中</c>
<c.magenta>我们也将引入#keyPath</c>

00:24:01.275 --> 00:24:03.777 align:middle
<c.magenta>#keyPath的作用</c>
<c.magenta>跟你们料想的一模一样</c>

00:24:03.911 --> 00:24:07.381 align:middle line:1
<c.magenta>你可以参考圆点间隔的</c>
<c.magenta>属性访问序列</c>

00:24:07.681 --> 00:24:10.817 align:middle line:1
<c.magenta>编译器会验证这些属性</c>
<c.magenta>实际上是Objective-C属性</c>

00:24:11.251 --> 00:24:12.419 align:middle line:1
<c.magenta>获取正确的名称</c>

00:24:12.786 --> 00:24:16.990 align:middle line:1
<c.magenta>然后生成我们传递到</c>
<c.magenta>框架中的字符串</c>

00:24:17.057 --> 00:24:19.626 align:middle line:1
<c.magenta>所以通过#selector</c>
<c.magenta>和#keyPath</c>

00:24:19.893 --> 00:24:23.263 align:middle line:1
<c.magenta>你基本不需要担心</c>
<c.magenta>Objective-C名称</c>

00:24:23.997 --> 00:24:26.533 align:middle line:1
<c.magenta>你只需要使用</c>
<c.magenta>Swift名称编程</c>

00:24:26.667 --> 00:24:28.535 align:middle line:1
<c.magenta>然后停留在</c>
<c.magenta>这套Swift名称里</c>

00:24:28.602 --> 00:24:30.404 align:middle line:1
<c.magenta>你无需游走于边界两边</c>

00:24:31.471 --> 00:24:33.507 align:middle
<c.magenta>现在 有的情况下</c>
<c.magenta>你确实需要考虑</c>

00:24:33.574 --> 00:24:35.309 align:middle
<c.magenta>Objective-C名称为何</c>

00:24:35.409 --> 00:24:37.744 align:middle
<c.magenta>你可能有一个混合项目</c>
<c.magenta>里面有Objective-C代码</c>

00:24:37.811 --> 00:24:40.080 align:middle
<c.magenta>需要关联到</c>
<c.magenta>你Swift代码中的名称</c>

00:24:40.314 --> 00:24:43.016 align:middle line:1
<c.magenta>像这样的名称：</c>
<c.magenta>“handleDragWithSender4”</c>

00:24:43.083 --> 00:24:45.953 align:middle line:1
<c.magenta>在Objective-C中时</c>
<c.magenta>感觉就是不太对</c>

00:24:46.887 --> 00:24:51.225 align:middle line:1
<c.magenta>所以这些情况下</c>
<c.magenta>你可以使用@objc属性</c>

00:24:51.425 --> 00:24:54.695 align:middle line:1
<c.magenta>在圆括号中 输入你想要的</c>
<c.magenta>确切的Objective-C名称</c>

00:24:55.262 --> 00:24:57.931 align:middle line:1
<c.magenta>该名称会体现到</c>
<c.magenta>你生成的标头和所有元数据</c>

00:24:57.998 --> 00:25:01.068 align:middle line:1
<c.magenta>等等当中</c>
<c.magenta>这样你能够具体控制</c>

00:24:57.998 --> 00:25:01.068 align:middle line:1
<c.magenta>等等当中</c>
<c.magenta>这样你能够具体控制</c>

00:25:01.134 --> 00:25:02.836 align:middle line:1
<c.magenta>Objective-C名称</c>

00:25:03.303 --> 00:25:06.039 align:middle line:1
<c.magenta>但是你Swift代码的</c>
<c.magenta>其他部分都无须在意这一点</c>

00:25:07.641 --> 00:25:11.845 align:middle
<c.magenta>当然 这个@objc</c>
<c.magenta>具备名称 适用于属性</c>

00:25:11.912 --> 00:25:14.147 align:middle
<c.magenta>适用于方法、类和协议</c>

00:25:14.214 --> 00:25:17.417 align:middle
<c.magenta>任何可以从Swift向</c>
<c.magenta>Objective-C公开的对象</c>

00:25:17.851 --> 00:25:19.353 align:middle
<c.magenta>你可以在这里控制名称</c>

00:25:19.887 --> 00:25:23.090 align:middle
<c.magenta>所以对于Swift代码</c>
<c.magenta>你可得到漂亮的Objective-C API</c>

00:25:25.025 --> 00:25:25.859 align:middle
<c.magenta>好</c>

00:25:26.593 --> 00:25:28.762 align:middle
<c.magenta>Swift 3 发生了很多改变</c>

00:25:29.897 --> 00:25:32.999 align:middle
<c.magenta>Swift语言本身</c>
<c.magenta>让你无需考虑</c>

00:25:33.066 --> 00:25:34.468 align:middle
<c.magenta>Objective-C名称</c>

00:25:34.535 --> 00:25:37.171 align:middle
<c.magenta>然而当你确实在意</c>
<c.magenta>Objective-C名称时</c>

00:25:37.237 --> 00:25:39.339 align:middle
<c.magenta>它又让你可以获取</c>
<c.magenta>所需的掌控力</c>

00:25:40.874 --> 00:25:42.743 align:middle
<c.magenta>我们有这些工具帮助你</c>

00:25:43.977 --> 00:25:47.614 align:middle
<c.magenta>所以Swift 3迁移器进入</c>
<c.magenta>Swift 2代码并将它</c>

00:25:47.681 --> 00:25:49.917 align:middle
<c.magenta>迁移到Swift 3名称</c>
<c.magenta>和Swift 3语法</c>

00:25:50.150 --> 00:25:51.418 align:middle
<c.magenta>这涉及很多变化</c>

00:25:52.286 --> 00:25:54.321 align:middle
<c.magenta>但这些工具可以帮助你</c>
<c.magenta>渡过难关</c>

00:25:54.388 --> 00:25:56.123 align:middle
<c.magenta>适应Swift 3下的工作</c>

00:25:57.090 --> 00:25:59.493 align:middle
<c.magenta>Swift 3迁移器</c>
<c.magenta>是很棒的工具</c>

00:25:59.726 --> 00:26:02.362 align:middle
<c.magenta>但它不能迁移</c>
<c.magenta>你的肌肉记忆</c>

00:25:59.726 --> 00:26:02.362 align:middle
<c.magenta>但它不能迁移</c>
<c.magenta>你的肌肉记忆</c>

00:26:02.863 --> 00:26:06.600 align:middle
<c.magenta>当然也无法迁移从堆栈溢出</c>
<c.magenta>复制粘贴的所有代码</c>

00:26:09.136 --> 00:26:11.839 align:middle
<c.magenta>所以 Swift编译器</c>
<c.magenta>也可以为你提供帮助</c>

00:26:12.139 --> 00:26:14.508 align:middle
<c.magenta>Swift编译器</c>
<c.magenta>了解所有这些API的</c>

00:26:14.575 --> 00:26:17.344 align:middle line:1
<c.magenta>Swift 2名称</c>
<c.magenta>和Swift 3名称</c>

00:26:17.444 --> 00:26:20.647 align:middle line:1
<c.magenta>所以如果你在一些</c>
<c.magenta>Swift 2代码中编写或复制</c>

00:26:20.814 --> 00:26:24.585 align:middle line:1
<c.magenta>编译器会识别</c>
<c.magenta>旧的API名称并向你提供诊断</c>

00:26:24.651 --> 00:26:27.654 align:middle line:1
<c.magenta>使用Fix-its更新代码</c>
<c.magenta>帮助你快速适应并工作</c>

00:26:28.989 --> 00:26:31.491 align:middle line:1
<c.magenta>此外 我们引入了</c>
<c.magenta>相近差错检测</c>

00:26:31.625 --> 00:26:33.994 align:middle line:1
<c.magenta>在实施可选协议方法时</c>
<c.magenta>可用</c>

00:26:34.094 --> 00:26:36.997 align:middle
<c.magenta>所以 当你在实施</c>
<c.magenta>委托时 这个功能很棒</c>

00:26:37.231 --> 00:26:39.600 align:middle
<c.magenta>你犯了个小错误</c>

00:26:39.666 --> 00:26:41.568 align:middle
<c.magenta>你想要实施的委托方法</c>
<c.magenta>名称错了</c>

00:26:41.668 --> 00:26:44.404 align:middle
<c.magenta>现在你收到警告消息</c>
<c.magenta>附带Fix-it 以便修复名称</c>

00:26:44.705 --> 00:26:47.341 align:middle
<c.magenta>这样你可以放心</c>
<c.magenta>你的方法会被准确调用</c>

00:26:49.877 --> 00:26:52.980 align:middle
<c.magenta>现在 我想将舞台</c>
<c.magenta>交给我的同事Michael</c>

00:26:53.280 --> 00:26:56.950 align:middle
<c.magenta>他将介绍将C和</c>
<c.magenta>Objective-C API映射到Swift</c>

00:27:07.661 --> 00:27:09.062 align:middle
<c.magenta>所以Swift很了不起</c>

00:27:09.296 --> 00:27:12.499 align:middle
<c.magenta>但如果你是</c>
<c.magenta>Objective-C开发者呢？</c>

00:27:12.666 --> 00:27:14.301 align:middle
<c.magenta>或者你的项目是</c>
<c.magenta>混合项目呢？</c>

00:27:14.868 --> 00:27:17.671 align:middle
<c.magenta>所有Objective-C API</c>
<c.magenta>在Swift中都有</c>

00:27:17.771 --> 00:27:18.839 align:middle
<c.magenta>它们一直都在那里</c>

00:27:19.173 --> 00:27:22.643 align:middle
<c.magenta>但正如Doug解释的</c>
<c.magenta>这些API是针对另一种语言设计的</c>

00:27:22.910 --> 00:27:27.347 align:middle
<c.magenta>在Swift中 它们日渐显得</c>
<c.magenta>有点格格不入</c>

00:27:28.348 --> 00:27:30.617 align:middle
<c.magenta>所以今天我将展示</c>
<c.magenta>你将如何控制局面</c>

00:27:30.684 --> 00:27:34.521 align:middle
<c.magenta>使你的Swift用户获得</c>
<c.magenta>应有的优质API</c>

00:27:36.757 --> 00:27:38.926 align:middle
<c.magenta>我会先开始展示</c>
<c.magenta>几个Objective-C API</c>

00:27:38.992 --> 00:27:40.661 align:middle
<c.magenta>它们被导入到了Swift 2中</c>

00:27:41.061 --> 00:27:44.865 align:middle
<c.magenta>这里有两个方法</c>
<c.magenta>saveToURL forSaveOperation</c>

00:27:44.932 --> 00:27:46.967 align:middle
<c.magenta>和revertToContentsOfURL</c>

00:27:47.301 --> 00:27:52.406 align:middle
<c.magenta>不过这些确实没有体现</c>
<c.magenta>Doug介绍的API设计准则</c>

00:27:52.472 --> 00:27:55.175 align:middle
<c.magenta>里面有很多冗余的类型信息</c>

00:27:55.475 --> 00:27:58.979 align:middle
<c.magenta>我们没有有效地利用</c>
<c.magenta>第一参数标签</c>

00:27:59.046 --> 00:28:00.113 align:middle
<c.magenta>第一参数标签</c>

00:27:59.046 --> 00:28:00.113 align:middle
<c.magenta>第一参数标签</c>

00:28:02.082 --> 00:28:04.384 align:middle
<c.magenta>我会先开始介绍</c>
<c.magenta>你在Swift 3编译器中</c>

00:28:04.451 --> 00:28:05.652 align:middle
<c.magenta>自动免费获取的功能</c>

00:28:05.919 --> 00:28:09.489 align:middle
<c.magenta>Swift 3改进了</c>
<c.magenta>Objective-C API的导入方法</c>

00:28:11.425 --> 00:28:15.329 align:middle
<c.magenta>Swift编译器将检查</c>
<c.magenta>方法名并使用语法正确的提示</c>

00:28:15.395 --> 00:28:18.498 align:middle
<c.magenta>以便推断第一参数标签</c>

00:28:23.070 --> 00:28:25.305 align:middle
<c.magenta>Swift编译器</c>
<c.magenta>将检查名称</c>

00:28:25.372 --> 00:28:27.508 align:middle
<c.magenta>从而消除冗余类型信息</c>

00:28:30.477 --> 00:28:33.480 align:middle
<c.magenta>编译器甚至可以推断一般</c>
<c.magenta>Objective-C习惯用语的</c>

00:28:33.547 --> 00:28:36.884 align:middle
<c.magenta>默认参数</c>
<c.magenta>如完成处理程序</c>

00:28:38.085 --> 00:28:39.887 align:middle
<c.magenta>或选项集</c>

00:28:42.155 --> 00:28:47.094 align:middle
<c.magenta>同时 有新的值类型</c>
<c.magenta>如连接到NSURL的URL</c>

00:28:47.461 --> 00:28:50.097 align:middle
<c.magenta>所以导入时</c>
<c.magenta>我们只需直接导入</c>

00:28:53.033 --> 00:28:55.335 align:middle
<c.magenta>要了解这些值类型的</c>
<c.magenta>详细信息 请访问</c>

00:28:55.402 --> 00:28:58.172 align:middle
<c.magenta>今天随后的</c>
<c.magenta>“Swift基础的新特性”</c>

00:29:00.207 --> 00:29:02.276 align:middle
<c.magenta>所以 自动推断非常棒</c>

00:29:02.342 --> 00:29:04.845 align:middle
<c.magenta>但根本上</c>
<c.magenta>它是启发式推动的</c>

00:29:04.978 --> 00:29:07.481 align:middle
<c.magenta>编译器不懂读心术</c>

00:29:07.548 --> 00:29:09.216 align:middle
<c.magenta>它不知道你的意图</c>

00:29:09.483 --> 00:29:12.819 align:middle
<c.magenta>经常</c>
<c.magenta>你需要指定自己的名称</c>

00:29:13.587 --> 00:29:15.289 align:middle
<c.magenta>为此 我们扩展了</c>
<c.magenta>NS Swift名称</c>

00:29:15.355 --> 00:29:17.391 align:middle
<c.magenta>现在 自从Swift 2起</c>
<c.magenta>NS Swift名称就存在了</c>

00:29:17.457 --> 00:29:20.661 align:middle
<c.magenta>但在Swift 3中 我们支持</c>
<c.magenta>完整的复合命名</c>

00:29:21.161 --> 00:29:23.897 align:middle
<c.magenta>复合名称是基名称</c>
<c.magenta>加参数标签</c>

00:29:23.997 --> 00:29:25.799 align:middle
<c.magenta>所以这种情况下</c>
<c.magenta>我们有两个方法</c>

00:29:26.200 --> 00:29:29.269 align:middle
<c.magenta>它们执行语义</c>
<c.magenta>十分相似的操作</c>

00:29:29.369 --> 00:29:32.039 align:middle
<c.magenta>但它们的不同点基本</c>
<c.magenta>在于它们处理参数的方式</c>

00:29:32.105 --> 00:29:34.842 align:middle
<c.magenta>所以在同样的基名称约束下</c>
<c.magenta>我们导入它们</c>

00:29:35.108 --> 00:29:38.712 align:middle
<c.magenta>但我们说我们希望它</c>
<c.magenta>等于此定位标记或</c>

00:29:38.779 --> 00:29:40.447 align:middle
<c.magenta>大于等于此定位标记</c>

00:29:42.683 --> 00:29:45.686 align:middle
<c.magenta>现在方法名可以推动你</c>
<c.magenta>朝向Swifty API行进一大步</c>

00:29:45.853 --> 00:29:47.855 align:middle
<c.magenta>但行进的距离仍然不够远</c>

00:29:48.255 --> 00:29:50.791 align:middle
<c.magenta>这里 我有一些简单的代码</c>
<c.magenta>可以创建标准的</c>

00:29:50.924 --> 00:29:52.259 align:middle
<c.magenta>格利高里日历</c>

00:29:52.793 --> 00:29:56.129 align:middle
<c.magenta>但如果你看一下这个</c>
<c.magenta>这真的不怎么Swifty</c>

00:29:56.797 --> 00:29:59.766 align:middle
<c.magenta>尤其是NSCalendarIdentifierGregorian</c>

00:29:59.967 --> 00:30:02.503 align:middle
<c.magenta>这是个普通的</c>
<c.magenta>字符串全局变量</c>

00:29:59.967 --> 00:30:02.503 align:middle
<c.magenta>这是个普通的</c>
<c.magenta>字符串全局变量</c>

00:30:02.870 --> 00:30:06.306 align:middle
<c.magenta>普通字符串全局变量</c>
<c.magenta>这可不是使用Swift编程的方法</c>

00:30:06.740 --> 00:30:10.677 align:middle
<c.magenta>这就是我们戏谑为</c>
<c.magenta>字符串型API的东西</c>

00:30:11.678 --> 00:30:13.881 align:middle
<c.magenta>而这种API使用字符串</c>

00:30:14.481 --> 00:30:16.183 align:middle
<c.magenta>这一定程度上</c>
<c.magenta>导致简单错误的发生</c>

00:30:16.250 --> 00:30:20.220 align:middle
<c.magenta>没错 故障很简单</c>
<c.magenta>开发者可以马上发现</c>

00:30:20.621 --> 00:30:25.058 align:middle
<c.magenta>但是此API的用户必须</c>
<c.magenta>记得这是什么</c>

00:30:25.125 --> 00:30:27.561 align:middle
<c.magenta>以及这不是</c>
<c.magenta>可以用在这里的有效字符串</c>

00:30:27.628 --> 00:30:30.130 align:middle
<c.magenta>这样对用户造成了</c>
<c.magenta>不必要的认知负担</c>

00:30:31.665 --> 00:30:34.168 align:middle
<c.magenta>所以 为什么这个API是这样的？</c>

00:30:34.601 --> 00:30:38.172 align:middle
<c.magenta>我们都知道为何该API是这样的</c>
<c.magenta>因为它来自Objective-C</c>

00:30:39.106 --> 00:30:41.542 align:middle
<c.magenta>但该API来自</c>
<c.magenta>Objective-C的事实</c>

00:30:41.608 --> 00:30:43.343 align:middle
<c.magenta>这是实施信息</c>

00:30:43.410 --> 00:30:45.913 align:middle
<c.magenta>而这种实施信息泄露了</c>

00:30:46.346 --> 00:30:48.982 align:middle
<c.magenta>在Apple</c>
<c.magenta>我们并不喜欢信息泄露</c>

00:30:51.852 --> 00:30:52.786 align:middle
<c.magenta>要搞清楚哪里出错了</c>

00:30:52.853 --> 00:30:55.222 align:middle
<c.magenta>让我们看一下Objective-C</c>
<c.magenta>API如何映射到Swift的</c>

00:30:55.289 --> 00:30:58.959 align:middle
<c.magenta>我们的全局变量作为</c>
<c.magenta>全局变量进入 当然</c>

00:30:59.426 --> 00:31:01.562 align:middle
<c.magenta>但除了全局变量的</c>
<c.magenta>名称外</c>

00:30:59.426 --> 00:31:01.562 align:middle
<c.magenta>但除了全局变量的</c>
<c.magenta>名称外</c>

00:31:01.828 --> 00:31:02.796 align:middle
<c.magenta>没有什么可以告诉你</c>

00:31:02.863 --> 00:31:07.701 align:middle
<c.magenta>这是针对特别具体的API</c>
<c.magenta>的特别具体的字符串</c>

00:31:08.802 --> 00:31:12.439 align:middle
<c.magenta>现在 我们可以尝试添加</c>
<c.magenta>typedef以试验并暗示我们的意图</c>

00:31:12.773 --> 00:31:14.741 align:middle
<c.magenta>但是typedef</c>
<c.magenta>不过是个类型别名</c>

00:31:14.808 --> 00:31:16.877 align:middle
<c.magenta>它是旧类型的新名称</c>

00:31:17.444 --> 00:31:19.780 align:middle
<c.magenta>所以这实际上</c>
<c.magenta>不能解决这里的问题</c>

00:31:21.348 --> 00:31:23.050 align:middle
<c.magenta>所以 API会是什么模样</c>

00:31:23.116 --> 00:31:25.886 align:middle
<c.magenta>如果我们要在Swift 3中</c>
<c.magenta>重新设计？</c>

00:31:26.653 --> 00:31:30.724 align:middle
<c.magenta>我们可能会在字符串</c>
<c.magenta>周围形成新的包装类型</c>

00:31:30.791 --> 00:31:32.426 align:middle
<c.magenta>从而获取一些强类型</c>

00:31:32.659 --> 00:31:36.263 align:middle
<c.magenta>而这些全局变量</c>
<c.magenta>相反 会是静态属性</c>

00:31:36.330 --> 00:31:39.433 align:middle
<c.magenta>所以在Swift 3中 我们引入了</c>
<c.magenta>仅针对该用例的新属性</c>

00:31:39.700 --> 00:31:43.470 align:middle
<c.magenta>你可以通过NS Extensible</c>
<c.magenta>String Enum访问该属性</c>

00:31:43.570 --> 00:31:45.305 align:middle
<c.magenta>当你想要告诉Swift编译器</c>

00:31:45.372 --> 00:31:48.175 align:middle
<c.magenta>围绕字符串</c>
<c.magenta>形成新的包装类型时</c>

00:31:50.577 --> 00:31:52.713 align:middle
<c.magenta>你可将此添加到typedef</c>

00:31:52.946 --> 00:31:57.284 align:middle line:1
<c.magenta>导入程序将围绕此</c>
<c.magenta>为你创建新类型</c>

00:31:57.451 --> 00:32:00.354 align:middle line:1
<c.magenta>任何此类型的全局变量</c>
<c.magenta>将作为此类型的</c>

00:31:57.451 --> 00:32:00.354 align:middle line:1
<c.magenta>任何此类型的全局变量</c>
<c.magenta>将作为此类型的</c>

00:32:00.420 --> 00:32:03.090 align:middle line:1
<c.magenta>静态属性自动导入</c>

00:32:04.925 --> 00:32:07.294 align:middle line:1
<c.magenta>因为这是可扩展的</c>
<c.magenta>我们在这里选择一个结构</c>

00:32:07.361 --> 00:32:10.297 align:middle line:1
<c.magenta>就是说 其他模块可能</c>
<c.magenta>需要定义自己的结构</c>

00:32:10.564 --> 00:32:13.500 align:middle
<c.magenta>而如果它们定义了 它们</c>
<c.magenta>也将作为静态属性被导入</c>

00:32:13.567 --> 00:32:15.235 align:middle
<c.magenta>到该结构的延伸部分</c>

00:32:18.305 --> 00:32:22.843 align:middle
<c.magenta>现在 在幕后</c>
<c.magenta>Swift编译器会直接将此映射到</c>

00:32:22.910 --> 00:32:24.411 align:middle
<c.magenta>潜在的存储值中</c>

00:32:24.478 --> 00:32:27.281 align:middle
<c.magenta>意味着这其中没有</c>
<c.magenta>额外的经费或装箱</c>

00:32:27.381 --> 00:32:29.349 align:middle
<c.magenta>或中间过程</c>

00:32:33.720 --> 00:32:35.389 align:middle
<c.magenta>所以 让我们关注使用站点</c>

00:32:35.455 --> 00:32:38.792 align:middle
<c.magenta>因为好的API设计</c>
<c.magenta>始终关注使用站点</c>

00:32:39.359 --> 00:32:40.394 align:middle
<c.magenta>过去如此...</c>

00:32:41.828 --> 00:32:42.796 align:middle
<c.magenta>以后也如此</c>

00:32:42.996 --> 00:32:44.865 align:middle
<c.magenta>因为类型语境更清楚</c>

00:32:44.965 --> 00:32:47.501 align:middle
<c.magenta>我们甚至可以</c>
<c.magenta>只是说“.gregorian”</c>

00:32:57.578 --> 00:33:00.714 align:middle
<c.magenta>下次 我会自己</c>
<c.magenta>开始领头鼓掌</c>

00:32:57.578 --> 00:33:00.714 align:middle
<c.magenta>下次 我会自己</c>
<c.magenta>开始领头鼓掌</c>

00:33:03.817 --> 00:33:07.921 align:middle
<c.magenta>同样 在Swift 3 NSCalendar中</c>
<c.magenta>现在 它作为日历为我们所知</c>

00:33:07.988 --> 00:33:10.657 align:middle
<c.magenta>这是个小改进</c>

00:33:10.824 --> 00:33:16.230 align:middle
<c.magenta>所以 我们有方法名</c>
<c.magenta>以及类型</c>

00:33:16.430 --> 00:33:17.464 align:middle
<c.magenta>我们还有什么？</c>

00:33:18.165 --> 00:33:21.235 align:middle
<c.magenta>好 我们有大象</c>

00:33:22.636 --> 00:33:25.305 align:middle
<c.magenta>就是说 我们在屋内</c>
<c.magenta>有大象</c>

00:33:26.540 --> 00:33:28.876 align:middle
<c.magenta>我们一直假装看不见它</c>

00:33:28.942 --> 00:33:30.711 align:middle
<c.magenta>但它始终在那里</c>

00:33:32.279 --> 00:33:33.413 align:middle
<c.magenta>它就是C</c>

00:33:35.249 --> 00:33:39.353 align:middle
<c.magenta>现在 通过Objective-C</c>
<c.magenta>API已经面向对象了</c>

00:33:39.419 --> 00:33:43.223 align:middle
<c.magenta>所以导入时 我们只需</c>
<c.magenta>更改几个字符串 添加几个类型</c>

00:33:43.290 --> 00:33:44.691 align:middle
<c.magenta>这相对简单</c>

00:33:44.758 --> 00:33:46.293 align:middle
<c.magenta>但是C呢？</c>

00:33:47.427 --> 00:33:49.630 align:middle
<c.magenta>我将主要介绍核心图像</c>

00:33:50.097 --> 00:33:52.999 align:middle
<c.magenta>现在 核心图像</c>
<c.magenta>是一种非常流行的API</c>

00:33:53.066 --> 00:33:54.935 align:middle
<c.magenta>基本每个Swift应用都会用</c>

00:33:55.202 --> 00:34:00.340 align:middle
<c.magenta>这是一种强大的API</c>
<c.magenta>但它的外观和感觉都像C</c>

00:33:55.202 --> 00:34:00.340 align:middle
<c.magenta>这是一种强大的API</c>
<c.magenta>但它的外观和感觉都像C</c>

00:34:01.675 --> 00:34:02.876 align:middle
<c.magenta>让我们从一些代码开始</c>

00:34:02.943 --> 00:34:04.211 align:middle
<c.magenta>我这里有两个函数</c>

00:34:04.344 --> 00:34:06.113 align:middle
<c.magenta>第一个转换 嗯...</c>

00:34:07.114 --> 00:34:09.750 align:middle
<c.magenta>进行转换并旋转特定偏移量</c>

00:34:10.350 --> 00:34:12.953 align:middle
<c.magenta>第二个函数跟踪红色路径</c>

00:34:13.320 --> 00:34:15.255 align:middle
<c.magenta>现在 两个函数</c>
<c.magenta>都不怎么复杂</c>

00:34:15.322 --> 00:34:16.757 align:middle
<c.magenta>而且细节并不重要</c>

00:34:16.889 --> 00:34:18.859 align:middle
<c.magenta>但我只是想看看</c>
<c.magenta>这看起来怎么样？</c>

00:34:18.926 --> 00:34:19.893 align:middle
<c.magenta>感觉如何？</c>

00:34:19.993 --> 00:34:21.728 align:middle
<c.magenta>继续 等等</c>

00:34:25.264 --> 00:34:28.268 align:middle
<c.magenta>所以 如果你注意</c>
<c.magenta>你会发现代码完全充斥着</c>

00:34:28.335 --> 00:34:30.603 align:middle
<c.magenta>全局变量和全局函数</c>

00:34:30.871 --> 00:34:33.340 align:middle
<c.magenta>当然 我们不怎么喜欢</c>
<c.magenta>全局函数</c>

00:34:34.107 --> 00:34:36.009 align:middle
<c.magenta>或全局变量</c>

00:34:37.844 --> 00:34:41.815 align:middle
<c.magenta>所以我们怎么拿到</c>
<c.magenta>一个这样的API</c>

00:34:42.149 --> 00:34:43.583 align:middle
<c.magenta>然后使它变Swifty？</c>

00:34:43.650 --> 00:34:45.918 align:middle
<c.magenta>我们如何使它有Swifty的感觉？</c>

00:34:47.087 --> 00:34:50.690 align:middle
<c.magenta>好 为此 我们再次看一下</c>
<c.magenta>NS Swift名称</c>

00:34:50.858 --> 00:34:55.529 align:middle
<c.magenta>你可以使用NS Swift</c>
<c.magenta>Name将全局作为类型成员导入</c>

00:34:56.362 --> 00:34:58.932 align:middle line:1
<c.magenta>让我从全局变量开始</c>
<c.magenta>向你展示我的意思</c>

00:34:59.666 --> 00:35:01.702 align:middle line:1
<c.magenta>在这里 顶部</c>
<c.magenta>有C的定义</c>

00:34:59.666 --> 00:35:01.702 align:middle line:1
<c.magenta>在这里 顶部</c>
<c.magenta>有C的定义</c>

00:35:02.169 --> 00:35:04.071 align:middle line:1
<c.magenta>下面是生成的</c>
<c.magenta>Swift界面</c>

00:35:04.137 --> 00:35:05.806 align:middle line:1
<c.magenta>下面是Swift使用站点</c>

00:35:05.873 --> 00:35:07.474 align:middle line:1
<c.magenta>将重点关注Swift使用站点</c>

00:35:07.541 --> 00:35:09.276 align:middle line:1
<c.magenta>并改进Swift使用站点</c>

00:35:10.277 --> 00:35:14.381 align:middle line:1
<c.magenta>我们添加NS Swift名称</c>
<c.magenta>并使用typename.membername</c>

00:35:14.448 --> 00:35:20.020 align:middle line:1
<c.magenta>从而告知Swift编译器</c>
<c.magenta>应将kCGColorWhite</c>

00:35:20.087 --> 00:35:22.890 align:middle line:1
<c.magenta>作为CGColor上的</c>
<c.magenta>静态属性导入</c>

00:35:23.190 --> 00:35:27.895 align:middle line:1
<c.magenta>当然 Swift使用站点现在</c>
<c.magenta>可以使用正确嵌套的属性</c>

00:35:35.536 --> 00:35:37.504 align:middle
<c.magenta>当然 如果类型语境清楚</c>

00:35:37.671 --> 00:35:39.673 align:middle
<c.magenta>用户甚至可以略去CGColor</c>

00:35:41.909 --> 00:35:44.278 align:middle
<c.magenta>新的核心图像有很多不同的全局函数</c>

00:35:44.344 --> 00:35:46.880 align:middle line:1
<c.magenta>可以创建不同类型的</c>
<c.magenta>CG Affine Transform</c>

00:35:46.947 --> 00:35:48.916 align:middle line:1
<c.magenta>这是CGAffineTransform</c>
<c.magenta>MakeTranslation</c>

00:35:48.982 --> 00:35:51.485 align:middle line:1
<c.magenta>以及CGAffineTransform</c>
<c.magenta>MakeRotation在所有这些上面</c>

00:35:51.552 --> 00:35:53.754 align:middle line:1
<c.magenta>但在Swift中</c>
<c.magenta>我们更喜欢初始值设定项</c>

00:35:53.820 --> 00:35:57.591 align:middle line:1
<c.magenta>所以我们使用TypeName.Init</c>
<c.magenta>并提供参数标签</c>

00:35:57.658 --> 00:35:59.159 align:middle line:1
<c.magenta>以便告知Swift编译器</c>

00:35:59.226 --> 00:36:01.495 align:middle line:1
<c.magenta>这应该只是一个</c>
<c.magenta>初始值设定项</c>

00:35:59.226 --> 00:36:01.495 align:middle line:1
<c.magenta>这应该只是一个</c>
<c.magenta>初始值设定项</c>

00:36:01.962 --> 00:36:03.730 align:middle line:1
<c.magenta>我们使用参数标签</c>

00:36:03.797 --> 00:36:06.333 align:middle line:1
<c.magenta>以便明确参数的角色</c>

00:36:09.336 --> 00:36:11.872 align:middle line:1
<c.magenta>你也可以作为</c>
<c.magenta>实例成员导入</c>

00:36:12.239 --> 00:36:14.675 align:middle line:1
<c.magenta>使用特殊参数标签self</c>

00:36:14.741 --> 00:36:16.810 align:middle line:1
<c.magenta>以告知Swift编译器</c>

00:36:16.877 --> 00:36:18.712 align:middle line:1
<c.magenta>将参照self</c>
<c.magenta>插到什么参数中</c>

00:36:20.147 --> 00:36:24.551 align:middle line:1
<c.magenta>所以现在CGContextFillPath</c>
<c.magenta>仅仅是一种方法填充路径</c>

00:36:24.918 --> 00:36:26.587 align:middle line:1
<c.magenta>当然</c>
<c.magenta>Swift使用站点</c>

00:36:27.421 --> 00:36:28.956 align:middle line:1
<c.magenta>只是像是方法一样调用它</c>

00:36:35.863 --> 00:36:37.865 align:middle
<c.magenta>编译器将获取</c>
<c.magenta>圆点左边的内容</c>

00:36:37.931 --> 00:36:41.702 align:middle
<c.magenta>将其插入相应的参数位置</c>

00:36:41.802 --> 00:36:43.570 align:middle
<c.magenta>就按照特殊参数标签self指示</c>

00:36:45.672 --> 00:36:46.940 align:middle
<c.magenta>我们可编写更复杂的代码</c>

00:36:47.274 --> 00:36:50.310 align:middle line:1
<c.magenta>你可以在Swift名称前</c>
<c.magenta>加上接受方或设置方</c>

00:36:50.377 --> 00:36:53.113 align:middle line:1
<c.magenta>告诉编译器将此函数</c>

00:36:53.180 --> 00:36:55.716 align:middle line:1
<c.magenta>作为计算的属性导入</c>
<c.magenta>接受方或设置方</c>

00:36:56.316 --> 00:36:57.918 align:middle line:1
<c.magenta>ArtistGetName</c>

00:36:57.985 --> 00:37:01.021 align:middle line:1
<c.magenta>ArtistSetName现在就是</c>

00:36:57.985 --> 00:37:01.021 align:middle line:1
<c.magenta>ArtistSetName现在就是</c>

00:37:01.088 --> 00:37:02.956 align:middle line:1
<c.magenta>计算属性Artist接受和设置方</c>

00:37:04.224 --> 00:37:05.926 align:middle
<c.magenta>让我们关注使用站点</c>

00:37:06.059 --> 00:37:09.196 align:middle
<c.magenta>因为好的API设计</c>
<c.magenta>始终关注使用站点</c>

00:37:09.530 --> 00:37:11.865 align:middle
<c.magenta>以前 我们会使用</c>
<c.magenta>全局函数</c>

00:37:11.932 --> 00:37:13.667 align:middle
<c.magenta>记住艺术家曾用名</c>

00:37:13.800 --> 00:37:16.370 align:middle
<c.magenta>并使用另一个全局函数</c>
<c.magenta>设置新名称</c>

00:37:18.238 --> 00:37:22.009 align:middle
<c.magenta>现在 我们的用户可以</c>
<c.magenta>直接使用计算的属性</c>

00:37:23.143 --> 00:37:26.613 align:middle
<c.magenta>所有情况下</c>
<c.magenta>经费成本都是零</c>

00:37:26.680 --> 00:37:29.783 align:middle
<c.magenta>编译器看到myArtist.Name时</c>
<c.magenta>就会将其</c>

00:37:29.850 --> 00:37:32.052 align:middle
<c.magenta>直接映射到相应的</c>
<c.magenta>C函数</c>

00:37:32.186 --> 00:37:35.589 align:middle
<c.magenta>而不调用任何包装</c>
<c.magenta>或中介或覆盖</c>

00:37:37.824 --> 00:37:40.627 align:middle
<c.magenta>你也可以使用</c>
<c.magenta>NS Swift名称嵌套类型</c>

00:37:40.961 --> 00:37:44.498 align:middle
<c.magenta>还记得先前</c>
<c.magenta>我们创建了新的标识符类型吗？</c>

00:37:47.768 --> 00:37:50.170 align:middle line:1
<c.magenta>好 你可以使用typeName</c>

00:37:50.604 --> 00:37:52.105 align:middle line:1
<c.magenta>好 成员名称</c>

00:37:52.172 --> 00:37:54.074 align:middle line:1
<c.magenta>嵌套类型名称</c>
<c.magenta>从而嵌套类型名称</c>

00:37:54.341 --> 00:37:57.311 align:middle line:1
<c.magenta>所以 这种情况下</c>
<c.magenta>我们得到了Calendar.Identifier</c>

00:38:06.019 --> 00:38:08.689 align:middle
<c.magenta>现在 我们喜欢</c>
<c.magenta>新的NS Swift名称</c>

00:38:11.291 --> 00:38:13.160 align:middle
<c.magenta>我们这么喜欢它</c>

00:38:14.328 --> 00:38:19.099 align:middle
<c.magenta>以致于我们完全</c>
<c.magenta>彻底发狂了</c>

00:38:27.908 --> 00:38:29.543 align:middle
<c.magenta>这里不要鼓掌</c>

00:38:31.778 --> 00:38:35.649 align:middle
<c.magenta>仅在核心图像中</c>

00:38:35.816 --> 00:38:38.385 align:middle
<c.magenta>我们就将它用在</c>
<c.magenta>超过600个API中 600个</c>

00:38:38.986 --> 00:38:40.120 align:middle
<c.magenta>现在可以鼓掌了</c>

00:38:43.857 --> 00:38:44.958 align:middle
<c.magenta>这确实很疯狂</c>

00:38:45.726 --> 00:38:48.028 align:middle
<c.magenta>那么 让我们再看看</c>
<c.magenta>之前的代码</c>

00:38:48.395 --> 00:38:50.230 align:middle
<c.magenta>之前 我们的全局变量</c>

00:38:50.297 --> 00:38:54.101 align:middle
<c.magenta>全局得非常痛苦</c>
<c.magenta>现在它成为成员了</c>

00:38:54.168 --> 00:38:56.136 align:middle
<c.magenta>而且因为类型语境</c>
<c.magenta>更清楚了</c>

00:38:56.203 --> 00:38:58.172 align:middle
<c.magenta>我们甚至可以略去类型名称</c>

00:39:00.674 --> 00:39:04.344 align:middle
<c.magenta>我们的全局函数</c>
<c.magenta>现在是方法</c>

00:39:11.051 --> 00:39:14.054 align:middle
<c.magenta>实际上 现在我看着这个</c>
<c.magenta>我觉得代码更简单了</c>

00:39:14.121 --> 00:39:16.190 align:middle
<c.magenta>我们不需要额外的变量结果</c>

00:39:17.524 --> 00:39:18.926 align:middle
<c.magenta>所以现在代码读起来...</c>

00:39:24.064 --> 00:39:26.767 align:middle
<c.magenta>读起来非常美</c>
<c.magenta>自然又Swifty</c>

00:39:26.834 --> 00:39:28.302 align:middle
<c.magenta>我们获取转换</c>

00:39:28.368 --> 00:39:29.403 align:middle
<c.magenta>进行翻译</c>

00:39:29.469 --> 00:39:31.471 align:middle
<c.magenta>进行旋转</c>
<c.magenta>然后翻译回去</c>

00:39:31.538 --> 00:39:32.372 align:middle
<c.magenta>非常简单</c>

00:39:32.840 --> 00:39:33.674 align:middle
<c.magenta>继续</c>

00:39:33.740 --> 00:39:35.742 align:middle line:1
<c.magenta>CGColorCreateGenericRGB</c>

00:39:35.809 --> 00:39:39.513 align:middle line:1
<c.magenta>以及所有其他很多很多</c>
<c.magenta>创建颜色的方法</c>

00:39:40.214 --> 00:39:43.450 align:middle line:1
<c.magenta>这些现在是</c>
<c.magenta>带有参数标签的初始值设定项</c>

00:39:43.517 --> 00:39:45.853 align:middle line:1
<c.magenta>当然 先别鼓掌</c>

00:39:45.919 --> 00:39:49.990 align:middle line:1
<c.magenta>而且 当然</c>
<c.magenta>CGContextAddPathContextPath</c>

00:39:50.057 --> 00:39:52.192 align:middle line:1
<c.magenta>以及所有其它疯狂冗余的东西</c>

00:39:53.327 --> 00:39:54.928 align:middle line:1
<c.magenta>它们现在都是方法</c>

00:40:01.902 --> 00:40:03.837 align:middle
<c.magenta>我们希望</c>
<c.magenta>你们喜欢这些新的API</c>

00:40:04.304 --> 00:40:09.409 align:middle
<c.magenta>所以 总结下 首先我们</c>
<c.magenta>展示了Swift中新的API设计准则</c>

00:40:09.676 --> 00:40:12.746 align:middle
<c.magenta>好的API设计</c>
<c.magenta>始终关注使用站点</c>

00:40:13.180 --> 00:40:15.849 align:middle
<c.magenta>第二 我们了解了</c>
<c.magenta>Grand Renaming</c>

00:40:15.916 --> 00:40:19.419 align:middle
<c.magenta>也是我们熟悉的：</c>
<c.magenta>“哦 不！什么都变了”</c>

00:40:19.620 --> 00:40:21.622 align:middle
<c.magenta>但是别慌</c>
<c.magenta>一切还好</c>

00:40:21.688 --> 00:40:24.024 align:middle
<c.magenta>名称改进了</c>
<c.magenta>代码更清楚了</c>

00:40:24.091 --> 00:40:25.592 align:middle
<c.magenta>你得到迁移工具了</c>

00:40:25.792 --> 00:40:27.794 align:middle
<c.magenta>最后我们介绍了</c>
<c.magenta>Swift编译器的新功能</c>

00:40:27.861 --> 00:40:31.732 align:middle
<c.magenta>以便于你拥有自己的</c>
<c.magenta>Great Renaming</c>

00:40:33.367 --> 00:40:36.336 align:middle
<c.magenta>要了解更多信息</c>
<c.magenta>请访问该站点页面</c>

00:40:36.403 --> 00:40:39.840 align:middle
<c.magenta>网址为developer.apple.com</c>
<c.magenta>并浏览Swift.org</c>

00:40:39.907 --> 00:40:42.009 align:middle
<c.magenta>开源Swift项目的主页上</c>

00:40:42.075 --> 00:40:44.211 align:middle
<c.magenta>你可以看到Swift的所有演变</c>

00:40:44.278 --> 00:40:46.013 align:middle
<c.magenta>我也显示了核心图像</c>

00:40:46.079 --> 00:40:48.849 align:middle
<c.magenta>不过Grand Central Dispatch</c>
<c.magenta>有自己的Great Renaming</c>

00:40:48.916 --> 00:40:51.251 align:middle
<c.magenta>使用的方法</c>
<c.magenta>跟我今天展示的很多相同</c>

00:40:51.318 --> 00:40:55.088 align:middle
<c.magenta>所以 星期五</c>
<c.magenta>请关注Swift 3中</c>

00:40:55.155 --> 00:40:57.457 align:middle
<c.magenta>使用Grand Central Dispatch技术的</c>
<c.magenta>并发程序设计</c>

00:40:57.524 --> 00:40:58.358 align:middle
<c.magenta>星期五</c>
