WEBVTT

00:00:19.920 --> 00:00:23.557
<c.magenta>Cocoa的新特性</c>

00:00:26.326 --> 00:00:27.261
<c.magenta>上午好</c>

00:00:27.895 --> 00:00:29.096
<c.magenta>我叫Ali Ozer</c>

00:00:29.329 --> 00:00:30.731
<c.magenta>我和我的同事们</c>

00:00:31.431 --> 00:00:32.366
<c.magenta>谢谢</c>

00:00:35.269 --> 00:00:37.905
<c.magenta>我和我的同事Raleigh Ledet</c>
<c.magenta>还有Taylor Kelly</c>

00:00:37.971 --> 00:00:40.073
<c.magenta>来自Cocoa框架团队</c>
<c.magenta>将给大家讲讲</c>

00:00:40.140 --> 00:00:41.808
<c.magenta>今年Cocoa的新特性</c>

00:00:42.743 --> 00:00:44.011
<c.magenta>我们的议程非常简单</c>

00:00:44.077 --> 00:00:46.880
<c.magenta>首先 继AppKit和</c>
<c.magenta>Foundation新特性</c>

00:00:46.947 --> 00:00:48.182
<c.magenta>之后的API更新</c>

00:00:49.683 --> 00:00:53.954
<c.magenta>关于API更新方面</c>
<c.magenta>我想跟大家讲讲</c>

00:00:54.021 --> 00:00:55.556
<c.magenta>我们主要有两类API更新</c>

00:00:55.622 --> 00:00:58.959
<c.magenta>第一 由于新Swift API指南</c>
<c.magenta>导致的API更新</c>

00:00:59.359 --> 00:01:02.062
<c.magenta>第二 我们做的一些常用API改良</c>

00:00:59.359 --> 00:01:02.062
<c.magenta>第二 我们做的一些常用API改良</c>

00:01:02.362 --> 00:01:03.430
<c.magenta>让我们开始吧</c>

00:01:04.897 --> 00:01:07.634
<c.magenta>无论你昨天是否听过</c>

00:01:07.701 --> 00:01:11.338
<c.magenta>今天上午 我们有关于</c>
<c.magenta>Swift新API设计指南</c>

00:01:11.538 --> 00:01:13.774
<c.magenta>并且这些指南包含Cocoa约定和实践</c>

00:01:13.841 --> 00:01:17.377
<c.magenta>我不过是要</c>
<c.magenta>提醒你这些东西是什么</c>

00:01:18.078 --> 00:01:20.414
<c.magenta>使用清晰和一致性命名</c>

00:01:20.848 --> 00:01:24.318
<c.magenta>追求流畅的使用</c>
<c.magenta>大家都知道 调用的地方读起来</c>

00:01:24.384 --> 00:01:26.854
<c.magenta>应该像英文短句</c>
<c.magenta>命名增强</c>

00:01:26.920 --> 00:01:30.457
<c.magenta>和不可变方法保持对应一致</c>
<c.magenta>sort与sorted</c>

00:01:30.524 --> 00:01:33.694
<c.magenta>append与appending</c>
<c.magenta>还有避免缩写</c>

00:01:33.760 --> 00:01:36.563
<c.magenta>这些都是我们多年来使用的主要指南</c>

00:01:36.630 --> 00:01:39.066
<c.magenta>我们把它写成文档</c>

00:01:39.132 --> 00:01:41.235
<c.magenta>在以前WWDC大会上</c>
<c.magenta>我们也讲过</c>

00:01:41.301 --> 00:01:42.903
<c.magenta>正如这次演讲你看到的一样</c>

00:01:43.504 --> 00:01:45.772
<c.magenta>现在我们把这些指南做了更新</c>

00:01:45.839 --> 00:01:49.109
<c.magenta>使用了Swift的特性 比如强类型</c>

00:01:49.176 --> 00:01:51.645
<c.magenta>类型推断 还有重载</c>

00:01:51.712 --> 00:01:54.681
<c.magenta>并且确保我们的API</c>
<c.magenta>在Swift中能表现出来</c>

00:01:54.748 --> 00:01:57.084
<c.magenta>我来讲下API中的一些关键不同点</c>

00:01:57.150 --> 00:01:58.819
<c.magenta>由于这些改变的结果</c>

00:01:59.386 --> 00:02:02.523
<c.magenta>一方面 我们消除了重复和</c>
<c.magenta>不必要的单词</c>

00:01:59.386 --> 00:02:02.523
<c.magenta>一方面 我们消除了重复和</c>
<c.magenta>不必要的单词</c>

00:02:02.589 --> 00:02:05.492
<c.magenta>显然使我们的API更加敏捷</c>

00:02:05.559 --> 00:02:06.693
<c.magenta>你昨天可能听了</c>

00:02:06.760 --> 00:02:08.095
<c.magenta>昨天有个例子</c>

00:02:08.161 --> 00:02:11.098
<c.magenta>如Chris Lattner</c>
<c.magenta>关于“详情咨文”的部分</c>

00:02:11.164 --> 00:02:14.735
<c.magenta>这里有另外一个例子</c>
<c.magenta>contacts.arrayByAddingObject</c>

00:02:14.801 --> 00:02:18.906
<c.magenta>比如这样的一个方法调用</c>
<c.magenta>“数组”和</c>

00:02:18.972 --> 00:02:21.341
<c.magenta>“对象”并不能</c>
<c.magenta>真实反应这个调用</c>

00:02:21.675 --> 00:02:25.245
<c.magenta>所以这个名字现在改成了</c>
<c.magenta>contacts.adding(person)</c>

00:02:26.713 --> 00:02:29.349
<c.magenta>在NSColor这个类上</c>
<c.magenta>还有另外一个例子</c>

00:02:29.950 --> 00:02:33.453
<c.magenta>NSColor.blueColor</c>
<c.magenta>我们现在NSColor类上</c>

00:02:33.520 --> 00:02:34.922
<c.magenta>Blue已经是一个颜色了</c>

00:02:34.988 --> 00:02:37.424
<c.magenta>color这个单词其实在</c>
<c.magenta>这调用中不需添加</c>

00:02:37.791 --> 00:02:38.892
<c.magenta>所以在新的指南中</c>

00:02:38.959 --> 00:02:40.961
<c.magenta>它将变成NSColor.blue</c>

00:02:41.795 --> 00:02:44.431
<c.magenta>不过需要注意的是我们仍然追求清晰</c>

00:02:44.498 --> 00:02:47.901
<c.magenta>这是NSColor另一方法</c>
<c.magenta>NSColor.textColor</c>

00:02:48.902 --> 00:02:51.605
<c.magenta>文本本质上不是一个颜色</c>
<c.magenta>其实</c>

00:02:51.672 --> 00:02:54.975
<c.magenta>谈论文本的颜色可能会产生混乱</c>

00:02:55.409 --> 00:02:58.979
<c.magenta>文本是代表颜色的RGB值</c>
<c.magenta>还是其它的？</c>

00:02:59.413 --> 00:03:01.715
<c.magenta>所以在此案例中 我们没改变这个方法</c>

00:02:59.413 --> 00:03:01.715
<c.magenta>所以在此案例中 我们没改变这个方法</c>

00:03:01.782 --> 00:03:04.051
<c.magenta>还是作为</c>
<c.magenta>NSColor.textColor</c>

00:03:04.151 --> 00:03:05.452
<c.magenta>跟它之前一样</c>

00:03:08.488 --> 00:03:12.593
<c.magenta>另外一些关键变化是类型的利用</c>

00:03:13.660 --> 00:03:17.497
<c.magenta>这里有个例子</c>
<c.magenta>document.readFromURL ofType</c>

00:03:18.498 --> 00:03:22.402
<c.magenta>现在这个API将变成</c>
<c.magenta>document.readFrom ofType</c>

00:03:22.769 --> 00:03:26.540
<c.magenta>你会注意到我们移除了</c>
<c.magenta>这个单词... URL</c>

00:03:26.640 --> 00:03:27.908
<c.magenta>从我们的方法签名中</c>

00:03:27.975 --> 00:03:31.411
<c.magenta>那是因为第一个参数的类型就是URL</c>

00:03:31.478 --> 00:03:34.214
<c.magenta>根据类型推断</c>
<c.magenta>Swift知道该如何去处理它</c>

00:03:34.281 --> 00:03:35.449
<c.magenta>通过移除这个单词</c>

00:03:35.516 --> 00:03:38.352
<c.magenta>其实在NSDocument上</c>
<c.magenta>现有三个阅读方法</c>

00:03:38.819 --> 00:03:42.589
<c.magenta>他们都准确的命名了同样一件事</c>
<c.magenta>从ofType读取</c>

00:03:42.656 --> 00:03:45.459
<c.magenta>并且它是作为第一个参数</c>
<c.magenta>第一个参数的类型</c>

00:03:45.526 --> 00:03:47.828
<c.magenta>URL 数据</c>
<c.magenta>或者FileWrapper</c>

00:03:47.895 --> 00:03:50.497
<c.magenta>把它们区分开来</c>

00:03:51.698 --> 00:03:54.401
<c.magenta>现在这需要注意的一件事情就是利用</c>

00:03:54.468 --> 00:03:55.602
<c.magenta>第一个参数</c>

00:03:56.970 --> 00:03:59.907
<c.magenta>这里从此以后就被拉到了括号内</c>

00:04:00.440 --> 00:04:01.909
<c.magenta>我们这样做是基于大量的案例</c>

00:04:01.975 --> 00:04:05.212
<c.magenta>例如 当第一个参数表现成</c>
<c.magenta>介词短语的一部分时</c>

00:04:05.279 --> 00:04:08.515
<c.magenta>我们会把这个短语拉到括号内</c>
<c.magenta>正如你这看到的一样</c>

00:04:08.582 --> 00:04:12.352
<c.magenta>你可以从我们的API中</c>
<c.magenta>看到大量这样的例子</c>

00:04:12.653 --> 00:04:15.622
<c.magenta>可能大家也注意到</c>
<c.magenta>第二个参数ofType</c>

00:04:15.989 --> 00:04:18.725
<c.magenta>我们并没有把类型这个单词</c>
<c.magenta>从API中移除</c>

00:04:18.791 --> 00:04:22.362
<c.magenta>因为这个参数是一个字符串</c>
<c.magenta>而且字符串是弱类型</c>

00:04:22.429 --> 00:04:24.731
<c.magenta>我们其实要一个单词来描述它们的角色</c>

00:04:24.798 --> 00:04:27.901
<c.magenta>而这里的角色就是我们打开的文件类型</c>

00:04:27.968 --> 00:04:30.838
<c.magenta>所以我们在API中</c>
<c.magenta>保留了类型这个单词</c>

00:04:35.042 --> 00:04:38.245
<c.magenta>现在很多框架和</c>
<c.magenta>标准库API都被改变了</c>

00:04:38.312 --> 00:04:40.247
<c.magenta>基于这些新的指南</c>

00:04:40.314 --> 00:04:43.584
<c.magenta>并且把Objective-C</c>
<c.magenta>API映射到</c>

00:04:43.650 --> 00:04:46.887
<c.magenta>Swift的输入者</c>
<c.magenta>也使用了这些新指南</c>

00:04:46.954 --> 00:04:49.623
<c.magenta>不过你可能会注意到有些API</c>
<c.magenta>还需要进一步调教</c>

00:04:49.890 --> 00:04:52.693
<c.magenta>我们已在些API中做了</c>
<c.magenta>如textColor API</c>

00:04:52.759 --> 00:04:54.995
<c.magenta>前面提到过的</c>
<c.magenta>它是一个例外</c>

00:04:55.062 --> 00:04:57.998
<c.magenta>若你在Swift中</c>
<c.magenta>暴露Objective-C API</c>

00:04:58.065 --> 00:05:00.534
<c.magenta>你可能需要使用一些</c>

00:04:58.065 --> 00:05:00.534
<c.magenta>你可能需要使用一些</c>

00:05:00.601 --> 00:05:04.371
<c.magenta>像NS Swift Name</c>
<c.magenta>它可以让你覆盖默认的</c>

00:05:04.438 --> 00:05:05.472
<c.magenta>输入者做的事情</c>

00:05:06.039 --> 00:05:08.208
<c.magenta>大家知道移植器转换你的——</c>

00:05:08.275 --> 00:05:10.544
<c.magenta>移植器可将你现有Swift 2代码</c>

00:05:10.611 --> 00:05:14.515
<c.magenta>转换成Swift 3并且</c>
<c.magenta>它还会帮你使用这些新命名</c>

00:05:14.581 --> 00:05:16.116
<c.magenta>在你现有的代码中 当然</c>

00:05:16.316 --> 00:05:18.719
<c.magenta>Swift API</c>
<c.magenta>设计指南讨论</c>

00:05:18.785 --> 00:05:21.088
<c.magenta>在此之前</c>
<c.magenta>你可以</c>

00:05:21.154 --> 00:05:22.589
<c.magenta>从视频中获取一些细节</c>

00:05:22.656 --> 00:05:24.658
<c.magenta>关于这些指南和它们的影响</c>

00:05:25.759 --> 00:05:29.196
<c.magenta>现在我们已经有很多常用的API改良</c>

00:05:29.263 --> 00:05:32.399
<c.magenta>有些我们已经完成有一段时间了</c>
<c.magenta>有些我们还将继续做</c>

00:05:32.466 --> 00:05:34.101
<c.magenta>我们来快速过一下</c>

00:05:34.168 --> 00:05:35.435
<c.magenta>可空性</c>

00:05:35.502 --> 00:05:38.805
<c.magenta>去年我们已经在这方面做了很多</c>

00:05:38.872 --> 00:05:41.909
<c.magenta>它通常用来声明是否有参数返回值</c>

00:05:41.975 --> 00:05:44.845
<c.magenta>属性可以为空</c>
<c.magenta>或者是否可选</c>

00:05:44.912 --> 00:05:47.347
<c.magenta>今年我们一直在持续完善它</c>

00:05:47.414 --> 00:05:51.018
<c.magenta>例如 该方法在10.11版本中标明</c>

00:05:51.084 --> 00:05:52.719
<c.magenta>返回一个可选值</c>

00:05:52.786 --> 00:05:56.557
<c.magenta>NSMenu中的addItem方法</c>
<c.magenta>但在10.12版本中 它并没有标明</c>

00:05:56.623 --> 00:05:59.526
<c.magenta>返回一个非可选值</c>
<c.magenta>因为我们决定</c>

00:05:59.593 --> 00:06:01.762
<c.magenta>它永远无法真正返回空值</c>
<c.magenta>而且</c>

00:05:59.593 --> 00:06:01.762
<c.magenta>它永远无法真正返回空值</c>
<c.magenta>而且</c>

00:06:01.828 --> 00:06:03.630
<c.magenta>最好由你的代码来反应出来更为适当</c>

00:06:03.697 --> 00:06:04.965
<c.magenta>当然 也更简单一点</c>

00:06:06.166 --> 00:06:09.269
<c.magenta>我们一直在改进属性</c>
<c.magenta>把getter和setter对</c>

00:06:09.336 --> 00:06:11.672
<c.magenta>转换成正规属性</c>

00:06:11.738 --> 00:06:14.441
<c.magenta>今年我们同样在实际中</c>
<c.magenta>使用了Swift的能力</c>

00:06:14.508 --> 00:06:16.176
<c.magenta>来声明类中的属性</c>

00:06:16.543 --> 00:06:19.179
<c.magenta>例如 这是NSWindow中的</c>
<c.magenta>一个新属性</c>

00:06:19.246 --> 00:06:20.814
<c.magenta>你会在后面的演讲中听到这个</c>

00:06:20.881 --> 00:06:22.616
<c.magenta>allowsAutomaticWindowTabbing</c>

00:06:23.150 --> 00:06:26.320
<c.magenta>这是在Swift中</c>
<c.magenta>一个真实类中的属性</c>

00:06:27.120 --> 00:06:28.655
<c.magenta>你还会注意到我们同样有能力</c>

00:06:28.722 --> 00:06:30.157
<c.magenta>在Objective-C中做到这样</c>

00:06:30.224 --> 00:06:32.259
<c.magenta>在Objective-C中</c>
<c.magenta>你也可定义类属性</c>

00:06:32.326 --> 00:06:34.661
<c.magenta>使用语法</c>
<c.magenta>@property class</c>

00:06:34.728 --> 00:06:36.964
<c.magenta>同样特性引入到了</c>
<c.magenta>Objective-C中</c>

00:06:37.030 --> 00:06:38.632
<c.magenta>这确实很酷</c>

00:06:38.699 --> 00:06:42.970
<c.magenta>这有个Core Data的例子</c>
<c.magenta>NSPersistentStoreCoordinator</c>

00:06:43.036 --> 00:06:46.039
<c.magenta>在10.11版本中 它有这个方法</c>
<c.magenta>registeredStoreTypes</c>

00:06:46.106 --> 00:06:47.774
<c.magenta>现在它被定义成了类的属性</c>

00:06:47.841 --> 00:06:48.942
<c.magenta>它是一个只读属性</c>

00:06:49.009 --> 00:06:51.245
<c.magenta>所以它只有get方法</c>
<c.magenta>正如你这里看到的一样</c>

00:06:51.478 --> 00:06:55.983
<c.magenta>同样在Objective-C</c>
<c.magenta>它也变成了类的属性 如你看到的一样</c>

00:06:58.085 --> 00:06:59.820
<c.magenta>泛型</c>
<c.magenta>我们把它应用到了</c>

00:06:59.887 --> 00:07:02.155
<c.magenta>集合类中</c>
<c.magenta>不过它们真的</c>

00:06:59.887 --> 00:07:02.155
<c.magenta>集合类中</c>
<c.magenta>不过它们真的</c>

00:07:02.222 --> 00:07:03.357
<c.magenta>不仅用于集合</c>

00:07:03.423 --> 00:07:05.425
<c.magenta>它们还用于其它任何地方</c>

00:07:05.492 --> 00:07:07.261
<c.magenta>我敢肯定 你已经意识到了</c>

00:07:07.728 --> 00:07:10.564
<c.magenta>这里有一个Core Data</c>
<c.magenta>NSFetchRequest的例子</c>

00:07:11.632 --> 00:07:14.301
<c.magenta>这里是10.11版本中定义的方式</c>
<c.magenta>非常简单</c>

00:07:14.368 --> 00:07:16.436
<c.magenta>在10.12中 我们前进了一步</c>

00:07:16.503 --> 00:07:19.239
<c.magenta>添加了一个</c>
<c.magenta>ResultType类型参数</c>

00:07:19.306 --> 00:07:23.076
<c.magenta>我们同样在其它一些API中</c>
<c.magenta>添加了一些东西</c>

00:07:23.143 --> 00:07:24.444
<c.magenta>如这execute方法</c>

00:07:24.511 --> 00:07:27.814
<c.magenta>返回一个这种结果类型的数组</c>

00:07:27.881 --> 00:07:31.752
<c.magenta>因此 这个用例</c>
<c.magenta>现在就变成这个样了</c>

00:07:31.818 --> 00:07:34.788
<c.magenta>你从一个管理对象获得请求</c>

00:07:34.855 --> 00:07:36.023
<c.magenta>比如员工</c>

00:07:36.290 --> 00:07:38.058
<c.magenta>然后往前继续执行它</c>

00:07:38.125 --> 00:07:40.060
<c.magenta>现在返回值被自动推断为</c>

00:07:40.127 --> 00:07:42.162
<c.magenta>一个员工数组</c>

00:07:42.596 --> 00:07:44.731
<c.magenta>现在这个例子会是这样</c>
<c.magenta>不过我们希望</c>

00:07:44.798 --> 00:07:49.269
<c.magenta>在将来的版本中</c>
<c.magenta>我们可以像这样表达得更干净</c>

00:07:49.336 --> 00:07:50.370
<c.magenta>这确实很酷</c>

00:07:50.437 --> 00:07:53.874
<c.magenta>所以从这两行</c>
<c.magenta>编译器可以推断</c>

00:07:53.941 --> 00:07:56.176
<c.magenta>返回类型是一个被管理了的对象数组</c>

00:07:57.845 --> 00:08:00.314
<c.magenta>我们一直在改进枚举命名</c>

00:07:57.845 --> 00:08:00.314
<c.magenta>我们一直在改进枚举命名</c>

00:08:00.380 --> 00:08:04.184
<c.magenta>来看一个我们在这方面已实施的例子</c>
<c.magenta>NSColorPanelMode</c>

00:08:04.251 --> 00:08:07.287
<c.magenta>变化是——这是一个Swift用例</c>

00:08:07.354 --> 00:08:08.755
<c.magenta>你看它并非很吸引人</c>

00:08:08.822 --> 00:08:12.860
<c.magenta>是因为.NSCrayonModeColorPanel</c>
<c.magenta>非常冗长</c>

00:08:13.560 --> 00:08:17.030
<c.magenta>变化就是我们把通用后缀拉到前面</c>

00:08:17.097 --> 00:08:19.199
<c.magenta>变成前缀</c>
<c.magenta>使得Swift里的名字</c>

00:08:19.266 --> 00:08:20.634
<c.magenta>更清晰一点</c>

00:08:20.701 --> 00:08:22.803
<c.magenta>你知道 出现这点的地方</c>

00:08:22.870 --> 00:08:24.905
<c.magenta>用例就是.crayon</c>

00:08:24.972 --> 00:08:27.241
<c.magenta>这是它之前的样子</c>

00:08:27.441 --> 00:08:29.576
<c.magenta>这是它现在的样子 相当清晰</c>

00:08:31.378 --> 00:08:33.113
<c.magenta>在枚举这一块</c>

00:08:33.179 --> 00:08:35.716
<c.magenta>我们同样对字符串枚举</c>
<c.magenta>做了改进</c>

00:08:35.782 --> 00:08:38.150
<c.magenta>Swift支持字符串值的枚举</c>

00:08:38.217 --> 00:08:41.154
<c.magenta>许多Cocoa API</c>
<c.magenta>都会暴露一组字符串</c>

00:08:41.221 --> 00:08:45.058
<c.magenta>无论打开或者关闭的API</c>
<c.magenta>在我们的API中</c>

00:08:45.125 --> 00:08:47.794
<c.magenta>我们来看一个字符串转换的例子</c>

00:08:48.829 --> 00:08:51.632
<c.magenta>在Swift 2中我们有一堆</c>
<c.magenta>全局常量</c>

00:08:51.999 --> 00:08:54.535
<c.magenta>NSStringTransformLatinToGreek</c>
<c.magenta>等等</c>

00:08:54.601 --> 00:08:56.904
<c.magenta>有一个API</c>
<c.magenta>stringByApplyingTransform</c>

00:08:56.970 --> 00:08:59.573
<c.magenta>把这些字符串作为</c>
<c.magenta>它的第一个参数</c>

00:08:59.773 --> 00:09:01.942
<c.magenta>在Swift 3中</c>
<c.magenta>我们添加了一种新类型</c>

00:08:59.773 --> 00:09:01.942
<c.magenta>在Swift 3中</c>
<c.magenta>我们添加了一种新类型</c>

00:09:02.009 --> 00:09:06.280
<c.magenta>叫StringTransform</c>
<c.magenta>还有一个扩展我们给它定义多种值</c>

00:09:06.346 --> 00:09:07.981
<c.magenta>比如LatinToGreek</c>

00:09:08.048 --> 00:09:10.551
<c.magenta>有API叫</c>
<c.magenta>applyingTransform</c>

00:09:10.617 --> 00:09:15.455
<c.magenta>它第一个参数现在是官方的</c>
<c.magenta>StringTransform</c>

00:09:15.522 --> 00:09:19.293
<c.magenta>所以这个字符串参数现在是</c>
<c.magenta>StringTransform</c>

00:09:19.359 --> 00:09:20.561
<c.magenta>类型更加安全</c>

00:09:21.094 --> 00:09:24.932
<c.magenta>现在 注意这里有一个</c>
<c.magenta>开放式枚举</c>

00:09:24.998 --> 00:09:26.967
<c.magenta>这里面你可以定义</c>
<c.magenta>你自己的值</c>

00:09:28.302 --> 00:09:29.436
<c.magenta>我演示下如何做到这点</c>

00:09:32.005 --> 00:09:33.040
<c.magenta>你可以继续添加一个扩展</c>

00:09:33.106 --> 00:09:36.043
<c.magenta>到StringTransform</c>
<c.magenta>然后定义你自己的类型</c>

00:09:36.109 --> 00:09:40.047
<c.magenta>现在这里的值就是</c>
<c.magenta>ICU库接受的值</c>

00:09:40.113 --> 00:09:41.114
<c.magenta>用于做转换</c>

00:09:41.181 --> 00:09:44.718
<c.magenta>你可以使用任何有效的</c>
<c.magenta>ICU提供的ID</c>

00:09:44.785 --> 00:09:47.020
<c.magenta>它转换成</c>
<c.magenta>一个ICU拥有的需要出版的东西</c>

00:09:47.087 --> 00:09:49.890
<c.magenta>这些我们API中并不暴露</c>

00:09:50.057 --> 00:09:52.960
<c.magenta>所以 你可以定义你自己的</c>
<c.magenta>出版转换</c>

00:09:53.026 --> 00:09:55.929
<c.magenta>然后把它传给API</c>
<c.magenta>如果它是一个内置的</c>

00:09:58.332 --> 00:10:00.534
<c.magenta>字符串枚举</c>
<c.magenta>同样在Objective-C可以使用</c>

00:09:58.332 --> 00:10:00.534
<c.magenta>字符串枚举</c>
<c.magenta>同样在Objective-C可以使用</c>

00:10:00.601 --> 00:10:04.204
<c.magenta>通过使用这两个宏</c>
<c.magenta>给开放或者封闭式的集合</c>

00:10:04.271 --> 00:10:07.441
<c.magenta>这是添加字符串转换声明的方式</c>

00:10:07.508 --> 00:10:08.809
<c.magenta>在10.11中 那是我们已有的方式</c>

00:10:08.876 --> 00:10:11.078
<c.magenta>在10.12中 有一个新</c>
<c.magenta>字符串转换类型</c>

00:10:11.144 --> 00:10:14.648
<c.magenta>被定义成NS Extensible</c>
<c.magenta>String Enum</c>

00:10:16.984 --> 00:10:19.620
<c.magenta>我们同样使用了Swift能力来改进</c>

00:10:19.686 --> 00:10:24.224
<c.magenta>在一个类型中嵌套声明另一种类型</c>

00:10:24.625 --> 00:10:26.627
<c.magenta>看一个NSData的例子</c>

00:10:26.693 --> 00:10:30.097
<c.magenta>我们有一个可选的集合</c>
<c.magenta>NSDataWritingOptions</c>

00:10:30.163 --> 00:10:34.368
<c.magenta>NSData类有一个API</c>
<c.magenta>writeToURL使用了这个值</c>

00:10:34.768 --> 00:10:38.138
<c.magenta>在Swift 3中</c>
<c.magenta>它变成NSData类</c>

00:10:38.205 --> 00:10:40.774
<c.magenta>嵌套了WritingOptions</c>
<c.magenta>如你在此所见</c>

00:10:42.176 --> 00:10:44.978
<c.magenta>使用这个API实际上是指向</c>

00:10:45.045 --> 00:10:48.315
<c.magenta>WritingOptions显然是</c>
<c.magenta>更加清晰更好作用域</c>

00:10:48.749 --> 00:10:52.419
<c.magenta>除了这些嵌套的改变</c>
<c.magenta>你可能注意到一些其它的东西</c>

00:10:53.720 --> 00:10:55.923
<c.magenta>那就是类型的变化</c>

00:10:55.989 --> 00:11:00.260
<c.magenta>你可能注意到</c>
<c.magenta>我们现在提供了一个空集合默认值</c>

00:10:55.989 --> 00:11:00.260
<c.magenta>你可能注意到</c>
<c.magenta>我们现在提供了一个空集合默认值</c>

00:11:00.327 --> 00:11:03.297
<c.magenta>大多数我们需要传入可选值时</c>

00:11:03.363 --> 00:11:06.366
<c.magenta>意味着我们不在需要传入可选参数了</c>

00:11:07.034 --> 00:11:09.937
<c.magenta>你可能还注意到</c>
<c.magenta>这里NSURL变成了URL</c>

00:11:10.003 --> 00:11:11.104
<c.magenta>你可能已听过这个了</c>

00:11:11.171 --> 00:11:13.440
<c.magenta>不过我们后面还会有</c>
<c.magenta>关于它的更多谈论</c>

00:11:15.108 --> 00:11:18.579
<c.magenta>现在 我离开舞台前的</c>
<c.magenta>最后一个主题是...</c>

00:11:19.713 --> 00:11:20.747
<c.magenta>noescape</c>

00:11:20.814 --> 00:11:23.717
<c.magenta>好的 noescape声明</c>

00:11:23.784 --> 00:11:27.588
<c.magenta>一个闭包的执行</c>
<c.magenta>在函数调用后将不会退出</c>

00:11:27.888 --> 00:11:28.856
<c.magenta>我的意思是什么？</c>

00:11:28.922 --> 00:11:32.059
<c.magenta>这里有一个NSCollection view的方法</c>
<c.magenta>performBatchUpdates</c>

00:11:32.125 --> 00:11:33.894
<c.magenta>它有两个闭包参数</c>

00:11:35.195 --> 00:11:37.364
<c.magenta>你可能注意到了</c>
<c.magenta>第一个参数标记为noescape</c>

00:11:37.431 --> 00:11:39.733
<c.magenta>意思是这个闭包的执行</c>

00:11:39.800 --> 00:11:42.636
<c.magenta>将完成执行</c>

00:11:42.703 --> 00:11:44.404
<c.magenta>在API performBatchUpdates</c>
<c.magenta>方法返回之前</c>

00:11:44.471 --> 00:11:46.773
<c.magenta>第二个参数没有标记为</c>
<c.magenta>noescape</c>

00:11:46.840 --> 00:11:51.044
<c.magenta>意思是这个闭包的执行将可能发生在</c>

00:11:51.111 --> 00:11:52.713
<c.magenta>函数返回之后</c>

00:11:52.779 --> 00:11:53.947
<c.magenta>所以 这对你来说是一个好的暗示</c>

00:11:54.014 --> 00:11:55.682
<c.magenta>同样对编译器也是一个好的暗示</c>

00:11:55.916 --> 00:11:58.151
<c.magenta>这个技巧同样适用于</c>
<c.magenta>Objective-C</c>

00:11:58.218 --> 00:12:00.687
<c.magenta>我们可以使用NS NOESCAPE</c>
<c.magenta>来装饰闭包</c>

00:11:58.218 --> 00:12:00.687
<c.magenta>我们可以使用NS NOESCAPE</c>
<c.magenta>来装饰闭包</c>

00:12:00.754 --> 00:12:01.855
<c.magenta>以达到同样的效果</c>

00:12:02.523 --> 00:12:05.692
<c.magenta>这些就是我们常用API变化的概览</c>

00:12:05.759 --> 00:12:07.561
<c.magenta>现在大家拥有的版本中</c>

00:12:07.628 --> 00:12:09.229
<c.magenta>我们已完成了所有想要做的事情</c>

00:12:09.296 --> 00:12:11.532
<c.magenta>将会有一些字符串枚举变化</c>

00:12:11.598 --> 00:12:14.234
<c.magenta>类属性变化将会在其它版本中出现</c>

00:12:14.301 --> 00:12:16.336
<c.magenta>我们将会应用到更多的API中</c>

00:12:19.806 --> 00:12:21.475
<c.magenta>接着我们来谈谈关于AppKit</c>

00:12:21.542 --> 00:12:25.045
<c.magenta>我将给大家邀请Raleigh</c>
<c.magenta>Ledet上台给大家讲讲</c>

00:12:25.112 --> 00:12:25.946
<c.magenta>谢谢</c>

00:12:30.284 --> 00:12:31.151
<c.magenta>谢谢 Ali</c>

00:12:31.385 --> 00:12:32.386
<c.magenta>大家 上午好</c>

00:12:33.287 --> 00:12:36.423
<c.magenta>大家看到 在过去的一年里</c>
<c.magenta>我们在AppKit上下了很多功夫</c>

00:12:36.723 --> 00:12:40.327
<c.magenta>现在我们深入一下</c>
<c.magenta>来讲讲窗口捕捉</c>

00:12:41.428 --> 00:12:45.165
<c.magenta>当你在macOS Sierra下</c>
<c.magenta>拖动一个窗口</c>

00:12:45.232 --> 00:12:47.634
<c.magenta>当你靠向一个边缘的时候</c>
<c.magenta>将产生边缘粘连</c>

00:12:47.701 --> 00:12:49.736
<c.magenta>还有与另外一个窗口的顶部对齐</c>

00:12:49.803 --> 00:12:51.238
<c.magenta>甚至是在缩放大小的时候</c>

00:12:51.305 --> 00:12:55.108
<c.magenta>所以现在将窗口对齐就简单多了</c>

00:12:55.175 --> 00:12:58.045
<c.magenta>或者以你想要的方式</c>
<c.magenta>来缩放大小</c>

00:12:58.612 --> 00:13:01.515
<c.magenta>我们付出很多努力</c>
<c.magenta>在这里提供摸索</c>

00:12:58.612 --> 00:13:01.515
<c.magenta>我们付出很多努力</c>
<c.magenta>在这里提供摸索</c>

00:13:01.582 --> 00:13:03.984
<c.magenta>来确保我们只提供捕捉行为</c>

00:13:04.151 --> 00:13:07.487
<c.magenta>第一时间推测</c>
<c.magenta>你想对窗口做些什么</c>

00:13:08.288 --> 00:13:10.858
<c.magenta>在你的应用中获取捕捉行为的方式就是</c>

00:13:10.924 --> 00:13:14.027
<c.magenta>让系统来为你处理窗口的拖拽</c>

00:13:14.795 --> 00:13:16.630
<c.magenta>如果你自己跟踪鼠标</c>

00:13:16.697 --> 00:13:18.599
<c.magenta>然后手动控制窗口的位置</c>

00:13:18.665 --> 00:13:21.702
<c.magenta>你将会绕开窗口捕捉</c>
<c.magenta>我们会恰当地放置窗口</c>

00:13:21.768 --> 00:13:24.738
<c.magenta>在这里你要求我们放置它</c>
<c.magenta>正如我们之前的发布</c>

00:13:26.740 --> 00:13:29.443
<c.magenta>如在keynote上看到的</c>
<c.magenta>我们现有了窗口tabbing</c>

00:13:30.410 --> 00:13:34.114
<c.magenta>这是一个TextEdit的例子</c>
<c.magenta>有三个文档tab打开</c>

00:13:34.848 --> 00:13:38.485
<c.magenta>关于窗口tabbing</c>
<c.magenta>其实他们就是多个窗口</c>

00:13:38.819 --> 00:13:42.823
<c.magenta>所以此例中</c>
<c.magenta>有三个tab的TextEdit</c>

00:13:42.890 --> 00:13:44.858
<c.magenta>其实就是三个不同NS窗口支持</c>

00:13:46.093 --> 00:13:49.596
<c.magenta>所以我们做的只是</c>
<c.magenta>对这些当中的每一个窗口</c>

00:13:49.663 --> 00:13:52.366
<c.magenta>只将一个tab设置可见</c>
<c.magenta>就认为是可见</c>

00:13:52.933 --> 00:13:55.269
<c.magenta>若你检查NSWindow</c>
<c.magenta>的.visible属性</c>

00:13:55.335 --> 00:13:56.537
<c.magenta>它将返回真</c>

00:13:57.404 --> 00:14:00.607
<c.magenta>只不过仅有可见的tab</c>
<c.magenta>才正真被渲染到屏幕上</c>

00:13:57.404 --> 00:14:00.607
<c.magenta>只不过仅有可见的tab</c>
<c.magenta>才正真被渲染到屏幕上</c>

00:14:00.807 --> 00:14:03.911
<c.magenta>我们将其它窗口</c>
<c.magenta>隐藏到窗口服务器级别</c>

00:14:03.977 --> 00:14:06.380
<c.magenta>所以它们没有被渲染</c>
<c.magenta>也不占用任何资源</c>

00:14:08.815 --> 00:14:10.651
<c.magenta>而且我们自动处理这些过程</c>

00:14:11.385 --> 00:14:14.054
<c.magenta>那如何给窗口添加</c>
<c.magenta>一个New Tab呢？</c>

00:14:14.688 --> 00:14:17.424
<c.magenta>创建一个新的窗口</c>
<c.magenta>然后将它排到前面</c>

00:14:17.491 --> 00:14:20.060
<c.magenta>然后我们将会继续</c>
<c.magenta>恰当地为你创建一个tab</c>

00:14:20.127 --> 00:14:21.762
<c.magenta>然后放置在窗口中</c>

00:14:22.462 --> 00:14:25.732
<c.magenta>如果你要移除一个tab</c>
<c.magenta>将你的窗口过滤掉</c>

00:14:25.799 --> 00:14:27.568
<c.magenta>然后我们将继续为你移除掉tab</c>

00:14:27.634 --> 00:14:29.136
<c.magenta>这些都是自动玩完成的</c>

00:14:30.704 --> 00:14:32.973
<c.magenta>现在如果用户缩放了窗口</c>
<c.magenta>我们将仅仅</c>

00:14:33.040 --> 00:14:35.442
<c.magenta>缩放与当前激活的tab</c>
<c.magenta>相关联的窗口</c>

00:14:36.143 --> 00:14:37.945
<c.magenta>我们不会花费时间</c>

00:14:38.011 --> 00:14:41.248
<c.magenta>去处理其它窗口</c>
<c.magenta>当用户并不想切换到它们的时候</c>

00:14:41.515 --> 00:14:43.817
<c.magenta>不过当用户要切换到</c>
<c.magenta>其它tab中的某一个时</c>

00:14:43.884 --> 00:14:45.586
<c.magenta>在那时AppKit将会继续</c>

00:14:45.652 --> 00:14:48.722
<c.magenta>适当的缩放窗口</c>
<c.magenta>重新渲染它</c>

00:14:48.789 --> 00:14:51.959
<c.magenta>然后将窗口服务器等级的</c>
<c.magenta>隐藏属性修改</c>

00:14:52.025 --> 00:14:54.461
<c.magenta>所以用户得到的是无缝的体验</c>

00:14:54.528 --> 00:14:57.831
<c.magenta>一个窗口拥有多个tab</c>
<c.magenta>尽管在这背后</c>

00:14:57.898 --> 00:14:59.833
<c.magenta>我们只是处理了三个窗口</c>

00:15:02.236 --> 00:15:05.138
<c.magenta>我想谈一些</c>
<c.magenta>大家需要做的东西</c>

00:15:05.205 --> 00:15:07.374
<c.magenta>当你准备给你的应用采取tab</c>

00:15:07.441 --> 00:15:09.610
<c.magenta>这依赖于你的应用</c>

00:15:09.676 --> 00:15:10.577
<c.magenta>是什么类型</c>

00:15:11.078 --> 00:15:14.181
<c.magenta>如果你有一个例如类似基于</c>
<c.magenta>NSDocument一样的应用</c>

00:15:14.615 --> 00:15:17.284
<c.magenta>或者non-NSDocument</c>
<c.magenta>的应用</c>

00:15:17.651 --> 00:15:18.685
<c.magenta>你需要做些什么</c>

00:15:18.752 --> 00:15:21.221
<c.magenta>如果你已经存在一个tab实现</c>

00:15:21.288 --> 00:15:24.858
<c.magenta>我讲围绕这一节来讲解</c>
<c.magenta>用一些大家可以使用的API</c>

00:15:25.058 --> 00:15:27.227
<c.magenta>在你的应用中去定制tab</c>

00:15:28.929 --> 00:15:31.398
<c.magenta>若是基于NSDocument的应用</c>
<c.magenta>你不需要做什么</c>

00:15:31.465 --> 00:15:34.868
<c.magenta>这基本上是自动的</c>
<c.magenta>其实此处TextEdit</c>

00:15:34.935 --> 00:15:38.172
<c.magenta>我们几乎完全是修改了0行代码</c>
<c.magenta>在TextEdit上</c>

00:15:38.405 --> 00:15:41.375
<c.magenta>它完全支持标签</c>
<c.magenta>而且在这个方框下运行的非常正确</c>

00:15:42.476 --> 00:15:46.280
<c.magenta>若是基于non-NSDocument的应用</c>
<c.magenta>它大部分是自动的</c>

00:15:46.346 --> 00:15:48.348
<c.magenta>不过你可能需要做的是</c>
<c.magenta>开启</c>

00:15:48.415 --> 00:15:51.752
<c.magenta>New Tab按钮</c>
<c.magenta>在你的应用里</c>

00:15:52.186 --> 00:15:54.922
<c.magenta>New Tab按钮</c>
<c.magenta>在这里是一个附加的按钮</c>

00:15:54.988 --> 00:15:56.323
<c.magenta>在所有tab的右边</c>

00:15:57.524 --> 00:16:02.162
<c.magenta>要开启这个按钮 你需要实现</c>
<c.magenta>newWindowForTab NSResponder</c>

00:15:57.524 --> 00:16:02.162
<c.magenta>要开启这个按钮 你需要实现</c>
<c.magenta>newWindowForTab NSResponder</c>

00:16:02.229 --> 00:16:04.932
<c.magenta>在你的NSWindow子类中重写</c>

00:16:04.998 --> 00:16:06.700
<c.magenta>或者在响应链中</c>
<c.magenta>某个更高的地方</c>

00:16:06.767 --> 00:16:09.036
<c.magenta>例如</c>
<c.magenta>NSWindow代理</c>

00:16:09.102 --> 00:16:12.239
<c.magenta>或者NSWindow控制器</c>
<c.magenta>或者NSWindow文档</c>

00:16:12.506 --> 00:16:14.942
<c.magenta>如果你在其中任何一个地方</c>
<c.magenta>实现了重写</c>

00:16:15.008 --> 00:16:16.977
<c.magenta>AppKit将会看到它并且将继续</c>

00:16:17.044 --> 00:16:19.479
<c.magenta>自动为你开启New Tab按钮</c>

00:16:22.082 --> 00:16:24.818
<c.magenta>如果你有自己已存在的tab实现</c>

00:16:24.885 --> 00:16:26.386
<c.magenta>你可能需要禁用</c>

00:16:26.453 --> 00:16:28.856
<c.magenta>AppKit的自动窗口</c>
<c.magenta>tabbing行为</c>

00:16:29.790 --> 00:16:30.891
<c.magenta>这里是这个类的属性</c>

00:16:30.958 --> 00:16:33.260
<c.magenta>NSWindow的</c>
<c.magenta>allowsAutomaticWindowTabbing</c>

00:16:34.161 --> 00:16:36.430
<c.magenta>这是一个类属性</c>
<c.magenta>在你的应用启动之初</c>

00:16:36.496 --> 00:16:37.998
<c.magenta>叫做NSWindow</c>

00:16:38.065 --> 00:16:42.169
<c.magenta>allowsAutomaticWindowTabbing</c>
<c.magenta>等于假</c>

00:16:42.236 --> 00:16:44.771
<c.magenta>这里将关闭</c>
<c.magenta>AppKit的tabbing行为</c>

00:16:44.838 --> 00:16:47.975
<c.magenta>然后你将可以继续使用</c>
<c.magenta>你自己的tabbing实现了</c>

00:16:48.375 --> 00:16:51.311
<c.magenta>这里非常重要</c>
<c.magenta>你需要在应用启动</c>

00:16:51.378 --> 00:16:53.113
<c.magenta>且开始将窗口展示出来前调用它</c>

00:16:56.083 --> 00:16:59.453
<c.magenta>你只需要在你的应用中添加tab支持</c>

00:16:59.520 --> 00:17:00.687
<c.magenta>它大多数情况下是自动工作的</c>

00:16:59.520 --> 00:17:00.687
<c.magenta>它大多数情况下是自动工作的</c>

00:17:00.754 --> 00:17:03.557
<c.magenta>不过这里有些API</c>
<c.magenta>你可以用来自定义一些事情</c>

00:17:04.090 --> 00:17:07.094
<c.magenta>首先 用户可以定义一些行为</c>

00:17:07.160 --> 00:17:10.030
<c.magenta>指定在系统中</c>
<c.magenta>他们想要的tabbing方式</c>

00:17:10.097 --> 00:17:11.832
<c.magenta>且他们可以在系统设置中来这么做</c>

00:17:11.898 --> 00:17:13.834
<c.magenta>你获取用户设置</c>

00:17:13.901 --> 00:17:17.804
<c.magenta>通过在NSWindow上</c>
<c.magenta>用户tabbing设置的类属性</c>

00:17:18.137 --> 00:17:21.241
<c.magenta>它们可以设置为手动</c>
<c.magenta>始终或者仅仅tabbing</c>

00:17:21.308 --> 00:17:23.143
<c.magenta>在它们全屏的时候</c>

00:17:25.279 --> 00:17:27.047
<c.magenta>在剩下的这些属性</c>
<c.magenta>和函数中</c>

00:17:27.114 --> 00:17:29.616
<c.magenta>我讲给大家讨论下</c>
<c.magenta>实例属性以及</c>

00:17:29.683 --> 00:17:30.984
<c.magenta>NSWindow的函数</c>

00:17:31.685 --> 00:17:33.687
<c.magenta>一旦你有了一个NSWindow实例</c>

00:17:33.954 --> 00:17:35.322
<c.magenta>你可将它设置为tabbing模式</c>

00:17:35.722 --> 00:17:37.457
<c.magenta>默认情况下</c>
<c.magenta>这个tabbing模式是自动的</c>

00:17:37.524 --> 00:17:40.694
<c.magenta>也就是说我们将使用</c>
<c.magenta>用户的tabbing设置</c>

00:17:41.061 --> 00:17:43.297
<c.magenta>不过你可以将它设置为首选或者禁用</c>

00:17:43.363 --> 00:17:44.965
<c.magenta>取决于你的窗口类型和你的需要</c>

00:17:47.100 --> 00:17:49.670
<c.magenta>当我们把窗口分组到一起</c>
<c.magenta>变成一组tab的时候</c>

00:17:49.736 --> 00:17:52.706
<c.magenta>我们只想把类似的窗口分组到一起</c>
<c.magenta>我们判断的方式就是</c>

00:17:52.773 --> 00:17:54.808
<c.magenta>通过查看tabbing的标识符</c>

00:17:54.875 --> 00:17:56.743
<c.magenta>若有相同tabbing标识符窗口</c>

00:17:56.810 --> 00:17:58.612
<c.magenta>我们就可以把它们</c>
<c.magenta>以tab的方式分组到一起</c>

00:17:59.213 --> 00:18:01.582
<c.magenta>默认情况下 AppKit会使用</c>
<c.magenta>一种启发式搜索并且</c>

00:17:59.213 --> 00:18:01.582
<c.magenta>默认情况下 AppKit会使用</c>
<c.magenta>一种启发式搜索并且</c>

00:18:01.648 --> 00:18:03.984
<c.magenta>从你的利益角度出发</c>
<c.magenta>生成一个tabbing标识符</c>

00:18:04.051 --> 00:18:07.387
<c.magenta>我们检查这些东西</c>
<c.magenta>例如窗口的子类名称</c>

00:18:07.754 --> 00:18:10.190
<c.magenta>窗口的属性 文档</c>

00:18:10.257 --> 00:18:13.260
<c.magenta>还有一些其它各种属性</c>
<c.magenta>然后尝试生成</c>

00:18:13.327 --> 00:18:16.129
<c.magenta>适当的tabbing标识符</c>

00:18:16.496 --> 00:18:17.865
<c.magenta>这种方式运作得非常好</c>

00:18:17.931 --> 00:18:20.501
<c.magenta>如果它在你的应用中</c>
<c.magenta>运作不够好的话</c>

00:18:20.567 --> 00:18:23.504
<c.magenta>或者你想要更多的控制它</c>

00:18:23.570 --> 00:18:25.706
<c.magenta>你可以手动设置tabbing标识符</c>

00:18:25.772 --> 00:18:27.441
<c.magenta>AppKit将会遵守它</c>

00:18:28.509 --> 00:18:30.978
<c.magenta>你无法获取到哪些窗口被分组到了一起</c>

00:18:31.044 --> 00:18:34.281
<c.magenta>通过tab中的某个窗口实例</c>

00:18:34.348 --> 00:18:35.849
<c.magenta>获取所有tab窗口</c>

00:18:36.383 --> 00:18:38.418
<c.magenta>注意它会返回一个可选数组</c>

00:18:38.886 --> 00:18:42.623
<c.magenta>它可返回空 而且如果tab栏不显示</c>
<c.magenta>它必然返回空值</c>

00:18:42.689 --> 00:18:44.925
<c.magenta>这里根本没有关联的tab</c>

00:18:46.760 --> 00:18:50.998
<c.magenta>你可以手动添加</c>
<c.magenta>其它的tab窗口将它们分组到一起</c>

00:18:51.064 --> 00:18:53.734
<c.magenta>因为这些都是窗口</c>
<c.magenta>这正好说明了API名称</c>

00:18:53.800 --> 00:18:56.637
<c.magenta>当你添加一个tab窗口</c>
<c.magenta>而不是添加一个tab自身</c>

00:18:56.703 --> 00:18:58.705
<c.magenta>添加了tab窗口之后</c>
<c.magenta>可以使用</c>

00:18:58.772 --> 00:19:01.408
<c.magenta>NSWindowOrderingMode进行排序</c>
<c.magenta>它将使tab跟其他</c>

00:18:58.772 --> 00:19:01.408
<c.magenta>NSWindowOrderingMode进行排序</c>
<c.magenta>它将使tab跟其他</c>

00:19:01.875 --> 00:19:03.277
<c.magenta>tab关联起来进行排序</c>

00:19:05.579 --> 00:19:08.649
<c.magenta>AppKit会给菜单添加一些新项</c>

00:19:09.082 --> 00:19:12.219
<c.magenta>也就是说在窗口菜单下</c>
<c.magenta>添加了一些项目</c>

00:19:12.286 --> 00:19:15.055
<c.magenta>以此来帮助用户在tab之前进行导航</c>

00:19:15.122 --> 00:19:17.191
<c.magenta>比如选择下一个或者上一个tab</c>

00:19:17.624 --> 00:19:19.960
<c.magenta>这只是NSWindow上的IB动作</c>

00:19:20.027 --> 00:19:23.297
<c.magenta>而且你也可以基于你自己的</c>
<c.magenta>用户界面元素来编写它们</c>

00:19:23.530 --> 00:19:26.600
<c.magenta>例如 你可能想要一个按钮</c>
<c.magenta>来切换tab栏</c>

00:19:26.834 --> 00:19:28.836
<c.magenta>你可以将那个按钮连接到窗口</c>

00:19:30.070 --> 00:19:32.072
<c.magenta>toggleTabBar IBAction</c>

00:19:32.439 --> 00:19:35.843
<c.magenta>NSWindow将为你处理</c>
<c.magenta>切换tab栏</c>

00:19:37.477 --> 00:19:39.580
<c.magenta>上面就是关于窗口捕获和</c>
<c.magenta>tabbing的所有内容</c>

00:19:40.147 --> 00:19:42.816
<c.magenta>让我们继续来讲下关于</c>
<c.magenta>右-左的支持</c>

00:19:42.883 --> 00:19:44.551
<c.magenta>我们在AppKit上做了很多工作</c>

00:19:44.618 --> 00:19:47.120
<c.magenta>来加强现有的右-左的支持</c>

00:19:47.721 --> 00:19:51.491
<c.magenta>大家这里看到的截图是运行在</c>
<c.magenta>阿拉伯语中的TextEdit</c>

00:19:51.892 --> 00:19:54.127
<c.magenta>标题栏是翻转过来的</c>

00:19:54.261 --> 00:19:56.230
<c.magenta>滚动条被放到了另外一边</c>

00:19:56.296 --> 00:19:58.298
<c.magenta>甚至New Tab按钮也放到另一边</c>

00:19:58.365 --> 00:19:59.900
<c.magenta>并且所有的小属性</c>

00:19:59.967 --> 00:20:02.069
<c.magenta>还有各式各样的标题栏按钮都翻转了</c>

00:19:59.967 --> 00:20:02.069
<c.magenta>还有各式各样的标题栏按钮都翻转了</c>

00:20:02.135 --> 00:20:04.705
<c.magenta>非常符合右-左用户的期望</c>

00:20:06.006 --> 00:20:09.142
<c.magenta>我想从三个不同的级别来讨论</c>
<c.magenta>从右-左的支持</c>

00:20:09.409 --> 00:20:12.913
<c.magenta>系统级别会发生什么</c>
<c.magenta>当用户设置了他们的本地化</c>

00:20:12.980 --> 00:20:14.381
<c.magenta>在系统设置面板中</c>

00:20:15.148 --> 00:20:16.517
<c.magenta>它会对应用产生什么影响</c>

00:20:16.583 --> 00:20:18.051
<c.magenta>你的应用会表现成什么样</c>

00:20:18.118 --> 00:20:20.187
<c.magenta>依赖于你对本地化的支持</c>

00:20:20.787 --> 00:20:22.422
<c.magenta>然后下降到内容层面</c>

00:20:22.489 --> 00:20:23.891
<c.magenta>就是在NSView级别</c>

00:20:24.224 --> 00:20:26.560
<c.magenta>如果需要的话</c>
<c.magenta>你可以进一步重写一些东西</c>

00:20:26.627 --> 00:20:28.428
<c.magenta>直接使用用户界面布局</c>

00:20:28.829 --> 00:20:30.931
<c.magenta>然后我将会围绕着一节</c>

00:20:30.998 --> 00:20:33.667
<c.magenta>通过一个非常不错的开发技巧来帮助你</c>

00:20:33.967 --> 00:20:36.436
<c.magenta>给你的应用提供右-左的支持</c>

00:20:37.704 --> 00:20:39.840
<c.magenta>首先 让我们从系统层面开始讲</c>

00:20:41.141 --> 00:20:42.876
<c.magenta>这里的关键点是一致性</c>

00:20:43.110 --> 00:20:45.245
<c.magenta>我们需要保持一致性的表现</c>

00:20:45.312 --> 00:20:47.447
<c.magenta>在用户设置为右-左的系统中</c>

00:20:47.814 --> 00:20:50.951
<c.magenta>所以不管你支持哪种本地化</c>

00:20:51.018 --> 00:20:53.820
<c.magenta>在你的应用中</c>
<c.magenta>我们想要让所有菜单栏</c>

00:20:54.087 --> 00:20:57.658
<c.magenta>在一个右-左的系统中</c>
<c.magenta>从Apple这个菜单项开始</c>

00:20:57.724 --> 00:21:01.762
<c.magenta>在这里放在其它的菜单项的右边</c>

00:20:57.724 --> 00:21:01.762
<c.magenta>在这里放在其它的菜单项的右边</c>

00:21:01.828 --> 00:21:05.132
<c.magenta>这里同样适用窗口的标题栏</c>

00:21:06.033 --> 00:21:08.302
<c.magenta>所以交通指示灯将翻转到另一边</c>

00:21:08.368 --> 00:21:09.803
<c.magenta>所有不在内容区域的东西</c>

00:21:09.870 --> 00:21:11.305
<c.magenta>都将翻转到另一边</c>

00:21:11.705 --> 00:21:14.041
<c.magenta>不管你的应用中支持的是何种本地化</c>

00:21:14.274 --> 00:21:16.476
<c.magenta>给用户提供一致性的体验</c>

00:21:17.311 --> 00:21:21.181
<c.magenta>现在降级到应用层面</c>
<c.magenta>我们将不能自动这么做了</c>

00:21:21.248 --> 00:21:22.916
<c.magenta>因为我们不想打断任何</c>

00:21:22.983 --> 00:21:24.318
<c.magenta>你的应用中可能有的设定</c>

00:21:24.785 --> 00:21:28.522
<c.magenta>所以强烈的建议你添加</c>
<c.magenta>右-左的支持</c>

00:21:28.589 --> 00:21:31.959
<c.magenta>在你的应用中</c>
<c.magenta>添加犹太人和阿拉伯人本地化</c>

00:21:32.993 --> 00:21:35.996
<c.magenta>一旦在有了这些本地化</c>

00:21:36.496 --> 00:21:37.731
<c.magenta>在应用层面</c>

00:21:37.798 --> 00:21:41.301
<c.magenta>所有的滚动区域将自动无视</c>
<c.magenta>垂直滚动和标尺</c>

00:21:41.368 --> 00:21:43.670
<c.magenta>NSBrowser将自动翻转</c>

00:21:44.104 --> 00:21:46.340
<c.magenta>在这个层面 我们同样需要一致性</c>

00:21:46.406 --> 00:21:51.211
<c.magenta>所以不管何种用户界面布局方向的</c>
<c.magenta>任何内容区域</c>

00:21:51.979 --> 00:21:55.816
<c.magenta>我们都想要滚动条保持一致性</c>
<c.magenta>都在同一侧</c>

00:21:57.184 --> 00:21:58.719
<c.magenta>下降到内容层面</c>

00:21:59.253 --> 00:22:01.688
<c.magenta>默认情况下用户界面布局方向</c>
<c.magenta>将会匹配</c>

00:21:59.253 --> 00:22:01.688
<c.magenta>默认情况下用户界面布局方向</c>
<c.magenta>将会匹配</c>

00:22:01.755 --> 00:22:04.091
<c.magenta>你的是应用如何设置的</c>

00:22:05.392 --> 00:22:08.529
<c.magenta>在大部分情况下</c>
<c.magenta>这正是你所期望的</c>

00:22:08.595 --> 00:22:09.963
<c.magenta>不过有一些例外</c>

00:22:10.030 --> 00:22:12.499
<c.magenta>也就是说 如果你有</c>
<c.magenta>一些类似媒体控件</c>

00:22:12.566 --> 00:22:15.035
<c.magenta>或者空间控件 或者时间控件</c>

00:22:15.102 --> 00:22:19.606
<c.magenta>它们始终是一样的布局</c>
<c.magenta>从左往右</c>

00:22:19.673 --> 00:22:22.376
<c.magenta>对于左-右用户和</c>
<c.magenta>右-左用户来说都是这样</c>

00:22:23.043 --> 00:22:25.812
<c.magenta>所以你可以修改用户界面布局方向</c>

00:22:26.513 --> 00:22:28.982
<c.magenta>并且下面这些AppKit中的</c>
<c.magenta>控件都支持那样做</c>

00:22:29.383 --> 00:22:31.885
<c.magenta>所以自动布局将不会在这个阶段中</c>

00:22:31.952 --> 00:22:38.492
<c.magenta>不过在即将到来第二阶段中</c>
<c.magenta>我们将开始使用父容器</c>

00:22:38.959 --> 00:22:44.731
<c.magenta>来决定哪边是头哪边是尾</c>

00:22:45.999 --> 00:22:47.534
<c.magenta>版本中已有的表格视图</c>

00:22:47.601 --> 00:22:50.270
<c.magenta>和outline view会适当的</c>
<c.magenta>调整它们的列</c>

00:22:50.337 --> 00:22:54.641
<c.magenta>NSPageController</c>
<c.magenta>可切换动画且这个列表还在继续</c>

00:22:54.708 --> 00:22:57.811
<c.magenta>我们在AppKit中</c>
<c.magenta>有很多对右-左的支持</c>

00:22:57.878 --> 00:22:59.980
<c.magenta>让AppKit做繁琐的工作</c>

00:23:00.347 --> 00:23:04.551
<c.magenta>给你的用户提供一个右-左更好的体验</c>

00:23:06.954 --> 00:23:08.422
<c.magenta>我答应过给大家一个开发技巧</c>

00:23:08.488 --> 00:23:10.057
<c.magenta>我已使用这个技巧一整年了</c>

00:23:10.123 --> 00:23:11.859
<c.magenta>我发现它难以置信的有用</c>

00:23:12.226 --> 00:23:14.828
<c.magenta>在Xcode中 你可以修改项目体质</c>

00:23:14.895 --> 00:23:17.497
<c.magenta>在Options选项中</c>
<c.magenta>修改你的应用的语言</c>

00:23:17.564 --> 00:23:19.099
<c.magenta>设置成右-左虚拟语言</c>

00:23:19.566 --> 00:23:21.435
<c.magenta>这可以让你的应用</c>

00:23:21.502 --> 00:23:24.037
<c.magenta>在开发语言中运行</c>
<c.magenta>对我来说它就是英语</c>

00:23:24.404 --> 00:23:26.173
<c.magenta>大家看到这里</c>
<c.magenta>TextEdit运行在英语当中</c>

00:23:26.640 --> 00:23:31.078
<c.magenta>但是它在所有控件中使用了</c>
<c.magenta>右-左翻转</c>

00:23:31.278 --> 00:23:34.281
<c.magenta>所以窗口标题栏被翻转了</c>

00:23:34.515 --> 00:23:36.383
<c.magenta>滚动区域的滚动条翻转了</c>

00:23:36.450 --> 00:23:39.186
<c.magenta>大家看到所有小的子项和</c>

00:23:39.253 --> 00:23:40.487
<c.magenta>标题栏所有按钮都翻转了</c>

00:23:40.554 --> 00:23:44.825
<c.magenta>所以这是一个非常简单的方式</c>
<c.magenta>让你获得右-左的支持</c>

00:23:44.892 --> 00:23:47.995
<c.magenta>并且确保所有的东西</c>
<c.magenta>在你的原生语言下运行正确</c>

00:23:49.796 --> 00:23:52.165
<c.magenta>在这里仅仅涵盖了</c>
<c.magenta>我们在AppKit中做的事</c>

00:23:53.033 --> 00:23:54.401
<c.magenta>还有很多东西可以讨论</c>

00:23:54.468 --> 00:23:57.504
<c.magenta>在“国际化用户界面新特性”的演讲中</c>

00:23:57.571 --> 00:23:59.139
<c.magenta>在星期五上午9:00</c>
<c.magenta>于Nob Hill举行</c>

00:23:59.640 --> 00:24:01.308
<c.magenta>他们涵盖了更多东西在桌面方面</c>

00:23:59.640 --> 00:24:01.308
<c.magenta>他们涵盖了更多东西在桌面方面</c>

00:24:01.375 --> 00:24:05.979
<c.magenta>比如WebKit 文本布局</c>
<c.magenta>资源管理</c>

00:24:06.046 --> 00:24:09.049
<c.magenta>他们还包含iOS上右-左的支持</c>

00:24:09.116 --> 00:24:11.151
<c.magenta>强烈推荐大家也关注下这个讨论</c>

00:24:14.054 --> 00:24:15.889
<c.magenta>让我们来讨论下promise拖拽</c>

00:24:16.256 --> 00:24:18.225
<c.magenta>若你还不熟悉</c>
<c.magenta>promise拖拽就是</c>

00:24:18.292 --> 00:24:21.328
<c.magenta>当用户从你的应用中拖拽一个文件</c>

00:24:22.262 --> 00:24:25.799
<c.magenta>但是在磁盘上其实并没有这个文件</c>

00:24:26.133 --> 00:24:27.334
<c.magenta>你只是许下个promise</c>

00:24:27.401 --> 00:24:29.570
<c.magenta>你将会写入到用户想要释放的地方</c>

00:24:29.903 --> 00:24:30.971
<c.magenta>这就是一个文件promise拖拽</c>

00:24:31.038 --> 00:24:34.575
<c.magenta>从一开始我们就在OS X中</c>
<c.magenta>支持promise拖拽</c>

00:24:35.809 --> 00:24:38.712
<c.magenta>在macOS Sierra中</c>
<c.magenta>我们升级了文件promise拖拽</c>

00:24:38.779 --> 00:24:42.015
<c.magenta>将会更加现代化</c>
<c.magenta>使用NSFilePromiseProvider</c>

00:24:42.082 --> 00:24:44.284
<c.magenta>和NSFilePromiseReceiver对象</c>

00:24:44.985 --> 00:24:47.354
<c.magenta>现在这些对象允许</c>
<c.magenta>文件promise拖拽</c>

00:24:47.421 --> 00:24:48.789
<c.magenta>来支持拖放群集</c>

00:24:49.223 --> 00:24:50.490
<c.magenta>若你对拖放群集还不熟悉</c>

00:24:50.557 --> 00:24:52.259
<c.magenta>其实就是当你拖放多个元素时</c>

00:24:52.326 --> 00:24:54.361
<c.magenta>它们会形成中间拖动</c>

00:24:54.428 --> 00:24:56.463
<c.magenta>这依赖于目标应用</c>

00:24:56.530 --> 00:24:57.531
<c.magenta>将会对它们做什么</c>

00:24:59.666 --> 00:25:03.170
<c.magenta>使用这两类的文件promise</c>
<c.magenta>拖拽可支持拖拽群集</c>

00:24:59.666 --> 00:25:03.170
<c.magenta>使用这两类的文件promise</c>
<c.magenta>拖拽可支持拖拽群集</c>

00:25:03.237 --> 00:25:04.204
<c.magenta>它们基于UTI</c>

00:25:04.538 --> 00:25:06.974
<c.magenta>它们完全是尊从</c>
<c.magenta>writer和reader样板</c>

00:25:07.040 --> 00:25:10.811
<c.magenta>即你可使用NSPasteboard</c>
<c.magenta>上基于元素的API</c>

00:25:10.878 --> 00:25:12.446
<c.magenta>同这些对象一起工作</c>

00:25:13.280 --> 00:25:14.982
<c.magenta>如果可能的话它们会适配文件</c>

00:25:15.048 --> 00:25:16.884
<c.magenta>所以你不用担心文件的适配</c>

00:25:16.950 --> 00:25:19.253
<c.magenta>我们会自动包装文件适配的读</c>

00:25:19.319 --> 00:25:21.488
<c.magenta>和写 从你的利益角度出发</c>

00:25:22.089 --> 00:25:23.457
<c.magenta>并且反过来它们也是兼容的</c>

00:25:24.124 --> 00:25:27.895
<c.magenta>它们反过来也兼容基于无元素的</c>
<c.magenta>文件promise API</c>

00:25:28.462 --> 00:25:31.031
<c.magenta>也就是说你只需要关心一个API</c>

00:25:31.231 --> 00:25:33.734
<c.magenta>如果你实现了一个</c>
<c.magenta>NSFilePromiseProvider</c>

00:25:33.800 --> 00:25:35.502
<c.magenta>你现可提供文件promise</c>

00:25:35.569 --> 00:25:39.406
<c.magenta>给任何使用新NSFilePromiseReceiver API的人</c>

00:25:39.473 --> 00:25:41.575
<c.magenta>或者那些在现有应用中</c>

00:25:41.642 --> 00:25:43.610
<c.magenta>使用基于无元素API的人</c>

00:25:43.677 --> 00:25:45.979
<c.magenta>他们同样可以接受</c>
<c.magenta>你的promise文件</c>

00:25:46.046 --> 00:25:49.283
<c.magenta>就像NSFilePromiseReceiver一样</c>

00:25:49.349 --> 00:25:51.552
<c.magenta>你也可以接受文件promise</c>

00:25:51.618 --> 00:25:54.454
<c.magenta>从任何使用NSFilePromiseProvider的地方</c>

00:25:54.521 --> 00:25:57.057
<c.magenta>或者使用基于无元素API的地方</c>

00:25:59.693 --> 00:26:03.530
<c.magenta>所以如果你想在拖拽中提供</c>
<c.magenta>一个文件promise</c>

00:25:59.693 --> 00:26:03.530
<c.magenta>所以如果你想在拖拽中提供</c>
<c.magenta>一个文件promise</c>

00:26:03.597 --> 00:26:06.200
<c.magenta>当用户开始拖动时</c>
<c.magenta>你需要创建一个promise</c>

00:26:06.266 --> 00:26:09.703
<c.magenta>通过创建一个</c>
<c.magenta>NSFilePromiseProvider实例来实现</c>

00:26:09.970 --> 00:26:13.207
<c.magenta>如果你想要给</c>
<c.magenta>每个promise的文件</c>

00:26:13.273 --> 00:26:14.641
<c.magenta>都创建一个实例</c>

00:26:14.708 --> 00:26:17.377
<c.magenta>你需要提供一个</c>
<c.magenta>NSFilePromiseProvider代理</c>

00:26:17.611 --> 00:26:19.580
<c.magenta>这个代理将负担承重的任务</c>

00:26:19.646 --> 00:26:21.248
<c.magenta>把文件写入到磁盘上</c>

00:26:21.949 --> 00:26:24.685
<c.magenta>同时 目的地将调用</c>
<c.magenta>这个promise</c>

00:26:24.751 --> 00:26:27.487
<c.magenta>你将会被询问提供目的地的文件名称</c>

00:26:27.554 --> 00:26:28.889
<c.magenta>现在你知道目的地在哪里了</c>

00:26:28.956 --> 00:26:30.657
<c.magenta>你就可以弄清楚文件名了</c>

00:26:30.724 --> 00:26:33.360
<c.magenta>不过请不要在这个时候写入文件</c>
<c.magenta>因为它还没被包装成</c>

00:26:33.427 --> 00:26:35.863
<c.magenta>文件适配</c>
<c.magenta>而且我们发现</c>

00:26:35.929 --> 00:26:37.598
<c.magenta>拖动中还有一些其它项目</c>

00:26:38.232 --> 00:26:39.099
<c.magenta>当拖动结束之后</c>

00:26:39.166 --> 00:26:40.667
<c.magenta>我们知道了所有需要知道的信息</c>

00:26:40.734 --> 00:26:43.904
<c.magenta>再来调用代理 然后询问</c>
<c.magenta>你promise要写入到的URL</c>

00:26:44.705 --> 00:26:46.340
<c.magenta>并提供一个完成的处理器</c>

00:26:46.406 --> 00:26:50.611
<c.magenta>在这个时候 它们都包装成了</c>
<c.magenta>文件适配写入</c>

00:26:50.944 --> 00:26:53.347
<c.magenta>然后只需要写入文件到</c>
<c.magenta>提供的URL</c>

00:26:53.413 --> 00:26:55.949
<c.magenta>然后调用完成的处理器</c>
<c.magenta>让文件适配知道</c>

00:26:56.016 --> 00:26:56.950
<c.magenta>你已经完成了写入</c>

00:26:58.385 --> 00:27:00.521
<c.magenta>若你想要接受一个文件promise</c>

00:26:58.385 --> 00:27:00.521
<c.magenta>若你想要接受一个文件promise</c>

00:27:00.821 --> 00:27:02.623
<c.magenta>你首先需要注册view</c>

00:27:02.689 --> 00:27:04.725
<c.magenta>在你想要允许任务发生的地方</c>

00:27:05.192 --> 00:27:07.861
<c.magenta>这通常由view.register</c>
<c.magenta>forDraggedTypes完成</c>

00:27:07.928 --> 00:27:11.198
<c.magenta>你需要添加的拖动类型</c>
<c.magenta>就是NSFilePromiseReceiver</c>

00:27:11.265 --> 00:27:12.699
<c.magenta>readableDrappedTypes</c>

00:27:12.766 --> 00:27:14.067
<c.magenta>这非常简单</c>

00:27:15.068 --> 00:27:17.771
<c.magenta>现在一旦用户拖动一个文件</c>
<c.magenta>promise到这个view上</c>

00:27:17.838 --> 00:27:19.273
<c.magenta>你将会得到拖拽消息</c>

00:27:19.339 --> 00:27:21.375
<c.magenta>然后你想得到promise对象</c>

00:27:22.242 --> 00:27:26.013
<c.magenta>可以使用基于元素样板API</c>

00:27:26.079 --> 00:27:29.650
<c.magenta>访问这个对象的forClasses</c>
<c.magenta>NSFilePromiseReceiver.self来获得访问</c>

00:27:29.716 --> 00:27:32.386
<c.magenta>你将会得到一个</c>
<c.magenta>NSFilePromiseReceiver对象的数组</c>

00:27:33.320 --> 00:27:35.689
<c.magenta>你但你有了</c>
<c.magenta>NSFilePromiseReceiver对象</c>

00:27:35.756 --> 00:27:37.090
<c.magenta>你可以调用这个promise里面的</c>

00:27:37.157 --> 00:27:40.227
<c.magenta>通过调用receivePromisedFiles</c>
<c.magenta>atDestination options</c>

00:27:40.294 --> 00:27:41.428
<c.magenta>operationQueue reader</c>

00:27:42.029 --> 00:27:44.531
<c.magenta>然后它将迅速的从这个函数返回</c>

00:27:44.598 --> 00:27:46.400
<c.magenta>reader块还没有被调用</c>

00:27:46.466 --> 00:27:47.768
<c.magenta>我们将在后面返回来调用</c>

00:27:48.869 --> 00:27:51.605
<c.magenta>一但源文件写入所有的promise</c>

00:27:51.672 --> 00:27:54.308
<c.magenta>现在我们继续</c>
<c.magenta>返回过去调用reader块</c>

00:27:54.374 --> 00:27:56.343
<c.magenta>在指定的操作队列上</c>

00:27:56.877 --> 00:28:01.615
<c.magenta>现在 这点非常重要</c>
<c.magenta>你没有指定NSMainOperationQueue</c>

00:27:56.877 --> 00:28:01.615
<c.magenta>现在 这点非常重要</c>
<c.magenta>你没有指定NSMainOperationQueue</c>

00:28:01.682 --> 00:28:04.117
<c.magenta>给这个操作队列</c>
<c.magenta>或者你将</c>

00:28:04.184 --> 00:28:07.521
<c.magenta>打断你的应用</c>
<c.magenta>在等待源进程</c>

00:28:07.588 --> 00:28:08.822
<c.magenta>完成文件写入的时候</c>

00:28:08.889 --> 00:28:09.957
<c.magenta>这过程需要一些时间</c>

00:28:10.023 --> 00:28:12.392
<c.magenta>而且你不想应用被打断在这整个过程中</c>

00:28:15.963 --> 00:28:18.198
<c.magenta>这就是关于文件</c>
<c.magenta>promise拖拽所做的事</c>

00:28:18.265 --> 00:28:22.202
<c.magenta>它有更简单的的API可以使用</c>
<c.magenta>而且可以同拖拽群集工作</c>

00:28:22.269 --> 00:28:24.872
<c.magenta>还可以通过样板支持基于元素API</c>

00:28:25.772 --> 00:28:27.708
<c.magenta>让我们继续来讲下我们做的一些改进</c>

00:28:27.774 --> 00:28:29.243
<c.magenta>针对各种容器视图</c>

00:28:29.476 --> 00:28:31.178
<c.magenta>我们从集合视图开始</c>

00:28:31.812 --> 00:28:34.681
<c.magenta>对于集合视图 预想你可以滚动</c>

00:28:35.182 --> 00:28:38.318
<c.magenta>内容可以在任何背景视图上滚动</c>

00:28:38.385 --> 00:28:39.419
<c.magenta>这就是你可能已有的</c>

00:28:39.586 --> 00:28:42.055
<c.magenta>现在你可以告诉背景视图</c>
<c.magenta>跟随上下文一起滚动</c>

00:28:42.122 --> 00:28:44.858
<c.magenta>通过设置backgroundViews</c>
<c.magenta>ScrollsWithContent为真</c>

00:28:44.925 --> 00:28:46.093
<c.magenta>它们将会一起滚动</c>

00:28:46.927 --> 00:28:50.464
<c.magenta>我们同样已经支持</c>
<c.magenta>可选浮动header和footer</c>

00:28:50.531 --> 00:28:52.699
<c.magenta>你可以把这里的文档header</c>
<c.magenta>设为浮动</c>

00:28:52.766 --> 00:28:54.334
<c.magenta>然后内容区域滚动将会在它下面</c>

00:28:55.936 --> 00:28:58.739
<c.magenta>使用NSCollectionView的浮动布局</c>
<c.magenta>这将非常的简单</c>

00:28:59.006 --> 00:29:01.275
<c.magenta>只需要设置sectionHeadersPinToVisible为真</c>

00:28:59.006 --> 00:29:01.275
<c.magenta>只需要设置sectionHeadersPinToVisible为真</c>

00:29:01.341 --> 00:29:04.444
<c.magenta>或者sectionFootersPinToVisibleBounds为真</c>

00:29:04.511 --> 00:29:05.979
<c.magenta>如果你想要footer为浮动</c>

00:29:06.046 --> 00:29:07.714
<c.magenta>NSCollectionView将会</c>

00:29:07.781 --> 00:29:10.083
<c.magenta>适当的处理 基于你的行为</c>

00:29:11.151 --> 00:29:13.720
<c.magenta>你也可以可选折叠任何部分</c>

00:29:13.787 --> 00:29:16.023
<c.magenta>到一个单独的水平的可滚动行</c>

00:29:16.089 --> 00:29:18.926
<c.magenta>正如你这里看到的一样</c>
<c.magenta>而且还有少许旋转效果</c>

00:29:18.992 --> 00:29:20.527
<c.magenta>当你水平滚动的时候</c>

00:29:22.229 --> 00:29:25.732
<c.magenta>通过toggleSectionCollapse IBAction</c>
<c.magenta>可以非常简单地做到这点</c>

00:29:25.799 --> 00:29:27.201
<c.magenta>在NSCollectionView上</c>

00:29:27.634 --> 00:29:31.805
<c.magenta>现在这个消息的发送者需要是一个视图</c>

00:29:31.872 --> 00:29:35.375
<c.magenta>在你的区块header或者一个</c>
<c.magenta>继承自区块header的视图</c>

00:29:35.442 --> 00:29:38.312
<c.magenta>NSCollectionView才能准确的确定</c>

00:29:38.378 --> 00:29:41.248
<c.magenta>哪个区块需要切换折叠</c>

00:29:43.250 --> 00:29:47.154
<c.magenta>一旦在header或者</c>
<c.magenta>派生的视图中有按钮</c>

00:29:47.588 --> 00:29:50.891
<c.magenta>你需要将区块的header</c>
<c.magenta>实现NSCollectionView</c>

00:29:50.958 --> 00:29:53.994
<c.magenta>SectionHeaderView协议</c>
<c.magenta>它仅仅只是</c>

00:29:54.061 --> 00:29:56.530
<c.magenta>把你的按钮链接到sectionCollapseButton的插口</c>

00:29:57.097 --> 00:29:59.499
<c.magenta>然后NSCollectionView</c>
<c.magenta>将可以可以找到你的按钮</c>

00:29:59.566 --> 00:30:01.201
<c.magenta>并且自动隐藏和显示它</c>

00:29:59.566 --> 00:30:01.201
<c.magenta>并且自动隐藏和显示它</c>

00:30:01.268 --> 00:30:05.038
<c.magenta>依赖于内部有足够的内容</c>

00:30:05.105 --> 00:30:07.174
<c.magenta>在这个区块来折叠</c>

00:30:09.009 --> 00:30:11.712
<c.magenta>NSTableView</c>
<c.magenta>将重绘所有的子视图</c>

00:30:12.212 --> 00:30:13.814
<c.magenta>当索引值为-1</c>

00:30:13.881 --> 00:30:17.150
<c.magenta>负1是我们的特殊数表示</c>

00:30:17.217 --> 00:30:22.489
<c.magenta>扩展你表格中的所有行和列</c>

00:30:22.823 --> 00:30:24.091
<c.magenta>因此 当你调用reloadData</c>

00:30:24.157 --> 00:30:26.226
<c.magenta>并且索引包含负1时</c>

00:30:26.293 --> 00:30:29.396
<c.magenta>我们将替你自动重载所有行</c>

00:30:29.863 --> 00:30:33.667
<c.magenta>这个仅从10.12版本开始支持</c>

00:30:34.501 --> 00:30:37.271
<c.magenta>因此在10.12或更新版本中</c>

00:30:37.337 --> 00:30:40.774
<c.magenta>NSOutlineView</c>
<c.magenta>也将自动加载它的表格</c>

00:30:40.841 --> 00:30:43.610
<c.magenta>相关联的也会重新加载</c>

00:30:44.545 --> 00:30:48.348
<c.magenta>另外 OutlineView</c>
<c.magenta>现在体验更好</c>

00:30:48.415 --> 00:30:50.584
<c.magenta>通过数据源返回</c>

00:30:51.785 --> 00:30:56.557
<c.magenta>这个功能非常有用 但若你的应用真想</c>

00:30:56.623 --> 00:31:01.161
<c.magenta>保持我们原有的刷新行为</c>

00:30:56.623 --> 00:31:01.161
<c.magenta>保持我们原有的刷新行为</c>

00:31:01.228 --> 00:31:03.063
<c.magenta>你可以设置</c>
<c.magenta>stronglyReferencesItems为假</c>

00:31:03.130 --> 00:31:07.568
<c.magenta>你就可以使用</c>
<c.magenta>10.12之前版本的行为</c>

00:31:10.737 --> 00:31:13.740
<c.magenta>然后 Taylor Kelly向前</c>

00:31:13.807 --> 00:31:15.742
<c.magenta>来和你谈谈网格视图</c>

00:31:22.516 --> 00:31:23.417
<c.magenta>谢谢Raleigh</c>

00:31:23.917 --> 00:31:26.854
<c.magenta>首先我想谈NSGridView视图</c>

00:31:27.054 --> 00:31:30.157
<c.magenta>这是和NSStackView</c>
<c.magenta>相似的一个新视图类</c>

00:31:30.224 --> 00:31:31.692
<c.magenta>我们实现了创建和管理</c>

00:31:31.758 --> 00:31:33.894
<c.magenta>约束你的布局</c>

00:31:34.862 --> 00:31:37.564
<c.magenta>但如同StackView</c>
<c.magenta>创建线性布局显示</c>

00:31:37.631 --> 00:31:40.667
<c.magenta>NSGridView</c>
<c.magenta>创建相交的行和列</c>

00:31:41.001 --> 00:31:43.871
<c.magenta>你在偏向窗格的UI中会经常看到</c>

00:31:44.104 --> 00:31:46.440
<c.magenta>是的 这些不同的行列</c>

00:31:46.507 --> 00:31:48.942
<c.magenta>会自动调整</c>

00:31:49.009 --> 00:31:50.477
<c.magenta>标准的定义</c>

00:31:51.278 --> 00:31:55.682
<c.magenta>它支持基线 头部 底部 对齐</c>

00:31:56.383 --> 00:31:59.520
<c.magenta>它支持GridView设置整体间距</c>

00:31:59.586 --> 00:32:02.890
<c.magenta>作为每个行列之间的间距</c>

00:31:59.586 --> 00:32:02.890
<c.magenta>作为每个行列之间的间距</c>

00:32:03.957 --> 00:32:06.727
<c.magenta>类似电子表格应用 它支持单元格合并</c>

00:32:06.793 --> 00:32:10.264
<c.magenta>因此 一个单一的视图</c>
<c.magenta>可以跨越多行或多个列</c>

00:32:11.098 --> 00:32:13.700
<c.magenta>如同分隔符做的一样</c>

00:32:15.135 --> 00:32:18.038
<c.magenta>它还支持动态隐藏行和列的显示</c>

00:32:18.105 --> 00:32:20.073
<c.magenta>不改变GridView结构的情况下</c>

00:32:20.440 --> 00:32:22.809
<c.magenta>例如 当我们点击这个复选框</c>

00:32:22.876 --> 00:32:24.811
<c.magenta>我们可能想隐藏</c>
<c.magenta>显示偏好按钮</c>

00:32:25.679 --> 00:32:28.382
<c.magenta>我们可以通过获取包含按钮的行</c>

00:32:28.448 --> 00:32:30.150
<c.magenta>并设置其隐藏属性为true</c>

00:32:30.784 --> 00:32:32.619
<c.magenta>GridView将自动刷新界面</c>

00:32:34.054 --> 00:32:36.490
<c.magenta>还有几个可以改进我们自动布局</c>

00:32:37.024 --> 00:32:39.660
<c.magenta>一个是清理AppKit布局周期</c>

00:32:40.260 --> 00:32:42.729
<c.magenta>视图不在需要使用布局</c>

00:32:42.796 --> 00:32:44.731
<c.magenta>或者不需要层的参与</c>

00:32:45.399 --> 00:32:47.768
<c.magenta>通过设置needslayout</c>
<c.magenta>为true</c>

00:32:47.835 --> 00:32:50.671
<c.magenta>下一个界面显示时 它会调用布局</c>

00:32:52.039 --> 00:32:55.542
<c.magenta>这样布局显示时</c>
<c.magenta>不再被调用两次</c>

00:32:55.609 --> 00:33:00.013
<c.magenta>对于层的支持</c>
<c.magenta>我们减少了隐性脏布局</c>

00:32:55.609 --> 00:33:00.013
<c.magenta>对于层的支持</c>
<c.magenta>我们减少了隐性脏布局</c>

00:33:00.080 --> 00:33:02.749
<c.magenta>因此减少布局</c>

00:33:02.816 --> 00:33:04.284
<c.magenta>这个实现方式很好</c>

00:33:04.585 --> 00:33:05.719
<c.magenta>但是 如果你遇到布局</c>

00:33:05.786 --> 00:33:07.821
<c.magenta>在你调用时没有响应</c>

00:33:07.888 --> 00:33:10.324
<c.magenta>确认你设置了needsLayout</c>

00:33:11.358 --> 00:33:14.561
<c.magenta>所有这一切都使它更容易</c>
<c.magenta>成为你的子视图手动布局</c>

00:33:14.628 --> 00:33:17.431
<c.magenta>所以你可以重写布局</c>
<c.magenta>而不需要调用super</c>

00:33:17.497 --> 00:33:21.468
<c.magenta>计算子视图宽架 设置并返回</c>

00:33:22.536 --> 00:33:24.738
<c.magenta>你要确保没有</c>

00:33:24.805 --> 00:33:26.573
<c.magenta>将自己的视图和其他视图混淆</c>

00:33:26.640 --> 00:33:28.308
<c.magenta>若在视图布局中发生这样的情况</c>

00:33:28.375 --> 00:33:30.978
<c.magenta>它设置自己的框架或父类的框架</c>

00:33:31.245 --> 00:33:36.283
<c.magenta>这将弄脏视图的布局</c>
<c.magenta>并导致额外的布局</c>

00:33:37.117 --> 00:33:39.720
<c.magenta>如果一直存在</c>
<c.magenta>这就是我们说的布局环</c>

00:33:40.254 --> 00:33:41.755
<c.magenta>这个很难去调试</c>

00:33:42.222 --> 00:33:44.024
<c.magenta>所以在macOS 和 iOS</c>

00:33:44.091 --> 00:33:46.560
<c.magenta>我们已经介绍了新的布局环的调试</c>

00:33:46.627 --> 00:33:49.596
<c.magenta>所以你可以更好的理解</c>
<c.magenta>哪儿布局有问题和为什么</c>

00:33:51.164 --> 00:33:54.201
<c.magenta>布局的改变添加的API到父类</c>

00:33:54.268 --> 00:33:57.070
<c.magenta>因此 你可以知道父类的含义</c>

00:33:57.538 --> 00:34:00.474
<c.magenta>即使不使用父类接口</c>
<c.magenta>你也需要申请</c>

00:33:57.538 --> 00:34:00.474
<c.magenta>即使不使用父类接口</c>
<c.magenta>你也需要申请</c>

00:34:02.442 --> 00:34:04.411
<c.magenta>除此之外</c>
<c.magenta>时间现在是可以为null</c>

00:34:04.478 --> 00:34:07.181
<c.magenta>因此 如果你正在使用该属性</c>
<c.magenta>一定要处理的是零的情况</c>

00:34:08.081 --> 00:34:10.117
<c.magenta>另外 接口支持新功能</c>

00:34:10.184 --> 00:34:12.052
<c.magenta>用于自动布局的添加</c>

00:34:12.418 --> 00:34:13.620
<c.magenta>因此在一个单独文件或</c>

00:34:13.687 --> 00:34:17.357
<c.magenta>在一个单一的视图层次结构中</c>
<c.magenta>你可以使用常量</c>

00:34:17.424 --> 00:34:18.458
<c.magenta>这是非常好的</c>

00:34:19.726 --> 00:34:22.029
<c.magenta>NSGridView布局环调试的</c>
<c.magenta>详细内容</c>

00:34:22.094 --> 00:34:24.831
<c.magenta>在周五“自动布局有何新特性”中讲解</c>

00:34:26.099 --> 00:34:28.101
<c.magenta>在这里</c>
<c.magenta>我想谈谈颜色</c>

00:34:28.168 --> 00:34:30.237
<c.magenta>特别是全范围的颜色</c>

00:34:30.771 --> 00:34:33.540
<c.magenta>所以sRGB是一个漂亮的</c>
<c.magenta>流行色彩空间</c>

00:34:33.607 --> 00:34:37.844
<c.magenta>通常是使用隐含的颜色</c>
<c.magenta>代替未指定的空间</c>

00:34:38.145 --> 00:34:40.581
<c.magenta>我们大部分的显示器</c>
<c.magenta>有一个sRGB色域</c>

00:34:41.514 --> 00:34:44.650
<c.magenta>新的5K iMac</c>
<c.magenta>和iPad Pro 9.7英寸屏</c>

00:34:44.918 --> 00:34:48.856
<c.magenta>都包含这些更新的显示器</c>
<c.magenta>可以显示更生动的颜色</c>

00:34:49.322 --> 00:34:52.059
<c.magenta>具体地说 他们正在使用</c>
<c.magenta>P3色域</c>

00:34:52.559 --> 00:34:56.063
<c.magenta>比起sRGB色域</c>

00:34:56.129 --> 00:34:58.565
<c.magenta>它可以显示很多</c>
<c.magenta>更充满活力的绿色和红色</c>

00:34:59.433 --> 00:35:02.603
<c.magenta>所以你的应用可以显示照片</c>

00:34:59.433 --> 00:35:02.603
<c.magenta>所以你的应用可以显示照片</c>

00:35:02.669 --> 00:35:05.706
<c.magenta>更精确的颜色</c>
<c.magenta>可以展示这些更具活力的</c>

00:35:05.772 --> 00:35:08.075
<c.magenta>颜色让界面看上去更加真实</c>

00:35:08.842 --> 00:35:11.678
<c.magenta>举颜色的一个例子</c>
<c.magenta>绿色</c>

00:35:11.745 --> 00:35:14.915
<c.magenta>正好是</c>
<c.magenta>Pantone的2013年度色</c>

00:35:16.149 --> 00:35:17.985
<c.magenta>它超出了sRGB范围</c>

00:35:18.051 --> 00:35:19.786
<c.magenta>所以以前显示器不能显示这个颜色</c>

00:35:19.853 --> 00:35:22.623
<c.magenta>但是使用P3可以完美显示出来</c>

00:35:24.024 --> 00:35:27.160
<c.magenta>你的照片也包含</c>
<c.magenta>这些更鲜艳的颜色</c>

00:35:27.227 --> 00:35:29.196
<c.magenta>特别是红色和橙色</c>

00:35:29.730 --> 00:35:33.400
<c.magenta>讽刺的是 投影机</c>
<c.magenta>甚至在家里的电视</c>

00:35:33.467 --> 00:35:35.669
<c.magenta>其实不去</c>
<c.magenta>显示这些颜色</c>

00:35:35.736 --> 00:35:38.672
<c.magenta>所以你不得不承认它们很特别</c>

00:35:40.541 --> 00:35:41.875
<c.magenta>如果你想用这些颜色</c>

00:35:41.942 --> 00:35:45.212
<c.magenta>有新的色彩空间displayP3</c>
<c.magenta>它让你可以拥有</c>

00:35:45.279 --> 00:35:47.915
<c.magenta>这包含sRGB和</c>
<c.magenta>其它的色彩空间</c>

00:35:48.415 --> 00:35:53.086
<c.magenta>NSColor中有新构造方法</c>
<c.magenta>displayP3红色 绿色 蓝色 阿尔法值</c>

00:35:53.153 --> 00:35:55.589
<c.magenta>它允许你</c>
<c.magenta>在颜色空间中创建一个颜色</c>

00:35:55.789 --> 00:35:58.692
<c.magenta>UIColor具有相同的构造函数</c>
<c.magenta>具有相同的效果</c>

00:35:59.760 --> 00:36:01.595
<c.magenta>另一种方式具有广泛的颜色</c>

00:35:59.760 --> 00:36:01.595
<c.magenta>另一种方式具有广泛的颜色</c>

00:36:01.662 --> 00:36:05.098
<c.magenta>采用的方式</c>
<c.magenta>我们调用扩展范围sRGB</c>

00:36:06.667 --> 00:36:09.837
<c.magenta>所以用色彩空间时</c>
<c.magenta>你通常被限制</c>

00:36:09.903 --> 00:36:11.872
<c.magenta>元件值从0到1</c>

00:36:12.406 --> 00:36:14.274
<c.magenta>且你可在色域范围内选择任何颜色</c>

00:36:14.341 --> 00:36:16.710
<c.magenta>比如蓝色 通过这些值</c>

00:36:17.311 --> 00:36:20.147
<c.magenta>但你不能代表一个颜色</c>
<c.magenta>这就是色域之外</c>

00:36:20.214 --> 00:36:22.583
<c.magenta>所以sRGB不能代表这个绿色的颜色</c>

00:36:23.550 --> 00:36:26.353
<c.magenta>扩展范围sRGB</c>
<c.magenta>使用相同的基色</c>

00:36:26.420 --> 00:36:29.389
<c.magenta>和相同的白色点为sRGB</c>
<c.magenta>但允许部件</c>

00:36:29.456 --> 00:36:32.059
<c.magenta>采取值小于</c>
<c.magenta>0或大于1</c>

00:36:32.759 --> 00:36:36.163
<c.magenta>所以它可以代表这个绿色</c>
<c.magenta>通过一个负的红色和蓝色的值</c>

00:36:36.230 --> 00:36:38.131
<c.magenta>和一个大于1的绿色值</c>

00:36:39.066 --> 00:36:42.069
<c.magenta>这恰好也是P3</c>
<c.magenta>绿色的原始值 因此</c>

00:36:42.135 --> 00:36:45.105
<c.magenta>扩展范围的sRGB</c>
<c.magenta>你可以代表全范围</c>

00:36:45.172 --> 00:36:47.207
<c.magenta>你需要的颜色</c>
<c.magenta>在显示器上</c>

00:36:48.542 --> 00:36:51.311
<c.magenta>这也有一个彩色空间</c>
<c.magenta>extendedSRGB</c>

00:36:51.879 --> 00:36:53.380
<c.magenta>和现有的NSColor</c>

00:36:53.447 --> 00:36:55.616
<c.magenta>以及UIColor已经在使用的函数</c>

00:36:55.782 --> 00:36:57.951
<c.magenta>先前提供的</c>
<c.magenta>颜色使用sRGB</c>

00:36:58.218 --> 00:37:01.555
<c.magenta>现在将接受较少的值</c>
<c.magenta>小于0或大于1</c>

00:36:58.218 --> 00:37:01.555
<c.magenta>现在将接受较少的值</c>
<c.magenta>小于0或大于1</c>

00:37:01.622 --> 00:37:03.891
<c.magenta>给你回一个</c>
<c.magenta>扩展范围的sRGB色</c>

00:37:04.391 --> 00:37:05.359
<c.magenta>这是非常方便的</c>

00:37:07.461 --> 00:37:08.662
<c.magenta>考虑一个重要的事</c>

00:37:08.729 --> 00:37:11.732
<c.magenta>这些更广泛的颜色</c>
<c.magenta>色域颜色深度</c>

00:37:12.132 --> 00:37:15.736
<c.magenta>所以sRGB理论上可以</c>
<c.magenta>表示在其色域任何颜色</c>

00:37:15.802 --> 00:37:17.137
<c.magenta>但每比特8位</c>

00:37:17.204 --> 00:37:20.440
<c.magenta>你也只能解决数量有限的 是的</c>

00:37:20.507 --> 00:37:22.876
<c.magenta>这里的黑色空间只是非寻址颜色</c>

00:37:22.943 --> 00:37:24.411
<c.magenta>使用8位每组件</c>

00:37:25.812 --> 00:37:29.283
<c.magenta>当你扩大色域 增加该色域的音量</c>

00:37:29.349 --> 00:37:31.118
<c.magenta>但保持相同的位深度</c>

00:37:31.185 --> 00:37:33.687
<c.magenta>你是可寻址的色密度下降</c>

00:37:34.121 --> 00:37:37.524
<c.magenta>你能够指定的颜色丢失精度</c>

00:37:38.158 --> 00:37:39.193
<c.magenta>这就是为何我们建议</c>

00:37:39.259 --> 00:37:42.462
<c.magenta>工作时</c>
<c.magenta>这些更广泛的色彩空间中 如P3</c>

00:37:42.529 --> 00:37:45.165
<c.magenta>你用16位比特</c>
<c.magenta>使用每个组件</c>

00:37:46.333 --> 00:37:48.535
<c.magenta>它内存和存储数量翻倍</c>

00:37:48.602 --> 00:37:51.271
<c.magenta>但给你成倍增长更多可寻址颜色</c>

00:37:51.338 --> 00:37:52.973
<c.magenta>因此 我们认为 权衡是值得的</c>

00:37:54.374 --> 00:37:57.945
<c.magenta>需要使用什么API</c>
<c.magenta>考虑到这些更深的颜色</c>

00:37:58.412 --> 00:38:00.981
<c.magenta>好了 好消息是</c>
<c.magenta>大多数都是自动的</c>

00:37:58.412 --> 00:38:00.981
<c.magenta>好了 好消息是</c>
<c.magenta>大多数都是自动的</c>

00:38:01.048 --> 00:38:04.151
<c.magenta>所以NSWindow将自动使用</c>
<c.magenta>较深的支持存储</c>

00:38:04.251 --> 00:38:07.321
<c.magenta>有了这些更高的位深度</c>
<c.magenta>宽色域显示</c>

00:38:07.387 --> 00:38:09.289
<c.magenta>即使你拖动</c>
<c.magenta>它在整个屏幕</c>

00:38:09.990 --> 00:38:11.959
<c.magenta>如果你需要一个方法</c>
<c.magenta>明确控制</c>

00:38:12.025 --> 00:38:15.295
<c.magenta>你可以设置深度限制属性</c>
<c.magenta>为你选的值</c>

00:38:16.430 --> 00:38:18.832
<c.magenta>视图和层内窗口会自动</c>

00:38:18.899 --> 00:38:22.202
<c.magenta>继承该位深度</c>
<c.magenta>唯一的例外是OpenGL视图</c>

00:38:22.636 --> 00:38:25.138
<c.magenta>你应该用</c>
<c.magenta>相关的像素格式的API</c>

00:38:26.406 --> 00:38:31.478
<c.magenta>在macOS和iOS的</c>
<c.magenta>CALayer有一新内容格式的属性</c>

00:38:32.079 --> 00:38:35.682
<c.magenta>允许你再次</c>
<c.magenta>明确控制它使用比特深度</c>

00:38:36.517 --> 00:38:39.119
<c.magenta>所以这是你可以利用的优势</c>
<c.magenta>在你的应用广泛的颜色</c>

00:38:39.186 --> 00:38:42.122
<c.magenta>我们也提高了部分</c>
<c.magenta>系统性能 能够更好的利用</c>

00:38:42.189 --> 00:38:43.357
<c.magenta>这些广泛的色彩</c>

00:38:43.790 --> 00:38:45.259
<c.magenta>一个例子是彩色面板</c>

00:38:45.659 --> 00:38:47.294
<c.magenta>所以 在iMac左边</c>

00:38:47.361 --> 00:38:49.530
<c.magenta>颜色盘会显示</c>

00:38:51.231 --> 00:38:52.065
<c.magenta>开始</c>

00:38:52.132 --> 00:38:55.969
<c.magenta>它实际上会显示和允许</c>
<c.magenta>从全方位的P3的颜色</c>

00:38:57.371 --> 00:38:59.773
<c.magenta>超出sRGB</c>
<c.magenta>正常颜色轮也会允许</c>

00:39:00.574 --> 00:39:03.677
<c.magenta>然而 你也能</c>
<c.magenta>右键单击颜色轮</c>

00:39:03.744 --> 00:39:06.280
<c.magenta>并明确选择</c>
<c.magenta>工作区色彩空间</c>

00:39:06.680 --> 00:39:09.783
<c.magenta>因此 即使在这些以前的显示器</c>
<c.magenta>不能使P3的颜色</c>

00:39:09.850 --> 00:39:11.785
<c.magenta>你仍然可以允许选则他们</c>

00:39:13.954 --> 00:39:15.989
<c.magenta>RGB颜色选择器</c>
<c.magenta>始终允许你</c>

00:39:16.056 --> 00:39:17.858
<c.magenta>选择颜色</c>
<c.magenta>替换你工作空间</c>

00:39:17.925 --> 00:39:19.960
<c.magenta>但它也允许你</c>
<c.magenta>改变表示</c>

00:39:20.027 --> 00:39:24.198
<c.magenta>从8位值</c>
<c.magenta>从0到255到浮点数</c>

00:39:24.565 --> 00:39:25.966
<c.magenta>所以你又能得到精度更高</c>

00:39:26.033 --> 00:39:28.001
<c.magenta>工作时</c>
<c.magenta>有了这些更广泛的色彩空间</c>

00:39:28.702 --> 00:39:32.539
<c.magenta>这些颜色面板的变化是</c>
<c.magenta>所有的应用程序完全免费</c>

00:39:32.606 --> 00:39:34.575
<c.magenta>没有任何的接口需要调用</c>

00:39:36.310 --> 00:39:39.313
<c.magenta>工作具有广泛的颜色</c>
<c.magenta>星期四的谈话涵盖更多</c>

00:39:39.379 --> 00:39:41.748
<c.magenta>如目录支持</c>
<c.magenta>WebKit支持</c>

00:39:42.149 --> 00:39:45.018
<c.magenta>我建议你更新出来</c>
<c.magenta>如果这些东西使你感兴趣</c>

00:39:46.520 --> 00:39:49.056
<c.magenta>因此 下一个主题是</c>
<c.magenta>状况项目改进</c>

00:39:49.122 --> 00:39:50.591
<c.magenta>所以状态项的事情</c>

00:39:50.657 --> 00:39:52.860
<c.magenta>底部的菜单栏</c>

00:39:52.926 --> 00:39:54.795
<c.magenta>这些是</c>
<c.magenta>先前的使用要求</c>

00:39:54.862 --> 00:39:57.965
<c.magenta>私有API来实现</c>
<c.magenta>但现在大多是免费的</c>

00:39:58.932 --> 00:40:00.367
<c.magenta>首先是排序</c>

00:39:58.932 --> 00:40:00.367
<c.magenta>首先是排序</c>

00:40:00.434 --> 00:40:03.604
<c.magenta>现在你可以命令点击</c>
<c.magenta>拖动任何项目排序它</c>

00:40:03.670 --> 00:40:05.873
<c.magenta>内部和外部的系统项目</c>

00:40:06.440 --> 00:40:09.476
<c.magenta>你也可以用键盘</c>
<c.magenta>焦点转到您的项</c>

00:40:09.543 --> 00:40:11.712
<c.magenta>甚至激活菜单项内</c>

00:40:12.779 --> 00:40:15.983
<c.magenta>这一切最好的部分 这是完全自动的</c>

00:40:16.049 --> 00:40:17.918
<c.magenta>没有API选择或链接检查</c>

00:40:18.485 --> 00:40:21.054
<c.magenta>所以所有的项目都是命令点击</c>
<c.magenta>拖动重新排序</c>

00:40:21.321 --> 00:40:24.858
<c.magenta>和任何菜单设置的项目</c>
<c.magenta>将参与键盘导航</c>

00:40:25.192 --> 00:40:27.928
<c.magenta>如果他们有一个自定义的目标活动</c>
<c.magenta>他们会被跳过</c>

00:40:29.463 --> 00:40:31.265
<c.magenta>其次是隐藏和去除</c>

00:40:31.632 --> 00:40:34.401
<c.magenta>您现在可以命令单击</c>
<c.magenta>并将一个项目从状态栏中拖动</c>

00:40:34.468 --> 00:40:36.336
<c.magenta>移除通知该更改</c>

00:40:36.403 --> 00:40:38.472
<c.magenta>甚至编程恢复</c>

00:40:39.373 --> 00:40:41.642
<c.magenta>不同的排序</c>
<c.magenta>这就需要选择</c>

00:40:41.708 --> 00:40:44.511
<c.magenta>没有状态项目将</c>
<c.magenta>自动移除</c>

00:40:44.945 --> 00:40:47.347
<c.magenta>你可以通过设置</c>
<c.magenta>现状项目的行为</c>

00:40:47.414 --> 00:40:49.049
<c.magenta>包含removalAllowed</c>

00:40:49.683 --> 00:40:51.285
<c.magenta>你可以编程</c>
<c.magenta>读/设置</c>

00:40:51.351 --> 00:40:55.022
<c.magenta>甚至得到KVO通知这个变化的</c>
<c.magenta>利用可见属性</c>

00:40:55.589 --> 00:40:57.491
<c.magenta>如果你的应用是一个状态栏的应用</c>

00:40:57.558 --> 00:41:00.260
<c.magenta>它只表示意义</c>
<c.magenta>是在状态栏图标</c>

00:40:57.558 --> 00:41:00.260
<c.magenta>它只表示意义</c>
<c.magenta>是在状态栏图标</c>

00:41:00.327 --> 00:41:03.597
<c.magenta>有无文件图标或其他的方式</c>
<c.magenta>要退出它 你可以设置它</c>

00:41:03.664 --> 00:41:05.599
<c.magenta>自动退出清除</c>

00:41:05.666 --> 00:41:07.801
<c.magenta>通过设置terminationOnRemoval行为</c>

00:41:09.369 --> 00:41:11.738
<c.magenta>所有这一切都会为你保存</c>
<c.magenta>位置</c>

00:41:11.805 --> 00:41:13.473
<c.magenta>和可见的状态</c>
<c.magenta>所以你不必担心</c>

00:41:13.540 --> 00:41:16.443
<c.magenta>为了保持使用</c>
<c.magenta>自动保存名字</c>

00:41:16.910 --> 00:41:19.346
<c.magenta>我们自动生成</c>
<c.magenta>这种基于项目指标</c>

00:41:19.413 --> 00:41:21.014
<c.magenta>你在你的应用程序中创建的</c>

00:41:21.481 --> 00:41:23.784
<c.magenta>但如果你创造它们</c>
<c.magenta>一些非确定性的顺序</c>

00:41:23.851 --> 00:41:25.485
<c.magenta>或者只是想拥有</c>
<c.magenta>更明确的控制</c>

00:41:25.686 --> 00:41:29.022
<c.magenta>您可以设置自动保存的名称</c>
<c.magenta>你选择一些标识符</c>

00:41:30.290 --> 00:41:31.658
<c.magenta>这样的状况项目改进</c>

00:41:31.725 --> 00:41:33.961
<c.magenta>很多都是免费的</c>
<c.magenta>和一点点的调整</c>

00:41:34.027 --> 00:41:36.163
<c.magenta>你真的可以使他们</c>
<c.magenta>在应用程序中更好使用</c>

00:41:37.097 --> 00:41:39.132
<c.magenta>下一个是控件构造函数</c>

00:41:39.533 --> 00:41:42.636
<c.magenta>所以这些新的构造函数</c>
<c.magenta>在现有NS控制</c>

00:41:42.703 --> 00:41:45.806
<c.magenta>这使它很容易</c>
<c.magenta>得到标准的外观和感觉</c>

00:41:46.507 --> 00:41:50.711
<c.magenta>例如 不同类型的按钮</c>
<c.magenta>分段控制</c>

00:41:50.944 --> 00:41:55.649
<c.magenta>图像视图 滑块</c>
<c.magenta>标签和文本字段</c>

00:41:56.116 --> 00:41:57.918
<c.magenta>所以这些类型的</c>
<c.magenta>已有的</c>

00:41:57.985 --> 00:41:59.753
<c.magenta>Interface Builder对象库</c>

00:41:59.820 --> 00:42:02.990
<c.magenta>这使得它很容易使用盒子的性能</c>

00:41:59.820 --> 00:42:02.990
<c.magenta>这使得它很容易使用盒子的性能</c>

00:42:03.624 --> 00:42:07.227
<c.magenta>他们跟标准的系统设置</c>
<c.magenta>合适的字体大小 颜色和文本颜色</c>

00:42:07.294 --> 00:42:09.162
<c.magenta>他们支持不同的情境</c>

00:42:09.229 --> 00:42:12.833
<c.magenta>浅绿色充满动感的标签看起来很棒</c>

00:42:12.900 --> 00:42:15.469
<c.magenta>甚至盒子中充满动感的暗色</c>

00:42:15.536 --> 00:42:17.070
<c.magenta>没有额外的安装</c>

00:42:17.471 --> 00:42:20.007
<c.magenta>这将对你代码起何作用</c>
<c.magenta>我想向你举例说明</c>

00:42:20.974 --> 00:42:22.643
<c.magenta>这是创建一个复选框前</c>

00:42:22.709 --> 00:42:24.278
<c.magenta>需设置相当多的属性</c>

00:42:24.344 --> 00:42:26.947
<c.magenta>不幸的是</c>
<c.magenta>我们真的只关心其中的三个</c>

00:42:27.014 --> 00:42:28.682
<c.magenta>标题 目标和行动</c>

00:42:29.816 --> 00:42:33.187
<c.magenta>复选框 以及标题 目标</c>
<c.magenta>行动 剩下的</c>

00:42:33.587 --> 00:42:34.688
<c.magenta>这是非常好的</c>

00:42:38.158 --> 00:42:39.560
<c.magenta>更多的一点 哦</c>

00:42:42.196 --> 00:42:43.030
<c.magenta>等着</c>

00:42:43.530 --> 00:42:45.599
<c.magenta>所以这就是创造一个静态标签</c>

00:42:45.666 --> 00:42:47.401
<c.magenta>只是屏幕上的一些文字</c>

00:42:47.467 --> 00:42:50.237
<c.magenta>而在这里 我们关心的</c>
<c.magenta>只是字符串值</c>

00:42:50.971 --> 00:42:53.974
<c.magenta>有文字的标签 又是这样的</c>

00:42:54.808 --> 00:42:56.977
<c.magenta>所以 这非常棒</c>

00:42:57.044 --> 00:42:58.445
<c.magenta>它是从盒子里出来的</c>

00:43:03.417 --> 00:43:06.687
<c.magenta>它出来的盒子可以用</c>
<c.magenta>带或不带自动布局</c>

00:43:06.753 --> 00:43:08.922
<c.magenta>所以 如果你要</c>
<c.magenta>定位约束</c>

00:43:08.989 --> 00:43:11.024
<c.magenta>你还需要设置</c>
<c.magenta>translatesAutoresizingMask</c>

00:43:11.091 --> 00:43:14.361
<c.magenta>IntoConstaints为假</c>
<c.magenta>像你其他的视图一样</c>

00:43:14.695 --> 00:43:16.997
<c.magenta>所以如果你已经有了类</c>
<c.magenta>做这些事情</c>

00:43:17.064 --> 00:43:19.166
<c.magenta>我们仍然建议移动到</c>
<c.magenta>这些新的系统</c>

00:43:19.233 --> 00:43:21.702
<c.magenta>因为你会确保</c>
<c.magenta>你的控制有标准的外观</c>

00:43:21.768 --> 00:43:24.137
<c.magenta>感觉现在和未来</c>

00:43:25.639 --> 00:43:28.041
<c.magenta>我最后想谈的是API的改进</c>

00:43:28.108 --> 00:43:30.644
<c.magenta>我只覆盖了一些这些</c>
<c.magenta>适用于我们所有的框架</c>

00:43:30.711 --> 00:43:32.212
<c.magenta>这些申请AppKit</c>

00:43:32.279 --> 00:43:35.082
<c.magenta>我还想谈谈适用于AppKit</c>
<c.magenta>的另外两点</c>

00:43:36.016 --> 00:43:37.684
<c.magenta>首先是弱委托</c>

00:43:38.352 --> 00:43:40.654
<c.magenta>所以我们已经添加了新的归零</c>
<c.magenta>弱委托的支持</c>

00:43:40.721 --> 00:43:44.124
<c.magenta>对于不同的代表和数据</c>
<c.magenta>不同类别的源</c>

00:43:45.025 --> 00:43:46.860
<c.magenta>所以你不再需要明确这些属性</c>

00:43:46.927 --> 00:43:48.562
<c.magenta>当引用们被释放</c>

00:43:49.696 --> 00:43:52.032
<c.magenta>它仍然支持非弱引用的对象</c>

00:43:52.232 --> 00:43:54.501
<c.magenta>在这种情况下 它会回到原有的分配</c>

00:43:54.568 --> 00:43:56.570
<c.magenta>或不安全的 不保留语义</c>

00:43:57.838 --> 00:43:59.072
<c.magenta>我们也经历过并确定了</c>

00:43:59.139 --> 00:44:02.843
<c.magenta>我们所有的类显式</c>
<c.magenta>并宣布其指定的初始化</c>

00:43:59.139 --> 00:44:02.843
<c.magenta>我们所有的类显式</c>
<c.magenta>并宣布其指定的初始化</c>

00:44:03.377 --> 00:44:05.646
<c.magenta>这些是和他们以前一样有效的</c>

00:44:05.712 --> 00:44:08.115
<c.magenta>但现在只是</c>
<c.magenta>在实际的接口中声明</c>

00:44:08.682 --> 00:44:10.551
<c.magenta>有一个例外</c>
<c.magenta>NSCursor</c>

00:44:10.617 --> 00:44:13.187
<c.magenta>所以 如果你是子NSCursor</c>
<c.magenta>请看发行说明</c>

00:44:13.253 --> 00:44:14.922
<c.magenta>你应该</c>
<c.magenta>正确处理</c>

00:44:16.290 --> 00:44:18.725
<c.magenta>与所有的新声明</c>
<c.magenta>指定的初始化</c>

00:44:19.059 --> 00:44:23.163
<c.magenta>你应该确保你是正确的</c>
<c.magenta>在你的类的处理</c>

00:44:24.198 --> 00:44:25.766
<c.magenta>所以如果你以前没有</c>

00:44:25.832 --> 00:44:27.534
<c.magenta>你可能会有这些错误问题</c>

00:44:27.601 --> 00:44:29.236
<c.magenta>这也许是微妙的错误</c>

00:44:29.436 --> 00:44:31.772
<c.magenta>在Objective-C</c>
<c.magenta>现在看到的编译警告</c>

00:44:31.839 --> 00:44:33.841
<c.magenta>在Swift 你要去</c>
<c.magenta>获得建立失败</c>

00:44:34.308 --> 00:44:37.044
<c.magenta>所以你要确保你</c>
<c.magenta>妥善处理这些不同的情况</c>

00:44:38.212 --> 00:44:39.413
<c.magenta>这是AppKit最新内容</c>

00:44:39.479 --> 00:44:40.714
<c.magenta>在这一点上</c>
<c.magenta>我想翻过去</c>

00:44:40.781 --> 00:44:43.083
<c.magenta>有请Ali</c>
<c.magenta>讲述“Foundation有何新特性”</c>

00:44:50.490 --> 00:44:51.391
<c.magenta>谢谢你 Taylor</c>

00:44:53.861 --> 00:44:56.463
<c.magenta>所以这里有一些东西</c>
<c.magenta>这是新基础</c>

00:44:56.530 --> 00:44:58.632
<c.magenta>现在进入主题</c>

00:44:59.299 --> 00:45:02.336
<c.magenta>现在你看到了</c>
<c.magenta>NSURL成为URL</c>

00:44:59.299 --> 00:45:02.336
<c.magenta>现在你看到了</c>
<c.magenta>NSURL成为URL</c>

00:45:02.402 --> 00:45:04.872
<c.magenta>我想我们昨天也谈到了一点</c>

00:45:04.938 --> 00:45:08.642
<c.magenta>我们把NS前缀</c>
<c.magenta>在Swift中添加了快捷键</c>

00:45:10.410 --> 00:45:13.280
<c.magenta>现在 你可能知道</c>
<c.magenta>地基大的子集</c>

00:45:13.347 --> 00:45:16.416
<c.magenta>实际上</c>
<c.magenta>用Swift核心库</c>

00:45:16.483 --> 00:45:18.085
<c.magenta>作为Swift 代码部分</c>

00:45:18.151 --> 00:45:20.621
<c.magenta>是可用的</c>
<c.magenta>在其他平台上 如Linux</c>

00:45:21.321 --> 00:45:25.526
<c.magenta>我们要匹配的命名样式</c>
<c.magenta>这部分的基础</c>

00:45:25.592 --> 00:45:28.028
<c.magenta>随着公约的建立</c>
<c.magenta>通过Swift标准库</c>

00:45:28.095 --> 00:45:29.963
<c.magenta>而不使用前缀</c>

00:45:31.164 --> 00:45:35.002
<c.magenta>因此 我们的类型很多</c>
<c.magenta>没有了NS前缀</c>

00:45:35.068 --> 00:45:36.970
<c.magenta>在基础和Swift中</c>
<c.magenta>正如你所看到的</c>

00:45:37.037 --> 00:45:38.972
<c.magenta>NSFormatter变成了</c>
<c.magenta>Formatter等等</c>

00:45:39.306 --> 00:45:42.576
<c.magenta>最后两个 NSData和NSURL</c>
<c.magenta>是一个特殊类别的一部分</c>

00:45:42.643 --> 00:45:44.878
<c.magenta>我会提到这一点</c>

00:45:45.913 --> 00:45:48.182
<c.magenta>现在 这正在发生</c>
<c.magenta>只有在基础上修改</c>

00:45:48.248 --> 00:45:49.349
<c.magenta>这不是我们应用的东西</c>

00:45:49.416 --> 00:45:52.186
<c.magenta>到我们的其他框架</c>
<c.magenta>甚至在基础</c>

00:45:52.252 --> 00:45:54.154
<c.magenta>这只是应用于一些API</c>

00:45:54.221 --> 00:45:56.757
<c.magenta>我们不把这</c>
<c.magenta>NS放到API</c>

00:45:56.823 --> 00:45:59.326
<c.magenta>本质上依赖于Objective-C</c>

00:45:59.393 --> 00:46:03.230
<c.magenta>例如 NSObject</c>
<c.magenta>NSProxy NSAutoreleasePool</c>

00:45:59.393 --> 00:46:03.230
<c.magenta>例如 NSObject</c>
<c.magenta>NSProxy NSAutoreleasePool</c>

00:46:03.530 --> 00:46:06.633
<c.magenta>我们也不把它的API</c>
<c.magenta>在特定的平台</c>

00:46:06.700 --> 00:46:09.303
<c.magenta>事实上</c>
<c.magenta>在其他平台上不可用</c>

00:46:09.369 --> 00:46:13.006
<c.magenta>比如NSUserNotification</c>
<c.magenta>NSXPCConnection</c>

00:46:14.341 --> 00:46:18.879
<c.magenta>在另一个情况是类</c>
<c.magenta>这也暴露了值类型</c>

00:46:19.313 --> 00:46:22.216
<c.magenta>所以在这里 我们正在暴露</c>
<c.magenta>数据 网址 等等 但</c>

00:46:22.282 --> 00:46:26.220
<c.magenta>我们也将NSData NSURL</c>

00:46:26.286 --> 00:46:27.855
<c.magenta>等等</c>
<c.magenta>我的意思是</c>

00:46:28.121 --> 00:46:30.791
<c.magenta>现在先让我解释</c>
<c.magenta>一点关于值类型</c>

00:46:32.025 --> 00:46:34.228
<c.magenta>你可能已经</c>
<c.magenta>熟悉值类型</c>

00:46:34.294 --> 00:46:36.697
<c.magenta>我们有这个概念在</c>
<c.magenta>基础很长一段时间</c>

00:46:36.763 --> 00:46:40.033
<c.magenta>这些类型的值是</c>
<c.magenta>重要的 而不是身份</c>

00:46:40.501 --> 00:46:44.505
<c.magenta>比如NSString NSData</c>
<c.magenta>URL  Array等等</c>

00:46:45.405 --> 00:46:49.643
<c.magenta>现在 由于一些基础的API</c>
<c.magenta>已经有这些值类型的语义</c>

00:46:49.710 --> 00:46:52.412
<c.magenta>我们已经提前并将</c>
<c.magenta>它们最为Swift值类型添加</c>

00:46:52.980 --> 00:46:55.682
<c.magenta>我们已经做的全套API</c>

00:46:55.883 --> 00:46:59.887
<c.magenta>这当然是</c>
<c.magenta>字符串 数组 字典</c>

00:46:59.953 --> 00:47:02.322
<c.magenta>和设置已经</c>
<c.magenta>作为值类型</c>

00:46:59.953 --> 00:47:02.322
<c.magenta>和设置已经</c>
<c.magenta>作为值类型</c>

00:47:02.389 --> 00:47:04.958
<c.magenta>在Swift中  他们是可用的</c>
<c.magenta>在标准库中</c>

00:47:05.425 --> 00:47:09.663
<c.magenta>所以现在这里的这些类型是</c>
<c.magenta>暴露结构在Swift中</c>

00:47:09.730 --> 00:47:13.534
<c.magenta>他们有价值的语义类型</c>
<c.magenta>这意味着他们可以直接变异</c>

00:47:13.600 --> 00:47:15.302
<c.magenta>如果他们有意义的可变性</c>

00:47:15.369 --> 00:47:19.173
<c.magenta>你可以使用let或者var突出异变</c>

00:47:19.540 --> 00:47:20.841
<c.magenta>在你声明他们的时候</c>

00:47:21.108 --> 00:47:24.011
<c.magenta>这些也符合Swift协议</c>

00:47:24.077 --> 00:47:25.445
<c.magenta>正如你所期望的</c>

00:47:28.182 --> 00:47:30.984
<c.magenta>现在已有的类的API</c>
<c.magenta>仍然保持在case</c>

00:47:31.051 --> 00:47:32.886
<c.magenta>在我们创建这些值类型</c>

00:47:32.953 --> 00:47:35.756
<c.magenta>让我看看</c>
<c.magenta>这里的案例研究</c>

00:47:36.123 --> 00:47:38.659
<c.magenta>一个例子是数据</c>
<c.magenta>我已经提到的那个</c>

00:47:38.725 --> 00:47:40.694
<c.magenta>所以现在我们的结构数据类型</c>

00:47:40.761 --> 00:47:42.329
<c.magenta>这是数据值类型</c>

00:47:42.429 --> 00:47:48.068
<c.magenta>这是我们期望的数据类型</c>
<c.magenta>在编程过程中使用最多</c>

00:47:48.135 --> 00:47:51.939
<c.magenta>这是前进的类型</c>
<c.magenta>然而 我们也有NSData</c>

00:47:52.005 --> 00:47:54.575
<c.magenta>这是NSObject和</c>
<c.magenta>NSMutableData子类</c>

00:47:54.641 --> 00:47:57.411
<c.magenta>这是一类NSData本身</c>

00:47:57.778 --> 00:48:01.348
<c.magenta>现在NS类型仍然存在</c>
<c.magenta>因为如NSMutableData</c>

00:47:57.778 --> 00:48:01.348
<c.magenta>现在NS类型仍然存在</c>
<c.magenta>因为如NSMutableData</c>

00:48:01.415 --> 00:48:05.052
<c.magenta>不是很容易迁移</c>
<c.magenta>所以他们不会迁移它</c>

00:48:05.452 --> 00:48:08.155
<c.magenta>我们的另一个原因是NS类型</c>
<c.magenta>有时你真的</c>

00:48:08.222 --> 00:48:09.423
<c.magenta>要继承这些类型</c>

00:48:09.489 --> 00:48:12.159
<c.magenta>你知道 你可以子类化</c>
<c.magenta>NSData或者NSMutableData</c>

00:48:12.226 --> 00:48:14.461
<c.magenta>提供一些专业化的实现</c>

00:48:14.528 --> 00:48:18.065
<c.magenta>当然 你可以这样做</c>
<c.magenta>类类型 如您在这里看到的</c>

00:48:18.131 --> 00:48:20.801
<c.magenta>所以这些都是一些原因</c>
<c.magenta>为什么NS类型仍然存在</c>

00:48:22.102 --> 00:48:24.471
<c.magenta>现在 让我们来看一看</c>
<c.magenta>这里有些差异</c>

00:48:25.772 --> 00:48:29.376
<c.magenta>NSData类有一个长度属性</c>

00:48:29.443 --> 00:48:31.745
<c.magenta>这个被命名为数</c>
<c.magenta>在结构版本</c>

00:48:31.812 --> 00:48:35.048
<c.magenta>因为它与其他</c>
<c.magenta>Swift标准库更一致</c>

00:48:35.482 --> 00:48:38.752
<c.magenta>如写入方法 范围</c>
<c.magenta>和许多其他方法</c>

00:48:38.819 --> 00:48:39.920
<c.magenta>保持相当完整</c>

00:48:39.987 --> 00:48:42.189
<c.magenta>他们遇到相同的</c>
<c.magenta>方法 除非你会注意到</c>

00:48:42.256 --> 00:48:45.692
<c.magenta>NSRange和NSData</c>
<c.magenta>已成为指标范围</c>

00:48:46.760 --> 00:48:50.697
<c.magenta>在数据结构的版本 这是</c>
<c.magenta>更符合Swift库</c>

00:48:50.931 --> 00:48:54.034
<c.magenta>最后你会注意到</c>
<c.magenta>这一变异的功能 如添加</c>

00:48:54.101 --> 00:48:57.237
<c.magenta>是不可以在这</c>
<c.magenta>直接值类型数据</c>

00:48:57.304 --> 00:49:00.374
<c.magenta>在NSData中</c>
<c.magenta>它在NSMutableData类中</c>

00:48:57.304 --> 00:49:00.374
<c.magenta>在NSData中</c>
<c.magenta>它在NSMutableData类中</c>

00:49:00.941 --> 00:49:02.342
<c.magenta>所以这些都是一些</c>
<c.magenta>的差异 你会看到</c>

00:49:02.409 --> 00:49:04.478
<c.magenta>在值类型</c>
<c.magenta>与类类型之间</c>

00:49:06.313 --> 00:49:08.382
<c.magenta>现在我不准备说</c>
<c.magenta>更多关于这个内容</c>

00:49:08.448 --> 00:49:11.585
<c.magenta>今天下午有一个谈话</c>
<c.magenta>“Swift基础有何新特性”</c>

00:49:11.652 --> 00:49:12.886
<c.magenta>在任务室里</c>

00:49:13.120 --> 00:49:15.722
<c.magenta>我鼓励你们参加</c>
<c.magenta>并听到更多关于这些内容</c>

00:49:17.824 --> 00:49:20.160
<c.magenta>现在我们有几个</c>
<c.magenta>基础新类型</c>

00:49:20.227 --> 00:49:21.862
<c.magenta>代表测量的量</c>

00:49:22.162 --> 00:49:24.264
<c.magenta>这里的主要类</c>
<c.magenta>是单元类</c>

00:49:24.331 --> 00:49:27.868
<c.magenta>这是一个抽象的类型</c>
<c.magenta>代表单位 如英里</c>

00:49:27.935 --> 00:49:30.504
<c.magenta>摄氏度 公里</c>
<c.magenta>每小时 等等</c>

00:49:30.904 --> 00:49:33.774
<c.magenta>然后我们有一个类维度</c>
<c.magenta>这是一个单位的子类</c>

00:49:33.841 --> 00:49:35.943
<c.magenta>这代表单位家庭</c>
<c.magenta>如长度</c>

00:49:36.043 --> 00:49:38.145
<c.magenta>温度和速度 等</c>

00:49:38.612 --> 00:49:40.047
<c.magenta>因此 在此 我们有单位类</c>

00:49:40.347 --> 00:49:43.383
<c.magenta>我们有子类维度</c>
<c.magenta>然后我们的子类</c>

00:49:44.117 --> 00:49:48.355
<c.magenta>如单位长度 单位温度</c>
<c.magenta>单位速度 和一堆更多</c>

00:49:50.090 --> 00:49:52.860
<c.magenta>有一个辅助类单元</c>
<c.magenta>转换器可以</c>

00:49:52.926 --> 00:49:55.395
<c.magenta>单位之间</c>
<c.magenta>同一单位家庭转换</c>

00:49:56.263 --> 00:49:59.399
<c.magenta>有一种结构测量</c>
<c.magenta>它是一个类</c>

00:49:59.466 --> 00:50:02.503
<c.magenta>在Objective-C</c>
<c.magenta>在Swift中作为一个值类型</c>

00:49:59.466 --> 00:50:02.503
<c.magenta>在Objective-C</c>
<c.magenta>在Swift中作为一个值类型</c>

00:50:02.936 --> 00:50:05.839
<c.magenta>结构测量相结合的值 如10</c>

00:50:05.906 --> 00:50:07.875
<c.magenta>用一个单位 如英里</c>

00:50:07.941 --> 00:50:09.843
<c.magenta>所以这基本上现在是一个测量</c>

00:50:09.910 --> 00:50:11.645
<c.magenta>最后锦上添花</c>

00:50:11.712 --> 00:50:13.614
<c.magenta>我们有测量</c>
<c.magenta>格式化程序类</c>

00:50:13.680 --> 00:50:15.449
<c.magenta>将一个测量</c>

00:50:15.516 --> 00:50:17.818
<c.magenta>并将其显示给用户区域中的用户</c>

00:50:18.318 --> 00:50:23.323
<c.magenta>所以它会显示10英里的用户</c>
<c.magenta>在美国这里</c>

00:50:23.390 --> 00:50:26.560
<c.magenta>但会显示16公里 例如在欧洲</c>

00:50:26.627 --> 00:50:27.728
<c.magenta>使用欧洲系统的用户</c>

00:50:27.794 --> 00:50:31.164
<c.magenta>所以它会为你做的转换</c>
<c.magenta>并向用户展示正确的数据</c>

00:50:36.803 --> 00:50:40.707
<c.magenta>我们有很多已定义即可用的</c>
<c.magenta>单位家庭定义</c>

00:50:40.774 --> 00:50:41.909
<c.magenta>这是全套</c>

00:50:42.142 --> 00:50:44.077
<c.magenta>所以这些尺度的子类</c>

00:50:44.144 --> 00:50:46.246
<c.magenta>在其中的每一个</c>
<c.magenta>单位家庭</c>

00:50:46.313 --> 00:50:49.383
<c.magenta>我们实际上有多个即可用的单位</c>

00:50:49.650 --> 00:50:51.919
<c.magenta>让我们看一看单位的温度</c>

00:50:52.352 --> 00:50:54.821
<c.magenta>你会看到温度</c>
<c.magenta>有三个标准单位</c>

00:50:54.888 --> 00:50:57.191
<c.magenta>开尔文 摄氏和华氏</c>

00:50:57.491 --> 00:51:01.728
<c.magenta>UnitTemperature类中</c>
<c.magenta>这些都被定义为类属性</c>

00:50:57.491 --> 00:51:01.728
<c.magenta>UnitTemperature类中</c>
<c.magenta>这些都被定义为类属性</c>

00:51:01.795 --> 00:51:05.966
<c.magenta>许多其他尺寸</c>
<c.magenta>也有一些单位规定</c>

00:51:06.033 --> 00:51:08.035
<c.magenta>知道彼此之间如何转换</c>

00:51:08.202 --> 00:51:13.207
<c.magenta>更好的消息</c>
<c.magenta>你可以添加你自定义的单位</c>

00:51:13.273 --> 00:51:16.510
<c.magenta>我们提供</c>
<c.magenta>它们将使用现有的</c>

00:51:16.577 --> 00:51:19.012
<c.magenta>而且你也可以添加</c>
<c.magenta>你自己的单位家庭</c>

00:51:19.413 --> 00:51:22.916
<c.magenta>你可以听到更多关于这个的内容</c>
<c.magenta>星期五下午4点</c>

00:51:22.983 --> 00:51:24.451
<c.magenta>测量和单位</c>

00:51:26.787 --> 00:51:29.356
<c.magenta>DateInterval是新类型</c>
<c.magenta>我们已添加到基础版本</c>

00:51:29.423 --> 00:51:32.059
<c.magenta>它表示一个日期间隔</c>

00:51:33.260 --> 00:51:36.597
<c.magenta>它有三个属性</c>
<c.magenta>开始 结束和持续时间</c>

00:51:36.663 --> 00:51:38.365
<c.magenta>相当直观 当然 这些都不是</c>

00:51:38.432 --> 00:51:41.435
<c.magenta>完全独立 但它们</c>
<c.magenta>作为三个独立的属性</c>

00:51:41.502 --> 00:51:42.769
<c.magenta>除了这些属性</c>

00:51:42.836 --> 00:51:46.640
<c.magenta>DateInterval能够做到</c>
<c.magenta>检查日期是否在日期间隔内</c>

00:51:46.707 --> 00:51:48.976
<c.magenta>或是否两个日期间隔重叠等</c>

00:51:49.510 --> 00:51:54.181
<c.magenta>当然日期间隔在格式化时很有用</c>

00:51:54.248 --> 00:51:55.682
<c.magenta>通过DateIntervalFormatter类</c>

00:51:55.749 --> 00:51:58.719
<c.magenta>这就是我们</c>
<c.magenta>这是我们去年发布API</c>

00:51:59.553 --> 00:52:01.788
<c.magenta>有个从String修改过来的</c>
<c.magenta>API接口</c>

00:51:59.553 --> 00:52:01.788
<c.magenta>有个从String修改过来的</c>
<c.magenta>API接口</c>

00:52:01.855 --> 00:52:05.092
<c.magenta>现在我们从API到String</c>
<c.magenta>只需要一个日期间隔</c>

00:52:05.659 --> 00:52:06.860
<c.magenta>如此相当简单</c>

00:52:07.728 --> 00:52:12.032
<c.magenta>现在在这里让我告诉你们</c>
<c.magenta>一个关于公共服务通告</c>

00:52:12.099 --> 00:52:13.500
<c.magenta>处理日期和时间</c>

00:52:14.635 --> 00:52:16.603
<c.magenta>所以处理日期可能是复杂的</c>

00:52:17.204 --> 00:52:19.106
<c.magenta>现在 这不是这里建议的</c>

00:52:19.173 --> 00:52:22.209
<c.magenta>好吗 我不是医生</c>

00:52:23.977 --> 00:52:26.313
<c.magenta>让我们说你想要</c>
<c.magenta>表示10秒时间</c>

00:52:26.780 --> 00:52:28.982
<c.magenta>你创建个DateInterval类</c>

00:52:29.049 --> 00:52:31.652
<c.magenta>开始时间和10秒</c>

00:52:31.718 --> 00:52:34.721
<c.magenta>这可能是正确的</c>
<c.magenta>无论你试图做什么</c>

00:52:34.788 --> 00:52:37.391
<c.magenta>无论你试图</c>
<c.magenta>怎样处理10秒</c>

00:52:37.791 --> 00:52:39.760
<c.magenta>但是让我们说你是</c>
<c.magenta>试图代表一天</c>

00:52:40.227 --> 00:52:42.196
<c.magenta>你也可能这样</c>
<c.magenta>写你的代码</c>

00:52:43.397 --> 00:52:46.433
<c.magenta>24乘以60乘以60表示一天的秒数</c>

00:52:46.900 --> 00:52:49.336
<c.magenta>这是一个数字</c>
<c.magenta>24小时内的秒数</c>

00:52:49.736 --> 00:52:52.873
<c.magenta>它往往不是</c>
<c.magenta>正确的</c>

00:52:53.240 --> 00:52:55.909
<c.magenta>原因是因为一天</c>
<c.magenta>并不总是24小时长</c>

00:52:55.976 --> 00:52:57.678
<c.magenta>一个月并非总是31天</c>

00:52:57.744 --> 00:53:00.280
<c.magenta>年不总是</c>
<c.magenta>365天 等等</c>

00:52:57.744 --> 00:53:00.280
<c.magenta>年不总是</c>
<c.magenta>365天 等等</c>

00:53:00.347 --> 00:53:02.783
<c.magenta>我们总是把那些记在心里</c>
<c.magenta>但是有时一天</c>

00:53:02.850 --> 00:53:07.688
<c.magenta>23小时 或者有时</c>
<c.magenta>24小时 25小时 如你所知</c>

00:53:08.222 --> 00:53:11.592
<c.magenta>所以取决于你想做什么</c>
<c.magenta>通过DateInterval表示日期</c>

00:53:11.959 --> 00:53:14.628
<c.magenta>你想设置一个闹钟吗</c>
<c.magenta>正是从现在开始的24个小时</c>

00:53:14.695 --> 00:53:17.865
<c.magenta>你想在第二天同一时间发出一闹钟吗</c>

00:53:17.931 --> 00:53:19.032
<c.magenta>你可要小心了</c>

00:53:19.233 --> 00:53:23.470
<c.magenta>通常情况下正确的解决方案</c>
<c.magenta>涉及使用日历类</c>

00:53:23.537 --> 00:53:25.205
<c.magenta>你会遇到这些问题</c>

00:53:25.272 --> 00:53:28.542
<c.magenta>而且幸运的是他们的解决方案</c>
<c.magenta>上面所提到的从2013年开始</c>

00:53:28.609 --> 00:53:30.511
<c.magenta>常见的数据的解决方案</c>
<c.magenta>和时间的问题</c>

00:53:30.577 --> 00:53:33.447
<c.magenta>我建议你</c>
<c.magenta>回去重新看看</c>

00:53:35.249 --> 00:53:38.752
<c.magenta>ISO8601 DateFormatter</c>
<c.magenta>是基础类中新提供的API</c>

00:53:38.819 --> 00:53:40.420
<c.magenta>这是一个格式化日期类</c>

00:53:40.787 --> 00:53:41.622
<c.magenta>谢谢</c>

00:53:45.392 --> 00:53:47.094
<c.magenta>很显然你们中的一些人</c>

00:53:47.160 --> 00:53:50.330
<c.magenta>以前使用8601</c>
<c.magenta>8601是一个标准</c>

00:53:50.397 --> 00:53:52.566
<c.magenta>这是一个用于指定日期的交换格式</c>

00:53:52.633 --> 00:53:53.967
<c.magenta>在明确的方法中</c>

00:53:54.334 --> 00:53:56.603
<c.magenta>所以这是一个单独的类</c>
<c.magenta>和DateFormatter相比</c>

00:53:56.670 --> 00:53:57.938
<c.magenta>因为不向DateFormatter</c>

00:53:58.005 --> 00:54:03.010
<c.magenta>它是用户本地化的日期</c>
<c.magenta>8601格式是非本地化</c>

00:53:58.005 --> 00:54:03.010
<c.magenta>它是用户本地化的日期</c>
<c.magenta>8601格式是非本地化</c>

00:54:03.310 --> 00:54:05.712
<c.magenta>你知道这是交换格式</c>
<c.magenta>所以这是一个单独的类型</c>

00:54:05.779 --> 00:54:08.115
<c.magenta>我们决定让事情变得简单</c>

00:54:08.448 --> 00:54:09.616
<c.magenta>使用起来非常简单</c>

00:54:10.484 --> 00:54:11.818
<c.magenta>所以创建一个格式化</c>

00:54:13.554 --> 00:54:16.390
<c.magenta>给自己一个日期</c>
<c.magenta>又没有关系的建议</c>

00:54:17.991 --> 00:54:20.527
<c.magenta>简单地问格式化程序</c>
<c.magenta>为日期转为字符串</c>

00:54:20.594 --> 00:54:22.129
<c.magenta>它会返回你的格式</c>

00:54:22.196 --> 00:54:24.531
<c.magenta>现在DateFormatter</c>
<c.magenta>可以两种方式实现</c>

00:54:24.731 --> 00:54:25.732
<c.magenta>所以你实际上可以</c>

00:54:25.799 --> 00:54:28.402
<c.magenta>哦 顺便说一下</c>
<c.magenta>这是调用的输出 正如你所看到的</c>

00:54:28.468 --> 00:54:29.903
<c.magenta>就要到午餐时间</c>

00:54:31.004 --> 00:54:33.407
<c.magenta>这里是 此格式化程序</c>
<c.magenta>还有其他的方式</c>

00:54:33.473 --> 00:54:34.641
<c.magenta>也做解析</c>

00:54:34.708 --> 00:54:38.612
<c.magenta>所以你可以自己格式化</c>
<c.magenta>并要求从字符串转换成日期</c>

00:54:38.679 --> 00:54:40.113
<c.magenta>它会返回你的日期</c>

00:54:40.180 --> 00:54:41.415
<c.magenta>所以它是双向的</c>

00:54:42.616 --> 00:54:46.286
<c.magenta>这默认是RFC 3339</c>
<c.magenta>它是一种格式</c>

00:54:46.353 --> 00:54:48.522
<c.magenta>然而</c>
<c.magenta>有选项可让您指定</c>

00:54:48.589 --> 00:54:50.691
<c.magenta>一些行为 如果你需要的话</c>

00:54:52.192 --> 00:54:55.495
<c.magenta>现在让我快速的告诉你们</c>
<c.magenta>我们提供的其他功能</c>

00:54:56.396 --> 00:55:00.434
<c.magenta>URL有一堆新的属性</c>

00:54:56.396 --> 00:55:00.434
<c.magenta>URL有一堆新的属性</c>

00:55:00.501 --> 00:55:04.104
<c.magenta>如一个文件和一系列其他的典型路径</c>

00:55:04.171 --> 00:55:06.406
<c.magenta>像音量是否加密等</c>

00:55:06.473 --> 00:55:08.542
<c.magenta>你可以阅读所有</c>
<c.magenta>这些在发行说明中</c>

00:55:08.609 --> 00:55:11.111
<c.magenta>有一个新类</c>
<c.magenta>URLSessionTaskMetrics</c>

00:55:11.512 --> 00:55:15.315
<c.magenta>这个类可以帮助你收集</c>
<c.magenta>网络资源</c>

00:55:15.382 --> 00:55:17.117
<c.magenta>加载性能信息</c>

00:55:17.184 --> 00:55:20.954
<c.magenta>所以你可以看看应用程序的网络性能</c>

00:55:22.422 --> 00:55:25.459
<c.magenta>PersonNameComponentsFormatter</c>
<c.magenta>是新版本我们提供的一个API</c>

00:55:25.893 --> 00:55:27.895
<c.magenta>正如你所知道的 它需要一个名字</c>

00:55:27.961 --> 00:55:30.697
<c.magenta>它以一个区域设置适当的方式来格式化</c>

00:55:31.064 --> 00:55:33.300
<c.magenta>在这个版本中</c>
<c.magenta>其实现在可以解析名称</c>

00:55:33.367 --> 00:55:35.135
<c.magenta>所以你给它一个名字</c>
<c.magenta>它会返回你</c>

00:55:35.202 --> 00:55:37.471
<c.magenta>名字 姓 等等</c>

00:55:37.538 --> 00:55:38.639
<c.magenta>这是一个不错的工作</c>

00:55:38.705 --> 00:55:41.475
<c.magenta>由于它采用了一种基于</c>
<c.magenta>真实数据的统计模型</c>

00:55:43.410 --> 00:55:45.445
<c.magenta>最后</c>

00:55:45.946 --> 00:55:47.814
<c.magenta>但也有一些棘手的名字</c>

00:55:47.881 --> 00:55:49.750
<c.magenta>所以不要期望太高</c>

00:55:52.853 --> 00:55:55.155
<c.magenta>DateComponentsFormatter</c>

00:55:55.222 --> 00:55:58.492
<c.magenta>是我们最新的版本中添加的</c>

00:55:58.559 --> 00:56:01.228
<c.magenta>除了长短类型</c>

00:55:58.559 --> 00:56:01.228
<c.magenta>除了长短类型</c>

00:56:01.295 --> 00:56:04.264
<c.magenta>我们现在有一个简单的风格</c>
<c.magenta>你可以格式化日期</c>

00:56:04.331 --> 00:56:07.000
<c.magenta>下一个发布</c>
<c.magenta>也许我们会添加boxer风格</c>

00:56:07.534 --> 00:56:09.369
<c.magenta>好吧 这就是基础</c>

00:56:11.305 --> 00:56:13.540
<c.magenta>核心数据 只是一个</c>
<c.magenta>简短的提及核心数据</c>

00:56:13.607 --> 00:56:15.576
<c.magenta>你已经看到一些</c>
<c.magenta>API的改进</c>

00:56:15.642 --> 00:56:16.844
<c.magenta>在核心数据与泛型</c>

00:56:16.910 --> 00:56:19.713
<c.magenta>有更多的</c>
<c.magenta>新的API在核心代码里</c>

00:56:19.780 --> 00:56:22.583
<c.magenta>比如generational查询</c>
<c.magenta>持久性存储</c>

00:56:22.649 --> 00:56:26.353
<c.magenta>NSFetchedResultsController类</c>
<c.magenta>现在在系统OS X中可以使用</c>

00:56:26.420 --> 00:56:28.689
<c.magenta>对不起 是macOS系统</c>

00:56:28.989 --> 00:56:32.392
<c.magenta>周五上午10点你将听到所有这一切</c>
<c.magenta>“核心数据有何新特性”</c>

00:56:33.026 --> 00:56:35.429
<c.magenta>还有一个我想大喊出来的</c>

00:56:36.430 --> 00:56:39.833
<c.magenta>我们每年都在这里</c>
<c.magenta>告诉你关于新的API</c>

00:56:39.900 --> 00:56:41.602
<c.magenta>介绍了新技术</c>

00:56:41.668 --> 00:56:44.471
<c.magenta>你可能并不总是处于一个方式</c>
<c.magenta>通过这些API</c>

00:56:44.538 --> 00:56:46.306
<c.magenta>因为你在做其他事情</c>

00:56:46.373 --> 00:56:48.041
<c.magenta>或者你等一个版本</c>

00:56:48.342 --> 00:56:51.712
<c.magenta>好吧 如果你想得到一个概述</c>
<c.magenta>关于最近我们已经添加的API</c>

00:56:51.778 --> 00:56:55.082
<c.magenta>APIs是重要的</c>
<c.magenta>创建用于Mac的现代应用</c>

00:56:55.148 --> 00:56:56.250
<c.magenta>这个谈话是给你们的</c>

00:56:56.450 --> 00:56:59.620
<c.magenta>它将涉及很多主题</c>
<c.magenta>他们将有</c>

00:56:59.686 --> 00:57:02.189
<c.magenta>其他感兴趣的演讲</c>
<c.magenta>不只是在本届 WWDC</c>

00:56:59.686 --> 00:57:02.189
<c.magenta>其他感兴趣的演讲</c>
<c.magenta>不只是在本届 WWDC</c>

00:57:02.256 --> 00:57:04.157
<c.magenta>往届 WWDC 也有</c>

00:57:04.391 --> 00:57:07.561
<c.magenta>它也适用于每个人</c>
<c.magenta>各年龄 不同经验水平</c>

00:57:07.895 --> 00:57:09.363
<c.magenta>这也是星期五下午5点</c>

00:57:09.429 --> 00:57:11.164
<c.magenta>所以我希望你在这里</c>

00:57:13.033 --> 00:57:17.471
<c.magenta>好的 那么这是网页</c>
<c.magenta>你可以了解更多信息</c>

00:57:17.738 --> 00:57:20.440
<c.magenta>请读AppKit</c>
<c.magenta>与基础版本说明</c>

00:57:20.507 --> 00:57:22.509
<c.magenta>您可以在我们的开发工具站点中找到</c>

00:57:22.576 --> 00:57:25.846
<c.magenta>它是一些原始信息</c>
<c.magenta>很多我已经谈到了</c>

00:57:26.146 --> 00:57:27.948
<c.magenta>这是我们提到的有关演讲</c>

00:57:28.015 --> 00:57:29.149
<c.magenta>还有更多的课程</c>

00:57:29.416 --> 00:57:30.350
<c.magenta>非常感谢大家</c>
