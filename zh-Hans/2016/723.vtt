WEBVTT

00:00:19.733 --> 00:00:21.300 align:middle
你好 我的名字是Tanya

00:00:21.367 --> 00:00:23.800 align:middle
欢迎参加第二部分

00:00:23.867 --> 00:00:25.867 align:middle
关于开发CarPlay系统

00:00:26.267 --> 00:00:28.867 align:middle
第一部分的视频已经准备好了

00:00:28.933 --> 00:00:31.867 align:middle
所以如果你还没有看过它
你一定要去看看

00:00:32.500 --> 00:00:34.600 align:middle
在这一部分
我们会覆盖更多细节

00:00:34.667 --> 00:00:36.367 align:middle
在CarPlay是如何集成

00:00:36.433 --> 00:00:39.367 align:middle
到一个典型的汽车
信息娱乐系统里的

00:00:40.367 --> 00:00:42.433 align:middle
我们从一个系统的概览开始

00:00:42.800 --> 00:00:45.600 align:middle
然后谈论音量和资源管理

00:00:45.933 --> 00:00:48.833 align:middle
最后以讨论应用状态管理结尾

00:00:50.267 --> 00:00:53.133 align:middle
现在让我们进入系统概览

00:00:54.833 --> 00:00:56.867 align:middle line:1
如果你观看了第一个视频

00:00:56.933 --> 00:01:01.200 align:middle line:1
你会记得要实现一个CarPlay
接收器所需的软件组成部分

00:00:56.933 --> 00:01:01.200 align:middle line:1
你会记得要实现一个CarPlay
接收器所需的软件组成部分

00:01:01.833 --> 00:01:05.667 align:middle line:1
总之你需要和主机之间
有一个基于IP的连接

00:01:05.733 --> 00:01:08.733 align:middle line:1
不管是USB或者Wi-Fi

00:01:09.267 --> 00:01:11.333 align:middle line:1
IP是为了交换数据

00:01:11.900 --> 00:01:14.400 align:middle line:1
CarPlay通讯插件的一个实例

00:01:14.467 --> 00:01:17.167 align:middle line:1
实现控制协议

00:01:17.233 --> 00:01:20.633 align:middle line:1
音频框架用来播放和录制声音

00:01:20.700 --> 00:01:23.167 align:middle line:1
视频框架用来渲染视频流

00:01:24.400 --> 00:01:28.500 align:middle line:1
然而这些组件只是一个子系统

00:01:28.567 --> 00:01:30.567 align:middle line:1
在一个典型的车载主机中

00:01:31.467 --> 00:01:34.267 align:middle line:1
除了CarPlay的功能

00:01:34.333 --> 00:01:39.000 align:middle line:1
主机还有自己的原生界面
音频资源和逻辑

00:01:39.800 --> 00:01:43.200 align:middle line:1
两者一起构成完整的主机

00:01:44.467 --> 00:01:45.500 align:middle line:1
然后你添加

00:01:45.567 --> 00:01:48.167 align:middle line:1
车里所有的硬件资源

00:01:48.233 --> 00:01:54.333 align:middle line:1
麦克风 音响 显示屏 传感器
用户输入设备

00:01:54.400 --> 00:01:56.567 align:middle line:1
然后你就有了完整的系统

00:01:58.100 --> 00:02:00.600 align:middle
好的 这样我们就有了整个系统

00:01:58.100 --> 00:02:00.600 align:middle
好的 这样我们就有了整个系统

00:02:01.067 --> 00:02:02.367 align:middle
现在的问题是

00:02:02.433 --> 00:02:06.867 align:middle
怎样让那些看起来互相竞争的子系统
互相协同工作？

00:02:08.199 --> 00:02:09.333 align:middle
让我们来理解这个问题

00:02:10.100 --> 00:02:13.800 align:middle
首先让我们来看看
传感器的数据是怎样被交换的

00:02:13.867 --> 00:02:16.533 align:middle
我们会用位置数据举例

00:02:17.133 --> 00:02:20.867 align:middle
位置信息包括GPS接收器获得的
数据

00:02:20.933 --> 00:02:23.900 align:middle
或者传感器数据比如轮胎速度

00:02:24.767 --> 00:02:27.733 align:middle
数据通过iAP2传输给设备

00:02:27.800 --> 00:02:29.433 align:middle
并且要一直可用

00:02:29.500 --> 00:02:32.100 align:middle
并且在手机需要时会被查询

00:02:33.533 --> 00:02:36.900 align:middle
接下来让我们来看看仪表组

00:02:36.967 --> 00:02:38.233 align:middle
也就是抬头显示

00:02:39.100 --> 00:02:40.867 align:middle
这个辅助显示

00:02:40.933 --> 00:02:43.967 align:middle
被用来显示设备提供的元数据

00:02:44.467 --> 00:02:48.767 align:middle
这些元数据可能包含
当前播放的音轨

00:02:49.100 --> 00:02:52.900 align:middle
正在进行的通话
或者从iOS 10开始

00:02:52.967 --> 00:02:54.733 align:middle
路线规划导航

00:02:55.233 --> 00:02:59.033 align:middle
数据还是通过IP协议发起

00:02:59.100 --> 00:03:00.900 align:middle
以及根据需要交换

00:02:59.100 --> 00:03:00.900 align:middle
以及根据需要交换

00:03:02.533 --> 00:03:05.867 align:middle
现在让我们来看看
主显示发生了什么

00:03:06.400 --> 00:03:10.000 align:middle
当然要控制
在显示屏上显示的内容

00:03:10.333 --> 00:03:13.133 align:middle
用户必须
用一个触摸屏

00:03:13.200 --> 00:03:15.100 align:middle
一个应用控制器
或者两者都用

00:03:15.600 --> 00:03:17.567 align:middle
所以我们可以认为

00:03:17.633 --> 00:03:21.733 align:middle
显示器和用户输入设备都是存在的

00:03:22.933 --> 00:03:25.200 align:middle
当CarPlay UI活动时

00:03:25.267 --> 00:03:29.100 align:middle
设备在主显示屏上渲染视频流

00:03:29.167 --> 00:03:33.233 align:middle
屏幕和用户输入都被设备使用

00:03:34.367 --> 00:03:39.400 align:middle
但是如果原生用户界面显示在
屏幕上

00:03:39.467 --> 00:03:42.233 align:middle
那么显示屏和用户输入都

00:03:42.300 --> 00:03:44.300 align:middle
被转到原生子系统

00:03:45.967 --> 00:03:49.767 align:middle
然而方向盘上额外的用户控制器

00:03:49.833 --> 00:03:53.367 align:middle
比如语音识别按钮
下/上一个单轨

00:03:53.433 --> 00:03:54.900 align:middle
可能与CarPlay相连

00:03:54.967 --> 00:03:57.900 align:middle
即使屏幕上显示的是原生UI

00:03:59.500 --> 00:04:02.933 align:middle
这样总是可以打开Siri

00:03:59.500 --> 00:04:02.933 align:middle
这样总是可以打开Siri

00:04:03.000 --> 00:04:05.067 align:middle
或者播放下一个单轨

00:04:07.333 --> 00:04:11.367 align:middle
我们已经看过用户界面集成

00:04:11.433 --> 00:04:12.900 align:middle
让我们来谈谈音频

00:04:16.867 --> 00:04:21.933 align:middle
车载音频可以被粗分成3类

00:04:22.000 --> 00:04:26.233 align:middle
第1类提供对音响和麦克风的使用

00:04:26.300 --> 00:04:29.367 align:middle
这被用来通话和进行语音识别

00:04:30.533 --> 00:04:32.900 align:middle
然后我们有音频播放

00:04:32.967 --> 00:04:36.833 align:middle
对任何媒体内容
比如收音机 音乐

00:04:38.033 --> 00:04:40.767 align:middle
最后我们有警告类别

00:04:40.833 --> 00:04:43.033 align:middle
被用作导航提示

00:04:43.100 --> 00:04:45.833 align:middle
或者其他更高优先级的警告

00:04:46.833 --> 00:04:48.833 align:middle
在原生子系统中

00:04:48.900 --> 00:04:52.600 align:middle
这三种类别会被重新发现

00:04:53.700 --> 00:04:57.000 align:middle
在CarPlay中
我们有一个主音频通道

00:04:57.067 --> 00:04:59.567 align:middle
它包括通话 语音识别

00:04:59.633 --> 00:05:01.300 align:middle
和音频播放

00:04:59.633 --> 00:05:01.300 align:middle
和音频播放

00:05:02.767 --> 00:05:06.100 align:middle
还有另一个音频通道被保留

00:05:06.167 --> 00:05:09.167 align:middle
给高优先级提示和声音

00:05:09.233 --> 00:05:13.033 align:middle
比如导航提示或者新消息通知

00:05:15.633 --> 00:05:17.167 align:middle
那么媒体通道

00:05:17.500 --> 00:05:20.533 align:middle
可以播放来自手机的音乐

00:05:21.433 --> 00:05:25.767 align:middle
或者播放来自原生音频资源
的媒体

00:05:27.033 --> 00:05:30.367 align:middle
现在我们看过了媒体播放

00:05:30.767 --> 00:05:32.367 align:middle
我们来看看发生了什么

00:05:32.433 --> 00:05:34.533 align:middle
当CarPlay接到电话时

00:05:35.900 --> 00:05:40.033 align:middle
通话需要音频通道提供

00:05:40.100 --> 00:05:42.633 align:middle
麦克风和音响

00:05:43.200 --> 00:05:47.600 align:middle
所以媒体播放被中断
并且通道被切换了

00:05:52.933 --> 00:05:55.167 align:middle
音频被切换到一个通道

00:05:55.233 --> 00:05:59.033 align:middle
这个通道提供对麦克风和音响
的访问

00:06:00.567 --> 00:06:03.533 align:middle
除了切换到音频通道

00:06:03.600 --> 00:06:07.567 align:middle
屏幕被切换到CarPlay来显示
通话UI

00:06:08.767 --> 00:06:12.033 align:middle
仪表组上的元数据信息

00:06:12.100 --> 00:06:13.500 align:middle
也会更新

00:06:15.467 --> 00:06:16.567 align:middle
当然

00:06:16.633 --> 00:06:21.233 align:middle
如果原生系统也支持通话

00:06:21.300 --> 00:06:25.533 align:middle
那么通话会使用原生系统
来播放和显示

00:06:26.500 --> 00:06:28.733 align:middle
但是在原生系统中通话时

00:06:28.800 --> 00:06:32.200 align:middle
用户可以用Apple Maps导航

00:06:33.900 --> 00:06:36.633 align:middle
所以每当接近转弯时

00:06:36.700 --> 00:06:38.767 align:middle
Apple Maps会播放一个声音

00:06:38.833 --> 00:06:41.467 align:middle
通过公告通道来通知用户

00:06:42.333 --> 00:06:46.033 align:middle
通话继续被转到汽车的音响上

00:06:46.433 --> 00:06:50.767 align:middle
但是路线规划导航通知也被显示

00:06:50.833 --> 00:06:53.133 align:middle
它们和通话音混合在一起

00:06:53.967 --> 00:06:56.000 align:middle
当然在这种情况下

00:06:56.433 --> 00:07:00.500 align:middle
我们不希望用户
听到手机的导航提示

00:06:56.433 --> 00:07:00.500 align:middle
我们不希望用户
听到手机的导航提示

00:07:00.700 --> 00:07:04.767 align:middle
只是一个警告音提醒前方有转弯

00:07:06.900 --> 00:07:09.633 align:middle
如果用户希望看到
下一个转弯在哪

00:07:09.700 --> 00:07:12.333 align:middle
主显示可以显示Apple Maps

00:07:13.733 --> 00:07:16.600 align:middle
最后当通话结束后

00:07:18.167 --> 00:07:21.600 align:middle
音乐继续通过原生子系统播放

00:07:22.300 --> 00:07:26.167 align:middle
就像用户在通话前正在听的一样

00:07:27.000 --> 00:07:29.467 align:middle
现在导航公告

00:07:29.533 --> 00:07:35.200 align:middle
将包括所有的导航语音
因为用户不再进行通话

00:07:36.367 --> 00:07:37.200 align:middle
好的

00:07:37.833 --> 00:07:42.833 align:middle
如你所见 集成CarPlay是一个
很复杂的任务

00:07:42.900 --> 00:07:46.300 align:middle
特别是在共享硬件资源方面

00:07:46.933 --> 00:07:49.733 align:middle
但是在我们进行这些细节前

00:07:49.800 --> 00:07:51.600 align:middle
让我们看看音量控制

00:07:53.933 --> 00:07:55.167 align:middle
音量管理

00:07:56.233 --> 00:07:57.533 align:middle
你们可能知道

00:07:58.000 --> 00:08:02.067 align:middle
一个普通的车载主机显示
音量指示

00:07:58.000 --> 00:08:02.067 align:middle
一个普通的车载主机显示
音量指示

00:08:02.133 --> 00:08:04.900 align:middle
当用户操作音量旋钮时

00:08:04.967 --> 00:08:06.133 align:middle
然后那个音量旋钮

00:08:06.200 --> 00:08:09.367 align:middle
控制当前播放的音频的音量

00:08:11.400 --> 00:08:14.533 align:middle
CarPlay音频也有相同原理

00:08:15.000 --> 00:08:17.633 align:middle
但是有一个不同的音量设置

00:08:17.700 --> 00:08:20.600 align:middle
对每一个主要的CarPlay应用

00:08:21.300 --> 00:08:22.533 align:middle
让我们看看它们

00:08:24.000 --> 00:08:25.467 align:middle
当播放Siri时

00:08:25.700 --> 00:08:29.367 align:middle
音量旋钮只对语音互动设置音量

00:08:30.333 --> 00:08:34.167 align:middle
当有来电时
来电铃声的音量被控制

00:08:35.732 --> 00:08:40.533 align:middle
当用户在通话中时
通话音量被控制

00:08:42.033 --> 00:08:46.667 align:middle
如果靠近下一个转弯
导航提示被播放

00:08:47.000 --> 00:08:49.900 align:middle
那么用户可以改变导航音量

00:08:50.600 --> 00:08:53.833 align:middle
请记住媒体可以在后台播放

00:08:54.000 --> 00:08:57.100 align:middle
但是它的音量会在有那些提示时
自动降低

00:08:57.167 --> 00:08:58.767 align:middle
而且不能被改变

00:09:00.233 --> 00:09:03.967 align:middle
一旦提示音结束并且音乐音量
恢复正常

00:09:04.067 --> 00:09:06.933 align:middle
这个旋钮就会控制媒体音量

00:09:08.267 --> 00:09:11.667 align:middle
好的现在让我们来看看资源管理

00:09:13.733 --> 00:09:17.600 align:middle
我们来看看哪些资源被管理

00:09:17.767 --> 00:09:19.700 align:middle
谈论他们怎样被管理

00:09:19.767 --> 00:09:22.267 align:middle
并讨论一些典型的例子

00:09:24.233 --> 00:09:27.233 align:middle
我们看到有很多硬件资源

00:09:27.633 --> 00:09:31.200 align:middle
但是让我们理解它们中的哪些
被管理了

00:09:32.600 --> 00:09:33.633 align:middle
只有2个

00:09:34.300 --> 00:09:37.700 align:middle
mainScreen是汽车的主显示

00:09:38.200 --> 00:09:39.500 align:middle
以及mainAudio

00:09:39.567 --> 00:09:43.000 align:middle
因为这个资源提供对车载音频
系统的访问

00:09:45.033 --> 00:09:48.467 align:middle
这些资源可以被占有或借用

00:09:49.367 --> 00:09:50.800 align:middle
当你占有一个资源时

00:09:50.867 --> 00:09:53.867 align:middle
它在无限的时间内属于你

00:09:53.933 --> 00:09:55.400 align:middle
它基本上就是你的

00:09:56.167 --> 00:09:59.467 align:middle
当你借用一个资源
你可以使用它一段时间

00:09:59.800 --> 00:10:02.500 align:middle
但是使用完后你要还回去

00:09:59.800 --> 00:10:02.500 align:middle
但是使用完后你要还回去

00:10:04.267 --> 00:10:10.367 align:middle
我们让原生用户界面
永久占有显示

00:10:10.833 --> 00:10:13.400 align:middle
用户可以使用原生导航

00:10:13.467 --> 00:10:15.333 align:middle
或者听收音机

00:10:15.400 --> 00:10:17.633 align:middle
或者修改一些汽车设置

00:10:19.033 --> 00:10:21.867 align:middle
怎样永久切换到原生UI？

00:10:22.833 --> 00:10:27.433 align:middle
原生UI可以在用户按硬件按钮时
占有屏幕

00:10:27.500 --> 00:10:29.333 align:middle
或者切换到原生UI

00:10:29.400 --> 00:10:32.567 align:middle
在CarPlay UI里的入口

00:10:33.267 --> 00:10:38.633 align:middle
或者用原生语音识别来启动
一个原生应用

00:10:40.767 --> 00:10:42.733 align:middle
现在假设用户选择

00:10:42.800 --> 00:10:45.367 align:middle
主菜单里的
Apple CarPlay图标

00:10:48.400 --> 00:10:49.600 align:middle
这种情况下

00:10:49.667 --> 00:10:53.967 align:middle
CarPlay接管屏幕
因为用户明确的要求这样

00:10:55.300 --> 00:10:58.700 align:middle
是什么导致的这个永久切换？

00:10:59.300 --> 00:11:01.233 align:middle
任何和CarPlay有关的硬件按钮

00:10:59.300 --> 00:11:01.233 align:middle
任何和CarPlay有关的硬件按钮

00:11:01.967 --> 00:11:03.500 align:middle
或者如我们所见

00:11:03.567 --> 00:11:06.500 align:middle
原生UI中的任何CarPlay按钮

00:11:07.267 --> 00:11:11.500 align:middle
或者通过Siri
例如通过说打开地图

00:11:14.000 --> 00:11:18.033 align:middle
现在有其他应用需要借用资源

00:11:18.433 --> 00:11:22.133 align:middle
请记住它们只需要使用一会
然后会还回来

00:11:23.200 --> 00:11:25.367 align:middle
我们在谈论哪些应用？

00:11:26.367 --> 00:11:29.067 align:middle
通话 话音互动

00:11:29.533 --> 00:11:32.033 align:middle
通知 警告

00:11:34.067 --> 00:11:35.433 align:middle
让我们来看一个例子

00:11:36.200 --> 00:11:39.333 align:middle
原生UI占用主屏幕资源

00:11:39.400 --> 00:11:41.567 align:middle
并且永久在屏幕上显示

00:11:43.933 --> 00:11:46.033 align:middle
现在用户在CarPlay里接到电话

00:11:46.567 --> 00:11:48.900 align:middle
CarPlay UI借用屏幕

00:11:48.967 --> 00:11:52.067 align:middle
并显示通话时间

00:11:52.900 --> 00:11:54.600 align:middle
一旦通话结束

00:11:55.567 --> 00:11:57.700 align:middle
我们回到原生UI

00:11:58.367 --> 00:12:01.500 align:middle
并保持这样直到有其他用户活动

00:11:58.367 --> 00:12:01.500 align:middle
并保持这样直到有其他用户活动

00:12:04.967 --> 00:12:07.533 align:middle
接下来让我们看看主音频资源

00:12:08.300 --> 00:12:11.133 align:middle
主音频可以被分为四个主要类型

00:12:11.433 --> 00:12:14.667 align:middle
每个类型被不同
CarPlay应用使用

00:12:14.933 --> 00:12:18.267 align:middle
因为它提供
对不同硬件资源的访问

00:12:19.733 --> 00:12:26.000 align:middle
媒体仅有音频输出
被用来播放所有媒体

00:12:26.633 --> 00:12:30.133 align:middle
警告仅有输出

00:12:30.200 --> 00:12:32.833 align:middle
被用来播放铃声和定时器警告

00:12:34.200 --> 00:12:37.067 align:middle
Siri使用语音识别

00:12:37.133 --> 00:12:39.267 align:middle
因为它加入了对麦克风的使用

00:12:40.700 --> 00:12:44.100 align:middle
对用来通话的电话类型同样如此

00:12:45.433 --> 00:12:49.933 align:middle
对用作未定义音频的默认类型
也是如此

00:12:52.400 --> 00:12:57.300 align:middle
但是不要忘记第二个音频通道
它用作导航公告

00:12:58.267 --> 00:13:02.767 align:middle
alternateAudio没有被管理
它基本上总是可用

00:12:58.267 --> 00:13:02.767 align:middle
alternateAudio没有被管理
它基本上总是可用

00:13:02.833 --> 00:13:05.133 align:middle
所以不需要占用或借用它

00:13:05.867 --> 00:13:07.800 align:middle
在mainAudio通道里

00:13:07.867 --> 00:13:11.833 align:middle
alternateAudio与所有的音频类型都
是混合在一起的

00:13:11.900 --> 00:13:13.533 align:middle
它总是可以被访问

00:13:15.100 --> 00:13:16.067 align:middle
就这些了

00:13:16.133 --> 00:13:19.800 align:middle
我要交给Tom来谈谈资源管理

00:13:22.867 --> 00:13:23.700 align:middle line:1
谢谢Tanya

00:13:23.867 --> 00:13:26.867 align:middle line:1
大家好 我是Tom
我也在CarPlay组里工作

00:13:27.533 --> 00:13:30.433 align:middle line:1
我们已经知道了哪些资源被管理

00:13:30.500 --> 00:13:33.200 align:middle line:1
而且你知道可以占有或借用资源

00:13:33.267 --> 00:13:35.433 align:middle line:1
让我们谈谈怎样管理它们

00:13:37.633 --> 00:13:42.533 align:middle
要在两个子系统中分配资源
我们需要仲裁者

00:13:42.600 --> 00:13:45.567 align:middle
我们把这个仲裁者叫做
资源管理器

00:13:49.467 --> 00:13:51.267 align:middle
资源管理器是干什么的？

00:13:51.900 --> 00:13:53.467 align:middle
它主要有三个任务

00:13:53.733 --> 00:13:56.533 align:middle
首先它知道整个系统的当前状态

00:13:57.433 --> 00:14:01.100 align:middle
其次它根据
一些严格的规则来决定

00:13:57.433 --> 00:14:01.100 align:middle
其次它根据
一些严格的规则来决定

00:14:01.167 --> 00:14:03.100 align:middle
哪个系统获得资源

00:14:03.600 --> 00:14:06.700 align:middle
第三根据当前状态和一系列规则

00:14:07.233 --> 00:14:09.933 align:middle
它把资源分配给一方或另一方

00:14:10.300 --> 00:14:12.333 align:middle
让我们看看实际中 它是如何工作的

00:14:14.833 --> 00:14:19.100 align:middle
假设原生UI和CarPlay
都需要在屏幕上显示一些信息

00:14:20.133 --> 00:14:23.300 align:middle
它们都发出申请要求获得
屏幕的所有权

00:14:25.400 --> 00:14:28.000 align:middle
那么资源管理器查看内部状态

00:14:28.067 --> 00:14:31.300 align:middle
并决定它们中的哪个应该获得屏幕

00:14:33.533 --> 00:14:35.967 align:middle
我们假设在这个情况下
原生UI的请求

00:14:36.033 --> 00:14:38.667 align:middle
有更高优先级
那么屏幕被分配给它

00:14:39.167 --> 00:14:41.200 align:middle
资源管理器发送通知

00:14:41.267 --> 00:14:43.467 align:middle
屏幕现在可以被原生UI使用

00:14:44.967 --> 00:14:48.533 align:middle
只有原生UI可以在屏幕上显示内容

00:14:49.333 --> 00:14:51.333 align:middle
必须要注意到状态并没有改变

00:14:51.400 --> 00:14:53.667 align:middle
直到资源管理器发送更新

00:14:56.333 --> 00:14:58.333 align:middle
那么资源管理器是在哪运行？

00:14:58.933 --> 00:15:01.600 align:middle
它是原生系统
还是CarPlay的一部分？

00:14:58.933 --> 00:15:01.600 align:middle
它是原生系统
还是CarPlay的一部分？

00:15:02.367 --> 00:15:05.800 align:middle
当我们设计CarPlay时
我们问了自己同样的问题

00:15:06.267 --> 00:15:10.400 align:middle
我们考虑了交换资源的详细信息
的复杂性

00:15:10.467 --> 00:15:11.733 align:middle
我们考虑了未来

00:15:11.967 --> 00:15:14.300 align:middle
如果那些规则要调整该怎么办？

00:15:14.967 --> 00:15:17.400 align:middle
如果CarPlay上出现新应用
该怎么办？

00:15:17.467 --> 00:15:20.000 align:middle
如果车上没有已有的设计需要
处理该怎么办？

00:15:20.633 --> 00:15:23.267 align:middle
哪种方案带来最大的灵活性

00:15:23.333 --> 00:15:24.567 align:middle
在接下来的五年？

00:15:24.967 --> 00:15:26.600 align:middle
所以我们决定实现一个系统

00:15:26.667 --> 00:15:30.467 align:middle
在原生系统中的复杂度更低
更易于升级

00:15:30.533 --> 00:15:33.233 align:middle
当消费者拥有车辆一段时间后

00:15:33.600 --> 00:15:37.233 align:middle
所以资源管理器在iOS里实现

00:15:40.067 --> 00:15:41.867 align:middle
因为资源管理器是

00:15:42.300 --> 00:15:45.100 align:middle
与原生系统互动的组件

00:15:45.167 --> 00:15:47.167 align:middle
我们让iPhone作为控制器

00:15:47.500 --> 00:15:49.200 align:middle
让主机作为附件

00:15:49.700 --> 00:15:50.567 align:middle
但不要忘了

00:15:51.367 --> 00:15:54.100 align:middle
所有iPhone应用请求同样的资源

00:15:54.167 --> 00:15:56.333 align:middle
用和原生UI同样的方式

00:15:59.533 --> 00:16:00.367 align:middle
接下来

00:15:59.533 --> 00:16:00.367 align:middle
接下来

00:16:00.633 --> 00:16:03.800 align:middle
你可以用什么命令和资源管理器
互动？

00:16:05.000 --> 00:16:05.833 align:middle
很简单

00:16:06.167 --> 00:16:07.633 align:middle
你只需要两个命令

00:16:08.167 --> 00:16:11.233 align:middle
changeModes命令
用来请求或释放资源

00:16:11.300 --> 00:16:14.600 align:middle
modesChanged命令
用来描述当前状态

00:16:16.233 --> 00:16:18.867 align:middle
changeModes
是主机发出的通知

00:16:20.400 --> 00:16:23.800 align:middle
在这个情况下主机是附件
向作为控制器的资源管理器

00:16:29.200 --> 00:16:31.100 align:middle
changeModes命令表明

00:16:31.167 --> 00:16:33.567 align:middle
附件想对资源做什么

00:16:33.800 --> 00:16:35.367 align:middle
它声明它为什么需要这个资源

00:16:36.033 --> 00:16:39.633 align:middle
以及谁可以占有或借用这个资源
当它被传递后

00:16:41.667 --> 00:16:45.700 align:middle
modesChanged
是控制器传递回主机的通知

00:16:48.233 --> 00:16:50.333 align:middle
modesChanged
提供当前状态

00:16:50.400 --> 00:16:53.500 align:middle
它描述谁拥有这个系统资源

00:16:53.900 --> 00:16:56.800 align:middle
它发送这些信息
所以附件知道一个资源是否被传递

00:16:56.867 --> 00:16:58.133 align:middle
所有者是否更换了

00:17:00.733 --> 00:17:03.633 align:middle
我们来谈谈资源管理器如何工作
的更多细节

00:17:04.700 --> 00:17:09.233 align:middle
我们从一个简单活动开始
切换iOS音频到收音机

00:17:09.800 --> 00:17:12.133 align:middle
然后我们会谈论原生语音识别

00:17:12.933 --> 00:17:14.599 align:middle
再接下来是怎样处理倒车雷达

00:17:14.666 --> 00:17:17.500 align:middle
这个情况下你不想iPhone应用
来打扰你

00:17:17.900 --> 00:17:21.633 align:middle
最后我们会看一个Siri触发
音乐播放的例子

00:17:23.099 --> 00:17:24.733 align:middle
让我们来看播放收音机音频

00:17:25.633 --> 00:17:28.600 align:middle
假设iPhone正在
通过车载音响播放音乐

00:17:29.600 --> 00:17:32.367 align:middle
然后用户在原生系统中想听收音机

00:17:32.433 --> 00:17:33.700 align:middle
这是收音机按钮

00:17:37.933 --> 00:17:41.433 align:middle
主机发送changeModes
请求获得音响的所有权

00:17:42.200 --> 00:17:43.467 align:middle
而且它获得这个所有权

00:17:43.533 --> 00:17:47.500 align:middle
因为用户可能会继续听很长时间
的收音机

00:17:48.733 --> 00:17:50.733 align:middle
控制器把音频交给主机

00:17:50.800 --> 00:17:52.900 align:middle
且发送modesChanged通知

00:17:54.000 --> 00:17:57.367 align:middle
主机就是音频资源的新的所有者

00:18:01.033 --> 00:18:03.100 align:middle
它可以开始播放收音机

00:18:03.700 --> 00:18:06.867 align:middle
mainAudio资源在这时被永久
赋予主机

00:18:09.467 --> 00:18:11.367 align:middle
总之这个例子向我们展示了

00:18:11.833 --> 00:18:13.267 align:middle
什么时候要求一个资源

00:18:13.333 --> 00:18:15.400 align:middle
以及原生系统不应该使用该资源

00:18:15.467 --> 00:18:17.933 align:middle
在它拥有这个资源前

00:18:20.000 --> 00:18:24.167 align:middle
让我们看下一个例子
使用原生语音识别

00:18:25.167 --> 00:18:27.500 align:middle
在我们的上个例子里
收音机仍然在播放

00:18:28.567 --> 00:18:32.000 align:middle
让我们看看用户启动原生语音识别
时会发生什么

00:18:34.700 --> 00:18:38.100 align:middle
这个单元请求暂时拥有显示和音频

00:18:38.467 --> 00:18:42.400 align:middle
所以transferType
应该设置成借用音频和屏幕

00:18:44.200 --> 00:18:47.833 align:middle
mainScreen和mainAudio
传递给附件

00:18:51.167 --> 00:18:53.467 align:middle
然后原生语音识别开始

00:18:55.500 --> 00:18:57.000 align:middle
一旦语音对话结束

00:18:57.067 --> 00:19:00.700 align:middle
主机把借用的资源交还
通过发送unborrow命令

00:18:57.067 --> 00:19:00.700 align:middle
主机把借用的资源交还
通过发送unborrow命令

00:19:03.433 --> 00:19:05.700 align:middle
因为单元在之前正在播放收音机

00:19:05.900 --> 00:19:08.400 align:middle
资源被重新赋予给主机

00:19:10.167 --> 00:19:11.633 align:middle
收音机可以继续

00:19:12.867 --> 00:19:14.100 align:middle
现在你可能想知道

00:19:14.267 --> 00:19:17.900 align:middle
为什么附件已经拥有资源
还要借用资源？

00:19:17.967 --> 00:19:19.400 align:middle
这是一个很好的问题

00:19:20.067 --> 00:19:22.367 align:middle
当资源管理器评估请求时

00:19:22.433 --> 00:19:26.467 align:middle
要变更一个资源的所有权
控制器要知道系统的当前状态

00:19:26.533 --> 00:19:29.233 align:middle
资源管理器需要知道你为什么在
使用这些资源

00:19:29.300 --> 00:19:30.933 align:middle
这样它才能进行正确判断

00:19:31.000 --> 00:19:33.233 align:middle
如果其它部分晚些时候需要资源

00:19:35.067 --> 00:19:36.700 align:middle
我们来看下一个例子

00:19:37.400 --> 00:19:38.733 align:middle
显示倒车雷达

00:19:40.700 --> 00:19:42.233 align:middle
若CarPlay正播放音频

00:19:42.300 --> 00:19:44.333 align:middle
屏幕上正显示原生UI

00:19:45.267 --> 00:19:48.733 align:middle
当用户挂倒车档
倒车雷达借用屏幕

00:19:49.533 --> 00:19:52.367 align:middle
然而请注意它也告诉资源管理器

00:19:52.433 --> 00:19:54.467 align:middle
屏幕不可被再次借用

00:19:59.633 --> 00:20:02.800 align:middle
资源管理器把屏幕分配给原生UI

00:19:59.633 --> 00:20:02.800 align:middle
资源管理器把屏幕分配给原生UI

00:20:02.867 --> 00:20:04.633 align:middle
并且注意到这个限制

00:20:06.133 --> 00:20:08.100 align:middle
现在显示倒车雷达

00:20:08.667 --> 00:20:10.433 align:middle
CarPlay音频继续播放

00:20:11.100 --> 00:20:12.833 align:middle
但是现在用户接到来电

00:20:15.633 --> 00:20:17.800 align:middle
iPhone不能在屏幕上
显示任何内容

00:20:17.867 --> 00:20:20.067 align:middle
因为主机限制了对屏幕的访问

00:20:20.133 --> 00:20:22.100 align:middle
但是铃声能过音响播放

00:20:23.700 --> 00:20:24.800 align:middle
这是怎么发生的？

00:20:25.867 --> 00:20:28.367 align:middle
changeModes命令中
这个单元告诉资源管理器

00:20:28.433 --> 00:20:31.067 align:middle
它拥有的资源使用哪些规则

00:20:31.133 --> 00:20:33.000 align:middle
通过在任何时间设置
borrowConstraint

00:20:33.067 --> 00:20:36.300 align:middle
这个单元允许应用借用资源

00:20:36.533 --> 00:20:40.767 align:middle
通过把它设置成user-initiated
只有用户发起的事件可以借用

00:20:41.500 --> 00:20:44.233 align:middle
永远没有应用可以使用这些资源

00:20:44.733 --> 00:20:45.767 align:middle
在这个例子中

00:20:48.133 --> 00:20:51.133 align:middle
如你所见这个限制对系统的行为
有个很大的影响

00:20:51.200 --> 00:20:53.233 align:middle
所以它们必须被正确使用

00:20:53.900 --> 00:20:57.700 align:middle
只有需要用户立即注意时
才限制访问

00:20:58.167 --> 00:21:01.533 align:middle
有CarPlay连接时
不要限制永久所有权

00:20:58.167 --> 00:21:01.533 align:middle
有CarPlay连接时
不要限制永久所有权

00:21:03.367 --> 00:21:04.933 align:middle
这就是使用倒车雷达

00:21:06.300 --> 00:21:09.500 align:middle
最后一个例子
当Siri播放音乐时发生了什么

00:21:10.767 --> 00:21:12.700 align:middle
我们又一次从播放收音机开始

00:21:13.900 --> 00:21:15.300 align:middle
用户启动Siri

00:21:17.833 --> 00:21:19.067 align:middle
Siri在手机上运行

00:21:19.133 --> 00:21:21.567 align:middle
资源管理器告诉原生系统

00:21:21.633 --> 00:21:23.967 align:middle
资源被分配给Siri

00:21:25.567 --> 00:21:29.467 align:middle
Siri出现然后用户说
“Siri播放音乐”

00:21:32.167 --> 00:21:34.267 align:middle
Siri交还显示和音频资源

00:21:34.333 --> 00:21:37.267 align:middle
但是现在音乐应用需要音频资源
播放音乐

00:21:37.500 --> 00:21:39.667 align:middle
所以资源管理器通知主机

00:21:39.733 --> 00:21:41.567 align:middle
手机拥有mainAudio

00:21:41.633 --> 00:21:43.633 align:middle
但是屏幕还给附件

00:21:44.400 --> 00:21:47.067 align:middle
主机不再继续播放收音机

00:21:49.433 --> 00:21:52.067 align:middle
所以在车里能听到iPhone音频

00:21:53.900 --> 00:21:55.000 align:middle
我们从中看到什么？

00:21:55.400 --> 00:21:57.000 align:middle
在两种场合
资源管理器

00:21:57.067 --> 00:21:59.733 align:middle
在没向主机发送请求的情况下
改变了状态

00:21:59.800 --> 00:22:01.200 align:middle
这是完全可以的

00:21:59.800 --> 00:22:01.200 align:middle
这是完全可以的

00:22:02.033 --> 00:22:05.733 align:middle
因为手机上的应用也会请求资源

00:22:05.800 --> 00:22:08.267 align:middle
如果它们得到资源
单元收到了通知

00:22:08.967 --> 00:22:10.133 align:middle
怎么处理这种情况

00:22:10.867 --> 00:22:14.233 align:middle
在每个modesChanged之后
你要检查你是否是所有者

00:22:14.533 --> 00:22:16.667 align:middle
如果你是继续你的活动

00:22:16.767 --> 00:22:19.367 align:middle
否则你需要得到CarPlay来处理

00:22:20.000 --> 00:22:21.533 align:middle
第二 不要忽略

00:22:21.600 --> 00:22:24.933 align:middle
手机发起的把资源切换给手机

00:22:27.033 --> 00:22:30.800 align:middle
至此我们已经看过了资源交换
的例子

00:22:30.867 --> 00:22:32.667 align:middle
但是还有一种情况两边

00:22:32.733 --> 00:22:34.667 align:middle
都想完成同样的任务

00:22:34.733 --> 00:22:37.000 align:middle
让我们看看应用是怎么被管理的

00:22:38.767 --> 00:22:42.533 align:middle
我们要管理原生和CarPlay应用
它们有相似的特点

00:22:42.600 --> 00:22:44.233 align:middle
但是关于那些应用呢？

00:22:44.800 --> 00:22:49.333 align:middle
他们导航 通话 语音识别

00:22:51.333 --> 00:22:54.567 align:middle
我们通过appState来实现
什么是appState？

00:22:54.967 --> 00:22:57.467 align:middle
我们用不同的appState记录
谁现在参与了

00:22:57.533 --> 00:23:00.033 align:middle
共享的应用
这些应用只能活动

00:22:57.533 --> 00:23:00.033 align:middle
共享的应用
这些应用只能活动

00:23:00.100 --> 00:23:03.000 align:middle
在附件上或者控制器上
在任一个时刻

00:23:03.833 --> 00:23:06.467 align:middle
所以这三个不同的appState
是TurnByTurn

00:23:06.533 --> 00:23:08.533 align:middle
PhoneCall和Speech

00:23:10.533 --> 00:23:11.467 align:middle
让我们来看看

00:23:12.067 --> 00:23:15.100 align:middle
导航appState是怎么被管理

00:23:16.900 --> 00:23:19.300 align:middle
当导航在附件上启动时

00:23:19.367 --> 00:23:21.167 align:middle
它用一changeModes命令

00:23:21.233 --> 00:23:23.933 align:middle
来更新要激活的
TurnByTurn appState

00:23:27.567 --> 00:23:30.633 align:middle
在这个例子中
是最后的会获胜的情况

00:23:31.033 --> 00:23:33.867 align:middle
控制器把TurnByTurn
appState交附件

00:23:33.933 --> 00:23:36.667 align:middle
返回一个modesChanged
命令 显示附件

00:23:36.733 --> 00:23:38.933 align:middle
是当前运行的导航

00:23:40.667 --> 00:23:44.867 align:middle
现在让我们来看看用户用Apple Maps
设置一个新目的地时会发生什么

00:23:44.933 --> 00:23:47.100 align:middle
当原生系统已经在导航时

00:23:47.567 --> 00:23:50.933 align:middle
用户说 “Siri带我去最近
的咖啡店”

00:23:51.867 --> 00:23:54.800 align:middle
现在iPhone开始了导航

00:23:54.867 --> 00:23:57.533 align:middle
控制器更新TurnByTurn appState

00:23:59.733 --> 00:24:04.033 align:middle
这是对附件的指令
要停止它自己的导航

00:23:59.733 --> 00:24:04.033 align:middle
这是对附件的指令
要停止它自己的导航

00:24:05.767 --> 00:24:10.233 align:middle
现在iPhone开始导航
控制器更新TurnByTurn appState

00:24:10.300 --> 00:24:14.100 align:middle
这是对附件的指令
要停止它自己的导航

00:24:16.033 --> 00:24:18.500 align:middle
现在Apple Maps的导航

00:24:18.567 --> 00:24:22.033 align:middle
显示在了屏幕上
并且公告通过音频播放

00:24:22.100 --> 00:24:25.133 align:middle
并且和原生导航系统不会冲突

00:24:27.667 --> 00:24:29.733 align:middle
所以现在Apple Maps的导航

00:24:29.800 --> 00:24:31.967 align:middle
显示在了屏幕上
并且公告通过音频播放

00:24:32.033 --> 00:24:34.733 align:middle
并且和原生导航系统不会冲突

00:24:36.300 --> 00:24:37.667 align:middle
关于导航就这么多了

00:24:38.167 --> 00:24:39.633 align:middle
接下来让我们看看通话

00:24:41.233 --> 00:24:44.800 align:middle
如果主机支持通过Bluetooth
来使用第二个电话

00:24:44.867 --> 00:24:46.400 align:middle
并且有一个正在进行的通话

00:24:46.867 --> 00:24:48.833 align:middle
这个通话独占mainAudio

00:24:49.233 --> 00:24:51.200 align:middle
通话不能被打断

00:24:51.467 --> 00:24:54.733 align:middle
那用户在CarPlay设备上收到
来电会发生什么？

00:24:55.933 --> 00:24:58.700 align:middle
CarPlay只能在这台设备上响铃

00:24:58.767 --> 00:25:01.100 align:middle
因为不能打断正在进行的通话

00:24:58.767 --> 00:25:01.100 align:middle
因为不能打断正在进行的通话

00:25:01.567 --> 00:25:03.833 align:middle
被PhoneCall appState管理

00:25:05.200 --> 00:25:07.300 align:middle
最后来看看语音互动

00:25:08.033 --> 00:25:10.300 align:middle
如果主机有原生的语音识别

00:25:10.367 --> 00:25:12.800 align:middle
当它运行时借用了资源

00:25:12.867 --> 00:25:16.800 align:middle
并独占音响 麦克风和屏幕资源

00:25:17.467 --> 00:25:20.833 align:middle
但是它能在任何时候被用户
发起的事件打断

00:25:21.733 --> 00:25:24.467 align:middle
所以用户启动Siri

00:25:25.900 --> 00:25:29.733 align:middle
原生语音识别结束
Siri继续出现在车载显示上

00:25:30.233 --> 00:25:32.567 align:middle
Speech appState
被用来实现这个

00:25:35.600 --> 00:25:36.433 align:middle
总之

00:25:36.933 --> 00:25:39.633 align:middle
CarPlay和你的原生系统依赖
相同的资源

00:25:39.700 --> 00:25:42.700 align:middle
被设计成和原生用户体验共存

00:25:43.333 --> 00:25:45.067 align:middle
为了优秀的CarPlay体验

00:25:45.133 --> 00:25:47.133 align:middle
考虑每一种使用情况的资源处理

00:25:47.200 --> 00:25:49.767 align:middle
遵守CarPlay设计建议

00:25:50.500 --> 00:25:53.833 align:middle
CarPlay的详述可以通过
MFi Program获得

00:25:55.067 --> 00:25:57.633 align:middle
若你还没有观看开发CarPlay
系统的第一部分

00:25:57.700 --> 00:25:59.333 align:middle
我鼓励你去看一下

00:25:59.767 --> 00:26:01.333 align:middle
关于这次讨论的更多信息

00:25:59.767 --> 00:26:01.333 align:middle
关于这次讨论的更多信息

00:26:01.733 --> 00:26:03.633 align:middle
请访问屏幕上的网址
