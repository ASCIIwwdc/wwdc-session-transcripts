WEBVTT

00:00:19.386 --> 00:00:23.724
watchOS 3性能架构设计

00:00:28.395 --> 00:00:32.299
大家下午好 欢迎来到
watchOS 3性能架构设计

00:00:32.799 --> 00:00:34.201
我是Tyler McAtee

00:00:34.334 --> 00:00:36.870
稍后你会看到
我的同事Todd Grooms

00:00:37.371 --> 00:00:40.807
今天我们会讨论在Apple
我们思考性能优化的方法

00:00:40.874 --> 00:00:42.976
和我们怎么样创建watchOS 3

00:00:43.810 --> 00:00:45.946
我们从2-Second任务开始说

00:00:46.313 --> 00:00:49.449
它是什么 它对watchOS 3
的设计有什么帮助和影响

00:00:49.583 --> 00:00:51.752
对你的应用架构意味着什么

00:00:52.352 --> 00:00:56.356
我还会讨论一下
设计策略是怎么影响性能的

00:00:56.423 --> 00:00:59.126
同时展示一个新的详细分页API

00:00:59.193 --> 00:01:01.695
它可以减少不必要的导航时间

00:00:59.193 --> 00:01:01.695
它可以减少不必要的导航时间

00:01:02.930 --> 00:01:05.966
最后 Todd会上台展示我们如何

00:01:06.033 --> 00:01:08.735
利用这些想法并
应用到watch股票应用上

00:01:09.369 --> 00:01:11.205
我们从2-Second开始

00:01:11.438 --> 00:01:13.841
我们专注于这个理念
作为经验法则

00:01:14.074 --> 00:01:16.443
和Apple Watch交互感觉
是怎样的

00:01:16.510 --> 00:01:17.778
什么是2-Second任务

00:01:18.612 --> 00:01:21.148
2-Second任务是
用户想要完成操作

00:01:21.215 --> 00:01:23.083
或看Apple Watch而学习

00:01:23.717 --> 00:01:26.086
这些任务应该在几秒内完成

00:01:27.988 --> 00:01:29.022
这几秒应该从

00:01:29.122 --> 00:01:31.692
开始交互到结束衡量

00:01:31.859 --> 00:01:34.695
从用户抬起手看
Apple Watch开始

00:01:34.761 --> 00:01:35.762
到他们放下手结束

00:01:36.763 --> 00:01:39.466
一些2-Second任务
的例子可能是这样

00:01:40.033 --> 00:01:43.537
查看通知 设定定时器或者开始锻炼

00:01:44.838 --> 00:01:45.873
今天我们会了解下

00:01:45.939 --> 00:01:47.875
我们对系统做的一些重要变动

00:01:47.941 --> 00:01:50.477
解释这将怎么影响开发者

00:01:50.544 --> 00:01:53.347
思考你的WatchKit应用的性能

00:01:54.982 --> 00:01:58.418
完成一个Apple Watch
任务的第一个瓶颈

00:01:58.485 --> 00:02:01.922
是访问到相应应用 花费的导航的次数

00:01:58.485 --> 00:02:01.922
是访问到相应应用 花费的导航的次数

00:02:02.489 --> 00:02:04.625
Apple Watch上
打开一个应用最快的方法

00:02:04.691 --> 00:02:06.226
是通过点击一个
complication

00:02:06.894 --> 00:02:09.363
只鼓励开发者实现一个
complication

00:02:09.429 --> 00:02:11.098
如果他们有相关数据去显示

00:02:11.765 --> 00:02:15.502
大多程序 例如信息 邮件和手机
并没有complication

00:02:16.236 --> 00:02:18.605
为了增加Apple Watch
的可操纵性

00:02:18.772 --> 00:02:21.575
和同时给用户提供更多选择去定制化

00:02:21.775 --> 00:02:25.045
现在在watchOS 3上
应用都有complication

00:02:25.879 --> 00:02:28.448
这些启动complication
对于从表盘上快速访问

00:02:28.515 --> 00:02:31.151
你喜欢的应用是很有用的

00:02:31.785 --> 00:02:34.721
对于你的应用
我们也鼓励你去适应这个规则

00:02:34.788 --> 00:02:37.591
实现一个complication
无论是否有数据显示

00:02:38.992 --> 00:02:41.728
新的watchOS 3中
我们为你带来了dock

00:02:42.563 --> 00:02:45.632
通过按压侧键开关
用户可以调用dock

00:02:45.699 --> 00:02:48.101
且快速浏览所有他们最爱的应用程序

00:02:49.236 --> 00:02:52.539
浏览这些应用程序是非常快和容易的

00:02:53.507 --> 00:02:56.143
我们想要我们的用户能够
使用这些最爱的应用程序

00:02:56.210 --> 00:02:57.678
并且使他们准备好加载好

00:02:57.744 --> 00:02:59.847
而不是必须等待

00:02:59.913 --> 00:03:01.348
因为这个应用已开始运行了

00:02:59.913 --> 00:03:01.348
因为这个应用已开始运行了

00:03:01.949 --> 00:03:05.085
在watchOS 3中为了记录这些
所有的应用程序

00:03:05.152 --> 00:03:08.055
一个用户选择放在表盘上
或者在他们的dock中

00:03:08.121 --> 00:03:10.657
应用将在系统中
保持运行或暂停在内存中

00:03:11.925 --> 00:03:14.027
这样当他们和应用程序交互时

00:03:14.094 --> 00:03:16.463
他们只需等待恢复 无需重新启动

00:03:16.897 --> 00:03:18.966
但是系统只有固定大小的内存

00:03:19.032 --> 00:03:22.169
并且在一个在系统中
应用需要成为一个好的公民

00:03:22.436 --> 00:03:26.173
因为最多可以有10个dock应用
5个complications

00:03:26.373 --> 00:03:29.042
同时还有系统应用 进程等等

00:03:30.911 --> 00:03:33.780
你要记得你仅是
庞大生态系统中的一部分

00:03:33.847 --> 00:03:36.550
因此你需要尽可能
只用你需要的资源

00:03:38.519 --> 00:03:40.954
这个系统 因为生态系统的自然性

00:03:41.088 --> 00:03:43.790
我们的系统提高了固定内存数量的上限

00:03:43.857 --> 00:03:45.526
一个WatchKit
的应用可使用的量

00:03:46.026 --> 00:03:47.160
如果应用超出这个限制

00:03:47.261 --> 00:03:50.163
我们的系统将会终止应用
连哭的机会都不给你

00:03:50.230 --> 00:03:52.733
因此内存可以被其他的程序使用

00:03:53.934 --> 00:03:55.102
限制不是目的

00:03:55.169 --> 00:03:57.070
尽量别用光内存

00:03:57.137 --> 00:03:59.339
事实上 它应该远不及限制

00:03:59.673 --> 00:04:02.109
现在在watchOS 3上
的限制是30兆字节

00:03:59.673 --> 00:04:02.109
现在在watchOS 3上
的限制是30兆字节

00:04:02.176 --> 00:04:04.878
每个WatchKit应用程序
但这个将来可能会改变

00:04:05.779 --> 00:04:08.515
所以有什么好的技巧控制应用
的内存使用？

00:04:09.149 --> 00:04:11.518
用合适于watch屏幕尺寸的图片

00:04:11.652 --> 00:04:13.587
这个不仅可以控制内存使用

00:04:13.820 --> 00:04:15.422
而且将会有助于提高整体性能

00:04:15.489 --> 00:04:18.692
{\an2因为这让watch不用做
额外去调整图片大小的工作

00:04:20.527 --> 00:04:24.364
用大小合适的数据集
不要去下载大量的数据集

00:04:24.431 --> 00:04:26.667
如果你只显示很少的数据在屏幕上

00:04:26.733 --> 00:04:29.236
如果你只显示一个数据对象的属性

00:04:29.303 --> 00:04:32.172
不要下载或保存其他属性

00:04:33.106 --> 00:04:36.009
如果你能控制API下载数据

00:04:36.076 --> 00:04:39.413
让我们看这个简单的应用

00:04:39.479 --> 00:04:40.914
因为watch将可能显示

00:04:40.981 --> 00:04:42.883
一个更浓缩的信息版本

00:04:43.217 --> 00:04:45.719
这将会帮助节省大量的网络流量

00:04:45.786 --> 00:04:47.154
你的watch会处理它

00:04:47.221 --> 00:04:49.456
瞬时数据和内存也会减少

00:04:50.290 --> 00:04:53.427
最后 重要的是释放你不再使用的对象

00:04:53.727 --> 00:04:54.962
花些时间过一遍你的代码

00:04:55.028 --> 00:04:58.131
并且确定你只保存必需的东西

00:04:58.532 --> 00:05:02.269
因为用户选择的应用
放在他们的表盘上

00:04:58.532 --> 00:05:02.269
因为用户选择的应用
放在他们的表盘上

00:05:02.336 --> 00:05:05.372
或者在dock中 系统会让它们
保持存活和悬挂在内存中

00:05:05.839 --> 00:05:08.208
它们更多的是被恢复而不是被启动

00:05:08.876 --> 00:05:10.410
因为这个 对于watchOS 3

00:05:10.477 --> 00:05:13.046
我们想要集中优化的关键
是恢复时间

00:05:14.047 --> 00:05:16.750
现在应用程序将不经常被恢复

00:05:16.850 --> 00:05:20.187
因为它们将被保存在内存里
但也因为它们在dock里

00:05:20.787 --> 00:05:23.090
当用户在dock栏中滑到你的应用

00:05:23.390 --> 00:05:24.925
应用会被恢复

00:05:25.125 --> 00:05:27.995
当用户滑过应用
应用将会被暂停

00:05:29.463 --> 00:05:32.132
这种经常恢复和暂停的行为

00:05:32.199 --> 00:05:35.269
是watchos3中应用典型的方式

00:05:36.003 --> 00:05:38.438
理解软件生命周期中哪一个方法

00:05:38.505 --> 00:05:39.706
用来做主要工作

00:05:39.773 --> 00:05:41.942
哪一个用来做不重要的工作很重要

00:05:42.876 --> 00:05:44.578
来看一下不同的生命周期方法

00:05:44.645 --> 00:05:46.813
在watchKit扩展代理会遇到

00:05:47.581 --> 00:05:50.884
你的代理中看到的第一个方法是
ApplicationDidFinishLaunching

00:05:50.951 --> 00:05:53.086
当程序第一次运行时 它将会被调用

00:05:53.420 --> 00:05:56.456
并且这是一个不错的地方
来执行应用应用的最终初始化

00:05:56.523 --> 00:05:59.159
像其他任务一样 这只需要被执行一次

00:06:00.160 --> 00:06:02.462
在你的代理中接下来看到的是

00:06:02.729 --> 00:06:04.298
applicationDidBecomeActive

00:06:05.032 --> 00:06:09.136
只要你的应用在系统中
变成活跃应用 这个将会被调用

00:06:09.203 --> 00:06:11.171
重新开始任何一个之前被暂停的任务

00:06:11.238 --> 00:06:14.541
或者没有启动 只要有需要
将会刷新用户界面

00:06:15.976 --> 00:06:19.179
一旦应用从活跃变为非活跃状态

00:06:19.246 --> 00:06:21.615
applicationWillResignActive会被调用

00:06:22.149 --> 00:06:24.518
这可能因为某些类型的临时中断而发生

00:06:24.585 --> 00:06:26.820
例如一个打进来的电话或者通知

00:06:27.421 --> 00:06:29.923
当用户按下侧键来唤醒dock时

00:06:29.990 --> 00:06:31.792
或者当用户退出你的应用时

00:06:31.859 --> 00:06:34.261
并且它将会过渡到后台运行状态

00:06:35.295 --> 00:06:38.232
当你的应用不再活跃并且被调到后台

00:06:38.332 --> 00:06:40.334
applicationDidEnterBackground将被调用

00:06:40.601 --> 00:06:42.369
当你的应用返回到前台时

00:06:42.436 --> 00:06:44.938
applicationWillEnterForeground将会被调用

00:06:45.072 --> 00:06:48.008
这些函数只有在程序
从后台到前台时才会被调用

00:06:48.075 --> 00:06:51.278
或者当程序从前台到后台
所以在程序第一次启动时不会被调用

00:06:52.646 --> 00:06:56.550
另外 有些生命周期方法
和接口控制器相关联

00:06:56.984 --> 00:06:58.352
AwakeWithContext
会被调用

00:06:58.418 --> 00:07:00.921
在你的接口控制器第一次实例化的时候

00:06:58.418 --> 00:07:00.921
在你的接口控制器第一次实例化的时候

00:07:00.988 --> 00:07:03.724
这是一个好位置
对那些只需要做一次的工作

00:07:04.424 --> 00:07:07.060
当界面激活时
willActivate将被调用

00:07:07.127 --> 00:07:08.996
或者能够更新的时候
它将会被调用

00:07:09.062 --> 00:07:11.598
在界面对于用户确实可见之前

00:07:11.865 --> 00:07:13.734
一旦用户完全看见界面

00:07:13.800 --> 00:07:15.335
didAppear被调用

00:07:15.636 --> 00:07:18.906
如果你有在恢复时需要做的工作
这些方法是是合适的位置

00:07:19.239 --> 00:07:21.041
如果需要做的比较多 你最好

00:07:21.108 --> 00:07:23.143
把任务分发到后台的队列

00:07:23.210 --> 00:07:26.480
这样这些方法可以完成
并且你的应用能够完成恢复

00:07:27.981 --> 00:07:30.083
一旦你的应用暂停了

00:07:30.150 --> 00:07:33.053
在接口控制器中
willDisappear将被调用

00:07:33.120 --> 00:07:37.024
当用户界面不再对用户可见时

00:07:37.724 --> 00:07:40.928
或者用户界面无效并且不再更新

00:07:40.994 --> 00:07:43.230
didDeactivate
将会被调用

00:07:43.463 --> 00:07:45.966
这些方法是取消任何繁重任务的地方

00:07:46.033 --> 00:07:48.602
你在willActivate
和didAppear中启动的任务

00:07:51.672 --> 00:07:53.273
理解这个生命周期非常重要

00:07:53.340 --> 00:07:56.610
并且明白这些方法
可能被重复频繁的调用

00:07:57.644 --> 00:07:59.179
我想通过一个例子

00:07:59.246 --> 00:08:01.882
一个程序是怎样遇到这些事件
在它的生命周期中

00:07:59.246 --> 00:08:01.882
一个程序是怎样遇到这些事件
在它的生命周期中

00:08:02.349 --> 00:08:05.252
我们将会从一个程序开始
为了这次课程的目的

00:08:05.319 --> 00:08:07.154
程序在前台和后台都没有运行

00:08:07.421 --> 00:08:08.956
当用户点击你的应用

00:08:09.022 --> 00:08:11.792
第一个方法将进入到
WatchKit扩展代理中

00:08:11.859 --> 00:08:13.861
didFinishLaunching
和didBecomeActive

00:08:14.228 --> 00:08:16.864
还有接口控制器将会接收到
awakeWithContext

00:08:16.930 --> 00:08:18.465
willActivate
和didAppear

00:08:19.533 --> 00:08:22.503
现在你的应用正在前台运行
并且是活跃的

00:08:22.703 --> 00:08:25.973
但是当用户按下侧键开关
调出dock时会发生什么呢

00:08:26.573 --> 00:08:30.444
此时你的应用不再是前台活跃的应用

00:08:30.511 --> 00:08:31.945
这是系统应用

00:08:32.111 --> 00:08:35.082
所以你的代理将会调用
applicationWillResignActive

00:08:37.251 --> 00:08:39.686
当用户继续选定你的应用

00:08:39.820 --> 00:08:42.722
程序将会在前台一直运行
一直在被CPU执行

00:08:42.789 --> 00:08:45.526
更新用户界面

00:08:45.626 --> 00:08:47.961
一旦用户滑走你的应用

00:08:48.028 --> 00:08:49.930
系统将会悬挂你的应用

00:08:50.097 --> 00:08:53.500
所以你的界面控制器将会调用
willDisappear和didDeactivate

00:08:53.567 --> 00:08:55.903
并且应用的didEnterBackground会被调用

00:08:58.005 --> 00:09:00.974
现在这里你的应用刚进入后台

00:08:58.005 --> 00:09:00.974
现在这里你的应用刚进入后台

00:09:01.041 --> 00:09:02.910
因此系统可能唤起你的应用

00:09:02.976 --> 00:09:04.611
为了一个后台快照任务

00:09:04.912 --> 00:09:08.382
了解更多这些快照任务
看看我们今早的课程

00:09:08.448 --> 00:09:10.217
保持你的watch
应用持续更新

00:09:10.651 --> 00:09:13.987
你的设备接口控制器被
willActivate和didAppear激活

00:09:14.054 --> 00:09:17.357
在你的代理把机会给
handleBackgroundTasks之前

00:09:17.824 --> 00:09:21.361
然后你的接口控制器会调用
willDisappear和didDeactivate

00:09:22.062 --> 00:09:25.732
现在你的应用被完全暂停
并且应用将执行它的后台任务

00:09:25.999 --> 00:09:28.068
一旦用户滑回你的应用

00:09:28.168 --> 00:09:30.504
程序将会调用applicationWillEnterForeground

00:09:30.571 --> 00:09:32.072
还有willActivate
和didAppear

00:09:33.674 --> 00:09:37.144
你的应用再次运行
同时进入dock的前台中

00:09:37.644 --> 00:09:39.746
直到用户点进你的应用

00:09:39.813 --> 00:09:41.882
你的应用才会变成前台中活跃的应用

00:09:41.949 --> 00:09:44.184
并且调用applicationDidBecomeActive

00:09:45.352 --> 00:09:47.988
从用户进入到dock时
发生了大量的事情

00:09:48.055 --> 00:09:50.557
自从用户滑出应用又滑回应用

00:09:50.924 --> 00:09:53.861
这就是为什么
理解程序的生命周期很重要

00:09:53.927 --> 00:09:55.629
就像用户浏览他们的dock

00:09:55.696 --> 00:09:59.099
你的应用可能重复频繁的遇到这些事件

00:10:01.034 --> 00:10:03.403
还有什么其他技巧
能缩短恢复时间

00:10:04.538 --> 00:10:07.708
你应该用discretion
当更新WKInterface对象时

00:10:07.774 --> 00:10:10.644
你每次给WKInterface对象
设置一个属性

00:10:10.711 --> 00:10:12.446
系统会创造一个信息来发送

00:10:12.613 --> 00:10:15.983
将它打包 并且分发到
应用进程中UI正在被更新的位置

00:10:16.583 --> 00:10:19.853
那可能是临时的
在你的应用上来建立一些方法

00:10:19.920 --> 00:10:22.990
更新应用的UI
且在每次恢复的时候调用

00:10:23.123 --> 00:10:25.125
但是设置每一个属性需要花费时间

00:10:25.225 --> 00:10:26.860
哪怕属性不会改变

00:10:26.927 --> 00:10:30.330
这导致了在应用和扩展间不必要的沟通

00:10:31.565 --> 00:10:33.534
仅设置这些属性是值得的

00:10:33.600 --> 00:10:35.602
若属性变了
那你必须这么做

00:10:38.472 --> 00:10:42.409
你需要注意WKInterfaceTable
和UITableView的不同

00:10:42.809 --> 00:10:45.712
手机有大量的内存来存储大量的信息

00:10:45.946 --> 00:10:47.748
UITableView
做了专门的优化

00:10:47.814 --> 00:10:50.050
当在这些比较大的数据集上快速滑动时

00:10:50.184 --> 00:10:53.153
cells被按需创建
当你滑动时会被重新使用

00:10:53.921 --> 00:10:55.622
然而用
WKInterfaceTable

00:10:55.689 --> 00:10:58.425
所有的cells被提前创建
并且不会被重新使用

00:10:58.492 --> 00:11:00.294
所以watch需要做的工作

00:10:58.492 --> 00:11:00.294
所以watch需要做的工作

00:11:00.360 --> 00:11:02.563
和表格的大小呈正相关

00:11:02.996 --> 00:11:06.533
由于这个原因控制
WKInterfaceTable的大小非常重要

00:11:06.834 --> 00:11:08.468
watch不合适这种类型

00:11:08.535 --> 00:11:10.270
翻阅数以百计的记录

00:11:10.337 --> 00:11:11.705
事实上 我们发现最好

00:11:11.772 --> 00:11:15.008
WKInterfaceTable
大小保持20出头

00:11:17.177 --> 00:11:19.279
你的应用应该避免重新加载一个
WKInterfaceTable

00:11:19.346 --> 00:11:20.814
无论如何

00:11:21.782 --> 00:11:23.350
这是一个耗费资源的操作

00:11:23.717 --> 00:11:26.153
它可能尝试重新加载整个表

00:11:26.220 --> 00:11:28.555
在恢复或数据集改变时

00:11:28.622 --> 00:11:30.257
但若你需要添加或移动一些行

00:11:30.324 --> 00:11:32.793
最好用插入和删除API

00:11:35.662 --> 00:11:37.431
我现在想谈一些设计方面的

00:11:37.931 --> 00:11:41.101
想想适合watch的信息展示方式

00:11:41.168 --> 00:11:44.271
好的展示方式对性能也很有帮助

00:11:45.572 --> 00:11:49.276
在watchos 3中
你应把应用设计成可以扫着看的

00:11:49.710 --> 00:11:55.449
dock让用户可快速访问收藏的应用

00:11:55.682 --> 00:11:58.852
你的应用可能只会被大体的扫一下

00:11:58.919 --> 00:12:01.688
当用户从一个应用滑到另一个的时候

00:11:58.919 --> 00:12:01.688
当用户从一个应用滑到另一个的时候

00:12:01.889 --> 00:12:04.491
集中显示最重要的信息

00:12:04.558 --> 00:12:06.426
并尽量清晰的显示

00:12:07.327 --> 00:12:11.532
根据特定的目的来设计
可以让应用变得更利于扫视

00:12:12.065 --> 00:12:14.034
watch不是合适的载体

00:12:14.101 --> 00:12:16.136
对于浏览大量的内容

00:12:16.503 --> 00:12:18.438
或者查看复杂的数据继承

00:12:19.473 --> 00:12:21.642
通过仅展示最基础的信息

00:12:21.708 --> 00:12:23.977
同时你会得到更好的性能

00:12:24.244 --> 00:12:27.314
由于你展示更少的信息
可以节省处理器和内存

00:12:27.381 --> 00:12:29.449
同时保持更新时需要更少的网络请求

00:12:31.585 --> 00:12:33.787
最后 导航也很重要

00:12:34.054 --> 00:12:37.090
我已经讲了很多关于我们如何在
系统层面提升导航了

00:12:37.157 --> 00:12:40.561
在应用层面考虑这些同样很重要

00:12:41.094 --> 00:12:43.597
为了帮助实现这些
我们引进了一个新的

00:12:44.331 --> 00:12:46.266
详细分页API

00:12:46.834 --> 00:12:51.538
WatchKit应用的
一个标准配置是继承数据视图

00:12:51.738 --> 00:12:53.707
你有一个表格

00:12:53.874 --> 00:12:56.810
点击其中一个单元
进入这个项目的详细

00:12:57.010 --> 00:12:58.245
这种设置的问题是

00:12:58.312 --> 00:13:00.480
如果你想浏览多个项目的详细

00:12:58.312 --> 00:13:00.480
如果你想浏览多个项目的详细

00:13:00.547 --> 00:13:02.883
你需要后退好多次

00:13:03.584 --> 00:13:05.986
为了解决这个问题
新的详细分页API

00:13:06.053 --> 00:13:08.822
可以让我们快速的浏览
从一个详细视图到另一个

00:13:09.089 --> 00:13:12.359
通过从屏幕上滑动或者
旋转数字表冠

00:13:13.293 --> 00:13:15.562
为了了解在代码中如何设置这些API

00:13:15.629 --> 00:13:18.432
同时学习其他快速交互技术

00:13:18.498 --> 00:13:19.900
我们向开发者发布的

00:13:19.967 --> 00:13:23.670
请查阅昨天的
“watchOS快速交互技巧”演讲

00:13:24.705 --> 00:13:27.741
在本次演讲中 我想说说这些API

00:13:27.808 --> 00:13:30.344
的视图控制器生命周期

00:13:30.444 --> 00:13:32.613
从视图的性能方面这很重要

00:13:33.080 --> 00:13:36.750
所以这里我们有一个有三个单元的表格
红的 橘黄的 黄的

00:13:37.251 --> 00:13:39.353
详细分页API触发segue

00:13:39.419 --> 00:13:41.822
从内部表到接口控制器

00:13:41.889 --> 00:13:44.591
当你点击其中的一个单元
我们会触发一个segue

00:13:45.058 --> 00:13:47.427
当你点击这个单元
你的主接口控制器

00:13:47.494 --> 00:13:51.331
将会调用contextForSegue:withIdentifier:inTable方法

00:13:52.165 --> 00:13:54.868
你可以在这里创建上下文对象传递给

00:13:54.935 --> 00:13:57.938
详细视图控制器和
awakeWithContext方法

00:13:58.438 --> 00:14:00.407
你的主视图控制器不会只接到它的调用

00:13:58.438 --> 00:14:00.407
你的主视图控制器不会只接到它的调用

00:14:00.474 --> 00:14:03.977
你点击的单元
而是表格每一个单元

00:14:04.778 --> 00:14:07.748
我们为每一个详细视图控制器
都准备了上下文

00:14:07.814 --> 00:14:10.250
所以当我们准备上下文的时候

00:14:10.317 --> 00:14:12.219
我们可以提前实例化

00:14:12.486 --> 00:14:14.721
那样的话 当用户点击第一个的时候

00:14:14.788 --> 00:14:16.890
可以在所有的单元间快速的滑动

00:14:20.327 --> 00:14:22.496
你的第一个视图控制器

00:14:22.563 --> 00:14:24.698
会是第一个调用
awakeWithContext

00:14:24.765 --> 00:14:27.601
包括willActivate
和didAppear

00:14:28.001 --> 00:14:30.470
这个是滑动试图最有意思的部分

00:14:30.804 --> 00:14:34.007
我们让控制器接近
这个选择的详细视图控制器

00:14:34.274 --> 00:14:36.610
然后用户可以滑动到下一个

00:14:36.944 --> 00:14:38.779
其他的颜色进入他们的生命周期方法

00:14:38.846 --> 00:14:40.013
会一样调用

00:14:40.714 --> 00:14:43.116
他们会首先调用
awakeWithContext

00:14:44.251 --> 00:14:46.820
然后是willActivate和
didDeactivate

00:14:50.023 --> 00:14:51.825
如何设置工作很重要

00:14:51.892 --> 00:14:53.660
对那些还没有渲染的视同控制器

00:14:54.027 --> 00:14:57.631
不要盲目的启动耗费CPU的任务

00:14:57.698 --> 00:15:01.468
这可能导致CPU处理不过来

00:14:57.698 --> 00:15:01.468
这可能导致CPU处理不过来

00:15:01.535 --> 00:15:03.170
如果你有很多表格单元的话

00:15:03.604 --> 00:15:05.839
当用户从一个详细视图
滑动到另一个的时候

00:15:06.039 --> 00:15:09.977
你之前的接口控制器会是第一个调用
willDisappear

00:15:10.811 --> 00:15:13.547
willActivate didDeactivate
和didAppear

00:15:14.147 --> 00:15:16.683
这使你的接口控制器维持一致的状态

00:15:16.817 --> 00:15:19.820
那些最近展示到屏幕
上的调用didAppear

00:15:19.887 --> 00:15:23.690
那些最近离开屏幕的调用
didDeactivate

00:15:24.324 --> 00:15:25.459
当你点击后退

00:15:25.526 --> 00:15:29.229
回到主控制界面 只有一个控制器

00:15:29.296 --> 00:15:31.899
需要用生命周期方法调用它
并且它是可视的

00:15:31.965 --> 00:15:34.568
应用调用willDisappear
和didDeactivate

00:15:37.104 --> 00:15:39.306
当然 我想要邀请Todd去谈论这些

00:15:39.373 --> 00:15:42.409
我们如何应用这些想法到我们的
Stocks WatchKit应用

00:15:42.743 --> 00:15:43.577
谢谢

00:15:55.756 --> 00:15:56.690
下午好

00:15:57.357 --> 00:15:59.126
我是一个watch OS的工程师

00:15:59.193 --> 00:16:03.363
我们把Stocks作为一个案例研究
面向WatchKit和开发者

00:15:59.193 --> 00:16:03.363
我们把Stocks作为一个案例研究
面向WatchKit和开发者

00:16:04.431 --> 00:16:05.899
你们中大多数可能不知道这个

00:16:05.966 --> 00:16:08.468
但Stocks是用WatchKit
建立的watch应用

00:16:08.836 --> 00:16:11.605
在Apple我们想要有第一手的经验

00:16:11.672 --> 00:16:14.408
在WatchKit开发中
我们感觉Stocks

00:16:14.474 --> 00:16:16.910
将会是WatchKit开发中
一个很棒的应用方案

00:16:19.313 --> 00:16:21.782
今天我有三个想要讨论的主题

00:16:21.849 --> 00:16:24.117
关于Stocks和
WatchKit开发

00:16:24.718 --> 00:16:28.655
我将要去分辨Stocks中的
2-Second任务

00:16:29.256 --> 00:16:32.259
之后我将要讨论一些实现的细节

00:16:32.326 --> 00:16:34.895
在我们的后台刷新用例中

00:16:36.797 --> 00:16:40.367
最后 我将要说一些关于我们做的优化

00:16:40.534 --> 00:16:44.905
通过扩展优化恢复时间
启动时间

00:16:46.507 --> 00:16:49.910
因此 我们将从2-Second任务开始

00:16:51.879 --> 00:16:53.146
我们思考Stocks时

00:16:53.647 --> 00:16:56.149
我们想到三个重要的
2-Second任务

00:16:56.750 --> 00:16:59.186
第一个是你很可能喜欢想要看的

00:16:59.253 --> 00:17:02.256
一个最爱的股票现在的价格是如何的

00:16:59.253 --> 00:17:02.256
一个最爱的股票现在的价格是如何的

00:17:03.156 --> 00:17:06.260
这可以用一个
complication实现

00:17:07.027 --> 00:17:08.295
但是在dock

00:17:08.428 --> 00:17:11.832
我们能够得到一点
2-Second任务的细节

00:17:12.132 --> 00:17:15.502
特别地 我想到另一个
2-Second任务

00:17:15.801 --> 00:17:19.039
想看看你最爱的股票的流通表现

00:17:19.106 --> 00:17:20.874
通过日线图

00:17:22.009 --> 00:17:25.646
最后 我们认为很重要的是 你能看见

00:17:25.712 --> 00:17:28.015
一些股票的当前价格

00:17:29.449 --> 00:17:31.185
我们从complication说起

00:17:31.618 --> 00:17:34.054
当然 complication
是最快的

00:17:34.454 --> 00:17:37.191
在你的watch上察看数据的方法

00:17:37.891 --> 00:17:39.626
数据总是最新的

00:17:39.693 --> 00:17:42.763
你每次从watch上看时间
也能看到它们

00:17:44.264 --> 00:17:46.700
这里最重要的一点
在watchOS 3中

00:17:46.767 --> 00:17:51.605
是数据在complication
和应用之间是同步的

00:17:52.372 --> 00:17:54.308
想要了解更多的信息

00:17:54.374 --> 00:17:57.878
可以去看看“让你的Watch应用
保持更新”的演讲

00:17:58.078 --> 00:17:59.346
今天早上开始的这个课程

00:18:01.682 --> 00:18:03.016
现在我们将要开始讨论

00:18:03.083 --> 00:18:07.020
一些其他的2-Second任务是
如何在watchOS 2表现的

00:18:08.488 --> 00:18:11.658
所以在watchOS 2中
你可以启动Stocks

00:18:12.025 --> 00:18:14.862
并且你可以看到现在的股票价格

00:18:14.928 --> 00:18:17.564
你感兴趣的或者其他的股票

00:18:18.265 --> 00:18:21.401
如果你想看到其他其他的股票
在一天中的表现情况

00:18:21.468 --> 00:18:24.638
你需要点一下那个股票
现在你可以看见了

00:18:24.705 --> 00:18:28.175
这是一点小信息
但是它还是没有回答

00:18:28.242 --> 00:18:31.211
一天股票价格是怎么被展示的

00:18:31.645 --> 00:18:33.080
所以 如果你想知道

00:18:33.146 --> 00:18:35.983
你得向下滚动一点
现在你在图表上了

00:18:37.084 --> 00:18:40.420
我们有四个选项 关于这个列表
我们有一天的间隔

00:18:40.487 --> 00:18:43.357
一周 一个月 半年

00:18:43.891 --> 00:18:46.059
你第一次可能滚动到这里

00:18:46.126 --> 00:18:48.929
你甚至不能看到你关心的间隔

00:18:48.996 --> 00:18:51.031
那可能是一天的间隔

00:18:52.165 --> 00:18:55.335
因此这需要你点击这些小按钮

00:18:55.536 --> 00:18:57.404
并且打开那个图表

00:18:58.172 --> 00:18:59.273
之后

00:18:59.339 --> 00:19:02.576
你将从下面获取其他的元数据

00:18:59.339 --> 00:19:02.576
你将从下面获取其他的元数据

00:19:02.643 --> 00:19:05.179
其实大量的时间并不是必要的

00:19:05.245 --> 00:19:08.015
当你瞥一眼今天的信息

00:19:09.149 --> 00:19:11.251
当然 如果你想看多个股票

00:19:11.318 --> 00:19:12.920
他们一天是如何表现的

00:19:12.986 --> 00:19:15.656
你得向前浏览 点进一个新的去

00:19:15.722 --> 00:19:18.125
很像刚刚Tyler
在动画中给你们展示的

00:19:19.326 --> 00:19:21.261
让我们看看watchOS 3

00:19:22.062 --> 00:19:24.865
这是新的watchOS 3设计
正如你看到的

00:19:24.932 --> 00:19:28.001
首先 仍然是一个你们可以进入的列表

00:19:28.535 --> 00:19:31.471
但是字体变大了 更易读了

00:19:31.538 --> 00:19:33.207
一点简化的接口

00:19:33.273 --> 00:19:37.044
对我来说很好
并且小字体也很容易读

00:19:37.110 --> 00:19:38.445
像你在dock中看的

00:19:39.613 --> 00:19:42.382
如果你想看看apple今天怎么样

00:19:42.449 --> 00:19:45.452
该怎么操作
你会再一次点击Apple

00:19:45.953 --> 00:19:47.988
但现在你在那里看到了表格

00:19:48.222 --> 00:19:51.225
同时我们假设你总是想看日线图

00:19:52.092 --> 00:19:54.795
也有例外 没有日线图

00:19:55.095 --> 00:19:57.297
像基金没有日线图

00:19:57.764 --> 00:20:00.067
我们可以回退到一个月的图表

00:19:57.764 --> 00:20:00.067
我们可以回退到一个月的图表

00:20:00.133 --> 00:20:01.468
当我们浏览它

00:20:01.702 --> 00:20:05.105
这可能是你更期望的一目了然的间隔

00:20:07.441 --> 00:20:10.410
我们同时去掉了
下面分钟的详细信息

00:20:10.878 --> 00:20:12.846
这让我们获得两个好处

00:20:12.980 --> 00:20:17.751
一个是 去掉了一个网络请求
加快了加载性能

00:20:18.919 --> 00:20:23.257
第二个是 我们可以使用新的垂直
详细分页API

00:20:23.490 --> 00:20:26.693
那样的话 你可以浏览多个股票

00:20:26.860 --> 00:20:30.330
可以通过旋转数字表冠
或者用手指轻扫

00:20:31.031 --> 00:20:34.101
当然 如果你想查看股票的详细信息

00:20:34.735 --> 00:20:36.837
像以前的分钟信息

00:20:36.904 --> 00:20:39.273
比如52周最高 52周最低

00:20:39.840 --> 00:20:41.608
你可以使用Handoff

00:20:42.209 --> 00:20:44.144
通过Handoff

00:20:44.278 --> 00:20:48.949
你可以设置一个上下文
然后把它转移到iPhone上

00:20:49.449 --> 00:20:52.653
所以我们感觉watch是
大体浏览数据的地方

00:20:53.187 --> 00:20:56.790
iPhone才是浏览 像一个视图

00:20:56.857 --> 00:20:59.793
详细和复杂的数据的地方

00:21:01.662 --> 00:21:03.830
好的是新的设计 像我刚才说的

00:21:03.897 --> 00:21:05.432
在dock上是易读的

00:21:06.266 --> 00:21:08.535
通过dock

00:21:08.602 --> 00:21:12.039
我们决定重新评估对于股票
我们应该在dock显示什么

00:21:12.639 --> 00:21:14.341
如果你参加了其他的一些课程

00:21:14.408 --> 00:21:18.345
你会注意到有一个理念默认状态
和一个快照

00:21:20.113 --> 00:21:22.516
这表示这应该是一个粘性的视图

00:21:22.816 --> 00:21:25.419
粘性的意思是当你离开股票应用时

00:21:25.485 --> 00:21:27.120
如果你正在看股票列表

00:21:27.387 --> 00:21:29.990
当你回到股票 无论从dock中或者

00:21:30.057 --> 00:21:32.292
通过应用进入

00:21:32.459 --> 00:21:34.027
你还会看到股票列表

00:21:34.862 --> 00:21:36.897
这个视图我们会持续更新

00:21:36.964 --> 00:21:37.965
在这一天中

00:21:38.966 --> 00:21:42.803
然而 如果你点击进入股票详细

00:21:42.870 --> 00:21:46.940
然后返回dock或进入应用

00:21:47.841 --> 00:21:49.343
你将会看到详细视图

00:21:49.710 --> 00:21:51.345
这里有一个需要注意的地方

00:21:52.079 --> 00:21:55.415
在股票中你设置complication股票

00:21:55.782 --> 00:21:58.752
你可以看到的股票
在你的complication

00:21:58.819 --> 00:22:01.722
我们这么做是这很可能是你喜欢的股票

00:21:58.819 --> 00:22:01.722
我们这么做是这很可能是你喜欢的股票

00:22:02.155 --> 00:22:03.524
一旦你设置了它

00:22:03.590 --> 00:22:05.926
这将是我们返回给你的详细视图

00:22:06.260 --> 00:22:07.728
如果你打开股票

00:22:07.794 --> 00:22:11.131
你从Apple浏览到
Facebook

00:22:11.532 --> 00:22:13.901
然后回到桌面

00:22:14.935 --> 00:22:16.036
差不多一个小时内

00:22:16.103 --> 00:22:19.439
当我们返回快照默认状态标识时

00:22:20.073 --> 00:22:22.309
我们会回到Apple的股票

00:22:22.543 --> 00:22:23.777
我们这样做是因为

00:22:23.844 --> 00:22:26.547
你已选择了它作为
你的complication股票

00:22:26.847 --> 00:22:28.215
然后将会是你的收藏股票

00:22:28.282 --> 00:22:30.317
这个是我们想要返回给你的

00:22:30.384 --> 00:22:32.553
我们有一个可预期的体验

00:22:32.619 --> 00:22:34.521
总是返回用户期望看到的东西

00:22:34.588 --> 00:22:37.191
在过一段时间后

00:22:38.792 --> 00:22:43.130
让我们概括下关于股票
我们做了什么2-Second任务

00:22:43.397 --> 00:22:44.231
第一件事是

00:22:46.099 --> 00:22:50.737
我们要保证应用和complication间的数据一致性

00:22:51.738 --> 00:22:52.573
另一个是

00:22:52.873 --> 00:22:54.274
我们简化了我们的设计

00:22:54.541 --> 00:22:57.411
我们在减小大小的同时
让它变得更清晰易读

00:22:58.278 --> 00:23:00.747
更易用

00:22:58.278 --> 00:23:00.747
更易用

00:23:01.181 --> 00:23:05.219
无论何时你通过
详细分页API垂直滚动

00:23:05.619 --> 00:23:09.189
可以快速的让你查看多个股票

00:23:09.456 --> 00:23:11.792
替代以前的来回拖拽

00:23:13.060 --> 00:23:15.762
接下来 我们讲一下后台刷新

00:23:16.463 --> 00:23:18.065
我会多讲一下

00:23:18.131 --> 00:23:20.934
我们如何实现股票的后台刷新

00:23:25.873 --> 00:23:28.675
当我们开始实现股票中的后台刷新

00:23:28.876 --> 00:23:30.277
我们需要考虑两个问题

00:23:30.611 --> 00:23:31.445
第一

00:23:31.845 --> 00:23:34.915
我们需要一个什么样的频率
来更新股票中的信息

00:23:36.049 --> 00:23:40.320
第二我们需要获取什么样的
数据来更新应用

00:23:42.489 --> 00:23:45.392
决定我们应该多久刷新下股票的数据

00:23:45.659 --> 00:23:47.461
有一点取巧的意思

00:23:48.195 --> 00:23:51.965
首先我们感觉每15分钟更新一次
看起来不错

00:23:54.301 --> 00:23:57.571
这将会使应用在一天中更新好多次

00:23:57.638 --> 00:24:02.709
但是其中很多时候的更新都没有用

00:23:57.638 --> 00:24:02.709
但是其中很多时候的更新都没有用

00:24:02.976 --> 00:24:06.980
像当每天结束或者周末闭盘的时候

00:24:08.815 --> 00:24:10.717
让我们参考下已知的一些事实情况

00:24:10.784 --> 00:24:13.820
因为我们感觉可以更好的实现它

00:24:13.921 --> 00:24:16.790
首先 股市只在每天的特定时间开盘

00:24:17.157 --> 00:24:19.760
例如 我们订阅了一个

00:24:19.826 --> 00:24:21.195
纽交所的股票

00:24:22.196 --> 00:24:23.397
同时我们知道

00:24:23.463 --> 00:24:26.166
纽交所在东部时间早上9:30开盘

00:24:26.533 --> 00:24:28.669
并且会在东部时间下午4点闭盘

00:24:29.269 --> 00:24:31.905
如果我们限制了后台刷新请求

00:24:31.972 --> 00:24:35.142
仅当股市开盘时

00:24:35.409 --> 00:24:38.045
我们可以减少更新次数

00:24:38.846 --> 00:24:41.949
可以节省出资源给其他应用

00:24:43.483 --> 00:24:45.185
同时也会让我们受益

00:24:45.285 --> 00:24:48.422
不用多次更新我们的应用
和complication

00:24:49.323 --> 00:24:51.058
它会很没效率

00:24:51.758 --> 00:24:53.293
同时这样也很好

00:24:58.632 --> 00:25:01.068
让我们看一点我们怎么实现的伪代码

00:24:58.632 --> 00:25:01.068
让我们看一点我们怎么实现的伪代码

00:25:01.134 --> 00:25:04.638
我们如何判断何时需要进行下一次刷新

00:25:05.606 --> 00:25:08.475
首先 我们会遍历我们的股票列表

00:25:09.943 --> 00:25:16.617
然后我们检查股市是不是都关闭了

00:25:16.683 --> 00:25:18.719
因为如果我们知道股市都闭盘了

00:25:18.785 --> 00:25:22.656
我们想知道股票列表中的
下一个最近的开盘时间

00:25:23.524 --> 00:25:26.093
不然的话 这表示
至少有一个股市是开着的

00:25:26.360 --> 00:25:28.962
那我们就需要15分钟刷新一次了

00:25:30.564 --> 00:25:32.199
我们看一点源代码

00:25:32.900 --> 00:25:34.401
首先大家需要注意

00:25:34.468 --> 00:25:36.303
一个函数 我们在股票应用中用来

00:25:36.370 --> 00:25:38.238
在后台定时刷新

00:25:38.572 --> 00:25:40.374
在特定的时间里

00:25:42.376 --> 00:25:47.814
我们用的是WKExtension中
的scheduleBackgroundRefresh方法

00:25:48.282 --> 00:25:51.418
我们会传入
preferredDate

00:25:52.486 --> 00:25:54.922
这个preferredDate是在
应用中的其他地方计算的

00:25:55.055 --> 00:25:57.424
代表我们的后台计划刷新时间

00:25:57.491 --> 00:25:59.860
我们从最后往前看一下

00:26:01.295 --> 00:26:04.998
我们看看在nextPreferredRefreshDate里有什么

00:26:06.099 --> 00:26:08.569
这个函数的开始有个guard

00:26:08.702 --> 00:26:13.874
我们会调用earliestNextOpenDateInStocks

00:26:15.442 --> 00:26:17.177
如果返回nil

00:26:18.412 --> 00:26:20.047
我们继续往前

00:26:20.214 --> 00:26:22.983
因为在earliestNextOpenDateInStocks中

00:26:23.050 --> 00:26:26.320
如果列表中没有股票我们会返回nil

00:26:26.520 --> 00:26:29.223
因为这时候 做后台刷新没有用

00:26:29.289 --> 00:26:30.924
因为没有数据刷新

00:26:33.060 --> 00:26:37.598
我们接着往下并且计算下一个
nextRegularRefreshDate

00:26:37.698 --> 00:26:40.234
刚好是更新频率 每15分钟一次

00:26:41.502 --> 00:26:43.737
最后我们在这里检查

00:26:43.804 --> 00:26:46.373
所以 我们用earliestNextOpenDateInStocks

00:26:46.773 --> 00:26:51.111
我们会和nextRegularRefreshDate做时间比较

00:26:52.179 --> 00:26:54.448
现在我们的earliestNextOpenDateInStocks

00:26:54.515 --> 00:26:58.085
也会多了一个返回
distantPast

00:26:58.585 --> 00:27:01.154
如果我们的任何一支股票正在开盘

00:26:58.585 --> 00:27:01.154
如果我们的任何一支股票正在开盘

00:27:01.488 --> 00:27:06.226
这段代码中后面的时间会
一直是固定的刷新时间

00:27:08.362 --> 00:27:11.131
我们看看earliestNextOpenDateInStocks方法

00:27:11.965 --> 00:27:13.967
首先我们将获取我们的股票列表

00:27:14.234 --> 00:27:16.270
然后做检查

00:27:17.504 --> 00:27:20.507
如果这里还是0
我们会退出 返回nil

00:27:20.574 --> 00:27:23.043
这时后台刷新没有用

00:27:25.379 --> 00:27:29.183
然后我们遍历我们列表中的股票

00:27:31.785 --> 00:27:35.689
如果任何其中一个开盘

00:27:36.089 --> 00:27:38.392
我们会提前返回
distantPast

00:27:39.126 --> 00:27:41.195
不然的话我们将检查

00:27:41.461 --> 00:27:45.232
我们会遍历列表找到
earliestNextOpenDate

00:27:46.066 --> 00:27:48.702
我的意思是 我想展示一些代码

00:27:49.269 --> 00:27:52.606
因为我们认为这是限制后台刷新

00:27:52.673 --> 00:27:55.709
次数的很好的方式
不用全部的代码

00:27:59.613 --> 00:28:02.149
我们说说多个后台请求调度

00:27:59.613 --> 00:28:02.149
我们说说多个后台请求调度

00:28:02.716 --> 00:28:03.917
因为特别对股票来说

00:28:03.984 --> 00:28:06.987
我们需要在两个地方保持应用数据更新

00:28:07.354 --> 00:28:08.522
我们需要在终点A

00:28:08.589 --> 00:28:11.792
保持应用数据更新

00:28:11.859 --> 00:28:14.695
我们还需要终点B
更新complication

00:28:17.331 --> 00:28:20.567
所以如果我们计划后台刷新时间

00:28:20.901 --> 00:28:21.735
我们这么做

00:28:22.102 --> 00:28:24.605
我们一旦收到处理后台任务

00:28:25.172 --> 00:28:28.242
我们会提交终端A的请求
提交终端B的请求

00:28:28.509 --> 00:28:31.044
我们会计划我们未来后台刷新时间

00:28:31.111 --> 00:28:32.813
它看起来是什么样的
好的...

00:28:33.046 --> 00:28:36.650
在WKExtension代理中
我们有处理后台任务的方法

00:28:37.718 --> 00:28:40.754
我们会遍历这些后台任务

00:28:41.889 --> 00:28:43.590
我们会首先检查

00:28:43.657 --> 00:28:45.325
是否是一个应用刷新任务

00:28:45.759 --> 00:28:49.396
如果是 我们会进行和
计划那些数据更新请求

00:28:49.463 --> 00:28:53.066
在那里我们进行我们的NSURL请求

00:28:54.434 --> 00:28:57.437
接着我们会计划下一次后台刷新时间

00:28:57.504 --> 00:29:00.073
使用nextPreferredRefreshDate

00:28:57.504 --> 00:29:00.073
使用nextPreferredRefreshDate

00:29:01.575 --> 00:29:03.610
然后我们会完成我们的应用刷新任务

00:29:04.545 --> 00:29:06.046
最后一部分
大家需要注意的是

00:29:06.113 --> 00:29:08.348
这个URL会话后台刷新任务

00:29:08.415 --> 00:29:09.650
你会得到其中的一个

00:29:09.983 --> 00:29:13.787
当你触发一个后台NSURL会话调用

00:29:14.288 --> 00:29:16.757
我们需要把它先存到某个地方

00:29:16.823 --> 00:29:20.460
我们会稍后完成它无论请求何时结束

00:29:24.031 --> 00:29:26.400
现在我们讨论过了它
我们看看 它看起来啥样

00:29:26.466 --> 00:29:28.402
当我们触发那些NSURL请求

00:29:28.468 --> 00:29:29.469
在一个高的层级

00:29:29.770 --> 00:29:34.575
我们安排那些请求
然后当那些请求结束了

00:29:35.242 --> 00:29:38.078
我们会计划一个快照
重新加载complication

00:29:38.145 --> 00:29:40.781
当我们将要完成我们的后台刷新任务

00:29:42.382 --> 00:29:43.383
第一件事

00:29:43.450 --> 00:29:46.653
我们会设置应用数据请求
和complication数据请求

00:29:47.554 --> 00:29:49.790
然后我们设置我们的完成更新处理函数

00:29:49.857 --> 00:29:53.794
现在完成更新处理函数仅仅是

00:29:53.861 --> 00:29:57.431
一个我设置的块
无论何时NSURL会话

00:29:57.497 --> 00:30:01.468
的完成后台请求代理方法被调用

00:29:57.497 --> 00:30:01.468
的完成后台请求代理方法被调用

00:30:01.535 --> 00:30:03.504
我就能调用那个完成更新处理函数

00:30:03.804 --> 00:30:06.507
这是那个块里面的所有内容

00:30:09.409 --> 00:30:10.878
然后我们有一个
submitRequest

00:30:10.944 --> 00:30:13.547
作用就是开始这个网络请求

00:30:13.614 --> 00:30:15.482
同时调用这个任务的恢复

00:30:16.984 --> 00:30:21.388
一旦该任务完成了 我们可从
urlSessionTasks里得到该任务

00:30:21.455 --> 00:30:22.756
它是一个字典

00:30:23.457 --> 00:30:26.293
我们会计划快照
重新加载complication

00:30:26.727 --> 00:30:29.796
我们继续然后完成那个URL会话任务

00:30:32.866 --> 00:30:37.004
最后我要调用的是
urlSessionDidFinishEvents

00:30:37.070 --> 00:30:40.407
为了给你展示
无论何时你的请求完成了

00:30:40.474 --> 00:30:45.179
我们会从会话配置里得到标识

00:30:45.579 --> 00:30:47.281
然后我们请求我们的
finishUpdateHandler

00:30:47.948 --> 00:30:49.650
这个给你一个线索

00:30:49.716 --> 00:30:53.187
如何同时运行多个请求
保持你的应用更新

00:30:53.253 --> 00:30:56.156
如果你的应用和
complication有不同的请求

00:30:56.723 --> 00:30:59.593
第一件事
明显是你想优化

00:30:59.660 --> 00:31:01.862
调用你应用的更新频率是多少

00:30:59.660 --> 00:31:01.862
调用你应用的更新频率是多少

00:31:01.929 --> 00:31:03.497
当你做后台刷新时

00:31:03.864 --> 00:31:05.832
这是第一目标

00:31:06.767 --> 00:31:09.336
如果你从服务器上更新数据

00:31:09.403 --> 00:31:12.573
尽量单独制定的端点
如果你能控制的话

00:31:12.940 --> 00:31:14.808
如果你不能 它可以

00:31:14.875 --> 00:31:17.811
提交多个请求在后台刷新时

00:31:19.012 --> 00:31:22.916
现在我们看下恢复时间优化

00:31:23.150 --> 00:31:25.886
当通过扩展你优化你的恢复时间

00:31:25.953 --> 00:31:27.988
你将同时会优化你的启动时间

00:31:28.055 --> 00:31:28.956
这很棒

00:31:31.558 --> 00:31:33.360
我们说说我们能做什么

00:31:33.694 --> 00:31:35.062
就像Tyler刚才说的

00:31:36.363 --> 00:31:39.867
你可以在willActivate和
didAppear时 将任务最小化

00:31:39.933 --> 00:31:41.201
你知道做它

00:31:41.268 --> 00:31:44.271
避免从willActivate中
触发较长运行时间的任务

00:31:44.505 --> 00:31:47.140
我们将会做一个聪明的
加载和重新加载数据

00:31:47.508 --> 00:31:49.810
当然像他刚才说的我们最好只设置属性

00:31:49.877 --> 00:31:52.412
属于接口中改变的元素的

00:31:53.380 --> 00:31:55.949
我将会用一个警示开始

00:31:56.016 --> 00:31:59.486
这包括实现垂直详细分页API

00:32:00.153 --> 00:32:01.121
像Tyler刚才说的

00:32:01.188 --> 00:32:03.590
相邻的详细分页的
willActivate会被调用

00:32:04.091 --> 00:32:06.693
你同时想要避免耗时的操作

00:32:06.760 --> 00:32:08.829
在详细页面
willActivate中

00:32:08.896 --> 00:32:12.699
尤其是 在这个视图里有一个
非常耗时的操作

00:32:13.600 --> 00:32:15.102
所以由几个错误报告开始

00:32:15.169 --> 00:32:17.204
我们基本上得到的是加载慢的报告

00:32:17.271 --> 00:32:20.874
股票视图加载慢
当你第一次进入详细页面时

00:32:21.308 --> 00:32:23.911
其他详细页从来没有加载他们的图表

00:32:23.977 --> 00:32:25.612
或者是相当慢

00:32:26.213 --> 00:32:27.581
现在我们看看代码

00:32:27.848 --> 00:32:29.349
尝试看看到底发生了什么

00:32:29.416 --> 00:32:32.286
这是一个缩减版的股票接口控制器

00:32:32.352 --> 00:32:33.420
你会发现

00:32:33.487 --> 00:32:36.390
在willActivate我们
调用了downloadAndGenerateChart

00:32:36.723 --> 00:32:40.994
基本上NSOperation
是一个长时间运行的

00:32:41.061 --> 00:32:44.164
并且做很多工作
获取图表数据绘制图表

00:32:45.032 --> 00:32:46.800
我们能在这个基础上提高点什么呢

00:32:48.101 --> 00:32:51.338
我们知道didAppear被调用

00:32:51.405 --> 00:32:53.774
当视图控制器可见的时候

00:32:53.841 --> 00:32:55.275
对用户同时被选中

00:32:56.176 --> 00:32:59.613
如果我们开始在这里
下载和生成数据表呢

00:33:00.514 --> 00:33:04.585
如果你频繁的滑动会发生什么

00:33:05.252 --> 00:33:07.754
我们不想继续下载和生成图表数据

00:33:07.821 --> 00:33:09.256
对于已经离开的视图

00:33:09.756 --> 00:33:12.659
我们会调用cancelDownloadAndGenerateChart

00:33:12.726 --> 00:33:15.295
它会获得运行的操作

00:33:15.362 --> 00:33:16.296
并取消它

00:33:16.830 --> 00:33:21.268
我们看看
再一次看看其中的注意事项

00:33:21.335 --> 00:33:23.570
因为我已经知道了这里的错误

00:33:24.338 --> 00:33:27.307
想在willActivate
避免触发长时间的运行任务

00:33:29.543 --> 00:33:34.047
如果可能 最好使用可取消的操作

00:33:34.448 --> 00:33:37.985
做这个NSOperation
是一个比较好的模板

00:33:38.285 --> 00:33:40.621
我们看看WKInterfaceTable加载

00:33:41.655 --> 00:33:43.657
我们知道所有的行被加载到内存

00:33:44.124 --> 00:33:45.993
我们知道它提前有个线性的花费

00:33:46.059 --> 00:33:48.195
根据你表中的行数

00:33:48.762 --> 00:33:52.232
同时不会像
UITableView会有重用

00:33:52.933 --> 00:33:54.868
我将会展示一个图
一个性能分析

00:33:54.935 --> 00:33:56.270
我对这个股票做的

00:33:57.037 --> 00:34:00.040
这是初始化启动时间
重启以后

00:33:57.037 --> 00:34:00.040
这是初始化启动时间
重启以后

00:34:00.107 --> 00:34:01.975
没有恢复时间或其他的

00:34:02.409 --> 00:34:05.245
重要的是你要注意这里
我们没有股票在列表中

00:34:05.312 --> 00:34:08.382
一个空的股票列表
用了5.5秒加载

00:34:09.683 --> 00:34:11.851
如果我们添加一个股票进去
它会多一点

00:34:11.918 --> 00:34:14.955
差不多6.5秒
如果加5个股票

00:34:15.022 --> 00:34:16.989
稍微多余6.5秒

00:34:17.424 --> 00:34:21.295
如果我们添加10个股票
现在开始接近7秒了

00:34:22.596 --> 00:34:25.899
如果你有大量的行

00:34:25.966 --> 00:34:30.404
在你的表中那会延长

00:34:30.469 --> 00:34:32.339
接口控制器的加载时间

00:34:36.176 --> 00:34:39.012
我们这里能做什么才能降低加载时间

00:34:39.079 --> 00:34:41.648
第一我们可以限制加载的行数

00:34:42.416 --> 00:34:45.418
我们可以智能的更新我们的表格

00:34:45.485 --> 00:34:48.388
当行发生变化 当列表发生变化

00:34:48.722 --> 00:34:50.991
我们看看loadTable
的初始化部分

00:34:52.525 --> 00:34:55.128
我们从manager里面获取数据

00:34:55.195 --> 00:34:57.731
接着设置表的行数

00:34:59.166 --> 00:35:00.133
然后

00:34:59.166 --> 00:35:00.133
然后

00:35:00.200 --> 00:35:03.237
我们计算每个股票的行控制器

00:35:03.537 --> 00:35:06.373
开始看起来没有问题
那里放生了什么

00:35:06.507 --> 00:35:09.776
股票的数量没有被限制
如果你有20个股票

00:35:09.843 --> 00:35:12.980
那将有20行 若有30个会有30行
依次往下

00:35:14.948 --> 00:35:17.084
我们一直使用一定数量行的集合

00:35:17.317 --> 00:35:21.488
如果有一行被添加
当使用那一行时

00:35:21.555 --> 00:35:24.958
你会擦掉之前有的

00:35:25.425 --> 00:35:26.894
然后从头开始

00:35:26.960 --> 00:35:28.028
这很没有效率

00:35:28.829 --> 00:35:31.632
我们看看我们怎么样处理
让它变得智能点

00:35:31.932 --> 00:35:34.902
我们像之前一样先获取股票
我们检查数量

00:35:34.968 --> 00:35:37.538
然后我们设置一个最大值

00:35:37.604 --> 00:35:39.106
在这个股票例子 为20

00:35:40.407 --> 00:35:43.110
我们接着计算行差异

00:35:43.177 --> 00:35:45.579
看他们之间的不同
变了多少

00:35:45.779 --> 00:35:47.881
然后我们调用insertRemoveTableRows

00:35:47.948 --> 00:35:49.249
稍后我们会仔细看看

00:35:49.950 --> 00:35:51.919
在下面

00:35:51.985 --> 00:35:54.188
我们确定我们没有做
超过必须的过多工作

00:35:54.254 --> 00:35:56.323
我们会检查确认索引

00:35:56.390 --> 00:35:59.092
在最大的股票列表大小之内

00:36:01.028 --> 00:36:03.130
我们看看insertRemoveTableRows

00:36:03.463 --> 00:36:06.533
第一个要做的是
计算行变化

00:36:07.134 --> 00:36:09.069
然后我检查股票行变化

00:36:09.136 --> 00:36:11.405
如果大于零
我们会处理

00:36:11.705 --> 00:36:16.176
如果小于零
我们需要删除掉

00:36:16.510 --> 00:36:17.477
最重要是

00:36:17.544 --> 00:36:19.680
你可以做的更聪明点
如果你想

00:36:19.746 --> 00:36:23.116
基于列表实际变了多少来更新

00:36:23.650 --> 00:36:25.185
但我们发现 因为性能原因

00:36:25.252 --> 00:36:29.857
仅仅做一个在0处插入或删除

00:36:29.923 --> 00:36:32.960
在索引0处
看起来工作的不错

00:36:34.127 --> 00:36:35.963
所以我们不要做我们不需要做的工作

00:36:37.397 --> 00:36:40.634
概括来说
你的股票列表的股票的数量

00:36:40.701 --> 00:36:43.070
或者像我的例子 这个股票列表

00:36:43.136 --> 00:36:44.805
你的情况中 我不确定你放了什么进去

00:36:44.872 --> 00:36:46.940
但是保持这个数量降低
并且控制在

00:36:47.007 --> 00:36:49.276
一个合理的数量在你的用例中

00:36:50.944 --> 00:36:53.947
下一步 当你插入和移除行时

00:36:54.014 --> 00:36:55.582
那将会更有效

00:36:55.649 --> 00:36:59.786
比你仅仅调用
WKInterfaceTable的设置行数方法

00:37:02.456 --> 00:37:04.525
最后一件事
不要遍历整个表

00:37:04.591 --> 00:37:08.362
当一行数据更新时

00:37:08.428 --> 00:37:12.533
所以这么想 就像如果
我们正在更新Apple股票的价格

00:37:12.599 --> 00:37:15.269
在表列表或股票列表

00:37:16.336 --> 00:37:17.471
作为取代遍历和

00:37:17.538 --> 00:37:20.140
更新每一行当我们不必这么做时

00:37:20.707 --> 00:37:23.010
我们可以使用
rowController(at index)

00:37:23.076 --> 00:37:25.512
这样我们就可以只更新
我们想更新的那一行

00:37:25.979 --> 00:37:30.117
或者 你甚至可以做类似
存储一个引用

00:37:30.184 --> 00:37:32.619
对于rowController
且在稍后更新

00:37:34.922 --> 00:37:38.091
我们讨论下更新UIElements

00:37:38.392 --> 00:37:42.729
Tyler刚才提到的
UIObjects和WatchKit

00:37:43.297 --> 00:37:47.067
他们在extension进程中
被修改更新这些属性

00:37:47.134 --> 00:37:49.369
需要从extension进程
发送到应用进程

00:37:49.903 --> 00:37:53.006
app进程处理界面的布局

00:37:53.473 --> 00:37:56.610
我们看看股票的UI
只有一个rowController

00:37:56.944 --> 00:37:58.512
但我们有个表盘这里

00:37:58.579 --> 00:38:01.248
对于这行是可点击的

00:37:58.579 --> 00:38:01.248
对于这行是可点击的

00:38:02.282 --> 00:38:05.018
我们也有一个列表名字
就是股票代码

00:38:05.085 --> 00:38:07.221
的公司名 它是个标签

00:38:07.287 --> 00:38:09.356
还有changeInPointsLabel

00:38:09.423 --> 00:38:11.325
这就是需要修改的地方

00:38:11.658 --> 00:38:14.094
还有价格标签表示当前价格

00:38:14.494 --> 00:38:16.463
我们看看我们需要做什么

00:38:16.530 --> 00:38:18.332
更新rowController时

00:38:18.398 --> 00:38:19.700
我们有更新方法

00:38:19.766 --> 00:38:21.568
它会接收我们给它的任何值

00:38:21.635 --> 00:38:23.504
它会立刻设置那些属性

00:38:24.505 --> 00:38:28.342
现在不好 因为界面上的对象属性

00:38:28.408 --> 00:38:31.945
没有被缓存 对么

00:38:32.779 --> 00:38:36.283
设置对象的属性会每次

00:38:36.350 --> 00:38:39.086
都发送值给应用进程
我们会减少它

00:38:39.152 --> 00:38:41.388
但我想强调它的重要性

00:38:42.723 --> 00:38:45.792
一般来说 在我的分析中

00:38:45.859 --> 00:38:49.696
在股票中需要花费大约
200毫秒把一个值

00:38:49.763 --> 00:38:52.733
从extension进程发送到
应用进程

00:38:53.233 --> 00:38:56.403
看起来时间不长 但是

00:38:57.371 --> 00:39:01.575
在有些分析中
在初次启动时

00:38:57.371 --> 00:39:01.575
在有些分析中
在初次启动时

00:39:02.142 --> 00:39:05.846
我发现会超过平均值很多

00:39:05.913 --> 00:39:09.883
最坏的情况需要1.4秒

00:39:09.950 --> 00:39:12.719
从extension进程发送到
应用进程

00:39:13.387 --> 00:39:14.655
变化很大

00:39:16.924 --> 00:39:18.725
我们该如何做才能更智能些

00:39:19.426 --> 00:39:22.262
缓存那些已经发送的数据

00:39:22.329 --> 00:39:25.399
只在发生变化时发送

00:39:26.533 --> 00:39:30.037
我们来概括下恢复时间的讨论

00:39:30.370 --> 00:39:33.140
我们想尽量减少
willActivate里的工作

00:39:33.207 --> 00:39:35.642
在 didAppear 我们想使用

00:39:35.709 --> 00:39:38.312
可取消的操作 当可能的时候

00:39:38.979 --> 00:39:42.316
你还要注意 过于复杂的用户界面

00:39:42.649 --> 00:39:44.451
会导致更慢的加载时间

00:39:44.518 --> 00:39:46.553
所以当数据越多

00:39:46.620 --> 00:39:49.122
需要更新到UI上
它就可能越慢

00:39:49.890 --> 00:39:52.526
当然 我们只想更新我们的用户界面

00:39:52.593 --> 00:39:54.895
在必要的时候 当发生变化时

00:39:55.863 --> 00:39:58.165
总结一下 这个股票的案例

00:39:58.532 --> 00:40:02.002
希望大家能从这里开始
思考关于你的应用

00:39:58.532 --> 00:40:02.002
希望大家能从这里开始
思考关于你的应用

00:40:02.503 --> 00:40:05.305
保证你的任务小和简单

00:40:06.073 --> 00:40:08.742
简化你的用户界面

00:40:09.209 --> 00:40:12.813
使用新的后台刷新API

00:40:13.981 --> 00:40:15.849
集中在应用的恢复时间

00:40:15.916 --> 00:40:19.419
我们需要多注意WKInterfaceController
生命周期方法

00:40:19.486 --> 00:40:21.522
尤其是willActivate
和didAppear

00:40:21.855 --> 00:40:24.725
充分利用可取消的操作

00:40:25.092 --> 00:40:27.961
在你更新UI时要做优化

00:40:28.028 --> 00:40:29.763
不要发送冗余的信息

00:40:30.631 --> 00:40:33.600
想要了解更多
你可以访问开发者网站

00:40:33.667 --> 00:40:35.102
我们的演讲编号是227

00:40:36.003 --> 00:40:38.805
一些相关的演讲 不幸的是已经开始了

00:40:39.239 --> 00:40:40.874
其中一些我感觉很重要

00:40:40.941 --> 00:40:44.545
不仅是WatchKit开发
我们也有并发编程

00:40:44.611 --> 00:40:47.214
Swift 3中的GCD
所以也同样重要

00:40:48.649 --> 00:40:51.885
谢谢
祝大家本周接下来的日子过得愉快
