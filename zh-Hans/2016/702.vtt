WEBVTT

00:00:19.386 --> 00:00:21.822 align:middle
在StoreKit中利用Swift 3
进行In-App Purchase

00:00:21.889 --> 00:00:22.756 align:middle
大家好

00:00:29.229 --> 00:00:30.631 align:middle
我是Dana DuBois

00:00:30.697 --> 00:00:33.500 align:middle
在基础框架团队担任技术经理

00:00:33.567 --> 00:00:37.137 align:middle
在iOS和tvOS上框架可以
帮助App Store更好发挥作用

00:00:37.204 --> 00:00:40.741 align:middle
今天我们要谈论的是众多框架中的一个

00:00:41.175 --> 00:00:42.309 align:middle
它是StoreKit

00:00:44.011 --> 00:00:46.914 align:middle
你们当中许多人知道
StoreKit已经存在了很长时间

00:00:46.980 --> 00:00:49.816 align:middle
它是在iPhone的iOS 3
系统中被引入的

00:00:50.117 --> 00:00:53.187 align:middle
从那时起到现在
它已经被成千上万的应用使用

00:00:53.253 --> 00:00:55.589 align:middle
来实现各式各样的商业模型

00:00:55.722 --> 00:01:00.627 align:middle
报纸 杂志 游戏

00:00:55.722 --> 00:01:00.627 align:middle
报纸 杂志 游戏

00:01:01.061 --> 00:01:03.163 align:middle
甚至约会应用都使用StoreKit

00:01:03.230 --> 00:01:05.065 align:middle
它实实在在的被广泛使用着

00:01:05.465 --> 00:01:09.870 align:middle
关于StoreKit我们在
WWDC 上已经谈论了很多

00:01:10.437 --> 00:01:12.506 align:middle
今年我们将要做一些新的东西

00:01:12.573 --> 00:01:14.675 align:middle
我们谈论它在Swift上的使用

00:01:14.741 --> 00:01:17.010 align:middle
听上去令人兴奋
我们有些新应用接口可使用

00:01:17.878 --> 00:01:21.315 align:middle
多了一些新的东西
那就是Swift API

00:01:21.381 --> 00:01:22.482 align:middle
那真是太棒了

00:01:22.916 --> 00:01:24.918 align:middle
在上周 你们中的许多人
或许已经听说了

00:01:24.985 --> 00:01:27.888 align:middle
围绕着程序订阅我们发布了
一些重要的通知

00:01:27.955 --> 00:01:30.490 align:middle
这同样也令我们兴奋

00:01:30.691 --> 00:01:34.094 align:middle
我想很多开发者最终会去

00:01:34.161 --> 00:01:37.297 align:middle
使用程序订阅的增强特性

00:01:37.531 --> 00:01:39.433 align:middle
我将给你们大体介绍下它的新特性

00:01:40.767 --> 00:01:43.303 align:middle
首先 分类

00:01:43.670 --> 00:01:46.240 align:middle
我们十分兴奋的宣布

00:01:46.306 --> 00:01:49.576 align:middle
分类将不再影响你选择

00:01:49.643 --> 00:01:52.479 align:middle
去使用自动更新订阅在你的应用中

00:01:53.213 --> 00:01:56.016 align:middle
但标准仍将存在

00:01:56.083 --> 00:01:58.619 align:middle
指导你如何使用自动更新订阅

00:01:58.685 --> 00:02:01.021 align:middle
但分类将不会再是一个重要的影响因素

00:01:58.685 --> 00:02:01.021 align:middle
但分类将不会再是一个重要的影响因素

00:02:02.322 --> 00:02:05.092 align:middle
其次 每个人都会感到兴奋

00:02:05.158 --> 00:02:07.728 align:middle
就是我们会把更多的收益给开发者

00:02:08.228 --> 00:02:12.232 align:middle
假如你保持你的订阅用户
使用一年以上 那是极好的

00:02:12.733 --> 00:02:14.468 align:middle
我想那将是一大单生意

00:02:19.540 --> 00:02:20.541 align:middle
定价

00:02:20.607 --> 00:02:23.143 align:middle
我们将更多的控制权给开发者

00:02:23.210 --> 00:02:26.180 align:middle
开发者通过iTunes
Connect来设置定价

00:02:26.246 --> 00:02:30.817 align:middle
基于领土之间 国家之间
为他们的程序订阅

00:02:31.084 --> 00:02:34.388 align:middle
如果由于商业原因
你需要调整在欧洲的定价

00:02:34.454 --> 00:02:38.292 align:middle
相比于美国来说
相对于过去现在你有了更多的权限

00:02:39.426 --> 00:02:42.329 align:middle
随着定价的改变 我们将给你能力

00:02:42.396 --> 00:02:47.034 align:middle
来保存价格 为部分用户保留价格

00:02:47.100 --> 00:02:49.002 align:middle
那些已经使用了你程序订阅的用户

00:02:49.069 --> 00:02:50.938 align:middle
仅为新的用户调整价格

00:02:51.004 --> 00:02:54.007 align:middle
假如你想奖励早期的使用者

00:02:54.074 --> 00:02:56.143 align:middle
你想让他们继续使用你的程序订阅

00:02:56.210 --> 00:02:58.912 align:middle
但是你想为新的用户调整定价

00:02:58.979 --> 00:03:00.280 align:middle
现在你有这样的权利了

00:02:58.979 --> 00:03:00.280 align:middle
现在你有这样的权利了

00:03:01.248 --> 00:03:03.584 align:middle
随之而来的是程序的升级和降级

00:03:03.650 --> 00:03:07.287 align:middle
这也是我们给与用户更多的权利...

00:03:07.921 --> 00:03:11.391 align:middle
准确的说用户可以在
你的服务中选择想要的级别

00:03:11.458 --> 00:03:14.027 align:middle
假如用户想升级到白金级

00:03:14.094 --> 00:03:16.296 align:middle
或者是回到普通级别

00:03:16.363 --> 00:03:19.266 align:middle
他们可以通过管理订阅界面
来进行升级或者降级

00:03:19.333 --> 00:03:20.601 align:middle
在他们的设备上

00:03:22.169 --> 00:03:25.472 align:middle line:1
以上就是程序订阅新特性的大体介绍

00:03:25.906 --> 00:03:27.207 align:middle line:1
更多关于程序订阅的内容

00:03:27.274 --> 00:03:30.410 align:middle line:1
如果你想将程序订阅集成到你的应用中

00:03:30.477 --> 00:03:33.380 align:middle
你真的应当去 扩展订阅的介绍

00:03:33.447 --> 00:03:34.481 align:middle
在iTunes Connect

00:03:34.715 --> 00:03:36.717 align:middle
今天下午四点
在Pacific Heights

00:03:37.651 --> 00:03:41.421 align:middle
他们将深入介绍
如何将程序订阅集成到你的应用中

00:03:41.488 --> 00:03:43.557 align:middle
如何在你的应用中去管理你的程序订阅

00:03:43.624 --> 00:03:45.592 align:middle
我极力推荐你们去参加那个活动

00:03:47.294 --> 00:03:48.629 align:middle
这就是程序订阅

00:03:48.695 --> 00:03:51.665 align:middle
我要兴奋地通知大家
除此外 还有新东西

00:03:51.999 --> 00:03:53.667 align:middle
那就是iMessage应用

00:03:54.001 --> 00:03:56.236 align:middle
我们在昨天的主题会中已经展示了

00:03:56.803 --> 00:03:59.006 align:middle
我们将带给大家一个全新类别的应用

00:03:59.072 --> 00:04:01.942 align:middle
在iMessage应用和iMessage中

00:03:59.072 --> 00:04:01.942 align:middle
在iMessage应用和iMessage中

00:04:02.209 --> 00:04:05.546 align:middle
你将可以构建自定义的扩展

00:04:06.046 --> 00:04:10.717 align:middle
我们将在这些扩展中
允许In-App Purchase

00:04:10.784 --> 00:04:14.922 align:middle
在iMessage应用可以使用
同StoreKit几乎一样的API

00:04:14.988 --> 00:04:18.325 align:middle
你今天或许使用着
你在应用商店下载的普通应用

00:04:18.591 --> 00:04:21.161 align:middle
假如你有额外的内容发布到市场

00:04:21.528 --> 00:04:24.665 align:middle
或者在iMessage中让用户体验

00:04:25.365 --> 00:04:26.567 align:middle
现在我们支持它们了

00:04:26.967 --> 00:04:28.902 align:middle
这些特性将在iOS 10可以使用

00:04:28.969 --> 00:04:30.604 align:middle
我们为这些特性感到兴奋

00:04:30.671 --> 00:04:33.607 align:middle
我想开发者们将会很好利用这些新特性

00:04:35.409 --> 00:04:38.712 align:middle
就像我之前说过的
StoreKit已经存在一段时间

00:04:38.779 --> 00:04:41.548 align:middle
人们已长时间使用
In-App Purchase

00:04:41.615 --> 00:04:43.217 align:middle
但对在座的一些人
它是新的东西

00:04:43.283 --> 00:04:47.521 align:middle
我将简单的介绍
何谓In-App Purchase

00:04:47.821 --> 00:04:51.124 align:middle
In-App Purchase
是数字内容或者服务

00:04:51.525 --> 00:04:53.827 align:middle
可以在你的应用中进行购买

00:04:54.528 --> 00:04:57.164 align:middle
然而 要清楚 它不是实体的商品

00:04:57.231 --> 00:04:58.699 align:middle
还有其他方法进行购买

00:04:58.765 --> 00:05:01.969 align:middle
这仅仅只是关于数字内容和服务

00:04:58.765 --> 00:05:01.969 align:middle
这仅仅只是关于数字内容和服务

00:05:03.604 --> 00:05:06.006 align:middle
当我们谈论数字内容和服务时

00:05:06.073 --> 00:05:07.241 align:middle
还有一大堆其他不同的类型

00:05:07.307 --> 00:05:09.009 align:middle
当使用iTunes Connect
对它进行配置的时候

00:05:09.076 --> 00:05:11.678 align:middle
有许多的选项需要你去确认

00:05:11.745 --> 00:05:15.482 align:middle
你需要选择适合你内容的类型

00:05:15.883 --> 00:05:17.818 align:middle
让我们来看下
我们谈论的东西是什么

00:05:18.585 --> 00:05:20.153 align:middle
可以消费的商品

00:05:20.521 --> 00:05:23.690 align:middle
人们在玩某个游戏时
都有一定数量的金币

00:05:23.757 --> 00:05:26.293 align:middle
流通的货币 或者在疾驰汽车里的汽油

00:05:26.360 --> 00:05:28.929 align:middle
或者是用户想要购买的一些东西

00:05:28.996 --> 00:05:32.199 align:middle
买一次 又买一次 用光剩余的时间

00:05:32.266 --> 00:05:34.268 align:middle
这就是可以被购买的商品

00:05:35.402 --> 00:05:39.406 align:middle
不可以被消耗的产品是一成不变的

00:05:39.473 --> 00:05:42.075 align:middle
它始终一成不变 只要用户想使用它

00:05:42.142 --> 00:05:43.510 align:middle
用户们能恢复它

00:05:43.577 --> 00:05:47.981 align:middle
它可以在设备之间传输

00:05:48.048 --> 00:05:49.850 align:middle
这是可消费和
不可消费产品间的细小区别

00:05:49.917 --> 00:05:52.286 align:middle
同样在一个游戏中你有一把剑

00:05:52.352 --> 00:05:55.956 align:middle
或者你有一些类型的武器
再或者你驾驶一辆疾驰的汽车

00:05:56.023 --> 00:05:58.759 align:middle
或者等级
又或者你有一个实用的应用

00:05:58.825 --> 00:06:01.161 align:middle
你的应用或许有一个基础版本

00:05:58.825 --> 00:06:01.161 align:middle
你的应用或许有一个基础版本

00:06:01.228 --> 00:06:03.864 align:middle
你或许想推出一个高级版本的应用

00:06:03.931 --> 00:06:06.667 align:middle
那就是一类不可消费的产品

00:06:08.068 --> 00:06:11.672 align:middle
当我们谈论程序订阅时
我们也有两种类型的订阅

00:06:11.738 --> 00:06:13.807 align:middle
有一种不能自动更新的订阅

00:06:14.474 --> 00:06:16.543 align:middle
像它的名字那样

00:06:16.610 --> 00:06:19.713 align:middle
它不会自动更新
它的更新取决于你和你的应用

00:06:19.780 --> 00:06:23.851 align:middle
你的后端来管理如何去更新订阅

00:06:24.618 --> 00:06:27.454 align:middle
我们也有自动更新订阅

00:06:27.521 --> 00:06:31.592 align:middle
这些程序订阅的使用者
会周期性的付款给Apple

00:06:31.658 --> 00:06:34.361 align:middle
这些都基于你在后台的配置

00:06:34.428 --> 00:06:36.029 align:middle
假如它是每月的程序订阅

00:06:36.496 --> 00:06:38.198 align:middle
每个月我们会给用户出账单

00:06:38.265 --> 00:06:40.767 align:middle
只要他们一直选择使用程序订阅

00:06:42.970 --> 00:06:44.371 align:middle
以上就是订阅的类型

00:06:45.239 --> 00:06:49.009 align:middle
让我们将In-App Purchase加入到你的应用的核心部分

00:06:51.478 --> 00:06:54.214 align:middle
我们将要快速浏览

00:06:54.281 --> 00:06:57.251 align:middle
这些种类中的所有步骤
再深入了解其中的每一步

00:06:57.317 --> 00:07:00.087 align:middle
接下来我们将谈论的是
如何在Swift中使用它

00:06:57.317 --> 00:07:00.087 align:middle
接下来我们将谈论的是
如何在Swift中使用它

00:07:00.721 --> 00:07:05.092 align:middle
你清楚的知道你需要去担心什么

00:07:05.459 --> 00:07:07.561 align:middle
或者你曾经碰到的问题

00:07:07.628 --> 00:07:10.764 align:middle
太多的事情有时会让我们感到厌烦

00:07:10.831 --> 00:07:13.066 align:middle
当你在开发中解决
StoreKit的问题时

00:07:13.600 --> 00:07:15.102 align:middle
一些事情需牢记

00:07:15.169 --> 00:07:16.670 align:middle
首先...

00:07:18.071 --> 00:07:21.508 align:middle
你需要准确了解你出售给用户的是什么

00:07:21.575 --> 00:07:24.111 align:middle
对于消费者就是使用你应用的用户

00:07:24.178 --> 00:07:28.015 align:middle
需要做的仅仅是辨识出这个标识

00:07:28.081 --> 00:07:31.285 align:middle
这些你将发布到应用内的标识

00:07:31.351 --> 00:07:32.619 align:middle
将立即展示给用户

00:07:33.353 --> 00:07:36.623 align:middle
一旦你拥有了这些标识
你可以前往App Store

00:07:36.990 --> 00:07:38.792 align:middle
获取到这些信息

00:07:39.092 --> 00:07:43.597 align:middle
本地化和标识相关的产品信息

00:07:43.664 --> 00:07:45.999 align:middle
确定本地化的信息很重要

00:07:46.066 --> 00:07:48.802 align:middle
App Store是全球化的
应用市场 你需要确保

00:07:48.869 --> 00:07:55.509 align:middle
你展示给用户的是本地化处理后的信息

00:07:57.077 --> 00:08:01.415 align:middle
一旦你有了这些信息
你就可以展示你的产品

00:07:57.077 --> 00:08:01.415 align:middle
一旦你有了这些信息
你就可以展示你的产品

00:08:01.481 --> 00:08:03.050 align:middle
你可以去App Store
发布他们出售你的产品

00:08:03.116 --> 00:08:05.519 align:middle
你的应用你做主

00:08:05.586 --> 00:08:09.089 align:middle
你可以构建优质的UI展示它们

00:08:09.890 --> 00:08:12.693 align:middle
用户会被它们吸引 然后去购买

00:08:12.759 --> 00:08:16.163 align:middle
它们将会被出售 用户会去挑选产品

00:08:16.230 --> 00:08:17.097 align:middle
立即看到产品

00:08:17.431 --> 00:08:21.502 align:middle
但是你需要为你的产品创建支付

00:08:21.568 --> 00:08:23.103 align:middle
并且把它加入到了支付队列

00:08:23.170 --> 00:08:25.873 align:middle
接下来我们谈论的内容
会有许多关于支付队列

00:08:27.574 --> 00:08:29.877 align:middle
当支付的订单通过支付队列时

00:08:29.943 --> 00:08:32.513 align:middle
关于交易的通知会被推送到你的应用

00:08:32.578 --> 00:08:35.015 align:middle
推送到达时你必须做出必要的响应

00:08:35.582 --> 00:08:38.184 align:middle
就是你将如何处理这些交易

00:08:39.052 --> 00:08:41.154 align:middle
最后 当支付完成后

00:08:41.221 --> 00:08:43.090 align:middle
你需要确保应用是可以正常使用

00:08:43.155 --> 00:08:44.958 align:middle
告知用户它们支付了什么

00:08:45.025 --> 00:08:48.795 align:middle
最后通知支付队列
你已经处理了这笔交易

00:08:48.862 --> 00:08:51.431 align:middle
处理完所有的事情 产品是可用的

00:08:51.498 --> 00:08:53.267 align:middle
这样这笔交易就完成了

00:08:54.401 --> 00:08:56.703 align:middle
这就是你需要采取的不同步骤如此迅速

00:08:56.770 --> 00:08:59.339 align:middle
我们将深入了解我们提到的每一步

00:08:59.406 --> 00:09:02.309 align:middle
需要特别注意的是支付队列

00:08:59.406 --> 00:09:02.309 align:middle
需要特别注意的是支付队列

00:09:03.277 --> 00:09:05.112 align:middle
支付队列是应用内购买的核心

00:09:05.179 --> 00:09:07.247 align:middle
In-App Purchase
购买中

00:09:07.848 --> 00:09:12.186 align:middle
对于支付和购买的状态来说
支付队列是它们的来源

00:09:12.252 --> 00:09:14.521 align:middle
由于它们贯穿支付过程的始终

00:09:14.588 --> 00:09:18.125 align:middle
从用户选择商品到完成支付

00:09:19.126 --> 00:09:20.894 align:middle
需要注意

00:09:20.961 --> 00:09:23.830 align:middle
你应当依靠队列并且只能依靠队列

00:09:24.531 --> 00:09:29.102 align:middle
并且需要了解交易的过程 支付的状态

00:09:29.536 --> 00:09:32.239 align:middle
假如你使用主机去下载

00:09:32.306 --> 00:09:34.908 align:middle
支付队列将会告诉你所有的这些下载

00:09:39.446 --> 00:09:41.748 align:middle
另一个需要注意的是

00:09:42.349 --> 00:09:44.651 align:middle
如果支付队列告诉你有一笔支付

00:09:45.085 --> 00:09:46.820 align:middle
它就是有效和真实的支付

00:09:47.454 --> 00:09:50.657 align:middle
在实际过程中 我们看到过一些案例

00:09:50.724 --> 00:09:53.794 align:middle
开发者有可能自己做了缓存

00:09:54.294 --> 00:09:57.798 align:middle
开发者会知道用户点击了产品

00:09:57.865 --> 00:10:00.067 align:middle
开发者管理着支付的各种状态

00:09:57.865 --> 00:10:00.067 align:middle
开发者管理着支付的各种状态

00:10:00.400 --> 00:10:03.704 align:middle
然而这些应用有可能会崩溃
或者会发生其它事情

00:10:03.770 --> 00:10:06.707 align:middle
用户将会在完成支付前关闭应用

00:10:06.773 --> 00:10:09.543 align:middle
用户们将会回到游戏或者其他地方

00:10:09.610 --> 00:10:11.478 align:middle
他们进行支付的页面

00:10:11.812 --> 00:10:14.448 align:middle
开发者没有必要关注这些响应

00:10:14.515 --> 00:10:15.916 align:middle
来自于支付队列

00:10:15.983 --> 00:10:18.352 align:middle
因为它们没有监听这些交易的支付

00:10:18.418 --> 00:10:21.588 align:middle
他们自己的队列没有支付队列的状态

00:10:22.155 --> 00:10:25.158 align:middle
因此你真的需要依赖支付队列

00:10:25.225 --> 00:10:28.662 align:middle
来告知你在这些支付的过程中
发生了什么

00:10:28.896 --> 00:10:30.631 align:middle
在实际应用中支付队列十分重要

00:10:31.832 --> 00:10:33.467 align:middle
在这里我们需要加入一些代码

00:10:33.534 --> 00:10:37.871 align:middle
当你启动应用时
用来监听和观察支付队列

00:10:38.405 --> 00:10:41.074 align:middle
我们可以在这儿的例子中添加代码

00:10:41.141 --> 00:10:43.010 align:middle
我们的didFinishLaunchingWithOptions函数

00:10:43.076 --> 00:10:46.280 align:middle
在我们启动应用的时候会最先被执行

00:10:46.647 --> 00:10:49.650 align:middle
我们用它创建监听支付交易的观察者

00:10:49.716 --> 00:10:51.585 align:middle
在这个例子中它是应用代理本身

00:10:51.752 --> 00:10:54.821 align:middle
我们把它设置到了支付队列上
并且把它加入到支付队列

00:10:55.088 --> 00:10:58.625 align:middle
如果支付队列有事情发生

00:10:58.692 --> 00:11:00.861 align:middle
在我们启动应用前已经发生

00:10:58.692 --> 00:11:00.861 align:middle
在我们启动应用前已经发生

00:11:00.928 --> 00:11:02.729 align:middle
我们将立即收到交易的通知

00:11:03.397 --> 00:11:07.401 align:middle
另一种被提及的是

00:11:07.467 --> 00:11:10.737 align:middle
在In-App Purchase时
使用兑换码

00:11:10.971 --> 00:11:13.373 align:middle
用户进入到App Store

00:11:13.440 --> 00:11:17.311 align:middle
并且在你应用的外部使用兑换码完成了
In-App Purchase

00:11:17.544 --> 00:11:20.681 align:middle
用户乐于使用In-App
Purchase进行消费

00:11:20.981 --> 00:11:22.749 align:middle
然后进入到你的应用中

00:11:22.816 --> 00:11:25.052 align:middle
如果你没有监听支付队列

00:11:25.118 --> 00:11:26.954 align:middle
产品将不可用

00:11:27.588 --> 00:11:29.690 align:middle
在应用启动的时候你需要监听支付队列

00:11:32.025 --> 00:11:33.827 align:middle
以上是关于支付队列的简记

00:11:34.394 --> 00:11:36.230 align:middle
让我们回到实现流程上来

00:11:36.296 --> 00:11:39.233 align:middle
准确理解如何添加支付队列
到你的应用中

00:11:41.001 --> 00:11:44.505 align:middle
首先要做的是加载标识符

00:11:44.571 --> 00:11:46.173 align:middle
为In-App Purchase

00:11:46.807 --> 00:11:50.711 align:middle
进行iTunes Connect时
会有相同的标识符

00:11:50.944 --> 00:11:52.980 align:middle
你需要定义这些标识符
对他们进行命名

00:11:53.280 --> 00:11:54.915 align:middle
开发应用时要获取标识符的列表

00:11:55.282 --> 00:11:56.517 align:middle
有不同的方法来获取它们

00:11:56.583 --> 00:11:57.951 align:middle
如果你的应用十分简单

00:11:58.385 --> 00:12:01.588 align:middle
你或许仅仅需要将这些标识符
复制到你的应用中

00:11:58.385 --> 00:12:01.588 align:middle
你或许仅仅需要将这些标识符
复制到你的应用中

00:12:01.655 --> 00:12:06.126 align:middle
如果你的应用有基础版本和高级版本

00:12:06.193 --> 00:12:08.061 align:middle
你有可能仅仅有一个可消费的版本

00:12:08.128 --> 00:12:10.364 align:middle
你仅仅需要复制标识符到你的应用中

00:12:10.631 --> 00:12:13.800 align:middle
然而 我们看到许多应用并没那样做

00:12:14.067 --> 00:12:15.903 align:middle
它们倾向于在外部

00:12:15.969 --> 00:12:19.506 align:middle
并且从他们提供的主机上
获取应用内标识符

00:12:19.573 --> 00:12:23.410 align:middle
以便应用过期后
它们可以改变应用的可用性

00:12:24.378 --> 00:12:26.547 align:middle
或者准确地说
可以改变呈现给用户的内容

00:12:27.414 --> 00:12:29.616 align:middle
它们这样做是没问题的
完全是符合规定的

00:12:30.150 --> 00:12:32.519 align:middle
我们想要说明的是如果你这样做

00:12:32.586 --> 00:12:36.123 align:middle
请确保你的主机具有
稳定性和较高的可伸缩性

00:12:36.190 --> 00:12:39.326 align:middle
是In-App Purchase
流程的开始

00:12:39.560 --> 00:12:42.296 align:middle
最坏的事情是展示给用户的价格
需要进行微调

00:12:42.362 --> 00:12:43.964 align:middle
当用户正在等待购买的时候

00:12:44.498 --> 00:12:48.936 align:middle
这应该是可能发生的
假如你能提前抓取信息 那是极好的

00:12:49.436 --> 00:12:51.805 align:middle
如果你能在设备上缓存
这些信息那就更好了

00:12:51.872 --> 00:12:56.076 align:middle
你要清楚的知道如何进行抓取
和保存这些标识信息

00:12:57.845 --> 00:12:59.713 align:middle
即然你已经有了这些标识信息

00:12:59.780 --> 00:13:03.951 align:middle
你需要去App Store
来抓取产品本地化的信息

00:12:59.780 --> 00:13:03.951 align:middle
你需要去App Store
来抓取产品本地化的信息

00:13:04.017 --> 00:13:05.686 align:middle
同产品密切相关的信息

00:13:06.954 --> 00:13:09.590 align:middle
你可使用SK产品请求来完成这些操作

00:13:09.890 --> 00:13:12.426 align:middle
这样你就可以拿到你感兴趣的标识符

00:13:12.893 --> 00:13:15.195 align:middle
为了获得更流畅的用户体验

00:13:15.262 --> 00:13:16.597 align:middle
你需要提前抓取这些标识符

00:13:16.663 --> 00:13:19.366 align:middle
你想要知道当用户有可能感兴趣

00:13:19.433 --> 00:13:21.468 align:middle
在看到你的
In-App Purchase时

00:13:21.535 --> 00:13:24.438 align:middle
你能在第一时间获得这些信息

00:13:26.073 --> 00:13:28.876 align:middle
你首先要做的是创建你的SK产品请求

00:13:28.942 --> 00:13:31.178 align:middle
你传递你感兴趣的标识符

00:13:32.179 --> 00:13:33.080 align:middle
你需要设置你的代理

00:13:33.146 --> 00:13:35.415 align:middle
它将给你的应用返回信息

00:13:35.482 --> 00:13:38.185 align:middle
当这些产品被加载的时候

00:13:39.586 --> 00:13:41.588 align:middle
你仅仅是需要调用开始
那是如此的简单

00:13:44.858 --> 00:13:47.294 align:middle
代理看起来像上面那个样子

00:13:47.694 --> 00:13:50.030 align:middle
我们有产品请求
didReceive函数会响应

00:13:50.097 --> 00:13:53.867 align:middle
它将传递给你从App Store上
下载的所有产品

00:13:54.201 --> 00:13:56.236 align:middle
每一个产品将会保留这些信息

00:13:56.303 --> 00:13:58.739 align:middle
像本地化的标题和描述

00:13:58.972 --> 00:14:01.375 align:middle
像我之前所说的App Store
是面向全球的应用市场

00:13:58.972 --> 00:14:01.375 align:middle
像我之前所说的App Store
是面向全球的应用市场

00:14:01.441 --> 00:14:04.645 align:middle
你是向全世界发布
In-App Purchase

00:14:05.045 --> 00:14:06.146 align:middle
最好确保

00:14:06.213 --> 00:14:09.349 align:middle
你正在使用本地化的信息

00:14:09.583 --> 00:14:11.151 align:middle
来进行你的交易

00:14:11.251 --> 00:14:13.353 align:middle
比如本地化的标题和描述

00:14:14.555 --> 00:14:17.858 align:middle
甚至更重要的是价格和的价格本地化

00:14:18.025 --> 00:14:20.861 align:middle
你想提供给用户
In-App Purchase价格

00:14:20.928 --> 00:14:24.665 align:middle
你需要确保呈现给用户的格式
是他们能理解的

00:14:24.932 --> 00:14:29.236 align:middle
在全世界流通的货币
呈现的方式是不同的

00:14:29.837 --> 00:14:33.640 align:middle
你要知道正确展示价格的重要

00:14:34.074 --> 00:14:35.776 align:middle
我们将会讲到这些

00:14:37.044 --> 00:14:40.681 align:middle
最后你拿到你的
In-App Purchase内容

00:14:40.747 --> 00:14:43.317 align:middle
启动iTunes Connect时
这些事会发生

00:14:43.383 --> 00:14:47.221 align:middle
我们会给出下载时长的信息

00:14:47.287 --> 00:14:50.157 align:middle
和购买相关的版本信息

00:14:50.557 --> 00:14:52.426 align:middle
就像我提到的定价
该信息也很重要

00:14:52.492 --> 00:14:58.599 align:middle
当你呈现这些价格的字符时
要做出正确的选择

00:14:58.932 --> 00:15:02.569 align:middle
当你呈现这些价格的时候
你想要使用换算到本地的价格

00:14:58.932 --> 00:15:02.569 align:middle
当你呈现这些价格的时候
你想要使用换算到本地的价格

00:15:02.636 --> 00:15:05.105 align:middle
将它转换到NS的数字格式

00:15:05.639 --> 00:15:08.609 align:middle
你将获得关于定价的相关信息

00:15:08.842 --> 00:15:12.079 align:middle
那个NS的数字格式
将会带有价格的信息

00:15:12.145 --> 00:15:13.814 align:middle
对它进行本地化操作

00:15:13.881 --> 00:15:16.550 align:middle
假如你对它设置了货币格式
你可以确信

00:15:16.617 --> 00:15:18.919 align:middle
你获取的价格信息是正确的

00:15:19.152 --> 00:15:20.320 align:middle
你要做的另外一件事情是

00:15:20.387 --> 00:15:24.358 align:middle
不要在进行货币转换的时候
进行无关的排序

00:15:24.424 --> 00:15:28.896 align:middle
App Store知道如何进行本地化
对货币进行转换

00:15:29.162 --> 00:15:31.131 align:middle
所以不要做任何其他无关的操作

00:15:31.431 --> 00:15:34.701 align:middle
只要把定价原本的样子
用NS数字格式呈现出来

00:15:35.269 --> 00:15:37.971 align:middle
下一步就是呈现你的UI

00:15:38.172 --> 00:15:40.040 align:middle
接着将不会过多谈论产品的本地化了

00:15:40.107 --> 00:15:42.342 align:middle
你的产品你做主

00:15:42.409 --> 00:15:47.748 align:middle
你知道如何呈现你的UI
使你的应用尽可能获得更高的销量

00:15:48.749 --> 00:15:51.285 align:middle
然而 一旦购买完毕

00:15:52.352 --> 00:15:55.956 align:middle
或者一旦UI被显示 我们将立即跳转

00:15:56.023 --> 00:15:57.624 align:middle
自动完成购买

00:15:57.958 --> 00:16:02.296 align:middle
添加并且创建SK支付对象
完成上面的操作

00:15:57.958 --> 00:16:02.296 align:middle
添加并且创建SK支付对象
完成上面的操作

00:16:02.362 --> 00:16:03.964 align:middle
并且把它加入到支付队列当中

00:16:04.765 --> 00:16:08.268 align:middle
一旦你创建了SK支付对象
并且添加到支付队列当中

00:16:09.069 --> 00:16:12.906 align:middle
随着支付的进行你将会获得一个回调

00:16:12.973 --> 00:16:14.608 align:middle
通过它更新交易

00:16:14.675 --> 00:16:17.878 align:middle
这就是你刚刚添加的
支付队列的观察者回调

00:16:17.945 --> 00:16:19.313 align:middle
当应用开始调用的时候

00:16:19.713 --> 00:16:21.748 align:middle
你创建了支付队列的观察者

00:16:21.815 --> 00:16:24.284 align:middle
观察者会调用支付队列的
函数来更新交易

00:16:24.351 --> 00:16:27.588 align:middle
在支付进行的过程中
你将获得关于支付的消息

00:16:27.654 --> 00:16:30.624 align:middle
你需要做的就是创建你的SK支付对象

00:16:31.291 --> 00:16:32.793 align:middle
将创建的对象添加到支付队列当中

00:16:32.993 --> 00:16:34.962 align:middle
消息开始陆续到来

00:16:35.729 --> 00:16:38.866 align:middle
你将会获得关于整个交易过程的信息

00:16:38.932 --> 00:16:40.801 align:middle
你可能有一条消息
也许有许多条消息

00:16:41.635 --> 00:16:43.837 align:middle
你需要遍历这些交易

00:16:44.171 --> 00:16:47.841 align:middle
并且监听每笔交易的状态变化

00:16:47.908 --> 00:16:48.876 align:middle
有许多不同的状态

00:16:48.942 --> 00:16:51.879 align:middle
它们之中你最感兴趣的是购买的状态

00:16:51.945 --> 00:16:54.915 align:middle
从那儿你可以知道购买完成了

00:16:54.982 --> 00:16:57.484 align:middle
继续去激活购买

00:16:57.551 --> 00:17:01.054 align:middle
我们将获得一小部分数据
使得应用的内容是可用的

00:16:57.551 --> 00:17:01.054 align:middle
我们将获得一小部分数据
使得应用的内容是可用的

00:17:01.889 --> 00:17:04.790 align:middle
然而 我想说还有另外一种状态

00:17:04.858 --> 00:17:07.261 align:middle
那就是延迟交易的状态

00:17:07.928 --> 00:17:14.233 align:middle
延迟是在iOS 8中为了购买前
询问特性添加进来的

00:17:14.568 --> 00:17:16.803 align:middle
这是为了让家人共享iCloud

00:17:16.869 --> 00:17:21.441 align:middle
家里的孩子可以去进行购买
例如In-App Purchase

00:17:21.508 --> 00:17:24.310 align:middle
孩子们的父母 监护人 担保人

00:17:24.377 --> 00:17:27.814 align:middle
可以决定儿童可不可进行购买

00:17:27.881 --> 00:17:31.752 align:middle
延迟的状态是你在登录状态进行
In-App Purchase时

00:17:32.419 --> 00:17:36.790 align:middle
延迟状态需要获得来自父母的许可

00:17:37.391 --> 00:17:40.994 align:middle
我们看到许多这种情况
并且想要将它解释清楚

00:17:41.061 --> 00:17:44.831 align:middle
如果是在延迟状态你不能阻塞你的UI

00:17:44.898 --> 00:17:47.301 align:middle
你应当以某种方式对它进行处理...

00:17:48.902 --> 00:17:50.737 align:middle
也许购买最后没有发生

00:17:50.804 --> 00:17:54.241 align:middle
允许孩子们尝试用你的应用进行购买

00:17:54.541 --> 00:17:58.212 align:middle
让孩子们返回并且继续可以使用游戏

00:17:58.278 --> 00:18:00.113 align:middle
或者是他们感兴趣的任何内容

00:17:58.278 --> 00:18:00.113 align:middle
或者是他们感兴趣的任何内容

00:18:00.180 --> 00:18:02.049 align:middle
因为延迟购买会持续一小时或几天

00:18:02.115 --> 00:18:05.018 align:middle
在他们父母审阅和同意这次购买前

00:18:05.085 --> 00:18:07.754 align:middle
不要微调 不要弹窗

00:18:08.155 --> 00:18:11.491 align:middle
仅仅是像购买从来没有发生过一样

00:18:11.558 --> 00:18:13.160 align:middle
就像你知道还没开始一样

00:18:15.596 --> 00:18:18.498 align:middle
一件我也想做的非常重要事情是

00:18:18.565 --> 00:18:21.668 align:middle
当你进行In-App Purchase时测试你的应用

00:18:21.735 --> 00:18:24.538 align:middle
就像测试你应用的其他功能一样

00:18:25.072 --> 00:18:27.708 align:middle
通过iTunes store
可以实现上面的操作

00:18:27.774 --> 00:18:29.109 align:middle
沙盒环境

00:18:29.176 --> 00:18:30.911 align:middle
沙盒环境是一个特殊的环境

00:18:31.245 --> 00:18:35.349 align:middle
假如你运行的是有开发者签名的应用

00:18:35.415 --> 00:18:39.086 align:middle
你进行的所有购买都会进入沙盒环境

00:18:41.889 --> 00:18:46.627 align:middle
然而 假如你对延迟交易的测试感兴趣

00:18:46.693 --> 00:18:49.463 align:middle
没有比创建一个家庭账户更好的方法

00:18:49.530 --> 00:18:51.999 align:middle
这样你就能在沙盒环境下
测试延迟交易了

00:18:52.466 --> 00:18:55.869 align:middle
假如你想在沙盒环境中
测试你的延迟交易

00:18:55.936 --> 00:19:00.073 align:middle
你可以使用SimulatesAskToBuyInSandbox

00:18:55.936 --> 00:19:00.073 align:middle
你可以使用SimulatesAskToBuyInSandbox

00:19:00.140 --> 00:19:04.211 align:middle
你可以在你的SKMutable
支付对象中创建它

00:19:04.578 --> 00:19:06.079 align:middle
你传递给你的产品

00:19:06.146 --> 00:19:10.017 align:middle
然后你设置SimulatesAskToBuySandBox标记

00:19:10.083 --> 00:19:12.920 align:middle
这个标记会告诉
App Store 嘿

00:19:13.153 --> 00:19:17.324 align:middle
对待这次购买就像家里
有小朋友在进行购买

00:19:17.958 --> 00:19:20.761 align:middle
一旦你将它加入到支付队列
就会被发送到App Store

00:19:20.827 --> 00:19:25.199 align:middle
然后App Store将会在
你的应用中返回给你延迟的状态

00:19:25.265 --> 00:19:29.536 align:middle
这种方法可以让你知道
你的应用可以在儿童购买时正常工作

00:19:31.638 --> 00:19:34.274 align:middle
我们同样需要谈论一下关于错误的处理

00:19:35.142 --> 00:19:36.410 align:middle
不是每件事情都正常执行

00:19:36.476 --> 00:19:38.912 align:middle
在你的应用中也会出现错误的状态

00:19:39.546 --> 00:19:41.448 align:middle
尤其是在
In-App Purchase时

00:19:42.182 --> 00:19:45.886 align:middle
你需要牢记的是
不同的错误需要不同对待

00:19:46.353 --> 00:19:50.524 align:middle
我强烈建议你翻阅In-App
Purchase编程指南

00:19:50.591 --> 00:19:53.327 align:middle
或者StoreKit框架参考指南

00:19:53.393 --> 00:19:55.929 align:middle
来更好的理解使用中出现的错误

00:19:55.996 --> 00:19:58.398 align:middle
随着程序的运行会有相应的返回

00:20:00.033 --> 00:20:03.103 align:middle
需要记住的是

00:20:03.170 --> 00:20:07.808 align:middle
大多数错误是不需要你去通知用户的

00:20:07.875 --> 00:20:10.444 align:middle
许多错误是我们通知开发者的

00:20:10.644 --> 00:20:12.212 align:middle
让开发者在应用中进行处理

00:20:12.713 --> 00:20:15.349 align:middle
我有过类似的经历

00:20:15.415 --> 00:20:17.518 align:middle
我在使用开发者开发的应用
我随意浏览着

00:20:17.584 --> 00:20:19.119 align:middle
我在进行网上购物

00:20:19.353 --> 00:20:20.554 align:middle
我点击了购买

00:20:20.988 --> 00:20:24.491 align:middle
确认了价格紧接着
StoreKit的窗口就出现了

00:20:24.558 --> 00:20:27.528 align:middle
然后我又改变主意了
我想返回看看其他东西

00:20:27.728 --> 00:20:28.795 align:middle
我选择了取消

00:20:29.329 --> 00:20:30.631 align:middle
可是取消发生错误

00:20:30.697 --> 00:20:34.501 align:middle
取消错误确实在你的应用中发生了

00:20:34.835 --> 00:20:38.605 align:middle
没有必要将取消错误的警告展示给用户

00:20:38.972 --> 00:20:41.175 align:middle
我们有时会在应用中看到这些错误

00:20:41.241 --> 00:20:42.776 align:middle
用户知道他们进行了取消操作

00:20:43.143 --> 00:20:45.312 align:middle
没有必要重复展示给他们

00:20:47.414 --> 00:20:50.350 align:middle
尽可能让StoreKit
处理交易流程

00:20:50.417 --> 00:20:52.019 align:middle
再次强调我们将要谈论支付队列

00:20:52.085 --> 00:20:55.889 align:middle
支付将会在支付队列中进行处理

00:20:56.190 --> 00:21:00.994 align:middle
App Store和StoreKit
会要求用户进行购买确认

00:20:56.190 --> 00:21:00.994 align:middle
App Store和StoreKit
会要求用户进行购买确认

00:21:01.228 --> 00:21:02.429 align:middle
他们将会给出一个价格

00:21:02.896 --> 00:21:05.199 align:middle
这个价格需要同你应用内价格进行匹配

00:21:05.265 --> 00:21:06.400 align:middle
这就是为什么确认本地的价格信息正确

00:21:06.466 --> 00:21:09.336 align:middle
是如此重要

00:21:09.670 --> 00:21:11.004 align:middle
我们会对用户进行认证

00:21:11.271 --> 00:21:13.307 align:middle
如果账单信息有任何问题

00:21:13.373 --> 00:21:14.441 align:middle
我们需处理账单问题

00:21:14.908 --> 00:21:18.745 align:middle
弹出确认框或者
做其他的特殊操作都是不必要的

00:21:18.812 --> 00:21:21.081 align:middle
让StoreKit为你处理这些问题

00:21:23.383 --> 00:21:25.719 align:middle
我们谈论了进入交易队列前的一小部分

00:21:25.786 --> 00:21:29.289 align:middle
我们谈论了支付返回的一些状态

00:21:30.224 --> 00:21:33.126 align:middle
一旦你的支付变成了购买的的状态

00:21:33.193 --> 00:21:36.330 align:middle
你需要在你的应用中做出多种选择

00:21:38.699 --> 00:21:42.769 align:middle
特别的 你需要验证购买的时候

00:21:42.836 --> 00:21:45.072 align:middle
可以使用现金进行交易

00:21:46.540 --> 00:21:49.042 align:middle
我们有好几种方法来完成这些购买操作

00:21:49.276 --> 00:21:52.346 align:middle
但是再次强调 你的应用
你的产品 你做主

00:21:52.579 --> 00:21:57.150 align:middle
你要特别注意你使用什么技术

00:21:57.217 --> 00:22:02.856 align:middle
你用何种安全级别验证购买的合法性

00:21:57.217 --> 00:22:02.856 align:middle
你用何种安全级别验证购买的合法性

00:22:06.193 --> 00:22:10.497 align:middle
回执的验证 回执会返回给应用

00:22:10.564 --> 00:22:11.865 align:middle
在购买的最后环节

00:22:11.932 --> 00:22:16.570 align:middle
回执就像消费者拿到的账单

00:22:16.637 --> 00:22:20.240 align:middle
当你在商场进行购物或者类似的事情

00:22:20.440 --> 00:22:24.011 align:middle
回执包含购买的所有信息

00:22:24.077 --> 00:22:25.879 align:middle
还有购买的
In-App Purchase

00:22:26.313 --> 00:22:28.315 align:middle
有两种主要的方法

00:22:28.382 --> 00:22:30.684 align:middle
你可以进行回执的校验

00:22:31.151 --> 00:22:33.520 align:middle
首先是在设备自身上验证

00:22:34.988 --> 00:22:36.490 align:middle
接下来是回执

00:22:36.557 --> 00:22:39.693 align:middle
你可以编写代码
将它在设备上分为几部分

00:22:39.760 --> 00:22:43.797 align:middle
授权来自Apple的回执

00:22:43.864 --> 00:22:47.134 align:middle
确认回执的现金来源是有效的

00:22:48.001 --> 00:22:53.073 align:middle
做这些是为了解锁应用中的一些特性

00:22:53.140 --> 00:22:54.708 align:middle
和内容

00:22:54.775 --> 00:22:57.044 align:middle
这是你必须选择的

00:22:57.110 --> 00:23:01.381 align:middle
这些购买完全只能在客户端进行吗？

00:22:57.110 --> 00:23:01.381 align:middle
这些购买完全只能在客户端进行吗？

00:23:01.915 --> 00:23:04.418 align:middle
或者说如果你有服务端

00:23:04.952 --> 00:23:07.821 align:middle
你想在服务端做回执的验证

00:23:07.888 --> 00:23:11.692 align:middle
因为你想让服务器为
你的内容和服务提供网关服务

00:23:11.925 --> 00:23:15.863 align:middle
为了完成上面的事情
你需要将发送到设备的回执

00:23:15.929 --> 00:23:19.266 align:middle
上传到你的服务器

00:23:19.333 --> 00:23:21.768 align:middle
然后让服务器发送回执
到App Store

00:23:21.835 --> 00:23:25.105 align:middle
有后台的API可以对回执进行验证

00:23:26.039 --> 00:23:28.308 align:middle
这可以做到从服务器到服务器

00:23:29.643 --> 00:23:33.981 align:middle
需要注意的一点是
App Store有后台API

00:23:34.047 --> 00:23:36.416 align:middle
可以接受和验证回执

00:23:36.483 --> 00:23:41.855 align:middle
但是你不能通过你的设备直接发送回执

00:23:42.022 --> 00:23:46.693 align:middle
那样做是不安全的

00:23:46.760 --> 00:23:50.631 align:middle
如何保证来自你应用的回执是可信的

00:23:50.998 --> 00:23:54.968 align:middle
如果你想验证回执的有效性

00:23:55.035 --> 00:23:57.304 align:middle
回执应当通过你的服务器

00:23:57.604 --> 00:23:59.273 align:middle
传递到App Store的后台

00:24:01.909 --> 00:24:04.711 align:middle
让我们来深入了解下回执是什么

00:24:05.612 --> 00:24:09.917 align:middle
回执是你在进行In-App
Purchase时得到的可信记录

00:24:10.517 --> 00:24:13.787 align:middle
它包含的信息允许你知道

00:24:13.854 --> 00:24:17.257 align:middle
在这个设备上用户已经购买了应用

00:24:17.591 --> 00:24:21.195 align:middle
对开发者而言
是用户在他们的设备上进行了购买

00:24:22.029 --> 00:24:23.430 align:middle
回执存储在设备上

00:24:23.497 --> 00:24:26.934 align:middle
你应用本身的容器中

00:24:28.068 --> 00:24:30.838 align:middle
回执由App Store签发
并且包含一些信息

00:24:30.904 --> 00:24:35.042 align:middle
允许你验证来自
App Store的回执信息

00:24:36.210 --> 00:24:39.379 align:middle
这只是针对你的应用和设备来说

00:24:39.646 --> 00:24:42.349 align:middle
如果你的应用在不同的设备上运行

00:24:42.416 --> 00:24:45.686 align:middle
对于不同的用户得到的回执也是不同的

00:24:47.955 --> 00:24:51.525 align:middle
这样做是为让你知道回执大体的样子

00:24:52.426 --> 00:24:55.929 align:middle
存储在App Bundle中

00:24:56.363 --> 00:24:57.764 align:middle
我们提供应用程序接口
允许你能获得这些信息

00:24:57.831 --> 00:24:59.833 align:middle
过一会儿我们将看到它大体的样子

00:25:00.901 --> 00:25:02.302 align:middle
它是单个文件

00:25:03.270 --> 00:25:05.272 align:middle
很早很早以前回执的版本

00:25:05.339 --> 00:25:07.941 align:middle
以前每一个In-App
Purchase通常会有多个文件

00:25:08.008 --> 00:25:10.911 align:middle
但是自从iOS 7开始
我们有了统一的回执

00:25:10.978 --> 00:25:13.580 align:middle
在一个文件中包含了所有的信息

00:25:14.147 --> 00:25:17.851 align:middle
它里边也包含了证书和签名信息

00:25:17.918 --> 00:25:20.954 align:middle
允许你通过这些信息验证回执

00:25:22.923 --> 00:25:27.094 align:middle
我们通过使用公钥密码标准

00:25:27.160 --> 00:25:28.462 align:middle
7容器来完成上面的操作

00:25:28.662 --> 00:25:31.932 align:middle
容器里边包含了所有信息

00:25:31.999 --> 00:25:33.734 align:middle
容器使用的是开放的标准

00:25:33.800 --> 00:25:36.637 align:middle
你有许多可以参考的信息

00:25:36.703 --> 00:25:40.374 align:middle
关于如何使用PKCS7标准容器

00:25:41.742 --> 00:25:43.610 align:middle
容器进行加载

00:25:43.844 --> 00:25:46.380 align:middle
里面包含有用的信息

00:25:46.446 --> 00:25:48.048 align:middle
是需要你去解析的

00:25:48.248 --> 00:25:53.120 align:middle
里面的编码是ASN1格式的
也是公开的标准

00:25:55.022 --> 00:25:58.792 align:middle
有很多不错的标准
可以选择用来做回执的验证

00:25:58.859 --> 00:26:01.028 align:middle
OpenSSL就是其中的一个

00:25:58.859 --> 00:26:01.028 align:middle
OpenSSL就是其中的一个

00:26:01.662 --> 00:26:03.430 align:middle
有时开发者会创建他们自己的标准

00:26:04.231 --> 00:26:06.099 align:middle
在这儿我要强调的是

00:26:06.166 --> 00:26:08.802 align:middle
这是你的应用 这是你的钱

00:26:09.303 --> 00:26:10.404 align:middle
这是你的生意

00:26:10.704 --> 00:26:13.841 align:middle
如何更好的验证回执依赖你做出的选择

00:26:13.907 --> 00:26:16.143 align:middle
你要使用什么技术

00:26:19.179 --> 00:26:22.349 align:middle
然而 不论你选择什么
都会有相似的处理过程

00:26:22.416 --> 00:26:23.750 align:middle
你在支付过程中会经历的

00:26:24.318 --> 00:26:27.754 align:middle
首先 你需要在你的应用中定位回执

00:26:27.821 --> 00:26:29.690 align:middle
使用NS bundle API

00:26:30.424 --> 00:26:32.759 align:middle
上面就是它在Swift中的样子

00:26:32.826 --> 00:26:35.696 align:middle
你可通过NS Bundle进行调用

00:26:35.996 --> 00:26:39.233 align:middle
App Store回执的URL
会通过上面的函数回传

00:26:39.299 --> 00:26:42.236 align:middle
它是本地的URL 在本地的文件系统

00:26:42.803 --> 00:26:45.472 align:middle
一旦你有了URL
你需要把它放入NS数据中

00:26:45.539 --> 00:26:48.375 align:middle
你可以获得二进制形式的回执

00:26:50.844 --> 00:26:54.248 align:middle
需要注意
你现在已经加载了二进制文件

00:26:55.082 --> 00:26:58.318 align:middle
证书会有过期时间

00:26:58.385 --> 00:26:59.686 align:middle
你必须十分小心

00:26:59.753 --> 00:27:01.455 align:middle
在核对过期日期的时候

00:26:59.753 --> 00:27:01.455 align:middle
在核对过期日期的时候

00:27:02.456 --> 00:27:05.158 align:middle
只是因为它是发行在一定时间内

00:27:05.559 --> 00:27:09.429 align:middle
并不意味着那个有效期是有效的

00:27:09.496 --> 00:27:10.964 align:middle
在未来所有时间里

00:27:11.899 --> 00:27:13.667 align:middle
所以如果你正检查有效期

00:27:13.734 --> 00:27:18.939 align:middle
比较App Store发行
receipt时间

00:27:19.006 --> 00:27:20.941 align:middle
而不是当前日期

00:27:21.275 --> 00:27:24.778 align:middle
它不像SSL握手 你每次都想检查它

00:27:25.112 --> 00:27:28.715 align:middle
只有被发行时 它才是唯一有效的

00:27:28.782 --> 00:27:31.652 align:middle
或者只有被发行时
这才是唯一有效的检查日期

00:27:32.152 --> 00:27:34.655 align:middle
或者它是完全有效的根本
不用检查日期

00:27:35.022 --> 00:27:37.391 align:middle
但是你要做的是检查

00:27:37.457 --> 00:27:40.494 align:middle
receipt上的根证书颁布机构

00:27:41.128 --> 00:27:44.097 align:middle
这将验证它来自Apple

00:27:44.164 --> 00:27:46.934 align:middle
你可以相信它 因为它是
Apple的receipt

00:27:47.701 --> 00:27:49.102 align:middle
所以检查到根

00:27:52.606 --> 00:27:54.508 align:middle line:1
所以再次，这只是一种给你一个想法

00:27:54.575 --> 00:27:56.543 align:middle line:1
关于receipt内部的情况

00:27:57.244 --> 00:28:00.647 align:middle line:1
它的有效负荷 我所说的ASN1格式

00:27:57.244 --> 00:28:00.647 align:middle line:1
它的有效负荷 我所说的ASN1格式

00:28:00.714 --> 00:28:01.982 align:middle line:1
是一系列的属性

00:28:02.049 --> 00:28:04.284 align:middle
你可以把它当做一本NS字典

00:28:05.185 --> 00:28:06.753 align:middle
它包含类型和值

00:28:07.087 --> 00:28:09.690 align:middle
还有我们将要标记一些这
些类型和值

00:28:09.756 --> 00:28:12.492 align:middle
那里还有比我们今天讨论的更多

00:28:12.559 --> 00:28:14.094 align:middle
你可以在线得到很多

00:28:14.161 --> 00:28:16.930 align:middle
通过我们的receipt
验证编程指南

00:28:17.664 --> 00:28:20.968 align:middle
但是一些你主要想使用的是

00:28:21.869 --> 00:28:25.706 align:middle
类型2和类型3 包括捆绑标识符

00:28:25.772 --> 00:28:28.775 align:middle
和receipt的捆绑版本

00:28:29.810 --> 00:28:32.980 align:middle
希望这和你的应用程序中的匹配
并且你应该检查它

00:28:33.914 --> 00:28:37.551 align:middle
所以你应该检查捆绑标识符
和捆绑版本

00:28:37.618 --> 00:28:39.620 align:middle
然后要记住的一件事是

00:28:39.686 --> 00:28:44.224 align:middle
你应该在你的APP的二进制文件中
使用硬编码值

00:28:44.725 --> 00:28:48.295 align:middle
这是一个更容易让我进去并
改变信息列表P

00:28:48.662 --> 00:28:51.598 align:middle
如果那个是你正在使用去
匹配的假receipt

00:28:51.665 --> 00:28:56.403 align:middle
相对于我同改变你程序有
效负荷去匹配receipt

00:28:56.503 --> 00:28:59.139 align:middle
所以如果你真的想去确认
那个receipt是

00:28:59.206 --> 00:29:02.376 align:middle
为你的程序的 使用硬编码值

00:28:59.206 --> 00:29:02.376 align:middle
为你的程序的 使用硬编码值

00:29:04.811 --> 00:29:07.247 align:middle
你现知道这receipt是
为你的应用程序的

00:29:07.314 --> 00:29:09.049 align:middle
你想去确认它是为

00:29:09.116 --> 00:29:11.185 align:middle
那些正在运行receipt的设备

00:29:11.652 --> 00:29:12.920 align:middle
这是一个小的技巧

00:29:12.986 --> 00:29:17.658 align:middle
你要去做的是看一下SHA-1哈希

00:29:17.724 --> 00:29:19.626 align:middle
它是在类型5中返回的

00:29:20.460 --> 00:29:22.496 align:middle
类型5包括这个哈希

00:29:22.729 --> 00:29:26.333 align:middle
哈希是有信息片段组成

00:29:26.400 --> 00:29:28.735 align:middle
是App Store在购买时获取的

00:29:28.969 --> 00:29:32.406 align:middle
是你在验证时获取的信息片段

00:29:33.106 --> 00:29:35.209 align:middle
特别是捆绑的标识

00:29:36.076 --> 00:29:38.412 align:middle
所以你想在你的应用中保留硬编码值

00:29:38.478 --> 00:29:39.680 align:middle
你的APP绑定标识

00:29:40.214 --> 00:29:41.682 align:middle
设备标识

00:29:42.049 --> 00:29:43.617 align:middle
这是一个或多个API用于那个

00:29:43.684 --> 00:29:46.753 align:middle
它是在iOS和macOS有些不同

00:29:46.820 --> 00:29:49.423 align:middle
但是你要加载这个设备的标识符

00:29:49.957 --> 00:29:51.692 align:middle
然后这个不透明的值

00:29:51.758 --> 00:29:55.762 align:middle
这个不透明的值是基本上
一点加密熵

00:29:55.829 --> 00:29:58.398 align:middle
它是一个包含在
回执里的加密盐值

00:29:58.465 --> 00:30:01.969 align:middle
它允许哈希随着时间推移
而改变即使如果绑定标识

00:29:58.465 --> 00:30:01.969 align:middle
它允许哈希随着时间推移
而改变即使如果绑定标识

00:30:02.035 --> 00:30:04.137 align:middle
和设备标识不改变

00:30:04.204 --> 00:30:07.207 align:middle
你应该基本上获取这个在
receipt里的不透明值

00:30:07.274 --> 00:30:08.942 align:middle
把它包括在你的哈希里

00:30:09.543 --> 00:30:14.214 align:middle
一旦你拥有了它 SHA-1哈希
对比它同属性5

00:30:14.281 --> 00:30:17.184 align:middle
如果匹配 你知道它是你的设备

00:30:19.887 --> 00:30:22.956 align:middle
对于你的在设备上的APP
是唯一的

00:30:26.293 --> 00:30:31.265 align:middle
receipt还包括你的所有
in-app purchases信息

00:30:31.532 --> 00:30:37.237 align:middle
所以我们这里所看到的是全部
远不止类型17

00:30:37.304 --> 00:30:42.409 align:middle
类型17是为了用户用你的
应用程序所做的每次购买

00:30:42.476 --> 00:30:45.779 align:middle
它包括一条关于
in-app purchase的记录

00:30:46.346 --> 00:30:48.248 align:middle
类型17的有效载荷

00:30:49.116 --> 00:30:53.820 align:middle
不是一个字符串 它实际上是
另外一个ASN1文档

00:30:54.488 --> 00:30:56.957 align:middle
它拥有自己的值

00:30:58.292 --> 00:30:59.560 align:middle
所以这些看起来像什么

00:30:59.626 --> 00:31:03.697 align:middle
好吧 1701 这是购买的数量

00:30:59.626 --> 00:31:03.697 align:middle
好吧 1701 这是购买的数量

00:31:03.764 --> 00:31:05.866 align:middle
所以我们以前讨论过消费品

00:31:06.800 --> 00:31:11.538 align:middle
用户能有购买10包硬币在
你的游戏里

00:31:11.605 --> 00:31:12.906 align:middle
或者100包硬币

00:31:13.173 --> 00:31:17.544 align:middle
这将是数量 购买的数量

00:31:17.611 --> 00:31:19.913 align:middle
这是针对特定的标识符

00:31:21.081 --> 00:31:23.350 align:middle
这个产品标识符，我们以前讨论过

00:31:23.417 --> 00:31:25.385 align:middle
这个是那个标识符你用来

00:31:25.452 --> 00:31:30.190 align:middle
从App Store加载你的
in-app purchase数据

00:31:30.257 --> 00:31:32.559 align:middle
如你在iTunes Connect
设置的样子

00:31:33.894 --> 00:31:36.463 align:middle
标识符 这是一个交易标识符

00:31:36.530 --> 00:31:38.699 align:middle
这是一个对于交易的唯一标识符

00:31:38.765 --> 00:31:40.367 align:middle
它被用来购买

00:31:41.935 --> 00:31:43.237 align:middle
购买的日期

00:31:44.171 --> 00:31:47.341 align:middle
然后最后的一个新事物 不是新的

00:31:47.407 --> 00:31:50.777 align:middle
但是一件事我想去强调是我们也包括

00:31:50.844 --> 00:31:52.679 align:middle
自动更新订阅

00:31:52.746 --> 00:31:55.249 align:middle
订阅有效期

00:31:55.749 --> 00:31:58.452 align:middle
所以如果你正切换你的应用去订阅

00:31:58.519 --> 00:32:00.020 align:middle
那是对你非常重要的

00:31:58.519 --> 00:32:00.020 align:middle
那是对你非常重要的

00:32:00.254 --> 00:32:03.156 align:middle
你将会使用这种类型 你将会
使用它去知道

00:32:03.223 --> 00:32:04.992 align:middle
订阅是否有效

00:32:05.058 --> 00:32:11.164 align:middle
我们是否需要去让用户去或者
你需要去仔细检查

00:32:11.231 --> 00:32:13.500 align:middle
用户是否在一个有效的订阅状态

00:32:13.967 --> 00:32:15.802 align:middle
因此领域非常重要

00:32:17.905 --> 00:32:19.106 align:middle
然后另外一个注意

00:32:19.306 --> 00:32:22.009 align:middle
如果你在Store里有个应用

00:32:22.476 --> 00:32:24.945 align:middle
它是付费的并且你有兴趣

00:32:25.012 --> 00:32:27.381 align:middle
切换它到一个订阅模式

00:32:28.081 --> 00:32:31.718 align:middle
有一件事你想去确保你检查
是主要的receipt里面

00:32:31.785 --> 00:32:34.254 align:middle
应用receipt本身是类型19

00:32:34.588 --> 00:32:37.291 align:middle
这包括原始应用程序版本

00:32:37.357 --> 00:32:39.059 align:middle
是应用买来的版本

00:32:39.693 --> 00:32:43.096 align:middle
所以如果我买的它是1.0版本
的付费应用

00:32:43.497 --> 00:32:46.300 align:middle
并且在2.0版本你转至订阅模式

00:32:46.834 --> 00:32:49.136 align:middle
我想看一下程序的原始版本

00:32:50.103 --> 00:32:54.141 align:middle
因为我想确认我把那个用户
当成付费用户

00:32:54.208 --> 00:32:57.144 align:middle
他们是或者不是一个订阅用户

00:32:57.511 --> 00:33:01.849 align:middle
我认为这是一个很差的体验
如果模式转换为订阅

00:32:57.511 --> 00:33:01.849 align:middle
我认为这是一个很差的体验
如果模式转换为订阅

00:33:01.915 --> 00:33:05.285 align:middle
并且你并不尊重他们买原始APP版本

00:33:05.586 --> 00:33:08.755 align:middle
所以如果你切换成订阅模式
记住这些非常重要

00:33:12.092 --> 00:33:13.493 align:middle
另外两个注意关于receipt

00:33:13.560 --> 00:33:16.129 align:middle
receipt是在购买时发行的

00:33:18.165 --> 00:33:20.334 align:middle
但是它实际上是同样可以续订的

00:33:21.068 --> 00:33:24.972 align:middle
但只针对in-app
purchase的特定的类型

00:33:25.205 --> 00:33:29.376 align:middle
所以当我们讨论可消费的
和不可更新的订阅的时候

00:33:29.877 --> 00:33:33.247 align:middle
他们将会在receipt里被刷新

00:33:34.081 --> 00:33:38.285 align:middle
所以可消费和不可续订的
订阅只会出现一次

00:33:38.352 --> 00:33:41.154 align:middle
他们出现刚好在交易生成之后

00:33:42.122 --> 00:33:43.624 align:middle
他们不会出现在那里

00:33:43.690 --> 00:33:46.860 align:middle
当用户刷新receipt
同样在该设备上

00:33:46.927 --> 00:33:48.929 align:middle
或者当他们切换至另外一个设备

00:33:50.197 --> 00:33:53.967 align:middle
但是 不可消费和自动更新的订阅

00:33:54.034 --> 00:33:56.170 align:middle
会一直出现在用户的receipt里

00:33:56.737 --> 00:33:58.038 align:middle
你可以拿回那些东西

00:33:58.105 --> 00:34:01.642 align:middle
应该拿回那些东西
通过StoreKit API

00:33:58.105 --> 00:34:01.642 align:middle
应该拿回那些东西
通过StoreKit API

00:34:03.010 --> 00:34:04.811 align:middle
我们可以看一下那个看起来像什么

00:34:04.878 --> 00:34:07.447 align:middle
他在IOS和macOS有些不同

00:34:08.014 --> 00:34:11.385 align:middle
在iOS receipt
不存在或者是无效的

00:34:11.451 --> 00:34:14.121 align:middle
你应该使用
StoreKit API去刷新它

00:34:15.355 --> 00:34:17.658 align:middle
但是记住你必须拥有网络

00:34:17.724 --> 00:34:20.127 align:middle
我们需要去连接App Store

00:34:20.527 --> 00:34:22.196 align:middle
我们需要去验证用户

00:34:22.496 --> 00:34:24.898 align:middle
我们必须要知道他们真的是那些
已经购买过这个东西的人

00:34:24.965 --> 00:34:27.568 align:middle
所以他们将要输入他们的密码

00:34:27.634 --> 00:34:29.303 align:middle
或者使用他们的指纹

00:34:31.338 --> 00:34:33.940 align:middle
如果你正在做一些事情如

00:34:35.208 --> 00:34:38.011 align:middle
应用每次启动刷新receipt

00:34:38.078 --> 00:34:40.614 align:middle
这绝不是一个好的模式去遵循

00:34:40.681 --> 00:34:44.016 align:middle
或者如果你正在做一些事情
如在检查receipt是无效的

00:34:44.083 --> 00:34:47.821 align:middle
然后获取它，因为你知道或许有些东西

00:34:47.888 --> 00:34:49.489 align:middle
有些东西看起来不对

00:34:49.556 --> 00:34:52.559 align:middle
你想小心点你不会陷入一遍
又一遍的循环中

00:34:52.626 --> 00:34:56.429 align:middle
如果你的应用崩溃而你正检查
你的receipt启动

00:34:56.864 --> 00:34:58.966 align:middle
或者如果你保持检查并且它是无效的

00:34:59.032 --> 00:35:02.135 align:middle
关于的验证码就是不对的

00:34:59.032 --> 00:35:02.135 align:middle
关于的验证码就是不对的

00:35:02.336 --> 00:35:04.805 align:middle
你不想去验证和取回
那个receipt

00:35:04.872 --> 00:35:06.273 align:middle
一遍又一遍

00:35:06.340 --> 00:35:08.342 align:middle
所以这些都必须要小心

00:35:10.210 --> 00:35:13.046 align:middle
这些能够在iOS完成通过

00:35:13.113 --> 00:35:16.416 align:middle
这些能够通过一个
SKRecipt刷新请求完成

00:35:17.017 --> 00:35:18.819 align:middle
你设置的代理并且
调用了start

00:35:19.186 --> 00:35:22.723 align:middle
这个会在代理中通知你的应用程序

00:35:22.789 --> 00:35:25.058 align:middle
当receipt被更新而且你能继续

00:35:25.125 --> 00:35:27.561 align:middle
并且处理这些交易在receipt中

00:35:27.628 --> 00:35:30.230 align:middle
就好像他们由用户购买一样

00:35:31.265 --> 00:35:33.333 align:middle
在macOS一点不同

00:35:33.834 --> 00:35:35.469 align:middle
如果receipt是无效的

00:35:35.836 --> 00:35:38.539 align:middle
你将会退出伴随着编码173

00:35:38.605 --> 00:35:41.875 align:middle
这个会告诉Finder
他们替我把receipt取得

00:35:43.410 --> 00:35:46.013 align:middle
再次 这里需要网络

00:35:46.079 --> 00:35:48.815 align:middle
用户可以登录Store

00:35:50.050 --> 00:35:52.920 align:middle
这个可以完成通过
调用exit 173

00:35:55.656 --> 00:35:58.892 align:middle
然后我只想去再次强调
server-to-server验证

00:35:58.959 --> 00:36:01.328 align:middle
若你正在做一个自动更新的
receipt并且你有

00:35:58.959 --> 00:36:01.328 align:middle
若你正在做一个自动更新的
receipt并且你有

00:36:01.395 --> 00:36:03.230 align:middle
一个自动更新的订阅

00:36:03.297 --> 00:36:05.399 align:middle
如果你有在服务器上可用的内容

00:36:05.465 --> 00:36:11.171 align:middle
你可能有一个hosted implementation
备份你的in-app purchases

00:36:11.905 --> 00:36:14.575 align:middle
所以如果你正在做
server-to-server验证

00:36:14.641 --> 00:36:18.111 align:middle
这个会允许你去在服务器端验证
receipt

00:36:18.178 --> 00:36:20.814 align:middle
那是用户获取用于他们的in-app
purchases是有效的

00:36:21.481 --> 00:36:23.684 align:middle
因此你拿到在那个设备上的
receipt

00:36:23.750 --> 00:36:25.118 align:middle
你上传它去服务器

00:36:28.622 --> 00:36:30.924 align:middle
但是 我要再次强调它

00:36:31.024 --> 00:36:34.928 align:middle
不要直接发送receipt去验证
receipt的端点

00:36:35.395 --> 00:36:38.765 align:middle
这是不安全的还有你不应该那样做

00:36:40.300 --> 00:36:43.737 align:middle
有件事需要注意是验证receipt
的端点返回的是一个JSON

00:36:43.804 --> 00:36:46.240 align:middle
有效载荷和实际包括信息

00:36:46.306 --> 00:36:48.976 align:middle
像如果你的receipt过期了

00:36:49.042 --> 00:36:51.845 align:middle
你会从App Store那里
得到最新的版本

00:36:51.912 --> 00:36:55.315 align:middle
它会包括一些关于它有效的信息

00:36:55.382 --> 00:36:59.186 align:middle
或者如果receipt的状态不对

00:36:59.253 --> 00:37:02.189 align:middle
所以再次 有在线文档

00:36:59.253 --> 00:37:02.189 align:middle
所以再次 有在线文档

00:37:02.256 --> 00:37:05.158 align:middle
关于到底验证receipt的端点
如何工作的

00:37:07.861 --> 00:37:11.431 align:middle
好吧 我们已经通过了
我们已经购买了

00:37:11.665 --> 00:37:13.367 align:middle
我们已经完成了交易处理

00:37:14.034 --> 00:37:17.171 align:middle
这取决于你决定到底你怎么去验证

00:37:17.237 --> 00:37:19.306 align:middle
receipt和哪个安全层级

00:37:19.373 --> 00:37:21.875 align:middle
你将要把它放到后面
还有什么技术你将会使用

00:37:22.109 --> 00:37:24.011 align:middle
你验证了那个购买是真的

00:37:24.077 --> 00:37:26.413 align:middle
那个背后有一个货币交易

00:37:26.713 --> 00:37:30.384 align:middle
使用户可以买到什么取决于你

00:37:30.450 --> 00:37:32.920 align:middle
再交易结束的时候做得很好

00:37:33.420 --> 00:37:37.791 align:middle
这里有两个方法
去实现而且我们以前讨论过

00:37:38.091 --> 00:37:40.460 align:middle
你可能只有隐藏在你的应用的功能

00:37:40.527 --> 00:37:42.029 align:middle
你将要解锁的

00:37:42.229 --> 00:37:43.897 align:middle
你的一个基本版本的应用程序

00:37:43.964 --> 00:37:47.367 align:middle
一个免费的基本版本
现在已经是一个专业版本

00:37:47.434 --> 00:37:50.671 align:middle
你只需要设置那个状态并且
确保对用户是可用的

00:37:51.305 --> 00:37:54.708 align:middle
或者如果你有来自服务器上的内容

00:37:54.775 --> 00:37:56.176 align:middle
你需要去下载它

00:37:57.144 --> 00:37:58.512 align:middle
一堆不同的技术

00:37:58.579 --> 00:38:00.013 align:middle
一堆实现的不同方式

00:37:58.579 --> 00:38:00.013 align:middle
一堆实现的不同方式

00:38:00.080 --> 00:38:01.849 align:middle
现在我要强调它们中的一部分

00:38:03.550 --> 00:38:06.486 align:middle
一个是Apple提供的一个更新的

00:38:06.553 --> 00:38:08.555 align:middle
是按需资源

00:38:08.822 --> 00:38:11.592 align:middle
这个方法能使你的应用程序

00:38:11.658 --> 00:38:16.363 align:middle
在初始下载的时候尽可能的小和压缩

00:38:16.430 --> 00:38:17.631 align:middle
如二进制文件

00:38:17.931 --> 00:38:20.367 align:middle
如果你要去让别的资源

00:38:20.434 --> 00:38:21.768 align:middle
关联应用程序

00:38:21.835 --> 00:38:23.737 align:middle
如果你的游戏有一堆不同的等级

00:38:23.804 --> 00:38:28.375 align:middle
而它们让你知道图片和视频关联它们

00:38:28.442 --> 00:38:33.013 align:middle
你可以在你的应用清单里把
他们分解成不同的组件

00:38:34.147 --> 00:38:38.151 align:middle
按需资源是托管在
App Store中

00:38:38.218 --> 00:38:40.020 align:middle
所以你不同担心托管的问题

00:38:40.287 --> 00:38:41.722 align:middle
它是可扩展和稳定的

00:38:41.788 --> 00:38:44.324 align:middle
我们已经用这个为全世界缓存

00:38:44.625 --> 00:38:46.927 align:middle
你的用户可以更快的获取他们的内容

00:38:48.962 --> 00:38:50.597 align:middle
一件事需要记住的是

00:38:50.864 --> 00:38:53.767 align:middle
它可以包含任何类型代码执行异常

00:38:53.834 --> 00:38:56.670 align:middle
所以所有的代码都在
你原始的二进制文件里

00:38:56.737 --> 00:39:00.174 align:middle
但是它可以包含
其他类型的你想要的内容

00:38:56.737 --> 00:39:00.174 align:middle
但是它可以包含
其他类型的你想要的内容

00:39:01.408 --> 00:39:05.145 align:middle
它只在IOS和tvOS中可用

00:39:05.212 --> 00:39:08.415 align:middle
macOS现在不支持按需资源

00:39:09.049 --> 00:39:11.218 align:middle
所以那个技术是你可能选择去使用

00:39:11.285 --> 00:39:14.655 align:middle
它去获取额外的内容在购买完成之后

00:39:14.922 --> 00:39:16.723 align:middle
如果你有兴趣想了解多一些关于它

00:39:16.957 --> 00:39:20.961 align:middle
我强烈建议你看一下
“按需资源的优化”这个讲座

00:39:21.028 --> 00:39:24.164 align:middle
它在Mission里 在这个房间
周四早上10点

00:39:27.201 --> 00:39:30.838 align:middle
另外一个Apple提供的技术是
in-app purchase托管内容

00:39:30.904 --> 00:39:34.875 align:middle
你可以这个内容关联你的
in-app purchase

00:39:34.942 --> 00:39:37.477 align:middle
在iTunes连接和再次连接

00:39:37.811 --> 00:39:39.746 align:middle
它托管在Apple服务器上

00:39:39.947 --> 00:39:42.449 align:middle
所以你不用担心主机本身

00:39:42.516 --> 00:39:43.951 align:middle
可扩展和可靠地

00:39:44.151 --> 00:39:45.619 align:middle
缓存全世界

00:39:46.987 --> 00:39:50.357 align:middle
一件事需要记住的关于这个和ODR

00:39:50.424 --> 00:39:53.026 align:middle
是这个会在后台下载你的内容

00:39:53.093 --> 00:39:54.695 align:middle
你的应用不需要运行

00:39:54.761 --> 00:39:58.699 align:middle
所以用户完成购买
并且会离开你的应用

00:39:58.765 --> 00:40:01.568 align:middle
运行其他的应用
而你需要去下载这些内容

00:39:58.765 --> 00:40:01.568 align:middle
运行其他的应用
而你需要去下载这些内容

00:40:01.635 --> 00:40:02.736 align:middle
那些会继续运行

00:40:04.104 --> 00:40:07.941 align:middle
每个in-app purchasable产品你有最高2G容量

00:40:08.008 --> 00:40:10.277 align:middle
所以不是所有的应用程序共有2G容量

00:40:10.344 --> 00:40:12.312 align:middle
是每个产品2G

00:40:13.547 --> 00:40:17.417 align:middle
这个iOS tvOS
macOS是支持的

00:40:17.618 --> 00:40:21.154 align:middle
所有 再次另外一个拥有
Apple托管内容的方法

00:40:21.221 --> 00:40:23.123 align:middle
为你in-app purchase

00:40:25.859 --> 00:40:28.395 align:middle
让我们看一下那个可能看起来有点

00:40:28.462 --> 00:40:30.864 align:middle
一个付款通过了

00:40:31.331 --> 00:40:34.568 align:middle
用户 你验证它并且你准备去下载内容

00:40:34.635 --> 00:40:37.304 align:middle
你将在更新的交易中回调

00:40:37.371 --> 00:40:38.739 align:middle
你的付款观察者

00:40:40.007 --> 00:40:41.074 align:middle
那么我们再往下一点

00:40:41.141 --> 00:40:42.609 align:middle
你将看到你的交易

00:40:42.676 --> 00:40:44.578 align:middle
你将获知一笔其中的交易

00:40:44.645 --> 00:40:46.813 align:middle
包含一个或多个下载

00:40:47.047 --> 00:40:49.650 align:middle
你所需要做的只是回传那个下载

00:40:49.716 --> 00:40:52.853 align:middle
去“支付队列” 它会开始下载

00:40:54.521 --> 00:40:58.659 align:middle
如果你的应用程序有兴趣使用托管
in-app purchase

00:40:58.725 --> 00:41:02.696 align:middle
你将拥有一个支付队列更新下载的方法

00:40:58.725 --> 00:41:02.696 align:middle
你将拥有一个支付队列更新下载的方法

00:41:02.763 --> 00:41:04.831 align:middle
在你的支付队列观察者里

00:41:07.201 --> 00:41:08.769 align:middle
这个会给你全部的信息

00:41:08.836 --> 00:41:11.071 align:middle
关于下载当他们进来

00:41:11.138 --> 00:41:15.209 align:middle
包括像进度这样的东西会
调用并让你知道进度

00:41:15.275 --> 00:41:17.911 align:middle
你会用这个去更新UI

00:41:18.145 --> 00:41:19.279 align:middle
或者时间剩余

00:41:19.646 --> 00:41:22.316 align:middle
或者如果错误发生
你需要对它做出反应

00:41:22.716 --> 00:41:24.084 align:middle
这些信息会在这里

00:41:24.351 --> 00:41:28.021 align:middle
然后一旦下载完成一个URL会被提供

00:41:28.088 --> 00:41:31.925 align:middle
那是一个本地URL 就在文件系统上

00:41:31.992 --> 00:41:35.162 align:middle
所以你可以抓取它然后在那里你可以
与你的内容进行交互

00:41:36.697 --> 00:41:39.199 align:middle
这是in-app
purchases托管怎么工作

00:41:40.400 --> 00:41:43.904 align:middle
但是你可能也想自托管这些内容

00:41:43.971 --> 00:41:45.506 align:middle
完全有效的事情

00:41:45.706 --> 00:41:47.975 align:middle
如果你有一个随时间变化的目录

00:41:48.041 --> 00:41:50.677 align:middle
如果你有一些不同的东西你不需要

00:41:50.744 --> 00:41:53.947 align:middle
去放到Apple托管
自托管内容完全有效的选择

00:41:54.414 --> 00:41:58.418 align:middle
一件事需要记住
那里有后台下载的API

00:41:58.485 --> 00:42:01.054 align:middle
你必须用NSURL会话调用

00:41:58.485 --> 00:42:01.054 align:middle
你必须用NSURL会话调用

00:42:01.154 --> 00:42:02.823 align:middle
这个是托管这个内容的方法

00:42:04.525 --> 00:42:07.094 align:middle
内容可以被下载
即使你的应用不是激活状态

00:42:07.160 --> 00:42:09.329 align:middle
若你扔使用
NSURLConnection

00:42:09.763 --> 00:42:10.864 align:middle
那是过时的

00:42:10.931 --> 00:42:13.166 align:middle
那不是一个好的体验

00:42:13.233 --> 00:42:15.302 align:middle
对应用户来使用NSURL会话

00:42:15.669 --> 00:42:18.505 align:middle
所以这个是非常重要的
对于你使用这些API

00:42:21.375 --> 00:42:23.243 align:middle
这个是它在Swift中的样子

00:42:23.810 --> 00:42:26.547 align:middle
你将要创建一个会话配置

00:42:26.980 --> 00:42:30.817 align:middle
这是一个配置你想命名为一个唯一的

00:42:30.884 --> 00:42:34.021 align:middle
对于你的应用程序用于描述那个会话
是关于什么的

00:42:35.522 --> 00:42:37.124 align:middle
你将要创建会话

00:42:37.191 --> 00:42:39.026 align:middle
你要传入配置的值

00:42:39.092 --> 00:42:43.030 align:middle
你要传入代理 这将是任何对象你想要

00:42:43.096 --> 00:42:45.432 align:middle
获取这些下载的信息

00:42:45.666 --> 00:42:47.134 align:middle
你会给出队列

00:42:47.201 --> 00:42:51.338 align:middle
这个操作队列实际上是在
你的代理中被调用的

00:42:51.405 --> 00:42:54.842 align:middle
什么线程和什么操作队列
将会在代理里调用

00:42:54.908 --> 00:42:57.811 align:middle
所以你想要确保你创建了一个专用的

00:42:57.878 --> 00:42:59.413 align:middle
操作队列

00:43:01.281 --> 00:43:04.418 align:middle
然后开始下载 你创建了一个任务

00:43:04.484 --> 00:43:08.555 align:middle
你递交请求和与in-app
purchase关联URL

00:43:08.922 --> 00:43:10.023 align:middle
你调用继续

00:43:10.357 --> 00:43:16.163 align:middle
这个会在你的后台开始自托管
in-app purchase下载

00:43:16.864 --> 00:43:20.634 align:middle
伴随着下载开始你的代理会接收到信息

00:43:20.701 --> 00:43:24.738 align:middle
它将在URL会话
didWriteData方法里被调用

00:43:25.606 --> 00:43:27.875 align:middle
这会给你这个能力

00:43:27.941 --> 00:43:29.510 align:middle
你可以带入这些信息

00:43:29.576 --> 00:43:31.545 align:middle
并且它能让你去更新UI

00:43:31.612 --> 00:43:33.347 align:middle
你可能有一个进度条

00:43:33.413 --> 00:43:34.715 align:middle
或其他东西你想告诉用户

00:43:34.781 --> 00:43:36.550 align:middle
关于下载的进度

00:43:39.753 --> 00:43:43.423 align:middle
但是重要的你要记住
你的应用程序有可能退出

00:43:44.024 --> 00:43:46.159 align:middle
在下载的过程中

00:43:46.226 --> 00:43:48.896 align:middle
所以当你的应用程序重启

00:43:49.329 --> 00:43:53.300 align:middle
你想把这些后台下载会话重新连接

00:43:54.134 --> 00:43:55.936 align:middle
所以在你的应用程序代理里

00:43:56.003 --> 00:44:00.174 align:middle
你会执行处理事件为后台URL会话

00:43:56.003 --> 00:44:00.174 align:middle
你会执行处理事件为后台URL会话

00:44:00.707 --> 00:44:04.545 align:middle
这会让操作系统唤醒你的应用程序

00:44:04.611 --> 00:44:09.316 align:middle
并且告诉它这个后台下载刚刚完成

00:44:09.383 --> 00:44:12.119 align:middle
或者正在进行 或者出了什么问题

00:44:12.553 --> 00:44:15.455 align:middle
所以处理事件为后台URL会话

00:44:15.522 --> 00:44:19.793 align:middle
这里会把之前使用的配置的标识符传入

00:44:20.194 --> 00:44:23.063 align:middle
你会重新创建带有标识符的配置

00:44:23.597 --> 00:44:27.968 align:middle
重新创建一个重新连接后台会话的会话

00:44:28.502 --> 00:44:31.171 align:middle
然后你要做的是那里有个完成句柄

00:44:31.238 --> 00:44:35.843 align:middle
它会被传入应用代理方法

00:44:35.909 --> 00:44:38.011 align:middle
你需要去调用完成处理程序

00:44:38.078 --> 00:44:41.415 align:middle
一旦你完成了
你就完成了所有关于下载的动作

00:44:41.481 --> 00:44:44.785 align:middle
所以如果下载完成
你需要去把它放入你的容器

00:44:44.852 --> 00:44:46.453 align:middle
解压它 让它工作

00:44:46.720 --> 00:44:49.590 align:middle
你需要去调用完成处理程序
一旦你完成了所有工作

00:44:49.656 --> 00:44:53.727 align:middle
让OS知道你已经完成了所有工作

00:44:55.796 --> 00:44:57.865 align:middle
所以这能使资产可用

00:44:58.632 --> 00:44:59.633 align:middle
但是你还没有完全完成

00:44:59.700 --> 00:45:01.268 align:middle
即使你已经做了所有可以做的

00:44:59.700 --> 00:45:01.268 align:middle
即使你已经做了所有可以做的

00:45:01.335 --> 00:45:02.870 align:middle
用户已经拥有他们买到的

00:45:03.337 --> 00:45:06.773 align:middle
你还是要做另外一件事
你需要告诉StoreKit

00:45:06.840 --> 00:45:09.009 align:middle
你已经完成了交易

00:45:09.776 --> 00:45:12.713 align:middle
这个很重要因为我们保留这个交易

00:45:12.779 --> 00:45:14.081 align:middle
在我们的购买队列中

00:45:14.147 --> 00:45:15.816 align:middle
我们保留它在
我们的state machine

00:45:16.183 --> 00:45:18.685 align:middle
如果你的应用程序死机并且重启

00:45:18.752 --> 00:45:20.454 align:middle
或者用户离开并返回

00:45:20.521 --> 00:45:22.823 align:middle
支付队列会持续告诉你这些

00:45:22.890 --> 00:45:26.827 align:middle
它实际会持续做这些在你行为
后台API调用的时候

00:45:26.894 --> 00:45:29.096 align:middle
所以这样会用光用户的数据空间

00:45:29.329 --> 00:45:30.898 align:middle
所以及时清理是非常重要的

00:45:30.964 --> 00:45:33.100 align:middle
在你完成交易之后

00:45:33.867 --> 00:45:35.736 align:middle
但是你应该确保是你做的

00:45:35.802 --> 00:45:38.005 align:middle
当内容下载完成

00:45:38.238 --> 00:45:41.608 align:middle
如果你完成了交易 然后开始下载

00:45:42.276 --> 00:45:44.578 align:middle
我们会再告诉你关于那个交易一次

00:45:44.645 --> 00:45:47.748 align:middle
所以如果下载失败或者下载出错

00:45:48.015 --> 00:45:49.550 align:middle
你不会得到更新信息

00:45:49.616 --> 00:45:52.186 align:middle
所以你要确保下载完成

00:45:52.252 --> 00:45:54.588 align:middle
然后调用完成交易

00:45:56.490 --> 00:45:59.359 align:middle
所以 再次 支付会继续在
队列里直到你完成它

00:45:59.960 --> 00:46:02.729 align:middle
如果你正在下载托管内容
另外一件你需要记住的

00:45:59.960 --> 00:46:02.729 align:middle
如果你正在下载托管内容
另外一件你需要记住的

00:46:02.796 --> 00:46:04.898 align:middle
是你需要完成下载

00:46:04.965 --> 00:46:07.601 align:middle
如果你在下载完成之前完成交易

00:46:07.668 --> 00:46:09.136 align:middle
我们会停止下载

00:46:11.338 --> 00:46:14.508 align:middle
这个可以很容易被实现通过
调用SK支付队列

00:46:14.575 --> 00:46:18.979 align:middle
完成交易和传递交易到支付队列

00:46:22.549 --> 00:46:26.553 align:middle
所以 用户已经使用你的应用
他们已经购买了in-app purchase

00:46:26.620 --> 00:46:29.156 align:middle
他们喜欢你的内容 他们决定

00:46:29.656 --> 00:46:30.958 align:middle
你知道我的空间已经用完

00:46:31.024 --> 00:46:33.927 align:middle
我会删除应用
可能我稍后会重新下载它

00:46:34.261 --> 00:46:36.063 align:middle
或者他们切换到另外一个设备

00:46:36.430 --> 00:46:38.665 align:middle
这总是很重要的
他们可以要回那些

00:46:39.800 --> 00:46:45.806 align:middle
非消费型和自动更新in-app
purchase到应用里

00:46:45.906 --> 00:46:48.008 align:middle
他们需要能恢复以前的内容

00:46:48.775 --> 00:46:51.178 align:middle
所以恢复交易允许用户

00:46:51.245 --> 00:46:55.983 align:middle
恢复非消费和自动更新的订阅

00:46:57.751 --> 00:47:00.487 align:middle
消费的和非自动更新的订阅

00:46:57.751 --> 00:47:00.487 align:middle
消费的和非自动更新的订阅

00:47:00.554 --> 00:47:02.456 align:middle
这取决于你去管理这个状态

00:47:02.890 --> 00:47:06.026 align:middle
所以可能有一些你刚好保存在本地

00:47:06.093 --> 00:47:08.128 align:middle
可能有一些你存储在Cloud中

00:47:08.195 --> 00:47:11.064 align:middle
或者你存在自己的托管后台

00:47:11.131 --> 00:47:14.835 align:middle
这取决于你去管理
你究竟想如何恢复内容

00:47:14.902 --> 00:47:17.738 align:middle
但是对于非消费和自动更新

00:47:17.871 --> 00:47:22.576 align:middle
你可以恢复它们使用恢复API

00:47:25.546 --> 00:47:29.116 align:middle
再次 我们提供API用于
SK支付队列恢复

00:47:29.183 --> 00:47:30.484 align:middle
完成交易

00:47:30.817 --> 00:47:34.955 align:middle
那能够降低一个品牌的应用的更新版本

00:47:35.389 --> 00:47:37.090 align:middle
和in-app purchase
receipt

00:47:38.425 --> 00:47:40.227 align:middle
再次 你会想去观察队列

00:47:40.294 --> 00:47:43.430 align:middle
你把它加到你的应用代理 所以当然
你正在观察队列

00:47:43.497 --> 00:47:44.498 align:middle
你正在获取信息

00:47:44.565 --> 00:47:46.600 align:middle
关于这些交易当它们进入

00:47:46.867 --> 00:47:48.035 align:middle
因为我们将调用

00:47:48.101 --> 00:47:50.771 align:middle
支付队列恢复完成 交易结束

00:47:50.838 --> 00:47:54.174 align:middle
这个会告诉你所有的发生的恢复

00:47:54.241 --> 00:47:55.709 align:middle
你会只想去处理它们

00:47:55.776 --> 00:47:57.845 align:middle
好像它们刚被用户购买

00:47:58.345 --> 00:48:00.581 align:middle
或者我们会告诉你错误发生了

00:47:58.345 --> 00:48:00.581 align:middle
或者我们会告诉你错误发生了

00:48:00.647 --> 00:48:02.983 align:middle
可能你需要让用户再尝试一次

00:48:03.083 --> 00:48:04.785 align:middle
或者对应的更新你的UI

00:48:05.252 --> 00:48:07.421 align:middle
所以 观察队列非常重要

00:48:09.690 --> 00:48:13.460 align:middle
再次 一旦恢复完成
你可以看看receipt

00:48:13.527 --> 00:48:15.596 align:middle
并且解锁对应的内容和功能

00:48:18.665 --> 00:48:20.033 align:middle
现在我们会感觉好点的是

00:48:20.100 --> 00:48:21.335 align:middle
你创造了自己的应用

00:48:21.401 --> 00:48:24.404 align:middle
你准备去提交它到
App Store你想确保

00:48:24.471 --> 00:48:25.839 align:middle
你能通过审查

00:48:26.373 --> 00:48:27.941 align:middle
有些事情需要记住

00:48:28.909 --> 00:48:30.978 align:middle
我们刚刚讨论的恢复

00:48:31.245 --> 00:48:33.714 align:middle
你真的需要一个恢复机制

00:48:33.780 --> 00:48:35.115 align:middle
它不必要是个UI按钮

00:48:35.182 --> 00:48:38.151 align:middle
你需要一些应用内在机制去允许用户

00:48:38.218 --> 00:48:41.321 align:middle
要回他们的内容否则这不会通过审查

00:48:43.056 --> 00:48:46.360 align:middle
再次 对应非消费和自动更新的订阅

00:48:46.426 --> 00:48:49.930 align:middle
你不会在恢复中得到其他的
in-app purchase类型

00:48:51.798 --> 00:48:54.067 align:middle
一件事需要记住的是

00:48:54.835 --> 00:48:57.671 align:middle
我们想让这些同购买隔离开

00:48:57.738 --> 00:48:59.039 align:middle
恢复是免费的

00:48:59.306 --> 00:49:02.609 align:middle
用户不会感到疑惑如果他们做了恢复

00:48:59.306 --> 00:49:02.609 align:middle
用户不会感到疑惑如果他们做了恢复

00:49:02.676 --> 00:49:04.978 align:middle
他们需要输入
来自App Store的密码

00:49:05.045 --> 00:49:06.780 align:middle
这会消耗他们任何东西

00:49:06.847 --> 00:49:09.349 align:middle
这个在你的应用程序是非常明显的

00:49:09.416 --> 00:49:12.519 align:middle
他们做的这次恢复操作不是一次购买

00:49:12.586 --> 00:49:14.254 align:middle
这是完全隔离开的

00:49:14.321 --> 00:49:17.157 align:middle
所以你要确保的是你的UI反映

00:49:19.593 --> 00:49:22.362 align:middle
其他你想要记住的消息

00:49:22.429 --> 00:49:26.066 align:middle
对于自动更新订阅的是关于政策的

00:49:27.534 --> 00:49:29.937 align:middle
保留信息在市场文本里

00:49:31.305 --> 00:49:34.308 align:middle
确保一旦他们订阅了

00:49:34.374 --> 00:49:36.310 align:middle
他们就可以立刻得到内容

00:49:36.376 --> 00:49:39.713 align:middle
他们不需要等待直到下个阶段开始

00:49:39.780 --> 00:49:40.914 align:middle
任何东西出现

00:49:40.981 --> 00:49:43.717 align:middle
如果你订阅了
你应该会马上获取一些信息

00:49:44.184 --> 00:49:45.853 align:middle
你应该获取信息

00:49:45.919 --> 00:49:48.455 align:middle
关于你应该只能通过订阅获得

00:49:48.522 --> 00:49:52.759 align:middle
而不是一堆产品或者内容

00:49:52.826 --> 00:49:54.661 align:middle
他们本可以在别处获取免费

00:49:54.728 --> 00:49:57.030 align:middle
所以 这就是一些政策

00:49:57.097 --> 00:50:01.335 align:middle
我强烈建议你看一下
“APPS审查政策指南”这个讲座

00:49:57.097 --> 00:50:01.335 align:middle
我强烈建议你看一下
“APPS审查政策指南”这个讲座

00:50:01.535 --> 00:50:04.171 align:middle
我已经听说
现在已经有一本漫画书关于它

00:50:04.238 --> 00:50:07.140 align:middle
所以我强烈建议你把这些全部学习一遍

00:50:07.374 --> 00:50:08.609 align:middle
因为它们一直在变化

00:50:08.675 --> 00:50:11.211 align:middle
你应该时刻关注它的变化

00:50:12.412 --> 00:50:14.715 align:middle
关于非更新的订阅这里有些其他政策

00:50:14.781 --> 00:50:16.283 align:middle
你要记住

00:50:16.583 --> 00:50:20.387 align:middle
关于隐私和确保用户有能力去参与

00:50:20.454 --> 00:50:22.489 align:middle
或退出

00:50:24.758 --> 00:50:27.895 align:middle
然后最终这最重要的事情
是通过应用反馈

00:50:27.961 --> 00:50:30.964 align:middle
是如果你已经在你的应用里拥有购买
它应该可以工作

00:50:32.032 --> 00:50:34.368 align:middle
你完成购买 内容就应该出现

00:50:34.601 --> 00:50:36.170 align:middle
它们应该得到信息

00:50:36.236 --> 00:50:38.105 align:middle
他们应该在那里得到内容

00:50:38.172 --> 00:50:40.407 align:middle
如果它是缺陷或者如果他是容易错误

00:50:40.474 --> 00:50:46.813 align:middle
或者如果有什么事情发生当
评论人正在评论它

00:50:46.880 --> 00:50:49.683 align:middle
在应用评论环境内部

00:50:50.050 --> 00:50:52.252 align:middle
你就会在那里立刻得到评论中的问题

00:50:52.319 --> 00:50:53.320 align:middle
所以测试它

00:50:53.387 --> 00:50:56.690 align:middle
测试它在Sandbox
确保一切如你期望的工作着

00:50:59.393 --> 00:51:02.462 align:middle
所以刚才总结下我们今天讨论的

00:50:59.393 --> 00:51:02.462 align:middle
所以刚才总结下我们今天讨论的

00:51:03.797 --> 00:51:06.633 align:middle
始终遵守支付队列

00:51:06.934 --> 00:51:09.536 align:middle
如果你在你的应用里与
in-app purchase交互

00:51:09.603 --> 00:51:14.408 align:middle
首先你的应用应该设置
一个支付队列观察者

00:51:14.474 --> 00:51:17.211 align:middle
去获取信息关于支付的进展情况

00:51:18.846 --> 00:51:22.382 align:middle
你应该从App Store中
获取本地化产品信息

00:51:22.449 --> 00:51:24.985 align:middle
这是通过一个SK产品请求

00:51:25.686 --> 00:51:27.788 align:middle
它会返回本地化信息

00:51:27.855 --> 00:51:31.191 align:middle
所以用户在他们国家的信息

00:51:31.258 --> 00:51:34.628 align:middle
关联到App Store
账户账单信息

00:51:36.463 --> 00:51:39.333 align:middle
再次强调
使用产品所在地的货币单位

00:51:39.566 --> 00:51:44.204 align:middle
这里有个SK产品返回
它有一个关联的场所

00:51:44.271 --> 00:51:48.275 align:middle
你应该去使用它
为了展示价格和货币信息

00:51:50.377 --> 00:51:52.346 align:middle
使用receipt去验证你的购买

00:51:52.412 --> 00:51:55.048 align:middle
再次 它们是你的购买 这是你的生意

00:51:55.249 --> 00:51:58.218 align:middle
你应该去做决定关于怎么
最好的去验证receipt

00:51:58.285 --> 00:52:01.054 align:middle
是否在本地验证或者在服务器

00:51:58.285 --> 00:52:01.054 align:middle
是否在本地验证或者在服务器

00:52:01.121 --> 00:52:02.956 align:middle
后面是什么技术

00:52:03.490 --> 00:52:06.860 align:middle
要知道到底每个优点和缺点是什么

00:52:06.927 --> 00:52:08.629 align:middle
用那个做下你的决定

00:52:09.763 --> 00:52:11.598 align:middle
最终使内容是可用的

00:52:11.665 --> 00:52:15.769 align:middle
你可以在那个设备的你的应用里解锁它

00:52:16.069 --> 00:52:19.907 align:middle
或者你可以发出一个
App Store自己的托管请求

00:52:20.174 --> 00:52:24.278 align:middle
或者你可以发出一个请求
到后端主机API

00:52:24.545 --> 00:52:25.979 align:middle
使内容可用

00:52:26.046 --> 00:52:28.315 align:middle
但是用一个可靠的而且快速的方法做它

00:52:28.382 --> 00:52:32.052 align:middle
如果你自托管
确保你的服务器是可扩展的

00:52:32.386 --> 00:52:35.389 align:middle
你知道缓存适度

00:52:35.455 --> 00:52:39.927 align:middle
是真的准备为了用户
很好地使用你的应用

00:52:41.228 --> 00:52:43.730 align:middle
然后最终完成交易

00:52:43.797 --> 00:52:45.766 align:middle
最后一件你需要确保的事情是

00:52:45.832 --> 00:52:48.302 align:middle
交易不再存在在支付队列中

00:52:48.368 --> 00:52:51.205 align:middle
否则你的观察者将会不断的被通知

00:52:51.271 --> 00:52:52.940 align:middle
关于它当你的应用启动

00:52:53.607 --> 00:52:59.513 align:middle
这将感觉很奇怪用户可能不得不

00:52:59.947 --> 00:53:01.448 align:middle
在特定的时间进行身份验证

00:52:59.947 --> 00:53:01.448 align:middle
在特定的时间进行身份验证

00:53:01.515 --> 00:53:06.687 align:middle
或者那里可能存在后台
代替你应用的API正在发生

00:53:06.753 --> 00:53:09.990 align:middle
为用户使用完数据空间
如果你不能完成交易

00:53:11.091 --> 00:53:12.092 align:middle
所以始终那样做

00:53:14.027 --> 00:53:18.799 align:middle
然后 允许用户恢复完成交易

00:53:18.866 --> 00:53:21.168 align:middle
你需要一个恢复机制在你的应用里

00:53:21.235 --> 00:53:25.172 align:middle
如果你有非消费或者自动更新的订阅

00:53:25.239 --> 00:53:28.308 align:middle
这会允许用户去获取之前已经购买的

00:53:30.544 --> 00:53:34.481 align:middle
更多信息请在开发者网站上

00:53:34.982 --> 00:53:37.885 align:middle
我强烈建议你返回并稍后看看它

00:53:39.119 --> 00:53:41.588 align:middle
然后两个相关的话题我们今天提到的

00:53:41.655 --> 00:53:44.224 align:middle
如果你正使用订阅在你的应用里

00:53:44.625 --> 00:53:47.261 align:middle
你应该明确的检查“介绍扩展订阅”

00:53:47.327 --> 00:53:49.062 align:middle
在iTunes Connect
今天稍后的时间里

00:53:49.463 --> 00:53:51.365 align:middle
或者如果你对按需资源有兴趣

00:53:51.431 --> 00:53:54.101 align:middle
周四早晨来看一下

00:53:54.168 --> 00:53:55.002 align:middle
这是全部

00:53:56.036 --> 00:53:56.937 align:middle
谢谢
