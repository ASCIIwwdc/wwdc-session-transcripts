WEBVTT

00:00:19.453 --> 00:00:23.524
<c.magenta>Swift Foundation</c>
<c.magenta>的新特性</c>

00:00:32.165 --> 00:00:33.033
<c.magenta>谢谢</c>

00:00:34.801 --> 00:00:36.904
<c.magenta>大家好 欢迎</c>
<c.magenta>我是Tony Parker</c>

00:00:36.970 --> 00:00:38.772
<c.magenta>我在Apple带领</c>
<c.magenta>Foundation团队</c>

00:00:38.839 --> 00:00:41.241
<c.magenta>今天我在这里和</c>
<c.magenta>Michael LeHew一起讨论</c>

00:00:41.308 --> 00:00:42.976
<c.magenta>Swift Foundation</c>
<c.magenta>的新特性</c>

00:00:44.678 --> 00:00:46.847
<c.magenta>这一年来Foundation团队</c>
<c.magenta>付出了很大的努力</c>

00:00:46.914 --> 00:00:49.049
<c.magenta>改善你使用Cocoa的方式</c>

00:00:49.116 --> 00:00:51.318
<c.magenta>以及Swift中</c>
<c.magenta>Cocoa Touch的API</c>

00:00:51.785 --> 00:00:54.488
<c.magenta>从Swift API设计指引开始</c>

00:00:55.088 --> 00:00:57.524
<c.magenta>随后 我们研究了</c>
<c.magenta>所有Objective-C的代码</c>

00:00:57.591 --> 00:01:01.428
<c.magenta>包括Cocoa SDK使用及</c>
<c.magenta>你自己编写的代码如何引入Swift</c>

00:00:57.591 --> 00:01:01.428
<c.magenta>包括Cocoa SDK使用及</c>
<c.magenta>你自己编写的代码如何引入Swift</c>

00:01:02.496 --> 00:01:04.131
<c.magenta>但是我们知道</c>
<c.magenta>我们可以做到更好</c>

00:01:04.197 --> 00:01:07.868
<c.magenta>所以 我们引入了一套新的</c>
<c.magenta>值类型到Foundation里</c>

00:01:08.335 --> 00:01:12.005
<c.magenta>同时也引入了大量</c>
<c.magenta>很棒的针对Swift的新API</c>

00:01:13.207 --> 00:01:15.509
<c.magenta>我们继续从设计指引开始</c>

00:01:17.144 --> 00:01:19.313
<c.magenta>我们今年的工作</c>
<c.magenta>围绕着Swift 3 但是</c>

00:01:19.446 --> 00:01:21.949
<c.magenta>我们最初设计Swfit的目标</c>
<c.magenta>一直没有变</c>

00:01:22.416 --> 00:01:26.119
<c.magenta>我们希望你编写的代码</c>
<c.magenta>快速 安全 表达性强</c>

00:01:26.854 --> 00:01:28.755
<c.magenta>我们创建了标准库</c>

00:01:28.822 --> 00:01:30.991
<c.magenta>以及围绕这些核心思想的</c>
<c.magenta>编程语言</c>

00:01:31.458 --> 00:01:34.228
<c.magenta>你们很多人也都</c>
<c.magenta>理解了这些原则</c>

00:01:34.428 --> 00:01:36.230
<c.magenta>并且根据它们</c>
<c.magenta>建立了自己的应用程序</c>

00:01:36.830 --> 00:01:39.533
<c.magenta>但是 我们都知道</c>
<c.magenta>还有另一部分内容没有提到</c>

00:01:39.600 --> 00:01:41.034
<c.magenta>那就是Cocoa SDK</c>

00:01:41.902 --> 00:01:44.304
<c.magenta>你的程序也非常依赖它</c>

00:01:44.371 --> 00:01:46.740
<c.magenta>甚至对它的依赖</c>
<c.magenta>要大于Swift标准库</c>

00:01:47.007 --> 00:01:49.543
<c.magenta>它需要看起来</c>
<c.magenta>属于同一个生态系统</c>

00:01:50.410 --> 00:01:52.980
<c.magenta>因为SDK在这里至关重要</c>

00:01:53.046 --> 00:01:55.282
<c.magenta>有关我们如何</c>
<c.magenta>在自己的平台上开发应用</c>

00:01:55.349 --> 00:01:59.052
<c.magenta>让语言和库相互合作</c>
<c.magenta>至关重要</c>

00:02:01.088 --> 00:02:03.991
<c.magenta>所以今年我们专注于表达性</c>

00:02:04.358 --> 00:02:06.927
<c.magenta>我提到表达性这个词时</c>
<c.magenta>有两层含义</c>

00:02:06.994 --> 00:02:09.295
<c.magenta>第一层意思指的是</c>
<c.magenta>你作为应用作者的能力</c>

00:02:09.363 --> 00:02:11.765
<c.magenta>你编写的Swift代码</c>
<c.magenta>能把你的意图</c>

00:02:11.832 --> 00:02:13.634
<c.magenta>传达给编译器和库</c>

00:02:14.134 --> 00:02:15.435
<c.magenta>但它还有另一种意思</c>

00:02:15.736 --> 00:02:18.105
<c.magenta>库需要能表达它们自己的目的</c>

00:02:18.172 --> 00:02:19.339
<c.magenta>它们的设计模式</c>

00:02:19.406 --> 00:02:23.677
<c.magenta>以及它们对于如何让作为应用作者的你</c>
<c.magenta>能最方便地使用API的想法</c>

00:02:25.546 --> 00:02:27.347
<c.magenta>所以在研究指引的时候</c>

00:02:27.414 --> 00:02:29.983
<c.magenta>我们注重一致的体验这一概念</c>

00:02:30.217 --> 00:02:33.187
<c.magenta>有关指引的决策</c>
<c.magenta>都基于这一概念</c>

00:02:33.253 --> 00:02:35.522
<c.magenta>语言和库密不可分</c>

00:02:35.589 --> 00:02:36.823
<c.magenta>它们必须协同工作</c>

00:02:37.224 --> 00:02:40.961
<c.magenta>举个例子</c>
<c.magenta>库带来了一堆新的特性</c>

00:02:41.261 --> 00:02:44.565
<c.magenta>很多你看到的</c>
<c.magenta>今年我们新版平台上的特性</c>

00:02:44.631 --> 00:02:48.535
<c.magenta>都源于库中的新特性</c>
<c.magenta>你也可以把它们用到自己的应用里</c>

00:02:48.635 --> 00:02:50.304
<c.magenta>提升你的开发体验</c>

00:02:51.104 --> 00:02:54.508
<c.magenta>这些库在我们所有的平台中</c>
<c.magenta>都有广泛应用</c>

00:02:54.575 --> 00:02:57.711
<c.magenta>包括今年新的Swift Auto ARC</c>
<c.magenta>和Swift Open Source</c>

00:02:58.245 --> 00:03:00.214
<c.magenta>我们有Swift Core</c>
<c.magenta>Libs Foundation</c>

00:02:58.245 --> 00:03:00.214
<c.magenta>我们有Swift Core</c>
<c.magenta>Libs Foundation</c>

00:03:00.347 --> 00:03:04.718
<c.magenta>把大部分Foundation</c>
<c.magenta>API移植到其他平台 如Linux</c>

00:03:05.786 --> 00:03:08.322
<c.magenta>这些库的实现经受得住考验</c>

00:03:08.455 --> 00:03:10.724
<c.magenta>其中很多自OS X时代</c>
<c.magenta>就已经存在了</c>

00:03:10.791 --> 00:03:12.159
<c.magenta>有些甚可追溯到更久远</c>

00:03:13.794 --> 00:03:16.430
<c.magenta>得益于Cocoa命名指引</c>
<c.magenta>它们还带来了</c>

00:03:16.496 --> 00:03:17.998
<c.magenta>一套悠久传统</c>

00:03:18.265 --> 00:03:20.667
<c.magenta>这意味着</c>
<c.magenta>当你看到一套新的API时</c>

00:03:20.934 --> 00:03:24.104
<c.magenta>你马上就能明白</c>
<c.magenta>它的工作原理以及功能</c>

00:03:24.838 --> 00:03:26.273
<c.magenta>最后重要的一点是</c>

00:03:26.340 --> 00:03:29.142
<c.magenta>这些库在不断更新中</c>

00:03:29.443 --> 00:03:31.311
<c.magenta>除了添加新的特性</c>

00:03:31.378 --> 00:03:34.848
<c.magenta>我们还在改进 修复漏洞 等等</c>

00:03:35.048 --> 00:03:38.752
<c.magenta>每年发布新系统</c>
<c.magenta>我们都会继续这样做</c>

00:03:40.120 --> 00:03:42.589
<c.magenta>另一方面 Swift语言</c>

00:03:42.656 --> 00:03:45.459
<c.magenta>带来了一些</c>
<c.magenta>Objective-C所没有的特性</c>

00:03:45.826 --> 00:03:47.895
<c.magenta>比如 对泛型的第一类支持</c>

00:03:48.462 --> 00:03:50.297
<c.magenta>以及内置的对可变类型的支持</c>

00:03:50.364 --> 00:03:52.666
<c.magenta>这些都是Swift语言</c>
<c.magenta>安全性的重要部分</c>

00:03:53.901 --> 00:03:55.669
<c.magenta>其中包括协议扩展</c>

00:03:55.736 --> 00:03:58.172
<c.magenta>函数重载 以及默认参数值</c>

00:03:58.438 --> 00:04:01.842
<c.magenta>这些都对如何设计Swift的API</c>
<c.magenta>有着重要的影响</c>

00:03:58.438 --> 00:04:01.842
<c.magenta>这些都对如何设计Swift的API</c>
<c.magenta>有着重要的影响</c>

00:04:03.043 --> 00:04:05.879
<c.magenta>这个清单两边都没有列全</c>
<c.magenta>我没有足够空间</c>

00:04:05.946 --> 00:04:07.314
<c.magenta>可以提到的还有很多</c>

00:04:07.814 --> 00:04:12.219
<c.magenta>所以我们提炼了三份关键文档</c>

00:04:12.586 --> 00:04:16.089
<c.magenta>第一份是SE-0023</c>
<c.magenta>API设计指引</c>

00:04:16.156 --> 00:04:20.027
<c.magenta>所有文档都发送到了Swift</c>
<c.magenta>Evolution邮件列表</c>

00:04:20.093 --> 00:04:22.262
<c.magenta>给你和Swift社区</c>

00:04:22.329 --> 00:04:25.666
<c.magenta>一个机会</c>
<c.magenta>参与到语言的设计和进化中</c>

00:04:26.233 --> 00:04:28.735
<c.magenta>我们把这些指引</c>
<c.magenta>视作统一的文档</c>

00:04:28.802 --> 00:04:30.804
<c.magenta>无论是现在还是将来的Swift库</c>

00:04:31.205 --> 00:04:32.773
<c.magenta>此外我们还有SE-0006</c>

00:04:32.840 --> 00:04:35.576
<c.magenta>将这些设计指引</c>
<c.magenta>用于标准库</c>

00:04:35.642 --> 00:04:38.145
<c.magenta>提供了一套</c>
<c.magenta>一致且可预测的原语集</c>

00:04:38.212 --> 00:04:41.315
<c.magenta>我们可以把它们作为基础</c>
<c.magenta>还有SE-0005</c>

00:04:41.648 --> 00:04:44.785
<c.magenta>它大幅提升了Cocoa SDK</c>
<c.magenta>的表达性</c>

00:04:45.052 --> 00:04:47.154
<c.magenta>通过引入默认参数值</c>

00:04:47.221 --> 00:04:49.389
<c.magenta>改进可选集以及编译属性</c>

00:04:49.456 --> 00:04:51.892
<c.magenta>甚至在一些情况下自动采用协议</c>

00:04:54.661 --> 00:04:55.796
<c.magenta>有一期关于此的演讲</c>

00:04:55.863 --> 00:04:58.065
<c.magenta>你如果没看过的话</c>
<c.magenta>建议你去看看</c>

00:04:58.131 --> 00:05:00.033
<c.magenta>Swift API设计指引</c>

00:04:58.131 --> 00:05:00.033
<c.magenta>Swift API设计指引</c>

00:05:02.369 --> 00:05:06.640
<c.magenta>这些已经算得上巨大的进步</c>
<c.magenta>但我们知道 还可以更进一步</c>

00:05:07.140 --> 00:05:09.776
<c.magenta>因为Swift的目标</c>
<c.magenta>不止于其名</c>

00:05:11.311 --> 00:05:14.882
<c.magenta>可变性是这门语言</c>
<c.magenta>至关重要的一部分</c>

00:05:15.549 --> 00:05:18.485
<c.magenta>所以我们把目光</c>
<c.magenta>聚焦于Foundation</c>

00:05:19.953 --> 00:05:22.022
<c.magenta>若你在想</c>
<c.magenta>为何选择Foundation？</c>

00:05:22.589 --> 00:05:24.658
<c.magenta>答案是它比较特别</c>

00:05:24.725 --> 00:05:26.827
<c.magenta>我这么说</c>
<c.magenta>不是因为我的工作是关于它的</c>

00:05:27.427 --> 00:05:30.664
<c.magenta>Foundation在SDK中</c>
<c.magenta>处于一个特别的位置</c>

00:05:30.797 --> 00:05:32.766
<c.magenta>它的层级足够低</c>

00:05:32.833 --> 00:05:35.602
<c.magenta>适用于任何我提到过的平台</c>

00:05:36.203 --> 00:05:38.539
<c.magenta>但与此同时</c>
<c.magenta>它的层级又足够高</c>

00:05:38.872 --> 00:05:42.476
<c.magenta>足以建立一整套</c>
<c.magenta>通用类型和设计模式</c>

00:05:42.543 --> 00:05:45.279
<c.magenta>同样你会发现</c>
<c.magenta>它会反映到整个SDK</c>

00:05:45.913 --> 00:05:49.816
<c.magenta>我们回顾一下刚才的图片</c>
<c.magenta>放大这里的Cocoa SDK</c>

00:05:49.883 --> 00:05:53.520
<c.magenta>你会发现很多</c>
<c.magenta>应用的日常开发中用到的框架</c>

00:05:53.587 --> 00:05:56.924
<c.magenta>从UIKit到SpriteKit</c>
<c.magenta>从WatchKit到CoreData</c>

00:05:56.990 --> 00:05:59.560
<c.magenta>还有很多其它不适合放于此的</c>
<c.magenta>Cores和Kits</c>

00:06:00.394 --> 00:06:02.062
<c.magenta>有趣之处在于</c>

00:06:02.129 --> 00:06:04.665
<c.magenta>所有这些都建立在</c>
<c.magenta>Foundation的基础上</c>

00:06:05.599 --> 00:06:07.701
<c.magenta>因此将Foundation</c>
<c.magnenta>视作一杠杆点</c>

00:06:08.635 --> 00:06:11.772
<c.magenta>在Foundation里的</c>
<c.magenta>一小点改动</c>

00:06:12.005 --> 00:06:15.209
<c.magenta>会对整个SDK产生巨大的影响</c>

00:06:16.476 --> 00:06:20.547
<c.magenta>一定程度上由于很多数值类型</c>
<c.magenta>出自Foundation</c>

00:06:21.481 --> 00:06:25.485
<c.magenta>所以我们注重</c>
<c.magenta>进化胜过彻底改变这一观点</c>

00:06:25.853 --> 00:06:29.489
<c.magenta>我们看到了标准库</c>
<c.magenta>为你的应用开发带来的所有东西</c>

00:06:29.590 --> 00:06:32.693
<c.magenta>我们不会因为新语言</c>
<c.magenta>而摒弃已有的一切</c>

00:06:32.926 --> 00:06:37.097
<c.magenta>我们做的是</c>
<c.magenta>让语言和库更加紧密</c>

00:06:37.164 --> 00:06:39.166
<c.magenta>通过同时改进双方</c>

00:06:39.700 --> 00:06:43.704
<c.magenta>我们今天谈论的</c>
<c.magenta>正是这一过程的延续</c>

00:06:45.739 --> 00:06:47.975
<c.magenta>把这一点放在心上</c>
<c.magenta>Foundation团队</c>

00:06:48.041 --> 00:06:50.878
<c.magenta>在Swift Evolution</c>
<c.magenta>邮件列表提出了两个新的提议</c>

00:06:51.178 --> 00:06:53.814
<c.magenta>第一个是Foundation中</c>
<c.magenta>数值类型的可变性</c>

00:06:54.114 --> 00:06:56.583
<c.magenta>把Swift的可变性模型</c>

00:06:56.650 --> 00:06:57.985
<c.magenta>应用到Foundation框架上</c>

00:06:59.720 --> 00:07:02.923
<c.magenta>另一个是抛弃Swift</c>
<c.magenta>Foundation里的NS前缀</c>

00:06:59.720 --> 00:07:02.923
<c.magenta>另一个是抛弃Swift</c>
<c.magenta>Foundation里的NS前缀</c>

00:07:03.190 --> 00:07:06.193
<c.magenta>为Swift建立通用类型和设计模式</c>

00:07:06.260 --> 00:07:08.729
<c.magenta>以适用于任何平台</c>

00:07:12.099 --> 00:07:15.536
<c.magenta>这是我们今年对API</c>
<c.magenta>做的一些改进的概述</c>

00:07:15.836 --> 00:07:17.838
<c.magenta>第一点最重要的是数值语义</c>

00:07:17.905 --> 00:07:20.908
<c.magenta>一套全新的数值类型</c>
<c.magenta>在整个SDK随处可见</c>

00:07:21.375 --> 00:07:23.911
<c.magenta>此外我们对命名进行了些改进</c>

00:07:23.977 --> 00:07:26.980
<c.magenta>超越了Objective-C</c>
<c.magenta>翻译成Swift能做到的</c>

00:07:27.514 --> 00:07:30.317
<c.magenta>我们让这些类型</c>
<c.magenta>采用了很多标准库协议</c>

00:07:30.384 --> 00:07:34.121
<c.magenta>这意味着你的通用算法</c>
<c.magenta>现在同样适用于Foundation类型</c>

00:07:34.688 --> 00:07:38.525
<c.magenta>我们额外添加了类型安全性</c>
<c.magenta>以及很多针对Swift的新特性</c>

00:07:41.228 --> 00:07:43.130
<c.magenta>我们来快速浏览一下数值类型</c>

00:07:44.498 --> 00:07:46.633
<c.magenta>数值类型和引用类型不同</c>

00:07:46.700 --> 00:07:50.437
<c.magenta>主要区别于复制时的行为</c>

00:07:50.504 --> 00:07:54.474
<c.magenta>数值类型在赋值或作为参数传递时</c>
<c.magenta>会复制它们的内容</c>

00:07:54.575 --> 00:07:56.476
<c.magenta>举个简单例子</c>
<c.magenta>我有一个点</c>

00:07:57.010 --> 00:08:00.447
<c.magenta>我用等号</c>
<c.magenta>把这个点赋值给另一个点</c>

00:07:57.010 --> 00:08:00.447
<c.magenta>我用等号</c>
<c.magenta>把这个点赋值给另一个点</c>

00:08:00.514 --> 00:08:03.851
<c.magenta>当我修改第二个点的时候</c>
<c.magenta>你可以看到 只有副本改变了</c>

00:08:03.917 --> 00:08:08.155
<c.magenta>我没有影响两个点的内容</c>
<c.magenta>因为CGPoint是数值类型</c>

00:08:09.156 --> 00:08:12.326
<c.magenta>另一方面</c>
<c.magenta>引用类型默认共享内容</c>

00:08:12.759 --> 00:08:16.330
<c.magenta>这里我用引用类型创建些数据</c>
<c.magenta>它们是可变数据</c>

00:08:16.763 --> 00:08:20.567
<c.magenta>同样用等号</c>
<c.magenta>把data赋值给otherData</c>

00:08:21.101 --> 00:08:23.704
<c.magenta>然而这一次</c>
<c.magenta>当我修改第二个数据的时候</c>

00:08:24.004 --> 00:08:26.073
<c.magenta>你会发现</c>
<c.magenta>它影响到了两个数据的内容</c>

00:08:27.341 --> 00:08:30.744
<c.magenta>重要的是要理解</c>
<c.magenta>这两者没有好坏之分</c>

00:08:30.811 --> 00:08:32.412
<c.magenta>只是使用方式不同</c>

00:08:33.212 --> 00:08:36.517
<c.magenta>我喜欢把它们看做</c>
<c.magenta>工具箱中的不同工具</c>

00:08:36.582 --> 00:08:39.052
<c.magenta>当你需要解决某个问题时</c>
<c.magenta>可以使用它们</c>

00:08:41.288 --> 00:08:43.423
<c.magenta>所以当你试着决定</c>

00:08:43.924 --> 00:08:46.193
<c.magenta>你的类型是数值类型还是引用类型</c>

00:08:46.860 --> 00:08:49.830
<c.magenta>你应该从对象身份和存储内容考虑</c>

00:08:50.597 --> 00:08:52.566
<c.magenta>我举几个例子来解释</c>

00:08:54.001 --> 00:08:57.037
<c.magenta>Foundation中有个叫</c>
<c.magenta>OperationQueue的类</c>

00:08:57.304 --> 00:09:00.307
<c.magenta>OperationQueue中有一个单例</c>
<c.magenta>叫main OperationQueue</c>

00:08:57.304 --> 00:09:00.307
<c.magenta>OperationQueue中有一个单例</c>
<c.magenta>叫main OperationQueue</c>

00:09:01.308 --> 00:09:03.310
<c.magenta>这个main</c>
<c.magenta>OperationQueue</c>

00:09:03.377 --> 00:09:05.946
<c.magenta>用于放置</c>
<c.magenta>你希望在主线程上完成的工作</c>

00:09:06.013 --> 00:09:09.116
<c.magenta>所以它只有一个</c>
<c.magenta>这一定程度上代表了身份</c>

00:09:09.383 --> 00:09:13.453
<c.magenta>若我能复制main OperationQueue</c>
<c.magenta>它就不再是主队列了</c>

00:09:13.954 --> 00:09:17.357
<c.magenta>所以我们相信OperationQueue</c>
<c.magenta>是一个引用类型</c>

00:09:18.592 --> 00:09:22.396
<c.magenta>另一个例子 Cocoa SDK里</c>
<c.magenta>随处可见的一种模式就是代理</c>

00:09:23.096 --> 00:09:26.366
<c.magenta>这是一个代理</c>
<c.magenta>或者说是URLSession的代理之一</c>

00:09:26.433 --> 00:09:30.237
<c.magenta>你会发现这个代理协议</c>
<c.magenta>有一个参数 就在这儿</c>

00:09:30.304 --> 00:09:34.908
<c.magenta>名叫Session</c>
<c.magenta>它告诉被委托的对象</c>

00:09:34.975 --> 00:09:37.377
<c.magenta>它将以哪个URLSession的名义工作</c>

00:09:37.845 --> 00:09:42.816
<c.magenta>这里的哪个URLSession</c>
<c.magenta>同样暗示了身份</c>

00:09:43.150 --> 00:09:47.054
<c.magenta>所以我们相信代理使用的类型</c>
<c.magenta>通常是引用类型</c>

00:09:48.989 --> 00:09:52.192
<c.magenta>从另一方面 很多类型的重点</c>
<c.magenta>在于它们存储的内容</c>

00:09:52.259 --> 00:09:53.560
<c.magenta>比如Date</c>

00:09:53.627 --> 00:09:55.729
<c.magenta>这是我们新Foundation</c>
<c.magenta>数值类型之一</c>

00:09:56.396 --> 00:09:57.898
<c.magenta>Date是一个绝对的时间点</c>

00:09:58.532 --> 00:10:01.301
<c.magenta>我们可以有两个具有相同值的Date</c>

00:09:58.532 --> 00:10:01.301
<c.magenta>我们可以有两个具有相同值的Date</c>

00:10:01.368 --> 00:10:04.538
<c.magenta>同样的绝对时间点</c>
<c.magenta>它们是同一个Date</c>

00:10:04.605 --> 00:10:07.508
<c.magenta>我们不需要讨论那个时间点的引用</c>

00:10:07.574 --> 00:10:09.710
<c.magenta>如果我们查看Date的实现</c>

00:10:09.776 --> 00:10:11.879
<c.magenta>正如你所见</c>
<c.magenta>其实它只是个Double</c>

00:10:12.312 --> 00:10:15.916
<c.magenta>Double我们可以本能地认为</c>
<c.magenta>是一个数值类型</c>

00:10:17.050 --> 00:10:18.519
<c.magenta>另一个例子就是Data</c>

00:10:18.952 --> 00:10:21.555
<c.magenta>Data是另一个</c>
<c.magenta>新的Foundation数值类型</c>

00:10:22.055 --> 00:10:24.992
<c.magenta>Data 通常情况下</c>
<c.magenta>你关心的是Data的内容</c>

00:10:25.125 --> 00:10:28.395
<c.magenta>它所包含的字节</c>
<c.magenta>而不是NSData对象</c>

00:10:28.495 --> 00:10:31.765
<c.magenta>所以Foundation</c>
<c.magenta>把Date设为数值类型</c>

00:10:34.101 --> 00:10:36.970
<c.magenta>每次我们把它作为参数传递时</c>
<c.magenta>都需要复制数据</c>

00:10:37.037 --> 00:10:38.772
<c.magenta>很快开销会变得很大</c>

00:10:39.006 --> 00:10:41.675
<c.magenta>所以我们进行了一种优化</c>
<c.magenta>叫做写时复制</c>

00:10:42.476 --> 00:10:44.178
<c.magenta>这里我建立了一些数据</c>

00:10:44.845 --> 00:10:46.580
<c.magenta>看到我建立了一个Struct</c>

00:10:46.647 --> 00:10:48.849
<c.magenta>但是在它内部</c>
<c.magenta>还有一个引用</c>

00:10:48.916 --> 00:10:51.885
<c.magenta>又一个合作提高效率的例子</c>

00:10:51.952 --> 00:10:54.154
<c.magenta>我同时使用了引用和数值</c>

00:10:54.221 --> 00:10:56.156
<c.magenta>来得到我想要的性能特征</c>

00:10:56.223 --> 00:10:58.992
<c.magenta>以及重要的数值语义</c>

00:10:59.960 --> 00:11:04.064
<c.magenta>如果我用等号</c>
<c.magenta>把这个数据赋值给另一个数据</c>

00:10:59.960 --> 00:11:04.064
<c.magenta>如果我用等号</c>
<c.magenta>把这个数据赋值给另一个数据</c>

00:11:04.131 --> 00:11:06.733
<c.magenta>你会发现我得到了另一个Struct</c>

00:11:06.800 --> 00:11:09.469
<c.magenta>但其实在内部</c>
<c.magenta>它们还是指向同一个类</c>

00:11:10.103 --> 00:11:14.241
<c.magenta>但是如果我修改这个数据</c>
<c.magenta>那我们就需要复制数据了</c>

00:11:14.408 --> 00:11:17.544
<c.magenta>修改副本</c>
<c.magenta>我们就有了两个独立的Data</c>

00:11:18.812 --> 00:11:20.681
<c.magenta>如果我继续修改第二个数据</c>

00:11:20.914 --> 00:11:23.617
<c.magenta>我们可以断定</c>
<c.magenta>Data各有独自的引用</c>

00:11:23.684 --> 00:11:25.352
<c.magenta>而我们也不需要每次都去复制它</c>

00:11:25.953 --> 00:11:29.256
<c.magenta>这是一种扩展 或者说</c>
<c.magenta>其实就是同样技术的另一种使用方式</c>

00:11:29.323 --> 00:11:32.226
<c.magenta>这个技术我们以前谈论过</c>
<c.magenta>包括去年谈到的</c>

00:11:32.292 --> 00:11:34.328
<c.magenta>在Swift里构建更好的</c>
<c.magenta>应用和值类型</c>

00:11:34.394 --> 00:11:37.464
<c.magenta>如果你想了解更多它的工作原理</c>
<c.magenta>可以去看看</c>

00:11:38.632 --> 00:11:41.435
<c.magenta>所以我们调查了</c>
<c.magenta>Foundation里每一个API</c>

00:11:41.602 --> 00:11:45.239
<c.magenta>总结出了这份列表</c>
<c.magenta>我们认为它们作为数值类型很棒</c>

00:11:45.639 --> 00:11:49.610
<c.magenta>你会很高兴看到</c>
<c.magenta>很多你平时使用的类型都在列表上</c>

00:11:49.877 --> 00:11:52.012
<c.magenta>包括我刚刚提到的Data和Date</c>

00:11:52.279 --> 00:11:54.815
<c.magenta>还有很多别的常用类型</c>
<c.magenta>比如URL</c>

00:11:55.115 --> 00:11:58.018
<c.magenta>IndexPath</c>
<c.magenta>CharacterSet 等等</c>

00:11:58.285 --> 00:12:00.454
<c.magenta>它们当中很多不只是变成了数据类型</c>

00:11:58.285 --> 00:12:00.454
<c.magenta>它们当中很多不只是变成了数据类型</c>

00:12:00.654 --> 00:12:03.223
<c.magenta>还增加了很多很棒的新API</c>

00:12:05.425 --> 00:12:08.629
<c.magenta>为了让你们了解它们是什么样的</c>
<c.magenta>我想有请Michael上台</c>

00:12:14.201 --> 00:12:15.102
<c.magenta>谢谢你 Tony</c>

00:12:15.636 --> 00:12:19.072
<c.magenta>咱们先看看</c>
<c.magenta>Foundation枚举类型的新家</c>

00:12:20.240 --> 00:12:21.909
<c.magenta>Objective-C里的枚举</c>

00:12:21.975 --> 00:12:24.144
<c.magenta>以及选项集合</c>
<c.magenta>生存在全局命名空间里</c>

00:12:24.211 --> 00:12:25.946
<c.magenta>和使用它们的类型在一起</c>

00:12:26.113 --> 00:12:30.083
<c.magenta>比如NSNumberFormatter</c>
<c.magenta>定义了四个枚举</c>

00:12:30.184 --> 00:12:33.720
<c.magenta>包括样式、行为、填充位置以及舍入模式</c>

00:12:34.354 --> 00:12:37.324
<c.magenta>它们和NumberFormatter</c>
<c.magenta>有一定暗中的联系</c>

00:12:37.391 --> 00:12:39.760
<c.magenta>通过严格一致的命名传统</c>

00:12:39.960 --> 00:12:43.597
<c.magenta>在Swift 2中 你也知道</c>
<c.magenta>它们同样在全局命名空间里</c>

00:12:45.065 --> 00:12:46.934
<c.magenta>但这就感觉不像是纯粹的Swift</c>

00:12:47.467 --> 00:12:49.336
<c.magenta>Swift支持嵌套类型</c>

00:12:49.903 --> 00:12:53.173
<c.magenta>所以在Swift 3里</c>
<c.magenta>我们决定改变这些类型的位置</c>

00:12:53.807 --> 00:12:56.443
<c.magenta>在它们注定应该在的地方</c>
<c.magenta>进行声明</c>

00:12:56.510 --> 00:12:58.946
<c.magenta>现在NumberFormatter</c>
<c.magenta>拥有内置的样式</c>

00:12:59.012 --> 00:13:00.848
<c.magenta>行为、填充位置以及舍入模式类型</c>

00:12:59.012 --> 00:13:00.848
<c.magenta>行为、填充位置以及舍入模式类型</c>

00:13:00.914 --> 00:13:02.850
<c.magenta>它们的名字不再繁冗</c>

00:13:03.784 --> 00:13:05.719
<c.magenta>这极大程度减少了</c>

00:13:05.786 --> 00:13:08.255
<c.magenta>Foundation在顶级命名空间</c>
<c.magenta>声明的类型数量</c>

00:13:08.522 --> 00:13:10.524
<c.magenta>关系也更加明确</c>

00:13:10.591 --> 00:13:12.993
<c.magenta>我们的API表达性变得更强</c>
<c.magenta>更易被发现</c>

00:13:14.528 --> 00:13:16.830
<c.magenta>还是关于枚举这个主题</c>

00:13:17.164 --> 00:13:20.868
<c.magenta>很多Foundation API</c>
<c.magenta>也使用字符串常量家族</c>

00:13:20.968 --> 00:13:24.671
<c.magenta>比如Notification Name</c>
<c.magenta>和URL Resource Key</c>

00:13:25.472 --> 00:13:30.377
<c.magenta>Swift支持建立在</c>
<c.magenta>其它原始类型上的枚举类型</c>

00:13:30.444 --> 00:13:33.413
<c.magenta>可以是整型以外的类型</c>
<c.magenta>包括字符串类型</c>

00:13:33.847 --> 00:13:36.750
<c.magenta>若我们在Objective-C里</c>
<c.magenta>也能做到这些岂不更妙？</c>

00:13:37.317 --> 00:13:40.087
<c.magenta>今年 我们可以了</c>
<c.magenta>常量现在被定义成了</c>

00:13:40.153 --> 00:13:42.823
<c.magenta>类型非常具体的字符串常量</c>

00:13:42.956 --> 00:13:46.326
<c.magenta>如Notification Name</c>
<c.magenta>及URL Resource Key</c>

00:13:46.727 --> 00:13:47.794
<c.magenta>以及很多很多别的</c>

00:13:49.630 --> 00:13:53.867
<c.magenta>这些常量保留了可扩展性</c>
<c.magenta>无论在Objective-C里</c>

00:13:54.501 --> 00:13:56.537
<c.magenta>还是在Swift里</c>

00:13:56.603 --> 00:14:02.476
<c.magenta>我们都可以对它们进行嵌套</c>
<c.magenta>就像对待它们的兄弟整数类型一样</c>

00:13:56.603 --> 00:14:02.476
<c.magenta>我们都可以对它们进行嵌套</c>
<c.magenta>就像对待它们的兄弟整数类型一样</c>

00:14:03.277 --> 00:14:06.213
<c.magenta>这样在Swift 3中使用它们</c>
<c.magenta>非常自然 表达性也很强</c>

00:14:06.813 --> 00:14:10.918
<c.magenta>另一个常见的Foundation</c>
<c.magenta>设计模式是把状态和类型联系起来</c>

00:14:11.185 --> 00:14:14.087
<c.magenta>比如standardUserDefaults</c>

00:14:14.821 --> 00:14:19.560
<c.magenta>Swift对于类属性的支持</c>
<c.magenta>可以很好地适用于这里</c>

00:14:20.694 --> 00:14:24.264
<c.magenta>今年我们把类属性</c>
<c.magenta>引入了Objective-C</c>

00:14:24.331 --> 00:14:26.633
<c.magenta>它们的定义和对象属性一样</c>

00:14:26.700 --> 00:14:29.469
<c.magenta>除了现在我们支持这个</c>
<c.magenta>酷酷的类别关键词</c>

00:14:29.736 --> 00:14:33.273
<c.magenta>由于我们知道它是类属性</c>

00:14:33.340 --> 00:14:36.543
<c.magenta>我们不需再像Swift 2.2那样</c>
<c.magenta>把它作为函数引入</c>

00:14:36.643 --> 00:14:39.646
<c.magenta>它现在可以作为类属性出现</c>

00:14:39.713 --> 00:14:42.449
<c.magenta>如同你会在Swift里定义一样</c>

00:14:43.584 --> 00:14:44.885
<c.magenta>但我们没有止步于此</c>

00:14:46.019 --> 00:14:48.155
<c.magenta>有些累赘的词</c>
<c.magenta>在Swift 3中</c>

00:14:48.222 --> 00:14:50.791
<c.magenta>我们彻底修改了</c>
<c.magenta>Swift代码的显示方式</c>

00:14:50.858 --> 00:14:53.093
<c.magenta>以及Swift里</c>
<c.magenta>Objective-C代码的显示方式</c>

00:14:53.393 --> 00:14:56.597
<c.magenta>所以我们的最终API更像这个</c>

00:14:57.164 --> 00:15:00.033
<c.magenta>我们知道它是userDefault</c>
<c.magenta>通过帮助把Foundation</c>

00:14:57.164 --> 00:15:00.033
<c.magenta>我们知道它是userDefault</c>
<c.magenta>通过帮助把Foundation</c>

00:15:00.100 --> 00:15:02.236
<c.magenta>变得更像Swift</c>
<c.magenta>我们获取了很多好处</c>

00:15:02.302 --> 00:15:04.304
<c.magenta>无论是对于Objective-C</c>
<c.magenta>还是Swift</c>

00:15:06.273 --> 00:15:09.943
<c.magenta>Tony刚才说很多Foundation</c>
<c.magenta>类型值得变成数值类型</c>

00:15:10.010 --> 00:15:12.546
<c.magenta>我谈谈其中的一些</c>
<c.magenta>我们从Date说起</c>

00:15:14.281 --> 00:15:16.316
<c.magenta>假设我们要安排一条备忘录</c>

00:15:16.383 --> 00:15:17.784
<c.magenta>提醒我们什么时候该回家</c>

00:15:17.851 --> 00:15:21.355
<c.magenta>我们从Swift 2.2开始</c>
<c.magenta>引出我们的例子</c>

00:15:21.555 --> 00:15:25.025
<c.magenta>假设我们有一个函数</c>
<c.magenta>它会告诉我们什么时候应该回家</c>

00:15:25.092 --> 00:15:29.963
<c.magenta>我们调用它</c>
<c.magenta>五分钟看起来正适合我们的提醒</c>

00:15:30.030 --> 00:15:32.633
<c.magenta>我们继续 你知道的</c>
<c.magenta>把它偏移一点</c>

00:15:33.200 --> 00:15:37.538
<c.magenta>有一点值得说明 NSDate</c>
<c.magenta>是且一直会是一个引用类型</c>

00:15:37.604 --> 00:15:41.375
<c.magenta>所以在这里</c>
<c.magenta>实际隐藏着两个动态分配</c>

00:15:41.842 --> 00:15:43.777
<c.magenta>一个在这里</c>
<c.magenta>另一个在这里</c>

00:15:45.412 --> 00:15:48.215
<c.magenta>在Swift 3里</c>
<c.magenta>我们可以使用Date数值类型</c>

00:15:49.249 --> 00:15:53.086
<c.magenta>所以现在我们就来使用它</c>
<c.magenta>用法和原来类似</c>

00:15:53.153 --> 00:15:56.490
<c.magenta>但是这个变量的行为</c>
<c.magenta>和以前大不相同</c>

00:15:56.890 --> 00:15:59.493
<c.magenta>特别地 我们允许内联修改</c>

00:16:00.460 --> 00:16:01.562
<c.magenta>我们没做额外的事情</c>

00:16:02.196 --> 00:16:04.565
<c.magenta>这两个例子做的是一样的事</c>

00:16:04.631 --> 00:16:09.203
<c.magenta>除了对于数值类型</c>
<c.magenta>我们不需要额外进行动态分配</c>

00:16:09.436 --> 00:16:10.737
<c.magenta>继续我们的例子</c>

00:16:11.071 --> 00:16:13.073
<c.magenta>当然了</c>
<c.magenta>我们也可以这样内联</c>

00:16:15.075 --> 00:16:17.277
<c.magenta>关于提醒事项</c>
<c.magenta>只有把它安排在事情发生前</c>

00:16:17.344 --> 00:16:19.513
<c.magenta>才是有意义的</c>

00:16:20.080 --> 00:16:22.416
<c.magenta>Swift带来的最棒的是</c>

00:16:22.482 --> 00:16:28.255
<c.magenta>满足某些条件时</c>
<c.magenta>协议会自动被采用</c>

00:16:28.322 --> 00:16:31.625
<c.magenta>在这个例子里Date自动遵从了</c>
<c.magenta>Comparable协议</c>

00:16:31.692 --> 00:16:35.863
<c.magenta>它赋予了我们使用小于号的能力</c>
<c.magenta>我们现在就在使用</c>

00:16:36.797 --> 00:16:39.399
<c.magenta>我们可以设定定时器</c>
<c.magenta>但首先我们要创建它</c>

00:16:39.466 --> 00:16:42.035
<c.magenta>我们要使用另一个今年的新API</c>

00:16:42.336 --> 00:16:45.973
<c.magenta>就是这个看起来很棒的</c>
<c.magenta>基于闭包的定时器API</c>

00:16:46.306 --> 00:16:48.308
<c.magenta>我们用一个闭包初始化定时器</c>

00:16:48.375 --> 00:16:50.577
<c.magenta>不再需要selector</c>
<c.magenta>和target了</c>

00:16:51.712 --> 00:16:53.580
<c.magenta>我们把它安排在主RunLoop上</c>

00:16:59.052 --> 00:17:03.056
<c.magenta>我相信线程和RunLoop</c>
<c.magenta>也有这样的方法</c>

00:16:59.052 --> 00:17:03.056
<c.magenta>我相信线程和RunLoop</c>
<c.magenta>也有这样的方法</c>

00:17:03.123 --> 00:17:05.559
<c.magenta>把它安排在主RunLoop上</c>
<c.magenta>然后就完成了</c>

00:17:06.460 --> 00:17:09.730
<c.magenta>这是个绝佳的例子 它展示了所有熟悉的</c>
<c.magenta>Foundation API是如何</c>

00:17:09.796 --> 00:17:12.266
<c.magenta>如此优雅地</c>
<c.magenta>移植到Swift 3里的</c>

00:17:12.799 --> 00:17:16.069
<c.magenta>这是我能在演示里展示的最具</c>
<c.magenta>Foundation特色的代码</c>

00:17:16.136 --> 00:17:18.137
<c.magenta>我有个RunLoop</c>
<c.magenta>一个定时器及几个日期</c>

00:17:18.204 --> 00:17:21.808
<c.magenta>基本上全是Foundation的内容</c>
<c.magenta>极少的其他内容</c>

00:17:22.108 --> 00:17:23.977
<c.magenta>看不到任何方括号</c>

00:17:25.612 --> 00:17:28.782
<c.magenta>另一个新例子</c>
<c.magenta>或说Fondation里另一新类型</c>

00:17:28.849 --> 00:17:30.350
<c.magenta>Measurement数值类型</c>

00:17:31.318 --> 00:17:34.788
<c.magenta>假设一个新例子</c>
<c.magenta>我们关心上下班线路有多长</c>

00:17:34.855 --> 00:17:37.791
<c.magenta>而且我们很幸运</c>
<c.magenta>我们住的地方距离上班的地方</c>

00:17:37.858 --> 00:17:38.692
<c.magenta>只有两条短街之隔</c>

00:17:39.326 --> 00:17:43.063
<c.magenta>Measurement是数值类型</c>
<c.magenta>并且Swift支持运算符重载</c>

00:17:43.330 --> 00:17:44.932
<c.magenta>它们不仅仅是数值类型</c>

00:17:44.998 --> 00:17:50.838
<c.magenta>它们还是Mathematical类型</c>
<c.magenta>所以给它们设置运算符有实际意义</c>

00:17:51.405 --> 00:17:54.474
<c.magenta>没人会轻视它或不待见它</c>

00:17:54.541 --> 00:17:56.977
<c.magenta>如果我们考虑把它们加起来</c>

00:17:57.044 --> 00:18:00.547
<c.magenta>我们就可以计算出它们的总和</c>
<c.magenta>甚至对它们进行转换</c>

00:17:57.044 --> 00:18:00.547
<c.magenta>我们就可以计算出它们的总和</c>
<c.magenta>甚至对它们进行转换</c>

00:18:00.614 --> 00:18:01.815
<c.magenta>转换成另一个单位</c>

00:18:02.049 --> 00:18:05.285
<c.magenta>假设我们很好奇</c>
<c.magenta>想知道去工作路上要花费多久</c>

00:18:05.552 --> 00:18:06.920
<c.magenta>这个我们也能做到</c>

00:18:07.287 --> 00:18:10.190
<c.magenta>只是在Swift 3里</c>
<c.magenta>如果我们试着编译这段代码</c>

00:18:10.257 --> 00:18:12.960
<c.magenta>它会失败的</c>
<c.magenta>而且是在编译的时候失败</c>

00:18:13.026 --> 00:18:16.563
<c.magenta>得益于Swfit 3中</c>
<c.magenta>泛型和类型限制的能力</c>

00:18:17.030 --> 00:18:20.267
<c.magenta>我们设计成</c>
<c.magenta>让单位的区别</c>

00:18:20.334 --> 00:18:21.869
<c.magenta>在编译的时候就可以看出来</c>

00:18:22.002 --> 00:18:24.004
<c.magenta>Swift编译器可检测出</c>
<c.magenta>然后提醒我们</c>

00:18:24.071 --> 00:18:26.173
<c.magenta>我们正在进行无效转换</c>

00:18:26.707 --> 00:18:30.210
<c.magenta>想了解更多Measurement类</c>
<c.magenta>单位以及今年新引入类型的</c>

00:18:30.277 --> 00:18:33.180
<c.magenta>整个新的生态系统的话</c>
<c.magenta>记得去收听这场演讲</c>

00:18:33.247 --> 00:18:37.017
<c.magenta>在周五下午 了解更多</c>
<c.magenta>Measurements和单位</c>

00:18:38.118 --> 00:18:39.953
<c.magenta>换一个例子</c>

00:18:41.488 --> 00:18:43.390
<c.magenta>我说过这将是一场探索</c>

00:18:43.991 --> 00:18:45.692
<c.magenta>假设我们想买几台MacBook</c>

00:18:45.826 --> 00:18:48.161
<c.magenta>会使用新</c>
<c.magenta>URLComponent数值类型</c>

00:18:48.896 --> 00:18:50.564
<c.magenta>可以表达性很强地做到</c>

00:18:51.198 --> 00:18:53.300
<c.magenta>从描述可变部分开始</c>

00:18:53.367 --> 00:18:55.569
<c.magenta>把它作为下面的模板</c>

00:18:55.802 --> 00:18:58.572
<c.magenta>遍历我们想要购买的产品</c>

00:19:00.140 --> 00:19:03.844
<c.magenta>复制我们的模板</c>
<c.magenta>然后修改这个副本</c>

00:19:03.911 --> 00:19:06.213
<c.magenta>指定我们想要买的产品</c>

00:19:06.980 --> 00:19:09.783
<c.magenta>在这里</c>
<c.magenta>我们可以放心地展开这个可选类型</c>

00:19:10.083 --> 00:19:13.287
<c.magenta>因为在我们的模板里把它设为了非空</c>

00:19:14.421 --> 00:19:18.358
<c.magenta>继续把我们的URL打印出来</c>
<c.magenta>我们发现可以</c>

00:19:20.427 --> 00:19:26.633
<c.magenta>不进行任何内存管理</c>
<c.magenta>创建我们想要购买的产品的链接</c>

00:19:26.967 --> 00:19:30.604
<c.magenta>只需声明我们的意图</c>
<c.magenta>指明是否可变</c>

00:19:30.671 --> 00:19:33.273
<c.magenta>然后语言就会为我们处理好剩下的事</c>

00:19:35.175 --> 00:19:38.979
<c.magenta>Swift 3 或者广泛地说Swift</c>
<c.magenta>带来的另一个特性</c>

00:19:39.046 --> 00:19:42.549
<c.magenta>是ProtocolComponents</c>
<c.magenta>在很多Foundation类型中 比如Date</c>

00:19:42.683 --> 00:19:46.553
<c.magenta>得到了有用的新能力</c>
<c.magenta>这得益于新的遵循协议的方式</c>

00:19:46.653 --> 00:19:51.391
<c.magenta>比如CharacterSet和IndexSet</c>
<c.magenta>现在遵循SetAlgebra协议</c>

00:19:51.458 --> 00:19:54.094
<c.magenta>你可以对它们进行并集</c>
<c.magenta>交集 对称差集操作</c>

00:19:54.161 --> 00:19:55.495
<c.magenta>根据你的需要</c>

00:19:56.463 --> 00:19:59.032
<c.magenta>Data现在遵循</c>
<c.magenta>8位无符号整数的</c>

00:19:59.333 --> 00:20:02.803
<c.magenta>MutableCollection协议和</c>
<c.magenta>MutableRandomAccessCollection协议</c>

00:19:59.333 --> 00:20:02.803
<c.magenta>MutableCollection协议和</c>
<c.magenta>MutableRandomAccessCollection协议</c>

00:20:03.403 --> 00:20:05.339
<c.magenta>就像你一直认为的那样</c>

00:20:06.740 --> 00:20:10.244
<c.magenta>我们来看看遵从新的协议后</c>
<c.magenta>Data现在能做些什么</c>

00:20:11.278 --> 00:20:15.482
<c.magenta>首先需要一些数据</c>
<c.magenta>我手头上有一些Base64数据</c>

00:20:15.549 --> 00:20:17.885
<c.magenta>通过普通的初始化函数</c>
<c.magenta>进行解析</c>

00:20:18.785 --> 00:20:23.690
<c.magenta>这里有个显式展开</c>
<c.magenta>我知道这么做是安全的</c>

00:20:23.757 --> 00:20:27.060
<c.magenta>因为这里只是个演示</c>
<c.magenta>我知道它是有效的Base64值</c>

00:20:28.929 --> 00:20:31.899
<c.magenta>你自己使用过程中</c>
<c.magenta>可能需要用到try语句</c>

00:20:31.965 --> 00:20:36.670
<c.magenta>我喜欢统计</c>
<c.magenta>以及看起来很棒的图表</c>

00:20:36.737 --> 00:20:40.507
<c.magenta>当你的统计用直方图的形式表现时</c>
<c.magenta>我们要来建立一个直方图</c>

00:20:40.574 --> 00:20:43.577
<c.magenta>我们需要用到后台存储</c>
<c.magenta>使用原始的Swift数组</c>

00:20:43.644 --> 00:20:45.012
<c.magenta>把它全都初始化为0</c>

00:20:45.078 --> 00:20:49.783
<c.magenta>我们把data里</c>
<c.magenta>每一字节的值作为索引</c>

00:20:49.850 --> 00:20:51.351
<c.magenta>然后维护一个频率计数</c>

00:20:52.686 --> 00:20:55.489
<c.magenta>由于Data是一个</c>
<c.magenta>Collection 遍历它的字节</c>

00:20:55.556 --> 00:20:58.859
<c.magenta>很自然且表达性高</c>
<c.magenta>我们可通过一个for-in循环做到</c>

00:20:59.560 --> 00:21:02.095
<c.magenta>接着我们创建直方图</c>
<c.magenta>来看一看</c>

00:20:59.560 --> 00:21:02.095
<c.magenta>接着我们创建直方图</c>
<c.magenta>来看一看</c>

00:21:02.963 --> 00:21:04.798
<c.magenta>这看着绝对像直方图</c>

00:21:04.865 --> 00:21:06.967
<c.magenta>就像所有直方图一样</c>
<c.magenta>里面有信号和噪声</c>

00:21:07.034 --> 00:21:09.303
<c.magenta>我在这看到了不少高频率数据</c>

00:21:09.803 --> 00:21:11.471
<c.magenta>我想要把它过滤出去</c>

00:21:11.839 --> 00:21:13.607
<c.magenta>幸运的是</c>
<c.magenta>Data现在是Collection了</c>

00:21:13.674 --> 00:21:16.143
<c.magenta>所以我们可使用到类似Map、</c>
<c.magenta>Reduce、Filter的功能</c>

00:21:16.210 --> 00:21:19.146
<c.magenta>以及其他你喜欢的</c>
<c.magenta>Collection函数</c>

00:21:19.746 --> 00:21:23.517
<c.magenta>假设我们想要剔除</c>
<c.magenta>所有大于三的数据</c>

00:21:23.717 --> 00:21:26.019
<c.magenta>就如同声明谓词一样简单</c>

00:21:26.453 --> 00:21:29.690
<c.magenta>然后我们可以就生成</c>
<c.magenta>过滤后的数据了</c>

00:21:30.991 --> 00:21:33.327
<c.magenta>作为一个Collection</c>
<c.magenta>Data是可切分的</c>

00:21:33.760 --> 00:21:37.197
<c.magenta>这些切片功能上和Mutable</c>
<c.magenta>Collection一样</c>

00:21:37.297 --> 00:21:40.467
<c.magenta>或是你在Swift里见到过的</c>
<c.magenta>数值类型Collection</c>

00:21:41.735 --> 00:21:44.338
<c.magenta>修改它们会触发</c>
<c.magenta>同样的写时复制机制</c>

00:21:44.404 --> 00:21:48.208
<c.magenta>正如Tony刚才描述的</c>
<c.magenta>它们的运行方式完全相同</c>

00:21:49.810 --> 00:21:53.347
<c.magenta>Data还保留了可扩展性</c>

00:21:53.413 --> 00:21:55.082
<c.magenta>通过继承隐含的引用类型</c>

00:21:55.148 --> 00:21:57.651
<c.magenta>这是很重要的一句话</c>
<c.magenta>我会详细讲个例子</c>

00:21:57.718 --> 00:21:59.653
<c.magenta>来解释我的意思</c>

00:21:59.987 --> 00:22:04.124
<c.magenta>举个例子 我们先创建一个</c>
<c.magenta>自定义的NSData子类</c>

00:21:59.987 --> 00:22:04.124
<c.magenta>举个例子 我们先创建一个</c>
<c.magenta>自定义的NSData子类</c>

00:22:04.358 --> 00:22:05.726
<c.magenta>不给它分配任何存储空间</c>

00:22:05.859 --> 00:22:08.495
<c.magenta>代表一个虚拟的</c>
<c.magenta>全是1的Collection</c>

00:22:09.096 --> 00:22:11.598
<c.magenta>我们将它名为</c>
<c.magenta>AllOnesData 描述性很强</c>

00:22:11.798 --> 00:22:14.768
<c.magenta>这里我只展示一个方法的实现</c>

00:22:15.269 --> 00:22:20.574
<c.magenta>获取指定的字节getBytes</c>
<c.magenta>多少可以实现这个类期望的功能</c>

00:22:20.641 --> 00:22:22.009
<c.magenta>我们把所有字节设置为1</c>

00:22:22.976 --> 00:22:24.511
<c.magenta>不需要储存任何东西</c>

00:22:25.245 --> 00:22:27.981
<c.magenta>接着我们创建一个它的只读对象</c>

00:22:28.849 --> 00:22:31.518
<c.magenta>我们不会单纯地使用引用</c>
<c.magenta>而是会建立一个数值类型</c>

00:22:31.585 --> 00:22:35.656
<c.magenta>并把引用包含其中</c>

00:22:35.889 --> 00:22:39.593
<c.magenta>我们使用了刚刚创建的</c>
<c.magenta>新的初始化方法</c>

00:22:40.227 --> 00:22:42.095
<c.magenta>它和你预期的效果一样</c>

00:22:42.563 --> 00:22:46.900
<c.magenta>现在我们的ones数值类型</c>
<c.magenta>指向全是1的数据的引用</c>

00:22:46.967 --> 00:22:47.801
<c.magenta>它们是虚拟的</c>

00:22:47.868 --> 00:22:50.470
<c.magenta>现在不会在内存里占用字节</c>

00:22:50.871 --> 00:22:54.474
<c.magenta>现在我们来创建一个可变副本</c>
<c.magenta>同样 我们不做任何修改</c>

00:22:54.541 --> 00:22:58.312
<c.magenta>所以我们现在不需要分配或管理</c>
<c.magenta>任何这些内存中的字节</c>

00:22:59.112 --> 00:23:01.582
<c.magenta>我们准备好对bytes进行需改</c>
<c.magenta>为了做到这一点</c>

00:22:59.112 --> 00:23:01.582
<c.magenta>我们准备好对bytes进行需改</c>
<c.magenta>为了做到这一点</c>

00:23:01.648 --> 00:23:04.585
<c.magenta>要用到一个今年新添的</c>
<c.magenta>Foundation API</c>

00:23:04.651 --> 00:23:07.688
<c.magenta>它是一个Scoped</c>
<c.magenta>Pointer Accessor</c>

00:23:08.989 --> 00:23:10.891
<c.magenta>叫做withUnsafeMutableBytes</c>

00:23:11.024 --> 00:23:15.395
<c.magenta>这比直接对data本身</c>
<c.magenta>调用mutableBytes好得多</c>

00:23:15.462 --> 00:23:19.099
<c.magenta>因为我们把</c>
<c.magenta>对这些字节的访问限制在了</c>

00:23:19.166 --> 00:23:21.068
<c.magenta>我们定义的闭包内</c>

00:23:21.635 --> 00:23:23.670
<c.magenta>这很好理解</c>

00:23:23.737 --> 00:23:25.372
<c.magenta>没有漫天乱飞的指针</c>

00:23:25.439 --> 00:23:27.975
<c.magenta>指针只在这个小的访问器内部有效</c>

00:23:29.376 --> 00:23:32.679
<c.magenta>我们实际进行修改</c>
<c.magenta>引起写时复制机制</c>

00:23:32.746 --> 00:23:34.114
<c.magenta>现在这些字节</c>

00:23:34.214 --> 00:23:37.150
<c.magenta>这些复制的字节</c>
<c.magenta>真正是可见的内存了</c>

00:23:38.852 --> 00:23:41.755
<c.magenta>接着下一个例子</c>
<c.magenta>我厌倦谈论Data了</c>

00:23:42.523 --> 00:23:47.261
<c.magenta>我们来说说URL</c>
<c.magenta>以及URL属性</c>

00:23:47.394 --> 00:23:48.562
<c.magenta>为了说明这个例子</c>

00:23:48.629 --> 00:23:52.065
<c.magenta>我想先说一说在Swift 2.2中</c>
<c.magenta>我们是怎么做的</c>

00:23:53.100 --> 00:23:56.303
<c.magenta>在Swift 2.2我们会请求</c>
<c.magenta>NSURL.fileURL</c>

00:23:56.370 --> 00:23:58.005
<c.magenta>以my-special-file</c>
<c.magenta>为例</c>

00:23:58.071 --> 00:24:01.375
<c.magenta>这个文件太特殊了</c>
<c.magenta>我把它放在我的文件系统的根目录</c>

00:23:58.071 --> 00:24:01.375
<c.magenta>这个文件太特殊了</c>
<c.magenta>我把它放在我的文件系统的根目录</c>

00:24:02.042 --> 00:24:03.544
<c.magenta>我对三个属性很好奇</c>

00:24:03.610 --> 00:24:07.014
<c.magenta>我想知道创建日期</c>
<c.magenta>它是否是常规文件</c>

00:24:07.247 --> 00:24:11.218
<c.magenta>以及出于某些原因</c>
<c.magenta>这个文件所处卷的最大文件大小</c>

00:24:11.885 --> 00:24:15.689
<c.magenta>这些在Swift 2.2只是字符串</c>
<c.magenta>所以这只是个字符串数组</c>

00:24:16.156 --> 00:24:18.292
<c.magenta>而且当我向我的URL</c>
<c.magenta>请求资源值的时候</c>

00:24:18.358 --> 00:24:21.295
<c.magenta>只会得到个普通的字典类型</c>
<c.magenta>不包含任何类型信息</c>

00:24:21.361 --> 00:24:25.799
<c.magenta>它只是字符串指向对象</c>
<c.magenta>这意味着使用它时</c>

00:24:26.834 --> 00:24:29.803
<c.magenta>需要用到很多as某个类</c>
<c.magenta>所以我必须</c>

00:24:29.870 --> 00:24:32.439
<c.magenta>暗示说它是布尔型</c>
<c.magenta>暗示它是整数型</c>

00:24:32.506 --> 00:24:37.077
<c.magenta>我一直在不停检查引用值</c>
<c.magenta>来确保我做的是对的</c>

00:24:37.144 --> 00:24:40.047
<c.magenta>除此之外</c>
<c.magenta>修改只是针对字典类型的</c>

00:24:40.380 --> 00:24:42.416
<c.magenta>所以你可以做类似这样的荒唐事情</c>

00:24:45.285 --> 00:24:48.255
<c.magenta>并且每一个错误都是运行时错误</c>

00:24:49.256 --> 00:24:51.425
<c.magenta>我们来看看Swift 3的改进</c>

00:24:52.659 --> 00:24:55.462
<c.magenta>在Swift 3中</c>
<c.magenta>建立URL的过程也很类似</c>

00:24:56.029 --> 00:24:59.032
<c.magenta>但是我们不再使用类工厂方法</c>

00:24:59.766 --> 00:25:02.669
<c.magenta>它变成了普通的初始化语法</c>

00:24:59.766 --> 00:25:02.669
<c.magenta>它变成了普通的初始化语法</c>

00:25:03.370 --> 00:25:05.405
<c.magenta>我们现在谈的依然是</c>
<c.magenta>my-special-file</c>

00:25:05.939 --> 00:25:09.243
<c.magenta>我们不再请求字符串数组</c>

00:25:09.309 --> 00:25:11.812
<c.magenta>而是使用强类型的字符串枚举</c>

00:25:11.879 --> 00:25:14.615
<c.magenta>正如我之前说的一样</c>
<c.magenta>我们要创建它们的集合</c>

00:25:15.482 --> 00:25:17.384
<c.magenta>当我们向URL请求资源值时</c>

00:25:17.451 --> 00:25:19.319
<c.magenta>我们得到的不再是个字典</c>

00:25:19.520 --> 00:25:23.590
<c.magenta>我们会得到一个值</c>
<c.magenta>一个新的Foundation数值类型</c>

00:25:23.657 --> 00:25:25.692
<c.magenta>我们看看这个</c>
<c.magenta>Foundation值的类型是什么</c>

00:25:25.759 --> 00:25:28.428
<c.magenta>针对我们请求的三个属性</c>

00:25:29.296 --> 00:25:31.698
<c.magenta>你可以看到creationDate</c>
<c.magenta>是一个Date</c>

00:25:31.865 --> 00:25:33.200
<c.magenta>isRegularFile</c>
<c.magenta>是一个Bool</c>

00:25:33.267 --> 00:25:35.402
<c.magenta>volumeMaximumFileSize</c>
<c.magenta>是一个Integer</c>

00:25:37.271 --> 00:25:39.706
<c.magenta>而且还有一点需要指出的是</c>

00:25:39.773 --> 00:25:42.276
<c.magenta>URLResourceValue</c>
<c.magenta>结构本身是惰性的</c>

00:25:42.342 --> 00:25:44.578
<c.magenta>它仍然是用字典实现的</c>

00:25:45.045 --> 00:25:47.548
<c.magenta>正如Swift 2 API一样</c>
<c.magenta>没有必要</c>

00:25:47.614 --> 00:25:51.251
<c.magenta>这个巨大的Struct会消耗内存</c>

00:25:51.318 --> 00:25:54.388
<c.magenta>我请求了三个东西</c>
<c.magenta>就会得到三个东西</c>

00:25:54.721 --> 00:25:57.457
<c.magenta>如果你有自定义keys</c>
<c.magenta>字典还是在那里</c>

00:25:57.524 --> 00:26:00.527
<c.magenta>你请求的不是字符串</c>
<c.magenta>而是你所感兴趣的</c>

00:25:57.524 --> 00:26:00.527
<c.magenta>你请求的不是字符串</c>
<c.magenta>而是你所感兴趣的</c>

00:26:00.594 --> 00:26:01.995
<c.magenta>URLResourceKey</c>

00:26:02.563 --> 00:26:04.665
<c.magenta>你可能注意到有很多问号</c>

00:26:04.731 --> 00:26:07.167
<c.magenta>原因就是 恩</c>
<c.magenta>其实有两个原因</c>

00:26:07.234 --> 00:26:09.102
<c.magenta>第一个原因是你并没有请求它</c>

00:26:09.469 --> 00:26:11.505
<c.magenta>所以这个创建日期就不存在</c>

00:26:11.572 --> 00:26:13.807
<c.magenta>这涉及到数据的稀疏性</c>

00:26:14.074 --> 00:26:15.943
<c.magenta>第二个它不存在的原因是</c>

00:26:16.009 --> 00:26:19.046
<c.magenta>就是属性本身可能是无效的</c>

00:26:19.279 --> 00:26:21.982
<c.magenta>volumMaximumFileSize就是个例子</c>

00:26:22.049 --> 00:26:24.284
<c.magenta>我们来看看</c>
<c.magenta>两个关于工作原理的例子</c>

00:26:25.519 --> 00:26:27.654
<c.magenta>因为我们请求的是普通文件</c>

00:26:27.721 --> 00:26:30.724
<c.magenta>我们完全可以显式展开</c>
<c.magenta>这个Optional值</c>

00:26:30.958 --> 00:26:32.593
<c.magenta>它会出现在此</c>
<c.magenta>因为我们请求了它</c>

00:26:32.659 --> 00:26:35.729
<c.magenta>然而 VolumeMaximumFileSize</c>
<c.magenta>的文档里面说到</c>

00:26:35.796 --> 00:26:37.764
<c.magenta>不是所有的卷</c>
<c.magenta>或所有的文件系统</c>

00:26:37.831 --> 00:26:41.235
<c.magenta>都支持最大文件尺寸这个属性</c>
<c.magenta>所以它可能并不在那儿</c>

00:26:41.435 --> 00:26:45.639
<c.magenta>这是Swift里</c>
<c.magenta>使用if let结构的绝佳例子</c>

00:26:45.706 --> 00:26:47.708
<c.magenta>有条件的设置局部变量</c>

00:26:49.877 --> 00:26:51.378
<c.magenta>现在咱们说说修改</c>

00:26:51.445 --> 00:26:55.482
<c.magenta>当然URLResourceValues中</c>
<c.magenta>URL的修改API</c>

00:26:55.549 --> 00:26:58.418
<c.magenta>与它新的值类型相关</c>
<c.magenta>所以当你尝试这么做的时候</c>

00:26:58.485 --> 00:27:00.087
<c.magenta>尽管这是我的特殊文件</c>

00:26:58.485 --> 00:27:00.087
<c.magenta>尽管这是我的特殊文件</c>

00:27:00.153 --> 00:27:02.689
<c.magenta>我非常努力地说它不是常规的</c>

00:27:02.756 --> 00:27:04.925
<c.magenta>编译器会在我编译的时候就会报错</c>

00:27:04.992 --> 00:27:07.694
<c.magenta>而不是让我自己在运行时</c>
<c.magenta>发现这个问题</c>

00:27:07.828 --> 00:27:12.266
<c.magenta>更进一步 文件创建日期也是强类型的</c>
<c.magenta>类型为Date</c>

00:27:12.332 --> 00:27:16.904
<c.magenta>如此荒唐的事 在Siri那可能行得通</c>
<c.magenta>但写代码的时候是不可能的</c>

00:27:19.139 --> 00:27:22.543
<c.magenta>关于Foundation的探索</c>
<c.magenta>我最后想说的一点</c>

00:27:22.609 --> 00:27:24.778
<c.magenta>就是Swift的原始枚举类型</c>

00:27:24.912 --> 00:27:27.481
<c.magenta>然后我们又要再一次</c>
<c.magenta>谈谈数据了</c>

00:27:27.548 --> 00:27:29.449
<c.magenta>因为有个例子真的很不错</c>

00:27:30.217 --> 00:27:32.719
<c.magenta>当data拥有一个</c>
<c.magenta>UnsafeMutablePointer时</c>

00:27:32.786 --> 00:27:35.155
<c.magenta>你可以选择设置</c>
<c.magenta>一个deallocator</c>

00:27:36.557 --> 00:27:38.492
<c.magenta>Data默认支持多种类型</c>

00:27:39.726 --> 00:27:43.463
<c.magenta>包括自定义deallocator</c>

00:27:44.231 --> 00:27:48.969
<c.magenta>现在 Swift支持</c>
<c.magenta>把值和枚举相关联</c>

00:27:49.036 --> 00:27:50.938
<c.magenta>你经常会看到这些和整数关联</c>

00:27:51.004 --> 00:27:54.842
<c.magenta>你可以在case表达式里使用它们</c>
<c.magenta>这样你就可以</c>

00:27:54.908 --> 00:27:57.945
<c.magenta>用它们做一些很酷的模式匹配</c>
<c.magenta>但这里我们接受的是一个闭包</c>

00:27:58.011 --> 00:28:01.515
<c.magenta>因为我们想把你提供的行为</c>
<c.magenta>包含其中</c>

00:27:58.011 --> 00:28:01.515
<c.magenta>因为我们想把你提供的行为</c>
<c.magenta>包含其中</c>

00:28:01.715 --> 00:28:03.083
<c.magenta>我们来实际做一下</c>

00:28:03.183 --> 00:28:05.085
<c.magenta>我们从一个简单的</c>
<c.magenta>malloc例子说起</c>

00:28:05.752 --> 00:28:07.087
<c.magenta>在Swift</c>
<c.magenta>你依然可使用malloc</c>

00:28:07.154 --> 00:28:10.357
<c.magenta>尽管你在演示中不常看到它</c>

00:28:10.524 --> 00:28:15.028
<c.magenta>使用malloc分配内存</c>
<c.magenta>当你把这个指针指向Data时</c>

00:28:15.162 --> 00:28:17.064
<c.magenta>你可以把deallocator</c>
<c.magenta>设置为free</c>

00:28:19.032 --> 00:28:23.203
<c.magenta>语法和使用集成值一样简单</c>

00:28:23.437 --> 00:28:24.805
<c.magenta>我们再看一个自定义的例子</c>

00:28:24.872 --> 00:28:28.942
<c.magenta>假设我们有一个函数</c>
<c.magenta>create_glorious_pointer</c>

00:28:29.009 --> 00:28:31.378
<c.magenta>我们想光荣地释放它</c>

00:28:31.445 --> 00:28:32.479
<c.magenta>以免它们受到冒犯</c>

00:28:32.846 --> 00:28:37.618
<c.magenta>设置自定义deallocator非常简单</c>
<c.magenta>只需提供一个闭包</c>

00:28:37.684 --> 00:28:40.220
<c.magenta>并且确保你进行了想要进行的操作</c>

00:28:41.288 --> 00:28:42.656
<c.magenta>这非常强大</c>

00:28:42.723 --> 00:28:46.994
<c.magenta>对于框架开发者来说</c>
<c.magenta>也是一个很强大的概念</c>

00:28:47.294 --> 00:28:50.664
<c.magenta>因为在别的语言里 我们不得不</c>

00:28:50.731 --> 00:28:52.933
<c.magenta>提供另一个基于函数指针的API</c>

00:28:53.233 --> 00:28:57.938
<c.magenta>但在Swift 3里</c>
<c.magenta>我们可以直接提供基于枚举的API</c>

00:28:58.005 --> 00:29:01.208
<c.magenta>它可以简洁地表达所有内容</c>
<c.magenta>非常有表现力</c>

00:28:58.005 --> 00:29:01.208
<c.magenta>它可以简洁地表达所有内容</c>
<c.magenta>非常有表现力</c>

00:29:02.342 --> 00:29:04.311
<c.magenta>至此我们的API探索之旅结束了</c>

00:29:04.545 --> 00:29:06.113
<c.magenta>但愿我们见到了不少奇妙之处</c>

00:29:06.180 --> 00:29:08.949
<c.magenta>现在让Tony给大家</c>
<c.magenta>详细讲讲Adoption</c>

00:29:16.156 --> 00:29:17.057
<c.magenta>谢谢 Michael</c>

00:29:18.692 --> 00:29:21.528
<c.magenta>现在你对于可能做到的事情</c>
<c.magenta>有了一点大致了解</c>

00:29:21.595 --> 00:29:23.664
<c.magenta>我们来谈谈</c>
<c.magenta>如何在你的应用中使用</c>

00:29:24.932 --> 00:29:26.700
<c.magenta>咱们先来讲讲桥接</c>

00:29:26.934 --> 00:29:29.369
<c.magenta>在这个主题上</c>
<c.magenta>我们不断迭代更新</c>

00:29:29.436 --> 00:29:32.973
<c.magenta>我们把Swift 2里面的一些</c>
<c.magenta>你已经熟悉的概念进行了扩充</c>

00:29:33.207 --> 00:29:35.342
<c.magenta>用于桥接Objective-C</c>
<c.magenta>和Swift</c>

00:29:35.676 --> 00:29:38.111
<c.magenta>如果你理解String和</c>
<c.magenta>NSString是如何桥接的</c>

00:29:38.178 --> 00:29:40.814
<c.magenta>我们把同样的概念</c>
<c.magenta>应用到了Data和NSData上</c>

00:29:40.981 --> 00:29:43.050
<c.magenta>以及你看到的</c>
<c.magenta>这里所有的数据类型</c>

00:29:43.851 --> 00:29:48.488
<c.magenta>这就表示所有从</c>
<c.magenta>Cocoa SDK引入的API</c>

00:29:48.555 --> 00:29:50.724
<c.magenta>都会使用这些新的数据类型</c>

00:29:51.091 --> 00:29:54.628
<c.magenta>这就是我们形成杠杆的核心思想</c>

00:29:57.130 --> 00:29:59.466
<c.magenta>例如 在Swift 2.2</c>
<c.magenta>的AppKit中</c>

00:29:59.533 --> 00:30:02.135
<c.magenta>你能看到这个类</c>
<c.magenta>名叫NSDatePicker</c>

00:29:59.533 --> 00:30:02.135
<c.magenta>你能看到这个类</c>
<c.magenta>名叫NSDatePicker</c>

00:30:02.769 --> 00:30:06.440
<c.magenta>它允许我们展示一个UI</c>
<c.magenta>并让你的用户选择日期</c>

00:30:06.507 --> 00:30:09.209
<c.magenta>除去其他属性</c>
<c.magenta>它有两个能够控制日期的属性</c>

00:30:09.510 --> 00:30:11.612
<c.magenta>你能在这里看到</c>
<c.magenta>它们被标成了@NSCopying</c>

00:30:11.712 --> 00:30:13.647
<c.magenta>它们是NSDate引用类型的</c>

00:30:14.948 --> 00:30:17.184
<c.magenta>在Swift 3</c>
<c.magenta>不改变AppKit前提下</c>

00:30:17.451 --> 00:30:20.821
<c.magenta>我们只改变了Foundation</c>
<c.magenta>这个类现在看起来是这样的</c>

00:30:20.888 --> 00:30:22.756
<c.magenta>你看 我们现在有Date结构类型了</c>

00:30:22.823 --> 00:30:27.160
<c.magenta>而且我们不需把它标作@NSCopying了</c>
<c.magenta>因为他们是数值类型</c>

00:30:27.227 --> 00:30:28.795
<c.magenta>我们会帮你进行复制</c>

00:30:32.132 --> 00:30:34.801
<c.magenta>进行桥接可能会有一定的性能折损</c>

00:30:34.868 --> 00:30:37.771
<c.magenta>为了介绍原因</c>
<c.magenta>我需要深入讲解一下具体细节</c>

00:30:37.838 --> 00:30:39.573
<c.magenta>桥接的原理究竟是什么</c>

00:30:39.873 --> 00:30:42.743
<c.magenta>桥接有两个主要策略</c>
<c.magenta>一个针对大型类型</c>

00:30:42.809 --> 00:30:45.445
<c.magenta>它会存储引用</c>
<c.magenta>另一个针对小型类型</c>

00:30:45.512 --> 00:30:46.680
<c.magenta>它会创建引用</c>

00:30:47.314 --> 00:30:49.550
<c.magenta>举个例子</c>
<c.magenta>我们再讨论一下数据</c>

00:30:51.118 --> 00:30:52.452
<c.magenta>我又创建了一次data</c>

00:30:52.519 --> 00:30:54.755
<c.magenta>它是一个结构体</c>
<c.magenta>包含了一个引用类型数据</c>

00:30:55.222 --> 00:30:57.324
<c.magenta>若调用</c>
<c.magenta>Objective-C的API</c>

00:30:57.391 --> 00:31:01.128
<c.magenta>将会发生的是 我们把引用交到</c>
<c.magenta>Objective-C端处理</c>

00:30:57.391 --> 00:31:01.128
<c.magenta>将会发生的是 我们把引用交到</c>
<c.magenta>Objective-C端处理</c>

00:31:01.261 --> 00:31:03.897
<c.magenta>因为Objective-C</c>
<c.magenta>不会处理结构体数据</c>

00:31:03.964 --> 00:31:05.499
<c.magenta>它只能看懂NSData</c>

00:31:05.933 --> 00:31:08.168
<c.magenta>在这个例子里</c>
<c.magenta>也许对于同步方法调用</c>

00:31:08.235 --> 00:31:11.572
<c.magenta>Objective-C的代码</c>
<c.magenta>在任何时间都不会持有这个数据</c>

00:31:11.638 --> 00:31:13.373
<c.magenta>它可以访问它</c>
<c.magenta>随后就忘记它</c>

00:31:13.440 --> 00:31:16.510
<c.magenta>仅仅保存一小段时间引用即可</c>

00:31:17.110 --> 00:31:22.416
<c.magenta>你会看到</c>
<c.magenta>许多API会长时间持有数据</c>

00:31:22.482 --> 00:31:25.953
<c.magenta>通常会被标注上Copying属性</c>

00:31:26.854 --> 00:31:28.789
<c.magenta>那样 在Objective-C中</c>

00:31:29.056 --> 00:31:31.692
<c.magenta>Objective-C代码</c>
<c.magenta>会调用数据的复制方法</c>

00:31:32.059 --> 00:31:33.760
<c.magenta>因为它需要保护自己</c>

00:31:33.827 --> 00:31:36.864
<c.magenta>以免潜在的对于原始数据的修改</c>

00:31:36.930 --> 00:31:38.332
<c.magenta>从一个完全未知的来源</c>

00:31:39.199 --> 00:31:42.469
<c.magenta>这意味着 当发生桥接时</c>
<c.magenta>可能发生数据的复制</c>

00:31:43.237 --> 00:31:44.371
<c.magenta>我们把它翻过来看</c>

00:31:44.471 --> 00:31:47.274
<c.magenta>这里是一段Swift代码</c>
<c.magenta>它调用了Objective-C方法</c>

00:31:47.341 --> 00:31:48.742
<c.magenta>并获取返回的数据</c>

00:31:48.809 --> 00:31:52.779
<c.magenta>这里 Objective-C代码</c>
<c.magenta>创建了NSData类</c>

00:31:52.846 --> 00:31:54.281
<c.magenta>当它回到Swift的时候</c>

00:31:54.648 --> 00:31:56.984
<c.magenta>我们建立结构体数据</c>
<c.magenta>并把引用包含其中</c>

00:31:57.050 --> 00:32:00.354
<c.magenta>然后调用复制方法</c>
<c.magenta>原因和上一页演示文档说的一样</c>

00:31:57.050 --> 00:32:00.354
<c.magenta>然后调用复制方法</c>
<c.magenta>原因和上一页演示文档说的一样</c>

00:32:00.721 --> 00:32:03.156
<c.magenta>这个结构体需要保持</c>
<c.magenta>它对这份副本的控制</c>

00:32:03.223 --> 00:32:06.426
<c.magenta>这样它才可以向你提供</c>
<c.magenta>正确的语义</c>

00:32:07.895 --> 00:32:10.330
<c.magenta>幸运的是 基本上所有通过这个方式</c>
<c.magenta>接收到的来自SDK的数据</c>

00:32:10.397 --> 00:32:12.032
<c.magenta>都是不可变的</c>

00:32:12.232 --> 00:32:14.501
<c.magenta>这意味着 这份副本在本质上</c>
<c.magenta>只用于保持计数</c>

00:32:14.568 --> 00:32:16.403
<c.magenta>但是有一点很重要</c>
<c.magenta>需要明白</c>

00:32:16.470 --> 00:32:18.872
<c.magenta>当桥接的时候</c>
<c.magenta>可能会出现复制操作</c>

00:32:19.940 --> 00:32:23.377
<c.magenta>对于小的类型 比如Date</c>
<c.magenta>你会发现并不存在引用</c>

00:32:23.443 --> 00:32:25.846
<c.magenta>我们刚才看到了它的实现</c>
<c.magenta>只有一个Double</c>

00:32:25.913 --> 00:32:30.384
<c.magenta>所以在Swift里 若我调用了一个</c>
<c.magenta>Objective-C的函数或方法</c>

00:32:30.851 --> 00:32:35.656
<c.magenta>它接受一个Date 我们需通过桥接</c>
<c.magenta>分配一个NSDate</c>

00:32:36.323 --> 00:32:39.893
<c.magenta>那是因为Objective-C代码</c>
<c.magenta>只知道如何处理引用类型</c>

00:32:40.194 --> 00:32:41.995
<c.magenta>在Objective-C方面</c>
<c.magenta>我们采用了很多技巧</c>

00:32:42.062 --> 00:32:44.831
<c.magenta>使NSDate分配的开销很小</c>

00:32:45.132 --> 00:32:49.002
<c.magenta>这点很重要 我们要明白</c>
<c.magenta>桥接的时候会产生内存分配</c>

00:32:53.473 --> 00:32:56.043
<c.magenta>所以我们优化了这些数据类型</c>
<c.magenta>以适配Swift</c>

00:32:56.910 --> 00:33:00.814
<c.magenta>在你的编码中</c>
<c.magenta>你应该避免来回桥接</c>

00:32:56.910 --> 00:33:00.814
<c.magenta>在你的编码中</c>
<c.magenta>你应该避免来回桥接</c>

00:33:01.748 --> 00:33:04.251
<c.magenta>这是因为我们想让我们的</c>
<c.magenta>编码默认是安全的</c>

00:33:04.585 --> 00:33:07.087
<c.magenta>但是它确实说明</c>
<c.magenta>在这里可能有潜在的复制操作</c>

00:33:07.154 --> 00:33:10.958
<c.magenta>这是使用新的数值类型时</c>
<c.magenta>需要注意的几点</c>

00:33:12.059 --> 00:33:13.594
<c.magenta>现在咱们来谈一谈迁移</c>

00:33:14.261 --> 00:33:15.462
<c.magenta>先来说说好消息</c>

00:33:16.096 --> 00:33:19.833
<c.magenta>我们今天说的新类型</c>
<c.magenta>适用于所有Swift部署目标</c>

00:33:20.400 --> 00:33:22.369
<c.magenta>这些都是Swift标准库的一部分</c>

00:33:22.436 --> 00:33:24.204
<c.magenta>所以你不需要等待客户</c>

00:33:24.271 --> 00:33:26.673
<c.magenta>升级到我们最新版本的平台</c>

00:33:26.740 --> 00:33:28.909
<c.magenta>一旦Swift 3和</c>
<c.magenta>Xcode 8发布</c>

00:33:28.976 --> 00:33:30.677
<c.magenta>你马上就可以使用它们</c>

00:33:32.112 --> 00:33:34.982
<c.magenta>现在 为了帮助你</c>
<c.magenta>我们升级了Migrator</c>

00:33:35.349 --> 00:33:38.585
<c.magenta>这就代表当你打开Xcode 8里</c>
<c.magenta>你的项目</c>

00:33:38.652 --> 00:33:42.189
<c.magenta>你会看到一个类似这个的对话框</c>
<c.magenta>我建议你点击Convert</c>

00:33:42.489 --> 00:33:45.726
<c.magenta>我来展示一下</c>
<c.magenta>Migrator可以帮你做的一些事</c>

00:33:47.227 --> 00:33:49.663
<c.magenta>现在我们在Swift 2.2中</c>
<c.magenta>有一些NSDate</c>

00:33:50.163 --> 00:33:53.066
<c.magenta>我们调用它的</c>
<c.magenta>dateByAddingTimeInterval方法</c>

00:33:53.400 --> 00:33:56.470
<c.magenta>Migrator会把NSDate</c>
<c.magenta>这个引用类型</c>

00:33:56.537 --> 00:33:58.505
<c.magenta>修改为结构类型的Date</c>

00:33:59.139 --> 00:34:01.041
<c.magenta>然后它会改变方法</c>

00:33:59.139 --> 00:34:01.041
<c.magenta>然后它会改变方法</c>

00:34:01.241 --> 00:34:04.645
<c.magenta>因为它们已依据最新的Swift 3</c>
<c.magenta>API设计指引进行了修改</c>

00:34:04.945 --> 00:34:07.381
<c.magenta>无论是针对引用类型</c>
<c.magenta>还是数值类型</c>

00:34:08.549 --> 00:34:09.683
<c.magenta>我们再来举一个例子</c>

00:34:10.016 --> 00:34:12.652
<c.magenta>我在Swift 2里创建了一个</c>
<c.magenta>NSDateComponents</c>

00:34:12.886 --> 00:34:15.222
<c.magenta>然后对它的属性进行了设定</c>

00:34:15.789 --> 00:34:19.893
<c.magenta>我能做到这些是因为NSDateComponents</c>
<c.magenta>永远是可变的引用类型</c>

00:34:20.561 --> 00:34:23.463
<c.magenta>Swift 3里引入了新的结构体</c>
<c.magenta>DateComponents</c>

00:34:23.597 --> 00:34:26.166
<c.magenta>所以Migrator</c>
<c.magenta>会把引用变成结构</c>

00:34:26.366 --> 00:34:30.469
<c.magenta>但是它注意到你对它进行了修改</c>
<c.magenta>所以它还会帮你把let改成var</c>

00:34:31.438 --> 00:34:33.540
<c.magenta>Migrator可以帮你做很多</c>

00:34:33.806 --> 00:34:36.844
<c.magenta>但有些地方</c>
<c.magenta>如果你检查一下它做了什么</c>

00:34:36.909 --> 00:34:40.347
<c.magenta>你自己可以做到更好</c>
<c.magenta>利用我们提供的新功能</c>

00:34:40.647 --> 00:34:43.516
<c.magenta>该例中DateComponents</c>
<c.magenta>有一个新的initializer</c>

00:34:43.583 --> 00:34:45.585
<c.magenta>这我们只能在Swift里做到</c>

00:34:45.786 --> 00:34:49.389
<c.magenta>这个initializer为 DateComponents</c>
<c.magenta>里的每一个属性提供了参数</c>

00:34:49.456 --> 00:34:51.725
<c.magenta>这些都不是必需项</c>
<c.magenta>而且都有默认值</c>

00:34:51.792 --> 00:34:54.962
<c.magenta>你可只利用自己在乎的值</c>
<c.magenta>创建DateComponents</c>

00:34:55.027 --> 00:34:56.463
<c.magenta>比如这个例子里</c>
<c.magenta>只提供月和日</c>

00:34:56.697 --> 00:34:58.165
<c.magenta>然后把var变回let</c>

00:34:58.232 --> 00:35:01.435
<c.magenta>因为初始化后</c>
<c.magenta>你不需要改变它</c>

00:34:58.232 --> 00:35:01.435
<c.magenta>因为初始化后</c>
<c.magenta>你不需要改变它</c>

00:35:03.337 --> 00:35:05.005
<c.magenta>最后又要说到我们的朋友</c>
<c.magenta>Data类型了</c>

00:35:05.072 --> 00:35:08.075
<c.magenta>Swift 2里我建立了</c>
<c.magenta>一个NSMutableData</c>

00:35:08.175 --> 00:35:10.577
<c.magenta>它是一个引用类型</c>
<c.magenta>然后我给它添加了一些数据</c>

00:35:11.778 --> 00:35:14.581
<c.magenta>在Swift 3里</c>
<c.magenta>Migrator会处理好方法名称</c>

00:35:14.781 --> 00:35:18.218
<c.magenta>比如contentsOfURL</c>
<c.magenta>以及appendData</c>

00:35:19.319 --> 00:35:21.822
<c.magenta>而且它会把NSData</c>
<c.magenta>变成Data结构</c>

00:35:22.222 --> 00:35:25.025
<c.magenta>但是 它没有处理</c>
<c.magenta>NSMutableData引用类型</c>

00:35:25.459 --> 00:35:27.961
<c.magenta>有些情况下 信息量不够</c>

00:35:28.028 --> 00:35:30.731
<c.magenta>Migrator没办法</c>
<c.magenta>做到我们认为最佳的选择</c>

00:35:30.797 --> 00:35:33.267
<c.magenta>我们不去管它</c>
<c.magenta>它依然能正常运行</c>

00:35:33.700 --> 00:35:37.004
<c.magenta>但是如果你回去自己做一些修补</c>

00:35:37.070 --> 00:35:38.605
<c.magenta>你可以做到些很酷的事情</c>

00:35:38.672 --> 00:35:41.074
<c.magenta>我们可以把MutableData</c>
<c.magenta>变成Data结构</c>

00:35:41.575 --> 00:35:43.544
<c.magenta>即我们把它从let改为var</c>

00:35:43.810 --> 00:35:47.447
<c.magenta>还可以删除掉options参数</c>
<c.magenta>因为它现在已经有默认值了</c>

00:35:50.484 --> 00:35:53.820
<c.magenta>我们今天谈了不少东西</c>
<c.magenta>现在让我们来稍微回顾一下</c>

00:35:54.421 --> 00:35:56.456
<c.magenta>相信这些对Foundation的改进</c>

00:35:56.523 --> 00:35:58.525
<c.magenta>会让整个SDK受益</c>

00:35:58.592 --> 00:36:00.928
<c.magenta>并提升你的整个Swift开发体验</c>

00:35:58.592 --> 00:36:00.928
<c.magenta>并提升你的整个Swift开发体验</c>

00:36:01.328 --> 00:36:03.530
<c.magenta>一方面是由于API重命名</c>

00:36:03.897 --> 00:36:06.433
<c.magenta>另外我们把握住了机会更进一步</c>

00:36:06.567 --> 00:36:10.470
<c.magenta>添加了一套全新的数据类型</c>
<c.magenta>以及很多针对Swift的新API</c>

00:36:11.538 --> 00:36:13.473
<c.magenta>我们将此视为一段旅程的开始</c>

00:36:13.540 --> 00:36:16.910
<c.magenta>并且在未来</c>
<c.magenta>我们也愿意继续成为支点</c>

00:36:17.311 --> 00:36:19.112
<c.magenta>我们要做很多改进</c>

00:36:19.179 --> 00:36:22.082
<c.magenta>让你的Swift应用</c>
<c.magenta>更安全 更迅速 表达性更好</c>

00:36:23.217 --> 00:36:25.552
<c.magenta>有兴趣多了解的话</c>
<c.magenta>去查看下这个URL结构</c>

00:36:26.453 --> 00:36:29.323
<c.magenta>以及这些相关演讲 包括</c>

00:36:29.389 --> 00:36:32.426
<c.magenta>使用Swift Open Source深入服务器端</c>
<c.magenta>Measurement类型和Unit类型</c>

00:36:34.127 --> 00:36:35.028
<c.magenta>谢谢大家</c>
