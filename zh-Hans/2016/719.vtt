WEBVTT

00:00:19.386 --> 00:00:21.788
<c.magenta>性能和电池寿命的I/O优化</c>

00:00:24.758 --> 00:00:25.692
<c.magenta>大家好 欢迎</c>

00:00:27.561 --> 00:00:31.365
<c.magenta>我叫Kushal Dalmia</c>
<c.magenta>我的同事Terry Long</c>

00:00:31.431 --> 00:00:33.800
<c.magenta>我将为大家讲解I/O优化</c>

00:00:33.901 --> 00:00:35.469
<c.magenta>为性能和电池寿命</c>

00:00:36.470 --> 00:00:39.139
<c.magenta>在本次演讲中 我们将讲解</c>
<c.magenta>什么是I/O</c>

00:00:39.806 --> 00:00:41.208
<c.magenta>它会如何影响你的应用</c>

00:00:41.708 --> 00:00:43.877
<c.magenta>以及如何提高应用的性能</c>

00:00:44.144 --> 00:00:45.913
<c.magenta>通过提高其I/O性能</c>

00:00:46.980 --> 00:00:47.848
<c.magenta>我们现在开始</c>

00:00:49.716 --> 00:00:53.120
<c.magenta>众所周知 每年设备越变越大</c>
<c.magenta>越变越好</c>

00:00:54.321 --> 00:00:58.759
<c.magenta>屏幕分辨率增加 在过去十年</c>
<c.magenta>增加了16倍</c>

00:01:00.160 --> 00:01:02.362
<c.magenta>在相机领域也有类似提高</c>

00:01:02.429 --> 00:01:04.864
<c.magenta>已经可以拍摄4K HD视频</c>

00:01:05.065 --> 00:01:08.135
<c.magenta>还可以从我们的移动设备里</c>
<c.magenta>拍出令人惊艳的的高画质相片</c>

00:01:10.137 --> 00:01:14.041
<c.magenta>所有这些改进造就</c>
<c.magenta>更为丰富的媒体每天被生产</c>

00:01:14.174 --> 00:01:15.242
<c.magenta>和消费</c>

00:01:17.778 --> 00:01:19.146
<c.magenta>为了关注它们的前景</c>

00:01:19.213 --> 00:01:22.382
<c.magenta>我们来看看iPhone</c>
<c.magenta>壁纸大小的趋势</c>

00:01:24.251 --> 00:01:27.888
<c.magenta>如果跨越设备和时代</c>
<c.magenta>来看iPhone壁纸</c>

00:01:28.188 --> 00:01:30.390
<c.magenta>可以发现其呈指数增长</c>

00:01:31.458 --> 00:01:34.228
<c.magenta>iPhone 6s Plus上的</c>
<c.magenta>壁纸大小</c>

00:01:34.428 --> 00:01:37.965
<c.magenta>是对应的iPhone 3G的14倍</c>

00:01:38.665 --> 00:01:41.368
<c.magenta>所有手机数据都有相似的趋势</c>

00:01:41.735 --> 00:01:43.770
<c.magenta>我们编写和使用复杂的应用</c>

00:01:43.837 --> 00:01:46.440
<c.magenta>在游戏 信息和社交网络领域</c>

00:01:47.474 --> 00:01:50.811
<c.magenta>我们工作和存储丰富的文件 如PDF</c>

00:01:52.379 --> 00:01:56.049
<c.magenta>我们分享和捕捉</c>
<c.magenta>高品质音频和视频文件</c>

00:01:59.486 --> 00:02:01.388
<c.magenta>现在为了管理这种数据爆炸</c>

00:01:59.486 --> 00:02:01.388
<c.magenta>现在为了管理这种数据爆炸</c>

00:02:01.488 --> 00:02:04.725
<c.magenta>应用需要在系统资源利用方面</c>
<c.magenta>做到非常高效</c>

00:02:05.626 --> 00:02:11.732
<c.magenta>主要系统资源有CPU 内存和I/O</c>

00:02:13.967 --> 00:02:17.204
<c.magenta>关于CPU和内存 我推荐大家观看</c>
<c.magenta>去年的WWDC演讲</c>

00:02:17.271 --> 00:02:19.173
<c.magenta>“iOS和watchOS上的性能”</c>

00:02:20.107 --> 00:02:22.009
<c.magenta>今天我们将来讲解I/O</c>

00:02:24.077 --> 00:02:29.283
<c.magenta>I/O 即输入输出</c>
<c.magenta>是和本地文件存储进行互动的操作</c>

00:02:29.349 --> 00:02:30.784
<c.magenta>或和基于网络的服务器</c>

00:02:32.553 --> 00:02:35.222
<c.magenta>和文件系统互动的操作</c>

00:02:35.289 --> 00:02:38.492
<c.magenta>以及处理文件读写的操作</c>
<c.magenta>都被认为是一个I/O</c>

00:02:40.727 --> 00:02:44.331
<c.magenta>和网络服务器交流是</c>
<c.magenta>基于网络I/O的很好的范例</c>

00:02:46.834 --> 00:02:49.203
<c.magenta>I/O如此有趣的其中一个原因是</c>

00:02:49.269 --> 00:02:52.105
<c.magenta>在I/O技术上发生了巨大的变化</c>

00:02:52.406 --> 00:02:54.141
<c.magenta>性能特征上也是如此</c>

00:02:55.809 --> 00:02:58.378
<c.magenta>考虑一兆字节的延迟</c>

00:02:58.445 --> 00:03:00.380
<c.magenta>当写入最平常的I/O媒介时</c>

00:02:58.445 --> 00:03:00.380
<c.magenta>当写入最平常的I/O媒介时</c>

00:03:00.914 --> 00:03:05.986
<c.magenta>如SSD 硬盘和普通Wi-Fi网络</c>

00:03:07.487 --> 00:03:09.656
<c.magenta>你可能会注意到 同样的操作</c>

00:03:09.723 --> 00:03:13.126
<c.magenta>大概耗时几毫秒到几百毫秒之间</c>

00:03:13.193 --> 00:03:15.429
<c.magenta>根据互动的媒介不同</c>

00:03:17.998 --> 00:03:19.566
<c.magenta>I/O之所以如此重要的原因</c>

00:03:19.900 --> 00:03:24.204
<c.magenta>是应用上I/O性能直接影响用户体验</c>

00:03:26.073 --> 00:03:28.976
<c.magenta>应用性能的延迟时间的改变</c>

00:03:29.042 --> 00:03:31.011
<c.magenta>可以表现为响应问题</c>

00:03:32.913 --> 00:03:35.182
<c.magenta>由于I/O是系统中的共享资源</c>

00:03:35.315 --> 00:03:38.552
<c.magenta>你的应用的I/O性能</c>
<c.magenta>可能会影响整体系统性能</c>

00:03:40.020 --> 00:03:41.622
<c.magenta>我们一会儿将会看到</c>

00:03:41.989 --> 00:03:44.791
<c.magenta>I/O也会显著影响设备上的电池寿命</c>

00:03:47.194 --> 00:03:50.430
<c.magenta>为了帮你们了解应用上I/O使用情况</c>

00:03:50.731 --> 00:03:52.833
<c.magenta>我们提出了自己的I/O哲学</c>

00:03:54.001 --> 00:03:56.503
<c.magenta>该I/O哲学有四个主要支柱</c>

00:03:59.006 --> 00:04:01.141
<c.magenta>减少应用里的I/O用量</c>

00:03:59.006 --> 00:04:01.141
<c.magenta>减少应用里的I/O用量</c>

00:04:02.876 --> 00:04:05.112
<c.magenta>用正确的线程完成这些I/O</c>

00:04:07.181 --> 00:04:10.751
<c.magenta>采用合适和高效API完成这些I/O</c>

00:04:11.118 --> 00:04:14.688
<c.magenta>最后 对应用中I/O性能测试和测量</c>

00:04:16.223 --> 00:04:17.591
<c.magenta>当我们通读剩下的文档时</c>

00:04:17.658 --> 00:04:19.860
<c.magenta>我们会了解其中每一项的更多细节</c>

00:04:23.363 --> 00:04:26.133
<c.magenta>提高应用中I/O效率的最好方法</c>

00:04:26.200 --> 00:04:28.268
<c.magenta>是减少I/O用量</c>

00:04:30.103 --> 00:04:33.407
<c.magenta>每一个I/O操作都和</c>
<c.magenta>多个硬件功能相互作用</c>

00:04:33.473 --> 00:04:34.408
<c.magenta>在设备上</c>

00:04:35.876 --> 00:04:38.812
<c.magenta>这是一个现代设备的简单框图</c>

00:04:38.879 --> 00:04:41.915
<c.magenta>包含部分功能及它们对电池寿命的影响</c>

00:04:43.784 --> 00:04:47.554
<c.magenta>当应用使用I/O时</c>
<c.magenta>会在CPU上运行代码</c>

00:04:48.922 --> 00:04:50.257
<c.magenta>访问内存</c>

00:04:51.091 --> 00:04:53.660
<c.magenta>最后从硬盘上读取或写入数据</c>

00:04:55.429 --> 00:04:56.830
<c.magenta>如果还涉及到网络</c>

00:04:57.164 --> 00:04:59.700
<c.magenta>基于网络收音机也参与到互动中</c>

00:05:01.502 --> 00:05:04.104
<c.magenta>所有这些组件联合起来的能量消耗</c>

00:05:04.304 --> 00:05:07.341
<c.magenta>让I/O在电池使用方面操作非常沉重</c>

00:05:09.109 --> 00:05:12.412
<c.magenta>由于I/O对设备电池寿命的负面影响</c>

00:05:12.746 --> 00:05:15.516
<c.magenta>我们来看看可以使用的最好的实践技巧</c>

00:05:15.716 --> 00:05:17.818
<c.magenta>来减少应用上的I/O用量</c>

00:05:19.920 --> 00:05:21.388
<c.magenta>首先是缓存</c>

00:05:22.923 --> 00:05:26.426
<c.magenta>基本理念是 建立数据的内存副本</c>

00:05:26.627 --> 00:05:29.229
<c.magenta>而不是每次操作都访问磁盘</c>

00:05:31.431 --> 00:05:34.868
<c.magenta>为了决定应用里的数据是否应该</c>
<c.magenta>在内存中建立缓存</c>

00:05:35.202 --> 00:05:37.504
<c.magenta>你应该查看数据的访问模式</c>

00:05:39.239 --> 00:05:41.942
<c.magenta>被频繁写入或更新的数据</c>

00:05:42.009 --> 00:05:44.545
<c.magenta>也许是在应用中建立缓存的好对象</c>

00:05:46.880 --> 00:05:50.951
<c.magenta>还有 当从磁盘中读取</c>
<c.magenta>需要昂贵处理步骤的数据</c>

00:05:51.285 --> 00:05:53.153
<c.magenta>比如 解压缩一个图片文件</c>

00:05:53.220 --> 00:05:55.756
<c.magenta>可能是应该缓存的一个好例子</c>

00:05:58.158 --> 00:06:02.062
<c.magenta>即便如此 应该注意内存和I/O平衡</c>

00:05:58.158 --> 00:06:02.062
<c.magenta>即便如此 应该注意内存和I/O平衡</c>

00:06:03.363 --> 00:06:07.067
<c.magenta>和I/O一样 内存也是系统中</c>
<c.magenta>共享和有限的资源</c>

00:06:07.134 --> 00:06:09.236
<c.magenta>应该格外小心用户需求</c>

00:06:10.304 --> 00:06:12.873
<c.magenta>如果决定在应用里建立缓存</c>

00:06:13.473 --> 00:06:15.843
<c.magenta>我们推荐使用NSCache API</c>

00:06:16.543 --> 00:06:19.713
<c.magenta>因为它们可以很好地处理内存压力条件</c>

00:06:24.451 --> 00:06:27.087
<c.magenta>下一个实践技巧是合并I/O</c>

00:06:28.589 --> 00:06:29.823
<c.magenta>基本理念是</c>

00:06:29.890 --> 00:06:33.627
<c.magenta>把系统里的I/O推迟到之后</c>
<c.magenta>更为合适的时间</c>

00:06:35.128 --> 00:06:37.164
<c.magenta>由于I/O技术的工作方式</c>

00:06:37.397 --> 00:06:40.534
<c.magenta>更大更少的I/O</c>
<c.magenta>对系统来说总是更为有效</c>

00:06:42.269 --> 00:06:43.403
<c.magenta>其中一种实现方法是</c>

00:06:43.470 --> 00:06:46.373
<c.magenta>是采用应用状态改变通知</c>

00:06:46.540 --> 00:06:49.910
<c.magenta>比如 后台应用数据来安排I/O</c>

00:06:51.778 --> 00:06:55.449
<c.magenta>在macOS 你可以使用</c>
<c.magenta>集中任务计划 API</c>

00:06:55.516 --> 00:06:57.618
<c.magenta>来安排维护和备份任务</c>

00:06:57.851 --> 00:07:00.988
<c.magenta>系统会找出运行这些任务的最佳时间</c>

00:06:57.851 --> 00:07:00.988
<c.magenta>系统会找出运行这些任务的最佳时间</c>

00:07:03.590 --> 00:07:05.125
<c.magenta>想了解更多这些API的信息</c>

00:07:05.192 --> 00:07:08.095
<c.magenta>我们推荐观看2014年WWDC演讲</c>

00:07:08.428 --> 00:07:10.297
<c.magenta>“编写节能高效的代码”</c>

00:07:12.132 --> 00:07:14.434
<c.magenta>我们已经看过一些最佳时间技巧</c>

00:07:14.501 --> 00:07:16.703
<c.magenta>来减少应用中的I/O用量</c>

00:07:17.304 --> 00:07:21.108
<c.magenta>我想为大家介绍我们的示例应用</c>
<c.magenta>是Terry和我编写的</c>

00:07:21.575 --> 00:07:23.944
<c.magenta>在剩下的演讲中</c>
<c.magenta>我们会一直使用这个应用</c>

00:07:24.011 --> 00:07:27.414
<c.magenta>来演示最佳实践技巧的实际影响</c>

00:07:28.649 --> 00:07:30.551
<c.magenta>这个应用叫ImageBox</c>

00:07:31.485 --> 00:07:35.189
<c.magenta>ImageBox是iOS和</c>
<c.magenta>macOS上很棒的应用</c>

00:07:35.722 --> 00:07:37.591
<c.magenta>让你可以添加和浏览图片</c>

00:07:39.960 --> 00:07:42.396
<c.magenta>对于每一个图片 它将显示其缩略图</c>

00:07:43.363 --> 00:07:46.099
<c.magenta>显示相关标识 比如喜欢</c>

00:07:47.134 --> 00:07:49.970
<c.magenta>或者某张特定图片是否有相关注释</c>

00:07:51.905 --> 00:07:54.942
<c.magenta>当你点击某特定图片 将进入详细视图</c>

00:07:55.542 --> 00:07:59.079
<c.magenta>可以让你把图片标记为喜欢 取消喜欢</c>

00:07:59.646 --> 00:08:00.881
<c.magenta>或者为它添加注释</c>

00:07:59.646 --> 00:08:00.881
<c.magenta>或者为它添加注释</c>

00:08:03.116 --> 00:08:04.852
<c.magenta>我们编写了这个应用</c>

00:08:04.918 --> 00:08:07.221
<c.magenta>我们想要知道它是否I/O高效</c>

00:08:07.287 --> 00:08:09.189
<c.magenta>并且在I/O性能方面也表现良好</c>

00:08:10.123 --> 00:08:12.159
<c.magenta>我将来介绍可以使用的工具</c>

00:08:12.226 --> 00:08:14.027
<c.magenta>来决定是否在你自己的应用上使用</c>

00:08:15.495 --> 00:08:17.531
<c.magenta>该工具叫做Xcode调试仪表</c>

00:08:18.565 --> 00:08:19.900
<c.magenta>来看看它如何使用</c>

00:08:21.101 --> 00:08:24.805
<c.magenta>为了使用该工具</c>
<c.magenta>只需从Xcode UI中运行项目</c>

00:08:26.240 --> 00:08:29.610
<c.magenta>这会在设备或模拟器上</c>
<c.magenta>启动项目或应用</c>

00:08:30.077 --> 00:08:32.145
<c.magenta>点击Xcode调试导航器</c>

00:08:33.947 --> 00:08:37.284
<c.magenta>它显示了应用里的实时数据</c>

00:08:37.351 --> 00:08:40.419
<c.magenta>关于应用正在使用的所有系统资源</c>

00:08:41.154 --> 00:08:45.893
<c.magenta>有CPU 内存 能量 网络和磁盘</c>

00:08:47.628 --> 00:08:51.398
<c.magenta>由于我们对应用中I/O活动或</c>
<c.magenta>I/O性能感兴趣</c>

00:08:51.665 --> 00:08:53.100
<c.magenta>我们选中磁盘</c>

00:08:54.735 --> 00:08:57.371
<c.magenta>一旦选中 可以注意到会显示实时数据</c>

00:08:57.437 --> 00:09:00.040
<c.magenta>应用中发生的读取和写入数据</c>

00:08:57.437 --> 00:09:00.040
<c.magenta>应用中发生的读取和写入数据</c>

00:09:00.641 --> 00:09:04.511
<c.magenta>看上去该应用每几秒都进行大量读写入</c>

00:09:04.578 --> 00:09:06.680
<c.magenta>即使没有用户活动时</c>

00:09:06.847 --> 00:09:10.918
<c.magenta>为了进一步调查</c>
<c.magenta>我们想进入Instrument</c>

00:09:11.018 --> 00:09:13.287
<c.magenta>用Instrument来找出原因</c>

00:09:13.687 --> 00:09:16.156
<c.magenta>继续在Instrument里</c>
<c.magenta>点击配置</c>

00:09:16.623 --> 00:09:17.858
<c.magenta>点击重启按钮</c>

00:09:19.793 --> 00:09:22.763
<c.magenta>如此操作时</c>
<c.magenta>Instruments提供了组模板</c>

00:09:22.829 --> 00:09:25.999
<c.magenta>你可以从中选择分析应用</c>

00:09:27.167 --> 00:09:29.937
<c.magenta>因为我们对应用里I/O活动感兴趣</c>

00:09:30.070 --> 00:09:34.474
<c.magenta>继续选择系统使用情况 然后点击选择</c>

00:09:36.810 --> 00:09:39.313
<c.magenta>将打开新的Instrument模板</c>

00:09:39.479 --> 00:09:42.282
<c.magenta>准备记录应用中的I/O活动</c>

00:09:43.016 --> 00:09:44.718
<c.magenta>继续开始记录</c>

00:09:48.388 --> 00:09:50.424
<c.magenta>注意到在详细显示区</c>

00:09:50.624 --> 00:09:54.127
<c.magenta>该模板显示了应用里所有的系统调用</c>

00:09:54.194 --> 00:09:56.230
<c.magenta>为你进行I/O操作</c>

00:09:57.030 --> 00:10:00.934
<c.magenta>还显示了其他有用信息 比如</c>
<c.magenta>实际和请求的字节数</c>

00:09:57.030 --> 00:10:00.934
<c.magenta>还显示了其他有用信息 比如</c>
<c.magenta>实际和请求的字节数</c>

00:10:01.001 --> 00:10:04.705
<c.magenta>对于那些读写操作以及相关的文件路径</c>

00:10:05.706 --> 00:10:07.574
<c.magenta>现在我将停止记录</c>

00:10:09.343 --> 00:10:11.912
<c.magenta>为了找到刚才看到的大量写入</c>

00:10:11.979 --> 00:10:13.413
<c.magenta>在Xcode调试仪表</c>

00:10:13.480 --> 00:10:16.884
<c.magenta>我们按照实际读写的字节数进行排序</c>

00:10:17.084 --> 00:10:20.020
<c.magenta>找出大量写入 在最上方</c>

00:10:21.955 --> 00:10:25.359
<c.magenta>有了这个之后 可以进入扩展详细视图</c>

00:10:25.659 --> 00:10:27.261
<c.magenta>查看确切的回溯</c>

00:10:27.327 --> 00:10:29.930
<c.magenta>关于应用中执行这些I/O的代码部分</c>

00:10:30.964 --> 00:10:33.400
<c.magenta>看上去是应用的委托方法</c>

00:10:35.202 --> 00:10:38.372
<c.magenta>双击进入源代码检查器r</c>

00:10:38.438 --> 00:10:41.408
<c.magenta>将显示执行I/O操作的准确代码块</c>

00:10:42.709 --> 00:10:45.078
<c.magenta>在源代码检查器中点击Xcode图标</c>

00:10:45.345 --> 00:10:47.114
<c.magenta>将会回到Xcode项目</c>

00:10:47.481 --> 00:10:50.117
<c.magenta>并为你高亮显示执行该I/O操作代码</c>

00:10:51.985 --> 00:10:54.588
<c.magenta>来看看这段代码更详细的情况</c>

00:10:55.789 --> 00:10:59.059
<c.magenta>问题出在应用中的实现部分</c>

00:10:59.126 --> 00:11:01.495
<c.magenta>委托方法didFinishLaunchingApp</c>

00:10:59.126 --> 00:11:01.495
<c.magenta>委托方法didFinishLaunchingApp</c>

00:11:02.796 --> 00:11:04.131
<c.magenta>作为实现的一部分</c>

00:11:04.198 --> 00:11:06.466
<c.magenta>我们新建了一个计时器</c>
<c.magenta>DispatchSource</c>

00:11:07.301 --> 00:11:09.603
<c.magenta>让它每5秒记录一次</c>

00:11:11.271 --> 00:11:13.507
<c.magenta>且对于该计时器作为事件处理的一部分</c>

00:11:13.740 --> 00:11:15.475
<c.magenta>我们写出整个数据存储</c>

00:11:16.910 --> 00:11:19.646
<c.magenta>我们中很多人这样写代码 因为我们想确保</c>

00:11:19.713 --> 00:11:23.417
<c.magenta>应用数据可以持续定期地保存</c>

00:11:24.551 --> 00:11:27.621
<c.magenta>然而 还有更为I/O高效的方法实现</c>

00:11:28.789 --> 00:11:29.990
<c.magenta>为了修改代码</c>

00:11:30.057 --> 00:11:33.727
<c.magenta>首先我们删除计时器的重复部分</c>

00:11:35.362 --> 00:11:36.430
<c.magenta>把这部分删除</c>

00:11:37.564 --> 00:11:41.034
<c.magenta>取而代之 新建一个方法叫</c>
<c.magenta>dataStoreDidChange</c>

00:11:41.335 --> 00:11:43.804
<c.magenta>在应用中不同的地方被调用</c>

00:11:43.871 --> 00:11:45.772
<c.magenta>只要数据存储发生任何变化</c>

00:11:47.541 --> 00:11:49.076
<c.magenta>作为该实现的一部分</c>

00:11:49.643 --> 00:11:53.247
<c.magenta>我们把计时器的调度源往后推15秒</c>

00:11:54.615 --> 00:11:59.086
<c.magenta>用这种方法</c>
<c.magenta>我们收集应用数据存储的所有更新</c>

00:11:59.453 --> 00:12:02.155
<c.magenta>往后推一段时间 合并写入</c>

00:11:59.453 --> 00:12:02.155
<c.magenta>往后推一段时间 合并写入</c>

00:12:03.323 --> 00:12:04.958
<c.magenta>当计时器最终过期时</c>

00:12:05.259 --> 00:12:08.428
<c.magenta>它收集了我们频繁采用的更新</c>

00:12:08.495 --> 00:12:10.931
<c.magenta>我们把其作为单一的I/O操作写出</c>

00:12:12.666 --> 00:12:15.335
<c.magenta>来看这些代码在应用中的功能</c>

00:12:16.436 --> 00:12:20.040
<c.magenta>再次点击Xcode UI中的</c>
<c.magenta>运行按钮启动应用</c>

00:12:21.008 --> 00:12:25.445
<c.magenta>进入调试导航仪 选择磁盘仪表</c>
<c.magenta>找到I/O活动</c>

00:12:27.714 --> 00:12:31.552
<c.magenta>可以发现应用已经不再进行那些写入了</c>

00:12:32.152 --> 00:12:34.955
<c.magenta>现它完全空闲 用户也没和它进行互动</c>

00:12:35.022 --> 00:12:36.590
<c.magenta>这就是我们的预期效果</c>

00:12:37.558 --> 00:12:40.794
<c.magenta>我们高效地合并了应用中I/O用量</c>

00:12:41.195 --> 00:12:43.263
<c.magenta>提高了I/O效率</c>

00:12:45.566 --> 00:12:46.466
<c.magenta>使用正确的线程</c>

00:12:46.533 --> 00:12:50.671
<c.magenta>在看过了一些最佳实践技巧</c>
<c.magenta>可以减少I/O用量之后</c>

00:12:51.171 --> 00:12:54.875
<c.magenta>我们来看看利用这些I/O实践的趋势</c>

00:12:55.409 --> 00:12:57.878
<c.magenta>我想请Terry上台为大家演讲</c>

00:12:58.111 --> 00:12:58.946
<c.magenta>Terry</c>

00:13:04.518 --> 00:13:05.352
<c.magenta>谢谢 Kushal</c>

00:13:05.919 --> 00:13:09.823
<c.magenta>我们刚看了一些</c>
<c.magenta>可以减少应用中I/O用量的好方法</c>

00:13:09.890 --> 00:13:11.925
<c.magenta>避免对电池寿命产生不良影响</c>

00:13:12.860 --> 00:13:15.896
<c.magenta>继续讲解我们的哲学的第二大支柱</c>

00:13:16.630 --> 00:13:21.068
<c.magenta>我会讲解一些方法 可以在应用中</c>
<c.magenta>有效使用线程和队列</c>

00:13:21.435 --> 00:13:23.637
<c.magenta>达到更好的I/O性能和效率</c>

00:13:26.206 --> 00:13:31.011
<c.magenta>系统中每一个线程或每一个应用</c>
<c.magenta>都从一个线程开始 叫做主线程</c>

00:13:31.979 --> 00:13:35.782
<c.magenta>该线程很特别 有几个主要功能</c>

00:13:35.849 --> 00:13:39.186
<c.magenta>主线程的第一个功能是处理输入</c>

00:13:40.254 --> 00:13:42.489
<c.magenta>如果点击应用里的一个按钮</c>

00:13:43.156 --> 00:13:45.859
<c.magenta>主线程负责处理该输入</c>

00:13:46.426 --> 00:13:47.528
<c.magenta>并作出响应</c>

00:13:49.062 --> 00:13:52.599
<c.magenta>此外 主线程还负责</c>
<c.magenta>更新界面</c>

00:13:53.300 --> 00:13:57.638
<c.magenta>这适用于比如绘制视图</c>
<c.magenta>操作布局 或动画</c>

00:13:59.339 --> 00:14:05.779
<c.magenta>当主线程空闲时 它随时备用</c>
<c.magenta>响应输入和更新用户界面</c>

00:13:59.339 --> 00:14:05.779
<c.magenta>当主线程空闲时 它随时备用</c>
<c.magenta>响应输入和更新用户界面</c>

00:14:07.247 --> 00:14:09.683
<c.magenta>但是如果在主线程上执行其他操作</c>

00:14:10.117 --> 00:14:12.819
<c.magenta>比如执行长任务</c>

00:14:12.886 --> 00:14:15.856
<c.magenta>比如昂贵的图片处理</c>

00:14:16.423 --> 00:14:18.825
<c.magenta>这类的工作将会一直占用主线程</c>

00:14:19.393 --> 00:14:20.994
<c.magenta>也就是说它不会空闲</c>

00:14:21.061 --> 00:14:24.331
<c.magenta>则无法响应输入或更新界面</c>

00:14:25.866 --> 00:14:27.935
<c.magenta>此外 我们今天关注的是</c>

00:14:28.402 --> 00:14:30.637
<c.magenta>应该避免在主线程上进行I/O</c>

00:14:31.805 --> 00:14:35.609
<c.magenta>我们已看到I/O是系统中的昂贵资源</c>

00:14:35.943 --> 00:14:37.578
<c.magenta>需要对其正确管理</c>

00:14:38.979 --> 00:14:40.714
<c.magenta>如果在主线程上进行I/O操作</c>

00:14:41.215 --> 00:14:44.117
<c.magenta>使用应用的用户会发现问题</c>

00:14:45.686 --> 00:14:48.121
<c.magenta>第一个例子是在macOS上</c>

00:14:48.755 --> 00:14:50.390
<c.magenta>用户可能会看到旋转光标</c>

00:14:51.558 --> 00:14:54.194
<c.magenta>旋转光标意味着主线程繁忙</c>

00:14:54.695 --> 00:14:57.364
<c.magenta>则无法和应用进行互动</c>

00:14:58.966 --> 00:15:00.734
<c.magenta>此外 在iOS上</c>

00:14:58.966 --> 00:15:00.734
<c.magenta>此外 在iOS上</c>

00:15:01.168 --> 00:15:05.939
<c.magenta>繁忙的主线程可能会造成</c>
<c.magenta>应用发生冻结或无法响应</c>

00:15:08.408 --> 00:15:12.479
<c.magenta>最后 在主线程上进行I/O</c>
<c.magenta>会造成动画出现问题</c>

00:15:13.347 --> 00:15:16.917
<c.magenta>比如 如果在视图表格里大幅度滚动</c>

00:15:17.317 --> 00:15:19.987
<c.magenta>然后在主线程上进行I/O</c>
<c.magenta>加载更多的数据</c>

00:15:21.121 --> 00:15:23.857
<c.magenta>应用在做这些操作时</c>

00:15:24.091 --> 00:15:26.593
<c.magenta>就无法继续显示动画</c>

00:15:26.860 --> 00:15:28.595
<c.magenta>就会造成诸如卡屏的问题</c>

00:15:29.396 --> 00:15:32.132
<c.magenta>我想再提一次</c>
<c.magenta>Kushal刚才指出的演讲</c>

00:15:32.666 --> 00:15:34.601
<c.magenta>iOS和watchOS的性能</c>

00:15:35.335 --> 00:15:39.173
<c.magenta>该演讲有很多关于</c>
<c.magenta>如何有效使用主线程的信息</c>

00:15:41.475 --> 00:15:44.411
<c.magenta>现在来看看ImageBox示例应用</c>

00:15:44.645 --> 00:15:46.146
<c.magenta>这次在macOS上运行</c>

00:15:47.114 --> 00:15:51.318
<c.magenta>我发现 当主集合视图想添加图片时</c>
<c.magenta>会产生问题</c>

00:15:52.052 --> 00:15:53.353
<c.magenta>来看一下</c>

00:15:54.788 --> 00:15:56.924
<c.magenta>首先从Xcode 点击运行按钮</c>

00:15:58.392 --> 00:15:59.960
<c.magenta>Xcode启动应用</c>

00:16:00.727 --> 00:16:03.263
<c.magenta>然后点击工具栏右边的添加按钮</c>

00:16:05.499 --> 00:16:10.003
<c.magenta>从打开的面板选中一张图片 点击打开</c>

00:16:12.706 --> 00:16:15.242
<c.magenta>如你所见 打开的面板并没有消失</c>

00:16:15.642 --> 00:16:17.010
<c.magenta>我们看到了旋转的光标</c>

00:16:18.812 --> 00:16:21.982
<c.magenta>终于 打开的面板消失了</c>

00:16:22.916 --> 00:16:26.119
<c.magenta>我们选中的图片显示在主集合视图中</c>

00:16:27.621 --> 00:16:29.022
<c.magenta>这里出了什么问题？</c>

00:16:32.025 --> 00:16:33.327
<c.magenta>我们已经知道</c>

00:16:33.994 --> 00:16:36.697
<c.magenta>旋转光标意味着主线程繁忙</c>

00:16:36.930 --> 00:16:38.765
<c.magenta>所以主线程上一定有操作在运行</c>

00:16:38.832 --> 00:16:41.735
<c.magenta>让它无法空闲</c>

00:16:41.935 --> 00:16:44.104
<c.magenta>所以我们无法和应用互动</c>

00:16:44.838 --> 00:16:46.473
<c.magenta>我们需要找出问题</c>

00:16:46.940 --> 00:16:49.243
<c.magenta>因此需要用到Instruments</c>

00:16:50.577 --> 00:16:53.580
<c.magenta>回到Xcode 可在“产品”菜单里</c>
<c.magenta>选择“配置”</c>

00:16:55.182 --> 00:16:57.684
<c.magenta>Xcode重新编译配置文件</c>

00:16:57.818 --> 00:16:59.253
<c.magenta>启动Instruments</c>

00:17:00.254 --> 00:17:02.956
<c.magenta>这次我选择Instruments里</c>
<c.magenta>时间分析器模板</c>

00:17:04.290 --> 00:17:07.426
<c.magenta>时间分析器是非常好的工具</c>
<c.magenta>用来观察耗费的时间</c>

00:17:07.493 --> 00:17:09.530
<c.magenta>每一部分代码执行时需要的</c>

00:17:10.030 --> 00:17:12.665
<c.magenta>所以我们可以利用它找出</c>
<c.magenta>为什么主线程繁忙</c>

00:17:14.401 --> 00:17:15.602
<c.magenta>点击选择</c>

00:17:16.136 --> 00:17:19.806
<c.magenta>Instruments打开</c>
<c.magenta>全新空白的时间分析器文件</c>

00:17:24.444 --> 00:17:26.880
<c.magenta>默认情况下</c>
<c.magenta>Instruments时间分析器</c>

00:17:26.946 --> 00:17:30.551
<c.magenta>只在CPU活跃执行代码时显示耗时</c>

00:17:31.818 --> 00:17:35.556
<c.magenta>其他诸如I/O的操作</c>
<c.magenta>并没有在CPU上活跃执行</c>

00:17:36.323 --> 00:17:38.358
<c.magenta>CPU会等待I/O结束</c>

00:17:39.493 --> 00:17:43.764
<c.magenta>若想在Instruments回溯中</c>
<c.magenta>看到此类操作</c>

00:17:44.031 --> 00:17:46.466
<c.magenta>首先点击“记录等待线程”选项</c>

00:17:46.667 --> 00:17:47.868
<c.magenta>在记录设置目录下</c>

00:17:48.735 --> 00:17:51.038
<c.magenta>现在Instruments也会显示耗时</c>

00:17:51.104 --> 00:17:53.140
<c.magenta>当我们进行其他操作时</c>
<c.magenta>比如等待I/O</c>

00:17:54.241 --> 00:17:57.177
<c.magenta>我们开始 点击Instruments中</c>
<c.magenta>“记录”按钮</c>

00:18:00.013 --> 00:18:03.650
<c.magenta>Instruments启动应用</c>
<c.magenta>我会做同样的操作</c>

00:18:03.717 --> 00:18:05.385
<c.magenta>和之前一样 来重现问题</c>

00:18:07.254 --> 00:18:10.791
<c.magenta>首先 点击“添加”按钮</c>
<c.magenta>选中一张图片 点击“打开”</c>

00:18:12.226 --> 00:18:13.393
<c.magenta>问题又出现了</c>

00:18:13.527 --> 00:18:15.629
<c.magenta>在Instruments里</c>
<c.magenta>点击“停止”</c>

00:18:15.963 --> 00:18:17.564
<c.magenta>看看问题所在</c>

00:18:19.233 --> 00:18:22.503
<c.magenta>在继续讲解之前 我想整理一下输出</c>

00:18:22.903 --> 00:18:25.005
<c.magenta>通过只关注我编写的代码</c>

00:18:25.305 --> 00:18:26.940
<c.magenta>而不是其他系统库</c>

00:18:27.808 --> 00:18:30.711
<c.magenta>要做到这点 首先 点击显示选项</c>

00:18:30.811 --> 00:18:32.312
<c.magenta>在Instruments右边</c>

00:18:33.881 --> 00:18:36.350
<c.magenta>然后点击“隐藏系统库”</c>

00:18:37.484 --> 00:18:40.187
<c.magenta>Instruments只显示</c>
<c.magenta>我编写的代码</c>

00:18:40.521 --> 00:18:43.223
<c.magenta>而不显示其他可能会调用的系统库</c>

00:18:45.225 --> 00:18:48.028
<c.magenta>现在我们来看</c>
<c.magenta>Instruments的主详细视图</c>

00:18:48.529 --> 00:18:51.365
<c.magenta>Instruments显示了</c>
<c.magenta>应用中所有不同线程</c>

00:18:51.431 --> 00:18:53.834
<c.magenta>和它们执行时不同的耗时数</c>

00:18:54.968 --> 00:18:57.804
<c.magenta>在本例中 我们只对主线程感兴趣</c>

00:18:58.205 --> 00:19:00.307
<c.magenta>所以我可以展开主线程部分</c>

00:18:58.205 --> 00:19:00.307
<c.magenta>所以我可以展开主线程部分</c>

00:19:02.376 --> 00:19:03.877
<c.magenta>找到最繁忙的栈</c>

00:19:07.281 --> 00:19:12.052
<c.magenta>本例中 我看到应用里有一个</c>
<c.magenta>打开的面板回调</c>

00:19:12.119 --> 00:19:14.621
<c.magenta>它在数据存储里调用一个添加方法</c>

00:19:15.522 --> 00:19:18.926
<c.magenta>该添加方法之后</c>
<c.magenta>把所有数据存储存到磁盘上</c>

00:19:20.961 --> 00:19:25.065
<c.magenta>Instruments显示</c>
<c.magenta>该存储操作耗时几乎为7秒</c>

00:19:25.632 --> 00:19:26.834
<c.magenta>这非常糟糕</c>

00:19:29.136 --> 00:19:32.906
<c.magenta>而我刚好知道该存储方法</c>
<c.magenta>正在写出一个很大的Plist</c>

00:19:33.207 --> 00:19:34.842
<c.magenta>这会让问题更为严重</c>

00:19:36.109 --> 00:19:38.145
<c.magenta>Kushal在之后的演讲</c>
<c.magenta>会提到一些方法</c>

00:19:38.212 --> 00:19:40.681
<c.magenta>来优化数据存储操作</c>

00:19:40.814 --> 00:19:42.316
<c.magenta>将使操作速度变得很快</c>

00:19:42.683 --> 00:19:46.420
<c.magenta>但现在 我只想关注如何解决这个问题</c>

00:19:46.486 --> 00:19:48.689
<c.magenta>使得无论该操作进行多久</c>

00:19:49.223 --> 00:19:51.592
<c.magenta>我们的应用响应度都非常高</c>

00:19:53.160 --> 00:19:54.761
<c.magenta>为了实现 来看一下代码</c>

00:19:56.964 --> 00:19:58.565
<c.magenta>这里是打开的面板回调</c>

00:19:59.933 --> 00:20:01.201
<c.magenta>它在等待一个响应</c>

00:19:59.933 --> 00:20:01.201
<c.magenta>它在等待一个响应</c>

00:20:02.002 --> 00:20:03.871
<c.magenta>当接受到该响应</c>

00:20:03.937 --> 00:20:07.341
<c.magenta>它将验证响应是否有一个</c>
<c.magenta>指向有效图片的URL</c>

00:20:09.243 --> 00:20:12.980
<c.magenta>然后它为图片的集合视图</c>
<c.magenta>新建一个项目</c>

00:20:13.347 --> 00:20:14.948
<c.magenta>并试图把它添加到数据存储</c>

00:20:17.150 --> 00:20:18.452
<c.magenta>如果成功了</c>

00:20:18.852 --> 00:20:21.154
<c.magenta>它会告诉主集合视图重新加载数据</c>

00:20:21.755 --> 00:20:24.858
<c.magenta>使得我们可以看见选中的图片</c>

00:20:27.094 --> 00:20:28.262
<c.magenta>如我们之前所见</c>

00:20:28.529 --> 00:20:30.497
<c.magenta>Instruments</c>
<c.magenta>也验证了这一点/b&gt;</c>

00:20:30.797 --> 00:20:32.566
<c.magenta>调用该添加方法非常昂贵</c>

00:20:32.900 --> 00:20:34.968
<c.magenta>因为它把所有的数据都存到磁盘</c>

00:20:36.803 --> 00:20:38.639
<c.magenta>看看如何进行修复</c>

00:20:40.707 --> 00:20:43.810
<c.magenta>回忆一下 应用有一个主线程</c>

00:20:44.778 --> 00:20:47.080
<c.magenta>主线程正在执行打开面板回调</c>

00:20:48.682 --> 00:20:51.618
<c.magenta>该回调在数据存储中调用添加方法</c>

00:20:51.785 --> 00:20:53.754
<c.magenta>这时我们看到旋转光标</c>

00:20:55.622 --> 00:20:56.723
<c.magenta>当所有操作完成</c>

00:20:56.990 --> 00:20:58.959
<c.magenta>才终于可以更新主集合视图</c>

00:21:00.727 --> 00:21:02.529
<c.magenta>这显然不是我们想要的</c>

00:21:03.030 --> 00:21:05.599
<c.magenta>在这整个过程中 主线程都是繁忙的</c>

00:21:06.033 --> 00:21:09.636
<c.magenta>我们无法和应用进行互动</c>
<c.magenta>也无法更新任何界面</c>

00:21:11.939 --> 00:21:16.009
<c.magenta>一种解决此问题的方法是</c>
<c.magenta>采用中央调度 即GCD</c>

00:21:17.578 --> 00:21:19.913
<c.magenta>利用GCD 可以新建调度队列</c>

00:21:21.448 --> 00:21:22.649
<c.magenta>调度队列</c>

00:21:22.716 --> 00:21:25.152
<c.magenta>是在主线程上同时运行代码的方法</c>

00:21:26.186 --> 00:21:30.524
<c.magenta>可以把昂贵的I/O相关操作</c>
<c.magenta>移动到该队列中</c>

00:21:31.024 --> 00:21:32.392
<c.magenta>让主线程空闲</c>

00:21:33.560 --> 00:21:36.396
<c.magenta>为了实现 我们可以</c>
<c.magenta>在该队列上调用async方法</c>

00:21:36.797 --> 00:21:38.298
<c.magenta>然后把昂贵的操作推入</c>

00:21:38.799 --> 00:21:40.868
<c.magenta>队列而不是主线程</c>

00:21:43.403 --> 00:21:46.874
<c.magenta>最后 由于UI相关操作</c>
<c.magenta>必须要返回主线程</c>

00:21:47.808 --> 00:21:52.079
<c.magenta>我们可以异步调度返回</c>
<c.magenta>最终更新集合视图</c>

00:21:54.414 --> 00:21:56.016
<c.magenta>现在 正是我们想要的</c>

00:21:57.417 --> 00:22:00.521
<c.magenta>昂贵的I/O操作正另一个队列中进行</c>

00:21:57.417 --> 00:22:00.521
<c.magenta>昂贵的I/O操作正另一个队列中进行</c>

00:22:00.921 --> 00:22:02.723
<c.magenta>因此主线程空闲</c>

00:22:02.789 --> 00:22:05.292
<c.magenta>也就是说我们可以跟应用进行互动</c>

00:22:05.359 --> 00:22:06.393
<c.magenta>并继续使用</c>

00:22:08.028 --> 00:22:10.697
<c.magenta>来看看在代码中实现是什么样子</c>

00:22:12.833 --> 00:22:15.302
<c.magenta>我还使用了之前同样的</c>
<c.magenta>openPanel回调</c>

00:22:16.336 --> 00:22:20.541
<c.magenta>首先新建GCD调度队列</c>

00:22:21.074 --> 00:22:22.543
<c.magenta>并提供一个描述标签</c>

00:22:24.111 --> 00:22:25.846
<c.magenta>本例中 我建立了一个队列</c>

00:22:25.913 --> 00:22:28.515
<c.magenta>可以重用所有数据存储操作</c>

00:22:30.617 --> 00:22:32.486
<c.magenta>接下来 把昂贵的操作</c>

00:22:32.553 --> 00:22:34.555
<c.magenta>当添加图片时 移动到这个队列</c>

00:22:35.022 --> 00:22:39.593
<c.magenta>在调度队列中</c>
<c.magenta>把代码块提供给async方法</c>

00:22:42.729 --> 00:22:47.868
<c.magenta>最后 要更新UI时 可以调用</c>
<c.magenta>dispatchqueue.main.async</c>

00:22:48.769 --> 00:22:51.772
<c.magenta>传入包含所有UI相关操作的代码块</c>

00:22:54.374 --> 00:22:56.443
<c.magenta>完成之后 来看结果</c>

00:22:56.510 --> 00:22:58.779
<c.magenta>如果在Xcode里重新编译运行</c>

00:23:00.080 --> 00:23:01.615
<c.magenta>首先点击“运行”按钮</c>

00:23:03.183 --> 00:23:04.785
<c.magenta>等待应用启动</c>

00:23:05.352 --> 00:23:06.920
<c.magenta>再次尝试添加图片操作</c>

00:23:08.121 --> 00:23:11.425
<c.magenta>点击“添加”按钮</c>
<c.magenta>从打开面板上选中一张图片</c>

00:23:12.392 --> 00:23:13.360
<c.magenta>点击“打开”</c>

00:23:14.962 --> 00:23:17.965
<c.magenta>可以看到 打开面板立即消失</c>

00:23:18.298 --> 00:23:20.667
<c.magenta>我们可以继续和应用进行互动</c>

00:23:20.934 --> 00:23:22.603
<c.magenta>添加更多的图片</c>

00:23:23.904 --> 00:23:27.241
<c.magenta>你还会发现 在主视图上</c>
<c.magenta>我添加了一些占位图片</c>

00:23:27.307 --> 00:23:30.744
<c.magenta>这只是表示 我们正在处理该数据</c>

00:23:30.811 --> 00:23:31.945
<c.magenta>并存到磁盘</c>

00:23:33.413 --> 00:23:35.916
<c.magenta>当所有数据完成添加和存储</c>

00:23:36.517 --> 00:23:38.785
<c.magenta>所有的图片都会显示在主集合视图</c>

00:23:38.952 --> 00:23:42.389
<c.magenta>在整个过程中 主线程都是空闲</c>

00:23:42.689 --> 00:23:44.958
<c.magenta>也就是说应用响应极为迅速</c>

00:23:45.626 --> 00:23:46.960
<c.magenta>这个结果正是我们想要的</c>

00:23:49.563 --> 00:23:53.233
<c.magenta>现在我们把操作从主线程移到</c>
<c.magenta>调度队列中</c>

00:23:53.567 --> 00:23:57.004
<c.magenta>应该考虑告诉系统该操作的内容</c>

00:23:57.070 --> 00:23:59.406
<c.magenta>使系统可以为我们管理资源</c>

00:24:00.407 --> 00:24:03.577
<c.magenta>为了实现 可以采用一种叫</c>
<c.magenta>“服务质量”的方法</c>

00:24:05.112 --> 00:24:07.814
<c.magenta>服务质量是一种方法 可以告诉系统</c>

00:24:07.881 --> 00:24:09.616
<c.magenta>正在执行的操作的内容</c>

00:24:09.983 --> 00:24:13.954
<c.magenta>使系统可以正确地管理资源</c>
<c.magenta>比如CPU或I/O</c>

00:24:16.356 --> 00:24:17.858
<c.magenta>系统管理这些资源</c>

00:24:18.125 --> 00:24:20.527
<c.magenta>在系统不同的运行中进程之间</c>

00:24:20.761 --> 00:24:22.896
<c.magenta>以及应用内部不同的线程之间</c>

00:24:24.831 --> 00:24:26.667
<c.magenta>当使用服务质量时</c>

00:24:26.900 --> 00:24:30.370
<c.magenta>请记住正在执行的工作的三个属性</c>

00:24:31.538 --> 00:24:34.141
<c.magenta>可见性 重要性和期待值</c>

00:24:35.776 --> 00:24:37.144
<c.magenta>问问自己三个问题</c>

00:24:38.412 --> 00:24:41.949
<c.magenta>正在执行的工作</c>
<c.magenta>是否对使用应用的用户可见？</c>

00:24:43.817 --> 00:24:46.286
<c.magenta>其次 该工作的重要性是什么？</c>

00:24:47.087 --> 00:24:51.291
<c.magenta>该工作是否必须完成</c>
<c.magenta>在别人可以继续使用应用之前？</c>

00:24:52.726 --> 00:24:56.263
<c.magenta>最后 该工作预计需要多久</c>

00:24:56.930 --> 00:25:01.935
<c.magenta>是否是立即发生的</c>
<c.magenta>还是估计需要很长时间的？</c>

00:24:56.930 --> 00:25:01.935
<c.magenta>是否是立即发生的</c>
<c.magenta>还是估计需要很长时间的？</c>

00:25:03.904 --> 00:25:07.774
<c.magenta>在继续之前 我想推荐</c>
<c.magenta>去年WWDC上的一个演讲</c>

00:25:08.075 --> 00:25:10.978
<c.magenta>叫作 用GCD建立响应式</c>
<c.magenta>和高效的应用</c>

00:25:11.645 --> 00:25:14.481
<c.magenta>该演讲讲解了很多GCD的细节</c>

00:25:14.748 --> 00:25:16.283
<c.magenta>以及如何使用服务质量</c>

00:25:16.550 --> 00:25:18.519
<c.magenta>我大力推荐大家观看</c>

00:25:20.988 --> 00:25:24.191
<c.magenta>当我们思考完这三个属性</c>

00:25:24.658 --> 00:25:28.095
<c.magenta>我们准备从四个服务质量类里选择一个</c>

00:25:29.796 --> 00:25:31.331
<c.magenta>第一个服务质量类</c>

00:25:31.598 --> 00:25:32.766
<c.magenta>是用户互动</c>

00:25:34.001 --> 00:25:36.703
<c.magenta>用户互动被指派给主线程</c>

00:25:37.671 --> 00:25:40.741
<c.magenta>为了完成比如响应输入和动画的操作</c>

00:25:42.776 --> 00:25:45.913
<c.magenta>所有其他和主线程异步发生的操作</c>

00:25:46.246 --> 00:25:49.750
<c.magenta>都应该使用其他三个服务质量类之一</c>

00:25:50.951 --> 00:25:53.687
<c.magenta>其中第一个是用户启动</c>

00:25:55.055 --> 00:25:58.392
<c.magenta>用户启动工作对应用用户可见</c>

00:25:58.458 --> 00:26:01.028
<c.magenta>用户期望得到立竿见影的效果</c>

00:25:58.458 --> 00:26:01.028
<c.magenta>用户期望得到立竿见影的效果</c>

00:26:01.595 --> 00:26:03.730
<c.magenta>用户可能也需要该工作结束</c>

00:26:04.064 --> 00:26:06.800
<c.magenta>在他们可以继续与应用互动之前</c>

00:26:07.734 --> 00:26:09.002
<c.magenta>一个好例子是</c>

00:26:09.069 --> 00:26:12.039
<c.magenta>如果我点击一个按钮 切换到新视图</c>

00:26:12.606 --> 00:26:15.309
<c.magenta>可能需要在不同的队列中加载资源</c>

00:26:15.676 --> 00:26:17.010
<c.magenta>为了显示该视图</c>

00:26:17.511 --> 00:26:19.913
<c.magenta>该工作应该在用户启动中进行</c>

00:26:21.648 --> 00:26:23.917
<c.magenta>服务类的第三个质量是实用工具</c>

00:26:25.085 --> 00:26:27.855
<c.magenta>实用工具服务质量通常和</c>

00:26:27.921 --> 00:26:31.291
<c.magenta>有进度条或其他活动显示器的工作相关</c>

00:26:32.159 --> 00:26:34.461
<c.magenta>该工作通常耗费很长的时间</c>

00:26:35.362 --> 00:26:38.532
<c.magenta>它也对应用用户可见</c>

00:26:39.399 --> 00:26:41.335
<c.magenta>这方面一个很好的例子是渲染电影</c>

00:26:41.869 --> 00:26:44.538
<c.magenta>它不会阻挡任何人</c>

00:26:44.605 --> 00:26:46.607
<c.magenta>继续使用你的应用</c>

00:26:46.773 --> 00:26:49.309
<c.magenta>但是它也耗费很长的时间才能完成</c>

00:26:50.911 --> 00:26:53.313
<c.magenta>最后一个服务质量类是后台</c>

00:26:54.047 --> 00:26:57.050
<c.magenta>后台操作对用户不可见</c>

00:26:57.918 --> 00:27:00.354
<c.magenta>其实 用户甚至根本不知道它正在进行</c>

00:26:57.918 --> 00:27:00.354
<c.magenta>其实 用户甚至根本不知道它正在进行</c>

00:27:01.288 --> 00:27:03.290
<c.magenta>这方面的一个好例子就是索引</c>

00:27:03.991 --> 00:27:06.760
<c.magenta>索引通常对应用性能十分重要</c>

00:27:07.461 --> 00:27:10.764
<c.magenta>但一般用户不会注意到</c>

00:27:12.866 --> 00:27:16.003
<c.magenta>所有这些服务质量类都很重要</c>

00:27:16.770 --> 00:27:19.640
<c.magenta>因为当你选择服务质量类</c>

00:27:19.706 --> 00:27:22.543
<c.magenta>它会帮助通知系统该如何管理资源</c>

00:27:22.976 --> 00:27:26.880
<c.magenta>使不太重要的工作 如后台操作和索引</c>

00:27:27.181 --> 00:27:30.551
<c.magenta>不会消极影响重要的工作 如动画</c>

00:27:31.051 --> 00:27:33.887
<c.magenta>即使该工作在不同的进程上进行</c>

00:27:36.056 --> 00:27:38.926
<c.magenta>当选择了一个服务质量类时</c>

00:27:39.426 --> 00:27:40.527
<c.magenta>有两种方法</c>

00:27:40.594 --> 00:27:43.564
<c.magenta>可以在应用中指定服务质量</c>

00:27:44.298 --> 00:27:48.368
<c.magenta>第一种方法是提供一个可选QOS参数</c>

00:27:48.435 --> 00:27:50.404
<c.magenta>给调度队列的async方法</c>

00:27:51.505 --> 00:27:54.508
<c.magenta>本例中 我指定了qos:.background</c>

00:27:55.576 --> 00:27:58.912
<c.magenta>也就是说当提供的代码块异步运行时</c>

00:27:59.446 --> 00:28:01.748
<c.magenta>它将使用后台服务质量</c>

00:27:59.446 --> 00:28:01.748
<c.magenta>它将使用后台服务质量</c>

00:28:03.517 --> 00:28:07.487
<c.magenta>此外 若正使用操作队列或操作API</c>

00:28:07.955 --> 00:28:11.291
<c.magenta>这两者都有一个服务质量属性</c>
<c.magenta>可以对其进行设置</c>

00:28:11.358 --> 00:28:12.226
<c.magenta>比如实用工具</c>

00:28:15.863 --> 00:28:18.031
<c.magenta>现在我们已经初步了解服务质量</c>

00:28:18.098 --> 00:28:19.566
<c.magenta>以及如何指定</c>

00:28:19.766 --> 00:28:21.869
<c.magenta>让我们回到ImageBox应用</c>

00:28:22.135 --> 00:28:25.706
<c.magenta>看能否为添加图片选择合适的服务质量</c>

00:28:27.040 --> 00:28:30.077
<c.magenta>为了实现这一点 我们可以思考</c>
<c.magenta>这项工作的三个属性</c>

00:28:30.377 --> 00:28:33.514
<c.magenta>可见性 重要性和期望值</c>

00:28:35.516 --> 00:28:37.751
<c.magenta>添加属性是可见的操作</c>

00:28:37.818 --> 00:28:39.386
<c.magenta>对应用用户来说</c>

00:28:40.587 --> 00:28:43.156
<c.magenta>但它不一定需要完成</c>

00:28:43.457 --> 00:28:45.292
<c.magenta>在我们可以继续做其他事之前</c>

00:28:45.359 --> 00:28:47.928
<c.magenta>比如浏览图片或添加更多图片</c>

00:28:49.563 --> 00:28:52.466
<c.magenta>此外 因为还显示了占位图片</c>

00:28:52.799 --> 00:28:55.269
<c.magenta>我们给出了指示 该操作</c>

00:28:55.335 --> 00:28:57.237
<c.magenta>可能会耗费较长时间</c>

00:28:58.772 --> 00:29:01.842
<c.magenta>出于以上种种原因 服务质量</c>

00:28:58.772 --> 00:29:01.842
<c.magenta>出于以上种种原因 服务质量</c>

00:29:02.109 --> 00:29:04.011
<c.magenta>可能是该项工作合适的选择</c>

00:29:07.114 --> 00:29:09.950
<c.magenta>现在我们知道了一些方法</c>
<c.magenta>可以移动昂贵工作</c>

00:29:10.117 --> 00:29:14.154
<c.magenta>比如I/O 让它们离开主线程</c>
<c.magenta>进入另一个调度队列</c>

00:29:14.621 --> 00:29:17.658
<c.magenta>以及如何利用服务质量指定该工作内容</c>

00:29:18.559 --> 00:29:21.495
<c.magenta>让我们来看哲学的第三支柱</c>

00:29:22.229 --> 00:29:24.064
<c.magenta>采用适当的API</c>

00:29:25.332 --> 00:29:29.069
<c.magenta>首先我要提到的就是 资产目录</c>

00:29:30.938 --> 00:29:33.307
<c.magenta>如果你还不知道 资产目录是一种方法</c>

00:29:33.373 --> 00:29:36.944
<c.magenta>可以简单地管理应用里的资源 如图片</c>

00:29:37.578 --> 00:29:40.480
<c.magenta>它们被用来存储</c>
<c.magenta>比如应用图标和启动图片</c>

00:29:41.181 --> 00:29:43.483
<c.magenta>以及所支持的不同设备上的所有图片</c>

00:29:43.550 --> 00:29:47.588
<c.magenta>以及比例系数</c>
<c.magenta>比如retina或非retina</c>

00:29:49.256 --> 00:29:50.757
<c.magenta>用SpriteKit编写游戏时</c>

00:29:50.824 --> 00:29:54.294
<c.magenta>资产目录也用来编写</c>
<c.magenta>Sprite Atlases</c>

00:29:55.562 --> 00:29:58.265
<c.magenta>可以利用资产目录来标注资源</c>

00:29:58.465 --> 00:30:00.567
<c.magenta>以服务按需资源功能</c>

00:29:58.465 --> 00:30:00.567
<c.magenta>以服务按需资源功能</c>

00:30:02.436 --> 00:30:04.972
<c.magenta>另一个使用资产目录的例子是</c>

00:30:05.038 --> 00:30:07.975
<c.magenta>在watch complications里存储资源</c>

00:30:10.244 --> 00:30:12.813
<c.magenta>为什么资产目录对I/O来说很棒？</c>

00:30:14.481 --> 00:30:17.684
<c.magenta>资产目录有一些很棒的存储效率性质</c>

00:30:19.052 --> 00:30:22.422
<c.magenta>首先 因为资产目录存储所有图片</c>

00:30:22.489 --> 00:30:24.091
<c.magenta>用同一种优化格式</c>

00:30:24.391 --> 00:30:26.593
<c.magenta>而不是许多单个文件</c>

00:30:27.928 --> 00:30:31.131
<c.magenta>你可以通过使用资产目录</c>
<c.magenta>得到较低的磁盘占用</c>

00:30:33.267 --> 00:30:36.436
<c.magenta>此外 通过iOS上的</c>
<c.magenta>如应用切片等功能</c>

00:30:37.004 --> 00:30:39.206
<c.magenta>当从App Store下载应用时</c>

00:30:39.640 --> 00:30:41.875
<c.magenta>它将利用资产目中的元数据</c>

00:30:42.176 --> 00:30:45.445
<c.magenta>决定该下载什么资源到设备上</c>

00:30:46.680 --> 00:30:49.316
<c.magenta>比如</c>
<c.magenta>若我下载一个应用到iPhone</c>

00:30:50.083 --> 00:30:52.753
<c.magenta>App Store知道</c>
<c.magenta>不需要下载任何资源</c>

00:30:52.819 --> 00:30:56.557
<c.magenta>准备给iPad或其他</c>
<c.magenta>不同屏幕分辨率的iPhone的</c>

00:30:56.924 --> 00:30:59.126
<c.magenta>这会在设备上省下不少空间</c>

00:31:01.461 --> 00:31:04.631
<c.magenta>此外 资产目录对性能也很有帮助</c>

00:31:05.566 --> 00:31:08.135
<c.magenta>因为它们存储用的优化格式</c>

00:31:08.569 --> 00:31:09.870
<c.magenta>图片加载将变得更快</c>

00:31:11.171 --> 00:31:14.141
<c.magenta>如果利用它们为游戏</c>
<c.magenta>编写Sprite Atlases</c>

00:31:15.142 --> 00:31:18.579
<c.magenta>由于用户可以很好地管理</c>
<c.magenta>一个大一点的资源</c>

00:31:18.812 --> 00:31:20.781
<c.magenta>而不是很多小的资源</c>

00:31:21.415 --> 00:31:24.351
<c.magenta>这些Sprite Atlases</c>
<c.magenta>可以加快纹理渲染时间</c>

00:31:25.986 --> 00:31:29.022
<c.magenta>最后 如果使用资产目录</c>

00:31:29.356 --> 00:31:31.391
<c.magenta>在运行macOS的硬盘机上</c>

00:31:32.326 --> 00:31:34.228
<c.magenta>还可以加快应用的启动时间</c>

00:31:35.362 --> 00:31:38.665
<c.magenta>实际上 我们看过高达百分之十的提高</c>

00:31:38.832 --> 00:31:43.103
<c.magenta>在这些机器上的应用启动时间</c>
<c.magenta>只需要切换到资产目录</c>

00:31:45.772 --> 00:31:49.443
<c.magenta>你可能会认为</c>
<c.magenta>要得到这么大的性能提高</c>

00:31:49.810 --> 00:31:53.280
<c.magenta>切换到资产目录一定很难</c>
<c.magenta>或很耗费时间</c>

00:31:54.014 --> 00:31:55.883
<c.magenta>而事实上 如果已经使用了</c>

00:31:55.949 --> 00:31:58.852
<c.magenta>标准NS图片和基于UI图片的API</c>

00:31:59.286 --> 00:32:01.321
<c.magenta>切换到资产目录很简单</c>

00:31:59.286 --> 00:32:01.321
<c.magenta>切换到资产目录很简单</c>

00:32:01.889 --> 00:32:04.658
<c.magenta>现在我想为大家</c>
<c.magenta>用一个示例项目来演示</c>

00:32:06.293 --> 00:32:09.363
<c.magenta>这里有一个还没采用资产目录的项目</c>

00:32:10.430 --> 00:32:15.068
<c.magenta>要开始 首先可从文件菜单选择新文件</c>

00:32:17.237 --> 00:32:23.977
<c.magenta>然后从资源类别 选择资产目录</c>
<c.magenta>点击下一步</c>

00:32:25.946 --> 00:32:27.748
<c.magenta>Xcode新建了一个 抱歉</c>

00:32:29.049 --> 00:32:32.386
<c.magenta>系统提示时 为资产目录</c>
<c.magenta>添加一个名称和地址</c>

00:32:33.153 --> 00:32:34.121
<c.magenta>然后点击新建</c>

00:32:34.788 --> 00:32:38.759
<c.magenta>现在Xcode为项目新建了</c>
<c.magenta>一个空白的资产目录</c>

00:32:41.094 --> 00:32:43.163
<c.magenta>要移动所有已存资产</c>

00:32:43.230 --> 00:32:45.566
<c.magenta>从项目到该新资产目录</c>

00:32:46.533 --> 00:32:48.869
<c.magenta>首先打开屏幕底部的添加菜单</c>

00:32:48.936 --> 00:32:50.504
<c.magenta>选择“从项目导入”</c>

00:32:52.639 --> 00:32:56.009
<c.magenta>Xcode会显示项目中所有图片列表</c>

00:32:56.577 --> 00:32:57.845
<c.magenta>点击“导入”</c>

00:32:58.645 --> 00:33:02.049
<c.magenta>它会把所有这些图片都移到</c>
<c.magenta>全新的空白资产目录中</c>

00:32:58.645 --> 00:33:02.049
<c.magenta>它会把所有这些图片都移到</c>
<c.magenta>全新的空白资产目录中</c>

00:33:02.683 --> 00:33:04.351
<c.magenta>Xcode自动找出</c>

00:33:04.585 --> 00:33:07.621
<c.magenta>哪些图片为哪些设备准备</c>
<c.magenta>以及以什么比例系数</c>

00:33:09.323 --> 00:33:14.061
<c.magenta>现在当重新编译应用时</c>
<c.magenta>它将使用该全新资产目录</c>

00:33:14.628 --> 00:33:15.462
<c.magenta>就这样</c>

00:33:16.063 --> 00:33:17.197
<c.magenta>用了不到一分钟</c>

00:33:17.497 --> 00:33:19.867
<c.magenta>并且不用修改任何一行代码</c>

00:33:20.467 --> 00:33:22.703
<c.magenta>真的很简单 所以我强烈鼓励</c>

00:33:22.769 --> 00:33:26.039
<c.magenta>大家采用资产目录 就在今天</c>
<c.magenta>如果你还没用</c>

00:33:28.509 --> 00:33:31.011
<c.magenta>关于资产目录 我还想提一点</c>

00:33:31.078 --> 00:33:34.214
<c.magenta>今年有一个新的功能是 图片压缩</c>

00:33:36.049 --> 00:33:39.152
<c.magenta>默认情况下 资产目录的图片</c>
<c.magenta>是无损画质</c>

00:33:40.354 --> 00:33:41.522
<c.magenta>但今年新的改变是</c>

00:33:41.588 --> 00:33:45.292
<c.magenta>可以选择一种有损图片压缩格式</c>

00:33:46.760 --> 00:33:49.429
<c.magenta>这些格式拥有硬件快速解压</c>

00:33:49.830 --> 00:33:50.931
<c.magenta>所以非常快</c>

00:33:51.899 --> 00:33:53.700
<c.magenta>因为有了这些压缩格式</c>

00:33:53.967 --> 00:33:55.936
<c.magenta>可以降低内存占用</c>

00:33:57.504 --> 00:33:59.573
<c.magenta>如果应用中有很多资产</c>

00:34:00.340 --> 00:34:03.377
<c.magenta>会在潜在内存和空间节省方面受益良多</c>

00:34:03.443 --> 00:34:04.745
<c.magenta>通过使用图片压缩</c>

00:34:06.280 --> 00:34:08.014
<c.magenta>来看看如何使用图片压缩</c>

00:34:08.382 --> 00:34:11.652
<c.magenta>回到刚转化到资产目录的项目</c>

00:34:13.187 --> 00:34:15.322
<c.magenta>首先 点击目录里的一张图片</c>

00:34:16.857 --> 00:34:19.693
<c.magenta>打开右边的实用工具侧栏</c>

00:34:21.128 --> 00:34:23.096
<c.magenta>点击属性检查器</c>

00:34:24.565 --> 00:34:27.134
<c.magenta>Xcode新包含了一个压缩弹出菜单</c>

00:34:28.202 --> 00:34:29.303
<c.magenta>选中它时</c>

00:34:29.735 --> 00:34:32.706
<c.magenta>它会显示所有可用的图片压缩格式</c>

00:34:34.842 --> 00:34:37.411
<c.magenta>本例中 我选择自动有损</c>

00:34:37.777 --> 00:34:40.880
<c.magenta>让Xcode为我选择一个好格式</c>

00:34:43.417 --> 00:34:47.420
<c.magenta>这是关于如何在应用中</c>
<c.magenta>利用资产目录的一点介绍</c>

00:34:47.487 --> 00:34:50.389
<c.magenta>采用它们 使用新的图片压缩功能</c>

00:34:51.792 --> 00:34:53.627
<c.magenta>现在我把讲台还给Kushal</c>

00:34:54.127 --> 00:34:56.396
<c.magenta>他将为大家讲解其他更多的API</c>

00:34:56.463 --> 00:34:58.632
<c.magenta>可以用来存储数据</c>

00:35:06.240 --> 00:35:07.074
<c.magenta>谢谢 Terry</c>

00:35:07.574 --> 00:35:09.843
<c.magenta>资产目录是既简单又高效的方法</c>

00:35:09.910 --> 00:35:11.278
<c.magenta>来管理应用中的资产</c>

00:35:12.679 --> 00:35:14.715
<c.magenta>我们很多人还会想到的另一件事</c>

00:35:14.781 --> 00:35:17.918
<c.magenta>是应用数据在设备上如何存储</c>
<c.magenta>和存储位置</c>

00:35:20.153 --> 00:35:22.890
<c.magenta>我们很多人对序列数据格式很熟悉</c>

00:35:22.956 --> 00:35:25.659
<c.magenta>如 Plists XML和JSON</c>

00:35:26.860 --> 00:35:28.795
<c.magenta>这些数据格式流行的原因</c>

00:35:29.062 --> 00:35:31.331
<c.magenta>是因为它们简单好用</c>

00:35:31.865 --> 00:35:35.002
<c.magenta>而且它们作为数据交换格式也流行多年</c>

00:35:35.335 --> 00:35:36.870
<c.magenta>在很多基于网络的服务中</c>

00:35:38.639 --> 00:35:41.842
<c.magenta>这些数据格式对少量只读数据很有用</c>

00:35:41.909 --> 00:35:44.878
<c.magenta>比如Info.plist文件中的</c>
<c.magenta>配置信息</c>

00:35:46.146 --> 00:35:48.282
<c.magenta>然而 它们不是数据库</c>

00:35:49.349 --> 00:35:51.418
<c.magenta>而它们不是数据库的最大原因</c>

00:35:51.485 --> 00:35:53.420
<c.magenta>是这些文件的微小更新</c>

00:35:53.487 --> 00:35:56.356
<c.magenta>都会导致整个数据文件写出到磁盘上</c>

00:35:56.557 --> 00:35:58.425
<c.magenta>这非常影响I/O效率</c>

00:35:59.693 --> 00:36:01.195
<c.magenta>为了所有数据的存储需要</c>

00:35:59.693 --> 00:36:01.195
<c.magenta>为了所有数据的存储需要</c>

00:36:01.395 --> 00:36:05.065
<c.magenta>建议使用Apple SQLite</c>
<c.magenta>数据库框架的核心数据</c>

00:36:07.234 --> 00:36:11.905
<c.magenta>核心数据是Cocoa应用开发框架</c>

00:36:12.172 --> 00:36:13.907
<c.magenta>用于管理应用数据</c>

00:36:17.644 --> 00:36:21.648
<c.magenta>它将通过采用SQLite作为</c>
<c.magenta>后备存储来处理数据持久化</c>

00:36:23.450 --> 00:36:28.422
<c.magenta>它自动管理对象 对象图形</c>
<c.magenta>和对象之间的关系</c>

00:36:28.956 --> 00:36:32.092
<c.magenta>让你更简单高效地管理数据</c>

00:36:34.228 --> 00:36:35.696
<c.magenta>它还进行修改跟踪</c>

00:36:35.762 --> 00:36:38.899
<c.magenta>可以让你在数据模型中</c>
<c.magenta>进行撤销和恢复操作</c>

00:36:40.968 --> 00:36:44.037
<c.magenta>核心数据完全集合在Xcode工具链</c>

00:36:44.104 --> 00:36:48.275
<c.magenta>因此可以建立和可视化数据模型</c>
<c.magenta>直接从Xcode UI</c>

00:36:51.545 --> 00:36:56.416
<c.magenta>现在我们知道这个优秀的工具和框架</c>
<c.magenta>可以用来设计或编写数据模型</c>

00:36:56.717 --> 00:36:58.952
<c.magenta>让我们思考该如何设计数据模型</c>

00:37:00.053 --> 00:37:04.458
<c.magenta>最好的方法是把数据模型</c>
<c.magenta>基于应用的UI需求</c>

00:37:05.993 --> 00:37:07.227
<c.magenta>回到ImageBox</c>

00:37:07.294 --> 00:37:09.630
<c.magenta>它到现在一直使用巨大的Plist</c>

00:37:09.696 --> 00:37:11.899
<c.magenta>来写出所有文件和所有图片</c>

00:37:11.965 --> 00:37:13.901
<c.magenta>和应用相关的</c>

00:37:14.902 --> 00:37:16.870
<c.magenta>现在用核心数据模型来替换它</c>

00:37:18.405 --> 00:37:22.075
<c.magenta>仔细思考该应用</c>
<c.magenta>ImageBox有两个实体</c>

00:37:23.010 --> 00:37:25.913
<c.magenta>第一个是集合视图里的项目列表</c>

00:37:27.047 --> 00:37:30.050
<c.magenta>第二个是其中每一项的相关注释</c>

00:37:31.151 --> 00:37:33.520
<c.magenta>我们来把它们放入各自的一张表里</c>

00:37:35.956 --> 00:37:37.558
<c.magenta>第一张表是BoxItem</c>

00:37:37.624 --> 00:37:40.160
<c.magenta>表示集合视图里的某些特定项目</c>

00:37:40.494 --> 00:37:43.397
<c.magenta>第二张表是注释 表示注释本身</c>

00:37:44.464 --> 00:37:46.567
<c.magenta>BoxItem表格含有一个布尔项</c>

00:37:46.767 --> 00:37:49.236
<c.magenta>表示图片是喜欢还是不喜欢</c>

00:37:49.870 --> 00:37:55.309
<c.magenta>还含有全分辨率图片 你想表示的图片</c>

00:37:56.643 --> 00:38:00.981
<c.magenta>Notes表包含BoxItem里</c>
<c.magenta>所有相关注释的主体</c>

00:37:56.643 --> 00:38:00.981
<c.magenta>Notes表包含BoxItem里</c>
<c.magenta>所有相关注释的主体</c>

00:38:01.315 --> 00:38:04.651
<c.magenta>我们把这两张表用</c>
<c.magenta>简单的一对多关系连接起来</c>

00:38:06.587 --> 00:38:10.290
<c.magenta>当使用该数据模型时</c>
<c.magenta>看看应用的性能表现</c>

00:38:10.357 --> 00:38:13.093
<c.magenta>我们发现应用启动性能非常慢</c>

00:38:14.127 --> 00:38:15.929
<c.magenta>我们用Instruments</c>
<c.magenta>调查原因</c>

00:38:16.230 --> 00:38:18.832
<c.magenta>发现应用耗费了绝大部分时间</c>

00:38:18.899 --> 00:38:21.401
<c.magenta>在启动面板上获取核心数据模型</c>

00:38:22.536 --> 00:38:25.272
<c.magenta>所以我们需要查看应用启动性能</c>

00:38:25.506 --> 00:38:26.840
<c.magenta>从核心数据的角度</c>

00:38:27.875 --> 00:38:30.544
<c.magenta>幸运的是核心数据让我们做到这一点</c>

00:38:31.545 --> 00:38:33.580
<c.magenta>它有一个工具集合 帮助你调查</c>

00:38:33.647 --> 00:38:35.582
<c.magenta>核心数据运行情况</c>

00:38:36.783 --> 00:38:40.020
<c.magenta>比如 你可在应用上设置一个启动参数</c>

00:38:40.087 --> 00:38:43.023
<c.magenta>即com.Apple.CoreData.SQLDebug</c>

00:38:43.090 --> 00:38:46.593
<c.magenta>带着速度级别</c>
<c.magenta>让你观察核心数据是如何</c>

00:38:46.660 --> 00:38:48.395
<c.magenta>和其SQLite后备存储进行互动的</c>

00:38:50.364 --> 00:38:54.501
<c.magenta>核心数据Instruments模板</c>
<c.magenta>让你观察任何模式</c>

00:38:54.568 --> 00:38:56.937
<c.magenta>关于获取和加载太多的数据</c>

00:38:59.640 --> 00:39:03.210
<c.magenta>最后 SQLite查询分析工具的</c>
<c.magenta>标准集合</c>

00:38:59.640 --> 00:39:03.210
<c.magenta>最后 SQLite查询分析工具的</c>
<c.magenta>标准集合</c>

00:39:03.377 --> 00:39:05.546
<c.magenta>比如 解释查询可用</c>

00:39:05.679 --> 00:39:07.848
<c.magenta>让你更深入到某个特定查询</c>

00:39:07.915 --> 00:39:09.249
<c.magenta>查看其性能</c>

00:39:11.652 --> 00:39:13.086
<c.magenta>想了解这些工具更详细信息</c>

00:39:13.320 --> 00:39:16.356
<c.magenta>我推荐大家查看去年WWDC文件</c>

00:39:16.423 --> 00:39:17.891
<c.magenta>“核心数据的全新功能”</c>

00:39:19.426 --> 00:39:21.528
<c.magenta>我们有了这些工具 来使用其中一个</c>

00:39:21.595 --> 00:39:23.597
<c.magenta>找到数据模型的问题</c>

00:39:25.032 --> 00:39:27.301
<c.magenta>为了实现这一点 点击项目</c>

00:39:28.135 --> 00:39:29.169
<c.magenta>点击编辑方案</c>

00:39:36.310 --> 00:39:39.279
<c.magenta>在打开的窗口中 选中参数面板</c>

00:39:41.682 --> 00:39:45.986
<c.magenta>添加一个新参数</c>
<c.magenta>com.Apple.CoreData.SQLDebug</c>

00:39:46.053 --> 00:39:47.921
<c.magenta>速度级别选择最高3</c>

00:39:53.694 --> 00:39:56.597
<c.magenta>完成后 继续点击关闭</c>

00:39:58.966 --> 00:40:01.702
<c.magenta>现在我们从Xcode UI启动应用</c>

00:39:58.966 --> 00:40:01.702
<c.magenta>现在我们从Xcode UI启动应用</c>

00:40:04.004 --> 00:40:07.674
<c.magenta>这样做将重编译项目加载并启动应用</c>

00:40:10.077 --> 00:40:13.013
<c.magenta>如你所见 控制台显示了各种日志</c>

00:40:13.080 --> 00:40:16.350
<c.magenta>关于数据模型性能的核心数据</c>

00:40:17.584 --> 00:40:18.785
<c.magenta>还会注意到的另个地方</c>

00:40:18.852 --> 00:40:21.088
<c.magenta>是该应用用了几秒的时间启动</c>

00:40:21.154 --> 00:40:22.956
<c.magenta>现在还没有结束启动</c>

00:40:25.959 --> 00:40:29.062
<c.magenta>在日志输出中 我们看到更多核心数据</c>

00:40:29.596 --> 00:40:31.398
<c.magenta>终于 应用启动完成</c>

00:40:33.066 --> 00:40:36.270
<c.magenta>回到Xcode UI</c>
<c.magenta>你可以深入挖掘所有日志</c>

00:40:36.336 --> 00:40:38.572
<c.magenta>找出数据模型的问题所在</c>

00:40:39.206 --> 00:40:41.408
<c.magenta>让我们继续 在应用中实践一下</c>

00:40:44.044 --> 00:40:45.846
<c.magenta>你在这里看到的最开始的日志之一</c>

00:40:45.913 --> 00:40:48.649
<c.magenta>是核心数据对所有行进行读取</c>

00:40:48.882 --> 00:40:52.319
<c.magenta>从SQLite数据库</c>
<c.magenta>在BoxItem表格</c>

00:40:52.386 --> 00:40:54.421
<c.magenta>这是我们想要的</c>

00:40:55.889 --> 00:41:00.060
<c.magenta>然而 下一个日志告诉我们</c>
<c.magenta>该读取操作耗费了大概9秒</c>

00:40:55.889 --> 00:41:00.060
<c.magenta>然而 下一个日志告诉我们</c>
<c.magenta>该读取操作耗费了大概9秒</c>

00:41:00.661 --> 00:41:01.595
<c.magenta>这非常糟糕</c>

00:41:01.662 --> 00:41:04.731
<c.magenta>是应用启动速度慢的最大原因</c>

00:41:06.366 --> 00:41:09.903
<c.magenta>回到之前执行读取所有这些数据的查询</c>

00:41:10.137 --> 00:41:11.238
<c.magenta>会注意到一点</c>

00:41:11.471 --> 00:41:13.507
<c.magenta>我们在读取全像素图片</c>

00:41:13.574 --> 00:41:15.876
<c.magenta>对于BoxItem表格的每一项</c>

00:41:16.176 --> 00:41:19.079
<c.magenta>尽管在启动屏幕上显示的只是缩略图</c>

00:41:20.914 --> 00:41:24.918
<c.magenta>继续 我们还发现</c>
<c.magenta>核心数据在进行一个合并操作</c>

00:41:24.985 --> 00:41:27.421
<c.magenta>在BoxItem表和Notes表间</c>

00:41:27.654 --> 00:41:30.157
<c.magenta>在从BoxItem表里读取每一项时</c>

00:41:31.258 --> 00:41:32.593
<c.magenta>这么做的原因是</c>

00:41:32.659 --> 00:41:34.561
<c.magenta>因为是一对多的关系</c>

00:41:34.628 --> 00:41:35.963
<c.magenta>在这两个实体之间</c>

00:41:36.463 --> 00:41:38.999
<c.magenta>而且我们需要</c>
<c.magenta>在启动屏幕上显示一个UI批处理</c>

00:41:39.066 --> 00:41:41.935
<c.magenta>来表示BoxItem是否有相关注释</c>

00:41:44.104 --> 00:41:46.139
<c.magenta>让我们继续修改数据模型</c>

00:41:48.008 --> 00:41:51.612
<c.magenta>首先要修改的是避免两张表的合并操作</c>

00:41:52.613 --> 00:41:54.948
<c.magenta>核心数据又做了合并操作的原因</c>

00:41:55.015 --> 00:41:58.218
<c.magenta>是因为我们需要显示UI</c>

00:41:58.285 --> 00:42:00.521
<c.magenta>对于BoxItem的注释是否出现</c>

00:41:58.285 --> 00:42:00.521
<c.magenta>对于BoxItem的注释是否出现</c>

00:42:01.989 --> 00:42:03.090
<c.magenta>所以为了改进该模型</c>

00:42:03.156 --> 00:42:05.926
<c.magenta>可以简单地在</c>
<c.magenta>BoxItem表里添加一个字段</c>

00:42:05.993 --> 00:42:07.394
<c.magenta>叫notesPresent</c>

00:42:08.428 --> 00:42:12.799
<c.magenta>该特定字段False值存在与否</c>

00:42:12.866 --> 00:42:16.236
<c.magenta>告诉我们是否需要</c>
<c.magenta>在启动屏幕上加入UI批处理</c>

00:42:18.872 --> 00:42:20.474
<c.magenta>数据模型的下一个问题</c>

00:42:20.707 --> 00:42:22.809
<c.magenta>是我们读取的是全像素图片</c>

00:42:22.876 --> 00:42:23.844
<c.magenta>在启动屏幕上</c>

00:42:24.811 --> 00:42:26.046
<c.magenta>让我们来修复它</c>

00:42:26.880 --> 00:42:29.082
<c.magenta>我们把图片数据替换为缩略图数据</c>

00:42:29.449 --> 00:42:31.752
<c.magenta>不再把全像素图片数据移动到</c>

00:42:31.818 --> 00:42:33.453
<c.magenta>它本身的表格</c>

00:42:33.887 --> 00:42:36.890
<c.magenta>而是把这两张表通过</c>
<c.magenta>一个简单的一对一关系连接起来</c>

00:42:38.759 --> 00:42:42.095
<c.magenta>如很多人知道的那样</c>
<c.magenta>这些图片会变得很大</c>

00:42:42.863 --> 00:42:45.132
<c.magenta>可能会是个好主意 来把这些图片</c>

00:42:45.199 --> 00:42:47.234
<c.magenta>作为单独的文件存储在文件系统</c>

00:42:47.301 --> 00:42:49.570
<c.magenta>而不是把它们放入SQLite数据库</c>

00:42:51.004 --> 00:42:53.006
<c.magenta>所以我们将把全像素图片</c>

00:42:53.073 --> 00:42:56.944
<c.magenta>作为数据库本身的一部分</c>
<c.magenta>取代为图片URL</c>

00:42:57.010 --> 00:42:59.046
<c.magenta>并把图片直接存在磁盘上</c>

00:43:00.747 --> 00:43:04.218
<c.magenta>现在来看看应用的启动性能</c>
<c.magenta>在修改完之后</c>

00:43:05.352 --> 00:43:07.354
<c.magenta>从Xcode UI运行项目</c>

00:43:07.421 --> 00:43:11.792
<c.magenta>采用新的数据模型 编译 启动</c>

00:43:15.229 --> 00:43:16.096
<c.magenta>如你所见</c>

00:43:16.163 --> 00:43:18.565
<c.magenta>应用启动速度快了四到五倍</c>

00:43:18.632 --> 00:43:20.100
<c.magenta>只是修改了数据模型</c>

00:43:21.034 --> 00:43:23.136
<c.magenta>所以让你的数据模型基于UI需求</c>

00:43:23.203 --> 00:43:26.707
<c.magenta>可以明显影响应用的运行和整体性能</c>

00:43:29.776 --> 00:43:32.613
<c.magenta>我们已经讲解了减少并优化</c>

00:43:32.679 --> 00:43:34.581
<c.magenta>应用I/O用量的方法</c>

00:43:34.882 --> 00:43:37.951
<c.magenta>我们接下来讲解如何测试I/O性能</c>

00:43:40.420 --> 00:43:44.091
<c.magenta>其中一点建议是在不同设备上测试应用</c>

00:43:45.259 --> 00:43:47.694
<c.magenta>如果应用发生改变 在多个平台上</c>

00:43:47.961 --> 00:43:50.297
<c.magenta>将会是一个好方法 测试你的应用</c>

00:43:50.364 --> 00:43:53.033
<c.magenta>在不同的设备 在所有这些平台上</c>

00:43:54.034 --> 00:43:56.069
<c.magenta>即使应用只在一个平台上发生改变</c>

00:43:56.270 --> 00:43:58.972
<c.magenta>跨代测试也是一个好方法</c>

00:43:59.039 --> 00:44:01.241
<c.magenta>因为I/O特性有很大不同</c>

00:43:59.039 --> 00:44:01.241
<c.magenta>因为I/O特性有很大不同</c>

00:44:04.411 --> 00:44:05.646
<c.magenta>另一个可能改变的部分</c>

00:44:05.712 --> 00:44:08.682
<c.magenta>在你的环境 和应用用户的环境之间</c>

00:44:08.749 --> 00:44:10.250
<c.magenta>是网络条件</c>

00:44:10.851 --> 00:44:12.853
<c.magenta>为了帮你测试网络条件</c>

00:44:12.920 --> 00:44:14.688
<c.magenta>或者最坏情况的网络条件</c>

00:44:15.055 --> 00:44:17.357
<c.magenta>我们提供了一个工具</c>
<c.magenta>叫做网络连接调节器</c>

00:44:19.193 --> 00:44:21.161
<c.magenta>打开网络连接调节器的方法是</c>

00:44:21.228 --> 00:44:22.229
<c.magenta>打开设置应用</c>

00:44:24.932 --> 00:44:28.001
<c.magenta>滚动到最底部 找到开发者设置</c>

00:44:31.305 --> 00:44:34.074
<c.magenta>点击开发者设置 进入这个菜单</c>

00:44:35.275 --> 00:44:37.911
<c.magenta>可以看到在这里 是网络连接调节器</c>

00:44:38.612 --> 00:44:41.348
<c.magenta>点击 打开这个菜单</c>

00:44:41.415 --> 00:44:44.518
<c.magenta>显示了可安装在设备上的各种配置文件</c>

00:44:45.185 --> 00:44:50.591
<c.magenta>有3G 高延迟DNS</c>
<c.magenta>以及我最喜欢的 非常糟糕的网络</c>

00:44:52.559 --> 00:44:55.429
<c.magenta>让我们来看看使用它的情况</c>
<c.magenta>选中“非常糟糕的网络”</c>

00:44:55.896 --> 00:44:58.599
<c.magenta>用上方的滑动按钮开启它</c>

00:45:00.467 --> 00:45:01.301
<c.magenta>就这样</c>

00:45:01.568 --> 00:45:04.238
<c.magenta>现在你的设备会表现的</c>
<c.magenta>好像处于非常糟糕的网络中</c>

00:45:04.304 --> 00:45:06.340
<c.magenta>你可以这样进行测试</c>

00:45:09.176 --> 00:45:12.679
<c.magenta>另一个需要记住的事实是</c>
<c.magenta>I/O是系统中的共享资源</c>

00:45:13.413 --> 00:45:16.650
<c.magenta>应用的I/O性能可能会受到</c>

00:45:16.717 --> 00:45:20.387
<c.magenta>其他系统资源的影响</c>
<c.magenta>或者其他设备上进行的I/O</c>

00:45:23.290 --> 00:45:27.160
<c.magenta>比如 由于多任务</c>
<c.magenta>还有其他应用正在运行</c>

00:45:27.394 --> 00:45:29.596
<c.magenta>你的应用的I/O性能可能会受到影响</c>

00:45:30.197 --> 00:45:33.634
<c.magenta>所以最好能够测试应用</c>
<c.magenta>在有其他应用的情况下</c>

00:45:35.602 --> 00:45:38.505
<c.magenta>并且 系统试图维持公平的平衡</c>

00:45:38.572 --> 00:45:40.674
<c.magenta>在内存和I/O使用之间</c>

00:45:41.341 --> 00:45:45.546
<c.magenta>在内存紧张情况下</c>
<c.magenta>I/O延迟也可能受到影响</c>

00:45:46.413 --> 00:45:49.683
<c.magenta>所以我们也建议</c>
<c.magenta>在内存紧张情况下测试应用</c>

00:45:51.685 --> 00:45:56.456
<c.magenta>最后 系统默认情况下</c>
<c.magenta>为你保留了很多缓存</c>

00:45:56.523 --> 00:45:58.592
<c.magenta>为了让你更好地访问和存储数据</c>

00:45:59.826 --> 00:46:04.798
<c.magenta>这些缓存的状态也可能影响系统</c>
<c.magenta>以及应用的I/O性能</c>

00:45:59.826 --> 00:46:04.798
<c.magenta>这些缓存的状态也可能影响系统</c>
<c.magenta>以及应用的I/O性能</c>

00:46:05.632 --> 00:46:07.701
<c.magenta>为了检测其最坏情况</c>

00:46:07.935 --> 00:46:10.938
<c.magenta>我们会建议重启iOS设备</c>

00:46:11.638 --> 00:46:13.874
<c.magenta>及macOS设备</c>
<c.magenta>可使用purge命令</c>

00:46:14.141 --> 00:46:18.645
<c.magenta>将会刷新所有缓存</c>
<c.magenta>为应用模拟最坏情况</c>

00:46:19.980 --> 00:46:21.081
<c.magenta>为了确保你的应用</c>

00:46:21.148 --> 00:46:24.318
<c.magenta>在所有这些环境变化中</c>
<c.magenta>保持性能良好</c>

00:46:24.651 --> 00:46:28.155
<c.magenta>我们建议遵循I/O哲学</c>
<c.magenta>减少和优化I/O</c>

00:46:30.023 --> 00:46:31.992
<c.magenta>这里是本次演讲的几点关键</c>

00:46:33.260 --> 00:46:38.232
<c.magenta>减少应用的I/O用量</c>
<c.magenta>因为它显著影响电池寿命</c>

00:46:40.267 --> 00:46:45.706
<c.magenta>把繁重的I/O工作量从主线程中移开</c>
<c.magenta>让主线程为UI和动画保持空闲</c>

00:46:47.641 --> 00:46:51.812
<c.magenta>指定正确的服务质量</c>
<c.magenta>为了指定正在进行的工作内容</c>

00:46:53.947 --> 00:46:57.084
<c.magenta>切换到资产目录</c>
<c.magenta>因为它们是最简单高效的方法</c>

00:46:57.150 --> 00:46:58.685
<c.magenta>来管理应用资产</c>

00:47:00.621 --> 00:47:03.023
<c.magenta>为数据库需求使用核心数据</c>

00:47:03.924 --> 00:47:06.894
<c.magenta>最后 测试和测量应用的I/O性能</c>

00:47:08.562 --> 00:47:10.931
<c.magenta>想了解更多信息</c>
<c.magenta>请访问www.developer.apple.com</c>

00:47:10.998 --> 00:47:12.966
<c.magenta>本场演讲编号为719</c>

00:47:14.968 --> 00:47:17.171
<c.magenta>本周内还会有这些相关演讲</c>

00:47:17.237 --> 00:47:20.841
<c.magenta>你可以参考更多</c>
<c.magenta>我们提到过的API和工具的细节</c>

00:47:21.575 --> 00:47:22.709
<c.magenta>谢谢大家</c>
