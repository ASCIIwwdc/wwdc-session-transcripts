WEBVTT

00:00:19.353 --> 00:00:21.355
<c.green>Metal的新特性</c>

00:00:27.261 --> 00:00:28.095
<c.green>欢迎大家的到来</c>

00:00:28.762 --> 00:00:31.765
<c.green>这是Metal的新特性的第二场演讲</c>

00:00:32.432 --> 00:00:36.803
<c.green>我叫Charles Brissart</c>
<c.green>是GPU软件工程师</c>

00:00:37.237 --> 00:00:41.008
<c.green>参加这场演讲的还有我的同事</c>
<c.green>Dan Omachi和Ana Tikhonova</c>

00:00:41.475 --> 00:00:43.977
<c.green>我要谈一下Metal的一些新特性</c>

00:00:45.445 --> 00:00:51.018
<c.green>但首先 让我们先回顾一下 WWDC</c>
<c.green>关于Metal的第一场演讲</c>

00:00:52.219 --> 00:00:55.389
<c.green>我把这前两场演讲称作采用Metal</c>

00:00:55.455 --> 00:00:58.325
<c.green>公开了Metal的一些基本概念</c>

00:00:58.759 --> 00:01:01.361
<c.green>以及一些更先进的想法</c>

00:00:58.759 --> 00:01:01.361
<c.green>以及一些更先进的想法</c>

00:01:02.896 --> 00:01:06.867
<c.green>Metal的新特性演讲</c>
<c.green>展示了我们的新特性</c>

00:01:07.968 --> 00:01:11.438
<c.green>最后 高级影子优化演讲</c>

00:01:11.972 --> 00:01:15.442
<c.green>将说明如何在不使用</c>
<c.green>着色器的情况下获得最佳性能</c>

00:01:18.278 --> 00:01:21.782
<c.green>今天早上 你们了解了曲面细分、</c>

00:01:21.849 --> 00:01:24.952
<c.green>资源堆、无记忆渲染目标</c>

00:01:25.018 --> 00:01:27.855
<c.green>以及一些GPU工具的改善</c>

00:01:29.556 --> 00:01:32.926
<c.green>今天下午 我们将讨论专用函数、</c>

00:01:32.993 --> 00:01:38.098
<c.green>资源读写函数、广颜色范围、</c>
<c.green>纹理资源</c>

00:01:38.432 --> 00:01:41.935
<c.green>以及Metal性能着色器的</c>
<c.green>一些新增功能</c>

00:01:44.004 --> 00:01:46.540
<c.green>好了 我们先讲一下专用函数</c>

00:01:48.775 --> 00:01:51.578
<c.green>它是渲染引擎中的一种常见模式</c>

00:01:52.246 --> 00:01:55.682
<c.green>用于定义一些复杂的主要函数</c>

00:01:55.749 --> 00:01:57.751
<c.green>并用这些主要函数</c>

00:01:57.818 --> 00:02:00.687
<c.green>生成最少的专用简单函数</c>

00:01:57.818 --> 00:02:00.687
<c.green>生成最少的专用简单函数</c>

00:02:01.688 --> 00:02:07.961
<c.green>理念是主要函数可以防止复制卡</c>

00:02:08.027 --> 00:02:14.101
<c.green>而专用函数由于性能的提高</c>
<c.green>变得更简单</c>

00:02:15.702 --> 00:02:17.137
<c.green>让我们看一个例子</c>

00:02:17.204 --> 00:02:19.973
<c.green>假如我们正在写一个材料函数</c>

00:02:20.040 --> 00:02:22.409
<c.green>你要写一个主要函数</c>

00:02:22.476 --> 00:02:26.380
<c.green>来执行你可能要用到的</c>
<c.green>所有材料的各个方面</c>

00:02:27.447 --> 00:02:32.152
<c.green>但是 假如你正在实施一种</c>
<c.green>亮晶晶的材料</c>

00:02:32.586 --> 00:02:36.523
<c.green>很可能就不需要反射了</c>
<c.green>但你一定需要镜面高光</c>

00:02:37.824 --> 00:02:40.561
<c.green>假如你在另一方面实施了</c>
<c.green>一种反射材料</c>

00:02:40.627 --> 00:02:44.865
<c.green>你就要给镜面高光材料也添加反射</c>

00:02:45.532 --> 00:02:48.735
<c.green>过度材料需要次表面散射</c>

00:02:48.802 --> 00:02:52.139
<c.green>但很可能不需要反射</c>
<c.green>也不需要镜面高光</c>

00:02:52.706 --> 00:02:54.808
<c.green>诸如此类 你们了解的</c>

00:02:56.410 --> 00:02:59.780
<c.green>因此</c>
<c.green>一般都是通过预处理宏来实施</c>

00:03:01.481 --> 00:03:05.452
<c.green>主要函数由一组值进行编译</c>

00:03:05.519 --> 00:03:07.855
<c.green>使宏创建专用函数</c>

00:03:08.188 --> 00:03:12.426
<c.green>这可以在运行时实现</c>
<c.green>但费用很高</c>

00:03:12.793 --> 00:03:14.428
<c.green>你还可以试试预编译</c>

00:03:14.494 --> 00:03:17.631
<c.green>预编译函数的每一个变体</c>

00:03:18.365 --> 00:03:20.267
<c.green>并把它们存储在Metal中</c>

00:03:20.334 --> 00:03:22.236
<c.green>但这需要大量的存储空间</c>

00:03:22.302 --> 00:03:24.171
<c.green>因为可能会有很多变体</c>

00:03:24.238 --> 00:03:26.240
<c.green>或者也许你不知道你需要哪个变体</c>

00:03:27.608 --> 00:03:30.477
<c.green>另一种方法是使用动态常量</c>

00:03:31.612 --> 00:03:34.748
<c.green>动态常量会防止重新编译函数</c>

00:03:34.815 --> 00:03:36.049
<c.green>然而</c>

00:03:36.116 --> 00:03:39.253
<c.green>你需要在运行时评估常量的值</c>

00:03:40.420 --> 00:03:43.524
<c.green>那会影响着色器的性能</c>

00:03:45.158 --> 00:03:48.395
<c.green>所以 我们提出了一种创建</c>
<c.green>专用函数的新方法</c>

00:03:48.795 --> 00:03:50.831
<c.green>就是用一个叫函数常量的东西</c>

00:03:51.365 --> 00:03:52.833
<c.green>函数常量是一种在Metal着色语言中</c>

00:03:52.900 --> 00:03:57.504
<c.green>直接定义的常量</c>

00:03:58.071 --> 00:04:01.141
<c.green>可编译到IR并存储在Metal库中</c>

00:03:58.071 --> 00:04:01.141
<c.green>可编译到IR并存储在Metal库中</c>

00:04:01.875 --> 00:04:05.746
<c.green>运行时可提供常量的值</c>

00:04:05.812 --> 00:04:07.881
<c.green>创建一个专用函数</c>

00:04:09.416 --> 00:04:11.251
<c.green>这种方法的优点是</c>

00:04:11.318 --> 00:04:13.687
<c.green>可以离线编译主要函数</c>

00:04:13.754 --> 00:04:15.189
<c.green>并把它存在Metal库中</c>

00:04:15.722 --> 00:04:17.089
<c.green>只需要很少的存储空间</c>

00:04:17.156 --> 00:04:19.392
<c.green>因为你只需要存储主要函数</c>

00:04:19.993 --> 00:04:24.965
<c.green>因为我们在创建专用函数时</c>
<c.green>运行了快速优化遍数</c>

00:04:25.365 --> 00:04:27.267
<c.green>你仍然能得到最佳性能</c>

00:04:29.603 --> 00:04:31.004
<c.green>让我们来看个例子</c>

00:04:31.638 --> 00:04:35.776
<c.green>这是个用了预处理宏的主要函数</c>

00:04:36.076 --> 00:04:38.645
<c.green>当然 这个例子很简单</c>

00:04:38.846 --> 00:04:40.647
<c.green>实际上主函数会更加复杂</c>

00:04:41.181 --> 00:04:43.650
<c.green>正如你所看到的 代码的不同部分</c>

00:04:43.717 --> 00:04:47.120
<c.green>都被what if语句包围着</c>

00:04:47.554 --> 00:04:50.257
<c.green>所以你可以消除代码的那个部分</c>

00:04:51.692 --> 00:04:54.394
<c.green>这是带函数常量的代码</c>

00:04:54.728 --> 00:04:58.432
<c.green>你可以看到 我们正在顶部</c>
<c.green>定义一些常量</c>

00:04:58.498 --> 00:05:00.000
<c.green>我们将在代码中使用这些常量</c>

00:05:00.601 --> 00:05:03.303
<c.green>要定义常量 就要用到常量关键字</c>

00:05:03.804 --> 00:05:06.640
<c.green>然后是类型</c>
<c.green>在这个例子中是布尔型</c>

00:05:07.174 --> 00:05:12.312
<c.green>最后是常量的名称</c>
<c.green>以及函数常量的属性</c>

00:05:13.247 --> 00:05:16.617
<c.green>函数常量属性指定了常量的值</c>

00:05:16.683 --> 00:05:19.052
<c.green>不会在编译时提供</c>

00:05:19.119 --> 00:05:22.623
<c.green>但会在运行中提供</c>
<c.green>就是当我们创建专用函数的时候</c>

00:05:23.323 --> 00:05:25.726
<c.green>你还应该注意到</c>
<c.green>我们正在传递一个索引</c>

00:05:26.093 --> 00:05:28.795
<c.green>当我们在运行中创建专用函数时</c>

00:05:28.862 --> 00:05:30.264
<c.green>除名称之外 索引也可以</c>

00:05:30.330 --> 00:05:33.367
<c.green>识别常量</c>

00:05:34.768 --> 00:05:37.504
<c.green>然后 你就可以在代码中的</c>
<c.green>任意地方使用这些常量了</c>

00:05:37.571 --> 00:05:39.072
<c.green>就像使用普通常量一样</c>

00:05:39.339 --> 00:05:41.308
<c.green>这里我们有一个简单的if语句</c>

00:05:41.375 --> 00:05:44.178
<c.green>用来限制部分代码</c>

00:05:45.846 --> 00:05:47.915
<c.green>一旦创建了主要函数</c>

00:05:47.981 --> 00:05:50.250
<c.green>并把它编译和存储在Metal库中</c>

00:05:50.651 --> 00:05:53.554
<c.green>你需要在运行时创建专用函数</c>

00:05:53.620 --> 00:05:56.657
<c.green>所以你需要提供常量值</c>

00:05:57.391 --> 00:06:01.128
<c.green>要提供常量值</c>
<c.green>我们就要用一个MTL函数常量值对象</c>

00:05:57.391 --> 00:06:01.128
<c.green>要提供常量值</c>
<c.green>我们就要用一个MTL函数常量值对象</c>

00:06:01.195 --> 00:06:03.664
<c.green>来解决多常量的值的问题</c>

00:06:04.031 --> 00:06:05.465
<c.green>一旦建好了对象</c>

00:06:05.999 --> 00:06:10.604
<c.green>就可以按名称、按索引或按名称</c>

00:06:11.371 --> 00:06:13.140
<c.green>来设置常量的值</c>

00:06:15.809 --> 00:06:17.578
<c.green>一旦创建了对象</c>

00:06:17.644 --> 00:06:20.214
<c.green>我们就能用库中的名称和常量</c>

00:06:20.280 --> 00:06:23.016
<c.green>创建专用函数</c>

00:06:23.083 --> 00:06:25.886
<c.green>简单地编码新函数</c>

00:06:26.320 --> 00:06:32.626
<c.green>提供主要函数的名称</c>
<c.green>以及我们刚填好的值</c>

00:06:33.293 --> 00:06:37.764
<c.green>这将返回一个常规的MTL函数</c>
<c.green>可以用于创建</c>

00:06:38.098 --> 00:06:42.002
<c.green>计算管道或渲染管道</c>
<c.green>取决于函数类型</c>

00:06:43.871 --> 00:06:47.941
<c.green>为了让你们更好地理解</c>
<c.green>让我们看一下编译管道</c>

00:06:49.042 --> 00:06:50.277
<c.green>在构建时</c>

00:06:50.577 --> 00:06:55.782
<c.green>用了主要函数源代码</c>
<c.green>编译并存储到Metal库中</c>

00:06:56.483 --> 00:07:02.856
<c.green>在运行时 加载了Metal库</c>
<c.green>创建了一个新函数</c>

00:06:56.483 --> 00:07:02.856
<c.green>在运行时 加载了Metal库</c>
<c.green>创建了一个新函数</c>

00:07:02.923 --> 00:07:08.428
<c.green>并用MTL函数常量值</c>
<c.green>使函数特化</c>

00:07:09.596 --> 00:07:11.465
<c.green>此时此刻 我们要运行一些优化</c>

00:07:11.532 --> 00:07:13.800
<c.green>来剔除不再使用的代码</c>

00:07:14.368 --> 00:07:17.204
<c.green>然后有一个内函数 可以用来</c>

00:07:17.571 --> 00:07:21.408
<c.green>创建一个渲染管道或计算管道</c>

00:07:24.144 --> 00:07:29.349
<c.green>你可以声明Metal所支持的任何</c>
<c.green>标量或矢量类型的常量</c>

00:07:29.416 --> 00:07:32.219
<c.green>其中有float、half、</c>
<c.green>int、uint等等</c>

00:07:32.786 --> 00:07:35.622
<c.green>在这里 我们定义half4颜色</c>

00:07:37.024 --> 00:07:43.030
<c.green>你还可以用函数常量的值</c>
<c.green>创建中间常量</c>

00:07:43.330 --> 00:07:45.732
<c.green>在这里我们定义一个布尔常量</c>

00:07:45.799 --> 00:07:48.569
<c.green>跟函数常量a的值相反</c>

00:07:49.403 --> 00:07:50.737
<c.green>这里我们正在计算一个值</c>

00:07:50.804 --> 00:07:53.574
<c.green>是基于值函数常量的值</c>

00:07:55.976 --> 00:07:58.478
<c.green>我们还有可选常量</c>

00:07:58.912 --> 00:08:01.481
<c.green>可选常量是不需要在特化函数时</c>

00:07:58.912 --> 00:08:01.481
<c.green>可选常量是不需要在特化函数时</c>

00:08:01.548 --> 00:08:04.585
<c.green>一直提供值的常量</c>

00:08:04.785 --> 00:08:08.155
<c.green>这跟在代码中</c>
<c.green>ifdef的作用完全一样</c>

00:08:08.222 --> 00:08:09.790
<c.green>当使用预处理宏时</c>

00:08:10.791 --> 00:08:14.194
<c.green>要实现此功能</c>
<c.green>就要用if函数内建的常量</c>

00:08:14.261 --> 00:08:17.297
<c.green>如果已提供了值 它将返回真</c>

00:08:17.431 --> 00:08:18.699
<c.green>反之则返回假</c>

00:08:22.269 --> 00:08:27.207
<c.green>你还可以用函数常量向函数中</c>
<c.green>添加或从函数中移除参数</c>

00:08:27.908 --> 00:08:34.014
<c.green>这有利于确定不需要绑定的</c>
<c.green>缓冲区或纹理</c>

00:08:34.081 --> 00:08:35.849
<c.green>如果你已经知道不会用到它的话</c>

00:08:36.283 --> 00:08:39.886
<c.green>还有利于替换参数类型</c>

00:08:40.320 --> 00:08:43.857
<c.green>稍后再详细介绍</c>

00:08:44.825 --> 00:08:46.326
<c.green>这里有个例子</c>

00:08:47.461 --> 00:08:50.664
<c.green>这是一个顶点函数 可以执行</c>

00:08:50.864 --> 00:08:54.268
<c.green>剥皮</c>
<c.green>取决于doSkinning常量的值</c>

00:08:56.236 --> 00:09:02.342
<c.green>函数的第一个参数是矩阵缓冲区</c>
<c.green>是否存在</c>

00:08:56.236 --> 00:09:02.342
<c.green>函数的第一个参数是矩阵缓冲区</c>
<c.green>是否存在</c>

00:09:02.409 --> 00:09:06.380
<c.green>取决于doSkinning常量真假</c>

00:09:06.713 --> 00:09:11.718
<c.green>我们用函数常量参数限制</c>
<c.green>那个参数为可选参数</c>

00:09:12.786 --> 00:09:17.157
<c.green>在代码中</c>
<c.green>仍然需要使用相同的函数常量</c>

00:09:17.224 --> 00:09:19.660
<c.green>来保护在参数中使用的代码</c>

00:09:20.227 --> 00:09:23.230
<c.green>那么我们在if语句中</c>
<c.green>用了doSkinning</c>

00:09:23.664 --> 00:09:29.136
<c.green>然后就能在代码中</c>
<c.green>安全地使用矩阵了</c>

00:09:31.004 --> 00:09:33.106
<c.green>你也可以用函数常量</c>

00:09:33.173 --> 00:09:35.943
<c.green>从阶段结构中移除参数</c>

00:09:37.077 --> 00:09:39.213
<c.green>在这里 我们有两个颜色参数</c>

00:09:39.413 --> 00:09:45.452
<c.green>float4型的第一个颜色参数</c>
<c.green>作为一个属性</c>

00:09:45.519 --> 00:09:46.920
<c.green>这是属性1</c>

00:09:48.121 --> 00:09:50.657
<c.green>第二个是精确度低的颜色</c>

00:09:50.991 --> 00:09:54.127
<c.green>是一种精度不高的颜色half4</c>

00:09:55.362 --> 00:09:57.965
<c.green>但覆盖了同样的属性索引</c>

00:09:58.966 --> 00:10:01.568
<c.green>你可以任选其一</c>

00:09:58.966 --> 00:10:01.568
<c.green>你可以任选其一</c>

00:10:01.635 --> 00:10:06.306
<c.green>这些专用于在代码中</c>

00:10:06.373 --> 00:10:07.207
<c.green>变更颜色属性的类型</c>

00:10:08.976 --> 00:10:11.445
<c.green>函数常量有一些限制</c>

00:10:11.512 --> 00:10:15.849
<c.green>比如 不能在内存中真正</c>
<c.green>变更结构的布局</c>

00:10:16.783 --> 00:10:19.152
<c.green>这可能成为一个问题</c>
<c.green>因为你可能想用</c>

00:10:19.219 --> 00:10:22.723
<c.green>不同的常量定义</c>
<c.green>不同的着色器等等</c>

00:10:23.891 --> 00:10:25.425
<c.green>但你可以迂回解决</c>

00:10:25.492 --> 00:10:28.462
<c.green>可以添加不同类型的多个参数</c>

00:10:28.996 --> 00:10:31.765
<c.green>那么在这个例子中</c>
<c.green>我们有两个缓冲参数</c>

00:10:32.499 --> 00:10:34.501
<c.green>都使用缓冲索引1</c>

00:10:35.235 --> 00:10:38.872
<c.green>它们受函数常量的约束</c>
<c.green>使用常量A和常量B</c>

00:10:41.508 --> 00:10:44.278
<c.green>一般选择其中一个</c>

00:10:44.378 --> 00:10:46.713
<c.green>请注意 我们...</c>

00:10:48.515 --> 00:10:52.753
<c.green>我们用了一个中间常量</c>
<c.green>与第一个常量相反</c>

00:10:52.819 --> 00:10:56.356
<c.green>确保在给定时间内</c>
<c.green>只存在一个参数</c>

00:10:56.523 --> 00:10:57.824
<c.green>总的来说</c>

00:10:57.891 --> 00:11:02.663
<c.green>你可在运行时用函数常量创建专用函数</c>

00:10:57.891 --> 00:11:02.663
<c.green>你可在运行时用函数常量创建专用函数</c>

00:11:03.197 --> 00:11:05.299
<c.green>无需前台编译</c>

00:11:05.365 --> 00:11:07.501
<c.green>因为我们只是使用...</c>

00:11:07.568 --> 00:11:11.071
<c.green>并且只用快速优化相来移除</c>
<c.green>不再使用的代码</c>

00:11:11.538 --> 00:11:13.073
<c.green>存储量很小</c>

00:11:13.140 --> 00:11:16.543
<c.green>因为你只需要在库中</c>
<c.green>存储主要函数</c>

00:11:17.277 --> 00:11:20.280
<c.green>你不必发行源代码</c>
<c.green>可以只发行IR</c>

00:11:20.714 --> 00:11:23.217
<c.green>最后 移除不再使用的代码</c>

00:11:23.283 --> 00:11:25.152
<c.green>会提供最佳性能</c>

00:11:27.888 --> 00:11:30.991
<c.green>现在</c>
<c.green>让我们谈一谈资源读写函数</c>

00:11:32.960 --> 00:11:35.229
<c.green>我们要介绍两个新特性</c>

00:11:35.696 --> 00:11:39.499
<c.green>缓冲区读写函数和纹理读写函数</c>

00:11:40.734 --> 00:11:45.038
<c.green>缓冲区读写函数是从任何函数类型中</c>

00:11:45.539 --> 00:11:47.207
<c.green>读入和写入缓冲区</c>

00:11:47.908 --> 00:11:51.478
<c.green>以及从任何函数类型中</c>

00:11:51.545 --> 00:11:52.713
<c.green>在缓冲区上使用原子操作</c>

00:11:53.347 --> 00:11:55.449
<c.green>你可能猜想纹理读写函数</c>

00:11:55.516 --> 00:11:58.919
<c.green>是从任何函数类型中</c>
<c.green>读入和写入纹理</c>

00:12:01.788 --> 00:12:03.323
<c.green>缓冲区读写函数</c>

00:12:03.891 --> 00:12:09.496
<c.green>在配有A9处理器的iOS</c>
<c.green>和macOS上都可用</c>

00:12:10.163 --> 00:12:13.901
<c.green>纹理读写函数在macOS上可用</c>

00:12:15.502 --> 00:12:18.071
<c.green>现在让我们讲一下</c>
<c.green>缓冲区读写函数</c>

00:12:18.172 --> 00:12:19.473
<c.green>有哪些新特性呢？</c>

00:12:19.540 --> 00:12:23.310
<c.green>新特性就是能从分段函数</c>
<c.green>向缓冲区写入</c>

00:12:23.710 --> 00:12:27.481
<c.green>以及在文本和分段函数中</c>
<c.green>使用原子操作</c>

00:12:28.148 --> 00:12:33.020
<c.green>这些可用于执行像顺序无关透明、</c>

00:12:34.021 --> 00:12:37.591
<c.green>创建影响指定瓷砖灯光的列表</c>

00:12:37.958 --> 00:12:39.893
<c.green>或只是调试着色器这样的事上</c>

00:12:41.662 --> 00:12:43.864
<c.green>让我们看一个简单的例子</c>

00:12:43.931 --> 00:12:49.636
<c.green>比如说 我们想写出正在渲染的</c>
<c.green>可见片段的位置</c>

00:12:50.537 --> 00:12:51.705
<c.green>应该是这样的</c>

00:12:52.406 --> 00:12:56.343
<c.green>有一个分段函数</c>
<c.green>我们向它传递了一个输出缓冲区</c>

00:12:56.410 --> 00:13:00.214
<c.green>输出缓冲区就是我们要储存</c>
<c.green>片段位置的地方</c>

00:12:56.410 --> 00:13:00.214
<c.green>输出缓冲区就是我们要储存</c>
<c.green>片段位置的地方</c>

00:13:02.516 --> 00:13:04.585
<c.green>然后有个计数器</c>

00:13:04.651 --> 00:13:07.354
<c.green>这是另一个缓冲区</c>
<c.green>我们开始插入原子</c>

00:13:07.421 --> 00:13:12.359
<c.green>找到位置并放入第一个缓冲区</c>

00:13:12.593 --> 00:13:14.194
<c.green>就是我们要写入的缓冲区</c>

00:13:15.529 --> 00:13:17.731
<c.green>然后 我们可以用原子预制</c>

00:13:17.798 --> 00:13:20.667
<c.green>计算已经写入的片段数量</c>

00:13:20.734 --> 00:13:22.402
<c.green>并在缓冲区生成一个索引</c>

00:13:22.836 --> 00:13:26.607
<c.green>然后把片段的位置写入缓冲区</c>

00:13:27.241 --> 00:13:29.176
<c.green>看起来还不错 但是...</c>

00:13:29.843 --> 00:13:31.011
<c.green>有个小问题</c>

00:13:33.247 --> 00:13:37.050
<c.green>当写入缓冲区时</c>
<c.green>深度测试和模板测试</c>

00:13:37.117 --> 00:13:40.120
<c.green>实际上总是在片段着色器之后进行</c>

00:13:41.088 --> 00:13:42.723
<c.green>这是个问题</c>

00:13:42.789 --> 00:13:46.326
<c.green>因为我们仍然会给缓冲区</c>
<c.green>分配权限</c>

00:13:46.393 --> 00:13:49.363
<c.green>这并不是我们想要的</c>
<c.green>我们只想使片段可见</c>

00:13:50.030 --> 00:13:54.334
<c.green>这也是需要注意的</c>
<c.green>因为它会影响你的性能</c>

00:13:54.401 --> 00:13:57.437
<c.green>这意味着</c>
<c.green>我们没有做任何早期的Z优化</c>

00:13:58.005 --> 00:14:01.775
<c.green>所以很可能会在不想展示</c>
<c.green>片段着色器时展示它</c>

00:13:58.005 --> 00:14:01.775
<c.green>所以很可能会在不想展示</c>
<c.green>片段着色器时展示它</c>

00:14:03.277 --> 00:14:07.181
<c.green>幸运的是 我们有个新特性</c>
<c.green>限定词早期片段测试</c>

00:14:07.915 --> 00:14:10.918
<c.green>用于强制在片段着色器之前执行</c>

00:14:11.285 --> 00:14:13.220
<c.green>深度测试和模板测试</c>

00:14:13.587 --> 00:14:16.456
<c.green>结果是 如果深度测试失败</c>

00:14:16.924 --> 00:14:19.526
<c.green>我们将跳过片段着色器的执行</c>

00:14:20.327 --> 00:14:22.529
<c.green>因此不会写入缓冲区</c>

00:14:22.863 --> 00:14:24.398
<c.green>这正是我们所需要的</c>

00:14:24.998 --> 00:14:26.633
<c.green>到达最后一个带早期片段</c>

00:14:27.034 --> 00:14:29.136
<c.green>测试属性的函数</c>

00:14:29.570 --> 00:14:32.339
<c.green>否则只当片段可见时</c>

00:14:33.073 --> 00:14:35.042
<c.green>执行函数</c>

00:14:37.211 --> 00:14:40.147
<c.green>现在让我们谈谈纹理读写函数</c>

00:14:40.614 --> 00:14:44.418
<c.green>新特性是可以从定点函数</c>

00:14:44.484 --> 00:14:46.587
<c.green>和分段函数中创建纹理</c>

00:14:47.154 --> 00:14:52.626
<c.green>以及从单一函数读入</c>
<c.green>和写入纹理</c>

00:14:53.293 --> 00:14:54.761
<c.green>可以用于 比如说</c>

00:14:54.828 --> 00:14:57.931
<c.green>在执行后置处理效果时</c>
<c.green>节约内存</c>

00:14:58.298 --> 00:15:01.168
<c.green>通过在输入和输出中</c>
<c.green>使用同一种纹理</c>

00:14:58.298 --> 00:15:01.168
<c.green>通过在输入和输出中</c>
<c.green>使用同一种纹理</c>

00:15:04.071 --> 00:15:06.073
<c.green>写入纹理是非常简单的</c>

00:15:06.406 --> 00:15:10.344
<c.green>你只需要把纹理定义为</c>
<c.green>访问限制符写入</c>

00:15:10.410 --> 00:15:12.880
<c.green>就可以写入纹理了</c>

00:15:16.016 --> 00:15:17.217
<c.green>读写纹理</c>

00:15:17.284 --> 00:15:21.755
<c.green>是一种能在着色器中</c>
<c.green>读和写的纹理</c>

00:15:22.289 --> 00:15:25.526
<c.green>只支持数量有限的几个格式</c>

00:15:26.260 --> 00:15:27.861
<c.green>要使用读写纹理</c>

00:15:28.128 --> 00:15:30.831
<c.green>就要使用读写的访问限制符</c>

00:15:31.698 --> 00:15:36.603
<c.green>然后你就可以在着色器中</c>
<c.green>读入并写入纹理了</c>

00:15:38.672 --> 00:15:41.608
<c.green>然而 写入纹理时得注意一下</c>

00:15:41.675 --> 00:15:47.714
<c.green>如果你想在着色器中再次</c>
<c.green>读到相同的像素</c>

00:15:48.515 --> 00:15:51.185
<c.green>在这个例子中</c>
<c.green>你需要使用纹理栅栏</c>

00:15:51.518 --> 00:15:55.989
<c.green>纹理栅栏会确保把写入</c>
<c.green>交付给内存</c>

00:15:56.056 --> 00:15:58.225
<c.green>这样就能读取正确的值</c>

00:15:59.726 --> 00:16:03.463
<c.green>在这里 我们写入一个给定的像素</c>

00:15:59.726 --> 00:16:03.463
<c.green>在这里 我们写入一个给定的像素</c>

00:16:04.064 --> 00:16:09.002
<c.green>然后 我们使用纹理栅栏</c>
<c.green>确保可以再次读取那个值</c>

00:16:09.636 --> 00:16:11.672
<c.green>再然后 我们最终读到了值</c>

00:16:12.739 --> 00:16:14.875
<c.green>我们也应该注意纹理栅栏</c>

00:16:14.942 --> 00:16:17.778
<c.green>因为它们只能在</c>
<c.green>单一SIMD线程上应用</c>

00:16:18.712 --> 00:16:22.049
<c.green>意思就是</c>
<c.green>如果有两个正在写入纹理的线程</c>

00:16:23.050 --> 00:16:24.651
<c.green>并且第二个线程</c>

00:16:24.718 --> 00:16:28.422
<c.green>正在读取由第一个线程写入的值</c>

00:16:29.590 --> 00:16:32.793
<c.green>就算在纹理栅栏之后读取</c>
<c.green>也不能读到</c>

00:16:34.528 --> 00:16:36.563
<c.green>能读到的情况是每个线程</c>

00:16:36.630 --> 00:16:40.067
<c.green>读取被各自写入的像素值</c>

00:16:40.133 --> 00:16:42.736
<c.green>而不能读取由其他线程写入的值</c>

00:16:44.538 --> 00:16:45.939
<c.green>这是关于读取的一个小贴士</c>

00:16:46.006 --> 00:16:48.876
<c.green>我们谈了很多写入缓冲区和纹理</c>

00:16:49.443 --> 00:16:52.980
<c.green>你应该注意顶点函数和分段函数</c>

00:16:53.914 --> 00:16:57.918
<c.green>在这个例子中</c>
<c.green>分段函数正写入一个缓冲区</c>

00:16:58.318 --> 00:17:01.088
<c.green>而顶点函数正读取结果</c>

00:16:58.318 --> 00:17:01.088
<c.green>而顶点函数正读取结果</c>

00:17:01.488 --> 00:17:05.092
<c.green>但是这并不能成功</c>
<c.green>因为它们的RenderCommandEncoder相同</c>

00:17:05.925 --> 00:17:10.364
<c.green>要解决这个问题</c>
<c.green>需要使用两个RenderCommandEncoder</c>

00:17:11.365 --> 00:17:15.234
<c.green>分段函数写入第一个</c>
<c.green>RenderCommandEncoder中的缓冲区</c>

00:17:15.402 --> 00:17:18.372
<c.green>而顶点函数写入第二个</c>
<c.green>RenderCommandEncoder中的缓冲区</c>

00:17:18.438 --> 00:17:21.008
<c.green>最终读取并获得正确的结果</c>

00:17:21.508 --> 00:17:26.547
<c.green>要注意的是</c>
<c.green>没有必要使用计算着色器</c>

00:17:26.613 --> 00:17:29.149
<c.green>可以在同一个计算</c>
<c.green>CommandEncoder中实现</c>

00:17:30.484 --> 00:17:32.920
<c.green>总之 我们引入了两个新函数</c>

00:17:33.287 --> 00:17:36.823
<c.green>缓冲区读写函数和纹理读写函数</c>

00:17:37.224 --> 00:17:39.326
<c.green>可以用早期片段测试</c>

00:17:39.626 --> 00:17:42.362
<c.green>来确保在执行片段着色器之前</c>

00:17:42.930 --> 00:17:45.232
<c.green>完成深度测试和模具测试</c>

00:17:45.766 --> 00:17:49.102
<c.green>要从一直在写入的读写纹理中读取数据</c>

00:17:49.169 --> 00:17:52.673
<c.green>应该使用纹理栅栏</c>

00:17:53.340 --> 00:17:57.177
<c.green>最后 用顶点着色器和片段着色器</c>
<c.green>写入缓冲区时</c>

00:17:57.711 --> 00:18:00.314
<c.green>就要使用不同的</c>
<c.green>RenderCommandEncoder</c>

00:17:57.711 --> 00:18:00.314
<c.green>就要使用不同的</c>
<c.green>RenderCommandEncoder</c>

00:18:00.380 --> 00:18:02.015
<c.green>要读取结果</c>

00:18:04.218 --> 00:18:07.888
<c.green>接下来</c>
<c.green>我要把舞台交给Dan Omachi</c>

00:18:07.955 --> 00:18:09.790
<c.green>他会跟大家谈一谈广颜色范围</c>

00:18:13.760 --> 00:18:14.895
<c.green>谢谢Charles</c>

00:18:15.596 --> 00:18:17.598
<c.green>Charles说过了</c>
<c.green>我叫Dan Omachi</c>

00:18:17.664 --> 00:18:20.567
<c.green>我是Apple GPU软件架构团队</c>
<c.green>的一名工程师</c>

00:18:21.368 --> 00:18:24.471
<c.green>我想先从色彩管理谈起</c>

00:18:24.738 --> 00:18:29.877
<c.green>实际上 这并不是一个</c>
<c.green>所有开发人员都熟悉的话题</c>

00:18:32.145 --> 00:18:35.582
<c.green>如果你是个美工</c>

00:18:35.649 --> 00:18:40.053
<c.green>无论是为游戏创建资源的纹理美工</c>

00:18:40.320 --> 00:18:43.390
<c.green>还是编辑照片的摄影师</c>

00:18:44.057 --> 00:18:46.093
<c.green>你心里都会有一个特殊的色系</c>

00:18:46.159 --> 00:18:49.496
<c.green>你会很认真地挑选颜色</c>

00:18:50.264 --> 00:18:52.666
<c.green>并且要保持一致性</c>

00:18:53.300 --> 00:18:57.604
<c.green>无论内容会在哪种</c>
<c.green>显示屏上显示</c>

00:18:58.505 --> 00:19:01.842
<c.green>作为开发者和软件工程师</c>
<c.green>我们有责任</c>

00:18:58.505 --> 00:19:01.842
<c.green>作为开发者和软件工程师</c>
<c.green>我们有责任</c>

00:19:01.909 --> 00:19:04.178
<c.green>保证这种一致性</c>

00:19:05.412 --> 00:19:07.648
<c.green>如果你正用一种高层框架</c>

00:19:07.714 --> 00:19:11.285
<c.green>比如SceneKit、</c>
<c.green>SpriteKit或核心图像</c>

00:19:11.718 --> 00:19:13.420
<c.green>那么大部分工作已经完成了</c>

00:19:13.487 --> 00:19:16.590
<c.green>应用开发人员不需要</c>
<c.green>再考虑一致性的问题了</c>

00:19:17.858 --> 00:19:21.128
<c.green>然而</c>
<c.green>Metal是一个层级低得多的API</c>

00:19:22.729 --> 00:19:26.266
<c.green>这就会提供强化的性能和一些灵活性</c>

00:19:26.633 --> 00:19:30.270
<c.green>但也会把其中一些责任转到你身上</c>

00:19:31.972 --> 00:19:32.806
<c.green>为什么呢？</c>

00:19:33.740 --> 00:19:37.911
<c.green>很多年前 你就已经能用</c>
<c.green>Apple设备上的</c>

00:19:38.378 --> 00:19:40.480
<c.green>不同色彩空间的不同显示屏了</c>

00:19:41.715 --> 00:19:46.520
<c.green>嗯 去年年底</c>
<c.green>Apple引入了几台iMacs</c>

00:19:46.587 --> 00:19:52.326
<c.green>它的显示屏能在</c>
<c.green>P3色彩空间渲染颜色</c>

00:19:52.759 --> 00:19:57.965
<c.green>今年四月我们引入了</c>
<c.green>9.7英寸的iPad Pro</c>

00:19:58.332 --> 00:20:01.034
<c.green>也有一个P3显示屏</c>

00:19:58.332 --> 00:20:01.034
<c.green>也有一个P3显示屏</c>

00:20:01.869 --> 00:20:04.037
<c.green>那么 什么是P3色彩空间呢？</c>

00:20:04.104 --> 00:20:06.340
<c.green>嗯 这是一个色度图</c>

00:20:06.406 --> 00:20:11.545
<c.green>从概念上讲</c>
<c.green>这个图呈现了可见光谱中的所有颜色</c>

00:20:12.112 --> 00:20:15.716
<c.green>换句话说</c>
<c.green>就是普通人肉眼可见的所有颜色</c>

00:20:17.584 --> 00:20:19.820
<c.green>虽然如此 这个三角形内的色彩</c>

00:20:20.087 --> 00:20:25.225
<c.green>是一个标准的sRGB显示屏</c>
<c.green>所能呈现的色彩</c>

00:20:27.361 --> 00:20:31.765
<c.green>P3显示屏可以呈现</c>

00:20:31.832 --> 00:20:35.135
<c.green>色度更宽的色彩</c>

00:20:37.171 --> 00:20:39.373
<c.green>这是它在macOS上的应用</c>

00:20:41.108 --> 00:20:44.311
<c.green>我们希望你能在任何</c>
<c.green>色彩空间进行渲染</c>

00:20:45.612 --> 00:20:49.249
<c.green>而且我也提到了</c>
<c.green>高层框架会处理这个</c>

00:20:49.716 --> 00:20:52.252
<c.green>色彩管理的问题</c>

00:20:52.319 --> 00:20:54.922
<c.green>通过执行一种</c>
<c.green>叫做颜色匹配的运算实现</c>

00:20:54.988 --> 00:20:56.990
<c.green>颜色和色彩空间</c>

00:20:57.057 --> 00:21:00.194
<c.green>与显示屏的色彩空间相匹配</c>

00:20:57.057 --> 00:21:00.194
<c.green>与显示屏的色彩空间相匹配</c>

00:21:00.260 --> 00:21:02.829
<c.green>这样就能在显示屏上</c>
<c.green>得到相同的亮度</c>

00:21:02.896 --> 00:21:05.399
<c.green>不管你正在处理的色彩空间</c>

00:21:05.599 --> 00:21:06.800
<c.green>是否显示</c>

00:21:08.202 --> 00:21:13.640
<c.green>Metal视图默认没有色彩管理</c>

00:21:14.441 --> 00:21:16.410
<c.green>跳过了这个颜色匹配运算</c>

00:21:17.444 --> 00:21:19.947
<c.green>这一般会强化性能</c>

00:21:21.849 --> 00:21:23.784
<c.green>因此 默认情况是</c>

00:21:24.017 --> 00:21:26.887
<c.green>忽略显示屏的颜色配置文件</c>

00:21:27.888 --> 00:21:31.458
<c.green>因此 显示屏会在自己的色彩空间</c>

00:21:32.025 --> 00:21:33.560
<c.green>解释颜色</c>

00:21:34.862 --> 00:21:37.231
<c.green>意思就是 sRGB颜色</c>

00:21:37.531 --> 00:21:39.600
<c.green>会被解释为P3颜色</c>

00:21:39.900 --> 00:21:42.336
<c.green>而两者之间的渲染将会不一致</c>

00:21:42.402 --> 00:21:46.507
<c.green>如果这是你的应用 带sRGB绘制</c>

00:21:47.508 --> 00:21:49.676
<c.green>这是显示屏</c>

00:21:50.644 --> 00:21:56.416
<c.green>嗯 当调用当前的绘制时</c>
<c.green>这些颜色会变得更饱和</c>

00:21:56.950 --> 00:21:58.118
<c.green>为什么会这样呢？</c>

00:21:58.485 --> 00:22:00.587
<c.green>让我们再回去看色度图</c>

00:21:58.485 --> 00:22:00.587
<c.green>让我们再回去看色度图</c>

00:22:02.789 --> 00:22:05.225
<c.green>这是你能在sRGB色彩空间中</c>

00:22:05.292 --> 00:22:08.529
<c.green>呈现的最绿的颜色</c>

00:22:09.062 --> 00:22:11.398
<c.green>在片段着色器中</c>

00:22:12.065 --> 00:22:15.769
<c.green>应该呈现为红色通道为0.0</c>

00:22:15.836 --> 00:22:20.107
<c.green>绿色通道为1.0</c>
<c.green>而蓝色通道为0.0</c>

00:22:20.841 --> 00:22:24.845
<c.green>嗯 P3显示屏只取原始值</c>

00:22:25.078 --> 00:22:26.079
<c.green>并做出解释</c>

00:22:26.580 --> 00:22:29.783
<c.green>从根本上说</c>
<c.green>它认为那是一个P3颜色</c>

00:22:30.217 --> 00:22:34.955
<c.green>所以你得到的是一个</c>
<c.green>最绿的P3显示颜色</c>

00:22:35.022 --> 00:22:37.457
<c.green>对于内容创作应用来说</c>

00:22:38.292 --> 00:22:42.329
<c.green>碰巧是一个不同的绿色</c>

00:22:42.596 --> 00:22:44.431
<c.green>把这个搞清楚相当重要</c>

00:22:44.498 --> 00:22:49.203
<c.green>因为美工们经过深思熟虑</c>

00:22:49.436 --> 00:22:51.338
<c.green>来渲染色彩</c>

00:22:52.472 --> 00:22:56.410
<c.green>对于游戏来说 效果更微妙</c>

00:22:58.412 --> 00:23:02.783
<c.green>但如果设计师和美工</c>

00:22:58.412 --> 00:23:02.783
<c.green>但如果设计师和美工</c>

00:23:02.850 --> 00:23:06.086
<c.green>正在寻找这种黑暗的主题</c>

00:23:06.486 --> 00:23:11.158
<c.green>他们一定会非常失望</c>
<c.green>因为 看起来要愉快得多</c>

00:23:11.225 --> 00:23:12.726
<c.green>当你在P3显示屏中插入它时</c>

00:23:13.727 --> 00:23:16.663
<c.green>同时 这个问题可能会更糟糕</c>

00:23:16.897 --> 00:23:21.235
<c.green>因为产业正在朝更宽的</c>
<c.green>色域显示屏前进</c>

00:23:24.304 --> 00:23:28.008
<c.green>解决方案真的很简单</c>

00:23:28.842 --> 00:23:33.647
<c.green>在NSWindow或CAMetal上</c>
<c.green>启动色彩管理</c>

00:23:33.714 --> 00:23:36.650
<c.green>把色彩空间设置为</c>
<c.green>你正在使用的色彩空间</c>

00:23:36.717 --> 00:23:38.819
<c.green>很可能是sRGB色彩空间</c>

00:23:39.353 --> 00:23:42.723
<c.green>这会使OS执行颜色匹配</c>

00:23:42.789 --> 00:23:46.527
<c.green>作为它的窗口服务器的</c>
<c.green>常规影像合成传输的一部分</c>

00:23:46.593 --> 00:23:49.997
<c.green>那么 如果这是你的显示屏</c>

00:23:50.364 --> 00:23:53.300
<c.green>抱歉 这是带sRGB绘制的应用</c>

00:23:53.634 --> 00:23:54.868
<c.green>这是显示屏</c>

00:23:56.436 --> 00:23:59.740
<c.green>当你调用当前绘制时</c>
<c.green>窗口服务器会取走你的绘制</c>

00:24:00.774 --> 00:24:04.578
<c.green>并在把它拍到玻璃上之前</c>
<c.green>执行颜色匹配</c>

00:24:06.980 --> 00:24:09.616
<c.green>好了 那么现在</c>
<c.green>你已经获得了一致性</c>

00:24:09.683 --> 00:24:12.386
<c.green>如果你想采用范围更广的颜色</c>
<c.green>会怎么样呢？</c>

00:24:12.986 --> 00:24:18.358
<c.green>你想有目的地渲染</c>
<c.green>那些更强烈的色彩</c>

00:24:18.425 --> 00:24:21.195
<c.green>广色域显示屏只能渲染</c>

00:24:21.995 --> 00:24:25.032
<c.green>嗯 首先 你需要创建一些内容</c>

00:24:25.098 --> 00:24:27.768
<c.green>你需要让美工</c>
<c.green>创建范围更广的内容</c>

00:24:28.769 --> 00:24:31.805
<c.green>为此 我们建议使用</c>

00:24:31.872 --> 00:24:36.210
<c.green>扩展范围的sRGB色彩空间</c>

00:24:37.411 --> 00:24:41.882
<c.green>这就允许不能在范围更广的</c>
<c.green>颜色中使用的现有资源</c>

00:24:41.949 --> 00:24:44.551
<c.green>能继续正常使用</c>

00:24:44.618 --> 00:24:48.021
<c.green>而着色器管道</c>
<c.green>不必执行任何额外操作</c>

00:24:49.122 --> 00:24:51.358
<c.green>然而 美工可以创建</c>

00:24:51.425 --> 00:24:54.161
<c.green>新的范围更宽的色彩资源</c>

00:24:54.261 --> 00:24:56.730
<c.green>可提供更强的色彩</c>

00:24:59.633 --> 00:25:03.303
<c.green>那么</c>
<c.green>到底什么是扩展范围sRGB呢？</c>

00:24:59.633 --> 00:25:03.303
<c.green>那么</c>
<c.green>到底什么是扩展范围sRGB呢？</c>

00:25:03.370 --> 00:25:07.808
<c.green>嗯 这是sRGB三角</c>
<c.green>而这是P3三角</c>

00:25:10.911 --> 00:25:12.212
<c.green>扩展范围sRGB</c>

00:25:12.279 --> 00:25:15.115
<c.green>会在各个方位超出无穷大</c>

00:25:15.182 --> 00:25:20.621
<c.green>意思是在着色器中</c>
<c.green>超出0到1的值</c>

00:25:20.888 --> 00:25:24.124
<c.green>代表只能查看的值</c>

00:25:24.391 --> 00:25:28.495
<c.green>在比sRGB色彩显示屏</c>
<c.green>更广的色彩显示屏上</c>

00:25:30.430 --> 00:25:33.667
<c.green>我提到了超出0到1的值</c>

00:25:34.334 --> 00:25:37.905
<c.green>意思就是</c>
<c.green>你需要使用浮点像素格式</c>

00:25:37.971 --> 00:25:39.806
<c.green>来表达这些值</c>

00:25:40.774 --> 00:25:44.611
<c.green>对于纹理源 我们有一些格式建议</c>

00:25:45.045 --> 00:25:48.315
<c.green>你可以使用BC6H浮点格式</c>

00:25:48.415 --> 00:25:51.018
<c.green>这是一种</c>
<c.green>提供高性能的压缩格式</c>

00:25:51.084 --> 00:25:54.555
<c.green>以及二进制浮点格式</c>
<c.green>和分享指数格式</c>

00:25:55.322 --> 00:25:59.293
<c.green>对于渲染目标</c>
<c.green>可以使用二进制浮点格式</c>

00:25:59.793 --> 00:26:03.697
<c.green>或RGBA半浮点格式</c>

00:25:59.793 --> 00:26:03.697
<c.green>或RGBA半浮点格式</c>

00:26:03.764 --> 00:26:07.267
<c.green>指定更强烈的颜色</c>

00:26:09.269 --> 00:26:12.072
<c.green>iOS上的色彩管理比较简单</c>

00:26:12.873 --> 00:26:15.843
<c.green>你总是在sRGB色彩空间中</c>
<c.green>进行渲染</c>

00:26:17.377 --> 00:26:19.613
<c.green>即使目标是P3显示屏也一样</c>

00:26:19.847 --> 00:26:23.016
<c.green>颜色是自动匹配的</c>
<c.green>没有性能损失</c>

00:26:24.117 --> 00:26:26.320
<c.green>如果你想使用范围更广的颜色</c>

00:26:26.820 --> 00:26:29.923
<c.green>你可以用一些原本就可以</c>

00:26:31.024 --> 00:26:33.560
<c.green>被显示屏读取的新像素格式</c>

00:26:34.027 --> 00:26:36.763
<c.green>并不需要任何影像合成运算</c>

00:26:37.798 --> 00:26:40.534
<c.green>它们可以进行伽马编码</c>
<c.green>提供效果更好的黑色</c>

00:26:40.601 --> 00:26:43.737
<c.green>并允许你在着色器中</c>
<c.green>进行线性混合</c>

00:26:44.471 --> 00:26:47.808
<c.green>并且它们作为纹理源</c>
<c.green>是很有效率的</c>

00:26:48.942 --> 00:26:52.145
<c.green>好了 这是新格式的位元布局</c>

00:26:52.212 --> 00:26:58.585
<c.green>有一个32位元的RGB格式</c>
<c.green>每种通道10个位元</c>

00:26:59.386 --> 00:27:01.722
<c.green>还有一个RGBA格式</c>

00:26:59.386 --> 00:27:01.722
<c.green>还有一个RGBA格式</c>

00:27:01.788 --> 00:27:05.158
<c.green>每种通道10个位元</c>
<c.green>扩展到了64个位元</c>

00:27:05.826 --> 00:27:10.197
<c.green>现在 这个10位元的值是...</c>

00:27:10.864 --> 00:27:13.267
<c.green>它们可以用</c>
<c.green>超出0到1之间的值来表达</c>

00:27:13.600 --> 00:27:18.172
<c.green>从0到384的值表示负值</c>

00:27:18.438 --> 00:27:22.409
<c.green>往后的510个值 从384到894</c>

00:27:22.476 --> 00:27:24.678
<c.green>代表0和1之间的值</c>

00:27:24.745 --> 00:27:29.516
<c.green>而大于894的值代表</c>
<c.green>这些更强烈的值</c>

00:27:30.350 --> 00:27:34.788
<c.green>请注意 RGBA像素格式</c>

00:27:35.322 --> 00:27:37.291
<c.green>比RGB格式大两倍</c>

00:27:37.357 --> 00:27:39.393
<c.green>因此也会占用两倍的内存</c>

00:27:39.459 --> 00:27:43.964
<c.green>并占用两倍的带宽</c>

00:27:44.631 --> 00:27:47.067
<c.green>一般来说 我们建议</c>

00:27:47.134 --> 00:27:50.704
<c.green>只在CAMetal层中使用</c>

00:27:51.238 --> 00:27:53.507
<c.green>如果你需要不透明度的话</c>

00:27:55.642 --> 00:28:00.314
<c.green>那么你决定要创建一些</c>
<c.green>广色域的内容</c>

00:27:55.642 --> 00:28:00.314
<c.green>那么你决定要创建一些</c>
<c.green>广色域的内容</c>

00:28:02.649 --> 00:28:04.852
<c.green>该如何实现呢？</c>
<c.green>嗯 你有一个美工</c>

00:28:05.185 --> 00:28:11.725
<c.green>作者在macOS上使用</c>
<c.green>支持P3色彩空间的图片编辑器</c>

00:28:12.059 --> 00:28:13.660
<c.green>比如Adobe Photoshop</c>

00:28:15.162 --> 00:28:20.000
<c.green>你可使用显示屏的P3色彩配置文件</c>
<c.green>把图片保存为每个通道</c>

00:28:20.067 --> 00:28:22.503
<c.green>16个位元的PNG或JPEG</c>

00:28:24.705 --> 00:28:28.976
<c.green>得到这个图片后</c>
<c.green>要如何创建纹理呢？</c>

00:28:29.676 --> 00:28:31.178
<c.green>有两种解决方案</c>

00:28:32.112 --> 00:28:35.516
<c.green>第一种是</c>
<c.green>创建自己的资源调节工具</c>

00:28:36.250 --> 00:28:41.054
<c.green>使用每个通道16位元的</c>
<c.green>适应P3显示模式的图片实现</c>

00:28:41.555 --> 00:28:42.890
<c.green>你可以通过使用ImageIO</c>

00:28:42.956 --> 00:28:47.427
<c.green>或vImage框架的</c>

00:28:47.995 --> 00:28:51.532
<c.green>扩展sRGB浮点色彩</c>
<c.green>空间进行转换</c>

00:28:52.366 --> 00:28:55.435
<c.green>然后在macOS上 你可以转换为</c>

00:28:55.502 --> 00:28:58.505
<c.green>我之前提到过的</c>
<c.green>浮点像素格式中的一种</c>

00:28:58.639 --> 00:29:00.140
<c.green>在iOS上 你可以转换为</c>

00:28:58.639 --> 00:29:00.140
<c.green>在iOS上 你可以转换为</c>

00:29:00.207 --> 00:29:03.277
<c.green>我刚提到的那些</c>
<c.green>扩展范围像素格式中的一种</c>

00:29:04.211 --> 00:29:05.712
<c.green>好了 这是方案一</c>

00:29:06.113 --> 00:29:09.816
<c.green>明确纹理创建的控制</c>

00:29:11.585 --> 00:29:17.024
<c.green>下一个方案是在资源目录中</c>
<c.green>给纹理使用Xcode支持</c>

00:29:17.491 --> 00:29:19.526
<c.green>这样会为有P3显示屏的设备</c>

00:29:19.593 --> 00:29:24.398
<c.green>自动创建</c>
<c.green>扩展范围sRGB纹理</c>

00:29:25.566 --> 00:29:29.169
<c.green>我还要说一下资源目录</c>

00:29:29.436 --> 00:29:32.105
<c.green>你暂时可以</c>

00:29:33.040 --> 00:29:35.909
<c.green>把图标和图片</c>

00:29:35.976 --> 00:29:39.413
<c.green>放到Xcode项目的资源目录中</c>

00:29:40.614 --> 00:29:43.417
<c.green>去年 我们引入了应用瘦身</c>

00:29:43.884 --> 00:29:46.653
<c.green>借此可以基于设备性能</c>

00:29:46.720 --> 00:29:49.923
<c.green>为不同的设备创建专用版本</c>

00:29:49.990 --> 00:29:53.460
<c.green>比如内存量、图形特征集</c>

00:29:54.094 --> 00:29:55.829
<c.green>或设备类型</c>

00:29:55.896 --> 00:30:01.635
<c.green>无论是iPad、Mac或</c>
<c.green>TV或watch...</c>

00:29:55.896 --> 00:30:01.635
<c.green>无论是iPad、Mac或</c>
<c.green>TV或watch...</c>

00:30:02.002 --> 00:30:03.770
<c.green>当然还有手机</c>

00:30:05.005 --> 00:30:08.075
<c.green>下载应用后</c>

00:30:08.242 --> 00:30:09.643
<c.green>你只下载和安装了</c>

00:30:09.710 --> 00:30:13.180
<c.green>专为该设备开发的单一版本</c>

00:30:13.914 --> 00:30:15.849
<c.green>有指定的功能</c>

00:30:16.950 --> 00:30:20.587
<c.green>在线路传输中和设备上</c>
<c.green>压缩了资产</c>

00:30:20.654 --> 00:30:24.691
<c.green>节省了用户设备上的存储空间</c>

00:30:25.292 --> 00:30:28.729
<c.green>并且有不计其数的API</c>

00:30:28.795 --> 00:30:31.999
<c.green>可以快速获取那些资源</c>

00:30:32.599 --> 00:30:37.037
<c.green>现在 我们已经向纹理集中</c>
<c.green>添加了这些资源目录</c>

00:30:37.604 --> 00:30:39.306
<c.green>这有什么用呢？</c>

00:30:39.373 --> 00:30:41.975
<c.green>嗯 处理mipmap层级的存储</c>

00:30:42.342 --> 00:30:45.812
<c.green>纹理不只是2D图片</c>

00:30:46.547 --> 00:30:50.751
<c.green>你可以在Xcode内部</c>
<c.green>执行离线mipmap生成</c>

00:30:51.952 --> 00:30:55.222
<c.green>这将自动为这个纹理</c>
<c.green>执行颜色匹配</c>

00:30:55.289 --> 00:30:59.860
<c.green>因此 如果是不同的</c>
<c.green>色彩空间的广色域纹理</c>

00:30:59.927 --> 00:31:03.163
<c.green>将在sRGB或</c>

00:30:59.927 --> 00:31:03.163
<c.green>将在sRGB或</c>

00:31:03.430 --> 00:31:07.267
<c.green>扩展范围sRGB色彩空间</c>
<c.green>执行色彩匹配运算</c>

00:31:07.801 --> 00:31:12.906
<c.green>我认为最重要的功能是</c>

00:31:12.973 --> 00:31:16.977
<c.green>可以为每种设备</c>

00:31:17.044 --> 00:31:20.581
<c.green>选择最理想的像素格式</c>

00:31:20.647 --> 00:31:25.185
<c.green>那么 在支持ASTC纹理压缩的</c>
<c.green>新设备上</c>

00:31:25.686 --> 00:31:27.354
<c.green>我们可以使用那种格式</c>

00:31:27.788 --> 00:31:30.023
<c.green>在不支持ASTC纹理压缩的老设备上</c>

00:31:30.090 --> 00:31:33.627
<c.green>我们可以选择非压缩格式</c>

00:31:33.694 --> 00:31:35.629
<c.green>或其他压缩格式</c>

00:31:36.430 --> 00:31:39.233
<c.green>此外 我们可为有P3显示屏的设备</c>

00:31:39.466 --> 00:31:42.035
<c.green>选择范围更广的色彩格式</c>

00:31:44.805 --> 00:31:46.273
<c.green>这就是基本流程</c>

00:31:47.441 --> 00:31:51.245
<c.green>在Xcode内创建纹理集</c>

00:31:51.512 --> 00:31:55.215
<c.green>给集合分配一个名称</c>
<c.green>作为唯一标识符</c>

00:31:56.149 --> 00:31:57.351
<c.green>添加一张图片</c>

00:31:57.417 --> 00:32:00.320
<c.green>并基本指出将如何使用纹理</c>

00:31:57.417 --> 00:32:00.320
<c.green>并基本指出将如何使用纹理</c>

00:32:00.387 --> 00:32:03.590
<c.green>无论是色彩纹理</c>
<c.green>或是其他类型的数据</c>

00:32:03.657 --> 00:32:06.126
<c.green>如普通地图或高度图</c>

00:32:07.127 --> 00:32:11.765
<c.green>然后 创建纹理</c>

00:32:11.832 --> 00:32:15.569
<c.green>Xcode会创建这个纹理</c>
<c.green>并提交给应用</c>

00:32:15.636 --> 00:32:18.238
<c.green>然后 你就可以通过Xcode UI或编程</c>

00:32:18.472 --> 00:32:21.375
<c.green>创建纹理集了</c>

00:32:23.610 --> 00:32:25.379
<c.green>一旦设备上有了纹理</c>

00:32:25.679 --> 00:32:28.382
<c.green>你就可把名称提供给MetalKit</c>

00:32:28.582 --> 00:32:34.087
<c.green>MetalKit会创建一个纹理</c>
<c.green>一个Metal纹理</c>

00:32:35.822 --> 00:32:38.859
<c.green>我可以跟大家一起</c>
<c.green>逐步执行这个Xcode流程</c>

00:32:38.926 --> 00:32:41.495
<c.green>并向你们介绍一下这些概念</c>

00:32:43.030 --> 00:32:43.864
<c.green>那么...</c>

00:32:45.365 --> 00:32:51.805
<c.green>首先</c>
<c.green>在项目导航侧边栏中选择资源目录</c>

00:32:53.240 --> 00:32:56.276
<c.green>然后点这里的这个加号按钮</c>
<c.green>打开这个菜单</c>

00:32:56.543 --> 00:33:00.848
<c.green>这里就是你要创建</c>
<c.green>各种集合类型的地方</c>

00:32:56.543 --> 00:33:00.848
<c.green>这里就是你要创建</c>
<c.green>各种集合类型的地方</c>

00:33:02.216 --> 00:33:06.887
<c.green>有图片集、图标集、通用数据集、</c>

00:33:07.154 --> 00:33:11.725
<c.green>以及纹理集和立方体贴图纹理集</c>

00:33:12.726 --> 00:33:16.763
<c.green>建好纹理集后 给它命名</c>

00:33:17.998 --> 00:33:21.168
<c.green>你的命名等级</c>
<c.green>没必要非得是flat型的</c>

00:33:21.235 --> 00:33:24.571
<c.green>如果你有许多叫做基础纹理的纹理</c>

00:33:24.638 --> 00:33:28.108
<c.green>每个对象都有一个这样的纹理</c>
<c.green>你可以为每个对象创建一个文件夹</c>

00:33:28.175 --> 00:33:31.879
<c.green>并把该对象的基础纹理</c>
<c.green>填充进相应的文件夹</c>

00:33:32.713 --> 00:33:35.916
<c.green>这样可以实现非常复杂的等级</c>

00:33:38.719 --> 00:33:39.820
<c.green>添加图片</c>

00:33:41.221 --> 00:33:43.290
<c.green>然后设置解释</c>

00:33:43.724 --> 00:33:45.359
<c.green>这里有三个选项</c>

00:33:45.692 --> 00:33:51.164
<c.green>颜色 在NonPremultiplied</c>
<c.green>颜色中执行颜色匹配运算</c>

00:33:52.032 --> 00:33:56.036
<c.green>NonPremultiplied</c>
<c.green>选项会在创建纹理之前</c>

00:33:56.103 --> 00:34:01.241
<c.green>用RGB通道乘以alpha通道</c>

00:33:56.103 --> 00:34:01.241
<c.green>用RGB通道乘以alpha通道</c>

00:34:02.009 --> 00:34:08.482
<c.green>这里的数据选项用于普通地图、</c>

00:34:08.549 --> 00:34:15.121
<c.green>高度地图、粗度地图、</c>
<c.green>非色彩类型纹理</c>

00:34:15.889 --> 00:34:17.591
<c.green>这就是你需要做的全部工作</c>

00:34:18.058 --> 00:34:19.493
<c.green> Xcode将开始创建</c>

00:34:19.560 --> 00:34:22.862
<c.green>这个纹理的各个版本</c>

00:34:23.263 --> 00:34:27.400
<c.green>并选择最理想的像素格式</c>

00:34:28.869 --> 00:34:33.440
<c.green>但是 你可以有更明确的控制</c>

00:34:33.739 --> 00:34:36.009
<c.green>你可以选择许多特性</c>

00:34:37.277 --> 00:34:41.181
<c.green>这些特性会打开很多bucket</c>
<c.green>可以用来自定义</c>

00:34:41.815 --> 00:34:44.818
<c.green>你可以给每个版本</c>
<c.green>添加不同的图片</c>

00:34:45.085 --> 00:34:47.521
<c.green>你很可能不会使用不同的图片</c>

00:34:47.588 --> 00:34:49.790
<c.green>而是同一张图片的不同尺寸</c>

00:34:49.857 --> 00:34:54.728
<c.green>那么在内存量大的设备上</c>
<c.green>使用较大的纹理</c>

00:34:54.795 --> 00:34:58.565
<c.green>在内存量小的设备上</c>
<c.green>使用较小的纹理</c>

00:35:00.501 --> 00:35:05.239
<c.green>然后</c>
<c.green>可以指定如何或是否想要mipmap</c>

00:35:05.806 --> 00:35:10.177
<c.green>这个“全部”选项将会生成</c>
<c.green>mipmap 一直到1x1级</c>

00:35:10.711 --> 00:35:15.749
<c.green>而“固定”选项</c>
<c.green>将提供一些更明确的控制</c>

00:35:15.949 --> 00:35:19.419
<c.green>比如是否想要使用最大级</c>

00:35:19.486 --> 00:35:24.491
<c.green>以及是否要给每个层级</c>
<c.green>添加不同的图片</c>

00:35:26.393 --> 00:35:28.095
<c.green>最后 你可以覆盖</c>

00:35:28.161 --> 00:35:30.731
<c.green>像素格式的自动选择</c>

00:35:33.166 --> 00:35:36.870
<c.green>我刚才提到过</c>
<c.green>你可以用程序来创建</c>

00:35:36.937 --> 00:35:38.138
<c.green>这些纹理集</c>

00:35:38.772 --> 00:35:41.241
<c.green>你不见得会一步步</c>
<c.green>按照Xcode UI的流程来</c>

00:35:41.308 --> 00:35:44.178
<c.green>如果你有几千个资源的话</c>

00:35:44.845 --> 00:35:48.215
<c.green>那么有一个很简单的目录结构</c>

00:35:48.282 --> 00:35:52.319
<c.green>在那个目录结构内有许多JSON文件</c>

00:35:52.586 --> 00:35:56.089
<c.green>这些文件和目录结构</c>

00:35:56.156 --> 00:36:02.196
<c.green>被完全记录在</c>
<c.green>资源目录参考上</c>

00:35:56.156 --> 00:36:02.196
<c.green>被完全记录在</c>
<c.green>资源目录参考上</c>

00:36:02.529 --> 00:36:05.299
<c.green>你可以创建自己的</c>
<c.green>资源调节工具</c>

00:36:05.365 --> 00:36:07.968
<c.green>来设置纹理集</c>

00:36:10.470 --> 00:36:14.174
<c.green>在设备上获得了这个资源后</c>
<c.green>该如何使用它呢？</c>

00:36:14.241 --> 00:36:17.711
<c.green>先创建一个MetalKit纹理加载器</c>

00:36:18.178 --> 00:36:20.047
<c.green>填充到Metal设备中</c>

00:36:21.515 --> 00:36:25.319
<c.green>然后把名称及其命名法</c>

00:36:25.385 --> 00:36:27.054
<c.green>提供给纹理加载器</c>

00:36:27.120 --> 00:36:29.556
<c.green>MetalKit将开始创建那个纹理</c>

00:36:29.623 --> 00:36:32.492
<c.green>你可以在这里提供其他选项</c>

00:36:32.559 --> 00:36:35.796
<c.green>比如比例因子 如果你有</c>
<c.green>不同版本的纹理的话</c>

00:36:35.863 --> 00:36:37.431
<c.green>不同比例因子的</c>

00:36:37.698 --> 00:36:39.867
<c.green>或bundle</c>

00:36:40.033 --> 00:36:44.238
<c.green>如果主bundle中没有资源目录</c>

00:36:44.505 --> 00:36:47.908
<c.green>你还可以指定一些选项</c>

00:36:49.643 --> 00:36:53.447
<c.green>我真心希望你们能</c>
<c.green>关注一下色彩空间</c>

00:36:53.514 --> 00:36:59.887
<c.green>并通过用范围更广的</c>
<c.green>色彩创建内容来分离应用</c>

00:37:00.821 --> 00:37:04.258
<c.green>资源目录可以帮助你</c>
<c.green>实现那个目标</c>

00:37:04.725 --> 00:37:07.661
<c.green>同样 它们还提供许多其他功能</c>

00:37:07.728 --> 00:37:11.999
<c.green>你可以利用起来</c>
<c.green>比如最佳的像素格式选择</c>

00:37:14.468 --> 00:37:17.838
<c.green>接下来 让我们欢迎我的同事</c>
<c.green>Anna Tikhonova上台</c>

00:37:17.905 --> 00:37:20.007
<c.green>谈一谈在Metal性能着色器框架中</c>

00:37:20.073 --> 00:37:22.376
<c.green>一些令人激动的改进</c>

00:37:28.615 --> 00:37:29.616
<c.green>大家下午好</c>

00:37:30.117 --> 00:37:31.718
<c.green>感谢Dan对我的介绍</c>

00:37:31.785 --> 00:37:33.253
<c.green>Dan说过了 我叫Anna</c>

00:37:33.320 --> 00:37:35.422
<c.green>我是GPU软件团队中的</c>
<c.green>一名工程师</c>

00:37:35.789 --> 00:37:39.126
<c.green>让我们谈一谈</c>
<c.green>Metal性能着色器中的一些新增功能</c>

00:37:41.261 --> 00:37:43.964
<c.green>去年 我们在</c>
<c.green>Metal的新特性的第二场演讲中</c>

00:37:44.031 --> 00:37:45.899
<c.green>引入了Metal性能着色器框架</c>

00:37:46.266 --> 00:37:49.303
<c.green>如果你没参加那场演讲</c>
<c.green>你真应该看一下视频</c>

00:37:50.270 --> 00:37:52.105
<c.green>我在此只给你们一个快速简明的回顾</c>

00:37:52.539 --> 00:37:55.042
<c.green>Metal性能着色器框架是</c>

00:37:55.108 --> 00:37:58.378
<c.green>为Metal中的GPU</c>

00:37:58.445 --> 00:37:59.580
<c.green>优化的高性能数据平行算法</c>

00:38:00.814 --> 00:38:03.016
<c.green>算法是针对iOS进行优化的</c>

00:38:03.083 --> 00:38:05.619
<c.green>自iOS 9起可用</c>

00:38:05.686 --> 00:38:08.121
<c.green>可用于A8 现在是A9处理器</c>

00:38:09.489 --> 00:38:13.961
<c.green>可以简易地把框架</c>
<c.green>整合到Metal应用中</c>

00:38:14.027 --> 00:38:15.562
<c.green>用起来很简单</c>

00:38:16.730 --> 00:38:19.600
<c.green>应该跟调用库函数一样简单</c>

00:38:21.535 --> 00:38:25.339
<c.green>去年 我们谈到了以下这些</c>
<c.green>所支持的图像运算</c>

00:38:25.906 --> 00:38:30.143
<c.green>你可从视频中获得更多详细信息和示例</c>

00:38:30.644 --> 00:38:33.347
<c.green>但今年我们增加了一些更酷的东西</c>

00:38:34.314 --> 00:38:36.083
<c.green>我们增加了</c>
<c.green>范围更广的颜色的转换</c>

00:38:36.149 --> 00:38:38.118
<c.green>可以用来在不同的色彩空间之间</c>

00:38:38.185 --> 00:38:39.820
<c.green>转换Metal纹理</c>

00:38:40.420 --> 00:38:45.492
<c.green>可以在RGB、sRGB、灰度、</c>
<c.green>CMYK、C3和你定义的</c>

00:38:45.559 --> 00:38:47.628
<c.green>任何色彩空间之间进行转换</c>

00:38:49.730 --> 00:38:51.965
<c.green>我们还增加了高斯金字塔</c>

00:38:52.733 --> 00:38:56.270
<c.green>用于在GPU上创建图片数据的多尺度呈现</c>

00:38:56.336 --> 00:38:59.006
<c.green>从而启动多尺度算法</c>

00:38:59.706 --> 00:39:03.310
<c.green>还可以用在常见的光流算法、</c>

00:38:59.706 --> 00:39:03.310
<c.green>还可以用在常见的光流算法、</c>

00:39:03.810 --> 00:39:06.713
<c.green>影像混合和优质mipmap生成中</c>

00:39:08.081 --> 00:39:12.186
<c.green>最后 我们还增加了卷积神经网络</c>
<c.green>或叫做CNN</c>

00:39:12.519 --> 00:39:15.689
<c.green>用于加快深度学习算法</c>

00:39:16.323 --> 00:39:18.325
<c.green>这是我们今天要重点讨论的话题</c>

00:39:18.392 --> 00:39:20.060
<c.green>让我们开始吧</c>

00:39:21.161 --> 00:39:23.096
<c.green>首先 什么是深度学习？</c>

00:39:24.264 --> 00:39:26.700
<c.green>深度学习是一种机器学习领域</c>

00:39:26.767 --> 00:39:28.635
<c.green>目标就是这个问题的答案</c>

00:39:29.002 --> 00:39:31.939
<c.green>机器是否可以完成</c>
<c.green>人类能够完成的任务？</c>

00:39:32.272 --> 00:39:34.274
<c.green>那么</c>
<c.green>我说的是什么类型的任务呢？</c>

00:39:35.108 --> 00:39:36.977
<c.green>你们每个人的口袋里</c>
<c.green>都有一部iPhone</c>

00:39:37.044 --> 00:39:38.979
<c.green>今天你很可能拍了一些照片</c>

00:39:39.346 --> 00:39:42.816
<c.green>我们所有人每天</c>
<c.green>都不断地暴露在图片和视频中</c>

00:39:42.883 --> 00:39:46.153
<c.green>在网页上、</c>
<c.green>在新闻网站上、在社交媒体上</c>

00:39:47.354 --> 00:39:48.589
<c.green>当你看到一个图片时</c>

00:39:49.156 --> 00:39:51.291
<c.green>你会立即了解它所描绘的内容</c>

00:39:51.725 --> 00:39:53.060
<c.green>你可以检测人脸</c>

00:39:53.393 --> 00:39:55.229
<c.green>如果你认识这些人</c>
<c.green>你可以标记他们</c>

00:39:55.295 --> 00:39:56.697
<c.green>你可以给这个图片添加注释</c>

00:39:57.331 --> 00:39:59.199
<c.green>如果是一张图片 那没什么问题</c>

00:39:59.933 --> 00:40:03.337
<c.green>但是如果有很多图片</c>
<c.green>甚至是很多很多图片呢？</c>

00:39:59.933 --> 00:40:03.337
<c.green>但是如果有很多图片</c>
<c.green>甚至是很多很多图片呢？</c>

00:40:03.704 --> 00:40:06.974
<c.green>再想象一下每天</c>
<c.green>上传到网页中的图片数量</c>

00:40:07.674 --> 00:40:10.177
<c.green>没有人可以手动地</c>
<c.green>给如此多的图片添加注释</c>

00:40:11.044 --> 00:40:14.414
<c.green>所以 深度学习就是为了</c>
<c.green>解决这种问题而提出的技术</c>

00:40:15.482 --> 00:40:18.285
<c.green>可以用于过滤大量数据</c>

00:40:18.352 --> 00:40:19.820
<c.green>并回答这样的问题</c>

00:40:19.887 --> 00:40:22.623
<c.green>如 “这张图片上有谁？”</c>
<c.green>和“这张照片是哪拍的？”</c>

00:40:23.557 --> 00:40:25.792
<c.green>我在这儿用了一个图片的示例</c>

00:40:25.859 --> 00:40:26.927
<c.green>因为图片是可见的</c>

00:40:26.994 --> 00:40:30.097
<c.green>非常适合这种类型的演讲</c>

00:40:30.163 --> 00:40:31.598
<c.green>但我只想提一下</c>

00:40:31.665 --> 00:40:34.768
<c.green>深度学习算法也能用于其他类型的数据</c>

00:40:34.835 --> 00:40:39.339
<c.green>比如其他信号类型 如音频</c>

00:40:39.406 --> 00:40:42.943
<c.green>可以进行语音识别 以及触觉</c>
<c.green>可以创建触摸感觉</c>

00:40:45.245 --> 00:40:47.614
<c.green>深度学习算法有两个阶段</c>

00:40:48.115 --> 00:40:50.017
<c.green>第一个阶段是训练阶段</c>

00:40:50.384 --> 00:40:53.453
<c.green>让我们通过一个具体的例子来了解</c>

00:40:54.254 --> 00:40:58.258
<c.green>想象一下你想训练你的系统给图片分类</c>

00:40:58.625 --> 00:41:00.961
<c.green>这是一张猫的图片 这是一张狗的图片</c>

00:40:58.625 --> 00:41:00.961
<c.green>这是一张猫的图片 这是一张狗的图片</c>

00:41:01.061 --> 00:41:02.462
<c.green>这是一张兔子的图片</c>

00:41:03.263 --> 00:41:05.399
<c.green>这是一项人工密集型任务</c>

00:41:05.465 --> 00:41:08.135
<c.green>需要大量图片</c>

00:41:08.769 --> 00:41:12.906
<c.green>手动标记并注解图片</c>
<c.green>然后划到每一个类中</c>

00:41:14.141 --> 00:41:17.744
<c.green>比如 如果你想训练系统识别猫</c>

00:41:18.212 --> 00:41:21.148
<c.green>你需要提供大量猫的图片</c>

00:41:21.415 --> 00:41:24.084
<c.green>所有图片都被标记过</c>
<c.green>要识别兔子和你想要系统能识别的</c>

00:41:24.151 --> 00:41:27.754
<c.green>其他动物也一样</c>

00:41:30.490 --> 00:41:34.728
<c.green>这是个一次性的、需要大量运算的阶段</c>

00:41:34.795 --> 00:41:35.796
<c.green>通常是离线实现的</c>

00:41:35.863 --> 00:41:38.432
<c.green>有大量可以利用的训练包</c>

00:41:39.099 --> 00:41:42.236
<c.green>训练阶段的结果是训练好的参数</c>

00:41:42.836 --> 00:41:46.673
<c.green>我现在先不谈这个 稍后再谈</c>

00:41:48.609 --> 00:41:51.245
<c.green>训练好的参数是下一个阶段所需要的</c>

00:41:51.311 --> 00:41:52.779
<c.green>也就是推理阶段</c>

00:41:53.514 --> 00:41:54.781
<c.green>这个阶段是</c>

00:41:55.282 --> 00:41:57.618
<c.green>给系统提供一张之前从未见过的</c>

00:41:57.684 --> 00:41:58.986
<c.green>新图片</c>

00:41:59.052 --> 00:42:00.754
<c.green>它需要实时地进行归类</c>

00:41:59.052 --> 00:42:00.754
<c.green>它需要实时地进行归类</c>

00:42:00.821 --> 00:42:03.857
<c.green>在这个例子中</c>
<c.green>系统正确地将这个图片归类到</c>

00:42:03.924 --> 00:42:04.858
<c.green>猫类的图中</c>

00:42:06.560 --> 00:42:09.596
<c.green>我们为推理阶段提供GPU加速</c>

00:42:09.997 --> 00:42:12.666
<c.green>尤其是 我们还提供</c>

00:42:12.999 --> 00:42:15.702
<c.green>为GPU创建推理网络的构建模块</c>

00:42:17.171 --> 00:42:20.874
<c.green>接下来让我们谈谈什么是卷积神经网络</c>

00:42:20.941 --> 00:42:23.210
<c.green>以及我们提供哪些构建模块？</c>

00:42:25.412 --> 00:42:27.548
<c.green>卷积神经网络 或叫做CNN</c>

00:42:27.614 --> 00:42:32.186
<c.green>是受生物学启发模拟视觉皮质</c>

00:42:33.253 --> 00:42:35.355
<c.green>当我们的大脑处理视觉输入时</c>

00:42:35.722 --> 00:42:38.659
<c.green>接收信息的神经元</c>
<c.green>的第一个等级</c>

00:42:38.725 --> 00:42:43.564
<c.green>从视觉皮质中</c>
<c.green>对特定的边界、斑点或颜色很敏感</c>

00:42:44.031 --> 00:42:46.834
<c.green>而大脑分区接下来进入视觉管道</c>

00:42:47.301 --> 00:42:51.205
<c.green>响应更复杂的结构</c>
<c.green>比如面部或各种各样的动物</c>

00:42:51.972 --> 00:42:53.340
<c.green>非常相似地</c>

00:42:54.208 --> 00:42:58.812
<c.green>卷积神经网络组成了神经元层</c>

00:42:59.479 --> 00:43:02.816
<c.green>被训练识别越来越多的复杂特征</c>

00:42:59.479 --> 00:43:02.816
<c.green>被训练识别越来越多的复杂特征</c>

00:43:04.751 --> 00:43:08.689
<c.green>所以</c>
<c.green>第一层被训练为识别低层特征</c>

00:43:08.755 --> 00:43:11.225
<c.green>如边界和色块</c>

00:43:11.558 --> 00:43:15.229
<c.green>随后的层被训练</c>
<c.green>识别较高层的特征</c>

00:43:15.295 --> 00:43:17.397
<c.green>比如 如果我们正在做人脸检测</c>

00:43:17.464 --> 00:43:21.368
<c.green>会有识别像鼻子、眼睛、</c>
<c.green>脸颊这样的特征的层</c>

00:43:21.435 --> 00:43:25.138
<c.green>然后把这些特征结合到一起</c>
<c.green>最后构成人脸</c>

00:43:27.241 --> 00:43:30.944
<c.green>最后几个层会结合所有已生成的信息</c>

00:43:31.178 --> 00:43:33.146
<c.green>生成最终的网络输出</c>

00:43:33.213 --> 00:43:35.949
<c.green>比如图片中很可能有一张人脸</c>

00:43:37.050 --> 00:43:38.619
<c.green>我一直提到特征</c>

00:43:39.486 --> 00:43:44.224
<c.green>可以把特征当做一种过滤器</c>
<c.green>过滤那个特征的输入</c>

00:43:44.291 --> 00:43:45.158
<c.green>比如鼻子</c>

00:43:45.692 --> 00:43:48.929
<c.green>如果找到那个信息 就传过来</c>

00:43:49.596 --> 00:43:50.964
<c.green>如果找到那个特征</c>

00:43:51.265 --> 00:43:54.535
<c.green>就把信息传给后续的层</c>

00:43:54.902 --> 00:43:57.604
<c.green>当然</c>
<c.green>我们需要发现很多这样的特征</c>

00:43:57.671 --> 00:43:59.439
<c.green>如果我们正在做人脸检测</c>

00:43:59.506 --> 00:44:02.142
<c.green>那么</c>
<c.green>只寻找鼻子很显然是远远不够的</c>

00:43:59.506 --> 00:44:02.142
<c.green>那么</c>
<c.green>只寻找鼻子很显然是远远不够的</c>

00:44:02.209 --> 00:44:04.211
<c.green>我们还需要寻找其他面部特征</c>

00:44:04.278 --> 00:44:07.714
<c.green>比如脸颊、眼睛</c>
<c.green>然后把这些特征结合在一起</c>

00:44:07.781 --> 00:44:09.983
<c.green>我们需要很多这样的</c>
<c.green>特征过滤器</c>

00:44:11.585 --> 00:44:14.454
<c.green>这就是卷积神经网络</c>

00:44:14.821 --> 00:44:16.990
<c.green>接下来谈一下</c>
<c.green>我们提供的构建模块</c>

00:44:17.758 --> 00:44:19.826
<c.green>第一个构建模块是你的数据</c>

00:44:20.661 --> 00:44:24.131
<c.green>我们建议使用</c>
<c.green>MPS图片和MPS临时图片</c>

00:44:24.198 --> 00:44:27.634
<c.green>是我们专门</c>
<c.green>为支持卷积网络新增加的</c>

00:44:28.168 --> 00:44:30.604
<c.green>它们会为数据、</c>
<c.green>为输入和中间结果</c>

00:44:30.671 --> 00:44:32.739
<c.green>提供优化布局</c>

00:44:34.074 --> 00:44:38.178
<c.green>可以把MPS临时图片想象成</c>
<c.green>轻量级的MPS图片</c>

00:44:39.146 --> 00:44:43.183
<c.green>作用于存在时间较短的图片数据</c>

00:44:44.685 --> 00:44:46.119
<c.green>MPS临时图片</c>

00:44:46.887 --> 00:44:49.223
<c.green>是用Metal资源堆创建的</c>

00:44:49.289 --> 00:44:54.595
<c.green>我们在第一场演讲中描述过</c>

00:44:56.263 --> 00:44:58.465
<c.green>它们会标记其中一些</c>
<c.green>重复利用的缓冲内存</c>

00:44:59.099 --> 00:45:04.938
<c.green>并避免资源占用过多</c>
<c.green>和重新分配纹理资源</c>

00:44:59.099 --> 00:45:04.938
<c.green>并避免资源占用过多</c>
<c.green>和重新分配纹理资源</c>

00:45:05.105 --> 00:45:07.040
<c.green>目标是节约大量内存</c>

00:45:07.474 --> 00:45:10.377
<c.green>并帮助管理中间资源</c>

00:45:11.945 --> 00:45:13.981
<c.green>我们还提供一些层</c>

00:45:14.047 --> 00:45:17.551
<c.green>用于创建推理网络</c>

00:45:17.918 --> 00:45:19.520
<c.green>但你现在可能在想</c>

00:45:19.586 --> 00:45:22.589
<c.green>“我如何得知</c>
<c.green>实际需要哪个构建模块</c>

00:45:22.656 --> 00:45:24.558
<c.green>来创建我自己的推理网络呢？”</c>

00:45:26.760 --> 00:45:28.896
<c.green>答案是训练好的参数</c>

00:45:29.530 --> 00:45:30.998
<c.green>训练好的参数...</c>

00:45:31.231 --> 00:45:34.535
<c.green>我在前面提到过</c>
<c.green>当我们谈到训练阶段的时候</c>

00:45:34.968 --> 00:45:37.337
<c.green>训练好的参数会提供</c>
<c.green>关于如何创建推理网络的</c>

00:45:37.404 --> 00:45:39.439
<c.green>完整方法</c>

00:45:39.840 --> 00:45:43.110
<c.green>它们会告诉你 要有多少个层</c>

00:45:43.177 --> 00:45:45.679
<c.green>是哪些层以及层出现的顺序</c>

00:45:45.746 --> 00:45:48.515
<c.green>你还会得到每一层的所有特征过滤器</c>

00:45:50.184 --> 00:45:52.953
<c.green>我们在底层实现了这一切</c>

00:45:53.020 --> 00:45:56.056
<c.green>以便确保你用这些构建模块</c>
<c.green>创建的网络</c>

00:45:56.123 --> 00:45:59.426
<c.green>在所有iOS GPU上</c>
<c.green>都有最好的性能</c>

00:45:59.493 --> 00:46:04.565
<c.green>你要做的就是把你的数据</c>
<c.green>挖掘到我们提供的这个优化布局</c>

00:45:59.493 --> 00:46:04.565
<c.green>你要做的就是把你的数据</c>
<c.green>挖掘到我们提供的这个优化布局</c>

00:46:05.199 --> 00:46:07.301
<c.green>并调用库函数</c>

00:46:07.367 --> 00:46:09.469
<c.green>创建组成网络的层</c>

00:46:10.504 --> 00:46:14.241
<c.green>现在让我们详细讨论一下</c>
<c.green>这些构建模块</c>

00:46:14.308 --> 00:46:17.177
<c.green>但让我们通过一个</c>
<c.green>具体的例子来解释</c>

00:46:20.914 --> 00:46:21.982
<c.green>在这个演示中</c>

00:46:24.451 --> 00:46:27.921
<c.green>我有一个系统被训练为识别微笑</c>

00:46:28.655 --> 00:46:31.124
<c.green>我们要实现的是系统将</c>

00:46:32.092 --> 00:46:33.894
<c.green>实时检测我是否微笑</c>

00:46:33.961 --> 00:46:36.063
<c.green>我先微笑 然后我再皱眉</c>

00:46:36.230 --> 00:46:38.398
<c.green>你将看到系统会给出正确的报告</c>

00:46:40.334 --> 00:46:42.836
<c.green>微笑</c>

00:46:42.903 --> 00:46:43.770
<c.green>没微笑</c>

00:46:43.837 --> 00:46:45.572
<c.green>微笑</c>

00:46:45.639 --> 00:46:46.640
<c.green>没微笑</c>

00:46:46.707 --> 00:46:47.541
<c.green>好了</c>

00:46:48.008 --> 00:46:49.576
<c.green>这就是我的演示</c>

00:46:55.048 --> 00:46:58.218
<c.green>好了 现在让我们来看看</c>

00:46:58.285 --> 00:47:00.988
<c.green>要创建这种网络所需要的构建模块</c>

00:46:58.285 --> 00:47:00.988
<c.green>要创建这种网络所需要的构建模块</c>

00:47:01.522 --> 00:47:04.892
<c.green>我们要谈到的第一个构建模块是卷积层</c>

00:47:05.592 --> 00:47:08.362
<c.green>是卷积神经网络中的核心构建模块</c>

00:47:08.929 --> 00:47:11.532
<c.green>它的目标是识别特征并输入</c>

00:47:11.598 --> 00:47:13.100
<c.green>之所以叫卷积层</c>

00:47:13.166 --> 00:47:15.636
<c.green>是因为它会对输入执行卷积运算</c>

00:47:15.702 --> 00:47:18.038
<c.green>让我们回想一下常规的</c>
<c.green>卷积运算是如何计算的</c>

00:47:18.539 --> 00:47:20.107
<c.green>你有输入和输出</c>

00:47:20.174 --> 00:47:23.143
<c.green>在这个例子中是一个</c>
<c.green>5x5像素的过滤器 有一些重量</c>

00:47:23.710 --> 00:47:27.014
<c.green>为了在输出中计算这个像素的值</c>

00:47:27.080 --> 00:47:29.449
<c.green>你需要用输入卷积过滤器</c>

00:47:30.651 --> 00:47:31.485
<c.green>非常简单</c>

00:47:32.019 --> 00:47:33.420
<c.green>卷积层</c>

00:47:33.487 --> 00:47:35.856
<c.green>是常规卷积运算的一个泛指</c>

00:47:36.790 --> 00:47:38.725
<c.green>你可以使用多个过滤器</c>

00:47:39.193 --> 00:47:42.329
<c.green>不同的过滤器</c>
<c.green>独立应用于输入中</c>

00:47:42.396 --> 00:47:44.364
<c.green>结果会形成不同的输出通道</c>

00:47:44.431 --> 00:47:47.801
<c.green>那么 如果你有16个过滤器</c>
<c.green>意味着你将有16个输出通道</c>

00:47:48.368 --> 00:47:50.304
<c.green>为了 获得这个像素的值</c>

00:47:50.370 --> 00:47:52.272
<c.green>在输出的第一个通道中</c>

00:47:52.339 --> 00:47:55.843
<c.green>你需要取到第一个过滤器</c>
<c.green>并用输入对它进行卷积运算</c>

00:47:56.343 --> 00:47:58.846
<c.green>为了 获得这个像素的值</c>

00:47:58.912 --> 00:48:01.248
<c.green>在输出的第二管道中</c>

00:47:58.912 --> 00:48:01.248
<c.green>在输出的第二管道中</c>

00:48:01.315 --> 00:48:04.451
<c.green>你需要取到第二个过滤器</c>
<c.green>并用输入对它进行卷积运算</c>

00:48:06.220 --> 00:48:10.023
<c.green>当然 我们的示例是比较轻微的检测</c>
<c.green>我们处理的是彩色图片</c>

00:48:10.090 --> 00:48:13.961
<c.green>意思是</c>
<c.green>你的输入实际上有三种独立的通道</c>

00:48:14.528 --> 00:48:17.764
<c.green>正是因为卷积神经网络的</c>
<c.green>这种运行方式所导致的</c>

00:48:18.098 --> 00:48:21.034
<c.green>你需要三组过滤器 每组16个</c>

00:48:21.301 --> 00:48:23.871
<c.green>每种输入通道分别为一组</c>

00:48:24.872 --> 00:48:28.275
<c.green>然后把不同的过滤器应用到</c>

00:48:29.009 --> 00:48:32.145
<c.green>独立的输入通道</c>

00:48:35.616 --> 00:48:39.286
<c.green>并把结果结合起来获得单一输出值</c>

00:48:43.290 --> 00:48:46.527
<c.green>这就是如何在我们的框架中</c>

00:48:46.593 --> 00:48:48.161
<c.green>创建卷积层</c>

00:48:48.662 --> 00:48:51.532
<c.green>首先创建一个描述符并制定参数</c>

00:48:51.632 --> 00:48:54.801
<c.green>比如过滤器的宽和高</c>

00:48:54.868 --> 00:48:57.371
<c.green>然后是输入和输出通道的数量</c>

00:49:00.140 --> 00:49:03.210
<c.green>然后 从描述符中创建卷积层</c>

00:49:03.610 --> 00:49:08.148
<c.green>并为特征过滤器提供从训练好的</c>

00:49:08.215 --> 00:49:10.250
<c.green>参数中获取的真实数据</c>

00:49:12.753 --> 00:49:15.222
<c.green>我们要谈到的下一个层是汇聚层</c>

00:49:15.856 --> 00:49:17.457
<c.green>汇聚层的作用是</c>

00:49:17.524 --> 00:49:21.528
<c.green>逐步减少网络的空间规模</c>

00:49:21.595 --> 00:49:24.531
<c.green>从而减少后续层的竞争</c>

00:49:24.665 --> 00:49:25.999
<c.green>通常是在中间连续的卷积层</c>

00:49:26.066 --> 00:49:29.036
<c.green>插入汇聚层</c>

00:49:29.603 --> 00:49:31.471
<c.green>汇聚层的另一个作用是</c>

00:49:31.738 --> 00:49:37.811
<c.green>总结或浓缩输入区中的信息</c>

00:49:38.612 --> 00:49:40.547
<c.green>应该提供两种汇聚运算</c>

00:49:40.614 --> 00:49:42.015
<c.green>最大值和平均值</c>

00:49:43.116 --> 00:49:44.151
<c.green>在这个例子中</c>

00:49:44.818 --> 00:49:48.722
<c.green>我们用了一个2x2的像素区</c>
<c.green>进行输入</c>

00:49:49.456 --> 00:49:53.827
<c.green>我们取到最大值</c>
<c.green>并把它存起来作为输出</c>

00:49:56.196 --> 00:49:59.967
<c.green>这是你需在Metal性能着色器</c>
<c.green>框架中使用的API</c>

00:50:00.033 --> 00:50:01.735
<c.green>用于创建汇聚层</c>

00:50:02.402 --> 00:50:04.671
<c.green>一般用的是最大运算</c>

00:50:06.139 --> 00:50:08.175
<c.green>过滤器尺寸是2x2</c>

00:50:11.245 --> 00:50:12.713
<c.green>全连接层</c>

00:50:12.779 --> 00:50:15.282
<c.green>是输入的每个神经元都被连接到</c>

00:50:15.349 --> 00:50:17.718
<c.green>输出的每个神经元的层</c>

00:50:18.185 --> 00:50:20.988
<c.green>可以把它看作卷积层的一种特殊类型</c>

00:50:21.488 --> 00:50:24.992
<c.green>过滤器的尺寸与输入尺寸相同</c>

00:50:25.058 --> 00:50:26.226
<c.green>在这个例子中</c>

00:50:26.293 --> 00:50:29.229
<c.green>过滤器的尺寸与输入尺寸是相同的</c>

00:50:29.296 --> 00:50:32.099
<c.green>我们对它们进行了卷积运算</c>
<c.green>并获得了单一输出值</c>

00:50:33.033 --> 00:50:34.301
<c.green>在这个架构中</c>

00:50:34.902 --> 00:50:38.805
<c.green>卷积层和汇聚层操作的是输入分区</c>

00:50:38.872 --> 00:50:40.407
<c.green>而全连接层</c>

00:50:40.474 --> 00:50:45.012
<c.green>用于从所有输入中聚集信息</c>

00:50:45.712 --> 00:50:47.981
<c.green>通常是网络中最末端的层之一</c>

00:50:48.048 --> 00:50:50.884
<c.green>是做出最终决策的地方</c>

00:50:51.118 --> 00:50:55.389
<c.green>并生成输出</c>

00:50:55.722 --> 00:50:58.525
<c.green>比如图片中很可能有笑脸</c>

00:51:01.495 --> 00:51:04.531
<c.green>这就是如何在Metal性能着色器</c>

00:51:04.598 --> 00:51:06.800
<c.green>框架中创建全连接层</c>

00:51:07.100 --> 00:51:08.702
<c.green>首先创建一个卷积描述符</c>

00:51:08.769 --> 00:51:11.371
<c.green>因为这是卷积层的一个特殊类型</c>

00:51:11.471 --> 00:51:13.574
<c.green>然后从这个描述符中</c>

00:51:14.074 --> 00:51:15.175
<c.green>创建一个全连接层</c>

00:51:16.610 --> 00:51:18.011
<c.green>我们还将提供一些其他的层</c>

00:51:18.078 --> 00:51:21.014
<c.green>我在本次演讲中不会披露太多信息</c>

00:51:21.081 --> 00:51:23.383
<c.green>但你们可从文档中找到相关信息</c>

00:51:23.717 --> 00:51:25.118
<c.green>我们还提供神经层</c>

00:51:25.352 --> 00:51:28.589
<c.green>通常跟卷积层一起结合使用</c>

00:51:28.856 --> 00:51:31.892
<c.green>我们还提供SoftMax层和</c>
<c.green>normalization层</c>

00:51:33.093 --> 00:51:35.462
<c.green>那么我们已经提到了所有的层</c>

00:51:35.529 --> 00:51:36.864
<c.green>现在让我们来谈谈数据</c>

00:51:37.264 --> 00:51:39.600
<c.green>我刚提到你应该用MPS图片</c>

00:51:39.867 --> 00:51:41.034
<c.green>它们到底是什么？</c>

00:51:42.436 --> 00:51:45.506
<c.green>你们中绝大多数人</c>
<c.green>都已经熟悉Metal纹理了</c>

00:51:45.572 --> 00:51:50.744
<c.green>那么这就是一个</c>
<c.green>多通道的2D Metal纹理</c>

00:51:50.811 --> 00:51:53.714
<c.green>每个通道对应着一个</c>
<c.green>颜色通道和alpha</c>

00:51:54.681 --> 00:51:56.383
<c.green>我在之前的示例中曾提到</c>

00:51:56.450 --> 00:52:00.187
<c.green>我们需要用多通道创建图片</c>

00:51:56.450 --> 00:52:00.187
<c.green>我们需要用多通道创建图片</c>

00:52:00.587 --> 00:52:02.122
<c.green>比如 32个通道</c>

00:52:02.189 --> 00:52:04.124
<c.green>如果我们有32个特征过滤器</c>

00:52:04.191 --> 00:52:08.529
<c.green>我们需要创建</c>
<c.green>有32个通道的输出图片</c>

00:52:08.595 --> 00:52:09.596
<c.green>我们该如何实现呢？</c>

00:52:10.764 --> 00:52:12.165
<c.green>MPS图片</c>

00:52:12.599 --> 00:52:16.370
<c.green>实际上是有多个切片的</c>
<c.green>Metal 2D数组纹理</c>

00:52:16.870 --> 00:52:20.741
<c.green>当你创建MPS图片时</c>
<c.green>你真正需要注意的是</c>

00:52:20.807 --> 00:52:25.179
<c.green>你正在创建有32个通道的图片</c>

00:52:26.046 --> 00:52:30.484
<c.green>但有时候 你可能需要</c>
<c.green>把MPS图片数据返回到CPU</c>

00:52:30.784 --> 00:52:34.087
<c.green>或者你想使用</c>
<c.green>现有的Metal 2D数组纹理</c>

00:52:34.154 --> 00:52:35.756
<c.green>作为MPS图片</c>

00:52:35.822 --> 00:52:37.691
<c.green>在这种情况下 你需要了解到</c>

00:52:37.758 --> 00:52:41.728
<c.green>我们为你的数据</c>
<c.green>使用了特殊的打包布局</c>

00:52:42.095 --> 00:52:47.367
<c.green>因此结构切片中的每个像素</c>
<c.green>都包含四个通道的数据</c>

00:52:48.735 --> 00:52:52.773
<c.green>所以一张有32个通道的图片</c>
<c.green>实际应该只有八个切片</c>

00:52:54.575 --> 00:52:56.276
<c.green>这是你在我们的框架中</c>

00:52:56.343 --> 00:52:59.446
<c.green>创建MPS图片要使用的API</c>

00:52:59.513 --> 00:53:00.814
<c.green>首先创建一个描述符</c>

00:52:59.513 --> 00:53:00.814
<c.green>首先创建一个描述符</c>

00:53:00.881 --> 00:53:05.185
<c.green>并制定参数 如数据格式的通道</c>

00:53:05.619 --> 00:53:08.856
<c.green>图片高度和通道数量</c>

00:53:09.790 --> 00:53:13.193
<c.green>然后从这个描述符中</c>
<c.green>创建一张MPS图片 非常简单</c>

00:53:14.928 --> 00:53:17.965
<c.green>当然 如果输入图片的尺寸小</c>

00:53:18.031 --> 00:53:20.601
<c.green>那么你可以批量处理</c>
<c.green>来更好地利用GPU</c>

00:53:21.068 --> 00:53:24.371
<c.green>我们会提供一个简单的机制</c>
<c.green>来帮助你实现批量处理</c>

00:53:24.738 --> 00:53:28.876
<c.green>在这个例子中 我们创建了一个</c>
<c.green>含有100张MPS图片的数组</c>

00:53:30.511 --> 00:53:34.615
<c.green>那么现在 我们已经提到了所有层</c>
<c.green>也提到了数据</c>

00:53:34.715 --> 00:53:37.751
<c.green>接下来 让我们看一下</c>
<c.green>要进行微笑探测</c>

00:53:38.285 --> 00:53:39.553
<c.green>所需要创建的实际网络</c>

00:53:40.053 --> 00:53:41.788
<c.green>我们从输入开始</c>

00:53:41.855 --> 00:53:45.325
<c.green>我们将使用</c>
<c.green>我一直在提的训练好的参数</c>

00:53:46.026 --> 00:53:47.895
<c.green>来帮助我们创建这个网络</c>

00:53:48.262 --> 00:53:50.230
<c.green>那么 训练好的参数告诉我们</c>

00:53:50.297 --> 00:53:53.901
<c.green>这个网络的第一层将是卷积层</c>

00:53:53.967 --> 00:53:56.270
<c.green>输入有三个通道的图片</c>

00:53:56.336 --> 00:53:58.405
<c.green>并输出有16个通道的图片</c>

00:53:59.573 --> 00:54:01.375
<c.green>训练好的参数还提供</c>

00:53:59.573 --> 00:54:01.375
<c.green>训练好的参数还提供</c>

00:54:01.441 --> 00:54:04.611
<c.green>三组过滤器 每组16个</c>

00:54:05.078 --> 00:54:07.848
<c.green>这些富有色彩的蓝色图片</c>

00:54:09.116 --> 00:54:12.286
<c.green>在把过滤器应用到输入中之后</c>

00:54:12.352 --> 00:54:14.755
<c.green>使输出通道变得可视化</c>

00:54:16.590 --> 00:54:18.659
<c.green>下一层是汇聚层</c>

00:54:18.725 --> 00:54:23.530
<c.green>通过每一个维度的两个因子</c>

00:54:23.797 --> 00:54:25.599
<c.green>降低卷积层输出的空间分辨率</c>

00:54:27.100 --> 00:54:29.336
<c.green>训练好的参数告诉我们</c>
<c.green>下一层</c>

00:54:29.403 --> 00:54:30.904
<c.green>是另一个卷积层</c>

00:54:30.971 --> 00:54:33.173
<c.green>输入有16个通道的图片</c>

00:54:33.240 --> 00:54:35.409
<c.green>并输出有16个通道的图片</c>

00:54:35.642 --> 00:54:38.745
<c.green>进一步缩小</c>
<c.green>下一个汇聚层的尺寸</c>

00:54:39.112 --> 00:54:42.583
<c.green>以此类推 直到我们得到输出</c>

00:54:43.517 --> 00:54:44.518
<c.green>正如你所看到的</c>

00:54:45.152 --> 00:54:48.155
<c.green>这个网络有一连串的卷积层</c>

00:54:48.222 --> 00:54:49.790
<c.green>每个卷基层后面都跟着一个汇聚层</c>

00:54:50.057 --> 00:54:53.160
<c.green>最后两层实际上是全连接层</c>

00:54:53.227 --> 00:54:56.597
<c.green>为网络生成最终输出</c>

00:54:58.065 --> 00:55:00.734
<c.green>现在 我们已经了解这个网络</c>
<c.green>应该是个什么样的网络</c>

00:54:58.065 --> 00:55:00.734
<c.green>现在 我们已经了解这个网络</c>
<c.green>应该是个什么样的网络</c>

00:55:00.801 --> 00:55:02.135
<c.green>这样的网络在为推理创建的</c>

00:55:02.202 --> 00:55:04.705
<c.green>卷积神经网络中很常见</c>

00:55:05.405 --> 00:55:08.709
<c.green>现在 让我们看一下</c>
<c.green>在框架中创建这种网络的代码</c>

00:55:10.711 --> 00:55:12.913
<c.green>第一步是创建层</c>

00:55:13.547 --> 00:55:16.283
<c.green>训练好的参数再次告诉我们说</c>
<c.green>我们需要</c>

00:55:16.350 --> 00:55:18.886
<c.green>在我们的网络中 四个卷积层</c>

00:55:19.586 --> 00:55:23.257
<c.green>为简单起见 我演示的代码</c>
<c.green>只创建其中一个卷基层</c>

00:55:23.323 --> 00:55:26.426
<c.green>但正如你所看到的</c>
<c.green>我使用了跟我之前给你们看过的</c>

00:55:26.493 --> 00:55:27.895
<c.green>完全一样的API</c>

00:55:28.695 --> 00:55:30.697
<c.green>然后 我们需要创建汇聚层</c>

00:55:31.565 --> 00:55:34.535
<c.green>我们只需要一个 因为我们要一直使用</c>

00:55:34.601 --> 00:55:37.304
<c.green>最大运算 过滤器尺寸为2x2</c>

00:55:38.071 --> 00:55:40.874
<c.green>我们还需要创建两个全连接层</c>

00:55:40.941 --> 00:55:44.545
<c.green>为简单起见 我只演示一个的代码</c>

00:55:45.679 --> 00:55:48.382
<c.green>现在 我们需要注意一下输入和输出</c>

00:55:48.882 --> 00:55:50.284
<c.green>在这个具体的例子中</c>

00:55:50.784 --> 00:55:54.087
<c.green>假设我们有一个现存的Metal应用</c>

00:55:54.154 --> 00:55:57.558
<c.green>并且你有一些想</c>

00:55:57.624 --> 00:56:01.595
<c.green>用在输入和输出中的纹理上</c>

00:55:57.624 --> 00:56:01.595
<c.green>用在输入和输出中的纹理上</c>

00:56:01.662 --> 00:56:03.397
<c.green>这就是用来创建MPS图片的API</c>

00:56:04.831 --> 00:56:08.569
<c.green>最后一个阶段是从现有的Metal纹理中</c>

00:56:08.635 --> 00:56:10.270
<c.green>按照训练好的参数所指定的顺序</c>

00:56:10.337 --> 00:56:12.840
<c.green>把所有层编码到一个现有的命令缓冲区</c>

00:56:14.575 --> 00:56:16.510
<c.green>这样 我们就有了输入和输出</c>

00:56:16.577 --> 00:56:20.480
<c.green>现在 我们注意到还需要注意一件事</c>

00:56:21.014 --> 00:56:24.351
<c.green>我们要把第一层的输出存起来</c>

00:56:24.852 --> 00:56:27.421
<c.green>那么让我们用MPS临时图片来处理</c>

00:56:28.388 --> 00:56:31.158
<c.green>这是如何创建MPS临时图片</c>

00:56:31.425 --> 00:56:33.193
<c.green>正如你所看到的 类似于</c>

00:56:33.260 --> 00:56:35.596
<c.green>你创建普通MPS图片的方法</c>

00:56:36.697 --> 00:56:40.334
<c.green>我们要立即在第一层的编码中使用它</c>

00:56:40.801 --> 00:56:43.103
<c.green>临时图片就会被清除</c>

00:56:43.170 --> 00:56:45.272
<c.green>提交命令缓冲区</c>

00:56:46.473 --> 00:56:49.009
<c.green>然后我们继续 创建另一张临时图片</c>

00:56:49.510 --> 00:56:51.812
<c.green>来存储第二层的输出</c>

00:56:52.079 --> 00:56:54.715
<c.green>以此类推 直到我们得到输出</c>

00:56:56.016 --> 00:56:56.850
<c.green>就是这样</c>

00:56:57.751 --> 00:56:59.653
<c.green>只需要把它们连接起来</c>

00:57:00.053 --> 00:57:02.523
<c.green>层的编码顺序</c>

00:57:02.589 --> 00:57:06.260
<c.green>跟我之前演示的</c>
<c.green>网络图表上的顺序完全一致</c>

00:57:06.527 --> 00:57:09.229
<c.green>从输入开始 一直到输出</c>

00:57:10.631 --> 00:57:13.033
<c.green>我们已经演示完了一个非常简单的例子</c>

00:57:13.267 --> 00:57:15.402
<c.green>现在让我们来看一个更复杂的例子</c>

00:57:16.937 --> 00:57:20.107
<c.green>我们从张量流中移植原始推理网络</c>

00:57:20.174 --> 00:57:22.876
<c.green>使用Metal性能着色器框架来运行</c>

00:57:23.410 --> 00:57:25.913
<c.green>这是一个很常用的推理网络</c>

00:57:25.979 --> 00:57:28.849
<c.green>用于对象检测 这是完整图表</c>

00:57:29.550 --> 00:57:30.417
<c.green>这个网络</c>

00:57:31.285 --> 00:57:33.086
<c.green>正如你们所看到的 这个网络</c>

00:57:33.153 --> 00:57:35.889
<c.green>比我刚演示的那个更复杂</c>

00:57:36.590 --> 00:57:38.125
<c.green>有100多个层</c>

00:57:38.225 --> 00:57:40.027
<c.green>但我想提醒一下 你们要做的</c>

00:57:40.093 --> 00:57:42.829
<c.green>只是调用一些库函数来创建这些层</c>

00:57:43.664 --> 00:57:46.633
<c.green>首先让我们看一下运行中的网络</c>

00:57:50.771 --> 00:57:53.740
<c.green>这里我有一些不同对象的图片集</c>

00:57:54.141 --> 00:57:56.076
<c.green>只要我轻触这个图片</c>

00:57:56.376 --> 00:58:00.581
<c.green>我们就会实时运行推理网络</c>

00:57:56.376 --> 00:58:00.581
<c.green>我们就会实时运行推理网络</c>

00:58:00.647 --> 00:58:04.751
<c.green>它将报告关于这是什么物体的</c>
<c.green>最有可能的五个猜想</c>

00:58:05.118 --> 00:58:07.888
<c.green>那么最可能的猜想是一匹斑马</c>

00:58:09.523 --> 00:58:11.525
<c.green>然后是一辆皮卡车</c>

00:58:12.693 --> 00:58:14.428
<c.green>然后是一座火山</c>

00:58:14.494 --> 00:58:17.097
<c.green>看起来很不错 当然了</c>

00:58:17.531 --> 00:58:20.334
<c.green>让我们在舞台上做一个现场演示吧</c>

00:58:20.868 --> 00:58:24.872
<c.green>我们要给这个水瓶拍一张照片</c>

00:58:27.174 --> 00:58:28.642
<c.green>让我们用这张图片</c>

00:58:30.277 --> 00:58:31.111
<c.green>水瓶</c>

00:58:40.153 --> 00:58:42.689
<c.green>我想用这个现场演示告诉你们的是</c>

00:58:42.756 --> 00:58:46.527
<c.green>即使是100多层的巨大网络</c>

00:58:46.593 --> 00:58:49.963
<c.green>也可以用</c>
<c.green>Metal性能着色器框架实时运行</c>

00:58:50.097 --> 00:58:51.064
<c.green>但这并不是全部</c>

00:58:51.698 --> 00:58:54.801
<c.green>我还想要谈一下 在演示中</c>

00:58:54.868 --> 00:58:57.538
<c.green>通过使用MPS临时图片节约内存</c>

00:58:58.539 --> 00:59:00.307
<c.green>在这个演示的第一个版本中</c>

00:58:58.539 --> 00:59:00.307
<c.green>在这个演示的第一个版本中</c>

00:59:00.641 --> 00:59:03.577
<c.green>我们用了MPS图片</c>
<c.green>来存储中间结果</c>

00:59:04.211 --> 00:59:07.581
<c.green>我们最终以需要74 MPS图片结束</c>

00:59:07.648 --> 00:59:12.219
<c.green>整个网络的总尺寸超过80兆</c>

00:59:12.719 --> 00:59:15.189
<c.green>当然 你不必使用74张图片</c>

00:59:15.255 --> 00:59:16.156
<c.green>你可以针对如何重新使用</c>

00:59:16.657 --> 00:59:20.294
<c.green>这些图片提出你自己的体系</c>

00:59:20.527 --> 00:59:23.430
<c.green>但这意味着需要在代码中</c>
<c.green>管理更多的内容</c>

00:59:23.497 --> 00:59:27.267
<c.green>我们想确保我们的框架</c>
<c.green>尽可能地简单易用</c>

00:59:27.835 --> 00:59:29.636
<c.green>所以 在演示的第二个版本中</c>

00:59:29.970 --> 00:59:34.208
<c.green>我们用MPS临时图片</c>
<c.green>替换了所有MPS图片</c>

00:59:34.942 --> 00:59:36.743
<c.green>这带来了一些优势</c>

00:59:36.910 --> 00:59:40.647
<c.green>第一点是在时间和能源方面</c>
<c.green>减少了CPU消耗</c>

00:59:41.315 --> 00:59:44.852
<c.green>但仍然创建了74张临时图片</c>

00:59:44.918 --> 00:59:49.056
<c.green>只有5个底层内存分配</c>

00:59:49.423 --> 00:59:54.294
<c.green>总计只有20兆多一点儿</c>
<c.green>这节省了76％的内存</c>

00:59:54.528 --> 00:59:55.529
<c.green>这个数超级巨大</c>

00:59:57.931 --> 01:00:00.167
<c.green>我用这两个现场演示的是</c>

00:59:57.931 --> 01:00:00.167
<c.green>我用这两个现场演示的是</c>

01:00:00.234 --> 01:00:03.070
<c.green>Metal性能着色器框架</c>

01:00:03.136 --> 01:00:04.972
<c.green>为推理创建卷积神经网络</c>

01:00:05.038 --> 01:00:07.374
<c.green>提供的全力支持</c>

01:00:07.674 --> 01:00:10.043
<c.green>并优化了iOS GPU的使用情况</c>

01:00:10.110 --> 01:00:12.946
<c.green>所以 请使用卷积神经网络</c>

01:00:13.013 --> 01:00:14.281
<c.green>来建一些很酷的应用吧</c>

01:00:16.383 --> 01:00:18.852
<c.green>以上就是</c>
<c.green>“Metal的新特性”演讲的全部内容</c>

01:00:18.919 --> 01:00:20.954
<c.green>如果你没参加第一场演讲</c>

01:00:21.355 --> 01:00:23.223
<c.green>请看一下相关视频</c>

01:00:23.290 --> 01:00:25.392
<c.green>这样你就能了解这些很酷的新特性</c>

01:00:25.459 --> 01:00:29.463
<c.green>如曲面细分、资源堆和无记忆渲染目标</c>

01:00:29.530 --> 01:00:31.198
<c.green>以及现有工具的改进</c>

01:00:33.100 --> 01:00:37.004
<c.green>在这场演讲中 我们谈了专用函数</c>

01:00:37.070 --> 01:00:40.874
<c.green>和资源读写函数、白色和纹理资源、</c>

01:00:40.941 --> 01:00:43.377
<c.green>Metal性能工具的新增功能</c>

01:00:43.443 --> 01:00:45.846
<c.green>以及卷积神经网络的简单介绍</c>

01:00:47.281 --> 01:00:50.384
<c.green>要获得关于本场演讲的更多信息</c>
<c.green>请访问这个URL</c>

01:00:51.585 --> 01:00:52.653
<c.green>你可以观看视频</c>

01:00:52.719 --> 01:00:56.256
<c.green>并获得相关文档和示例代码的链接</c>

01:00:57.624 --> 01:01:00.260
<c.green>还有一些相关的演讲的信息</c>

01:00:57.624 --> 01:01:00.260
<c.green>还有一些相关的演讲的信息</c>

01:01:01.028 --> 01:01:05.866
<c.green>你总可以在线查看</c>
<c.green>过往Metal演讲的视频</c>

01:01:05.933 --> 01:01:07.534
<c.green>你还可以参加</c>

01:01:07.601 --> 01:01:10.504
<c.green>今天晚些时候举办的</c>
<c.green>高级Metal着色器优化演讲</c>

01:01:11.171 --> 01:01:14.575
<c.green>请注意 这场演讲的地址</c>
<c.green>改为了Knob Hill</c>

01:01:15.909 --> 01:01:19.479
<c.green>明天你们将有机会参加白色处理演讲</c>

01:01:19.546 --> 01:01:22.049
<c.green>及神经网络和加速演讲</c>

01:01:22.115 --> 01:01:25.018
<c.green>可以了解如何为CPU创建神经网络</c>

01:01:25.085 --> 01:01:26.720
<c.green>使用加速框架</c>

01:01:27.187 --> 01:01:30.991
<c.green>非常感谢大家来参加本场演讲</c>
<c.green>祝你们在WWDC期间度过一段美好的时光</c>
