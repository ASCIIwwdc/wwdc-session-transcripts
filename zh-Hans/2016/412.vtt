WEBVTT

00:00:19.486 --> 00:00:23.757
<c.magenta>线程检查工具</c>
<c.magenta>和静态分析</c>

00:00:23.824 --> 00:00:28.829
<c.magenta>帮助你在代码中查找错误</c>

00:00:31.765 --> 00:00:32.833
<c.magenta>大家好 我是Anna</c>

00:00:32.900 --> 00:00:35.869
<c.magenta>欢迎来到线程检查工具</c>
<c.magenta>和静态分析演讲</c>

00:00:36.937 --> 00:00:39.606
<c.magenta>由于我们的团队</c>
<c.magenta>从事于错误寻找工具</c>

00:00:39.673 --> 00:00:43.377
<c.magenta>我们将告诉你</c>
<c.magenta>找出错误的新方法</c>

00:00:44.044 --> 00:00:47.614
<c.magenta>我开始会简要概述一下</c>
<c.magenta>地址检查工具</c>

00:00:47.681 --> 00:00:50.484
<c.magenta>然后更加深入到</c>
<c.magenta>线程检查工具</c>

00:00:50.551 --> 00:00:52.953
<c.magenta>这是我们今年推出的新功能</c>

00:00:53.554 --> 00:00:56.456
<c.magenta>之后 Devin会上台</c>
<c.magenta>给大家讲讲新的检查</c>

00:00:56.523 --> 00:00:58.759
<c.magenta>我们添加到</c>
<c.magenta>Clang静态分析器上</c>

00:00:59.893 --> 00:01:00.727
<c.magenta>开始吧</c>

00:00:59.893 --> 00:01:00.727
<c.magenta>开始吧</c>

00:01:01.895 --> 00:01:07.601
<c.magenta>检查工具是LEM工具的一个家族</c>
<c.magenta>组合编译时间检测工具</c>

00:01:07.835 --> 00:01:11.405
<c.magenta>和运行时监控</c>
<c.magenta>在运行时寻找错误</c>

00:01:11.772 --> 00:01:13.407
<c.magenta>它们与Valgrind相似</c>

00:01:13.540 --> 00:01:17.377
<c.magenta>然而 它们的主要优点</c>
<c.magenta>是有低的运行时开销</c>

00:01:18.178 --> 00:01:20.314
<c.magenta>兼容Swift</c>
<c.magenta>和Objective-C</c>

00:01:20.514 --> 00:01:23.317
<c.magenta>而且紧密集成于</c>
<c.magenta>Xcode UI</c>

00:01:24.651 --> 00:01:28.555
<c.magenta>去年我们在macOS和iOS上</c>
<c.magenta>推出了地址检查工具</c>

00:01:29.056 --> 00:01:33.694
<c.magenta>这个工具能找出内存崩溃</c>
<c.magenta>例如栈堆缓冲区溢出</c>

00:01:33.760 --> 00:01:35.762
<c.magenta>用后死机 双重死机</c>

00:01:36.530 --> 00:01:39.499
<c.magenta>在寻找内存问题上</c>
<c.magenta>极为有效</c>

00:01:39.566 --> 00:01:43.470
<c.magenta>所以如果你还没使用</c>
<c.magenta>我极力推荐它</c>

00:01:44.304 --> 00:01:47.975
<c.magenta>今年我们扩展这个工具</c>
<c.magenta>给Swift提供全面支持</c>

00:01:48.609 --> 00:01:51.044
<c.magenta>这会是令人激动的消息</c>
<c.magenta>对于那些</c>

00:01:51.144 --> 00:01:53.780
<c.magenta>喜欢在Swift中</c>
<c.magenta>不走寻常路的人</c>

00:01:55.148 --> 00:01:58.452
<c.magenta>所以这意味着什么</c>
<c.magenta>如果你使用不安全指针类型？</c>

00:01:58.752 --> 00:02:03.056
<c.magenta>在地址检查工具开启时</c>
<c.magenta>进行测试 它会为你找出错误</c>

00:01:58.752 --> 00:02:03.056
<c.magenta>在地址检查工具开启时</c>
<c.magenta>进行测试 它会为你找出错误</c>

00:02:04.491 --> 00:02:08.829
<c.magenta>地址检查工具</c>
<c.magenta>虽然主要注重于内存崩溃问题</c>

00:02:08.895 --> 00:02:11.965
<c.magenta>这里还有一个大的错误来源</c>
<c.magenta>那就是线程问题</c>

00:02:12.933 --> 00:02:15.135
<c.magenta>这些更加难以重现并调试</c>

00:02:15.469 --> 00:02:16.970
<c.magenta>对时机很敏感</c>

00:02:17.171 --> 00:02:20.174
<c.magenta>它们可能只会在</c>
<c.magenta>某些情况下出现</c>

00:02:20.440 --> 00:02:23.577
<c.magenta>这意味着</c>
<c.magenta>包含它们的应用程序</c>

00:02:23.644 --> 00:02:25.746
<c.magenta>会有难以预测的行为</c>

00:02:26.213 --> 00:02:30.284
<c.magenta>所以今年我们推出另一个工具的支持</c>
<c.magenta>线程检查工具</c>

00:02:30.918 --> 00:02:32.819
<c.magenta>这会有助于你找到</c>

00:02:33.020 --> 00:02:35.756
<c.magenta>并更好理解</c>
<c.magenta>你的线程错误</c>

00:02:37.124 --> 00:02:39.126
<c.magenta>TSan报告很多</c>
<c.magenta>不同类型的错误</c>

00:02:39.193 --> 00:02:40.894
<c.magenta>我们来看一些错误</c>

00:02:41.228 --> 00:02:44.064
<c.magenta>我会告诉你关于</c>
<c.magenta>未初始化互斥体的使用</c>

00:02:44.531 --> 00:02:46.166
<c.magenta>这可能看起来</c>
<c.magenta>没什么大不了</c>

00:02:46.400 --> 00:02:49.736
<c.magenta>然而 如果你使用</c>
<c.magenta>未经恰当初始化的互斥体</c>

00:02:49.870 --> 00:02:52.372
<c.magenta>这会在你的应用程序中</c>
<c.magenta>导致非常细微的错误</c>

00:02:52.439 --> 00:02:55.509
<c.magenta>因为实际上</c>
<c.magenta>你没有实现任何互相排斥</c>

00:02:55.576 --> 00:02:56.977
<c.magenta>当你使用那样互斥体</c>

00:02:57.411 --> 00:02:59.446
<c.magenta>另一个例子是线程泄露</c>

00:02:59.713 --> 00:03:01.682
<c.magenta>如果你的应用程序</c>
<c.magenta>拥有很多线程</c>

00:02:59.713 --> 00:03:01.682
<c.magenta>如果你的应用程序</c>
<c.magenta>拥有很多线程</c>

00:03:01.748 --> 00:03:03.383
<c.magenta>如果那些线程泄露了</c>

00:03:03.984 --> 00:03:06.186
<c.magenta>这就会导致内存泄漏</c>

00:03:06.687 --> 00:03:09.089
<c.magenta>另一个是信号处理器中的</c>
<c.magenta>不安全调用</c>

00:03:09.156 --> 00:03:11.058
<c.magenta>以及从错误线程中解锁</c>

00:03:11.325 --> 00:03:15.028
<c.magenta>然而 数据竞争</c>
<c.magenta>是目前最常见的问题</c>

00:03:15.295 --> 00:03:17.397
<c.magenta>因为它们非常易于引发</c>

00:03:17.898 --> 00:03:21.468
<c.magenta>当多个线程访问相同</c>
<c.magenta>内存位置时就会发生</c>

00:03:21.768 --> 00:03:24.004
<c.magenta>没有使用恰当的同步</c>

00:03:25.005 --> 00:03:26.874
<c.magenta>我们看看该工具</c>
<c.magenta>是如何工作的</c>

00:03:26.940 --> 00:03:29.109
<c.magenta>通过进入Xcode演示</c>

00:03:39.419 --> 00:03:42.689
<c.magenta>这里我将演示</c>
<c.magenta>线程检查工具</c>

00:03:42.756 --> 00:03:45.859
<c.magenta>在去年Alpha版的</c>
<c.magenta>WWDC应用上</c>

00:03:46.393 --> 00:03:49.329
<c.magenta>所以如你所料</c>
<c.magenta>这里显示出了一周的安排</c>

00:03:49.863 --> 00:03:51.965
<c.magenta>不过 注意这个</c>
<c.magenta>有趣的视觉错误</c>

00:03:52.032 --> 00:03:54.735
<c.magenta>即使所有会话的数据</c>
<c.magenta>已下载完成</c>

00:03:54.968 --> 00:03:57.171
<c.magenta>网络活动指示器</c>
<c.magenta>还是在转动</c>

00:03:58.238 --> 00:04:00.374
<c.magenta>我知道我使用</c>
<c.magenta>全局变量来决定</c>

00:03:58.238 --> 00:04:00.374
<c.magenta>我知道我使用</c>
<c.magenta>全局变量来决定</c>

00:04:00.440 --> 00:04:03.744
<c.magenta>何时显示或隐藏这个指示器</c>
<c.magenta>所以这里可能有线程问题</c>

00:04:03.810 --> 00:04:06.380
<c.magenta>我们看看线程检查工具</c>
<c.magenta>能否帮我们找到</c>

00:04:07.381 --> 00:04:10.517
<c.magenta>为启用线程检查工具</c>
<c.magenta>我们选择编辑方案</c>

00:04:11.585 --> 00:04:13.287
<c.magenta>现在Diagnostics选项卡</c>

00:04:13.820 --> 00:04:16.055
<c.magenta>点击这里启用</c>
<c.magenta>线程检查工具</c>

00:04:16.990 --> 00:04:19.993
<c.magenta>现在你可以选择</c>
<c.magenta>每当遇到一个问题时</c>

00:04:20.060 --> 00:04:23.063
<c.magenta>就暂停调试器</c>
<c.magenta>并就地调试那个问题</c>

00:04:23.530 --> 00:04:25.332
<c.magenta>或者你可以选择保持运行</c>

00:04:25.399 --> 00:04:28.235
<c.magenta>收集线程检查工具</c>
<c.magenta>报告的所有线程问题</c>

00:04:28.302 --> 00:04:29.469
<c.magenta>之后再探究它们</c>

00:04:30.003 --> 00:04:33.707
<c.magenta>Xcode 8第二个工作流程是新的</c>
<c.magenta>只有线程检查工具支持</c>

00:04:33.774 --> 00:04:35.809
<c.magenta>我们看看其工作原理</c>

00:04:37.444 --> 00:04:40.147
<c.magenta>当你在线程检查工具下</c>
<c.magenta>启动应用程序</c>

00:04:40.347 --> 00:04:44.084
<c.magenta>Xcode会通过额外的</c>
<c.magenta>编译器工具重建你的项目</c>

00:04:44.518 --> 00:04:46.653
<c.magenta>然后会在特殊模式中启动它</c>

00:04:46.720 --> 00:04:48.722
<c.magenta>尝试找到线程问题</c>

00:04:49.256 --> 00:04:51.358
<c.magenta>这里我们的应用程序启动了</c>

00:04:51.658 --> 00:04:54.494
<c.magenta>Xcode告诉我们线程检查工具</c>
<c.magenta>检测到两个问题</c>

00:04:54.561 --> 00:04:58.031
<c.magenta>并在活动查看器中显示了</c>
<c.magenta>这个紫色的指示器</c>

00:04:59.032 --> 00:05:01.034
<c.magenta>点击这个紫色指示器</c>

00:04:59.032 --> 00:05:01.034
<c.magenta>点击这个紫色指示器</c>

00:05:01.401 --> 00:05:03.136
<c.magenta>会将我们带到</c>
<c.magenta>问题导航器</c>

00:05:03.437 --> 00:05:05.172
<c.magenta>之前我们只是用它</c>

00:05:05.239 --> 00:05:07.608
<c.magenta>显示构建时间问题</c>
<c.magenta>例如编译器警告</c>

00:05:07.674 --> 00:05:09.776
<c.magenta>编译器错误</c>
<c.magenta>静态分析器问题</c>

00:05:09.843 --> 00:05:12.779
<c.magenta>今年扩展支持了</c>
<c.magenta>运行时问题</c>

00:05:12.846 --> 00:05:15.849
<c.magenta>这样线程检查工具</c>
<c.magenta>的问题就能找到根源</c>

00:05:16.783 --> 00:05:20.053
<c.magenta>线程检查工具报告了两个问题</c>
<c.magenta>我们一个个看</c>

00:05:20.120 --> 00:05:23.123
<c.magenta>第一个是使用了</c>
<c.magenta>未初始化互斥体</c>

00:05:24.091 --> 00:05:27.928
<c.magenta>这个问题在之前运行</c>
<c.magenta>应用程序的某个时候出现的</c>

00:05:28.295 --> 00:05:31.431
<c.magenta>线程检查工具</c>
<c.magenta>会告诉我们确切的时间</c>

00:05:31.498 --> 00:05:33.834
<c.magenta>通过提供历史堆栈跟踪</c>

00:05:34.301 --> 00:05:36.336
<c.magenta>即使这不是即时堆栈跟踪</c>

00:05:36.403 --> 00:05:39.606
<c.magenta>你可以把它当做即时</c>
<c.magenta>堆栈跟踪 一帧一帧查看</c>

00:05:39.706 --> 00:05:40.707
<c.magenta>我们来看看</c>

00:05:40.774 --> 00:05:42.976
<c.magenta>某时刻</c>
<c.magenta>我们调用了acquireLock</c>

00:05:43.043 --> 00:05:46.613
<c.magenta>这调用了pthread_mutex_lock</c>
<c.magenta>然后传递了无效的互斥体引用</c>

00:05:47.114 --> 00:05:50.551
<c.magenta>这是调用自resetFeedStatus</c>
<c.magenta>而它又是调用自初始化器</c>

00:05:51.485 --> 00:05:53.820
<c.magenta>这里如你所见</c>
<c.magenta>我们确实初始化了互斥体</c>

00:05:53.921 --> 00:05:55.889
<c.magenta>不过是在使用之后</c>
<c.magenta>才初始化的</c>

00:05:56.023 --> 00:05:57.491
<c.magenta>这是简单的排序错误</c>

00:05:58.025 --> 00:06:00.961
<c.magenta>所以重新给这两个陈述排序</c>
<c.magenta>就应该解决好了</c>

00:05:58.025 --> 00:06:00.961
<c.magenta>所以重新给这两个陈述排序</c>
<c.magenta>就应该解决好了</c>

00:06:01.195 --> 00:06:05.199
<c.magenta>好了 我们来看看第二个问题</c>
<c.magenta>那就是数据竞争</c>

00:06:06.433 --> 00:06:09.036
<c.magenta>线程检查工具</c>
<c.magenta>告诉我们出现数据竞争</c>

00:06:09.102 --> 00:06:11.004
<c.magenta>在叫做活动计数的变量上</c>

00:06:11.071 --> 00:06:14.341
<c.magenta>这是相同的全局变量</c>
<c.magenta>用来决定</c>

00:06:14.408 --> 00:06:16.476
<c.magenta>何时显示或隐藏指示器的</c>

00:06:17.344 --> 00:06:21.381
<c.magenta>因为这是数据竞争</c>
<c.magenta>线程检查工具会告诉我们两个事件</c>

00:06:21.582 --> 00:06:23.617
<c.magenta>两个竞争访问</c>

00:06:23.684 --> 00:06:25.118
<c.magenta>一个读取和一个写入</c>

00:06:25.452 --> 00:06:27.187
<c.magenta>所以线程11上出现读取</c>

00:06:27.254 --> 00:06:29.256
<c.magenta>而线程13上出现写入</c>

00:06:29.857 --> 00:06:32.326
<c.magenta>注意这两个都不是主线程</c>

00:06:32.893 --> 00:06:34.428
<c.magenta>而且堆栈跟踪是一样的</c>

00:06:34.494 --> 00:06:37.297
<c.magenta>这意味着它们可能</c>
<c.magenta>通过多个线程</c>

00:06:37.598 --> 00:06:40.467
<c.magenta>在相同的线上执行</c>
<c.magenta>并且没有使用同步</c>

00:06:40.701 --> 00:06:41.635
<c.magenta>我们来看看</c>

00:06:42.169 --> 00:06:45.372
<c.magenta>好了 我们在更新</c>
<c.magenta>活动计数变量</c>

00:06:46.139 --> 00:06:49.009
<c.magenta>现在我可以通过添加锁</c>
<c.magenta>来修复这个竞争</c>

00:06:49.409 --> 00:06:51.578
<c.magenta>不过注意这只是症状</c>

00:06:52.312 --> 00:06:54.882
<c.magenta>这里的下一行更新UI</c>

00:06:55.983 --> 00:06:59.052
<c.magenta>我们知道UI更新</c>
<c.magenta>应该发生在主线程上</c>

00:06:59.419 --> 00:07:01.989
<c.magenta>所以合适的修复是将</c>

00:06:59.419 --> 00:07:01.989
<c.magenta>所以合适的修复是将</c>

00:07:02.456 --> 00:07:06.293
<c.magenta>counter-increment</c>
<c.magenta>和UI更新分派到</c>

00:07:06.560 --> 00:07:10.764
<c.magenta>Grand Central Dispatch</c>
<c.magenta>的主队列上</c>

00:07:11.965 --> 00:07:15.202
<c.magenta>这既会解决</c>
<c.magenta>我们应用程序的逻辑问题</c>

00:07:15.269 --> 00:07:18.539
<c.magenta>也会解决竞争</c>
<c.magenta>因为所有的线程会从</c>

00:07:20.174 --> 00:07:22.242
<c.magenta>相同的线程上</c>
<c.magenta>访问计数变量</c>

00:07:22.743 --> 00:07:25.579
<c.magenta>我确定</c>
<c.magenta>我说得十分有说服力</c>

00:07:25.646 --> 00:07:27.814
<c.magenta>而且你们都相信</c>
<c.magenta>我将错误修复好了</c>

00:07:28.048 --> 00:07:30.450
<c.magenta>然而 最好的自行检查方式</c>

00:07:30.517 --> 00:07:33.253
<c.magenta>就是在你的项目上</c>
<c.magenta>再次运行这个工具</c>

00:07:33.921 --> 00:07:38.525
<c.magenta>所以我们应该在线程检查工具</c>
<c.magenta>启用的情况下重新运行应用程序</c>

00:07:38.592 --> 00:07:40.594
<c.magenta>这会再次重建你的项目</c>

00:07:40.661 --> 00:07:43.897
<c.magenta>带有这个额外检查</c>
<c.magenta>而且在特殊模式中启动</c>

00:07:44.731 --> 00:07:46.400
<c.magenta>现在应用程序启动了</c>

00:07:46.800 --> 00:07:50.103
<c.magenta>我们看到奇怪的</c>
<c.magenta>视觉UI错误消失了</c>

00:07:50.170 --> 00:07:52.406
<c.magenta>而且线程检查工具</c>
<c.magenta>没有报告任何问题</c>

00:07:52.840 --> 00:07:53.907
<c.magenta>一切正常</c>

00:07:54.274 --> 00:07:56.844
<c.magenta>我们回到幻灯片</c>

00:08:05.819 --> 00:08:07.654
<c.magenta>我们回顾一下演示</c>

00:08:08.288 --> 00:08:10.691
<c.magenta>在方案编辑器中启用</c>
<c.magenta>线程检查工具</c>

00:08:10.757 --> 00:08:14.528
<c.magenta>当你进入诊断选项卡</c>
<c.magenta>跟地址检查工具的做法一样</c>

00:08:14.728 --> 00:08:19.166
<c.magenta>除了拥有在出现第一个问题时</c>
<c.magenta>暂停调试器的ASan工作流程之外</c>

00:08:19.399 --> 00:08:21.802
<c.magenta>线程检查工具</c>
<c.magenta>支持另一种模式</c>

00:08:21.969 --> 00:08:24.471
<c.magenta>你可以在检测问题的</c>
<c.magenta>过程中保持运行</c>

00:08:24.538 --> 00:08:27.040
<c.magenta>之后你可以在</c>
<c.magenta>问题导航器中探究它们</c>

00:08:27.207 --> 00:08:29.877
<c.magenta>在你重启应用程序之前</c>
<c.magenta>它们会留在那里</c>

00:08:30.944 --> 00:08:33.947
<c.magenta>我们来谈谈Xcode</c>
<c.magenta>在后台发挥了什么作用</c>

00:08:34.014 --> 00:08:35.649
<c.magenta>来让这一切奏效</c>

00:08:36.316 --> 00:08:39.520
<c.magenta>为了使用线程检查工具</c>
<c.magenta>Xcode将特殊标记传递给</c>

00:08:39.586 --> 00:08:41.822
<c.magenta>Clang和Swift编译器</c>

00:08:42.289 --> 00:08:44.925
<c.magenta>命令它们生成</c>
<c.magenta>被检测二进制文件</c>

00:08:45.993 --> 00:08:48.929
<c.magenta>这个二进制文件链接到</c>
<c.magenta>TSan运行时间库</c>

00:08:49.329 --> 00:08:51.832
<c.magenta>由检测工具使用来</c>

00:08:51.965 --> 00:08:55.302
<c.magenta>监控程序的执行</c>
<c.magenta>并检测那些线程问题</c>

00:08:55.936 --> 00:08:58.805
<c.magenta>所以如果你从命令行</c>
<c.magenta>进行构建和运行</c>

00:08:58.872 --> 00:09:01.942
<c.magenta>你可以将选项</c>
<c.magenta>传递给任何一个编译器</c>

00:08:58.872 --> 00:09:01.942
<c.magenta>你可以将选项</c>
<c.magenta>传递给任何一个编译器</c>

00:09:02.876 --> 00:09:04.978
<c.magenta>而且xcodebuild还会支持</c>
<c.magenta>线程检查工具</c>

00:09:05.045 --> 00:09:07.381
<c.magenta>通过提供</c>
<c.magenta>enableThreadSanitizer选项</c>

00:09:08.282 --> 00:09:11.818
<c.magenta>默认情况下 TSan会在</c>
<c.magenta>检测错误的过程中持续运行</c>

00:09:12.319 --> 00:09:15.756
<c.magenta>不过你可以命令它</c>
<c.magenta>在遇到第一个问题时就中止</c>

00:09:15.956 --> 00:09:18.492
<c.magenta>通过将TSan选项</c>
<c.magenta>环境变量设置成</c>

00:09:18.559 --> 00:09:21.562
<c.magenta>在启动过程的时候</c>
<c.magenta>当halt_on_error=1时中止</c>

00:09:21.828 --> 00:09:25.832
<c.magenta>这会允许你有相同的工作流</c>
<c.magenta>与地址检查工具是一样</c>

00:09:27.968 --> 00:09:29.403
<c.magenta>在哪里可以使用这个工具？</c>

00:09:29.503 --> 00:09:31.705
<c.magenta>线程检查工具</c>
<c.magenta>在macOS上有支持</c>

00:09:31.772 --> 00:09:33.640
<c.magenta>以及64位的模拟器</c>

00:09:33.841 --> 00:09:36.109
<c.magenta>并不在设备上支持</c>

00:09:37.344 --> 00:09:40.480
<c.magenta>现在你知道如何使用该工具</c>
<c.magenta>如何启动 如果寻找问题</c>

00:09:40.547 --> 00:09:43.750
<c.magenta>我们来谈谈</c>
<c.magenta>如何修复报告中的错误</c>

00:09:44.117 --> 00:09:45.986
<c.magenta>我们主要注重于数据竞争</c>

00:09:46.053 --> 00:09:49.423
<c.magenta>因为这是所报告的</c>
<c.magenta>错误中最多的类型</c>

00:09:50.224 --> 00:09:51.825
<c.magenta>什么是数据竞争？</c>

00:09:52.159 --> 00:09:54.328
<c.magenta>数据竞争发生于</c>
<c.magenta>当多个线程</c>

00:09:54.995 --> 00:09:56.997
<c.magenta>访问相同的内存位置</c>

00:09:57.064 --> 00:09:59.233
<c.magenta>没有使用恰当的同步</c>

00:09:59.733 --> 00:10:02.703
<c.magenta>而且至少一个访问是写入</c>

00:09:59.733 --> 00:10:02.703
<c.magenta>而且至少一个访问是写入</c>

00:10:03.971 --> 00:10:08.642
<c.magenta>这里的问题是</c>
<c.magenta>你最后可能不止得到过期数据</c>

00:10:08.942 --> 00:10:10.944
<c.magenta>而且行为是无法预测的</c>

00:10:11.011 --> 00:10:13.380
<c.magenta>你最后甚至可能遇到内存崩溃</c>

00:10:14.281 --> 00:10:16.550
<c.magenta>所以数据竞争的原因是什么？</c>

00:10:16.717 --> 00:10:19.419
<c.magenta>这通常表明</c>
<c.magenta>你遇到了逻辑问题</c>

00:10:19.853 --> 00:10:22.389
<c.magenta>在你程序的结构中</c>

00:10:22.556 --> 00:10:24.424
<c.magenta>而且只有你知道如何修复</c>

00:10:25.125 --> 00:10:28.195
<c.magenta>另一方面 这还意味着</c>
<c.magenta>缺失一些同步</c>

00:10:28.262 --> 00:10:30.797
<c.magenta>我们来谈谈第二种情景</c>

00:10:31.965 --> 00:10:34.368
<c.magenta>这是一个Swift中</c>
<c.magenta>数据竞争的例子</c>

00:10:34.668 --> 00:10:36.270
<c.magenta>我们有全局变量数据</c>

00:10:36.703 --> 00:10:38.839
<c.magenta>我们有一个生产者</c>
<c.magenta>设置成42</c>

00:10:38.906 --> 00:10:41.141
<c.magenta>以及一个打印它的消费者</c>

00:10:42.009 --> 00:10:44.244
<c.magenta>如果执行这两段代码</c>

00:10:44.511 --> 00:10:46.947
<c.magenta>通过两个不同的线程</c>
<c.magenta>这就会出现数据竞争</c>

00:10:48.182 --> 00:10:49.283
<c.magenta>那这个代码怎么样？</c>

00:10:49.650 --> 00:10:52.886
<c.magenta>我们引入了另一个变量</c>
<c.magenta>叫做isDataAvailable</c>

00:10:53.287 --> 00:10:57.024
<c.magenta>数据在生产者中更新后</c>
<c.magenta>我们设置那个标记</c>

00:10:57.291 --> 00:10:59.826
<c.magenta>而在消费者中我们要等待</c>
<c.magenta>直到标记设置完成</c>

00:10:59.893 --> 00:11:01.929
<c.magenta>如果一旦设置好</c>
<c.magenta>我们打印数据</c>

00:10:59.893 --> 00:11:01.929
<c.magenta>如果一旦设置好</c>
<c.magenta>我们打印数据</c>

00:11:02.362 --> 00:11:04.464
<c.magenta>这看起来很有逻辑</c>

00:11:04.598 --> 00:11:05.999
<c.magenta>看起来应该会奏效</c>

00:11:06.600 --> 00:11:10.070
<c.magenta>问题是你看到的东西</c>
<c.magenta>不会得到执行</c>

00:11:11.238 --> 00:11:14.808
<c.magenta>这里的指令可以被</c>
<c.magenta>任一个编译器重新排序</c>

00:11:14.875 --> 00:11:18.045
<c.magenta>或者CPU 所以你不能</c>
<c.magenta>假设标记是在</c>

00:11:18.111 --> 00:11:20.314
<c.magenta>数据更新之后设置</c>

00:11:20.848 --> 00:11:23.617
<c.magenta>指令的顺序无法保证</c>

00:11:23.684 --> 00:11:25.319
<c.magenta>在生产者和</c>
<c.magenta>消费者中都一样</c>

00:11:26.687 --> 00:11:28.422
<c.magenta>所以这张幻灯片的意义何在？</c>

00:11:28.488 --> 00:11:30.724
<c.magenta>我只是想演示</c>

00:11:31.058 --> 00:11:34.428
<c.magenta>试着推出自己的同步方法</c>

00:11:34.628 --> 00:11:36.597
<c.magenta>通常是不好的想法</c>

00:11:37.030 --> 00:11:38.198
<c.magenta>那应该怎么做？</c>

00:11:38.465 --> 00:11:40.868
<c.magenta>我们应该使用</c>
<c.magenta>已经可用的东西</c>

00:11:41.201 --> 00:11:43.537
<c.magenta>例如</c>
<c.magenta>Grand Central Dispatch</c>

00:11:43.770 --> 00:11:47.007
<c.magenta>是一个非常好的选项</c>
<c.magenta>你可以将最近访问</c>

00:11:47.407 --> 00:11:49.543
<c.magenta>分配到相同的串行队列</c>

00:11:49.943 --> 00:11:52.613
<c.magenta>这会确保它们在</c>
<c.magenta>相同的线程上执行</c>

00:11:52.679 --> 00:11:54.147
<c.magenta>而且没有数据竞争</c>

00:11:55.382 --> 00:11:59.486
<c.magenta>现你可能想起线程检查工具</c>
<c.magenta>适用于Objective-C和Swift</c>

00:11:59.653 --> 00:12:02.089
<c.magenta>我们使用Objective-C</c>
<c.magenta>作为下一个例子</c>

00:11:59.653 --> 00:12:02.089
<c.magenta>我们使用Objective-C</c>
<c.magenta>作为下一个例子</c>

00:12:03.557 --> 00:12:05.459
<c.magenta>这是惰性初始化代码</c>

00:12:05.759 --> 00:12:09.196
<c.magenta>我们的实现方法</c>
<c.magenta>叫做getSingleton</c>

00:12:09.496 --> 00:12:13.467
<c.magenta>确保我们将相同的共享实例</c>
<c.magenta>返回到其所有的调用者</c>

00:12:14.968 --> 00:12:17.738
<c.magenta>如果这个代码</c>
<c.magenta>由多个线程执行</c>

00:12:18.071 --> 00:12:20.741
<c.magenta>没有适当的同步</c>
<c.magenta>这就会出现数据竞争</c>

00:12:21.074 --> 00:12:24.878
<c.magenta>当两个线程都尝试</c>
<c.magenta>更新共享实例变量</c>

00:12:26.146 --> 00:12:27.881
<c.magenta>好了 那这个代码呢？</c>

00:12:28.348 --> 00:12:31.485
<c.magenta>我们尝试修复这个问题</c>
<c.magenta>通过分配</c>

00:12:31.552 --> 00:12:33.487
<c.magenta>并初始化本地变量</c>

00:12:33.921 --> 00:12:37.024
<c.magenta>之后我们使用</c>
<c.magenta>atomic_compare_and_set操作</c>

00:12:37.090 --> 00:12:41.962
<c.magenta>来确保线程会原子级地</c>
<c.magenta>更新那个全局变量</c>

00:12:42.062 --> 00:12:44.565
<c.magenta>所以在右边</c>
<c.magenta>不会有数据竞争</c>

00:12:45.566 --> 00:12:47.301
<c.magenta>这看起来像是踏入正轨</c>

00:12:47.367 --> 00:12:48.902
<c.magenta>不过这个代码还有问题</c>

00:12:49.336 --> 00:12:50.637
<c.magenta>我们来看看它们</c>

00:12:50.771 --> 00:12:54.441
<c.magenta>首先 这会非常难以</c>
<c.magenta>推断出内存管理</c>

00:12:54.541 --> 00:12:56.143
<c.magenta>当你使用原子</c>

00:12:56.543 --> 00:12:59.813
<c.magenta>例如 如果你使用ARC</c>
<c.magenta>这里你会遇到use-after-free</c>

00:13:00.681 --> 00:13:02.783
<c.magenta>如果你使用MRR</c>

00:13:03.083 --> 00:13:06.420
<c.magenta>这个对象只有在</c>
<c.magenta>竞争出现时泄露</c>

00:13:07.054 --> 00:13:09.122
<c.magenta>这不是好事</c>

00:13:09.223 --> 00:13:10.357
<c.magenta>问题不只这一个</c>

00:13:10.424 --> 00:13:14.628
<c.magenta>另一个问题是</c>
<c.magenta>因为读取是非同步的</c>

00:13:14.895 --> 00:13:17.030
<c.magenta>这里还是会出现竞争</c>
<c.magenta>如果一个线程尝试</c>

00:13:17.097 --> 00:13:18.699
<c.magenta>读取那个共享变量</c>

00:13:18.765 --> 00:13:21.802
<c.magenta>而另一个尝试</c>
<c.magenta>原子级地设置它</c>

00:13:22.503 --> 00:13:25.305
<c.magenta>所以这是未定义行为</c>
<c.magenta>这不好</c>

00:13:26.039 --> 00:13:27.274
<c.magenta>那你应该怎么做？</c>

00:13:27.341 --> 00:13:30.444
<c.magenta>如果你已经知道解决方案了</c>
<c.magenta>使用Grand Central Dispatch</c>

00:13:30.511 --> 00:13:34.081
<c.magenta>这会替你进行</c>
<c.magenta>惰性初始化设置</c>

00:13:35.282 --> 00:13:36.850
<c.magenta>这在Swift中更加容易</c>

00:13:37.251 --> 00:13:41.855
<c.magenta>全局变量和类型常量</c>
<c.magenta>都分派了一个语义</c>

00:13:42.122 --> 00:13:43.924
<c.magenta>你能选择两者任意</c>
<c.magenta>一个解决方案</c>

00:13:43.991 --> 00:13:45.792
<c.magenta>对你的代码有最有效的那个</c>

00:13:47.561 --> 00:13:49.196
<c.magenta>好了 总结一下</c>

00:13:49.263 --> 00:13:52.366
<c.magenta>你应该使用适合</c>
<c.magenta>你需求的最高级别API</c>

00:13:52.900 --> 00:13:55.936
<c.magenta>大多数人应该使用Grand</c>
<c.magenta>Central Dispatch</c>

00:13:56.069 --> 00:13:59.940
<c.magenta>如果这不适合</c>
<c.magenta>你可以使用pthread API</c>

00:14:00.240 --> 00:14:01.775
<c.magenta>或者比如NSLock</c>

00:14:03.343 --> 00:14:07.781
<c.magenta>我们新os_unfair_lock</c>
<c.magenta>是今年在我们平台上新出的</c>

00:14:07.848 --> 00:14:09.716
<c.magenta>它代替了OSSpinLock</c>

00:14:09.950 --> 00:14:12.553
<c.magenta>我们还有</c>
<c.magenta>C++和C11 Atomics</c>

00:14:13.120 --> 00:14:15.255
<c.magenta>线程检查工具支持它们</c>

00:14:15.355 --> 00:14:19.226
<c.magenta>你在之前的例子中看过了</c>
<c.magenta>它们非常难以正确地使用</c>

00:14:20.093 --> 00:14:21.495
<c.magenta>除了性能之外</c>

00:14:21.562 --> 00:14:25.265
<c.magenta>这要么是不可测量的</c>
<c.magenta>或者是可以忽略的</c>

00:14:25.699 --> 00:14:29.870
<c.magenta>所以不要选择使用那些API</c>
<c.magenta>如果你不去测量</c>

00:14:29.937 --> 00:14:32.873
<c.magenta>它们确实在你的</c>
<c.magenta>应用程序上有一些东西</c>

00:14:34.408 --> 00:14:36.844
<c.magenta>所以关于更多这些API的信息</c>

00:14:36.910 --> 00:14:40.547
<c.magenta>请参加</c>
<c.magenta>周五的并发程序设计演讲</c>

00:14:42.216 --> 00:14:44.618
<c.magenta>现在我们来谈谈良性竞争</c>

00:14:44.918 --> 00:14:45.953
<c.magenta>这是什么？</c>

00:14:46.019 --> 00:14:48.689
<c.magenta>一些开发者主张</c>
<c.magenta>在一些架构上</c>

00:14:48.956 --> 00:14:50.457
<c.magenta>例如x86</c>

00:14:50.858 --> 00:14:54.328
<c.magenta>你不需要在读取和</c>
<c.magenta>写入之间插入同步</c>

00:14:54.828 --> 00:14:57.798
<c.magenta>因为架构本身就保证了自动</c>

00:14:57.865 --> 00:15:00.534
<c.magenta>指针大小数据的操作</c>

00:14:57.865 --> 00:15:00.534
<c.magenta>指针大小数据的操作</c>

00:15:01.802 --> 00:15:05.539
<c.magenta>要记住的重要一点是</c>
<c.magenta>任何竞争 即使是良性竞争</c>

00:15:05.606 --> 00:15:09.676
<c.magenta>在C或C++标准中</c>
<c.magenta>被视为未定义的行为</c>

00:15:10.377 --> 00:15:14.781
<c.magenta>所以你不仅会惊奇地发现</c>
<c.magenta>带有良性竞争的代码运行在</c>

00:15:14.848 --> 00:15:17.684
<c.magenta>你之前没有完全测试好的架构上</c>

00:15:18.118 --> 00:15:21.421
<c.magenta>而且编译器可以自由</c>
<c.magenta>给那些指令重新排序</c>

00:15:21.488 --> 00:15:23.724
<c.magenta>跟没有其他线程看到一样</c>

00:15:24.958 --> 00:15:28.328
<c.magenta>所以最后你可能</c>
<c.magenta>会遇到非常细微的错误</c>

00:15:28.695 --> 00:15:35.068
<c.magenta>正如我们的线程检查工具</c>
<c.magenta>工程主管所说：“修复所有错误”</c>

00:15:43.277 --> 00:15:46.013
<c.magenta>现在到我们演讲</c>
<c.magenta>最精彩的部分了</c>

00:15:46.580 --> 00:15:49.716
<c.magenta>我们都知道数据竞争</c>
<c.magenta>很难重现 因为它们</c>

00:15:49.783 --> 00:15:51.051
<c.magenta>对时机非常敏感</c>

00:15:51.652 --> 00:15:55.222
<c.magenta>线程检查工具</c>
<c.magenta>最有趣的一点是它可以检测</c>

00:15:55.289 --> 00:15:58.192
<c.magenta>那些在特定程序运行</c>
<c.magenta>过程中未显现的竞争</c>

00:15:58.825 --> 00:16:00.260
<c.magenta>来看看它是怎么做到的</c>

00:15:58.825 --> 00:16:00.260
<c.magenta>来看看它是怎么做到的</c>

00:16:01.295 --> 00:16:04.031
<c.magenta>当你用线程检查工具</c>
<c.magenta>编译你的程序</c>

00:16:04.231 --> 00:16:06.300
<c.magenta>它会检测每个内存访问</c>

00:16:06.366 --> 00:16:09.369
<c.magenta>然后在上面加上标记前缀</c>
<c.magenta>使用引号</c>

00:16:09.636 --> 00:16:13.273
<c.magenta>不过首先</c>
<c.magenta>记录关于访问的信息</c>

00:16:14.341 --> 00:16:19.680
<c.magenta>第二 检查那个</c>
<c.magenta>访问是否参与竞争</c>

00:16:20.347 --> 00:16:21.715
<c.magenta>我们来深入看看</c>

00:16:22.683 --> 00:16:25.319
<c.magenta>对于每个对齐的</c>
<c.magenta>8字节应用程序内存</c>

00:16:25.919 --> 00:16:30.791
<c.magenta>线程检查工具的影子状态</c>
<c.magenta>会最多记录4个访问</c>

00:16:31.425 --> 00:16:33.126
<c.magenta>假设你有4个线程</c>

00:16:33.360 --> 00:16:35.229
<c.magenta>线程1写入到那个内存位置</c>

00:16:35.495 --> 00:16:38.165
<c.magenta>线程检查工具更新它</c>
<c.magenta>将信息存储在</c>

00:16:38.232 --> 00:16:40.434
<c.magenta>影子线程</c>
<c.magenta>来重置内存位置</c>

00:16:40.701 --> 00:16:43.871
<c.magenta>我们还是会记录</c>
<c.magenta>我们持续不断做下去</c>

00:16:44.338 --> 00:16:47.841
<c.magenta>现在如果你有</c>
<c.magenta>4个以上的访问怎么办？</c>

00:16:50.377 --> 00:16:52.880
<c.magenta>线程检查工具</c>
<c.magenta>使用有根据的推测</c>

00:16:52.946 --> 00:16:55.816
<c.magenta>决定接下来</c>
<c.magenta>将哪个单元格驱逐掉</c>

00:16:55.883 --> 00:16:59.052
<c.magenta>这里它驱逐了</c>
<c.magenta>相同线程的访问</c>

00:16:59.887 --> 00:17:01.855
<c.magenta>这不会使其失去精度</c>

00:16:59.887 --> 00:17:01.855
<c.magenta>这不会使其失去精度</c>

00:17:03.090 --> 00:17:05.325
<c.magenta>然而 如果我们有</c>
<c.magenta>第五个访问</c>

00:17:05.392 --> 00:17:07.426
<c.magenta>这会驱逐一个随机单元格</c>

00:17:07.994 --> 00:17:10.797
<c.magenta>所以像这样限制</c>
<c.magenta>访问的数量意味着</c>

00:17:10.864 --> 00:17:13.500
<c.magenta>我们可能不会在</c>
<c.magenta>所有案例中遇到所有竞争</c>

00:17:14.902 --> 00:17:18.839
<c.magenta>好了 现在我们谈谈</c>
<c.magenta>它是如何检测数据竞争的</c>

00:17:19.339 --> 00:17:21.208
<c.magenta>线程检查工具</c>
<c.magenta>使用众所周知的方法</c>

00:17:21.275 --> 00:17:23.377
<c.magenta>用向量时钟检查竞争</c>

00:17:24.178 --> 00:17:25.345
<c.magenta>这如何起作用的？</c>

00:17:25.878 --> 00:17:27.580
<c.magenta>每个线程有线程本地存储</c>

00:17:27.915 --> 00:17:30.651
<c.magenta>记录线程自身的计数器</c>

00:17:31.885 --> 00:17:34.955
<c.magenta>以及其他所有线程的计数器</c>

00:17:35.822 --> 00:17:37.991
<c.magenta>这个计数器初始化为0</c>

00:17:38.225 --> 00:17:40.627
<c.magenta>每次有线程访问内存</c>

00:17:41.195 --> 00:17:42.896
<c.magenta>计数器就会增加</c>

00:17:43.497 --> 00:17:48.836
<c.magenta>例如 线程1访问了</c>
<c.magenta>2个内存位置</c>

00:17:49.236 --> 00:17:52.039
<c.magenta>线程2访问了</c>
<c.magenta>22个内存位置</c>

00:17:52.906 --> 00:17:55.342
<c.magenta>线程3访问了</c>
<c.magenta>55个内存位置</c>

00:17:56.343 --> 00:17:58.712
<c.magenta>这个时间戳</c>
<c.magenta>是没有可比性的</c>

00:17:59.413 --> 00:18:02.182
<c.magenta>每个线程使用这些</c>
<c.magenta>时间戳或者计数器</c>

00:17:59.413 --> 00:18:02.182
<c.magenta>每个线程使用这些</c>
<c.magenta>时间戳或者计数器</c>

00:18:02.249 --> 00:18:06.253
<c.magenta>来给其进行的内存访问排序</c>

00:18:07.955 --> 00:18:10.090
<c.magenta>好了 我们回来</c>

00:18:10.824 --> 00:18:13.727
<c.magenta>将内存位置带回来</c>

00:18:13.794 --> 00:18:17.598
<c.magenta>及其影子</c>
<c.magenta>看看线程是如何交互的</c>

00:18:17.664 --> 00:18:19.333
<c.magenta>以及它们如何</c>
<c.magenta>更新这里的计数器</c>

00:18:19.900 --> 00:18:21.802
<c.magenta>我们还会加入锁</c>
<c.magenta>线程使用它</c>

00:18:21.869 --> 00:18:24.071
<c.magenta>来同步内存位置的访问</c>

00:18:24.838 --> 00:18:26.473
<c.magenta>好了 线程1写入</c>

00:18:27.174 --> 00:18:29.810
<c.magenta>这是行为良好的线程</c>
<c.magenta>它会获取那个锁</c>

00:18:30.577 --> 00:18:32.279
<c.magenta>它会更新其计数器</c>

00:18:33.146 --> 00:18:35.182
<c.magenta>它会写入到那个内存位置中</c>

00:18:35.749 --> 00:18:37.784
<c.magenta>线程检查工具</c>
<c.magenta>现在看到它了</c>

00:18:38.151 --> 00:18:39.887
<c.magenta>它会更新影子</c>

00:18:40.721 --> 00:18:44.057
<c.magenta>在更新影子之前</c>
<c.magenta>它看到影子中什么都没有</c>

00:18:44.124 --> 00:18:46.226
<c.magenta>没保存到影子中</c>
<c.magenta>意味着</c>

00:18:46.460 --> 00:18:49.763
<c.magenta>内存位置之前未被访问</c>

00:18:50.264 --> 00:18:52.299
<c.magenta>所以可以安全地写入进去</c>

00:18:53.734 --> 00:18:56.770
<c.magenta>在释放锁之前</c>
<c.magenta>线程1会在上面</c>

00:18:56.904 --> 00:18:58.805
<c.magenta>更新有自己的时间戳</c>

00:18:59.706 --> 00:19:01.074
<c.magenta>然后释放那个锁</c>

00:18:59.706 --> 00:19:01.074
<c.magenta>然后释放那个锁</c>

00:19:01.575 --> 00:19:04.278
<c.magenta>现在该线程2去写入了</c>

00:19:05.012 --> 00:19:08.448
<c.magenta>线程2也是行为非常良好</c>
<c.magenta>的线程 它会获取那个锁</c>

00:19:09.550 --> 00:19:13.287
<c.magenta>像这样获取锁</c>
<c.magenta>会让线程2看到</c>

00:19:13.353 --> 00:19:16.123
<c.magenta>线程1的计数器已经增加了</c>

00:19:18.192 --> 00:19:20.194
<c.magenta>线程2增加其自身的计数器</c>

00:19:20.260 --> 00:19:22.296
<c.magenta>写入到那个内存位置中</c>

00:19:22.629 --> 00:19:25.332
<c.magenta>线程检查工具</c>
<c.magenta>看到它想要更新影子</c>

00:19:26.033 --> 00:19:28.969
<c.magenta>它在这里看到</c>
<c.magenta>之前有东西进入影子里了</c>

00:19:29.036 --> 00:19:31.839
<c.magenta>这意味着那个内存位置</c>
<c.magenta>已经被访问了</c>

00:19:31.905 --> 00:19:33.574
<c.magenta>所以就会检查是否有竞争</c>

00:19:36.009 --> 00:19:38.178
<c.magenta>通过对比时间戳</c>

00:19:38.245 --> 00:19:41.148
<c.magenta>线程检查工具</c>
<c.magenta>看到线程2的同步时间</c>

00:19:41.215 --> 00:19:43.650
<c.magenta>是在线程1访问内存之后</c>

00:19:44.284 --> 00:19:45.786
<c.magenta>所以没有数据竞争</c>

00:19:46.486 --> 00:19:48.255
<c.magenta>我们就可以继续更新</c>

00:19:48.422 --> 00:19:50.457
<c.magenta>在释放锁之前</c>
<c.magenta>线程2会更新</c>

00:19:50.524 --> 00:19:51.892
<c.magenta>其自身的时间戳</c>

00:19:52.426 --> 00:19:53.527
<c.magenta>然后释放锁</c>

00:19:54.561 --> 00:19:56.730
<c.magenta>好了 现在该线程3去写入了</c>

00:19:57.297 --> 00:19:58.932
<c.magenta>线程3已经等了很长时间</c>

00:19:58.999 --> 00:20:01.168
<c.magenta>很激动地要写入</c>
<c.magenta>那个内存位置中</c>

00:19:58.999 --> 00:20:01.168
<c.magenta>很激动地要写入</c>
<c.magenta>那个内存位置中</c>

00:20:01.268 --> 00:20:03.303
<c.magenta>结果呢 它把锁忘了</c>

00:20:03.971 --> 00:20:06.740
<c.magenta>它增加计数器</c>
<c.magenta>写入到内存位置</c>

00:20:07.508 --> 00:20:09.610
<c.magenta>线程检查工具</c>
<c.magenta>在那里监督着</c>

00:20:09.910 --> 00:20:14.047
<c.magenta>它想更新影子</c>
<c.magenta>并检查有没有竞争</c>

00:20:15.015 --> 00:20:18.886
<c.magenta>线程检查工具</c>
<c.magenta>看到线程3的</c>

00:20:18.952 --> 00:20:20.420
<c.magenta>旧视图实在旧了</c>

00:20:21.154 --> 00:20:23.757
<c.magenta>在影子中存储的</c>
<c.magenta>读取和写入是发生在</c>

00:20:23.824 --> 00:20:25.659
<c.magenta>线程3上次同步之后</c>

00:20:27.060 --> 00:20:29.897
<c.magenta>这就允许线程检查工具</c>
<c.magenta>揪出那个错误</c>

00:20:37.104 --> 00:20:39.540
<c.magenta>关于这个算法</c>
<c.magenta>重要是要知道</c>

00:20:39.606 --> 00:20:42.409
<c.magenta>我们将与数据竞争相关联的</c>

00:20:42.476 --> 00:20:44.311
<c.magenta>时间敏感性</c>
<c.magenta>在这里不适用</c>

00:20:45.045 --> 00:20:49.049
<c.magenta>即使竞争在特定运行中没有</c>
<c.magenta>显现出来 TSan还是能检测到</c>

00:20:49.116 --> 00:20:51.285
<c.magenta>但可能再次运行</c>
<c.magenta>应用程序就会出现</c>

00:20:51.351 --> 00:20:53.220
<c.magenta>或者用户运行你的应用程序</c>

00:20:53.754 --> 00:20:56.723
<c.magenta>这让使用线程检查工具</c>
<c.magenta>更加高效</c>

00:20:56.924 --> 00:21:00.294
<c.magenta>相比于调试并</c>
<c.magenta>重现那些数据竞争</c>

00:20:56.924 --> 00:21:00.294
<c.magenta>相比于调试并</c>
<c.magenta>重现那些数据竞争</c>

00:21:00.360 --> 00:21:02.763
<c.magenta>在不使用该工具的</c>
<c.magenta>普通环境下</c>

00:21:03.964 --> 00:21:05.732
<c.magenta>另一个需要记住的是</c>

00:21:05.799 --> 00:21:08.569
<c.magenta>线程检查工具</c>
<c.magenta>是运行时错误查找工具</c>

00:21:08.635 --> 00:21:10.804
<c.magenta>所以它只会找出竞争</c>

00:21:11.071 --> 00:21:13.941
<c.magenta>当你提供了足够的覆盖面</c>

00:21:14.007 --> 00:21:17.144
<c.magenta>所以请在线程检查工具</c>
<c.magenta>启用时运行你的所有测试</c>

00:21:18.245 --> 00:21:21.315
<c.magenta>这就是Xcode 8上新出的</c>
<c.magenta>线程检查工具</c>　<c.magenta>用它</c>

00:21:21.715 --> 00:21:24.484
<c.magenta>它会找出错误</c>
<c.magenta>它会让你的应用程序更好</c>

00:21:32.459 --> 00:21:35.062
<c.magenta>现在交给Devin</c>
<c.magenta>他会讲讲我们在</c>

00:21:35.128 --> 00:21:37.130
<c.magenta>Clang静态分析器</c>
<c.magenta>上添加的检查</c>

00:21:43.470 --> 00:21:44.338
<c.magenta>谢谢 Anna</c>

00:21:46.106 --> 00:21:49.510
<c.magenta>与检查工具不同</c>
<c.magenta>静态分析器可无需</c>

00:21:49.676 --> 00:21:51.645
<c.magenta>运行你的代码</c>
<c.magenta>就能找出错误</c>

00:21:52.479 --> 00:21:56.383
<c.magenta>其做法是系统性地探测</c>
<c.magenta>整个程序的所有路径</c>

00:21:57.084 --> 00:22:00.888
<c.magenta>这让使其十分适合找出</c>
<c.magenta>重现条件很难很极端的错误</c>

00:21:57.084 --> 00:22:00.888
<c.magenta>这让使其十分适合找出</c>
<c.magenta>重现条件很难很极端的错误</c>

00:22:01.989 --> 00:22:04.992
<c.magenta>它支持Clang</c>
<c.magenta>可编译的所有语言</c>

00:22:05.058 --> 00:22:07.761
<c.magenta>所以C</c>
<c.magenta>Objective-C和C++</c>

00:22:09.630 --> 00:22:12.966
<c.magenta>今年静态分析器</c>
<c.magenta>我们添加了三个新检查</c>

00:22:13.500 --> 00:22:15.235
<c.magenta>本地化能力缺失的检查</c>

00:22:16.136 --> 00:22:17.938
<c.magenta>不正当的实例清理检查</c>

00:22:18.138 --> 00:22:19.840
<c.magenta>在手动保持的释放代码中</c>

00:22:20.240 --> 00:22:22.142
<c.magenta>还有为空性违规的检查</c>

00:22:23.010 --> 00:22:24.344
<c.magenta>我来跟大家讲讲</c>

00:22:25.712 --> 00:22:28.248
<c.magenta>在本地化应用中的常见错误</c>

00:22:28.382 --> 00:22:30.651
<c.magenta>就是忘记本地化UI元素</c>

00:22:31.218 --> 00:22:33.654
<c.magenta>这对用户来说</c>
<c.magenta>会是很惊人的事</c>

00:22:34.454 --> 00:22:37.824
<c.magenta>他们会以自己的母语</c>
<c.magenta>使用你的应用</c>

00:22:37.891 --> 00:22:39.626
<c.magenta>不过突然出乎意料地</c>

00:22:39.993 --> 00:22:43.497
<c.magenta>你语言中的字符串</c>
<c.magenta>出现在他们的UI中</c>

00:22:43.830 --> 00:22:45.933
<c.magenta>这不是好的用户体验</c>

00:22:46.767 --> 00:22:47.868
<c.magenta>我来给演示一下</c>

00:22:47.935 --> 00:22:50.737
<c.magenta>静态分析器</c>
<c.magenta>是如何找出这种错误的</c>

00:22:56.143 --> 00:22:59.346
<c.magenta>好了 我将演示</c>
<c.magenta>静态分析器</c>

00:22:59.413 --> 00:23:00.781
<c.magenta>Anna使用的相同应用上</c>

00:22:59.413 --> 00:23:00.781
<c.magenta>Anna使用的相同应用上</c>

00:23:02.549 --> 00:23:05.519
<c.magenta>要运行分析器</c>
<c.magenta>你可以去Xcode的产品菜单</c>

00:23:05.586 --> 00:23:06.753
<c.magenta>选择分析</c>

00:23:07.554 --> 00:23:10.157
<c.magenta>这会探测大量经过你程序的路径</c>

00:23:10.224 --> 00:23:12.359
<c.magenta>并试图在每个路径里发现错误</c>

00:23:13.727 --> 00:23:15.429
<c.magenta>就像线程检查工具</c>

00:23:15.963 --> 00:23:19.166
<c.magenta>如果静态分析器</c>
<c.magenta>发现一个问题</c>

00:23:19.466 --> 00:23:22.202
<c.magenta>它会将这蓝色</c>
<c.magenta>静态分析器图标</c>

00:23:22.269 --> 00:23:24.638
<c.magenta>显示在Xcode的活动条中</c>

00:23:26.406 --> 00:23:28.876
<c.magenta>如果你点击它</c>
<c.magenta>它会给你显示问题导航器</c>

00:23:29.042 --> 00:23:31.445
<c.magenta>看来我们有一个本地化问题</c>

00:23:32.779 --> 00:23:36.183
<c.magenta>一个非本地化字符串</c>
<c.magenta>流向了面向用户属性</c>

00:23:36.617 --> 00:23:38.051
<c.magenta>所以我们应将其本地化</c>

00:23:39.152 --> 00:23:41.188
<c.magenta>不过看看这个方法</c>

00:23:41.722 --> 00:23:43.857
<c.magenta>我没有看出任何很明显的错误</c>

00:23:44.525 --> 00:23:46.293
<c.magenta>我会去点击诊断功能</c>

00:23:47.427 --> 00:23:49.630
<c.magenta>这给我展示了更多的信息</c>

00:23:49.696 --> 00:23:53.066
<c.magenta>关于这个非本地化</c>
<c.magenta>字符串是如何流向</c>

00:23:53.233 --> 00:23:54.668
<c.magenta>面向用户属性的</c>

00:23:56.436 --> 00:23:58.972
<c.magenta>我可以通过路径探测器栏</c>
<c.magenta>探测这个路径</c>

00:23:59.406 --> 00:24:01.441
<c.magenta>在Xcode编辑器顶部</c>

00:23:59.406 --> 00:24:01.441
<c.magenta>在Xcode编辑器顶部</c>

00:24:02.843 --> 00:24:05.379
<c.magenta>通过反向推断</c>
<c.magenta>我能看到这个方法是调用自</c>

00:24:05.445 --> 00:24:07.381
<c.magenta>表视图数据源方法</c>

00:24:07.648 --> 00:24:10.184
<c.magenta>之后反过来它将其传递到</c>

00:24:10.350 --> 00:24:12.252
<c.magenta>这个非本地化的常量字符串</c>

00:24:12.719 --> 00:24:14.121
<c.magenta>所以我们将其本地化</c>

00:24:16.190 --> 00:24:18.825
<c.magenta>为此我将使用</c>
<c.magenta>NS本地化字符串宏</c>

00:24:21.395 --> 00:24:24.798
<c.magenta>这会在运行时</c>
<c.magenta>加载一个翻译版的字符串</c>

00:24:25.866 --> 00:24:28.735
<c.magenta>在使用这个宏时</c>
<c.magenta>非常重要的是</c>

00:24:28.802 --> 00:24:31.672
<c.magenta>同时包括你给译员的注释</c>

00:24:31.738 --> 00:24:33.807
<c.magenta>来帮助他们正确翻译字符串</c>

00:24:34.741 --> 00:24:35.776
<c.magenta>所以我会说：</c>

00:24:36.176 --> 00:24:37.611
<c.magenta>“这是按钮...</c>

00:24:38.278 --> 00:24:40.414
<c.magenta>会重置会话筛选器”</c>

00:24:44.318 --> 00:24:45.152
<c.magenta>好了</c>

00:24:45.752 --> 00:24:48.822
<c.magenta>我们再次运行分析器</c>
<c.magenta>确保我们解决了这个问题</c>

00:24:52.793 --> 00:24:55.329
<c.magenta>看起来很好</c>
<c.magenta>我切换回幻灯片</c>

00:25:03.670 --> 00:25:07.140
<c.magenta>回顾一下 你可以从</c>
<c.magenta>产品菜单中运行分析器</c>

00:25:07.407 --> 00:25:10.711
<c.magenta>它会将其找到的任何问题</c>
<c.magenta>在问题导航器中显示</c>

00:25:11.645 --> 00:25:16.750
<c.magenta>正如我们所见 点击诊断功能</c>
<c.magenta>非常有助于显示路径</c>

00:25:17.184 --> 00:25:21.121
<c.magenta>这会使问题更易于理解</c>
<c.magenta>并且最终修复它</c>

00:25:26.393 --> 00:25:29.863
<c.magenta>我们看到分析器可以</c>
<c.magenta>找到缺失本地化功能的地方</c>

00:25:30.497 --> 00:25:33.233
<c.magenta>但这也警告我们</c>
<c.magenta>当我们忘记给</c>

00:25:33.567 --> 00:25:35.769
<c.magenta>译员提供注释</c>

00:25:36.670 --> 00:25:40.541
<c.magenta>这里我提供了零的注释</c>
<c.magenta>没有一点帮助</c>

00:25:40.874 --> 00:25:42.910
<c.magenta>所以分析器会警告</c>

00:25:44.478 --> 00:25:45.812
<c.magenta>你可以把这些检查打开</c>

00:25:45.879 --> 00:25:49.416
<c.magenta>其他静态分析器</c>
<c.magenta>检查在项目构建设置中</c>

00:25:49.483 --> 00:25:51.318
<c.magenta>静态分析器的部分</c>

00:25:52.052 --> 00:25:55.822
<c.magenta>本地化功能缺失的检查</c>
<c.magenta>会由Xcode自动打开</c>

00:25:56.156 --> 00:25:59.193
<c.magenta>如果你的项目拥有</c>
<c.magenta>不止一种语言的本地化版本</c>

00:26:00.427 --> 00:26:02.829
<c.magenta>注释缺失的检查</c>
<c.magenta>是默认关闭的</c>

00:26:02.930 --> 00:26:05.165
<c.magenta>但你一定要打开它</c>

00:26:05.232 --> 00:26:09.236
<c.magenta>如果你不用其他方式</c>
<c.magenta>将这些注释传达给你的译员</c>

00:26:10.070 --> 00:26:13.740
<c.magenta>例如 你可能已经直接</c>
<c.magenta>在字符串文件中这么做了</c>

00:26:18.478 --> 00:26:21.048
<c.magenta>今年我们还改进了</c>
<c.magenta>dealloc检查</c>

00:26:21.148 --> 00:26:23.183
<c.magenta>在你的手动保留释放代码中</c>

00:26:24.218 --> 00:26:26.854
<c.magenta>在手动保持释放下</c>
<c.magenta>非常重要的是</c>

00:26:27.454 --> 00:26:30.090
<c.magenta>不要释放实例变量</c>
<c.magenta>合成用于</c>

00:26:30.157 --> 00:26:32.426
<c.magenta>dealloc内的分配属性</c>

00:26:32.993 --> 00:26:35.495
<c.magenta>如果你那么做</c>
<c.magenta>这会导致过度释放</c>

00:26:35.562 --> 00:26:39.900
<c.magenta>当那个值的所有者也释放它</c>
<c.magenta>这会使你的程序崩溃</c>

00:26:40.601 --> 00:26:42.669
<c.magenta>所以现在分析器</c>
<c.magenta>放出了警告</c>

00:26:44.505 --> 00:26:47.274
<c.magenta>另一方面</c>
<c.magenta>你必须释放实例变量</c>

00:26:47.341 --> 00:26:49.977
<c.magenta>合成用于保持或复制属性</c>

00:26:50.210 --> 00:26:52.279
<c.magenta>因为如果你不这样做</c>
<c.magenta>它们会泄露</c>

00:26:52.880 --> 00:26:54.715
<c.magenta>分析器同样也会警告</c>

00:26:56.383 --> 00:26:57.217
<c.magenta>耶！</c>

00:26:59.520 --> 00:27:02.322
<c.magenta>这真是非常棒的检查</c>

00:26:59.520 --> 00:27:02.322
<c.magenta>这真是非常棒的检查</c>

00:27:02.789 --> 00:27:06.793
<c.magenta>我们运行的每个手动</c>
<c.magenta>保持释放项目中 它都会</c>

00:27:07.027 --> 00:27:07.961
<c.magenta>找出一个错误</c>

00:27:08.262 --> 00:27:09.263
<c.magenta>所以试一下</c>

00:27:11.565 --> 00:27:14.935
<c.magenta>当然去除保持释放问题</c>
<c.magenta>最好的方法</c>

00:27:15.035 --> 00:27:17.971
<c.magenta>是将你的项目</c>
<c.magenta>升级到自动引用计数</c>

00:27:22.176 --> 00:27:24.711
<c.magenta>幸运的是 Xcode可以</c>
<c.magenta>帮你自动完成这些</c>

00:27:24.778 --> 00:27:26.213
<c.magenta>如果你去编辑菜单</c>

00:27:26.480 --> 00:27:29.183
<c.magenta>选择转换到</c>
<c.magenta>Objective-C ARC</c>

00:27:29.950 --> 00:27:32.386
<c.magenta>这会让编译器</c>
<c.magenta>为你处理所有的麻烦</c>

00:27:32.452 --> 00:27:34.087
<c.magenta>关于保持释放</c>

00:27:36.990 --> 00:27:38.258
<c.magenta>终于在今年</c>

00:27:38.592 --> 00:27:40.894
<c.magenta>我们给为空性违规</c>
<c.magenta>添加了一个检查</c>

00:27:41.962 --> 00:27:45.365
<c.magenta>这是基于去年的成果</c>
<c.magenta>我们给SDK加注释</c>

00:27:45.432 --> 00:27:49.570
<c.magenta>来表示方法或属性</c>
<c.magenta>是接收还是返回零</c>

00:27:50.637 --> 00:27:54.608
<c.magenta>例如 Core Location的</c>
<c.magenta>时间戳属性是非空的</c>

00:27:55.075 --> 00:27:57.244
<c.magenta>这是因为每次的位置测量</c>

00:27:57.678 --> 00:27:59.980
<c.magenta>也有对应的日期和时间</c>

00:28:00.914 --> 00:28:03.016
<c.magenta>相比之下</c>
<c.magenta>其底层属性可为空</c>

00:28:03.650 --> 00:28:06.653
<c.magenta>这是因为这个属性会返回零</c>

00:28:07.087 --> 00:28:10.557
<c.magenta>当这个位置不是</c>
<c.magenta>室内定位激活的场地</c>

00:28:12.492 --> 00:28:14.962
<c.magenta>你应该给自己标头注释为空性</c>

00:28:15.062 --> 00:28:17.164
<c.magenta>因为它会启用</c>
<c.magenta>新的程序和模型</c>

00:28:17.631 --> 00:28:20.501
<c.magenta>可以将你的为空性预期直接</c>

00:28:20.567 --> 00:28:22.236
<c.magenta>传达到客户那里</c>

00:28:22.903 --> 00:28:25.205
<c.magenta>这很重要 因为违反</c>

00:28:25.272 --> 00:28:28.842
<c.magenta>这些预期 可能会引起</c>
<c.magenta>崩溃或意想不到的行为</c>

00:28:29.710 --> 00:28:31.445
<c.magenta>事实上 我们认为它如此重要</c>

00:28:31.578 --> 00:28:35.215
<c.magenta>以至于将它内置到Swift中</c>
<c.magenta>那里的可选类型要求你</c>

00:28:35.282 --> 00:28:37.518
<c.magenta>先检查零 之后再使用值</c>

00:28:38.619 --> 00:28:40.888
<c.magenta>这在Objective-C</c>
<c.magenta>中也很重要</c>

00:28:41.288 --> 00:28:45.325
<c.magenta>所以我们将为空性违规的检查</c>
<c.magenta>添加到静态分析器</c>

00:28:46.360 --> 00:28:48.729
<c.magenta>而且这个检查特别适用于</c>

00:28:48.795 --> 00:28:51.431
<c.magenta>混合Swift和</c>
<c.magenta>Objective-C代码项目</c>

00:28:52.199 --> 00:28:53.867
<c.magenta>它会发现两种问题</c>

00:28:54.668 --> 00:28:56.670
<c.magenta>在代码中可能有逻辑问题</c>

00:28:56.737 --> 00:28:58.872
<c.magenta>可能你在错误时间返回零</c>

00:28:59.173 --> 00:29:01.441
<c.magenta>或者你可能会有错误的注释</c>

00:28:59.173 --> 00:29:01.441
<c.magenta>或者你可能会有错误的注释</c>

00:29:02.276 --> 00:29:03.710
<c.magenta>所以我们看看如何修复</c>

00:29:03.777 --> 00:29:06.280
<c.magenta>这两种问题</c>

00:29:08.482 --> 00:29:12.986
<c.magenta>一个常见错误是</c>
<c.magenta>从零初始化局部变量</c>

00:29:13.220 --> 00:29:15.522
<c.magenta>之后填充进一连串</c>

00:29:15.589 --> 00:29:17.324
<c.magenta>非穷举的分支</c>

00:29:18.425 --> 00:29:19.693
<c.magenta>例如 这个方法</c>

00:29:19.927 --> 00:29:22.629
<c.magenta>返回一个位置的简短说明</c>

00:29:23.163 --> 00:29:24.364
<c.magenta>要么是城市的名字</c>

00:29:24.731 --> 00:29:27.100
<c.magenta>或国家</c>
<c.magenta>含有着这个位置</c>

00:29:28.035 --> 00:29:30.671
<c.magenta>但我们没能考虑到</c>
<c.magenta>一个很重要的情况</c>

00:29:31.605 --> 00:29:33.841
<c.magenta>如果这个位置是</c>
<c.magenta>位于国际海域呢？</c>

00:29:34.441 --> 00:29:36.510
<c.magenta>那这既不是城市</c>
<c.magenta>也不是国家</c>

00:29:36.577 --> 00:29:39.713
<c.magenta>所以这个方法会</c>
<c.magenta>不出意外地返回零</c>

00:29:40.614 --> 00:29:42.482
<c.magenta>然后分析器会告诉我们</c>

00:29:43.550 --> 00:29:44.418
<c.magenta>幸运的是</c>

00:29:45.185 --> 00:29:46.320
<c.magenta>这也很棒</c>

00:29:50.757 --> 00:29:52.793
<c.magenta>幸运的是</c>
<c.magenta>这很容易修复的</c>

00:29:53.026 --> 00:29:55.729
<c.magenta>你要做的是</c>
<c.magenta>初始化你的局部变量</c>

00:29:57.664 --> 00:30:00.000
<c.magenta>通过非零默认值</c>

00:30:00.667 --> 00:30:02.870
<c.magenta>在此例中</c>
<c.magenta>我们使用常量字符串Earth</c>

00:30:03.070 --> 00:30:05.772
<c.magenta>当然 要确保将其本地化</c>

00:30:08.609 --> 00:30:11.144
<c.magenta>另一方面</c>
<c.magenta>可能是你的代码</c>

00:30:11.445 --> 00:30:13.780
<c.magenta>在实施方面完全没问题</c>

00:30:14.081 --> 00:30:15.983
<c.magenta>而是注释出现错误</c>

00:30:16.950 --> 00:30:19.453
<c.magenta>我们发现其经常</c>
<c.magenta>发生的一个原因</c>

00:30:19.686 --> 00:30:23.957
<c.magenta>是当你使用方便的</c>
<c.magenta>NS_ASSUME_NONNULL_BEGIN和END的宏</c>

00:30:25.092 --> 00:30:27.160
<c.magenta>这些宏会将</c>
<c.magenta>标头的一部分包起来</c>

00:30:27.961 --> 00:30:30.264
<c.magenta>而且它们包起来的内部范围</c>

00:30:30.397 --> 00:30:32.833
<c.magenta>那些类型会隐含地成为非空</c>

00:30:33.567 --> 00:30:35.736
<c.magenta>这可以节省你很多的键入</c>

00:30:36.236 --> 00:30:38.405
<c.magenta>但这也让你很容易忘记</c>

00:30:38.705 --> 00:30:40.474
<c.magenta>将属性标记为可空</c>

00:30:41.341 --> 00:30:44.411
<c.magenta>在这个例子中</c>
<c.magenta>压力特性会返回零</c>

00:30:44.478 --> 00:30:46.547
<c.magenta>如果设备没有气压计</c>

00:30:47.414 --> 00:30:50.617
<c.magenta>但是属性是隐含成为非空的</c>

00:30:52.352 --> 00:30:54.821
<c.magenta>幸运的是</c>
<c.magenta>这里也很容易修复</c>

00:30:55.322 --> 00:30:57.591
<c.magenta>我们可以明确地</c>
<c.magenta>将属性标记为</c>

00:30:57.658 --> 00:30:59.760
<c.magenta>可空</c>
<c.magenta>在那个区域内部</c>

00:30:59.993 --> 00:31:02.996
<c.magenta>这会告诉客户</c>
<c.magenta>不要期待压力数据</c>

00:30:59.993 --> 00:31:02.996
<c.magenta>这会告诉客户</c>
<c.magenta>不要期待压力数据</c>

00:31:03.063 --> 00:31:04.565
<c.magenta>是一直可用的</c>

00:31:07.334 --> 00:31:09.970
<c.magenta>你的确需要注意这个</c>

00:31:10.404 --> 00:31:13.240
<c.magenta>这是因为你API的</c>
<c.magenta>为空性是一种契约</c>

00:31:13.540 --> 00:31:16.343
<c.magenta>所以你不应该为满足</c>
<c.magenta>分析器而更改它</c>

00:31:17.277 --> 00:31:19.713
<c.magenta>相反 你应该仔细考虑你想</c>

00:31:19.780 --> 00:31:22.282
<c.magenta>公开的API并使用它</c>

00:31:23.884 --> 00:31:25.986
<c.magenta>如果你决定改变你的API</c>

00:31:26.253 --> 00:31:29.256
<c.magenta>那你还要仔细考虑向后兼容</c>

00:31:30.057 --> 00:31:32.392
<c.magenta>这在Swift尤为重要</c>

00:31:32.960 --> 00:31:35.596
<c.magenta>因为 为空性会改变</c>
<c.magenta>类型的导入方式</c>

00:31:38.632 --> 00:31:40.767
<c.magenta>你也可能处在这样的情况下</c>

00:31:41.168 --> 00:31:43.804
<c.magenta>你无法改变方法的实现</c>

00:31:43.871 --> 00:31:45.072
<c.magenta>及其注释</c>

00:31:45.706 --> 00:31:49.209
<c.magenta>在这些情况下 你可以通过</c>
<c.magenta>转换来压制分析器诊断功能</c>

00:31:50.277 --> 00:31:53.080
<c.magenta>它经常出现的一个原因要归咎于</c>

00:31:53.347 --> 00:31:56.583
<c.magenta>当违反前提条件时</c>
<c.magenta>会防守性返回零的方法</c>

00:31:57.284 --> 00:31:59.152
<c.magenta>在这个例子中</c>
<c.magenta>该方法返回零</c>

00:31:59.219 --> 00:32:01.221
<c.magenta>当索引越界的时候</c>

00:31:59.219 --> 00:32:01.221
<c.magenta>当索引越界的时候</c>

00:32:02.155 --> 00:32:05.092
<c.magenta>如果有依靠这种行为</c>
<c.magenta>的现有代码</c>

00:32:05.792 --> 00:32:07.261
<c.magenta>那你不能移除那个检查</c>

00:32:07.628 --> 00:32:09.363
<c.magenta>而且你不能</c>
<c.magenta>用一个证书替代它</c>

00:32:10.030 --> 00:32:13.800
<c.magenta>相反 正确做法是告诉分析器</c>
<c.magenta>这是你特意做的</c>

00:32:14.134 --> 00:32:16.670
<c.magenta>通过将返回值转化为非空</c>

00:32:22.075 --> 00:32:25.279
<c.magenta>所以这是静态分析器</c>
<c.magenta>和Xcode 8的新功能</c>

00:32:32.586 --> 00:32:33.520
<c.magenta>我们做个总结</c>

00:32:34.621 --> 00:32:37.024
<c.magenta>今天我们讲了</c>
<c.magenta>三个很棒的工具</c>

00:32:37.824 --> 00:32:39.793
<c.magenta>这些工具找到真正的错误</c>

00:32:40.561 --> 00:32:43.497
<c.magenta>地址检查工具和</c>
<c.magenta>线程检查工具在运行时</c>

00:32:43.564 --> 00:32:45.232
<c.magenta>查找内存崩溃和线程问题</c>

00:32:45.599 --> 00:32:49.469
<c.magenta>静态分析器甚至不用运行</c>
<c.magenta>你的代码就能发现错误</c>

00:32:49.837 --> 00:32:53.040
<c.magenta>所以请在自己的项目中</c>
<c.magenta>使用这些工具</c>

00:32:53.307 --> 00:32:57.010
<c.magenta>它们会在用户发现错误</c>
<c.magenta>之前帮你找到错误</c>

00:32:58.312 --> 00:33:01.281
<c.magenta>如果你有兴趣了解更多信息</c>
<c.magenta>你可以去演讲网站</c>

00:32:58.312 --> 00:33:01.281
<c.magenta>如果你有兴趣了解更多信息</c>
<c.magenta>你可以去演讲网站</c>

00:33:02.349 --> 00:33:04.284
<c.magenta>这里还有几个相关演讲</c>

00:33:04.351 --> 00:33:06.086
<c.magenta>我们认为可能会帮助到你</c>

00:33:07.521 --> 00:33:08.355
<c.magenta>谢谢大家</c>
