WEBVTT

00:00:19.353 --> 00:00:21.421
<c.magenta>iOS 10中UICollection</c>
<c.magenta>的新特性</c>

00:00:21.488 --> 00:00:22.322
<c.magenta>早上好</c>

00:00:25.692 --> 00:00:27.561
<c.magenta>我叫Steve Breen</c>

00:00:27.928 --> 00:00:29.730
<c.magenta>我叫Peter Hajas</c>

00:00:29.796 --> 00:00:32.833
<c.magenta>我们都是</c>
<c.magenta>UIKit框架团队的工程师</c>

00:00:34.234 --> 00:00:37.304
<c.magenta>我们很高兴跟大家分享</c>
<c.magenta>CollectionView上的新特性</c>

00:00:38.438 --> 00:00:39.840
<c.magenta>让我们开始吧</c>

00:00:41.108 --> 00:00:43.510
<c.magenta>我们今天早晨要讲三个话题</c>

00:00:44.077 --> 00:00:47.347
<c.magenta>第一个话题是平滑滚动</c>

00:00:48.315 --> 00:00:52.553
<c.magenta>每个iOS应用都希望</c>
<c.magenta>有一个不错的滚动体验</c>

00:00:53.053 --> 00:00:54.922
<c.magenta>在CollectionView上</c>
<c.magenta>我们添加了一些了不起的新功能</c>

00:00:54.988 --> 00:00:57.157
<c.magenta>帮助你的应用比以前任何</c>
<c.magenta>时候都能更好地滚动</c>

00:00:57.591 --> 00:01:00.260
<c.magenta>其中最精华的部分是</c>
<c.magenta>很多改进</c>

00:00:57.591 --> 00:01:00.260
<c.magenta>其中最精华的部分是</c>
<c.magenta>很多改进</c>

00:01:00.327 --> 00:01:03.197
<c.magenta>在你的应用中</c>
<c.magenta>不需要或只需要少量工作</c>

00:01:05.299 --> 00:01:09.069
<c.magenta>接下来 我们会讲</c>
<c.magenta>自动调整单元格中的改进</c>

00:01:09.570 --> 00:01:12.506
<c.magenta>我们在iOS 8中</c>
<c.magenta>引入了这个API</c>

00:01:12.940 --> 00:01:15.442
<c.magenta>我们在iOS 10中</c>
<c.magenta>做了很多不错的改进</c>

00:01:15.509 --> 00:01:17.244
<c.magenta>使它更易用</c>

00:01:18.645 --> 00:01:22.583
<c.magenta>最后 我们会回顾一下</c>
<c.magenta>交互式重排序</c>

00:01:23.083 --> 00:01:26.119
<c.magenta>去年在iOS 9中</c>
<c.magenta>我们引入了这个API</c>

00:01:26.520 --> 00:01:29.857
<c.magenta>在iOS 10中</c>
<c.magenta>我们又改善了很多功能</c>

00:01:30.824 --> 00:01:33.160
<c.magenta>让我们从平滑滚动开始讲吧</c>

00:01:34.628 --> 00:01:38.065
<c.magenta>iOS设备体验的一个标志是</c>

00:01:38.398 --> 00:01:41.668
<c.magenta>对用户的触摸</c>
<c.magenta>立即响应</c>

00:01:43.136 --> 00:01:46.507
<c.magenta>响应式用户体验的</c>
<c.magenta>一个重要部分</c>

00:01:46.974 --> 00:01:51.378
<c.magenta>是确保我的手指</c>
<c.magenta>在屏幕上滚动</c>

00:01:51.678 --> 00:01:55.682
<c.magenta>这种对象在屏幕上的移动</c>
<c.magenta>就像在真实的世界中移动一样</c>

00:01:56.416 --> 00:02:00.921
<c.magenta>这对于使用户全神贯注于应用</c>
<c.magenta>非常重要</c>

00:01:56.416 --> 00:02:00.921
<c.magenta>这对于使用户全神贯注于应用</c>
<c.magenta>非常重要</c>

00:02:01.855 --> 00:02:03.957
<c.magenta>我们要讨论一下</c>
<c.magenta>平滑滚动</c>

00:02:04.124 --> 00:02:07.060
<c.magenta>及我们在UI CollectionView上</c>
<c.magenta>所做的改进</c>

00:02:07.761 --> 00:02:10.163
<c.magenta>通过讨论一个演示应用</c>

00:02:10.764 --> 00:02:14.902
<c.magenta>正如你即将看到</c>
<c.magenta>这个应用滚动效果并不是那么好</c>

00:02:14.968 --> 00:02:17.404
<c.magenta>我们想像黄油一样滚动</c>
<c.magenta>但目前</c>

00:02:17.471 --> 00:02:20.007
<c.magenta>需要太多滚动</c>
<c.magenta>就像一块花生酱</c>

00:02:20.374 --> 00:02:21.475
<c.magenta>让我们看看iPad</c>

00:02:25.779 --> 00:02:27.114
<c.magenta>我要切换到iPad上</c>

00:02:29.449 --> 00:02:32.753
<c.magenta>澄清一点</c>
<c.magenta>蓝色方块通常消耗较少</c>

00:02:32.953 --> 00:02:34.855
<c.magenta>但是我们故意把这些变慢了</c>

00:02:35.455 --> 00:02:36.957
<c.magenta>想象一下若更复杂会怎么样</c>

00:02:37.024 --> 00:02:39.193
<c.magenta>比如</c>
<c.magenta>也许它们有两种颜色</c>

00:02:40.260 --> 00:02:41.128
<c.magenta>无论如何...</c>

00:02:42.362 --> 00:02:44.264
<c.magenta>有了CollectionView</c>
<c.magenta>我们可以看到</c>

00:02:44.331 --> 00:02:47.901
<c.magenta>滚动已经加载了内容</c>
<c.magenta>很好 很快</c>

00:02:48.602 --> 00:02:49.970
<c.magenta>但是 让我们仔细查看一下</c>

00:02:50.037 --> 00:02:51.338
<c.magenta>Steve 请注意看</c>

00:02:51.872 --> 00:02:53.407
<c.magenta>当我再往下滚动时</c>

00:02:54.508 --> 00:02:55.576
<c.magenta>哦 哎呦</c>

00:02:55.943 --> 00:02:57.444
<c.magenta>一颗星 不能买</c>

00:02:59.346 --> 00:03:00.914
<c.magenta>我也不会买</c>

00:02:59.346 --> 00:03:00.914
<c.magenta>我也不会买</c>

00:03:01.014 --> 00:03:04.718
<c.magenta>这种用户体验</c>
<c.magenta>是我们要极力避免的体验</c>

00:03:05.185 --> 00:03:06.386
<c.magenta>这是怎么回事？</c>

00:03:06.920 --> 00:03:10.824
<c.magenta>嗯 我们之前说过 这些是</c>
<c.magenta>非常简陋的蓝色方块</c>

00:03:11.024 --> 00:03:14.795
<c.magenta>在你的应用中</c>
<c.magenta>模拟高消耗的复杂单元格</c>

00:03:15.429 --> 00:03:17.564
<c.magenta>遇到CollectionView时</c>

00:03:18.265 --> 00:03:21.235
<c.magenta>加载单元格</c>
<c.magenta>的时间恰好是它们请求被加载的时候</c>

00:03:21.668 --> 00:03:22.836
<c.magenta>让我演示一下</c>

00:03:23.971 --> 00:03:25.405
<c.magenta>我们要在这儿重新加载数据</c>

00:03:25.606 --> 00:03:26.673
<c.magenta>我会打开一个视图</c>

00:03:26.740 --> 00:03:29.977
<c.magenta>这个视图将显示在</c>
<c.magenta>CollectionView中加载的所有单元格</c>

00:03:30.844 --> 00:03:33.647
<c.magenta>这样你可以看到那些底部的单元格</c>
<c.magenta>超出了</c>

00:03:33.947 --> 00:03:35.182
<c.magenta>可见的边界</c>

00:03:35.816 --> 00:03:37.718
<c.magenta>现在看看当我滚动时会发生什么</c>

00:03:39.853 --> 00:03:42.923
<c.magenta>我们一下带入了</c>
<c.magenta>一整行单元格</c>

00:03:43.290 --> 00:03:46.326
<c.magenta>这就是导致</c>
<c.magenta>滚动体验磕磕绊绊的原因</c>

00:03:47.561 --> 00:03:49.429
<c.magenta>在性能术语中</c>

00:03:49.496 --> 00:03:52.799
<c.magenta>我们可以称之为</c>
<c.magenta>应用掉帧</c>

00:03:53.367 --> 00:03:55.702
<c.magenta>让我们再切回幻灯片</c>
<c.magenta>了解更多的信息</c>

00:03:56.403 --> 00:03:59.840
<c.magenta>我们究竟要表达什么意思呢</c>
<c.magenta>当提到掉帧时</c>

00:04:00.307 --> 00:04:02.209
<c.magenta>在你的应用中</c>

00:04:02.476 --> 00:04:04.711
<c.magenta>用户期待</c>
<c.magenta>平滑的滚动体验</c>

00:04:04.778 --> 00:04:07.614
<c.magenta>意思是你的应用要达到</c>
<c.magenta>那个神奇的数字</c>

00:04:07.814 --> 00:04:09.383
<c.magenta>每秒60帧</c>

00:04:10.484 --> 00:04:11.585
<c.magenta>让我们算一下</c>

00:04:11.652 --> 00:04:14.121
<c.magenta>这意味着每次</c>
<c.magenta>刷新时</c>

00:04:14.688 --> 00:04:17.457
<c.magenta>我们需要在16毫秒内显现那个窗口</c>

00:04:18.425 --> 00:04:20.293
<c.magenta>好了 让我们看几帧</c>

00:04:20.360 --> 00:04:23.764
<c.magenta>我们这儿有一个图表</c>
<c.magenta>显示了三个不同的帧</c>

00:04:25.232 --> 00:04:26.300
<c.magenta>在第一帧中...</c>

00:04:28.068 --> 00:04:29.503
<c.magenta>我们几乎不需要做什么</c>

00:04:29.770 --> 00:04:31.405
<c.magenta>正如Peter刚提到的那样</c>

00:04:31.605 --> 00:04:34.541
<c.magenta>我们在显示屏中上下移动当前内容</c>

00:04:34.875 --> 00:04:37.044
<c.magenta>这是iOS上的一个高度优化的情形</c>

00:04:37.110 --> 00:04:38.378
<c.magenta>所以速度超快</c>

00:04:38.445 --> 00:04:39.713
<c.magenta>不需做很多工作就能达到</c>

00:04:39.780 --> 00:04:42.649
<c.magenta>我们获得了这个很棒的五星级</c>
<c.magenta>滚动体验</c>

00:04:43.016 --> 00:04:43.917
<c.magenta>这帧不错</c>

00:04:44.618 --> 00:04:45.786
<c.magenta>掉帧剖析</c>

00:04:46.086 --> 00:04:48.989
<c.magenta>但是在演示中</c>
<c.magenta>并不总那么好</c>

00:04:50.357 --> 00:04:54.127
<c.magenta>偶尔 会有这样的情况</c>
<c.magenta>我们需要做大量的工作</c>

00:04:54.361 --> 00:04:58.899
<c.magenta>不仅装载当前帧</c>
<c.magenta>还会掺杂下一帧</c>

00:05:00.701 --> 00:05:02.269
<c.magenta>这是我们的广告帧</c>

00:05:02.336 --> 00:05:04.104
<c.magenta>我们掉了一帧 一颗星</c>

00:05:06.206 --> 00:05:08.442
<c.magenta>让我们以一种不同的视角来看它</c>

00:05:08.775 --> 00:05:12.613
<c.magenta>在这个图中</c>
<c.magenta>我们可以看到有两个不同的区</c>

00:05:13.113 --> 00:05:16.316
<c.magenta>顶部有一个区</c>
<c.magenta>我们把它叫做红区</c>

00:05:16.884 --> 00:05:18.819
<c.magenta>这是我们失了一帧的地方</c>

00:05:18.886 --> 00:05:21.955
<c.magenta>我们比那个神奇的16毫秒线高了</c>

00:05:23.156 --> 00:05:25.392
<c.magenta>让我们查看一下</c>
<c.magenta>坐标轴上的标签</c>

00:05:25.692 --> 00:05:27.294
<c.magenta>那么 在我们的y轴上</c>

00:05:27.361 --> 00:05:30.197
<c.magenta>我们要用图表示出</c>
<c.magenta>主线程上的CPU时间</c>

00:05:30.964 --> 00:05:31.798
<c.magenta>x轴</c>

00:05:32.065 --> 00:05:36.170
<c.magenta>显示滚动发生时的最新事件</c>

00:05:36.870 --> 00:05:38.138
<c.magenta>好的 让我们看一个图表</c>

00:05:39.339 --> 00:05:40.741
<c.magenta>好吧 那么在这个图表中</c>

00:05:40.908 --> 00:05:42.976
<c.magenta>显示了Peter</c>
<c.magenta>刚刚阐述过的内容</c>

00:05:43.043 --> 00:05:45.445
<c.magenta>这些访问进入</c>
<c.magenta>到红区了</c>

00:05:45.512 --> 00:05:46.613
<c.magenta>丢帧的地方</c>

00:05:46.680 --> 00:05:49.716
<c.magenta>但最重要的是</c>
<c.magenta>看看这些平静时期</c>

00:05:49.917 --> 00:05:52.252
<c.magenta>CollectionView</c>
<c.magenta>几乎什么都没做</c>

00:05:52.986 --> 00:05:55.055
<c.magenta>然后 我们在最后</c>
<c.magenta>又一次进入到红区</c>

00:05:55.122 --> 00:05:58.692
<c.magenta>如果我们稍微改变一下</c>
<c.magenta>这种现象会怎么样呢</c>

00:05:58.759 --> 00:06:01.094
<c.magenta>并且降低我们的工作量</c>

00:05:58.759 --> 00:06:01.094
<c.magenta>并且降低我们的工作量</c>

00:06:01.328 --> 00:06:02.563
<c.magenta>当用户滚动时</c>

00:06:04.031 --> 00:06:04.965
<c.magenta>好的 酷 请看</c>

00:06:05.032 --> 00:06:08.769
<c.magenta>现在 这些不再进入到红区了</c>

00:06:09.570 --> 00:06:11.138
<c.magenta>并且形成了平静周期</c>

00:06:11.205 --> 00:06:13.040
<c.magenta>我们让工作量均匀分布</c>

00:06:13.106 --> 00:06:14.975
<c.magenta>我们平摊了时间</c>

00:06:16.610 --> 00:06:17.611
<c.magenta>为了帮助讨论</c>

00:06:17.678 --> 00:06:20.881
<c.magenta>如何把这些峰值变平</c>
<c.magenta>以及如何拉起这个谷值</c>

00:06:21.114 --> 00:06:23.650
<c.magenta>来打造一个美好的、</c>
<c.magenta>始终如一的体验</c>

00:06:24.184 --> 00:06:26.920
<c.magenta>我想谈一下</c>
<c.magenta>单元格生命周期</c>

00:06:27.187 --> 00:06:29.122
<c.magenta>在iOS 9上的</c>

00:06:29.690 --> 00:06:32.526
<c.magenta>我们要讨论的是</c>
<c.magenta>单元格的整个生命周期</c>

00:06:32.893 --> 00:06:33.760
<c.magenta>很漂亮</c>

00:06:34.394 --> 00:06:36.296
<c.magenta>让我们加入</c>
<c.magenta>CollectionView单元格</c>

00:06:37.130 --> 00:06:40.367
<c.magenta>我们滚动时 可以说是</c>
<c.magenta>我们需要加入一个新的单元格</c>

00:06:41.702 --> 00:06:45.239
<c.magenta>我们把它从重用队列中拿出来</c>
<c.magenta>叫做prepareForReuse</c>

00:06:46.240 --> 00:06:50.577
<c.magenta>这就给了单元格一个</c>
<c.magenta>把自己重设为预设状态的机会</c>

00:06:50.911 --> 00:06:53.313
<c.magenta>准备接收来自应用的新数据</c>

00:06:54.214 --> 00:06:58.485
<c.magenta>接下来 我们继续调用</c>
<c.magenta>其余的cellForItemAtIndexPath</c>

00:06:59.319 --> 00:07:02.890
<c.magenta>这是你要做大量工作的地方</c>
<c.magenta>填充单元格</c>

00:06:59.319 --> 00:07:02.890
<c.magenta>这是你要做大量工作的地方</c>
<c.magenta>填充单元格</c>

00:07:03.357 --> 00:07:05.993
<c.magenta>你要建立数据模型</c>
<c.magenta>在单元格上设置数据模型</c>

00:07:06.226 --> 00:07:07.928
<c.magenta>然后再把数据模型带回系统</c>

00:07:08.929 --> 00:07:11.965
<c.magenta>在那个单元格即将在屏幕上显示之前</c>

00:07:12.165 --> 00:07:14.268
<c.magenta>我们会调用</c>
<c.magenta>willDisplayCell</c>

00:07:15.402 --> 00:07:20.140
<c.magenta>这可以给应用一个机会</c>
<c.magenta>完成最后一刻要做的工作</c>

00:07:20.407 --> 00:07:22.209
<c.magenta>当单元格在屏幕上显示之前</c>

00:07:23.010 --> 00:07:26.713
<c.magenta>对于即将要显示的单元格</c>
<c.magenta>我们会调用didEndDisplayingCell</c>

00:07:28.015 --> 00:07:29.950
<c.magenta>好的 这就是单元格生命周期</c>

00:07:30.250 --> 00:07:31.652
<c.magenta>iOS 10之前的版本</c>

00:07:32.619 --> 00:07:35.255
<c.magenta>现在 让我们查看一下</c>
<c.magenta>在iOS 10上是怎么样的</c>

00:07:35.889 --> 00:07:38.692
<c.magenta>我们有跟 Peter刚提过的</c>
<c.magenta>布局相同类型的布局</c>

00:07:38.759 --> 00:07:41.595
<c.magenta>单栏</c>
<c.magenta>很适合演示用</c>

00:07:42.362 --> 00:07:44.531
<c.magenta>那么现在 当用户向上滚动时</c>

00:07:44.731 --> 00:07:45.632
<c.magenta>请注意这里</c>

00:07:45.832 --> 00:07:48.836
<c.magenta>就在这个单元格</c>
<c.magenta>要显示在屏幕上之前</c>

00:07:48.902 --> 00:07:50.971
<c.magenta>我们要把它从重用队列中拿进去</c>

00:07:51.605 --> 00:07:54.341
<c.magenta>然后按照Peter刚讲的</c>
<c.magenta>那个熟悉的模式</c>

00:07:54.408 --> 00:07:56.543
<c.magenta>我们会给它发送一个</c>
<c.magenta>prepareForReuse</c>

00:07:56.910 --> 00:07:59.513
<c.magenta>然后 构造单元格中余下的内容</c>

00:07:59.580 --> 00:08:01.415
<c.magenta>用cellForItemAtIndexPath</c>

00:07:59.580 --> 00:08:01.415
<c.magenta>用cellForItemAtIndexPath</c>

00:08:01.481 --> 00:08:05.252
<c.magenta>当用户继续滚动时</c>
<c.magenta>这里有点不一样了</c>

00:08:05.986 --> 00:08:09.189
<c.magenta>我们不调用willDisplayCell</c>
<c.magenta>当我们创建这个单元格时</c>

00:08:09.256 --> 00:08:12.492
<c.magenta>我们有个迟疑 延迟</c>
<c.magenta>然后就在它要显示时</c>

00:08:12.559 --> 00:08:14.628
<c.magenta>我们会调用</c>
<c.magenta>willDisplayCell</c>

00:08:15.462 --> 00:08:17.698
<c.magenta>好的 现在用户继续滚动</c>

00:08:18.899 --> 00:08:22.402
<c.magenta>我们会让其他单元格淡出</c>
<c.magenta>聚焦在这个单元格的生命周期上</c>

00:08:22.803 --> 00:08:24.471
<c.magenta>现在这个单元格要退出</c>

00:08:24.538 --> 00:08:26.540
<c.magenta>可见的边框</c>
<c.magenta>从CollectionView中</c>

00:08:26.607 --> 00:08:29.610
<c.magenta>那么我们会给它发送</c>
<c.magenta>didEndDisplayingCell</c>

00:08:30.110 --> 00:08:33.280
<c.magenta>Peter谈的是iOS 9</c>
<c.magenta>此时</c>

00:08:33.480 --> 00:08:36.082
<c.magenta>单元格进入重用队列</c>
<c.magenta>然后就结束了</c>

00:08:36.582 --> 00:08:39.119
<c.magenta>要使这个单元格再次显示数据</c>

00:08:39.385 --> 00:08:41.855
<c.magenta>我们得重新开始</c>
<c.magenta>一个单元格的生命周期</c>

00:08:41.922 --> 00:08:44.191
<c.magenta>并且调用cellForItemAtIndexPath</c>

00:08:45.158 --> 00:08:48.328
<c.magenta>但在iOS 10中 我们会让那个单元格</c>
<c.magenta>保留较长的时间</c>

00:08:49.029 --> 00:08:51.732
<c.magenta>因此 若用户稍微向上滚动</c>
<c.magenta>然后说 “哦 等一会儿</c>

00:08:51.798 --> 00:08:54.468
<c.magenta>那是我妹妹刚生的小孩的照片</c>
<c.magenta>我要滚动回来”</c>

00:08:55.102 --> 00:08:58.839
<c.magenta>我们将继续保留那个单元格并再次发送</c>
<c.magenta>willDisplayCell</c>

00:08:59.406 --> 00:09:01.842
<c.magenta>然后 内容将继续在单元格中显示出来</c>

00:08:59.406 --> 00:09:01.842
<c.magenta>然后 内容将继续在单元格中显示出来</c>

00:09:21.361 --> 00:09:25.966
<c.magenta>请注意 Steve在这里展示的东西</c>
<c.magenta>同样适用于多栏布局</c>

00:09:26.700 --> 00:09:29.536
<c.magenta>我们要一次一个地引入单元格</c>

00:09:29.603 --> 00:09:32.206
<c.magenta>而不是一次全部引入</c>
<c.magenta>以便获得更好的滚动体验</c>

00:09:32.272 --> 00:09:33.941
<c.magenta>你说的对 Peter 请注意</c>

00:09:34.007 --> 00:09:36.643
<c.magenta>这些单元格实际上还</c>
<c.magenta>不能在屏幕上显示出来</c>

00:09:36.710 --> 00:09:38.078
<c.magenta>它们仍然在屏幕外</c>

00:09:38.378 --> 00:09:40.848
<c.magenta>现在 我们发送</c>
<c.magenta>我们DQ的第二个单元格</c>

00:09:41.014 --> 00:09:44.651
<c.magenta>cellForItemIndexPath</c>
<c.magenta>并向上滚动两个单元格</c>

00:09:44.718 --> 00:09:47.521
<c.magenta>现在我们要发送</c>
<c.magenta>willDisplayCellMessage</c>

00:09:47.588 --> 00:09:50.224
<c.magenta>给那两个单元格</c>
<c.magenta>就在它们在屏幕上显示之前</c>

00:09:51.358 --> 00:09:53.493
<c.magenta>这听起来像是一个很微妙的变化</c>

00:09:53.694 --> 00:09:55.596
<c.magenta>实际效果要明显得多</c>

00:09:56.096 --> 00:09:59.099
<c.magenta>通过在iOS 10中应用这个新生命周期</c>

00:09:59.333 --> 00:10:02.069
<c.magenta>我们获得了自动的、</c>
<c.magenta>更快的滚动体验</c>

00:09:59.333 --> 00:10:02.069
<c.magenta>我们获得了自动的、</c>
<c.magenta>更快的滚动体验</c>

00:10:02.302 --> 00:10:03.504
<c.magenta>让我们回到iPad上</c>

00:10:06.373 --> 00:10:08.275
<c.magenta>我要切回iPad</c>

00:10:10.611 --> 00:10:15.082
<c.magenta>你可以看到跟刚在iOS 9上看到的</c>
<c.magenta>相同的CollectionView</c>

00:10:15.616 --> 00:10:19.353
<c.magenta>请记住 滚动当前内容</c>
<c.magenta>很好 很快</c>

00:10:19.686 --> 00:10:21.388
<c.magenta>但当我们引入更多单元格时</c>

00:10:22.422 --> 00:10:23.824
<c.magenta>就开始不流畅了</c>

00:10:24.224 --> 00:10:26.193
<c.magenta>准备CollectionView时</c>

00:10:26.460 --> 00:10:29.496
<c.magenta>我们同时也在烤箱里准备了一个CollectionView</c>
<c.magenta>正在iOS 10下烤着呢</c>

00:10:30.063 --> 00:10:31.398
<c.magenta>我要转到那个CollectionView</c>

00:10:33.100 --> 00:10:35.736
<c.magenta>在此 我们已经有了两个完全相同的</c>
<c.magenta>CollectionView</c>

00:10:36.003 --> 00:10:40.207
<c.magenta>有同样的高消耗</c>
<c.magenta>在iOS 10上运行的蓝色方块</c>

00:10:41.475 --> 00:10:43.944
<c.magenta>我们可以看到滚动当前内容</c>

00:10:44.178 --> 00:10:46.680
<c.magenta>仍然很好 很快 很流畅</c>

00:10:46.880 --> 00:10:48.849
<c.magenta>-但请仔细看 Steve</c>
<c.magenta>-好吧</c>

00:10:48.916 --> 00:10:50.551
<c.magenta>当我再滚动时</c>

00:10:51.518 --> 00:10:53.620
<c.magenta>哦 很棒 五颗星</c>

00:10:54.087 --> 00:10:55.222
<c.magenta>就是这样</c>

00:11:01.228 --> 00:11:04.331
<c.magenta>这是因为我们使用了</c>
<c.magenta>这个新的单元格生命周期</c>

00:11:04.565 --> 00:11:06.300
<c.magenta>我们并没有对应用做出任何变更</c>

00:11:07.167 --> 00:11:08.769
<c.magenta>我要打开那个相同的视图</c>

00:11:08.836 --> 00:11:11.638
<c.magenta>展示CollectionView</c>
<c.magenta>加载的所有单元格</c>

00:11:11.805 --> 00:11:13.407
<c.magenta>帮助我们了解这个不同点</c>

00:11:14.942 --> 00:11:15.976
<c.magenta>打开那个视图</c>

00:11:16.610 --> 00:11:20.380
<c.magenta>在这里 你可看到底部的单元格行</c>
<c.magenta>已经准备好了</c>

00:11:20.747 --> 00:11:22.783
<c.magenta>但是请看当我快速滚动时</c>
<c.magenta>会怎么样</c>

00:11:23.250 --> 00:11:25.719
<c.magenta>并不是一次一行引入单元格</c>

00:11:26.520 --> 00:11:28.922
<c.magenta>我们让工作量均匀分布</c>
<c.magenta>在滚动过程中</c>

00:11:29.156 --> 00:11:32.226
<c.magenta>这是促成更平滑的滚动体验的原因</c>

00:11:32.359 --> 00:11:33.193
<c.magenta>这样是不是很好</c>

00:11:38.765 --> 00:11:41.168
<c.magenta>要了解更多信息</c>
<c.magenta>让我们切回幻灯片</c>

00:11:45.138 --> 00:11:46.206
<c.magenta>相当不错</c>

00:11:46.807 --> 00:11:51.111
<c.magenta>今天我们很高兴地发布一个新UI</c>
<c.magenta>CollectionView Cell Pre-Fetching</c>

00:11:52.713 --> 00:11:56.083
<c.magenta>是默认开启的</c>
<c.magenta>当你在iOS 10上编译你的应用时</c>

00:11:57.484 --> 00:11:58.385
<c.magenta>不需要任何步骤</c>

00:11:59.853 --> 00:12:01.054
<c.magenta>现在无论什么原因</c>

00:11:59.853 --> 00:12:01.054
<c.magenta>现在无论什么原因</c>

00:12:01.121 --> 00:12:05.192
<c.magenta>你想用iOS 10之前</c>
<c.magenta>版本上的旧生命周期行为</c>

00:12:05.259 --> 00:12:06.593
<c.magenta>选择关闭非常简单</c>

00:12:07.160 --> 00:12:09.463
<c.magenta>只需把UICollectionView</c>
<c.magenta>的新属性设为</c>

00:12:09.530 --> 00:12:12.065
<c.magenta>默认值isPrefetchingEnabled即可</c>

00:12:14.735 --> 00:12:17.804
<c.magenta>我们有这个新技术应用相关的最佳范例</c>

00:12:18.972 --> 00:12:20.674
<c.magenta>我们要谈的第一点是</c>

00:12:20.807 --> 00:12:23.677
<c.magenta>我们想在cellForItemAtIndexPath中</c>
<c.magenta>完成所有繁重的工作</c>

00:12:23.744 --> 00:12:25.879
<c.magenta>所有 给单元格创建的所有内容</c>

00:12:25.946 --> 00:12:29.316
<c.magenta>在cellForItemAtIndexPath中</c>
<c.magenta>无论什么都应该居中</c>

00:12:30.684 --> 00:12:31.518
<c.magenta>此外</c>

00:12:31.585 --> 00:12:33.587
<c.magenta>我们想确保</c>
<c.magenta>做最少量的工作</c>

00:12:33.654 --> 00:12:36.757
<c.magenta>在willDisplayCell</c>
<c.magenta>和didEndDisplayCell中</c>

00:12:38.592 --> 00:12:40.661
<c.magenta>最后 很重要的一点是</c>

00:12:41.228 --> 00:12:42.996
<c.magenta>cellForItemAtIndexPath</c>

00:12:43.063 --> 00:12:45.566
<c.magenta>很可能还预备了一个单元格</c>
<c.magenta>这个单元格实际上永远不会被显示出来</c>

00:12:45.933 --> 00:12:47.234
<c.magenta>用户可能已滚动到别处了</c>

00:12:47.301 --> 00:12:49.603
<c.magenta>在那个单元格有机会</c>
<c.magenta>被显示出来之前</c>

00:12:51.271 --> 00:12:52.739
<c.magenta>这很棒</c>

00:12:53.307 --> 00:12:55.475
<c.magenta>只需在iOS 10中进行重新编译即可</c>

00:12:55.542 --> 00:12:57.477
<c.magenta>并且做好你很可能已经在做的</c>

00:12:57.544 --> 00:13:00.647
<c.magenta>在cellForItemAtIndexPath中的</c>
<c.magenta>大部分工作</c>

00:12:57.544 --> 00:13:00.647
<c.magenta>在cellForItemAtIndexPath中的</c>
<c.magenta>大部分工作</c>

00:13:00.981 --> 00:13:04.451
<c.magenta>你自然而然会免费获得更好的</c>
<c.magenta>滚动体验</c>

00:13:05.586 --> 00:13:07.654
<c.magenta>但是 我们想再进一步</c>

00:13:08.155 --> 00:13:10.424
<c.magenta>我们知道</c>
<c.magenta>有一大类应用</c>

00:13:10.591 --> 00:13:13.660
<c.magenta>对于预备CollectionView</c>
<c.magenta>有个小问题</c>

00:13:14.127 --> 00:13:17.264
<c.magenta>我该怎么处理</c>
<c.magenta>高消耗的数据模型呢？</c>

00:13:18.398 --> 00:13:19.800
<c.magenta>事实的真相是</c>

00:13:19.933 --> 00:13:21.535
<c.magenta>很多CollectionView</c>
<c.magenta>单元格</c>

00:13:21.668 --> 00:13:24.938
<c.magenta>需要使用高消耗的</c>
<c.magenta>数据模型来创建</c>

00:13:25.539 --> 00:13:27.040
<c.magenta>我指的是像这样的东西</c>

00:13:27.374 --> 00:13:30.077
<c.magenta>解码图片、</c>
<c.magenta>和数据库通讯、</c>

00:13:30.143 --> 00:13:32.212
<c.magenta>或在核心数据存储之外加载</c>

00:13:32.746 --> 00:13:35.549
<c.magenta>我们知道</c>
<c.magenta>对于这类应用</c>

00:13:36.083 --> 00:13:38.218
<c.magenta>我们并不想显示</c>
<c.magenta>像模板单元格这样的东西</c>

00:13:38.285 --> 00:13:39.786
<c.magenta>当我们在做</c>
<c.magenta>异步网络请求时</c>

00:13:41.622 --> 00:13:45.659
<c.magenta>为了解决这个问题</c>
<c.magenta>我们在iOS 10中引入了新API</c>

00:13:45.726 --> 00:13:48.962
<c.magenta>可以告知</c>
<c.magenta>数据模型如何加载内容</c>

00:13:50.097 --> 00:13:51.465
<c.magenta>自从引入它之后</c>

00:13:51.565 --> 00:13:55.402
<c.magenta>就存在两种伴生对象：</c>

00:13:55.969 --> 00:13:58.038
<c.magenta>数据源和委托</c>

00:13:58.539 --> 00:14:02.276
<c.magenta>在iOS 10中</c>
<c.magenta>我们增加了第三个伴生对象</c>

00:13:58.539 --> 00:14:02.276
<c.magenta>在iOS 10中</c>
<c.magenta>我们增加了第三个伴生对象</c>

00:14:02.543 --> 00:14:05.812
<c.magenta>它是可选的</c>
<c.magenta>叫做prefetchDataSource</c>

00:14:06.713 --> 00:14:08.682
<c.magenta>只有一个必需的方法</c>

00:14:08.916 --> 00:14:10.684
<c.magenta>用起来很简单</c>

00:14:11.451 --> 00:14:14.721
<c.magenta>ColletionView</c>
<c.magenta>prefetchItemsAt indexPaths</c>

00:14:15.622 --> 00:14:18.458
<c.magenta>这将会在预取数据源上调用</c>

00:14:18.692 --> 00:14:22.930
<c.magenta>当从异步模型中预加载内容时</c>

00:14:23.797 --> 00:14:28.035
<c.magenta>那个参数索引路径</c>
<c.magenta>是一个索引路径的有序数组</c>

00:14:28.635 --> 00:14:31.672
<c.magenta>因此 那个数组中越靠前的项</c>
<c.magenta>越先显示出来</c>

00:14:32.306 --> 00:14:35.843
<c.magenta>你可以用此改变</c>
<c.magenta>异步模型读取</c>

00:14:36.743 --> 00:14:39.213
<c.magenta>在这个协议中 还有第二个可选方法</c>

00:14:39.646 --> 00:14:43.550
<c.magenta>CollectionViewcancel</c>
<c.magenta>PrefetcingForItemsAtindexPaths</c>

00:14:45.619 --> 00:14:48.222
<c.magenta>将在预取数据源上调用</c>

00:14:49.289 --> 00:14:51.124
<c.magenta>当我们决定</c>
<c.magenta>不再</c>

00:14:51.191 --> 00:14:53.660
<c.magenta>滚动一组索引路径时</c>

00:14:54.528 --> 00:15:00.367
<c.magenta>你可以用这个来取消或降低</c>
<c.magenta>任何待加载的优先级</c>

00:14:54.528 --> 00:15:00.367
<c.magenta>你可以用这个来取消或降低</c>
<c.magenta>任何待加载的优先级</c>

00:15:01.301 --> 00:15:04.872
<c.magenta>有一个关于此API的重要信息</c>
<c.magenta>我想强调一下</c>

00:15:05.639 --> 00:15:09.042
<c.magenta>这并不是替代</c>
<c.magenta>现有的数据模型</c>

00:15:09.343 --> 00:15:13.647
<c.magenta>而是要跟现有的异步方案共同使用</c>

00:15:13.814 --> 00:15:16.383
<c.magenta>你已在应用中为加载数据创建的</c>

00:15:17.684 --> 00:15:20.487
<c.magenta>你要做的就是把这个</c>
<c.magenta>当作额外提示</c>

00:15:21.021 --> 00:15:23.223
<c.magenta>内容何时加载</c>
<c.magenta>在CollectionView中</c>

00:15:26.260 --> 00:15:28.395
<c.magenta>让我们演示一下 把它们联系起来</c>

00:15:28.462 --> 00:15:31.598
<c.magenta>这个演示包含我们目前提到的所有概念</c>

00:15:31.732 --> 00:15:34.001
<c.magenta>而且我们要引入</c>
<c.magenta>一点儿技术分析</c>

00:15:36.336 --> 00:15:38.672
<c.magenta>来看看这个</c>
<c.magenta>Steve会做一件非常神奇的事儿</c>

00:15:39.439 --> 00:15:40.307
<c.magenta>是技术分析 同志们</c>

00:15:44.311 --> 00:15:46.513
<c.magenta>好的 我们要切回演示应用</c>

00:15:46.580 --> 00:15:47.648
<c.magenta>我们之前看到的</c>

00:15:50.817 --> 00:15:52.953
<c.magenta>好的 那么这是我们正在看的演示应用</c>

00:15:53.020 --> 00:15:56.256
<c.magenta>但我们隐藏了这个很棒的功能</c>
<c.magenta>我们把它叫做技术分析面板</c>

00:15:56.857 --> 00:15:58.692
<c.magenta>好的 那么 我现在要打开它</c>

00:15:59.359 --> 00:16:02.396
<c.magenta>好的 那么我们有两个</c>
<c.magenta>不同的区 对吧</c>

00:15:59.359 --> 00:16:02.396
<c.magenta>好的 那么我们有两个</c>
<c.magenta>不同的区 对吧</c>

00:16:02.462 --> 00:16:04.798
<c.magenta>我们有红区</c>
<c.magenta>一颗星 是个不好的区域</c>

00:16:04.865 --> 00:16:07.301
<c.magenta>然后</c>
<c.magenta>底部有很好很大块的绿区</c>

00:16:07.701 --> 00:16:10.437
<c.magenta>我们可以在这个区域获得超级</c>
<c.magenta>平滑的滚动体验</c>

00:16:11.338 --> 00:16:12.439
<c.magenta>我现在要做的是</c>

00:16:12.506 --> 00:16:15.976
<c.magenta>运行</c>
<c.magenta>iOS 9版本的应用</c>

00:16:16.710 --> 00:16:19.279
<c.magenta>我要再现一个</c>

00:16:19.346 --> 00:16:20.414
<c.magenta>我之前记录的滚动会话</c>

00:16:20.814 --> 00:16:23.050
<c.magenta>展示它是如何运作</c>
<c.magenta>以及如何执行技术分析的</c>

00:16:24.051 --> 00:16:25.118
<c.magenta>好的 现在开始吧</c>

00:16:26.186 --> 00:16:28.188
<c.magenta>滚动 执行技术分析</c>

00:16:29.523 --> 00:16:30.357
<c.magenta>咔 咔</c>

00:16:31.391 --> 00:16:32.459
<c.magenta>好的 看这是什么？</c>

00:16:33.360 --> 00:16:34.695
<c.magenta>让我们看看这个图表</c>

00:16:35.095 --> 00:16:38.832
<c.magenta>我们进入了八次红区</c>
<c.magenta>有八次掉帧</c>

00:16:40.000 --> 00:16:42.970
<c.magenta>但同时 我们也可以看到我们有</c>
<c.magenta>很长的平静周期</c>

00:16:43.036 --> 00:16:44.371
<c.magenta>就像我们之前提到的那样</c>

00:16:44.805 --> 00:16:47.074
<c.magenta>因此 图表区域中</c>
<c.magenta>都是这种又大又尖的东西</c>

00:16:47.441 --> 00:16:49.142
<c.magenta>然后让我们再看一下谷底</c>

00:16:49.376 --> 00:16:51.078
<c.magenta>看看在iOS 10中是怎么样的</c>

00:16:53.847 --> 00:16:55.449
<c.magenta>好的 切回iOS 10模式</c>

00:16:55.516 --> 00:16:57.150
<c.magenta>Peter之前提到过的</c>

00:16:57.384 --> 00:17:00.721
<c.magenta>现在 我要重现</c>
<c.magenta>相同的滚动会话</c>

00:16:57.384 --> 00:17:00.721
<c.magenta>现在 我要重现</c>
<c.magenta>相同的滚动会话</c>

00:17:00.787 --> 00:17:02.122
<c.magenta>哇 看啊 Peter</c>

00:17:02.523 --> 00:17:04.925
<c.magenta>-平滑多了 Steve</c>
<c.magenta>-是啊 看起来好多了</c>

00:17:05.559 --> 00:17:06.627
<c.magenta>看看我们的成果</c>

00:17:07.027 --> 00:17:08.194
<c.magenta>嘿 看那个</c>

00:17:08.529 --> 00:17:09.762
<c.magenta>没有失帧</c>

00:17:13.133 --> 00:17:13.967
<c.magenta>非常棒</c>

00:17:16.036 --> 00:17:19.373
<c.magenta>看看我们在这图表曲线下得到了什么</c>

00:17:19.806 --> 00:17:22.643
<c.magenta>这些峰值并没有上天</c>
<c.magenta>并且与平静周期</c>

00:17:22.876 --> 00:17:26.280
<c.magenta>融合在了一起</c>
<c.magenta>现在 我们得到了这种平滑的效果</c>

00:17:26.512 --> 00:17:29.283
<c.magenta>使应用在主线程上更积极地响应</c>

00:17:29.917 --> 00:17:32.452
<c.magenta>好的 你准备好了吗Peter？</c>

00:17:32.953 --> 00:17:34.254
<c.magenta>-准备好了</c>
<c.magenta>-让我们开始吧</c>

00:17:35.122 --> 00:17:38.058
<c.magenta>好的 现在我们要</c>
<c.magenta>看看iOS 10版本</c>

00:17:38.125 --> 00:17:39.693
<c.magenta>但我们要使用API</c>

00:17:39.760 --> 00:17:41.762
<c.magenta>Peter之前提到过的</c>
<c.magenta>预取API</c>

00:17:41.828 --> 00:17:43.931
<c.magenta>我们要把这些用到</c>
<c.magenta>这个应用中</c>

00:17:44.031 --> 00:17:46.099
<c.magenta>好的 我已经准备好了演示应用</c>

00:17:46.567 --> 00:17:48.569
<c.magenta>我要重现</c>
<c.magenta>相同的滚动会话</c>

00:17:49.536 --> 00:17:50.504
<c.magenta>哇 Peter 看</c>

00:17:50.771 --> 00:17:53.140
<c.magenta>-现在是黄油式的滚动了 Steve</c>
<c.magenta>-看起来很不错</c>

00:17:53.707 --> 00:17:54.541
<c.magenta>五颗星</c>

00:17:55.876 --> 00:17:57.044
<c.magenta>技术分析也表明足以达到五颗星</c>

00:18:04.017 --> 00:18:06.653
<c.magenta>好的 但Peter</c>
<c.magenta>这里有点儿不一样了 是吧</c>

00:18:06.720 --> 00:18:09.890
<c.magenta>曲线上的区域中的</c>
<c.magenta>主队列活动</c>

00:18:10.123 --> 00:18:11.658
<c.magenta>和之前的版本不一样了</c>

00:18:11.725 --> 00:18:13.527
<c.magenta>曲线下降了不少</c>
<c.magenta>发生了什么？</c>

00:18:13.994 --> 00:18:17.164
<c.magenta>那么 如果我们正确地使用预取API</c>

00:18:17.431 --> 00:18:19.533
<c.magenta>我们很可能把数据模型读取移动到</c>

00:18:19.600 --> 00:18:22.302
<c.magenta>后台队列上</c>
<c.magenta>释放主队列</c>

00:18:23.203 --> 00:18:25.639
<c.magenta>就是这样</c>
<c.magenta>就是这么回事</c>

00:18:25.706 --> 00:18:28.208
<c.magenta>现在 我们把所有工作都挪到了</c>
<c.magenta>后台队列上</c>

00:18:28.275 --> 00:18:30.911
<c.magenta>我们不必再</c>
<c.magenta>扰乱主线程了</c>

00:18:31.345 --> 00:18:32.713
<c.magenta>让我们切回幻灯片</c>

00:18:39.953 --> 00:18:41.455
<c.magenta>接下来 我想谈一点儿</c>

00:18:41.522 --> 00:18:43.557
<c.magenta>预取API的小技巧</c>

00:18:43.624 --> 00:18:46.426
<c.magenta>以最合适的方式使你的应用</c>
<c.magenta>使用这个API</c>

00:18:48.428 --> 00:18:51.064
<c.magenta>首先</c>
<c.magenta>当你调用预取时</c>

00:18:51.131 --> 00:18:54.368
<c.magenta>你想要保证立即在后台队列上</c>
<c.magenta>完成所有工作</c>

00:18:54.935 --> 00:18:57.037
<c.magenta>现在 我们有两种很棒的</c>
<c.magenta>技术可以实现：</c>

00:18:57.271 --> 00:18:59.973
<c.magenta>GCD和NSOperationQueue</c>

00:19:03.677 --> 00:19:07.581
<c.magenta>还有一点很重要</c>
<c.magenta>预取是一种自适应技术</c>

00:19:07.648 --> 00:19:09.650
<c.magenta>自适应技术是什么意思呢？</c>

00:19:10.217 --> 00:19:12.719
<c.magenta>嗯 记得我们谈到</c>
<c.magenta>那些平静周期</c>

00:19:12.786 --> 00:19:14.755
<c.magenta>和预取如何</c>
<c.magenta>利用那些的吗</c>

00:19:14.888 --> 00:19:16.056
<c.magenta>通过额外工作</c>

00:19:17.558 --> 00:19:21.261
<c.magenta>在应用中 有时候</c>
<c.magenta>用户滚动太快</c>

00:19:21.328 --> 00:19:22.629
<c.magenta>没有平静时间</c>

00:19:23.163 --> 00:19:26.099
<c.magenta>在这种情况下 当我们不得不</c>
<c.magenta>很频繁地更新显示时</c>

00:19:26.333 --> 00:19:28.001
<c.magenta>我们将不进行预取</c>

00:19:28.468 --> 00:19:29.536
<c.magenta>这样是正确的</c>

00:19:31.038 --> 00:19:34.141
<c.magenta>最后</c>
<c.magenta>使用cancelPrefetchingAPI</c>

00:19:34.374 --> 00:19:36.910
<c.magenta>来适应用户的焦点转移</c>

00:19:36.977 --> 00:19:40.314
<c.magenta>现在 可能用户向上移动到了</c>
<c.magenta>CollectionView</c>

00:19:40.380 --> 00:19:42.015
<c.magenta>并且正与内容一起滚动</c>

00:19:42.082 --> 00:19:44.384
<c.magenta>但然后 他们改变了主意</c>
<c.magenta>开始向另一个方向滚动</c>

00:19:44.685 --> 00:19:47.221
<c.magenta>我们将通过取消消息把这个事件通知给你</c>

00:19:47.487 --> 00:19:49.923
<c.magenta>这样你就可以忽略那些优先的内容</c>

00:19:49.990 --> 00:19:53.227
<c.magenta>聚焦在视图即将要滚动到的新内容上</c>

00:19:54.795 --> 00:19:57.130
<c.magenta>对于CollectionView来说</c>
<c.magenta>这真的很棒</c>

00:19:57.564 --> 00:20:01.034
<c.magenta>你什么也不用做</c>
<c.magenta>就能得到更好的滚动体验</c>

00:19:57.564 --> 00:20:01.034
<c.magenta>你什么也不用做</c>
<c.magenta>就能得到更好的滚动体验</c>

00:20:01.201 --> 00:20:03.136
<c.magenta>只需要做一点儿工作</c>

00:20:03.370 --> 00:20:05.472
<c.magenta>使用你已经写好的类</c>

00:20:05.639 --> 00:20:07.641
<c.magenta>你就能得到更好的滚动体验</c>

00:20:08.442 --> 00:20:10.477
<c.magenta>若你使用UITableView</c>
<c.magenta>请别担心</c>

00:20:10.544 --> 00:20:11.712
<c.magenta>一点儿都不重要</c>

00:20:11.879 --> 00:20:14.815
<c.magenta>我们也在表视图中</c>
<c.magenta>引入了完全一样的API</c>

00:20:22.055 --> 00:20:26.627
<c.magenta>有一个类似的可选</c>
<c.magenta>预取数据源伴生对象</c>

00:20:27.494 --> 00:20:30.464
<c.magenta>有一个类似的方法 只有一个方法</c>

00:20:31.265 --> 00:20:34.368
<c.magenta>TableView</c>
<c.magenta>prefetchRowsAt indexPaths</c>

00:20:34.701 --> 00:20:37.504
<c.magenta>索引路径也是个数组</c>

00:20:37.704 --> 00:20:40.974
<c.magenta>按照优先级排序</c>
<c.magenta>在表的可见区域</c>

00:20:41.375 --> 00:20:43.911
<c.magenta>越靠前的索引路径</c>
<c.magenta>越先显示出来</c>

00:20:44.745 --> 00:20:46.847
<c.magenta>跟CollectionView API一样</c>

00:20:46.914 --> 00:20:50.651
<c.magenta>你可以用此来通知</c>
<c.magenta>异步数据模型读取</c>

00:20:51.251 --> 00:20:54.788
<c.magenta>还有相同的第二个</c>
<c.magenta>可选委托方法</c>

00:20:55.589 --> 00:20:59.026
<c.magenta>表视图 cancelPrefetchingForRowsAt</c>
<c.magenta>indexPaths</c>

00:21:00.027 --> 00:21:02.896
<c.magenta>就像Steve刚提到的那样</c>
<c.magenta>你可以用此</c>

00:21:03.063 --> 00:21:07.634
<c.magenta>来取消或降低任何待定数据模型</c>
<c.magenta>加载的优先级</c>

00:21:08.502 --> 00:21:10.270
<c.magenta>这是最棒的一点</c>

00:21:10.704 --> 00:21:12.840
<c.magenta>就跟CollectionView API一样</c>

00:21:13.073 --> 00:21:16.977
<c.magenta>这也要跟当前异步模型方案一起使用</c>

00:21:17.344 --> 00:21:19.046
<c.magenta>你不必丢掉任何东西</c>

00:21:19.146 --> 00:21:22.783
<c.magenta>相反 使用这个通知你正在做的加载</c>

00:21:23.317 --> 00:21:25.986
<c.magenta>那么这就是iOS 10中的单元格预取</c>

00:21:32.526 --> 00:21:34.528
<c.magenta>我们非常激动</c>
<c.magenta>引入了这个技术</c>

00:21:34.595 --> 00:21:37.931
<c.magenta>我们迫不及待要看到实际的应用</c>
<c.magenta>有更平滑的滚动体验</c>

00:21:39.967 --> 00:21:43.670
<c.magenta>接下来 我们要讲讲</c>
<c.magenta>我们今年所做的一些改进</c>

00:21:43.737 --> 00:21:45.639
<c.magenta>针对自动调整单元格</c>

00:21:45.939 --> 00:21:47.908
<c.magenta>我们在iOS 8中引入了这个API</c>

00:21:48.208 --> 00:21:50.110
<c.magenta>今年我们又做了一些改进</c>

00:21:50.177 --> 00:21:52.613
<c.magenta>使它更容易地应用到你的应用中</c>

00:21:53.480 --> 00:21:56.917
<c.magenta>在我们讲这个之前</c>
<c.magenta>我想回顾一下现有的API</c>

00:21:56.984 --> 00:21:58.151
<c.magenta>简单聊一下</c>

00:22:01.154 --> 00:22:05.225
<c.magenta>在CollectionView中</c>
<c.magenta>我们发布了一个具体布局类</c>

00:22:05.292 --> 00:22:07.261
<c.magenta>叫做</c>
<c.magenta>UICollectionViewFlowLayout</c>

00:22:07.995 --> 00:22:10.931
<c.magenta>并且完全支持</c>
<c.magenta>这个类自动调整单元格</c>

00:22:11.932 --> 00:22:14.001
<c.magenta>要开启这个功能 我们只需要设置</c>

00:22:14.067 --> 00:22:17.538
<c.magenta>预估尺寸</c>
<c.magenta>把它设置为一些非零CG尺寸</c>

00:22:17.871 --> 00:22:20.407
<c.magenta>这就会告诉CollectionView</c>
<c.magenta>你想 计算</c>

00:22:20.474 --> 00:22:23.410
<c.magenta>动态布局</c>
<c.magenta>在显示内容时</c>

00:22:25.479 --> 00:22:27.814
<c.magenta>现在 获得</c>
<c.magenta>单元格的实际尺寸</c>

00:22:27.881 --> 00:22:30.117
<c.magenta>有三种不同的方法</c>
<c.magenta>可以实现</c>

00:22:30.918 --> 00:22:33.053
<c.magenta>第一种方法是使用自动布局</c>

00:22:33.654 --> 00:22:37.157
<c.magenta>如果你可以完全把</c>
<c.magenta>层级的内容视图限制到</c>

00:22:37.224 --> 00:22:39.593
<c.magenta>CollectionView</c>
<c.magenta>单元格的内容视图中</c>

00:22:39.660 --> 00:22:42.896
<c.magenta>我们就会请求自动布局系统计算</c>
<c.magenta>单元格的尺寸</c>

00:22:43.163 --> 00:22:44.231
<c.magenta>并使用那个值</c>

00:22:46.033 --> 00:22:48.969
<c.magenta>如果你不使用自动布局</c>
<c.magenta>或你需要更多手动控制</c>

00:22:49.436 --> 00:22:51.805
<c.magenta>你可以重写sizeThatFits</c>

00:22:53.874 --> 00:22:55.709
<c.magenta>最后 实现最终控制</c>

00:22:56.109 --> 00:22:59.479
<c.magenta>你可以重写 preferredLayout</c>
<c.magenta>AttributesFittingAttributes</c>

00:22:59.546 --> 00:23:03.050
<c.magenta>不仅提供尺寸信息</c>
<c.magenta>还可以调整属性</c>

00:22:59.546 --> 00:23:03.050
<c.magenta>不仅提供尺寸信息</c>
<c.magenta>还可以调整属性</c>

00:23:03.116 --> 00:23:04.818
<c.magenta>比如阿尔法和变形</c>

00:23:06.186 --> 00:23:10.123
<c.magenta>因此 指定单元格尺寸</c>
<c.magenta>使用三种机制中的一种</c>

00:23:10.390 --> 00:23:11.325
<c.magenta>非常简单</c>

00:23:11.725 --> 00:23:14.695
<c.magenta>大部分应用使用自动布局</c>
<c.magenta>但对于不使用自动布局的应用</c>

00:23:14.761 --> 00:23:18.465
<c.magenta>可以通过第二个机制</c>
<c.magenta>实现更多的手动控制</c>

00:23:19.333 --> 00:23:22.202
<c.magenta>但是我们发现</c>
<c.magenta>对于某些类型的布局</c>

00:23:22.536 --> 00:23:26.406
<c.magenta>选择一个适当的预估尺寸</c>
<c.magenta>非常有挑战性</c>

00:23:26.974 --> 00:23:29.042
<c.magenta>因为有时候很难猜测</c>

00:23:29.943 --> 00:23:32.079
<c.magenta>我的意思是有时候你要用哪个？</c>

00:23:32.312 --> 00:23:35.215
<c.magenta>50乘50、100乘100 等等</c>

00:23:35.382 --> 00:23:36.383
<c.magenta>很难说</c>

00:23:37.384 --> 00:23:40.354
<c.magenta>对于这种类型的布局来说</c>
<c.magenta>很酷的是</c>

00:23:40.754 --> 00:23:43.390
<c.magenta>如果流布局能适应它的预期尺寸</c>

00:23:44.157 --> 00:23:48.695
<c.magenta>然后使用这个数</c>
<c.magenta>而不是计算预估尺寸</c>

00:23:48.862 --> 00:23:51.765
<c.magenta>通过我们已经订好的内容的实际尺寸</c>

00:23:52.966 --> 00:23:56.603
<c.magenta>在iOS 10中 我们有个新API</c>
<c.magenta>可以在流布局中实现那个功能</c>

00:23:57.804 --> 00:24:00.941
<c.magenta>你要做的就是将流</c>
<c.magenta>layout.EstimatedItemSize设置为</c>

00:23:57.804 --> 00:24:00.941
<c.magenta>你要做的就是将流</c>
<c.magenta>layout.EstimatedItemSize设置为</c>

00:24:01.008 --> 00:24:05.379
<c.magenta>新常量 UICollectionView</c>
<c.magenta>FlowLayoutAutomaticSize</c>

00:24:11.785 --> 00:24:15.255
<c.magenta>通过将预估尺寸设为自动调整尺寸</c>

00:24:15.489 --> 00:24:17.724
<c.magenta>这就表示</c>
<c.magenta>CollectionViewFlowLayout</c>

00:24:17.791 --> 00:24:19.293
<c.magenta>会替你计算</c>

00:24:19.726 --> 00:24:23.397
<c.magenta>它将保留一个已订好尺寸的</c>
<c.magenta>全部单元格的流水账</c>

00:24:23.864 --> 00:24:27.267
<c.magenta>并使用那个流水账来影响</c>
<c.magenta>之后的尺寸预估值</c>

00:24:28.101 --> 00:24:29.169
<c.magenta>等会儿就看到了</c>

00:24:29.469 --> 00:24:31.872
<c.magenta>这使得流布局更精确</c>

00:24:31.939 --> 00:24:33.941
<c.magenta>当指定CollectionView</c>
<c.magenta>单元格的尺寸时</c>

00:24:34.007 --> 00:24:37.077
<c.magenta>以获得更好的性能</c>
<c.magenta>和更精确的布局</c>

00:24:37.144 --> 00:24:38.078
<c.magenta>在我们指定尺寸时</c>

00:24:38.712 --> 00:24:42.216
<c.magenta>我们要做一个演示来展示</c>

00:24:42.282 --> 00:24:45.719
<c.magenta>UICollectionViewFlowLayout</c>
<c.magenta>自动调整尺寸的好处</c>

00:24:50.490 --> 00:24:52.192
<c.magenta>我要切回到iPad</c>

00:25:00.334 --> 00:25:03.504
<c.magenta>在这里我们有一个使用流布局的</c>
<c.magenta>CollectionView</c>

00:25:04.104 --> 00:25:07.541
<c.magenta>每个单元格代表文本运行中的一个词</c>

00:25:08.442 --> 00:25:11.645
<c.magenta>澄清一下 我们不提倡</c>
<c.magenta>创建文本查看器</c>

00:25:11.712 --> 00:25:13.647
<c.magenta>或使用UICollectionView编辑器</c>

00:25:14.314 --> 00:25:15.983
<c.magenta>但作为演示效果很好</c>

00:25:17.050 --> 00:25:18.986
<c.magenta>我要把应用放在模式中</c>

00:25:20.120 --> 00:25:24.091
<c.magenta>可以观察到流布局</c>
<c.magenta>当给每个单元格指定尺寸时</c>

00:25:24.858 --> 00:25:26.393
<c.magenta>用户永远不会看到这些</c>

00:25:26.793 --> 00:25:30.631
<c.magenta>但这种方式可以很好地了解</c>
<c.magenta>这个新API的优点</c>

00:25:31.331 --> 00:25:35.435
<c.magenta>让我们以固定的预估值开始吧</c>
<c.magenta>就像我们在iOS 9上使用的那样</c>

00:25:36.069 --> 00:25:37.771
<c.magenta>那么 我要打开模拟器</c>

00:25:39.206 --> 00:25:41.775
<c.magenta>在这里 你可以看到</c>
<c.magenta>我们已经给每个单元格填充了</c>

00:25:41.875 --> 00:25:45.479
<c.magenta>初始预估尺寸</c>
<c.magenta>就像我们刚刚猜想的那样</c>

00:25:46.346 --> 00:25:50.417
<c.magenta>在文本运行中我要给第一个词</c>
<c.magenta>Lorem指定一下尺寸</c>

00:25:51.018 --> 00:25:52.152
<c.magenta>看看会怎么样</c>

00:25:54.555 --> 00:25:57.724
<c.magenta>那么 我们给Lorem制定了尺寸</c>
<c.magenta>现在已经是正确的尺寸了</c>

00:25:57.991 --> 00:26:01.261
<c.magenta>请注意CollectionView</c>
<c.magenta>实际上并不接近</c>

00:25:57.991 --> 00:26:01.261
<c.magenta>请注意CollectionView</c>
<c.magenta>实际上并不接近</c>

00:26:01.528 --> 00:26:03.830
<c.magenta>应有的目标布局尺寸</c>

00:26:04.431 --> 00:26:07.267
<c.magenta>我们并没有使用那个预估值</c>
<c.magenta>来影响任何东西</c>

00:26:07.634 --> 00:26:11.305
<c.magenta>一切都还是那么大</c>
<c.magenta>跟我们传过来的初始预估值一样</c>

00:26:13.841 --> 00:26:17.377
<c.magenta>现在 这种情况会持续发生</c>
<c.magenta>当我们分别给每个单元格制定尺寸时</c>

00:26:17.511 --> 00:26:18.712
<c.magenta>在CollectionView中</c>

00:26:19.713 --> 00:26:24.251
<c.magenta>请注意 实际上我们并不能把</c>
<c.magenta>任何其他单元格的尺寸</c>

00:26:24.451 --> 00:26:26.887
<c.magenta>调整为我们之前计算好的尺寸</c>

00:26:27.754 --> 00:26:29.122
<c.magenta>很明显</c>

00:26:29.423 --> 00:26:32.960
<c.magenta>在文本运行中 当我们给</c>
<c.magenta>最后一个词Fusce制定尺寸时</c>

00:26:33.760 --> 00:26:35.329
<c.magenta>当我们要给这个词制定尺寸时</c>

00:26:36.763 --> 00:26:39.366
<c.magenta>你会注意到 我们向上滑动了</c>
<c.magenta>所有其他单元格</c>

00:26:39.433 --> 00:26:41.101
<c.magenta>使它们的y-位置失效</c>

00:26:42.035 --> 00:26:45.038
<c.magenta>我们没有使用第一行文本的信息</c>

00:26:45.539 --> 00:26:48.275
<c.magenta>来影响任何其他单元格的尺寸</c>

00:26:49.510 --> 00:26:52.779
<c.magenta>现在我要把设备调成</c>
<c.magenta>iOS 10模式</c>

00:26:53.313 --> 00:26:56.750
<c.magenta>使用UICollectionViewFlowLayout</c>
<c.magenta>自动调整尺寸</c>

00:26:57.351 --> 00:26:58.318
<c.magenta>让我们切换一下</c>

00:26:59.419 --> 00:27:00.988
<c.magenta>好的 切换好了</c>
<c.magenta>我们已填充</c>

00:26:59.419 --> 00:27:00.988
<c.magenta>好的 切换好了</c>
<c.magenta>我们已填充</c>

00:27:01.054 --> 00:27:04.791
<c.magenta>相同的初始尺寸</c>
<c.magenta>帮助你观察不同之处</c>

00:27:05.692 --> 00:27:07.828
<c.magenta>我要给第一个词Lorem定个尺寸</c>

00:27:08.161 --> 00:27:09.530
<c.magenta>看看会发生什么</c>

00:27:11.098 --> 00:27:14.001
<c.magenta>哇哦 我们给第一个单元格重定了尺寸</c>

00:27:14.067 --> 00:27:17.371
<c.magenta>并使用那个单元格尺寸</c>
<c.magenta>作为所有其他CollectionView单元格</c>

00:27:17.437 --> 00:27:19.506
<c.magenta>运行中的预估值</c>

00:27:20.073 --> 00:27:22.209
<c.magenta>现在布局还不是那么精确</c>

00:27:22.609 --> 00:27:25.612
<c.magenta>但请注意 已经非常贴近</c>
<c.magenta>最终的结果了</c>

00:27:25.979 --> 00:27:29.416
<c.magenta>事实上 y-位置的高度</c>
<c.magenta>非常正确</c>

00:27:30.651 --> 00:27:33.387
<c.magenta>请注意 当我给这个文本运行</c>
<c.magenta>重新制定尺寸时</c>

00:27:33.453 --> 00:27:37.424
<c.magenta>我们实际上是正使它越来越精确</c>

00:27:37.791 --> 00:27:39.893
<c.magenta>全面地为CollectionView单元格调整预估尺寸</c>

00:27:42.062 --> 00:27:44.898
<c.magenta>请注意 在文本运行中</c>
<c.magenta>给最后一个词重定尺寸时</c>

00:27:45.832 --> 00:27:49.403
<c.magenta>不再使</c>
<c.magenta>其他单元格的y-位置失效</c>

00:27:49.937 --> 00:27:52.372
<c.magenta>这很棒</c>
<c.magenta>可以很大程度上帮助我们</c>

00:27:52.439 --> 00:27:55.275
<c.magenta>当你做这样的操作时</c>
<c.magenta>比如scrollToItemAt indexPath</c>

00:27:56.176 --> 00:27:58.011
<c.magenta>现在 由于这个API的性质</c>

00:27:58.312 --> 00:28:00.347
<c.magenta>你将得到最货真价实的东西</c>

00:27:58.312 --> 00:28:00.347
<c.magenta>你将得到最货真价实的东西</c>

00:28:00.414 --> 00:28:01.782
<c.magenta>使用自动调整尺寸</c>

00:28:02.182 --> 00:28:05.385
<c.magenta>如果你的单元格有</c>
<c.magenta>相似的宽或高</c>

00:28:05.986 --> 00:28:09.289
<c.magenta>这就是自动调整</c>
<c.magenta>在iOS 10上的改进</c>

00:28:09.356 --> 00:28:10.524
<c.magenta>让我们再返回去看幻灯片</c>

00:28:18.065 --> 00:28:20.501
<c.magenta>这就是</c>
<c.magenta>自动调整单元格</c>

00:28:20.567 --> 00:28:24.338
<c.magenta>并且现在 我们要谈一下</c>
<c.magenta>关于我们去年引入的API的信息</c>

00:28:24.838 --> 00:28:26.340
<c.magenta>交互式重排序</c>

00:28:28.008 --> 00:28:31.512
<c.magenta>这是个很熟悉的用户体验</c>
<c.magenta>对于表视图单元格用户来说</c>

00:28:31.578 --> 00:28:34.815
<c.magenta>他们希望用户能抓住</c>
<c.magenta>一段内容然后移动它</c>

00:28:34.882 --> 00:28:37.584
<c.magenta>并在你的表视图中</c>
<c.magenta>垂直地重新排列</c>

00:28:38.318 --> 00:28:41.021
<c.magenta>去年我们的技术引入了</c>
<c.magenta>CollectionView</c>

00:28:41.288 --> 00:28:43.323
<c.magenta>通过一个新的交互式重排序API</c>

00:28:43.657 --> 00:28:45.158
<c.magenta>让我们再回到iPad</c>

00:28:45.225 --> 00:28:47.194
<c.magenta>看看在演示中是什么样的</c>

00:28:57.571 --> 00:28:58.739
<c.magenta>切回iPad</c>

00:28:58.805 --> 00:28:59.806
<c.magenta>好的</c>
<c.magenta>切换好了</c>

00:29:00.240 --> 00:29:03.110
<c.magenta>好的 那么我们有一个非常</c>
<c.magenta>漂亮的自定义布局</c>

00:29:04.545 --> 00:29:05.812
<c.magenta>哦 快看这个滚动 Peter</c>

00:29:06.580 --> 00:29:08.182
<c.magenta>我们很可能应用了预取</c>

00:29:08.248 --> 00:29:10.317
<c.magenta>-非常简单</c>
<c.magenta>-很可能是</c>

00:29:10.584 --> 00:29:11.485
<c.magenta>好的 让我们看一下</c>

00:29:11.552 --> 00:29:14.922
<c.magenta>假如用户喜欢这个内容</c>
<c.magenta>但他们想要重新排列这个内容</c>

00:29:15.289 --> 00:29:17.224
<c.magenta>可能会用手指拖拽</c>

00:29:17.524 --> 00:29:20.127
<c.magenta>在CollectionView中</c>
<c.magenta>平滑地移动内容</c>

00:29:20.294 --> 00:29:22.396
<c.magenta>请注意 它是如何自动回流的</c>

00:29:23.063 --> 00:29:26.166
<c.magenta>不只是那样 如果我们改成</c>
<c.magenta>一个有着不同尺寸的项</c>

00:29:26.433 --> 00:29:28.001
<c.magenta>你也可以进行以上操作</c>

00:29:28.869 --> 00:29:31.371
<c.magenta>现在 当用户完成重新排序后</c>
<c.magenta>他们可能会松手</c>

00:29:31.672 --> 00:29:34.241
<c.magenta>平滑地嵌入</c>
<c.magenta>就是这样</c>

00:29:35.008 --> 00:29:37.611
<c.magenta>让我们再切回幻灯片</c>
<c.magenta>让Peter演示一下API</c>

00:29:38.712 --> 00:29:42.449
<c.magenta>这就是iOS 9上的交互式重排序</c>

00:29:42.816 --> 00:29:43.717
<c.magenta>这个API</c>

00:29:43.784 --> 00:29:44.885
<c.magenta>非常简单</c>

00:29:46.186 --> 00:29:49.790
<c.magenta>要开始一个交互式移动</c>
<c.magenta>你要先调用CollectionViews</c>

00:29:49.957 --> 00:29:53.060
<c.magenta>beginInteractiveMovement</c>
<c.magenta>ForItematindexPath</c>

00:29:53.694 --> 00:29:57.364
<c.magenta>索引路径体现的是</c>
<c.magenta>单元格的索引路径</c>

00:29:57.531 --> 00:29:58.866
<c.magenta>我们想要移动的</c>

00:29:59.533 --> 00:30:01.602
<c.magenta>如果你这样做是为了</c>
<c.magenta>响应某个手势</c>

00:29:59.533 --> 00:30:01.602
<c.magenta>如果你这样做是为了</c>
<c.magenta>响应某个手势</c>

00:30:01.869 --> 00:30:04.238
<c.magenta>你可以点击测试</c>
<c.magenta>CollectionView</c>

00:30:04.838 --> 00:30:07.207
<c.magenta>使用本地项的索引路径</c>

00:30:08.041 --> 00:30:10.577
<c.magenta>接下来 手势每次更新时</c>

00:30:10.878 --> 00:30:13.146
<c.magenta>我们都想</c>
<c.magenta>更新单元格的位置</c>

00:30:13.213 --> 00:30:14.781
<c.magenta>响应手指的操作</c>

00:30:15.449 --> 00:30:19.386
<c.magenta>为此 我们要调用updateInteractive</c>
<c.magenta>MovementTargetPosition</c>

00:30:19.953 --> 00:30:24.091
<c.magenta>在CollectionView</c>
<c.magenta>的坐标空间传递手势的位置</c>

00:30:25.893 --> 00:30:28.762
<c.magenta>接下来 当我们想结束</c>
<c.magenta>交互式移动</c>

00:30:28.896 --> 00:30:30.230
<c.magenta>并确认重新排序时</c>

00:30:30.464 --> 00:30:34.134
<c.magenta>我们要在CollectionView上</c>
<c.magenta>调用endInteractiveMovement</c>

00:30:35.402 --> 00:30:37.504
<c.magenta>CollectionView</c>
<c.magenta>会释放单元格</c>

00:30:37.571 --> 00:30:39.673
<c.magenta>正确处理所有布局属性</c>

00:30:40.007 --> 00:30:42.342
<c.magenta>然后 返回一条信息</c>
<c.magenta>给应用的数据源</c>

00:30:42.809 --> 00:30:45.412
<c.magenta>这样你可以在模型中实现真正的重新排序</c>

00:30:47.381 --> 00:30:48.215
<c.magenta>现在</c>

00:30:48.649 --> 00:30:49.683
<c.magenta>如果手势取消了</c>

00:30:49.750 --> 00:30:52.119
<c.magenta>或你不允许重新排序</c>
<c.magenta>此时</c>

00:30:52.553 --> 00:30:55.622
<c.magenta>你可调用CollectionView的</c>
<c.magenta>cancelInteractiveMovement</c>

00:30:56.356 --> 00:30:58.892
<c.magenta>在这里 我们会把一切恢复成</c>
<c.magenta>原来的样子</c>

00:30:59.560 --> 00:31:01.328
<c.magenta>并且我们不会调用数据源</c>

00:30:59.560 --> 00:31:01.328
<c.magenta>并且我们不会调用数据源</c>

00:31:02.396 --> 00:31:05.299
<c.magenta>现在对于使用了UICollection</c>
<c.magenta>ViewController的人来说</c>

00:31:05.632 --> 00:31:07.568
<c.magenta>你的使用更加方便</c>

00:31:08.235 --> 00:31:10.604
<c.magenta>你只需要设置</c>
<c.magenta>安装交互式移动</c>

00:31:10.671 --> 00:31:13.273
<c.magenta>标准手势属性为真</c>

00:31:13.941 --> 00:31:17.010
<c.magenta>CollectionViewController</c>
<c.magenta>将添加一个手势</c>

00:31:17.077 --> 00:31:19.746
<c.magenta>替你调用这些方法</c>

00:31:20.113 --> 00:31:23.116
<c.magenta>你要做的就是</c>
<c.magenta>实现数据源部分</c>

00:31:24.618 --> 00:31:27.955
<c.magenta>这就是我们去年在iOS 9中</c>
<c.magenta>发布的API</c>

00:31:29.256 --> 00:31:33.193
<c.magenta>今年 我们非常骄傲地宣布</c>
<c.magenta>我们即将在这个功能中添加分页支持</c>

00:31:33.293 --> 00:31:36.997
<c.magenta>现在 没有新API</c>
<c.magenta>就是最好的API</c>

00:31:37.064 --> 00:31:40.300
<c.magenta>自CollectionView</c>
<c.magenta>从UIScrollView中衍生出来之后</c>

00:31:40.367 --> 00:31:41.335
<c.magenta>你所要做的就是</c>

00:31:41.568 --> 00:31:44.271
<c.magenta>设置isPagingEnabled</c>
<c.magenta>属性</c>

00:31:44.338 --> 00:31:46.707
<c.magenta>ScrollView的交互式属性</c>
<c.magenta>为真</c>

00:31:46.940 --> 00:31:48.375
<c.magenta>这样就会开启新API</c>

00:31:49.009 --> 00:31:50.978
<c.magenta>让我们切回iPad</c>
<c.magenta>在演示中看一下</c>

00:31:51.945 --> 00:31:55.315
<c.magenta>在这里 我们有一个水平滚动的</c>
<c.magenta>CollectionView</c>

00:31:56.416 --> 00:32:00.053
<c.magenta>当前并没有使用分页</c>
<c.magenta>而是连续的</c>

00:31:56.416 --> 00:32:00.053
<c.magenta>当前并没有使用分页</c>
<c.magenta>而是连续的</c>

00:32:00.287 --> 00:32:02.523
<c.magenta>看那个平滑的</c>
<c.magenta>滚动体验</c>

00:32:02.689 --> 00:32:03.524
<c.magenta>耶</c>

00:32:04.224 --> 00:32:07.928
<c.magenta>那么在重新排序中</c>
<c.magenta>当我们连续滚动时</c>

00:32:08.495 --> 00:32:10.163
<c.magenta>我们选择CollectionView单元格</c>

00:32:10.497 --> 00:32:12.599
<c.magenta>并把它移动到屏幕的边缘</c>

00:32:12.799 --> 00:32:15.502
<c.magenta>然后我们就得到了非常好的</c>
<c.magenta>自动滚动行为</c>

00:32:15.802 --> 00:32:19.673
<c.magenta>许多基于CollectionView</c>
<c.magenta>的应用用户应该很熟悉这个操作</c>

00:32:21.074 --> 00:32:23.377
<c.magenta>现在 我要开启分页支持</c>

00:32:24.044 --> 00:32:27.748
<c.magenta>我们可看到CollectionView</c>
<c.magenta>现有了页面尺寸递增</c>

00:32:28.182 --> 00:32:31.285
<c.magenta>对于某些类型的CollectionView来说</c>
<c.magenta>这非常自然</c>

00:32:31.852 --> 00:32:33.086
<c.magenta>这是新增的功能</c>

00:32:34.121 --> 00:32:36.156
<c.magenta>我们调用的是相同的重排序API</c>

00:32:36.523 --> 00:32:40.994
<c.magenta>但iOS 10中的新特性是</c>
<c.magenta>重排序能和分页可以同时使用</c>

00:32:41.628 --> 00:32:44.097
<c.magenta>所以 当我把单元格移动到</c>
<c.magenta>屏幕边缘时</c>

00:32:46.266 --> 00:32:49.336
<c.magenta>我们将以页面尺寸递增值自动滚动</c>

00:32:50.771 --> 00:32:54.741
<c.magenta>这可以使应用获得真正的</c>
<c.magenta>主屏幕式重排序体验</c>

00:32:54.975 --> 00:32:56.877
<c.magenta>我松开手 就是这样</c>

00:33:03.717 --> 00:33:04.952
<c.magenta>让我们再返回幻灯片</c>

00:33:11.058 --> 00:33:12.526
<c.magenta>这有点儿像内部战术</c>

00:33:12.593 --> 00:33:15.829
<c.magenta>那么 我们早期开发iOS 10时</c>

00:33:16.263 --> 00:33:19.099
<c.magenta>他经常来我的办公室</c>
<c.magenta>热情高涨</c>

00:33:19.766 --> 00:33:22.069
<c.magenta>“Steve 我正做一个很棒的功能</c>

00:33:22.135 --> 00:33:23.804
<c.magenta>开发人员会蹦起来的”</c>

00:33:24.271 --> 00:33:25.105
<c.magenta>他当时也蹦起来了</c>

00:33:26.540 --> 00:33:27.741
<c.magenta>我同意这种说法 这是个很棒的功能</c>

00:33:27.808 --> 00:33:30.010
<c.magenta>我要迫不及待地展示</c>
<c.magenta>给开发人员</c>

00:33:30.477 --> 00:33:32.746
<c.magenta>那么在WWDC期间</c>

00:33:32.813 --> 00:33:35.682
<c.magenta>他找到了一个能展示这个功能的地方</c>

00:33:35.749 --> 00:33:37.751
<c.magenta>于是我们讨论这个功能</c>
<c.magenta>并跟人们一起分享</c>

00:33:38.552 --> 00:33:40.387
<c.magenta>那么 就在前几天</c>

00:33:40.487 --> 00:33:42.489
<c.magenta>他又说了</c>
<c.magenta>“我们必须这样做 ”</c>

00:33:43.023 --> 00:33:44.358
<c.magenta>我说 “好的 没问题 ”</c>

00:33:44.691 --> 00:33:48.295
<c.magenta>两个幻灯片 九十秒</c>
<c.magenta>Peter 你能搞定吗？</c>

00:33:48.395 --> 00:33:50.397
<c.magenta>谢谢Steve</c>
<c.magenta>只需要一分钟</c>

00:33:50.664 --> 00:33:53.233
<c.magenta>另一个令我非常激动的功能</c>

00:33:53.300 --> 00:33:55.769
<c.magenta>iOS 10中CollectionView的新功能</c>

00:33:55.836 --> 00:33:57.704
<c.magenta>就是UIRefreshControl！</c>

00:33:58.038 --> 00:34:01.208
<c.magenta>就是这个！</c>
<c.magenta>UIRefreshControl现在可以直接</c>

00:33:58.038 --> 00:34:01.208
<c.magenta>就是这个！</c>
<c.magenta>UIRefreshControl现在可以直接</c>

00:34:01.275 --> 00:34:02.743
<c.magenta>在CollectionView</c>
<c.magenta>的内部支持</c>

00:34:05.779 --> 00:34:08.415
<c.magenta>但不只是如此</c>
<c.magenta>还可以直接在</c>

00:34:08.482 --> 00:34:12.452
<c.magenta>UITableView内部支持 而无需</c>
<c.magenta>使用UITableViewController！</c>

00:34:12.619 --> 00:34:16.456
<c.magenta>不只是这样 还由</c>
<c.magenta>UIScrollView内部支持</c>

00:34:16.623 --> 00:34:19.960
<c.magenta>因为RefreshControl</c>
<c.magenta>现在只是一ScrollView属性！</c>

00:34:25.565 --> 00:34:27.434
<c.magenta>非常简单易用</c>

00:34:27.835 --> 00:34:30.804
<c.magenta>你所要做的就是创建</c>
<c.magenta>RefreshControl</c>

00:34:31.438 --> 00:34:33.873
<c.magenta>把自己添加为它的一个目标</c>
<c.magenta>通过动作</c>

00:34:34.373 --> 00:34:36.043
<c.magenta>然后在CollectionView</c>
<c.magenta>上进行设置</c>

00:34:36.109 --> 00:34:38.411
<c.magenta>你将实现</c>
<c.magenta>立即刷新</c>

00:34:38.712 --> 00:34:40.080
<c.magenta>非常感谢Steve</c>
<c.magenta>这对于我来说意义重大</c>

00:34:40.147 --> 00:34:41.014
<c.magenta>嘿 做的不错</c>

00:34:41.614 --> 00:34:42.482
<c.magenta>干得好</c>

00:34:46.887 --> 00:34:48.621
<c.magenta>就像是我们今天谈话的一个总结</c>

00:34:48.688 --> 00:34:52.192
<c.magenta>我们回顾了全新的</c>
<c.magenta>UICollectionView单元格预取功能</c>

00:34:52.259 --> 00:34:55.495
<c.magenta>我们迫不及待地想看到你们</c>
<c.magenta>如何在你们的应用中进行应用</c>

00:34:56.196 --> 00:34:58.999
<c.magenta>然后我们又谈了</c>
<c.magenta>新的预取数据源API</c>

00:34:59.066 --> 00:35:00.868
<c.magenta>Collection和表视图</c>

00:34:59.066 --> 00:35:00.868
<c.magenta>Collection和表视图</c>

00:35:02.636 --> 00:35:04.972
<c.magenta>接下来 我们谈了</c>
<c.magenta>自动调整单元格的改进</c>

00:35:05.038 --> 00:35:07.241
<c.magenta>通过新的自动调整尺寸常量</c>

00:35:09.042 --> 00:35:10.043
<c.magenta>然后我们顺带谈了</c>

00:35:10.110 --> 00:35:13.046
<c.magenta>在iOS 9中引入的API</c>
<c.magenta>交互式重排序</c>

00:35:13.113 --> 00:35:15.949
<c.magenta>以及在iOS 10上的新的分页支持</c>

00:35:17.451 --> 00:35:19.386
<c.magenta>如果你想查看</c>
<c.magenta>示例代码和其他资源</c>

00:35:19.453 --> 00:35:20.921
<c.magenta>关于这个应用和这场演讲</c>

00:35:20.988 --> 00:35:23.490
<c.magenta>你可以看开发者网站上的这个地址</c>

00:35:24.992 --> 00:35:28.161
<c.magenta>我们有一些</c>
<c.magenta>与这些技术相关的不错的演讲</c>

00:35:28.495 --> 00:35:29.796
<c.magenta>我们再次感谢大家的到来</c>

00:35:29.863 --> 00:35:31.398
<c.magenta>-希望你们度过美好的——</c>
<c.magenta>-非常感谢</c>
