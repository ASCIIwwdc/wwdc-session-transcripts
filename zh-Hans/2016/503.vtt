WEBVTT

00:00:21.088 --> 00:00:21.922 align:middle
<c.magenta>早上好</c>

00:00:21.989 --> 00:00:23.790 align:middle
<c.magenta>AVFoundation回放的新进展</c>

00:00:23.857 --> 00:00:25.959 align:middle
<c.magenta>等待 循环 转换 扩展 优化</c>

00:00:27.160 --> 00:00:30.597 align:middle
<c.magenta>欢迎来到我们关于</c>
<c.magenta>AVFoundation回放新进展的会话</c>

00:00:32.366 --> 00:00:33.534 align:middle
<c.magenta>我是Sam Bushell</c>

00:00:34.501 --> 00:00:38.305 align:middle
<c.magenta>今天我们要讲一些新添加的增强功能</c>

00:00:38.372 --> 00:00:40.340 align:middle
<c.magenta>这可以使得开发者在处理</c>

00:00:40.407 --> 00:00:43.043 align:middle
<c.magenta>难题时变得更加得心应手</c>

00:00:43.744 --> 00:00:46.180 align:middle
<c.magenta>所以AVFoundation</c>
<c.magenta>提供样式广泛的API</c>

00:00:46.246 --> 00:00:47.614 align:middle
<c.magenta>用于多媒体活动</c>

00:00:47.915 --> 00:00:51.118 align:middle
<c.magenta>包括回放 拍摄 导出</c>
<c.magenta>以及多种类型的编辑</c>

00:00:51.185 --> 00:00:53.287 align:middle
<c.magenta>我的重点主要在回放上</c>

00:00:54.421 --> 00:00:57.624 align:middle
<c.magenta>AVFoundation回放</c>
<c.magenta>支持样式非常广泛的</c>

00:00:57.691 --> 00:01:01.028 align:middle
<c.magenta>存储于本地的媒体格式</c>

00:00:57.691 --> 00:01:01.028 align:middle
<c.magenta>存储于本地的媒体格式</c>

00:01:01.428 --> 00:01:03.597 align:middle
<c.magenta>在大多数情况下</c>
<c.magenta>你可以将相同的文件</c>

00:01:03.697 --> 00:01:05.199 align:middle
<c.magenta>放到一个网络服务器上</c>

00:01:05.532 --> 00:01:08.869 align:middle
<c.magenta>然后AVFoundation</c>
<c.magenta>可以通过网络播放那个文件</c>

00:01:09.203 --> 00:01:12.539 align:middle
<c.magenta>该情况下文件格式是相同的</c>
<c.magenta>不过IO是通过网络的</c>

00:01:13.273 --> 00:01:15.876 align:middle
<c.magenta>我们称之为渐进式下载回放</c>

00:01:16.910 --> 00:01:18.712 align:middle
<c.magenta>一旦我们开始下载该文件</c>

00:01:18.912 --> 00:01:21.215 align:middle
<c.magenta>即使网络特性发生变化</c>

00:01:21.281 --> 00:01:23.050 align:middle
<c.magenta>我们继续下载的还是相同文件</c>

00:01:24.251 --> 00:01:27.154 align:middle
<c.magenta>HTTP直播流更为动态</c>

00:01:27.855 --> 00:01:31.024 align:middle line:1
<c.magenta>一般来说 基URL</c>
<c.magenta>引用的是主播放列表</c>

00:01:31.592 --> 00:01:34.361 align:middle line:1
<c.magenta>这会带来相同内容的</c>
<c.magenta>多个播放列表</c>

00:01:34.428 --> 00:01:37.664 align:middle line:1
<c.magenta>但在比特率 格式</c>
<c.magenta>或是语言上会有差异</c>

00:01:39.132 --> 00:01:41.802 align:middle line:1
<c.magenta>而且每一个播放列表都引用</c>

00:01:41.869 --> 00:01:44.371 align:middle line:1
<c.magenta>含有实际压缩媒体文件的分段</c>

00:01:46.106 --> 00:01:48.075 align:middle
<c.magenta>我们来谈谈今天的话题</c>

00:01:49.142 --> 00:01:50.244 align:middle
<c.magenta>我们要讨论</c>

00:01:50.611 --> 00:01:54.081 align:middle
<c.magenta>和预回放缓冲时间</c>
<c.magenta>有关的回放变更</c>

00:01:54.715 --> 00:01:56.550 align:middle
<c.magenta>我们将推出一个新的API</c>

00:01:56.984 --> 00:01:59.253 align:middle
<c.magenta>来简化单个文件的循环播放</c>

00:01:59.853 --> 00:02:02.623 align:middle
<c.magenta>我们会讨论一些</c>
<c.magenta>在底层作出的回放改进</c>

00:01:59.853 --> 00:02:02.623 align:middle
<c.magenta>我们会讨论一些</c>
<c.magenta>在底层作出的回放改进</c>

00:02:05.492 --> 00:02:08.829 align:middle
<c.magenta>我们会讨论让你的应用程序</c>
<c.magenta>为广色域视频做好准备</c>

00:02:09.763 --> 00:02:12.499 align:middle
<c.magenta>然后我们会用余下的时间</c>
<c.magenta>讨论一个热门的话题</c>

00:02:12.566 --> 00:02:15.469 align:middle
<c.magenta>回放应用中的静态时间优化</c>

00:02:16.503 --> 00:02:19.173 align:middle
<c.magenta>我们先从等待网络开始</c>

00:02:19.239 --> 00:02:21.041 align:middle
<c.magenta>缓冲中</c>
<c.magenta>请稍等...</c>

00:02:21.141 --> 00:02:23.177 align:middle
<c.magenta>因为当我们在网上</c>
<c.magenta>进行媒体回放时</c>

00:02:23.243 --> 00:02:24.678 align:middle
<c.magenta>我们任凭网络的摆布</c>

00:02:24.745 --> 00:02:27.481 align:middle
<c.magenta>我们不想太早开始</c>
<c.magenta>否则回放会卡顿</c>

00:02:27.548 --> 00:02:29.983 align:middle
<c.magenta>我们不想太晚开始</c>
<c.magenta>否则用户会放弃观看</c>

00:02:30.417 --> 00:02:33.020 align:middle
<c.magenta>我们想在那个</c>
<c.magenta>完美时刻的开始播放</c>

00:02:33.086 --> 00:02:35.656 align:middle
<c.magenta>且在我们有足够数据时</c>
<c.magenta>开始回放 这样我们就能够</c>

00:02:35.722 --> 00:02:37.491 align:middle
<c.magenta>持续播放 没有卡顿</c>

00:02:38.392 --> 00:02:40.294 align:middle
<c.magenta>这是现有的API</c>

00:02:40.827 --> 00:02:43.797 align:middle
<c.magenta>AVPlayerItem</c>
<c.magenta>提供三个Boolean属性</c>

00:02:44.631 --> 00:02:47.401 align:middle
<c.magenta>playbackLikelyToKeepUp</c>
<c.magenta>playbackBufferFull</c>

00:02:47.467 --> 00:02:48.936 align:middle
<c.magenta>以及playbackBufferEmpty</c>

00:02:49.636 --> 00:02:53.106 align:middle
<c.magenta>playbackBuffer——抱歉——</c>
<c.magenta>playbackLikelyToKeepUp为true的</c>

00:02:53.173 --> 00:02:56.977 align:middle
<c.magenta>条件是AVFoundation算法</c>
<c.magenta>认为如果你现在停止播放</c>

00:02:57.211 --> 00:02:59.079 align:middle
<c.magenta>你就可以持续播放 没有卡顿</c>

00:02:59.146 --> 00:03:00.013 align:middle
<c.magenta>直到播放结束</c>

00:02:59.146 --> 00:03:00.013 align:middle
<c.magenta>直到播放结束</c>

00:03:00.948 --> 00:03:04.117 align:middle
<c.magenta>playbackBufferFull</c>
<c.magenta>为true的条件是缓冲</c>

00:03:04.184 --> 00:03:06.186 align:middle
<c.magenta>已经达到最大量了</c>

00:03:06.253 --> 00:03:07.821 align:middle
<c.magenta>如果你还没有开始回放</c>

00:03:07.888 --> 00:03:08.755 align:middle
<c.magenta>那就开始回放吧</c>

00:03:09.489 --> 00:03:12.092 align:middle
<c.magenta>playbackBufferEmpty</c>
<c.magenta>意味着你卡住了</c>

00:03:12.159 --> 00:03:13.327 align:middle
<c.magenta>或者即将卡住</c>

00:03:16.330 --> 00:03:19.566 align:middle
<c.magenta>对于iOS 9和更早版本中的</c>
<c.magenta>渐进式下载回放</c>

00:03:19.900 --> 00:03:23.570 align:middle
<c.magenta>AVFoundation客户端</c>
<c.magenta>必须自己监控这些属性</c>

00:03:23.937 --> 00:03:26.607 align:middle
<c.magenta>等待直到</c>
<c.magenta>playbackLikelyToKeepUp为true</c>

00:03:26.673 --> 00:03:28.842 align:middle
<c.magenta>或playbackBufferFull为true</c>

00:03:29.009 --> 00:03:31.812 align:middle
<c.magenta>之后再将AVPlayer</c>
<c.magenta>的速率属性设置为1</c>

00:03:32.913 --> 00:03:35.215 align:middle
<c.magenta>对于HTTP直播流</c>
<c.magenta>规则更加简单</c>

00:03:35.782 --> 00:03:38.218 align:middle
<c.magenta>你可立刻将AVPlayer</c>
<c.magenta>速率属性设置为1</c>

00:03:38.385 --> 00:03:40.187 align:middle
<c.magenta>当用户选择播放的时候</c>

00:03:40.487 --> 00:03:42.222 align:middle
<c.magenta>这就会自动等待</c>

00:03:42.856 --> 00:03:45.359 align:middle
<c.magenta>缓冲足够的媒体文件</c>
<c.magenta>之后再开始回放</c>

00:03:47.160 --> 00:03:49.363 align:middle
<c.magenta>我们精简了默认的API契约</c>

00:03:49.429 --> 00:03:51.899 align:middle
<c.magenta>在2016年的iOS版本中</c>

00:03:51.965 --> 00:03:54.234 align:middle
<c.magenta>iOS  Mac OS  tvOS</c>

00:03:55.002 --> 00:03:59.306 align:middle
<c.magenta>对使用iOS 10 Mac OS</c>
<c.magenta>Sierra tvOS 10及之后版本应用</c>

00:04:00.340 --> 00:04:02.543 align:middle
<c.magenta>HLS的规则也同样适用于</c>

00:04:02.609 --> 00:04:04.044 align:middle
<c.magenta>渐进式下载回放</c>

00:04:04.778 --> 00:04:06.046 align:middle
<c.magenta>当用户点击播放时</c>

00:04:06.113 --> 00:04:09.449 align:middle
<c.magenta>你可以立刻将AVPlayer</c>
<c.magenta>的速率属性设置为1</c>

00:04:09.650 --> 00:04:11.652 align:middle
<c.magenta>或调用播放方法</c>
<c.magenta>都是一样的</c>

00:04:12.452 --> 00:04:14.321 align:middle
<c.magenta>AVFoundation自动等待</c>

00:04:14.388 --> 00:04:16.190 align:middle
<c.magenta>足够多的缓冲</c>
<c.magenta>从而避免卡住</c>

00:04:17.257 --> 00:04:20.127 align:middle
<c.magenta>如果回放期间网络中断</c>
<c.magenta>然后播放卡住</c>

00:04:20.661 --> 00:04:23.497 align:middle
<c.magenta>速率属性仍将设置为1</c>

00:04:24.231 --> 00:04:26.934 align:middle
<c.magenta>所以它会再次缓冲并自动恢复</c>

00:04:27.000 --> 00:04:27.968 align:middle
<c.magenta>当有足够缓冲的时候</c>

00:04:31.271 --> 00:04:34.374 align:middle
<c.magenta>如果你使用AVKit</c>
<c.magenta>或者MediaPlayer框架</c>

00:04:34.775 --> 00:04:36.710 align:middle
<c.magenta>来呈现你的回放UI</c>

00:04:37.544 --> 00:04:40.814 align:middle
<c.magenta>它已经支持了自动缓冲等待</c>

00:04:40.881 --> 00:04:41.849 align:middle
<c.magenta>并且会继续支持</c>

00:04:42.616 --> 00:04:45.118 align:middle
<c.magenta>若你的应用</c>
<c.magenta>直接使用AVFoundation</c>

00:04:45.385 --> 00:04:46.887 align:middle
<c.magenta>然后你构建自己的回放UI</c>

00:04:47.054 --> 00:04:48.589 align:middle
<c.magenta>你可能需要做一些调整</c>

00:04:50.157 --> 00:04:51.758 align:middle
<c.magenta>所以这个新API应该叫什么？</c>

00:04:52.125 --> 00:04:56.430 align:middle
<c.magenta>Autoplay这个词</c>
<c.magenta>已经用在了QTKit中</c>

00:04:56.530 --> 00:04:59.533 align:middle
<c.magenta>和HTML 5中</c>
<c.magenta>但我们得出的结论是</c>

00:04:59.600 --> 00:05:02.803 align:middle
<c.magenta>从这个AVPlayer API</c>
<c.magenta>的角度看</c>

00:04:59.600 --> 00:05:02.803 align:middle
<c.magenta>从这个AVPlayer API</c>
<c.magenta>的角度看</c>

00:05:03.136 --> 00:05:05.439 align:middle
<c.magenta>自动的部分并不是回放</c>

00:05:05.839 --> 00:05:06.673 align:middle
<c.magenta>而是等待</c>

00:05:07.674 --> 00:05:10.077 align:middle
<c.magenta>所以这个API的正式名称是</c>

00:05:10.210 --> 00:05:12.513 align:middle
<c.magenta>automaticallyWaits</c>
<c.magenta>ToMinimizeStalling</c>

00:05:12.579 --> 00:05:14.381 align:middle
<c.magenta>但若你喜欢</c>
<c.magenta>称它为Autoplay也行</c>

00:05:16.250 --> 00:05:17.551 align:middle
<c.magenta>这个网络回放现在看起来</c>

00:05:17.618 --> 00:05:19.419 align:middle
<c.magenta>像是有三个状态的状态机</c>

00:05:20.220 --> 00:05:22.189 align:middle
<c.magenta>暂停 等待 播放</c>

00:05:23.023 --> 00:05:25.592 align:middle
<c.magenta>我们从暂停状态开始</c>
<c.magenta>直到用户选择播放</c>

00:05:25.993 --> 00:05:28.862 align:middle
<c.magenta>然后应用调用播放</c>
<c.magenta>我们就移至等待状态</c>

00:05:30.264 --> 00:05:33.133 align:middle
<c.magenta>当playbackLikelyToKeepUp</c>
<c.magenta>属性为true时</c>

00:05:33.200 --> 00:05:35.202 align:middle
<c.magenta>播放器会前进到播放状态</c>

00:05:35.936 --> 00:05:37.738 align:middle
<c.magenta>如果缓冲是空的</c>

00:05:38.438 --> 00:05:40.107 align:middle
<c.magenta>播放器会切换回等待状态</c>

00:05:40.174 --> 00:05:41.375 align:middle
<c.magenta>直到再次</c>
<c.magenta>可能跟上播放</c>

00:05:42.209 --> 00:05:45.312 align:middle
<c.magenta>如果用户暂停</c>
<c.magenta>我们会回到暂停状态</c>

00:05:45.879 --> 00:05:47.714 align:middle
<c.magenta>这里还有一个</c>
<c.magenta>可以实现的过渡</c>

00:05:48.282 --> 00:05:51.585 align:middle
<c.magenta>回想在此次更改之前的</c>
<c.magenta>iOS 9或者之前版本</c>

00:05:51.952 --> 00:05:55.055 align:middle
<c.magenta>你可以在回放可能</c>
<c.magenta>跟上之前调用播放</c>

00:05:55.289 --> 00:05:56.957 align:middle
<c.magenta>回放会立刻开始</c>

00:05:57.391 --> 00:05:58.458 align:middle
<c.magenta>即使可能会卡住</c>

00:05:58.825 --> 00:06:01.962 align:middle
<c.magenta>所以我们通过提供</c>
<c.magenta>另一种方法保留了该语义</c>

00:05:58.825 --> 00:06:01.962 align:middle
<c.magenta>所以我们通过提供</c>
<c.magenta>另一种方法保留了该语义</c>

00:06:02.162 --> 00:06:03.797 align:middle
<c.magenta>playImmediately(atRate:)</c>

00:06:03.864 --> 00:06:05.832 align:middle
<c.magenta>这可以让你直接</c>
<c.magenta>跳转到播放状态</c>

00:06:06.166 --> 00:06:08.168 align:middle
<c.magenta>从暂停状态或</c>
<c.magenta>等待状态过来</c>

00:06:09.102 --> 00:06:11.405 align:middle
<c.magenta>要注意的是</c>
<c.magenta>这可能会导致卡顿</c>

00:06:11.605 --> 00:06:14.608 align:middle
<c.magenta>而耐心的等待状态</c>
<c.magenta>会避免这种情况</c>

00:06:17.177 --> 00:06:18.011 align:middle
<c.magenta>所以要注意</c>

00:06:18.145 --> 00:06:20.147 align:middle
<c.magenta>AVPlayer的速率属性</c>
<c.magenta>可能不是</c>

00:06:20.214 --> 00:06:21.114 align:middle
<c.magenta>你所理解的意义</c>

00:06:21.448 --> 00:06:23.016 align:middle
<c.magenta>我们重述一遍</c>
<c.magenta>这样大家都清楚</c>

00:06:24.084 --> 00:06:25.385 align:middle
<c.magenta>AVPlayer的速率属性</c>

00:06:26.486 --> 00:06:28.822 align:middle
<c.magenta>是应用请求的回放速率</c>

00:06:29.423 --> 00:06:31.525 align:middle
<c.magenta>不要和AVPlayeritem的</c>

00:06:31.758 --> 00:06:32.593 align:middle
<c.magenta>时基速率相混淆</c>

00:06:32.926 --> 00:06:35.062 align:middle
<c.magenta>那是回放实际发生的速率</c>

00:06:36.630 --> 00:06:38.198 align:middle
<c.magenta>我们添加了两个新的属性在</c>

00:06:39.867 --> 00:06:42.336 align:middle
<c.magenta>此版本中</c>

00:06:43.403 --> 00:06:44.571 align:middle
<c.magenta>来给大家展示更多细节</c>

00:06:44.638 --> 00:06:46.573 align:middle
<c.magenta>一个是</c>
<c.magenta>timeControlStatus</c>

00:06:46.640 --> 00:06:48.442 align:middle
<c.magenta>这可以表达出</c>
<c.magenta>你在哪一个状态中</c>

00:06:48.575 --> 00:06:50.043 align:middle
<c.magenta>暂停 等待或是播放</c>

00:06:50.377 --> 00:06:51.879 align:middle
<c.magenta>如果你在等待状态中</c>

00:06:52.813 --> 00:06:55.883 align:middle
<c.magenta>等待播放的原因</c>
<c.magenta>属性会告诉你原因</c>

00:06:56.717 --> 00:06:59.152 align:middle
<c.magenta>例如 你可能在等待状态中</c>

00:06:59.219 --> 00:07:03.156 align:middle
<c.magenta>那AVPlayer的</c>
<c.magenta>速率属性可能是1</c>

00:06:59.219 --> 00:07:03.156 align:middle
<c.magenta>那AVPlayer的</c>
<c.magenta>速率属性可能是1</c>

00:07:04.491 --> 00:07:06.927 align:middle
<c.magenta>因为你在等待</c>
<c.magenta>所以timebase.rate会是0</c>

00:07:06.994 --> 00:07:08.595 align:middle
<c.magenta>timeControlStatus</c>
<c.magenta>会再次表达</c>

00:07:08.662 --> 00:07:10.364 align:middle
<c.magenta>我在等待以特定速率进行播放</c>

00:07:10.797 --> 00:07:14.134 align:middle
<c.magenta>然后等待播放的原因</c>
<c.magenta>可能是为减少卡顿而等待</c>

00:07:15.469 --> 00:07:16.603 align:middle
<c.magenta>所以凭借这些背景知识</c>

00:07:16.670 --> 00:07:18.872 align:middle
<c.magenta>我想介绍我的朋友</c>
<c.magenta>Moritz Wittenhagen</c>

00:07:18.939 --> 00:07:20.140 align:middle
<c.magenta>他比我更加大胆</c>

00:07:20.274 --> 00:07:21.441 align:middle
<c.magenta>因为他要尝试</c>

00:07:21.608 --> 00:07:24.778 align:middle
<c.magenta>在台上进行</c>
<c.magenta>现场网络回放演示</c>

00:07:24.845 --> 00:07:26.446 align:middle
<c.magenta>所以各位祝他好运</c>
<c.magenta>给他一些掌声</c>

00:07:31.051 --> 00:07:32.452 align:middle
<c.magenta>各位早上好</c>

00:07:34.254 --> 00:07:35.923 align:middle
<c.magenta>我想先开始展示一下</c>

00:07:36.290 --> 00:07:37.824 align:middle
<c.magenta>我们在台上有的设备</c>

00:07:38.125 --> 00:07:39.293 align:middle
<c.magenta>这是我的iPad</c>

00:07:39.560 --> 00:07:41.328 align:middle
<c.magenta>你能看到</c>
<c.magenta>这在屏幕上同步显示着</c>

00:07:41.895 --> 00:07:44.031 align:middle
<c.magenta>那个iPad正在加入一个</c>

00:07:44.097 --> 00:07:45.265 align:middle
<c.magenta>由Mac搭建的网络</c>

00:07:46.099 --> 00:07:49.336 align:middle
<c.magenta>这可以让我使用</c>
<c.magenta>网络连接调节器</c>

00:07:49.403 --> 00:07:51.605 align:middle
<c.magenta>来限制网络连接</c>

00:07:51.672 --> 00:07:53.106 align:middle
<c.magenta>用于这个iPad的</c>

00:07:53.774 --> 00:07:55.475 align:middle
<c.magenta>这可以使用</c>
<c.magenta>网络连接调节器的</c>

00:07:55.542 --> 00:07:56.376 align:middle
<c.magenta>偏好面板做到</c>

00:07:56.677 --> 00:07:58.579 align:middle
<c.magenta>Sam一会儿</c>
<c.magenta>会告诉你去哪里去找</c>

00:07:59.112 --> 00:08:01.415 align:middle
<c.magenta>我设置了</c>
<c.magenta>Slow Server配置文件</c>

00:07:59.112 --> 00:08:01.415 align:middle
<c.magenta>我设置了</c>
<c.magenta>Slow Server配置文件</c>

00:08:01.748 --> 00:08:04.785 align:middle
<c.magenta>这会将其限制成一般的网络连接</c>

00:08:04.885 --> 00:08:06.253 align:middle
<c.magenta>这稍微慢于</c>

00:08:06.787 --> 00:08:08.589 align:middle
<c.magenta>我们想要播放的</c>
<c.magenta>媒体比特率</c>

00:08:09.389 --> 00:08:10.290 align:middle
<c.magenta>目前这是关闭的</c>

00:08:11.391 --> 00:08:14.161 align:middle
<c.magenta>我们先不开启它</c>
<c.magenta>然后来看看iPad在</c>

00:08:14.728 --> 00:08:16.263 align:middle
<c.magenta>优质网络条件下的性能</c>

00:08:17.431 --> 00:08:19.967 align:middle
<c.magenta>所以我这里有的只是一个选集</c>

00:08:20.033 --> 00:08:21.768 align:middle
<c.magenta>我可以选择一个视频</c>

00:08:21.935 --> 00:08:22.803 align:middle
<c.magenta>我开始选择</c>

00:08:23.036 --> 00:08:26.306 align:middle
<c.magenta>你看到的是</c>
<c.magenta>视频马上就加载上了</c>

00:08:26.573 --> 00:08:32.011 align:middle
<c.magenta>我们看到</c>
<c.magenta>目前没在播放</c>

00:08:32.346 --> 00:08:34.581 align:middle
<c.magenta>你看看这下面</c>
<c.magenta>极好的工程UI</c>

00:08:34.648 --> 00:08:37.351 align:middle
<c.magenta>告诉我们所有的属性</c>

00:08:37.417 --> 00:08:39.520 align:middle
<c.magenta>以及功能</c>
<c.magenta>这都和自动等待有关</c>

00:08:39.953 --> 00:08:43.289 align:middle
<c.magenta>这真的是从AVPlayer</c>
<c.magenta>和AVPlayeritem中获取的</c>

00:08:43.357 --> 00:08:47.327 align:middle
<c.magenta>所以有这些属性可供你使用</c>
<c.magenta>如果你需要知道</c>

00:08:47.427 --> 00:08:48.729 align:middle
<c.magenta>自动等待在做什么的话</c>

00:08:49.329 --> 00:08:51.765 align:middle
<c.magenta>因为现在我们暂停了</c>
<c.magenta>所以这些速率都是0</c>

00:08:51.832 --> 00:08:52.766 align:middle
<c.magenta>当前时间是0</c>

00:08:52.833 --> 00:08:56.370 align:middle
<c.magenta>但有意思的是</c>
<c.magenta>因为我们在快速的网络中</c>

00:08:56.436 --> 00:08:58.472 align:middle
<c.magenta>我们加载了39秒的视频</c>

00:08:58.539 --> 00:08:59.773 align:middle
<c.magenta>这实际上就是整个视频</c>

00:08:59.840 --> 00:09:02.309 align:middle
<c.magenta>然后我们目前</c>
<c.magenta>可能跟上回放</c>

00:08:59.840 --> 00:09:02.309 align:middle
<c.magenta>然后我们目前</c>
<c.magenta>可能跟上回放</c>

00:09:03.043 --> 00:09:06.046 align:middle
<c.magenta>这意味着</c>
<c.magenta>当我现在点击播放</c>

00:09:06.513 --> 00:09:09.750 align:middle
<c.magenta>视频就会开始播放</c>
<c.magenta>没有任何问题</c>

00:09:10.884 --> 00:09:14.755 align:middle
<c.magenta>现在我们想看看</c>
<c.magenta>在差的网络条件下会怎么样</c>

00:09:14.821 --> 00:09:17.457 align:middle
<c.magenta>所以我们启用Mac</c>
<c.magenta>上的网络连接调节器</c>

00:09:18.592 --> 00:09:19.426 align:middle
<c.magenta>好了</c>

00:09:19.660 --> 00:09:21.995 align:middle
<c.magenta>对这个视频没什么差别</c>

00:09:22.062 --> 00:09:26.333 align:middle
<c.magenta>因为如我所说整个视频已经缓冲完毕了</c>

00:09:26.967 --> 00:09:29.803 align:middle
<c.magenta>所以当我回去再次加载它</c>

00:09:29.870 --> 00:09:32.239 align:middle
<c.magenta>我想让大家重新注意</c>
<c.magenta>loadedTimeRanges</c>

00:09:32.306 --> 00:09:34.374 align:middle
<c.magenta>和isPlaybackLikely</c>
<c.magenta>ToKeepUp</c>

00:09:34.741 --> 00:09:35.576 align:middle
<c.magenta>所以开始吧</c>

00:09:36.543 --> 00:09:37.444 align:middle
<c.magenta>重新加载视频</c>

00:09:38.111 --> 00:09:39.680 align:middle
<c.magenta>现在我们看到的是</c>

00:09:39.746 --> 00:09:42.516 align:middle
<c.magenta>loadedTimeRange</c>
<c.magenta>只是缓慢地增加</c>

00:09:42.583 --> 00:09:45.152 align:middle
<c.magenta>isPlaybackLikely</c>
<c.magenta>ToKeepUp 为false</c>

00:09:46.086 --> 00:09:47.654 align:middle
<c.magenta>但终究会变成true</c>

00:09:47.988 --> 00:09:50.791 align:middle
<c.magenta>在那一时刻我们</c>
<c.magenta>处在了和之前相同的状态</c>

00:09:50.858 --> 00:09:54.361 align:middle
<c.magenta>现在准备播放</c>
<c.magenta>然后回放就会开始</c>

00:09:55.262 --> 00:09:57.564 align:middle
<c.magenta>现在我们再试一次</c>

00:09:57.631 --> 00:10:00.534 align:middle
<c.magenta>这一次我会在视频加载好</c>
<c.magenta>之后马上点击播放</c>

00:09:57.631 --> 00:10:00.534 align:middle
<c.magenta>这一次我会在视频加载好</c>
<c.magenta>之后马上点击播放</c>

00:10:00.934 --> 00:10:04.071 align:middle
<c.magenta>所以这一次</c>
<c.magenta>我们没有足够的数据</c>

00:10:04.137 --> 00:10:05.472 align:middle
<c.magenta>然后就进入了这个等待状态</c>

00:10:05.539 --> 00:10:08.809 align:middle
<c.magenta>你看到这个转动图标</c>
<c.magenta>告诉用户在等待回放</c>

00:10:08.876 --> 00:10:11.979 align:middle
<c.magenta>最终这会成为准备播放</c>
<c.magenta>然后回放就会开始</c>

00:10:12.880 --> 00:10:16.049 align:middle
<c.magenta>还有一件事我们可以做</c>
<c.magenta>那就是立刻回放</c>

00:10:16.183 --> 00:10:17.284 align:middle
<c.magenta>我们也试一下</c>

00:10:19.286 --> 00:10:22.623 align:middle
<c.magenta>我进入这个视频</c>
<c.magenta>马上点击立刻播放</c>

00:10:22.890 --> 00:10:26.360 align:middle
<c.magenta>我们看到回放开始了</c>
<c.magenta>不过之后很快就卡住了</c>

00:10:26.426 --> 00:10:29.129 align:middle
<c.magenta>因为我们没有足够的缓冲</c>
<c.magenta>来将视频播完</c>

00:10:29.296 --> 00:10:31.899 align:middle
<c.magenta>这种情况下</c>
<c.magenta>我们会进入等待状态</c>

00:10:31.965 --> 00:10:36.303 align:middle
<c.magenta>直到重新缓冲出</c>
<c.magenta>足够的数据播到最后</c>

00:10:37.037 --> 00:10:39.840 align:middle
<c.magenta>以上就是自动等待的简短演示</c>

00:10:40.641 --> 00:10:41.842 align:middle
<c.magenta>回到Sam和幻灯片上</c>

00:10:48.448 --> 00:10:49.383 align:middle
<c.magenta>谢谢 Moritz</c>

00:10:49.750 --> 00:10:51.485 align:middle
<c.magenta>我们回顾一下</c>
<c.magenta>中间发生了什么</c>

00:10:52.152 --> 00:10:54.655 align:middle
<c.magenta>当我们设置了</c>
<c.magenta>更缓慢的网络速度</c>

00:10:54.755 --> 00:10:56.023 align:middle
<c.magenta>接近那部电影的数据速率</c>

00:10:57.090 --> 00:10:58.625 align:middle
<c.magenta>电影一开始是暂停的</c>

00:10:59.293 --> 00:11:00.394 align:middle
<c.magenta>当他点击播放</c>

00:10:59.293 --> 00:11:00.394 align:middle
<c.magenta>当他点击播放</c>

00:11:02.029 --> 00:11:03.263 align:middle
<c.magenta>这就进入等待状态</c>

00:11:04.631 --> 00:11:07.467 align:middle
<c.magenta>因为目前回放不可能跟上</c>

00:11:08.402 --> 00:11:11.271 align:middle
<c.magenta>注意到这个时候</c>
<c.magenta>播放器的速率是1</c>

00:11:11.338 --> 00:11:12.773 align:middle
<c.magenta>但时基速率是0</c>

00:11:13.807 --> 00:11:16.677 align:middle
<c.magenta>几秒钟之后</c>
<c.magenta>AVFoundation断定</c>

00:11:17.477 --> 00:11:18.745 align:middle
<c.magenta>回放有可能跟上</c>

00:11:19.680 --> 00:11:21.982 align:middle
<c.magenta>所以它将时间控制--</c>

00:11:22.449 --> 00:11:26.119 align:middle
<c.magenta>它将状态设置成播放</c>
<c.magenta>然后现在你看到</c>

00:11:26.186 --> 00:11:28.422 align:middle
<c.magenta>播放器速率和时基速率都是1</c>

00:11:31.258 --> 00:11:32.092 align:middle
<c.magenta>你可能会想到</c>

00:11:32.159 --> 00:11:34.027 align:middle
<c.magenta>有更多一点的细节存在于</c>

00:11:34.094 --> 00:11:36.897 align:middle
<c.magenta>timeControlStatus</c>
<c.magenta>而非播放器速率属性中</c>

00:11:37.197 --> 00:11:39.499 align:middle
<c.magenta>记住播放器速率告诉你的是应用</c>

00:11:39.566 --> 00:11:40.701 align:middle
<c.magenta>所求的回放速率</c>

00:11:40.767 --> 00:11:42.336 align:middle
<c.magenta>timeControlStatus</c>

00:11:42.402 --> 00:11:43.670 align:middle
<c.magenta>还考虑到实际发生的事情</c>

00:11:44.071 --> 00:11:45.772 align:middle
<c.magenta>所以这些东西</c>
<c.magenta>你可能要考虑周全</c>

00:11:45.839 --> 00:11:46.807 align:middle
<c.magenta>当你构建回放UI时</c>

00:11:48.475 --> 00:11:49.776 align:middle
<c.magenta>假如你想在家中尝试</c>

00:11:50.210 --> 00:11:52.646 align:middle
<c.magenta>你可能要知道如何找到</c>
<c.magenta>网络连接调节器</c>

00:11:52.713 --> 00:11:55.516 align:middle
<c.magenta>这不是我们发明的东西</c>
<c.magenta>至少不是我们团队</c>

00:11:55.949 --> 00:11:59.820 align:middle
<c.magenta>这是硬件IO工具下载的一部分</c>

00:12:00.320 --> 00:12:03.390 align:middle
<c.magenta>最简单的获取方法是</c>
<c.magenta>顺着Xcode菜单</c>

00:12:03.457 --> 00:12:04.858 align:middle
<c.magenta>找到更多开发者工具</c>

00:12:05.459 --> 00:12:07.761 align:middle
<c.magenta>登陆后</c>
<c.magenta>你就会在这里找到</c>

00:12:09.062 --> 00:12:10.731 align:middle
<c.magenta>好了 所以</c>

00:12:11.532 --> 00:12:15.669 align:middle
<c.magenta>如果你使用</c>
<c.magenta>2016 SDK或之后的版本</c>

00:12:16.203 --> 00:12:19.006 align:middle
<c.magenta>你的应用就会</c>
<c.magenta>表现出这样的属性设置</c>

00:12:19.106 --> 00:12:21.775 align:middle
<c.magenta>自动将WaitsToMinimizeStalling</c>
<c.magenta>设置为true</c>

00:12:21.842 --> 00:12:23.544 align:middle
<c.magenta>你可以将那个属性设成false</c>

00:12:24.311 --> 00:12:25.812 align:middle
<c.magenta>如果你想回到之前的行为</c>

00:12:25.913 --> 00:12:27.581 align:middle
<c.magenta>你这么做可能会有这几个原因</c>

00:12:27.881 --> 00:12:33.287 align:middle
<c.magenta>具体说 如果你想使用</c>
<c.magenta>setRate(time atHostTime)的调用</c>

00:12:33.554 --> 00:12:36.290 align:middle
<c.magenta>来用外部时间轴</c>
<c.magenta>同步回放</c>

00:12:36.823 --> 00:12:39.359 align:middle
<c.magenta>那你必须选择性退出</c>
<c.magenta>做法是自动将</c>

00:12:39.426 --> 00:12:41.662 align:middle
<c.magenta>WaitsToMinimizeStalling</c>
<c.magenta>属性设置为false</c>

00:12:41.728 --> 00:12:43.564 align:middle
<c.magenta>否则 你会遇到友好异常</c>

00:12:44.364 --> 00:12:45.199 align:middle
<c.magenta>很有帮助的提醒</c>

00:12:46.767 --> 00:12:49.770 align:middle
<c.magenta>最后 提醒一下</c>
<c.magenta>绝对不要使用播放器速率</c>

00:12:49.837 --> 00:12:51.905 align:middle
<c.magenta>来推断将来的当前超时</c>

00:12:52.439 --> 00:12:54.908 align:middle
<c.magenta>如果你想那么做</c>
<c.magenta>那使用项目的时基速率</c>

00:12:54.975 --> 00:12:55.809 align:middle
<c.magenta>来代替它</c>

00:12:56.043 --> 00:12:57.678 align:middle
<c.magenta>或使用时基对象中的其他API</c>

00:12:57.744 --> 00:12:58.645 align:middle
<c.magenta>那是它们的专长</c>

00:12:59.279 --> 00:13:00.781 align:middle
<c.magenta>好了 这就是缓冲的内容</c>

00:12:59.279 --> 00:13:00.781 align:middle
<c.magenta>好了 这就是缓冲的内容</c>

00:13:01.048 --> 00:13:02.583 align:middle
<c.magenta>我们前进到循环的话题</c>

00:13:02.983 --> 00:13:03.984 align:middle
<c.magenta>我问大家一个问题</c>

00:13:04.852 --> 00:13:07.421 align:middle
<c.magenta>什么是循环单一项目的最佳方法</c>

00:13:07.955 --> 00:13:09.590 align:middle
<c.magenta>一个想法是设置监听器来</c>

00:13:09.656 --> 00:13:11.058 align:middle
<c.magenta>监听发出的通知</c>

00:13:11.258 --> 00:13:12.626 align:middle
<c.magenta>当回放抵达结尾的时候</c>

00:13:12.926 --> 00:13:13.861 align:middle
<c.magenta>当被调用的时候</c>

00:13:14.261 --> 00:13:16.163 align:middle
<c.magenta>找回到开头 然后重新开始</c>

00:13:16.830 --> 00:13:18.899 align:middle
<c.magenta>这个想法挺不错的</c>

00:13:19.166 --> 00:13:21.134 align:middle
<c.magenta>但不幸的是这会导致空白</c>

00:13:21.201 --> 00:13:22.870 align:middle
<c.magenta>在两次回放之间</c>
<c.magenta>原因有两个</c>

00:13:23.403 --> 00:13:25.138 align:middle
<c.magenta>第一个原因是这会有延迟</c>

00:13:25.372 --> 00:13:27.174 align:middle
<c.magenta>这是由于通知发出</c>

00:13:27.241 --> 00:13:30.444 align:middle
<c.magenta>并送达到程序的时间</c>
<c.magenta>以及第二次播放器请求</c>

00:13:30.511 --> 00:13:31.912 align:middle
<c.magenta>返回到回放系统的时间</c>

00:13:32.713 --> 00:13:35.749 align:middle
<c.magenta>第二个更为显著的原因是预滚</c>

00:13:35.916 --> 00:13:36.850 align:middle
<c.magenta>所需的时间</c>

00:13:37.551 --> 00:13:38.452 align:middle
<c.magenta>你是不可能</c>

00:13:38.519 --> 00:13:40.921 align:middle
<c.magenta>立刻进行媒体回放的</c>

00:13:40.988 --> 00:13:41.955 align:middle
<c.magenta>如果没有一些准备</c>

00:13:42.389 --> 00:13:45.926 align:middle
<c.magenta>有必要先加载媒体数据并解码一些数据</c>

00:13:46.126 --> 00:13:47.694 align:middle
<c.magenta>之后你才能开始播放出来</c>

00:13:48.262 --> 00:13:50.764 align:middle
<c.magenta>这个先补充回放管道</c>

00:13:50.998 --> 00:13:53.267 align:middle
<c.magenta>再开始回放的过程叫做预滚</c>

00:13:54.668 --> 00:13:57.171 align:middle
<c.magenta>所以我们想在这里做的是</c>

00:13:57.571 --> 00:14:00.140 align:middle
<c.magenta>将AVFoundation</c>
<c.magenta>参与到该计划中</c>

00:13:57.571 --> 00:14:00.140 align:middle
<c.magenta>将AVFoundation</c>
<c.magenta>参与到该计划中</c>

00:14:00.807 --> 00:14:03.610 align:middle
<c.magenta>如果AVFoundation</c>
<c.magenta>对回放项目B</c>

00:14:03.877 --> 00:14:07.281 align:middle
<c.magenta>足够提前获悉</c>
<c.magenta>那这就可以开始预滚</c>

00:14:07.447 --> 00:14:10.450 align:middle
<c.magenta>然后解码</c>
<c.magenta>在项目A播完前进行</c>

00:14:10.717 --> 00:14:13.187 align:middle
<c.magenta>所以这就能优化A到B的过渡了</c>

00:14:14.121 --> 00:14:17.991 align:middle
<c.magenta>如果项目B十分短</c>
<c.magenta>那AVFoundation甚至可以开始</c>

00:14:18.058 --> 00:14:19.459 align:middle
<c.magenta>进行到项目C的过渡</c>

00:14:20.994 --> 00:14:24.598 align:middle
<c.magenta>实现该目的AVFoundation</c>
<c.magenta>工具就是AVQueuePlayer</c>

00:14:25.332 --> 00:14:28.802 align:middle
<c.magenta>AVQueuePlayer是</c>
<c.magenta>AVPlayer的子类 拥有一排的</c>

00:14:28.869 --> 00:14:30.838 align:middle
<c.magenta>AVPlayer项目 叫做播放队列</c>

00:14:31.538 --> 00:14:34.575 align:middle
<c.magenta>当前项目排在列阵的第一位</c>

00:14:36.043 --> 00:14:38.245 align:middle
<c.magenta>用AVQueuePlayer</c>

00:14:38.312 --> 00:14:39.446 align:middle
<c.magenta>优化不同项目间的过渡</c>

00:14:39.847 --> 00:14:43.050 align:middle
<c.magenta>但在循环的情况下</c>
<c.magenta>你可以创建多个AVPlayer项目</c>

00:14:43.116 --> 00:14:44.651 align:middle
<c.magenta>从同样的AVAsset上面</c>

00:14:45.018 --> 00:14:46.486 align:middle
<c.magenta>这是另一种优化</c>

00:14:46.820 --> 00:14:48.689 align:middle
<c.magenta>AVFoundation无需加载</c>

00:14:48.755 --> 00:14:51.124 align:middle
<c.magenta>并多次暂停媒体文件</c>

00:14:53.627 --> 00:14:56.530 align:middle
<c.magenta>提醒一下 播放列队不是播放列表</c>

00:14:57.130 --> 00:14:59.733 align:middle
<c.magenta>请别加载接下来的10,000个项目</c>

00:14:59.800 --> 00:15:02.369 align:middle
<c.magenta>你认为你可能会在播放列队中播放</c>

00:14:59.800 --> 00:15:02.369 align:middle
<c.magenta>你认为你可能会在播放列队中播放</c>

00:15:02.436 --> 00:15:03.504 align:middle
<c.magenta>这并不高效</c>

00:15:03.904 --> 00:15:06.373 align:middle
<c.magenta>播放列队的目的是提供关于</c>

00:15:06.440 --> 00:15:08.308 align:middle
<c.magenta>将要播放项目的信息</c>

00:15:08.375 --> 00:15:11.411 align:middle
<c.magenta>这样AVFoundation</c>
<c.magenta>可以优化过渡</c>

00:15:13.747 --> 00:15:15.315 align:middle
<c.magenta>这种设计模式是当你想无限循环</c>

00:15:15.449 --> 00:15:17.150 align:middle
<c.magenta>单个媒体文件的话</c>

00:15:17.518 --> 00:15:19.953 align:middle
<c.magenta>要制作少量的</c>
<c.magenta>AVPlayer项目</c>

00:15:20.120 --> 00:15:22.189 align:middle
<c.magenta>然后将它们放在</c>
<c.magenta>AVQueuePlayer列队中</c>

00:15:22.256 --> 00:15:25.058 align:middle
<c.magenta>并将行动项和属性设置成提前</c>

00:15:26.560 --> 00:15:28.495 align:middle
<c.magenta>当回放达到一个项目的结尾时</c>

00:15:29.096 --> 00:15:32.599 align:middle
<c.magenta>随着回放前进到下一个</c>
<c.magenta>它会从播放列队中移除</c>

00:15:33.433 --> 00:15:35.402 align:middle
<c.magenta>当你得到完成过渡的通知时</c>

00:15:35.702 --> 00:15:36.970 align:middle
<c.magenta>你可将那个播放完的项目</c>

00:15:37.304 --> 00:15:38.872 align:middle
<c.magenta>将其当前时间设置回开头</c>

00:15:39.139 --> 00:15:41.608 align:middle
<c.magenta>然后将其放在播放列队的最后重新播放</c>

00:15:42.643 --> 00:15:44.278 align:middle
<c.magenta>我们将这种</c>
<c.magenta>模式叫做跑步机</c>

00:15:45.913 --> 00:15:48.081 align:middle
<c.magenta>而且你可以自己</c>
<c.magenta>实施这个跑步机模式</c>

00:15:48.148 --> 00:15:49.149 align:middle
<c.magenta>使用AVQueuePlayer</c>

00:15:49.216 --> 00:15:50.517 align:middle
<c.magenta>我们有示例代码来帮助大家</c>

00:15:51.051 --> 00:15:54.221 align:middle
<c.magenta>稍微难的一点是</c>
<c.magenta>你必须设置键值观察</c>

00:15:54.988 --> 00:15:56.523 align:middle
<c.magenta>来查看项目何时被移除的</c>

00:15:56.857 --> 00:15:58.225 align:middle
<c.magenta>然后将其找回到开头</c>

00:16:00.460 --> 00:16:01.862 align:middle
<c.magenta>然后又出现在播放列队最后</c>

00:16:02.963 --> 00:16:04.932 align:middle
<c.magenta>如你所见 在这个代码中</c>

00:16:05.065 --> 00:16:07.301 align:middle
<c.magenta>我们停用了KVO观察者</c>

00:16:07.701 --> 00:16:08.869 align:middle
<c.magenta>当我们改变播放列队时</c>

00:16:09.203 --> 00:16:10.637 align:middle
<c.magenta>来避免任何递归的可能</c>

00:16:11.338 --> 00:16:12.639 align:middle
<c.magenta>所以很明显这是可能的</c>

00:16:12.706 --> 00:16:13.974 align:middle
<c.magenta>只是有一点复制</c>

00:16:14.942 --> 00:16:16.143 align:middle
<c.magenta>而且我们收到的反馈是</c>

00:16:16.210 --> 00:16:18.712 align:middle
<c.magenta>如果我们能将其变得更简单</c>
<c.magenta>那就再好不过了</c>

00:16:20.881 --> 00:16:22.983 align:middle
<c.magenta>我们推出</c>
<c.magenta>AVPlayerLooper</c>

00:16:23.116 --> 00:16:24.818 align:middle
<c.magenta>这会替你实现跑步机模式</c>

00:16:25.219 --> 00:16:27.054 align:middle
<c.magenta>你给它一个</c>
<c.magenta>AVQueuePlayer</c>

00:16:30.624 --> 00:16:33.794 align:middle
<c.magenta>你给它一个AVQueuePlayer</c>
<c.magenta>和一个模板AVPlayerItem</c>

00:16:33.861 --> 00:16:36.463 align:middle
<c.magenta>然后它构建少量</c>
<c.magenta>AVPlayerItem的副本</c>

00:16:36.697 --> 00:16:38.232 align:middle
<c.magenta>这之后会在播放列队中循环</c>

00:16:38.298 --> 00:16:39.366 align:middle
<c.magenta>直到你告诉它停止</c>

00:16:41.668 --> 00:16:43.470 align:middle
<c.magenta>将AVPlayerLooper采用于</c>

00:16:43.537 --> 00:16:45.873 align:middle
<c.magenta>符号案例中的代码就变得更加容易了</c>

00:16:47.307 --> 00:16:48.609 align:middle
<c.magenta>所以我想给大家演示一下</c>

00:16:49.276 --> 00:16:50.544 align:middle
<c.magenta>在这里的iPad上面</c>

00:16:51.011 --> 00:16:52.579 align:middle
<c.magenta>所以这是一段示例代码</c>

00:16:52.980 --> 00:16:54.581 align:middle
<c.magenta>启动Video Looper</c>

00:16:54.948 --> 00:16:57.217 align:middle
<c.magenta>我在这里添加了我自己的一个媒体文件</c>

00:16:57.451 --> 00:16:59.486 align:middle
<c.magenta>然后我们将用</c>
<c.magenta>AVPlayerLooper来播放</c>

00:17:07.928 --> 00:17:08.929 align:middle
<c.magenta>感觉是不是很柔和？</c>

00:17:11.431 --> 00:17:12.566 align:middle
<c.magenta>好了 这很明显在循环</c>

00:17:12.633 --> 00:17:15.234 align:middle
<c.magenta>代码如我指出的那样</c>

00:17:15.301 --> 00:17:16.236 align:middle
<c.magenta>非常简单</c>

00:17:16.737 --> 00:17:19.406 align:middle
<c.magenta>这种工具适合用于 例如</c>

00:17:19.740 --> 00:17:21.074 align:middle
<c.magenta>如果你有一个tvOS应用</c>

00:17:21.441 --> 00:17:24.310 align:middle
<c.magenta>而且你想在标题菜单</c>
<c.magenta>后面放上循环的背景视频</c>

00:17:27.114 --> 00:17:28.949 align:middle
<c.magenta>好了 我们回到幻灯片</c>

00:17:30.150 --> 00:17:33.053 align:middle
<c.magenta>演示AVPLAYERLOOPER</c>

00:17:34.588 --> 00:17:37.024 align:middle
<c.magenta>我们讲了讲如何循环</c>

00:17:37.691 --> 00:17:39.593 align:middle
<c.magenta>我想花点时间讲讲循环什么</c>

00:17:42.930 --> 00:17:45.632 align:middle
<c.magenta>理想来说 如果你有音频轨和视频轨</c>

00:17:45.966 --> 00:17:47.568 align:middle
<c.magenta>它们的长度应该精确相同</c>

00:17:48.035 --> 00:17:52.306 align:middle
<c.magenta>为什么？如果音频轨更长 那这意味着</c>

00:17:52.372 --> 00:17:54.174 align:middle
<c.magenta>在接近结尾的时候 那一段</c>

00:17:54.241 --> 00:17:56.510 align:middle
<c.magenta>音频应该播放的时间 视频却没在播放</c>

00:17:57.411 --> 00:17:59.112 align:middle
<c.magenta>我们有一段空白的视频</c>

00:17:59.179 --> 00:18:00.480 align:middle
<c.magenta>所以视频应该怎么办？</c>

00:17:59.179 --> 00:18:00.480 align:middle
<c.magenta>所以视频应该怎么办？</c>

00:18:00.547 --> 00:18:01.648 align:middle
<c.magenta>应该关闭吗？</c>

00:18:01.748 --> 00:18:03.250 align:middle
<c.magenta>应该停在一帧上吗？</c>

00:18:04.151 --> 00:18:06.186 align:middle
<c.magenta>相反如果视频轨更长</c>

00:18:06.353 --> 00:18:09.323 align:middle
<c.magenta>那就会有一段没有音频的时间</c>

00:18:09.857 --> 00:18:12.659 align:middle
<c.magenta>所以当你创建用于循环的媒体资源时</c>

00:18:12.926 --> 00:18:15.529 align:middle
<c.magenta>要花时间确认轨道时长互相匹配</c>

00:18:15.596 --> 00:18:16.864 align:middle
<c.magenta>在QuickTime电影文件中</c>

00:18:16.930 --> 00:18:19.099 align:middle
<c.magenta>轨道时长是由编辑列表所定义的</c>

00:18:20.734 --> 00:18:23.537 align:middle
<c.magenta>如果用于循环的媒体资源</c>
<c.magenta>并非完全处在你的控制之下</c>

00:18:23.604 --> 00:18:24.705 align:middle
<c.magenta>另一种可能是</c>

00:18:24.771 --> 00:18:28.008 align:middle
<c.magenta>你可以将AVPlayerItem的</c>
<c.magenta>正向回放结束时间设置成</c>

00:18:28.075 --> 00:18:30.177 align:middle
<c.magenta>最短轨道的长度</c>

00:18:30.644 --> 00:18:33.247 align:middle
<c.magenta>从而调短另一个轨道</c>
<c.magenta>来实现匹配</c>

00:18:36.049 --> 00:18:38.952 align:middle
<c.magenta>好了 接下来看看我们在</c>

00:18:39.019 --> 00:18:40.287 align:middle
<c.magenta>回放管道中做的优化</c>

00:18:40.354 --> 00:18:42.589 align:middle
<c.magenta>这可能会影响到你的应用程序</c>

00:18:43.624 --> 00:18:45.592 align:middle
<c.magenta>假设我们当前正在播放中</c>

00:18:45.993 --> 00:18:48.462 align:middle
<c.magenta>然后播放中的轨道列表发生改变</c>

00:18:49.897 --> 00:18:52.799 align:middle
<c.magenta>例如 我们能更改字幕语言</c>

00:18:53.066 --> 00:18:54.168 align:middle
<c.magenta>或者音频语言</c>

00:18:54.601 --> 00:18:56.069 align:middle
<c.magenta>将音频从英语换成法语</c>

00:18:56.370 --> 00:18:59.139 align:middle
<c.magenta>我会将字幕语言从英语换成西班牙语</c>

00:19:00.374 --> 00:19:03.710 align:middle
<c.magenta>或者我们可以移除正在显示</c>
<c.magenta>视频的AVPlayerLayer</c>

00:19:05.646 --> 00:19:08.916 align:middle
<c.magenta>或添加AVPlayerLayer</c>
<c.magenta>开始显示视频</c>

00:19:11.852 --> 00:19:13.720 align:middle
<c.magenta>在iOS 9中的所有这些情况里</c>

00:19:13.954 --> 00:19:16.223 align:middle
<c.magenta>AVFoundation会暂停回放</c>

00:19:16.423 --> 00:19:19.626 align:middle
<c.magenta>调整回放管道来匹配启用的轨道列表</c>

00:19:19.793 --> 00:19:20.961 align:middle
<c.magenta>然后恢复回放</c>

00:19:21.361 --> 00:19:23.463 align:middle
<c.magenta>在一些情况中 这甚至会导致视频</c>

00:19:23.530 --> 00:19:24.831 align:middle
<c.magenta>回跳到一个关键帧上</c>

00:19:25.299 --> 00:19:28.669 align:middle
<c.magenta>我要说我们收到了有建设性的反馈</c>

00:19:28.735 --> 00:19:30.404 align:middle
<c.magenta>都来自用户和开发者</c>

00:19:31.638 --> 00:19:33.407 align:middle
<c.magenta>所以我很高兴地宣布</c>

00:19:34.608 --> 00:19:38.745 align:middle
<c.magenta>在iOS 10和</c>
<c.magenta>其他2016年的姊妹系统中</c>

00:19:38.946 --> 00:19:41.949 align:middle
<c.magenta>这些改变不会再导致回放暂停</c>

00:19:42.249 --> 00:19:46.253 align:middle
<c.magenta>在播放中的AVPlayer上添加或</c>
<c.magenta>移除唯一AVPlayerLayer</c>

00:19:46.587 --> 00:19:47.855 align:middle
<c.magenta>改变字幕语言</c>

00:19:47.921 --> 00:19:50.123 align:middle
<c.magenta>或改变播放中</c>
<c.magenta>AVPlayer的音频语言</c>

00:19:50.290 --> 00:19:52.392 align:middle
<c.magenta>或者手动停用或启用轨道</c>

00:19:54.928 --> 00:19:57.731 align:middle
<c.magenta>我们认为这对用户和</c>
<c.magenta>开发者来说是一种提升</c>

00:19:57.798 --> 00:20:00.801 align:middle
<c.magenta>然而 这显著地改变了API的行为</c>

00:19:57.798 --> 00:20:00.801 align:middle
<c.magenta>然而 这显著地改变了API的行为</c>

00:20:00.901 --> 00:20:05.405 align:middle
<c.magenta>所以我请各位在</c>
<c.magenta>seed版本中查看一下</c>

00:20:06.006 --> 00:20:08.642 align:middle
<c.magenta>看看这是否会在</c>
<c.magenta>应用中导致任何复杂问题</c>

00:20:08.976 --> 00:20:12.012 align:middle
<c.magenta>如果你发现了一个问题</c>
<c.magenta>像是我们这边出的错误</c>

00:20:12.246 --> 00:20:13.347 align:middle
<c.magenta>那就请给我们反馈</c>

00:20:13.413 --> 00:20:15.549 align:middle
<c.magenta>使用Apple错误报告系统上报错误</c>

00:20:15.849 --> 00:20:17.518 align:middle
<c.magenta>像往常一样 当上报错误时</c>

00:20:17.784 --> 00:20:19.653 align:middle
<c.magenta>请给我们所需要的一切信息</c>

00:20:19.720 --> 00:20:21.388 align:middle
<c.magenta>来让我们自己再现出那个问题</c>

00:20:25.292 --> 00:20:30.130 align:middle
<c.magenta>我们的行业正在过渡到更广的色域上</c>

00:20:30.430 --> 00:20:32.366 align:middle
<c.magenta>用于数码摄影和数码视频</c>

00:20:34.134 --> 00:20:36.770 align:middle
<c.magenta>很多iOS开发者从来不需要应对</c>

00:20:36.837 --> 00:20:40.174 align:middle
<c.magenta>不使用Rec.709</c>
<c.magenta>色彩空间标准的视频</c>

00:20:40.474 --> 00:20:42.609 align:middle
<c.magenta>因为那是高清视频的标准</c>

00:20:42.676 --> 00:20:45.012 align:middle
<c.magenta>且那也是我们自iPhone 4</c>
<c.magenta>开始使用的拍摄标准</c>

00:20:45.646 --> 00:20:47.848 align:middle
<c.magenta>但是更广色域的</c>
<c.magenta>色彩空间即将来临</c>

00:20:48.782 --> 00:20:51.485 align:middle
<c.magenta>你可能已看到了</c>
<c.magenta>在最新的iPad Pro上</c>

00:20:51.685 --> 00:20:53.120 align:middle
<c.magenta>当运行iOS 10时</c>

00:20:54.521 --> 00:20:57.057 align:middle
<c.magenta>你可以拍摄并显示照片</c>

00:20:57.291 --> 00:20:58.992 align:middle
<c.magenta>在P3色彩空间中</c>

00:20:59.726 --> 00:21:03.230 align:middle
<c.magenta>一些第三方产品也在P3中拍摄视频</c>

00:20:59.726 --> 00:21:03.230 align:middle
<c.magenta>一些第三方产品也在P3中拍摄视频</c>

00:21:03.830 --> 00:21:06.967 align:middle
<c.magenta>所以我想给大家指点一下</c>
<c.magenta>你可以应用的API</c>

00:21:07.034 --> 00:21:09.036 align:middle
<c.magenta>用于你的应用中来做好准备</c>

00:21:09.102 --> 00:21:11.905 align:middle
<c.magenta>让你的应用支持广色域视频</c>

00:21:13.140 --> 00:21:14.675 align:middle
<c.magenta>当我首先要给你一些背景知识</c>

00:21:16.243 --> 00:21:18.912 align:middle
<c.magenta>在媒体文件中色彩空间信息是</c>

00:21:18.979 --> 00:21:20.814 align:middle
<c.magenta>视频轨的元数据的一部分</c>

00:21:21.181 --> 00:21:23.984 align:middle
<c.magenta>在QuickTime电影文件中</c>
<c.magenta>它保存于样本描述中</c>

00:21:24.218 --> 00:21:27.254 align:middle
<c.magenta>在一些Codec中</c>
<c.magenta>它还保存于Codec特定的位置</c>

00:21:27.688 --> 00:21:29.723 align:middle
<c.magenta>这个信息有三个主体</c>

00:21:30.457 --> 00:21:33.827 align:middle
<c.magenta>基色 用于明确100%红色</c>

00:21:33.894 --> 00:21:36.430 align:middle
<c.magenta>100%绿色和100%蓝色是什么</c>

00:21:36.830 --> 00:21:37.831 align:middle
<c.magenta>还有白点</c>

00:21:39.032 --> 00:21:40.234 align:middle
<c.magenta>传递特性</c>

00:21:40.734 --> 00:21:42.369 align:middle
<c.magenta>你可能听过叫做伽玛曲线</c>

00:21:42.703 --> 00:21:43.604 align:middle
<c.magenta>或是传递函数</c>

00:21:44.571 --> 00:21:48.509 align:middle
<c.magenta>这些从像素值到光级来定义映射</c>

00:21:49.276 --> 00:21:52.913 align:middle
<c.magenta>然后回答那是直线还是曲线的问题</c>

00:21:52.980 --> 00:21:55.048 align:middle
<c.magenta>这会在黑暗的区域给你更多细节</c>

00:21:55.115 --> 00:21:56.283 align:middle
<c.magenta>那里我们的眼睛更敏感</c>

00:21:57.317 --> 00:22:00.454 align:middle
<c.magenta>然后是YCbCr矩阵 是指坐标变换</c>

00:21:57.317 --> 00:22:00.454 align:middle
<c.magenta>然后是YCbCr矩阵 是指坐标变换</c>

00:22:00.687 --> 00:22:03.190 align:middle
<c.magenta>从它们的RGB空间进入到用于</c>

00:22:03.257 --> 00:22:04.825 align:middle
<c.magenta>高效压缩的空间</c>

00:22:06.660 --> 00:22:08.295 align:middle
<c.magenta>所以在这里我有一些例子</c>

00:22:08.729 --> 00:22:11.098 align:middle
<c.magenta>若你没有听说过Rec.709相当于</c>

00:22:11.164 --> 00:22:13.033 align:middle
<c.magenta>视频上面的SIGB</c>

00:22:13.300 --> 00:22:15.302 align:middle
<c.magenta>其实SIGB是基于Rec.709的</c>

00:22:16.103 --> 00:22:17.437 align:middle
<c.magenta>广色域可以通过</c>

00:22:17.804 --> 00:22:20.007 align:middle
<c.magenta>使用不同组的基色来实现</c>

00:22:20.607 --> 00:22:26.146 align:middle
<c.magenta>P3基色所指定的100%红色</c>

00:22:26.213 --> 00:22:28.482 align:middle
<c.magenta>100%绿色和100%蓝色的值</c>

00:22:28.649 --> 00:22:31.318 align:middle
<c.magenta>要比Rec.709更加鲜艳</c>

00:22:34.454 --> 00:22:35.522 align:middle
<c.magenta>我还有一点要说</c>

00:22:36.290 --> 00:22:39.359 align:middle
<c.magenta>在我们的API中 我们一般是通过</c>

00:22:39.860 --> 00:22:41.428 align:middle
<c.magenta>使用枚举字符串来表现这些选择</c>

00:22:41.528 --> 00:22:43.597 align:middle
<c.magenta>因为它们更易于打印 显示以及调试</c>

00:22:44.097 --> 00:22:47.267 align:middle
<c.magenta>但在媒体文件中</c>
<c.magenta>它们是通过数字表达的</c>

00:22:47.734 --> 00:22:51.004 align:middle
<c.magenta>这些标准标签数字</c>
<c.magenta>是在MPEG规格中定义出的</c>

00:22:51.271 --> 00:22:52.573 align:middle
<c.magenta>叫做编码独立代码点</c>

00:22:52.940 --> 00:22:54.341 align:middle
<c.magenta>这听起来是否有点矛盾？</c>

00:22:54.842 --> 00:22:56.410 align:middle
<c.magenta>怎么会是编码独立代码点呢？</c>

00:22:56.476 --> 00:22:58.979 align:middle
<c.magenta>它会不是那么的矛盾</c>

00:22:59.613 --> 00:23:01.882 align:middle
<c.magenta>如果你读成Codec编码独立代码点</c>

00:22:59.613 --> 00:23:01.882 align:middle
<c.magenta>如果你读成Codec编码独立代码点</c>

00:23:02.382 --> 00:23:04.785 align:middle
<c.magenta>这个规则的目的是确保这些标签数字的</c>

00:23:04.852 --> 00:23:06.153 align:middle
<c.magenta>任务是以一种协调的方式</c>

00:23:06.220 --> 00:23:08.989 align:middle
<c.magenta>在所有Codec和文件格式中完成</c>

00:23:09.223 --> 00:23:11.058 align:middle
<c.magenta>所以对数字的解释会是相同的</c>

00:23:11.225 --> 00:23:14.494 align:middle
<c.magenta>在QuickTime Movie</c>
<c.magenta>MPEG-4和H264中等</c>

00:23:15.128 --> 00:23:17.531 align:middle
<c.magenta>好 有了这些背景知识</c>
<c.magenta>我们看看一些新的API</c>

00:23:18.398 --> 00:23:21.535 align:middle
<c.magenta>我们推出了一个新的媒体特性</c>
<c.magenta>这会告诉你</c>

00:23:21.602 --> 00:23:24.004 align:middle
<c.magenta>视频轨标签有更广的基色</c>

00:23:24.071 --> 00:23:25.939 align:middle
<c.magenta>比Rec.709基色还要广</c>

00:23:26.473 --> 00:23:28.809 align:middle
<c.magenta>若你的应用发现这里有广色域视频</c>

00:23:29.243 --> 00:23:30.878 align:middle
<c.magenta>适合做的是让你的应用采取措施</c>

00:23:30.944 --> 00:23:33.981 align:middle
<c.magenta>将其保留下来 所以</c>
<c.magenta>这不会压回到709的色彩空间</c>

00:23:34.882 --> 00:23:36.617 align:middle
<c.magenta>如果没有 最好的做法是</c>

00:23:36.717 --> 00:23:38.318 align:middle
<c.magenta>停留在Rec.709中处理</c>

00:23:39.887 --> 00:23:43.223 align:middle
<c.magenta>所以你可指定工作色彩空间</c>

00:23:43.290 --> 00:23:46.693 align:middle
<c.magenta>当你设置AVPlayerItemVideoOutput</c>
<c.magenta>或AVAssetReaderOutput时</c>

00:23:47.194 --> 00:23:49.162 align:middle
<c.magenta>然后你收到的缓冲就被转化到了</c>

00:23:49.229 --> 00:23:50.330 align:middle
<c.magenta>那个色彩空间中</c>

00:23:50.864 --> 00:23:53.700 align:middle
<c.magenta>你还可以指定目标色彩空间</c>

00:23:53.767 --> 00:23:55.435 align:middle
<c.magenta>当你设置AVAssetWriterInput时</c>

00:23:55.502 --> 00:23:57.638 align:middle
<c.magenta>这种情况下 你提供的源图像缓冲</c>

00:23:57.771 --> 00:23:59.406 align:middle
<c.magenta>就会被转化到那个色彩空间中</c>

00:23:59.473 --> 00:24:00.307 align:middle
<c.magenta>在压缩之前</c>

00:23:59.473 --> 00:24:00.307 align:middle
<c.magenta>在压缩之前</c>

00:24:02.709 --> 00:24:06.146 align:middle
<c.magenta>使用AVPlayerItemVideoOutput</c>
<c.magenta>或AVAssetReaderOutput</c>

00:24:06.213 --> 00:24:08.282 align:middle
<c.magenta>如果你不想让图像缓冲被转化到</c>

00:24:08.348 --> 00:24:09.616 align:middle
<c.magenta>普通色彩空间中</c>

00:24:09.816 --> 00:24:13.420 align:middle
<c.magenta>那你应该设置</c>
<c.magenta>AVVideoAllowWideColorKey为true</c>

00:24:13.820 --> 00:24:16.023 align:middle
<c.magenta>然后你会收到在原始色彩空间中的缓冲</c>

00:24:16.323 --> 00:24:19.560 align:middle
<c.magenta>这是有效保证了无论什么样的软件收到</c>

00:24:19.626 --> 00:24:22.329 align:middle
<c.magenta>并处理缓冲 无论是我们的还是你的</c>

00:24:22.563 --> 00:24:24.698 align:middle
<c.magenta>就会检查并履行那些色彩空间标签</c>

00:24:26.466 --> 00:24:29.636 align:middle
<c.magenta>这里有类似特性用于配置视频合成</c>

00:24:29.937 --> 00:24:32.306 align:middle
<c.magenta>首先 你可以指定一个工作色彩空间</c>

00:24:32.372 --> 00:24:33.907 align:middle
<c.magenta>用于整个视频合成</c>

00:24:34.775 --> 00:24:36.877 align:middle
<c.magenta>或者 如果你有自定义的视频合成器</c>

00:24:37.077 --> 00:24:38.745 align:middle
<c.magenta>你可以选择让其支持广色域</c>

00:24:39.279 --> 00:24:42.783 align:middle
<c.magenta>你可以声明你的自定义</c>
<c.magenta>视频合成器支持广色域</c>

00:24:42.850 --> 00:24:45.319 align:middle
<c.magenta>并且会检查并履行色彩空间的标签</c>

00:24:45.385 --> 00:24:47.020 align:middle
<c.magenta>在每个源帧缓冲上</c>

00:24:47.287 --> 00:24:50.090 align:middle
<c.magenta>通过应用可选的</c>
<c.magenta>supportsWideColorSourceFrames</c>

00:24:50.157 --> 00:24:51.458 align:middle
<c.magenta>属性和返回真值</c>

00:24:53.927 --> 00:24:54.995 align:middle
<c.magenta>我给大家提醒一下</c>

00:24:56.396 --> 00:24:58.498 align:middle
<c.magenta>比如 如果你手动创建图片缓冲</c>

00:24:58.565 --> 00:24:59.933 align:middle
<c.magenta>在Metal 使用像素缓冲池</c>

00:25:00.367 --> 00:25:02.402 align:middle
<c.magenta>然后你应该明确地设置色彩空间标签</c>

00:25:02.469 --> 00:25:04.638 align:middle
<c.magenta>在每个缓冲上面</c>
<c.magenta>通过调用核心视频API</c>

00:25:05.138 --> 00:25:06.707 align:middle
<c.magenta>大多数开发者不需要这样做</c>

00:25:06.907 --> 00:25:09.843 align:middle
<c.magenta>在大多数情况下</c>
<c.magenta>当你使用支持色彩空间的API时</c>

00:25:09.910 --> 00:25:12.346 align:middle
<c.magenta>用于源缓冲 这会替你将它们标记上</c>

00:25:12.613 --> 00:25:15.349 align:middle
<c.magenta>应众人要求 我将用剩下的时间讨论</c>

00:25:15.482 --> 00:25:18.752 align:middle
<c.magenta>优化回放启动时间的最佳做法</c>

00:25:18.986 --> 00:25:21.889 align:middle
<c.magenta>我会首先谈谈本地文件回放</c>

00:25:21.989 --> 00:25:23.690 align:middle
<c.magenta>之后我们去讲HTTP直播流</c>

00:25:24.591 --> 00:25:26.860 align:middle
<c.magenta>现在的一些优化方法可能</c>

00:25:26.927 --> 00:25:28.195 align:middle
<c.magenta>第一眼看上去违背常理</c>

00:25:28.428 --> 00:25:29.897 align:middle
<c.magenta>它们需要你从</c>

00:25:29.963 --> 00:25:32.332 align:middle
<c.magenta>AVFoundation角度考虑</c>

00:25:32.799 --> 00:25:35.536 align:middle
<c.magenta>然后考虑它何时会得到其需要的信息</c>

00:25:35.669 --> 00:25:37.271 align:middle
<c.magenta>来做你的应用所要求的事情</c>

00:25:38.105 --> 00:25:40.440 align:middle
<c.magenta>例如 这里有一段很直接的代码</c>

00:25:40.574 --> 00:25:42.442 align:middle
<c.magenta>用于设置本地文件回放</c>

00:25:43.076 --> 00:25:44.478 align:middle
<c.magenta>我们从文件的URL开始</c>

00:25:44.545 --> 00:25:46.280 align:middle
<c.magenta>我们创建一AVURLAsset</c>

00:25:46.446 --> 00:25:48.749 align:middle
<c.magenta>代表存储那个文件的产品</c>

00:25:49.449 --> 00:25:52.853 align:middle
<c.magenta>之后创建AVPlayerItem</c>
<c.magenta>保持回放的可变状态</c>

00:25:52.953 --> 00:25:54.888 align:middle
<c.magenta>用一个AVPlayeritem</c>
<c.magenta>保持回放</c>

00:25:55.155 --> 00:25:56.990 align:middle
<c.magenta>然后我们创建一个</c>
<c.magenta>AVPlayerLayer</c>

00:25:57.057 --> 00:25:59.193 align:middle
<c.magenta>来将视频回放连接到我们的显示层次中</c>

00:25:59.760 --> 00:26:02.396 align:middle
<c.magenta>这个代码没问题 但有一点小瑕疵</c>

00:25:59.760 --> 00:26:02.396 align:middle
<c.magenta>这个代码没问题 但有一点小瑕疵</c>

00:26:02.462 --> 00:26:04.331 align:middle
<c.magenta>你最初可能没看出来</c>

00:26:05.065 --> 00:26:07.601 align:middle
<c.magenta>一旦播放项目设置成播放器的当前项目</c>

00:26:08.068 --> 00:26:10.003 align:middle
<c.magenta>播放器就会开始设置回放管道</c>

00:26:10.070 --> 00:26:11.338 align:middle
<c.magenta>它不知道将来的事</c>

00:26:11.405 --> 00:26:12.906 align:middle
<c.magenta>它不知道你过会将设置</c>

00:26:13.040 --> 00:26:14.675 align:middle
<c.magenta>AVPlayerLayout</c>

00:26:15.676 --> 00:26:18.278 align:middle
<c.magenta>所以它设置了仅有音频的回放</c>

00:26:18.579 --> 00:26:22.282 align:middle
<c.magenta>当AVPlayerLayer添加时</c>
<c.magenta>现在AVFoundation知道</c>

00:26:22.349 --> 00:26:23.851 align:middle
<c.magenta>这个视频也需要解码</c>

00:26:23.917 --> 00:26:25.752 align:middle
<c.magenta>现在它可以重新配置</c>

00:26:25.953 --> 00:26:27.254 align:middle
<c.magenta>音频和视频的回放</c>

00:26:28.622 --> 00:26:31.491 align:middle
<c.magenta>如我之前所说</c>

00:26:31.558 --> 00:26:34.461 align:middle
<c.magenta>我们在今年的iOS版本中做了增强</c>

00:26:35.295 --> 00:26:38.398 align:middle
<c.magenta>意味着微小的</c>

00:26:38.498 --> 00:26:41.001 align:middle
<c.magenta>回放列表变更 启用轨道列表的变更</c>

00:26:41.268 --> 00:26:43.170 align:middle
<c.magenta>不一定会导致中断</c>

00:26:43.637 --> 00:26:46.840 align:middle
<c.magenta>但理想的做法是在一开始就让</c>

00:26:46.907 --> 00:26:49.877 align:middle
<c.magenta>AVFoundation</c>
<c.magenta>获取所需信息使第一次就一切正常</c>

00:26:49.943 --> 00:26:51.445 align:middle
<c.magenta>所以我将稍微改变这个代码</c>

00:26:51.512 --> 00:26:53.780 align:middle
<c.magenta>看好了AVPlayerItem</c>
<c.magenta>到哪里连接</c>

00:26:54.147 --> 00:26:55.082 align:middle
<c.magenta>AVPlayer</c>

00:26:57.351 --> 00:27:00.120 align:middle
<c.magenta>所以现在播放器</c>
<c.magenta>创建好了 没有当前项目</c>

00:26:57.351 --> 00:27:00.120 align:middle
<c.magenta>所以现在播放器</c>
<c.magenta>创建好了 没有当前项目</c>

00:27:00.187 --> 00:27:02.689 align:middle
<c.magenta>这意味着现在</c>
<c.magenta>没有理由构建回放管道</c>

00:27:03.257 --> 00:27:05.526 align:middle
<c.magenta>在你添加AVPlayerLayer</c>
<c.magenta>时不会变</c>

00:27:06.293 --> 00:27:07.694 align:middle
<c.magenta>不会构建回放管道</c>

00:27:07.794 --> 00:27:09.596 align:middle
<c.magenta>直到播放项目成为了当前项目</c>

00:27:09.796 --> 00:27:12.165 align:middle
<c.magenta>而到那时候 播放器会知道其需要什么</c>

00:27:12.232 --> 00:27:14.034 align:middle
<c.magenta>来让第一次就不出问题</c>

00:27:14.868 --> 00:27:16.003 align:middle
<c.magenta>我们可以概括一下</c>

00:27:16.069 --> 00:27:17.905 align:middle
<c.magenta>先创建AVPlayerLayer</c>

00:27:17.971 --> 00:27:20.908 align:middle
<c.magenta>抱歉 首先创建AVPlayer</c>
<c.magenta>和AVPlayerItem对象</c>

00:27:20.974 --> 00:27:22.976 align:middle
<c.magenta>然后设置你在上面需要的属性</c>

00:27:23.043 --> 00:27:26.446 align:middle
<c.magenta>包括将AVPlayer连接到</c>
<c.magenta>AVPlayerLayer上</c>

00:27:26.513 --> 00:27:29.349 align:middle
<c.magenta>或将AVPlayerItem连接到</c>
<c.magenta>AVPlayerItemVideoOutput上</c>

00:27:30.784 --> 00:27:31.785 align:middle
<c.magenta>这可能似乎有点疯狂</c>

00:27:31.852 --> 00:27:34.021 align:middle
<c.magenta>但如果你只想要马上开始回放</c>

00:27:34.087 --> 00:27:37.057 align:middle
<c.magenta>你可以先告诉播放器进行播放</c>
<c.magenta>之后你再将播放项目提供给它</c>

00:27:37.157 --> 00:27:38.192 align:middle
<c.magenta>为什么要这样做？</c>

00:27:38.592 --> 00:27:40.928 align:middle
<c.magenta>如果你反过来做 播放器一开始会认为</c>

00:27:40.994 --> 00:27:43.764 align:middle
<c.magenta>你想要显示视频开头的静止帧</c>

00:27:43.931 --> 00:27:45.199 align:middle
<c.magenta>它可能在这上面浪费时间</c>

00:27:45.265 --> 00:27:48.368 align:middle
<c.magenta>之后再得到你是真的只想要回放的消息</c>

00:27:48.468 --> 00:27:51.872 align:middle
<c.magenta>从实际目标开始可能节省几毫秒</c>

00:27:52.973 --> 00:27:54.474 align:middle
<c.magenta>我们来谈谈HLS</c>

00:27:54.875 --> 00:27:57.744 align:middle
<c.magenta>我们尝试用HLS来优化</c>
<c.magenta>的时间段会更加的长</c>

00:27:57.811 --> 00:28:01.548 align:middle
<c.magenta>因为它们受网络IO的控制</c>
<c.magenta>这比本地文件存储要慢得多</c>

00:27:57.811 --> 00:28:01.548 align:middle
<c.magenta>因为它们受网络IO的控制</c>
<c.magenta>这比本地文件存储要慢得多</c>

00:28:01.815 --> 00:28:05.219 align:middle
<c.magenta>所以优化的潜在好处会更加显而易见</c>

00:28:05.652 --> 00:28:07.621 align:middle
<c.magenta>网络IO能分解成四个部分</c>

00:28:07.688 --> 00:28:11.158 align:middle
<c.magenta>检索主播放列表 那是你交给</c>
<c.magenta>AVURLAsset的URL</c>

00:28:11.225 --> 00:28:13.493 align:middle
<c.magenta>若内容受到 FairPlay</c>
<c.magenta>Streaming的保护</c>

00:28:13.560 --> 00:28:17.431 align:middle
<c.magenta>检索内容密钥</c>
<c.magenta>检索选中的变体播放列表</c>

00:28:17.497 --> 00:28:20.634 align:middle
<c.magenta>用于视频和音频的合适比特率和格式</c>

00:28:21.001 --> 00:28:22.569 align:middle
<c.magenta>然后检索一些媒体分段</c>

00:28:22.769 --> 00:28:23.971 align:middle
<c.magenta>在播放列表中引用过的</c>

00:28:24.238 --> 00:28:27.074 align:middle
<c.magenta>现媒体分段的实际数据传输量是最多的</c>

00:28:27.207 --> 00:28:29.710 align:middle
<c.magenta>但在网络IO中</c>
<c.magenta>我们要考虑往返延迟</c>

00:28:30.511 --> 00:28:32.079 align:middle
<c.magenta>其中一些阶段是序列化的</c>

00:28:32.613 --> 00:28:35.215 align:middle
<c.magenta>你无法从播放列表下载内容</c>

00:28:35.582 --> 00:28:37.251 align:middle
<c.magenta>直到你得到了播放列表</c>

00:28:38.819 --> 00:28:41.054 align:middle
<c.magenta>所以要思索的是</c>

00:28:41.421 --> 00:28:44.324 align:middle
<c.magenta>我们能不能在用户</c>
<c.magenta>选择播放之前做这些事？</c>

00:28:46.527 --> 00:28:47.861 align:middle
<c.magenta>例如 可能在你的应用中</c>

00:28:48.095 --> 00:28:50.664 align:middle
<c.magenta>当内容先被选择时 显示标题卡片</c>

00:28:51.265 --> 00:28:53.867 align:middle
<c.magenta>然后这会让用户表明</c>
<c.magenta>这个是不是我想播放的内容？</c>

00:28:53.934 --> 00:28:55.435 align:middle
<c.magenta>或我是否想阅读一些关于它的信息</c>

00:28:55.969 --> 00:28:59.373 align:middle
<c.magenta>所以问题是我们能不能猜测性地</c>

00:28:59.439 --> 00:29:00.941 align:middle
<c.magenta>做少量的网络IO</c>

00:28:59.439 --> 00:29:00.941 align:middle
<c.magenta>做少量的网络IO</c>

00:29:01.842 --> 00:29:04.678 align:middle
<c.magenta>当用户识别出他们可能想要播放的内容</c>

00:29:04.745 --> 00:29:05.579 align:middle
<c.magenta>在确认之前？</c>

00:29:06.713 --> 00:29:09.917 align:middle
<c.magenta>AVURLAsset是一种懒API</c>

00:29:10.184 --> 00:29:11.885 align:middle
<c.magenta>它不会开始加载或暂停任何数据</c>

00:29:11.952 --> 00:29:12.953 align:middle
<c.magenta>直到有人向它要求</c>

00:29:13.520 --> 00:29:15.989 align:middle
<c.magenta>为了触发从主播放列表进行数据加载</c>

00:29:16.056 --> 00:29:18.559 align:middle
<c.magenta>我们需要请求它</c>
<c.magenta>加载一个会从其中衍生出的值</c>

00:29:18.625 --> 00:29:22.196 align:middle
<c.magenta>像是时长或是可用的媒体特性</c>

00:29:22.262 --> 00:29:23.363 align:middle
<c.magenta>外加媒体选择选项</c>

00:29:23.764 --> 00:29:24.932 align:middle
<c.magenta>时长易于输入</c>

00:29:25.699 --> 00:29:27.601 align:middle
<c.magenta>你不需要提供完成处理程序 除非</c>

00:29:27.734 --> 00:29:29.303 align:middle
<c.magenta>你真的要用那个值来做某些事情</c>

00:29:31.138 --> 00:29:33.440 align:middle
<c.magenta>谈到播放列表 它们易于压缩</c>

00:29:33.507 --> 00:29:36.210 align:middle
<c.magenta>我们多年支持使用gzip来压缩它们</c>

00:29:36.610 --> 00:29:37.611 align:middle
<c.magenta>所以一定要这样做</c>

00:29:38.045 --> 00:29:39.880 align:middle
<c.magenta>这可能只是配置你服务器的事</c>

00:29:41.448 --> 00:29:43.717 align:middle
<c.magenta>如果你的内容受到</c>
<c.magenta>FairPlay Streaming的保护</c>

00:29:43.784 --> 00:29:44.785 align:middle
<c.magenta>那这里还涉及一个</c>

00:29:44.852 --> 00:29:47.120 align:middle
<c.magenta>与你的服务器协商内容密钥的往返过程</c>

00:29:47.454 --> 00:29:48.755 align:middle
<c.magenta>且你可以将其更早地触发</c>

00:29:48.956 --> 00:29:51.725 align:middle
<c.magenta>通过设置</c>
<c.magenta>asset.resourceLoader的</c>

00:29:51.959 --> 00:29:54.127 align:middle
<c.magenta>preloadsEligibleContentKeys</c>
<c.magenta>属性为true</c>

00:29:54.194 --> 00:29:56.196 align:middle
<c.magenta>为了起作用 主播放列表必须包含</c>

00:29:56.263 --> 00:29:57.497 align:middle
<c.magenta>会话密钥声明</c>

00:29:59.032 --> 00:30:00.100 align:middle
<c.magenta>所以现在情况如何？</c>

00:29:59.032 --> 00:30:00.100 align:middle
<c.magenta>所以现在情况如何？</c>

00:30:00.300 --> 00:30:01.969 align:middle
<c.magenta>有了这些方法 我们可以开始——</c>

00:30:02.302 --> 00:30:05.172 align:middle
<c.magenta>它们能将主播放列表</c>
<c.magenta>和内容密钥下载下来</c>

00:30:05.472 --> 00:30:06.673 align:middle
<c.magenta>即使我们还在标题卡上</c>

00:30:06.740 --> 00:30:07.574 align:middle
<c.magenta>这非常炫酷</c>

00:30:08.041 --> 00:30:10.444 align:middle
<c.magenta>变体播放列表和数据分段</c>

00:30:10.644 --> 00:30:12.145 align:middle
<c.magenta>还是会在我们点击播放后加载</c>

00:30:12.613 --> 00:30:13.847 align:middle
<c.magenta>所以你可能问自己</c>

00:30:14.047 --> 00:30:15.849 align:middle
<c.magenta>我们能让这种方法更进一步吗？</c>

00:30:17.150 --> 00:30:19.319 align:middle
<c.magenta>在2016年的新API中有一个叫做</c>

00:30:19.386 --> 00:30:21.355 align:middle
<c.magenta>preferredForwardBufferDuration</c>

00:30:22.189 --> 00:30:23.991 align:middle
<c.magenta>设置成低的时长 比如5秒</c>

00:30:24.124 --> 00:30:27.027 align:middle
<c.magenta>会让AVFoundation缓冲出</c>
<c.magenta>其认为你需要的最少内容量</c>

00:30:27.094 --> 00:30:27.961 align:middle
<c.magenta>来开始播放</c>

00:30:28.629 --> 00:30:31.532 align:middle
<c.magenta>不过一旦回放开始将覆盖设置回0</c>

00:30:31.698 --> 00:30:34.535 align:middle
<c.magenta>来让正常缓冲算法重新发挥作用</c>

00:30:37.204 --> 00:30:38.672 align:middle
<c.magenta>这是一个视频方差的列表</c>

00:30:39.006 --> 00:30:40.340 align:middle
<c.magenta>可能会出现在主播放列表中</c>

00:30:40.807 --> 00:30:42.643 align:middle
<c.magenta>在尺寸和比特率上各有不同</c>

00:30:43.143 --> 00:30:46.079 align:middle
<c.magenta>对于配有快速连接和</c>
<c.magenta>大电视的Apple TV来说</c>

00:30:46.146 --> 00:30:47.848 align:middle
<c.magenta>1080p的变体</c>
<c.magenta>可能会是理想</c>

00:30:48.515 --> 00:30:49.850 align:middle
<c.magenta>对于iPhone SE</c>

00:30:50.884 --> 00:30:52.653 align:middle
<c.magenta>即使拥有超快的Wi-Fi连接</c>

00:30:52.853 --> 00:30:54.755 align:middle
<c.magenta>720p变体会是最佳选择</c>

00:30:54.955 --> 00:30:57.591 align:middle
<c.magenta>这已经比iPhone SE的</c>
<c.magenta>屏幕分辨率更大了</c>

00:30:57.824 --> 00:30:59.760 align:middle
<c.magenta>所以选择更高的不会提升任何品质</c>

00:31:00.627 --> 00:31:03.197 align:middle
<c.magenta>在巨大的iPad Pro上面</c>
<c.magenta>有很多的像素</c>

00:31:03.430 --> 00:31:05.933 align:middle
<c.magenta>所以我们可以选择</c>
<c.magenta>大的变体来全屏显示</c>

00:31:06.266 --> 00:31:07.768 align:middle
<c.magenta>但如果我们在画中画中播放</c>

00:31:07.835 --> 00:31:09.603 align:middle
<c.magenta>我们不再需要那么高的分辨率</c>

00:31:10.070 --> 00:31:13.674 align:middle
<c.magenta>而且更低的比特率变体</c>
<c.magenta>可以降低缓存的大小</c>

00:31:13.874 --> 00:31:16.176 align:middle
<c.magenta>然后帮助我们留出更多</c>
<c.magenta>储存空间用于其他应用</c>

00:31:17.277 --> 00:31:19.513 align:middle
<c.magenta>如果网络连接在所有设备上都很慢</c>

00:31:19.746 --> 00:31:20.914 align:middle
<c.magenta>那这就会成为限制因素</c>

00:31:21.381 --> 00:31:23.483 align:middle
<c.magenta>这意味着这AVFoundation</c>

00:31:23.550 --> 00:31:25.519 align:middle
<c.magenta>需要考虑到显示尺寸</c>

00:31:25.752 --> 00:31:27.821 align:middle
<c.magenta>以及网络比特率 当选择变体的时候</c>

00:31:28.822 --> 00:31:31.792 align:middle
<c.magenta>AVFoundation使用屏幕上</c>
<c.magenta>AVPlayerLayer的大小</c>

00:31:31.859 --> 00:31:32.893 align:middle
<c.magenta>来评估尺寸</c>

00:31:33.360 --> 00:31:36.129 align:middle
<c.magenta>所以将AVPlayerLayer</c>
<c.magenta>设置成正确的大小</c>

00:31:36.196 --> 00:31:38.398 align:middle
<c.magenta>然后尽早连接到AVPlayer上</c>

00:31:38.966 --> 00:31:40.467 align:middle
<c.magenta>这可以隐藏在其他UI后面</c>

00:31:40.534 --> 00:31:41.869 align:middle
<c.magenta>如果你还没准备好显示视频</c>

00:31:42.769 --> 00:31:45.272 align:middle
<c.magenta>在Retina屏幕的iOS设备上</c>
<c.magenta>目前有必要将</c>

00:31:45.339 --> 00:31:47.207 align:middle
<c.magenta>contentsScale</c>
<c.magenta>设置成手动</c>

00:31:48.909 --> 00:31:51.812 align:middle
<c.magenta>对于比特率</c>
<c.magenta>AVFoundation在</c>

00:31:51.879 --> 00:31:53.547 align:middle
<c.magenta>回放第一个开头时会陷于</c>

00:31:53.981 --> 00:31:55.415 align:middle
<c.magenta>难分先后的情况中</c>

00:31:56.049 --> 00:31:57.351 align:middle
<c.magenta>它必须选择一些变体</c>

00:31:57.885 --> 00:31:59.987 align:middle
<c.magenta>但不知道会得到什么样的比特率</c>

00:32:00.921 --> 00:32:02.623 align:middle
<c.magenta>一旦开始下载分段</c>

00:32:02.723 --> 00:32:04.791 align:middle
<c.magenta>它可以使用来自那些下载的统计数据</c>

00:32:04.858 --> 00:32:06.059 align:middle
<c.magenta>来调整变体的选择</c>

00:32:06.593 --> 00:32:07.828 align:middle
<c.magenta>但对于第一个变体</c>

00:32:08.061 --> 00:32:09.530 align:middle
<c.magenta>它没有收到任何统计数据</c>

00:32:10.397 --> 00:32:12.599 align:middle
<c.magenta>所以AVFoundation</c>
<c.magenta>的基础算法就是</c>

00:32:12.666 --> 00:32:15.669 align:middle
<c.magenta>在主播放列表中</c>
<c.magenta>选取第一个可适用的变体</c>

00:32:16.036 --> 00:32:17.371 align:middle
<c.magenta>如果那是低比特率的选项</c>

00:32:17.604 --> 00:32:19.339 align:middle
<c.magenta>用户开始会看到模糊的内容</c>

00:32:19.706 --> 00:32:22.643 align:middle
<c.magenta>但AVFoundation会</c>
<c.magenta>马上判断出实际的网络比特率是什么</c>

00:32:22.709 --> 00:32:24.111 align:middle
<c.magenta>然后切换成合适的变体</c>

00:32:25.245 --> 00:32:27.648 align:middle
<c.magenta>但问题是如果你想尝试</c>

00:32:27.714 --> 00:32:29.416 align:middle
<c.magenta>提升那个最初选择呢？</c>

00:32:29.950 --> 00:32:33.353 align:middle
<c.magenta>记住 你要做出权衡</c>

00:32:33.420 --> 00:32:35.589 align:middle
<c.magenta>在最初品质和启动时间两者之间</c>

00:32:36.223 --> 00:32:39.259 align:middle
<c.magenta>更高比特率的第一分段需更长时间下载</c>

00:32:39.626 --> 00:32:41.195 align:middle
<c.magenta>这就意味着开始的时间会更长</c>

00:32:41.695 --> 00:32:45.465 align:middle
<c.magenta>你可能会决定最好是</c>
<c.magenta>从更低比特率的变体开始</c>

00:32:46.099 --> 00:32:47.234 align:middle
<c.magenta>为了更快开始播放</c>

00:32:48.035 --> 00:32:50.037 align:middle
<c.magenta>做出权衡的一种方法是弄清楚</c>

00:32:50.103 --> 00:32:52.472 align:middle
<c.magenta>你想看到的最低可接受的品质等级</c>

00:32:52.739 --> 00:32:55.242 align:middle
<c.magenta>在特定大小的屏幕上 然后从那里开始</c>

00:32:55.876 --> 00:32:58.345 align:middle
<c.magenta>之后AVFoundation</c>
<c.magenta>切换到更高品质上</c>

00:32:58.645 --> 00:33:01.181 align:middle
<c.magenta>在回放开始之后 只要网络条件允许</c>

00:32:58.645 --> 00:33:01.181 align:middle
<c.magenta>在回放开始之后 只要网络条件允许</c>

00:33:02.249 --> 00:33:04.918 align:middle
<c.magenta>可能你知道AVFoundation</c>
<c.magenta>不知道的一件事</c>

00:33:05.419 --> 00:33:07.955 align:middle
<c.magenta>可能你的应用刚播放了不同部分的内容</c>

00:33:08.555 --> 00:33:10.924 align:middle
<c.magenta>然后也许你可以使用那个回放访问日志</c>

00:33:11.258 --> 00:33:13.060 align:middle
<c.magenta>来更好地猜测下一个</c>

00:33:13.126 --> 00:33:14.761 align:middle
<c.magenta>回放站会得到的比特率</c>

00:33:16.630 --> 00:33:18.298 align:middle
<c.magenta>所以我们假设你得出了一个结论</c>

00:33:18.632 --> 00:33:21.335 align:middle
<c.magenta>基于启动品质和最近比特率统计数据</c>

00:33:21.768 --> 00:33:23.737 align:middle
<c.magenta>然后你要决定选择</c>

00:33:23.804 --> 00:33:25.472 align:middle
<c.magenta>你想以哪一个变体开始</c>

00:33:25.706 --> 00:33:28.308 align:middle
<c.magenta>如何将那个选择</c>
<c.magenta>导入AVFoundation中？</c>

00:33:29.176 --> 00:33:30.711 align:middle
<c.magenta>这里使用了两种方法</c>

00:33:31.178 --> 00:33:32.045 align:middle
<c.magenta>这是第一种方法</c>

00:33:32.646 --> 00:33:35.115 align:middle
<c.magenta>在服务器上</c>
<c.magenta>给变体排序</c>

00:33:35.282 --> 00:33:36.483 align:middle
<c.magenta>从最高到最低</c>

00:33:38.919 --> 00:33:39.753 align:middle
<c.magenta>就像这样</c>

00:33:40.053 --> 00:33:41.321 align:middle
<c.magenta>然后在你的应用里</c>

00:33:41.722 --> 00:33:45.425 align:middle
<c.magenta>你需要设置</c>
<c.magenta>playerItem.preferredPeakBitRate</c>

00:33:46.059 --> 00:33:47.194 align:middle
<c.magenta>为你猜测的比特率</c>

00:33:48.195 --> 00:33:50.464 align:middle
<c.magenta>这样会使更高的比特率变体</c>

00:33:50.697 --> 00:33:51.832 align:middle
<c.magenta>从初始选择中淘汰掉</c>

00:33:52.499 --> 00:33:53.800 align:middle
<c.magenta>回放开始之后不久</c>

00:33:54.034 --> 00:33:56.370 align:middle
<c.magenta>你应该将那个控制重置为0</c>

00:33:56.703 --> 00:33:59.706 align:middle
<c.magenta>这能让AVFoundation</c>
<c.magenta>提升到更高的比特率变体上</c>

00:33:59.773 --> 00:34:00.641 align:middle
<c.magenta>只要网络有提升</c>

00:33:59.773 --> 00:34:00.641 align:middle
<c.magenta>只要网络有提升</c>

00:34:02.676 --> 00:34:03.710 align:middle
<c.magenta>第二个方法</c>

00:34:03.977 --> 00:34:06.547 align:middle
<c.magenta>是在你的应用里动态改写主播放列表</c>

00:34:06.947 --> 00:34:09.016 align:middle
<c.magenta>然后把你的优先选择移动到列表顶部</c>

00:34:10.150 --> 00:34:14.588 align:middle
<c.magenta>为了做到这一点</c>
<c.magenta>在AVURLAsset中使用自定义URL方案</c>

00:34:15.722 --> 00:34:19.793 align:middle
<c.magenta>然后应用AVasset</c>
<c.magenta>资源加载器委托协议</c>

00:34:20.226 --> 00:34:23.130 align:middle
<c.magenta>这样你可以提供改写的播放列表</c>

00:34:23.197 --> 00:34:26.065 align:middle
<c.magenta>来回应自定义URL方案的加载请求</c>

00:34:27.701 --> 00:34:29.870 align:middle
<c.magenta>我还想要提醒一下你要分析你的代码</c>

00:34:30.070 --> 00:34:33.005 align:middle
<c.magenta>在你调用AVFoundation前</c>
<c.magenta>看看是否出现任何延迟</c>

00:34:33.072 --> 00:34:36.643 align:middle
<c.magenta>特别的是 你不需等待</c>
<c.magenta>LikelyToKeepUp</c>

00:34:36.710 --> 00:34:39.179 align:middle
<c.magenta>在设置播放器速率之前</c>
<c.magenta>成为true</c>

00:34:39.545 --> 00:34:43.083 align:middle
<c.magenta>你现在不需要</c>
<c.magenta>实际上 对于HLS从来不需要</c>

00:34:44.184 --> 00:34:46.652 align:middle
<c.magenta>确保你将AVPlayer</c>
<c.magenta>和AVPlayerItem</c>

00:34:46.719 --> 00:34:48.021 align:middle
<c.magenta>从之前的回放会话中释放出来</c>

00:34:48.288 --> 00:34:50.858 align:middle
<c.magenta>这样它们不会在后台浪费宽带</c>

00:34:50.924 --> 00:34:53.793 align:middle
<c.magenta>你可以使用Instruments中的</c>
<c.magenta>Allocations Instrument</c>

00:34:53.860 --> 00:34:57.264 align:middle
<c.magenta>来查看AVPlayer和</c>
<c.magenta>AVPlayerItem对象的寿命</c>

00:34:58.065 --> 00:35:00.501 align:middle
<c.magenta>如果你有应用在做其他网络活动</c>

00:34:58.065 --> 00:35:00.501 align:middle
<c.magenta>如果你有应用在做其他网络活动</c>

00:35:00.567 --> 00:35:03.504 align:middle
<c.magenta>考虑一下在网络回放时是否该将其暂停</c>

00:35:03.570 --> 00:35:07.808 align:middle
<c.magenta>这样用户可充分利用可用宽带进行回放</c>

00:35:09.576 --> 00:35:11.879 align:middle
<c.magenta>好了 总之</c>

00:35:13.213 --> 00:35:15.382 align:middle
<c.magenta>自动等待会将卡顿减到最少</c>

00:35:15.816 --> 00:35:17.384 align:middle
<c.magenta>自动播放 自动等待</c>

00:35:18.318 --> 00:35:19.553 align:middle
<c.magenta>这默认设置为true</c>

00:35:19.620 --> 00:35:22.789 align:middle
<c.magenta>如果你的应用使用今年或之后的SDK</c>

00:35:23.357 --> 00:35:25.392 align:middle
<c.magenta>它提供了统一的缓冲规则</c>

00:35:25.559 --> 00:35:28.362 align:middle
<c.magenta>用于渐进式下载和HLS回放</c>

00:35:29.963 --> 00:35:32.766 align:middle
<c.magenta>我们推出一个新的API</c>
<c.magenta>叫做AVPlayerLooper</c>

00:35:33.233 --> 00:35:36.970 align:middle
<c.magenta>使用跑步机模式简化单一项目循环回放</c>

00:35:38.739 --> 00:35:41.742 align:middle
<c.magenta>在回放期间更改启用的轨道组</c>

00:35:41.808 --> 00:35:44.077 align:middle
<c.magenta>不会总是引起短暂停顿</c>

00:35:45.312 --> 00:35:47.247 align:middle
<c.magenta>我们看了看</c>
<c.magenta>AVFoundation API</c>

00:35:47.314 --> 00:35:50.184 align:middle
<c.magenta>你可以用它来让你的应用</c>
<c.magenta>为广色域视频做好准备</c>

00:35:51.652 --> 00:35:54.421 align:middle
<c.magenta>最后 我们谈论了优化回放启动</c>

00:35:54.488 --> 00:35:56.590 align:middle
<c.magenta>用于本地文件和HLS</c>

00:35:57.124 --> 00:36:00.360 align:middle
<c.magenta>总之 避免不必要的工作</c>

00:35:57.124 --> 00:36:00.360 align:middle
<c.magenta>总之 避免不必要的工作</c>

00:36:01.028 --> 00:36:03.197 align:middle
<c.magenta>对于你需要做的工作 试着早些去做</c>

00:36:04.598 --> 00:36:07.601 align:middle
<c.magenta>在这个URL上我们有与</c>
<c.magenta>这个会议相关的更多信息</c>

00:36:07.668 --> 00:36:09.636 align:middle
<c.magenta>包括我们展示的示例代码</c>

00:36:10.637 --> 00:36:13.507 align:middle
<c.magenta>我们有一些相关会话你可能会想补看</c>

00:36:13.574 --> 00:36:16.076 align:middle
<c.magenta>可以现场看或者在网上观看</c>

00:36:16.310 --> 00:36:19.479 align:middle
<c.magenta>最下面的那个是在应用里</c>
<c.magenta>只能点播观看的</c>

00:36:20.080 --> 00:36:22.082 align:middle
<c.magenta>谢谢关注 倍感荣幸</c>

00:36:22.216 --> 00:36:23.450 align:middle
<c.magenta>希望大家度过愉快的一周</c>
