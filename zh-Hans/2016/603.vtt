WEBVTT

00:00:19.887 --> 00:00:23.790 align:middle
采用Metal技术 第二部分

00:00:30.797 --> 00:00:33.100 align:middle
大家好 欢迎来到全球开发者大会

00:00:33.166 --> 00:00:34.935 align:middle
希望目前为止 你们都过得很愉快

00:00:35.002 --> 00:00:36.336 align:middle
你们已看过很多优秀的演讲

00:00:36.403 --> 00:00:38.505 align:middle
我们为你们准备了非常棒的一周

00:00:38.572 --> 00:00:39.773 align:middle
会非常有趣的

00:00:39.840 --> 00:00:40.707 align:middle
我是Matt Collins

00:00:40.774 --> 00:00:42.543 align:middle
这是我的同事Jared Marsau

00:00:42.609 --> 00:00:45.379 align:middle
我们将为你讲解
采用Metal技术 第二部分

00:00:45.445 --> 00:00:47.548 align:middle
这里是603号演讲

00:00:48.015 --> 00:00:50.951 align:middle
如果你走错了 你也能看到一些图像

00:00:53.787 --> 00:00:54.721 align:middle
所以 让我们回忆一下

00:00:55.189 --> 00:00:56.557 align:middle
我们共有两部分
“采用Metal技术”演讲

00:00:56.623 --> 00:00:59.226 align:middle
希望你们也参加了
Warren的第一部分演讲

00:00:59.293 --> 00:01:01.495 align:middle
第一部分我们讲解了基本概念：

00:00:59.293 --> 00:01:01.495 align:middle
第一部分我们讲解了基本概念：

00:01:01.562 --> 00:01:04.998 align:middle
基本绘图 光照 纹理
诸如此类的优秀功能

00:01:05.666 --> 00:01:08.135 align:middle
在本次演讲中 我们会更上一个层次

00:01:08.202 --> 00:01:09.703 align:middle
我们会绘制很多对象

00:01:09.770 --> 00:01:12.272 align:middle
我们将会讲解如何管理动态数据

00:01:12.339 --> 00:01:13.907 align:middle
大量的动态数据

00:01:14.308 --> 00:01:15.909 align:middle
GPU-CPU同步

00:01:16.443 --> 00:01:18.879 align:middle
我们将会以多线程编码的话题结束

00:01:20.414 --> 00:01:22.649 align:middle
明天我们还有精彩的演讲

00:01:22.950 --> 00:01:24.718 align:middle
我们会讲解Metal的新特性

00:01:25.085 --> 00:01:28.689 align:middle
明天的第一个演讲
将讲解细分曲面 资源堆

00:01:28.755 --> 00:01:30.157 align:middle
无记忆帧缓冲

00:01:30.490 --> 00:01:32.326 align:middle
和关于我们改进后的工具

00:01:32.392 --> 00:01:34.895 align:middle
以真正帮助大家做出最好的应用

00:01:35.128 --> 00:01:37.631 align:middle
第二部分 我们将要讨论函数专用化

00:01:37.831 --> 00:01:39.633 align:middle
以及函数资源读写

00:01:40.033 --> 00:01:42.169 align:middle
丰富的色彩和纹理资产

00:01:42.870 --> 00:01:45.239 align:middle
此外还有Metal性能着色器

00:01:46.540 --> 00:01:47.941 align:middle
如果你还想继续深入

00:01:48.008 --> 00:01:50.978 align:middle
我们还会有关于高级着色器优化的
精彩讨论

00:01:51.044 --> 00:01:53.947 align:middle
着色起性能基础 调整着色器代码

00:01:54.281 --> 00:01:56.617 align:middle
及更多关于硬件工作原理的细节
将会十分精彩

00:01:56.683 --> 00:01:59.019 align:middle
如果你对调整着色器代码非常感兴趣

00:01:59.086 --> 00:02:01.722 align:middle
想让它们达到最佳效果
请关注明天的讲座

00:01:59.086 --> 00:02:01.722 align:middle
想让它们达到最佳效果
请关注明天的讲座

00:02:04.458 --> 00:02:06.860 align:middle
这里是采用Metal技术的第二部分

00:02:07.394 --> 00:02:09.729 align:middle
我们将在第一部分的所学基础上继续

00:02:10.030 --> 00:02:11.765 align:middle
我们弄清楚如何启动和运行

00:02:12.266 --> 00:02:14.067 align:middle
让我们看一下你所需要的概念

00:02:14.134 --> 00:02:16.637 align:middle
能让Metal在真实世界
得到最大的应用

00:02:17.337 --> 00:02:20.541 align:middle
我们有一个演示
将会把很多内容绘入一个简单的场景

00:02:20.807 --> 00:02:23.944 align:middle
在今天的演讲中
我们都会使用该演示作为上下文

00:02:24.011 --> 00:02:26.313 align:middle
并从中学到很多内容

00:02:27.281 --> 00:02:29.983 align:middle
我们将会讲解数据的理想组织流程

00:02:30.050 --> 00:02:32.352 align:middle
如何管理大批量动态数据

00:02:32.553 --> 00:02:36.156 align:middle
CPU和GPU同步的重要性

00:02:36.290 --> 00:02:39.026 align:middle
以及如我之前所说 一些多线程编码

00:02:39.693 --> 00:02:41.595 align:middle
希望你已对Metal的基础有所熟悉

00:02:41.662 --> 00:02:42.996 align:middle
因为我们不会再次讲解

00:02:43.063 --> 00:02:46.233 align:middle
我们预设你已经理解
如何新建Metal队列

00:02:46.433 --> 00:02:48.902 align:middle
新建Metal命令缓冲
如何编码指令

00:02:49.970 --> 00:02:51.672 align:middle
我们在此基础上进行下一步

00:02:53.240 --> 00:02:57.177 align:middle
我们先来看演示
看看我们的目标是什么

00:02:58.879 --> 00:03:01.348 align:middle
现在我们有10,000个立方体

00:02:58.879 --> 00:03:01.348 align:middle
现在我们有10,000个立方体

00:03:01.982 --> 00:03:04.418 align:middle line:1
它们都在四处旋转 在空中加载

00:03:04.651 --> 00:03:05.853 align:middle line:1
很有趣的画面

00:03:06.653 --> 00:03:08.689 align:middle line:1
Metal允许我们展开无数绘图调用

00:03:08.755 --> 00:03:09.957 align:middle line:1
开销却很小

00:03:10.224 --> 00:03:13.293 align:middle line:1
所以在此有10,000个立方体和
10,000个绘图调用

00:03:14.061 --> 00:03:16.029 align:middle line:1
你可以看到在底部 有一点阴影

00:03:16.096 --> 00:03:17.331 align:middle line:1
我们正使用一个阴影映射

00:03:17.664 --> 00:03:19.933 align:middle line:1
它被放在底部
是一些美观的反锯齿线

00:03:20.000 --> 00:03:21.235 align:middle line:1
产生一些深度暗示

00:03:23.003 --> 00:03:24.471 align:middle line:1
当然是所有的立方体

00:03:25.272 --> 00:03:27.508 align:middle line:1
所以怎样才能渲染这样的画面？

00:03:27.941 --> 00:03:29.543 align:middle line:1
我们有很多对象

00:03:29.610 --> 00:03:33.146 align:middle line:1
每一个对象都有自身相关联的唯一数据

00:03:33.413 --> 00:03:36.617 align:middle line:1
我们需要位置 旋转和颜色

00:03:37.150 --> 00:03:39.386 align:middle
每一帧都必须要更新
因为我们在动画显示它们

00:03:39.453 --> 00:03:42.256 align:middle
所以这是我们不断在改变的一组数据

00:03:42.623 --> 00:03:45.225 align:middle
不断重新通知GPU我们正在绘制什么

00:03:46.159 --> 00:03:47.861 align:middle
我们还可以绘制更多的对象

00:03:49.096 --> 00:03:50.097 align:middle line:1
还可以再多一点

00:03:51.098 --> 00:03:52.666 align:middle line:1
你可以把它们转动起来

00:03:52.733 --> 00:03:54.668 align:middle line:1
看到它们正漂浮在空中

00:03:56.703 --> 00:04:00.541 align:middle line:1
所以我们有一个立方体的绘图调用
和相关数据

00:03:56.703 --> 00:04:00.541 align:middle line:1
所以我们有一个立方体的绘图调用
和相关数据

00:04:00.774 --> 00:04:03.577 align:middle
我们得想想该如何更好地思考这些数据

00:04:03.644 --> 00:04:04.645 align:middle
如何管理它们

00:04:04.811 --> 00:04:06.880 align:middle
以及如何让它和GPU通讯

00:04:08.215 --> 00:04:09.316 align:middle
让我们深入看一下

00:04:09.883 --> 00:04:10.784 align:middle
谢谢你 Jared

00:04:14.755 --> 00:04:16.089 align:middle
管理动态数据

00:04:16.490 --> 00:04:18.992 align:middle
这是每一帧都在变化的大量数据

00:04:19.059 --> 00:04:21.361 align:middle
可以想像 在一个现代应用里
比如一个游戏

00:04:21.495 --> 00:04:24.531 align:middle
你也需要每帧都要更新的大量数据

00:04:25.399 --> 00:04:27.434 align:middle
所以我们的绘图基本看上去是这样

00:04:27.668 --> 00:04:29.937 align:middle
我们想遍历所有在绘图中感兴趣的对象

00:04:30.003 --> 00:04:30.871 align:middle
并更新它们

00:04:31.772 --> 00:04:34.441 align:middle
然后我们想为每一个对象编码绘图调用

00:04:35.008 --> 00:04:37.277 align:middle
然后我们必须提交所有这些GPU指令

00:04:37.678 --> 00:04:38.946 align:middle
我们有很多对象

00:04:39.012 --> 00:04:41.448 align:middle
我们从10,000个开始 不断增加

00:04:41.748 --> 00:04:43.417 align:middle
直到10万 20万个

00:04:44.117 --> 00:04:46.119 align:middle
每一个对象都有自己的数据集合

00:04:46.720 --> 00:04:48.989 align:middle
我们要找到更新数据的最好方法

00:04:50.924 --> 00:04:53.360 align:middle
过去 你可能做过类似这样的事情

00:04:54.261 --> 00:04:55.929 align:middle
你把更新好的数据推送到GPU

00:04:55.996 --> 00:04:57.564 align:middle
可能是统一形式或其他

00:04:58.098 --> 00:05:00.567 align:middle
绑定一个着色器 一些缓冲 一些纹理

00:04:58.098 --> 00:05:00.567 align:middle
绑定一个着色器 一些缓冲 一些纹理

00:05:00.634 --> 00:05:01.535 align:middle
然后开始绘制

00:05:02.002 --> 00:05:03.370 align:middle
然后你推送更多的数据

00:05:03.770 --> 00:05:05.506 align:middle
绑定着色器 缓冲 纹理

00:05:05.572 --> 00:05:06.740 align:middle
绘制下一个对象

00:05:07.007 --> 00:05:09.877 align:middle
在我们的场景里 重复1万 2万次

00:05:10.410 --> 00:05:12.579 align:middle
但是我们想跳出这样的模式

00:05:12.646 --> 00:05:13.680 align:middle
尝试新的方法

00:05:16.016 --> 00:05:18.252 align:middle
如果我们可以预先加载所有数据

00:05:18.552 --> 00:05:22.055 align:middle
所有发出的指令 以及数据引用
都已经存在

00:05:22.623 --> 00:05:24.992 align:middle
GPU是一个非常强大的处理器

00:05:25.058 --> 00:05:26.393 align:middle
它不愿意等待

00:05:27.127 --> 00:05:30.831 align:middle
如果所有数据都已经就位
只需把GPU指向它即可

00:05:31.064 --> 00:05:32.599 align:middle
它会很高兴地开始处理

00:05:32.666 --> 00:05:34.101 align:middle
为我们处理所有的渲染

00:05:36.603 --> 00:05:38.071 align:middle
我们发出的每一个绘图调用

00:05:38.138 --> 00:05:41.141 align:middle
都可以引用合适的数据
都已经存在了

00:05:41.742 --> 00:05:43.744 align:middle
在我们的示例中 这一切很简单易懂

00:05:43.810 --> 00:05:46.280 align:middle
我们有一个绘图调用 引用了一组数据

00:05:46.580 --> 00:05:49.216 align:middle
第一个绘图调用引用第一组数据

00:05:49.283 --> 00:05:51.885 align:middle
第二个 第二组 依此类推

00:05:52.486 --> 00:05:53.921 align:middle
但并不是只有这种方法

00:05:54.221 --> 00:05:55.656 align:middle
实际上可以重复使用数据

00:05:56.456 --> 00:05:58.892 align:middle
我们有一些数据
如前面的这些 帧数据

00:05:59.693 --> 00:06:01.762 align:middle
可以从所有的绘图调用中引用

00:05:59.693 --> 00:06:01.762 align:middle
可以从所有的绘图调用中引用

00:06:01.895 --> 00:06:03.197 align:middle
或者 我们可以有一个绘图调用

00:06:03.263 --> 00:06:05.732 align:middle line:1
在不同的地方引用两组数据

00:06:06.133 --> 00:06:08.902 align:middle
如果你熟悉实例化的概念
其理念是很相近的

00:06:09.203 --> 00:06:12.172 align:middle
开始渲染的时候
所有的数据已经准备好

00:06:15.142 --> 00:06:16.577 align:middle
Metal是如何做到的？

00:06:17.377 --> 00:06:20.848 align:middle
在我们的应用里
新建一个单一Metal缓冲

00:06:21.014 --> 00:06:22.516 align:middle
这是我们的常量缓冲

00:06:22.616 --> 00:06:25.085 align:middle
它拥有我们需要用来渲染框架的
所有数据

00:06:25.552 --> 00:06:28.722 align:middle
我们想事先就新建好 在渲染循环之外

00:06:28.789 --> 00:06:30.490 align:middle
并且在每一次绘制中重新使用

00:06:31.058 --> 00:06:32.459 align:middle
我们不需要复制任何数据

00:06:32.893 --> 00:06:35.495 align:middle
再次强调
任何绘图调用可以引用任何数据

00:06:35.996 --> 00:06:37.598 align:middle
所以没有必要复制

00:06:38.465 --> 00:06:41.201 align:middle
每一个绘图调用都会
把一个偏移引用到缓冲

00:06:41.602 --> 00:06:45.105 align:middle
它会作一小部分跟踪处理
从而知道哪个绘图代表了哪个偏移

00:06:46.106 --> 00:06:48.775 align:middle
你可以运用一切绘图 一切都已经就位

00:06:49.176 --> 00:06:50.811 align:middle
我们来看看这部分代码

00:06:53.213 --> 00:06:54.515 align:middle
这是应用里的代码

00:06:54.781 --> 00:06:56.750 align:middle
你可以认为我们有两个数据集合

00:06:56.817 --> 00:06:59.319 align:middle
如我之前所讲 有一个帧数据集合

00:06:59.887 --> 00:07:01.054 align:middle
将在这里进行更新

00:06:59.887 --> 00:07:01.054 align:middle
将在这里进行更新

00:07:03.357 --> 00:07:05.926 align:middle
这是每个对象都发生改变的数据集合

00:07:06.293 --> 00:07:08.562 align:middle
这是唯一旋转位置 等等

00:07:09.796 --> 00:07:11.765 align:middle
我们需要把两组数据都准备好

00:07:16.870 --> 00:07:18.539 align:middle
我所说的每帧数据是什么意思呢？

00:07:19.473 --> 00:07:22.509 align:middle
这是每次进行绘图调用时
都保持一致的数据

00:07:23.377 --> 00:07:26.480 align:middle
比如 在本例中 有一个视图投影矩阵

00:07:26.547 --> 00:07:28.782 align:middle
这是个4X4的矩阵 很直观

00:07:28.849 --> 00:07:30.384 align:middle
如果你熟悉图像处理

00:07:30.450 --> 00:07:32.953 align:middle
它代表了照相机变换和投影

00:07:33.420 --> 00:07:35.255 align:middle
在框架范围内将不会发生改变

00:07:35.322 --> 00:07:36.757 align:middle
所以我们只需要一份副本

00:07:38.091 --> 00:07:39.993 align:middle
我们想要尽可能多地重复使用数据

00:07:40.894 --> 00:07:43.564 align:middle
所以我们新建一个副本 放入缓冲内

00:07:43.931 --> 00:07:45.265 align:middle
开始填充

00:07:47.234 --> 00:07:50.037 align:middle
在这里 是常量缓冲

00:07:50.103 --> 00:07:52.005 align:middle
也就是新建的Metal缓冲

00:07:52.072 --> 00:07:54.775 align:middle
通过Contents函数
我们有了一个指向它的指针

00:07:58.545 --> 00:08:01.281 align:middle
我们的应用有一个帮助函数
也就是取出帧数据

00:07:58.545 --> 00:08:01.281 align:middle
我们的应用有一个帮助函数
也就是取出帧数据

00:08:01.548 --> 00:08:04.418 align:middle
它将返回我刚演示过的主通路结构

00:08:04.484 --> 00:08:06.119 align:middle
里面有视图转换

00:08:06.186 --> 00:08:08.188 align:middle
视图投影转换
不好意思

00:08:08.922 --> 00:08:11.859 align:middle
之后只需简单地把它复制到缓冲的前端

00:08:12.826 --> 00:08:13.994 align:middle
然后一切就绪

00:08:15.028 --> 00:08:16.496 align:middle
我们的缓冲看上去将会是这样

00:08:16.563 --> 00:08:19.466 align:middle
我们有一个主通路 含有合适的帧数据

00:08:20.133 --> 00:08:22.669 align:middle
并且把它放到巨大的常量缓冲的前端

00:08:23.837 --> 00:08:25.973 align:middle
所以后面会有这一片空白区域

00:08:26.039 --> 00:08:29.543 align:middle
如之前所见
我们需要做1万次 2万次的绘图调用

00:08:29.776 --> 00:08:32.479 align:middle
所以需要开始在里面填充很多信息

00:08:35.249 --> 00:08:37.183 align:middle
然后我们有了一组每个对象数据

00:08:37.618 --> 00:08:40.153 align:middle
这是绘制单一对象所需要的唯一数据

00:08:40.888 --> 00:08:43.789 align:middle
在我们的例子里
有一个“局部空间到世界空间”转换

00:08:43.857 --> 00:08:46.493 align:middle
它是位置和旋转的串联

00:08:46.727 --> 00:08:47.761 align:middle
还有颜色

00:08:48.595 --> 00:08:50.931 align:middle
这就是每一个绘图调用所需的数据集合

00:08:56.403 --> 00:08:58.872 align:middle
我们会遍历想要渲染的每一个对象

00:08:59.673 --> 00:09:01.808 align:middle
记录偏移位置到缓冲

00:08:59.673 --> 00:09:01.808 align:middle
记录偏移位置到缓冲

00:09:02.309 --> 00:09:04.344 align:middle
我们有“更新数据”实用工具函数

00:09:04.411 --> 00:09:06.747 align:middle
它将更新旋转数据

00:09:06.813 --> 00:09:08.348 align:middle
然后更新偏移数据

00:09:08.649 --> 00:09:11.652 align:middle
这样将数据紧密封装
一边遍历一边填充

00:09:11.919 --> 00:09:14.588 align:middle
看看“更新数据”函数是什么样子

00:09:16.456 --> 00:09:17.391 align:middle
它非常简单

00:09:19.359 --> 00:09:22.329 align:middle
动画效果似乎不是本次演讲的范围

00:09:22.996 --> 00:09:26.600 align:middle
有一个小帮助函数 “更新动画”函数
带有“增量时间”参数

00:09:26.867 --> 00:09:28.969 align:middle
在你的应用里
可以按照自己的意愿编码

00:09:29.036 --> 00:09:30.204 align:middle
而且确实应该这样做

00:09:30.270 --> 00:09:31.939 align:middle
但是也要看你需要什么样的动画

00:09:33.507 --> 00:09:35.943 align:middle
在我的例子里
它返回一个对象数据对象

00:09:36.276 --> 00:09:38.478 align:middle
它有局部空间到世界空间转换和颜色

00:09:39.513 --> 00:09:43.283 align:middle
和之前一样 把它复制到常量缓冲

00:09:48.722 --> 00:09:50.123 align:middle
看上去是这个样子

00:09:50.624 --> 00:09:52.125 align:middle
帧数据已经准备完毕

00:09:55.996 --> 00:09:57.097 align:middle
还有别的数据

00:09:59.099 --> 00:10:01.635 align:middle
其他的数据 还有其他的

00:09:59.099 --> 00:10:01.635 align:middle
其他的数据 还有其他的

00:10:02.603 --> 00:10:05.439 align:middle line:1
所有的数据都到位了 我们准备好渲染

00:10:05.939 --> 00:10:07.307 align:middle
但是不是还缺了点什么？

00:10:10.377 --> 00:10:13.046 align:middle
确实缺了什么
我想要提醒你们注意的是

00:10:13.113 --> 00:10:14.615 align:middle
我们有一个常量缓冲

00:10:14.815 --> 00:10:17.551 align:middle
我说过新建一个Metal缓冲
然后反复使用

00:10:18.619 --> 00:10:19.753 align:middle
这样做有一个问题

00:10:19.820 --> 00:10:23.724 align:middle
CPU和GPU实际上是
两个不同的平行处理器

00:10:24.057 --> 00:10:26.693 align:middle
它们可以同时对同一内存进行读写

00:10:27.127 --> 00:10:28.562 align:middle
会发生什么 如果有函数

00:10:28.629 --> 00:10:31.532 align:middle
正在读一块内存 而另外有函数在写？

00:10:35.135 --> 00:10:36.236 align:middle
资源争用

00:10:39.039 --> 00:10:40.407 align:middle
看上去有点像这样

00:10:40.974 --> 00:10:43.911 align:middle
CPU准备好一个帧数据
写入一个缓存

00:10:45.779 --> 00:10:47.447 align:middle
GPU开始处理

00:10:49.516 --> 00:10:50.717 align:middle
它从缓存里读取数据

00:10:51.385 --> 00:10:53.387 align:middle
而CPU对这一切一无所知

00:10:53.453 --> 00:10:55.422 align:middle
它决定 我要准备下一帧数据

00:10:55.489 --> 00:10:57.291 align:middle
然后它开始覆盖相同的数据

00:10:59.526 --> 00:11:01.094 align:middle
现在结果变成未定义

00:10:59.526 --> 00:11:01.094 align:middle
现在结果变成未定义

00:11:01.161 --> 00:11:02.963 align:middle
我们不知道读入了什么

00:11:03.030 --> 00:11:05.832 align:middle
读出什么 或者写入什么
数据状态会是什么

00:11:08.769 --> 00:11:12.206 align:middle
所以认识到在Metal里
这不是隐式处理 这点很重要

00:11:12.573 --> 00:11:16.543 align:middle
CPU和GPU可以随意
同时写同样的数据

00:11:16.944 --> 00:11:18.779 align:middle
必须自己同步访问权限

00:11:19.613 --> 00:11:22.049 align:middle
就好像编写多线程的CPU代码

00:11:22.649 --> 00:11:25.052 align:middle
必须得确保没有踩到自己

00:11:28.388 --> 00:11:31.692 align:middle
这把我们带到了
CPU-GPU同步的主题

00:11:32.259 --> 00:11:33.260 align:middle
让我们从简单的开始

00:11:35.195 --> 00:11:38.131 align:middle
最简单的方法就是 等待

00:11:38.198 --> 00:11:40.367 align:middle
把指令提交给GPU之后

00:11:41.068 --> 00:11:43.036 align:middle
CPU绘图函数做好所有的工作

00:11:43.103 --> 00:11:45.239 align:middle
提交指令 然后就坐在那儿等

00:11:45.305 --> 00:11:47.441 align:middle
直到它确保GPU的工作完成

00:11:48.709 --> 00:11:50.644 align:middle
这样我们就知道永远不会覆盖

00:11:50.711 --> 00:11:53.981 align:middle
因为我们试图生产下一帧数据时
GPU是空闲的

00:11:55.115 --> 00:11:56.917 align:middle
这种做法不够快 但很安全

00:11:57.284 --> 00:12:00.220 align:middle
所以需要有某种机制
让GPU通知我们

00:11:57.284 --> 00:12:00.220 align:middle
所以需要有某种机制
让GPU通知我们

00:12:00.287 --> 00:12:02.322 align:middle
嘿 我工作完成 你开始做你的吧

00:12:04.391 --> 00:12:06.660 align:middle
Metal提供了这种机制
以回调的形式

00:12:06.860 --> 00:12:09.596 align:middle
我们称为处理程序 其中两种很有意思

00:12:10.697 --> 00:12:11.832 align:middle
“添加计划处理程序”

00:12:12.266 --> 00:12:16.703 align:middle
当命令缓冲被计划在GPU上运行时
将执行该处理程序

00:12:18.739 --> 00:12:22.075 align:middle
对我们来说 更有意思的是
“完成处理程序”

00:12:22.442 --> 00:12:23.577 align:middle
它将被调用

00:12:23.644 --> 00:12:26.246 align:middle
当GPU结束执行一个命令缓冲时

00:12:26.580 --> 00:12:28.615 align:middle
命令缓冲完全退休时

00:12:28.782 --> 00:12:31.952 align:middle
此时我们确定修改任何资源都是安全的

00:12:32.019 --> 00:12:33.120 align:middle
正在使用的任何资源

00:12:34.021 --> 00:12:34.922 align:middle
这样非常完美

00:12:34.988 --> 00:12:37.057 align:middle
我们只需要采用某种方法告诉自己

00:12:37.124 --> 00:12:39.026 align:middle
嘿 我们完成了 继续下一步

00:12:41.929 --> 00:12:44.665 align:middle
你们当中有多少人熟悉信号量的概念？

00:12:45.232 --> 00:12:46.133 align:middle
有谁知道？

00:12:47.034 --> 00:12:47.935 align:middle
很好

00:12:48.735 --> 00:12:50.270 align:middle
快速介绍一下信号量的背景

00:12:50.337 --> 00:12:51.638 align:middle
它们是同步基元

00:12:51.705 --> 00:12:54.575 align:middle
被用来控制有限资源的访问权限

00:12:54.641 --> 00:12:56.076 align:middle
应用在此堪称完美

00:12:56.510 --> 00:13:00.214 align:middle
我们有一个常量缓存
它是一个有限资源

00:12:56.510 --> 00:13:00.214 align:middle
我们有一个常量缓存
它是一个有限资源

00:13:00.280 --> 00:13:03.317 align:middle
我们将会新建一个信号量 初始值为1

00:13:03.383 --> 00:13:04.918 align:middle
信号量的值代表

00:13:04.985 --> 00:13:06.653 align:middle
有多少想要保护的有限资源

00:13:08.589 --> 00:13:09.756 align:middle
新建一个信号量

00:13:09.823 --> 00:13:12.392 align:middle
它应该建立在渲染循环以外

00:13:13.360 --> 00:13:15.362 align:middle
一旦开始绘图 第一件要做的事情

00:13:16.363 --> 00:13:17.698 align:middle
就是等待信号量

00:13:19.266 --> 00:13:21.168 align:middle
Apple里的信号量
称为“等待”

00:13:21.235 --> 00:13:23.403 align:middle
有人称它为“占据”
有人称之为“倒数”

00:13:23.470 --> 00:13:24.471 align:middle
无关紧要

00:13:24.838 --> 00:13:26.473 align:middle
理念就是等着它

00:13:26.540 --> 00:13:28.542 align:middle
把超时设置为遥远的未来

00:13:28.775 --> 00:13:30.644 align:middle
也就是说我们会永远等待下去

00:13:30.744 --> 00:13:32.946 align:middle
如果没有资源可用 线程会进入休眠

00:13:33.046 --> 00:13:34.381 align:middle
等着做点什么

00:13:36.483 --> 00:13:37.484 align:middle
我们结束后

00:13:37.751 --> 00:13:40.120 align:middle
在完成处理程序里 我们会通知信号量

00:13:41.021 --> 00:13:44.024 align:middle
那将会告诉我们 修改资源又安全了

00:13:45.092 --> 00:13:47.494 align:middle
工作已全部完成 可以进行下一步

00:13:50.397 --> 00:13:52.833 align:middle
这是一个有点幼稚的同步方法

00:13:52.900 --> 00:13:54.268 align:middle
看上去有点像这个样子

00:13:55.335 --> 00:13:57.004 align:middle
我们会把帧数据0写入缓冲

00:13:58.372 --> 00:14:01.041 align:middle
GPU从缓冲读取

00:13:58.372 --> 00:14:01.041 align:middle
GPU从缓冲读取

00:14:01.108 --> 00:14:02.276 align:middle
CPU将会等待

00:14:02.809 --> 00:14:05.212 align:middle
当GPU处理完帧数据0

00:14:05.279 --> 00:14:08.815 align:middle
它将发送完成处理程序
帧数据1开始工作

00:14:09.816 --> 00:14:11.685 align:middle
并将在CPU上新建一帧数据

00:14:12.953 --> 00:14:14.888 align:middle
GPU上会对其进行处理 依此类推

00:14:15.989 --> 00:14:19.193 align:middle
这种方法可行 但如你所见
有这么多等待时间

00:14:19.726 --> 00:14:22.496 align:middle
CPU和GPU实际上都有
一半的时间处于空闲

00:14:22.896 --> 00:14:25.265 align:middle
看上去并没有好好利用计算资源

00:14:27.568 --> 00:14:30.637 align:middle
我们想要做的是
重叠CPU和GPU的工作时间

00:14:31.338 --> 00:14:34.308 align:middle
这样就可以利用系统固有的并行机制

00:14:35.008 --> 00:14:37.344 align:middle
但还是需要想办法避免踩到数据

00:14:40.314 --> 00:14:42.716 align:middle
所以我们理想的工作量看上去是这样

00:14:44.017 --> 00:14:47.521 align:middle
第0帧将会在CPU上做好准备
推到GPU

00:14:47.588 --> 00:14:49.256 align:middle
当GPU处理它时

00:14:49.323 --> 00:14:54.595 align:middle
CPU开始新建帧数据1 等等
反复如此

00:14:56.597 --> 00:14:58.065 align:middle
在此谨记一点

00:14:58.632 --> 00:15:01.568 align:middle
CPU实际上要比GPU超前一点

00:14:58.632 --> 00:15:01.568 align:middle
CPU实际上要比GPU超前一点

00:15:01.768 --> 00:15:03.937 align:middle
请注意 当帧数据2在CPU上时

00:15:05.572 --> 00:15:07.574 align:middle
GPU上只有帧数据0是完成的

00:15:07.641 --> 00:15:08.609 align:middle
所以CPU有一点超前

00:15:08.675 --> 00:15:10.577 align:middle
也请你一直记住这点

00:15:12.446 --> 00:15:15.415 align:middle
来看看演示里的解决方案
看我们是怎么做的

00:15:16.683 --> 00:15:19.853 align:middle line:1
我们想要重叠CPU和GPU
但我们知道无法做到

00:15:19.920 --> 00:15:21.722 align:middle line:1
用一个常量缓冲 而不等待很长时间

00:15:21.989 --> 00:15:24.525 align:middle line:1
所以解决方案是新建一个缓冲池

00:15:26.927 --> 00:15:28.228 align:middle line:1
所以新建帧数据0

00:15:28.929 --> 00:15:30.197 align:middle line:1
把它写入一个缓冲

00:15:31.198 --> 00:15:32.332 align:middle line:1
然后CPU开始工作

00:15:32.399 --> 00:15:35.235 align:middle line:1
新建下一个帧数据 写入另一个缓冲

00:15:36.336 --> 00:15:38.639 align:middle line:1
此时 GPU可以自由从缓冲中读取

00:15:38.705 --> 00:15:40.274 align:middle line:1
之前的那个缓冲

00:15:41.742 --> 00:15:43.477 align:middle line:1
我们没有无限的缓冲

00:15:43.544 --> 00:15:45.078 align:middle line:1
因为没有无限的内存

00:15:45.145 --> 00:15:46.647 align:middle line:1
所以缓冲池必须得有个限额

00:15:47.047 --> 00:15:48.882 align:middle line:1
在我们的应用中 我们选择了3个

00:15:49.316 --> 00:15:51.151 align:middle line:1
这部分你得自己决定

00:15:51.218 --> 00:15:52.486 align:middle line:1
我们无法告诉你怎么做

00:15:53.320 --> 00:15:55.856 align:middle line:1
因为要考虑延迟的问题

00:15:56.323 --> 00:15:57.858 align:middle
想要用多少内存

00:15:58.225 --> 00:16:00.894 align:middle
所以我们建议你测试自己的应用
了解多少是最合适的

00:15:58.225 --> 00:16:00.894 align:middle
所以我们建议你测试自己的应用
了解多少是最合适的

00:16:01.929 --> 00:16:03.697 align:middle
本例中 我们选择3个

00:16:06.033 --> 00:16:08.669 align:middle
在这里 可以看到缓冲池用完了

00:16:08.735 --> 00:16:10.204 align:middle
我们准备好3帧数据

00:16:10.270 --> 00:16:11.805 align:middle
但GPU只处理完成了一帧

00:16:12.105 --> 00:16:13.207 align:middle
所以得等一会儿

00:16:15.609 --> 00:16:17.144 align:middle
现在 帧数据0已经完成

00:16:17.211 --> 00:16:20.747 align:middle
所以可再次使用池里的缓冲 如此继续

00:16:28.388 --> 00:16:29.590 align:middle
来看一下代码

00:16:30.490 --> 00:16:32.492 align:middle
同步常量缓冲的访问权限

00:16:32.759 --> 00:16:34.328 align:middle
我们已经有了一个信号量

00:16:34.394 --> 00:16:37.130 align:middle
它可以很好地控制有限资源的访问权限

00:16:37.197 --> 00:16:38.565 align:middle
在本例中 我们的限制是3

00:16:39.099 --> 00:16:40.234 align:middle
但这个数字可随意设定

00:16:41.335 --> 00:16:43.637 align:middle
在这里按照限制数字
新建了一个信号量

00:16:44.605 --> 00:16:46.673 align:middle
我们不再只新建一个常量缓冲

00:16:46.740 --> 00:16:48.041 align:middle
而是新建一个缓冲数组

00:16:50.344 --> 00:16:51.278 align:middle
最后

00:16:52.179 --> 00:16:53.380 align:middle
需要一个索引

00:16:53.847 --> 00:16:55.516 align:middle
我们用这个索引表示

00:16:55.582 --> 00:16:57.851 align:middle
当前可用的常量缓冲数

00:16:58.318 --> 00:17:00.521 align:middle
我们可以遍历数组并回返

00:16:58.318 --> 00:17:00.521 align:middle
我们可以遍历数组并回返

00:17:00.587 --> 00:17:03.123 align:middle
信号量会控制我们的访问权限
和保护我们

00:17:07.227 --> 00:17:10.364 align:middle
所以在绘图函数里
我们会立即等待信号量

00:17:11.031 --> 00:17:12.900 align:middle
如果没有可用缓冲 就进入休眠

00:17:14.101 --> 00:17:15.903 align:middle
一旦取得信号量 就开始工作

00:17:15.969 --> 00:17:18.204 align:middle
我们知道获取当前的
常量缓冲是安全的

00:17:18.906 --> 00:17:22.108 align:middle
在索引中 “当前常量缓冲”
记录哪个资源可用

00:17:23.710 --> 00:17:26.413 align:middle
然后正常填写帧数据 编码所有命令

00:17:26.480 --> 00:17:29.283 align:middle
进行更新 添加完成处理程序

00:17:30.751 --> 00:17:33.320 align:middle
然后我们通知信号量
说嘿 该帧数据处理完了

00:17:33.554 --> 00:17:34.488 align:middle
你可以进行下一步了

00:17:35.522 --> 00:17:38.225 align:middle
最后要做的是更新索引

00:17:39.293 --> 00:17:41.562 align:middle
我们加上1 我们取模进行环绕

00:17:42.196 --> 00:17:44.364 align:middle
我们不用担心覆盖自身

00:17:44.431 --> 00:17:45.899 align:middle
因为信号量会保护我们

00:17:48.802 --> 00:17:50.437 align:middle
这就是演示中的常量缓冲

00:17:51.138 --> 00:17:52.940 align:middle
演示里有一个3个缓冲的数列

00:17:53.407 --> 00:17:55.509 align:middle
但我也看过有些应用会跟踪缓冲

00:17:55.576 --> 00:17:59.079 align:middle
把它们标记为
该缓冲正在被帧数据7读取

00:17:59.146 --> 00:18:00.881 align:middle
该缓冲正在被帧数据5写入

00:17:59.146 --> 00:18:00.881 align:middle
该缓冲正在被帧数据5写入

00:18:01.215 --> 00:18:03.317 align:middle
在本模式下 我们不需要这么做

00:18:03.383 --> 00:18:05.819 align:middle
信号量为你做所有同步的工作

00:18:06.987 --> 00:18:08.355 align:middle
而且如果你取得了信号量

00:18:08.422 --> 00:18:11.158 align:middle
你可以确认最后正在使用
该资源的帧数据已经结束

00:18:11.225 --> 00:18:12.426 align:middle
否则你还会处于休眠

00:18:14.728 --> 00:18:17.698 align:middle
所以现在数据都已经准备好
并且受到保护

00:18:19.533 --> 00:18:22.169 align:middle
我们想要发出一些绘图调用

00:18:22.236 --> 00:18:23.570 align:middle
在屏幕上显示一些图像

00:18:27.140 --> 00:18:29.510 align:middle
这就是本演示的基本渲染循环

00:18:30.911 --> 00:18:33.547 align:middle
我们有两个通路：
一个通路绘制阴影映射

00:18:33.981 --> 00:18:35.549 align:middle
一个通路读取该阴影映射

00:18:36.016 --> 00:18:38.852 align:middle
我们决定把它们分成
两个独立的命令缓冲

00:18:39.319 --> 00:18:40.554 align:middle
这样做有一个很好的理由

00:18:40.921 --> 00:18:43.123 align:middle
它让我们有两个编码函数

00:18:43.190 --> 00:18:44.591 align:middle
是独立和唯一的

00:18:45.025 --> 00:18:46.493 align:middle
它们不依赖于彼此

00:18:46.793 --> 00:18:49.229 align:middle
你编码阴影通路 你把它传到命令缓冲

00:18:49.296 --> 00:18:51.498 align:middle
以及你已经填写的常量缓冲

00:18:51.932 --> 00:18:54.501 align:middle
它会编码所有的命令 渲染阴影映射

00:18:55.302 --> 00:18:58.272 align:middle
然后你有了一个独立的编码函数
可以编码主通路

00:18:58.338 --> 00:19:00.908 align:middle
把它传到主命令缓冲
以及其他所需数据

00:18:58.338 --> 00:19:00.908 align:middle
把它传到主命令缓冲
以及其他所需数据

00:19:00.974 --> 00:19:02.643 align:middle
编码所有其他的命令

00:19:03.410 --> 00:19:04.878 align:middle
编码结束时

00:19:05.145 --> 00:19:07.748 align:middle
调用提交两个命令缓冲

00:19:07.981 --> 00:19:10.384 align:middle
输出 帧数据处理完毕

00:19:14.221 --> 00:19:17.291 align:middle
那么 如何真正编码绘制
其中一个立方体？

00:19:17.791 --> 00:19:20.561 align:middle
我们需要一组数据
而不仅仅是旋转数据

00:19:21.295 --> 00:19:23.330 align:middle
我们需要立方体的一些几何数据

00:19:23.530 --> 00:19:24.898 align:middle
这非常简单 你知道

00:19:24.965 --> 00:19:27.968 align:middle
把立方体想成是8个顶点
也许还有一个索引缓冲

00:19:29.102 --> 00:19:32.239 align:middle
在本例中 我们不需要任何复杂的材料

00:19:32.306 --> 00:19:33.974 align:middle
只需用到很简单的漫反射着色

00:19:34.408 --> 00:19:36.777 align:middle
因此我们可以重复使用管道状态对象

00:19:36.844 --> 00:19:38.011 align:middle
在所有立方体范围内

00:19:39.046 --> 00:19:40.681 align:middle
我们之前提到过每帧数据

00:19:40.747 --> 00:19:41.915 align:middle
我们需要它的一份副本

00:19:42.282 --> 00:19:44.117 align:middle
我们更新它 准备好

00:19:44.818 --> 00:19:46.687 align:middle
当然我们还需要 每光学数据

00:19:47.020 --> 00:19:50.457 align:middle
以及我们动画里展示
的 LocalToWorld和颜色信息

00:19:52.559 --> 00:19:54.094 align:middle
所以当发出绘图调用时

00:19:54.895 --> 00:19:56.663 align:middle
我们想确保引用了正确的数据

00:19:57.364 --> 00:19:59.433 align:middle
所以编码器会产生命令

00:19:59.499 --> 00:20:00.801 align:middle
把它们放入命令缓冲

00:19:59.499 --> 00:20:00.801 align:middle
把它们放入命令缓冲

00:20:01.168 --> 00:20:02.236 align:middle
绘图调用0

00:20:02.302 --> 00:20:05.873 align:middle
将会引用帧数据和我们感兴趣的对象

00:20:06.907 --> 00:20:09.576 align:middle
绘图调用1 同样 将会引用帧数据

00:20:10.410 --> 00:20:12.913 align:middle
和对象1数据 依此类推

00:20:14.248 --> 00:20:15.349 align:middle
这样一切都会准备好

00:20:15.415 --> 00:20:18.452 align:middle
发出调用 GPU开始处理

00:20:20.888 --> 00:20:22.756 align:middle
现在我们有很多调用要发出

00:20:22.923 --> 00:20:25.526 align:middle
你知道 在演示中 至少有1万个

00:20:26.360 --> 00:20:28.629 align:middle
我们想尽可能高效地发出调用

00:20:29.530 --> 00:20:31.632 align:middle
我们想避免重复的工作

00:20:31.698 --> 00:20:33.667 align:middle
不想每一次绘制就进行重设

00:20:33.967 --> 00:20:37.371 align:middle
所有共享资源 几何 管道状态

00:20:37.504 --> 00:20:40.140 align:middle
我们只想设一次 然后保持

00:20:40.974 --> 00:20:42.843 align:middle
这样就可以避免重复的状态更新

00:20:43.143 --> 00:20:45.045 align:middle
并且避免重复的变量表格更新

00:20:46.146 --> 00:20:48.315 align:middle
还有一点值得注意

00:20:48.382 --> 00:20:51.151 align:middle
顶点和片段变量表是完全分开的

00:20:52.052 --> 00:20:54.021 align:middle
你可以将缓冲绑定在顶点阶段

00:20:54.087 --> 00:20:55.989 align:middle
而不是片段阶段 反之同理

00:20:56.590 --> 00:20:58.325 align:middle
但若必须要把所有绑定到两个阶段

00:20:58.392 --> 00:21:02.062 align:middle
调用“设置顶点缓冲”函数时
可能会调用两次

00:20:58.392 --> 00:21:02.062 align:middle
调用“设置顶点缓冲”函数时
可能会调用两次

00:21:02.129 --> 00:21:03.564 align:middle
“设置片段缓冲”函数也是如此

00:21:03.630 --> 00:21:06.633 align:middle
这就是为什么在本例
没有使用“设置顶点字节”函数

00:21:07.267 --> 00:21:09.803 align:middle
你可以想像
我们有50,000个对象

00:21:10.137 --> 00:21:12.973 align:middle
必须把所有那些数据复制两遍

00:21:13.040 --> 00:21:15.342 align:middle
一遍在顶点阶段 一遍在片段阶段

00:21:15.576 --> 00:21:16.810 align:middle
很快工作量会变得很大

00:21:17.678 --> 00:21:19.847 align:middle
而如果把所有数据放入一个缓冲
只需引用它

00:21:19.913 --> 00:21:21.181 align:middle
我们就不用担心该问题了

00:21:22.182 --> 00:21:23.884 align:middle
最后我想指出的是

00:21:24.718 --> 00:21:25.919 align:middle
使用新函数

00:21:26.887 --> 00:21:30.224 align:middle
“设置顶点缓冲偏移”和
“设置片段缓冲偏移”

00:21:31.091 --> 00:21:34.328 align:middle
这只是把指针指向其中一个缓冲

00:21:36.830 --> 00:21:38.699 align:middle
可以看到 在调用这些函数时

00:21:38.765 --> 00:21:41.034 align:middle
它们并没有把引用放入Metal缓冲

00:21:41.401 --> 00:21:44.438 align:middle
它们只取出了一个偏移和一个索引

00:21:45.072 --> 00:21:48.375 align:middle
因为你肯定已经设置该指针指向缓冲

00:21:48.876 --> 00:21:50.677 align:middle
这样缓冲内部的指针也随之改变

00:21:50.944 --> 00:21:52.279 align:middle
这就是我们想要实现的

00:21:52.713 --> 00:21:55.282 align:middle
我们有一个常量缓冲 正在遍历

00:21:55.782 --> 00:21:57.451 align:middle
所以可以在一开始只设置一次

00:21:57.918 --> 00:22:00.988 align:middle
然后每一次绘制时
就调用“设置顶点缓冲偏移”函数

00:21:57.918 --> 00:22:00.988 align:middle
然后每一次绘制时
就调用“设置顶点缓冲偏移”函数

00:22:01.488 --> 00:22:04.458 align:middle
并且把下一个绘图调用
指向缓冲中正确的位置

00:22:05.092 --> 00:22:06.460 align:middle
看上去有点像这样

00:22:07.294 --> 00:22:08.762 align:middle
绑定该常量缓冲

00:22:09.329 --> 00:22:11.164 align:middle
然后调用“设置顶点缓冲偏移”函数

00:22:12.199 --> 00:22:13.200 align:middle
用该偏移量作为参数

00:22:14.601 --> 00:22:16.937 align:middle
然后再次调用 继续往前

00:22:18.238 --> 00:22:19.606 align:middle
再一次往前

00:22:20.274 --> 00:22:22.809 align:middle
我们并没有修改该索引指定的缓冲

00:22:22.943 --> 00:22:24.945 align:middle
我们只是修改了缓冲里的偏移值

00:22:28.148 --> 00:22:29.683 align:middle
记住这些原则

00:22:29.750 --> 00:22:31.585 align:middle
编码其实非常简单

00:22:33.654 --> 00:22:35.289 align:middle
可以事先设置好一组数据

00:22:35.589 --> 00:22:37.524 align:middle
每帧常量是很显然的

00:22:37.591 --> 00:22:39.059 align:middle
因为我们知道会修改它

00:22:39.126 --> 00:22:40.027 align:middle
所以一起来设置

00:22:41.395 --> 00:22:44.698 align:middle
我们将一次设定常量缓冲
因为它必须要准备好

00:22:44.765 --> 00:22:47.267 align:middle
我们才能使用设置顶点缓冲偏移函数

00:22:49.102 --> 00:22:51.705 align:middle
还会设置几何缓冲 和管道状态

00:22:51.772 --> 00:22:53.874 align:middle
我们知道整个立方体范围内
它们是共享的

00:22:55.609 --> 00:22:58.512 align:middle
然后终于可以开始循环
通过想要绘制的对象

00:22:59.980 --> 00:23:01.982 align:middle
设置当前绘图调用

00:22:59.980 --> 00:23:01.982 align:middle
设置当前绘图调用

00:23:02.049 --> 00:23:02.916 align:middle
常量缓冲的偏移值

00:23:05.052 --> 00:23:06.420 align:middle
然后我们真正开始绘图

00:23:11.325 --> 00:23:14.061 align:middle
这里是 "编码主要通路"
函数的代码

00:23:14.261 --> 00:23:15.095 align:middle
在例子里的

00:23:16.463 --> 00:23:18.432 align:middle
首先设置顶点缓冲

00:23:18.498 --> 00:23:20.901 align:middle
那是几何和渲染管道状态

00:23:21.235 --> 00:23:22.870 align:middle
也就是光照阴影管道

00:23:25.138 --> 00:23:26.373 align:middle
我们将会设置常量缓冲

00:23:26.440 --> 00:23:28.408 align:middle
在之后调用
“设置顶点缓冲偏移”函数

00:23:28.575 --> 00:23:32.179 align:middle
在本例中把它传给顶点和片段阶段

00:23:34.715 --> 00:23:36.116 align:middle
然后设置每帧数据

00:23:38.352 --> 00:23:40.287 align:middle
你现在看到
我已设置了一个常量缓冲

00:23:40.354 --> 00:23:43.323 align:middle
有两个分开的索引 和不同的偏移

00:23:43.390 --> 00:23:45.225 align:middle
Metal允许你随意这样做

00:23:45.826 --> 00:23:48.529 align:middle
可以把同样的常量缓冲设给每一个索引

00:23:48.595 --> 00:23:51.231 align:middle
带有不同的偏移 如果你愿意的话
完全取决于你

00:23:54.001 --> 00:23:55.502 align:middle
接下来马上看看缓冲池

00:23:56.436 --> 00:23:59.106 align:middle
我们需要追踪偏移 因为我们不是

00:23:59.173 --> 00:24:00.774 align:middle
在常量缓冲的开始部分开始的

00:23:59.173 --> 00:24:00.774 align:middle
在常量缓冲的开始部分开始的

00:24:00.841 --> 00:24:02.142 align:middle
还有一些帧数据在那里

00:24:02.609 --> 00:24:04.945 align:middle
所以偏移将会被推回 经过帧数据

00:24:06.747 --> 00:24:09.950 align:middle
然后将调用“设置顶点缓冲偏移”
及“设置片段缓冲偏移”函数

00:24:10.884 --> 00:24:13.687 align:middle
来把该绘图调用指向要绘制的正确数据

00:24:15.422 --> 00:24:16.623 align:middle
发出绘图调用

00:24:17.357 --> 00:24:22.095 align:middle
然后再次设置偏移 一次完成一个对象

00:24:25.065 --> 00:24:26.400 align:middle
绘图都准备好了

00:24:27.301 --> 00:24:28.569 align:middle
这仍然是非常线性

00:24:28.669 --> 00:24:30.304 align:middle
我答应做一些多线程编程

00:24:30.671 --> 00:24:31.972 align:middle
并且Warren提过

00:24:32.039 --> 00:24:34.208 align:middle
可以在Metal里进行平行编码

00:24:34.808 --> 00:24:36.009 align:middle
该怎么做？

00:24:37.244 --> 00:24:38.912 align:middle
一个理想框架看上应该是这样

00:24:38.979 --> 00:24:41.982 align:middle
渲染线程正在埋头苦干
然后它意识到 嘿

00:24:42.049 --> 00:24:44.518 align:middle
我得渲染一个阴影映射
还得渲染一个主通路

00:24:44.885 --> 00:24:46.587 align:middle
要是我能并行编码就好了

00:24:47.087 --> 00:24:48.555 align:middle
我有很多CPU

00:24:49.056 --> 00:24:52.059 align:middle
如果能调度一些工作出去
进行一些编码

00:24:53.227 --> 00:24:54.795 align:middle
然后回来继续参与渲染线程

00:24:54.862 --> 00:24:57.497 align:middle
然后渲染线程把它推给GPU

00:24:57.564 --> 00:24:58.665 align:middle
让GPU做接下来的工作

00:24:58.966 --> 00:24:59.933 align:middle
这种方法一定非常好

00:25:03.570 --> 00:25:05.572 align:middle
你们中有多少人
用过GCD（大中央调度）？

00:25:07.040 --> 00:25:09.076 align:middle
此时非常适合使用大中央调度

00:25:09.142 --> 00:25:12.813 align:middle
大中央调度是
Apple的多处理API

00:25:13.280 --> 00:25:15.282 align:middle
该API让你新建队列

00:25:15.782 --> 00:25:17.818 align:middle
这些队列管理计算资源

00:25:18.252 --> 00:25:19.152 align:middle
在你的机器上

00:25:19.720 --> 00:25:21.188 align:middle
可以新建两种类型的队列

00:25:21.655 --> 00:25:22.823 align:middle
一种是串行队列

00:25:23.357 --> 00:25:25.192 align:middle
当你通过串行队列调度工作时

00:25:25.259 --> 00:25:27.594 align:middle
可以保证所有工作都按照顺序处理

00:25:28.629 --> 00:25:31.832 align:middle
但对我们来说更有意思的是并发队列

00:25:32.833 --> 00:25:34.701 align:middle
当你把工作调度给并发队列

00:25:35.102 --> 00:25:36.537 align:middle
大中央调度会查看系统

00:25:36.603 --> 00:25:38.539 align:middle
为你做出最好的安排

00:25:39.273 --> 00:25:40.107 align:middle
这非常完美

00:25:40.174 --> 00:25:42.109 align:middle
我们有两个需要并行的作业

00:25:42.809 --> 00:25:45.812 align:middle
所以我们新建这一个队列
把工作推送给它

00:25:46.213 --> 00:25:47.247 align:middle
它会帮我完成

00:25:48.515 --> 00:25:51.084 align:middle
有另一个对象你想新建一次
并可以重复使用

00:25:51.518 --> 00:25:53.754 align:middle
这里是一些新建并发调度队列的代码

00:25:54.254 --> 00:25:55.789 align:middle
你应该始终为队列加上标签

00:25:55.856 --> 00:25:57.925 align:middle
在此我使用了
非常具有创造性的标签队列

00:25:58.592 --> 00:25:59.993 align:middle
但你也许想称呼它别的名称

00:26:03.730 --> 00:26:05.499 align:middle
所以我们修改了部分代码

00:26:06.533 --> 00:26:08.468 align:middle
一开始还是新建命令缓冲

00:26:09.870 --> 00:26:13.440 align:middle
但是既然我们如此聪明
会使用两个命令缓冲

00:26:13.674 --> 00:26:16.577 align:middle
并把编码函数分成两个不同的函数

00:26:16.777 --> 00:26:19.379 align:middle
我们除了调度工作外
没什么别的事情可做

00:26:20.480 --> 00:26:22.115 align:middle
所以dispatchQueue.async

00:26:22.549 --> 00:26:25.519 align:middle
是大中央调度中用来调度工作的主调用

00:26:25.853 --> 00:26:27.154 align:middle
这是一个异步调用

00:26:27.554 --> 00:26:30.357 align:middle
它将推送工作 线程将会继续

00:26:31.425 --> 00:26:34.294 align:middle
在这里我们调度了阴影通路

00:26:36.163 --> 00:26:37.598 align:middle
然后我们调度了主通路

00:26:39.299 --> 00:26:40.934 align:middle
我们得想办法提交该工作

00:26:41.535 --> 00:26:43.203 align:middle
所以我们调用“调度障碍同步”

00:26:43.837 --> 00:26:47.007 align:middle
这将确保此时所有的工作都已经完成

00:26:48.675 --> 00:26:52.012 align:middle
最终我们重新加入 提交工作

00:26:52.779 --> 00:26:54.281 align:middle
在这里 顺序是很重要的

00:26:54.882 --> 00:26:57.417 align:middle
阴影映射必须在我们要引用的时候完成

00:26:57.885 --> 00:27:00.187 align:middle
所以必须首先提交阴影命令缓冲

00:26:57.885 --> 00:27:00.187 align:middle
所以必须首先提交阴影命令缓冲

00:27:00.554 --> 00:27:02.122 align:middle
之后是主命令缓冲

00:27:04.892 --> 00:27:06.593 align:middle
在这里我还想提出一点

00:27:07.427 --> 00:27:09.630 align:middle
你们之中有多少人熟悉“闭包”的概念

00:27:12.232 --> 00:27:13.066 align:middle
很好

00:27:13.300 --> 00:27:16.737 align:middle
有多少人曾经在闭包捕获自身时
遇到过问题

00:27:16.904 --> 00:27:18.839 align:middle
你以为自己在引用别的？

00:27:20.507 --> 00:27:22.142 align:middle
你们可诚实作答
我们都会发生

00:27:22.943 --> 00:27:24.311 align:middle
我只是想提出这一点

00:27:24.478 --> 00:27:25.846 align:middle
闭包捕获自身

00:27:25.913 --> 00:27:29.349 align:middle
如果你正在引用一个成员变量
或其中的成员变量

00:27:29.616 --> 00:27:32.019 align:middle
而你并没明确指定self.iVar

00:27:32.286 --> 00:27:34.555 align:middle
它还是会引用那个变量

00:27:35.122 --> 00:27:38.792 align:middle
如果你想确保引用正确的数据

00:27:39.493 --> 00:27:43.263 align:middle
在外部捕获它是一个好方法
我将会马上对此进行演示

00:27:45.732 --> 00:27:47.734 align:middle
这两样东西做的事情不一样

00:27:48.468 --> 00:27:50.604 align:middle
第一个调用中 编码阴影通路的地方

00:27:50.671 --> 00:27:52.639 align:middle
可以看到正在获取的常量缓冲

00:27:52.706 --> 00:27:55.142 align:middle
独立于self.constantBufferSlot之外

00:27:55.843 --> 00:27:58.745 align:middle
我实际上并不知道它执行时会怎么样

00:27:59.046 --> 00:28:00.747 align:middle
这是真正的异步编程

00:27:59.046 --> 00:28:00.747 align:middle
这是真正的异步编程

00:28:00.814 --> 00:28:04.017 align:middle
所以当调度正在运行时

00:28:04.351 --> 00:28:05.786 align:middle
它已经背着我发生了改变

00:28:06.386 --> 00:28:08.989 align:middle
也许是对的 也许不对 我无法保证

00:28:13.260 --> 00:28:15.195 align:middle
所以请谨记这点 不要那样做

00:28:16.029 --> 00:28:17.865 align:middle
相反 我们想捕捉一个引用

00:28:17.931 --> 00:28:19.600 align:middle
到我们感兴趣的常量缓冲中

00:28:20.167 --> 00:28:22.135 align:middle
所以在这里 取出常量缓冲

00:28:22.536 --> 00:28:23.770 align:middle
把它从数列里拿出去

00:28:24.972 --> 00:28:26.607 align:middle
然后再发出调度

00:28:26.974 --> 00:28:29.510 align:middle
引用已经获取的缓冲

00:28:29.576 --> 00:28:32.379 align:middle
这样就能保证
确切知道读取的是哪个数据

00:28:37.651 --> 00:28:39.052 align:middle
这就是多线程编程的趣味

00:28:39.553 --> 00:28:41.555 align:middle
示例中的实际代码看上去是这样

00:28:42.956 --> 00:28:44.391 align:middle
捕捉常量缓冲

00:28:46.593 --> 00:28:50.297 align:middle
当使用它时 保证用的是正确的那个

00:28:50.364 --> 00:28:51.798 align:middle
是已经捕捉的那个

00:28:52.399 --> 00:28:54.268 align:middle
知道正在使用该帧数据的常量缓冲

00:28:56.003 --> 00:28:58.539 align:middle
我之前提过“排序”以及它非常重要

00:29:00.007 --> 00:29:02.242 align:middle
当新建一个命令缓冲 提交

00:29:03.043 --> 00:29:05.312 align:middle
GPU上执行的顺序

00:29:06.480 --> 00:29:08.348 align:middle
通过你提交到GPU上的顺序来表示

00:29:08.415 --> 00:29:10.617 align:middle
所以如果先提交阴影命令缓冲

00:29:10.684 --> 00:29:12.286 align:middle
再提交主命令缓冲

00:29:12.553 --> 00:29:15.722 align:middle
可以确保在GPU先执行阴影

00:29:15.789 --> 00:29:17.457 align:middle
接着再执行主命令缓冲

00:29:17.758 --> 00:29:20.294 align:middle
有时我们把这称为 隐式命令缓冲排序

00:29:22.529 --> 00:29:24.565 align:middle
但是可以变得显式一点

00:29:25.766 --> 00:29:27.634 align:middle
Metal提供了“排队”函数

00:29:27.701 --> 00:29:29.436 align:middle
强制执行命令缓冲排序

00:29:30.237 --> 00:29:32.806 align:middle
如果有一组命令缓冲 可以把它们排队

00:29:33.207 --> 00:29:35.242 align:middle
这样可以确保它们按照那个顺序被执行

00:29:35.309 --> 00:29:37.611 align:middle
不论提交方法和提交时间

00:29:38.579 --> 00:29:40.681 align:middle
这是非常酷的方法 因为它允许你

00:29:40.747 --> 00:29:43.383 align:middle
从多重线程上提交命令缓冲
按任何顺序

00:29:44.017 --> 00:29:45.285 align:middle
而你完全不用为此操心

00:29:45.619 --> 00:29:48.422 align:middle
运行时将会确保运行顺序是正确的

00:29:49.890 --> 00:29:51.658 align:middle
我们来看看如何在代码里实现

00:29:52.926 --> 00:29:54.127 align:middle
新加了一些内容

00:29:54.561 --> 00:29:56.163 align:middle
当新建命令缓冲时

00:29:56.230 --> 00:29:57.898 align:middle
马上按照顺序把它们排队

00:29:58.265 --> 00:29:59.266 align:middle
顺序很重要

00:29:59.333 --> 00:30:02.035 align:middle
所以我们还是会让阴影命令缓冲先排队

00:29:59.333 --> 00:30:02.035 align:middle
所以我们还是会让阴影命令缓冲先排队

00:30:02.536 --> 00:30:03.904 align:middle
然后是主命令缓冲

00:30:05.572 --> 00:30:06.907 align:middle
但是现在 当我们调度时

00:30:07.241 --> 00:30:09.810 align:middle
我们可以从别的线程上提交

00:30:10.277 --> 00:30:12.112 align:middle
再次强调 运行时候将会确保

00:30:12.980 --> 00:30:13.814 align:middle
顺序正确

00:30:13.881 --> 00:30:15.616 align:middle
所以我们不用为此担心

00:30:16.316 --> 00:30:19.052 align:middle
这实际上移除了之前的障碍

00:30:19.286 --> 00:30:22.155 align:middle
因为不必重新加入 再提交命令缓冲了

00:30:22.222 --> 00:30:23.724 align:middle
它们已经自己提交了

00:30:26.527 --> 00:30:28.962 align:middle
我似乎跳过了所有的同步内容

00:30:29.029 --> 00:30:30.297 align:middle
不久前我刚说起过

00:30:30.764 --> 00:30:32.466 align:middle
我们还是需要了解 因为我们还是

00:30:32.533 --> 00:30:34.268 align:middle
会自我覆盖 如果我们不同步的话

00:30:34.801 --> 00:30:37.604 align:middle
所以能否把同样的同步原理

00:30:37.938 --> 00:30:39.840 align:middle
应用到这个多线程世界？

00:30:42.109 --> 00:30:45.112 align:middle
答案是可以 并且实际上它非常直观

00:30:46.180 --> 00:30:49.349 align:middle
回到友善的信号量 还有常量缓冲数列

00:30:49.416 --> 00:30:51.652 align:middle
记住取出你想要的正确缓冲

00:30:52.819 --> 00:30:56.123 align:middle
一开始 等待信号量
如果没有可用缓冲就进入休眠

00:30:57.457 --> 00:31:01.662 align:middle
我们已用排队强制执行了顺序 推出去

00:30:57.457 --> 00:31:01.662 align:middle
我们已用排队强制执行了顺序 推出去

00:31:03.430 --> 00:31:07.067 align:middle
我们知道 主命令缓冲是
框架里最后的命令缓冲

00:31:07.768 --> 00:31:10.470 align:middle
且我们知道要通知帧数据已经处理完毕

00:31:11.171 --> 00:31:14.575 align:middle
所以应把完成处理程序加到主命令缓冲

00:31:14.641 --> 00:31:16.944 align:middle
可以在调度内部完成

00:31:18.579 --> 00:31:20.914 align:middle
主命令缓冲是最终命令缓冲

00:31:20.981 --> 00:31:24.017 align:middle
我们为它添加上完成处理程序
用来通知信号量

00:31:24.084 --> 00:31:27.054 align:middle
在调度内部提交它 如之前所做的那样

00:31:28.121 --> 00:31:31.124 align:middle
现在你可能注意到
我引用self.semaphore

00:31:31.391 --> 00:31:33.527 align:middle
不久前我刚告诉你要注意这点

00:31:33.961 --> 00:31:34.995 align:middle
所以发生了什么？

00:31:35.596 --> 00:31:38.665 align:middle
结果是信号量是一个同步图元

00:31:39.233 --> 00:31:41.502 align:middle
我们确实想要用同一个

00:31:41.568 --> 00:31:42.836 align:middle
和所有其他线程一样

00:31:43.403 --> 00:31:45.172 align:middle
所以需要知道信号量的值

00:31:45.239 --> 00:31:46.907 align:middle
在线程正在执行的时候

00:31:48.141 --> 00:31:50.944 align:middle
所以在本例中确实
需要self.semaphore

00:31:51.011 --> 00:31:52.679 align:middle
需要时刻注意

00:31:56.283 --> 00:31:58.585 align:middle
这是渲染的方法

00:31:59.419 --> 00:32:02.122 align:middle
在渲染函数的开始 等待信号量

00:31:59.419 --> 00:32:02.122 align:middle
在渲染函数的开始 等待信号量

00:32:03.390 --> 00:32:05.192 align:middle
选择并发常量缓冲

00:32:06.426 --> 00:32:08.462 align:middle
把数据写入常量缓冲

00:32:08.529 --> 00:32:10.697 align:middle
也代表了所有的对象

00:32:11.565 --> 00:32:13.767 align:middle
把命令编码到命令缓冲

00:32:13.834 --> 00:32:16.937 align:middle
可以单线程编码
也可以多线程 随你所愿

00:32:17.704 --> 00:32:20.641 align:middle
在最终命令缓冲里
加上一个完成处理程序

00:32:21.008 --> 00:32:24.344 align:middle
用它来通知信号量 完成时通知我们

00:32:24.945 --> 00:32:26.513 align:middle
然后提交命令缓冲

00:32:27.548 --> 00:32:29.183 align:middle
GPU接过所有

00:32:29.249 --> 00:32:31.018 align:middle
开始处理帧数据

00:32:33.020 --> 00:32:35.289 align:middle
我们再看看演示 看看最后呈现结果

00:32:38.892 --> 00:32:42.362 align:middle line:1
可以看到在左上角
这是单线程编码模式

00:32:42.429 --> 00:32:44.998 align:middle line:1
可以看出正在进行
多少绘图调用 10,000个

00:32:45.732 --> 00:32:49.303 align:middle line:1
右上角 可以看到编码
一个帧数据的时间

00:32:50.137 --> 00:32:51.939 align:middle line:1
我们看到是5毫秒

00:32:53.540 --> 00:32:55.342 align:middle line:1
我们可以增加绘图的数量

00:32:55.876 --> 00:32:58.846 align:middle line:1
绘制的东西越多 时间越长

00:33:00.113 --> 00:33:01.648 align:middle line:1
这就是单线程模式

00:33:01.715 --> 00:33:04.718 align:middle line:1
你们想想看 我们在绘制一个阴影映射

00:33:04.785 --> 00:33:09.056 align:middle
也就是说必须在阴影映射内
发出40,000个绘图

00:33:09.323 --> 00:33:11.325 align:middle
当绘制主通路时
意味着我们必须再发出

00:33:11.391 --> 00:33:14.328 align:middle
另外的40,000个绘图来引用

00:33:15.729 --> 00:33:17.531 align:middle
但是再次强调 我们可以并发操作

00:33:17.598 --> 00:33:19.566 align:middle
所以在演示里 加了一个并行模式

00:33:22.236 --> 00:33:24.137 align:middle line:1
可以看到速度有多么快

00:33:25.873 --> 00:33:27.574 align:middle line:1
看一看正在发生的一切

00:33:29.176 --> 00:33:30.444 align:middle line:1
你可再让它们飞起来一点

00:33:36.650 --> 00:33:40.654 align:middle line:1
在这里 我们有4万个立方体
独一无二 各自分离

00:33:40.721 --> 00:33:41.889 align:middle line:1
它们随时都在更新

00:33:42.689 --> 00:33:46.093 align:middle line:1
我们使用大中央调度
并行编码了许多内容

00:33:47.294 --> 00:33:48.262 align:middle line:1
我们有两个命令缓冲

00:33:48.328 --> 00:33:50.364 align:middle line:1
一个产生地上的阴影地图

00:33:50.898 --> 00:33:52.733 align:middle line:1
一个为所有的立方体渲染上色

00:33:54.268 --> 00:33:57.237 align:middle line:1
光照很简单 即漫反射着色 基本上是

00:33:57.304 --> 00:33:59.973 align:middle line:1
沃伦之前说过的N.L光照

00:34:02.976 --> 00:34:03.977 align:middle line:1
这就是我们的演示内容

00:34:04.044 --> 00:34:06.713 align:middle line:1
这些都会作为示例代码 供大家参考

00:34:07.214 --> 00:34:09.483 align:middle line:1
希望你们可以把它拆开
取得其中的一些想法

00:34:09.550 --> 00:34:11.685 align:middle line:1
和思路
并且能够应用到自己的代码当中

00:34:12.686 --> 00:34:14.087 align:middle
所以我们今天讲了什么？

00:34:15.455 --> 00:34:16.723 align:middle
你们走进来的时候

00:34:16.889 --> 00:34:18.625 align:middle
希望你们也听过沃伦的演讲

00:34:18.692 --> 00:34:20.226 align:middle
可能稍微了解一点图形的知识

00:34:20.293 --> 00:34:22.161 align:middle
或者以前有相关编程经验

00:34:22.795 --> 00:34:25.098 align:middle
但带你们一起了解了
Metal里的一切

00:34:25.966 --> 00:34:29.069 align:middle
Metal的概念性的概览
它的相关原理

00:34:29.402 --> 00:34:32.438 align:middle
是运用API 和硬件相近的API

00:34:32.505 --> 00:34:33.639 align:middle
及和驱动相近的API

00:34:35.007 --> 00:34:36.610 align:middle
我们学习了Metal设备

00:34:36.677 --> 00:34:39.313 align:middle
即Metal的根对象
也是一切的来源

00:34:41.047 --> 00:34:42.783 align:middle
稍微讨论了加载数据到Metal

00:34:42.850 --> 00:34:45.719 align:middle
以及不同的资源类型 和如何使用它们

00:34:46.719 --> 00:34:49.556 align:middle
Metal着色语言 即C++的变体

00:34:49.623 --> 00:34:51.024 align:middle
可以在GPU上编程

00:34:52.592 --> 00:34:54.494 align:middle
我们讨论了建立管道状态

00:34:54.561 --> 00:34:58.565 align:middle
事先验证过的对象 包含两种函数

00:34:58.632 --> 00:35:00.834 align:middle
顶点或片段 或某个计算函数

00:34:58.632 --> 00:35:00.834 align:middle
顶点或片段 或某个计算函数

00:35:01.235 --> 00:35:03.437 align:middle line:1
和其他在预先验证状态的对象

00:35:03.504 --> 00:35:04.872 align:middle line:1
能在运行时节省时间

00:35:05.973 --> 00:35:07.875 align:middle line:1
然后我们讨论了发出GPU命令

00:35:07.941 --> 00:35:11.178 align:middle line:1
创建Metal队列
创建该队列的命令缓冲

00:35:11.745 --> 00:35:14.114 align:middle line:1
还有创建编码器填入命令缓冲

00:35:15.215 --> 00:35:17.718 align:middle line:1
然后该工作发送给GPU

00:35:18.485 --> 00:35:20.754 align:middle
我们带你了解了动画和纹理

00:35:20.988 --> 00:35:24.091 align:middle
以及使用设置顶点字节 发送小位数据

00:35:24.157 --> 00:35:25.325 align:middle
以支持动画效果

00:35:26.994 --> 00:35:28.795 align:middle
之后当小位数据不够时

00:35:28.862 --> 00:35:31.532 align:middle
我们讲解了管理大批量动态数据

00:35:31.598 --> 00:35:35.102 align:middle
使用一个大常量缓冲
以及在不同的地方对其进行引用

00:35:35.402 --> 00:35:38.038 align:middle
在系统外反复使用数据

00:35:38.872 --> 00:35:42.976 align:middle
我们讨论了CPU-GPU同步
以及确保

00:35:43.043 --> 00:35:45.279 align:middle
CPU和GPU不彼此覆盖

00:35:45.746 --> 00:35:46.880 align:middle
及互相协作的重要性

00:35:47.681 --> 00:35:48.849 align:middle
最后

00:35:48.916 --> 00:35:51.285 align:middle
我们讨论了一点关于多线程编码的内容

00:35:51.351 --> 00:35:55.289 align:middle
你如何利用Metal的大中央调度
编码多命令缓冲

00:35:55.355 --> 00:35:57.090 align:middle
同时编码队列中的所有缓冲

00:35:59.092 --> 00:36:00.494 align:middle
这就是采用Metal技术

00:35:59.092 --> 00:36:00.494 align:middle
这就是采用Metal技术

00:36:01.028 --> 00:36:02.129 align:middle
希望你喜欢本次讲座

00:36:02.196 --> 00:36:03.931 align:middle
也希望你把其中一部分
应用到自己的应用里

00:36:03.997 --> 00:36:05.532 align:middle
让应用变得比现在更好

00:36:06.934 --> 00:36:10.504 align:middle
如果想了解更多信息 可以访问网站

00:36:11.104 --> 00:36:14.308 align:middle
developer.apple.com/wwdc/603

00:36:15.843 --> 00:36:18.912 align:middle
明天我们还有更多的演讲
我大力鼓励你们能够参与

00:36:19.112 --> 00:36:21.682 align:middle
上午11点
有“Metal的新特性 第一部分”

00:36:22.115 --> 00:36:25.252 align:middle
晚些 下午1点40分
有“Metal的新特性 第二部分”

00:36:25.319 --> 00:36:27.921 align:middle
这两个讲座将告诉我们
Metal世界里所有新特性

00:36:27.988 --> 00:36:30.524 align:middle
你可在应用里加入很棒的内容
让应用更优秀

00:36:31.491 --> 00:36:34.194 align:middle
之后 为了你们当中的着色狂人

00:36:34.261 --> 00:36:37.231 align:middle
下午3点
有“高级Metal着色器优化”演讲

00:36:37.698 --> 00:36:39.533 align:middle
如果你想知道如何更好地利用着色器

00:36:39.600 --> 00:36:41.768 align:middle
我建议你们参与该话题
非常棒的演讲

00:36:42.836 --> 00:36:44.471 align:middle
感谢你们前来听我们的讲座

00:36:44.538 --> 00:36:47.174 align:middle
欢迎来到全球开发者大会
希望你们剩下几天过得愉快

00:36:47.908 --> 00:36:48.809 align:middle
再次感谢
