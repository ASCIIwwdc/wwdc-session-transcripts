WEBVTT

00:00:19.686 --> 00:00:25.158
Core Location最佳实践

00:00:26.860 --> 00:00:27.828
下午好

00:00:27.895 --> 00:00:31.665
我是Brad 今天同大家谈论
Core Location最佳实践

00:00:33.166 --> 00:00:36.103
为了大家完全明白今天的主题
我将从介绍

00:00:36.170 --> 00:00:38.505
Core Location
的主要特性开始

00:00:39.239 --> 00:00:42.342
由于是它是被广泛使用的API
这里我们将做些回顾

00:00:42.709 --> 00:00:44.678
对新手来说

00:00:45.579 --> 00:00:48.115
这样做挺不错
不过你在会后最好查询一下相关文档

00:00:49.650 --> 00:00:52.486
做完回顾之后 我们将会谈论最佳实践

00:00:52.553 --> 00:00:54.087
使用Core Location

00:00:54.388 --> 00:00:58.225
我们所有的API
只能运行在iOS平台上

00:00:58.725 --> 00:01:00.460
iOS将是我们谈论的焦点

00:00:58.725 --> 00:01:00.460
iOS将是我们谈论的焦点

00:01:00.961 --> 00:01:04.765
但是呢 如果你对macOS
tvOS或者watchOS感兴趣

00:01:04.831 --> 00:01:06.033
你可能想在这待一会儿

00:01:06.099 --> 00:01:09.102
iOS上Core Location
许多特性在那些平台上也适用

00:01:09.169 --> 00:01:11.305
我们将在演讲快结束的时候特别说明

00:01:13.507 --> 00:01:16.977
接下来 我们谈论
Core Location主要特性

00:01:17.878 --> 00:01:20.480
首先是API的授权机制

00:01:21.415 --> 00:01:24.484
API授权是必要的

00:01:24.551 --> 00:01:27.087
以便应用可以访问用户的位置

00:01:28.121 --> 00:01:30.123
你以前有可能使用过类似功能

00:01:30.190 --> 00:01:32.226
如果你看到过像上面那样的提示

00:01:32.526 --> 00:01:33.393
Core Location
正在询问用户

00:01:33.460 --> 00:01:38.065
是否授权相机应用获得用户的当前位置

00:01:40.234 --> 00:01:42.736
我们提供两种授权方式

00:01:42.803 --> 00:01:44.004
你的应用可以去请求

00:01:44.771 --> 00:01:47.174
第一个是使用期间授权

00:01:48.108 --> 00:01:49.376
就像它的名字那样

00:01:49.510 --> 00:01:51.845
当你的应用收到使用期间授权的时候

00:01:51.912 --> 00:01:54.147
应用便可以获得用户的位置

00:01:54.214 --> 00:01:55.949
当用户使用应用时

00:01:56.383 --> 00:01:58.886
我们待会解释使用期间授权的含义

00:02:00.020 --> 00:02:02.289
当你想请求授权的时候

00:02:02.356 --> 00:02:05.893
你只需要调用
requestWhenInUseAuthorization方法

00:02:07.361 --> 00:02:09.630
我们还有另一种方式是永久授权

00:02:10.364 --> 00:02:12.332
当你的应用获得永久授权

00:02:12.399 --> 00:02:14.501
应用能够取得用户的位置信息

00:02:14.568 --> 00:02:16.136
当你运行应用的时候

00:02:17.437 --> 00:02:21.008
想要使用它 你需要调用
requestAlwaysAuthorization方法

00:02:22.543 --> 00:02:25.045
无论你请求何种方式的授权

00:02:25.112 --> 00:02:29.416
你必须在你应用的属性信息列表里
提供用途描述

00:02:30.484 --> 00:02:33.253
Core Location会从
你的信息列表里获取用途描述的字符串

00:02:33.320 --> 00:02:36.323
然后把提取到的字符串
作为授权提示的一部分展示给用户

00:02:40.127 --> 00:02:42.696
你的应用要在何时进行授权请求?

00:02:46.233 --> 00:02:49.670
假如你的应用在前台运行
我们就会请求授权

00:02:49.736 --> 00:02:51.705
这是Potluck
我们的示例应用

00:02:54.341 --> 00:02:57.244
如果你的应用在后台运行
会有一个蓝色的条块

00:02:57.311 --> 00:02:59.413
这个时候应用也可以获得授权

00:03:00.380 --> 00:03:01.682
若你在思考该蓝色条块

00:03:01.748 --> 00:03:03.817
我们待会会谈论蓝色条块的内容

00:03:05.652 --> 00:03:09.189
最后 若你的应用正处理来自
WatchConnectivity的消息

00:03:09.590 --> 00:03:11.525
前台watchOS应用发出的消息

00:03:11.592 --> 00:03:13.727
应用同样也可以获得
授权使用用户位置信息

00:03:17.898 --> 00:03:21.001
一旦你的应用获得了来自用户的授权

00:03:21.068 --> 00:03:23.804
你的应用就可以使用我们的定位API

00:03:24.204 --> 00:03:27.708
首先我们要谈论的是
Core Location必要组件

00:03:27.774 --> 00:03:29.476
标准的定位服务

00:03:30.410 --> 00:03:32.012
定位服务有两个版本

00:03:33.380 --> 00:03:35.716
一个是简化版本的定位API

00:03:37.017 --> 00:03:38.719
当你请求定位的时候

00:03:38.785 --> 00:03:42.356
Core Location
会尽全力计算出用户的准确位置

00:03:42.422 --> 00:03:44.291
然后将位置传递给你应用的代理

00:03:46.193 --> 00:03:49.062
还有一个是持续提供定位服务的API

00:03:49.963 --> 00:03:52.065
当你调用StartUpdatingLocation

00:03:52.132 --> 00:03:55.002
Core Location
会产生一系列定位更新数据

00:03:55.068 --> 00:03:56.870
并将一系列数据传递给你应用的代理

00:03:58.939 --> 00:04:01.475
当你使用完定位服务的时候
记得停止定位更新

00:03:58.939 --> 00:04:01.475
当你使用完定位服务的时候
记得停止定位更新

00:04:01.542 --> 00:04:04.745
若不停止 Core
Location会持续计算位置信息

00:04:06.747 --> 00:04:08.549
你可以调整相应的参数

00:04:08.615 --> 00:04:10.951
来控制定位服务如何进行工作

00:04:12.219 --> 00:04:13.820
例如 延迟更新

00:04:14.354 --> 00:04:16.757
当你允许定位延迟更新的时候

00:04:16.822 --> 00:04:19.159
你可告诉Core Location
那是可接受的

00:04:19.226 --> 00:04:22.429
在更新位置信息的时候
传大批量的数据给应用

00:04:23.163 --> 00:04:25.499
有时我们这样做是出于功耗的原因

00:04:28.769 --> 00:04:31.238
我们也会提供自动暂停更新的功能

00:04:31.672 --> 00:04:33.073
默认情况下该功能是开启的

00:04:34.141 --> 00:04:35.876
它需要做的是监测

00:04:35.943 --> 00:04:40.447
当定位会话失效或者
在一定程度上来说是无用的时候

00:04:40.714 --> 00:04:42.082
让我们来看一下这个应用

00:04:42.349 --> 00:04:45.285
假设用户正在使用一款跑步追踪应用

00:04:45.719 --> 00:04:48.922
用户开始跑步
但是当他们回到家 用户已经很累了

00:04:48.989 --> 00:04:50.224
他们想要冲个澡

00:04:50.290 --> 00:04:52.926
但是用户忘记停止当前定位会话

00:04:54.228 --> 00:04:56.196
除非应用尝试指定操作

00:04:56.263 --> 00:04:58.065
来监测一系列的情况

00:04:58.599 --> 00:05:02.135
否则用户的手机
会持续计算用户的位置信息

00:04:58.599 --> 00:05:02.135
否则用户的手机
会持续计算用户的位置信息

00:05:02.202 --> 00:05:03.937
直到电量耗尽

00:05:05.005 --> 00:05:06.173
使用自动暂停定位的话

00:05:06.240 --> 00:05:09.076
Core Location
会对类似上述情况进行监测

00:05:09.142 --> 00:05:11.812
监测到后 会自动停止位置更新

00:05:14.581 --> 00:05:16.950
Core Location会支持

00:05:17.017 --> 00:05:19.987
应用在后台运行时使用标准的定位服务

00:05:21.421 --> 00:05:23.991
当你进入到这些特殊的会话时

00:05:24.057 --> 00:05:25.859
Core Location
将使你的应用持续运行

00:05:25.926 --> 00:05:28.161
持续传递更新的定位数据给你的应用

00:05:29.563 --> 00:05:31.598
如果你的应用已经获得使用期间授权

00:05:31.932 --> 00:05:34.968
我们会自动在屏幕的顶端
显示一个蓝色的条块

00:05:35.335 --> 00:05:37.171
以此标记的你的应用
正使用定位服务

00:05:37.237 --> 00:05:39.840
允许你的应用
持续接收到位置的更新信息

00:05:41.608 --> 00:05:44.111
获得永久授权的应用可以在后台运行

00:05:44.178 --> 00:05:46.547
但是不会在顶部显示蓝色条块

00:05:46.780 --> 00:05:49.783
当你完成你的应用后
你需要停止你的定位会话

00:05:49.850 --> 00:05:52.586
否则会有潜在的问题

00:05:55.355 --> 00:05:57.491
为了启动一些列的后台会话

00:05:57.558 --> 00:06:00.027
你需要在你的应用中做三件事情

00:05:57.558 --> 00:06:00.027
你需要在你的应用中做三件事情

00:06:00.694 --> 00:06:03.864
首先你需要允许进行后台定位

00:06:03.931 --> 00:06:05.666
在你应用的属性信息列表中

00:06:06.066 --> 00:06:08.302
完成上面操作最便捷的方法是

00:06:08.368 --> 00:06:10.404
转到Xcode的功能标签页

00:06:11.205 --> 00:06:13.373
向下滚动到后台模式部分

00:06:13.774 --> 00:06:15.976
勾选位置更新复选框

00:06:17.444 --> 00:06:19.546
第二 你必须设置

00:06:19.613 --> 00:06:22.549
将后台位置更新的属性为真

00:06:23.183 --> 00:06:25.953
这表明定位管理器

00:06:26.019 --> 00:06:28.956
可以启动后台定位会话

00:06:31.458 --> 00:06:34.661
最后你需要开启定位更新

00:06:34.728 --> 00:06:36.263
当应用处于前台的时候

00:06:36.597 --> 00:06:38.565
如果你没有在前台开启定位更新

00:06:38.632 --> 00:06:40.300
你不会获得用户的位置数据

00:06:42.169 --> 00:06:45.439
如果你在后台开启定位更新
将会发生什么？

00:06:46.006 --> 00:06:50.410
嗯 你的应用很有可能
需要获得永久授权

00:06:50.677 --> 00:06:53.380
因为你的应用在后台
那段时间是不可用的

00:06:54.515 --> 00:06:57.117
此外 Core Location
不执行任何操作

00:06:57.184 --> 00:07:00.053
来保证你的应用可以在后台运行

00:06:57.184 --> 00:07:00.053
来保证你的应用可以在后台运行

00:07:01.688 --> 00:07:03.991
如果你的应用需要在后台运行

00:07:04.057 --> 00:07:06.026
你需要去开启定位会话

00:07:06.093 --> 00:07:07.361
你可能获得位置更新信息

00:07:07.427 --> 00:07:10.264
但是在你收到位置更新消息之前
你的应用有可能会被挂起

00:07:10.330 --> 00:07:12.466
你希望获得的信息

00:07:15.269 --> 00:07:19.973
在启动定位服务之后
我们可以使用后台监视API

00:07:20.607 --> 00:07:23.310
我们首先要谈论的是区域监控

00:07:24.077 --> 00:07:25.712
区域监听允许你的应用

00:07:25.779 --> 00:07:28.782
指定一个它感兴趣的位置

00:07:28.849 --> 00:07:30.617
Core Location将判断

00:07:30.684 --> 00:07:33.820
给出用户是否已经到达
或者用户已经从当前位置出发

00:07:34.988 --> 00:07:37.257
这些操作持续运行尽管你的应用被挂起

00:07:37.324 --> 00:07:40.093
或应用在后台运行
Core Location启动应用

00:07:40.160 --> 00:07:43.564
并设置为后台运行
若有需要会把启动事件传递给你的应用

00:07:45.832 --> 00:07:48.936
我们有两个版本的区域监控API

00:07:49.636 --> 00:07:52.639
首先 我们圆形区域的监控

00:07:53.273 --> 00:07:55.242
当你开启圆形区域的监控

00:07:55.309 --> 00:07:57.678
你需要提供圆形的地理区域

00:07:57.744 --> 00:08:00.981
那是应用需使用的区域
Core Location尝试探测

00:07:57.744 --> 00:08:00.981
那是应用需使用的区域
Core Location尝试探测

00:08:01.048 --> 00:08:03.183
用户从那个圆形区域的进入和退出

00:08:04.818 --> 00:08:06.987
我们有Beacon区域监控

00:08:07.821 --> 00:08:10.457
Beacon区域监控会发现最近

00:08:10.524 --> 00:08:12.993
的iBeacon设备并匹配

00:08:13.060 --> 00:08:14.928
匹配你应用提供的iBeacon设备

00:08:17.798 --> 00:08:22.336
在另外的情况下
区域监控会消耗有限的系统资源

00:08:22.402 --> 00:08:27.407
Core Location只允许你
设置有限数量的区域

00:08:28.108 --> 00:08:29.276
请注意

00:08:29.343 --> 00:08:32.111
如果你写的应用
使用到了Beacon区域监控

00:08:32.179 --> 00:08:35.849
单一的Beacon区域
可以监控多个iBeacon设备

00:08:38.784 --> 00:08:40.953
当你开始区域监控的时候

00:08:41.020 --> 00:08:42.823
你需要构建一个CL区域

00:08:42.890 --> 00:08:45.959
或者CL Beacon区域
又或者一个CL圆形区域

00:08:46.026 --> 00:08:48.495
然后将这些区域传给
startMonitoring(for:)方法

00:08:48.562 --> 00:08:49.963
在CL区域管理器上

00:08:51.965 --> 00:08:56.336
当你处理完上一步传递相同的区域到
stopMonitoring(for:)方法

00:08:59.640 --> 00:09:03.510
如果你想使用区域监测
去触发一个消息通知

00:08:59.640 --> 00:09:03.510
如果你想使用区域监测
去触发一个消息通知

00:09:03.577 --> 00:09:06.647
你有可能会对用户通知框架感兴趣

00:09:06.713 --> 00:09:08.248
用户通知框架有对区域监控的相应支持

00:09:08.315 --> 00:09:11.852
通过UNLocationNotificationTrigger类

00:09:13.620 --> 00:09:17.324
用户通知框架是
在iOS 10中引入的

00:09:18.125 --> 00:09:20.627
但是用户通知的这个功能之前是可以

00:09:20.694 --> 00:09:22.529
通过UI本地通知实现的

00:09:22.863 --> 00:09:26.400
如果你想学习用户通知框架的更多内容

00:09:26.466 --> 00:09:29.870
你或许想在线观看消息通知介绍的演讲

00:09:31.572 --> 00:09:34.474
同样的HomeKit框架提供了支持

00:09:34.808 --> 00:09:38.979
为区域监控事件触发
HomeKit场景模式

00:09:40.180 --> 00:09:42.816
HM LocationEvent
允许你触发上述操作

00:09:42.916 --> 00:09:45.519
若你想学习使用
HM LocationEvent

00:09:45.586 --> 00:09:48.622
我建议你去看一下
去年的HomeKit演讲

00:09:48.689 --> 00:09:50.023
你可以在线观看它

00:09:51.124 --> 00:09:54.661
在另一种情境下
你只需要获得使用期间授权

00:09:54.728 --> 00:09:56.563
来使用用户消息通知框架

00:09:56.630 --> 00:09:59.600
或者是HomeKit框架
为区域监控提供支持

00:10:00.334 --> 00:10:02.669
通过Core Location
达到区域监控

00:10:02.736 --> 00:10:04.438
需要获取永久权限

00:10:07.708 --> 00:10:11.278
同Beacon区域监控类似
我们有Beacon Ranging

00:10:12.312 --> 00:10:16.116
每一个iBeacon设备
广播的消息有三个部分

00:10:16.383 --> 00:10:20.187
UUID 主ID 监控ID

00:10:22.089 --> 00:10:24.057
当一个Beacon区域事件触发了

00:10:24.124 --> 00:10:27.427
这个消息的三部分你不会全部收到

00:10:28.161 --> 00:10:31.131
使用Beacon Ranging
你可以填充丢失的信息

00:10:32.099 --> 00:10:35.802
Ranging对于
评估有效的距离是有用的

00:10:35.869 --> 00:10:38.772
从用户的设备到iBeacon设备

00:10:40.374 --> 00:10:44.545
当你的应用在前台运行的时候
距离估算会更准确

00:10:44.611 --> 00:10:46.914
但可在后台
用Beacon Ranging

00:10:48.148 --> 00:10:50.784
若你想那样做
要记得Core Location

00:10:50.851 --> 00:10:52.886
不会阻止你的应用被挂起

00:10:53.187 --> 00:10:54.555
这样 你的应用可能被挂起

00:10:54.621 --> 00:10:57.691
在你收到你期望的信息之前

00:11:00.861 --> 00:11:04.264
另外 如果你有兴趣
使用iBeacon设备

00:11:04.331 --> 00:11:07.935
我建议访问
developer.apple.com/ibeacon

00:11:08.769 --> 00:11:12.039
同意iBeacon license后
你可以去下载

00:11:12.105 --> 00:11:14.107
iBeacon的官方规范

00:11:14.174 --> 00:11:16.944
如何对每个iBeacon设备
进行设置使它运行良好

00:11:20.113 --> 00:11:22.850
下一个我们要谈论的后台监测API

00:11:23.050 --> 00:11:25.886
是位置大幅变化监控API

00:11:27.054 --> 00:11:30.991
从它的名字可以推断
用于用户位置发生大幅变化的监控

00:11:31.058 --> 00:11:32.759
变化达到了公里的级别

00:11:35.162 --> 00:11:36.563
就像我们介绍的那样

00:11:36.630 --> 00:11:39.099
在Core Location
上发生了不少变化 在这点上

00:11:39.166 --> 00:11:41.902
我们相信这个API是相当独特的

00:11:42.936 --> 00:11:45.906
许多的应用使用位置大幅变化监控

00:11:45.973 --> 00:11:48.475
通过访问监测提供更好的服务

00:11:50.911 --> 00:11:52.513
在访问监控主题中

00:11:53.013 --> 00:11:55.716
访问监控利用复杂算法

00:11:55.782 --> 00:12:00.220
来监视一天中用户逗留过
并且对用户来说有意义的地方

00:11:55.782 --> 00:12:00.220
来监视一天中用户逗留过
并且对用户来说有意义的地方

00:12:00.888 --> 00:12:04.124
那就是为什么我们会认为
访问监控能使得应用更好的服务用户

00:12:04.191 --> 00:12:08.228
毕竟 你会对用户逗留和
花费的时间地点会感兴趣的

00:12:08.695 --> 00:12:10.564
相对用户偶尔逗留的地方来说

00:12:10.631 --> 00:12:13.400
当Core Location探测到
位置发生较大的变化

00:12:16.436 --> 00:12:17.871
我们做了许多工作来保证

00:12:17.938 --> 00:12:20.307
访问监控有较低的功耗

00:12:20.374 --> 00:12:23.343
你会在全天的情景中使用访问监控

00:12:26.513 --> 00:12:28.782
就像我们接下来要讲的后台监控API

00:12:28.849 --> 00:12:31.618
尽管在应用挂起的时候
访问监控还是会持续工作

00:12:31.685 --> 00:12:35.088
并且会在后台启动你的应用
传递事件信息给应用

00:12:37.324 --> 00:12:39.259
如果你想开启访问监控

00:12:39.326 --> 00:12:42.529
你只需简单调用
startMonitoringVisits方法

00:12:42.596 --> 00:12:45.899
当你完成以上步骤
调用stopMonitoringVisits

00:12:48.135 --> 00:12:51.839
最后我将介绍地理编码的API

00:12:52.639 --> 00:12:54.842
Core Location
支持双向地理编码

00:12:54.908 --> 00:12:57.311
将地址转换到地理坐标系

00:12:57.945 --> 00:13:00.781
反向地理编码将地理坐标系转换

00:12:57.945 --> 00:13:00.781
反向地理编码将地理坐标系转换

00:13:00.848 --> 00:13:02.115
到地址

00:13:03.717 --> 00:13:06.320
不像我们将要谈论的剩下的API

00:13:06.386 --> 00:13:10.557
地理编码不需要用户授权 然而

00:13:10.858 --> 00:13:13.994
如果你的应用被授权
访问用户的位置信息

00:13:14.494 --> 00:13:18.765
当需要执行前向编码时
会自动使用用户的位置信息

00:13:18.832 --> 00:13:21.335
这就是将用户地址转换为
地理坐标的过程

00:13:23.737 --> 00:13:26.073
地理编码API调用的频率是有限制的

00:13:26.139 --> 00:13:28.709
你不能发送太多的地理编码请求

00:13:29.309 --> 00:13:33.580
避免达到发送频率上限的
最好方法是缓存查询结果

00:13:33.647 --> 00:13:35.048
地理编码提供的查询结果

00:13:35.449 --> 00:13:39.119
使用这种方法
你不需要查询同一个地理编码信息多次

00:13:40.921 --> 00:13:43.790
我同样建议仅对

00:13:43.857 --> 00:13:45.726
用户的操作进行地理编解码

00:13:45.893 --> 00:13:48.662
例如 若用户在地图上放置一个大头针

00:13:48.729 --> 00:13:51.265
那时可以对用户位置进行地理编解码

00:13:54.668 --> 00:13:57.471
好了 现在你已经熟悉了
我们所有的API

00:13:58.205 --> 00:14:00.207
让我们在看一下授权

00:13:58.205 --> 00:14:00.207
让我们在看一下授权

00:14:01.108 --> 00:14:05.078
如果你的应用
使用期间授权或者永久授权

00:14:05.312 --> 00:14:07.381
它可以使用标准的定位服务

00:14:08.282 --> 00:14:10.817
这些特殊的后台定位会话

00:14:10.884 --> 00:14:12.419
它们在前台启动

00:14:12.486 --> 00:14:15.956
随后进入后台
和Beacon Ranging

00:14:17.925 --> 00:14:19.626
如果你的应用有永久授权

00:14:19.693 --> 00:14:22.796
应用还可以使用后台监控API

00:14:23.463 --> 00:14:25.599
那是区域监控和访问监控

00:14:25.666 --> 00:14:27.835
和位置大幅改变的监控

00:14:28.535 --> 00:14:30.871
不要忘记用户通知框架

00:14:30.938 --> 00:14:34.541
HomeKit框架允许你
进行特定区域的监控

00:14:34.608 --> 00:14:36.276
使用使用期间授权

00:14:39.680 --> 00:14:41.548
只需要关注可用性

00:14:42.115 --> 00:14:44.685
我们的API均可以在iOS上运行

00:14:45.652 --> 00:14:48.689
在macOS上
你可以使用标准的定位服务

00:14:49.489 --> 00:14:50.858
圆形区域的监控

00:14:51.458 --> 00:14:54.461
位置大幅变化的监控和地理编码

00:14:55.696 --> 00:14:59.066
在watchOS上
我们支持标准的定位服务

00:14:59.600 --> 00:15:02.970
和地理编解码 最后 在tvOS上

00:14:59.600 --> 00:15:02.970
和地理编解码 最后 在tvOS上

00:15:03.036 --> 00:15:07.140
你可以使用单一定位API
和地理编解码API

00:15:11.345 --> 00:15:13.347
好了 让我们开始

00:15:13.413 --> 00:15:15.582
使用Core Location
最佳实践

00:15:19.019 --> 00:15:22.222
用户的隐私是十分重要的部分

00:15:22.289 --> 00:15:24.057
关于使用Core Location

00:15:24.591 --> 00:15:27.160
定位信息是高度敏感的信息

00:15:27.528 --> 00:15:30.163
它描述了我们生活和工作的地方

00:15:30.230 --> 00:15:31.865
我们大多数时间和谁在一起

00:15:32.666 --> 00:15:36.737
当使用Core Location时
你必须尊重用户的隐私

00:15:37.237 --> 00:15:38.505
那是值得反复强调的

00:15:38.572 --> 00:15:42.009
在使用Core Location时
你必须尊重用户的隐私

00:15:43.410 --> 00:15:47.047
Core Location使用授权
系统帮助用户保护他们的隐私

00:15:47.481 --> 00:15:50.150
除了获得用户的许可
你可以获得你们的位置信息

00:15:50.217 --> 00:15:51.351
抱歉 用户的位置信息

00:15:51.985 --> 00:15:54.721
这是尊重用户隐私需要做的第一步

00:15:57.057 --> 00:16:01.261
你需要确认你的应用
没有请求过多的信息

00:15:57.057 --> 00:16:01.261
你需要确认你的应用
没有请求过多的信息

00:16:01.328 --> 00:16:05.399
比满足用户实际请求需要的信息

00:16:07.134 --> 00:16:11.672
同样 你必须清楚告诉
用户你在请求什么

00:16:11.738 --> 00:16:13.740
你使用这些信息的目的是什么

00:16:17.311 --> 00:16:19.680
你的应用需要做两件事情

00:16:19.746 --> 00:16:21.949
若你的应用要
使用Core Location

00:16:22.516 --> 00:16:26.019
首先如果你要同服务器进行对话

00:16:26.086 --> 00:16:28.455
尽可能使用隐蔽查询

00:16:29.056 --> 00:16:30.324
让我们看一个例子

00:16:30.791 --> 00:16:33.360
如果你正在写一个签到应用

00:16:33.994 --> 00:16:36.763
如果用户已经点击了签到按钮

00:16:36.830 --> 00:16:39.433
然后你需要发送用户的确认

00:16:39.499 --> 00:16:42.903
信息和定位信息到你的服务器
在一次请求中

00:16:42.970 --> 00:16:45.472
在用户清楚知道
将会发送这两个信息的情况下

00:16:46.640 --> 00:16:50.344
如果你正在编写一个天气应用

00:16:50.410 --> 00:16:53.514
用户有可能对你的服务器不太了解

00:16:53.580 --> 00:16:57.217
你能够访问到用户确认消息和定位信息

00:16:57.518 --> 00:17:01.555
用户可以获得良好的用户体验
有赖于隐匿的查询

00:16:57.518 --> 00:17:01.555
用户可以获得良好的用户体验
有赖于隐匿的查询

00:17:04.491 --> 00:17:08.462
此外 假如你想把
用户的定位信息保存到磁盘上

00:17:08.529 --> 00:17:10.964
你需要使用有文件保护功能的API

00:17:11.999 --> 00:17:13.800
保存文件是相对简单的

00:17:13.867 --> 00:17:17.838
从iOS 8开始
文件保护是默认开启的

00:17:18.070 --> 00:17:21.108
然而 仍然是可以创建
不被保护的文件

00:17:21.708 --> 00:17:23.109
所以你需要确认

00:17:23.176 --> 00:17:25.244
假如你想使用户定位信息持久化

00:17:25.311 --> 00:17:28.315
你最好不要把
信息存储在未受保护的文件中

00:17:33.353 --> 00:17:36.190
除了隐私 功耗是第二件重要的事情

00:17:36.256 --> 00:17:38.458
需在使用Core
Location时考虑的

00:17:40.027 --> 00:17:43.764
使用Core Location时
的功耗差别是相当大的

00:17:44.031 --> 00:17:46.967
在一种极端情况下
我们使用Beacon区域监控

00:17:47.034 --> 00:17:49.503
的全部内容

00:17:50.137 --> 00:17:53.607
在另一种极端情况下
我们持续使用定位会话

00:17:53.674 --> 00:17:56.610
在几个小时之内
会将我们电池的电量耗尽

00:18:00.047 --> 00:18:01.982
不管你的应用有多酷

00:18:02.049 --> 00:18:05.385
如果你的应用耗电比预期的快

00:18:05.452 --> 00:18:07.354
用户也不会喜欢使用你的应用的

00:18:09.656 --> 00:18:12.960
所以 你在设计应用时 需要考虑功耗

00:18:13.427 --> 00:18:16.897
有时候那意味你不得不牺牲
定位的精确性和即时性

00:18:16.964 --> 00:18:20.534
以便能达到用户预期的功耗标准

00:18:22.803 --> 00:18:26.240
为了达到这个要求
你必须使用正确的API

00:18:28.442 --> 00:18:30.410
由于Core Location
有许多API

00:18:30.477 --> 00:18:32.646
你如何知道哪一个是正确的

00:18:33.514 --> 00:18:35.148
我把它们放到了一个决策树里

00:18:35.215 --> 00:18:38.318
会引导你使用正确的API

00:18:38.385 --> 00:18:40.387
那不意味着它可以处理所有的情况

00:18:40.454 --> 00:18:42.389
但它可以满足你的入门要求

00:18:44.024 --> 00:18:46.960
你需要考虑的第一件事情是
你是否需要知道用户的位置

00:18:47.027 --> 00:18:49.129
现在 或者是将来的某段时间

00:18:50.364 --> 00:18:51.965
假如你想在未来的某段时间使用

00:18:52.799 --> 00:18:55.702
那样你可以使用我们的后台监控API

00:18:55.769 --> 00:18:57.237
或者是区域监控

00:18:57.304 --> 00:18:59.406
如果你对特定的位置感兴趣

00:18:59.940 --> 00:19:04.111
或者访问监控
假如你对用户逗留的位置感兴趣

00:18:59.940 --> 00:19:04.111
或者访问监控
假如你对用户逗留的位置感兴趣

00:19:08.415 --> 00:19:10.217
如果你想知道用户现在的位置

00:19:10.284 --> 00:19:12.619
那么你需要使用标准的定位服务

00:19:13.487 --> 00:19:15.589
现在 你有许多不同的方法来使用它

00:19:15.656 --> 00:19:17.457
让我们深入的了解其中的一些

00:19:18.859 --> 00:19:20.527
如果你正在写一个健身应用

00:19:21.094 --> 00:19:23.530
我们建议你使用延迟位置更新

00:19:23.597 --> 00:19:25.265
在一个持续的位置会话中

00:19:27.234 --> 00:19:29.336
如果你正在写导航应用

00:19:29.570 --> 00:19:33.006
你有可能想使用持续定位的会话

00:19:36.443 --> 00:19:38.712
如果你的应用要持续的更新UI

00:19:38.779 --> 00:19:42.649
那么你也可能需要使用持续的定位会话

00:19:44.484 --> 00:19:47.054
最后需要考虑的事情是你的应用

00:19:47.120 --> 00:19:49.590
是否需要记录用户的运动轨迹

00:19:50.490 --> 00:19:54.061
如果需要的话
我们建议你使用延迟位置更新

00:19:54.895 --> 00:19:56.363
在其他的情况下

00:19:56.430 --> 00:19:58.999
我们建议你使用单一定位API

00:20:00.067 --> 00:20:02.870
你或许已经注意到了底部的电池图标

00:20:02.936 --> 00:20:04.538
那不是意味着依次执行

00:20:04.605 --> 00:20:09.309
只是为了告诉你每次使用服务的耗电量

00:20:14.047 --> 00:20:15.616
好了 对于授权

00:20:16.149 --> 00:20:19.920
我强烈建议你使用使用期间授权

00:20:21.421 --> 00:20:23.924
用户更倾向于知道
你不能对他们进行追踪

00:20:23.991 --> 00:20:25.225
除了有他们的授权

00:20:27.528 --> 00:20:29.963
此外 你需要同用户进行交互

00:20:30.030 --> 00:20:32.332
确认用户懂得你为什么

00:20:32.399 --> 00:20:36.203
需要获得授权
还有你会如何使用获得的授权

00:20:38.839 --> 00:20:40.807
记住 Core Location
显示一个提示

00:20:40.874 --> 00:20:44.178
提示中包含你应用提供的用途描述

00:20:44.511 --> 00:20:47.514
这是一个同用户进行交互的好机会

00:20:47.581 --> 00:20:50.484
但是幸运的是 这不是你同用户
进行交互的最后一次机会

00:20:53.987 --> 00:20:57.057
你的应用需要引导用户到设置页面

00:20:57.124 --> 00:20:58.725
Core Location只会显示

00:20:58.792 --> 00:21:01.628
来自你应用的有限数量的授权提示

00:20:58.792 --> 00:21:01.628
来自你应用的有限数量的授权提示

00:21:01.695 --> 00:21:03.197
从一些方面来说

00:21:03.263 --> 00:21:05.365
如果你想改变你的授权等级

00:21:05.432 --> 00:21:07.935
用户不得不进入到
设置界面自己进行更改

00:21:09.336 --> 00:21:11.138
若你引导UI应用
打开设置的UI

00:21:11.205 --> 00:21:15.375
调用
UIApplicationOpenSettingsURLString常量

00:21:16.677 --> 00:21:19.780
然后iOS将会打开你应用的设置面板

00:21:20.747 --> 00:21:23.383
对于Potluck 我们的示例应用
它看来像这样

00:21:24.117 --> 00:21:26.820
你可以看到 用户仅需要点击几下

00:21:26.887 --> 00:21:29.089
便可以改变Potluck的授权

00:21:34.461 --> 00:21:37.297
我们见过许多开发者
被Core Location困扰

00:21:37.364 --> 00:21:39.032
还有它对线程的要求

00:21:39.933 --> 00:21:43.871
你需要记住
Core Locatioon要求你

00:21:43.937 --> 00:21:48.375
在一个有RunLoop的线程上创建
CLLocationManager

00:21:49.643 --> 00:21:52.713
当位置管理器初始化完成后

00:21:52.779 --> 00:21:55.482
它会将当前的线程附加到
RunLoop上

00:21:56.650 --> 00:22:00.020
它将传递全部代理的回调到
RunLoop上

00:21:56.650 --> 00:22:00.020
它将传递全部代理的回调到
RunLoop上

00:22:02.422 --> 00:22:04.091
现在 对许多应用来说

00:22:04.558 --> 00:22:07.294
主线程就是唯一拥有
RunLoop的线程

00:22:08.462 --> 00:22:12.799
所以呢 在主线程上创建位置管理器是安全的

00:22:12.866 --> 00:22:14.902
但如果你那样做 也需要特别注意的

00:22:15.469 --> 00:22:19.606
你必须保持你的主线程是激活的
以便可以处理UI事件

00:22:20.374 --> 00:22:23.544
如果你花费了很多时间处理定位信息

00:22:23.610 --> 00:22:25.579
那么你的应用将会卡顿

00:22:29.516 --> 00:22:32.452
我们建议你要不间断同
位置管理器进行交互

00:22:32.519 --> 00:22:35.956
就是调用它的方法在创建它的线程里面

00:22:37.090 --> 00:22:40.460
这样就简化了同
位置管理器进行的交互

00:22:43.897 --> 00:22:45.199
让我们看一下代码

00:22:45.599 --> 00:22:47.634
这儿我正在请求授权

00:22:48.068 --> 00:22:52.573
这里假定我已经在应用中
加入了必要的应用描述

00:22:52.639 --> 00:22:54.374
到我的信息属性列表里

00:22:55.375 --> 00:22:56.810
我创建了一个位置管理器

00:22:56.877 --> 00:22:59.313
我会使用使用授权授权

00:22:59.913 --> 00:23:02.015
不幸的是 不起作用

00:22:59.913 --> 00:23:02.015
不幸的是 不起作用

00:23:02.583 --> 00:23:05.786
原来
requestWhenInUseAuthorization方法是异步的

00:23:06.253 --> 00:23:09.823
并且CLLocationManager会自动释放

00:23:09.890 --> 00:23:12.626
销毁显著的授权提示

00:23:13.360 --> 00:23:16.864
这样用户根本看不到授权提示

00:23:16.930 --> 00:23:19.867
由于管理器会在函数结束的时候释放

00:23:22.936 --> 00:23:24.471
让我们尝试下与众不同的操作

00:23:25.272 --> 00:23:28.008
如果把管理器作为一个静态类的属性

00:23:28.075 --> 00:23:29.943
那样的话它将存在足够长的时间

00:23:30.577 --> 00:23:33.881
然而 那样的话会引入新的漏洞

00:23:34.515 --> 00:23:38.785
Swift的类将会在第一时间
初始化管理器这个属性

00:23:40.020 --> 00:23:43.156
除非我们十分小心并且
确定我们可以访问那个属性

00:23:43.223 --> 00:23:44.858
在有RunLoop的线程上访问

00:23:44.992 --> 00:23:49.162
这将在没有RunLoop的线程上
创建位置管理器

00:23:49.763 --> 00:23:52.933
我们认为这样做会容易导致错误
我们也不鼓励这样使用它

00:23:55.602 --> 00:23:56.703
再一次尝试

00:23:57.137 --> 00:23:59.373
我们创建位置管理器

00:23:59.439 --> 00:24:03.210
作为视图控制器的一个实例化的属性

00:23:59.439 --> 00:24:03.210
作为视图控制器的一个实例化的属性

00:24:05.145 --> 00:24:08.649
视图控制器通常是在主线程上创建的

00:24:08.715 --> 00:24:10.417
在这个实例中 位置管理器

00:24:10.484 --> 00:24:12.686
将会随着视图控制器的创建而创建

00:24:13.587 --> 00:24:16.123
这样我们就可以确保

00:24:16.190 --> 00:24:18.725
位置管理器会在主线程上创建

00:24:20.194 --> 00:24:23.363
我们比较倾向用这种方式创建
位置管理器

00:24:23.697 --> 00:24:26.900
你有可能会考虑将它
依附到你应用的代理上

00:24:32.472 --> 00:24:34.541
由于标准的定位服务

00:24:34.608 --> 00:24:37.911
在所有Core Location
的API中耗电惊人

00:24:37.978 --> 00:24:39.713
正确使用API就显得重要了

00:24:41.215 --> 00:24:45.018
首先我们建议使用请求定位API

00:24:45.085 --> 00:24:46.220
在任何可能的时候

00:24:48.322 --> 00:24:51.725
其次 你需要确保获得合适的精度

00:24:51.792 --> 00:24:54.761
可以在你的应用中
设置你能允许的最大偏差

00:24:55.996 --> 00:25:00.467
一般来说越精确的定位意味着耗电越多

00:24:55.996 --> 00:25:00.467
一般来说越精确的定位意味着耗电越多

00:25:02.135 --> 00:25:06.106
举个例子 你请求的是100米的精度

00:25:06.173 --> 00:25:09.009
Core Location
通常不需要打开GPS

00:25:09.076 --> 00:25:11.645
来满足我们的定位请求

00:25:13.313 --> 00:25:16.817
Core Location
将会给你或者尽力给你

00:25:16.884 --> 00:25:19.753
一个比你请求的更精确的定位信息

00:25:21.455 --> 00:25:25.459
如果说你请求一个3公里精确度的定位

00:25:25.626 --> 00:25:27.961
这会要求Core Location

00:25:28.028 --> 00:25:30.597
给你的定位信息是它获得的最接近的

00:25:35.235 --> 00:25:38.038
我们建议你开启自动停止功能

00:25:38.505 --> 00:25:40.507
我们已经对自动停止的算法进行了优化

00:25:40.574 --> 00:25:41.909
使它能行之有效

00:25:42.409 --> 00:25:46.046
我们会感到惊讶
如果它停止了你的定位会话

00:25:46.113 --> 00:25:48.916
当用户正在使用定位会话的时间段中

00:25:49.383 --> 00:25:51.451
只要你对自动停止的配置是正确的

00:25:51.518 --> 00:25:53.954
你可以让定位会话持续运行着

00:25:55.055 --> 00:25:59.927
对自动停止进行配置
设置活动选项的属性

00:25:59.993 --> 00:26:02.529
在位置管理器上设置合适值

00:25:59.993 --> 00:26:02.529
在位置管理器上设置合适值

00:26:03.297 --> 00:26:05.866
如果你想了解更多的内容
你可以查阅我们的文档

00:26:08.535 --> 00:26:13.974
同样 我建议不用去管
或者打开延迟定位更新

00:26:14.575 --> 00:26:17.244
延迟位置更新允许
Core Location

00:26:17.311 --> 00:26:18.745
让设备处在耗电量低的状态

00:26:18.812 --> 00:26:23.450
被动搜集位置信息
然后大批量的处理这些数据

00:26:27.521 --> 00:26:30.224
这样做可以在很大程度上节省电量

00:26:30.290 --> 00:26:33.160
相比于正常状态下持续定位会话来说

00:26:38.498 --> 00:26:41.335
还有一点困惑就是你不能了解

00:26:41.401 --> 00:26:43.437
每一步的设置是如何工作的

00:26:43.504 --> 00:26:47.007
你可能想在Xcode中使用耗电日志

00:26:47.441 --> 00:26:49.510
它将给你一个关于耗电的粗略统计

00:26:49.576 --> 00:26:51.578
你持续定位会话正在运行

00:26:54.815 --> 00:26:59.453
最后我建议你设置
allowsBackgroundLocationUpdates属性

00:26:59.520 --> 00:27:02.389
为真 只有当你

00:26:59.520 --> 00:27:02.389
为真 只有当你

00:27:02.456 --> 00:27:04.358
开启后台定位会话的时候

00:27:05.092 --> 00:27:07.761
我们看到许多应用将那个属性设置为真

00:27:07.828 --> 00:27:11.198
当他们进入到后台之后
会停止他们的位置会话

00:27:11.265 --> 00:27:13.100
这样做会有一个消极的影响

00:27:13.867 --> 00:27:18.172
这儿 我已修改了Potluck
我们的示例应用来模拟那种情况

00:27:19.039 --> 00:27:22.042
你将看到当我启动会话
然后返回到主界面

00:27:22.543 --> 00:27:25.379
蓝色的条块在屏幕顶部
仅仅持续了几秒钟

00:27:25.812 --> 00:27:27.548
在这儿我开启了会话

00:27:27.915 --> 00:27:31.084
然后我点击了home键
有一个蓝色的条块在屏幕顶端

00:27:32.319 --> 00:27:34.555
这样的失误可以通过简单管理进行避免

00:27:34.621 --> 00:27:37.624
对你的allowsBackgroundLocationUpdates
属性进行正确的设置

00:27:44.398 --> 00:27:47.935
现在 我们的监控API
会监控你的进程

00:27:48.468 --> 00:27:51.572
像这样 我建议你频繁的交互

00:27:51.638 --> 00:27:55.375
从你进程分享的唯一
一个位置管理器

00:27:56.343 --> 00:27:58.445
你有可能想附加到你应用的代理上

00:28:01.281 --> 00:28:06.019
除此之外 我们的监控API
将持续运行直到你告诉它停止

00:28:07.588 --> 00:28:12.726
确实如此 尽管你更新应用且移除对
Core Location全部引用

00:28:12.793 --> 00:28:14.494
并且断开同框架的连接

00:28:16.163 --> 00:28:19.633
所以我们建议不管你何时启动你的应用

00:28:19.700 --> 00:28:23.337
你需要花一点时间思考
Core Location

00:28:23.403 --> 00:28:26.106
是否需要在后台监控你的应用

00:28:27.241 --> 00:28:29.510
除非你确定在那个时间段

00:28:29.576 --> 00:28:30.944
后台监控是在运行的

00:28:31.211 --> 00:28:33.947
你需告诉Core Location
停止监控

00:28:36.250 --> 00:28:37.518
这一小片段代码

00:28:37.584 --> 00:28:41.421
可以停止所有的三种后台监控API

00:28:48.495 --> 00:28:50.964
如果你你正在编写室内应用

00:28:52.099 --> 00:28:55.369
记住Core Location
将会自动

00:28:55.435 --> 00:28:58.972
允许室内定位不管何时你的应用

00:28:59.039 --> 00:29:02.209
不好意思 是不管何时用户在室内

00:28:59.039 --> 00:29:02.209
不好意思 是不管何时用户在室内

00:29:03.677 --> 00:29:06.180
这只发生在如果你的路线已经被记录

00:29:06.713 --> 00:29:08.849
如果你想你的路线被记录

00:29:08.916 --> 00:29:11.952
访问mapsconnect.apple.com
学习更多

00:29:15.489 --> 00:29:18.425
Beacon区域监控
是广泛使用的技术

00:29:18.492 --> 00:29:22.029
可以应用到各个领域

00:29:22.095 --> 00:29:25.799
我认为最好配合室内场景使用

00:29:26.166 --> 00:29:28.502
它能很好的完成室内定位

00:29:29.803 --> 00:29:33.240
Beacon区域监控
允许你的应用探测接近

00:29:33.307 --> 00:29:36.009
你已经在室内放置的地标

00:29:37.778 --> 00:29:41.815
室内定位允许你在地图上显示用户位置

00:29:41.882 --> 00:29:44.551
可以帮助你从一个地方导航到另一地方

00:29:49.823 --> 00:29:52.693
在watchOS上 你需要记住

00:29:52.759 --> 00:29:57.664
Core Location将
自动利用附近的iPhone

00:29:58.432 --> 00:30:02.436
让我们处理同iPhone的
连接并且计算位置

00:29:58.432 --> 00:30:02.436
让我们处理同iPhone的
连接并且计算位置

00:30:04.605 --> 00:30:07.207
除此之外 我们看到过许多应用的请求

00:30:07.274 --> 00:30:09.376
在watchOS上获得永久授权

00:30:09.443 --> 00:30:11.812
尽管可以使用完成任务

00:30:11.879 --> 00:30:13.514
利用使用期间授权

00:30:16.283 --> 00:30:20.187
如果你想使用永久授权
在watchOS上

00:30:20.254 --> 00:30:21.955
让我们再一次看一下

00:30:22.022 --> 00:30:23.557
在使用期间授权

00:30:26.927 --> 00:30:28.095
对于watchOS 3

00:30:28.161 --> 00:30:31.498
我们在watchOS上开放了
startUpdatingLocation接口

00:30:32.633 --> 00:30:36.703
然而 使用requestLocation
可以更好的服务大多数的应用

00:30:37.971 --> 00:30:39.339
这是一个例外

00:30:40.274 --> 00:30:44.945
在watchOS 3上
可以让健身应用运行在后台是可行的

00:30:45.612 --> 00:30:48.182
如果你长在编写锻炼类的应用

00:30:48.248 --> 00:30:52.219
我认为startUpdatingLocation方法
对你来说是比较合适的API

00:30:56.924 --> 00:30:57.858
对于macOS来说

00:30:59.993 --> 00:31:02.129
我们只支持永久授权

00:30:59.993 --> 00:31:02.129
我们只支持永久授权

00:31:04.698 --> 00:31:08.235
此外 Core Location
将会自动显示一个提示

00:31:08.302 --> 00:31:10.537
当你尝试获取位置信息的时候

00:31:11.138 --> 00:31:14.374
你不需要在macOS上调用
requestAlwaysAuthorization

00:31:17.845 --> 00:31:20.380
因为Mac不会经常被移动

00:31:21.548 --> 00:31:27.154
我认为requestLocation
是你想在macOS上使用的API

00:31:30.691 --> 00:31:34.161
对tvOS来说
你可以使用三种功能强大的API

00:31:34.661 --> 00:31:38.165
单一定位 地理编解码和MapKit

00:31:38.866 --> 00:31:41.201
使用这些API
你能获得你想要的任何东西

00:31:41.268 --> 00:31:44.371
在Apple TV上
创建良好的定位体验

00:31:46.106 --> 00:31:48.275
但是需要额外注意的是任何信息

00:31:48.342 --> 00:31:50.978
通过Core Location获取
显示到你的应用中

00:31:51.879 --> 00:31:54.982
tvOS设备通常放置在用户的家里

00:31:55.549 --> 00:31:58.952
用户的家庭信息是十分敏感的隐私信息

00:31:59.019 --> 00:32:01.121
你可从Core Location上
获取的

00:31:59.019 --> 00:32:01.121
你可从Core Location上
获取的

00:32:01.488 --> 00:32:04.358
你应当恰当使用你获得信息

00:32:08.729 --> 00:32:11.765
不知不觉到了今天演讲结束的时候

00:32:11.832 --> 00:32:14.801
当你离开的时候请记住四件事情

00:32:16.370 --> 00:32:19.640
首先 你必须尊重用户的隐私

00:32:21.575 --> 00:32:23.610
其中一部分就是通用户进行交互

00:32:23.677 --> 00:32:26.513
确定用户理解你正在询问的

00:32:26.580 --> 00:32:28.348
知道你如何使用这些信息

00:32:30.450 --> 00:32:34.288
其次省电是必须的部分

00:32:34.354 --> 00:32:35.989
在使用Core Location时

00:32:36.723 --> 00:32:40.027
有时你不得不牺牲精确度并且延迟

00:32:40.093 --> 00:32:44.364
以便获得用户期望的用户体验

00:32:44.798 --> 00:32:48.101
同时能达到用户期望的耗电标准

00:32:50.237 --> 00:32:54.741
为达到上述效果 需保证使用了正确的
Core Location API

00:32:54.808 --> 00:32:56.109
对你面临的难题来说

00:32:57.511 --> 00:33:00.881
同样确保你使用的是使用期间授权

00:32:57.511 --> 00:33:00.881
同样确保你使用的是使用期间授权

00:33:00.948 --> 00:33:02.182
不论何时你都可以使用

00:33:04.718 --> 00:33:07.654
若使用Core Location
使你感到困难

00:33:08.355 --> 00:33:11.058
我建议你看一下Potluck
我们的示例应用

00:33:11.491 --> 00:33:15.162
我们将在今年更新Swift 3
它会比以往更好些

00:33:17.097 --> 00:33:21.001
如果你想学习更多
你可以访问我们的在线资料库

00:33:24.371 --> 00:33:26.607
或者是查看相关的演讲

00:33:29.676 --> 00:33:32.546
就这些 谢谢你们
祝大家在余下的WWDC过得愉快
