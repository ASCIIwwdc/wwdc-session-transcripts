WEBVTT

00:00:19.920 --> 00:00:23.924
<c.magenta>GameplayKit的新特性</c>

00:00:27.961 --> 00:00:28.795
<c.magenta>大家早上好</c>

00:00:30.163 --> 00:00:31.164
<c.magenta>我是Bruno Sommer</c>

00:00:31.231 --> 00:00:33.066
<c.magenta>我是Apple的游戏技术工程师</c>

00:00:33.133 --> 00:00:35.235
<c.magenta>“GameplayKit的新特性”</c>

00:00:37.070 --> 00:00:38.872
<c.magenta>去年 我们介绍了</c>
<c.magenta>GameplayKit</c>

00:00:38.939 --> 00:00:41.008
<c.magenta>是Apple的一个高级游戏框架</c>

00:00:41.642 --> 00:00:43.110
<c.magenta>GameplayKit是一个集合</c>

00:00:43.177 --> 00:00:47.214
<c.magenta>包含一些常用的架构模式</c>
<c.magenta>数据结构和算法</c>

00:00:47.781 --> 00:00:49.917
<c.magenta>这允许我们的开发者</c>
<c.magenta>开发很棒的</c>

00:00:49.983 --> 00:00:52.119
<c.magenta>引人入胜的玩法</c>
<c.magenta>在他们开发的游戏中</c>

00:00:53.287 --> 00:00:56.156
<c.magenta>GameplayKit</c>
<c.magenta>作为你的工具箱</c>

00:00:56.223 --> 00:00:57.357
<c.magenta>为了很棒的游戏体验</c>

00:00:57.758 --> 00:00:59.359
<c.magenta>所以不管你要开发</c>
<c.magenta>什么类型的游戏</c>

00:00:59.426 --> 00:01:02.629
<c.magenta>不管它是游戏平台</c>
<c.magenta>还是RPG或城市建设者</c>

00:00:59.426 --> 00:01:02.629
<c.magenta>不管它是游戏平台</c>
<c.magenta>还是RPG或城市建设者</c>

00:01:03.864 --> 00:01:07.000
<c.magenta>你总可以在GameplayKit中</c>
<c.magenta>找到能方便开发的东西</c>

00:01:07.100 --> 00:01:08.869
<c.magenta>并让你的游戏更加健壮</c>

00:01:11.271 --> 00:01:12.973
<c.magenta>去年我们引入了</c>
<c.magenta>GameplayKit</c>

00:01:13.040 --> 00:01:14.908
<c.magenta>它由七个主要系统构成</c>

00:01:14.975 --> 00:01:17.744
<c.magenta>比如实体和组件 状态机</c>

00:01:17.911 --> 00:01:19.646
<c.magenta>以及我们的游戏质量无规源</c>

00:01:21.181 --> 00:01:25.118
<c.magenta>今年 我们在寻路 代理</c>
<c.magenta>和游戏AI方面进行了提升</c>

00:01:26.386 --> 00:01:29.690
<c.magenta>还向GameplayKit中引入</c>
<c.magenta>三个新的主要系统</c>

00:01:30.257 --> 00:01:32.659
<c.magenta>我们有一个很强大的</c>
<c.magenta>区域分割系统</c>

00:01:32.726 --> 00:01:34.394
<c.magenta>这将允许你获得很好的表现</c>

00:01:34.461 --> 00:01:36.730
<c.magenta>在游戏的运行时查询中</c>

00:01:38.298 --> 00:01:40.434
<c.magenta>你必须有一个很强大的</c>
<c.magenta>过程生成系统</c>

00:01:40.501 --> 00:01:43.070
<c.magenta>来制作引人入胜</c>
<c.magenta>的运行时内容</c>

00:01:44.538 --> 00:01:46.840
<c.magenta>今年 我们也集成了</c>

00:01:46.907 --> 00:01:48.876
<c.magenta>GameplayKit</c>
<c.magenta>在Xcode游戏编辑器中</c>

00:01:48.942 --> 00:01:51.678
<c.magenta>所以许多曾经只能在代码中</c>
<c.magenta>使用的工作流</c>

00:01:51.778 --> 00:01:55.349
<c.magenta>现在可以直接在数据编辑器中使用</c>
<c.magenta>不需要重新编译</c>

00:01:56.950 --> 00:01:58.185
<c.magenta>所以我们今天内容很多</c>

00:01:58.252 --> 00:02:01.421
<c.magenta>我打算直接说寻路中的新功能</c>

00:01:58.252 --> 00:02:01.421
<c.magenta>我打算直接说寻路中的新功能</c>

00:02:03.390 --> 00:02:05.425
<c.magenta>去年 我们介绍了障碍物图</c>

00:02:05.492 --> 00:02:07.528
<c.magenta>这些是我们的图类型</c>
<c.magenta>它们负责处理</c>

00:02:07.594 --> 00:02:09.596
<c.magenta>你的游戏世界中</c>
<c.magenta>不可同行的障碍物的集合</c>

00:02:10.430 --> 00:02:12.633
<c.magenta>在名字之下 我们使用</c>
<c.magenta>了一系列视野算法</c>

00:02:12.699 --> 00:02:14.968
<c.magenta>来在障碍物之间</c>
<c.magenta>绘制可通行区域</c>

00:02:16.236 --> 00:02:17.738
<c.magenta>现在这个方法很强大</c>

00:02:17.804 --> 00:02:19.640
<c.magenta>它生成了质量很高的路径</c>

00:02:20.174 --> 00:02:21.875
<c.magenta>但是对较大的游戏世界而言</c>

00:02:21.942 --> 00:02:24.044
<c.magenta>以及障碍物数量较大的游戏世界</c>

00:02:24.111 --> 00:02:26.513
<c.magenta>计算过程强度很高</c>

00:02:26.780 --> 00:02:29.283
<c.magenta>在计算并保存结果时</c>

00:02:30.517 --> 00:02:32.519
<c.magenta>所以今年 我们提供给</c>
<c.magenta>大家另一个选择</c>

00:02:32.586 --> 00:02:34.588
<c.magenta>我们要引入GKMeshGraph</c>

00:02:35.589 --> 00:02:37.391
<c.magenta>现在 这很类似</c>
<c.magenta>我们的障碍物图</c>

00:02:37.457 --> 00:02:40.661
<c.magenta>再一次 我们要处理</c>
<c.magenta>游戏世界中不可通过的障碍物</c>

00:02:40.727 --> 00:02:43.730
<c.magenta>但是现在我们不再使用</c>
<c.magenta>视野直线来计算可通行区域</c>

00:02:43.797 --> 00:02:45.065
<c.magenta>在这些障碍物之间</c>

00:02:45.132 --> 00:02:47.201
<c.magenta>我们要将这个区域分成三角形</c>

00:02:47.267 --> 00:02:49.036
<c.magenta>我们由之计算出</c>
<c.magenta>一个三角形网状图</c>

00:02:49.136 --> 00:02:50.571
<c.magenta>这样每一个可通行的点</c>

00:02:50.637 --> 00:02:53.807
<c.magenta>在你的游戏世界中</c>
<c.magenta>由仅仅一个三角形代表</c>

00:02:55.409 --> 00:02:58.812
<c.magenta>这个新的三角化方法</c>
<c.magenta>一样会生成很高质量的路径</c>

00:02:58.879 --> 00:03:01.748
<c.magenta>而且附加好处是</c>
<c.magenta>计算起来很快</c>

00:02:58.879 --> 00:03:01.748
<c.magenta>而且附加好处是</c>
<c.magenta>计算起来很快</c>

00:03:01.815 --> 00:03:05.319
<c.magenta>保存起来成本很低</c>
<c.magenta>尤其是对很大的游戏世界</c>

00:03:06.653 --> 00:03:08.488
<c.magenta>此外 它的灵活性很高</c>
<c.magenta>在计算节点</c>

00:03:08.555 --> 00:03:10.757
<c.magenta>应该处在网状图的哪个位置时</c>

00:03:10.958 --> 00:03:13.861
<c.magenta>你可以把它们放在三教中心</c>
<c.magenta>三角的定点上</c>

00:03:13.927 --> 00:03:16.296
<c.magenta>与三角形的边上</c>
<c.magenta>以及所有存在的组合</c>

00:03:18.465 --> 00:03:20.100
<c.magenta>让我们看一个小代码示例</c>

00:03:20.200 --> 00:03:22.603
<c.magenta>展示GameplayKit中</c>
<c.magenta>用网状图的样子</c>

00:03:22.970 --> 00:03:24.638
<c.magenta>你们会对它的样子很熟悉</c>

00:03:24.705 --> 00:03:25.906
<c.magenta>和曾经的障碍物图相较</c>

00:03:25.973 --> 00:03:28.075
<c.magenta>它们都在以不同方式解决同样的问题</c>

00:03:29.376 --> 00:03:31.812
<c.magenta>在这里的最上端</c>
<c.magenta>我要制作我的网状图</c>

00:03:31.879 --> 00:03:33.814
<c.magenta>我要传入的缓存半径为10</c>

00:03:33.881 --> 00:03:36.984
<c.magenta>这里的缓存半径关联于</c>
<c.magenta>你的代理的尺度</c>

00:03:37.050 --> 00:03:39.152
<c.magenta>它们负责在你的世界中</c>
<c.magenta>进行寻路工作</c>

00:03:39.219 --> 00:03:42.589
<c.magenta>我们要手工的在后台</c>
<c.magenta>提高你的障碍物的尺寸</c>

00:03:42.656 --> 00:03:44.424
<c.magenta>来弥补代理尺寸</c>

00:03:45.926 --> 00:03:49.062
<c.magenta>现在我要传入两点(0, 0)</c>
<c.magenta>和(1000, 1000)</c>

00:03:49.129 --> 00:03:52.566
<c.magenta>这是我的网状图要代表的</c>
<c.magenta>游戏世界的跨度</c>

00:03:54.701 --> 00:03:57.571
<c.magenta>下一步 我要设置我的网状图</c>
<c.magenta>的三角化模式</c>

00:03:57.671 --> 00:03:59.640
<c.magenta>这就是节点放置的灵活性所在</c>

00:03:59.706 --> 00:04:01.074
<c.magenta>即我刚才所提到的</c>

00:03:59.706 --> 00:04:01.074
<c.magenta>即我刚才所提到的</c>

00:04:01.475 --> 00:04:03.911
<c.magenta>现在我要具体地</c>
<c.magenta>将节点放在</c>

00:04:03.977 --> 00:04:06.480
<c.magenta>三角形的定点上</c>
<c.magenta>以及三角形的中心</c>

00:04:08.382 --> 00:04:10.751
<c.magenta>最后 我们要将</c>
<c.magenta>障碍物集合添加到网状图中</c>

00:04:10.851 --> 00:04:13.120
<c.magenta>我们有一个障碍物集合</c>
<c.magenta>与我们的游戏世界关联</c>

00:04:13.520 --> 00:04:14.988
<c.magenta>而后我们要调用三角化</c>

00:04:15.255 --> 00:04:17.391
<c.magenta>这会将这些障碍图托付给图</c>

00:04:17.724 --> 00:04:19.892
<c.magenta>它负责运行背后的</c>
<c.magenta>三角化算法</c>

00:04:20.194 --> 00:04:21.428
<c.magenta>而后就完成了</c>

00:04:21.495 --> 00:04:24.164
<c.magenta>这个图已经可以</c>
<c.magenta>在我们的游戏中进行寻路了</c>

00:04:27.167 --> 00:04:28.335
<c.magenta>除了我们的网状图之外</c>

00:04:28.402 --> 00:04:30.871
<c.magenta>今年我们还介绍了寻路中</c>
<c.magenta>定制节点类别</c>

00:04:31.839 --> 00:04:34.508
<c.magenta>我们的一些图会</c>
<c.magenta>自动的实例化它们的节点</c>

00:04:34.575 --> 00:04:37.778
<c.magenta>这就是我们的格子图</c>
<c.magenta>障碍图和网状图</c>

00:04:38.579 --> 00:04:39.813
<c.magenta>在实例化的时候</c>

00:04:39.880 --> 00:04:43.550
<c.magenta>你可以选择指定一个</c>
<c.magenta>自定义节点类别来让它们实例化</c>

00:04:44.084 --> 00:04:46.420
<c.magenta>这将会大有用处</c>
<c.magenta>如果你需要附加任何自定义数据</c>

00:04:46.486 --> 00:04:48.355
<c.magenta>或逻辑在你的节点上</c>
<c.magenta>这有时会很有用</c>

00:04:48.422 --> 00:04:49.890
<c.magenta>取决于你想要制作的游戏</c>

00:04:51.191 --> 00:04:52.192
<c.magenta>我们要调用合适的init()</c>

00:04:52.259 --> 00:04:54.795
<c.magenta>在我们生成了我们的</c>
<c.magenta>原始节点类型时</c>

00:04:55.729 --> 00:04:58.498
<c.magenta>还有 这些所有类型的图现都支持</c>
<c.magenta>Object-C和Swift属性</c>

00:04:58.565 --> 00:05:02.002
<c.magenta>所以你在访问自定义节点</c>
<c.magenta>时不需要类型转换</c>

00:04:58.565 --> 00:05:02.002
<c.magenta>所以你在访问自定义节点</c>
<c.magenta>时不需要类型转换</c>

00:05:04.972 --> 00:05:07.140
<c.magenta>这就是今年寻路中的新特性</c>

00:05:07.708 --> 00:05:09.710
<c.magenta>现在让我们继续说说</c>
<c.magenta>代理中的新特性</c>

00:05:11.612 --> 00:05:14.581
<c.magenta>说些GameplayKit中</c>
<c.magenta>有关代理的令人振奋的事情</c>

00:05:14.648 --> 00:05:16.550
<c.magenta>他们是自动运动的实体</c>

00:05:17.351 --> 00:05:19.453
<c.magenta>被一系列的目标和行为控制</c>

00:05:19.520 --> 00:05:22.289
<c.magenta>它们也被一系列现实的</c>
<c.magenta>物理限制所局限</c>

00:05:22.356 --> 00:05:26.960
<c.magenta>比如速度 质量 躲避障碍和寻路</c>

00:05:28.395 --> 00:05:29.863
<c.magenta>在此右侧 你看到一系列目标</c>

00:05:29.930 --> 00:05:32.900
<c.magenta>供你使用 来达到你在</c>
<c.magenta>你的游戏中想要的行为</c>

00:05:32.999 --> 00:05:36.803
<c.magenta>比如寻找与躲避或者漫游与逃跑</c>

00:05:39.573 --> 00:05:41.808
<c.magenta>原来 代理是纯2D的</c>

00:05:41.875 --> 00:05:44.611
<c.magenta>今年 我们很激动地宣布</c>
<c.magenta>我们要将其带入3D</c>

00:05:45.345 --> 00:05:47.114
<c.magenta>相关类叫GKAgent3D</c>

00:05:47.814 --> 00:05:50.551
<c.magenta>用户界面与2D的变形很像</c>

00:05:50.617 --> 00:05:53.687
<c.magenta>主要的区别在于</c>
<c.magenta>其位置是三个浮点</c>

00:05:54.121 --> 00:05:57.057
<c.magenta>旋转也是三阶矩阵流</c>

00:05:57.324 --> 00:05:59.593
<c.magenta>所有的目标和行为都被支持</c>

00:06:00.661 --> 00:06:02.663
<c.magenta>有关这次改变要提到几点</c>

00:06:02.796 --> 00:06:06.400
<c.magenta>我们改了GKPath来同时</c>
<c.magenta>支持2D和3D点</c>

00:06:06.466 --> 00:06:08.669
<c.magenta>考虑到遵从路径的目标</c>

00:06:09.903 --> 00:06:12.639
<c.magenta>考虑到躲避障碍物目标</c>
<c.magenta>中的障碍物</c>

00:06:12.706 --> 00:06:16.143
<c.magenta>如果你要使用3D的障碍</c>
<c.magenta>它们依然存在于一个平面上</c>

00:06:16.210 --> 00:06:18.712
<c.magenta>所以你要选择一个平面</c>
<c.magenta>对你的游戏有意义</c>

00:06:20.581 --> 00:06:22.349
<c.magenta>除了将代理带入3D以外</c>

00:06:22.416 --> 00:06:24.985
<c.magenta>今年我们还引入了行为成分</c>

00:06:25.586 --> 00:06:29.089
<c.magenta>我们引入新类GKCompositeBehavior</c>
<c.magenta>它是GKBehavior的子类</c>

00:06:29.790 --> 00:06:31.658
<c.magenta>这是一个行为的加权集合</c>

00:06:31.725 --> 00:06:35.996
<c.magenta>这和刚才行为与目标</c>
<c.magenta>的关系很像</c>

00:06:36.063 --> 00:06:37.898
<c.magenta>行为是一个目标的加权合集</c>

00:06:39.533 --> 00:06:41.034
<c.magenta>它是完全可嵌套的</c>
<c.magenta>所以你现在可以完成</c>

00:06:41.101 --> 00:06:44.638
<c.magenta>很有趣的嵌套行为</c>
<c.magenta>在你的游戏中的行为</c>

00:06:44.705 --> 00:06:47.140
<c.magenta>这也使得它们更易于维护</c>
<c.magenta>尤其当你在完成</c>

00:06:47.207 --> 00:06:49.877
<c.magenta>你的游戏中的很多的行为时</c>

00:06:51.512 --> 00:06:55.082
<c.magenta>让我们很快地看看代码示例</c>
<c.magenta>关于实际情况下的行为成分</c>

00:06:55.282 --> 00:06:57.718
<c.magenta>在这里的最上</c>
<c.magenta>我要创建一个群聚行为</c>

00:06:58.018 --> 00:07:00.954
<c.magenta>通过结合队列 黏合</c>
<c.magenta>与分离这三个目标</c>

00:06:58.018 --> 00:07:00.954
<c.magenta>通过结合队列 黏合</c>
<c.magenta>与分离这三个目标</c>

00:07:02.689 --> 00:07:04.892
<c.magenta>下一步 我要些障碍物</c>
<c.magenta>和敌人添加到游戏中</c>

00:07:04.958 --> 00:07:06.393
<c.magenta>我需要我的代理来躲避</c>

00:07:06.460 --> 00:07:07.861
<c.magenta>我们要制作一个躲避行为</c>

00:07:07.928 --> 00:07:11.131
<c.magenta>通过结合avoidObstacles</c>
<c.magenta>和avoidEnemies目标</c>

00:07:13.133 --> 00:07:16.403
<c.magenta>然后我要结合这两个行为</c>
<c.magenta>成为一个新的合并行为</c>

00:07:16.470 --> 00:07:18.205
<c.magenta>很高效地合二为一</c>

00:07:19.973 --> 00:07:21.542
<c.magenta>最终 我要制作我的代理</c>

00:07:21.608 --> 00:07:24.711
<c.magenta>我要将我的组合行为</c>
<c.magenta>设置为代理的行为</c>

00:07:25.279 --> 00:07:26.113
<c.magenta>现在可以运行了</c>

00:07:26.180 --> 00:07:29.449
<c.magenta>下一次我们更新这个代理时</c>
<c.magenta>它同时会正确地尝试</c>

00:07:29.516 --> 00:07:32.252
<c.magenta>来达到这两个子目标</c>
<c.magenta>或是子行为</c>

00:07:35.923 --> 00:07:37.591
<c.magenta>这就是今年代理的新特性了</c>

00:07:37.658 --> 00:07:40.327
<c.magenta>让我们继续说说</c>
<c.magenta>我们的全新空间分割系统</c>

00:07:43.397 --> 00:07:45.299
<c.magenta>先介绍一点空间分割的背景知识</c>

00:07:45.365 --> 00:07:47.034
<c.magenta>可能对你的游戏很重要</c>

00:07:47.367 --> 00:07:50.337
<c.magenta>经常在我们完成高级游戏编程时</c>

00:07:50.571 --> 00:07:52.973
<c.magenta>我们会问好多有关</c>
<c.magenta>游戏世界的空间问题</c>

00:07:53.240 --> 00:07:55.642
<c.magenta>比如 有多少敌人离玩家较近？</c>

00:07:55.709 --> 00:07:58.145
<c.magenta>或是 在我的世界中</c>
<c.magenta>所有的物品都在哪里？</c>

00:07:58.478 --> 00:08:00.747
<c.magenta>或是在这一帧中</c>
<c.magenta>哪个抛射体会击中玩家？</c>

00:07:58.478 --> 00:08:00.747
<c.magenta>或是在这一帧中</c>
<c.magenta>哪个抛射体会击中玩家？</c>

00:08:02.082 --> 00:08:03.550
<c.magenta>尤其对于更大的游戏世界</c>

00:08:03.617 --> 00:08:06.286
<c.magenta>或是有大量游戏物体的游戏世界</c>

00:08:06.587 --> 00:08:08.956
<c.magenta>回答这类问题可能开销很大</c>

00:08:10.324 --> 00:08:13.227
<c.magenta>在游戏编程中 我们往往</c>
<c.magenta>加速这一类的空间查询</c>

00:08:13.293 --> 00:08:16.296
<c.magenta>通过使用一种叫空间分割的缓存</c>

00:08:18.665 --> 00:08:20.534
<c.magenta>总览我们所提供的</c>

00:08:20.601 --> 00:08:22.302
<c.magenta>在我们的空间分割系统中</c>

00:08:22.402 --> 00:08:24.838
<c.magenta>这是一个树状数据</c>
<c.magenta>结构集合 能让你</c>

00:08:24.905 --> 00:08:26.807
<c.magenta>基于空间缓存游戏物体</c>

00:08:26.940 --> 00:08:28.775
<c.magenta>你将物体添加到</c>
<c.magenta>这些树状数据结构中</c>

00:08:28.842 --> 00:08:31.912
<c.magenta>它们在底层会聚集为</c>
<c.magenta>层级与桶</c>

00:08:32.212 --> 00:08:35.315
<c.magenta>然后未来查询这些物体时</c>
<c.magenta>效率就会高得多</c>

00:08:36.582 --> 00:08:39.186
<c.magenta>今年 我们引入了</c>
<c.magenta>三个这样的数据结构</c>

00:08:39.253 --> 00:08:40.988
<c.magenta>供大家进行空间划分所需</c>

00:08:41.188 --> 00:08:43.924
<c.magenta>我们有R-trees、</c>
<c.magenta>quadtrees和octrees</c>

00:08:45.759 --> 00:08:47.361
<c.magenta>让我们深入这些数据结构分析</c>

00:08:47.427 --> 00:08:48.695
<c.magenta>先说R-tree</c>

00:08:50.230 --> 00:08:52.366
<c.magenta>R-tree是一个树状数据结构</c>

00:08:52.432 --> 00:08:54.668
<c.magenta>内有一系列的层级桶</c>

00:08:55.202 --> 00:08:59.673
<c.magenta>每当你向一个R-tree添加</c>
<c.magenta>一个对象时 它会进入其中一个桶</c>

00:09:00.107 --> 00:09:03.343
<c.magenta>所有这些桶都</c>
<c.magenta>附带一个包围盒与之关联</c>

00:09:04.044 --> 00:09:08.248
<c.magenta>它是该桶中所有的子对象</c>
<c.magenta>的包围盒的总和</c>

00:09:09.216 --> 00:09:10.450
<c.magenta>R-tree有一个特定的规则</c>

00:09:10.517 --> 00:09:13.253
<c.magenta>每当这些桶变得太大时</c>
<c.magenta>就需要被分割</c>

00:09:13.954 --> 00:09:17.591
<c.magenta>这些桶的最大尺寸</c>
<c.magenta>是一个由用户配置的参数</c>

00:09:18.358 --> 00:09:20.527
<c.magenta>我们还有一系列策略供使用</c>

00:09:20.594 --> 00:09:22.462
<c.magenta>来决定这些桶应当如何分割</c>

00:09:22.829 --> 00:09:25.265
<c.magenta>我们可以很简单的分割</c>
<c.magenta>或是尝试进行线性优化</c>

00:09:25.332 --> 00:09:29.636
<c.magenta>与二次的距离</c>
<c.magenta>或是尝试降低桶之间的重叠</c>

00:09:30.938 --> 00:09:32.606
<c.magenta>我将给大家一个</c>
<c.magenta>很快的视觉样例</c>

00:09:32.673 --> 00:09:34.374
<c.magenta>关于构建简单的</c>
<c.magenta>R-tree是什么样子的</c>

00:09:34.441 --> 00:09:38.245
<c.magenta>比如说 我有一个太空游戏</c>
<c.magenta>里面有一些宇宙飞船和小行星</c>

00:09:38.745 --> 00:09:42.082
<c.magenta>我要将一个宇宙飞船添加到</c>
<c.magenta>R-tree中 它进入了一个桶</c>

00:09:42.149 --> 00:09:44.351
<c.magenta>它就是那个飞船的包围盒</c>

00:09:45.018 --> 00:09:47.020
<c.magenta>然后我要添加两个</c>
<c.magenta>小行星到桶中</c>

00:09:47.087 --> 00:09:50.090
<c.magenta>你可以看到它变大了</c>
<c.magenta>来容纳这些物体</c>

00:09:51.758 --> 00:09:53.760
<c.magenta>我在这个R-tree中指定了规则</c>

00:09:53.827 --> 00:09:56.697
<c.magenta>当这些桶超过三个物体时</c>
<c.magenta>需要进行分割</c>

00:09:57.097 --> 00:09:59.299
<c.magenta>所以我要再向这个桶中</c>
<c.magenta>添加第四个物体</c>

00:09:59.499 --> 00:10:01.835
<c.magenta>现在这个桶太大了</c>
<c.magenta>它需要被分割</c>

00:09:59.499 --> 00:10:01.835
<c.magenta>现在这个桶太大了</c>
<c.magenta>它需要被分割</c>

00:10:02.302 --> 00:10:04.471
<c.magenta>我们要进行一个</c>
<c.magenta>简单的线性距离分割</c>

00:10:04.538 --> 00:10:06.373
<c.magenta>最后结果是两个桶</c>

00:10:07.708 --> 00:10:10.210
<c.magenta>再一次 我向右侧的桶</c>
<c.magenta>中添加了两个物体</c>

00:10:12.312 --> 00:10:14.248
<c.magenta>这个桶又变得太大</c>
<c.magenta>需要被分割开</c>

00:10:14.314 --> 00:10:17.484
<c.magenta>再一次 我们要完成一次</c>
<c.magenta>线性分割 得到两个桶</c>

00:10:17.718 --> 00:10:20.087
<c.magenta>这就是R-tree在</c>
<c.magenta>底层的运作模式了</c>

00:10:24.424 --> 00:10:26.860
<c.magenta>让我们继续说</c>
<c.magenta>quadtree和octree</c>

00:10:27.227 --> 00:10:28.629
<c.magenta>我将这两个一起说</c>

00:10:28.695 --> 00:10:31.965
<c.magenta>因为它们都在解决同样的问题</c>
<c.magenta>只不过quadtree解决2D</c>

00:10:32.032 --> 00:10:33.100
<c.magenta>而octree解决3D</c>

00:10:33.166 --> 00:10:34.568
<c.magenta>界面是一样的</c>

00:10:35.702 --> 00:10:39.273
<c.magenta>这些有一系列等级和层次</c>
<c.magenta>的树状数据结构</c>

00:10:39.606 --> 00:10:41.942
<c.magenta>在每一层中</c>
<c.magenta>空间也被均等的分割</c>

00:10:42.009 --> 00:10:44.244
<c.magenta>在右侧</c>
<c.magenta>我有一个quadtree的示例</c>

00:10:44.545 --> 00:10:47.314
<c.magenta>你可以在左上侧看到</c>
<c.magenta>我已经将这个扇形区域细分过了</c>

00:10:47.381 --> 00:10:51.185
<c.magenta>在新的被分割扇形的左上侧</c>
<c.magenta>我再一次进行分割</c>

00:10:52.819 --> 00:10:55.556
<c.magenta>所以quadtree和octree</c>
<c.magenta>都有个与之关联最大单元扇形尺寸</c>

00:10:55.622 --> 00:10:58.258
<c.magenta>这控制了这些树的</c>
<c.magenta>最大成长深度</c>

00:10:58.325 --> 00:11:00.394
<c.magenta>以及这些单元扇形的细分极限</c>

00:10:58.325 --> 00:11:00.394
<c.magenta>以及这些单元扇形的细分极限</c>

00:11:01.461 --> 00:11:03.397
<c.magenta>现在 当你向quadtree</c>
<c.magenta>与octree中添加对象时</c>

00:11:03.463 --> 00:11:06.867
<c.magenta>它会被放在一个</c>
<c.magenta>它能占满的最小隔间中</c>

00:11:08.235 --> 00:11:10.070
<c.magenta>关于该最大隔间尺寸</c>
<c.magenta>给大家一小贴士</c>

00:11:10.137 --> 00:11:13.073
<c.magenta>它的关联度很高</c>
<c.magenta>这个值很重要 尤其关于</c>

00:11:13.140 --> 00:11:15.242
<c.magenta>这些数据结构的表现性能</c>

00:11:15.309 --> 00:11:16.910
<c.magenta>所以你应该选择一个隔间尺寸</c>

00:11:17.244 --> 00:11:19.079
<c.magenta>或一个最大隔间尺寸</c>
<c.magenta>对游戏最有意义</c>

00:11:19.146 --> 00:11:20.581
<c.magenta>一般来说 这个关联于</c>

00:11:20.647 --> 00:11:23.317
<c.magenta>你的游戏世界中</c>
<c.magenta>一些较小的游戏物体</c>

00:11:24.451 --> 00:11:26.820
<c.magenta>我给大家一个</c>
<c.magenta>构建quadtree的视觉示例</c>

00:11:27.321 --> 00:11:29.089
<c.magenta>同样的示例 宇宙飞船和小行星</c>

00:11:29.156 --> 00:11:31.158
<c.magenta>我向quadtree中</c>
<c.magenta>插入一宇宙飞船</c>

00:11:31.258 --> 00:11:34.294
<c.magenta>被放置在两层下的</c>
<c.magenta>左边的扇形区域中</c>

00:11:35.362 --> 00:11:38.365
<c.magenta>我要添加一些更大的物体</c>
<c.magenta>它们被放置在更上一层</c>

00:11:39.600 --> 00:11:41.101
<c.magenta>这里注意左边的小行星</c>

00:11:41.168 --> 00:11:43.470
<c.magenta>它有些跨越了扇形的边界</c>

00:11:43.537 --> 00:11:44.872
<c.magenta>它事实上需要处在更高一层</c>

00:11:44.938 --> 00:11:47.608
<c.magenta>因为它不能很好地</c>
<c.magenta>安放在任何一个隔间中</c>

00:11:48.842 --> 00:11:50.444
<c.magenta>最终 我再添加一些更小的物体</c>

00:11:50.511 --> 00:11:52.846
<c.magenta>你可以看到</c>
<c.magenta>它们处在向下三层的位置</c>

00:11:55.382 --> 00:11:57.818
<c.magenta>这就是底层的运作模式了</c>

00:11:57.918 --> 00:11:59.920
<c.magenta>当你使用quadtree</c>
<c.magenta>或是octree时</c>

00:12:01.188 --> 00:12:03.390
<c.magenta>实际情况中</c>
<c.magenta>quadtree的代码示例</c>

00:12:04.525 --> 00:12:06.460
<c.magenta>最上部</c>
<c.magenta>我要创造我的quadtree</c>

00:12:06.527 --> 00:12:09.363
<c.magenta>我要传入一个quad</c>
<c.magenta>这是我的游戏世界中的区域</c>

00:12:09.429 --> 00:12:10.964
<c.magenta>我想让这quadtree代表</c>

00:12:11.031 --> 00:12:16.003
<c.magenta>我们要覆盖游戏世界中(0, 0)</c>
<c.magenta>和(1000, 1000)间的区域</c>

00:12:17.137 --> 00:12:19.273
<c.magenta>我要指定最小隔间尺寸为100</c>

00:12:19.339 --> 00:12:22.242
<c.magenta>这个quadtree中没</c>
<c.magenta>哪个隔间可以小于100个单位</c>

00:12:24.278 --> 00:12:25.746
<c.magenta>我在游戏世界中还有一些敌人</c>

00:12:25.812 --> 00:12:28.115
<c.magenta>我要将它们添加到</c>
<c.magenta>我的quadtree中</c>

00:12:28.382 --> 00:12:31.285
<c.magenta>要注意这些敌人也有</c>
<c.magenta>一个quad与他们关联</c>

00:12:31.351 --> 00:12:33.520
<c.magenta>这就是我们的游戏世界</c>
<c.magenta>中的敌人所处的地方</c>

00:12:33.587 --> 00:12:35.923
<c.magenta>也是它们将在quadtree中</c>
<c.magenta>终止的地方</c>

00:12:37.658 --> 00:12:40.060
<c.magenta>最后 我要在quadtree</c>
<c.magenta>中进行一次查询</c>

00:12:40.160 --> 00:12:42.229
<c.magenta>我要让quadtree</c>
<c.magenta>给我所有的物体</c>

00:12:42.296 --> 00:12:46.066
<c.magenta>在quadtree的(0, 0)</c>
<c.magenta>和(1000, 1000)之间</c>

00:12:46.133 --> 00:12:47.801
<c.magenta>在我的游戏世界中</c>

00:12:47.868 --> 00:12:50.370
<c.magenta>结果我的三个敌人</c>
<c.magenta>都在这个范围中</c>

00:12:50.504 --> 00:12:52.806
<c.magenta>我要在查询后获得</c>
<c.magenta>这所有三个敌人</c>

00:12:54.374 --> 00:12:56.677
<c.magenta>这就是GameplayKit中</c>
<c.magenta>空间划分了</c>

00:12:56.977 --> 00:12:59.746
<c.magenta>让我们继续说说</c>
<c.magenta>我们的过程生成系统</c>

00:13:02.082 --> 00:13:04.184
<c.magenta>先说说一点背景知识</c>
<c.magenta>有关为什么过程生成</c>

00:13:04.251 --> 00:13:05.519
<c.magenta>可能对你很重要</c>

00:13:06.854 --> 00:13:09.356
<c.magenta>我相信大家都很熟悉</c>
<c.magenta>游戏中的预制内容</c>

00:13:09.423 --> 00:13:11.758
<c.magenta>这是我们在游戏运行前</c>
<c.magenta>我们制作的内容</c>

00:13:11.825 --> 00:13:13.360
<c.magenta>甚至是在游戏上市之前</c>

00:13:13.627 --> 00:13:16.730
<c.magenta>这些包括 艺术家设计</c>
<c.magenta>或是设计师设计的水平</c>

00:13:16.797 --> 00:13:19.333
<c.magenta>或艺术家开发的</c>
<c.magenta>结构或特质</c>

00:13:20.801 --> 00:13:23.470
<c.magenta>这些是很棒的资产</c>
<c.magenta>它们对许多游戏很有好处</c>

00:13:23.537 --> 00:13:26.373
<c.magenta>但对于其他的游戏</c>
<c.magenta>以及特定的题材</c>

00:13:27.207 --> 00:13:30.244
<c.magenta>你会遇到一些问题</c>
<c.magenta>因为这些资产是静态的</c>

00:13:30.310 --> 00:13:32.212
<c.magenta>它们在运行时不怎么变化</c>

00:13:32.279 --> 00:13:34.781
<c.magenta>所以尤其当我在寻找</c>
<c.magenta>一种随机的感觉时</c>

00:13:34.848 --> 00:13:36.750
<c.magenta>需要每次玩游戏时</c>
<c.magenta>都感觉到新</c>

00:13:37.818 --> 00:13:40.187
<c.magenta>我就不能使用这种</c>
<c.magenta>静态的资产了</c>

00:13:40.521 --> 00:13:42.089
<c.magenta>所以我需要的是过程内容</c>

00:13:42.155 --> 00:13:44.124
<c.magenta>比如随机生成的世界</c>

00:13:44.391 --> 00:13:47.027
<c.magenta>过程生成的结构或高度地图</c>

00:13:50.297 --> 00:13:53.100
<c.magenta>我们要制作游戏中的</c>
<c.magenta>这些过程内容</c>

00:13:53.433 --> 00:13:56.670
<c.magenta>我们真正需要的是</c>
<c.magenta>一种连贯的随机性的来源</c>

00:13:56.737 --> 00:13:59.606
<c.magenta>我所尝试制作的许多这种</c>
<c.magenta>随机元素都存在于自然中</c>

00:13:59.673 --> 00:14:02.643
<c.magenta>比如世界 结构和高度地图</c>

00:13:59.673 --> 00:14:02.643
<c.magenta>比如世界 结构和高度地图</c>

00:14:03.911 --> 00:14:06.046
<c.magenta>我们需要一种随机性</c>
<c.magenta>能在空间上具有意义</c>

00:14:06.113 --> 00:14:08.549
<c.magenta>能有一个潜在的</c>
<c.magenta>空间模式与之对应</c>

00:14:09.850 --> 00:14:10.684
<c.magenta>现在 你可能对自己说</c>

00:14:10.751 --> 00:14:12.486
<c.magenta>可以直接使用随机数生成器对吗？</c>

00:14:12.586 --> 00:14:14.922
<c.magenta>我可以从随机数生成器中获取一些数值</c>

00:14:14.988 --> 00:14:17.090
<c.magenta>来制作我的随机内容</c>
<c.magenta>然后就完成了</c>

00:14:18.025 --> 00:14:21.094
<c.magenta>所有尝试这么做的人</c>
<c.magenta>很快就会遇到障碍</c>

00:14:21.728 --> 00:14:24.364
<c.magenta>随机数生成器的输出波动很大</c>

00:14:24.431 --> 00:14:28.101
<c.magenta>连续的调用结果很难有</c>
<c.magenta>空间上有意义的联系</c>

00:14:28.435 --> 00:14:30.604
<c.magenta>尝试决定论也是很有挑战性的</c>

00:14:30.671 --> 00:14:34.808
<c.magenta>每当我随机生成内容时</c>
<c.magenta>我希望它能展示同样的内容</c>

00:14:34.875 --> 00:14:36.210
<c.magenta>如果我给它同样的种子</c>

00:14:37.544 --> 00:14:39.246
<c.magenta>我们要的来源应提供一致的随机性</c>

00:14:39.313 --> 00:14:42.049
<c.magenta>有一种这样的来源叫噪声</c>

00:14:43.650 --> 00:14:48.222
<c.magenta>噪声是一个函数</c>
<c.magenta>它接收一个输入 并输出数值</c>

00:14:48.555 --> 00:14:50.524
<c.magenta>但这个关联之间</c>
<c.magenta>还有一些规则</c>

00:14:51.158 --> 00:14:53.827
<c.magenta>对于输入中的微小变化</c>
<c.magenta>输出的变化也很小</c>

00:14:54.361 --> 00:14:56.930
<c.magenta>如果输入变化很大</c>
<c.magenta>我就会得到随机的</c>

00:14:56.997 --> 00:15:00.234
<c.magenta>但依然在空间上</c>
<c.magenta>有意义的输出变化</c>

00:14:56.997 --> 00:15:00.234
<c.magenta>但依然在空间上</c>
<c.magenta>有意义的输出变化</c>

00:15:00.300 --> 00:15:03.070
<c.magenta>在这个噪声来源中</c>
<c.magenta>有一些隐含的模式</c>

00:15:04.037 --> 00:15:07.040
<c.magenta>噪声函数对于整个</c>
<c.magenta>输入域来说是无穷的</c>

00:15:07.107 --> 00:15:09.443
<c.magenta>它无穷地伸展</c>
<c.magenta>而且它们具有确定性</c>

00:15:09.510 --> 00:15:11.612
<c.magenta>给定同样的输入</c>
<c.magenta>我总是会获得同样的输出</c>

00:15:13.847 --> 00:15:16.984
<c.magenta>所以一旦你使用这个噪声函数</c>
<c.magenta>我们可以在特定间隔处取样</c>

00:15:17.050 --> 00:15:20.220
<c.magenta>间隔与我要制作的游戏</c>
<c.magenta>与其内容类型相关</c>

00:15:20.287 --> 00:15:21.922
<c.magenta>所以如果我要随机生成世界时</c>

00:15:21.989 --> 00:15:25.359
<c.magenta>它可能是坐标或是瓦片索引</c>
<c.magenta>或是生物指数</c>

00:15:25.726 --> 00:15:27.327
<c.magenta>如果我要随机生成材质时</c>

00:15:27.394 --> 00:15:29.696
<c.magenta>它可以是贴图像素</c>
<c.magenta>或是像素等等</c>

00:15:33.100 --> 00:15:34.701
<c.magenta>概述一下我们所提供的</c>

00:15:34.768 --> 00:15:38.005
<c.magenta>通过我们的过程生成系统</c>
<c.magenta>和我们的噪声系统</c>

00:15:39.006 --> 00:15:42.676
<c.magenta>你有一系列的噪声来源</c>
<c.magenta>供你使用与取样</c>

00:15:42.743 --> 00:15:44.077
<c.magenta>来制作游戏中有意义的内容</c>

00:15:44.144 --> 00:15:45.913
<c.magenta>这些是类似于比较</c>
<c.magenta>随机的噪声</c>

00:15:45.979 --> 00:15:48.315
<c.magenta>比如Perlin噪声</c>
<c.magenta>和Voronoi噪声</c>

00:15:48.549 --> 00:15:50.884
<c.magenta>还有几何噪声源</c>
<c.magenta>比如巨浪</c>

00:15:50.951 --> 00:15:53.187
<c.magenta>与球体 脊与圆柱</c>

00:15:54.321 --> 00:15:56.924
<c.magenta>以及一些常量噪声源</c>
<c.magenta>比如西洋棋跳盘模式</c>

00:15:56.990 --> 00:15:58.859
<c.magenta>或是常量噪声函数</c>

00:16:00.427 --> 00:16:03.030
<c.magenta>然后你就可以组合这些</c>
<c.magenta>噪声源成为一个噪声物体</c>

00:16:03.096 --> 00:16:05.299
<c.magenta>并在其上展示一系列的变换</c>

00:16:05.832 --> 00:16:07.634
<c.magenta>这些包括结合噪声源</c>

00:16:07.701 --> 00:16:10.304
<c.magenta>或是转化 度量 旋转噪声源</c>

00:16:11.905 --> 00:16:15.209
<c.magenta>一旦我们以某种有意义的</c>
<c.magenta>方式将它们结合成一个噪声物体时</c>

00:16:15.275 --> 00:16:19.046
<c.magenta>我们而后可以对隐含的</c>
<c.magenta>一个区域的噪声地图 噪声函数取样</c>

00:16:19.346 --> 00:16:23.550
<c.magenta>在噪声地图中 我们获取采样</c>
<c.magenta>然后制作我们的游戏内容</c>

00:16:25.452 --> 00:16:28.355
<c.magenta>让我们再深入一下</c>
<c.magenta>聊聊我们的噪声源</c>

00:16:29.056 --> 00:16:32.793
<c.magenta>现在 我们所有的噪声源</c>
<c.magenta>输出值在负1与1之间</c>

00:16:32.926 --> 00:16:35.162
<c.magenta>我们一会针对这个再多说一些</c>

00:16:36.263 --> 00:16:39.032
<c.magenta>它们接收参数来调整</c>
<c.magenta>它们的不同的噪声输出</c>

00:16:39.099 --> 00:16:40.934
<c.magenta>在这些噪声函数之下</c>

00:16:41.068 --> 00:16:44.104
<c.magenta>所以对于我们随机性与一致性</c>
<c.magenta>较强的噪声源 如Perlin和Voronoi</c>

00:16:44.171 --> 00:16:46.507
<c.magenta>它们可以使用</c>
<c.magenta>GKRandomSource作为种子</c>

00:16:46.573 --> 00:16:49.943
<c.magenta>它们可以接收一系列参数</c>
<c.magenta>来调整它们隐含的模式</c>

00:16:50.711 --> 00:16:53.981
<c.magenta>对于偏几何的噪声源</c>
<c.magenta>可以接收参数来修改形状</c>

00:16:54.047 --> 00:16:58.852
<c.magenta>比如球体和圆柱体的尺寸</c>
<c.magenta>或是脊与巨浪的频率</c>

00:17:00.954 --> 00:17:02.556
<c.magenta>一旦我们有了合适的噪声源</c>

00:17:02.623 --> 00:17:04.758
<c.magenta>我们就可将它们结合</c>
<c.magenta>为一个GKNoiseObject</c>

00:17:05.659 --> 00:17:10.063
<c.magenta>它拥有所有必要的函数</c>
<c.magenta>以进行变换 组合和修改</c>

00:17:10.130 --> 00:17:12.398
<c.magenta>我们的噪声源</c>
<c.magenta>以及许多常用的数学</c>

00:17:12.465 --> 00:17:14.535
<c.magenta>与支持的逻辑操作</c>

00:17:14.867 --> 00:17:18.571
<c.magenta>如果我尝试组合噪声源</c>
<c.magenta>我可以做加法 乘法 取最大最小值</c>

00:17:19.439 --> 00:17:21.040
<c.magenta>但若我要变换单一的噪声源时</c>

00:17:21.108 --> 00:17:23.410
<c.magenta>我可以缩放、旋转、变换</c>

00:17:23.477 --> 00:17:27.013
<c.magenta>或者我可以通过取绝对值</c>
<c.magenta>取极限 取相反数来进行修改</c>

00:17:29.383 --> 00:17:31.351
<c.magenta>一旦我们找到了喜欢的噪声</c>

00:17:31.418 --> 00:17:34.188
<c.magenta>而后我们可以对该噪声的</c>
<c.magenta>一个区域进行取样</c>

00:17:34.254 --> 00:17:37.357
<c.magenta>对隐含的噪声函数</c>
<c.magenta>通过一个GKNoiseMap对象</c>

00:17:38.258 --> 00:17:39.893
<c.magenta>你指定一个起源与尺度</c>

00:17:39.960 --> 00:17:43.096
<c.magenta>这就是我们要取样的</c>
<c.magenta>隐含的噪声图的区域</c>

00:17:43.163 --> 00:17:44.731
<c.magenta>你还需要指定一个样本数量</c>

00:17:44.798 --> 00:17:47.301
<c.magenta>我们要在这个区域中</c>
<c.magenta>对该噪声函数进行几次取样？</c>

00:17:47.367 --> 00:17:49.770
<c.magenta>我取样的保真度是多高？</c>

00:17:51.171 --> 00:17:53.207
<c.magenta>当我们对区域完成取样后</c>

00:17:53.273 --> 00:17:56.343
<c.magenta>我们就可以获得该噪声图</c>
<c.magenta>上任意位置的值</c>

00:17:56.410 --> 00:17:59.880
<c.magenta>再说一次 我刚才提到了</c>
<c.magenta>范围是负1到1</c>

00:18:00.314 --> 00:18:02.816
<c.magenta>在运行时 你可以选择</c>
<c.magenta>按需覆盖某些值</c>

00:18:02.883 --> 00:18:03.984
<c.magenta>若你的游戏世界改变</c>

00:18:05.886 --> 00:18:07.120
<c.magenta>这些理解起来并不轻松</c>

00:18:07.187 --> 00:18:10.224
<c.magenta>我认为解释清楚这些的</c>
<c.magenta>最佳方式是给出视觉例子</c>

00:18:11.191 --> 00:18:13.727
<c.magenta>假设我要为我的游戏</c>
<c.magenta>随机生成一个地图</c>

00:18:14.094 --> 00:18:16.797
<c.magenta>我要根据地球的生物</c>
<c.magenta>群系来对其建立模型</c>

00:18:16.930 --> 00:18:18.432
<c.magenta>我想让它看起来很真实</c>

00:18:18.498 --> 00:18:21.668
<c.magenta>沙漠 树林 北极区</c>
<c.magenta>诸如此类</c>

00:18:23.437 --> 00:18:25.772
<c.magenta>第一 这是你为了完成需求</c>
<c.magenta>可以使用的一种方法</c>

00:18:25.839 --> 00:18:28.075
<c.magenta>这里我生成了两个Perlin噪声图</c>

00:18:29.843 --> 00:18:31.512
<c.magenta>我将左边的称为湿度图</c>

00:18:31.578 --> 00:18:33.981
<c.magenta>在我的游戏世界的任何一点</c>
<c.magenta>我都可以找到这张图</c>

00:18:34.047 --> 00:18:37.017
<c.magenta>来决定我的游戏世界应有</c>
<c.magenta>多潮湿或说多干燥</c>

00:18:37.885 --> 00:18:39.753
<c.magenta>我将右边的图称为温度图</c>

00:18:39.820 --> 00:18:42.656
<c.magenta>在我的游戏世界的任意一点</c>
<c.magenta>我可以找到这张图</c>

00:18:43.056 --> 00:18:45.626
<c.magenta>来决定我的游戏世界</c>
<c.magenta>有多热或说有多冷</c>

00:18:47.294 --> 00:18:49.229
<c.magenta>在这里需要提到</c>
<c.magenta>我们将来还要回到这里</c>

00:18:49.296 --> 00:18:53.133
<c.magenta>在湿度图中 你可以看到</c>
<c.magenta>我在右侧有一个很干燥的点</c>

00:18:53.200 --> 00:18:56.170
<c.magenta>那就是黑斑</c>
<c.magenta>是左侧的一个很干燥的区域</c>

00:18:56.470 --> 00:18:59.206
<c.magenta>再说一次 这些颜色</c>
<c.magenta>代表我所说的输出</c>

00:18:59.273 --> 00:19:03.610
<c.magenta>这里黑色是负1</c>
<c.magenta>白色是正1</c>

00:18:59.273 --> 00:19:03.610
<c.magenta>这里黑色是负1</c>
<c.magenta>白色是正1</c>

00:19:05.045 --> 00:19:07.214
<c.magenta>在右侧 注意到我</c>
<c.magenta>在顶部有一个很冷的点</c>

00:19:07.281 --> 00:19:08.415
<c.magenta>那又是一个黑斑</c>

00:19:08.482 --> 00:19:11.885
<c.magenta>还有一个很热的</c>
<c.magenta>在我的噪声图的右侧</c>

00:19:13.720 --> 00:19:16.423
<c.magenta>我要指定在组合这些</c>
<c.magenta>时的一些规则</c>

00:19:16.490 --> 00:19:18.158
<c.magenta>以对我的游戏产生意义</c>

00:19:18.992 --> 00:19:20.294
<c.magenta>这里我有一个简单2D图</c>

00:19:20.360 --> 00:19:25.532
<c.magenta>在纵轴中 我有湿度</c>
<c.magenta>在横轴中是温度</c>

00:19:26.166 --> 00:19:30.103
<c.magenta>我可以使用这些规则</c>
<c.magenta>来决定这两个图的交界</c>

00:19:30.170 --> 00:19:33.140
<c.magenta>如果我有一个点</c>
<c.magenta>它有很高的温度和很低的湿度</c>

00:19:33.207 --> 00:19:35.242
<c.magenta>我就会获得一个沙漠</c>

00:19:35.576 --> 00:19:38.078
<c.magenta>或者如果我有一个点</c>
<c.magenta>温度很高 湿度很高</c>

00:19:38.145 --> 00:19:39.913
<c.magenta>我就会获得一个热带雨林</c>

00:19:40.314 --> 00:19:42.449
<c.magenta>所以在这里</c>
<c.magenta>在冷的那一端</c>

00:19:42.516 --> 00:19:44.351
<c.magenta>我有冻土和北极区</c>

00:19:44.551 --> 00:19:47.187
<c.magenta>在中间 我有更加温和的地带</c>

00:19:47.254 --> 00:19:49.623
<c.magenta>比如森林 大草原和牧场</c>

00:19:51.525 --> 00:19:54.695
<c.magenta>这两个图一起使用</c>
<c.magenta>我基于这些规则将它们组合</c>

00:19:56.029 --> 00:19:57.364
<c.magenta>就获得了这样的东西</c>

00:19:58.532 --> 00:20:02.336
<c.magenta>你可以看到它有一个</c>
<c.magenta>很好很真实的感觉 还有一点</c>

00:19:58.532 --> 00:20:02.336
<c.magenta>你可以看到它有一个</c>
<c.magenta>很好很真实的感觉 还有一点</c>

00:20:02.402 --> 00:20:04.304
<c.magenta>在右侧 可以看到我们有很大的沙漠</c>

00:20:04.371 --> 00:20:07.708
<c.magenta>渐渐变为牧场</c>
<c.magenta>而后变为森林地区</c>

00:20:08.108 --> 00:20:10.811
<c.magenta>这与我们湿度图的干燥点相符</c>

00:20:10.911 --> 00:20:13.080
<c.magenta>以及在我们的温度图</c>
<c.magenta>中的那个很热的点</c>

00:20:13.814 --> 00:20:15.649
<c.magenta>在左上方 你看到我们有</c>

00:20:15.716 --> 00:20:17.651
<c.magenta>一个很大的冻土与冰冷的点</c>

00:20:18.151 --> 00:20:21.522
<c.magenta>在右上方与左下方</c>
<c.magenta>我们有一些小的热带雨林</c>

00:20:21.588 --> 00:20:24.391
<c.magenta>与很高的温度与湿度相符</c>

00:20:26.260 --> 00:20:29.029
<c.magenta>所以这只是很基本的例子</c>
<c.magenta>有关你可以完成的很酷的东西</c>

00:20:29.096 --> 00:20:30.264
<c.magenta>通过过程生成</c>

00:20:30.330 --> 00:20:32.165
<c.magenta>这里我们只使用了两个简单的噪声图</c>

00:20:32.232 --> 00:20:36.170
<c.magenta>并通过很简单的规则将它们组合</c>
<c.magenta>获得了很漂亮很好的结果</c>

00:20:38.438 --> 00:20:40.374
<c.magenta>我想邀请同事</c>
<c.magenta>Michael Brennan上台</c>

00:20:40.440 --> 00:20:42.342
<c.magenta>来向大家分享游戏AI中的新特性</c>

00:20:42.442 --> 00:20:43.277
<c.magenta>Michael？</c>

00:20:49.950 --> 00:20:51.084
<c.magenta>谢谢 Bruno</c>

00:20:51.718 --> 00:20:53.453
<c.magenta>大家好</c>
<c.magenta>我是Michael Brennan</c>

00:20:53.520 --> 00:20:56.023
<c.magenta>我是Apple的游戏技术工程师</c>

00:20:56.190 --> 00:20:57.558
<c.magenta>我很高兴今天能与大家分享</c>

00:20:58.091 --> 00:21:00.794
<c.magenta>我们为游戏AI在</c>
<c.magenta>GameplayKit中进行更新</c>

00:20:58.091 --> 00:21:00.794
<c.magenta>我们为游戏AI在</c>
<c.magenta>GameplayKit中进行更新</c>

00:21:03.497 --> 00:21:06.900
<c.magenta>去年与GameplayKit一起</c>
<c.magenta>我们介绍了Minmax策略</c>

00:21:07.367 --> 00:21:10.103
<c.magenta>这是一个对于各种游戏的</c>
<c.magenta>很棒的AI方案</c>

00:21:10.537 --> 00:21:13.907
<c.magenta>可以保证对你的游戏状态</c>
<c.magenta>有最佳的搜索</c>

00:21:15.309 --> 00:21:18.445
<c.magenta>它之所以能保证</c>
<c.magenta>是通过对状态空间进行大量搜索</c>

00:21:18.879 --> 00:21:24.051
<c.magenta>同时组合你对游戏中每种状态</c>
<c.magenta>所提供的得分函数</c>

00:21:24.117 --> 00:21:28.088
<c.magenta>来提供给你你的一个实体</c>
<c.magenta>在某一点的最佳行为</c>

00:21:29.089 --> 00:21:31.024
<c.magenta>但是Minmax策略的高消耗本质</c>

00:21:31.091 --> 00:21:35.262
<c.magenta>使它对于那些状态空间较大</c>
<c.magenta>的游戏并不合适</c>

00:21:35.362 --> 00:21:37.297
<c.magenta>比如围棋和象棋</c>

00:21:38.832 --> 00:21:43.237
<c.magenta>这就是为何今年我很高兴向大家</c>
<c.magenta>介绍Monte Carlo策略</c>

00:21:44.505 --> 00:21:48.041
<c.magenta>Monte Carlo策略是一个对</c>
<c.magenta>状态空间的最佳首次搜索</c>

00:21:48.108 --> 00:21:51.044
<c.magenta>与对状态空间的随机取样结合</c>

00:21:51.111 --> 00:21:53.780
<c.magenta>来计算出你的对手的最佳行为</c>

00:21:55.015 --> 00:21:57.718
<c.magenta>它完成这一点</c>
<c.magenta>是通过首先选择一个玩家行为</c>

00:21:58.151 --> 00:22:02.122
<c.magenta>使用勘探开采算法</c>
<c.magenta>来选择该行为</c>

00:21:58.151 --> 00:22:02.122
<c.magenta>使用勘探开采算法</c>
<c.magenta>来选择该行为</c>

00:22:02.789 --> 00:22:05.392
<c.magenta>然后从该行为开始</c>
<c.magenta>模拟新的游戏</c>

00:22:05.692 --> 00:22:09.596
<c.magenta>直到它达到结束状态</c>
<c.magenta>不论是胜利 失败或是平局</c>

00:22:10.097 --> 00:22:12.533
<c.magenta>而后继续沿着树迭代</c>

00:22:15.202 --> 00:22:18.939
<c.magenta>它不能保证如Minmax一样</c>
<c.magenta>的最佳行为</c>

00:22:19.006 --> 00:22:21.308
<c.magenta>但是它趋近于最佳行为</c>

00:22:23.877 --> 00:22:25.612
<c.magenta>Monte Carlo策略速度快</c>

00:22:25.746 --> 00:22:28.615
<c.magenta>它能保证很好的表现</c>
<c.magenta>即使是对一些游戏</c>

00:22:28.682 --> 00:22:31.585
<c.magenta>有很大的状态空间</c>
<c.magenta>比如说围棋</c>

00:22:32.319 --> 00:22:34.821
<c.magenta>由于它只需要最终情况</c>

00:22:35.322 --> 00:22:37.491
<c.magenta>这需要让你的游戏提供</c>

00:22:37.691 --> 00:22:39.793
<c.magenta>这在你的游戏中很容易实现</c>

00:22:40.460 --> 00:22:41.895
<c.magenta>它几乎是最佳的</c>

00:22:41.962 --> 00:22:45.098
<c.magenta>虽然它可能不是Minmax</c>
<c.magenta>所找到的最佳行为</c>

00:22:45.165 --> 00:22:49.002
<c.magenta>它们几乎是一样的</c>
<c.magenta>并且会随着时间增加越来越趋近</c>

00:22:52.139 --> 00:22:54.041
<c.magenta>让我们说说你需要</c>
<c.magenta>用到的元素</c>

00:22:54.208 --> 00:22:56.076
<c.magenta>来在你的游戏中集成这一点</c>

00:22:57.144 --> 00:22:59.913
<c.magenta>使用GKMonteCarloStrategist时</c>
<c.magenta>你需要提供一个预算</c>

00:23:00.180 --> 00:23:03.317
<c.magenta>这是它完成我们刚才说到的</c>
<c.magenta>四个步骤所要花费的时间</c>

00:23:03.951 --> 00:23:06.687
<c.magenta>你需要提供探索参数</c>

00:23:06.753 --> 00:23:10.157
<c.magenta>现在 这是一个在0与1之间</c>
<c.magenta>的值 代表要不要</c>

00:23:10.224 --> 00:23:13.794
<c.magenta>选择一个行为时</c>
<c.magenta>探索没有到达过的节点</c>

00:23:14.461 --> 00:23:18.932
<c.magenta>或是你想让它开拓</c>
<c.magenta>它去过与发现的节点来最大化优势</c>

00:23:19.833 --> 00:23:21.635
<c.magenta>你当然还需要提供游戏模型</c>

00:23:21.702 --> 00:23:25.539
<c.magenta>若你使用过GKMinmaxStrategist</c>
<c.magenta>你就应该对这很熟悉了</c>

00:23:26.874 --> 00:23:28.475
<c.magenta>现让我们看一很简单的代码示例</c>

00:23:29.543 --> 00:23:31.745
<c.magenta>获取了游戏模型</c>
<c.magenta>GoGameModel</c>

00:23:31.812 --> 00:23:33.547
<c.magenta>我们要持有它的一个引用</c>

00:23:33.614 --> 00:23:34.948
<c.magenta>及我们的Monte Carlo策略</c>

00:23:35.015 --> 00:23:37.384
<c.magenta>我们要将其实例化</c>
<c.magenta>并持有一个引用</c>

00:23:37.918 --> 00:23:40.387
<c.magenta>我们先设置Monte Carlo</c>
<c.magenta>策略游戏模型</c>

00:23:40.454 --> 00:23:42.256
<c.magenta>来指向我们的游戏模型</c>

00:23:43.590 --> 00:23:45.359
<c.magenta>下一步 我们要对其指定预算</c>

00:23:45.626 --> 00:23:46.727
<c.magenta>设置在100左右</c>

00:23:46.793 --> 00:23:51.231
<c.magenta>这意味着它要完成四个步骤</c>
<c.magenta>模拟与迭代100次</c>

00:23:51.565 --> 00:23:53.467
<c.magenta>然后我们要将探索</c>
<c.magenta>参数设置为1</c>

00:23:53.534 --> 00:23:56.203
<c.magenta>这意味着我们想让它</c>
<c.magenta>尽可能地探索</c>

00:23:58.438 --> 00:24:01.842
<c.magenta>然后我们只需要获取</c>
<c.magenta>活动玩家的最佳行为</c>

00:23:58.438 --> 00:24:01.842
<c.magenta>然后我们只需要获取</c>
<c.magenta>活动玩家的最佳行为</c>

00:24:01.909 --> 00:24:06.346
<c.magenta>在该游戏状态中 找到最佳行为</c>
<c.magenta>并将其应用到游戏模型中</c>

00:24:06.613 --> 00:24:07.748
<c.magenta>就是这么简单</c>

00:24:09.850 --> 00:24:12.019
<c.magenta>今年 我很激动地告诉大家</c>
<c.magenta>我们还允许</c>

00:24:12.085 --> 00:24:13.554
<c.magenta>制作自己自定义的策略</c>

00:24:14.488 --> 00:24:16.890
<c.magenta>我们实现了新协议</c>
<c.magenta>叫GKStrategist</c>

00:24:16.957 --> 00:24:19.560
<c.magenta>你只需要遵守它</c>
<c.magenta>给出游戏模型</c>

00:24:19.626 --> 00:24:21.728
<c.magenta>游戏模型更新与游戏模型玩家</c>

00:24:22.829 --> 00:24:25.766
<c.magenta>并实现找到玩家的最佳行为</c>

00:24:25.999 --> 00:24:30.637
<c.magenta>你可以使用这个策略</c>
<c.magenta>就像你使用我我们提供的策略一样</c>

00:24:32.639 --> 00:24:33.941
<c.magenta>这就是我们在策略方面提供的新功能</c>

00:24:34.007 --> 00:24:35.542
<c.magenta>现在让我们说点别的</c>

00:24:36.243 --> 00:24:37.244
<c.magenta>决策制定</c>

00:24:40.113 --> 00:24:42.149
<c.magenta>有许多方法来对你的</c>
<c.magenta>游戏中的逻辑建模</c>

00:24:42.316 --> 00:24:44.818
<c.magenta>其中许多已经被</c>
<c.magenta>GameplayKit所支持</c>

00:24:45.552 --> 00:24:49.356
<c.magenta>你的敌人需要制定决策</c>
<c.magenta>来考虑大量的状态</c>

00:24:49.423 --> 00:24:51.825
<c.magenta>他们需要能很快的</c>
<c.magenta>制定决策</c>

00:24:53.126 --> 00:24:55.762
<c.magenta>你可以在这里看到</c>
<c.magenta>我们有这个很小的按钮跳跃游戏</c>

00:24:56.230 --> 00:24:59.099
<c.magenta>就算是在这个简单的游戏中</c>
<c.magenta>你的对手需要考虑</c>

00:24:59.199 --> 00:25:02.469
<c.magenta>你的位置 其他敌人的位置</c>
<c.magenta>和按钮的位置</c>

00:24:59.199 --> 00:25:02.469
<c.magenta>你的位置 其他敌人的位置</c>
<c.magenta>和按钮的位置</c>

00:25:02.703 --> 00:25:04.638
<c.magenta>在某个时间点谁</c>
<c.magenta>拥有按钮</c>

00:25:04.705 --> 00:25:07.174
<c.magenta>他们是否在跳跃</c>
<c.magenta>敌人是否在跳跃</c>

00:25:07.608 --> 00:25:08.809
<c.magenta>他们在一层的哪个位置</c>

00:25:08.876 --> 00:25:10.444
<c.magenta>还是要考虑不少事情的</c>

00:25:12.980 --> 00:25:16.250
<c.magenta>一个简单的制定决策的</c>
<c.magenta>方法是决策树</c>

00:25:16.817 --> 00:25:20.420
<c.magenta>它们是树状的数据结构</c>
<c.magenta>使决策更易于观察与除错</c>

00:25:20.954 --> 00:25:22.923
<c.magenta>它们可以是制作的</c>
<c.magenta>或是学习得到的</c>

00:25:25.859 --> 00:25:30.130
<c.magenta>GKDecisionTree让你在</c>
<c.magenta>决定行为时能有较小的开销</c>

00:25:30.797 --> 00:25:32.900
<c.magenta>它是完全可序列化的</c>
<c.magenta>灵活性也很强</c>

00:25:33.300 --> 00:25:34.735
<c.magenta>允许你创造节点</c>

00:25:34.801 --> 00:25:38.105
<c.magenta>能随机进行决策</c>
<c.magenta>并对分支委派权重</c>

00:25:38.172 --> 00:25:41.675
<c.magenta>或是基于特定分支的值</c>
<c.magenta>如果这个值是真或假的话</c>

00:25:41.742 --> 00:25:43.544
<c.magenta>或是均等的满足描述</c>

00:25:43.610 --> 00:25:46.180
<c.magenta>它非常的灵活</c>
<c.magenta>允许你完成许多事情</c>

00:25:48.382 --> 00:25:49.983
<c.magenta>让我们看一个简单的代码示例</c>

00:25:50.851 --> 00:25:52.452
<c.magenta>你可以在这里看到</c>
<c.magenta>我们有一个树</c>

00:25:52.519 --> 00:25:54.821
<c.magenta>我们要通过一个根元素</c>
<c.magenta>对它进行初始化</c>

00:25:54.888 --> 00:25:56.557
<c.magenta>查询是否我们接近按钮</c>

00:25:57.724 --> 00:26:00.327
<c.magenta>然后我们要获取该根元素节点</c>
<c.magenta>的引用以备后用</c>

00:25:57.724 --> 00:26:00.327
<c.magenta>然后我们要获取该根元素节点</c>
<c.magenta>的引用以备后用</c>

00:26:01.962 --> 00:26:05.432
<c.magenta>在此之后 我们只需要从</c>
<c.magenta>该根元素出发创建分支</c>

00:26:05.499 --> 00:26:11.004
<c.magenta>一个是我们接近该按钮的情况</c>
<c.magenta>这种情况下我们就要跳</c>

00:26:11.138 --> 00:26:14.708
<c.magenta>另一个是我们并不接近的情况</c>
<c.magenta>这种情况下我们要选择游走</c>

00:26:14.942 --> 00:26:17.578
<c.magenta>我们也要获取到该</c>
<c.magenta>游走节点的引用</c>

00:26:19.179 --> 00:26:21.582
<c.magenta>通过那个游走节点</c>
<c.magenta>我们就可以创建一些分支</c>

00:26:21.782 --> 00:26:25.185
<c.magenta>一个权重是9</c>
<c.magenta>意为在该点向左走</c>

00:26:25.252 --> 00:26:26.620
<c.magenta>另一权重是1</c>
<c.magenta>意为我们要向右走</c>

00:26:26.687 --> 00:26:27.554
<c.magenta>现在 这个权重是叠加的</c>

00:26:27.621 --> 00:26:31.625
<c.magenta>意思是对于左侧分支而言</c>
<c.magenta>我们走的权重是9</c>

00:26:31.692 --> 00:26:35.329
<c.magenta>因为总权重是10</c>
<c.magenta>所以向左走的概率是90%</c>

00:26:35.696 --> 00:26:38.599
<c.magenta>向右走则有10%的概率发生</c>

00:26:40.801 --> 00:26:43.637
<c.magenta>然后我们要将状态</c>
<c.magenta>打包到字典中</c>

00:26:43.770 --> 00:26:47.608
<c.magenta>并将其传入树的findActionForAnswers</c>
<c.magenta>方法来获得我们的行为</c>

00:26:49.510 --> 00:26:51.311
<c.magenta>决策树也可以被建模</c>

00:26:51.678 --> 00:26:53.714
<c.magenta>你只需要提供游戏数据</c>

00:26:54.114 --> 00:26:56.817
<c.magenta>它就会在数据中寻找到</c>
<c.magenta>进行决策的行为</c>

00:26:56.884 --> 00:26:59.853
<c.magenta>并对该制定决策的行为</c>
<c.magenta>找到一个合适的树</c>

00:27:01.922 --> 00:27:05.392
<c.magenta>在我们的方阵中你可以看到</c>
<c.magenta>最上的一行是深灰色的</c>

00:27:05.559 --> 00:27:06.793
<c.magenta>那就是属性</c>

00:27:07.294 --> 00:27:09.663
<c.magenta>内部的矩阵是我们的样例</c>

00:27:10.063 --> 00:27:12.999
<c.magenta>那就是我们在游戏中</c>
<c.magenta>不同的游戏点的样子</c>

00:27:13.433 --> 00:27:16.303
<c.magenta>在右侧 我们有进行的动作</c>

00:27:16.470 --> 00:27:19.406
<c.magenta>这只是我们在游戏的不同点</c>
<c.magenta>中进行的操作</c>

00:27:20.574 --> 00:27:23.210
<c.magenta>你将它传入GKDecisionTree</c>
<c.magenta>的构造方法中</c>

00:27:23.377 --> 00:27:26.980
<c.magenta>它就会找到一个决策树</c>
<c.magenta>来适应你所记录的游戏数据</c>

00:27:28.815 --> 00:27:30.851
<c.magenta>让我们看看这在游戏中的样子</c>

00:27:33.053 --> 00:27:37.357
<c.magenta>这里我有一个玩家</c>
<c.magenta>浅绿色到青绿色的玩家</c>

00:27:37.424 --> 00:27:38.792
<c.magenta>对抗深蓝色玩家</c>

00:27:38.859 --> 00:27:41.094
<c.magenta>使用我们刚才展示的</c>
<c.magenta>手动创建的决策树</c>

00:27:41.195 --> 00:27:43.130
<c.magenta>如你所见 它遗漏掉了一些</c>

00:27:43.197 --> 00:27:45.032
<c.magenta>我们进行的操作</c>
<c.magenta>这样我们表现会变好</c>

00:27:47.167 --> 00:27:48.902
<c.magenta>让我们看另一个例子</c>

00:27:49.670 --> 00:27:53.841
<c.magenta>这里你可以看到它的行为</c>
<c.magenta>更像我们刚才的行为</c>

00:27:54.308 --> 00:27:56.476
<c.magenta>如我所说 你只需要记录</c>
<c.magenta>你的游戏数据</c>

00:27:56.543 --> 00:27:59.947
<c.magenta>将其传入 你就能模拟行为</c>
<c.magenta>就像你自己的行为一样</c>

00:28:02.082 --> 00:28:04.751
<c.magenta>即在GameplayKit中</c>
<c.magenta>今年新引入的游戏AI</c>

00:28:05.219 --> 00:28:07.054
<c.magenta>它很棒</c>
<c.magenta>我很激动能与大家分享</c>

00:28:07.120 --> 00:28:10.123
<c.magenta>现在我要邀请我的同事</c>
<c.magenta>Sri Nair上台</c>

00:28:10.190 --> 00:28:13.093
<c.magenta>介绍更多有关Xcode</c>
<c.magenta>集成Gameplay</c>

00:28:13.727 --> 00:28:14.595
<c.magenta>Sri？</c>

00:28:18.765 --> 00:28:19.766
<c.magenta>谢谢Michael</c>

00:28:22.236 --> 00:28:23.136
<c.magenta>大家好</c>

00:28:23.770 --> 00:28:24.838
<c.magenta>我是Sri Nair</c>

00:28:24.905 --> 00:28:27.608
<c.magenta>我是Apple的一个游戏技术工程师</c>

00:28:30.110 --> 00:28:32.446
<c.magenta>去年介绍GameplayKit时</c>

00:28:32.946 --> 00:28:35.082
<c.magenta>它只能由代码驱动</c>

00:28:36.016 --> 00:28:38.485
<c.magenta>你需要创建构造器</c>
<c.magenta>完成所有的连接工作</c>

00:28:39.353 --> 00:28:42.289
<c.magenta>并改变属性和值</c>
<c.magenta>全在代码中完成</c>

00:28:43.257 --> 00:28:46.193
<c.magenta>这可能会很低效</c>
<c.magenta>原因显而易见</c>

00:28:47.628 --> 00:28:51.031
<c.magenta>我很高兴能告诉大家</c>
<c.magenta>我们对这个问题进行了优化</c>

00:28:51.398 --> 00:28:55.102
<c.magenta>通过向GameplayKit引入</c>
<c.magenta>更加由数据驱动的工作流</c>

00:28:56.003 --> 00:28:59.173
<c.magenta>通过在Xcode和</c>
<c.magenta>SpriteKit编辑器中集成它</c>

00:29:00.707 --> 00:29:04.545
<c.magenta>如你所知 编辑器整合</c>
<c.magenta>可以更快的提高</c>

00:29:04.611 --> 00:29:06.647
<c.magenta>你的游戏功能的体验</c>

00:29:07.881 --> 00:29:10.384
<c.magenta>它们还有助于分离</c>
<c.magenta>工程师工作流</c>

00:29:10.551 --> 00:29:11.952
<c.magenta>和设计工作流</c>

00:29:14.388 --> 00:29:17.324
<c.magenta>所以现在编辑器有</c>
<c.magenta>四个主要的新特性</c>

00:29:17.457 --> 00:29:19.826
<c.magenta>帮大家加速</c>
<c.magenta>GameplayKit开发</c>

00:29:21.295 --> 00:29:23.764
<c.magenta>第一个 实体和组件编辑器</c>

00:29:24.765 --> 00:29:26.767
<c.magenta>第二个 导航图编辑器</c>

00:29:27.301 --> 00:29:29.236
<c.magenta>第三个 场景轮廓视图</c>

00:29:29.970 --> 00:29:32.005
<c.magenta>第四个 状态机快速查看</c>

00:29:32.940 --> 00:29:35.375
<c.magenta>让我们细说这四个特性</c>

00:29:35.909 --> 00:29:37.511
<c.magenta>什么是组件编辑器呢？</c>

00:29:38.545 --> 00:29:42.516
<c.magenta>让我们回想一下</c>
<c.magenta>实体和组件系统是一个设计模式</c>

00:29:43.417 --> 00:29:45.986
<c.magenta>其中一个游戏物体是通过实体展示</c>

00:29:46.520 --> 00:29:51.225
<c.magenta>而它们的行为则是通过</c>
<c.magenta>更小的独立组件展示</c>

00:29:52.025 --> 00:29:55.395
<c.magenta>这能提供更好的代码架构</c>
<c.magenta>与代码易用性</c>

00:29:56.463 --> 00:30:00.334
<c.magenta>它们也会更易于维护和扩展</c>

00:29:56.463 --> 00:30:00.334
<c.magenta>它们也会更易于维护和扩展</c>

00:30:01.502 --> 00:30:06.440
<c.magenta>所以现在通过组件编辑器</c>
<c.magenta>你可以将实体与组件赋给</c>

00:30:06.507 --> 00:30:08.308
<c.magenta>在编辑器中的节点</c>

00:30:10.177 --> 00:30:13.280
<c.magenta>并在编辑器中修改属性</c>
<c.magenta>编辑器提供</c>

00:30:13.380 --> 00:30:15.916
<c.magenta>一个基于编辑器的</c>
<c.magenta>数据驱动的工作流</c>

00:30:17.918 --> 00:30:21.255
<c.magenta>编辑器与代码紧密整合</c>

00:30:21.321 --> 00:30:24.992
<c.magenta>并支持组件类和属性的自动查找</c>

00:30:25.559 --> 00:30:28.996
<c.magenta>举个例子 假设你要写一个</c>
<c.magenta>运动组件类</c>

00:30:29.296 --> 00:30:31.965
<c.magenta>它派生自GKComponent</c>
<c.magenta>添加了几个属性</c>

00:30:32.199 --> 00:30:36.136
<c.magenta>并由新引入的</c>
<c.magenta>GKInspectableKeyword注解</c>

00:30:36.537 --> 00:30:38.472
<c.magenta>来展示在UI中</c>

00:30:39.907 --> 00:30:43.710
<c.magenta>组件编辑器会自动探测到</c>

00:30:43.777 --> 00:30:46.280
<c.magenta>这些你已经添加并展示在</c>
<c.magenta>UI中的组件</c>

00:30:46.346 --> 00:30:49.683
<c.magenta>现在你只需要选择你需要的组件</c>

00:30:49.750 --> 00:30:51.285
<c.magenta>并赋给节点</c>

00:30:52.085 --> 00:30:56.023
<c.magenta>一旦你添加了组件</c>
<c.magenta>属性就被自动填充了</c>

00:30:57.291 --> 00:30:59.126
<c.magenta>基于相应的数据类型</c>

00:30:59.993 --> 00:31:03.530
<c.magenta>现在你只需修改这些属性</c>
<c.magenta>并在编辑器中直接预览变更</c>

00:30:59.993 --> 00:31:03.530
<c.magenta>现在你只需修改这些属性</c>
<c.magenta>并在编辑器中直接预览变更</c>

00:31:03.864 --> 00:31:06.133
<c.magenta>无需退出编辑器</c>

00:31:06.200 --> 00:31:09.136
<c.magenta>或是重新编辑代码</c>
<c.magenta>来使遍历更快</c>

00:31:11.538 --> 00:31:16.677
<c.magenta>并且这些所有的更新</c>
<c.magenta>都保存在SKS文件下的一个JKC中</c>

00:31:18.145 --> 00:31:21.815
<c.magenta>所有未被改变的属性值</c>
<c.magenta>都使用默认设置代码</c>

00:31:23.784 --> 00:31:27.788
<c.magenta>与节点连接相关联的GKEntity</c>
<c.magenta>是在后台生成的</c>

00:31:27.855 --> 00:31:29.790
<c.magenta>通过一个GKSKComponent</c>

00:31:31.491 --> 00:31:34.628
<c.magenta>UI支持所有的</c>
<c.magenta>常用属性类型</c>

00:31:34.862 --> 00:31:37.631
<c.magenta>比如浮点 整形 布尔等等</c>

00:31:40.067 --> 00:31:41.235
<c.magenta>这就是组件编辑器了</c>

00:31:41.301 --> 00:31:44.004
<c.magenta>现在 让我们继续说</c>
<c.magenta>导航图编辑器</c>

00:31:45.172 --> 00:31:46.607
<c.magenta>Bruno刚才提到了</c>

00:31:46.673 --> 00:31:50.410
<c.magenta>导航图 也就是GKGraph</c>
<c.magenta>是用于寻路的目的</c>

00:31:51.011 --> 00:31:54.848
<c.magenta>来找到一个物体从A到B的最佳路径</c>

00:31:56.884 --> 00:31:59.353
<c.magenta>通过导航图编辑器</c>

00:31:59.820 --> 00:32:02.556
<c.magenta>现在你可以直接在</c>
<c.magenta>编辑器中创建GKGraph</c>

00:31:59.820 --> 00:32:02.556
<c.magenta>现在你可以直接在</c>
<c.magenta>编辑器中创建GKGraph</c>

00:32:03.490 --> 00:32:08.095
<c.magenta>你可以添加或修改节点</c>
<c.magenta>在其间添加连接</c>

00:32:08.161 --> 00:32:10.831
<c.magenta>只需要在一个窗口中</c>
<c.magenta>点击并拖拽</c>

00:32:12.032 --> 00:32:15.569
<c.magenta>这些GKGraph保存在</c>
<c.magenta>GKScene中</c>

00:32:15.636 --> 00:32:18.672
<c.magenta>你可以在之后通过代码获取</c>
<c.magenta>并用于寻路</c>

00:32:21.441 --> 00:32:25.646
<c.magenta>还有一个我们在SpriteKit编辑器中</c>
<c.magenta>一个很有用的特性</c>

00:32:25.712 --> 00:32:28.749
<c.magenta>对Gameplay Kit</c>
<c.magenta>开发也很有用</c>

00:32:28.815 --> 00:32:30.484
<c.magenta>叫做场景轮廓视图</c>

00:32:33.220 --> 00:32:37.257
<c.magenta>它绘出场景元素的轮廓</c>
<c.magenta>它们的父子层级关系</c>

00:32:39.226 --> 00:32:42.729
<c.magenta>这里支持大多数</c>
<c.magenta>标准的操作</c>

00:32:42.796 --> 00:32:47.534
<c.magenta>比如添加 编辑 重排 删除等等</c>

00:32:49.736 --> 00:32:53.440
<c.magenta>你在你的场景中添加的导航图</c>
<c.magenta>也会在这里展示</c>

00:32:53.507 --> 00:32:55.075
<c.magenta>在场景轮廓图中</c>

00:32:56.743 --> 00:33:00.914
<c.magenta>它还可以用于锁定节点</c>
<c.magenta>与修改可见性</c>

00:32:56.743 --> 00:33:00.914
<c.magenta>它还可以用于锁定节点</c>
<c.magenta>与修改可见性</c>

00:33:01.415 --> 00:33:05.752
<c.magenta>它同时附带一个上下文菜单</c>
<c.magenta>来进行选项特定的操作</c>

00:33:06.153 --> 00:33:07.187
<c.magenta>很好用</c>

00:33:08.622 --> 00:33:11.859
<c.magenta>最后同样重要的</c>
<c.magenta>状态机快速查看</c>

00:33:13.427 --> 00:33:16.630
<c.magenta>回忆一下 我们去年</c>
<c.magenta>引入了GKStateMachine</c>

00:33:16.697 --> 00:33:21.168
<c.magenta>它允许你在游戏中</c>
<c.magenta>表示一种执行流</c>

00:33:21.401 --> 00:33:23.537
<c.magenta>它在游戏中有许多应用</c>

00:33:23.604 --> 00:33:27.841
<c.magenta>比如AI、动画、UI、</c>
<c.magenta>等级序列等等</c>

00:33:29.510 --> 00:33:32.980
<c.magenta>直到现在</c>
<c.magenta>你都不能预览</c>

00:33:33.046 --> 00:33:35.082
<c.magenta>这些状态机的样子</c>

00:33:36.316 --> 00:33:39.553
<c.magenta>很难理解这些状态之间的关联</c>

00:33:39.620 --> 00:33:43.757
<c.magenta>执行流 或是其当前所在的状态</c>

00:33:44.324 --> 00:33:48.428
<c.magenta>为了解决这个问题</c>
<c.magenta>我们整合了一个状态机预览工具</c>

00:33:49.263 --> 00:33:52.299
<c.magenta>直接在Xcode Debugger</c>
<c.magenta>的快速查看功能中</c>

00:33:53.800 --> 00:33:55.802
<c.magenta>这允许你在代码中设置断点</c>

00:33:56.103 --> 00:34:01.942
<c.magenta>在你想查看状态机的地方</c>
<c.magenta>并点击快速查看图标</c>

00:33:56.103 --> 00:34:01.942
<c.magenta>在你想查看状态机的地方</c>
<c.magenta>并点击快速查看图标</c>

00:34:02.109 --> 00:34:06.313
<c.magenta>就会弹出一个当前状态机</c>
<c.magenta>的视觉展示</c>

00:34:06.847 --> 00:34:08.982
<c.magenta>它会展示状态</c>
<c.magenta>以及其间关联</c>

00:34:09.049 --> 00:34:11.083
<c.magenta>当前的状态被高亮</c>

00:34:13.387 --> 00:34:17.958
<c.magenta>这里有几个关于快速查看</c>
<c.magenta>状态机的例子</c>

00:34:21.594 --> 00:34:26.733
<c.magenta>通过这些 我想演示</c>
<c.magenta>GameplayKit中 基于编辑器的工作流</c>

00:34:35.108 --> 00:34:40.080
<c.magenta>这里我要搭建一个简单的游戏</c>

00:34:40.147 --> 00:34:45.752
<c.magenta>其中一个玩家捡起气球</c>
<c.magenta>将其涂色并扔到敌人那里</c>

00:34:45.819 --> 00:34:51.358
<c.magenta>这是由游戏AI模拟的</c>
<c.magenta>敌人也可以做同样的事</c>

00:34:51.425 --> 00:34:54.127
<c.magenta>所以我们有一个基本的场景</c>

00:34:54.194 --> 00:34:56.196
<c.magenta>你可以在场景轮廓视图中看到</c>

00:34:56.463 --> 00:35:00.534
<c.magenta>我们有一个背景和一个玩家</c>
<c.magenta>和一些气球</c>

00:34:56.463 --> 00:35:00.534
<c.magenta>我们有一个背景和一个玩家</c>
<c.magenta>和一些气球</c>

00:35:02.903 --> 00:35:07.407
<c.magenta>所以首先 我们要尝试添加</c>
<c.magenta>这很简单 没有进行什么行为</c>

00:35:08.141 --> 00:35:09.443
<c.magenta>这是一个很静态的场景</c>

00:35:09.510 --> 00:35:13.747
<c.magenta>我们通过使用键盘向玩家</c>
<c.magenta>添加一些行为作为开始</c>

00:35:14.281 --> 00:35:16.950
<c.magenta>对于这一点 我已经添加了一些组件</c>

00:35:17.050 --> 00:35:20.621
<c.magenta>我们要看看刚才提到的</c>
<c.magenta>行动组件</c>

00:35:20.687 --> 00:35:24.758
<c.magenta>有几个属性来帮助行动</c>
<c.magenta>比如速度</c>

00:35:25.392 --> 00:35:26.960
<c.magenta>摩擦 加速等等</c>

00:35:27.160 --> 00:35:30.764
<c.magenta>你使用GKInspectable</c>
<c.magenta>对其注解</c>

00:35:30.831 --> 00:35:34.168
<c.magenta>这样你就可以在以后</c>
<c.magenta>在UI中处理这些属性</c>

00:35:35.202 --> 00:35:37.738
<c.magenta>类似的 我又一个玩家输入组件</c>

00:35:38.338 --> 00:35:43.911
<c.magenta>我们要将这些赋值给玩家</c>

00:35:43.977 --> 00:35:47.781
<c.magenta>通过进入场景</c>
<c.magenta>并在组件编辑器中寻找</c>

00:35:47.848 --> 00:35:50.517
<c.magenta>在右侧检查区中</c>

00:35:50.584 --> 00:35:53.187
<c.magenta>我有一个新引入的组件编辑器</c>

00:35:53.487 --> 00:35:57.991
<c.magenta>现在 我可以选择玩家</c>
<c.magenta>并点击加按钮</c>

00:35:58.058 --> 00:36:00.494
<c.magenta>来将这些组件添加到节点</c>

00:35:58.058 --> 00:36:00.494
<c.magenta>来将这些组件添加到节点</c>

00:36:00.561 --> 00:36:04.498
<c.magenta>我们下面要添加用户输入组件</c>

00:36:04.831 --> 00:36:06.633
<c.magenta>与运动组件</c>

00:36:09.703 --> 00:36:12.973
<c.magenta>而后我们会看到结果</c>

00:36:13.040 --> 00:36:18.278
<c.magenta>我期待用户可以通过键盘移动</c>

00:36:18.345 --> 00:36:23.317
<c.magenta>太棒了 它可以在任何方向运动</c>

00:36:23.851 --> 00:36:26.453
<c.magenta>除了可以之外</c>
<c.magenta>你还能发现它不会在边界停下来</c>

00:36:26.520 --> 00:36:29.790
<c.magenta>因为我没有对玩家</c>
<c.magenta>添加任何碰撞</c>

00:36:30.324 --> 00:36:32.759
<c.magenta>但我的确添加了一个</c>
<c.magenta>碰撞组件</c>

00:36:32.826 --> 00:36:36.263
<c.magenta>它主要是给玩家节点</c>
<c.magenta>添加了物理躯体</c>

00:36:36.330 --> 00:36:41.168
<c.magenta>我下面要将其赋给玩家</c>

00:36:41.768 --> 00:36:45.072
<c.magenta>在完成这一点的同时</c>
<c.magenta>我还要赋一个战斗组件</c>

00:36:45.138 --> 00:36:49.109
<c.magenta>我已经添加过了</c>
<c.magenta>能允许你捡起气球并扔出</c>

00:36:49.710 --> 00:36:53.747
<c.magenta>让我们看看它的样子</c>

00:36:57.217 --> 00:37:00.354
<c.magenta>太好了 现在我可以捡起气球</c>
<c.magenta>而且它在边界处停止了</c>

00:36:57.217 --> 00:37:00.354
<c.magenta>太好了 现在我可以捡起气球</c>
<c.magenta>而且它在边界处停止了</c>

00:37:00.420 --> 00:37:01.488
<c.magenta>这很棒</c>

00:37:02.589 --> 00:37:04.258
<c.magenta>我们下面要对敌人</c>
<c.magenta>进行同样的操作</c>

00:37:04.324 --> 00:37:08.996
<c.magenta>未完成这一点</c>
<c.magenta>我在场景中创建了一个敌人物体</c>

00:37:09.062 --> 00:37:11.965
<c.magenta>但我将其设为不可见了</c>

00:37:12.032 --> 00:37:15.235
<c.magenta>所以我要在场景轮廓视图中</c>
<c.magenta>设其为可见</c>

00:37:15.969 --> 00:37:19.473
<c.magenta>而后将组件赋值给敌人</c>

00:37:19.606 --> 00:37:22.743
<c.magenta>在这里 区别在于</c>
<c.magenta>它是一个敌人输入组件</c>

00:37:22.809 --> 00:37:25.712
<c.magenta>这样它就使用游戏AI</c>
<c.magenta>而不是使用键盘</c>

00:37:26.513 --> 00:37:30.984
<c.magenta>类似地 运动组件 碰撞组件</c>

00:37:31.051 --> 00:37:32.686
<c.magenta>以及战斗组件</c>

00:37:34.855 --> 00:37:39.092
<c.magenta>有了这些 我会期待敌人也会</c>

00:37:39.159 --> 00:37:44.097
<c.magenta>捡起气球并</c>

00:37:45.999 --> 00:37:47.367
<c.magenta>啊 它赢了我</c>

00:37:47.434 --> 00:37:49.636
<c.magenta>这对它太简单了</c>

00:37:49.703 --> 00:37:52.506
<c.magenta>但我们要让游戏更加有趣</c>

00:37:52.573 --> 00:37:58.278
<c.magenta>通过一个绘制的物体</c>
<c.magenta>向场景中投落一些气球</c>

00:37:58.345 --> 00:38:05.085
<c.magenta>所以我有一个绘制的物体</c>
<c.magenta>我要将其在场景中设为可见</c>

00:37:58.345 --> 00:38:05.085
<c.magenta>所以我有一个绘制的物体</c>
<c.magenta>我要将其在场景中设为可见</c>

00:38:06.553 --> 00:38:09.389
<c.magenta>而后添加绘制组件</c>

00:38:09.590 --> 00:38:16.597
<c.magenta>能沿一个确定的路径</c>
<c.magenta>投落气球</c>

00:38:16.830 --> 00:38:20.534
<c.magenta>我想要向场景中</c>
<c.magenta>添加一个导航图</c>

00:38:21.034 --> 00:38:23.437
<c.magenta>这就像进入物体库并输入</c>

00:38:23.504 --> 00:38:26.340
<c.magenta>“导航图”一样简单</c>

00:38:26.607 --> 00:38:31.111
<c.magenta>现在 你可以简单的将</c>
<c.magenta>导航图拖拽到场景中</c>

00:38:31.178 --> 00:38:37.017
<c.magenta>我们要把导航图稍稍放大</c>
<c.magenta>来解释这个新特性</c>

00:38:38.051 --> 00:38:40.120
<c.magenta>这就是导航图编辑器</c>

00:38:45.058 --> 00:38:48.262
<c.magenta>在我们操作它的同时</c>
<c.magenta>我们要修改一些属性</c>

00:38:49.329 --> 00:38:55.369
<c.magenta>我们要设置玩家的健康为2</c>
<c.magenta>还要设置运动</c>

00:38:57.070 --> 00:39:01.708
<c.magenta>稍稍加速 让玩家稍稍占优势</c>
<c.magenta>只是一个第一等级</c>

00:38:57.070 --> 00:39:01.708
<c.magenta>稍稍加速 让玩家稍稍占优势</c>
<c.magenta>只是一个第一等级</c>

00:39:02.176 --> 00:39:06.914
<c.magenta>你好歹也是有了一些优势</c>
<c.magenta>敌人的健康值也是2</c>

00:39:08.215 --> 00:39:12.853
<c.magenta>让我们看看结果</c>

00:39:16.490 --> 00:39:19.526
<c.magenta>你知道 你可以看到飞机</c>
<c.magenta>扔下的气球</c>

00:39:19.593 --> 00:39:21.662
<c.magenta>比如能捡起来扔出去的多</c>

00:39:24.031 --> 00:39:27.301
<c.magenta>他赢了我一次 我也赢了一次</c>
<c.magenta>让我们看看</c>

00:39:28.769 --> 00:39:30.137
<c.magenta>好 好了</c>

00:39:30.971 --> 00:39:34.308
<c.magenta>我确定我的儿子</c>
<c.magenta>玩这个游戏时会很高兴</c>

00:39:35.475 --> 00:39:37.578
<c.magenta>这解释了</c>

00:39:38.478 --> 00:39:41.181
<c.magenta>GameplayKit中新的</c>
<c.magenta>基于编辑器的工作流</c>

00:39:41.315 --> 00:39:42.983
<c.magenta>让我们切换回幻灯片</c>

00:39:45.953 --> 00:39:47.387
<c.magenta>来回放一下本期</c>

00:39:51.225 --> 00:39:53.493
<c.magenta>今年 我们介绍了很多引人入胜的</c>

00:39:53.727 --> 00:39:55.629
<c.magenta>有用的GameplayKit特性</c>

00:39:56.763 --> 00:40:00.567
<c.magenta>在最开始 Bruno分享了</c>
<c.magenta>新的空间划分系统</c>

00:39:56.763 --> 00:40:00.567
<c.magenta>在最开始 Bruno分享了</c>
<c.magenta>新的空间划分系统</c>

00:40:00.634 --> 00:40:02.903
<c.magenta>来在你的游戏中进行</c>
<c.magenta>高效的空间查询</c>

00:40:04.271 --> 00:40:08.909
<c.magenta>新的过程生成系统</c>
<c.magenta>使用不同的噪声函数</c>

00:40:08.976 --> 00:40:11.345
<c.magenta>来在你的游戏中创建</c>
<c.magenta>更加动态的内容</c>

00:40:11.745 --> 00:40:16.617
<c.magenta>同时对诸如寻路与代理</c>
<c.magenta>等现存系统也有提升</c>

00:40:18.285 --> 00:40:21.488
<c.magenta>Michael分享了有关</c>
<c.magenta>游戏AI的新特性</c>

00:40:21.755 --> 00:40:25.459
<c.magenta>通过游戏策略和决策树</c>

00:40:26.527 --> 00:40:30.397
<c.magenta>最后我介绍了新引入的</c>
<c.magenta>基于编辑器的工作流</c>

00:40:30.664 --> 00:40:32.799
<c.magenta>在GameplayKit中</c>
<c.magenta>带来更快遍历</c>

00:40:33.667 --> 00:40:35.335
<c.magenta>希望大家认为这些新特性很有用处</c>

00:40:35.402 --> 00:40:38.071
<c.magenta>我们已经等不及看到</c>
<c.magenta>大家下一步的成果了</c>

00:40:39.606 --> 00:40:43.410
<c.magenta>这是以后再看这段分享的URL</c>

00:40:43.577 --> 00:40:45.879
<c.magenta>608就是本场演讲的编号</c>

00:40:47.247 --> 00:40:50.384
<c.magenta>还有相关技术的其它演讲</c>

00:40:50.450 --> 00:40:51.818
<c.magenta>你可能感兴趣参加</c>

00:40:51.885 --> 00:40:55.923
<c.magenta>SpriteKit、SceneKit、</c>
<c.magenta>Rendering、Game Center的新特性</c>

00:40:55.989 --> 00:40:58.058
<c.magenta>及Apple Watch的游戏技术</c>

00:40:59.593 --> 00:41:00.427
<c.magenta>感谢大家前来</c>

00:40:59.593 --> 00:41:00.427
<c.magenta>感谢大家前来</c>

00:41:00.494 --> 00:41:02.629
<c.magenta>我们希望大家在余下的演讲中</c>
<c.magenta>度过愉快时光</c>
