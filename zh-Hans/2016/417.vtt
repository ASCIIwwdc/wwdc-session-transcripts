WEBVTT

00:00:19.353 --> 00:00:21.488
<c.magenta>调试要诀和技巧</c>

00:00:28.896 --> 00:00:32.232
<c.magenta>大家下午好</c>
<c.magenta>欢迎参加“调试要诀和技巧”演讲</c>

00:00:32.598 --> 00:00:36.570
<c.magenta>看到这么多人来参加这个主题演讲</c>
<c.magenta>我感到很欣慰</c>

00:00:36.637 --> 00:00:38.105
<c.magenta>很激动</c>

00:00:38.405 --> 00:00:39.239
<c.magenta>我叫Kate Stone</c>

00:00:39.306 --> 00:00:42.910
<c.magenta>我是Apple调试技术核心团队的组长</c>

00:00:43.644 --> 00:00:45.312
<c.magenta>非常激动</c>

00:00:45.379 --> 00:00:48.282
<c.magenta>我希望能从我们的团队中</c>
<c.magenta>请几名工程师</c>

00:00:48.348 --> 00:00:52.452
<c.magenta>讲一些新鲜事儿</c>
<c.magenta>如果你刚开始着手的话</c>

00:00:52.519 --> 00:00:54.922
<c.magenta>还有一些比较新鲜的小技巧</c>

00:00:54.988 --> 00:00:58.592
<c.magenta>即使你已经在你自己的平台上做了十年</c>
<c.magenta>的调试工作 你仍然还会觉得新鲜</c>

00:00:58.659 --> 00:01:02.262
<c.magenta>这真的是个深水区</c>
<c.magenta>我们有很多内容要讲</c>

00:00:58.659 --> 00:01:02.262
<c.magenta>这真的是个深水区</c>
<c.magenta>我们有很多内容要讲</c>

00:01:02.329 --> 00:01:03.363
<c.magenta>让我们开始吧</c>

00:01:04.932 --> 00:01:09.403
<c.magenta>特别注意</c>
<c.magenta>我们要讲的技术就是LLDB</c>

00:01:09.469 --> 00:01:11.505
<c.magenta>若你用Xcode做过调试</c>
<c.magenta>你可能没注意过</c>

00:01:11.572 --> 00:01:14.842
<c.magenta>后台有一个叫做LLDB的技术</c>

00:01:14.908 --> 00:01:17.945
<c.magenta>这是一个底层调试工具</c>
<c.magenta>支持所有核心技术</c>

00:01:18.545 --> 00:01:21.615
<c.magenta>不仅仅存在于Xcode中</c>
<c.magenta>只要你需要 它无处不在</c>

00:01:21.682 --> 00:01:24.518
<c.magenta>但是 当然了 你跟它打交道</c>
<c.magenta>最多的地方之一</c>

00:01:24.585 --> 00:01:27.120
<c.magenta>是Xcode的调试控制台</c>

00:01:27.821 --> 00:01:30.858
<c.magenta>Xcode把那个控制台作为调试区</c>
<c.magenta>的一个部分</c>

00:01:31.925 --> 00:01:35.863
<c.magenta>你将看到可视化的变量</c>
<c.magenta>同时也会看到这个LLDB控制台</c>

00:01:36.096 --> 00:01:38.632
<c.magenta>我们今天要讲的内容很多</c>

00:01:38.899 --> 00:01:42.469
<c.magenta>在那个提示框中</c>
<c.magenta>你可以获得提示和一些很棒的东西</c>

00:01:44.905 --> 00:01:46.940
<c.magenta>当然 那个区域通常不只是包含</c>

00:01:47.007 --> 00:01:50.611
<c.magenta>LLDB的提示框以及</c>
<c.magenta>与调试器交互</c>

00:01:50.677 --> 00:01:52.779
<c.magenta>还包含你应用的输出</c>

00:01:52.846 --> 00:01:56.183
<c.magenta>若是基于控制台的应用 还可以键入</c>

00:01:56.817 --> 00:01:58.685
<c.magenta>那也许不是最便捷的方式</c>

00:01:58.752 --> 00:02:01.355
<c.magenta>如果你的应用利用了控制台的其他功能</c>

00:01:58.752 --> 00:02:01.355
<c.magenta>如果你的应用利用了控制台的其他功能</c>

00:02:01.421 --> 00:02:05.993
<c.magenta>如移动指针或色彩或其他</c>
<c.magenta>ANSI指针操作功能</c>

00:02:06.326 --> 00:02:08.595
<c.magenta>那么 在Xcode 8中有个新选项</c>

00:02:08.662 --> 00:02:12.199
<c.magenta>允许你给你的应用分配独立终端</c>

00:02:12.266 --> 00:02:14.801
<c.magenta>而LLDB仍留在Xcode中</c>

00:02:14.868 --> 00:02:17.037
<c.magenta>用起来很简单 提出了选择方案</c>

00:02:17.938 --> 00:02:21.041
<c.magenta>并且在最底部的选项标签中</c>
<c.magenta>你能看到这个新控制台</c>

00:02:21.108 --> 00:02:26.079
<c.magenta>你可以从默认切换到Xcode和终端</c>

00:02:26.313 --> 00:02:28.382
<c.magenta>然后 当你运行时</c>
<c.magenta>你将得到一个独立终端</c>

00:02:28.448 --> 00:02:31.652
<c.magenta>用于处理应用的输入和输出</c>
<c.magenta>与Xcode是分离的</c>

00:02:37.558 --> 00:02:40.360
<c.magenta>接下来的演讲 我们主要讲LLDB</c>

00:02:40.427 --> 00:02:43.130
<c.magenta>若你对Xcode其它具体功能感兴趣</c>

00:02:43.497 --> 00:02:45.532
<c.magenta>请查看这两场演讲的相关信息</c>

00:02:45.599 --> 00:02:49.102
<c.magenta>当然 演讲已结束</c>
<c.magenta>但是你们可以看一下视频</c>

00:02:50.704 --> 00:02:53.440
<c.magenta>你还要注意 LLDB不只是</c>
<c.magenta>Xcode的一部分</c>

00:02:53.674 --> 00:02:57.110
<c.magenta>而Swift REPL</c>
<c.magenta>其实就是LLDB</c>

00:02:57.578 --> 00:03:00.080
<c.magenta>当你打开Swift REPL</c>
<c.magenta>并开始跟它交互时</c>

00:02:57.578 --> 00:03:00.080
<c.magenta>当你打开Swift REPL</c>
<c.magenta>并开始跟它交互时</c>

00:03:00.147 --> 00:03:02.816
<c.magenta>你就已经在调试环境中了</c>

00:03:02.883 --> 00:03:05.919
<c.magenta>因此 无论什么时候你需要调试器</c>
<c.magenta>它都在那儿</c>

00:03:05.986 --> 00:03:08.422
<c.magenta>事实上 我们今天要讲的每个命令</c>

00:03:08.488 --> 00:03:10.090
<c.magenta>你都能在REPL中直接使用</c>

00:03:10.157 --> 00:03:12.793
<c.magenta>只需要在REPL的提示框中加个</c>
<c.magenta>冒号前缀即可</c>

00:03:13.093 --> 00:03:16.930
<c.magenta>先是冒号 然后是命令 这样就能直接</c>
<c.magenta>在LLDB中发出命令了</c>

00:03:17.664 --> 00:03:19.766
<c.magenta>比如</c>
<c.magenta>我现在Swift REPL提示框</c>

00:03:20.367 --> 00:03:23.570
<c.magenta>此刻 我想查找某类型的信息</c>

00:03:23.637 --> 00:03:26.240
<c.magenta>当然 我可以打开Xcode并查看帮助</c>

00:03:26.306 --> 00:03:27.774
<c.magenta>但是在提示框中</c>

00:03:28.108 --> 00:03:31.411
<c.magenta>我可以简单地使用</c>
<c.magenta>：type lookup Comparable</c>

00:03:31.912 --> 00:03:34.414
<c.magenta>我要查找这个协议 我发现事实上</c>

00:03:34.481 --> 00:03:37.718
<c.magenta>它是从另一个协议衍生出来的</c>
<c.magenta>添加了以下四个函数</c>

00:03:38.285 --> 00:03:42.155
<c.magenta>如果你熟悉并且一直在使用类型查找</c>
<c.magenta>它是个很棒的功能</c>

00:03:42.222 --> 00:03:45.492
<c.magenta>但你可能不会注意这一点</c>
<c.magenta>尽管它的名字是类型查找</c>

00:03:45.559 --> 00:03:47.895
<c.magenta>它实际上可以用来查找更多的东西</c>

00:03:47.961 --> 00:03:50.831
<c.magenta>实际上我可以查找函数</c>
<c.magenta>得到完整的签名</c>

00:03:51.265 --> 00:03:53.667
<c.magenta>甚至可以查找整个模块</c>

00:03:53.734 --> 00:03:55.636
<c.magenta>当然了 内容会很多</c>

00:03:55.702 --> 00:03:58.872
<c.magenta>因为它是那个模块中每个类型的</c>
<c.magenta>完整说明</c>

00:03:59.072 --> 00:04:00.407
<c.magenta>在这里 我们把它简化了</c>

00:03:59.072 --> 00:04:00.407
<c.magenta>在这里 我们把它简化了</c>

00:04:02.042 --> 00:04:05.679
<c.magenta>那么 REPL可以很好地处理</c>
<c.magenta>这种附加的命令</c>

00:04:05.746 --> 00:04:11.552
<c.magenta>还可以用来与你在REPL中写的代码</c>
<c.magenta>进行交互</c>

00:04:11.818 --> 00:04:13.620
<c.magenta>假如我写一个简单的函数</c>

00:04:14.221 --> 00:04:17.391
<c.magenta>我写好了一个函数</c>
<c.magenta>当我在函数中时 我想停止</c>

00:04:17.457 --> 00:04:19.459
<c.magenta>查看某一行正在发生什么</c>

00:04:19.526 --> 00:04:21.361
<c.magenta>那么我可以发布断点命令</c>

00:04:21.695 --> 00:04:23.730
<c.magenta>加一个冒号前缀 ：b 2</c>

00:04:23.797 --> 00:04:25.432
<c.magenta>我在第二行设置了一个断点</c>

00:04:25.499 --> 00:04:28.769
<c.magenta>当我调用这个函数时 正如我所</c>
<c.magenta>期待的那样停止了</c>

00:04:29.136 --> 00:04:33.006
<c.magenta>因为执行已经停止了</c>
<c.magenta>它会立即切回LLDB提示框</c>

00:04:33.073 --> 00:04:34.541
<c.magenta>在LLDB提示框中</c>

00:04:34.608 --> 00:04:39.146
<c.magenta>我可以发布其他LLDB命令</c>
<c.magenta>进行交互并探测我的应用</c>

00:04:39.446 --> 00:04:43.150
<c.magenta>REPL还将自动进行这些操作</c>
<c.magenta>如果你遇到溢出的情况</c>

00:04:43.217 --> 00:04:45.552
<c.magenta>或一般会终止你应用的其他东西</c>

00:04:45.619 --> 00:04:47.754
<c.magenta>所以 你可以直接从Swift REPL中</c>

00:04:47.821 --> 00:04:49.289
<c.magenta>利用调试器的全部功能</c>

00:04:50.324 --> 00:04:53.694
<c.magenta>你还要注意 你可以随时在两个</c>
<c.magenta>提示框之间切换</c>

00:04:53.760 --> 00:04:55.095
<c.magenta>如果你在REPL提示框中</c>

00:04:55.262 --> 00:04:59.533
<c.magenta>只写一个冒号 然后按Enter</c>
<c.magenta>将打开LLDB提示框</c>

00:04:59.900 --> 00:05:02.636
<c.magenta>而REPL命令将切回REPL提示框</c>

00:04:59.900 --> 00:05:02.636
<c.magenta>而REPL命令将切回REPL提示框</c>

00:05:02.703 --> 00:05:05.005
<c.magenta>这样 你可以随时使用这两个提示框</c>

00:05:05.472 --> 00:05:07.174
<c.magenta>REPL有一些不同的特点</c>

00:05:07.241 --> 00:05:09.376
<c.magenta>可能更适用于调试Swift代码时</c>

00:05:09.443 --> 00:05:10.711
<c.magenta>的调试会话中</c>

00:05:12.813 --> 00:05:13.647
<c.magenta>这很棒</c>

00:05:14.014 --> 00:05:17.084
<c.magenta>这是大多数人跟LLDB互动的</c>
<c.magenta>主要方式</c>

00:05:17.150 --> 00:05:20.220
<c.magenta>但LLDB还是个独立的</c>
<c.magenta>命令行工具</c>

00:05:20.587 --> 00:05:23.590
<c.magenta>如果我要远程连接到一台机器的</c>
<c.magenta>命令窗口 很奇妙</c>

00:05:23.657 --> 00:05:25.125
<c.magenta>我的连接很慢</c>

00:05:25.192 --> 00:05:28.729
<c.magenta>我非常想利用命令行工具</c>

00:05:28.996 --> 00:05:31.131
<c.magenta>但在其它环境下也很有用</c>

00:05:31.198 --> 00:05:35.068
<c.magenta>你可能想用它来 比如说</c>
<c.magenta>如果你正在自动化调试任务</c>

00:05:35.369 --> 00:05:38.372
<c.magenta>我想把调试器设置成每次开启时</c>
<c.magenta>加载的命令都一样</c>

00:05:38.438 --> 00:05:40.741
<c.magenta>所以我可能要提供</c>

00:05:40.807 --> 00:05:44.378
<c.magenta>一个包含一大堆LLDB命令的文件</c>
<c.magenta>用于进行配置</c>

00:05:44.444 --> 00:05:48.115
<c.magenta>LLDB -- source</c>
<c.magenta>后边跟一个文件名</c>

00:05:48.182 --> 00:05:51.151
<c.magenta>这将调用LLDB并</c>
<c.magenta>source所有命令</c>

00:05:51.218 --> 00:05:53.487
<c.magenta>按照我想要的方式设置调试会话</c>

00:05:54.688 --> 00:05:57.057
<c.magenta>如果你不想陷入设置文件的麻烦中</c>

00:05:57.124 --> 00:06:00.928
<c.magenta>你可以调用LLDB</c>
<c.magenta>然后直接在命令行上写命令</c>

00:05:57.124 --> 00:06:00.928
<c.magenta>你可以调用LLDB</c>
<c.magenta>然后直接在命令行上写命令</c>

00:06:00.994 --> 00:06:04.464
<c.magenta>-one-line接着是命令</c>

00:06:04.531 --> 00:06:07.000
<c.magenta>只要我启动LLDB 就会发出命令</c>

00:06:07.267 --> 00:06:09.303
<c.magenta>如果我想附加命令</c>

00:06:09.369 --> 00:06:12.372
<c.magenta>我可以在这里重复option的</c>
<c.magenta>简化形式</c>

00:06:12.439 --> 00:06:15.609
<c.magenta>-o后边跟着另一个命令</c>
<c.magenta>可以重复无数次</c>

00:06:16.043 --> 00:06:19.146
<c.magenta>所以 在自动化脚本中</c>
<c.magenta>把LLDB设置成</c>

00:06:19.213 --> 00:06:20.480
<c.magenta>我所期待的方式非常琐碎</c>

00:06:20.914 --> 00:06:24.017
<c.magenta>当然 这也非常有价值</c>

00:06:24.251 --> 00:06:28.488
<c.magenta>如果我有一个应用</c>
<c.magenta>只有百分之一的错误率</c>

00:06:28.555 --> 00:06:31.792
<c.magenta>是一个竟用条件</c>
<c.magenta>我想一次次地运行同样的调试顺序</c>

00:06:31.859 --> 00:06:34.695
<c.magenta>我也有个特殊选项可以实现</c>

00:06:35.662 --> 00:06:38.832
<c.magenta>LLDB -- batch</c>
<c.magenta>启动批处理模式</c>

00:06:39.066 --> 00:06:43.804
<c.magenta>那将执行我提供的指令</c>
<c.magenta>从单行命令或从文件中获得</c>

00:06:44.338 --> 00:06:48.041
<c.magenta>并且假设我的应用正常运行</c>
<c.magenta>然后正常退出</c>

00:06:48.942 --> 00:06:50.511
<c.magenta>如果应用崩溃</c>

00:06:50.577 --> 00:06:53.847
<c.magenta>它会在LLDB提示框中停止</c>
<c.magenta>我可以查找问题所在</c>

00:06:54.615 --> 00:06:58.085
<c.magenta>当然 我可以用其他窗口命令</c>
<c.magenta>把它打包</c>

00:06:58.151 --> 00:07:01.088
<c.magenta>无限重复那一系列动作</c>

00:06:58.151 --> 00:07:01.088
<c.magenta>无限重复那一系列动作</c>

00:07:01.154 --> 00:07:04.925
<c.magenta>或者至少直到应用崩溃</c>
<c.magenta>并且我也准备好调查问题了</c>

00:07:07.060 --> 00:07:09.496
<c.magenta>LLDB有大量的选项</c>

00:07:09.563 --> 00:07:11.932
<c.magenta>如果你之前没有看过</c>
<c.magenta>LLDB -- help</c>

00:07:11.999 --> 00:07:15.235
<c.magenta>我建议你看一看 帮助文档中描述了</c>
<c.magenta>这些选项以及更多的内容</c>

00:07:17.604 --> 00:07:21.675
<c.magenta>我要在这里介绍一个非常有趣的概念</c>

00:07:22.209 --> 00:07:25.345
<c.magenta>这可能是整场演讲中</c>
<c.magenta>最无关紧要的事了</c>

00:07:25.412 --> 00:07:28.382
<c.magenta>那么 如果你打算忘记某张幻灯片</c>
<c.magenta>请从这张开始</c>

00:07:29.550 --> 00:07:32.886
<c.magenta>因为它大部分是透明的</c>
<c.magenta>你可能没注意到效果</c>

00:07:32.953 --> 00:07:35.856
<c.magenta>我还想要介绍一些微妙的地方</c>

00:07:36.089 --> 00:07:37.491
<c.magenta>从Xcode 8开始</c>

00:07:37.558 --> 00:07:40.928
<c.magenta>LLDB已经从Xcode的程序中</c>
<c.magenta>完全分离</c>

00:07:41.094 --> 00:07:42.462
<c.magenta>它对你完全透明</c>

00:07:42.529 --> 00:07:44.531
<c.magenta>你按照你一般的调试方式开始调试</c>

00:07:45.065 --> 00:07:49.403
<c.magenta>支持多个不同的调试器版本</c>

00:07:50.237 --> 00:07:51.905
<c.magenta>它会自动为你选择</c>

00:07:51.972 --> 00:07:55.409
<c.magenta>因此 如果我要调试Swift 3</c>
<c.magenta>我会得到最新的调试器</c>

00:07:55.475 --> 00:07:58.312
<c.magenta>有我们在这场演讲中介绍的所有功能</c>

00:07:58.378 --> 00:08:02.883
<c.magenta>其实若我使用纯C++或</c>
<c.magenta>Objective C 也是一样的</c>

00:07:58.378 --> 00:08:02.883
<c.magenta>其实若我使用纯C++或</c>
<c.magenta>Objective C 也是一样的</c>

00:08:02.950 --> 00:08:06.186
<c.magenta>我会得到最新的调试器</c>
<c.magenta>拥有我们在这里讲的所有功能</c>

00:08:07.187 --> 00:08:09.590
<c.magenta>另一方面</c>
<c.magenta>如果我调试Swift 2.3</c>

00:08:09.656 --> 00:08:11.258
<c.magenta>我将得到一个调试器</c>

00:08:11.325 --> 00:08:16.263
<c.magenta>其实是跟我们今年早些时候发布</c>
<c.magenta>Xcode 7.3.1时一起发布的</c>

00:08:16.730 --> 00:08:18.765
<c.magenta>意思是 有些新命令不可用</c>

00:08:18.832 --> 00:08:23.237
<c.magenta>但我们支持自Swift编译器</c>
<c.magenta>时代的全部调试器</c>

00:08:25.873 --> 00:08:27.307
<c.magenta>但最重要的是</c>

00:08:27.374 --> 00:08:29.176
<c.magenta>如果你是我们开源社区中的一员</c>

00:08:29.576 --> 00:08:32.379
<c.magenta>你可以使用调试器进行调试</c>

00:08:32.446 --> 00:08:35.349
<c.magenta>该调试器与</c>
<c.magenta>你正使用的开源Swift匹配</c>

00:08:35.414 --> 00:08:37.985
<c.magenta>因此 如果你下载正在开发中的快照</c>

00:08:38.051 --> 00:08:40.453
<c.magenta>或如果你开始添加代码</c>

00:08:40.520 --> 00:08:42.756
<c.magenta>那么调试器会立即可用</c>

00:08:42.823 --> 00:08:44.458
<c.magenta>你可以使用那个</c>

00:08:44.525 --> 00:08:48.662
<c.magenta>同时调试在Swift 3或</c>
<c.magenta>Swift 2.3中写的程序</c>

00:08:48.729 --> 00:08:50.697
<c.magenta>一切都是完全透明的</c>

00:08:52.065 --> 00:08:54.168
<c.magenta>有一个额外的好处：</c>

00:08:54.234 --> 00:08:57.905
<c.magenta>如果LLDB陷入了一个</c>
<c.magenta>不能继续的情况</c>

00:08:57.971 --> 00:09:00.040
<c.magenta>它需要关闭调试会话</c>

00:08:57.971 --> 00:09:00.040
<c.magenta>它需要关闭调试会话</c>

00:09:00.240 --> 00:09:01.742
<c.magenta>调试会话将会被终止</c>

00:09:01.808 --> 00:09:05.078
<c.magenta>LLDB可以优雅地退出</c>
<c.magenta>而Xcode将继续运行</c>

00:09:09.082 --> 00:09:13.153
<c.magenta>说起如何利用LLDB这个强大的工具</c>

00:09:13.620 --> 00:09:17.191
<c.magenta>以及如何自定义你的体验</c>
<c.magenta>我要邀请我们的一位工程师上台</c>

00:09:17.257 --> 00:09:18.392
<c.magenta>Enrico Granata</c>

00:09:24.498 --> 00:09:26.400
<c.magenta>谢谢Kate 大家好</c>

00:09:27.267 --> 00:09:32.139
<c.magenta>对于LLDB</c>
<c.magenta>我最看好的是调试器的定制性</c>

00:09:32.573 --> 00:09:36.577
<c.magenta>开启调试器定制技术</c>
<c.magenta>不仅能收获很大的乐趣</c>

00:09:36.643 --> 00:09:39.847
<c.magenta>还能让你在调试应用的过程中</c>

00:09:39.913 --> 00:09:41.582
<c.magenta>获得令人惊叹的效率</c>

00:09:41.648 --> 00:09:46.353
<c.magenta>LLDB提供许多切入点</c>
<c.magenta>你可以进行自定义</c>

00:09:46.820 --> 00:09:48.755
<c.magenta>你可以从命令别名开始</c>

00:09:48.822 --> 00:09:53.160
<c.magenta>然后以你的方式定制命令</c>
<c.magenta>或定制数据格式化程序</c>

00:09:53.227 --> 00:09:56.964
<c.magenta>在Xcode 8中</c>
<c.magenta>我们有一个新的扩展点</c>

00:09:57.097 --> 00:09:58.498
<c.magenta>阶梯效应</c>

00:09:59.700 --> 00:10:04.371
<c.magenta>考虑阶梯效应的方式是你想</c>
<c.magenta>让下一行命令做什么？</c>

00:09:59.700 --> 00:10:04.371
<c.magenta>考虑阶梯效应的方式是你想</c>
<c.magenta>让下一行命令做什么？</c>

00:10:04.438 --> 00:10:06.240
<c.magenta>你想让阶梯命令做什么？</c>

00:10:06.306 --> 00:10:09.276
<c.magenta>但你是否发现你自己想要</c>
<c.magenta>以一种或两种方式随处</c>

00:10:09.343 --> 00:10:11.578
<c.magenta>调整它的行为？</c>

00:10:11.912 --> 00:10:14.581
<c.magenta>通过阶梯效应 你全部可以实现</c>

00:10:15.682 --> 00:10:21.054
<c.magenta>但使LLDB...自定义LLDB</c>
<c.magenta>满足你需求的最简单方式</c>

00:10:21.121 --> 00:10:22.589
<c.magenta>是创建一个命令别名</c>

00:10:22.923 --> 00:10:25.592
<c.magenta>这种方式需要取一段你频繁使用的</c>

00:10:25.659 --> 00:10:27.761
<c.magenta>调试器语句</c>

00:10:27.828 --> 00:10:30.531
<c.magenta>并给它附上一段短语句</c>

00:10:31.064 --> 00:10:36.537
<c.magenta>现在 在Xcode 8中</c>
<c.magenta>你还可以附上帮助文本</c>

00:10:36.603 --> 00:10:38.972
<c.magenta>这样可以达到你自己的或跟你一起分享</c>

00:10:39.039 --> 00:10:41.842
<c.magenta>那些别名的人目的</c>

00:10:41.909 --> 00:10:44.144
<c.magenta>可以帮你记住别名是干什么用的</c>

00:10:44.678 --> 00:10:45.712
<c.magenta>让我们来看个例子</c>

00:10:46.780 --> 00:10:50.384
<c.magenta>首先 要创建别名</c>
<c.magenta>从command alias命令起</c>

00:10:50.851 --> 00:10:54.154
<c.magenta>然后 正如我刚说过的</c>
<c.magenta>你可以附上帮助文本</c>

00:10:54.421 --> 00:10:57.491
<c.magenta>你提供给我们一段短语句</c>

00:10:57.791 --> 00:11:00.661
<c.magenta>然后给我们一个你想要替换的</c>
<c.magenta>完整的调试器命令</c>

00:10:57.791 --> 00:11:00.661
<c.magenta>然后给我们一个你想要替换的</c>
<c.magenta>完整的调试器命令</c>

00:11:01.261 --> 00:11:05.065
<c.magenta>shell现在就是个正常的调试器命令</c>

00:11:05.132 --> 00:11:07.334
<c.magenta>跟我们内建的其他命令一样</c>

00:11:07.534 --> 00:11:09.503
<c.magenta>你可以 比如 help shell</c>

00:11:09.770 --> 00:11:13.607
<c.magenta>它会显示那些你定义的帮助文本</c>

00:11:14.408 --> 00:11:19.012
<c.magenta>在这些情况下 调试变得有些粗糙</c>

00:11:19.079 --> 00:11:22.649
<c.magenta>你可能在查找漏洞时忘记你自己是谁</c>

00:11:22.716 --> 00:11:25.352
<c.magenta>你可以要求调试器提醒你的身份</c>

00:11:25.686 --> 00:11:28.655
<c.magenta>它会像这样通知你 我是Enrico</c>

00:11:29.423 --> 00:11:33.060
<c.magenta>这很棒 但如果你想做一些</c>
<c.magenta>更高级的事儿</c>

00:11:33.126 --> 00:11:35.495
<c.magenta>而不仅仅是给现有命令</c>
<c.magenta>附上一个新名称</c>

00:11:35.829 --> 00:11:38.265
<c.magenta>我们还公布了一Python API</c>

00:11:38.532 --> 00:11:40.501
<c.magenta>这是一个有相当广泛选项的模型</c>

00:11:40.567 --> 00:11:43.003
<c.magenta>可以让你按照你的意愿绑定调试器</c>

00:11:43.871 --> 00:11:46.340
<c.magenta>相当容易上手</c>

00:11:46.673 --> 00:11:50.177
<c.magenta>我们在之前的WWDC演讲中</c>
<c.magenta>曾详细阐述过这个工具</c>

00:11:50.244 --> 00:11:51.678
<c.magenta>你可以看一下在线视频</c>

00:11:52.212 --> 00:11:55.682
<c.magenta>我们有个网站 里面有文档和示例</c>

00:11:56.016 --> 00:11:59.353
<c.magenta>你可以在线搜索一下</c>

00:11:59.553 --> 00:12:01.555
<c.magenta>有一个社区在LLDB脚本处理方面</c>

00:11:59.553 --> 00:12:01.555
<c.magenta>有一个社区在LLDB脚本处理方面</c>

00:12:01.622 --> 00:12:02.990
<c.magenta>做得很棒</c>

00:12:03.891 --> 00:12:05.392
<c.magenta>让我们快速地看一个例子</c>

00:12:05.959 --> 00:12:10.464
<c.magenta>假如 我想要一个命令</c>
<c.magenta>可以让我检索</c>

00:12:10.531 --> 00:12:13.800
<c.magenta>调试时退出的最后一个函数的返回值</c>

00:12:14.601 --> 00:12:15.736
<c.magenta>这里有一些注意事项</c>

00:12:16.336 --> 00:12:20.607
<c.magenta>这个命令只有在你执行完函数</c>
<c.magenta>并且之后不再执行任何</c>

00:12:20.674 --> 00:12:23.877
<c.magenta>阶梯效应后</c>
<c.magenta>才起作用</c>

00:12:24.111 --> 00:12:26.680
<c.magenta>你可以键入表达式</c>
<c.magenta>你可以查看变量</c>

00:12:26.747 --> 00:12:28.482
<c.magenta>只要不单步跳过就没问题</c>

00:12:28.916 --> 00:12:30.651
<c.magenta>让我们快速看一个例子</c>

00:12:30.984 --> 00:12:34.788
<c.magenta>你导入一个包含那个命令的文件</c>

00:12:35.255 --> 00:12:37.991
<c.magenta>然后 正如我所说的</c>
<c.magenta>执行完函数</c>

00:12:38.058 --> 00:12:40.527
<c.magenta>就能看到返回值</c>

00:12:40.627 --> 00:12:41.728
<c.magenta>好的 很棒</c>

00:12:41.795 --> 00:12:44.598
<c.magenta>这是默认的 不需要自定义</c>

00:12:44.765 --> 00:12:48.202
<c.magenta>但是 比如说 如果我键入回溯</c>

00:12:48.468 --> 00:12:51.271
<c.magenta>这是个冗余的回溯</c>

00:12:51.338 --> 00:12:53.807
<c.magenta>现在 我不记得返回值在哪儿了</c>

00:12:54.007 --> 00:12:56.710
<c.magenta>好的 我会进入终端</c>
<c.magenta>尝试把它挖掘出来</c>

00:12:56.977 --> 00:12:58.645
<c.magenta>但是很幸运</c>

00:12:58.979 --> 00:13:01.582
<c.magenta>我们实际上可以写一个命令</c>
<c.magenta>告诉我们答案</c>

00:12:58.979 --> 00:13:01.582
<c.magenta>我们实际上可以写一个命令</c>
<c.magenta>告诉我们答案</c>

00:13:01.915 --> 00:13:04.985
<c.magenta>从而再次得到返回值</c>

00:13:07.087 --> 00:13:09.623
<c.magenta>这就是再次得到返回值要做的</c>
<c.magenta>所有工作</c>

00:13:09.857 --> 00:13:12.826
<c.magenta>另外 不要再担心读取那个值了</c>

00:13:12.893 --> 00:13:15.162
<c.magenta>它会一直在那儿</c>

00:13:16.196 --> 00:13:19.766
<c.magenta>另一方面 你看到那是个文本</c>

00:13:19.833 --> 00:13:23.370
<c.magenta>现在你可以键入你的别名shell</c>
<c.magenta>键入文本</c>

00:13:23.670 --> 00:13:25.606
<c.magenta>你会发现你自己键入这些内容</c>

00:13:25.672 --> 00:13:27.808
<c.magenta>是因为每次你开始调试时</c>
<c.magenta>它们都很棒</c>

00:13:27.875 --> 00:13:29.810
<c.magenta>你会一次一次再一次地键入它们</c>

00:13:29.877 --> 00:13:34.281
<c.magenta>直到你变成一只会打字的猴子</c>
<c.magenta>你要做的就是键入这些内容</c>

00:13:34.848 --> 00:13:36.884
<c.magenta>不 我要说不</c>

00:13:37.150 --> 00:13:40.554
<c.magenta>我要说不要再让你自己重复键入了</c>

00:13:40.921 --> 00:13:41.989
<c.magenta>完全没必要</c>

00:13:42.055 --> 00:13:44.157
<c.magenta>LLDB有一个初始化文件</c>

00:13:44.558 --> 00:13:48.529
<c.magenta>叫做.llbdinit</c>
<c.magenta>就在你的主文件夹中</c>

00:13:49.463 --> 00:13:53.033
<c.magenta>如果你需要LLDB做一些特别的事</c>
<c.magenta>一些不同的事</c>

00:13:53.100 --> 00:13:56.503
<c.magenta>在Xcode下启动或终端下启动时</c>

00:13:57.671 --> 00:14:00.340
<c.magenta>有一个.llbdinit -Xcode文件</c>

00:13:57.671 --> 00:14:00.340
<c.magenta>有一个.llbdinit -Xcode文件</c>

00:14:00.541 --> 00:14:04.511
<c.magenta>当在Xcode下的调试器中启动时</c>
<c.magenta>很好用</c>

00:14:05.279 --> 00:14:06.380
<c.magenta>还有一个诀窍</c>

00:14:06.680 --> 00:14:09.750
<c.magenta>如果你需要在调试器启动时</c>
<c.magenta>带有Python命令</c>

00:14:10.050 --> 00:14:12.853
<c.magenta>请不要把它们键入</c>
<c.magenta>.llbdinit中</c>

00:14:13.120 --> 00:14:17.191
<c.magenta>而是要把它们放在一个.py文件中</c>
<c.magenta>然后source该.py文件</c>

00:14:17.524 --> 00:14:20.494
<c.magenta>在.llbdinit中导入命令脚本</c>

00:14:23.530 --> 00:14:26.967
<c.magenta>如果你们用过LLDB</c>

00:14:27.467 --> 00:14:30.604
<c.magenta>你很可能非常熟悉p和po命令</c>

00:14:31.305 --> 00:14:32.906
<c.magenta>这些是很不错的命令</c>

00:14:33.207 --> 00:14:37.611
<c.magenta>可以查找数据</c>
<c.magenta>因为它们是完全表达式</c>

00:14:38.078 --> 00:14:41.815
<c.magenta>它们有你编写应用所使用的语言的</c>
<c.magenta>全部功能</c>

00:14:41.882 --> 00:14:44.051
<c.magenta>你可以在调试器控制台上使用</c>

00:14:44.918 --> 00:14:48.288
<c.magenta>另外 强大的功能伴随着</c>
<c.magenta>重大的责任</c>

00:14:49.156 --> 00:14:52.593
<c.magenta>这些命令在你的目标进程中</c>
<c.magenta>运行代码</c>

00:14:52.726 --> 00:14:55.429
<c.magenta>它们可能会导致一些副作用</c>

00:14:55.729 --> 00:14:58.866
<c.magenta>有时候 几乎不可能</c>

00:14:58.932 --> 00:15:01.768
<c.magenta>在你当前停止的点上运行代码</c>

00:14:58.932 --> 00:15:01.768
<c.magenta>在你当前停止的点上运行代码</c>

00:15:02.769 --> 00:15:07.508
<c.magenta>如果p运行了一次代码</c>
<c.magenta>那么po实际上将运行两次代码</c>

00:15:07.875 --> 00:15:11.245
<c.magenta>因为它不仅会评估你提供的表达式</c>

00:15:11.311 --> 00:15:14.481
<c.magenta>还会评估代码</c>

00:15:14.548 --> 00:15:17.384
<c.magenta>以便以一种作者可定制的方式</c>

00:15:17.451 --> 00:15:19.920
<c.magenta>打印你的自定义类型</c>

00:15:20.954 --> 00:15:25.359
<c.magenta>这种方式很棒 如果作者给他们的类型</c>
<c.magenta>完全按照你想要的方式</c>

00:15:25.425 --> 00:15:27.194
<c.magenta>定制了显示</c>

00:15:27.661 --> 00:15:28.996
<c.magenta>如果你没那么幸运</c>

00:15:29.263 --> 00:15:32.099
<c.magenta>p命令提供另一种变量视角</c>

00:15:32.165 --> 00:15:33.767
<c.magenta>可能更接近你想要的</c>

00:15:34.468 --> 00:15:38.105
<c.magenta>同时po是一个运行两次的命令</c>

00:15:38.172 --> 00:15:41.608
<c.magenta>在编码你的目标进程时也很可能</c>
<c.magenta>会产生副作用</c>

00:15:42.643 --> 00:15:43.777
<c.magenta>如果你担心这个问题</c>

00:15:44.311 --> 00:15:48.148
<c.magenta>我们有另一个查看变量的</c>
<c.magenta>命令frame variable</c>

00:15:48.549 --> 00:15:52.352
<c.magenta>这是个可预见的命令</c>
<c.magenta>它不会运行任何代码</c>

00:15:52.953 --> 00:15:53.921
<c.magenta>另一方面</c>

00:15:53.987 --> 00:15:56.423
<c.magenta>因为它没有运行代码的能力</c>

00:15:56.690 --> 00:15:59.860
<c.magenta>它提供的语句也极其有限</c>

00:16:01.562 --> 00:16:04.031
<c.magenta>现在有很多方法可以查看数据</c>

00:16:04.431 --> 00:16:08.969
<c.magenta>但是剧透一下 在Xcode 8中</c>
<c.magenta>我们有更多方式来实现</c>

00:16:10.771 --> 00:16:14.141
<c.magenta>有两种新方式</c>
<c.magenta>分别是parray和poarray</c>

00:16:14.875 --> 00:16:17.644
<c.magenta>是的 你说对了 听起来像p和po</c>

00:16:17.878 --> 00:16:20.347
<c.magenta>但它们可以专门处理数组</c>

00:16:21.415 --> 00:16:23.417
<c.magenta>它们如何专门处理数组？</c>

00:16:23.984 --> 00:16:24.818
<c.magenta>嗯</c>

00:16:26.019 --> 00:16:31.058
<c.magenta>如果你在Objective C</c>
<c.magenta>或Swift数组中用过NS数组</c>

00:16:31.124 --> 00:16:35.762
<c.magenta>你习惯于安全容器</c>
<c.magenta>该容器知道包含了多少东西</c>

00:16:36.296 --> 00:16:38.065
<c.magenta>C指针并不能了解这个信息</c>

00:16:38.265 --> 00:16:40.901
<c.magenta>C指针并不包含某种电量模块</c>

00:16:41.068 --> 00:16:43.403
<c.magenta>它们不知道要指向多少元素</c>

00:16:43.637 --> 00:16:48.709
<c.magenta>那么 当我们像在这个调试器中</c>
<c.magenta>打印C指针时</c>

00:16:49.042 --> 00:16:51.612
<c.magenta>我们所能了解的只是指针的值</c>

00:16:52.479 --> 00:16:54.581
<c.magenta>但现在我们知道它指向一群元素</c>

00:16:54.648 --> 00:16:56.717
<c.magenta>所以我们可以开始打印第一个</c>

00:16:57.117 --> 00:16:58.285
<c.magenta>打印第二个</c>

00:16:58.886 --> 00:17:01.889
<c.magenta>继续依次打印 现在我们又变成</c>
<c.magenta>那只打字的小猴子了</c>

00:16:58.886 --> 00:17:01.889
<c.magenta>继续依次打印 现在我们又变成</c>
<c.magenta>那只打字的小猴子了</c>

00:17:01.955 --> 00:17:03.290
<c.magenta>我们并不想这样</c>

00:17:04.858 --> 00:17:05.692
<c.magenta>嗯</c>

00:17:06.859 --> 00:17:11.265
<c.magenta>在Xcode 8中 你可以这样处理</c>
<c.magenta>parray 元素个数 指针</c>

00:17:11.665 --> 00:17:13.800
<c.magenta>这会扩展指针</c>

00:17:13.867 --> 00:17:17.171
<c.magenta>就像指定元素个数的一个数组一样</c>

00:17:18.872 --> 00:17:20.641
<c.magenta>谢谢 谢谢</c>

00:17:22.409 --> 00:17:26.914
<c.magenta>这个方案已经很好了 但我为什么</c>
<c.magenta>要猜测元素个数呢？</c>

00:17:27.481 --> 00:17:30.150
<c.magenta>它就在那儿 个数就在那儿</c>

00:17:30.217 --> 00:17:35.422
<c.magenta>我真正想要的是能键入parray</c>
<c.magenta>个数 数据集</c>

00:17:36.456 --> 00:17:37.791
<c.magenta>几乎就要实现了</c>

00:17:38.192 --> 00:17:40.894
<c.magenta>我要做的就是把count</c>
<c.magenta>放在倒引号中</c>

00:17:41.428 --> 00:17:45.365
<c.magenta>那个倒引号是个常用的</c>
<c.magenta>LLDB语法功能</c>

00:17:45.432 --> 00:17:48.168
<c.magenta>可以让你取出表达式</c>
<c.magenta>并进行评估</c>

00:17:48.235 --> 00:17:52.005
<c.magenta>然后在执行命令之前 在命令中</c>
<c.magenta>替换那个表达式的值</c>

00:17:52.739 --> 00:17:55.509
<c.magenta>现在 我已经显示出了完整的数组</c>

00:17:57.678 --> 00:17:58.512
<c.magenta>谢谢大家</c>

00:18:02.149 --> 00:18:04.384
<c.magenta>而po也一样</c>

00:18:04.451 --> 00:18:06.453
<c.magenta>poarray 元素个数</c>

00:18:07.387 --> 00:18:10.891
<c.magenta>指针 然后我得到了po式的对象描述</c>

00:18:11.859 --> 00:18:13.961
<c.magenta>在po的话题上</c>

00:18:14.261 --> 00:18:17.965
<c.magenta>我确定你们可以</c>
<c.magenta>写Objective C代码</c>

00:18:18.031 --> 00:18:19.233
<c.magenta>我确定有不少人</c>

00:18:19.299 --> 00:18:23.704
<c.magenta>就是那样实现的</c>
<c.magenta>很可能没有认真思考过</c>

00:18:24.271 --> 00:18:25.906
<c.magenta>你取出po 键入po</c>

00:18:25.973 --> 00:18:29.176
<c.magenta>接着是一个数字</c>
<c.magenta>恰巧你知道是个指针值</c>

00:18:29.243 --> 00:18:31.111
<c.magenta>然后你取回一个非常漂亮的描述</c>

00:18:31.745 --> 00:18:35.916
<c.magenta>你在Swift中尝试做同样的事</c>
<c.magenta>你取回的只是个数字</c>

00:18:36.183 --> 00:18:37.784
<c.magenta>为什么？怎么回事？</c>

00:18:38.685 --> 00:18:42.122
<c.magenta>嗯 我确定你不止一次</c>
<c.magenta>听过这样的事</c>

00:18:42.189 --> 00:18:43.824
<c.magenta>但我再说一次</c>

00:18:44.091 --> 00:18:46.994
<c.magenta>Swift是一种比</c>
<c.magenta>Objective C类型更安全的语言</c>

00:18:47.194 --> 00:18:50.130
<c.magenta>我们不能假设数字是任意对象</c>

00:18:50.197 --> 00:18:53.634
<c.magenta>因为并不是所有的Swift对象</c>
<c.magenta>都关联着一个指针值</c>

00:18:53.967 --> 00:18:57.471
<c.magenta>那么当我们po一个数字时</c>
<c.magenta>我们会得到数字</c>

00:18:58.405 --> 00:19:01.408
<c.magenta>好的 这很棒 但拜托</c>
<c.magenta>我知道那儿有个对象</c>

00:18:58.405 --> 00:19:01.408
<c.magenta>好的 这很棒 但拜托</c>
<c.magenta>我知道那儿有个对象</c>

00:19:01.475 --> 00:19:02.876
<c.magenta>刚刚已经显示出来了</c>

00:19:03.677 --> 00:19:04.978
<c.magenta>有一种方式可以实现</c>

00:19:06.613 --> 00:19:07.447
<c.magenta>就是这个</c>

00:19:08.081 --> 00:19:10.651
<c.magenta>看起来有很多词 我知道</c>

00:19:10.717 --> 00:19:13.020
<c.magenta>但它实际上...听我讲</c>

00:19:13.353 --> 00:19:16.757
<c.magenta>expr -O的意思是po</c>

00:19:17.291 --> 00:19:20.260
<c.magenta>如果你在LLDB控制台中</c>
<c.magenta>键入help po</c>

00:19:20.460 --> 00:19:24.498
<c.magenta>它将告诉你那是expr -O的</c>
<c.magenta>一个别名</c>

00:19:25.065 --> 00:19:27.201
<c.magenta>那么我们实际上在这里键入的是</c>

00:19:27.534 --> 00:19:30.904
<c.magenta>po这个东西 就像我们在</c>
<c.magenta>Objective C代码中做的那样</c>

00:19:31.438 --> 00:19:35.075
<c.magenta>这样 我们实际上会得到</c>
<c.magenta>我们想要的描述</c>

00:19:36.577 --> 00:19:37.644
<c.magenta>这很棒</c>

00:19:38.312 --> 00:19:42.349
<c.magenta>在一个实际检验内存地址</c>
<c.magenta>相关的主题上</c>

00:19:42.416 --> 00:19:43.984
<c.magenta>并尝试搞清楚它们的</c>

00:19:45.285 --> 00:19:46.653
<c.magenta>底层调试</c>

00:19:47.487 --> 00:19:51.458
<c.magenta>关于底层调试</c>
<c.magenta>如果你只记得一件事</c>

00:19:51.725 --> 00:19:54.394
<c.magenta>那就是离它越远越好</c>

00:19:54.628 --> 00:19:55.762
<c.magenta>不要碰底层调试</c>

00:19:59.399 --> 00:20:03.170
<c.magenta>很不幸的是 有时候你必须得碰</c>

00:19:59.399 --> 00:20:03.170
<c.magenta>很不幸的是 有时候你必须得碰</c>

00:20:03.904 --> 00:20:07.307
<c.magenta>也许你要调试只存在于</c>
<c.magenta>你应用发布版本中</c>

00:20:07.374 --> 00:20:08.842
<c.magenta>优化代码的东西</c>

00:20:08.909 --> 00:20:10.377
<c.magenta>我有时候会遇到这种情况</c>

00:20:11.245 --> 00:20:15.716
<c.magenta>或者你要调试第三方代码</c>
<c.magenta>而你没有任何调试信息</c>

00:20:16.583 --> 00:20:18.118
<c.magenta>如果出现以上任意一种情况</c>

00:20:18.719 --> 00:20:22.990
<c.magenta>那么请听我讲 在这段旅程中</c>
<c.magenta>我们将穿越赫丘利斯之柱</c>

00:20:24.091 --> 00:20:29.129
<c.magenta>但请注意 在这段旅程中</c>
<c.magenta>如要前行 风险自担</c>

00:20:31.598 --> 00:20:33.500
<c.magenta>就像这样开始</c>

00:20:34.101 --> 00:20:37.004
<c.magenta>去年 有一位先生来到我的实验室</c>

00:20:37.070 --> 00:20:40.307
<c.magenta>拿着他的笔记本电脑</c>
<c.magenta>让我看那种状态下的Xcode</c>

00:20:40.374 --> 00:20:43.210
<c.magenta>在Objc msgSend中崩溃了</c>

00:20:43.844 --> 00:20:45.112
<c.magenta>他给我讲了一个故事</c>

00:20:45.512 --> 00:20:48.916
<c.magenta>我在商店中有个应用</c>
<c.magenta>很棒</c>

00:20:49.249 --> 00:20:50.918
<c.magenta>然后 我的框架供应商对我说</c>

00:20:50.984 --> 00:20:54.588
<c.magenta>“嘿 我的框架有新版本了</c>
<c.magenta>更新一下吧 没问题的 ”</c>

00:20:54.955 --> 00:20:58.158
<c.magenta>我就更新了 我听了他的话</c>
<c.magenta>然后现在 我的应用一启动就崩溃</c>

00:20:58.225 --> 00:20:59.793
<c.magenta>我该怎么做 请帮帮我</c>

00:21:00.394 --> 00:21:04.831
<c.magenta>然后 我们坐下来 我告诉他说</c>
<c.magenta>“嗯 我们几乎都不了解情况</c>

00:21:04.898 --> 00:21:09.837
<c.magenta>但有一件事我们可以做...</c>
<c.magenta>就是开始读取机器寄存器”</c>

00:21:10.604 --> 00:21:12.806
<c.magenta>LLDB有一个功能可以实现</c>
<c.magenta>读取寄存器</c>

00:21:12.873 --> 00:21:17.010
<c.magenta>它允许你查看所有寄存器</c>
<c.magenta>其中只有一小部分寄存器</c>

00:21:17.077 --> 00:21:19.313
<c.magenta>甚至会允许你进行</c>
<c.magenta>自定义格式化</c>

00:21:19.947 --> 00:21:21.048
<c.magenta>它是什么样的呢？</c>

00:21:21.815 --> 00:21:23.016
<c.magenta>键入register read</c>

00:21:24.218 --> 00:21:25.853
<c.magenta>你将得到你的寄存器的值</c>

00:21:26.753 --> 00:21:27.988
<c.magenta>这里有很多寄存器</c>

00:21:28.055 --> 00:21:32.426
<c.magenta>那么 我为什么要关心屏幕上所有</c>
<c.magenta>这些怪异的数字和文字呢？</c>

00:21:32.626 --> 00:21:34.061
<c.magenta>嗯 你一定要关心</c>

00:21:35.095 --> 00:21:38.265
<c.magenta>因为参数通常是在寄存器中</c>
<c.magenta>进行传递的</c>

00:21:38.832 --> 00:21:41.268
<c.magenta>好的 很好玩儿</c>
<c.magenta>但寄存器也太多了</c>

00:21:41.335 --> 00:21:43.637
<c.magenta>我如何了解实际上哪个</c>
<c.magenta>比较重要呢？</c>

00:21:44.204 --> 00:21:49.610
<c.magenta>这个问题要问你平台应用的</c>
<c.magenta>二进制ABI接口</c>

00:21:49.676 --> 00:21:51.812
<c.magenta>：convention</c>
<c.magenta>会提供一些规则</c>

00:21:52.479 --> 00:21:54.815
<c.magenta>但LLDB还提供</c>

00:21:54.882 --> 00:21:59.553
<c.magenta>便捷的伪寄存器的命名</c>
<c.magenta>像$arg1 $arg2等等</c>

00:21:59.620 --> 00:22:04.057
<c.magenta>适用于参数为简单计数器的情况</c>

00:21:59.620 --> 00:22:04.057
<c.magenta>适用于参数为简单计数器的情况</c>

00:22:04.124 --> 00:22:05.492
<c.magenta>或指针类型</c>

00:22:05.559 --> 00:22:09.363
<c.magenta>实际上寄存器和参数是一一对应的</c>

00:22:10.030 --> 00:22:13.700
<c.magenta>在C阵营表达式中也有类似的便捷方式</c>

00:22:14.368 --> 00:22:15.502
<c.magenta>比如说</c>

00:22:16.537 --> 00:22:20.207
<c.magenta>如果我有个函数读取这三个参数</c>
<c.magenta>然后我调用函数</c>

00:22:20.874 --> 00:22:26.313
<c.magenta>这些参数实际上将一对一映射为</c>
<c.magenta>$arg1 $arg2和$arg3</c>

00:22:27.648 --> 00:22:30.217
<c.magenta>好的 这符合我们的情况</c>

00:22:30.284 --> 00:22:33.987
<c.magenta>在Objc msgSend中</c>
<c.magenta>我们开始读取参数</c>

00:22:34.521 --> 00:22:37.491
<c.magenta>第一个参数是</c>
<c.magenta>指针 0 X 4 D 2</c>

00:22:37.724 --> 00:22:40.894
<c.magenta>第二个参数是选择器符字符</c>
<c.magenta>紧接着一个附加字符</c>

00:22:41.361 --> 00:22:44.531
<c.magenta>我们恰巧知道Objc</c>
<c.magenta>msgSends的第一个参数</c>

00:22:44.598 --> 00:22:46.667
<c.magenta>是我们尝试与对象</c>
<c.magenta>进行通讯的参数</c>

00:22:46.733 --> 00:22:49.436
<c.magenta>第二个参数是我们尝试</c>
<c.magenta>要发送的选择符</c>

00:22:50.204 --> 00:22:52.506
<c.magenta>且我们还可使用</c>
<c.magenta>memory read命令</c>

00:22:52.573 --> 00:22:55.375
<c.magenta>来查看我们要通讯的那个对象</c>
<c.magenta>到底怎么了</c>

00:22:55.809 --> 00:22:57.711
<c.magenta>原来那是个不好的对象</c>

00:23:01.582 --> 00:23:02.616
<c.magenta>实际情况是</c>

00:23:02.683 --> 00:23:05.552
<c.magenta>我们在一个坏的对象上调用</c>
<c.magenta>这个选择符</c>

00:23:06.053 --> 00:23:07.387
<c.magenta>我们是如何变成这样的呢？</c>

00:23:09.189 --> 00:23:12.626
<c.magenta>嗯 在Objc msgSend中</c>
<c.magenta>崩溃了</c>

00:23:12.960 --> 00:23:16.964
<c.magenta>有东西调用了Objc msgSend</c>
<c.magenta>有东西调用了那个调用Objc msgSend的东西</c>

00:23:17.030 --> 00:23:18.332
<c.magenta>以此类推</c>

00:23:18.398 --> 00:23:21.768
<c.magenta>直到我们到达应用的切入点</c>

00:23:22.603 --> 00:23:27.307
<c.magenta>在LLDB中 我们从最小的</c>
<c.magenta>框架0开始调用</c>

00:23:27.574 --> 00:23:30.511
<c.magenta>一直到最大的框架N</c>

00:23:30.978 --> 00:23:32.813
<c.magenta>并且 如果你想移动到某个框架</c>

00:23:33.113 --> 00:23:34.648
<c.magenta>你可以使用up命令</c>

00:23:34.715 --> 00:23:37.417
<c.magenta>返回到堆栈上的一个编号较大的框架</c>

00:23:37.484 --> 00:23:40.554
<c.magenta>down命令可以返回到</c>
<c.magenta>编号较小的框架</c>

00:23:42.656 --> 00:23:46.126
<c.magenta>另一个需要了解的是</c>
<c.magenta>disassemble命令</c>

00:23:46.193 --> 00:23:48.862
<c.magenta>可以让你反汇编一个函数</c>

00:23:49.363 --> 00:23:52.399
<c.magenta>你可以用在当前函数、任意框架、</c>

00:23:52.633 --> 00:23:54.902
<c.magenta>地址、函数名称上</c>

00:23:55.102 --> 00:23:57.437
<c.magenta>你可以自定义反汇编的显示方式</c>

00:23:57.738 --> 00:24:00.207
<c.magenta>在某些情况下 它会在有源代码</c>

00:23:57.738 --> 00:24:00.207
<c.magenta>在某些情况下 它会在有源代码</c>

00:24:00.407 --> 00:24:02.476
<c.magenta>和调试信息的地方执行调试</c>

00:24:02.543 --> 00:24:05.879
<c.magenta>但如果你想比较这些指令</c>
<c.magenta>和机器指令</c>

00:24:05.946 --> 00:24:11.518
<c.magenta>你还可以让LLDB总是随着</c>
<c.magenta>源代码一起显示反汇编</c>

00:24:12.052 --> 00:24:13.153
<c.magenta>那么在我们的例子中</c>

00:24:14.855 --> 00:24:17.925
<c.magenta>我们在那儿崩溃了 我们可以</c>
<c.magenta>看到谁调用了函数</c>

00:24:17.991 --> 00:24:19.793
<c.magenta>是一个启动完成的应用</c>

00:24:20.027 --> 00:24:23.764
<c.magenta>让我们快速看一眼那个函数</c>
<c.magenta>正在做什么</c>

00:24:26.667 --> 00:24:29.069
<c.magenta>那个函数正在调用这个</c>
<c.magenta>初始化程序</c>

00:24:29.136 --> 00:24:33.240
<c.magenta>框架供应商告诉我们 “是的</c>
<c.magenta>编码那个初始化程序getGlobalToken”</c>

00:24:33.607 --> 00:24:35.375
<c.magenta>它正在来回来去地填充东西</c>

00:24:35.442 --> 00:24:39.179
<c.magenta>然后调用Objc msgSend</c>
<c.magenta>我们就崩溃了</c>

00:24:40.514 --> 00:24:44.952
<c.magenta>那么我们可以单步跳过机器编码</c>
<c.magenta>并查看这些调用实际上是在做什么</c>

00:24:45.219 --> 00:24:48.755
<c.magenta>首先 我们单步跳过</c>
<c.magenta>getGlobalToken调用</c>

00:24:49.189 --> 00:24:52.125
<c.magenta>然后我要做个弊</c>

00:24:52.392 --> 00:24:56.029
<c.magenta>我恰巧知道寄存器叫做rax</c>

00:24:56.296 --> 00:24:58.398
<c.magenta>包含那个函数的返回值</c>

00:24:58.665 --> 00:24:59.900
<c.magenta>若我读取这个函数返回值</c>

00:25:01.568 --> 00:25:03.470
<c.magenta>我只能得到不正确的指针值</c>

00:25:03.937 --> 00:25:05.138
<c.magenta>有意思</c>

00:25:05.472 --> 00:25:07.708
<c.magenta>让我们再做几次单步跳过</c>

00:25:08.208 --> 00:25:10.677
<c.magenta>不 并没有修改它 并没有修改它</c>

00:25:11.211 --> 00:25:14.815
<c.magenta>我们正在做的是取出那个指针值</c>
<c.magenta>不做任何修改</c>

00:25:14.882 --> 00:25:16.783
<c.magenta>并把它移动到rdi中</c>

00:25:17.150 --> 00:25:19.720
<c.magenta>然后调用Objc msgSend</c>

00:25:20.153 --> 00:25:21.722
<c.magenta>我在想是否关联？</c>

00:25:22.289 --> 00:25:25.626
<c.magenta>如果我在这时候</c>
<c.magenta>在进入Objc msgSend之前</c>

00:25:25.826 --> 00:25:28.662
<c.magenta>reg read $arg1</c>

00:25:30.264 --> 00:25:32.366
<c.magenta>rdi是不正确的指针值</c>

00:25:33.600 --> 00:25:35.369
<c.magenta>我们证明了什么呢？</c>

00:25:35.435 --> 00:25:38.705
<c.magenta>我们证明了</c>
<c.magenta>getGlobalToken函数</c>

00:25:38.772 --> 00:25:41.575
<c.magenta>就是我们的框架供应商非常激动地</c>
<c.magenta>让我们调用的函数</c>

00:25:41.642 --> 00:25:43.844
<c.magenta>实际上给我们返回了一个</c>
<c.magenta>不正确的对象</c>

00:25:44.044 --> 00:25:47.080
<c.magenta>一尝试给那个不正确的对象</c>
<c.magenta>发送消息</c>

00:25:47.414 --> 00:25:50.584
<c.magenta>就会收到一个大惊喜</c>
<c.magenta>我们的应用就会崩溃</c>

00:25:51.318 --> 00:25:53.754
<c.magenta>最后验证了我们的情况后</c>

00:25:53.820 --> 00:25:55.822
<c.magenta>轻轻拍了拍我们的背</c>

00:25:56.156 --> 00:25:58.258
<c.magenta>接着有请</c>
<c.magenta>Sean Callanan上台</c>

00:25:58.325 --> 00:26:01.595
<c.magenta>他会讲解表达式解析器</c>
<c.magenta>相关的新特性 谢谢</c>

00:25:58.325 --> 00:26:01.595
<c.magenta>他会讲解表达式解析器</c>
<c.magenta>相关的新特性 谢谢</c>

00:26:07.734 --> 00:26:08.836
<c.magenta>不觉得神奇吗？</c>

00:26:09.203 --> 00:26:10.237
<c.magenta>感觉像魔术一样</c>

00:26:10.304 --> 00:26:13.740
<c.magenta>你的程序只是把数据以数字、数字数组</c>

00:26:14.041 --> 00:26:15.475
<c.magenta>的方式进行存储</c>

00:26:16.109 --> 00:26:19.012
<c.magenta>但你可以用LLDB这个强大的工具</c>

00:26:19.446 --> 00:26:22.983
<c.magenta>以你想要的方式来表现数据</c>

00:26:25.219 --> 00:26:26.286
<c.magenta>有时候</c>

00:26:26.720 --> 00:26:30.624
<c.magenta>并不是只看数字和判断是什么数据</c>

00:26:31.225 --> 00:26:32.860
<c.magenta>那么容易</c>

00:26:33.861 --> 00:26:36.330
<c.magenta>有时候你需要使用表达式解析器</c>

00:26:37.164 --> 00:26:38.632
<c.magenta>Enrico已经展示了</c>

00:26:38.699 --> 00:26:42.269
<c.magenta>表达式解析器在一般情况下的</c>
<c.magenta>命令语句</c>

00:26:42.636 --> 00:26:44.404
<c.magenta>但是它还有好多功能</c>

00:26:45.572 --> 00:26:50.878
<c.magenta>表达式解析器的工作是跟你的程序</c>
<c.magenta>和SDK一起运行</c>

00:26:51.745 --> 00:26:54.882
<c.magenta>在你当前的断点上</c>

00:26:55.582 --> 00:27:00.120
<c.magenta>表达式解析器通过变形数据</c>
<c.magenta>来得到你想要</c>

00:26:55.582 --> 00:27:00.120
<c.magenta>表达式解析器通过变形数据</c>
<c.magenta>来得到你想要</c>

00:27:01.054 --> 00:27:04.057
<c.magenta>实际检测的数据</c>

00:27:05.559 --> 00:27:10.831
<c.magenta>我说过</c>
<c.magenta>程序和SDK是一起运行的</c>

00:27:11.732 --> 00:27:15.636
<c.magenta>回忆一下前几年的情况</c>
<c.magenta>SDK在LLDB中运行</c>

00:27:15.702 --> 00:27:17.571
<c.magenta>并不总是那么容易</c>

00:27:18.939 --> 00:27:22.109
<c.magenta>那么比如说 如果你在</c>
<c.magenta>Objective C程序上断点了</c>

00:27:22.576 --> 00:27:25.812
<c.magenta>你尝试获取程序的撤销管理器</c>

00:27:27.247 --> 00:27:31.919
<c.magenta>你很可能会得到至少一次</c>
<c.magenta>或两次烦人的报错</c>

00:27:33.020 --> 00:27:37.024
<c.magenta>这跟你正在尝试做的完全无关</c>

00:27:37.858 --> 00:27:39.193
<c.magenta>真是莫名其妙</c>

00:27:39.726 --> 00:27:42.429
<c.magenta>但是去年我们就讲了一个</c>
<c.magenta>解决方式</c>

00:27:44.364 --> 00:27:48.368
<c.magenta>如果你手动导入AppKit</c>

00:27:49.736 --> 00:27:52.606
<c.magenta>那么你的表达式就能起作用了</c>

00:27:53.273 --> 00:27:56.677
<c.magenta>好吧 但是我们为什么要这么做呢？</c>
<c.magenta>它已经在那儿了</c>

00:27:58.445 --> 00:27:59.479
<c.magenta>我都能听见你在哀嚎</c>

00:28:02.516 --> 00:28:03.750
<c.magenta>并非只有你一个人遇到这种情况</c>

00:28:05.052 --> 00:28:09.323
<c.magenta>因此今年我们考虑如何使这个</c>
<c.magenta>方式变得更好</c>

00:28:10.290 --> 00:28:11.558
<c.magenta>效果非常明显</c>

00:28:12.259 --> 00:28:15.462
<c.magenta>我们查看了当前源文件导入的</c>
<c.magenta>那个模块</c>

00:28:16.129 --> 00:28:18.332
<c.magenta>然后就自动导入</c>

00:28:18.532 --> 00:28:20.868
<c.magenta>不再需要手动导入了</c>

00:28:26.807 --> 00:28:27.641
<c.magenta>很酷</c>

00:28:27.708 --> 00:28:30.544
<c.magenta>我们可以更有效地摆脱</c>
<c.magenta>手动实现方式</c>

00:28:30.878 --> 00:28:34.348
<c.magenta>非常棒 但我们认为这是一个</c>
<c.magenta>很强大的工具</c>

00:28:34.815 --> 00:28:39.353
<c.magenta>让我来讲一下这个工具的一些</c>
<c.magenta>不错的功能</c>

00:28:40.687 --> 00:28:44.424
<c.magenta>现在 有时候 这种便捷可能会</c>
<c.magenta>阻碍你的开发</c>

00:28:44.491 --> 00:28:48.328
<c.magenta>你实际上想手动地导入</c>
<c.magenta>你想要的东西</c>

00:28:49.263 --> 00:28:50.464
<c.magenta>有个功能可以实现</c>

00:28:50.764 --> 00:28:55.102
<c.magenta>有一个设置</c>
<c.magenta>你可以禁用自动导入功能</c>

00:28:55.169 --> 00:28:58.071
<c.magenta>然后你就能使用去年的老功能了</c>

00:28:58.972 --> 00:29:01.608
<c.magenta>我们认为你一定会喜欢上这个功能</c>
<c.magenta>它的默认状态为开启</c>

00:28:58.972 --> 00:29:01.608
<c.magenta>我们认为你一定会喜欢上这个功能</c>
<c.magenta>它的默认状态为开启</c>

00:29:02.709 --> 00:29:03.544
<c.magenta>很好</c>

00:29:03.877 --> 00:29:07.881
<c.magenta>现在 让我们谈谈</c>
<c.magenta>如何通过重用代码</c>

00:29:08.448 --> 00:29:10.017
<c.magenta>有效地使用表达式解析器</c>

00:29:11.985 --> 00:29:16.790
<c.magenta>重用代码最简单的情况是</c>
<c.magenta>重用变量</c>

00:29:17.758 --> 00:29:22.162
<c.magenta>请记住 我说过</c>
<c.magenta>你可能需要做多级表达式</c>

00:29:22.596 --> 00:29:26.433
<c.magenta>从你当前位置获得你实际</c>
<c.magenta>想要的数据</c>

00:29:27.701 --> 00:29:32.706
<c.magenta>在Swift中 你可以执行像定义</c>
<c.magenta>和使用</c>

00:29:33.006 --> 00:29:33.841
<c.magenta>临时变量那么简单的操作</c>

00:29:35.175 --> 00:29:37.978
<c.magenta>这就能解决问题 就像你在你自己的</c>
<c.magenta>程序中键入一样</c>

00:29:39.313 --> 00:29:43.684
<c.magenta>现在 可能会超出你想象的是如果</c>
<c.magenta>你再次使用它 会发生什么</c>

00:29:44.818 --> 00:29:47.221
<c.magenta>那么我们会问</c>
<c.magenta>变量名称是什么？</c>

00:29:49.122 --> 00:29:52.526
<c.magenta>嗯 实际上我们刻意</c>
<c.magenta>让它这样工作</c>

00:29:53.060 --> 00:29:56.230
<c.magenta>原因是你可能会单步跳过</c>

00:29:56.296 --> 00:29:58.365
<c.magenta>你可能会在不同的地方设置断点</c>

00:29:58.432 --> 00:30:02.603
<c.magenta>也许稍后 你会位于一个程序</c>
<c.magenta>定义A的地方</c>

00:29:58.432 --> 00:30:02.603
<c.magenta>也许稍后 你会位于一个程序</c>
<c.magenta>定义A的地方</c>

00:30:02.836 --> 00:30:06.273
<c.magenta>我们希望作为临时变量的A</c>
<c.magenta>给你带来阻碍吗？</c>

00:30:07.174 --> 00:30:10.777
<c.magenta>很可能不希望</c>
<c.magenta>但有一个解决方法</c>

00:30:14.047 --> 00:30:16.517
<c.magenta>我们可以设置一个功能可见性</c>

00:30:16.917 --> 00:30:20.087
<c.magenta>确保你的变量不会像那样消失</c>

00:30:20.153 --> 00:30:22.222
<c.magenta>实际上我们会设置一个</c>
<c.magenta>本地环境</c>

00:30:22.289 --> 00:30:25.626
<c.magenta>就像你在程序中添加了</c>
<c.magenta>一对大括号</c>

00:30:25.959 --> 00:30:28.195
<c.magenta>把let A放在大括号中</c>
<c.magenta>然后是打印</c>

00:30:29.329 --> 00:30:31.365
<c.magenta>但是如果你想让A起作用</c>

00:30:31.798 --> 00:30:34.401
<c.magenta>你要做的就是给它一个专用名称</c>

00:30:34.868 --> 00:30:36.336
<c.magenta>一个名称外加$符号</c>

00:30:37.171 --> 00:30:40.941
<c.magenta>意思是 它将永远不会跟你自己的</c>
<c.magenta>程序名称冲突</c>

00:30:41.875 --> 00:30:45.846
<c.magenta>这意味着只要你的调试会话存在</c>
<c.magenta>它就会存在</c>

00:30:47.080 --> 00:30:47.915
<c.magenta>了不起</c>

00:30:48.448 --> 00:30:51.251
<c.magenta>你还可以用这个工具做什么？</c>
<c.magenta>可以做很多</c>

00:30:52.719 --> 00:30:55.956
<c.magenta>在Swift中</c>
<c.magenta>自LLDB和Swift发布的第一天起</c>

00:30:56.023 --> 00:30:58.559
<c.magenta>你就可以用函数来解决</c>
<c.magenta>同样的问题</c>

00:30:59.626 --> 00:31:01.328
<c.magenta>现在 当你解决问题时</c>

00:30:59.626 --> 00:31:01.328
<c.magenta>现在 当你解决问题时</c>

00:31:01.395 --> 00:31:05.132
<c.magenta>你很可能想要使用</c>
<c.magenta>多行表达式模式</c>

00:31:05.199 --> 00:31:08.101
<c.magenta>事实上 如果你键入表达式命令</c>
<c.magenta>并按下Enter键</c>

00:31:08.168 --> 00:31:10.504
<c.magenta>你会立即打开一个多行编辑器</c>

00:31:10.571 --> 00:31:12.873
<c.magenta>你可以键入你自己的函数</c>

00:31:13.640 --> 00:31:15.108
<c.magenta>如果你定义你的函数</c>

00:31:15.843 --> 00:31:20.514
<c.magenta>你就可以简便地重用这个函数</c>
<c.magenta>请不要忘了$符号</c>

00:31:22.015 --> 00:31:25.853
<c.magenta>若你们曾在Swift中尝试过</c>
<c.magenta>这样做并且说过“太棒了！”</c>

00:31:26.286 --> 00:31:28.155
<c.magenta>你可能在Objective C中</c>
<c.magenta>也尝试过了</c>

00:31:29.690 --> 00:31:32.492
<c.magenta>效果并没那么好</c>

00:31:34.061 --> 00:31:36.296
<c.magenta>这里不允许函数定义</c>

00:31:36.630 --> 00:31:38.999
<c.magenta>“不是吧 LLDB那东西</c>
<c.magenta>总是会妨碍我 ”</c>

00:31:39.399 --> 00:31:43.837
<c.magenta>好吧 嗯 看起来我们</c>
<c.magenta>也喜欢这个功能</c>

00:31:43.904 --> 00:31:45.739
<c.magenta>我们认为这功能很不错</c>
<c.magenta>我们想让它变得更好</c>

00:31:46.807 --> 00:31:50.110
<c.magenta>但我们不能让它变得那么神奇</c>

00:31:50.377 --> 00:31:54.248
<c.magenta>因为 你记得吧</c>
<c.magenta>我们在你的代码中停止了</c>

00:31:54.615 --> 00:31:57.751
<c.magenta>我们想表现得像在你的函数内一样</c>

00:31:58.652 --> 00:32:01.588
<c.magenta>如果你在Swift中</c>
<c.magenta>你可以定义余下的函数</c>

00:31:58.652 --> 00:32:01.588
<c.magenta>如果你在Swift中</c>
<c.magenta>你可以定义余下的函数</c>

00:32:01.655 --> 00:32:03.690
<c.magenta>没什么大不了的</c>
<c.magenta>编译器会喜欢的</c>

00:32:03.757 --> 00:32:06.493
<c.magenta>它不喜欢$符号</c>
<c.magenta>你可以去掉它</c>

00:32:06.560 --> 00:32:08.262
<c.magenta>但余下的就没什么问题了</c>

00:32:08.996 --> 00:32:10.097
<c.magenta>这完全合法</c>

00:32:11.665 --> 00:32:14.234
<c.magenta>但是在C、C++</c>
<c.magenta>和Objective C中</c>

00:32:14.301 --> 00:32:16.970
<c.magenta>尝试像那样处理余下的函数</c>

00:32:17.137 --> 00:32:19.706
<c.magenta>没有用 编译器会对你咆哮的</c>

00:32:22.276 --> 00:32:28.715
<c.magenta>嗯 避免方式是使用</c>
<c.magenta>顶层表达式模式</c>

00:32:29.383 --> 00:32:31.752
<c.magenta>是expression命令的</c>
<c.magenta>一个扩展</c>

00:32:31.818 --> 00:32:32.986
<c.magenta>可以使它完全脱离</c>

00:32:33.053 --> 00:32:36.056
<c.magenta>你停止的那个当前函数</c>

00:32:36.123 --> 00:32:38.058
<c.magenta>并定义全局代码</c>

00:32:38.559 --> 00:32:41.328
<c.magenta>可以是函数或变量或其他你想要的</c>

00:32:42.129 --> 00:32:45.499
<c.magenta>现在 你可以定义函数</c>
<c.magenta>并按照你期待的方式使用函数</c>

00:32:46.733 --> 00:32:47.568
<c.magenta>好的</c>

00:32:48.502 --> 00:32:52.139
<c.magenta>现在 函数不是你可以定义的</c>
<c.magenta>唯一能重用的东西</c>

00:32:52.206 --> 00:32:55.442
<c.magenta>我已经讲过变量了</c>
<c.magenta>你还可以定义闭包</c>

00:32:55.509 --> 00:32:58.111
<c.magenta>闭包是变量和代码的一种合并</c>

00:32:59.146 --> 00:33:00.881
<c.magenta>在Swift中 你可定义一个闭包</c>

00:32:59.146 --> 00:33:00.881
<c.magenta>在Swift中 你可定义一个闭包</c>

00:33:00.948 --> 00:33:01.782
<c.magenta>并使用它</c>

00:33:02.916 --> 00:33:04.585
<c.magenta>今年 Xcode有了新特性</c>

00:33:05.219 --> 00:33:07.154
<c.magenta>你可在Objective C中</c>
<c.magenta>实现同样的功能</c>

00:33:07.554 --> 00:33:09.957
<c.magenta>你可以定义和重用块</c>

00:33:11.124 --> 00:33:14.394
<c.magenta>如果你是C++的铁杆粉丝</c>

00:33:14.461 --> 00:33:16.730
<c.magenta>你可以用匿名函数实现</c>
<c.magenta>完全一样的功能</c>

00:33:18.599 --> 00:33:19.433
<c.magenta>现在</c>

00:33:20.501 --> 00:33:23.170
<c.magenta>你可以用这些块做什么呢？</c>
<c.magenta>它们有什么特殊作用呢？</c>

00:33:23.370 --> 00:33:25.939
<c.magenta>嗯 比如说</c>
<c.magenta>你可以把它们传给函数</c>

00:33:26.773 --> 00:33:30.611
<c.magenta>有时候你可能需要在指定队列上</c>
<c.magenta>手动运行某些东西</c>

00:33:31.845 --> 00:33:32.679
<c.magenta>那样是可以的</c>

00:33:33.013 --> 00:33:35.449
<c.magenta>你可以把素材发送给</c>
<c.magenta>比如说 一个全局队列</c>

00:33:35.749 --> 00:33:37.217
<c.magenta>块就会运行</c>

00:33:38.585 --> 00:33:39.419
<c.magenta>现在</c>

00:33:40.420 --> 00:33:43.123
<c.magenta>有时候有点儿烦人</c>

00:33:43.457 --> 00:33:49.496
<c.magenta>因为这些复杂的表达式会增加</c>
<c.magenta>错别字的出现频率</c>

00:33:50.564 --> 00:33:52.132
<c.magenta>现在 不同的是</c>

00:33:52.733 --> 00:33:55.469
<c.magenta>速度很快 不用回头看之前的代码</c>

00:33:55.536 --> 00:33:58.672
<c.magenta>在这个表达式和之前代码中的表达式？</c>

00:33:59.439 --> 00:34:00.607
<c.magenta>你很可能会错过它</c>

00:33:59.439 --> 00:34:00.607
<c.magenta>你很可能会错过它</c>

00:34:00.707 --> 00:34:02.276
<c.magenta>但编译器一定不会错过它</c>

00:34:02.943 --> 00:34:06.246
<c.magenta>如果丢了分号</c>
<c.magenta>编译器会对你咆哮</c>

00:34:07.814 --> 00:34:09.216
<c.magenta>但还有个更好的方式</c>

00:34:09.583 --> 00:34:13.152
<c.magenta>如果你在源编辑器中键入</c>
<c.magenta>我们会告诉你</c>

00:34:13.453 --> 00:34:16.556
<c.magenta>“这里很可能丢失了一个分号</c>
<c.magenta>你想加上它吗？”</c>

00:34:18.192 --> 00:34:21.728
<c.magenta>嗯 看起来LLDB可以实现</c>
<c.magenta>同样的功能</c>

00:34:21.995 --> 00:34:23.496
<c.magenta>并且我们可以做得更好</c>

00:34:23.563 --> 00:34:26.967
<c.magenta>只需要自动添加遗失的分号</c>

00:34:27.266 --> 00:34:28.534
<c.magenta>然后就能运行表达式了</c>

00:34:28.902 --> 00:34:30.571
<c.magenta>我们管这个叫做修订</c>

00:34:30.871 --> 00:34:34.808
<c.magenta>以前是在Clang中使用</c>
<c.magenta>现在LLDB也可以实现同样的功能了</c>

00:34:36.777 --> 00:34:38.512
<c.magenta>Swift中也有修订</c>

00:34:39.646 --> 00:34:42.815
<c.magenta>在Swift中 你不太可能会遇到</c>
<c.magenta>分号问题</c>

00:34:43.083 --> 00:34:45.418
<c.magenta>但是同志们 那些感叹号很烦人</c>

00:34:49.056 --> 00:34:53.860
<c.magenta>是的 嗯 它们很有用 因为它们</c>
<c.magenta>在你自己的代码中</c>

00:34:53.927 --> 00:34:56.096
<c.magenta>当你调试时 帮助你理解它</c>

00:34:56.163 --> 00:34:58.131
<c.magenta>你只是希望它们不要阻碍你</c>

00:34:58.599 --> 00:35:00.234
<c.magenta>相信我 我们也是这么想的</c>

00:34:58.599 --> 00:35:00.234
<c.magenta>相信我 我们也是这么想的</c>

00:35:01.668 --> 00:35:04.872
<c.magenta>如果你尝试使用一些没有</c>
<c.magenta>解包的东西</c>

00:35:06.039 --> 00:35:08.075
<c.magenta>我们就会应用修订并为你解包</c>

00:35:09.209 --> 00:35:12.045
<c.magenta>现在 可能会有一两个人</c>

00:35:12.112 --> 00:35:14.548
<c.magenta>说“我不希望调试器碰我的代码 ”</c>

00:35:15.048 --> 00:35:15.883
<c.magenta>现在</c>

00:35:18.285 --> 00:35:20.988
<c.magenta>对于这些人 我也有过这样的顾虑</c>

00:35:21.688 --> 00:35:23.524
<c.magenta>我们有设置</c>

00:35:23.824 --> 00:35:26.960
<c.magenta>可以关闭整个自动应用修订功能</c>

00:35:27.628 --> 00:35:31.198
<c.magenta>如果你不喜欢调试器</c>
<c.magenta>自鸣得意地指出</c>

00:35:31.265 --> 00:35:34.001
<c.magenta>你代码中的每一个小错误</c>
<c.magenta>并为你修改好</c>

00:35:34.101 --> 00:35:36.303
<c.magenta>那么你也可以关闭那部分功能</c>

00:35:37.871 --> 00:35:38.705
<c.magenta>好的</c>

00:35:39.573 --> 00:35:40.407
<c.magenta>谢谢</c>

00:35:44.745 --> 00:35:45.579
<c.magenta>好了</c>

00:35:45.846 --> 00:35:48.182
<c.magenta>很好 这是个不错的便捷功能</c>

00:35:48.248 --> 00:35:51.985
<c.magenta>但是我还要提另一个</c>

00:35:52.052 --> 00:35:53.854
<c.magenta>你能定义为可重用的东西</c>

00:35:55.155 --> 00:35:56.857
<c.magenta>你可以在Swift中定义你自己的类型</c>

00:35:57.925 --> 00:36:00.761
<c.magenta>比如说</c>
<c.magenta>你可以输入多行表达式</c>

00:35:57.925 --> 00:36:00.761
<c.magenta>比如说</c>
<c.magenta>你可以输入多行表达式</c>

00:36:00.827 --> 00:36:02.196
<c.magenta>定义一个类</c>

00:36:03.130 --> 00:36:05.933
<c.magenta>当你尝试实例化那个类时</c>

00:36:05.999 --> 00:36:08.435
<c.magenta>它就是这样</c>

00:36:08.502 --> 00:36:11.004
<c.magenta>就像你已经在程序中</c>
<c.magenta>定义过的类一样</c>

00:36:12.239 --> 00:36:17.411
<c.magenta>在C++中也一样 你可以定义</c>
<c.magenta>一个类并重用它</c>

00:36:19.513 --> 00:36:22.716
<c.magenta>现在让我们来看个例子</c>

00:36:22.783 --> 00:36:25.786
<c.magenta>我们可以在你自己的程序中</c>
<c.magenta>使用所有这些概念</c>

00:36:28.422 --> 00:36:32.693
<c.magenta>通常尤其是当你的程序</c>
<c.magenta>与web API交互时</c>

00:36:32.759 --> 00:36:35.229
<c.magenta>你会得到返回的许多数据</c>
<c.magenta>你想要筛选数据</c>

00:36:35.295 --> 00:36:36.797
<c.magenta>尤其是当你正在调试时</c>

00:36:37.698 --> 00:36:41.401
<c.magenta>筛选数据的方式</c>
<c.magenta>尤其是在NS数组中</c>

00:36:41.602 --> 00:36:43.203
<c.magenta>是通过定义一个判断实现的</c>

00:36:44.438 --> 00:36:48.342
<c.magenta>现在 在表达式分析器中</c>
<c.magenta>你可以定义自定义判断</c>

00:36:49.076 --> 00:36:52.346
<c.magenta>在这种情况下 我们写一个块</c>

00:36:52.646 --> 00:36:56.383
<c.magenta>从web服务器取出结果字符串</c>

00:36:56.917 --> 00:37:01.054
<c.magenta>进行筛选 查找有文本错误的字符串</c>

00:36:56.917 --> 00:37:01.054
<c.magenta>进行筛选 查找有文本错误的字符串</c>

00:37:01.755 --> 00:37:03.190
<c.magenta>很可能有利于调试</c>

00:37:04.258 --> 00:37:09.530
<c.magenta>现在 如果你只从web服务器</c>
<c.magenta>取出完整数据的数组</c>

00:37:10.464 --> 00:37:12.432
<c.magenta>然后就应用判断</c>

00:37:12.599 --> 00:37:15.869
<c.magenta>你可以立即获得</c>
<c.magenta>你实际关心的消息</c>

00:37:18.338 --> 00:37:23.076
<c.magenta>现在你已经了解表达式分析器</c>
<c.magenta>是如何强大了</c>

00:37:23.143 --> 00:37:24.978
<c.magenta>接着有请</c>
<c.magenta>Jim Ingham上台</c>

00:37:25.045 --> 00:37:27.147
<c.magenta>他会给你们讲LLDB更强大的特性</c>

00:37:32.319 --> 00:37:33.153
<c.magenta>谢谢 Sean</c>

00:37:33.353 --> 00:37:36.657
<c.magenta>目前我们已经按先后顺序</c>

00:37:36.723 --> 00:37:40.160
<c.magenta>讲了如何当你停止后</c>

00:37:40.227 --> 00:37:42.529
<c.magenta>查看程序状态 但我们还没讲</c>

00:37:42.596 --> 00:37:44.865
<c.magenta>如何得到这样一个有趣的点</c>

00:37:44.932 --> 00:37:46.834
<c.magenta>这是我要跟你们讲的内容</c>

00:37:47.267 --> 00:37:51.839
<c.magenta>当然 断点是停止程序的一种</c>
<c.magenta>顺其自然的方式</c>

00:37:51.905 --> 00:37:56.476
<c.magenta>那么 我想谈谈你们觉得断点</c>
<c.magenta>就是自然而然地</c>

00:37:56.543 --> 00:37:59.580
<c.magenta>在我设置断点的地方停止</c>
<c.magenta>我的程序</c>

00:37:59.713 --> 00:38:03.550
<c.magenta>但这并不是它们的实现方式</c>
<c.magenta>LLDB也不是这么认为的</c>

00:37:59.713 --> 00:38:03.550
<c.magenta>但这并不是它们的实现方式</c>
<c.magenta>LLDB也不是这么认为的</c>

00:38:03.750 --> 00:38:07.221
<c.magenta>对于LLDB来说</c>
<c.magenta>断点其实是一个搜索</c>

00:38:07.287 --> 00:38:10.757
<c.magenta>在你的程序空间中寻找这些</c>
<c.magenta>有趣的位置以便停止</c>

00:38:10.824 --> 00:38:13.360
<c.magenta>事实证明也许是很多不同的搜索</c>

00:38:14.027 --> 00:38:16.730
<c.magenta>因此 断点其实是搜索条件</c>

00:38:16.797 --> 00:38:20.734
<c.magenta>你停止的个别位置</c>

00:38:20.801 --> 00:38:23.036
<c.magenta>就是你认为的那个</c>
<c.magenta>自然而然的断点</c>

00:38:23.103 --> 00:38:25.138
<c.magenta>我们叫做断点位置</c>

00:38:25.372 --> 00:38:29.209
<c.magenta>让我们具体讲一下 我要把这个</c>
<c.magenta>连到Xcode的断点</c>

00:38:29.276 --> 00:38:33.447
<c.magenta>因为不管怎样 当使用LLDB调试时</c>
<c.magenta>Xcode都在幕后</c>

00:38:33.514 --> 00:38:37.217
<c.magenta>所以 Xcode断点必须</c>
<c.magenta>都得是LLDB断点</c>

00:38:37.284 --> 00:38:41.588
<c.magenta>那么比如说 当你在Xcode中</c>
<c.magenta>点击源边列时</c>

00:38:41.688 --> 00:38:44.858
<c.magenta>你实际正在做的是在LLDB中</c>
<c.magenta>运行这条命令</c>

00:38:44.925 --> 00:38:46.627
<c.magenta>有些断点设置命令</c>

00:38:46.894 --> 00:38:49.229
<c.magenta>类似地 当你做符号断点时</c>

00:38:49.296 --> 00:38:52.399
<c.magenta>你正在运行一个按名称</c>
<c.magenta>设置的断点</c>

00:38:52.833 --> 00:38:56.970
<c.magenta>那么我想让你们有一点概念</c>
<c.magenta>就是这些实际上是搜索</c>

00:38:57.037 --> 00:38:58.572
<c.magenta>我要演示一些例子</c>

00:38:58.639 --> 00:39:02.776
<c.magenta>从而你可以自然而然地得到</c>
<c.magenta>多种结果</c>

00:38:58.639 --> 00:39:02.776
<c.magenta>从而你可以自然而然地得到</c>
<c.magenta>多种结果</c>

00:39:02.843 --> 00:39:06.146
<c.magenta>虽然以前你觉得只是一个</c>
<c.magenta>单一的断点设置</c>

00:39:06.446 --> 00:39:10.651
<c.magenta>那么 第一个例子是符号断点</c>

00:39:10.851 --> 00:39:14.221
<c.magenta>这是一个只在主函数上</c>
<c.magenta>设置断点的例子</c>

00:39:14.288 --> 00:39:16.156
<c.magenta>这应该很简单 对吧？</c>

00:39:16.223 --> 00:39:18.692
<c.magenta>但是稍后它会告诉你</c>
<c.magenta>“不 我有19个位置 ”</c>

00:39:18.759 --> 00:39:20.561
<c.magenta>为什么最终会得到19个呢？</c>

00:39:20.861 --> 00:39:24.398
<c.magenta>执行break list命令是不是</c>
<c.magenta>查看断点设置的结果</c>

00:39:24.464 --> 00:39:28.202
<c.magenta>你看到的是断点名称搜索</c>

00:39:28.268 --> 00:39:31.305
<c.magenta>实际上是一个不精确的</c>
<c.magenta>名称匹配搜索</c>

00:39:31.371 --> 00:39:35.075
<c.magenta>那么比如说 它在一个类中</c>
<c.magenta>选取了选择器名称</c>

00:39:35.142 --> 00:39:37.044
<c.magenta>在很多情况下</c>
<c.magenta>这样的确很方便</c>

00:39:37.110 --> 00:39:40.714
<c.magenta>因为就像你在C++中调试时</c>
<c.magenta>你有命名空间、</c>

00:39:40.781 --> 00:39:43.050
<c.magenta>命名空间内部、类、方法</c>

00:39:43.116 --> 00:39:47.154
<c.magenta>你并不想键入整条路径</c>

00:39:47.521 --> 00:39:48.922
<c.magenta>另一方面 也确实意味着</c>

00:39:48.989 --> 00:39:51.992
<c.magenta>搜索也许比你想要的范围更广</c>

00:39:52.526 --> 00:39:54.862
<c.magenta>我们提供很多不同类型的搜索</c>

00:39:54.928 --> 00:39:57.865
<c.magenta>当然 我们提供更精确的搜索</c>

00:39:57.931 --> 00:40:01.869
<c.magenta>即全名搜索 强制名称匹配</c>

00:39:57.931 --> 00:40:01.869
<c.magenta>即全名搜索 强制名称匹配</c>

00:40:01.935 --> 00:40:05.305
<c.magenta>你指定的符号全名</c>

00:40:05.639 --> 00:40:07.875
<c.magenta>我们尝试过 但就算那样也不行</c>

00:40:08.141 --> 00:40:10.911
<c.magenta>因为某些原因</c>
<c.magenta>某人决定在库内加</c>

00:40:10.978 --> 00:40:13.514
<c.magenta>一个函数调用主函数</c>
<c.magenta>不知道为什么 但确实起作用了</c>

00:40:13.814 --> 00:40:16.350
<c.magenta>因此 你甚至可以指定</c>

00:40:16.416 --> 00:40:19.119
<c.magenta>通过shlib选项</c>

00:40:19.186 --> 00:40:21.822
<c.magenta>限制搜索特定的共享库</c>

00:40:21.889 --> 00:40:24.558
<c.magenta>那么最后 你就得到</c>
<c.magenta>你想要的断点了</c>

00:40:24.625 --> 00:40:27.494
<c.magenta>我要再举一个例子 不是因为</c>
<c.magenta>我认为你们不相信我</c>

00:40:27.561 --> 00:40:30.297
<c.magenta>而是因为这个例子</c>
<c.magenta>经常会在Swift中出现</c>

00:40:30.364 --> 00:40:32.132
<c.magenta>文件和行断点</c>

00:40:32.332 --> 00:40:34.201
<c.magenta>因为Swift有个不错的功能</c>

00:40:34.268 --> 00:40:36.904
<c.magenta>就是你调用一个使用闭包</c>

00:40:36.970 --> 00:40:39.706
<c.magenta>并定义闭包函数的函数</c>

00:40:39.773 --> 00:40:42.709
<c.magenta>简单地通过用波形号来继续</c>

00:40:42.776 --> 00:40:45.012
<c.magenta>然后接着是闭包体</c>

00:40:45.179 --> 00:40:47.548
<c.magenta>但是 如果你尝试在那行设置断点</c>

00:40:47.614 --> 00:40:50.584
<c.magenta>你就会发现有两个停止的点</c>

00:40:50.651 --> 00:40:51.652
<c.magenta>为什么会这样？</c>

00:40:52.019 --> 00:40:54.688
<c.magenta>你观察时 你觉得很简单</c>
<c.magenta>对吧？</c>

00:40:54.855 --> 00:40:59.960
<c.magenta>源代码行实际上给闭包函数</c>
<c.magenta>提供了一些代码</c>

00:41:00.027 --> 00:41:03.664
<c.magenta>你可以看到 我们在闭包函数上</c>
<c.magenta>有一个断点位置</c>

00:41:03.931 --> 00:41:07.501
<c.magenta>但是它也是函数引用的位置</c>

00:41:07.701 --> 00:41:10.537
<c.magenta>因此还有一个位置是</c>
<c.magenta>那个引用的位置</c>

00:41:12.172 --> 00:41:14.208
<c.magenta>那么无论怎么样 就是这样</c>

00:41:14.274 --> 00:41:16.910
<c.magenta>已经讲了一些例子</c>

00:41:16.977 --> 00:41:19.079
<c.magenta>我要给你们一个命令的通用格式</c>

00:41:19.146 --> 00:41:22.850
<c.magenta>然后再继续讲其他功能</c>

00:41:23.317 --> 00:41:25.652
<c.magenta>断点设置命令是这样的：</c>

00:41:25.719 --> 00:41:27.187
<c.magenta>键入break set</c>

00:41:27.254 --> 00:41:30.390
<c.magenta>然后有一些指定类型的选项</c>

00:41:30.958 --> 00:41:34.661
<c.magenta>这是指定你要进行</c>
<c.magenta>哪种搜索的选项</c>

00:41:34.728 --> 00:41:36.930
<c.magenta>是文件和行搜索</c>
<c.magenta>还是符号名搜索</c>

00:41:36.997 --> 00:41:38.131
<c.magenta>等等诸如此类？</c>

00:41:38.198 --> 00:41:43.036
<c.magenta>那个类型选项的值是用于</c>
<c.magenta>搜索的数据</c>

00:41:43.270 --> 00:41:48.108
<c.magenta>然后还有其他选项 比如忽略计数</c>
<c.magenta>条件 等等</c>

00:41:48.175 --> 00:41:52.412
<c.magenta>这些选项规定的不是指定</c>
<c.magenta>在哪儿中断</c>

00:41:52.479 --> 00:41:54.314
<c.magenta>而是规定是不是中断</c>

00:41:55.415 --> 00:41:59.253
<c.magenta>所以 搜索后是否可以修改</c>

00:41:59.419 --> 00:42:02.089
<c.magenta>是不能改变的</c>
<c.magenta>因为我们已经搜索完了</c>

00:41:59.419 --> 00:42:02.089
<c.magenta>是不能改变的</c>
<c.magenta>因为我们已经搜索完了</c>

00:42:02.155 --> 00:42:04.658
<c.magenta>如果你希望这样做的话</c>
<c.magenta>你只能设置一个新断点来实现</c>

00:42:04.725 --> 00:42:07.394
<c.magenta>让我们讲讲断点位置相关的事</c>

00:42:07.461 --> 00:42:09.630
<c.magenta>断点位置就是你要停止的位置</c>

00:42:09.696 --> 00:42:11.765
<c.magenta>它们是个别的搜索结果</c>

00:42:11.965 --> 00:42:13.333
<c.magenta>一般都会有地址</c>

00:42:13.400 --> 00:42:16.270
<c.magenta>是程序要叫停的地址</c>

00:42:17.070 --> 00:42:21.542
<c.magenta>当你查看它们时</c>
<c.magenta>它们通过生成断点和位置编号被指定</c>

00:42:21.642 --> 00:42:24.244
<c.magenta>通过一个点分开</c>

00:42:24.311 --> 00:42:27.714
<c.magenta>因此 当你在Xcode中调试</c>
<c.magenta>并且在某个断点上停止时</c>

00:42:27.781 --> 00:42:31.518
<c.magenta>你注意一下</c>
<c.magenta>你看一下PC小功能区</c>

00:42:31.585 --> 00:42:34.421
<c.magenta>PC功能区将在右侧给出停止原因</c>

00:42:34.488 --> 00:42:37.591
<c.magenta>它总是会给出像2.1</c>
<c.magenta>这样形式的断点</c>

00:42:37.658 --> 00:42:39.459
<c.magenta>它从不给出像2这样形式的断点</c>

00:42:39.526 --> 00:42:42.196
<c.magenta>因为你只能在这些位置上中断</c>

00:42:42.262 --> 00:42:44.331
<c.magenta>所以是1.1 1.2等等</c>

00:42:45.165 --> 00:42:49.269
<c.magenta>另外 位置和断点在某种程度上</c>
<c.magenta>与我讲的其他选项</c>

00:42:49.336 --> 00:42:52.606
<c.magenta>是对称的</c>

00:42:52.773 --> 00:42:57.244
<c.magenta>它们都有像命令和条件等那样</c>
<c.magenta>相同的通用选项</c>

00:42:57.311 --> 00:43:00.581
<c.magenta>你可在断点上指定任何命令条件</c>

00:42:57.311 --> 00:43:00.581
<c.magenta>你可在断点上指定任何命令条件</c>

00:43:00.647 --> 00:43:03.550
<c.magenta>然后它将适用于所有位置</c>

00:43:03.617 --> 00:43:06.587
<c.magenta>但是你还可以重载特定位置</c>

00:43:06.653 --> 00:43:10.824
<c.magenta>通过在位置上设置其中一个</c>
<c.magenta>命令或条件来实现</c>

00:43:11.525 --> 00:43:13.560
<c.magenta>还有一点好处</c>

00:43:14.294 --> 00:43:17.798
<c.magenta>很多时候</c>
<c.magenta>若你有一个生成一批位置的断点</c>

00:43:17.865 --> 00:43:20.067
<c.magenta>你想得到其中五个</c>
<c.magenta>或你不想得到其中五个</c>

00:43:20.133 --> 00:43:22.936
<c.magenta>那么你可以禁用它们</c>
<c.magenta>你可以分别执行</c>

00:43:23.203 --> 00:43:25.672
<c.magenta>但是 如果你不想搜索到它们</c>

00:43:25.739 --> 00:43:27.941
<c.magenta>你想禁用整个断点</c>

00:43:28.008 --> 00:43:29.643
<c.magenta>你可以通过禁用断点来实现</c>

00:43:29.710 --> 00:43:33.847
<c.magenta>但看起来并没有改变位置的开启</c>
<c.magenta>或禁用状态</c>

00:43:33.914 --> 00:43:35.983
<c.magenta>因此 你只需要再把它打开即可</c>

00:43:36.049 --> 00:43:39.219
<c.magenta>就会像你所期待的那样改变</c>
<c.magenta>所有位置的状态</c>

00:43:39.520 --> 00:43:42.389
<c.magenta>这只是一个小贴士</c>
<c.magenta>那么现在你已经看到</c>

00:43:42.756 --> 00:43:45.726
<c.magenta>断点在LLDB中的概念</c>

00:43:45.959 --> 00:43:49.162
<c.magenta>让我展示一些</c>
<c.magenta>LLDB提供的</c>

00:43:49.229 --> 00:43:50.564
<c.magenta>更强大的断点类型</c>

00:43:50.631 --> 00:43:53.033
<c.magenta>这些仍然是搜索要停止的位置</c>

00:43:53.133 --> 00:43:55.536
<c.magenta>我们要进行哪种搜索呢？</c>

00:43:55.602 --> 00:43:59.406
<c.magenta>这正是你程序中的命名空间</c>
<c.magenta>所感兴趣的</c>

00:43:59.473 --> 00:44:03.143
<c.magenta>看起来所有命名空间都是</c>
<c.magenta>黏糊糊的东西</c>

00:43:59.473 --> 00:44:03.143
<c.magenta>看起来所有命名空间都是</c>
<c.magenta>黏糊糊的东西</c>

00:44:03.210 --> 00:44:05.512
<c.magenta>因为它们都像函数名</c>
<c.magenta>或诸如此类的东西</c>

00:44:05.746 --> 00:44:10.984
<c.magenta>因为我们总是使用常规表达式</c>
<c.magenta>作为搜索模式的表达方式</c>

00:44:11.084 --> 00:44:12.486
<c.magenta>那么如果你知道常规表达式</c>

00:44:12.553 --> 00:44:14.054
<c.magenta>你一定会觉得它很可爱</c>

00:44:14.121 --> 00:44:15.889
<c.magenta>如果你不熟悉常规表达式</c>

00:44:16.290 --> 00:44:17.891
<c.magenta>几年前我就说过</c>

00:44:17.958 --> 00:44:22.129
<c.magenta>在你的办公室找一个</c>
<c.magenta>有动物封面书的人</c>

00:44:22.196 --> 00:44:24.164
<c.magenta>即使现在 如果你想找个前辈</c>

00:44:24.231 --> 00:44:27.201
<c.magenta>你可以找个有书的人</c>

00:44:28.168 --> 00:44:29.036
<c.magenta>那么无论如何...</c>

00:44:32.773 --> 00:44:36.743
<c.magenta>我们提供两种搜索</c>
<c.magenta>一种显而易见</c>

00:44:36.977 --> 00:44:40.647
<c.magenta>是搜索程序中的函数名</c>

00:44:40.714 --> 00:44:42.216
<c.magenta>这是那种搜索的选项</c>

00:44:42.282 --> 00:44:43.984
<c.magenta>还有一种可能不那么明显</c>

00:44:44.051 --> 00:44:46.687
<c.magenta>但我希望随着我们更深入地讲解</c>
<c.magenta>我能说服你 让你觉得那很有意思</c>

00:44:46.753 --> 00:44:49.590
<c.magenta>就是源文本搜索断点</c>

00:44:49.890 --> 00:44:51.458
<c.magenta>这就是搜索的选项</c>

00:44:51.892 --> 00:44:52.993
<c.magenta>让我们先来看第一种</c>

00:44:53.060 --> 00:44:55.829
<c.magenta>函数名模式跟断点相匹配</c>

00:44:55.896 --> 00:44:57.631
<c.magenta>我只展示一些例子</c>

00:44:57.698 --> 00:45:00.067
<c.magenta>假如某人给了你一个新类</c>

00:44:57.698 --> 00:45:00.067
<c.magenta>假如某人给了你一个新类</c>

00:45:00.133 --> 00:45:02.736
<c.magenta>你不知道这个类是干什么的</c>
<c.magenta>你想知道它是如何工作的</c>

00:45:02.803 --> 00:45:06.740
<c.magenta>那么你想要做的其实是中断</c>
<c.magenta>那个类实现的所有方法</c>

00:45:06.807 --> 00:45:09.676
<c.magenta>你可以通过在Xcode中</c>
<c.magenta>仔细检查源文件来实现</c>

00:45:09.743 --> 00:45:12.946
<c.magenta>从最开始进行 但很快你会觉得乏味</c>

00:45:13.380 --> 00:45:16.183
<c.magenta>顺便说一下 你不想在父类</c>
<c.magenta>或子类这样的类上中断</c>

00:45:16.750 --> 00:45:19.953
<c.magenta>最好是尝试制定一个</c>
<c.magenta>常规表达式</c>

00:45:20.020 --> 00:45:23.790
<c.magenta>匹配给定类中的所有函数</c>

00:45:23.957 --> 00:45:26.760
<c.magenta>那么在Swift中</c>
<c.magenta>这是个合适的常规表达式</c>

00:45:26.960 --> 00:45:29.763
<c.magenta>或在Objective C中</c>
<c.magenta>这是个合适的常规表达式</c>

00:45:29.830 --> 00:45:32.633
<c.magenta>然后你要在这些表达式上</c>
<c.magenta>设置断点</c>

00:45:32.699 --> 00:45:35.402
<c.magenta>然后你就可以运行程序</c>
<c.magenta>看看会发生什么</c>

00:45:35.469 --> 00:45:38.071
<c.magenta>请记住 因为你可以禁用个别位置</c>

00:45:38.272 --> 00:45:40.407
<c.magenta>当你做这种实验时</c>

00:45:40.474 --> 00:45:44.478
<c.magenta>你会发现你可能搜索到其中一个</c>
<c.magenta>你知道它是干什么的 你并不感兴趣</c>

00:45:44.545 --> 00:45:47.214
<c.magenta>所以你只需要禁用那个位置</c>
<c.magenta>然后继续</c>

00:45:47.281 --> 00:45:49.716
<c.magenta>发现第二个 禁用</c>
<c.magenta>然后继续 以此类推</c>

00:45:49.983 --> 00:45:52.119
<c.magenta>那么这是一种探索新代码的</c>
<c.magenta>不错的方式</c>

00:45:52.186 --> 00:45:54.955
<c.magenta>更高级的版本是</c>

00:45:55.022 --> 00:45:57.791
<c.magenta>某人给你一个共享库</c>

00:45:57.858 --> 00:46:00.561
<c.magenta>你想看看它在运行时到底</c>
<c.magenta>有什么功能</c>

00:45:57.858 --> 00:46:00.561
<c.magenta>你想看看它在运行时到底</c>
<c.magenta>有什么功能</c>

00:46:00.627 --> 00:46:05.098
<c.magenta>然后设置一个常规表达式断点</c>
<c.magenta>我在这里用的是简化的-r形式</c>

00:46:05.165 --> 00:46:07.734
<c.magenta>常规表达式匹配一切</c>

00:46:07.801 --> 00:46:09.169
<c.magenta>用.*实现</c>

00:46:09.236 --> 00:46:12.372
<c.magenta>然后把它限制在</c>
<c.magenta>你感兴趣的那个库</c>

00:46:12.439 --> 00:46:14.408
<c.magenta>把这些和断点命令相结合</c>

00:46:14.474 --> 00:46:16.143
<c.magenta>通常是一种很好的方式</c>

00:46:16.210 --> 00:46:20.447
<c.magenta>以便又迅速又随性地获得</c>
<c.magenta>这个库的执行轨迹</c>

00:46:20.514 --> 00:46:22.883
<c.magenta>你可以向后追踪 也许会打印局部</c>

00:46:22.950 --> 00:46:25.485
<c.magenta>然后继续 你只需要运行程序</c>

00:46:25.552 --> 00:46:29.690
<c.magenta>并且得到那个库的执行磁带输出即可</c>

00:46:30.390 --> 00:46:33.460
<c.magenta>当然了 在执行过程中速度会慢下来</c>
<c.magenta>但值得等待</c>

00:46:34.394 --> 00:46:36.230
<c.magenta>然后另一个小技巧是</c>

00:46:36.296 --> 00:46:39.433
<c.magenta>如果你找到你并不感兴趣的</c>
<c.magenta>你可以禁用它们</c>

00:46:39.833 --> 00:46:43.971
<c.magenta>那么让我们谈谈另一种</c>
<c.magenta>匹配模式吧</c>

00:46:44.304 --> 00:46:47.841
<c.magenta>这里的重点是有一些构造函数</c>

00:46:47.908 --> 00:46:50.844
<c.magenta>当你查看源文本时非常明显</c>

00:46:50.911 --> 00:46:53.680
<c.magenta>但如何在生成的代码中得到</c>
<c.magenta>那些构造函数</c>

00:46:53.747 --> 00:46:55.182
<c.magenta>真的很不明显</c>

00:46:55.315 --> 00:46:57.551
<c.magenta>其中一个例子是宏</c>

00:46:57.618 --> 00:47:01.088
<c.magenta>通常在你的程序中替代文本</c>

00:46:57.618 --> 00:47:01.088
<c.magenta>通常在你的程序中替代文本</c>

00:47:01.154 --> 00:47:02.356
<c.magenta>然后它就悄悄消失了</c>
<c.magenta>但你知道</c>

00:47:02.422 --> 00:47:06.293
<c.magenta>它们插在代码的哪个位置</c>
<c.magenta>因为它们是大写字母</c>

00:47:06.360 --> 00:47:09.196
<c.magenta>那么想要搜索到它们</c>
<c.magenta>也许需要搜索全部大写字母</c>

00:47:09.263 --> 00:47:11.431
<c.magenta>或你所关注的特定的宏</c>

00:47:11.498 --> 00:47:13.300
<c.magenta>但是你可以更有创造力</c>

00:47:13.367 --> 00:47:17.905
<c.magenta>比如说 我想了解指针</c>

00:47:17.971 --> 00:47:19.506
<c.magenta>指定字段的位置</c>

00:47:19.773 --> 00:47:22.242
<c.magenta>很明显是在源文本中</c>

00:47:22.309 --> 00:47:24.077
<c.magenta>因为看起来就像是那样</c>

00:47:24.178 --> 00:47:27.915
<c.magenta>但在生成的代码中</c>
<c.magenta>寻找这些位置可能会很困难</c>

00:47:27.981 --> 00:47:32.386
<c.magenta>因此还有另一个实例</c>
<c.magenta>在源文本中使用模式匹配</c>

00:47:32.452 --> 00:47:36.590
<c.magenta>可以允许你发现你用其他方式</c>
<c.magenta>发现不了的构造函数</c>

00:47:37.191 --> 00:47:38.759
<c.magenta>另一种使用方法是</c>

00:47:38.825 --> 00:47:42.696
<c.magenta>做主题分组</c>

00:47:42.763 --> 00:47:44.631
<c.magenta>你可以在上边设置断点</c>

00:47:44.698 --> 00:47:48.569
<c.magenta>通过插入手动模式到你的源代码</c>

00:47:48.635 --> 00:47:51.605
<c.magenta>就像注释里说的中断这里</c>
<c.magenta>或中断那里</c>

00:47:51.672 --> 00:47:53.640
<c.magenta>如果你有兴趣检测</c>

00:47:53.707 --> 00:47:57.211
<c.magenta>程序功能中的这个特定的部分</c>

00:47:57.444 --> 00:47:59.913
<c.magenta>然后使用这些源常规表达式断点</c>

00:47:59.980 --> 00:48:01.048
<c.magenta>来捕捉它</c>

00:47:59.980 --> 00:48:01.048
<c.magenta>来捕捉它</c>

00:48:01.415 --> 00:48:06.320
<c.magenta>那么这就是源断点的工作原理</c>

00:48:06.386 --> 00:48:09.356
<c.magenta>选项是源常规表达式</c>

00:48:09.423 --> 00:48:12.226
<c.magenta>为搜索提供的数据是模式</c>

00:48:12.292 --> 00:48:14.928
<c.magenta>然后你可以把它限定在一个文件中</c>

00:48:15.229 --> 00:48:20.434
<c.magenta>你可以通过多次给出-f选项</c>
<c.magenta>限定在多个文件中</c>

00:48:20.567 --> 00:48:23.103
<c.magenta>并且还有一个标志可以搜索</c>
<c.magenta>全部源文件</c>

00:48:24.004 --> 00:48:27.841
<c.magenta>让我举个例子来吊你的胃口</c>

00:48:27.908 --> 00:48:31.044
<c.magenta>假如我有个复杂的函数</c>
<c.magenta>比如状态机</c>

00:48:31.111 --> 00:48:34.481
<c.magenta>是计算用的</c>
<c.magenta>然后从许多不同的地方返回</c>

00:48:34.548 --> 00:48:37.384
<c.magenta>在某些恐怖的超长的选择语句中</c>
<c.magenta>或其他类似的选择语句中</c>

00:48:37.451 --> 00:48:41.154
<c.magenta>我想找到什么时候会返回空</c>

00:48:41.221 --> 00:48:45.826
<c.magenta>但我想了解返回空时</c>

00:48:46.026 --> 00:48:47.594
<c.magenta>的具体情况</c>

00:48:48.095 --> 00:48:49.563
<c.magenta>很难实现</c>

00:48:49.630 --> 00:48:51.398
<c.magenta>因为你可以在函数返回后中断</c>

00:48:51.465 --> 00:48:52.699
<c.magenta>并查看是否为空</c>

00:48:52.766 --> 00:48:55.802
<c.magenta>你可以点击所有返回空的位置</c>

00:48:55.869 --> 00:48:59.740
<c.magenta>但你可能会遗漏其中一个</c>
<c.magenta>或你只关注模式</c>

00:49:00.340 --> 00:49:02.376
<c.magenta>这里有另外一个便捷方式</c>

00:49:02.442 --> 00:49:05.012
<c.magenta>在源常规表达式断点类型中</c>

00:49:05.078 --> 00:49:07.314
<c.magenta>你不仅可以指定一个文件</c>

00:49:07.381 --> 00:49:09.483
<c.magenta>你还可以把它限定在一个</c>
<c.magenta>特定的函数中</c>

00:49:09.550 --> 00:49:11.385
<c.magenta>如果那样的话</c>
<c.magenta>我要做这样的操作</c>

00:49:11.451 --> 00:49:14.621
<c.magenta>中断要返回的模式</c>

00:49:14.688 --> 00:49:18.625
<c.magenta>我正在展示我会用常规表达式</c>
<c.magenta>因为我正在炫耀</c>

00:49:18.692 --> 00:49:20.961
<c.magenta>空格+星号代表任意数量的空格</c>

00:49:21.028 --> 00:49:22.462
<c.magenta>然后空指针</c>

00:49:22.529 --> 00:49:25.432
<c.magenta>我把它限定在一个函数中</c>
<c.magenta>且限定在我感兴趣的一个文件中</c>

00:49:25.499 --> 00:49:29.803
<c.magenta>然后我会发现</c>
<c.magenta>在这个特定的用法中</c>

00:49:29.870 --> 00:49:31.138
<c.magenta>我精确地找到了返回空的位置</c>

00:49:32.539 --> 00:49:35.776
<c.magenta>那么值得谈一些额外的断点选项</c>

00:49:35.843 --> 00:49:37.711
<c.magenta>你可能没听说过</c>

00:49:37.778 --> 00:49:42.349
<c.magenta>其中一个类似逐行或筛选</c>

00:49:42.816 --> 00:49:47.888
<c.magenta>很有用 因为我们程序中同时存在</c>
<c.magenta>Swift和Objective C</c>

00:49:48.255 --> 00:49:51.024
<c.magenta>可以给指定的一种语言设置断点</c>

00:49:51.091 --> 00:49:54.795
<c.magenta>那么比如说 随处都有计数方法</c>

00:49:54.862 --> 00:49:56.597
<c.magenta>如果你在计数上设置一个断点</c>

00:49:56.663 --> 00:49:58.999
<c.magenta>你将在Swift代码中得到一批断点</c>

00:49:59.066 --> 00:50:01.502
<c.magenta>你也会得到一批</c>
<c.magenta>Objective C方法的断点</c>

00:49:59.066 --> 00:50:01.502
<c.magenta>你也会得到一批</c>
<c.magenta>Objective C方法的断点</c>

00:50:01.568 --> 00:50:03.504
<c.magenta>但你并不关心</c>
<c.magenta>Objective C方法</c>

00:50:03.570 --> 00:50:05.138
<c.magenta>你只想查看Swift代码</c>

00:50:05.405 --> 00:50:07.841
<c.magenta>然后你可以指定语言为Swift</c>

00:50:08.041 --> 00:50:10.711
<c.magenta>它将不会在 Objective C</c>
<c.magenta>名称上执行恰巧匹配的断点</c>

00:50:10.777 --> 00:50:13.680
<c.magenta>这很有用</c>

00:50:13.747 --> 00:50:15.482
<c.magenta>是的 对</c>

00:50:15.549 --> 00:50:18.485
<c.magenta>另一个有用的选项</c>

00:50:18.552 --> 00:50:22.723
<c.magenta>能使搜索缩小到一个</c>
<c.magenta>指定的线程</c>

00:50:22.856 --> 00:50:26.326
<c.magenta>假如你有一些能调用的代码</c>
<c.magenta>和一批不同的线程</c>

00:50:26.393 --> 00:50:27.928
<c.magenta>就像内核或诸如此类的</c>

00:50:27.995 --> 00:50:31.164
<c.magenta>但当你开始执行一个线程时</c>

00:50:31.231 --> 00:50:34.635
<c.magenta>你不想让用于检测的断点</c>

00:50:34.701 --> 00:50:37.704
<c.magenta>把你带到其他线程上去 很简单</c>

00:50:37.871 --> 00:50:40.240
<c.magenta>有一个线程ID选项</c>

00:50:40.774 --> 00:50:42.776
<c.magenta>这个选项可以让你按照</c>
<c.magenta>线程名执行</c>

00:50:42.843 --> 00:50:45.812
<c.magenta>可以通过调用</c>
<c.magenta>pthread_setname_np设置</c>

00:50:45.879 --> 00:50:48.615
<c.magenta>这很方便 因为如果你命名</c>
<c.magenta>一个线程</c>

00:50:48.682 --> 00:50:51.084
<c.magenta>然后保留在多个调试会话中</c>

00:50:51.151 --> 00:50:53.620
<c.magenta>线程ID当然会随时变更</c>

00:50:53.954 --> 00:50:55.322
<c.magenta>你甚至可以限制它</c>

00:50:55.389 --> 00:50:59.593
<c.magenta>按照名称对指定队列进行编码</c>

00:51:00.994 --> 00:51:02.596
<c.magenta>还有一点你可能会注意到</c>

00:51:02.663 --> 00:51:06.166
<c.magenta>就是你可以把全部选项</c>
<c.magenta>添加到现有断点上</c>

00:51:06.633 --> 00:51:07.935
<c.magenta>特别有用</c>

00:51:08.001 --> 00:51:11.605
<c.magenta>如果你已经在Xcode的边列中</c>
<c.magenta>设置了文件和行断点的话</c>

00:51:11.672 --> 00:51:15.642
<c.magenta>比如说 你决定你想限定到</c>
<c.magenta>一个指定线程</c>

00:51:15.709 --> 00:51:18.946
<c.magenta>你可以在查询后进行变更</c>
<c.magenta>命令是break modify</c>

00:51:19.012 --> 00:51:22.983
<c.magenta>另一件有用的事是展示</c>
<c.magenta>如何指定它们</c>

00:51:23.050 --> 00:51:26.620
<c.magenta>因为你可以通过断点指定</c>

00:51:26.920 --> 00:51:28.622
<c.magenta>通过断点位置编号指定</c>

00:51:28.689 --> 00:51:31.325
<c.magenta>还有一个小语句来指定范围</c>

00:51:33.227 --> 00:51:34.061
<c.magenta>就是这样</c>

00:51:35.229 --> 00:51:39.099
<c.magenta>那么现在 你得到了你想要的</c>
<c.magenta>所有断点</c>

00:51:39.166 --> 00:51:41.201
<c.magenta>但你遇到了绊脚石</c>

00:51:41.268 --> 00:51:43.570
<c.magenta>就是目前Xcode看起来</c>

00:51:43.637 --> 00:51:46.640
<c.magenta>只保留了它已知的你设置的断点</c>

00:51:46.707 --> 00:51:51.211
<c.magenta>而那些你想方设法手动写入的断点</c>
<c.magenta>它并不了解</c>

00:51:51.345 --> 00:51:53.013
<c.magenta>那么如何保留那些断点呢？</c>

00:51:53.247 --> 00:51:55.582
<c.magenta>第一种方法是Enrico讲过的：</c>

00:51:55.649 --> 00:51:58.185
<c.magenta>如果你想把它保留在所有对象中</c>

00:51:58.252 --> 00:52:01.054
<c.magenta>你只需要把它放在LLDB初始化</c>
<c.magenta>文件中即可</c>

00:51:58.252 --> 00:52:01.054
<c.magenta>你只需要把它放在LLDB初始化</c>
<c.magenta>文件中即可</c>

00:52:01.288 --> 00:52:05.392
<c.magenta>但是如果你想指定对象</c>
<c.magenta>有一个小技巧你可以使用</c>

00:52:05.459 --> 00:52:10.030
<c.magenta>当你每次调试那个指定对象时</c>
<c.magenta>加载断点</c>

00:52:10.097 --> 00:52:13.333
<c.magenta>这其实是做一个</c>
<c.magenta>Xcode存储的断点</c>

00:52:13.400 --> 00:52:17.037
<c.magenta>最好是在程序执行中</c>
<c.magenta>早期断开的断点</c>

00:52:17.104 --> 00:52:19.540
<c.magenta>然后你把你的断点和命令</c>
<c.magenta>放在那个断点中</c>

00:52:19.606 --> 00:52:22.676
<c.magenta>这样你就知道</c>
<c.magenta>如果是主可执行文件</c>

00:52:22.743 --> 00:52:24.978
<c.magenta>比如说 主函数是个快速接口</c>

00:52:25.045 --> 00:52:26.980
<c.magenta>那么你可以做一个符号断点</c>

00:52:27.080 --> 00:52:29.650
<c.magenta>然后把主函数放进去</c>

00:52:29.716 --> 00:52:32.786
<c.magenta>然后你还记得刚才那张幻灯片吧</c>

00:52:32.853 --> 00:52:34.821
<c.magenta>我说过有个主函数的小麻烦</c>

00:52:34.888 --> 00:52:37.090
<c.magenta>那么你可以指定共享库</c>

00:52:37.791 --> 00:52:41.061
<c.magenta>然后你可以添加动作</c>
<c.magenta>是个调试器命令动作</c>

00:52:41.128 --> 00:52:44.331
<c.magenta>然后不要一个一个地</c>
<c.magenta>键入所有断点</c>

00:52:44.398 --> 00:52:45.999
<c.magenta>因为会很乏味</c>

00:52:46.066 --> 00:52:48.869
<c.magenta>把命令放在一个文件中很方便</c>

00:52:48.936 --> 00:52:54.274
<c.magenta>然后使用LLDB的command</c>
<c.magenta>source命令来加载这些断点</c>

00:52:54.341 --> 00:52:56.009
<c.magenta>最后 如果你自动继续</c>

00:52:56.076 --> 00:52:58.712
<c.magenta>每次你运行时 你都将自动获得</c>

00:52:58.779 --> 00:53:00.380
<c.magenta>所有那些断点集</c>

00:52:58.779 --> 00:53:00.380
<c.magenta>所有那些断点集</c>

00:53:01.281 --> 00:53:04.084
<c.magenta>我还想讲另一个便捷方式</c>

00:53:04.151 --> 00:53:06.386
<c.magenta>用来克服</c>

00:53:06.453 --> 00:53:11.825
<c.magenta>你在现代语言中常见的一种</c>
<c.magenta>特定的烦人的麻烦</c>

00:53:12.326 --> 00:53:16.330
<c.magenta>就是当你尝试单步跳入某个东西时</c>

00:53:16.396 --> 00:53:19.199
<c.magenta>问题是在大部分现代语言中</c>

00:53:19.266 --> 00:53:22.970
<c.magenta>大多数变量存取现在都是通过属性</c>
<c.magenta>完成的</c>

00:53:23.036 --> 00:53:25.205
<c.magenta>或通过存取子函数或诸如此类</c>

00:53:25.272 --> 00:53:26.106
<c.magenta>所以...</c>

00:53:26.473 --> 00:53:29.910
<c.magenta>一般来说 这并不是你尝试</c>
<c.magenta>要调试的代码</c>

00:53:30.811 --> 00:53:32.913
<c.magenta>最后导致了这样一个情况</c>

00:53:32.980 --> 00:53:35.782
<c.magenta>我在这儿 我尝试进入这个函数</c>
<c.magenta>完成某些功能</c>

00:53:35.849 --> 00:53:36.950
<c.magenta>我想进入那里</c>

00:53:37.017 --> 00:53:39.987
<c.magenta>所以我尝试单步跳入</c>
<c.magenta>但并没有成功</c>

00:53:40.053 --> 00:53:42.556
<c.magenta>因为我正在传递的一个参数</c>

00:53:42.623 --> 00:53:44.858
<c.magenta>是存取子函数</c>
<c.magenta>所以我在那个存取器中中断了</c>

00:53:44.925 --> 00:53:47.394
<c.magenta>我并不想在那儿中断</c>
<c.magenta>因为那一点儿都没有意义</c>

00:53:47.461 --> 00:53:50.364
<c.magenta>因此我要做的是完成并返回</c>

00:53:50.430 --> 00:53:53.033
<c.magenta>是不是有一种方式可以让这个</c>
<c.magenta>过程变得更简单？</c>

00:53:53.100 --> 00:53:56.436
<c.magenta>看起来我们添加了一个叫做</c>
<c.magenta>定向单步跳入的东西</c>

00:53:56.503 --> 00:54:00.841
<c.magenta>选项是step_in_target</c>
<c.magenta>表示你要单步跳入</c>

00:53:56.503 --> 00:54:00.841
<c.magenta>选项是step_in_target</c>
<c.magenta>表示你要单步跳入</c>

00:54:00.908 --> 00:54:02.809
<c.magenta>我要做的是单步跳入</c>

00:54:02.876 --> 00:54:05.479
<c.magenta>但我只想让你在这个指定的地方中断</c>

00:54:05.546 --> 00:54:07.514
<c.magenta>就是你正在用这个表达的意思</c>

00:54:07.581 --> 00:54:09.416
<c.magenta>让我们在这种情况中尝试一下</c>

00:54:09.483 --> 00:54:12.286
<c.magenta>我们发现它几乎不怎么工作</c>

00:54:12.352 --> 00:54:13.820
<c.magenta>不怎么工作的原因是</c>

00:54:13.887 --> 00:54:16.290
<c.magenta>虽然我们没有在存取器中中断</c>

00:54:16.356 --> 00:54:20.093
<c.magenta>但是我们却在下一个源文件上中断了</c>
<c.magenta>而不是在函数中中断</c>

00:54:20.160 --> 00:54:21.261
<c.magenta>这是有道理的</c>

00:54:21.328 --> 00:54:24.231
<c.magenta>因为实际上单步跳入是按照</c>
<c.magenta>源代码逐行执行的</c>

00:54:24.298 --> 00:54:26.266
<c.magenta>这就是多行调用</c>

00:54:26.333 --> 00:54:28.402
<c.magenta>那么我们也要通过给出</c>

00:54:28.468 --> 00:54:31.238
<c.magenta>结束行的编号添加能指定</c>

00:54:31.305 --> 00:54:33.140
<c.magenta>单步跳入的终止范围</c>

00:54:33.207 --> 00:54:36.510
<c.magenta>或更方便的是只进入这个块</c>

00:54:36.577 --> 00:54:38.846
<c.magenta>让我进入 做一些操作</c>

00:54:38.912 --> 00:54:43.383
<c.magenta>甚至还有一个别名</c>
<c.magenta>即函数中的sif单步跳入</c>

00:54:43.584 --> 00:54:47.654
<c.magenta>那么 你要做的就是坐在这里</c>
<c.magenta>并在函数中键入step</c>

00:54:47.721 --> 00:54:49.756
<c.magenta>然后你就会着陆在正确的位置</c>

00:54:49.823 --> 00:54:51.625
<c.magenta>若你没着陆在正确的位置</c>
<c.magenta>我就不会把它放在幻灯片中讲了</c>

00:54:52.292 --> 00:54:56.029
<c.magenta>最后我想讲一下排错</c>

00:54:56.263 --> 00:54:59.600
<c.magenta>你需要了解的一个信息是</c>

00:54:59.666 --> 00:55:02.436
<c.magenta>运行程序中到底有什么</c>

00:54:59.666 --> 00:55:02.436
<c.magenta>运行程序中到底有什么</c>

00:55:02.536 --> 00:55:05.405
<c.magenta>比如 也许我创建了发布版本</c>
<c.magenta>和调试版本</c>

00:55:05.472 --> 00:55:07.841
<c.magenta>我想了解我实际使用的是</c>
<c.magenta>哪个版本</c>

00:55:07.908 --> 00:55:09.977
<c.magenta>或某人给了我一个带dSYM的库</c>

00:55:10.043 --> 00:55:11.545
<c.magenta>这个dSYM允许读入吗？</c>

00:55:11.812 --> 00:55:14.681
<c.magenta>那么 需要那种信息的命令</c>

00:55:14.748 --> 00:55:16.116
<c.magenta>是image list命令</c>

00:55:16.183 --> 00:55:19.219
<c.magenta>你可以给它一个模块名</c>
<c.magenta>这样它将给出</c>

00:55:19.286 --> 00:55:21.522
<c.magenta>关于加载到你程序中</c>
<c.magenta>某个模块的信息</c>

00:55:21.588 --> 00:55:25.559
<c.magenta>或者为了消遣</c>
<c.magenta>你可以不提供任何选项</c>

00:55:25.626 --> 00:55:28.262
<c.magenta>将会显示全部</c>
<c.magenta>有时候多得令人震惊</c>

00:55:29.830 --> 00:55:32.232
<c.magenta>那么 这里有个例子</c>
<c.magenta>让我们看看如何使用它</c>

00:55:32.432 --> 00:55:35.335
<c.magenta>我键入image list</c>

00:55:35.402 --> 00:55:37.938
<c.magenta>我看到这里有个</c>
<c.magenta>二进制映像的路径</c>

00:55:38.005 --> 00:55:41.041
<c.magenta>那么假如 如果我想查看我是否</c>
<c.magenta>使用的是调试版本</c>

00:55:41.108 --> 00:55:43.544
<c.magenta>是的 看起来我的确像是用的调试版本</c>

00:55:43.610 --> 00:55:47.481
<c.magenta>如果有dSYM的话 它总是会在</c>
<c.magenta>二进制映像后列出来</c>

00:55:47.548 --> 00:55:49.683
<c.magenta>此情况下</c>
<c.magenta>我看到我的确得到了二进制映像</c>

00:55:50.517 --> 00:55:53.654
<c.magenta>我想告诉你一个</c>
<c.magenta>Swift调试的信息</c>

00:55:53.720 --> 00:55:56.857
<c.magenta>我这张幻灯片上的内容实际上</c>
<c.magenta>并不是我要讲的内容</c>

00:55:56.924 --> 00:55:58.759
<c.magenta>因为我们时间很紧</c>

00:55:58.825 --> 00:56:00.994
<c.magenta>但我会告诉你TLDR</c>

00:55:58.825 --> 00:56:00.994
<c.magenta>但我会告诉你TLDR</c>

00:56:01.428 --> 00:56:03.130
<c.magenta>因为我讲得太快 你可能读不完</c>

00:56:03.197 --> 00:56:07.868
<c.magenta>由于Swift和LLDB之间的</c>
<c.magenta>工作方式</c>

00:56:07.935 --> 00:56:11.338
<c.magenta>所有带调试信息的Swift代码</c>

00:56:11.405 --> 00:56:13.273
<c.magenta>都必须在本地创建</c>

00:56:13.340 --> 00:56:17.277
<c.magenta>因此 从其他人那儿拷贝二进制</c>
<c.magenta>映像是行不通的</c>

00:56:17.344 --> 00:56:20.013
<c.magenta>你要确保一切都是在本地创建的</c>

00:56:20.080 --> 00:56:21.682
<c.magenta>并且有编译器</c>

00:56:21.748 --> 00:56:24.585
<c.magenta>随着你正在使用的调试器一起运行</c>

00:56:26.253 --> 00:56:28.922
<c.magenta>我想说的是 这是我们提供的</c>
<c.magenta>一个小便利</c>

00:56:28.989 --> 00:56:31.692
<c.magenta>那么 Enrico讲的优化代码</c>
<c.magenta>优化的规则</c>

00:56:31.758 --> 00:56:34.561
<c.magenta>我们之前听到</c>
<c.magenta>如果不是不得不做的话 就不要做</c>

00:56:34.628 --> 00:56:39.533
<c.magenta>由于大部分软件开发者都是理性的人</c>

00:56:39.600 --> 00:56:42.069
<c.magenta>你可以写一个推论</c>

00:56:42.135 --> 00:56:45.873
<c.magenta>调试优化代码的绝大多数人</c>
<c.magenta>实际上都不是故意执行的</c>

00:56:46.106 --> 00:56:48.575
<c.magenta>那么现在当你中断在文件中时</c>

00:56:48.642 --> 00:56:52.112
<c.magenta> LLDB将告诉你</c>
<c.magenta>那个文件被优化了</c>

00:56:52.179 --> 00:56:56.216
<c.magenta>每个库只通知一次</c>
<c.magenta>你将得到一条像这样的消息</c>

00:56:56.283 --> 00:56:59.586
<c.magenta>然后你快速进入设置</c>
<c.magenta>把它们改回来</c>

00:57:00.921 --> 00:57:03.957
<c.magenta>刚刚添加到Clang中的</c>
<c.magenta>另一个新功能</c>

00:57:04.024 --> 00:57:05.926
<c.magenta>是这个模块概念</c>

00:57:05.993 --> 00:57:09.363
<c.magenta>模块是允许编译器</c>

00:57:09.429 --> 00:57:13.066
<c.magenta>查看你程序标头环境中的</c>
<c.magenta>所有标头的方式</c>

00:57:13.667 --> 00:57:16.870
<c.magenta>编译并解析它们</c>

00:57:16.937 --> 00:57:19.740
<c.magenta>然后在所有编译器中重用</c>

00:57:19.806 --> 00:57:22.376
<c.magenta>然后我们想</c>
<c.magenta>为什么我们不能对调试信息</c>

00:57:22.442 --> 00:57:23.944
<c.magenta>做同样的事呢？</c>

00:57:24.011 --> 00:57:28.215
<c.magenta>为什么不能允许</c>
<c.magenta>类型信息的解析形式</c>

00:57:28.282 --> 00:57:31.251
<c.magenta>也一次性完成然后</c>

00:57:31.318 --> 00:57:35.222
<c.magenta>在所有带调试信息.o文件中共享呢？</c>

00:57:35.289 --> 00:57:38.258
<c.magenta>这叫做Clang模式调试功能</c>

00:57:38.959 --> 00:57:40.827
<c.magenta>此外 我们还可以使用</c>
<c.magenta>PCH文件</c>

00:57:40.894 --> 00:57:44.631
<c.magenta>Xcode中的设置</c>
<c.magenta>是Clang模块调试</c>

00:57:44.698 --> 00:57:47.067
<c.magenta>这是由于某种原因</c>
<c.magenta>我放进去的标志</c>

00:57:47.367 --> 00:57:50.270
<c.magenta>这很棒 因为就像编译器一样</c>

00:57:50.337 --> 00:57:53.273
<c.magenta>提高了调试信息的生成速度</c>

00:57:53.340 --> 00:57:57.010
<c.magenta>它将缩短编译时间</c>
<c.magenta>但它有一个警告</c>

00:57:57.077 --> 00:58:00.380
<c.magenta>那个警告实际上可能是个重要警告</c>

00:57:57.077 --> 00:58:00.380
<c.magenta>那个警告实际上可能是个重要警告</c>

00:58:00.447 --> 00:58:04.518
<c.magenta>那么 那个警告是你的调试不仅</c>
<c.magenta>依赖于.o文件</c>

00:58:04.585 --> 00:58:07.721
<c.magenta>还依赖于内存中的某些东西</c>

00:58:07.988 --> 00:58:11.625
<c.magenta>因此 一般来说 那不是个问题</c>
<c.magenta>每个东西都在自己的位置上</c>

00:58:11.692 --> 00:58:16.096
<c.magenta>但当你要给某人发布库或应用时</c>

00:58:16.363 --> 00:58:20.300
<c.magenta>该怎么工作呢？</c>
<c.magenta>嗯 如果是应用或框架</c>

00:58:20.367 --> 00:58:23.237
<c.magenta>你只需要运行dsymutil即可</c>

00:58:23.303 --> 00:58:26.740
<c.magenta>效果是一样的 它把一切都集合起来</c>
<c.magenta>一切都能正常运行</c>

00:58:26.807 --> 00:58:30.177
<c.magenta>但请记住</c>
<c.magenta>dsymutil只在关联产品上运行</c>

00:58:30.244 --> 00:58:32.145
<c.magenta>并不在.o文件上运行</c>

00:58:32.212 --> 00:58:35.916
<c.magenta>因此 若你发布的是</c>
<c.magenta>带调试信息的静态库</c>

00:58:35.983 --> 00:58:38.519
<c.magenta>那么你必须关闭这个</c>
<c.magenta>G模块的功能</c>

00:58:38.585 --> 00:58:41.488
<c.magenta>否则你将会给客户发布</c>
<c.magenta>已损毁的调试信息</c>

00:58:41.989 --> 00:58:44.458
<c.magenta>顺便说一下 如果磁盘空间不足</c>

00:58:44.525 --> 00:58:46.193
<c.magenta>你删除了模块缓存</c>

00:58:46.260 --> 00:58:48.495
<c.magenta>那么你就不能再调试了</c>

00:58:48.695 --> 00:58:51.365
<c.magenta>这是那个功能的一个不利因素</c>

00:58:51.965 --> 00:58:55.669
<c.magenta>那么 让我来总结一下吧</c>

00:58:56.103 --> 00:58:59.773
<c.magenta>我希望你了解LLDB是个</c>
<c.magenta>定制化很强的调试器</c>

00:58:59.840 --> 00:59:02.242
<c.magenta>提供多种查看数据的方式</c>

00:58:59.840 --> 00:59:02.242
<c.magenta>提供多种查看数据的方式</c>

00:59:02.743 --> 00:59:07.114
<c.magenta>表达式实际上可以提供</c>
<c.magenta>更强大的检测功能</c>

00:59:07.181 --> 00:59:11.251
<c.magenta>我认为Sean的例子很好</c>
<c.magenta>讲了如何在live状态下</c>

00:59:11.318 --> 00:59:14.221
<c.magenta>从一个复杂的数组中通过</c>
<c.magenta>并发现你感兴趣的点</c>

00:59:15.022 --> 00:59:18.592
<c.magenta>在Xcode中 我们有很多断点类型</c>
<c.magenta>比你想象的多</c>

00:59:19.326 --> 00:59:22.729
<c.magenta>你可以把自己陷入超级深的麻烦中</c>

00:59:22.796 --> 00:59:24.431
<c.magenta>比源代码层的调试还深</c>

00:59:24.498 --> 00:59:28.936
<c.magenta>总之 希望我们提供了丰富的</c>
<c.magenta>工具集让你探索自己的代码</c>

00:59:29.002 --> 00:59:33.440
<c.magenta>这里有一些之前演讲的信息</c>
<c.magenta>可能涉及你感兴趣的内容</c>

00:59:33.507 --> 00:59:36.543
<c.magenta>还有一些早些时候的演讲</c>
<c.magenta>你可能没参加</c>

00:59:36.910 --> 00:59:39.213
<c.magenta>或参加了 但无论如何</c>
<c.magenta>我把它们列在幻灯片上了</c>

00:59:39.279 --> 00:59:40.214
<c.magenta>谢谢大家</c>

00:59:40.414 --> 00:59:43.584
<c.magenta>希望你们能在仅剩的WWDC</c>
<c.magenta>期间度过一段美好的时光</c>
