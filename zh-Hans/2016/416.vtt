WEBVTT

00:00:19.653 --> 00:00:25.692
了解Swift功能

00:00:26.226 --> 00:00:29.229
大家好
欢迎参加“了解Swift功能”演讲

00:00:29.329 --> 00:00:30.397
我是Kyle

00:00:30.831 --> 00:00:34.735
今天能跟大家一起探讨Swift
我和Arnold都很激动

00:00:35.435 --> 00:00:39.940
作为开发人员 Swift提供了广阔而
强大的设计空间等待我们去探索

00:00:40.474 --> 00:00:43.143
Swift有各种各样的头等类型

00:00:43.210 --> 00:00:46.146
以及各种代码复用和动态机制

00:00:46.880 --> 00:00:49.183
语言中的所有特性都能

00:00:49.283 --> 00:00:51.285
以一种有趣、迅捷的方式结合在一起

00:00:51.451 --> 00:00:55.088
那么我们该如何缩小这个设计空间

00:00:55.355 --> 00:00:57.191
并为我们的项目选择
合适的工具呢？

00:00:57.691 --> 00:01:00.360
嗯 首先 你要考虑到

00:00:57.691 --> 00:01:00.360
嗯 首先 你要考虑到

00:01:00.427 --> 00:01:04.531
Swift的多种抽象机制的建模意义

00:01:04.965 --> 00:01:07.668
值或引用语义是否恰当？

00:01:08.235 --> 00:01:10.871
这个抽象需要有多动态？

00:01:12.306 --> 00:01:14.842
嗯 今天我和Arnold也想使你们

00:01:15.042 --> 00:01:17.444
用性能来缩小设计空间

00:01:17.611 --> 00:01:21.248
以我的经验来说 考虑性能影响

00:01:21.515 --> 00:01:24.251
总会有一个
更顺畅的方案

00:01:25.519 --> 00:01:27.855
那么 我们主要关注的是性能

00:01:27.921 --> 00:01:29.489
我们会接触点儿建模

00:01:29.656 --> 00:01:32.960
但我们去年做了一些很不错的
演讲 今年我们也会继续努力

00:01:33.026 --> 00:01:35.963
主要内容是在Swift中
为项目建模的强大技巧

00:01:36.063 --> 00:01:37.798
如果你想充分利用本场演讲

00:01:37.865 --> 00:01:40.734
我强烈建议你们至少参加
一场这类演讲

00:01:41.301 --> 00:01:45.005
好了 那么
我们想用性能来缩小设计空间

00:01:45.272 --> 00:01:48.141
嗯 理解
性能影响的最好方式是

00:01:48.208 --> 00:01:50.077
Swift抽象机制的

00:01:50.244 --> 00:01:52.646
理解它们的优先执行

00:01:52.713 --> 00:01:54.414
这就是我们今天要讲的主题

00:01:55.115 --> 00:01:56.984
我们从识别 开始

00:01:57.050 --> 00:01:59.286
不同的维度

00:01:59.353 --> 00:02:02.356
当评估不同的抽象机制选项时

00:01:59.353 --> 00:02:02.356
当评估不同的抽象机制选项时

00:02:02.422 --> 00:02:04.625
其中的每一项 我们都会
演示一些代码

00:02:04.691 --> 00:02:06.493
用结构和类

00:02:06.560 --> 00:02:09.229
深化我们的心智模型
所涉及到的总开销

00:02:09.596 --> 00:02:11.365
然后 看看如何应用我们所学的技术

00:02:11.431 --> 00:02:13.600
来清理和加速一些Swift代码

00:02:14.468 --> 00:02:15.969
在演讲的后半场

00:02:16.036 --> 00:02:19.473
我们要评估
面向协议程序设计的性能

00:02:19.540 --> 00:02:22.609
我们要看一下
高级Swift功能的实现

00:02:22.676 --> 00:02:24.478
如协议和泛型

00:02:24.611 --> 00:02:26.113
来更好地理解

00:02:26.180 --> 00:02:28.749
它们的建模和性能影响

00:02:29.049 --> 00:02:32.786
免责声明：我们要看一下
内存表现

00:02:32.853 --> 00:02:34.655
和所生成代码的表现

00:02:34.721 --> 00:02:37.257
当Swift编译和执行
你的代码时

00:02:37.624 --> 00:02:39.626
这些必然要被简化

00:02:39.693 --> 00:02:41.962
但我和Arnold认为
已达到了很好的平衡

00:02:42.029 --> 00:02:44.231
在简易和准确之间

00:02:44.498 --> 00:02:47.501
这是一个很好的推理出
代码的心智模型

00:02:48.068 --> 00:02:50.904
好了 让我们从识别

00:02:50.971 --> 00:02:52.973
性能的不同维度开始吧

00:02:53.440 --> 00:02:57.444
那么 当你在创建一个抽象
并选择一个抽象机制时

00:02:57.611 --> 00:02:59.213
你应该问问自己

00:02:59.279 --> 00:03:02.683
我的实例要分配给堆栈还是堆？

00:02:59.279 --> 00:03:02.683
我的实例要分配给堆栈还是堆？

00:03:03.350 --> 00:03:05.085
当我传递这个实例时

00:03:05.452 --> 00:03:08.288
我要产生多少计算开销？

00:03:08.722 --> 00:03:10.624
当我在这个实例中调用方法时

00:03:10.791 --> 00:03:13.660
要静态还是动态发送？

00:03:14.127 --> 00:03:17.531
当我们想快速地写Swift代码时
我们就要避免

00:03:17.598 --> 00:03:21.335
为我们不能利用的动态
和运行时间付出代价

00:03:22.936 --> 00:03:26.306
我们需要学习何时以及如何在

00:03:26.373 --> 00:03:29.376
这些不同维度之间切换
来获得更好的性能

00:03:30.010 --> 00:03:32.346
好了 我们要讲一下每种维度

00:03:32.412 --> 00:03:34.581
一个一个地讲 从分配开始

00:03:36.183 --> 00:03:39.586
Swift会替你自动分配内存
并取消内存配额

00:03:39.853 --> 00:03:42.122
有些内存会分配给堆栈

00:03:42.589 --> 00:03:44.591
堆栈是一种非常简单的数据结构

00:03:44.658 --> 00:03:48.362
你可以推到栈底 并弹出栈底

00:03:48.629 --> 00:03:51.398
因为你能只添加或移除栈底

00:03:51.465 --> 00:03:54.468
所以我们可以
实现堆栈或实现入栈和出栈

00:03:54.535 --> 00:03:56.770
仅仅通过在栈底放一个指针

00:03:58.172 --> 00:04:00.974
意思是 当我们调用函数时
或不如说

00:03:58.172 --> 00:04:00.974
意思是 当我们调用函数时
或不如说

00:04:01.041 --> 00:04:03.844
我们把栈底的指针叫做堆栈指针

00:04:03.911 --> 00:04:07.848
当我们调用函数时 我们
分配我们需要的内存

00:04:08.015 --> 00:04:11.585
仅仅通过递减堆栈
指针数值获得空间

00:04:12.186 --> 00:04:14.154
当函数执行完毕之后

00:04:14.221 --> 00:04:16.423
我们可以释放内存

00:04:16.589 --> 00:04:19.326
只需要把堆栈指针增加至原来
的数值即可

00:04:19.392 --> 00:04:20.961
调用这个函数之前

00:04:21.228 --> 00:04:24.097
现在 如果你并不那么熟悉
堆栈或堆栈指针

00:04:24.164 --> 00:04:26.033
我想让你从这个幻灯片中看到

00:04:26.099 --> 00:04:28.135
堆栈分配是多么快

00:04:28.368 --> 00:04:30.804
字面意思其实是
分配一个整数的消耗

00:04:31.972 --> 00:04:33.941
那么 这就与堆形成了对比

00:04:34.074 --> 00:04:36.977
堆更动态化 但比堆栈效率低

00:04:37.144 --> 00:04:39.112
堆可以让你实现堆栈
所不能实现的功能

00:04:39.179 --> 00:04:41.481
比如以动态周期分配内存

00:04:42.282 --> 00:04:44.518
但那需要更高级的数据结构

00:04:44.585 --> 00:04:46.386
那么 如果你要在堆上分配内存

00:04:46.453 --> 00:04:48.789
你实际上要搜索堆数据结构

00:04:48.856 --> 00:04:51.391
寻找闲置的
适当大小的内存块

00:04:51.692 --> 00:04:53.660
用完之后要释放内存

00:04:53.727 --> 00:04:57.397
你要重新把那个内存
插入适当的位置

00:04:58.232 --> 00:04:59.867
很明显 这涉及的东西更多

00:04:59.933 --> 00:05:02.536
相对于我们在堆栈中实现的
仅仅分配一个整数来说

00:04:59.933 --> 00:05:02.536
相对于我们在堆栈中实现的
仅仅分配一个整数来说

00:05:02.870 --> 00:05:06.139
但这些不见得是涉及
堆分配的必要的主消耗

00:05:06.540 --> 00:05:10.210
因为同时可以给多线程分配内存

00:05:10.277 --> 00:05:13.013
堆需要使用锁
来保护它的完整性

00:05:13.080 --> 00:05:14.915
或其他同步机制

00:05:15.215 --> 00:05:16.650
这是一个很大的消耗

00:05:17.050 --> 00:05:18.886
如果你今天不注意

00:05:19.086 --> 00:05:21.955
你的程序何时及在何处
在堆上分配内存

00:05:22.022 --> 00:05:23.490
仅仅需要多考虑那么一点儿

00:05:23.557 --> 00:05:26.159
你就能显著地改善性能

00:05:26.527 --> 00:05:27.528
好了

00:05:27.594 --> 00:05:30.931
让我们来看一些代码
看Swift都替我们做了什么

00:05:31.164 --> 00:05:34.334
在这里 我们有一个点结构
有x和y存储属性

00:05:34.668 --> 00:05:36.336
还有draw方法

00:05:37.004 --> 00:05:39.239
我们用(0, 0)构造点

00:05:39.540 --> 00:05:41.909
把point1赋值给point2
复制一下

00:05:42.109 --> 00:05:44.444
并给point2.x赋一个为5的值

00:05:44.645 --> 00:05:47.681
然后 我们要开始
使用point1和point2了

00:05:48.015 --> 00:05:49.383
让我们来看一下

00:05:49.583 --> 00:05:54.354
我们进入这个函数
在我们执行任何代码之前

00:05:54.421 --> 00:05:59.059
我们已为point1和point2
实例在堆栈上分配了一个空间

00:05:59.126 --> 00:06:00.661
因为点是一个结构

00:05:59.126 --> 00:06:00.661
因为点是一个结构

00:06:00.794 --> 00:06:04.431
而x和y属性被存储在堆栈线中

00:06:04.831 --> 00:06:08.135
那么 当我们用x为0
和y为0来构造点时

00:06:08.202 --> 00:06:10.170
我们所要做的就是
初始化那块 内存

00:06:10.237 --> 00:06:12.105
我们已经分配到堆栈上的

00:06:12.573 --> 00:06:14.575
当把point1
赋值给point2时

00:06:14.641 --> 00:06:19.713
我们仅仅是复制了那个点
并初始化了point2的内存 也是

00:06:19.780 --> 00:06:21.748
我们已经分配到堆栈上的内存

00:06:21.882 --> 00:06:25.285
请注意 point1和point2
是独立的实例

00:06:25.352 --> 00:06:28.922
意思就是 当我们给point2.x
赋一个为5的值时

00:06:28.989 --> 00:06:32.259
point2.x是5
但point1.x仍然是0

00:06:32.326 --> 00:06:34.161
这就是值语义

00:06:34.528 --> 00:06:37.598
然后我们继续
使用point1 使用point2

00:06:37.664 --> 00:06:39.733
并完成函数的执行

00:06:40.100 --> 00:06:43.670
那么 我们就可以来释放
point1和point2的内存

00:06:43.737 --> 00:06:46.006
仅仅通过把堆栈指针的值增至

00:06:46.073 --> 00:06:48.775
我们进入函数之前的值

00:06:49.376 --> 00:06:51.778
跟同样的代码比较

00:06:51.879 --> 00:06:54.715
这段代码仅使用了一个点
该点是一个类 而不是一个结构

00:06:56.183 --> 00:06:58.485
好了 那么
我们进入这个函数

00:06:58.552 --> 00:07:01.021
就跟刚才一样
我们给堆栈分配内存

00:06:58.552 --> 00:07:01.021
就跟刚才一样
我们给堆栈分配内存

00:07:01.088 --> 00:07:04.758
但并不实际存储点的属性

00:07:04.825 --> 00:07:08.061
我们要给point1和point2
分配内存引用

00:07:08.629 --> 00:07:11.131
引用我们要分配到堆上的内存

00:07:11.198 --> 00:07:13.600
那么 我们用(0, 0)构造点

00:07:13.667 --> 00:07:16.403
Swift会锁住堆
并搜索数据结构

00:07:16.470 --> 00:07:18.839
寻找适当大小的闲置内存块

00:07:19.006 --> 00:07:22.309
然后 得到内存块后
我们要以x为0 进行初始化

00:07:22.376 --> 00:07:25.279
y为0 并且我们要
把point1引用初始化

00:07:25.412 --> 00:07:28.582
用内存地址
到那个堆上的内存

00:07:29.183 --> 00:07:30.918
请注意 当我们在堆上分配时

00:07:31.018 --> 00:07:35.255
Swift其实是为我们的点类
分配了四个字的存储

00:07:35.489 --> 00:07:39.493
这跟当我们的点是结构时
所分配的两个字形成了对比

00:07:39.660 --> 00:07:43.897
这是因为 现在的点是个类
除了为x和y存储的之外

00:07:43.964 --> 00:07:47.067
我们又分配了两个字
Swift将替我们进行管理

00:07:47.134 --> 00:07:50.904
那些字通过堆图中的
这些蓝色框来指示

00:07:51.505 --> 00:07:53.173
当我们把point1
赋值给point2时

00:07:53.240 --> 00:07:55.209
我们并不是要复制点的内容

00:07:55.275 --> 00:07:56.743
不像当point1是一个结构时所做的那样

00:07:56.810 --> 00:07:58.412
相反 我们要复制引用

00:07:58.512 --> 00:08:00.681
point1和point2其实指的

00:07:58.512 --> 00:08:00.681
point1和point2其实指的

00:08:00.747 --> 00:08:03.116
正是堆上的同一个实例

00:08:03.550 --> 00:08:06.420
意思是 当我们给point2.x
赋一个为5的值时

00:08:06.787 --> 00:08:09.389
point1.x和
point2.x的值都为5

00:08:09.890 --> 00:08:13.894
这就是引用的语义
可导致非计划的状态共享

00:08:14.294 --> 00:08:16.797
然后 我们要使用point1
使用point2

00:08:16.930 --> 00:08:19.433
然后Swift会替我们
释放这个内存

00:08:19.499 --> 00:08:22.870
锁住堆 再分配闲置
内存块到适当的位置

00:08:22.936 --> 00:08:24.438
然后我们就可以出栈了

00:08:25.205 --> 00:08:27.174
好了 我们刚看到了什么？

00:08:27.508 --> 00:08:30.811
我们看到类的构造
比结构的构造消耗更多

00:08:30.878 --> 00:08:33.480
因为类需要堆式分配

00:08:35.414 --> 00:08:38.818
由于类是在堆上分配的
并且有引用语义

00:08:39.253 --> 00:08:43.890
所以类有一些强大的特性
如一致性和间接存储

00:08:44.291 --> 00:08:46.760
但是 如果我们的抽象
不需要这些特性

00:08:47.194 --> 00:08:49.263
我们最好还是用结构

00:08:51.031 --> 00:08:56.703
而且结构不会导致像类那样的
非计划的状态共享

00:08:57.137 --> 00:08:58.338
那么 我们该如何应用

00:08:58.405 --> 00:09:00.574
以便改善某些Swift代码的性能呢

00:08:58.405 --> 00:09:00.574
以便改善某些Swift代码的性能呢

00:09:01.141 --> 00:09:04.344
这儿有个例子
是我正在做的一个消息应用

00:09:05.279 --> 00:09:08.348
那么 从根本上说
这来自视图层

00:09:08.515 --> 00:09:10.417
我的用户们发送一条短信

00:09:10.918 --> 00:09:14.288
在那条短信末端
我想画一个漂亮的气球

00:09:14.521 --> 00:09:17.157
我的makeBalloon函数
是生成这个图片的函数

00:09:17.324 --> 00:09:19.092
并支持不同的配置

00:09:19.159 --> 00:09:21.929
或不同气球的整体配置空间

00:09:21.995 --> 00:09:25.299
比如说 这个气球
我们看到是蓝色的

00:09:25.365 --> 00:09:27.201
方位向右 有个尾部

00:09:27.467 --> 00:09:29.736
我们还支持 比如说 灰色气球

00:09:29.970 --> 00:09:32.072
方位向左 带气泡

00:09:33.340 --> 00:09:37.110
makeBalloon函数执行要快
因为我会 频繁地调用它

00:09:37.177 --> 00:09:39.713
在启动分配和用户滚动过程中

00:09:39.880 --> 00:09:43.116
所以 我添加了这个缓存层
那么 对于任何给定的配置

00:09:43.183 --> 00:09:46.854
我从不两次生成气球图片

00:09:46.920 --> 00:09:49.056
如果我已生成了一次
我只需要从缓存中取出即可

00:09:49.590 --> 00:09:53.927
我的实现方式是通过把颜色、
方位和尾部序列化

00:09:53.994 --> 00:09:55.562
到一个键中 这个键是个字符串

00:09:56.430 --> 00:09:58.599
这里有一些不妥当的地方

00:09:59.233 --> 00:10:02.336
字符串不见得是这个键的
健壮类型

00:09:59.233 --> 00:10:02.336
字符串不见得是这个键的
健壮类型

00:10:03.103 --> 00:10:05.272
我用它来呈现这个配置空间

00:10:05.339 --> 00:10:08.108
但我只是把我的狗的名字
放在了那个键中

00:10:08.542 --> 00:10:10.110
所以 那儿不是很安全

00:10:10.177 --> 00:10:12.546
而且字符串可以代表很多东西

00:10:12.646 --> 00:10:16.617
因为它实际上把它的字符内容
间接地存储在堆上了

00:10:16.683 --> 00:10:19.553
意思是我们每次
调用makeBalloon函数时

00:10:19.620 --> 00:10:22.823
即使我们有缓存命中
我们也会引发堆的分配

00:10:23.690 --> 00:10:24.992
看看是否可以做得更好

00:10:25.259 --> 00:10:28.061
嗯 在Swift中
我们可以只用一个结构

00:10:28.128 --> 00:10:31.365
来表示这个配置空间的
颜色、方位和尾部

00:10:32.099 --> 00:10:35.836
这是一个比字符串更安全地
呈现配置空间的方式

00:10:35.903 --> 00:10:38.372
因为结构在Swift中是头等类型

00:10:38.438 --> 00:10:40.707
可以用作我们字典中的键

00:10:41.608 --> 00:10:43.877
当调用makeBalloon函数时

00:10:44.011 --> 00:10:46.813
如果我们有缓存命中
就不会有内存消耗

00:10:46.947 --> 00:10:49.783
因为构造一个
像属性一这样的结构

00:10:49.850 --> 00:10:53.187
不需要任何堆式分配
可以在堆栈上进行分配

00:10:54.188 --> 00:10:57.090
更安全 也更快

00:10:57.791 --> 00:11:02.563
让我们继续讲下一个
性能维度：引用计数

00:10:57.791 --> 00:11:02.563
让我们继续讲下一个
性能维度：引用计数

00:11:03.730 --> 00:11:07.234
当我们谈堆式分配时
我隐瞒了一个详细信息

00:11:07.301 --> 00:11:10.237
Swift如何了解何时释放

00:11:11.605 --> 00:11:13.207
在堆上分配的内存是安全的呢？

00:11:13.407 --> 00:11:17.177
嗯 答案是Swift会保持一个
引用个数的总计数

00:11:17.344 --> 00:11:20.681
到堆上任何的实例中
并把它存储在实例本身

00:11:20.747 --> 00:11:22.816
当你添加引用或移除引用时

00:11:22.883 --> 00:11:25.485
就会增加或减少引用计数

00:11:25.652 --> 00:11:29.022
当计数为零时
Swift就知道没有指向

00:11:29.089 --> 00:11:32.893
堆上的这个实例的引用
而且释放那个内存很安全

00:11:33.627 --> 00:11:35.529
引用计数的关键点是

00:11:35.596 --> 00:11:38.932
这是个非常频繁的运算
实际上

00:11:38.999 --> 00:11:41.502
比只增加和减少一个整数更复杂

00:11:41.668 --> 00:11:44.171
首先
涉及到成对出现的间接层级

00:11:44.638 --> 00:11:48.175
来执行增加和减少

00:11:48.342 --> 00:11:50.911
但更重要的是
跟堆式分配一样

00:11:51.044 --> 00:11:54.114
需要考虑线程的安全性

00:11:54.214 --> 00:11:57.284
因为引用能被添加或移除到
任何堆实例

00:11:57.351 --> 00:11:59.019
多线程上的 同时

00:11:59.086 --> 00:12:02.422
我们实际上要自动增加
和减少引用计数

00:11:59.086 --> 00:12:02.422
我们实际上要自动增加
和减少引用计数

00:12:02.723 --> 00:12:06.426
由于引用计数运算的频率高
会增加消耗

00:12:07.561 --> 00:12:11.131
让我们返回去看点类和程序

00:12:11.265 --> 00:12:13.800
看看Swift替我们做了什么

00:12:14.902 --> 00:12:19.306
那么 在这里
我们有用来对比的一些伪代码

00:12:19.573 --> 00:12:22.776
我们看到 我们的点获得了
一个附加属性refCount

00:12:23.210 --> 00:12:26.747
并且Swift添加了一对调用
来保留–

00:12:26.813 --> 00:12:29.049
或一个调用保留
和一个调用释放

00:12:29.216 --> 00:12:31.518
保留会自动增加
我们的引用计数

00:12:31.618 --> 00:12:34.188
释放会自动减少
我们的引用计数

00:12:34.288 --> 00:12:36.256
这样 Swift就可以追踪

00:12:36.323 --> 00:12:39.826
堆上的点上有多少激活的引用

00:12:41.428 --> 00:12:43.363
好了 如果我们进行快速追踪

00:12:43.430 --> 00:12:46.466
我们可以看到
在堆上构造点之后

00:12:46.533 --> 00:12:48.402
那个点就被初始化为
引用计数为1

00:12:48.468 --> 00:12:51.471
因为我们有一个
那个点的实时引用

00:12:51.905 --> 00:12:55.742
我们查看整个程序
并把point1赋值给point2

00:12:55.809 --> 00:12:59.046
我们现在就有两个引用了
那么Swift已经添加了一个调用

00:12:59.112 --> 00:13:02.716
来自动增加点实例的引用计数

00:12:59.112 --> 00:13:02.716
来自动增加点实例的引用计数

00:13:02.916 --> 00:13:05.919
继续执行
一旦我们不再使用point1

00:13:07.955 --> 00:13:10.958
Swift会添加一个调用
来自动减少引用计数

00:13:11.024 --> 00:13:13.527
因为point1不再是
一个激活的引用了

00:13:13.594 --> 00:13:14.862
它所关注的

00:13:15.095 --> 00:13:17.064
同样地
一旦我们不再使用point2

00:13:17.130 --> 00:13:20.067
Swift会添加另一个
自动减少引用计数

00:13:20.133 --> 00:13:22.636
在这个点上 没有引用被 使用

00:13:22.703 --> 00:13:24.938
我们的点实例
所以Swift就知道很安全

00:13:25.005 --> 00:13:28.709
会锁住堆
并把那个内存块返回给它

00:13:31.545 --> 00:13:32.913
如果是结构会怎么样呢？

00:13:33.213 --> 00:13:35.582
结构是否涉及引用计数呢？

00:13:35.649 --> 00:13:37.851
嗯 当我们构造点结构时

00:13:38.218 --> 00:13:39.853
不会涉及任何堆式分配

00:13:40.287 --> 00:13:42.489
当我们复制时
也不会涉及任何堆式分配

00:13:42.556 --> 00:13:44.558
每个步骤都不会涉及引用

00:13:44.625 --> 00:13:48.562
所以 点结构没有引用计数

00:13:50.330 --> 00:13:52.533
那更复杂的结构呢？

00:13:53.166 --> 00:13:55.302
在这里 我们有一个
包含文本的标签结构

00:13:55.369 --> 00:13:58.238
类型为字符串类型
字体为UIFont

00:13:58.605 --> 00:14:01.175
我们刚才提到过字符串
实际上是把它的

00:13:58.605 --> 00:14:01.175
我们刚才提到过字符串
实际上是把它的

00:14:01.241 --> 00:14:03.277
字符内容存储在堆上

00:14:03.343 --> 00:14:05.112
所以需要引用计数

00:14:05.179 --> 00:14:06.680
字体是一个类

00:14:06.747 --> 00:14:08.482
也需要引用计数

00:14:08.849 --> 00:14:12.219
我们看一下内存表现
标签有两个引用

00:14:12.386 --> 00:14:15.422
当我们复制它时
我们实际上增加了两个引用

00:14:15.489 --> 00:14:18.492
另一个文本存储
另一个字体

00:14:18.825 --> 00:14:20.294
Swift的追踪方式是

00:14:20.360 --> 00:14:23.630
这些堆式分配是通过
添加保留和释放的调用来实现的

00:14:24.398 --> 00:14:26.767
那么在这里 我们看到
标签实际上会引发

00:14:26.834 --> 00:14:29.937
两倍于那个类应有的引用计数

00:14:31.471 --> 00:14:35.742
好了 总之
由于类是在堆上分配的

00:14:36.310 --> 00:14:38.912
Swift得管理那个
堆式分配的使用期限

00:14:38.979 --> 00:14:40.814
这是通过引用计数实现的

00:14:42.015 --> 00:14:44.117
这并不容易
因为引用计数运算

00:14:44.218 --> 00:14:47.955
相对频繁
另外引用计数具备原子性

00:14:48.989 --> 00:14:50.824
这也是不愿使用结构的
另一个原因

00:14:51.758 --> 00:14:54.094
但是 如果结构包含引用

00:14:54.228 --> 00:14:56.697
也会进行引用计数

00:14:56.763 --> 00:14:58.665
事实上 结构会
进行引用计数

00:14:58.732 --> 00:15:01.502
相应地与它们所包含的
引用数量成比例地

00:14:58.732 --> 00:15:01.502
相应地与它们所包含的
引用数量成比例地

00:15:01.568 --> 00:15:03.537
所以 如果它们有一个
以上的引用

00:15:04.171 --> 00:15:07.007
它们会保留一个类以上的
引用计数

00:15:07.174 --> 00:15:10.077
让我们看看如何
把链应用到另一个示例

00:15:11.311 --> 00:15:13.914
从我那个假设的消息应用中

00:15:14.448 --> 00:15:17.351
那么 我的用户们
不愿意只发送文本消息

00:15:17.417 --> 00:15:20.521
他们还想发送附件 如图片

00:15:20.821 --> 00:15:24.791
那么 这个结构附件
在应用中是一个模型对象

00:15:24.858 --> 00:15:26.460
有fileURL属性

00:15:26.527 --> 00:15:30.063
即在磁盘上存储
这个附件的数据路径

00:15:30.430 --> 00:15:33.700
有一个通用的唯一标识符
是一个唯一的、随机生成的标识符

00:15:33.867 --> 00:15:35.802
这样 我们就可以
识别这个附件了

00:15:35.869 --> 00:15:38.272
在客户端和服务器端
以及不同的客户设备上

00:15:38.338 --> 00:15:40.307
还有一个mimeType 用于存储

00:15:41.208 --> 00:15:45.546
这个附件所使用的数据类型
如JPG、PNG或GIF

00:15:46.113 --> 00:15:47.381
很可能的情况是 唯一重要的代码

00:15:47.447 --> 00:15:50.284
这个示例中
可能导致初始化失败 会检测

00:15:50.417 --> 00:15:52.686
mimeType是否为
应用所支持的文件类型中的一个

00:15:52.753 --> 00:15:55.189
因为我并不支持
所有mimeType

00:15:55.255 --> 00:15:57.925
如果不支持 我们就会失败

00:15:57.991 --> 00:16:01.762
反之 我们会初始化fileURL、
唯一标识和mimeType

00:15:57.991 --> 00:16:01.762
反之 我们会初始化fileURL、
唯一标识和mimeType

00:16:03.463 --> 00:16:05.799
那么 我们注意到有很多引用计数

00:16:06.800 --> 00:16:09.703
并且 如果我们看一下
这个结构的内存表现

00:16:09.770 --> 00:16:12.439
属性引发了引用计数

00:16:12.506 --> 00:16:14.408
当传递属性时

00:16:14.474 --> 00:16:17.344
由于在每个结构的底层
有进行堆式分配的引用

00:16:18.345 --> 00:16:19.313
我们可以做得更好

00:16:20.013 --> 00:16:21.915
首先 就像我们刚看到的

00:16:22.716 --> 00:16:24.885
唯一标识是一个
意义明确的概念

00:16:25.052 --> 00:16:29.523
它是一个随机生成的标识符
有128个位元

00:16:30.123 --> 00:16:33.393
而且我们绝对不想让你随意
在唯一标识字段放入任何东西

00:16:33.527 --> 00:16:35.495
且作为一个字符串
其实你是可放入任何东西的

00:16:35.662 --> 00:16:38.832
嗯 今年 Foundation
增加了一个新的数值类型

00:16:39.499 --> 00:16:44.004
为唯一标识 这很棒 因为它会
存储那128个位元

00:16:44.271 --> 00:16:46.039
直接在结构线中

00:16:46.273 --> 00:16:47.708
让我们用一下那个新数值类型

00:16:48.242 --> 00:16:50.177
它要实现的是

00:16:50.244 --> 00:16:51.879
移除所有引用计数所带来的消耗

00:16:51.945 --> 00:16:54.014
为唯一标识字段
就是那个字符串

00:16:54.314 --> 00:16:55.949
我们将获得更好的安全性

00:16:56.016 --> 00:16:58.819
因为我们不能在这儿随意
放东西了 我们只能放唯一标识

00:16:58.986 --> 00:16:59.953
棒极了

00:17:00.287 --> 00:17:01.555
让我们看一下文件类型

00:17:02.389 --> 00:17:04.825
以及如何实现文件类型检测

00:17:05.092 --> 00:17:08.628
今天 我实际上只支持了
文件类型的一个闭集

00:17:08.962 --> 00:17:11.131
JPG、PNG、GIF

00:17:11.999 --> 00:17:14.134
我们都知道
Swift有强大的抽象体系

00:17:14.201 --> 00:17:17.905
来表现固定集合 这是个枚举

00:17:18.271 --> 00:17:19.839
我要把那个switch语句

00:17:19.906 --> 00:17:21.708
放到可能导致
初始化失败的程序中

00:17:21.842 --> 00:17:26.480
并把那些mimeType
映射到枚举中合适的案例中

00:17:26.646 --> 00:17:29.883
那么 现在 我得到了
更多的mimeType枚举值

00:17:30.083 --> 00:17:33.220
而且我还获得了更优化的性能
因为我不需要 存储

00:17:33.287 --> 00:17:34.988
在堆上间接地
这些不同的案例

00:17:35.589 --> 00:17:37.958
Swift实际上有一个
非常简洁、有效的方式

00:17:38.025 --> 00:17:39.393
来写这段代码

00:17:39.560 --> 00:17:42.362
就是使用
由原始字符串值支持的枚举

00:17:42.529 --> 00:17:45.199
所以 这就是有效的代码
完全一样

00:17:45.299 --> 00:17:47.034
除了更强大之外

00:17:47.134 --> 00:17:50.204
有同样的性能特征
但写起来更便利

00:17:50.404 --> 00:17:52.272
我们现在看一下附件结构

00:17:52.573 --> 00:17:53.674
该方式使类型更安全

00:17:53.740 --> 00:17:56.109
我们得到了类型非常强大的
唯一标识和mimeType字段

00:17:56.176 --> 00:17:58.812
我们也不用做那么多引用计数

00:17:58.879 --> 00:18:02.783
因为唯一标识和mimeType
不需要进行引用计数或堆式分配

00:17:58.879 --> 00:18:02.783
因为唯一标识和mimeType
不需要进行引用计数或堆式分配

00:18:03.884 --> 00:18:07.354
好了 让我们继续看
最后一个性能维度

00:18:07.588 --> 00:18:08.655
方法调度

00:18:09.690 --> 00:18:11.825
在运行过程中
当调用一个方法时

00:18:12.092 --> 00:18:14.428
Swift需要执行正确的实现

00:18:15.195 --> 00:18:18.732
是否能在编译时确定
要执行的实现

00:18:18.799 --> 00:18:20.367
这就是著名的静态调度

00:18:20.434 --> 00:18:21.935
在运行过程中 我们只能直接跳到

00:18:22.002 --> 00:18:23.904
正确的实现

00:18:24.171 --> 00:18:25.339
这很酷

00:18:25.405 --> 00:18:28.876
因为编译器实际上可以看到

00:18:28.942 --> 00:18:31.078
要执行哪些实现

00:18:31.245 --> 00:18:32.446
并且也可以

00:18:32.513 --> 00:18:36.116
强行优化这个代码
包括一些像内联的东西

00:18:36.750 --> 00:18:38.919
这跟动态调度形成了对比

00:18:39.953 --> 00:18:41.021
动态调度

00:18:41.955 --> 00:18:44.157
在编译时我们不能直接决定

00:18:44.224 --> 00:18:45.726
要执行哪个实现

00:18:45.859 --> 00:18:48.795
在运行过程中
我们实际上需要查找实现

00:18:49.763 --> 00:18:50.697
然后跳到那儿

00:18:50.764 --> 00:18:52.533
那么 对于实现本身 动态调度

00:18:52.599 --> 00:18:54.902
比静态调度的消耗
并不多

00:18:54.968 --> 00:18:56.470
只有一个间接层级

00:18:56.537 --> 00:18:59.773
没有一个线程同步像我们之前

00:18:59.840 --> 00:19:02.176
引用计数和堆式分配中的那样

00:18:59.840 --> 00:19:02.176
引用计数和堆式分配中的那样

00:19:02.476 --> 00:19:06.213
但是这个动态调度阻塞了
编译器的可见性

00:19:06.280 --> 00:19:09.883
所以 编译器可以
实现所有很酷的优化

00:19:09.950 --> 00:19:11.251
为静态调度

00:19:11.318 --> 00:19:15.088
动态调度
编译器不能推理通过

00:19:16.123 --> 00:19:18.625
那么 我提到了内联
什么是内联？

00:19:19.092 --> 00:19:22.663
嗯 让我们返回去看
我们熟悉的点结构

00:19:23.330 --> 00:19:25.599
有一个x和y
还有一个draw方法

00:19:25.666 --> 00:19:27.868
我还添加了这个
drawAPoint方法

00:19:28.202 --> 00:19:31.471
drawAPoint方法在点中应用
只调用draw

00:19:31.705 --> 00:19:32.706
很有意思

00:19:32.773 --> 00:19:35.609
我的程序用(0,0)构造了一个点

00:19:35.676 --> 00:19:37.411
并把那个点传给drawAPoint

00:19:37.644 --> 00:19:41.181
嗯 drawAPoint函数
和point.draw方法

00:19:41.448 --> 00:19:42.983
都是静态调度

00:19:45.185 --> 00:19:47.120
意思就是编译器完全了解

00:19:47.187 --> 00:19:49.556
要执行哪些实现

00:19:49.656 --> 00:19:52.793
所以它实际上只要
把drawAPoint调度

00:19:53.193 --> 00:19:56.930
替换为drawAPoint的实现

00:19:57.431 --> 00:19:59.900
然后再把point.draw方法

00:20:00.000 --> 00:20:01.602
因为它是个静态调度

00:20:01.668 --> 00:20:04.071
替换为实际的 实现即可

00:20:04.137 --> 00:20:05.305
point.draw的

00:20:05.539 --> 00:20:08.342
那么 当我们在运行过程中
执行代码时

00:20:08.408 --> 00:20:09.877
我们可以只构造点

00:20:11.411 --> 00:20:13.547
然后运行实现 就完成了

00:20:13.714 --> 00:20:17.818
我们不需要那两个静态调度

00:20:17.885 --> 00:20:20.988
以及设置和销毁
相关联的堆栈调用

00:20:21.121 --> 00:20:22.322
这很酷

00:20:22.389 --> 00:20:25.626
这就回答了为什么是静态调度
以及静态调度

00:20:25.692 --> 00:20:27.528
比动态调度要快多少的问题

00:20:28.996 --> 00:20:32.299
然而 就像单一静态调度
与单一动态调度形成对比一样

00:20:32.366 --> 00:20:35.802
并没有太多不同
但是一个完整的静态调度

00:20:35.869 --> 00:20:38.639
编译器可以看到整个调度

00:20:38.705 --> 00:20:40.440
因此 动态调度链

00:20:40.507 --> 00:20:43.377
要在推理的每一步中被阻塞

00:20:43.443 --> 00:20:44.611
在没有它的较高层级上

00:20:44.678 --> 00:20:46.213
所以编译器要能

00:20:46.280 --> 00:20:48.282
分解静态方法调度链

00:20:48.348 --> 00:20:49.983
就像没有调用栈的

00:20:50.050 --> 00:20:52.553
单一实现

00:20:52.819 --> 00:20:54.154
这很酷

00:20:54.454 --> 00:20:57.558
我们究竟为什么要这个
动态调度呢？

00:20:58.025 --> 00:21:01.061
嗯 原因之一是它可以
启动很强大的东西

00:20:58.025 --> 00:21:01.061
嗯 原因之一是它可以
启动很强大的东西

00:21:01.261 --> 00:21:02.829
比如多态

00:21:03.063 --> 00:21:05.265
我们看一个传统的
面向对象的程序

00:21:05.465 --> 00:21:07.968
有一个可绘制的抽象超类

00:21:08.402 --> 00:21:11.905
我可以定义一个
点子类和线子类

00:21:12.039 --> 00:21:14.541
用自定义实现来覆盖draw

00:21:14.608 --> 00:21:17.711
然后我有个程序
可以多态地

00:21:18.579 --> 00:21:20.581
创建绘制的数组

00:21:20.647 --> 00:21:24.284
可能包含线 可能包含点
可以分别调用draw

00:21:24.952 --> 00:21:26.486
那么是如何实现的呢？

00:21:27.187 --> 00:21:32.059
嗯 因为
可绘制的点和线都是类

00:21:32.125 --> 00:21:35.028
我们可以创建一个数组
大小都一样

00:21:35.095 --> 00:21:37.231
因为我们在数组中
通过引用来存储

00:21:37.798 --> 00:21:40.367
然后
当我们查看每一个数组的时候

00:21:40.467 --> 00:21:41.702
在数组上调用draw

00:21:43.103 --> 00:21:47.474
我们明白或者希望
我们有一些直觉

00:21:47.674 --> 00:21:51.178
为什么编译器
不能在编译时做出决定

00:21:51.245 --> 00:21:53.113
哪个是要执行的正确的实现

00:21:53.380 --> 00:21:57.184
因为这个d.draw可以是个点
可以是条线

00:21:57.284 --> 00:21:58.585
这是不同的代码路径

00:21:58.652 --> 00:22:00.587
那么 如何决定调用哪个呢？

00:21:58.652 --> 00:22:00.587
那么 如何决定调用哪个呢？

00:22:00.654 --> 00:22:03.690
嗯 编译器向类中添加了
另一个字段

00:22:03.790 --> 00:22:06.927
是那个类的信息类型的指针

00:22:06.994 --> 00:22:08.428
存储在静态内存中

00:22:08.729 --> 00:22:10.898
因此 当我们调用draw时

00:22:11.031 --> 00:22:14.768
编译器实际上替我们
生成的是一个对类型的查询

00:22:14.968 --> 00:22:17.004
查找一个虚拟方法表

00:22:17.070 --> 00:22:19.573
在类型和包含
指针的静态内存上

00:22:19.640 --> 00:22:21.475
找到要执行的正确的实现

00:22:21.742 --> 00:22:23.744
所以
如果我们修改了这个d.draw

00:22:23.877 --> 00:22:25.412
编译器替我们做的是

00:22:25.812 --> 00:22:28.549
我们看到
实际是查询虚拟方法表

00:22:28.615 --> 00:22:30.984
找到要执行的正确的draw实现

00:22:31.151 --> 00:22:34.488
然后把那个实际的实例
作为隐藏的自-参数传过来

00:22:36.857 --> 00:22:38.892
好了 那么 我们看到了什么？

00:22:40.327 --> 00:22:43.897
嗯 类默认动态地
调度它们的方法

00:22:44.498 --> 00:22:46.633
这对于它本身并没有什么不同

00:22:46.767 --> 00:22:50.704
但是如果形成方法链或其他形式
可以防止

00:22:51.572 --> 00:22:54.208
内联优化 并且可以累计

00:22:54.408 --> 00:22:57.444
但是 并不是所有类
都需要动态调度

00:22:57.578 --> 00:23:00.147
如果你从未打算
给一个类创建子类

00:22:57.578 --> 00:23:00.147
如果你从未打算
给一个类创建子类

00:23:00.447 --> 00:23:03.851
你可以把它标记为最终类
传给随后的同事

00:23:03.917 --> 00:23:06.687
和未来的你 那是你的打算

00:23:07.054 --> 00:23:08.355
编译器会注意到这一点

00:23:08.422 --> 00:23:10.757
并动态地调度这些方法

00:23:11.024 --> 00:23:13.927
此外 如果编译器
可以推理和证明

00:23:13.994 --> 00:23:16.663
你从不打算在应用中
给类建立子类

00:23:16.730 --> 00:23:19.233
它将适时地替你
把那些动态调度返回

00:23:19.299 --> 00:23:20.934
到静态调度

00:23:21.235 --> 00:23:23.871
如果你想了解更多实现方式

00:23:24.071 --> 00:23:27.674
请参考去年关于
优化Swift性能的演讲

00:23:29.510 --> 00:23:31.078
好了 我们讲到哪儿了？

00:23:33.013 --> 00:23:35.883
在演讲的上半场
我想让你了解的是

00:23:36.016 --> 00:23:37.584
问你自己的这些问题

00:23:37.951 --> 00:23:39.953
无论何时 当你读和写Swift代码时

00:23:40.554 --> 00:23:42.222
你都应该看和思考

00:23:42.322 --> 00:23:44.625
“这个实例要在堆栈中
还是在堆中分配？”

00:23:45.559 --> 00:23:47.027
当我传递这个实例时

00:23:47.160 --> 00:23:49.429
我要引发多少引用计算？

00:23:49.863 --> 00:23:51.498
当我在这个实例中调用方法时

00:23:51.598 --> 00:23:53.967
是动态调度还是静态调度？

00:23:54.334 --> 00:23:56.136
如果我们不需要执行动态调度

00:23:56.236 --> 00:23:58.038
会影响我们的性能

00:23:58.705 --> 00:24:02.109
如果你是Swift新手
或是使用代码库

00:23:58.705 --> 00:24:02.109
如果你是Swift新手
或是使用代码库

00:24:02.176 --> 00:24:04.411
从objective C
移植到Swift

00:24:04.478 --> 00:24:08.182
你很可能会更好地利用结构

00:24:08.315 --> 00:24:12.786
就像我们今天在例子中所看到的
为什么我使用结构而不是字符串

00:24:14.721 --> 00:24:16.356
有一个问题是

00:24:16.690 --> 00:24:19.526
“如何用结构写多态代码？”

00:24:19.593 --> 00:24:20.794
我们还没有讲

00:24:21.428 --> 00:24:23.297
嗯 答案是面向协议程序设计

00:24:23.564 --> 00:24:26.867
现在让我们欢迎Arnold
来到台上给大家讲解

00:24:31.638 --> 00:24:32.472
去吧

00:24:32.940 --> 00:24:33.774
谢谢Kyle

00:24:34.675 --> 00:24:36.210
大家好 我叫Arnold

00:24:37.010 --> 00:24:39.112
让我们一起来看一下

00:24:39.246 --> 00:24:42.716
协议类型和通用代码的实现

00:24:43.183 --> 00:24:45.352
先讲协议类型
我们要看如何

00:24:45.485 --> 00:24:49.823
存储和复制协议类型的变量
以及方法调度的运作

00:24:51.525 --> 00:24:53.627
让我们再回到我们的应用中

00:24:53.694 --> 00:24:56.463
这次 我们要用
协议类型来实现

00:24:57.297 --> 00:24:59.833
这次我们不再用可绘制的抽象基类

00:25:00.133 --> 00:25:04.304
我们要用声明了draw方法的
可绘制协议

00:25:05.172 --> 00:25:08.141
并且我们有数值类型的点结构

00:25:08.442 --> 00:25:11.278
和遵循协议的线结构

00:25:12.513 --> 00:25:16.750
请注意 我们还有一个
遵循协议的SharedLine类

00:25:17.351 --> 00:25:20.621
然而 我们决定不再让
由于非计划共享

00:25:20.754 --> 00:25:24.458
而使类所具有的引用语义

00:25:24.525 --> 00:25:26.426
出现 让我们停止它

00:25:30.163 --> 00:25:32.032
我们程序仍然是多态的

00:25:32.499 --> 00:25:38.939
我们可以
存储点类型和线类型的值

00:25:39.339 --> 00:25:41.708
在可绘制的协议类型数组中

00:25:42.142 --> 00:25:45.279
然而 跟以前相比
有一个不同点

00:25:47.047 --> 00:25:49.449
请注意
我们的线数值类型结构

00:25:49.716 --> 00:25:53.787
和点结构并不共享一个
共同的继承关系

00:25:55.189 --> 00:25:58.825
做V-表调度所必须的
就是Kyle刚展示给我们的机制

00:25:59.359 --> 00:26:03.163
那么 Swift是如何
调度正确的方法的呢？

00:25:59.359 --> 00:26:03.163
那么 Swift是如何
调度正确的方法的呢？

00:26:03.997 --> 00:26:06.066
在这个例子中
是通过彻底审查数组实现的

00:26:07.434 --> 00:26:10.938
这个问题的答案是
一个基于表的机制

00:26:11.104 --> 00:26:12.739
叫协议证明表

00:26:13.473 --> 00:26:16.043
每种类型都有一张表

00:26:16.410 --> 00:26:19.379
会在你的应用中实现协议

00:26:20.347 --> 00:26:22.149
并且表中的条目

00:26:22.549 --> 00:26:25.552
会链接到类型中的一个实现

00:26:27.921 --> 00:26:30.824
好了 那么 现在我们了解
如何找到那个方法了

00:26:31.491 --> 00:26:33.227
但是仍然有个问题

00:26:33.393 --> 00:26:37.364
“如何把元素从数组中拿到表中？”

00:26:38.232 --> 00:26:39.466
还有另一个问题

00:26:40.467 --> 00:26:44.137
请注意 我们现在有
数值类型的线和点

00:26:44.905 --> 00:26:47.241
线需要四个字

00:26:48.642 --> 00:26:50.143
点需要两个字

00:26:50.577 --> 00:26:52.179
它们的大小不一样

00:26:52.746 --> 00:26:56.283
但数组需要
一致地存储元素

00:26:56.416 --> 00:26:59.620
在数组中以固定的偏移量
那是如何实现的呢？

00:27:01.889 --> 00:27:06.026
这个问题的答案是
Swift使用一个特殊存储布局

00:27:06.360 --> 00:27:08.262
叫存在容器

00:27:09.863 --> 00:27:10.831
里边有什么呢？

00:27:13.200 --> 00:27:16.470
存在容器内的前三个字

00:27:16.870 --> 00:27:19.039
是留给valueBuffer的

00:27:20.574 --> 00:27:24.645
小类型 比如我们的点类型
只需要两个字

00:27:24.711 --> 00:27:26.580
刚好能放进valueBuffer中

00:27:26.680 --> 00:27:30.050
现在 你可能会说
“等一下 那线呢？

00:27:30.350 --> 00:27:32.786
它需要四个字
我们该把它放哪儿去？”

00:27:33.720 --> 00:27:37.324
嗯 在这种情况下
Swift会在堆上分配内存

00:27:38.058 --> 00:27:41.628
并把值存入内存 而且会
给那个内存存一个指针

00:27:42.996 --> 00:27:45.666
在存在容器中

00:27:46.500 --> 00:27:50.003
现在 你看到了
点和线之间的不同点

00:27:50.204 --> 00:27:53.674
因此 存在容器无论如何
得管理这个不同点

00:27:53.907 --> 00:27:55.075
那么该如何实现呢？

00:27:56.543 --> 00:28:00.948
嗯 答案是 还是
基于表的机制

00:27:56.543 --> 00:28:00.948
嗯 答案是 还是
基于表的机制

00:28:01.348 --> 00:28:04.017
在这个示例中
我们叫它值证明表

00:28:05.152 --> 00:28:09.690
值证明表会管理值的有效期

00:28:10.224 --> 00:28:12.960
在程序中
每种类型都有一张表

00:28:14.228 --> 00:28:17.264
现在 让我们来看一下
局部变量的有效期

00:28:17.331 --> 00:28:19.533
看这个表是如何运作的

00:28:20.334 --> 00:28:24.071
那么 在协议类型的
局部变量的有效期的开始

00:28:24.137 --> 00:28:27.608
Swift在那个表内部
调用了分配函数

00:28:28.575 --> 00:28:32.880
在这个函数中 因为这个例子
有一个线值证明表

00:28:32.980 --> 00:28:36.016
我们将在堆上分配内存并
给该内存存一个指针

00:28:36.083 --> 00:28:38.519
存在容器的valueBuffer内

00:28:39.853 --> 00:28:42.322
下一步 Swift要把复制

00:28:42.689 --> 00:28:44.658
值从赋值源代码中

00:28:44.725 --> 00:28:46.593
初始化局部变量的

00:28:46.727 --> 00:28:48.962
到存在容器中

00:28:49.263 --> 00:28:50.564
我们在这里有一个线

00:28:51.198 --> 00:28:54.368
所以值证明表的复制条目

00:28:54.601 --> 00:28:58.071
会做出正确的判断并把它
复制到valueBuffer中

00:28:58.972 --> 00:29:00.140
在堆中分配的

00:28:58.972 --> 00:29:00.140
在堆中分配的

00:29:00.941 --> 00:29:03.076
好了 程序继续

00:29:03.610 --> 00:29:06.480
我们现在是在局部变量
有效期的最后阶段

00:29:06.547 --> 00:29:10.551
Swift会调用值证明
表的破坏条目

00:29:10.784 --> 00:29:14.388
这将递减可能包含在类型中的

00:29:14.454 --> 00:29:16.123
值的引用计数

00:29:16.924 --> 00:29:19.793
线并没有任何引用计数
所以这里没什么需要注意的

00:29:20.093 --> 00:29:21.261
然后 在最后

00:29:21.562 --> 00:29:24.431
Swift会调用表中的
解除分配函数

00:29:24.598 --> 00:29:26.767
再说一次
我们有一个线的值证明表

00:29:26.834 --> 00:29:31.238
这将释放
在堆上为值分配的内存

00:29:32.439 --> 00:29:34.808
好了 那么 我们已经看到了

00:29:34.975 --> 00:29:38.679
Swift处理不同种类的值的一般性机制

00:29:38.979 --> 00:29:41.415
但无论如何
它仍需要进入这些表 对吧？

00:29:42.883 --> 00:29:44.952
嗯 答案很明显

00:29:45.419 --> 00:29:48.255
值证明表的下一条
是一个引用

00:29:48.722 --> 00:29:50.958
在存在容器中对值证明表的

00:29:51.258 --> 00:29:52.526
一个引用

00:29:53.627 --> 00:29:56.864
最后
如何进入协议证明表呢？

00:29:56.930 --> 00:30:00.968
嗯 它是 再说一次
在存在容器中进行引用的

00:29:56.930 --> 00:30:00.968
嗯 它是 再说一次
在存在容器中进行引用的

00:30:02.035 --> 00:30:03.370
我们已经看到那个机制

00:30:03.770 --> 00:30:10.611
关于Swift是如何管理
协议类型的值

00:30:10.944 --> 00:30:13.847
让我们来看个例子

00:30:13.914 --> 00:30:15.883
看看运行中的存在容器

00:30:18.118 --> 00:30:22.689
在这个例子中 我们有一个函数

00:30:22.756 --> 00:30:25.759
把协议类型参数当做局部参数

00:30:26.593 --> 00:30:28.795
并在局部参数上执行draw方法

00:30:29.396 --> 00:30:31.632
然后 我们的程序会创建一个
局部变量

00:30:32.099 --> 00:30:36.837
可绘制的协议类型的
并用点对其进行初始化

00:30:37.571 --> 00:30:40.007
然后把这个局部变量传给

00:30:40.374 --> 00:30:43.243
一个drawACopy函数调用
作为它的参数

00:30:44.678 --> 00:30:48.916
为了显示Swift编译器
为我们生成的代码

00:30:49.650 --> 00:30:54.388
在这个例子中
我将使用Swift作为伪代码注释

00:30:54.621 --> 00:30:57.925
那么 对于存在容器而言
我有一个结构

00:30:58.358 --> 00:31:02.829
存储valueBuffer的三个字

00:30:58.358 --> 00:31:02.829
存储valueBuffer的三个字

00:31:03.030 --> 00:31:05.899
还有一个值证明表
和协议证明表的引用

00:31:07.501 --> 00:31:10.237
当drawACopy函数调用执行时

00:31:10.838 --> 00:31:16.476
它会接收实参并把它传给函数

00:31:17.211 --> 00:31:19.012
在生成的代码中我们看到

00:31:19.179 --> 00:31:21.515
Swift把存在容器传给了

00:31:21.582 --> 00:31:23.450
实参的函数

00:31:27.087 --> 00:31:28.956
当函数开始执行时

00:31:29.022 --> 00:31:32.593
函数为那个形参
创建了一个局部变量

00:31:33.894 --> 00:31:35.262
并给它赋了一个实参

00:31:36.330 --> 00:31:38.031
在所生成的代码中

00:31:40.701 --> 00:31:44.805
Swift将在堆上分配
一个存在容器

00:31:46.139 --> 00:31:50.010
下一步 它将
读取值证明表和协议证明表

00:31:50.344 --> 00:31:52.779
从实参存在容器中

00:31:53.614 --> 00:31:57.484
并在局部实参容器中
对字段进行初始化

00:31:59.686 --> 00:32:02.456
下一步 它将调用值证明函数

00:31:59.686 --> 00:32:02.456
下一步 它将调用值证明函数

00:32:02.556 --> 00:32:05.859
分配缓冲区 如果必要的话
还会复制值

00:32:06.927 --> 00:32:08.896
在这个例子中 我们传了一个点

00:32:09.263 --> 00:32:12.099
所以就不需要
任何动态堆式分配了

00:32:12.933 --> 00:32:16.403
这个函数只是从实参中把值复制

00:32:17.171 --> 00:32:20.073
到局部存在容器的
valueBuffer中

00:32:20.841 --> 00:32:23.911
然而 如果我们传一个线

00:32:24.344 --> 00:32:28.682
这个函数将会分配缓冲区
并在缓冲区中复制值

00:32:31.118 --> 00:32:32.953
下一步执行draw方法

00:32:33.320 --> 00:32:35.989
Swift会从存在容器字段中

00:32:36.356 --> 00:32:38.692
查询协议证明表

00:32:39.426 --> 00:32:43.096
在那个表的固定偏移中
查询draw方法

00:32:43.263 --> 00:32:44.932
并跳到那个实现

00:32:45.365 --> 00:32:46.333
但是稍等一下

00:32:47.835 --> 00:32:50.604
还有另一个值证明调用
就是projectBuffer

00:32:50.671 --> 00:32:51.605
它为什么会在那儿？

00:32:53.373 --> 00:32:57.711
嗯 draw方法把值的地址
当成了它的输入

00:32:59.780 --> 00:33:03.884
请注意 这取决于值是否为

00:32:59.780 --> 00:33:03.884
请注意 这取决于值是否为

00:33:03.951 --> 00:33:06.920
正好能放进内联缓冲区的小值
决定了这个地址是否为

00:33:07.154 --> 00:33:08.655
存在容器的开始

00:33:09.389 --> 00:33:14.061
或若我们有一个大值不适合放进
内联valueBuffer

00:33:14.361 --> 00:33:17.164
那个地址就是在堆上分配的内存

00:33:17.231 --> 00:33:19.233
的开始

00:33:20.133 --> 00:33:24.004
那么 这个值证明函数
把这个不同点抽象化了

00:33:24.071 --> 00:33:25.405
根据类型

00:33:26.907 --> 00:33:30.143
然后执行draw方法 执行完毕

00:33:30.310 --> 00:33:32.112
现在 我们是在函数的末端

00:33:32.179 --> 00:33:36.183
意思就是 为形参创建的
局部变量超出了适用范围

00:33:37.150 --> 00:33:38.519
所以Swift调用

00:33:38.585 --> 00:33:41.421
一个值证明函数来破坏值

00:33:41.722 --> 00:33:43.624
这将递减引用计数

00:33:44.157 --> 00:33:45.959
如果值中有引用的话

00:33:46.026 --> 00:33:48.996
并且如果分配了缓冲区
会释放缓冲区

00:33:50.063 --> 00:33:56.203
函数执行完毕 移除了堆栈

00:33:56.270 --> 00:33:59.106
也移除了在堆栈上创建的

00:33:59.173 --> 00:34:00.507
局部存在容器

00:33:59.173 --> 00:34:00.507
局部存在容器

00:34:01.942 --> 00:34:05.078
好了 这个工作量很大

00:34:06.113 --> 00:34:06.980
是吧？

00:34:08.047 --> 00:34:10.583
我想告诉你们的是

00:34:10.717 --> 00:34:14.955
这项工作是使结合的值类型

00:34:15.054 --> 00:34:19.359
如结构线和结构点还有协议

00:34:19.659 --> 00:34:22.362
获得动态行为、动态多态性

00:34:22.429 --> 00:34:25.032
我们可以 存储一条线和一个点

00:34:25.465 --> 00:34:29.536
在可绘制的协议类型的数组中

00:34:31.271 --> 00:34:34.574
如果你需要这个多态性
一切都值得你付出

00:34:35.442 --> 00:34:38.612
跟使用类相比

00:34:38.978 --> 00:34:41.315
就像Kyle在示例中
给我们演示的一样

00:34:41.614 --> 00:34:43.684
因为类也要查询V-表

00:34:43.817 --> 00:34:49.456
并且类还有附加的引用计数

00:34:50.924 --> 00:34:55.762
好了 我们已经了解
如何复制局部变量

00:34:55.963 --> 00:34:59.233
以及方法调度
如何处理协议类型值

00:35:00.801 --> 00:35:02.402
让我们看一下存储属性

00:35:04.605 --> 00:35:06.773
那么在这个例子中
我们有个对儿

00:35:07.107 --> 00:35:10.410
包含两个存储属性
第一个和第二个属性

00:35:11.545 --> 00:35:13.580
即可绘制的协议类型的

00:35:15.215 --> 00:35:18.418
Swift是如何存储
这两个存储属性的呢？

00:35:19.353 --> 00:35:23.357
嗯 是封闭结构的内联

00:35:24.124 --> 00:35:27.828
那么 我们看一下-
当我们分配一个对儿时

00:35:28.161 --> 00:35:31.498
Swift将存储这两个
非常必要的存在容器

00:35:31.899 --> 00:35:35.502
对于在封闭结构内联中存储
那个对儿来说

00:35:36.770 --> 00:35:39.540
然后 我们的程序就开始执行
并初始化 这个对儿

00:35:39.606 --> 00:35:42.309
线和点
正如我们之前所看到的

00:35:42.709 --> 00:35:45.179
对于线
我们将在堆上分配一个缓冲区

00:35:45.279 --> 00:35:48.482
把点放到内联valueBuffer
并把它内联存储

00:35:48.849 --> 00:35:50.884
到存在容器中

00:35:52.553 --> 00:35:56.390
现在 这种呈现允许
在后面的程序中

00:35:56.823 --> 00:35:58.225
存储一个不同类型的值

00:35:58.492 --> 00:36:01.495
那么 程序继续执行
把线存入第二个元素

00:35:58.492 --> 00:36:01.495
那么 程序继续执行
把线存入第二个元素

00:36:01.628 --> 00:36:04.665
没什么问题
但我们现在有两个堆式分配了

00:36:05.499 --> 00:36:07.234
好的 两个堆式分配

00:36:07.701 --> 00:36:10.003
嗯 让我们用另外一个程序

00:36:10.370 --> 00:36:12.472
来说明堆式分配的消耗

00:36:13.807 --> 00:36:15.809
那么 再一次 我们创建一个线

00:36:16.944 --> 00:36:20.514
然后创建一个对儿
并用线对这个对儿进行初始化

00:36:21.014 --> 00:36:23.817
那么 我们有一个、
两个堆式分配

00:36:24.251 --> 00:36:27.087
然后我们再一次复制那个对儿

00:36:27.588 --> 00:36:31.058
堆栈中有两个存在容器
然后有两个堆式分配

00:36:32.159 --> 00:36:33.160
现在 你可能会说

00:36:33.427 --> 00:36:35.929
“Kyle刚告诉我们说
堆式分配的消耗很大”

00:36:36.296 --> 00:36:37.731
四个堆式分配？

00:36:38.131 --> 00:36:40.634
嗯 我们能做点什么吗？

00:36:42.736 --> 00:36:43.737
嗯

00:36:45.339 --> 00:36:49.943
请记住
存在容器能容纳三个字

00:36:50.477 --> 00:36:52.713
可以把引用放进

00:36:52.779 --> 00:36:55.849
那三个字中
因为引用基本上是一个字

00:36:56.416 --> 00:37:00.454
那么
如果我们用类代替线来实现

00:36:56.416 --> 00:37:00.454
那么
如果我们用类代替线来实现

00:37:02.322 --> 00:37:05.659
并且类是个引用语义
因此它们

00:37:05.959 --> 00:37:09.296
通过引用存储 该引用可放入
valueBuffer中

00:37:11.498 --> 00:37:15.802
当我们把第一个引用复制

00:37:16.203 --> 00:37:19.673
到对儿的第二个字段时
只复制了引用

00:37:20.340 --> 00:37:24.311
我们消耗的只是
附加的引用计数增量

00:37:25.612 --> 00:37:27.314
现在 你可能会说 “等一下

00:37:27.614 --> 00:37:31.118
我们刚才不是听说
引用语义会引发

00:37:31.785 --> 00:37:33.787
非计划的状态共享吗？”

00:37:34.188 --> 00:37:38.825
那么 如果我们
存储到x1字段

00:37:39.226 --> 00:37:42.229
通过对儿的第二个字段

00:37:42.529 --> 00:37:44.498
第一个字段可以观察到变更

00:37:45.199 --> 00:37:47.568
这并不是我们想要的结果

00:37:47.634 --> 00:37:49.203
我们想要的是值语义 对吧？

00:37:49.636 --> 00:37:51.605
嗯 我们能做点什么呢？

00:37:53.073 --> 00:37:56.577
嗯 有一种技术叫复制并写入

00:37:57.311 --> 00:37:59.079
可以帮助我们处理这个问题

00:38:00.113 --> 00:38:04.318
那么 在我们写入类之前

00:38:04.518 --> 00:38:05.986
我们要先查看它的引用计数

00:38:06.887 --> 00:38:07.888
我们已经了解到

00:38:07.955 --> 00:38:11.491
当同一实例有一个以上的
明显引用时

00:38:11.725 --> 00:38:13.794
引用计数将大于一

00:38:13.927 --> 00:38:15.562
二、三、四或五

00:38:15.829 --> 00:38:19.967
如果是这种情况
在我们写入实例之前

00:38:20.200 --> 00:38:23.370
我们先复制实例
然后写入那个副本

00:38:23.437 --> 00:38:25.439
这将削弱状态

00:38:26.740 --> 00:38:30.210
好了 让我们以线为例
看看是如何实现的

00:38:34.715 --> 00:38:38.218
我们不直接在线的内部
实现存储

00:38:38.552 --> 00:38:40.554
创建一个
叫LineStorage的类

00:38:40.888 --> 00:38:43.023
这个类有线结构的所有字段

00:38:43.991 --> 00:38:47.127
然后线结构引用这个存储

00:38:48.295 --> 00:38:50.097
无论何时
当我们要读取值时

00:38:50.230 --> 00:38:53.901
我们只需要
从那个存储内读取值

00:38:54.735 --> 00:38:57.804
然而 当我们想要修改、
改变值时

00:38:58.272 --> 00:39:00.040
我们首先要查看引用计数

00:38:58.272 --> 00:39:00.040
我们首先要查看引用计数

00:39:00.107 --> 00:39:01.341
是否大于一？

00:39:01.808 --> 00:39:05.846
这是Uniquely
Referenced调用要实现的

00:39:06.046 --> 00:39:08.182
它只有一个功能
就是查看引用计数

00:39:08.248 --> 00:39:10.617
是否大于或等于一？

00:39:11.985 --> 00:39:14.188
如果引用计数比一大

00:39:14.688 --> 00:39:15.889
大于一

00:39:16.256 --> 00:39:19.560
就创建一个线存储的副本
并修改这个副本

00:39:21.061 --> 00:39:27.334
好了 那么 我们已经了解
如何结合一个结构和一个类

00:39:28.368 --> 00:39:30.704
使用复制和写入获得间接存储

00:39:30.771 --> 00:39:34.208
让我们再回过来看例子
看看发生了什么

00:39:35.542 --> 00:39:37.611
这次 我们使用间接存储

00:39:38.846 --> 00:39:40.247
我们再创建一个线

00:39:40.647 --> 00:39:43.483
这将在堆上创建一个线存储对象

00:39:43.817 --> 00:39:46.420
然后 我们用那个线
对对儿进行初始化

00:39:46.920 --> 00:39:51.258
这次 只复制线存储的引用

00:39:54.695 --> 00:39:56.263
当我们复制线时

00:40:00.033 --> 00:40:03.804
只会复制引用
引用计数会递增

00:40:03.871 --> 00:40:06.907
这比堆式分配的消耗小多了

00:40:07.140 --> 00:40:08.642
这是个不错的交易

00:40:15.516 --> 00:40:20.787
好了 我们已经了解如何复制和存储
协议类型的变量

00:40:20.888 --> 00:40:23.790
以及方法调度的运作方式

00:40:24.124 --> 00:40:27.227
让我们看一下
这些对于性能的意义

00:40:28.462 --> 00:40:31.431
如果协议类型包含能放进存在容器的
内联valueBuffer中

00:40:31.698 --> 00:40:33.667
的小值

00:40:33.734 --> 00:40:37.171
那么就不存在堆式分配

00:40:38.305 --> 00:40:40.607
如果结构不包含引用

00:40:40.807 --> 00:40:44.011
也就无所谓引用计数了
所以 这真的是一种快速编码

00:40:44.545 --> 00:40:47.014
然而 由于间接

00:40:47.881 --> 00:40:51.451
查询值证明表和协议证明表

00:40:51.718 --> 00:40:56.690
我们得到了完整的动态调度

00:40:57.624 --> 00:41:00.494
这就允许动态的多态行为

00:40:57.624 --> 00:41:00.494
这就允许动态的多态行为

00:41:03.397 --> 00:41:06.934
跟大值比较
大值会引发堆式分配

00:41:07.034 --> 00:41:10.337
无论什么时候初始化
或赋予协议类型的变量

00:41:12.439 --> 00:41:13.941
可能也将引发引用计数

00:41:14.074 --> 00:41:16.643
如果大值结构包含引用的话

00:41:19.713 --> 00:41:21.348
然而 我演示了一种技术

00:41:21.415 --> 00:41:24.685
就是使用
可复制和写入的间接存储

00:41:24.885 --> 00:41:28.255
承担堆式分配的部分消耗

00:41:32.059 --> 00:41:33.794
这适用于消耗较少的引用计数

00:41:35.596 --> 00:41:40.834
请注意 与使用类相比
很有优势

00:41:41.468 --> 00:41:43.370
类还会引发引用计数

00:41:46.106 --> 00:41:48.475
并在初始化时进行分配

00:41:50.277 --> 00:41:51.778
这是笔好交易

00:41:53.747 --> 00:41:58.018
好了 那么 我们回顾一下
简而言之

00:41:58.085 --> 00:42:02.589
协议类型提供
多态的动态形式

00:41:58.085 --> 00:42:02.589
协议类型提供
多态的动态形式

00:42:03.257 --> 00:42:06.760
值类型可以跟协议一起使用

00:42:07.361 --> 00:42:12.566
并可以在协议类型的数组内
存储线和点

00:42:13.400 --> 00:42:16.103
这是通过协议 实现的

00:42:16.170 --> 00:42:19.006
和值证明表以及存在容器

00:42:19.973 --> 00:42:23.844
复制大值会引发堆式分配

00:42:23.911 --> 00:42:26.680
然而 我讲了一种
如何解决这个问题的技巧

00:42:26.747 --> 00:42:30.350
即通过用间接存储
及复制和写入实现结构

00:42:32.586 --> 00:42:36.256
好了 让我们再回到应用中

00:42:36.924 --> 00:42:39.826
那么 在我们的应用中
我们需要draw一个函数

00:42:39.893 --> 00:42:43.030
以协议类型为形参

00:42:43.997 --> 00:42:45.666
然而 我们的使用方式是

00:42:45.966 --> 00:42:48.902
我们要一直在具体类型上使用

00:42:49.536 --> 00:42:51.104
在这里 我们要在线上使用

00:42:52.139 --> 00:42:54.808
稍后 我们会在点上使用

00:42:55.943 --> 00:42:57.010
然后我们会想“嗯

00:42:58.979 --> 00:43:00.581
我们能在此使用通用代码吗？”

00:42:58.979 --> 00:43:00.581
我们能在此使用通用代码吗？”

00:43:01.248 --> 00:43:02.349
嗯 是的 我们能

00:43:02.950 --> 00:43:04.084
让我们看一下

00:43:04.284 --> 00:43:08.589
在演讲的最后
我要谈一下

00:43:08.889 --> 00:43:12.559
通用类型的变量如何存储和复制
以及变量与方法调度的运作方式

00:43:12.926 --> 00:43:17.531
那么 再返回我们的应用
这次 我们要使用通用代码来实现

00:43:17.598 --> 00:43:21.168
DrawACopy方法把一个
泛型参数限制变得可绘制

00:43:22.202 --> 00:43:24.071
程序的其它部分保持不变

00:43:26.507 --> 00:43:31.745
那么 跟协议类型
有什么不同呢？

00:43:33.914 --> 00:43:37.484
通用代码支持多态的
更静态的形式

00:43:37.551 --> 00:43:39.419
也叫做参数多态性

00:43:39.720 --> 00:43:41.455
每种调用情境都有一种类型

00:43:42.322 --> 00:43:45.492
这是什么意思呢？
嗯 让我们看这个例子

00:43:46.994 --> 00:43:48.262
我们有foo函数

00:43:49.229 --> 00:43:52.199
这个函数把泛型参数T限制
变得可绘制

00:43:52.733 --> 00:43:55.435
并把这个参数传给bar函数

00:43:56.236 --> 00:43:58.839
这个函数再一次取走泛型参数T

00:43:59.339 --> 00:44:01.141
然后 我们的程序创建一个点

00:43:59.339 --> 00:44:01.141
然后 我们的程序创建一个点

00:44:01.308 --> 00:44:03.510
并把这个点传给foo函数

00:44:04.344 --> 00:44:06.213
当函数执行时

00:44:07.481 --> 00:44:12.252
Swift会把泛型类型T绑定到

00:44:12.719 --> 00:44:18.125
本次调用中所使用的类型
在这个例子中是点

00:44:19.426 --> 00:44:21.795
当foo函数带着这个绑定执行时

00:44:22.729 --> 00:44:25.966
它会进入bar的函数调用

00:44:27.367 --> 00:44:31.171
局部变量的类型是刚发现的
也就是点

00:44:31.505 --> 00:44:34.541
那么 泛型参数T再次

00:44:34.608 --> 00:44:37.878
在这个调用情境中
通过点类型进行绑定

00:44:38.278 --> 00:44:42.249
我们可以看到 在调用链中
类型随着参数被取而代之

00:44:42.816 --> 00:44:44.151
这正是我们的用意...

00:44:45.385 --> 00:44:48.589
通过更静态的多态形式
或参数化的多态性

00:44:48.689 --> 00:44:51.558
那么 让我们看看Swift
是如何在后台实现的

00:44:53.660 --> 00:44:56.597
让我们再次回到
drawACopy函数

00:44:58.599 --> 00:45:00.400
在这个例子中
我们传递了一个点

00:44:58.599 --> 00:45:00.400
在这个例子中
我们传递了一个点

00:45:04.938 --> 00:45:08.775
就像我们使用协议类型时一样
有一个共享的实现

00:45:10.711 --> 00:45:13.247
这个共享的实现
如果我可以给你展示它的代码

00:45:13.313 --> 00:45:17.050
就像之前展示的协议类型的
代码一样 两者的代码看起来很相似

00:45:18.418 --> 00:45:20.487
可以使用协议和值证明表

00:45:20.554 --> 00:45:24.157
在函数内部执行运算

00:45:26.493 --> 00:45:29.897
然而 因为每种调用情境
都有一个类型

00:45:30.030 --> 00:45:32.533
所以
Swift不会在这里使用存在容器

00:45:34.535 --> 00:45:38.672
相反 它可以传递值证明表

00:45:38.739 --> 00:45:40.607
和协议证明表– 点的

00:45:40.674 --> 00:45:43.710
在这次调用中使用的类型的

00:45:43.777 --> 00:45:45.712
作为函数的附加参数

00:45:47.080 --> 00:45:49.082
因此 在这个例子中
我们看到点和线的

00:45:49.149 --> 00:45:50.651
值证明表被传过去了

00:45:51.218 --> 00:45:53.520
在那个函数的执行过程中

00:45:53.587 --> 00:45:57.858
当我们为参数创建局部变量时

00:45:59.092 --> 00:46:01.328
Swift将使用值证明表

00:45:59.092 --> 00:46:01.328
Swift将使用值证明表

00:46:01.428 --> 00:46:04.598
在堆上分配可能必要的缓冲区

00:46:04.831 --> 00:46:10.170
并根据目的地
执行赋值源代码的副本

00:46:11.138 --> 00:46:15.309
当在局部参数上执行
draw方法时 很相似

00:46:15.375 --> 00:46:18.178
它将使用所传递的协议证明表

00:46:18.512 --> 00:46:21.348
在表中查询
固定偏移的draw方法

00:46:21.415 --> 00:46:22.983
并跳到那个实现

00:46:25.619 --> 00:46:28.822
我刚刚说过了
这里没有存在容器

00:46:29.590 --> 00:46:33.160
那么 Swift是如何
给局部参数

00:46:33.227 --> 00:46:36.330
给为这个参数创建的
局部变量

00:46:36.430 --> 00:46:38.599
分配所需要的内存呢？

00:46:39.867 --> 00:46:44.037
嗯 它在堆栈上
分配一个valueBuffer

00:46:44.104 --> 00:46:46.573
该valueBuffer仍是三个字

00:46:47.040 --> 00:46:50.444
像点这样的小值
会放进valueBuffer

00:46:51.712 --> 00:46:56.950
像线那样的大值
仍然会存在堆上

00:46:57.117 --> 00:47:01.288
并且我们在局部存在内存里
存了一个指示器

00:46:57.117 --> 00:47:01.288
并且我们在局部存在内存里
存了一个指示器

00:47:04.324 --> 00:47:07.628
所有这些都是为了使用值证明表

00:47:09.096 --> 00:47:12.199
现在 你可能会问
“这样会更快吗？这样会更好吗？”

00:47:12.699 --> 00:47:16.970
“我可不可以不只使用协议类型？”

00:47:18.105 --> 00:47:23.043
嗯 多态的静态形式
可以使编译器优化

00:47:23.710 --> 00:47:25.846
叫做泛型特化

00:47:25.913 --> 00:47:26.880
让我们具体看一下

00:47:27.481 --> 00:47:29.449
这是我们的drawACopy函数

00:47:29.516 --> 00:47:33.720
取走泛型参数
我们把一个点传给

00:47:33.787 --> 00:47:35.689
那个函数调用方法

00:47:37.591 --> 00:47:41.428
我们有静态多态
调用时有一种类型

00:47:41.595 --> 00:47:46.500
Swift使用那个类型
在函数中替换泛型参数

00:47:46.567 --> 00:47:50.070
并创建那个类型专用的

00:47:50.337 --> 00:47:51.939
函数的一个版本

00:47:52.739 --> 00:47:55.309
那么 在这里 我们现在有点函数
的drawACopy了

00:47:55.676 --> 00:47:58.712
取走点类型的参数

00:48:01.148 --> 00:48:04.918
函数内部的代码
仍然是那个类型专用的

00:48:06.053 --> 00:48:09.289
就像Kyle给我们的展示的一样
这是非常迅捷的编码

00:48:10.757 --> 00:48:15.963
Swift将给程序中的调用
所使用的每个类型都创建一个版本

00:48:16.029 --> 00:48:19.900
那么 如果我们在点中
调用线上的drawACopy函数

00:48:19.967 --> 00:48:23.770
它将特化并创建
那个函数的两个版本

00:48:24.271 --> 00:48:26.006
现在 你可能会问“等一下

00:48:26.073 --> 00:48:29.109
这可能会大量增加代码量 对吗？”

00:48:30.210 --> 00:48:32.913
但是 由于静态类型信息

00:48:32.980 --> 00:48:37.451
不能使编译器优化

00:48:37.918 --> 00:48:41.021
Swift实际上可能会减少代码量

00:48:41.221 --> 00:48:45.125
那么 比如说
它将内联点函数的drawACopy

00:48:45.425 --> 00:48:48.962
然后进一步优化代码
因为现在有更多的情境了

00:48:49.730 --> 00:48:54.568
因此 那个函数调用
基本上可以为这一条线

00:48:54.635 --> 00:48:58.138
而正如Kyle所说的
这可以进一步减少为

00:48:58.338 --> 00:49:00.374
draw的实现

00:48:58.338 --> 00:49:00.374
draw的实现

00:49:01.141 --> 00:49:04.711
现在 不再引用
点方法的drawACopy了

00:49:04.811 --> 00:49:06.513
编译器也将把它移除

00:49:06.580 --> 00:49:09.683
并在线示例中执行类似的优化

00:49:09.750 --> 00:49:11.752
因此 几乎不太可能发生

00:49:11.852 --> 00:49:15.289
编译器优化会增加代码量

00:49:15.689 --> 00:49:17.858
有可能发生
但不一定是在这种情况下发生

00:49:20.794 --> 00:49:23.463
好的 那么 我们已经了解特化

00:49:23.664 --> 00:49:26.366
但还有一个问题
“何时进行？”

00:49:28.702 --> 00:49:31.371
嗯 让我们看一个小例子

00:49:31.438 --> 00:49:36.243
那么 我们定义了一个点
然后创建了那个点类型的局部变量-

00:49:36.310 --> 00:49:39.513
把它初始化到一个点
然后把那个点传给

00:49:39.680 --> 00:49:43.617
drawACopy函数

00:49:44.184 --> 00:49:47.221
为了特化这个代码 Swift需要

00:49:47.287 --> 00:49:50.123
在这次调用中推断出类型

00:49:51.091 --> 00:49:53.994
它是可以实现的
因为它可以看到那个局部变量

00:49:54.294 --> 00:49:55.896
再返回去看它的初始化

00:49:55.963 --> 00:49:58.665
然后就会看到
它被初始化成了一个点

00:50:01.735 --> 00:50:03.937
Swift还需要有
在特化过程中所使用的类型

00:50:04.137 --> 00:50:07.107
的定义

00:50:07.274 --> 00:50:10.677
和通用函数自身

00:50:10.744 --> 00:50:13.747
这里的情况是这样的
在一个文件中进行了所有定义

00:50:16.116 --> 00:50:19.786
这个文件能在很大程度上
提高整个模块优化

00:50:19.987 --> 00:50:21.655
的优化几率

00:50:22.322 --> 00:50:23.924
让我们看看这是为什么

00:50:26.193 --> 00:50:31.465
比如说
我把点的定义挪到另一个文件中

00:50:32.432 --> 00:50:34.868
如果我们分别编译那两个文件

00:50:36.703 --> 00:50:39.640
当我编译UsePoint文件时

00:50:39.973 --> 00:50:42.476
点的定义就不再可用了

00:50:42.543 --> 00:50:45.212
因为编译器已经
分别编译了那两个文件

00:50:45.646 --> 00:50:47.981
然而 对于整个模块优化

00:50:48.916 --> 00:50:52.519
编译器将把两个文件
作为一个单元一起进行编译

00:50:53.020 --> 00:50:57.491
洞悉点文件的定义

00:50:58.058 --> 00:51:00.093
并进行优化

00:50:58.058 --> 00:51:00.093
并进行优化

00:51:00.727 --> 00:51:04.798
因为这能很大程度地
提高优化几率

00:51:04.865 --> 00:51:08.936
现在 我们在Xcode 8中
启动了默认整体模块优化

00:51:14.842 --> 00:51:17.778
好的 让我们
再返回来看我们的程序

00:51:18.545 --> 00:51:24.418
那么 在我们的程序中
我们有可绘制的协议类型的对儿

00:51:26.420 --> 00:51:29.056
并且 我们再次意识到
要如何使用它

00:51:31.091 --> 00:51:34.094
无论什么时候我们要创建
一个对儿时 我们实际上是想

00:51:34.161 --> 00:51:36.029
创建同一个类型的对儿

00:51:36.163 --> 00:51:39.800
比如一对儿线或一对儿点

00:51:43.537 --> 00:51:48.242
请记住 一对儿线的存储表示

00:51:48.308 --> 00:51:50.043
会消耗两个堆式分配

00:51:52.846 --> 00:51:55.048
当我们看这个程序时

00:51:55.115 --> 00:51:59.520
我们注意到
我们可以在这里使用泛型类型

00:52:00.754 --> 00:52:03.257
如果我们把对儿定义为泛型

00:52:04.324 --> 00:52:08.695
然后那个泛型类型的第一个
和第二个属性有这种泛型类型

00:52:08.762 --> 00:52:10.998
那么 编译器实际上可以强制

00:52:11.365 --> 00:52:15.302
我们只能创建同一个类型的对儿

00:52:16.003 --> 00:52:21.975
此外 我们也不能在后面的程序中
把点存储到一对儿线中

00:52:23.076 --> 00:52:24.711
这的确是我们想要的结果

00:52:25.879 --> 00:52:30.117
但是这样的表示对于性能来说
是好是坏呢？

00:52:30.651 --> 00:52:31.852
让我们看一眼

00:52:34.221 --> 00:52:35.422
那么 在此我们有对儿

00:52:35.489 --> 00:52:38.926
这次 存储属性是泛型类型的

00:52:39.693 --> 00:52:43.230
请记住我刚才说过的
不能在运行过程中改变类型

00:52:45.699 --> 00:52:49.203
对于生成的代码来说 这意味着

00:52:49.269 --> 00:52:53.640
Swift可以分配
闭合类型的存储内联

00:52:54.875 --> 00:52:56.810
那么 当我们创建一对儿线时

00:52:57.945 --> 00:53:02.115
给线分配的内存实际上
将被分配给内联的闭合对儿

00:52:57.945 --> 00:53:02.115
给线分配的内存实际上
将被分配给内联的闭合对儿

00:53:02.916 --> 00:53:05.118
不需要任何额外的堆式分配

00:53:06.486 --> 00:53:07.621
这很酷

00:53:09.890 --> 00:53:15.095
然而 就像我所说的
你不能再向不同类型的值中存储

00:53:15.162 --> 00:53:16.964
那个存储属性了

00:53:17.030 --> 00:53:18.332
但这正是我们想要实现的

00:53:23.170 --> 00:53:26.940
好的 我们已经了解了
非专用代码如何使用

00:53:27.007 --> 00:53:29.042
值证明表和协议证明表

00:53:30.511 --> 00:53:34.381
以及编译器如何
通用函数的指定类型的版本

00:53:34.448 --> 00:53:37.784
特化代码创建

00:53:38.552 --> 00:53:40.554
让我们看一下它的性能

00:53:41.588 --> 00:53:46.994
首先看包含结构的
特化通用代码

00:53:47.794 --> 00:53:49.830
在这种情况下
我们有性能特性

00:53:49.897 --> 00:53:53.100
与使用结构类型相同
因为正如我们所看到的

00:53:53.367 --> 00:53:55.002
从本质上说 通用代码

00:53:55.068 --> 00:53:58.739
看起来就好像是
你按照结构来写的这个函数

00:53:58.906 --> 00:54:02.242
当我们复制结构类型的值时

00:53:58.906 --> 00:54:02.242
当我们复制结构类型的值时

00:54:02.342 --> 00:54:04.178
不需要任何堆式分配

00:54:05.112 --> 00:54:06.280
也不需要引用计数

00:54:06.780 --> 00:54:09.049
如果结构不包含任何引用的话

00:54:10.350 --> 00:54:12.386
而且我们有静态方法调度

00:54:12.519 --> 00:54:14.922
进一步地优化编译器

00:54:14.988 --> 00:54:19.193
并减少运行—执行时间

00:54:21.862 --> 00:54:26.300
如果我们使用类类型
那么跟类类型相比

00:54:26.767 --> 00:54:30.237
我们有跟类相似的特性

00:54:30.304 --> 00:54:33.507
堆式分配、
创建实例和引用计数

00:54:33.574 --> 00:54:35.843
是为了传递值

00:54:35.943 --> 00:54:37.845
并对V-表进行动态调度

00:54:39.046 --> 00:54:43.517
现在让我们看看
包含小值的非特化通用代码

00:54:43.951 --> 00:54:47.321
不必给局部变量进行堆式分配
正如我们所看到的

00:54:47.387 --> 00:54:52.326
因为小值可以放入分配到
堆栈中的valueBuffer

00:54:53.493 --> 00:54:56.897
如果值不包含任何引用
也不会有引用计数

00:54:57.831 --> 00:55:01.235
然而 我们在所有潜在的调用情境中

00:54:57.831 --> 00:55:01.235
然而 我们在所有潜在的调用情境中

00:55:01.969 --> 00:55:04.304
通过使用证明表

00:55:04.571 --> 00:55:08.141
共享一个实现

00:55:13.780 --> 00:55:16.917
好了 今天我们这场研讨会讲了

00:55:17.384 --> 00:55:21.088
结构和类的性能特性

00:55:21.588 --> 00:55:26.093
以及通用代码
和协议类型的运作方式

00:55:26.860 --> 00:55:28.896
我们学到了什么？

00:55:30.464 --> 00:55:32.299
哦 嗯 就这样吧

00:55:32.366 --> 00:55:34.535
我忘了该讲哪个笑话了

00:55:34.601 --> 00:55:39.773
如果我们使用大值和通用代码

00:55:39.873 --> 00:55:41.441
就会引发堆式分配

00:55:41.508 --> 00:55:43.343
但我之前展示过
那个技巧 也就是

00:55:43.410 --> 00:55:47.314
使用间接存储方案

00:55:48.282 --> 00:55:50.350
如果大值包含引用的话

00:55:52.019 --> 00:55:53.353
然后还有引用计数

00:55:53.420 --> 00:55:55.956
然后
我们再一次实现了动态调度

00:55:56.023 --> 00:55:58.659
意思是 我们可以
共享一个通用实现

00:55:59.059 --> 00:56:00.961
在代码中

00:55:59.059 --> 00:56:00.961
在代码中

00:56:03.664 --> 00:56:04.598
好了

00:56:04.665 --> 00:56:07.167
最后让我们看一下简述

00:56:07.601 --> 00:56:09.603
总结

00:56:09.770 --> 00:56:14.208
为应用中的实体
选择合适的抽象

00:56:14.441 --> 00:56:17.878
动态运行时间要尽可能少

00:56:19.112 --> 00:56:22.916
这将启动静态类型的检测
编译器可以确保

00:56:22.983 --> 00:56:28.155
编译过程中程序的正确性 此外

00:56:28.355 --> 00:56:31.291
编译器有更多的信息
来优化代码

00:56:31.391 --> 00:56:32.960
从而得到更迅捷的代码

00:56:33.560 --> 00:56:36.129
那么 如果你可以在程序中
使用值类型 如结构和枚举

00:56:36.296 --> 00:56:39.633
表达实体

00:56:39.967 --> 00:56:42.536
你将得到值语义 这很棒

00:56:42.603 --> 00:56:44.271
不会出现非计划的状态共享

00:56:45.038 --> 00:56:47.140
并且你将获得高度优化的代码

00:56:49.843 --> 00:56:52.179
如果你因为需要 使用类 比如

00:56:52.279 --> 00:56:55.682
一个实体或你正在使用
一个面向对象的框架

00:56:56.350 --> 00:57:00.020
Kyle给我们展示了如何减少
引用计数的消耗的一些技巧

00:56:56.350 --> 00:57:00.020
Kyle给我们展示了如何减少
引用计数的消耗的一些技巧

00:57:02.756 --> 00:57:06.927
如果你的部分程序可以使用
一个更静态的多态形式来表达

00:57:06.994 --> 00:57:10.063
你可以把通用代码
和值类型结合起来

00:57:11.198 --> 00:57:15.202
并获得非常迅捷的代码

00:57:15.435 --> 00:57:18.238
但共享那个代码的实现

00:57:19.506 --> 00:57:23.076
如果你需要动态多态 比如

00:57:23.143 --> 00:57:26.180
在我们的可绘制协议类型
示例的数组中

00:57:26.947 --> 00:57:30.684
你可以把协议类型
和值类型相结合

00:57:30.784 --> 00:57:36.623
得到跟使用类得到的代码
同样迅捷的代码

00:57:38.058 --> 00:57:40.561
但你仍然可以停留在值语义内

00:57:42.896 --> 00:57:45.799
如果你遇到了堆式分配问题

00:57:46.066 --> 00:57:49.770
因为你在协议类型或泛型类型内复制值

00:57:49.870 --> 00:57:53.173
我也给你们展示了一种技巧 也就是

00:57:53.240 --> 00:57:56.677
使用可复制和写入的
简洁存储来处理

00:57:58.812 --> 00:58:03.417
好的 那么 这里有一些与建模和性能

00:57:58.812 --> 00:58:03.417
好的 那么 这里有一些与建模和性能

00:58:03.817 --> 00:58:05.018
相关的演讲

00:58:05.085 --> 00:58:07.988
我强烈推荐你们参加
今天下午的一场演讲

00:58:08.121 --> 00:58:11.525
“UIKit应用中以协议和
值为导向的编程”

00:58:11.692 --> 00:58:12.526
谢谢大家
