WEBVTT

00:00:19.353 --> 00:00:21.421 align:middle
HTTP Live Streaming的新特性

00:00:21.488 --> 00:00:22.322 align:middle
打开了吗？

00:00:26.293 --> 00:00:27.127 align:middle
下午好

00:00:27.928 --> 00:00:29.196 align:middle
我是Roger Pantos

00:00:29.263 --> 00:00:32.031 align:middle
本次会话关于"HTTP Live
Streaming的新特性"

00:00:32.766 --> 00:00:36.403 align:middle
我们谈论HLS有七八年之久了

00:00:36.470 --> 00:00:40.407 align:middle
然而 每次我谈的时候
营销部的人都说

00:00:40.741 --> 00:00:43.544 align:middle
"你一定要跟人们说
有什么新进展了！"

00:00:43.710 --> 00:00:47.948 align:middle
所以开始吧
这就是新的内容

00:00:49.216 --> 00:00:52.052 align:middle
但首先
用20秒简介HLS

00:00:52.286 --> 00:00:55.255 align:middle
HLS重点在于播放
播放列表 什么是播放列表？

00:00:55.322 --> 00:00:57.291 align:middle
就是这样的东西
是TXT文件

00:00:57.558 --> 00:01:00.594 align:middle
上面有标签
是蓝色的那些

00:00:57.558 --> 00:01:00.594 align:middle
上面有标签
是蓝色的那些

00:01:00.894 --> 00:01:04.096 align:middle
还有分段 白色的那些
每一个都是10秒的媒体文件

00:01:04.164 --> 00:01:07.201 align:middle
如果你想播放一个
你在这些标签中翻找一遍

00:01:07.267 --> 00:01:09.036 align:middle
找找有趣的东西

00:01:09.102 --> 00:01:12.673 align:middle
比如...这个写着
这是INF分段 先加载它

00:01:12.906 --> 00:01:13.740 align:middle
所以去加载

00:01:14.241 --> 00:01:16.243 align:middle
然后加载segment1
播放它

00:01:16.310 --> 00:01:17.945 align:middle
加载segment2
播放它

00:01:18.011 --> 00:01:20.514 align:middle
可能这是直播播放列表
所以你刷新播放列表

00:01:20.581 --> 00:01:22.282 align:middle
加载segment3
播放它

00:01:22.349 --> 00:01:24.718 align:middle
简而言之
这基本上就是HLS

00:01:25.085 --> 00:01:27.888 align:middle
所以现在我们都
明白这是怎么一回事了

00:01:28.622 --> 00:01:29.890 align:middle
我们来讲讲新的内容

00:01:30.624 --> 00:01:31.959 align:middle
很好 好了

00:01:33.427 --> 00:01:35.095 align:middle
MPEG-4 Fragment Support

00:01:35.162 --> 00:01:37.898 align:middle
MPEG-4是个什么东西
为什么要被分成片段？

00:01:39.333 --> 00:01:42.069 align:middle
在座的大多数人
可能熟悉MPEG-4文件

00:01:42.135 --> 00:01:46.473 align:middle
如果你的硬盘上有一部电影
这很可能就是MP4格式的

00:01:46.540 --> 00:01:47.908 align:middle
或者是相近的格式

00:01:48.909 --> 00:01:53.146 align:middle
如果你去深入观察
它包括一个样本表

00:01:53.213 --> 00:01:57.651 align:middle
通常是开头
然后所有的样本数据都在其后

00:01:58.418 --> 00:01:59.853 align:middle
我们最初是这样做的

00:01:59.920 --> 00:02:04.791 align:middle
之后 我们推出了新的分段
随后称之为片段

00:01:59.920 --> 00:02:04.791 align:middle
之后 我们推出了新的分段
随后称之为片段

00:02:04.858 --> 00:02:08.362 align:middle
片段基本上是指一种方法
能将你的MPEG-4文件

00:02:08.428 --> 00:02:11.698 align:middle
分割成这些
小的可播放数据岛

00:02:11.765 --> 00:02:14.168 align:middle
小的样本表
小的样本数据

00:02:14.234 --> 00:02:16.670 align:middle
小的样本表
更多小的样本数据

00:02:17.204 --> 00:02:20.741 align:middle
这些小岛
都叫做"片段"

00:02:21.241 --> 00:02:26.613 align:middle
所以我们今天宣布的
本质上就是你现在能做的是

00:02:26.680 --> 00:02:30.651 align:middle
你能够将这些东西
这些MPEG-4片段

00:02:30.717 --> 00:02:33.053 align:middle
在你的HLS播放列表中
当做分段使用

00:02:33.120 --> 00:02:35.489 align:middle
就像传输流文件那样

00:02:35.556 --> 00:02:37.591 align:middle
或者基本音频流

00:02:38.392 --> 00:02:41.929 align:middle
我们会更新细则
来给你详细信息

00:02:41.995 --> 00:02:44.331 align:middle
我认为现在
会有本次会议的链接

00:02:45.399 --> 00:02:46.233 align:middle
不过...

00:02:47.734 --> 00:02:53.507 align:middle
它能让你做的
本质上是使用fMP4分段

00:02:53.574 --> 00:02:58.812 align:middle
传输流能做的事
你都可以用fMP4做到

00:02:58.979 --> 00:03:02.916 align:middle
这包括iframe播放列表
包括不连续性

00:02:58.979 --> 00:03:02.916 align:middle
这包括iframe播放列表
包括不连续性

00:03:02.983 --> 00:03:06.486 align:middle
包括直播流 等等
同样的功能

00:03:06.753 --> 00:03:10.290 align:middle
当然 我们会应用到
我们所有的HLS平台上

00:03:10.490 --> 00:03:13.827 align:middle
所以你可以选择将你所有的
流媒体编码成fMP4文件

00:03:13.894 --> 00:03:16.029 align:middle
然后在所有平台上使用

00:03:16.597 --> 00:03:21.101 align:middle
为什么要这么做？
简言之 互操作性

00:03:21.635 --> 00:03:26.740 align:middle
如果你要将你整个
媒体库用一种方式编码

00:03:26.807 --> 00:03:31.812 align:middle
传输到Apple平台上
之后你还要重新进行编码

00:03:31.879 --> 00:03:35.649 align:middle
换一种方式 例如传输到
Android设备上 那就太糟了

00:03:36.683 --> 00:03:39.653 align:middle
但如果你只有一个库

00:03:40.120 --> 00:03:43.724 align:middle
那你的传输成本会下降
你的存储成本会下降...

00:03:43.924 --> 00:03:45.726 align:middle
缓存的使用率会更好

00:03:45.792 --> 00:03:49.029 align:middle
因为你不再是拼命抢用缓存了

00:03:49.363 --> 00:03:52.032 align:middle
而且作为附加福利

00:03:53.267 --> 00:03:56.603 align:middle
还有 如果你有
单一的生产链

00:03:56.737 --> 00:03:58.705 align:middle
你可以在你全部的生态系统中

00:04:00.507 --> 00:04:04.077 align:middle
使用相同的工具和验证方法

00:04:04.411 --> 00:04:05.746 align:middle
作为附加福利

00:04:05.812 --> 00:04:09.449 align:middle
因为fMP4不使用
同样的信息分包

00:04:09.516 --> 00:04:10.918 align:middle
而传输流使用

00:04:11.451 --> 00:04:17.057 align:middle
在较低的比特率下
你会得到略微更高的效率

00:04:17.124 --> 00:04:18.791 align:middle
所以这算是附赠的好处

00:04:19.959 --> 00:04:24.198 align:middle
所以HLS对各位播放列表
作家带来了什么变化？

00:04:24.698 --> 00:04:26.633 align:middle
实际上 没什么变化

00:04:26.700 --> 00:04:29.536 align:middle
如果我们拿之前
看过的播放列表

00:04:29.603 --> 00:04:33.040 align:middle
并将它转化成fMP4格式
我们只需要这样做

00:04:33.440 --> 00:04:37.044 align:middle
我们更改初始化分段
使其指向Movie Box

00:04:37.110 --> 00:04:40.347 align:middle
然后每个分段
就成为了MPEG-4片段

00:04:41.014 --> 00:04:42.115 align:middle
这就行了

00:04:42.182 --> 00:04:45.319 align:middle
播放列表级别上的
其他东西几乎是一样的

00:04:45.819 --> 00:04:49.156 align:middle
在分段级别上
这里还有一点我想谈谈

00:04:49.223 --> 00:04:50.357 align:middle
那就是加密

00:04:50.457 --> 00:04:53.927 align:middle
如你所知 HLS有
两种不同的加密方法

00:04:53.994 --> 00:04:56.463 align:middle
你要么可以只加密整个分段

00:04:56.663 --> 00:04:58.398 align:middle
AES CBC 全部加密

00:04:58.665 --> 00:05:01.702 align:middle
这对传输流或是
fMP4都是一样的

00:04:58.665 --> 00:05:01.702 align:middle
这对传输流或是
fMP4都是一样的

00:05:02.202 --> 00:05:06.039 align:middle
对于样本加密 例如
如果你想用FairPlay Streaming

00:05:06.273 --> 00:05:10.077 align:middle
这就稍微复杂了
因为你必需说明

00:05:10.143 --> 00:05:12.679 align:middle
哪部分文件已加密
哪部分未加密

00:05:13.380 --> 00:05:16.850 align:middle
这一次...上一次
我们做的是传输流

00:05:16.917 --> 00:05:18.652 align:middle
我们本质上创造出我们自己的格式

00:05:19.386 --> 00:05:21.655 align:middle
这一次 我们决定
使用现有的格式

00:05:21.889 --> 00:05:23.190 align:middle
而且...

00:05:26.560 --> 00:05:29.596 align:middle
在这MPEG中叫做
"共用加密"

00:05:29.663 --> 00:05:31.832 align:middle
是一种标准
几年前推出的

00:05:32.032 --> 00:05:35.602 align:middle
最新版的标准里
有一个叫做cbcs的模式

00:05:35.669 --> 00:05:37.738 align:middle
这可以兼容
FairPlay Streaming

00:05:37.804 --> 00:05:40.240 align:middle
所以如果你在
HLS中做样本加密

00:05:40.440 --> 00:05:43.610 align:middle
你会使用共用加密
的cbcs模式来做

00:05:44.411 --> 00:05:47.114 align:middle
有了加密
播放列表和其他东西

00:05:47.181 --> 00:05:50.851 align:middle
这基本上就是
HLS的全部内容了

00:05:51.118 --> 00:05:53.120 align:middle
围绕片段化MPEG-4

00:05:53.520 --> 00:05:57.791 align:middle
但如果我们要想实现
那个快乐 闪亮 有活力的世界

00:05:57.858 --> 00:06:00.961 align:middle
在那里每个人可以
只有一条目录

00:05:57.858 --> 00:06:00.961 align:middle
在那里每个人可以
只有一条目录

00:06:01.161 --> 00:06:04.364 align:middle
可以传输到任何地方
那我们就必须超越HLS

00:06:04.631 --> 00:06:07.901 align:middle
我们要做的一件事是
我们需要写下一套规则

00:06:07.968 --> 00:06:12.673 align:middle
上面写着 "你要这样
创作你的fMP4分段或

00:06:12.739 --> 00:06:15.976 align:middle
片段诸如此类
来让它们在任何地方播放"

00:06:16.610 --> 00:06:18.345 align:middle
而且我们也一直在这方面努力

00:06:18.812 --> 00:06:23.016 align:middle
一开始是我们和
微软做的一个假设演练

00:06:23.083 --> 00:06:26.486 align:middle
一旦当我们进展到
觉着靠谱的时候

00:06:26.553 --> 00:06:30.724 align:middle
觉着能行了
我们就向MPEG提了这件事

00:06:31.024 --> 00:06:33.927 align:middle
那里的很多人都认为
这个想法很不错

00:06:33.994 --> 00:06:38.899 align:middle
所以最后得出的
是一套约束条件

00:06:38.966 --> 00:06:42.169 align:middle
用于如何创建你的fMP4分段

00:06:42.469 --> 00:06:45.873 align:middle
所以你要将
音频和视频分开传输

00:06:46.039 --> 00:06:48.742 align:middle
你要在每个视频分段
开头加入一个iframe

00:06:48.809 --> 00:06:51.245 align:middle
你要保证能严格
对齐所有分段

00:06:51.311 --> 00:06:52.779 align:middle
涵盖不同的比特率

00:06:53.413 --> 00:06:56.583 align:middle
你不需要做这些的
如果你的目标只是HLS

00:06:56.984 --> 00:07:01.622 align:middle
当你想要让你的媒体库
拥有最广泛的受众

00:06:56.984 --> 00:07:01.622 align:middle
当你想要让你的媒体库
拥有最广泛的受众

00:07:01.688 --> 00:07:05.125 align:middle
那我们为你准备了一系列推荐

00:07:05.392 --> 00:07:11.365 align:middle
我认为这会让所有人
受益...至少我希望如此

00:07:12.266 --> 00:07:13.200 align:middle
所以...

00:07:13.634 --> 00:07:17.905 align:middle
现在我要转换一下
来谈谈其他事情

00:07:18.272 --> 00:07:20.407 align:middle
大家都爱讨论的话题
...元数据

00:07:21.008 --> 00:07:26.013 align:middle
所以为了描述它
我首先开始谈谈

00:07:26.079 --> 00:07:29.750 align:middle
一些我们已经在HLS上为
元数据所做的现有的东西

00:07:30.651 --> 00:07:32.486 align:middle
静态元数据和ID3

00:07:32.986 --> 00:07:36.990 align:middle
静态元数据是用于
静态元数据的 不出意料

00:07:37.858 --> 00:07:40.360 align:middle
它会提供
内容标题之类的东西

00:07:40.427 --> 00:07:41.828 align:middle
大多数是文本

00:07:42.062 --> 00:07:44.431 align:middle
这就能很容易地
放入播放列表文件中

00:07:44.498 --> 00:07:46.466 align:middle
要么直接是标签

00:07:46.533 --> 00:07:50.037 align:middle
或者打包成JSON文件
然后通过URL引用

00:07:52.639 --> 00:07:55.175 align:middle
现在只有一个标题
或一个作者

00:07:55.242 --> 00:07:58.512 align:middle
或一个版权
对应每个演示文件 是静态的

00:07:59.213 --> 00:08:03.183 align:middle line:1
但这样的好处是
在你任何想要的时候都能获得

00:07:59.213 --> 00:08:03.183 align:middle line:1
但这样的好处是
在你任何想要的时候都能获得

00:08:03.250 --> 00:08:04.618 align:middle line:1
马上就能获得

00:08:06.053 --> 00:08:08.021 align:middle line:1
所以拿它和ID3对比

00:08:10.557 --> 00:08:16.063 align:middle line:1
因为计时元数据和
媒体演示文件的时间轴相连接

00:08:16.129 --> 00:08:19.066 align:middle line:1
还经常在流媒体中
用于为事件发信号

00:08:19.132 --> 00:08:22.169 align:middle line:1
例如 广告的开始
节目的开始

00:08:23.504 --> 00:08:28.008 align:middle line:1
它存在于媒体格式的本身
所以是一种叫做ID3的二进制格式

00:08:28.642 --> 00:08:32.145 align:middle line:1
这让它体积小巧
同时还变得难以创作

00:08:32.212 --> 00:08:34.014 align:middle line:1
因为需要专业的工具

00:08:34.081 --> 00:08:36.082 align:middle line:1
如果你要排除故障
这会让你痛不欲生

00:08:36.149 --> 00:08:37.417 align:middle line:1
很难读取ID3

00:08:38.352 --> 00:08:40.287 align:middle line:1
但你想要多少数量都行

00:08:40.354 --> 00:08:42.856 align:middle line:1
而且可以放置到
时间轴上的任意位置

00:08:43.056 --> 00:08:44.391 align:middle line:1
所以这十分强大

00:08:45.125 --> 00:08:47.961 align:middle line:1
而在另一面
因为它存在于媒体文件中

00:08:48.028 --> 00:08:50.831 align:middle line:1
我们只能在播放之后
才能提供给你

00:08:52.165 --> 00:08:55.302 align:middle line:1
所以这个新玩意
有什么作用？

00:08:56.803 --> 00:09:01.775 align:middle line:1
我们添加的是一种在播放列表
自身内部创建计时元数据的方式

00:08:56.803 --> 00:09:01.775 align:middle line:1
我们添加的是一种在播放列表
自身内部创建计时元数据的方式

00:09:02.743 --> 00:09:07.714 align:middle line:1
所以现在你在ID3中用的
同样东西都可以在这上面使用

00:09:09.449 --> 00:09:12.719 align:middle line:1
你可以将它们创建成文本
这很简单

00:09:12.920 --> 00:09:15.489 align:middle line:1
你可以轻松地把它们
放入播放列表中

00:09:16.723 --> 00:09:18.325 align:middle line:1
而且想要多少数量都行

00:09:18.392 --> 00:09:21.295 align:middle line:1
它们可以覆盖
可以嵌套 什么都行

00:09:22.729 --> 00:09:26.567 align:middle line:1
另一方面
因为它们在播放列表中

00:09:26.633 --> 00:09:29.837 align:middle line:1
我们读取完播放列表之后
就可以马上提供给你整个集合

00:09:30.671 --> 00:09:32.639 align:middle line:1
无论播放指针位于
媒体文件的哪个位置

00:09:33.240 --> 00:09:35.075 align:middle
这就非常有助于

00:09:35.142 --> 00:09:38.378 align:middle
做特别像是
导航控制之类的事情

00:09:39.813 --> 00:09:45.219 align:middle
所以它是什么样子？
我们如何应用它呢？

00:09:45.586 --> 00:09:48.555 align:middle
我们在HLS中已经有
日期的概念了

00:09:48.822 --> 00:09:53.360 align:middle
PROGRAM-DATE-TIME标签允许
你精准地在播放列表内部发送时间信号

00:09:53.427 --> 00:09:55.295 align:middle
所以我们以此为基础 我们说

00:09:55.529 --> 00:10:01.268 align:middle
每个比特的元数据都
将会被表达成时间范围

00:09:55.529 --> 00:10:01.268 align:middle
每个比特的元数据都
将会被表达成时间范围

00:10:01.668 --> 00:10:04.304 align:middle
并附带有一组的属性

00:10:04.805 --> 00:10:07.574 align:middle
其中一些是我们的
其中一些是你们的

00:10:09.877 --> 00:10:11.979 align:middle
我们设置句法
所以能整洁地从直播流

00:10:12.045 --> 00:10:13.947 align:middle
添加和移除这些东西

00:10:14.214 --> 00:10:16.517 align:middle
所以这能完美契合
直播工作流

00:10:18.785 --> 00:10:20.454 align:middle
它是什么样子？

00:10:21.255 --> 00:10:22.956 align:middle
我们来看一下这些句子

00:10:24.758 --> 00:10:27.294 align:middle
我们将新的标签称作
DATERANGE标签

00:10:27.361 --> 00:10:28.562 align:middle
这是另一个播放列表

00:10:28.629 --> 00:10:30.831 align:middle
第一句基本上
在说现在是什么时间

00:10:31.064 --> 00:10:33.333 align:middle
第二个是DATERANGE标签
如果你去看看

00:10:33.400 --> 00:10:36.670 align:middle
你能看到
这是由属性组成的

00:10:37.037 --> 00:10:40.841 align:middle
这些蓝色的部分是细则中定义出来的

00:10:41.108 --> 00:10:43.210 align:middle
ID START-DATE
DURATION

00:10:44.044 --> 00:10:50.317 align:middle
我们为各位保留了X-namespace
这与HTTP相似

00:10:50.384 --> 00:10:53.554 align:middle
这样你能用它来
放入你想要的属性值对

00:10:53.854 --> 00:10:57.524 align:middle
在本案例中 有人决定
放入AD-ID和beacon URL

00:10:58.392 --> 00:10:59.893 align:middle
这是一个示例

00:10:59.960 --> 00:11:02.362 align:middle
这是它们在播放列表中的样子

00:10:59.960 --> 00:11:02.362 align:middle
这是它们在播放列表中的样子

00:11:03.830 --> 00:11:08.669 align:middle
当你在进行内容创建时
你可以用在直播或点播上

00:11:08.735 --> 00:11:11.171 align:middle
这只需要有
DATERANGE标签和日期

00:11:11.872 --> 00:11:15.709 align:middle
很明显 在创建播放列表时
你可以将这些东西放进去

00:11:15.976 --> 00:11:19.880 align:middle
不过另一个好处是
因为播放列表易于操作

00:11:19.947 --> 00:11:22.282 align:middle
如果你有后期制作工作流

00:11:22.349 --> 00:11:24.651 align:middle
在做广告插入

00:11:24.718 --> 00:11:27.054 align:middle
可以非常容易地使用元数据

00:11:27.120 --> 00:11:29.323 align:middle
同时增强播放列表和演示文件

00:11:30.591 --> 00:11:32.192 align:middle
应众人要求

00:11:32.259 --> 00:11:36.763 align:middle
我们还包括了如何
映射SCTE-35的规则

00:11:36.830 --> 00:11:41.068 align:middle
你可以在源媒体文件中找到它
然后用于DATERANGE标签之内

00:11:41.201 --> 00:11:46.306 align:middle
这样你可以在HLS中
无损地执行SCTE-35

00:11:47.574 --> 00:11:51.011 align:middle
最后我们添加了
媒体流验证程序的支持

00:11:51.178 --> 00:11:52.779 align:middle
我想花点时间

00:11:52.846 --> 00:11:55.315 align:middle
宣传一下
我们有的新工具

00:11:55.749 --> 00:11:57.284 align:middle
我们办了一次演讲

00:11:57.351 --> 00:11:59.486 align:middle
现在我们没有时间说这件事

00:11:59.553 --> 00:12:02.422 align:middle
但我们办了一次演讲
谈论了新的工具

00:11:59.553 --> 00:12:02.422 align:middle
但我们办了一次演讲
谈论了新的工具

00:12:02.756 --> 00:12:04.691 align:middle
所以我鼓励大家去看看

00:12:04.892 --> 00:12:07.661 align:middle
你可以在你的应用
或其他东西上点播

00:12:08.595 --> 00:12:10.764 align:middle
你应该看看
有什么新的本领

00:12:10.831 --> 00:12:13.267 align:middle
特别出现在验证程序上了

00:12:14.434 --> 00:12:15.569 align:middle
对于重放

00:12:15.636 --> 00:12:20.240 align:middle
当你想让视频流
中的元数据起作用

00:12:21.975 --> 00:12:24.011 align:middle
你要有一组
AVFoundation API

00:12:24.211 --> 00:12:26.813 align:middle
所以这个时候
你一定要在应用内部

00:12:27.381 --> 00:12:31.151 align:middle
而且API本质上就是
"给我你目前有的所有数据"

00:12:31.552 --> 00:12:35.189 align:middle
然后如果你有直播播放列表
当有新内容出现时要通知我

00:12:36.323 --> 00:12:41.562 align:middle
这中心围绕在
一个新的对象 叫做

00:12:41.728 --> 00:12:44.932 align:middle
AVPlayerItemMetadataCollector

00:12:45.599 --> 00:12:49.603 align:middle
我们这里有一个小样本
你能看到没有什么特别的

00:12:50.704 --> 00:12:52.639 align:middle
你创建资源和PlayerItem

00:12:52.706 --> 00:12:54.908 align:middle
然后你说
"我想收集一些元数据"

00:12:54.975 --> 00:12:57.110 align:middle
所以你创建
MetadataCollector

00:12:57.377 --> 00:13:00.013 align:middle
你将自己设定成委托
这样我们可以将内容告诉你

00:12:57.377 --> 00:13:00.013 align:middle
你将自己设定成委托
这样我们可以将内容告诉你

00:13:00.214 --> 00:13:01.882 align:middle
然后将它添加到
PlayerItem

00:13:02.249 --> 00:13:07.321 align:middle
这就好了
之后你就得到所有元数据项了

00:13:07.788 --> 00:13:11.658 align:middle
所以使用起来十分容易
十分强大

00:13:12.025 --> 00:13:15.262 align:middle
我认为这会很快成为
一种首选方式

00:13:15.329 --> 00:13:17.564 align:middle
来将元数据输入到HLS中

00:13:18.432 --> 00:13:21.835 align:middle
所以接下来
我们今天要讲的

00:13:21.902 --> 00:13:27.140 align:middle
是另一个功能
这也是应众人要求的

00:13:27.641 --> 00:13:33.847 align:middle
那就是离线模式下
播放HLS的功能

00:13:39.920 --> 00:13:41.922 align:middle
我想请我的同事

00:13:41.989 --> 00:13:44.258 align:middle
Jordan Schneider
上台给大家作说明

00:13:52.165 --> 00:13:57.471 align:middle
嗨 看看幻灯片好不好用

00:13:58.672 --> 00:13:59.540 align:middle
好了

00:13:59.773 --> 00:14:03.744 align:middle
在iOS 10中 我们让你能够下载

00:13:59.773 --> 00:14:03.744 align:middle
在iOS 10中 我们让你能够下载

00:14:03.810 --> 00:14:06.647 align:middle
并播放HLS内容不需要网络连接

00:14:07.381 --> 00:14:11.151 align:middle
现在你可以将离线媒体
重播功能提供给你们的用户了

00:14:11.218 --> 00:14:13.687 align:middle
使用现有的流媒体库

00:14:14.354 --> 00:14:17.324 align:middle
作为此功能的一部分
我们扩展了

00:14:17.391 --> 00:14:20.594 align:middle
去年我们推出的
FairPlay Streaming支持

00:14:21.195 --> 00:14:24.131 align:middle
来兼容离线HLS

00:14:24.698 --> 00:14:28.702 align:middle
而且我们给大家提供
一种下载HLS内容的方式

00:14:28.769 --> 00:14:30.571 align:middle
即使你的应用在后台运行

00:14:31.104 --> 00:14:36.076 align:middle
最后 我们推出播放
部分下载内容的功能

00:14:36.143 --> 00:14:38.478 align:middle
即使你的下载可能还在进行中

00:14:39.313 --> 00:14:44.251 align:middle
所以第一个问题-
应该何时使用离线HLS？

00:14:44.685 --> 00:14:48.355 align:middle
没错 如果你想将这种功能

00:14:48.422 --> 00:14:52.159 align:middle
主要用于
当用户想要播放内容的时候

00:14:52.226 --> 00:14:55.128 align:middle
然而他们可能没有网络连接

00:14:55.195 --> 00:14:56.964 align:middle
例如当他们进入飞行模式

00:14:57.130 --> 00:15:00.567 align:middle
不过 此项功能并非
针对于预先加载媒体文件

00:14:57.130 --> 00:15:00.567 align:middle
不过 此项功能并非
针对于预先加载媒体文件

00:15:00.868 --> 00:15:03.504 align:middle
我们有使用AVPlayerItem
的其他做法

00:15:04.671 --> 00:15:09.810 align:middle
所以为什么使用HLS播放离线内容
而不是直接下载好电影文件呢？

00:15:10.277 --> 00:15:13.514 align:middle
第一点 你的内容
可能已经是用HLS制作了

00:15:13.580 --> 00:15:18.318 align:middle
所以采用HLS来播放
离线内容可能对你非常便利

00:15:18.385 --> 00:15:19.953 align:middle
从工程学角度来说

00:15:20.354 --> 00:15:22.523 align:middle
同时除了视频轨

00:15:22.890 --> 00:15:26.927 align:middle
电影文件可以包括很多
不同的音频轨和字幕轨

00:15:26.994 --> 00:15:30.297 align:middle
你的用户可能不太需要
或是在离线存留着

00:15:30.998 --> 00:15:35.269 align:middle
在HLS中 因为所有的
轨道都是分隔保存于

00:15:35.335 --> 00:15:41.341 align:middle line:1
服务器的不同播放列表中
我们能实现更大一点的灵活度

00:15:41.608 --> 00:15:45.779 align:middle line:1
我们能精确控制
被下载的媒体选择

00:15:46.046 --> 00:15:50.217 align:middle line:1
节省用户的时间 网络数据
和设备上的存储空间

00:15:50.684 --> 00:15:55.756 align:middle line:1
例如 默认下 我们下载了
一个用户的默认媒体选择

00:15:55.822 --> 00:15:59.293 align:middle line:1
用户在离线播放时
很可能只会关心这些文件

00:15:59.359 --> 00:16:03.030 align:middle line:1
我们还给你提供的方式是
确切配置

00:15:59.359 --> 00:16:03.030 align:middle line:1
我们还给你提供的方式是
确切配置

00:16:03.096 --> 00:16:06.733 align:middle line:1
你和用户想下载的
可以离线回放的内容

00:16:08.268 --> 00:16:12.339 align:middle line:1
离线播放HLS
的另一好处在于

00:16:12.406 --> 00:16:14.208 align:middle line:1
使用相同的资源

00:16:14.274 --> 00:16:18.478 align:middle line:1
我们仍可以下载
未被下载的媒体选择选项

00:16:18.545 --> 00:16:21.915 align:middle line:1
只要它们还存储在
你的服务器中 这非常不错

00:16:22.783 --> 00:16:24.585 align:middle
所以怎么做呢？

00:16:25.319 --> 00:16:29.489 align:middle
在iOS 10中 我们推出一个
新的类 用于下载AVAssets

00:16:29.556 --> 00:16:31.058 align:middle
叫做AVAssetDownloadTask

00:16:31.625 --> 00:16:35.262 align:middle
这个类继承了
URL会话的功能

00:16:35.495 --> 00:16:39.700 align:middle
更重要的是
在后台下载资源的功能

00:16:39.766 --> 00:16:43.203 align:middle
即使你的应用没有使用
其所有的机制运行

00:16:43.804 --> 00:16:45.572 align:middle
我们让你有能力...

00:16:45.639 --> 00:16:48.342 align:middle
控制下载哪些媒体选择

00:16:48.775 --> 00:16:50.844 align:middle
因为这是HLS

00:16:50.911 --> 00:16:54.815 align:middle
我们让你有能力
选择你想要的资源品质

00:16:54.882 --> 00:16:56.917 align:middle
还可以离线下载下来

00:16:57.451 --> 00:17:01.321 align:middle line:1
AVAssetDownloadTask
的界面是这个样

00:16:57.451 --> 00:17:01.321 align:middle line:1
AVAssetDownloadTask
的界面是这个样

00:17:01.688 --> 00:17:04.090 align:middle line:1
继承了
URLSessionTask

00:17:04.156 --> 00:17:06.359 align:middle line:1
我想在这里提一下
这不是继承了

00:17:06.425 --> 00:17:08.328 align:middle line:1
URLSessionDownloadTask

00:17:08.662 --> 00:17:12.799 align:middle line:1
作用很相似 但是
我想指出几点不同之处

00:17:13.599 --> 00:17:18.672 align:middle line:1
所以为了创建这些东西
你要设置URLSession

00:17:18.739 --> 00:17:21.909 align:middle line:1
现在我们有一个特定的
URLSession子类 叫做

00:17:21.974 --> 00:17:25.212 align:middle line:1
AVAssetDownloadURLSession
你需要使用这些东西

00:17:25.279 --> 00:17:28.849 align:middle line:1
所以调用makeAssetDownloadTask
来创建资源下载任务

00:17:29.349 --> 00:17:31.518 align:middle line:1
之后为了选择品质

00:17:31.585 --> 00:17:34.388 align:middle line:1
我们有最低要求
比特率的选项键

00:17:34.454 --> 00:17:36.390 align:middle line:1
以及媒体选择键

00:17:37.124 --> 00:17:40.060 align:middle line:1
现在我应该说一下
每个AVAssetDownloadTask

00:17:40.127 --> 00:17:42.829 align:middle
对应单个的媒体选择

00:17:43.096 --> 00:17:46.233 align:middle
如果你想在同一资源上
下载多个媒体选择

00:17:46.300 --> 00:17:49.770 align:middle
那你需要设置多个
AVAssetDownloadTask才行

00:17:50.037 --> 00:17:51.972 align:middle
我会在几张幻灯片中展示的

00:17:52.706 --> 00:17:55.509 align:middle
要想使用这些东西
我们要这样做

00:17:55.809 --> 00:17:59.179 align:middle
首先要设置一个
AVAssetDownloadTask

00:17:59.246 --> 00:18:01.615 align:middle
任意进行配置
然后开始下载

00:17:59.246 --> 00:18:01.615 align:middle
任意进行配置
然后开始下载

00:18:02.082 --> 00:18:05.452 align:middle
我们要响应下载过程中
可能发生的任何事件

00:18:05.519 --> 00:18:07.754 align:middle
例如监控下载进程

00:18:08.255 --> 00:18:09.723 align:middle
一旦下载完毕

00:18:09.790 --> 00:18:13.527 align:middle
我们要存储位置
来在离线时进行回放

00:18:14.261 --> 00:18:18.031 align:middle
你可能要下载额外的
媒体选择供你的用户所用

00:18:18.699 --> 00:18:21.235 align:middle
最后 你要播放该内容

00:18:22.369 --> 00:18:26.006 align:middle
所以要想设置这些下载

00:18:26.073 --> 00:18:28.542 align:middle
设置完资源后
首先要做的是

00:18:28.609 --> 00:18:31.678 align:middle
你要去设置
backgroundConfiguration

00:18:31.745 --> 00:18:34.648 align:middle
来自background
URLSessionConfiguration

00:18:35.482 --> 00:18:38.685 align:middle
然后你要创建你的
AssetDownloadURLSession

00:18:39.052 --> 00:18:41.021 align:middle
然后创建你的下载任务

00:18:41.154 --> 00:18:45.325 align:middle
这里我有一个下载任务
下载品质

00:18:45.392 --> 00:18:47.928 align:middle
的媒体比特率
大概是每秒2兆位

00:18:48.228 --> 00:18:52.699 align:middle
但默认下 我们会下载
提供的最高品质的视频

00:18:53.367 --> 00:18:56.303 align:middle
一旦设置完成
因为这是URLSessionTask

00:18:56.370 --> 00:18:58.272 align:middle
你可以调用resume
来设置你的下载

00:18:59.439 --> 00:19:02.843 align:middle
所以一旦下载开始了
那你就要去监控它

00:18:59.439 --> 00:19:02.843 align:middle
所以一旦下载开始了
那你就要去监控它

00:19:03.010 --> 00:19:07.347 align:middle
为此 我们为你准备了新协议
叫做AVAssetDownloadDelegate

00:19:07.581 --> 00:19:12.286 align:middle
这继承了URLSessionTaskDelegate
中相同的委托方法

00:19:12.586 --> 00:19:16.623 align:middle
我想指出两件事
是我们在这里推出的

00:19:17.157 --> 00:19:21.562 align:middle
一个是我们使用的
监控下载进程的方法

00:19:22.196 --> 00:19:26.166 align:middle
在此方法中
我们显示出下载进程

00:19:26.233 --> 00:19:30.704 align:middle
和时间范围 而不是字节
来实现更好的媒体界面表达

00:19:31.271 --> 00:19:32.739 align:middle
之后我们有一个

00:19:32.806 --> 00:19:36.009 align:middle
didFinishDownloadingTo location
委托方法 来通知你

00:19:36.076 --> 00:19:38.612 align:middle
下载文件的所在位置

00:19:38.912 --> 00:19:41.982 align:middle
这相似于
URLSessionDownloadDelegate

00:19:42.049 --> 00:19:46.086 align:middle
的协议方法 你需要做的
事情的预期

00:19:46.153 --> 00:19:50.424 align:middle
当你得到这个委托方法
是稍微有点不同的

00:19:50.490 --> 00:19:52.059 align:middle
我马上就指出来

00:19:53.594 --> 00:19:57.331 align:middle
这是我们进程
委托方法的一个示例

00:19:57.397 --> 00:20:02.503 align:middle
这里我将时间范围转化成
已完成下载的百分数

00:19:57.397 --> 00:20:02.503 align:middle
这里我将时间范围转化成
已完成下载的百分数

00:20:02.569 --> 00:20:05.606 align:middle
我不会对其深入说明
不过这就是它的做法

00:20:06.507 --> 00:20:09.743 align:middle
你的应用可能在
下载过程中被关闭

00:20:10.043 --> 00:20:13.547 align:middle
进程可能被终止
那你怎么办？

00:20:13.614 --> 00:20:14.915 align:middle
你的下载会继续

00:20:14.982 --> 00:20:17.551 align:middle
为了应对该情况
你的响应方法完全与

00:20:17.618 --> 00:20:19.486 align:middle
URLSessionDownloadTasks
相同

00:20:19.786 --> 00:20:22.556 align:middle
当你的应用启用后
你要去设置

00:20:22.623 --> 00:20:26.159 align:middle
另一个后台配置
你使用的标识符相同于

00:20:26.226 --> 00:20:30.297 align:middle
最初设置下载时的标识符
然后从中创建一个URLSession

00:20:30.631 --> 00:20:32.499 align:middle
从那里
调用getAllTasks方法

00:20:32.566 --> 00:20:35.669 align:middle
然后这里 你可以恢复
你的AVAssetDownloadTask

00:20:35.736 --> 00:20:37.738 align:middle
其中会有当前的进程

00:20:37.804 --> 00:20:40.541 align:middle
你可以用它来更新
应用中可能有的任何UI

00:20:40.607 --> 00:20:43.744 align:middle
然后你甚至可以用它
来抓取原始AVAsset

00:20:43.810 --> 00:20:45.546 align:middle
之前你用它来
设置你的下载

00:20:46.246 --> 00:20:50.584 align:middle
所以一旦下载完成
首先你要做的是

00:20:50.651 --> 00:20:52.786 align:middle
储存下载资源的位置

00:20:53.420 --> 00:20:57.925 align:middle
所以每当有东西存到这个位置
这个方法就会被调用

00:20:57.991 --> 00:21:02.963 align:middle
包括当部分下载的内容
被用户取消的时候

00:20:57.991 --> 00:21:02.963 align:middle
包括当部分下载的内容
被用户取消的时候

00:21:03.297 --> 00:21:05.666 align:middle
现在你可以用

00:21:05.732 --> 00:21:12.172 align:middle
先前取消的下载内容恢复下载

00:21:12.472 --> 00:21:16.443 align:middle
或者你甚至可以用它
回放部分下载的内容

00:21:16.510 --> 00:21:18.612 align:middle
如果你不想让那个下载

00:21:18.679 --> 00:21:21.582 align:middle
或者那个内容
占用你的应用储存空间

00:21:21.815 --> 00:21:24.017 align:middle
那你可能要在这里删除它

00:21:24.451 --> 00:21:25.352 align:middle
所以...

00:21:26.019 --> 00:21:28.055 align:middle
不同于
URLSessionDownloadDelegate

00:21:28.255 --> 00:21:32.059 align:middle
我们希望各位
不要将资源从这里移开

00:21:32.459 --> 00:21:36.096 align:middle
我们这样做是因为让系统
能够找到这些文件是很重要的

00:21:36.163 --> 00:21:38.398 align:middle
因为系统会回收磁盘空间

00:21:38.465 --> 00:21:41.301 align:middle
如果磁盘空间很少的话
而且会在某个时刻

00:21:41.368 --> 00:21:44.838 align:middle
会从应用容器中删除该资源

00:21:45.339 --> 00:21:50.043 align:middle
所以你想保存的是
位置的相对路径

00:21:50.110 --> 00:21:54.147 align:middle
从这里 你能够在将来
恢复你的资源 从而进行回放

00:21:55.582 --> 00:21:59.953 align:middle
所以 现在你下载完
资源的一个版本

00:22:00.287 --> 00:22:03.023 align:middle
比如说 你想下载
额外的媒体选择

00:22:03.190 --> 00:22:07.794 align:middle
这个适合在我们的
didCompleteWithError委托方法中做

00:22:07.861 --> 00:22:10.197 align:middle
这跟URLSessionTask
有的那个一样

00:22:10.797 --> 00:22:13.200 align:middle
适合在这里做的原因是

00:22:13.267 --> 00:22:16.570 align:middle
因为同一资源上的
媒体选择是连续下载的

00:22:16.803 --> 00:22:22.142 align:middle
通常这里适合进行
任何完成下载的清理工作

00:22:22.543 --> 00:22:27.381 align:middle
所以用额外媒体选择
选项来进行增强

00:22:27.447 --> 00:22:28.682 align:middle
比如 西班牙语音频

00:22:28.749 --> 00:22:31.685 align:middle
我们首先会抓取
要下载的spanishOption

00:22:32.085 --> 00:22:37.958 align:middle
然后我们改变最初放入的
AVMediaSelection

00:22:38.025 --> 00:22:40.928 align:middle
从这里选择spanishOption

00:22:41.495 --> 00:22:43.130 align:middle
一旦选择好了

00:22:43.197 --> 00:22:46.133 align:middle
我们要去创建一个新的
AVAssetDownloadTask

00:22:46.633 --> 00:22:48.702 align:middle
最好是在同一会话中

00:22:48.769 --> 00:22:51.872 align:middle
外加传递我们要
下载的额外媒体选择

00:22:51.939 --> 00:22:55.075 align:middle
然后我们调用resume
这样整个过程就会重复

00:22:55.142 --> 00:22:58.512 align:middle
如果想的话 我们可以
之后下载额外媒体选择

00:23:00.380 --> 00:23:02.449 align:middle
现在我们谈谈
播放的事情

00:23:03.083 --> 00:23:09.656 align:middle
假如说我们有...这里示范了
如何创建下载任务的方法

00:23:09.723 --> 00:23:13.193 align:middle
注意到我输入了一个
带有networkURL的资源了吗？

00:23:13.594 --> 00:23:17.297 align:middle
但我们离线回放HLS

00:23:17.364 --> 00:23:20.501 align:middle
如果我们仍可以用
原始的urlAsset

00:23:20.567 --> 00:23:25.572 align:middle
那我们应该使用
那个AVAsset实例来播放

00:23:26.106 --> 00:23:29.676 align:middle
我们可以从AssetDownloadTask
上的urlAsset属性中抓取

00:23:30.043 --> 00:23:32.145 align:middle
如果你输入带有
networkURL的新资源

00:23:32.212 --> 00:23:35.682 align:middle
AVFoundation无法知道
从何处寻找下载的内容

00:23:35.983 --> 00:23:39.553 align:middle
所以你应该使用同一资源
然后你就能离线回放了

00:23:40.053 --> 00:23:45.158 align:middle
然而 如果你无法引用
那个原始AVAsset

00:23:45.559 --> 00:23:50.631 align:middle
例如 很长时间之后
你的应用可能没在运作

00:23:50.898 --> 00:23:54.801 align:middle
那你要做的就是
创建新的AVAsset

00:23:54.868 --> 00:23:57.571 align:middle
用我们提供给你的下载位置

00:23:57.638 --> 00:24:00.407 align:middle
在didFinishDownloadingTo
委托方法中

00:23:57.638 --> 00:24:00.407 align:middle
在didFinishDownloadingTo
委托方法中

00:24:00.474 --> 00:24:02.342 align:middle
并用它创建一个
PlayerItem

00:24:03.143 --> 00:24:09.149 align:middle
在这个案例中 如果你想
对资源进行操作 例如

00:24:09.216 --> 00:24:11.552 align:middle
用额外媒体选择下载来增强

00:24:11.618 --> 00:24:13.620 align:middle
你真的应该重新使用
那个同一个资源

00:24:13.687 --> 00:24:18.659 align:middle
你不应该有大量的AVAsset
指向磁盘上相同的fileURL

00:24:18.759 --> 00:24:21.495 align:middle
这有助于让
AVFoundation高效地

00:24:21.562 --> 00:24:24.331 align:middle
重新使用已经下载的媒体数据

00:24:25.299 --> 00:24:29.503 align:middle
所以我们还有一个附加级
来帮助你严谨规定

00:24:29.570 --> 00:24:33.941 align:middle
用户能离线播放的内容
这叫做AVAssetCache

00:24:34.341 --> 00:24:37.344 align:middle
你从一个AVAsset的
资源缓存属性中抓取

00:24:37.711 --> 00:24:41.181 align:middle
这有两个作用
一个是能告诉你

00:24:41.248 --> 00:24:44.885 align:middle
是否这个资源的
各个版本都能离线播放

00:24:45.385 --> 00:24:47.721 align:middle
另一个是
它能告诉你

00:24:47.788 --> 00:24:50.991 align:middle
是否出现了可用于
离线的特定媒体选择选项

00:24:51.225 --> 00:24:53.660 align:middle
如果它不允许离线
但还是能够播放的

00:24:53.727 --> 00:24:56.997 align:middle
前提是要有网络连接
而且那个媒体选择选项

00:24:57.064 --> 00:24:59.800 align:middle
仍然存在于
你去下载的那个服务器上

00:25:00.334 --> 00:25:03.170 align:middle
这就是如何使用
AVAssetDownloadTask

00:25:03.237 --> 00:25:06.640 align:middle
并播放后续的下载资源

00:25:06.740 --> 00:25:09.710 align:middle
我应该提一下第五点
如果你在下载资源磁盘上播放

00:25:09.776 --> 00:25:12.946 align:middle
这会在该过程的任何时刻发生

00:25:13.013 --> 00:25:16.583 align:middle
这甚至可能在
开始下载之前发生

00:25:16.650 --> 00:25:19.653 align:middle
或在下载过程中发生
而且AVFoundation会高效地

00:25:19.720 --> 00:25:22.990 align:middle
重新使用已经从网络上
下载下来的内容

00:25:23.924 --> 00:25:25.392 align:middle
我想换一下话题

00:25:25.459 --> 00:25:27.828 align:middle
来谈谈
保护离线内容

00:25:29.029 --> 00:25:32.032 align:middle
去年 我们推出了
FairPlay Streaming

00:25:32.099 --> 00:25:34.801 align:middle
为HLS生态系统带来了
强大的内容保护

00:25:35.536 --> 00:25:37.237 align:middle
然而 在iOS 9中

00:25:37.304 --> 00:25:40.374 align:middle
FairPlay Streaming需要
对密钥服务器的活动连接

00:25:40.440 --> 00:25:43.177 align:middle
这无法用在离线回放上面

00:25:43.710 --> 00:25:45.812 align:middle
所以今年我们扩展
FairPlay Streaming

00:25:45.879 --> 00:25:49.850 align:middle
使其在离线HLS情况下
无需网络连接也能工作

00:25:50.317 --> 00:25:54.922 align:middle
我们的做法是将你的密钥
以安全的方式打包并存储在磁盘上

00:25:54.988 --> 00:25:56.790 align:middle
并重新用于离线回放

00:25:57.191 --> 00:26:00.394 align:middle
但你的应用本身
还是会保存这个密钥

00:25:57.191 --> 00:26:00.394 align:middle
但你的应用本身
还是会保存这个密钥

00:26:00.460 --> 00:26:03.697 align:middle
并响应来自
AVFoundation的密钥请求

00:26:03.764 --> 00:26:07.668 align:middle
用于每次回放 一旦密钥
进入缓存 就不需要接入网络了

00:26:08.569 --> 00:26:12.306 align:middle
所以要想支持这些密钥
需要对你的密钥服务器进行更改

00:26:12.372 --> 00:26:15.409 align:middle
具体是新的TLV值
这样你的密钥服务器

00:26:15.475 --> 00:26:19.046 align:middle
必须明确地选择加入密钥
从而满足使用离线回放的资格

00:26:20.180 --> 00:26:23.550 align:middle
最后
我们想提醒一下FPS Keys

00:26:23.784 --> 00:26:26.687 align:middle
你必须在主播放列表中
将它们声明为会话密钥

00:26:26.753 --> 00:26:28.922 align:middle
如果你想确认
是否下载完成的话

00:26:29.590 --> 00:26:30.424 align:middle
所以...

00:26:31.091 --> 00:26:33.260 align:middle line:1
为离线FairPlay Streaming
保存密钥

00:26:33.327 --> 00:26:37.331 align:middle line:1
真的就是基于在线
FairPlay Streaming的请求流

00:26:37.531 --> 00:26:41.435 align:middle line:1
你要更改的只是和修改
这个请求流有关的内容

00:26:41.902 --> 00:26:44.905 align:middle line:1
我在这里快速总结一下
来指出你需要做的事情

00:26:45.172 --> 00:26:47.508 align:middle line:1
但如要了解更多信息
你应该观看去年的演讲

00:26:47.574 --> 00:26:49.343 align:middle line:1
我们在那里讲得十分详细了

00:26:50.477 --> 00:26:52.679 align:middle line:1
与FairPlay Streaming
回放一样

00:26:52.746 --> 00:26:54.448 align:middle line:1
AVFoundation会
下载你的播放列表

00:26:54.515 --> 00:26:57.084 align:middle line:1
并在找到密钥标签时
触发密钥请求

00:26:57.150 --> 00:27:00.554 align:middle line:1
这会让你的应用有机会
保存密钥 从而用于离线回放

00:26:57.150 --> 00:27:00.554 align:middle line:1
这会让你的应用有机会
保存密钥 从而用于离线回放

00:27:01.088 --> 00:27:05.192 align:middle line:1
所以你的应用首先会
回调AVFoundation

00:27:05.259 --> 00:27:06.860 align:middle line:1
来获取流媒体密钥请求

00:27:07.160 --> 00:27:10.797 align:middle line:1
然后会和你的服务器对话
这会取走

00:27:10.864 --> 00:27:14.835 align:middle line:1
那个流媒体密钥请求 然后
给你一个内容密钥上下文或CKC

00:27:15.302 --> 00:27:17.971 align:middle line:1
在线上FairPlay Streaming中
你会在这里完成

00:27:18.038 --> 00:27:21.909 align:middle line:1
请求流 并用那个CKC
返回到AVFoundation

00:27:22.442 --> 00:27:25.312 align:middle line:1
然而
在离线FairPlay Streaming中

00:27:25.712 --> 00:27:29.116 align:middle line:1
在这里你要将那个CKC
交给AVFoundation

00:27:29.183 --> 00:27:31.852 align:middle line:1
这样AVFoundation
能将其冻干成一种格式

00:27:31.919 --> 00:27:35.422 align:middle line:1
可以安全存储在
你应用的存储空间中

00:27:35.656 --> 00:27:39.793 align:middle line:1
你也可以在后续的
回放中重新用上它

00:27:39.927 --> 00:27:40.761 align:middle line:1
之后...

00:27:40.827 --> 00:27:43.297 align:middle line:1
一旦你将它写入
你的应用存储空间中

00:27:43.363 --> 00:27:46.500 align:middle line:1
你要将那个冻干的密钥
返回给AVFoundation

00:27:46.567 --> 00:27:47.668 align:middle line:1
来完成这个请求

00:27:47.935 --> 00:27:50.304 align:middle line:1
如果你的应用离线了
那你需要做的只是

00:27:50.370 --> 00:27:53.373 align:middle line:1
从你的应用存储空间中
读取那个冻干的密钥 并返还给

00:27:53.440 --> 00:27:56.543 align:middle line:1
AVFoundation 这样
不需要网络就能做得到

00:27:57.945 --> 00:28:00.280 align:middle
所以我们来看看这究竟
会怎样改变你的代码

00:27:57.945 --> 00:28:00.280 align:middle
所以我们来看看这究竟
会怎样改变你的代码

00:28:00.714 --> 00:28:04.852 align:middle
在线上FairPlay Streaming中
这些密钥请求作为

00:28:04.918 --> 00:28:06.687 align:middle
AVAssetResourceLoader
的一部分

00:28:06.887 --> 00:28:11.124 align:middle
具体是AVAssetResourceLoadingRequest
上面的委托方法

00:28:11.491 --> 00:28:13.560 align:middle
一旦收到请求
首先你要做的是

00:28:13.627 --> 00:28:19.099 align:middle
请求AVFoundation
创建流媒体内容密钥请求

00:28:19.166 --> 00:28:21.702 align:middle
或是SPC
这会发送到你的服务器上

00:28:21.768 --> 00:28:26.073 align:middle
这会返回一个CKC 之后
你用它来响应AVFoundation

00:28:27.541 --> 00:28:30.744 align:middle
现在 在离线FairPlay Streaming中
我们有一个新方法

00:28:30.811 --> 00:28:32.980 align:middle
这是用来冻干密钥的方法

00:28:33.046 --> 00:28:36.650 align:middle
你输入从服务器返回的CKC

00:28:36.950 --> 00:28:41.255 align:middle
然后返回那个为你保存的
数据团 从而用于离线存储

00:28:42.022 --> 00:28:44.791 align:middle
我们还有一个新的内容类型
作为这个请求流的一部分

00:28:44.858 --> 00:28:46.527 align:middle
是persistentContentKey类型

00:28:46.894 --> 00:28:48.262 align:middle
和一个新的选项

00:28:48.328 --> 00:28:52.232 align:middle
来为应用方法输入我们的
流媒体内容密钥请求数据

00:28:54.034 --> 00:28:58.839 align:middle
所以我们是这样
修改那个密钥请求流的

00:28:58.906 --> 00:29:00.874 align:middle
用于我们要离线保存的密钥

00:28:58.906 --> 00:29:00.874 align:middle
用于我们要离线保存的密钥

00:29:01.441 --> 00:29:06.146 align:middle
我们首先要做的是请求
AVFoundation创建SPC

00:29:06.547 --> 00:29:09.683 align:middle
不同之处是我们要输入
所需的persistentKey选项

00:29:09.750 --> 00:29:12.019 align:middle
这样 AVFoundation
和你的密钥服务器

00:29:12.085 --> 00:29:16.290 align:middle
会知道去请求一个
适用于冻干过程的密钥

00:29:16.957 --> 00:29:19.560 align:middle
所以它将SPC发送到
你的服务器 从而得到CKC

00:29:19.927 --> 00:29:23.330 align:middle
一旦拿回了CKC 你就调用
你的persistentContentKey方法

00:29:23.397 --> 00:29:26.066 align:middle
来创建这个冻干的密钥
然后可以保存于磁盘上

00:29:26.500 --> 00:29:28.769 align:middle
之后你要将这个密钥
真正写到你的磁盘上

00:29:28.836 --> 00:29:33.073 align:middle
你要将内容类型设置成
persistentContentKey类型

00:29:33.674 --> 00:29:38.445 align:middle
然后用那个持久性CKC
来完成数据加载请求

00:29:38.512 --> 00:29:40.714 align:middle
那个CKC保存在你的磁盘上

00:29:41.448 --> 00:29:43.183 align:middle
现在如果你离线了

00:29:43.250 --> 00:29:46.053 align:middle
或者比如说 你之前已经
满足了这个密钥请求

00:29:46.587 --> 00:29:48.655 align:middle
那你要这样做

00:29:49.189 --> 00:29:51.458 align:middle
你会得到
资源loadingRequest

00:29:52.292 --> 00:29:58.498 align:middle
你只需从应用存储空间中
读取你的冻干密钥

00:29:59.266 --> 00:30:03.003 align:middle
设置persistentContentKey类型
然后响应密钥loadingRequest

00:29:59.266 --> 00:30:03.003 align:middle
设置persistentContentKey类型
然后响应密钥loadingRequest

00:30:03.070 --> 00:30:06.507 align:middle
完全不需要接入网络
这很明显是必须的

00:30:06.573 --> 00:30:09.543 align:middle
因为你可能在飞行模式下

00:30:09.610 --> 00:30:12.379 align:middle
并且在这个过程中
没有任何网络连接

00:30:13.514 --> 00:30:15.849 align:middle
这就是如何修改
FairPlay Streaming

00:30:15.916 --> 00:30:18.051 align:middle
来用于你的离线HLS内容

00:30:19.253 --> 00:30:22.856 align:middle
现在我想谈谈管理
资源的最佳做法

00:30:23.490 --> 00:30:26.426 align:middle
很重要的一点是
这些下载会占用

00:30:26.493 --> 00:30:29.429 align:middle
你的应用磁盘使用量
所以你要稍微多留意

00:30:30.063 --> 00:30:32.733 align:middle
你真的应该清除
磁盘上任何不需要的资源

00:30:33.066 --> 00:30:36.637 align:middle
具体点 你一定要
为你的用户提供一种

00:30:36.703 --> 00:30:39.206 align:middle
查看所有下载内容的方式

00:30:39.273 --> 00:30:42.176 align:middle
并允许他们删除
那些不再需要的内容

00:30:44.111 --> 00:30:48.582 align:middle
要记住 用户取消的下载
还会保留在磁盘上

00:30:48.649 --> 00:30:52.119 align:middle
你可以用这些资源在
将来的某个时刻恢复下载

00:30:52.186 --> 00:30:55.255 align:middle
如果你不想恢复下载
那你就要注意在

00:30:55.322 --> 00:30:58.025 align:middle
取消下载的时候
删除那些资源

00:30:59.126 --> 00:31:04.164 align:middle
我们希望各位基于
明确的用户行动来保留下载

00:30:59.126 --> 00:31:04.164 align:middle
我们希望各位基于
明确的用户行动来保留下载

00:31:04.231 --> 00:31:06.667 align:middle
你不应该去下载一堆东西

00:31:06.733 --> 00:31:08.902 align:middle
因为用户可能不想离线观看

00:31:09.636 --> 00:31:12.940 align:middle
我们冒昧地
选择性排除了这些下载

00:31:13.006 --> 00:31:14.241 align:middle
在iCloud备份上面

00:31:16.310 --> 00:31:18.946 align:middle
我之前提过了
你应该做好准备 这个系统会在

00:31:19.012 --> 00:31:22.416 align:middle
在低磁盘空间的情况下
删除资源来回收磁盘空间

00:31:22.916 --> 00:31:25.152 align:middle
这不会在应用运行的时候发生

00:31:25.219 --> 00:31:27.521 align:middle
这只会在你应用终止后发生

00:31:28.589 --> 00:31:32.893 align:middle
当你的程序启动后
你应该稍微保守地

00:31:32.960 --> 00:31:35.696 align:middle
推测你的资源是否真的

00:31:35.762 --> 00:31:37.931 align:middle
提前下载在磁盘上了

00:31:40.400 --> 00:31:44.771 align:middle
你不要将资源从我们
提供的位置中移走

00:31:44.838 --> 00:31:48.609 align:middle
因为让系统能够找到
这些资源是非常重要的

00:31:50.110 --> 00:31:55.349 align:middle
最终 因为下载的资源可能包含

00:31:55.415 --> 00:31:57.985 align:middle
未被下载的媒体选择

00:31:58.051 --> 00:32:01.355 align:middle
注意不要改变你服务器上的资源

00:31:58.051 --> 00:32:01.355 align:middle
注意不要改变你服务器上的资源

00:32:01.488 --> 00:32:08.495 align:middle
如果你一定要更改
媒体播放列表的位置

00:32:08.562 --> 00:32:10.831 align:middle
并改变你的主播放列表

00:32:10.898 --> 00:32:14.001 align:middle
那你应该将修改后的资源
托管到新的URL上

00:32:14.067 --> 00:32:16.336 align:middle
而不是更改原来的那个

00:32:17.471 --> 00:32:19.473 align:middle
这就是 离线HLS

00:32:19.540 --> 00:32:23.143 align:middle
我们高兴向各位发布
并期待各位会采用它

00:32:24.111 --> 00:32:27.214 align:middle
总之 今年我们有
新功能供你们使用

00:32:27.281 --> 00:32:34.221 align:middle
我们有MP4片段支持
这会带来通用的媒体格式

00:32:34.288 --> 00:32:37.324 align:middle
可以用在你们所支持的
所有不同平台上

00:32:37.958 --> 00:32:40.761 align:middle
记住 这个兼容所有的HLS功能

00:32:40.827 --> 00:32:43.897 align:middle
而且对HLS播放列表
只需微小改动便可采用

00:32:45.065 --> 00:32:49.536 align:middle
接下来 我们有使用DATERANGE标签
的新播放列表内的元数据

00:32:49.603 --> 00:32:54.641 align:middle
在直播内容中
非常适合使用元数据

00:32:54.708 --> 00:32:57.277 align:middle
内容可能有动态更新的元数据

00:32:57.344 --> 00:32:59.179 align:middle
像是广告边界之类的东西

00:33:00.047 --> 00:33:03.450 align:middle
最后我们提供离线HLS回放

00:33:03.817 --> 00:33:08.455 align:middle
其中我们有一个
强大的媒体下载引擎

00:33:08.522 --> 00:33:12.292 align:middle line:1
你还可以配置要下载的
媒体选择和品质

00:33:12.926 --> 00:33:16.663 align:middle line:1
我们还扩展
FairPlay Streaming支持

00:33:16.730 --> 00:33:18.632 align:middle line:1
没有网络连接时也能工作

00:33:19.867 --> 00:33:21.301 align:middle line:1
所以要想获取更多信息

00:33:21.368 --> 00:33:26.106 align:middle
包括如何使用
AVAssetDownloadTask的样本代码

00:33:26.173 --> 00:33:29.810 align:middle
和关于这些新版本的
更多的资料

00:33:29.877 --> 00:33:34.114 align:middle
去查看我们开发网站上
针对本次会议的页面

00:33:36.116 --> 00:33:39.319 align:middle
我想指出
Roger之前提到的会议

00:33:39.586 --> 00:33:42.723 align:middle
已播出的创作和验证演讲

00:33:43.190 --> 00:33:47.661 align:middle
现在你可以在WWDC应用
上观看这个视频

00:33:48.095 --> 00:33:50.063 align:middle
我极力推荐观看

00:33:50.831 --> 00:33:53.734 align:middle
感谢各位的到来
希望大家会喜欢之后的发布会
