WEBVTT

00:00:19.353 --> 00:00:23.190 align:middle
Swift入门

00:00:23.257 --> 00:00:25.926 align:middle
大家好欢迎参加Swift入门

00:00:26.426 --> 00:00:29.563 align:middle
我是Dave Addey
和同事Brian和Alex一起

00:00:29.630 --> 00:00:33.033 align:middle
我想要给你们一个Swift编程语言
的快速概览

00:00:33.800 --> 00:00:36.970 align:middle
在之后60分钟里
你们会获得足够的Swift 3知识

00:00:37.037 --> 00:00:40.774 align:middle
来能够阅读Swift代码
最好还能开始写代码

00:00:42.309 --> 00:00:46.180 align:middle
让我们看看这个语言的一些基础

00:00:46.680 --> 00:00:48.916 align:middle
这是一些我两年前写的代码

00:00:49.383 --> 00:00:51.418 align:middle
我写了一个常量
用let来表明

00:00:51.718 --> 00:00:54.188 align:middle
这被叫做language
是一个字符串类型

00:00:54.721 --> 00:00:57.491 align:middle
这中间的冒号我们会经常
在Swift中看见

00:00:57.558 --> 00:00:58.992 align:middle
它表明是类型

00:00:59.059 --> 00:01:00.994 align:middle
language是一个字符串类型

00:00:59.059 --> 00:01:00.994 align:middle
language是一个字符串类型

00:01:01.562 --> 00:01:04.730 align:middle
我在swift代码里用字符串给它赋值

00:01:05.966 --> 00:01:06.934 align:middle
让我们做更多

00:01:07.301 --> 00:01:09.403 align:middle
假设有个整数称为
introduced

00:01:09.469 --> 00:01:10.904 align:middle
我们将它赋值为2014

00:01:11.305 --> 00:01:13.307 align:middle
及一个布尔型被称为
isAwesome

00:01:13.473 --> 00:01:14.675 align:middle
把它设为真

00:01:16.043 --> 00:01:19.413 align:middle
你注意到这些值都无需改变

00:01:19.713 --> 00:01:21.515 align:middle
名字language不会改变

00:01:21.582 --> 00:01:23.183 align:middle
或者它出现的年份

00:01:23.684 --> 00:01:26.486 align:middle
两年了Swift还是很好

00:01:26.553 --> 00:01:28.355 align:middle
所以这也可以是一个常量

00:01:28.989 --> 00:01:30.924 align:middle
这是Swift中的一般原则

00:01:31.258 --> 00:01:34.027 align:middle
如果一些量不需要被改变
我们申明它为常量

00:01:35.329 --> 00:01:38.131 align:middle
现在你可能还注意到了命名习惯

00:01:38.565 --> 00:01:41.902 align:middle
常量和变量是小写开始的驼峰式
命名法

00:01:41.969 --> 00:01:45.372 align:middle
像字符串、取整和布尔
类型是大写驼峰式命名法

00:01:47.174 --> 00:01:49.209 align:middle
现在如果我们看右边的这些

00:01:49.276 --> 00:01:50.644 align:middle
很明显

00:01:50.711 --> 00:01:54.314 align:middle
我想要的是字符串 整数 布尔型

00:01:55.215 --> 00:01:58.385 align:middle
在这种情况下
Swift会推断这些类型

00:01:58.452 --> 00:02:00.754 align:middle
我们不需要写出来

00:01:58.452 --> 00:02:00.754 align:middle
我们不需要写出来

00:02:00.821 --> 00:02:03.323 align:middle
你仍然得到明确申明了类型的变量

00:02:03.390 --> 00:02:04.992 align:middle
但是你不用写那么多代码

00:02:06.426 --> 00:02:07.861 align:middle
这是一些常量

00:02:07.928 --> 00:02:10.797 align:middle
那么对于变量呢？
它们有时候会改变

00:02:10.864 --> 00:02:12.799 align:middle
这是一个变量
被用var表明

00:02:12.866 --> 00:02:14.401 align:middle
这是为了语言的版本

00:02:14.468 --> 00:02:17.838 align:middle
它被改变了
让我们更新它到2016年的情况

00:02:19.239 --> 00:02:21.608 align:middle
现在如果我试着对常量这样做

00:02:21.675 --> 00:02:23.977 align:middle
如果我试着给
isAwesome赋值为假

00:02:24.645 --> 00:02:25.979 align:middle
Swift告诉我有个错误

00:02:26.046 --> 00:02:27.047 align:middle
这是对的

00:02:28.982 --> 00:02:31.285 align:middle
编程时常做的一件事

00:02:31.351 --> 00:02:33.320 align:middle
是通过其它值生成字符串

00:02:33.387 --> 00:02:36.089 align:middle
我们可以把字符串连接在一起

00:02:36.156 --> 00:02:39.393 align:middle
像这里展示的这样
但是Swift有一个更整洁的方法

00:02:39.459 --> 00:02:42.162 align:middle
被称为字符串插入
它看起来是这样的

00:02:42.930 --> 00:02:46.233 align:middle
我们可以把字符串和值放进
一个更大的字符串

00:02:46.300 --> 00:02:49.403 align:middle
通过用括号包裹并在前面加一个
反斜杠

00:02:49.469 --> 00:02:52.005 align:middle
我们在这想生成消息
“Hello WWDC”

00:02:53.207 --> 00:02:54.908 align:middle
我们并不只用字符串

00:02:54.975 --> 00:02:56.443 align:middle
我们还可以添加其他值

00:02:56.510 --> 00:02:58.478 align:middle
像是这里的整数
加入年

00:02:59.079 --> 00:03:01.582 align:middle
我们还可以加入表达式

00:02:59.079 --> 00:03:01.582 align:middle
我们还可以加入表达式

00:03:01.648 --> 00:03:04.751 align:middle
我们可以让年加1
为了可能是明年的代码

00:03:06.520 --> 00:03:09.756 align:middle
现在Swift中的字符串
对于Unicode编码是完全兼容的

00:03:09.823 --> 00:03:14.127 align:middle
它可以是ASCII
也可以是猫 狗 国旗

00:03:14.828 --> 00:03:16.530 align:middle
这都是相同的

00:03:16.597 --> 00:03:19.066 align:middle
不论是常量还是变量

00:03:19.132 --> 00:03:20.868 align:middle
你几乎可以使用任何字符

00:03:20.934 --> 00:03:23.036 align:middle
在常量和变量名中

00:03:24.338 --> 00:03:26.373 align:middle
说到标准字符

00:03:26.440 --> 00:03:29.409 align:middle
Swift做了很多工作来解决这意味
什么

00:03:29.476 --> 00:03:30.844 align:middle
做为一个单独字符

00:03:31.311 --> 00:03:33.780 align:middle
无论你的字符串是怎样在幕后编码的

00:03:33.847 --> 00:03:35.349 align:middle
或者怎么显示在屏幕上

00:03:36.683 --> 00:03:38.785 align:middle
我有一个字符串
叫做dogString

00:03:39.353 --> 00:03:42.689 align:middle
你可能认为它有6个字符

00:03:42.756 --> 00:03:46.627 align:middle
D O G ？！狗脸

00:03:47.194 --> 00:03:48.495 align:middle
但你错了

00:03:48.562 --> 00:03:51.098 align:middle
这里只有5个字符而不是6个

00:03:51.765 --> 00:03:55.302 align:middle
这里有一个特殊符号
被称为问号惊叹号

00:03:55.369 --> 00:03:59.106 align:middle
很好的用来形容狗

00:04:00.374 --> 00:04:02.910 align:middle
如果你不相信我
让Swift来证明这点

00:04:03.744 --> 00:04:06.146 align:middle
每个字符串都有一属性
叫characters

00:04:06.213 --> 00:04:08.382 align:middle
它给我们字符串中的字符的集合

00:04:08.448 --> 00:04:11.051 align:middle
我们可以访问这个集合的计数属性

00:04:11.118 --> 00:04:12.653 align:middle
来看有多少字符

00:04:13.253 --> 00:04:14.922 align:middle
如果把那传递给Print函数

00:04:14.988 --> 00:04:17.558 align:middle
我们发现我们实际上有5个字符

00:04:18.725 --> 00:04:20.793 align:middle
如果你仍然不相信我

00:04:20.861 --> 00:04:23.197 align:middle
让我们一个个遍历那些字符

00:04:23.263 --> 00:04:24.865 align:middle
用for-in循环

00:04:24.932 --> 00:04:26.767 align:middle
把每一个打印在它们自己的一行中

00:04:26.834 --> 00:04:29.403 align:middle
你可以看到我们实际上有5个字符

00:04:29.736 --> 00:04:33.240 align:middle
D O G ？！和狗脸

00:04:35.943 --> 00:04:39.012 align:middle
除了基本类型外

00:04:39.079 --> 00:04:41.181 align:middle
我们还有一些内置的集合

00:04:41.248 --> 00:04:43.217 align:middle
我们有数组和字典

00:04:43.584 --> 00:04:47.221 align:middle
你可能知道字典在别的语言里
是哈希或者映射表

00:04:47.955 --> 00:04:51.191 align:middle
最简单的创造数组或字典的方法
是使用字面值

00:04:51.258 --> 00:04:54.361 align:middle
这是一个数组字面值
用方括号包围

00:04:54.428 --> 00:04:55.762 align:middle
并用逗号分隔每个值

00:04:56.663 --> 00:04:59.933 align:middle
这里我们有一个数组包含4个名字
4个字符串

00:05:00.968 --> 00:05:02.436 align:middle
字典看起来类似

00:05:02.503 --> 00:05:05.172 align:middle
它们的键和值被冒号分开

00:05:05.239 --> 00:05:08.542 align:middle
我们有一个字典
它的键是名字是字符串类型

00:05:08.609 --> 00:05:10.143 align:middle
它的值是整数

00:05:11.912 --> 00:05:15.782 align:middle
现在你可能注意到在数组中

00:05:15.849 --> 00:05:17.718 align:middle
它们都是相同的类型
都是字符串

00:05:18.318 --> 00:05:21.188 align:middle
在名字数组中插入其它类型是
没有意义的

00:05:21.255 --> 00:05:24.224 align:middle
有一个整数 布尔型或自行车

00:05:24.725 --> 00:05:26.126 align:middle
这会很奇怪

00:05:26.760 --> 00:05:29.029 align:middle
对于名字
我们总是希望它们是字符串

00:05:29.530 --> 00:05:30.664 align:middle
我们可在Swift中表达它

00:05:30.731 --> 00:05:33.166 align:middle
我们可以说我们想要一个字符串
数组

00:05:33.233 --> 00:05:35.369 align:middle
当我们从中取出值时

00:05:35.435 --> 00:05:37.271 align:middle
我们可以把它当成字符串处理

00:05:38.038 --> 00:05:39.273 align:middle
这就是我们为何这样写

00:05:39.339 --> 00:05:42.442 align:middle
这是我们怎么写一个字符串数组
用方括号包围一个字符串

00:05:43.443 --> 00:05:44.611 align:middle
但是我们早前看到

00:05:45.479 --> 00:05:49.183 align:middle
如果右手边明显的表明了我们
想要的类型

00:05:49.583 --> 00:05:52.319 align:middle
Swift会为我们做推断
在这也会发生

00:05:52.386 --> 00:05:54.021 align:middle
我们不需要写下类型

00:05:54.321 --> 00:05:57.057 align:middle
很清楚我们想要字符串数组

00:05:57.791 --> 00:05:59.126 align:middle
对字典也是同样的

00:05:59.193 --> 00:06:02.329 align:middle
这里很明显我们想要键是字符串
值是整数

00:05:59.193 --> 00:06:02.329 align:middle
这里很明显我们想要键是字符串
值是整数

00:06:02.396 --> 00:06:06.099 align:middle
Swift可以为我们推断这些
所有东西都有清楚的类型

00:06:08.335 --> 00:06:11.638 align:middle
Swift有所以你在别的语言里知道
循环种类

00:06:11.705 --> 00:06:15.509 align:middle
我们有在执行循环体之前
检查条件用的While循环

00:06:16.043 --> 00:06:18.545 align:middle
一repeat-while循环
执行循环体一次

00:06:18.612 --> 00:06:21.081 align:middle
在检查条件前
来决定是否继续

00:06:22.015 --> 00:06:24.384 align:middle
我们先前看过我们有for-in循环

00:06:24.451 --> 00:06:26.653 align:middle
用来在字符串中遍历所有字符

00:06:27.421 --> 00:06:30.424 align:middle
这不是for-in唯一能做的事

00:06:31.258 --> 00:06:34.061 align:middle line:1
我们能用它遍历一个范围

00:06:34.127 --> 00:06:36.864 align:middle line:1
这里我们有一个从1到5的范围

00:06:36.930 --> 00:06:38.565 align:middle line:1
包括这些数字

00:06:38.632 --> 00:06:41.602 align:middle line:1
我们用来打印5个入口
在乘以4表中

00:06:42.302 --> 00:06:46.473 align:middle line:1
我们把它写成1... 5
这被称为闭合范围

00:06:46.540 --> 00:06:47.908 align:middle line:1
因为它包括2边的数字

00:06:48.675 --> 00:06:50.511 align:middle line:1
有时我们需要

00:06:50.577 --> 00:06:54.014 align:middle line:1
一个范围
运行到比最后的数字少1

00:06:54.548 --> 00:06:55.949 align:middle line:1
这是一个它很有用的例子

00:06:56.717 --> 00:06:59.987 align:middle line:1
我有一个整数数组
但我只想打印前5个

00:07:00.621 --> 00:07:05.058 align:middle line:1
因为数组的索引从0开始
我希望索引从0到4

00:07:05.792 --> 00:07:08.362 align:middle line:1
所以我们想要用半闭合范围运算符

00:07:08.428 --> 00:07:09.429 align:middle line:1
点 点 小于

00:07:09.496 --> 00:07:12.566 align:middle line:1
因为它运行到比最终的数字
在这是5小1

00:07:14.835 --> 00:07:17.037 align:middle line:1
我们可以对数组使用for-in循环

00:07:17.104 --> 00:07:19.773 align:middle line:1
这里我们为数组里的每个名字
打印一条信息

00:07:20.541 --> 00:07:22.376 align:middle line:1
我们也可以对字典使用它

00:07:22.943 --> 00:07:26.613 align:middle line:1
现在注意我们要遍历键和值

00:07:26.680 --> 00:07:28.682 align:middle line:1
名字和年龄
在同一时间

00:07:29.383 --> 00:07:32.486 align:middle line:1
这在Swift里被称为元组

00:07:32.553 --> 00:07:34.454 align:middle line:1
让你把多个值组合在一起

00:07:34.521 --> 00:07:35.789 align:middle line:1
同时使用它们

00:07:35.856 --> 00:07:38.225 align:middle line:1
我们晚点会看到另一个例子

00:07:38.425 --> 00:07:41.595 align:middle line:1
这使代码遍历一个字典时清楚很多

00:07:43.497 --> 00:07:45.699 align:middle line:1
我们要怎么修改这些集合？

00:07:46.366 --> 00:07:49.303 align:middle line:1
这是我今年 WWDC 的装箱单

00:07:49.369 --> 00:07:51.905 align:middle line:1
我把它申明我一个变量
所以我可以改变它

00:07:51.972 --> 00:07:55.042 align:middle line:1
我包括了基本的袜子和鞋子

00:07:56.677 --> 00:08:00.147 align:middle line:1
在 WWDC 2014

00:07:56.677 --> 00:08:00.147 align:middle line:1
在 WWDC 2014

00:08:00.214 --> 00:08:03.984 align:middle line:1
我忘记了我的袜子
这是一个恶梦

00:08:04.051 --> 00:08:05.853 align:middle
我不会再犯同样的错误

00:08:06.186 --> 00:08:10.057 align:middle
所以我们检查数组的第一项是袜子

00:08:10.123 --> 00:08:12.960 align:middle
2014后如果我把它放在列表里它
会是第一个

00:08:13.527 --> 00:08:15.295 align:middle
我们通过下标来这样做

00:08:15.362 --> 00:08:18.565 align:middle
在数组名后写一个在方括号里的
索引

00:08:18.632 --> 00:08:21.802 align:middle
如果我们打印这个值
我实际上记得添加袜子

00:08:23.070 --> 00:08:26.039 align:middle
袜子和鞋子还不够
但是为了一星期的会议

00:08:26.106 --> 00:08:28.809 align:middle
我还需要其他东西
让我们添加一个新物品

00:08:28.876 --> 00:08:31.245 align:middle line:1
让我们把裤子加入数组

00:08:31.311 --> 00:08:33.145 align:middle line:1
我们使用append方法

00:08:34.448 --> 00:08:35.782 align:middle line:1
但是这有一个问题

00:08:36.683 --> 00:08:39.852 align:middle line:1
这个会议是在美国
他们不叫裤子“trousers”

00:08:40.787 --> 00:08:42.121 align:middle line:1
他们叫裤子“pants”

00:08:42.188 --> 00:08:44.591 align:middle line:1
这会引起很多误解

00:08:44.791 --> 00:08:46.727 align:middle
所以让我们修改数组中的一个值

00:08:47.094 --> 00:08:49.062 align:middle
让我们把它改成牛仔裤

00:08:49.129 --> 00:08:52.432 align:middle line:1
我们又用下标来这样做
改变在索引2的项目

00:08:52.799 --> 00:08:55.536 align:middle line:1
牛仔裤在哪都一样
因此不会招致误解

00:08:57.371 --> 00:09:00.641 align:middle line:1
这个会议在加利福尼亚州
这里总是晴天很热

00:08:57.371 --> 00:09:00.641 align:middle line:1
这个会议在加利福尼亚州
这里总是晴天很热

00:09:01.208 --> 00:09:02.476 align:middle line:1
让我们再加一些东西

00:09:02.543 --> 00:09:06.446 align:middle line:1
让我们加一些短裤 拖鞋 防晒霜

00:09:07.147 --> 00:09:09.716 align:middle line:1
我们可用append
contentsOf方法

00:09:09.783 --> 00:09:12.452 align:middle line:1
并传递一个兼容的数组
另一个字符串数组

00:09:13.120 --> 00:09:15.022 align:middle line:1
它们在同一时间都被添加

00:09:16.523 --> 00:09:21.094 align:middle line:1
这个会议是在加利福尼亚州的
旧金山

00:09:21.628 --> 00:09:23.163 align:middle line:1
这里并不总是天晴并且炎热

00:09:23.764 --> 00:09:25.566 align:middle line:1
所以让我们修改一下这三项

00:09:25.632 --> 00:09:28.302 align:middle
用连帽衫和围巾来代替

00:09:29.069 --> 00:09:31.738 align:middle
我们可以通过传递一个下标范围
来这么做

00:09:32.005 --> 00:09:33.974 align:middle
注意我们要修改三项中的两项

00:09:34.041 --> 00:09:35.943 align:middle line:1
这在Swift中是合法的

00:09:37.811 --> 00:09:40.214 align:middle line:1
那对于字典呢？
让我们修改一个字典

00:09:40.547 --> 00:09:44.117 align:middle line:1
这里是我的年龄字典

00:09:44.184 --> 00:09:46.520 align:middle line:1
我想加入其他人

00:09:46.587 --> 00:09:51.191 align:middle line:1
我们通过用下标的办法
来为一个还没有值的键加一个值

00:09:51.258 --> 00:09:52.659 align:middle line:1
我加入了Justyn

00:09:53.660 --> 00:09:56.129 align:middle line:1
但是仔细想想
上周是Justyn的生日

00:09:56.196 --> 00:09:57.397 align:middle line:1
所以这个值现在不对

00:09:57.464 --> 00:10:00.901 align:middle line:1
我需要更新它
我还是用一样的方法

00:09:57.464 --> 00:10:00.901 align:middle line:1
我需要更新它
我还是用一样的方法

00:10:00.968 --> 00:10:02.936 align:middle line:1
我给同一个键赋不同的值

00:10:03.003 --> 00:10:04.404 align:middle line:1
现在我的字典是对的了

00:10:06.607 --> 00:10:09.576 align:middle
如果我想要从字典里取出一个值

00:10:10.077 --> 00:10:12.246 align:middle
如果我想知道是否有Devon的年龄

00:10:12.312 --> 00:10:15.382 align:middle
或者Daryl
或者Daniel

00:10:16.650 --> 00:10:19.319 align:middle
可能在字典对这些人有一个值

00:10:19.386 --> 00:10:22.189 align:middle
也可能没有
我们需要一个方式来应对这种情况

00:10:22.956 --> 00:10:26.226 align:middle
这是Swift的被称为可选的一个
功能的好的使用案例

00:10:27.294 --> 00:10:31.532 align:middle line:1
如果我们试着对Amy这样做
我们可能期望有个值是40

00:10:32.299 --> 00:10:34.768 align:middle line:1
如果我们对Daryl这么做
我们应该得到什么？

00:10:34.835 --> 00:10:36.236 align:middle line:1
这里对Daryl没有值

00:10:37.938 --> 00:10:39.239 align:middle
这样考虑这个问题

00:10:39.907 --> 00:10:43.677 align:middle
或者在字典里Amy有一个整数值

00:10:44.244 --> 00:10:47.915 align:middle
或者没有一个整数值
像例子里的Daryl

00:10:49.216 --> 00:10:54.087 align:middle
所以这里我们有一个可选的整数
我们写成Int问号

00:10:54.788 --> 00:10:56.823 align:middle
问号表示这里可能有值

00:10:56.890 --> 00:10:57.991 align:middle
也可能没有

00:10:59.860 --> 00:11:02.196 align:middle
我们看看我们是否找到一个值

00:10:59.860 --> 00:11:02.196 align:middle
我们看看我们是否找到一个值

00:11:02.262 --> 00:11:03.897 align:middle
通过把它和nil比较

00:11:03.964 --> 00:11:06.834 align:middle
nil是一种特殊情况
是没有值的简写

00:11:07.401 --> 00:11:09.870 align:middle
如果对Daryl这么做
没有值

00:11:09.937 --> 00:11:11.071 align:middle
我们会打印这个信息

00:11:12.406 --> 00:11:13.240 align:middle
年龄没有找到

00:11:14.041 --> 00:11:16.743 align:middle
如果我们试着对Amy这样做
我们找到一个值

00:11:16.810 --> 00:11:19.479 align:middle
所以它不等于nil
我们不打印这个消息

00:11:21.014 --> 00:11:23.183 align:middle
一般我们不仅仅查看一个值是否
存在

00:11:23.250 --> 00:11:25.319 align:middle
当它存在时我们想使用它

00:11:25.385 --> 00:11:27.955 align:middle
Swift有一种简单的写法

00:11:28.288 --> 00:11:29.456 align:middle
写下“if let”

00:11:30.858 --> 00:11:35.195 align:middle
它是说如果字典含有Amy的值

00:11:36.129 --> 00:11:38.832 align:middle
让一个新的常量age等于那个值

00:11:39.533 --> 00:11:42.135 align:middle line:1
我们就可以在if语句里使用那个值

00:11:42.970 --> 00:11:45.072 align:middle line:1
请注意在此我们把它当成
真正的整数使用

00:11:45.138 --> 00:11:46.373 align:middle line:1
它不再是可选的

00:11:47.307 --> 00:11:50.110 align:middle line:1
if语句查看它的值并解包

00:11:50.177 --> 00:11:53.447 align:middle line:1
给我们一个普通的整数
我们可以对它做整数的操作

00:11:55.649 --> 00:11:57.818 align:middle
我们看了一些if语句

00:11:57.885 --> 00:11:59.987 align:middle
这是另一个
用来打印生日消信

00:12:00.721 --> 00:12:03.056 align:middle
有两件事需要注意

00:12:04.057 --> 00:12:07.895 align:middle
首先我们不需要在条件附近有括号
只需要写下条件

00:12:09.029 --> 00:12:13.133 align:middle
第二我们给每一部分的语句加
大括号

00:12:13.200 --> 00:12:15.936 align:middle
加表明哪部分代码会被执行

00:12:18.071 --> 00:12:21.508 align:middle
此外我们还有switch语句

00:12:21.575 --> 00:12:24.378 align:middle
可以用来写更复杂更强大的匹配

00:12:25.345 --> 00:12:28.949 align:middle
它转换一个常量或者变量的当前值

00:12:29.016 --> 00:12:30.817 align:middle
和一系列可能的情况匹配

00:12:31.552 --> 00:12:33.554 align:middle
比如我们有这种情况

00:12:33.620 --> 00:12:36.623 align:middle
如果年龄值是1

00:12:36.690 --> 00:12:39.426 align:middle
我们想要打印第一个生日快乐的
消息

00:12:40.127 --> 00:12:42.062 align:middle
我们也可以匹配范围

00:12:42.262 --> 00:12:44.831 align:middle
匹配任意值使一些人是青少年

00:12:45.666 --> 00:12:48.936 align:middle
我们可以匹配更复杂的模式
比如这一个

00:12:49.002 --> 00:12:52.139 align:middle
一个叫decade的临时常量

00:12:52.606 --> 00:12:54.641 align:middle
等于我们当前要匹配的值

00:12:55.309 --> 00:12:57.377 align:middle
检查是否能被10整除

00:12:58.245 --> 00:13:01.815 align:middle
如果可以
用它打印一条特殊的生日消息

00:12:58.245 --> 00:13:01.815 align:middle
如果可以
用它打印一条特殊的生日消息

00:13:01.882 --> 00:13:06.220 align:middle
为任何人刚满30或40岁或其他
重要的年龄

00:13:07.788 --> 00:13:10.424 align:middle
但这有一个问题

00:13:11.525 --> 00:13:15.062 align:middle
如果我们想要为以下年龄的人打印
消息 比如41

00:13:15.462 --> 00:13:17.664 align:middle
97或56

00:13:18.632 --> 00:13:20.200 align:middle
它们不会得到一个消息

00:13:20.267 --> 00:13:23.070 align:middle
听起来很不幸
特别是在它们的生日上

00:13:25.038 --> 00:13:26.640 align:middle
坦白说Swift在这帮助我们

00:13:27.040 --> 00:13:30.277 align:middle
Swift确保switch语句
是完整的

00:13:30.344 --> 00:13:33.780 align:middle
你不会偶然的忘记你需要的情况

00:13:34.448 --> 00:13:37.084 align:middle
在这个例子里
我们可以加一个default语句

00:13:37.317 --> 00:13:40.888 align:middle line:1
捕获每一个我们之前没有捕获的
情况

00:13:40.954 --> 00:13:43.357 align:middle line:1
说无聊的生日快乐

00:13:45.559 --> 00:13:47.261 align:middle line:1
这里有另一个switch语句

00:13:48.095 --> 00:13:51.932 align:middle
它获得一个字符串值用户名
和一个布尔型值

00:13:51.999 --> 00:13:54.735 align:middle
指示用户密码是否合法

00:13:55.469 --> 00:13:57.771 align:middle
我们会一起用这两个值

00:13:57.838 --> 00:14:00.073 align:middle
来产生一个合适的消息用来显示

00:13:57.838 --> 00:14:00.073 align:middle
来产生一个合适的消息用来显示

00:14:00.140 --> 00:14:02.509 align:middle
当用户要登录一个受限的区域

00:14:03.777 --> 00:14:07.481 align:middle
要这样做 我们可以同时switch
两个值

00:14:08.015 --> 00:14:09.783 align:middle
用一个元组
像之前做过的那样

00:14:10.918 --> 00:14:13.620 align:middle
这表明我们可以写一些非常非常
有趣的case

00:14:13.687 --> 00:14:15.455 align:middle
有趣的switch case

00:14:15.522 --> 00:14:17.524 align:middle
可有一个case
是用户名为admin

00:14:17.591 --> 00:14:19.126 align:middle
密码为真

00:14:19.193 --> 00:14:21.328 align:middle
然后打印消息来欢迎管理员回来

00:14:22.863 --> 00:14:24.598 align:middle
现在如果是一个客人

00:14:24.665 --> 00:14:27.234 align:middle
我们永远都不希望客人进入受限
区域

00:14:27.301 --> 00:14:28.936 align:middle
即使密码是合法的

00:14:29.436 --> 00:14:32.706 align:middle
我们可以用下划线来忽略密码

00:14:33.273 --> 00:14:35.742 align:middle
它的意思是匹配任意可能的值

00:14:36.977 --> 00:14:38.478 align:middle
对所有其他用户

00:14:38.545 --> 00:14:41.782 align:middle
我们不关心用户名是什么
我们只关心密码

00:14:41.849 --> 00:14:43.617 align:middle
我们可以忽略用户名

00:14:44.184 --> 00:14:47.054 align:middle
我们切换到我们想要做的

00:14:47.120 --> 00:14:48.655 align:middle
检查密码合法性

00:14:48.922 --> 00:14:51.892 align:middle
要这么做我们创建一个叫做
IsValid的临时常量

00:14:52.459 --> 00:14:55.562 align:middle
然后我们用三元条件运算符

00:14:55.629 --> 00:14:57.998 align:middle
就是这个问号和冒号

00:14:59.166 --> 00:15:01.602 align:middle
来说如果是合法的
用这个消息

00:14:59.166 --> 00:15:01.602 align:middle
来说如果是合法的
用这个消息

00:15:01.668 --> 00:15:03.871 align:middle
否则用这个消息

00:15:05.005 --> 00:15:06.707 align:middle
如果我们浏览一些例子

00:15:07.774 --> 00:15:10.010 align:middle
如果使用管理员并且密码有效

00:15:10.077 --> 00:15:12.679 align:middle
他们将得到一个管理员消息
就像我预期的那样

00:15:13.614 --> 00:15:16.817 align:middle
如果我们试着用客人
即使密码有效

00:15:16.884 --> 00:15:19.720 align:middle
他们得到对不起你不能进入的消息

00:15:20.320 --> 00:15:22.823 align:middle
如果我们用Bob并且密码有效

00:15:22.890 --> 00:15:25.058 align:middle
他获得预期的欢迎消息

00:15:25.592 --> 00:15:28.428 align:middle
但如果他的密码无效
他得到访问被拒绝的消息

00:15:30.664 --> 00:15:34.268 align:middle
现在关于这个switch语句
有最后一个需要注意的点

00:15:35.068 --> 00:15:37.437 align:middle
它没有默认这个情况

00:15:38.305 --> 00:15:40.374 align:middle
它没有的原因是它不需要

00:15:40.440 --> 00:15:42.042 align:middle
它已经是完整的

00:15:42.109 --> 00:15:46.346 align:middle
如果我们看一下后这个case

00:15:46.713 --> 00:15:49.850 align:middle
实际上它包括了所有可能的情况

00:15:49.917 --> 00:15:51.451 align:middle
我们没有在上面匹配到的

00:15:51.518 --> 00:15:53.921 align:middle
所以switch语句不需要default
就已经完整了

00:15:56.023 --> 00:15:58.926 align:middle
这就是Swift语言的一些基本知识

00:15:58.992 --> 00:16:00.994 align:middle
现在我想把演讲交给
我的同事Brian

00:15:58.992 --> 00:16:00.994 align:middle
现在我想把演讲交给
我的同事Brian

00:16:01.061 --> 00:16:03.463 align:middle
来介绍Swift中的函数和闭包

00:16:08.802 --> 00:16:11.038 align:middle
好的 谢谢Dave
就像我已经说过的

00:16:11.104 --> 00:16:13.974 align:middle
让我从怎样在Swift中
定义函数开始

00:16:14.675 --> 00:16:17.110 align:middle
你用func关键字定义函数

00:16:17.177 --> 00:16:19.513 align:middle
然后你在大括号里实现它

00:16:19.580 --> 00:16:22.416 align:middle
我们定义了一个简单的函数
叫做sendMessage

00:16:22.482 --> 00:16:24.251 align:middle
打印消息到控制台

00:16:25.419 --> 00:16:27.821 align:middle
然后你可以用一个直观的方式
调用这个函数

00:16:27.888 --> 00:16:32.392 align:middle line:1
通过写下其名sendMessage
接着是一对空括号

00:16:33.293 --> 00:16:34.962 align:middle line:1
让我们给这个函数加上参数

00:16:35.028 --> 00:16:38.198 align:middle line:1
来表明消息是否应该吼叫

00:16:39.366 --> 00:16:41.802 align:middle
你写下参数的名称
接着是冒号

00:16:41.869 --> 00:16:43.070 align:middle
然后是参数的类型

00:16:43.136 --> 00:16:46.406 align:middle
就像你申明一个常量或变量
所做的那样

00:16:46.940 --> 00:16:50.110 align:middle
我们添加了一个叫做shouting
的参数 它是布尔类型

00:16:50.844 --> 00:16:52.079 align:middle
当你调用这个函数时

00:16:52.145 --> 00:16:55.716 align:middle
参数的名称为你传入的参数提供
一个标签

00:16:57.618 --> 00:17:00.287 align:middle line:1
给参数加标签使代码更易读

00:16:57.618 --> 00:17:00.287 align:middle line:1
给参数加标签使代码更易读

00:17:00.354 --> 00:17:03.056 align:middle line:1
使参数的目的清楚

00:17:03.757 --> 00:17:06.193 align:middle line:1
在这个情况下
如果没有shouting标签

00:17:06.260 --> 00:17:09.229 align:middle line:1
一些阅读你的代码的人可能以为
那个真是表明

00:17:09.296 --> 00:17:11.565 align:middle line:1
是否发送这条消息

00:17:12.965 --> 00:17:14.233 align:middle line:1
所以你可以喊出一个消息

00:17:14.300 --> 00:17:15.836 align:middle line:1
但是你要把消息发给谁？

00:17:16.403 --> 00:17:17.738 align:middle line:1
让我们加入另一个参数

00:17:17.804 --> 00:17:19.873 align:middle line:1
使我们把消息发给特定的人

00:17:21.308 --> 00:17:23.343 align:middle
在这我们添加一个参数叫做接收人

00:17:23.410 --> 00:17:24.877 align:middle
是一个字符串类型

00:17:24.944 --> 00:17:28.982 align:middle
我们还通过字符串插入将接收人
姓名加入我们的消息中

00:17:30.417 --> 00:17:33.654 align:middle line:1
当你调用函数时你可以传入接收人
姓名

00:17:34.555 --> 00:17:37.291 align:middle line:1
现在虽然这个消息按你期待的
那样打印

00:17:37.357 --> 00:17:39.526 align:middle line:1
它读起来不是很好

00:17:40.127 --> 00:17:43.497 align:middle
发送消息接收人
Morgan读起来很怪

00:17:43.964 --> 00:17:46.233 align:middle
当你调用函数时你希望它读起来
自然

00:17:46.300 --> 00:17:48.335 align:middle
在这个例子中你希望读起来像

00:17:48.402 --> 00:17:52.206 align:middle
发送消息给Morgan
这形成一个有好的语法的短语

00:17:52.806 --> 00:17:55.475 align:middle
你可以通过改变参数名称来这样做

00:17:55.542 --> 00:17:58.212 align:middle
这也会改变参数的标签名

00:17:58.278 --> 00:18:00.981 align:middle
这使得函数被调用时读起来好一些

00:17:58.278 --> 00:18:00.981 align:middle
这使得函数被调用时读起来好一些

00:18:01.048 --> 00:18:02.883 align:middle
发送消息给Morgan

00:18:02.950 --> 00:18:06.153 align:middle
但是这在函数内部工作的不好

00:18:07.187 --> 00:18:11.091 align:middle
在函数体里你希望参数是一个名词
而不是一个介词

00:18:11.158 --> 00:18:13.560 align:middle
嘿给听起来不好

00:18:14.461 --> 00:18:17.197 align:middle
但是有时没有一个单词能工作良好

00:18:17.264 --> 00:18:21.368 align:middle
既在函数体内
又在调用函数的标签

00:18:21.969 --> 00:18:24.104 align:middle
在Swift中你不用放弃其中的一个

00:18:24.605 --> 00:18:26.406 align:middle
当一个参数的名称不合适时

00:18:26.473 --> 00:18:29.710 align:middle
参数的标签

00:18:29.776 --> 00:18:31.778 align:middle
你可以明确地提供一个更合适的
名称

00:18:33.080 --> 00:18:36.817 align:middle
你把这个明确的参数标签写在
参数名前

00:18:36.884 --> 00:18:39.520 align:middle
在这我们添加to作为明确的参数标签

00:18:39.586 --> 00:18:41.622 align:middle
在接收者参数的之上

00:18:41.688 --> 00:18:43.524 align:middle
这表示你可以用“to”

00:18:43.590 --> 00:18:46.093 align:middle
当你调用函数发送消息给Morgan

00:18:46.159 --> 00:18:49.630 align:middle
然后你仍然可以在函数体内
使用接收者

00:18:51.098 --> 00:18:53.634 align:middle
让我们添加另一个参数到函数中

00:18:53.700 --> 00:18:55.802 align:middle
使你调用它时能提供一个定制消息

00:18:57.504 --> 00:19:00.174 align:middle
这里我们添加了一个消息参数
是字符串类型

00:18:57.504 --> 00:19:00.174 align:middle
这里我们添加了一个消息参数
是字符串类型

00:19:00.240 --> 00:19:03.010 align:middle
现在我们调用函数
你可以传递你自己的消息

00:19:04.745 --> 00:19:07.481 align:middle line:1
再一次的
代码如预期一样运行

00:19:07.548 --> 00:19:09.516 align:middle line:1
但是读起来还是不好

00:19:10.050 --> 00:19:12.686 align:middle line:1
发送消息消息是重复的

00:19:13.587 --> 00:19:17.824 align:middle
消息标签无助于澄清第一个
参数的作用

00:19:17.891 --> 00:19:20.394 align:middle
因为函数名中已经说清楚了

00:19:20.460 --> 00:19:21.461 align:middle
发送消息

00:19:22.329 --> 00:19:24.998 align:middle
在这里参数标签使代码更难读

00:19:25.732 --> 00:19:26.834 align:middle
在这种情况

00:19:26.900 --> 00:19:29.469 align:middle
你可以在参数名前写一个下划线

00:19:30.304 --> 00:19:32.840 align:middle
这表明你不给参数提供标签

00:19:32.906 --> 00:19:34.174 align:middle
当你调用函数时

00:19:37.277 --> 00:19:39.513 align:middle
这时我们的函数读起来自然

00:19:39.580 --> 00:19:41.548 align:middle
发送消息 在Bash见
给Morgan

00:19:43.784 --> 00:19:46.420 align:middle
我们不常需要喊出我们的消息

00:19:46.486 --> 00:19:49.523 align:middle
我们通常传递假给这个参数

00:19:50.157 --> 00:19:51.825 align:middle
在Swift你可以捕获这个行为

00:19:51.892 --> 00:19:54.027 align:middle
在函数申明中

00:19:54.695 --> 00:19:57.631 align:middle
当参数有一个常用到的值时

00:19:57.698 --> 00:19:59.900 align:middle
你可以把它作为default值

00:20:01.001 --> 00:20:04.438 align:middle
你能过赋一个default值
在这个情况下是假

00:20:04.505 --> 00:20:06.340 align:middle
在参数的类型的后面

00:20:07.074 --> 00:20:08.442 align:middle
当你调用函数时

00:20:08.509 --> 00:20:10.677 align:middle
你可以忽略相应的参数

00:20:10.744 --> 00:20:12.346 align:middle
default值被使用

00:20:15.015 --> 00:20:18.752 align:middle line:1
当你决定是否使用 怎样使用
明确的参数标签

00:20:18.819 --> 00:20:22.990 align:middle line:1
什么时候忽略一个参数或者提供
一个default值

00:20:23.056 --> 00:20:25.826 align:middle line:1
记得函数只被申明一次

00:20:25.893 --> 00:20:27.361 align:middle line:1
但是被重复使用

00:20:27.427 --> 00:20:29.296 align:middle line:1
最重要的事是

00:20:29.363 --> 00:20:32.232 align:middle line:1
函数被调用时读起来清楚准确

00:20:33.467 --> 00:20:34.701 align:middle line:1
现在让我们学习更多

00:20:34.768 --> 00:20:36.436 align:middle line:1
你需要考虑的事

00:20:36.503 --> 00:20:38.238 align:middle line:1
当编写优秀Swift API时

00:20:38.939 --> 00:20:41.141 align:middle line:1
请去看Swift API指导演讲

00:20:42.309 --> 00:20:44.811 align:middle
我们已经看了很多种函数获得
值的方式

00:20:45.312 --> 00:20:48.015 align:middle
让我们看看让它们返回值的方法

00:20:48.815 --> 00:20:50.250 align:middle
假设你想写一个函数

00:20:50.317 --> 00:20:53.453 align:middle
返回数组里第一个有给定前缀的
字符串

00:20:54.588 --> 00:20:56.423 align:middle
函数获得一个字符串前缀

00:20:57.391 --> 00:20:58.692 align:middle
一个字符串数组

00:20:59.660 --> 00:21:02.196 align:middle
返回一个有给定前缀的字符串

00:20:59.660 --> 00:21:02.196 align:middle
返回一个有给定前缀的字符串

00:21:02.262 --> 00:21:03.797 align:middle
如你所见 你用一个箭头

00:21:03.864 --> 00:21:06.433 align:middle
来表明函数值的类型

00:21:06.500 --> 00:21:07.668 align:middle
在这里是字符串

00:21:08.735 --> 00:21:10.137 align:middle
让我们看看这是怎么工作的

00:21:11.438 --> 00:21:14.575 align:middle
首先用一个for-in循环来遍历
数组中的每一个字符串

00:21:15.375 --> 00:21:17.711 align:middle
然后检测字符串是否有给定的前缀

00:21:19.413 --> 00:21:21.515 align:middle
你需要检测字符串
是否有给定的前缀

00:21:21.582 --> 00:21:23.550 align:middle
使用string.hasprefix方法

00:21:23.917 --> 00:21:27.020 align:middle
如果它有 那么完成了
你只需要返回这个字符串

00:21:27.087 --> 00:21:28.889 align:middle
通过将它写进返回语句

00:21:30.724 --> 00:21:31.859 align:middle
但是你要返回什么

00:21:31.925 --> 00:21:34.261 align:middle
如果数组不含有你在找的字符串？

00:21:35.128 --> 00:21:37.564 align:middle
因为这个函数申明了会返回字符串

00:21:37.631 --> 00:21:40.734 align:middle
唯一的选项是一些合法的字符串

00:21:40.801 --> 00:21:42.236 align:middle
在这个情况下是空字符串

00:21:43.003 --> 00:21:44.304 align:middle
但这不是好的Swift代码

00:21:45.405 --> 00:21:48.041 align:middle
但是像Dave演示过的
可选是完美的

00:21:48.108 --> 00:21:50.410 align:middle
用来表明值有可能不存在

00:21:51.712 --> 00:21:54.181 align:middle
所以你只需要改变函数返回类型

00:21:54.248 --> 00:21:57.184 align:middle
为可选字符串
通过在字符串后写一个问号

00:21:57.584 --> 00:22:00.487 align:middle
现在你可以返回nil
当字符串没有找到时

00:21:57.584 --> 00:22:00.487 align:middle
现在你可以返回nil
当字符串没有找到时

00:22:01.388 --> 00:22:04.124 align:middle line:1
因为函数返回可选的字符串

00:22:04.191 --> 00:22:06.560 align:middle line:1
你可以在一个if-let语句里安全
地使用它

00:22:07.528 --> 00:22:10.497 align:middle line:1
请注意Swift推断函数的返回类型

00:22:10.564 --> 00:22:12.666 align:middle
所以不需要明确的写出来

00:22:14.434 --> 00:22:16.003 align:middle
我们看了一些方法

00:22:16.069 --> 00:22:19.072 align:middle
函数能获得和返回不同类型

00:22:19.139 --> 00:22:22.943 align:middle
比如字符串 整数 数组
和可选类型

00:22:23.243 --> 00:22:25.913 align:middle
让我们看看怎么写另一种函数

00:22:28.015 --> 00:22:30.651 align:middle
假设你要写一个函数过滤一个
数字数组

00:22:30.717 --> 00:22:32.085 align:middle
基于一些条件

00:22:33.120 --> 00:22:34.988 align:middle
让我们想想这个函数需要做什么

00:22:36.223 --> 00:22:37.925 align:middle line:1
它要获得一个数字数组

00:22:38.358 --> 00:22:39.927 align:middle line:1
对数组中的每一个数字

00:22:39.993 --> 00:22:43.330 align:middle line:1
函数判断是否将它包含在被过滤
的结果中

00:22:44.364 --> 00:22:48.635 align:middle line:1
比如你想要一个数组
被过滤成只含有偶数

00:22:49.469 --> 00:22:51.772 align:middle line:1
你可以测试每个数是否能被2整除

00:22:52.339 --> 00:22:56.210 align:middle line:1
4当然是偶数
所以它被包括在结果数组里

00:22:57.978 --> 00:23:00.180 align:middle line:1
如果一个数不是偶数
比如17

00:22:57.978 --> 00:23:00.180 align:middle line:1
如果一个数不是偶数
比如17

00:23:01.114 --> 00:23:03.884 align:middle line:1
过滤函数转而检测下一个数

00:23:03.951 --> 00:23:05.886 align:middle line:1
然后继续 遍历剩下的数组

00:23:06.920 --> 00:23:08.822 align:middle line:1
让我们看看写这个函数的代码

00:23:10.858 --> 00:23:13.227 align:middle
函数申明是你想要的

00:23:13.493 --> 00:23:16.230 align:middle
但是你要把什么类型放在
这个包括数字参数这里？

00:23:16.964 --> 00:23:21.101 align:middle
你刚刚看到
决定是否把数字包括进结果里

00:23:21.668 --> 00:23:23.570 align:middle
是一个函数

00:23:23.637 --> 00:23:26.139 align:middle
不是一个简单的值比如字符串
或者一个数字

00:23:27.241 --> 00:23:31.245 align:middle
在Swift里函数可以接收其他函数
做为参数

00:23:31.912 --> 00:23:34.014 align:middle
那么函数类型看起来是怎样的？

00:23:35.182 --> 00:23:37.684 align:middle
所有的函数类型在Swift中
都有基本的形式

00:23:38.085 --> 00:23:40.521 align:middle
函数参数类型
如果有的话

00:23:40.587 --> 00:23:43.757 align:middle
在括号里
跟随的是一个箭头

00:23:43.824 --> 00:23:44.858 align:middle
然后是函数返回类型

00:23:46.326 --> 00:23:49.663 align:middle
比如说我们早前的发送消息函数

00:23:50.163 --> 00:23:52.266 align:middle
它有空的括号

00:23:52.332 --> 00:23:55.169 align:middle
因为它不需要任何参数
箭头空

00:23:55.836 --> 00:23:58.405 align:middle
这里空表示它不返回任何值

00:23:59.406 --> 00:24:01.575 align:middle
在Swift中如果你的函数不返回
任何值

00:23:59.406 --> 00:24:01.575 align:middle
在Swift中如果你的函数不返回
任何值

00:24:01.642 --> 00:24:04.478 align:middle
你不需要明确的写箭头空

00:24:08.715 --> 00:24:11.218 align:middle
这是第一个字符串函数

00:24:11.385 --> 00:24:13.353 align:middle
它的签名复杂一些

00:24:13.420 --> 00:24:15.489 align:middle
但是它的类型还是遵循基本的形式

00:24:16.256 --> 00:24:19.793 align:middle
它获得一个字符串一个数组
一个字符串参数并返回一个可选字符串

00:24:20.327 --> 00:24:23.096 align:middle
你们已经知道了函数类型的语法

00:24:23.163 --> 00:24:26.767 align:middle
所以很清楚你要怎么完成过滤
整数这个函数的申明

00:24:27.768 --> 00:24:29.169 align:middle
这个包括数字参数

00:24:29.236 --> 00:24:33.207 align:middle
可以是任何函数获得一个整数
返回一个布尔型

00:24:33.273 --> 00:24:37.511 align:middle
你把类型Int写在括号里
箭头布尔

00:24:38.212 --> 00:24:40.380 align:middle
让我们来完成函数的剩余部分

00:24:41.915 --> 00:24:44.151 align:middle
你需要生成一个过滤过的数字
的数组

00:24:44.218 --> 00:24:46.019 align:middle
这有一个变量叫做结果

00:24:46.086 --> 00:24:48.755 align:middle
它被初始化为一个整数数组

00:24:49.423 --> 00:24:52.392 align:middle
随着你遍历传给这个函数的数组

00:24:52.559 --> 00:24:55.796 align:middle
检查每个数字是否应该包括在
结果数组里

00:24:56.830 --> 00:25:00.501 align:middle
要这么做 你把每个数字传递给
包括数字函数

00:24:56.830 --> 00:25:00.501 align:middle
要这么做 你把每个数字传递给
包括数字函数

00:25:00.567 --> 00:25:02.636 align:middle
注意在过滤整数函数体内

00:25:02.703 --> 00:25:07.441 align:middle
包括数字参数被当成被传入的函数
的名字

00:25:07.908 --> 00:25:09.009 align:middle
那说明你可以调用它

00:25:09.076 --> 00:25:11.311 align:middle
和调用其实函数相同的方式

00:25:12.412 --> 00:25:13.780 align:middle
这就是你怎么写一个函数

00:25:13.847 --> 00:25:15.949 align:middle
获得另一个函数做为一个参数

00:25:16.450 --> 00:25:18.452 align:middle
但是你怎么调用这类函数？

00:25:19.720 --> 00:25:22.689 align:middle
首先你需要把一些值传递给过滤
整数函数

00:25:22.756 --> 00:25:24.458 align:middle
这是一个数字数组

00:25:24.525 --> 00:25:26.927 align:middle
和一个简单的函数叫做可被2整除

00:25:26.994 --> 00:25:28.896 align:middle
表明一个整数是否是偶数

00:25:31.465 --> 00:25:34.334 align:middle
你可以看到能被2整除的类型

00:25:34.401 --> 00:25:37.104 align:middle
和包括数字参数的类型匹配

00:25:37.671 --> 00:25:42.676 align:middle
这表明我们可以传递能被2整除
函数

00:25:43.143 --> 00:25:45.145 align:middle
给过滤整数函数做为一个参数

00:25:46.346 --> 00:25:50.284 align:middle
你通过简单地传递能被2整除
函数的名字

00:25:51.218 --> 00:25:53.854 align:middle line:1
现在你得到一个数组只含有偶数

00:25:54.788 --> 00:25:57.057 align:middle line:1
注意你没有包括括号

00:25:57.124 --> 00:25:59.793 align:middle line:1
当传递能被2整除函数时

00:25:59.860 --> 00:26:02.362 align:middle line:1
这是因为你现在并没有调用它

00:25:59.860 --> 00:26:02.362 align:middle line:1
这是因为你现在并没有调用它

00:26:02.429 --> 00:26:05.299 align:middle line:1
它在晚些时候在过滤整数函数体
内被调用

00:26:07.201 --> 00:26:10.037 align:middle line:1
还要注意我们传递了数组的名字

00:26:11.238 --> 00:26:14.007 align:middle line:1
我们也可以传递数组字面值

00:26:14.474 --> 00:26:16.910 align:middle line:1
比如如果你只需要传递少量值

00:26:16.977 --> 00:26:19.746 align:middle line:1
不需要创建一个常量
为了等会的重用

00:26:21.081 --> 00:26:24.184 align:middle line:1
传递函数参数也可以这样

00:26:26.653 --> 00:26:29.323 align:middle line:1
很可能能被2整除函数

00:26:29.389 --> 00:26:30.757 align:middle line:1
不会被重用

00:26:31.291 --> 00:26:33.794 align:middle line:1
新建一个函数很麻烦

00:26:33.861 --> 00:26:37.231 align:middle line:1
每次你想要传递不同的过滤函数
条件

00:26:38.565 --> 00:26:41.368 align:middle line:1
如果你看看能被2整除的重要部分

00:26:41.668 --> 00:26:43.637 align:middle line:1
你可以看到给它一个名字

00:26:43.704 --> 00:26:46.573 align:middle line:1
仅仅是为了方便重用

00:26:47.941 --> 00:26:50.210 align:middle
能被2整除仅仅是一个名字

00:26:50.277 --> 00:26:52.679 align:middle
针对你所看重的功能

00:26:54.715 --> 00:26:58.552 align:middle
在Swift中像你可以写
一个字面值字符串或字面值数组

00:26:58.619 --> 00:27:01.522 align:middle
你也可以写一个
没有名字的字面值函数

00:26:58.619 --> 00:27:01.522 align:middle
你也可以写一个
没有名字的字面值函数

00:27:01.588 --> 00:27:04.224 align:middle
被称为闭包表达式
并在你的代码中被传递

00:27:05.325 --> 00:27:06.860 align:middle
写一个闭包表达示的语法

00:27:06.927 --> 00:27:09.363 align:middle
和函数申明很像

00:27:09.429 --> 00:27:10.898 align:middle
除了它没有名字

00:27:11.832 --> 00:27:15.903 align:middle
把整个闭包的函数写在大括号中

00:27:15.969 --> 00:27:20.741 align:middle
用in关键字把闭包函数体和
签名区分开

00:27:20.807 --> 00:27:23.777 align:middle
用数字参数类型是整数

00:27:23.844 --> 00:27:26.280 align:middle
在闭包的函数体内返回一个布尔型

00:27:28.649 --> 00:27:31.752 align:middle
这是最明确和最完整的定义闭包
的方式

00:27:32.452 --> 00:27:33.720 align:middle
但是你之前见过了

00:27:33.787 --> 00:27:37.157 align:middle
Swift可以推断很多信息
从代码的上下文中

00:27:39.393 --> 00:27:42.829 align:middle
比如闭包的函数类型已知

00:27:42.896 --> 00:27:45.566 align:middle
从包括数字这个参数的类型中

00:27:46.099 --> 00:27:48.202 align:middle
所以你不需要明确的写出来

00:27:49.670 --> 00:27:53.207 align:middle
如果整个闭包的体只是一个
返回语句

00:27:53.273 --> 00:27:56.777 align:middle
像这里一样你不需要明确的写
出return关键字

00:27:58.345 --> 00:28:02.382 align:middle
这是更干净的语法
但是因为闭包很短

00:27:58.345 --> 00:28:02.382 align:middle
这是更干净的语法
但是因为闭包很短

00:28:02.649 --> 00:28:05.652 align:middle
看起来这个参数数字都显得有点
多余

00:28:06.186 --> 00:28:09.790 align:middle
像这种情况
Swift提供暗示的变量名

00:28:09.857 --> 00:28:13.460 align:middle
所以不需要写出参数名或者in
关键字

00:28:14.928 --> 00:28:16.230 align:middle
这个暗示的文件名

00:28:16.296 --> 00:28:18.732 align:middle
用一个美元符号开始
以及一个从0开始的数字

00:28:18.799 --> 00:28:23.136 align:middle
$0表示第一个闭包参数
$1是第二个 等等

00:28:24.238 --> 00:28:27.574 align:middle
虽然这可以在任何闭包表达式中
使用

00:28:28.275 --> 00:28:31.979 align:middle
使用它们不会使你的代码变得
难以阅读

00:28:33.714 --> 00:28:37.818 align:middle line:1
现在你看到Swift提供很多方便的
编写闭包的方式

00:28:37.985 --> 00:28:41.255 align:middle line:1
但是直接在一个函数的括号中
传递它们

00:28:41.688 --> 00:28:43.457 align:middle line:1
看起来有很多符号

00:28:44.258 --> 00:28:47.060 align:middle line:1
一个关闭大括号紧邻一个关闭括号

00:28:47.327 --> 00:28:48.428 align:middle line:1
看起来很怪

00:28:50.030 --> 00:28:53.100 align:middle line:1
但是当闭包是最后一个参数时

00:28:53.166 --> 00:28:54.401 align:middle line:1
这种情况就是

00:28:55.002 --> 00:28:57.371 align:middle line:1
你可以写一个尾随闭包

00:28:57.437 --> 00:28:59.139 align:middle line:1
就在括号外面

00:29:00.307 --> 00:29:04.278 align:middle line:1
你接下来会看到如果一个闭包是
一个函数的唯一参数

00:29:04.678 --> 00:29:06.713 align:middle line:1
你可以移除这个括号

00:29:07.814 --> 00:29:09.983 align:middle line:1
这时尾随闭包看起来很好

00:29:10.317 --> 00:29:12.886 align:middle line:1
当闭包含有多于一行代码时

00:29:13.820 --> 00:29:16.323 align:middle
比如这个更复杂的闭包

00:29:16.390 --> 00:29:19.860 align:middle
它判断一个数每一位相加的和
是否是偶数

00:29:21.328 --> 00:29:22.563 align:middle
尾随闭包语法

00:29:22.629 --> 00:29:27.034 align:middle
确保即使是复杂的有多行的闭包

00:29:27.100 --> 00:29:28.836 align:middle
看起来也很自然很好

00:29:30.671 --> 00:29:33.273 align:middle
现在过滤整数函数很有用

00:29:33.340 --> 00:29:35.642 align:middle
如果你想要过滤整数

00:29:36.376 --> 00:29:39.313 align:middle
但是要怎么过滤其他类型的数组
比如类型数组？

00:29:40.514 --> 00:29:42.816 align:middle
例如假设你有一个名字数组

00:29:42.883 --> 00:29:45.352 align:middle
你想要一个过滤了的数组
只含有名字

00:29:45.419 --> 00:29:47.354 align:middle
含有少于给定的字符数

00:29:48.755 --> 00:29:50.757 align:middle line:1
你可以写一个过滤字符串函数

00:29:50.824 --> 00:29:52.259 align:middle line:1
像你看到的这个

00:29:52.726 --> 00:29:55.262 align:middle line:1
因为你已经写好了一个过滤整数
函数

00:29:55.329 --> 00:29:57.764 align:middle line:1
让我们来看看你能否重用一些逻辑

00:29:59.499 --> 00:30:01.568 align:middle
首先你当然想要做一些簿记

00:29:59.499 --> 00:30:01.568 align:middle
首先你当然想要做一些簿记

00:30:01.635 --> 00:30:05.372 align:middle
把所有涉及数字的地方改成字符串

00:30:06.507 --> 00:30:11.278 align:middle
下一步把所有整型改成字符串类型

00:30:13.447 --> 00:30:15.382 align:middle
因为实际上这2个函数的行为

00:30:15.449 --> 00:30:18.318 align:middle
是一样的
对整数和字符串

00:30:18.385 --> 00:30:19.786 align:middle
没有什么别的要做

00:30:19.853 --> 00:30:21.421 align:middle
它们实际上是同样的函数

00:30:22.422 --> 00:30:25.025 align:middle
你现在有函数过滤字符串数组

00:30:26.393 --> 00:30:30.197 align:middle
现在如果你想要一个函数过滤
其他类型

00:30:30.464 --> 00:30:33.534 align:middle
你可以重复这个步骤

00:30:33.600 --> 00:30:34.601 align:middle
为每种类型

00:30:34.935 --> 00:30:37.638 align:middle
但是这显然很无聊

00:30:38.505 --> 00:30:41.141 align:middle
实际上你可以写一个函数

00:30:41.208 --> 00:30:43.977 align:middle
可以处理任意类型的数组

00:30:44.044 --> 00:30:45.546 align:middle
这被称为泛型函数

00:30:46.346 --> 00:30:47.948 align:middle
我们来看看怎么写一个

00:30:48.682 --> 00:30:52.152 align:middle
写一个这种函数和你已经看到的
没有很大不同

00:30:52.753 --> 00:30:54.988 align:middle
首先你把名字改得更通用

00:30:55.055 --> 00:30:57.925 align:middle
比如函数叫过滤

00:30:57.991 --> 00:31:00.594 align:middle
而不是过滤整数或过滤字符串

00:30:57.991 --> 00:31:00.594 align:middle
而不是过滤整数或过滤字符串

00:31:01.495 --> 00:31:04.164 align:middle
接下来更重要的是你需要填写
占位符

00:31:04.231 --> 00:31:07.234 align:middle
你在这里看到的
元素的类型

00:31:07.835 --> 00:31:10.137 align:middle
但是你现在还不知道元素的类型

00:31:10.971 --> 00:31:13.640 align:middle
所以你希望是一个类型参数

00:31:14.007 --> 00:31:16.844 align:middle
实际的类型会在函数被调用时确定

00:31:18.378 --> 00:31:20.247 align:middle
这里我们填写了占位符

00:31:20.314 --> 00:31:22.649 align:middle
用一个通用类型参数叫做元素

00:31:23.650 --> 00:31:26.720 align:middle
所以你能看到区别
在类型参数

00:31:26.787 --> 00:31:30.190 align:middle
和实际存在的类型比如字符串
或者整数

00:31:30.624 --> 00:31:34.528 align:middle
你把类型参数写在尖括号中

00:31:34.595 --> 00:31:36.163 align:middle
紧跟函数名后面

00:31:36.730 --> 00:31:38.632 align:middle
现在你有一个泛型函数

00:31:38.699 --> 00:31:42.035 align:middle
作用于一个数组包含任意类型的值

00:31:44.571 --> 00:31:47.374 align:middle
你和以前一样调用这种函数

00:31:47.441 --> 00:31:50.611 align:middle
你不需要指定你想要这个函数
处理的类型

00:31:50.677 --> 00:31:53.247 align:middle
因为可以通过你传入的值推断

00:31:54.681 --> 00:31:58.352 align:middle line:1
过滤是如此有用的操作
所以Swift标准库

00:31:58.418 --> 00:32:02.256 align:middle line:1
有一个过滤方法可用用于任何
种类的序列或集合

00:31:58.418 --> 00:32:02.256 align:middle line:1
有一个过滤方法可用用于任何
种类的序列或集合

00:32:03.257 --> 00:32:07.160 align:middle
你和你看到的过滤函数以同样的
方式工作

00:32:07.227 --> 00:32:10.531 align:middle
除了这是一个方法
你需要用点号来调用它

00:32:10.597 --> 00:32:12.900 align:middle
names.filter像你看到的

00:32:14.668 --> 00:32:17.037 align:middle line:1
Swift标准库实际上有很多其他
方法

00:32:17.104 --> 00:32:19.339 align:middle line:1
接受闭包作为一个参数

00:32:19.907 --> 00:32:22.643 align:middle line:1
另一个很有用的是映射方法

00:32:22.709 --> 00:32:25.212 align:middle line:1
它也作用于任何序列或集合

00:32:26.013 --> 00:32:27.981 align:middle line:1
映射返回一个新的数组

00:32:28.048 --> 00:32:30.884 align:middle line:1
包含对每个元素进行闭包的结果

00:32:31.251 --> 00:32:34.888 align:middle line:1
这是一个例子在对上面得到的
包含短名字的数组调用映射方法

00:32:35.088 --> 00:32:38.625 align:middle line:1
它传递一个闭包把每个字符串
转成大写

00:32:40.527 --> 00:32:44.598 align:middle line:1
你可以把它们链起来强行多个操作

00:32:44.665 --> 00:32:45.666 align:middle
比如

00:32:45.732 --> 00:32:49.102 align:middle
你可以在同一个表达式里过滤
并大写

00:32:49.169 --> 00:32:51.672 align:middle
通过把两个方法形成一个链

00:32:51.738 --> 00:32:53.073 align:middle
使用点号

00:32:53.140 --> 00:32:54.875 align:middle
过滤先进行

00:32:54.942 --> 00:32:56.977 align:middle
然后映射在被过滤过的数组上
被调用

00:32:57.044 --> 00:32:59.613 align:middle
最终返回大写的字符串

00:33:01.381 --> 00:33:02.516 align:middle line:1
这读起来很棒

00:33:02.583 --> 00:33:04.918 align:middle line:1
即使你用尾随闭包语法

00:33:06.587 --> 00:33:10.324 align:middle line:1
所以使用闭包和函数接收闭包
作为参数的这个组合

00:33:10.390 --> 00:33:15.362 align:middle line:1
使它有可能写一些复杂强大的代码

00:33:15.929 --> 00:33:18.498 align:middle line:1
用一个简明但是很有表现力的方式

00:33:19.099 --> 00:33:22.936 align:middle
我们已经看了函数和闭包
以及一点泛型函数

00:33:23.003 --> 00:33:27.274 align:middle
我想邀请Alex上台告诉你们
所有关于Swift数据类型的事

00:33:34.314 --> 00:33:35.148 align:middle
谢谢Brian

00:33:36.083 --> 00:33:38.886 align:middle
你们看到了Swift中的数据类型

00:33:39.286 --> 00:33:43.123 align:middle
现在让我们看看怎样创建
你自己的数据类型

00:33:44.525 --> 00:33:46.126 align:middle
让我们从结构开始

00:33:46.627 --> 00:33:48.595 align:middle
你创建一个像这样

00:33:48.662 --> 00:33:52.799 align:middle
你写下struct关键字
跟随的是结构的名字

00:33:52.866 --> 00:33:54.568 align:middle
矩形

00:33:56.170 --> 00:33:58.172 align:middle
然后在大括号里

00:34:00.374 --> 00:34:02.543 align:middle
你写下结构的属性

00:34:04.478 --> 00:34:06.213 align:middle
属性使用相同的语法

00:34:06.280 --> 00:34:09.382 align:middle
和你在前面见过的变量和常量一样

00:34:11.083 --> 00:34:12.652 align:middle
这里有两个属性

00:34:12.719 --> 00:34:15.656 align:middle
做为申明的一部分被赋值

00:34:15.989 --> 00:34:20.293 align:middle
所以你可以新建一个矩形
通过只写下矩形这个名字

00:34:21.027 --> 00:34:23.197 align:middle
跟随一对括号

00:34:24.197 --> 00:34:27.601 align:middle
要访问属性
你使用点号

00:34:30.137 --> 00:34:33.139 align:middle
你不需要为属性提供值

00:34:33.206 --> 00:34:35.442 align:middle
在类型申明中

00:34:35.509 --> 00:34:37.844 align:middle
实际上大部分时候你不这么做

00:34:38.277 --> 00:34:40.581 align:middle
更常见的 你只写类型

00:34:41.648 --> 00:34:44.818 align:middle
然后你在建立实例时赋值

00:34:46.520 --> 00:34:51.458 align:middle
矩形除了尺寸的另一个属性是面积

00:34:52.525 --> 00:34:54.895 align:middle
虽然你不想储存面积

00:34:55.062 --> 00:34:58.665 align:middle
你需要在每次尺寸变化时更新它

00:34:59.533 --> 00:35:01.602 align:middle
你想要的是一个属性

00:34:59.533 --> 00:35:01.602 align:middle
你想要的是一个属性

00:35:01.668 --> 00:35:05.172 align:middle
它的值当你需要的时候被计算出

00:35:05.639 --> 00:35:08.675 align:middle
你可以用一个被计算属性

00:35:10.077 --> 00:35:11.778 align:middle
要创建一个被计算属性

00:35:12.513 --> 00:35:17.885 align:middle
在属性的名称和类型后面
你写一个函数体

00:35:18.118 --> 00:35:21.321 align:middle
用来计算并返回

00:35:21.588 --> 00:35:23.590 align:middle
函数的当前值

00:35:24.658 --> 00:35:27.628 align:middle
虽然它是被计算的而不是被储存的

00:35:27.694 --> 00:35:30.197 align:middle
你还是可以用点号访问它

00:35:31.665 --> 00:35:33.967 align:middle
你还可以用属性做更多

00:35:34.334 --> 00:35:36.870 align:middle
你可以有设置者和监视者

00:35:38.038 --> 00:35:40.507 align:middle line:1
你可以获得更多信息

00:35:40.574 --> 00:35:45.445 align:middle line:1
在Swift编程语言的属性章节

00:35:48.215 --> 00:35:51.051 align:middle
就像你在结构中定义属性

00:35:51.218 --> 00:35:53.120 align:middle
你还可以定义方法

00:35:54.154 --> 00:35:57.691 align:middle
和你已经看过的函数一样的语法

00:35:59.159 --> 00:36:03.597 align:middle line:1
和属性一样
你用点号访问方法

00:35:59.159 --> 00:36:03.597 align:middle line:1
和属性一样
你用点号访问方法

00:36:03.664 --> 00:36:05.132 align:middle line:1
当你需要调用它们时

00:36:08.435 --> 00:36:12.339 align:middle line:1
你看到几次新建矩形的语法了

00:36:12.906 --> 00:36:15.943 align:middle line:1
我们看看它做了什么的更多细节

00:36:17.377 --> 00:36:21.815 align:middle
这看起来像调用函数因为这个括号

00:36:22.049 --> 00:36:24.351 align:middle
实际上它是在调用初始化者

00:36:25.319 --> 00:36:28.889 align:middle
我们一直在用一个特殊的初始化者

00:36:28.956 --> 00:36:31.291 align:middle
称为成员初始化者

00:36:31.358 --> 00:36:34.995 align:middle
Swift为你的结构实现

00:36:35.662 --> 00:36:37.130 align:middle
这是它看起来的样子

00:36:37.197 --> 00:36:40.033 align:middle line:1
如果你明确的写这个初始化者

00:36:41.134 --> 00:36:43.370 align:middle line:1
你写init关键字

00:36:43.437 --> 00:36:47.641 align:middle line:1
然后在里面你为矩形的属性设值

00:36:48.942 --> 00:36:52.012 align:middle line:1
注意有两个宽度

00:36:52.513 --> 00:36:54.815 align:middle line:1
一个是属性另一个是参数

00:36:55.516 --> 00:37:00.654 align:middle line:1
你写下self点来明确的参考属性

00:36:55.516 --> 00:37:00.654 align:middle line:1
你写下self点来明确的参考属性

00:37:01.855 --> 00:37:04.424 align:middle line:1
这就是你怎么写初始化者

00:37:06.894 --> 00:37:10.097 align:middle line:1
矩形结构有足够多的代码

00:37:10.163 --> 00:37:13.100 align:middle line:1
值得进行一些组织

00:37:13.166 --> 00:37:16.970 align:middle line:1
Swift中这样做的一个方法是
使用扩展

00:37:18.372 --> 00:37:22.676 align:middle
一个扩展让你向一个已有的类型
添加功能

00:37:23.911 --> 00:37:28.682 align:middle
在Swift里你可以用扩展来分离
你的代码

00:37:29.816 --> 00:37:33.487 align:middle
核心功能可以在结构的申明中

00:37:34.588 --> 00:37:39.193 align:middle
辅助的功能可以在一个或多个
扩展中

00:37:40.427 --> 00:37:43.263 align:middle
你可以不受限地扩展你自己的类型

00:37:43.830 --> 00:37:47.768 align:middle
如果你需要你可以扩展从其他
地方来的类型

00:37:47.835 --> 00:37:51.538 align:middle
比如foundation 或者标准库

00:37:53.140 --> 00:37:56.643 align:middle
你早前看到怎么创建范型函数

00:37:56.710 --> 00:38:01.215 align:middle
在不同的类型上进行相同的操作

00:37:56.710 --> 00:38:01.215 align:middle
在不同的类型上进行相同的操作

00:38:01.982 --> 00:38:07.554 align:middle
你还可以创建泛型结构
它包含不同类型的数据

00:38:08.255 --> 00:38:10.424 align:middle
语法看起来很相似

00:38:10.490 --> 00:38:15.863 align:middle
你仍然有泛型类型参数在名字
后面的尖括号里

00:38:16.730 --> 00:38:21.935 align:middle
这个例子把名字附加给一些种类
的元素的数组

00:38:22.970 --> 00:38:26.440 align:middle
这会是个有用的数据结构
比如

00:38:26.507 --> 00:38:31.178 align:middle
来填充一个表视图
有不同的部分有标题名

00:38:31.678 --> 00:38:35.215 align:middle
你创建一个泛型结构实例

00:38:35.282 --> 00:38:37.684 align:middle
就像另一个类型的实例

00:38:39.586 --> 00:38:43.123 align:middle
你在这看到如果你写下类型标注

00:38:44.424 --> 00:38:48.028 align:middle
棋盘游戏和质数有不同的类型

00:38:49.029 --> 00:38:53.433 align:middle
一个是字符串数组
另一个是整数数组

00:38:54.301 --> 00:38:58.739 align:middle
它们有不同的元素类型
所以它们是不同的类型

00:39:00.174 --> 00:39:02.209 align:middle
你不需要写数组

00:39:02.709 --> 00:39:06.146 align:middle
Swift自动推测是什么元素

00:39:08.182 --> 00:39:09.650 align:middle
这就是结构

00:39:11.518 --> 00:39:14.621 align:middle
在Swift中另一个数据类型是类

00:39:15.689 --> 00:39:18.392 align:middle
你在名称前写下类别关键字

00:39:18.458 --> 00:39:21.161 align:middle
但是关于结构的一切都仍然有效

00:39:21.695 --> 00:39:24.998 align:middle
属性 方法 初始化者等等

00:39:26.099 --> 00:39:29.169 align:middle
那么为什么你想要创建一个类？

00:39:30.804 --> 00:39:36.176 align:middle
一个原因是你的代码可以引用
一个类的同一个实例

00:39:36.243 --> 00:39:38.045 align:middle
从不同的地方

00:39:38.679 --> 00:39:41.982 align:middle
这和结构的行为不同

00:39:43.083 --> 00:39:46.019 align:middle
一个结构的行为像一个大的值

00:39:46.787 --> 00:39:51.058 align:middle
比如 在游戏中 你让玩家1有
一个分数

00:39:52.359 --> 00:39:58.031 align:middle
你给玩家2一个一样的分数
你有两个独立的分数

00:39:58.899 --> 00:40:03.837 align:middle
改变玩家2的分数不会改变
玩家1的分数

00:39:58.899 --> 00:40:03.837 align:middle
改变玩家2的分数不会改变
玩家1的分数

00:40:05.072 --> 00:40:10.477 align:middle
但是两个玩家需要引用硬盘上
的同一个文件

00:40:10.544 --> 00:40:12.446 align:middle
当他们记录他们的高分的时候

00:40:13.914 --> 00:40:17.150 align:middle
因为这是一个类
这就是你想要的行为

00:40:18.652 --> 00:40:23.991 align:middle
当玩家2得到一个新的高分
并把它记录到文件中

00:40:24.658 --> 00:40:26.960 align:middle
两个玩家都看到改变

00:40:29.062 --> 00:40:31.999 align:middle
如果你是从另一个面向对象语言
中过来

00:40:32.065 --> 00:40:35.402 align:middle
你可能习惯于写很多类

00:40:35.469 --> 00:40:40.040 align:middle
在Swift中你不需要经常写它们

00:40:41.208 --> 00:40:45.746 align:middle
任何时候你想要检查是否相等
或进行复制

00:40:46.780 --> 00:40:49.917 align:middle
你通常只需要一个值类型像是结构

00:40:51.518 --> 00:40:55.822 align:middle line:1
要知道更多为什么以及怎么
用值类型的信息

00:40:55.889 --> 00:40:58.492 align:middle line:1
你可以看一个很有用的演讲

00:40:59.726 --> 00:41:02.095 align:middle line:1
另一个用类的原因是

00:40:59.726 --> 00:41:02.095 align:middle line:1
另一个用类的原因是

00:41:02.162 --> 00:41:05.065 align:middle line:1
你想从已有的类中派生一个子类

00:41:06.934 --> 00:41:09.670 align:middle
比如假设你有一个框架

00:41:09.736 --> 00:41:14.741 align:middle
给你鱼类包含一些核心的鱼的功能

00:41:15.976 --> 00:41:22.049 align:middle line:1
你可以创建子类来添加功能
像是飞鱼可以添加飞方法

00:41:23.050 --> 00:41:27.654 align:middle line:1
你标明这是一个子类通过写冒号鱼

00:41:28.789 --> 00:41:34.394 align:middle line:1
子类还可以覆盖方法来提供它们
自己的实现

00:41:35.462 --> 00:41:37.664 align:middle line:1
像抱怨鱼

00:41:37.731 --> 00:41:41.835 align:middle line:1
它像普通鱼一样游泳
只是会先报怨

00:41:44.838 --> 00:41:49.610 align:middle line:1
你写super.swim
来调用父类的实现

00:41:50.611 --> 00:41:53.046 align:middle line:1
这个代码还不能被编译

00:41:54.014 --> 00:41:56.617 align:middle line:1
当你在Swift中覆盖方法

00:41:56.683 --> 00:42:00.854 align:middle line:1
你需能写覆写关键字来明确标明

00:41:56.683 --> 00:42:00.854 align:middle line:1
你需能写覆写关键字来明确标明

00:42:01.455 --> 00:42:03.257 align:middle line:1
现在代码工作

00:42:04.725 --> 00:42:08.862 align:middle line:1
像是一个错误
偶然覆盖了一些东西

00:42:08.929 --> 00:42:14.568 align:middle line:1
这也是一个错误
写了覆写却不覆盖任何东西

00:42:15.736 --> 00:42:20.474 align:middle line:1
这就是说如果你拼错了一个
想要覆盖的方法的名字

00:42:20.974 --> 00:42:24.545 align:middle line:1
Swift会在编译时告诉你这个错误

00:42:26.346 --> 00:42:29.249 align:middle line:1
一个赛格威也可以提供初始化者

00:42:30.684 --> 00:42:35.189 align:middle line:1
比如鱼有初始化者接收一个名字

00:42:35.889 --> 00:42:41.361 align:middle line:1
抱怨鱼的初始化者需要名字和报怨

00:42:42.663 --> 00:42:46.900 align:middle line:1
在初始化者中你设置初始值

00:42:46.967 --> 00:42:50.370 align:middle line:1
为子类申明的属性

00:42:51.471 --> 00:42:53.907 align:middle line:1
然后你调用super.init

00:42:54.808 --> 00:42:58.011 align:middle line:1
让父类完成初始化

00:42:59.613 --> 00:43:04.017 align:middle line:1
你可以用初始化者做更多
特别是围绕类

00:42:59.613 --> 00:43:04.017 align:middle line:1
你可以用初始化者做更多
特别是围绕类

00:43:05.752 --> 00:43:09.389 align:middle line:1
你可以在初始化者这一章知道更多

00:43:09.456 --> 00:43:11.425 align:middle line:1
在Swift编程语言中

00:43:13.193 --> 00:43:15.562 align:middle
你看过了怎么用子类

00:43:15.629 --> 00:43:18.632 align:middle
让我们谈谈子类编程

00:43:20.868 --> 00:43:25.772 align:middle
继续游戏的例子
假设你有玩家基类

00:43:26.473 --> 00:43:30.511 align:middle
因为每个玩家轮流行动
你有一种方法这样做

00:43:31.411 --> 00:43:33.680 align:middle
你有两类玩家

00:43:34.348 --> 00:43:36.383 align:middle
你有人类玩家类

00:43:36.450 --> 00:43:39.887 align:middle
通过显示UI给用户来完成一轮

00:43:40.554 --> 00:43:43.190 align:middle line:1
你有电脑玩家类

00:43:43.257 --> 00:43:46.960 align:middle line:1
通过进行最好的合法的移动来
完成一轮

00:43:48.161 --> 00:43:53.400 align:middle line:1
问题就是什么进入基类的实现中？

00:43:54.768 --> 00:44:00.307 align:middle line:1
人类和电脑玩家没有共享的行为

00:43:54.768 --> 00:44:00.307 align:middle line:1
人类和电脑玩家没有共享的行为

00:44:01.008 --> 00:44:04.211 align:middle
没有共享的代码可以移出

00:44:05.145 --> 00:44:07.681 align:middle
在附近的代码

00:44:07.748 --> 00:44:12.019 align:middle
你永远都不会想要一个
玩家基类实例

00:44:12.553 --> 00:44:15.122 align:middle
所以这个方法永远都不应该被调用

00:44:16.757 --> 00:44:19.626 align:middle
这里能写的唯一合理的东西

00:44:19.693 --> 00:44:23.931 align:middle line:1
是一些严重错误来帮助你捕获失误

00:44:23.997 --> 00:44:26.466 align:middle line:1
在开发的早期阶段

00:44:27.534 --> 00:44:33.240 align:middle line:1
所有玩家类在做的是描述
做为一个玩家意味着什么

00:44:33.640 --> 00:44:36.243 align:middle line:1
每个玩家进行一轮

00:44:36.844 --> 00:44:39.847 align:middle line:1
它是玩家的蓝图

00:44:41.181 --> 00:44:46.286 align:middle line:1
在Swift中你用协议表达这种关系

00:44:47.321 --> 00:44:51.725 align:middle line:1
协议规定要求像是方法和属性

00:44:52.960 --> 00:44:56.296 align:middle
他们就像接口或者抽象类

00:44:56.363 --> 00:44:58.332 align:middle
你可能在别的语言里知道

00:44:59.700 --> 00:45:03.003 align:middle
你使用protocol关键字
来创建一个

00:44:59.700 --> 00:45:03.003 align:middle
你使用protocol关键字
来创建一个

00:45:03.637 --> 00:45:08.308 align:middle line:1
因为它描述其他类型要实现的要求

00:45:09.042 --> 00:45:11.044 align:middle line:1
你不提供一个实现

00:45:12.779 --> 00:45:17.417 align:middle line:1
类型通过提供那些实际来遵守协议

00:45:18.418 --> 00:45:22.456 align:middle line:1
你通过写：Player来申明符合性

00:45:22.956 --> 00:45:25.325 align:middle line:1
就像你对父类做的那样

00:45:26.960 --> 00:45:30.297 align:middle line:1
这样你不再使用子类

00:45:30.364 --> 00:45:33.467 align:middle line:1
这些方法不覆盖任何东西

00:45:34.868 --> 00:45:36.970 align:middle line:1
你不写覆写关键字

00:45:39.406 --> 00:45:43.243 align:middle line:1
没有理由它再是一个类

00:45:43.343 --> 00:45:44.978 align:middle line:1
让我们把它变为结构

00:45:46.847 --> 00:45:50.384 align:middle line:1
让我们仔细看看人类玩家

00:45:52.286 --> 00:45:56.023 align:middle
它还有一些其它的属性比如
名字和分数

00:45:56.757 --> 00:46:00.194 align:middle
如果你创建一个玩家实例
你可以打印它

00:45:56.757 --> 00:46:00.194 align:middle
如果你创建一个玩家实例
你可以打印它

00:46:02.329 --> 00:46:07.000 align:middle line:1
你得到一个default的描述
因为标准库

00:46:07.267 --> 00:46:10.404 align:middle line:1
可以把任何类型转化成字符串

00:46:12.306 --> 00:46:15.042 align:middle line:1
但是如果你想要定制这个转化

00:46:15.108 --> 00:46:17.511 align:middle line:1
来打印一个更好的描述

00:46:18.445 --> 00:46:23.450 align:middle line:1
该标准库还有一个协议
叫CustomStringConvertible

00:46:23.984 --> 00:46:26.453 align:middle line:1
使你提供自己的描述

00:46:27.154 --> 00:46:29.456 align:middle
这是这个协议的样子

00:46:30.090 --> 00:46:33.594 align:middle
它有一个要求
一个描述属性

00:46:34.962 --> 00:46:39.700 align:middle
任何遵守这个协议的类型
使用定制描述

00:46:40.467 --> 00:46:45.239 align:middle
你要在哪实现这个描述属性？

00:46:46.340 --> 00:46:49.710 align:middle
记住你可以整理你的代码

00:46:49.776 --> 00:46:54.982 align:middle
使用扩展
核心功能在函数申明中

00:46:55.048 --> 00:46:58.185 align:middle
附加功能在扩展中

00:46:59.186 --> 00:47:04.291 align:middle
有一个字符串转换功能是第二类

00:46:59.186 --> 00:47:04.291 align:middle
有一个字符串转换功能是第二类

00:47:04.358 --> 00:47:08.896 align:middle
它不是核心功能
所以把它放在扩展里

00:47:09.396 --> 00:47:13.500 align:middle
这是你如何扩展一个类型
来遵守协议

00:47:14.468 --> 00:47:18.872 align:middle
你在第一行写下
“: CustomStringConvertible”

00:47:20.007 --> 00:47:24.144 align:middle
然后你在扩展体内实现要求

00:47:26.113 --> 00:47:30.417 align:middle line:1
现在你可以调用打印
你获得定制的字符串转换

00:47:31.818 --> 00:47:36.657 align:middle line:1
你可以在Swift里用协议和扩展
做很多

00:47:36.757 --> 00:47:39.693 align:middle line:1
来组织你的代码并建立抽象

00:47:40.827 --> 00:47:43.864 align:middle line:1
要知道更多信息请看

00:47:43.931 --> 00:47:47.901 align:middle line:1
2015年的面向协议编程

00:47:49.436 --> 00:47:54.575 align:middle line:1
那带来Swift最后的一个数据类型
枚举

00:47:55.576 --> 00:47:58.912 align:middle
你在有一个值列表时使用枚举

00:47:58.979 --> 00:48:00.881 align:middle
当你提前知道

00:47:58.979 --> 00:48:00.881 align:middle
当你提前知道

00:48:01.582 --> 00:48:06.587 align:middle
这是一个枚举支持左或右对齐
的文本

00:48:07.588 --> 00:48:12.893 align:middle
当你用一个枚举时
你用点号来访问它的案例

00:48:14.027 --> 00:48:16.463 align:middle
这里只有两个案例

00:48:16.530 --> 00:48:19.600 align:middle
所以你把它们写在一行还是可读的

00:48:21.101 --> 00:48:25.138 align:middle
因为枚举是一个可能值的列表

00:48:25.205 --> 00:48:27.808 align:middle
经常把它和switch一起用

00:48:28.709 --> 00:48:32.212 align:middle line:1
一个switch case
对应一个枚举案例

00:48:33.714 --> 00:48:37.751 align:middle line:1
一遍遍写对齐有点重复

00:48:37.818 --> 00:48:39.853 align:middle line:1
在这并不需要

00:48:40.921 --> 00:48:47.261 align:middle line:1
switch考虑文本对齐
所以需要检查的仅有的可能值

00:48:47.461 --> 00:48:50.397 align:middle line:1
是枚举的案例

00:48:51.164 --> 00:48:54.535 align:middle line:1
所以你可以省略枚举名称

00:48:54.601 --> 00:48:56.803 align:middle line:1
只用写“.left”

00:48:58.438 --> 00:49:01.742 align:middle line:1
还要注意这里没有default

00:48:58.438 --> 00:49:01.742 align:middle line:1
还要注意这里没有default

00:49:02.843 --> 00:49:05.379 align:middle line:1
和你已经看到的原因一样

00:49:05.979 --> 00:49:10.417 align:middle line:1
switch已经覆盖了所有可能的
对齐值

00:49:10.584 --> 00:49:14.087 align:middle line:1
没有东西留下给default来处理

00:49:15.489 --> 00:49:18.892 align:middle line:1
省略default有一个好处

00:49:19.493 --> 00:49:23.597 align:middle line:1
如果你晚些回来增加一个枚举案例

00:49:23.664 --> 00:49:26.200 align:middle line:1
但是忘记更新switch

00:49:26.266 --> 00:49:30.504 align:middle line:1
Swift会高亮这个错误直到你添加
遗失的代码

00:49:32.673 --> 00:49:38.011 align:middle line:1
让我们快速看一看
你能对枚举做的其他两件事

00:49:40.681 --> 00:49:44.718 align:middle
你可以给每个枚举案例关联一个值

00:49:45.652 --> 00:49:51.124 align:middle
比如对齐可以指定要用多少填充

00:49:52.793 --> 00:49:58.332 align:middle line:1
你可以获得那个填充值
在switch case中

00:50:00.601 --> 00:50:07.441 align:middle
你也可以给每个枚举案例
一个原始值从其他类型中

00:50:07.508 --> 00:50:09.877 align:middle
比如字符串或者整数

00:50:11.578 --> 00:50:14.882 align:middle line:1
来让你提升代码的类型安全

00:50:14.948 --> 00:50:18.752 align:middle line:1
通过用枚举取代字符串常量

00:50:21.154 --> 00:50:24.258 align:middle line:1
你今天下午看了很多Swift

00:50:24.758 --> 00:50:27.127 align:middle line:1
但是没有时间展示所有的

00:50:28.028 --> 00:50:31.532 align:middle line:1
最后一个我想展示的是错误处理

00:50:34.134 --> 00:50:39.173 align:middle
在Swift中你可以用枚举来描述
错误

00:50:40.741 --> 00:50:44.912 align:middle
你用throws关键字标记一个函数
可以抛出错误

00:50:47.047 --> 00:50:51.752 align:middle
你在必须要运行的代码块前
写defer关键字

00:50:51.818 --> 00:50:53.720 align:middle
无论是否发生错误

00:50:54.087 --> 00:50:58.258 align:middle
它都会在退出作用域前被运行

00:50:58.325 --> 00:51:00.294 align:middle
比如从一个函数返回

00:50:58.325 --> 00:51:00.294 align:middle
比如从一个函数返回

00:51:03.630 --> 00:51:06.633 align:middle
在调用可能抛出错误的代码前

00:51:06.700 --> 00:51:08.402 align:middle
你用try关键字标记它

00:51:09.970 --> 00:51:14.675 align:middle line:1
你可以捕获和抛出错误
用catch和throw关键字

00:51:16.243 --> 00:51:21.582 align:middle line:1
关于所有细节请看错误处理章节

00:51:21.648 --> 00:51:23.717 align:middle line:1
在Swift编程语言中

00:51:25.452 --> 00:51:29.389 align:middle
你可以在这找到这本书和其他资源
的链接

00:51:31.592 --> 00:51:36.964 align:middle line:1
有很多很好的Swift演讲
可以在这周晚些时间参加或者看视频

00:51:37.698 --> 00:51:38.532 align:middle
谢谢
