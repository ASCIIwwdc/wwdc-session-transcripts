WEBVTT

00:00:20.153 --> 00:00:23.023 align:middle
<c.magenta>采用METAL 第一部分</c>

00:00:26.393 --> 00:00:29.296 align:middle
<c.magenta>下午好 欢迎来到</c>
<c.magenta>“采用Metal 第一部分”</c>

00:00:29.696 --> 00:00:32.165 align:middle
<c.magenta>我是GPU软件团队的</c>
<c.magenta>Warren Moore</c>

00:00:32.499 --> 00:00:36.203 align:middle
<c.magenta>我和同事Matt Collins</c>
<c.magenta>一起 他主要负责做展示</c>

00:00:36.904 --> 00:00:38.338 align:middle
<c.magenta>我想问一个</c>

00:00:38.405 --> 00:00:41.542 align:middle
<c.magenta>看似简单的问题 什么是Metal</c>

00:00:42.209 --> 00:00:45.345 align:middle
<c.magenta>你可能已听说过Metal是</c>
<c.magenta>Apple的偏底层的API</c>

00:00:45.412 --> 00:00:48.882 align:middle
<c.magenta>面向GPU的</c>
<c.magenta>它是一个统一的图形计算语言</c>

00:00:49.216 --> 00:00:51.652 align:middle
<c.magenta>并且面向多线程做了优化</c>

00:00:51.952 --> 00:00:53.720 align:middle
<c.magenta>专门为我们的平台所设计</c>

00:00:53.954 --> 00:00:55.255 align:middle
<c.magenta>这些都是正确的</c>

00:00:55.589 --> 00:00:58.825 align:middle
<c.magenta>但是Metal不仅有</c>
<c.magenta>Metal.framework</c>

00:00:59.193 --> 00:01:04.864 align:middle
<c.magenta>Metal同时也被</c>
<c.magenta>其他的框架和工具支持</c>

00:00:59.193 --> 00:01:04.864 align:middle
<c.magenta>Metal同时也被</c>
<c.magenta>其他的框架和工具支持</c>

00:01:05.699 --> 00:01:08.869 align:middle
<c.magenta>它们提供了比metal框架</c>
<c.magenta>API多很多的东西</c>

00:01:09.269 --> 00:01:11.939 align:middle
<c.magenta>尤其是去年我们引入MetalKit</c>

00:01:12.339 --> 00:01:14.775 align:middle
<c.magenta>它包括了用来一些处理常见任务的工具</c>

00:01:14.842 --> 00:01:18.478 align:middle
<c.magenta>像与UIKit和AppKit交互</c>
<c.magenta>加载纹理</c>

00:01:20.113 --> 00:01:21.748 align:middle
<c.magenta>还有Metal性能着色器</c>

00:01:21.949 --> 00:01:25.419 align:middle
<c.magenta>能帮你做图片处理</c>

00:01:25.485 --> 00:01:28.789 align:middle
<c.magenta>可以手动调优 高度优化的着色器</c>

00:01:29.189 --> 00:01:32.159 align:middle
<c.magenta>可以直接放到你的应用里</c>
<c.magenta>来处理这些任务</c>

00:01:33.227 --> 00:01:36.263 align:middle
<c.magenta>Metal同时还紧密</c>
<c.magenta>与我们的开发工具结合</c>

00:01:36.496 --> 00:01:37.998 align:middle
<c.magenta>像Xcode与</c>
<c.magenta>Instruments</c>

00:01:40.167 --> 00:01:41.902 align:middle
<c.magenta>当你的应用里面有着色器</c>

00:01:42.336 --> 00:01:44.471 align:middle
<c.magenta>它们会同你的应用一起编译</c>

00:01:44.571 --> 00:01:48.809 align:middle
<c.magenta>通过Xcode集成到你的应用包里</c>

00:01:49.376 --> 00:01:52.279 align:middle
<c.magenta>还有GPU框架调试器</c>
<c.magenta>可以做一个快照</c>

00:01:52.579 --> 00:01:55.916 align:middle
<c.magenta>在程序运行的任何一个点</c>
<c.magenta>来看看程序现在是什么情况</c>

00:01:56.717 --> 00:01:59.086 align:middle
<c.magenta>Instruments中</c>
<c.magenta>Metal系统跟踪</c>

00:01:59.553 --> 00:02:01.955 align:middle
<c.magenta>可以让你在运行是查看应用的性能</c>

00:01:59.553 --> 00:02:01.955 align:middle
<c.magenta>可以让你在运行是查看应用的性能</c>

00:02:02.022 --> 00:02:03.857 align:middle
<c.magenta>和行为</c>

00:02:05.359 --> 00:02:07.794 align:middle
<c.magenta>两年前我们把Metal引入了iOS</c>

00:02:08.027 --> 00:02:13.100 align:middle
<c.magenta>然后我们又把它带到了</c>
<c.magenta>Mac OS和tvOS</c>

00:02:13.800 --> 00:02:16.436 align:middle
<c.magenta>所以现在在我们平台上</c>
<c.magenta>受到了广泛的支持</c>

00:02:17.004 --> 00:02:19.540 align:middle
<c.magenta>同时我们的大部分硬件也支持它</c>

00:02:19.907 --> 00:02:24.044 align:middle
<c.magenta>包括桌面架构和移动架构</c>

00:02:24.111 --> 00:02:27.114 align:middle
<c.magenta>像Apple AMD Intel</c>
<c.magenta>和NVIDIA</c>

00:02:27.447 --> 00:02:30.884 align:middle
<c.magenta>所有的2012年后的Mac</c>

00:02:31.185 --> 00:02:34.655 align:middle
<c.magenta>2013年以后的所有iOS设备</c>
<c.magenta>还有新的Apple TV</c>

00:02:35.389 --> 00:02:38.725 align:middle
<c.magenta>Metal可以让应用程序充分利用</c>
<c.magenta>GPU的性能</c>

00:02:38.792 --> 00:02:42.162 align:middle
<c.magenta>在我们的海量的产品上</c>

00:02:44.898 --> 00:02:47.701 align:middle
<c.magenta>在这些平台上Metal属于基础技术</c>

00:02:48.235 --> 00:02:52.406 align:middle
<c.magenta>它支持核心图像 核心动画</c>

00:02:52.773 --> 00:02:56.710 align:middle
<c.magenta>游戏和图形库比如SpriteKit</c>
<c.magenta>SceneKit和Model I/O</c>

00:02:57.211 --> 00:02:58.912 align:middle
<c.magenta>也是我们关键系统软件的重要部分</c>

00:02:58.979 --> 00:03:02.716 align:middle
<c.magenta>像Preview和Safari</c>

00:02:58.979 --> 00:03:02.716 align:middle
<c.magenta>像Preview和Safari</c>

00:03:04.384 --> 00:03:06.587 align:middle
<c.magenta>各种各样开发者们</c>
<c.magenta>已广泛使用了Metal</c>

00:03:06.653 --> 00:03:10.591 align:middle
<c.magenta>从AAA工作室 游戏引擎提供商</c>

00:03:11.024 --> 00:03:14.294 align:middle
<c.magenta>到独立开发者和专业工具开发者</c>

00:03:14.428 --> 00:03:17.831 align:middle
<c.magenta>他们开发了非常好的应用和游戏</c>

00:03:18.398 --> 00:03:21.502 align:middle
<c.magenta>这只是一部分</c>
<c.magenta>我想着重说几个</c>

00:03:22.469 --> 00:03:26.073 align:middle
<c.magenta>比如 Fancy Guo用</c>
<c.magenta>Metal显著的提升了性能</c>

00:03:26.273 --> 00:03:27.741 align:middle
<c.magenta>带来了惊人的视觉效果</c>

00:03:27.808 --> 00:03:31.512 align:middle
<c.magenta>在他们广受欢迎的MORPG游戏</c>
<c.magenta>Furious Wings</c>

00:03:33.180 --> 00:03:36.817 align:middle
<c.magenta>Metal也被用在</c>
<c.magenta>专业的内容创造工具</c>

00:03:36.884 --> 00:03:39.419 align:middle
<c.magenta>像iPad上即将发布的</c>
<c.magenta>Affinity Photos</c>

00:03:40.487 --> 00:03:44.691 align:middle
<c.magenta>我带大家快速预览下都有什么</c>

00:03:46.026 --> 00:03:48.595 align:middle
<c.magenta>这个是Serif Labs的</c>
<c.magenta>Affinity Photos</c>

00:03:49.196 --> 00:03:51.198 align:middle
<c.magenta>这是个全功能的图片编辑应用</c>

00:03:51.265 --> 00:03:54.501 align:middle
<c.magenta>在iPad pro上</c>
<c.magenta>Metal可让其获得令人惊叹的效果</c>

00:03:57.938 --> 00:04:00.874 align:middle
<c.magenta>今年的 WWDC</c>
<c.magenta>我们会给你一些工具</c>

00:03:57.938 --> 00:04:00.874 align:middle
<c.magenta>今年的 WWDC</c>
<c.magenta>我们会给你一些工具</c>

00:04:01.241 --> 00:04:02.743 align:middle
<c.magenta>让你们开始使用Metal</c>

00:04:02.809 --> 00:04:05.812 align:middle
<c.magenta>来制作体验非常棒的应用</c>

00:04:06.780 --> 00:04:10.551 align:middle
<c.magenta>今年的 WWDC 有很多很棒的内容</c>

00:04:10.751 --> 00:04:12.619 align:middle
<c.magenta>有五场讲座专门介绍Metal</c>

00:04:13.253 --> 00:04:16.390 align:middle
<c.magenta>当然这是第一场会话</c>
<c.magenta>采用Metal 第一部分</c>

00:04:16.990 --> 00:04:19.159 align:middle
<c.magenta>在这节中我们会讨论</c>

00:04:19.226 --> 00:04:23.263 align:middle
<c.magenta>Metal里的一些基本概念</c>

00:04:23.864 --> 00:04:26.600 align:middle
<c.magenta>接着会介绍2D绘图添加光照</c>

00:04:26.667 --> 00:04:29.903 align:middle
<c.magenta>纹理和动画 我们还会介绍3D</c>

00:04:30.637 --> 00:04:34.074 align:middle
<c.magenta>这节课的第二部分</c>
<c.magenta>也是在这个教室 紧接着这节课</c>

00:04:34.474 --> 00:04:36.176 align:middle
<c.magenta>我们会介绍动态数据管理</c>

00:04:36.243 --> 00:04:38.445 align:middle
<c.magenta>接着会介绍一些高级的</c>

00:04:38.545 --> 00:04:40.414 align:middle
<c.magenta>关于GPU和CPU的同步</c>

00:04:40.614 --> 00:04:43.016 align:middle
<c.magenta>会让你性能达到新高度</c>

00:04:43.116 --> 00:04:44.885 align:middle
<c.magenta>通过使用多线程编码</c>

00:04:47.421 --> 00:04:49.723 align:middle
<c.magenta>我们会介绍下</c>
<c.magenta>Metal里有什么新东西</c>

00:04:49.790 --> 00:04:52.893 align:middle
<c.magenta>确实有很多新特性</c>

00:04:52.960 --> 00:04:56.063 align:middle
<c.magenta>在昨天的统一介绍中</c>
<c.magenta>相信你们也看到了一些</c>

00:04:57.831 --> 00:04:59.266 align:middle
<c.magenta>我不会详细介绍全部的东西</c>

00:04:59.333 --> 00:05:01.768 align:middle
<c.magenta>如果你想在你的应用中使用</c>

00:04:59.333 --> 00:05:01.768 align:middle
<c.magenta>如果你想在你的应用中使用</c>

00:05:01.835 --> 00:05:03.837 align:middle
<c.magenta>你应该看一下那个最新课程</c>

00:05:05.572 --> 00:05:08.709 align:middle
<c.magenta>最后 我们会有个很棒的</c>
<c.magenta>高级着色器优化的课程</c>

00:05:09.176 --> 00:05:12.312 align:middle
<c.magenta>对于那些想要</c>

00:05:12.379 --> 00:05:14.781 align:middle
<c.magenta>更好的使用着色器的人来说</c>
<c.magenta>这些绝对是干货</c>

00:05:14.848 --> 00:05:17.284 align:middle
<c.magenta>我们会详细的讨论硬件如何工作</c>

00:05:17.351 --> 00:05:20.587 align:middle
<c.magenta>你该怎样使用Metal来更好的</c>
<c.magenta>发挥它的性能</c>

00:05:21.622 --> 00:05:23.056 align:middle
<c.magenta>还有调优你的着色器代码</c>

00:05:24.157 --> 00:05:26.827 align:middle
<c.magenta>在这些课程中 我们会创建样例工程</c>

00:05:26.894 --> 00:05:30.030 align:middle
<c.magenta>由简单的</c>
<c.magenta>Hello Triangle开始</c>

00:05:30.097 --> 00:05:31.798 align:middle
<c.magenta>图形编程领域的</c>
<c.magenta>Hello world</c>

00:05:32.232 --> 00:05:35.402 align:middle
<c.magenta>然后 我们会研究动画和纹理贴图</c>

00:05:35.702 --> 00:05:38.305 align:middle
<c.magenta>第二部分 我们会进入到下一层级</c>

00:05:38.906 --> 00:05:41.341 align:middle
<c.magenta>讨论下实时更新对象数据</c>

00:05:41.675 --> 00:05:44.578 align:middle
<c.magenta>同时还有 通过多线程</c>
<c.magenta>来优化绘制调用</c>

00:05:45.913 --> 00:05:48.515 align:middle
<c.magenta>现在我们假设</c>

00:05:49.283 --> 00:05:50.651 align:middle
<c.magenta>你们已经熟悉</c>

00:05:50.717 --> 00:05:53.086 align:middle
<c.magenta>基本的图形编程 最好是</c>

00:05:54.288 --> 00:05:58.525 align:middle
<c.magenta>知道可编程管线</c>
<c.magenta>熟悉着色器等</c>

00:05:58.592 --> 00:06:01.895 align:middle
<c.magenta>同时你想知道怎么能用Metal来</c>

00:05:58.592 --> 00:06:01.895 align:middle
<c.magenta>同时你想知道怎么能用Metal来</c>

00:06:01.962 --> 00:06:03.964 align:middle
<c.magenta>让你的程序和游戏变得更棒</c>

00:06:04.164 --> 00:06:07.000 align:middle
<c.magenta>我假设大家都是这样</c>

00:06:07.067 --> 00:06:08.468 align:middle
<c.magenta>这也是你们为啥在此 对吧</c>

00:06:09.970 --> 00:06:11.705 align:middle
<c.magenta>我先过一遍议题</c>

00:06:12.039 --> 00:06:14.241 align:middle
<c.magenta>我们会先大体介绍下</c>

00:06:14.308 --> 00:06:16.476 align:middle
<c.magenta>Metal的理念</c>

00:06:16.543 --> 00:06:18.312 align:middle
<c.magenta>和为何Metal会是现在的样子</c>

00:06:18.378 --> 00:06:20.147 align:middle
<c.magenta>接着我们会详细的</c>

00:06:20.214 --> 00:06:22.049 align:middle
<c.magenta>介绍创建一个Metal实例</c>

00:06:22.482 --> 00:06:24.218 align:middle
<c.magenta>接下来会介绍加载数据</c>

00:06:24.551 --> 00:06:26.687 align:middle
<c.magenta>到内存来供GPU使用</c>

00:06:26.753 --> 00:06:29.389 align:middle
<c.magenta>我们会简要介绍下Metal着色语言</c>

00:06:29.456 --> 00:06:32.326 align:middle
<c.magenta>我们会介绍创建预验证管线状态</c>

00:06:33.026 --> 00:06:36.096 align:middle
<c.magenta>和GPU调用 包括绘制调用</c>

00:06:36.830 --> 00:06:39.132 align:middle
<c.magenta>我们会用一个讨论结束</c>

00:06:39.199 --> 00:06:42.970 align:middle
<c.magenta>如何在Metal中处理</c>
<c.magenta>动画和纹理贴图</c>

00:06:43.737 --> 00:06:45.672 align:middle
<c.magenta>第二部分我们会介绍的更深一些</c>

00:06:45.739 --> 00:06:47.508 align:middle
<c.magenta>刚才我已经提到了</c>

00:06:47.574 --> 00:06:49.009 align:middle
<c.magenta>现在我们开始</c>

00:06:49.543 --> 00:06:51.345 align:middle
<c.magenta>从理念概览开始</c>

00:06:51.411 --> 00:06:53.981 align:middle
<c.magenta>只有几点需要强调</c>

00:06:55.415 --> 00:06:57.851 align:middle
<c.magenta>使用和硬件驱动相匹配的API</c>

00:06:58.652 --> 00:07:00.654 align:middle
<c.magenta>尽量明确一些</c>

00:06:58.652 --> 00:07:00.654 align:middle
<c.magenta>尽量明确一些</c>

00:07:01.021 --> 00:07:03.790 align:middle
<c.magenta>尽量不做耗时操作</c>

00:07:04.658 --> 00:07:07.160 align:middle
<c.magenta>先说说使用和硬件驱动相匹配的API</c>

00:07:08.295 --> 00:07:10.230 align:middle
<c.magenta>Metal是一个完全现代化的API</c>

00:07:10.430 --> 00:07:13.967 align:middle
<c.magenta>也可以说它使用了最新的硬件特性</c>

00:07:15.269 --> 00:07:18.338 align:middle
<c.magenta>和硬件的工作流程息息相关</c>

00:07:18.805 --> 00:07:22.476 align:middle
<c.magenta>作为一个全新的API</c>
<c.magenta>它非常轻量级</c>

00:07:22.543 --> 00:07:25.679 align:middle
<c.magenta>并且没有历史包袱</c>

00:07:26.446 --> 00:07:29.616 align:middle
<c.magenta>对的开销的操作没有花哨的技巧</c>

00:07:29.816 --> 00:07:33.120 align:middle
<c.magenta>它和Metal契合</c>

00:07:33.187 --> 00:07:34.755 align:middle
<c.magenta>并且都是在最基础的层级操作</c>

00:07:34.821 --> 00:07:37.191 align:middle
<c.magenta>幸运的是 它是统一的</c>

00:07:37.591 --> 00:07:39.226 align:middle
<c.magenta>在我们的所有平台上</c>

00:07:41.328 --> 00:07:42.930 align:middle
<c.magenta>当我们说我们更倾向明确的操作</c>

00:07:42.996 --> 00:07:45.866 align:middle
<c.magenta>意思是我们想让你</c>

00:07:45.933 --> 00:07:49.770 align:middle
<c.magenta>负责操作GPU</c>

00:07:49.837 --> 00:07:51.805 align:middle
<c.magenta>而不是让其默认的操作</c>

00:07:52.105 --> 00:07:54.508 align:middle
<c.magenta>同时还包括数据的管理和同步</c>

00:07:55.342 --> 00:07:57.578 align:middle
<c.magenta>这让你有更多的责任</c>

00:07:57.644 --> 00:08:00.480 align:middle
<c.magenta>同时能有更好的性能</c>

00:07:57.644 --> 00:08:00.480 align:middle
<c.magenta>同时能有更好的性能</c>

00:08:02.082 --> 00:08:04.284 align:middle
<c.magenta>再来解释下</c>

00:08:04.351 --> 00:08:06.453 align:middle
<c.magenta>不要经常做耗费大的工作</c>

00:08:07.754 --> 00:08:12.626 align:middle
<c.magenta>有三个地方</c>

00:08:12.759 --> 00:08:14.194 align:middle
<c.magenta>程序创建时</c>

00:08:14.695 --> 00:08:16.496 align:middle
<c.magenta>程序加载时</c>

00:08:16.630 --> 00:08:18.165 align:middle
<c.magenta>加载资源的时候</c>

00:08:18.465 --> 00:08:21.869 align:middle
<c.magenta>然后就是绘制时 每秒会调用60次</c>

00:08:23.537 --> 00:08:25.672 align:middle
<c.magenta>如果是历史API 如OpenGL</c>

00:08:25.973 --> 00:08:27.074 align:middle
<c.magenta>你大部分时间会花在</c>

00:08:27.140 --> 00:08:29.810 align:middle
<c.magenta>状态检查上</c>
<c.magenta>每次调用绘制的时候</c>

00:08:30.143 --> 00:08:33.246 align:middle
<c.magenta>最坏的时候你需要在运行时重新编译</c>

00:08:33.746 --> 00:08:36.683 align:middle
<c.magenta>这些都会给GPU的必要工作上</c>

00:08:37.484 --> 00:08:40.254 align:middle
<c.magenta>添加负担 在调用绘制函数的时候</c>

00:08:41.688 --> 00:08:44.525 align:middle
<c.magenta>在Metal中我们把这些工作提前</c>

00:08:44.958 --> 00:08:46.693 align:middle
<c.magenta>像我开始说的</c>

00:08:47.094 --> 00:08:48.896 align:middle
<c.magenta>着色器的编译可以在</c>

00:08:48.962 --> 00:08:50.931 align:middle
<c.magenta>程序编译的时候同时进行</c>

00:08:52.366 --> 00:08:54.701 align:middle
<c.magenta>同时 我们也允许你验证状态</c>

00:08:54.768 --> 00:08:57.538 align:middle
<c.magenta>在调用绘制的时候提前验证</c>

00:08:57.838 --> 00:09:01.208 align:middle
<c.magenta>这样就不用在每次</c>
<c.magenta>调用绘制的时候验证了</c>

00:08:57.838 --> 00:09:01.208 align:middle
<c.magenta>这样就不用在每次</c>
<c.magenta>调用绘制的时候验证了</c>

00:09:01.642 --> 00:09:04.545 align:middle
<c.magenta>这样你需要做的唯一工作</c>

00:09:04.611 --> 00:09:07.581 align:middle
<c.magenta>就是只有绘制调用了</c>

00:09:10.083 --> 00:09:11.485 align:middle
<c.magenta>通过这些理念介绍</c>

00:09:11.552 --> 00:09:13.487 align:middle
<c.magenta>我们看看实际情况中的</c>

00:09:13.554 --> 00:09:14.888 align:middle
<c.magenta>Metal设备</c>

00:09:16.123 --> 00:09:17.724 align:middle
<c.magenta>这里有个类MTL设备</c>

00:09:18.425 --> 00:09:21.061 align:middle
<c.magenta>它表示抽象的GPU</c>

00:09:21.528 --> 00:09:24.865 align:middle
<c.magenta>它是你Metal应用中的最基本对象</c>

00:09:25.265 --> 00:09:27.301 align:middle
<c.magenta>你将会用它来创建</c>

00:09:27.367 --> 00:09:30.904 align:middle
<c.magenta>像指令队列 资源和管线状态对象</c>

00:09:30.971 --> 00:09:33.006 align:middle
<c.magenta>和其他你需要用的对象</c>

00:09:35.709 --> 00:09:37.845 align:middle
<c.magenta>创建Metal设备很简单</c>

00:09:37.911 --> 00:09:41.114 align:middle
<c.magenta>只需调用</c>
<c.magenta>MTLCreateSystemDefaultDevice</c>

00:09:41.715 --> 00:09:43.951 align:middle
<c.magenta>现在设备代表对象</c>

00:09:44.017 --> 00:09:46.553 align:middle
<c.magenta>你需要在程序开始时创建一个</c>

00:09:46.720 --> 00:09:50.557 align:middle
<c.magenta>并保持引用</c>
<c.magenta>因为会在整个程序的生命周期使用</c>

00:09:51.391 --> 00:09:52.759 align:middle
<c.magenta>就这么简单</c>

00:09:53.927 --> 00:09:56.129 align:middle
<c.magenta>现在说说怎么把数据</c>

00:09:56.430 --> 00:09:58.265 align:middle
<c.magenta>放到GPU可以读取的位置</c>

00:09:58.565 --> 00:10:00.267 align:middle
<c.magenta>然后你可以触发绘制调用</c>

00:09:58.565 --> 00:10:00.267 align:middle
<c.magenta>然后你可以触发绘制调用</c>

00:10:00.968 --> 00:10:04.037 align:middle
<c.magenta>在Metal中</c>
<c.magenta>我们把数据存到缓冲中</c>

00:10:04.338 --> 00:10:07.808 align:middle
<c.magenta>缓冲就是一块内存用来存数据</c>

00:10:07.875 --> 00:10:09.309 align:middle
<c.magenta>你可以用任何格式</c>

00:10:10.043 --> 00:10:14.348 align:middle
<c.magenta>可能是顶点数据 索引数据 常量</c>

00:10:15.449 --> 00:10:17.084 align:middle
<c.magenta>你把数据写到缓存中</c>

00:10:17.150 --> 00:10:18.752 align:middle
<c.magenta>随后在</c>

00:10:19.052 --> 00:10:20.988 align:middle
<c.magenta>顶点和片段函数中访问</c>

00:10:22.222 --> 00:10:23.957 align:middle
<c.magenta>我们看看大体是个什么样子</c>

00:10:24.024 --> 00:10:26.059 align:middle
<c.magenta>这里有个包含几个缓存的例子</c>

00:10:26.360 --> 00:10:28.795 align:middle
<c.magenta>你加载数据的时候可能会创建</c>

00:10:28.862 --> 00:10:31.565 align:middle
<c.magenta>我们有个vertexBuffer</c>
<c.magenta>包含一些顶点数据</c>

00:10:31.665 --> 00:10:34.434 align:middle
<c.magenta>一个indexBuffer</c>
<c.magenta>包含一些连续的索引</c>

00:10:35.702 --> 00:10:37.171 align:middle
<c.magenta>更具体写来说</c>

00:10:37.671 --> 00:10:42.042 align:middle
<c.magenta>每个顶点类型的实例</c>
<c.magenta>可能是一个Swift结构</c>

00:10:42.376 --> 00:10:44.845 align:middle
<c.magenta>用向量表示顶点的位置</c>

00:10:45.579 --> 00:10:47.548 align:middle
<c.magenta>同样还有点的颜色</c>

00:10:47.848 --> 00:10:50.050 align:middle
<c.magenta>你可以让它们在内存你连续保存</c>

00:10:51.285 --> 00:10:53.387 align:middle
<c.magenta>说下如何创建缓存</c>

00:10:55.088 --> 00:10:58.292 align:middle
<c.magenta>这个API在你已经创建的设备里</c>

00:10:58.692 --> 00:11:00.894 align:middle
<c.magenta>简单调用newBufferWithLength</c>

00:10:58.692 --> 00:11:00.894 align:middle
<c.magenta>简单调用newBufferWithLength</c>

00:11:00.961 --> 00:11:02.729 align:middle
<c.magenta>来获得一个指定大小的缓存</c>

00:11:02.996 --> 00:11:04.998 align:middle
<c.magenta>里面默认没有数据</c>

00:11:05.432 --> 00:11:07.734 align:middle
<c.magenta>或调用newBufferWithBytes</c>

00:11:07.801 --> 00:11:10.237 align:middle
<c.magenta>传一个已经在内存中有数据的指针</c>

00:11:10.637 --> 00:11:12.339 align:middle
<c.magenta>Metal会把数据拷贝</c>

00:11:12.573 --> 00:11:14.308 align:middle
<c.magenta>到新创建的缓存</c>

00:11:14.441 --> 00:11:16.109 align:middle
<c.magenta>你可以马上使用</c>

00:11:17.244 --> 00:11:20.781 align:middle
<c.magenta>你也可以用memcpy</c>
<c.magenta>把内容指针拷贝到缓存里</c>

00:11:23.717 --> 00:11:26.587 align:middle
<c.magenta>既然我们要展示一个2D的三角</c>

00:11:26.720 --> 00:11:27.988 align:middle
<c.magenta>作为我们第一部分的展示</c>

00:11:28.589 --> 00:11:31.825 align:middle
<c.magenta>我们先说下三角的几何坐标</c>

00:11:33.126 --> 00:11:35.162 align:middle
<c.magenta>既然我们想让顶点着色器</c>

00:11:35.229 --> 00:11:37.164 align:middle
<c.magenta>和片段着色器尽可能的简单</c>

00:11:37.731 --> 00:11:40.901 align:middle
<c.magenta>我们在裁减的空间里提供坐标</c>

00:11:41.668 --> 00:11:44.705 align:middle
<c.magenta>Metal的裁剪空间很有趣</c>

00:11:44.771 --> 00:11:47.674 align:middle
<c.magenta>它和其他类似的API有些不同</c>

00:11:47.741 --> 00:11:49.343 align:middle
<c.magenta>有点像DirectX裁剪空间</c>

00:11:49.776 --> 00:11:53.013 align:middle
<c.magenta>X从负1到1 Y轴从负1到1</c>

00:11:53.080 --> 00:11:55.883 align:middle
<c.magenta>Z轴从0到1</c>

00:11:56.617 --> 00:11:59.753 align:middle
<c.magenta>这个是我们要用的坐标空间</c>

00:11:59.953 --> 00:12:01.855 align:middle
<c.magenta>代码中是这样的</c>

00:11:59.953 --> 00:12:01.855 align:middle
<c.magenta>代码中是这样的</c>

00:12:02.723 --> 00:12:04.992 align:middle
<c.magenta>我们创建了个Swift的顶点数组</c>

00:12:05.292 --> 00:12:07.127 align:middle
<c.magenta>我们依次添加顶点</c>

00:12:07.194 --> 00:12:09.196 align:middle
<c.magenta>同时包括位置和颜色值</c>

00:12:12.766 --> 00:12:15.302 align:middle
<c.magenta>现在 我们不用严格的使用索引绘制</c>

00:12:15.402 --> 00:12:18.438 align:middle
<c.magenta>在这个简单的用例中</c>

00:12:18.672 --> 00:12:22.609 align:middle
<c.magenta>接着创建一个indexBuffer</c>
<c.magenta>并向其中添加0 1 2</c>

00:12:22.876 --> 00:12:24.978 align:middle
<c.magenta>代表三角形的第一个 第二个</c>

00:12:25.045 --> 00:12:27.047 align:middle
<c.magenta>和第三个点</c>

00:12:27.114 --> 00:12:29.449 align:middle
<c.magenta>然后用我们的设备创建接个缓存</c>

00:12:29.550 --> 00:12:32.019 align:middle
<c.magenta>我们会用newBuffer(withBytes</c>
<c.magenta>创建vertexBuffer</c>

00:12:32.085 --> 00:12:34.721 align:middle
<c.magenta>把顶点数据加载到Metal缓存中</c>

00:12:35.122 --> 00:12:37.024 align:middle
<c.magenta>我们再调用一次newBuffer(withBytes</c>

00:12:37.090 --> 00:12:40.360 align:middle
<c.magenta>把索引数据穿进去</c>
<c.magenta>得到indexBuffer</c>

00:12:42.229 --> 00:12:44.398 align:middle
<c.magenta>现在我们有了数据和内存</c>

00:12:44.531 --> 00:12:47.634 align:middle
<c.magenta>下面说说统一着色语言</c>

00:12:48.202 --> 00:12:51.972 align:middle
<c.magenta>Metal的着色语言是</c>
<c.magenta>C++ 14的扩展子集</c>

00:12:52.339 --> 00:12:54.908 align:middle
<c.magenta>他是图形和计算的统一语言</c>

00:12:55.275 --> 00:12:56.810 align:middle
<c.magenta>代表你还可以做很多事</c>

00:12:56.877 --> 00:12:58.645 align:middle
<c.magenta>不仅是3D图形</c>

00:12:58.979 --> 00:13:01.481 align:middle
<c.magenta>它可以让你写程序给GPU</c>

00:12:58.979 --> 00:13:01.481 align:middle
<c.magenta>它可以让你写程序给GPU</c>

00:13:02.816 --> 00:13:06.153 align:middle
<c.magenta>这里有个管线各个阶段的图表</c>

00:13:06.253 --> 00:13:08.689 align:middle
<c.magenta>现在我们是在顶点</c>

00:13:08.755 --> 00:13:10.524 align:middle
<c.magenta>和片段处理阶段</c>

00:13:10.591 --> 00:13:13.393 align:middle
<c.magenta>每个阶段都有相应的函数要写</c>

00:13:13.627 --> 00:13:16.930 align:middle
<c.magenta>要么是处理顶点要么是片段</c>

00:13:16.997 --> 00:13:18.632 align:middle
<c.magenta>将会刷到屏幕上</c>

00:13:19.266 --> 00:13:21.335 align:middle
<c.magenta>语法上 它看起来像这样</c>

00:13:21.902 --> 00:13:25.672 align:middle
<c.magenta>我们不会详细介绍</c>

00:13:25.739 --> 00:13:30.244 align:middle
<c.magenta>希望你们注意这些函数修饰符：</c>
<c.magenta>顶点和片段</c>

00:13:30.544 --> 00:13:33.280 align:middle
<c.magenta>你会注意到右面函数的前面</c>

00:13:33.347 --> 00:13:36.083 align:middle
<c.magenta>不像普通的C++程序</c>

00:13:36.183 --> 00:13:38.418 align:middle
<c.magenta>我们相用这些修饰符来表示</c>

00:13:38.552 --> 00:13:40.854 align:middle
<c.magenta>这些函数和哪个阶段相关</c>

00:13:41.321 --> 00:13:42.856 align:middle
<c.magenta>我们有一个顶点函数在上面</c>

00:13:42.923 --> 00:13:44.591 align:middle
<c.magenta>和一个片段函数在下面</c>

00:13:46.026 --> 00:13:48.795 align:middle
<c.magenta>我将简单展示怎么实际把这些</c>

00:13:49.429 --> 00:13:51.865 align:middle
<c.magenta>和你的管线结合在绘制的时候</c>

00:13:52.266 --> 00:13:55.035 align:middle
<c.magenta>我们还会看看这些函数的内部实现</c>

00:13:55.269 --> 00:13:58.105 align:middle
<c.magenta>在以后的2D和3D展示中</c>

00:13:59.006 --> 00:14:01.074 align:middle
<c.magenta>我提过好几次Metal可以</c>

00:13:59.006 --> 00:14:01.074 align:middle
<c.magenta>我提过好几次Metal可以</c>

00:14:01.141 --> 00:14:03.644 align:middle
<c.magenta>直接把着色器编译到程序包里</c>

00:14:03.710 --> 00:14:07.915 align:middle
<c.magenta>方法是即使你有一个.Metal文件</c>

00:14:08.282 --> 00:14:11.318 align:middle
<c.magenta>在你的工程中的编译源码层</c>

00:14:11.385 --> 00:14:13.720 align:middle
<c.magenta>Metal会自动生成</c>

00:14:13.787 --> 00:14:16.390 align:middle
<c.magenta>一个Metal库文件</c>
<c.magenta>default.Metallib</c>

00:14:16.657 --> 00:14:17.958 align:middle
<c.magenta>同时会拷贝到你的包中</c>

00:14:18.158 --> 00:14:19.860 align:middle
<c.magenta>在你的程序编译的时候</c>

00:14:19.927 --> 00:14:21.562 align:middle
<c.magenta>除此之外不会再编译</c>

00:14:22.763 --> 00:14:24.831 align:middle
<c.magenta>所以它会在你程序包中</c>

00:14:25.732 --> 00:14:27.301 align:middle
<c.magenta>这是</c>
<c.magenta>default.Metallib</c>

00:14:28.502 --> 00:14:29.436 align:middle
<c.magenta>简单说</c>

00:14:31.438 --> 00:14:33.273 align:middle
<c.magenta>你可在运行时编译Metal着色器</c>

00:14:33.540 --> 00:14:36.176 align:middle
<c.magenta>如果你程序里有一个.Metal文件</c>

00:14:36.243 --> 00:14:37.845 align:middle
<c.magenta>它会被Xcode用</c>
<c.magenta>Metal工具链编译</c>

00:14:38.111 --> 00:14:41.248 align:middle
<c.magenta>生成一个default.Metallib</c>
<c.magenta>打到你的应用包中</c>

00:14:42.115 --> 00:14:44.051 align:middle
<c.magenta>这里很自然会有个问题</c>

00:14:44.117 --> 00:14:47.955 align:middle
<c.magenta>运行时怎么使用这些函数</c>

00:14:48.021 --> 00:14:49.389 align:middle
<c.magenta>答案是你会用一个叫做</c>

00:14:49.456 --> 00:14:51.058 align:middle
<c.magenta>Metal Library的类</c>

00:14:51.124 --> 00:14:52.693 align:middle
<c.magenta>Metal Library</c>
<c.magenta>是一个集合</c>

00:14:52.759 --> 00:14:55.596 align:middle
<c.magenta>编译器编译的函数对象</c>

00:14:55.996 --> 00:14:57.598 align:middle
<c.magenta>有几种方法创建</c>

00:14:57.664 --> 00:14:59.466 align:middle
<c.magenta>你可以通过我们讨论的流程</c>

00:14:59.800 --> 00:15:02.503 align:middle
<c.magenta>创建一个</c>
<c.magenta>default.Metallib</c>

00:14:59.800 --> 00:15:02.503 align:middle
<c.magenta>创建一个</c>
<c.magenta>default.Metallib</c>

00:15:02.569 --> 00:15:04.872 align:middle
<c.magenta>到你的应用包</c>
<c.magenta>然后在运行时加载</c>

00:15:04.938 --> 00:15:09.576 align:middle
<c.magenta>你还可以用我们的命令行工具链</c>
<c.magenta>编译一个.metallibs</c>

00:15:10.344 --> 00:15:13.347 align:middle
<c.magenta>运行时你还可以用代码串创建一个目录</c>

00:15:13.413 --> 00:15:16.750 align:middle
<c.magenta>例如 通过字符串来编译一个渲染器</c>

00:15:18.085 --> 00:15:19.853 align:middle
<c.magenta>在代码里看起来像这样</c>

00:15:20.020 --> 00:15:22.022 align:middle
<c.magenta>为了加载</c>
<c.magenta>default.Metallib</c>

00:15:22.089 --> 00:15:24.491 align:middle
<c.magenta>调用</c>
<c.magenta>newDefaultLibrary</c>

00:15:24.992 --> 00:15:26.627 align:middle
<c.magenta>用你已经创建的Metal设备</c>

00:15:27.361 --> 00:15:30.297 align:middle
<c.magenta>还有其他的API加载 例如</c>

00:15:30.364 --> 00:15:32.799 align:middle
<c.magenta>从编译好的.Metallib</c>
<c.magenta>或者从源代码</c>

00:15:32.866 --> 00:15:35.002 align:middle
<c.magenta>你可以详细查看文档</c>
<c.magenta>来了解这些API</c>

00:15:37.671 --> 00:15:40.107 align:middle
<c.magenta>现你已有Metal Library</c>

00:15:40.207 --> 00:15:42.876 align:middle
<c.magenta>能从中得到什么</c>
<c.magenta>可以得到Metal函数</c>

00:15:42.943 --> 00:15:46.380 align:middle
<c.magenta>现在Metal函数是一个简单对象</c>
<c.magenta>代表一个函数</c>

00:15:46.880 --> 00:15:49.183 align:middle
<c.magenta>它和一个特定的管线阶段关联</c>

00:15:49.249 --> 00:15:50.884 align:middle
<c.magenta>记得我们刚才看过的图么</c>

00:15:50.951 --> 00:15:52.519 align:middle
<c.magenta>顶点或片段阶段</c>

00:15:52.853 --> 00:15:55.856 align:middle
<c.magenta>我们还有一个额外的</c>
<c.magenta>描述符叫“kernel”</c>

00:15:55.923 --> 00:15:58.825 align:middle
<c.magenta>表示并行处理数据的函数</c>

00:16:01.795 --> 00:16:04.498 align:middle
<c.magenta>这里有段代码 你可以看到</c>

00:16:04.565 --> 00:16:07.768 align:middle
<c.magenta>函数名是</c>
<c.magenta>vertex transform</c>

00:16:08.001 --> 00:16:11.405 align:middle
<c.magenta>fragmentFunction名是fragment lighting</c>

00:16:11.738 --> 00:16:14.641 align:middle
<c.magenta>我重改下以便我能给你展示API</c>

00:16:14.708 --> 00:16:16.743 align:middle
<c.magenta>如何在你的库中加载函数</c>

00:16:16.810 --> 00:16:17.945 align:middle
<c.magenta>像这样</c>

00:16:18.011 --> 00:16:19.780 align:middle
<c.magenta>我们先调用</c>
<c.magenta>NewFunctionWithName</c>

00:16:19.847 --> 00:16:22.249 align:middle
<c.magenta>传一个代表函数名的字符串</c>

00:16:22.616 --> 00:16:26.520 align:middle
<c.magenta>获得一个Metal函数 引用它</c>

00:16:27.588 --> 00:16:30.457 align:middle
<c.magenta>稍后将展示实际中如何使用这些对象</c>

00:16:30.724 --> 00:16:33.794 align:middle
<c.magenta>但也只是简要介绍Metal着色语言</c>

00:16:34.695 --> 00:16:38.232 align:middle
<c.magenta>让我们介绍下创建预验证的管线状态</c>

00:16:40.701 --> 00:16:42.769 align:middle
<c.magenta>但首先 我们先预热下</c>

00:16:42.970 --> 00:16:45.439 align:middle
<c.magenta>像OpenGL中的API</c>

00:16:45.706 --> 00:16:48.008 align:middle
<c.magenta>你经常需要设置许多状态</c>

00:16:48.375 --> 00:16:50.043 align:middle
<c.magenta>然后触发绘制调用</c>

00:16:50.110 --> 00:16:53.280 align:middle
<c.magenta>在这之间驱动负责验证</c>

00:16:53.347 --> 00:16:56.250 align:middle
<c.magenta>你设置的状态是有效的</c>

00:16:56.650 --> 00:16:59.052 align:middle
<c.magenta>然后 最坏的情况</c>

00:16:59.219 --> 00:17:01.255 align:middle
<c.magenta>你还得付出运行时</c>
<c.magenta>重新编译着色器的代价</c>

00:16:59.219 --> 00:17:01.255 align:middle
<c.magenta>你还得付出运行时</c>
<c.magenta>重新编译着色器的代价</c>

00:17:01.922 --> 00:17:03.724 align:middle
<c.magenta>我们想要避免这些</c>

00:17:04.590 --> 00:17:07.261 align:middle
<c.magenta>在Metal中 它看起来像这样</c>

00:17:08.228 --> 00:17:10.564 align:middle
<c.magenta>你设置一个预验证的管线状态对象</c>

00:17:10.631 --> 00:17:12.933 align:middle
<c.magenta>可能还有其他少数辅助状态</c>

00:17:12.999 --> 00:17:14.468 align:middle
<c.magenta>然后触发绘制调用</c>

00:17:14.867 --> 00:17:17.604 align:middle
<c.magenta>我们这里想要减少绘制调用的负担</c>

00:17:17.671 --> 00:17:20.374 align:middle
<c.magenta>把更多工作提前进行</c>

00:17:21.375 --> 00:17:27.146 align:middle
<c.magenta>这里有几个你可以在管线状态对象中</c>
<c.magenta>设置的样例状态</c>

00:17:27.214 --> 00:17:30.384 align:middle
<c.magenta>这些状态绘制时你可以在任何时间设置</c>

00:17:30.617 --> 00:17:32.085 align:middle
<c.magenta>你看到左面这栏</c>

00:17:32.152 --> 00:17:33.987 align:middle
<c.magenta>你可能设置的管线状态</c>

00:17:34.054 --> 00:17:37.157 align:middle
<c.magenta>有顶点和片段函数用来绘制的</c>

00:17:37.391 --> 00:17:40.127 align:middle
<c.magenta>还有透明渲染状态</c>

00:17:42.162 --> 00:17:44.364 align:middle
<c.magenta>右面 我们看到的状态是</c>

00:17:44.431 --> 00:17:46.700 align:middle
<c.magenta>你可以在触发绘制函数前设置</c>

00:17:46.767 --> 00:17:49.603 align:middle
<c.magenta>包括front face winding</c>
<c.magenta>和cull mode</c>

00:17:50.971 --> 00:17:53.173 align:middle
<c.magenta>来讲一下如何创建对象</c>

00:17:53.240 --> 00:17:55.242 align:middle
<c.magenta>包括这些预验证的状态</c>

00:17:56.276 --> 00:17:59.179 align:middle
<c.magenta>主要对象是</c>
<c.magenta>Metal RenderPipelineState</c>

00:17:59.880 --> 00:18:02.983 align:middle
<c.magenta>它代表一类GPU的管线配置</c>

00:17:59.880 --> 00:18:02.983 align:middle
<c.magenta>它代表一类GPU的管线配置</c>

00:18:03.217 --> 00:18:06.820 align:middle
<c.magenta>它包括你会在加载时创建的</c>
<c.magenta>一个预验证集合</c>

00:18:08.055 --> 00:18:09.423 align:middle
<c.magenta>像设备</c>

00:18:09.489 --> 00:18:11.992 align:middle
<c.magenta>RenderPipelineStates</c>
<c.magenta>是持久对象</c>

00:18:12.059 --> 00:18:16.063 align:middle
<c.magenta>你想让它在你的整个程序</c>
<c.magenta>生命周期都存在</c>

00:18:16.597 --> 00:18:18.365 align:middle
<c.magenta>如果你有很多不同的函数</c>

00:18:18.432 --> 00:18:20.033 align:middle
<c.magenta>你可以异步创建管线状态对象</c>

00:18:20.100 --> 00:18:22.269 align:middle
<c.magenta>在程序运行的时候</c>

00:18:23.270 --> 00:18:25.372 align:middle
<c.magenta>实际上在创建</c>
<c.magenta>RenderPipelineState时</c>

00:18:25.439 --> 00:18:26.673 align:middle
<c.magenta>我们不会直接创建</c>

00:18:26.740 --> 00:18:29.443 align:middle
<c.magenta>反而 我们会用一个叫做</c>
<c.magenta>Descriptor的对象</c>

00:18:30.577 --> 00:18:34.014 align:middle
<c.magenta>它打包了所有参数用来创建</c>
<c.magenta>RenderPipelineState</c>

00:18:34.515 --> 00:18:37.551 align:middle
<c.magenta>通常在Metal中</c>
<c.magenta>我们创建Descriptor对象</c>

00:18:37.618 --> 00:18:40.354 align:middle
<c.magenta>它会把所有不同的参数弄在一起</c>

00:18:40.420 --> 00:18:42.623 align:middle
<c.magenta>我们在创建其他对象时也会使用</c>

00:18:42.689 --> 00:18:45.158 align:middle
<c.magenta>对于RenderPipelineState对象</c>

00:18:45.225 --> 00:18:47.227 align:middle
<c.magenta>它被叫做渲染管线描述符</c>

00:18:47.294 --> 00:18:50.230 align:middle
<c.magenta>你会发现它包含指向顶点函数</c>

00:18:50.297 --> 00:18:52.232 align:middle
<c.magenta>和片段函数的指针</c>
<c.magenta>我早先曾介绍过</c>

00:18:52.299 --> 00:18:55.202 align:middle
<c.magenta>它还包含一个附件集合</c>

00:18:55.569 --> 00:18:59.506 align:middle
<c.magenta>附件是一些纹理我们会在</c>

00:18:59.573 --> 00:19:01.341 align:middle
<c.magenta>实际渲染中用到</c>

00:18:59.573 --> 00:19:01.341 align:middle
<c.magenta>实际渲染中用到</c>

00:19:01.708 --> 00:19:04.344 align:middle
<c.magenta>现在在Metal中</c>
<c.magenta>所有的渲染都会被渲染到纹理中</c>

00:19:04.678 --> 00:19:08.081 align:middle
<c.magenta>但我们不需要提前指向</c>
<c.magenta>那些纹理的指针</c>

00:19:08.348 --> 00:19:11.552 align:middle
<c.magenta>我们只需要提供你要渲染的像素格式</c>

00:19:11.618 --> 00:19:15.255 align:middle
<c.magenta>这样我们对它们的管线状态优化</c>

00:19:15.689 --> 00:19:18.258 align:middle
<c.magenta>若你使用了深度</c>
<c.magenta>或者Stencil Buffer</c>

00:19:18.325 --> 00:19:21.361 align:middle
<c.magenta>你也可以指定它们的像素格式</c>

00:19:22.229 --> 00:19:24.831 align:middle
<c.magenta>你一旦创建了一个管线描述符</c>

00:19:25.199 --> 00:19:27.201 align:middle
<c.magenta>你可以传递给你的Metal设备</c>

00:19:27.267 --> 00:19:29.937 align:middle
<c.magenta>然后得到一个</c>
<c.magenta>MTLRenderPipelineState对象</c>

00:19:30.504 --> 00:19:32.039 align:middle
<c.magenta>让我们在代码中看一下</c>

00:19:32.673 --> 00:19:35.375 align:middle
<c.magenta>这是一个RenderPipelineState</c>
<c.magenta>的最小化配置</c>

00:19:35.442 --> 00:19:37.611 align:middle
<c.magenta>你会发现我们设置了顶点函数</c>

00:19:37.678 --> 00:19:39.780 align:middle
<c.magenta>和片段函数属性给</c>

00:19:39.847 --> 00:19:43.116 align:middle
<c.magenta>我们先前从我们库中创建的</c>
<c.magenta>顶点和片段对象</c>

00:19:44.284 --> 00:19:46.453 align:middle
<c.magenta>同时我们也创建了</c>

00:19:46.520 --> 00:19:49.857 align:middle
<c.magenta>主要颜色附件的像素格式</c>
<c.magenta>为.bgra8Unorm</c>

00:19:49.923 --> 00:19:53.560 align:middle
<c.magenta>它是一个可显示和渲染的像素格式</c>

00:19:55.429 --> 00:19:57.331 align:middle
<c.magenta>这代表我们最终要</c>

00:19:57.397 --> 00:19:59.666 align:middle
<c.magenta>在绘制的时候绘制的纹理</c>

00:20:00.367 --> 00:20:03.270 align:middle
<c.magenta>最后 一旦我们创建了管线描述符</c>

00:20:03.737 --> 00:20:06.540 align:middle
<c.magenta>我们可以用设备新的</c>
<c.magenta>RenderPipelineState函数</c>

00:20:06.607 --> 00:20:10.077 align:middle
<c.magenta>来获得实际的预验证对象</c>

00:20:11.945 --> 00:20:14.715 align:middle
<c.magenta>我还行强调下PipelineStates</c>
<c.magenta>是持久的对象</c>

00:20:14.781 --> 00:20:16.450 align:middle
<c.magenta>你应该在加载时创建</c>

00:20:16.517 --> 00:20:19.086 align:middle
<c.magenta>在使用设备和资源的时候需要保持</c>

00:20:19.186 --> 00:20:20.921 align:middle
<c.magenta>你可以在绘制时在它们之间切换</c>

00:20:20.988 --> 00:20:22.489 align:middle
<c.magenta>来达到不同的效果</c>

00:20:22.789 --> 00:20:26.693 align:middle
<c.magenta>通常会有一对顶点和片段函数</c>

00:20:28.862 --> 00:20:31.765 align:middle
<c.magenta>现在我们已经讨论了</c>
<c.magenta>如何创建预验证的状态</c>

00:20:32.132 --> 00:20:34.535 align:middle
<c.magenta>和如何加载资源到内存中</c>

00:20:34.601 --> 00:20:37.905 align:middle
<c.magenta>接下来我们说下触发GPU指令</c>
<c.magenta>包括绘制调用</c>

00:20:39.640 --> 00:20:41.341 align:middle
<c.magenta>我们通过几个阶段介绍</c>

00:20:41.408 --> 00:20:43.877 align:middle
<c.magenta>我们还会讨论和</c>
<c.magenta>UIKit AppKit交互</c>

00:20:44.378 --> 00:20:47.314 align:middle
<c.magenta>稍微讨论下Metal指令提交模型</c>

00:20:47.414 --> 00:20:49.950 align:middle
<c.magenta>然后到渲染和绘制调用 最终</c>

00:20:50.017 --> 00:20:52.052 align:middle
<c.magenta>如何展现你的内容到屏幕上</c>

00:20:53.153 --> 00:20:55.322 align:middle
<c.magenta>就与UIKit和AppKit</c>
<c.magenta>交互而言</c>

00:20:55.389 --> 00:20:59.092 align:middle
<c.magenta>我们用MetalKit里的</c>
<c.magenta>一个工具MTKView</c>

00:20:59.660 --> 00:21:02.729 align:middle
<c.magenta>MTKView是一个跨平台的视图类</c>

00:20:59.660 --> 00:21:02.729 align:middle
<c.magenta>MTKView是一个跨平台的视图类</c>

00:21:02.796 --> 00:21:05.265 align:middle
<c.magenta>继承自Mac OS的NSView</c>

00:21:05.799 --> 00:21:08.068 align:middle
<c.magenta>iOS和tvOS中的UIView</c>

00:21:09.269 --> 00:21:11.405 align:middle
<c.magenta>它可以减少你要写的代码</c>

00:21:11.471 --> 00:21:13.173 align:middle
<c.magenta>为了让它在Metal中运行起来</c>

00:21:13.473 --> 00:21:17.010 align:middle
<c.magenta>例如 它会创建和管理一个</c>
<c.magenta>CA Metal Layer</c>

00:21:17.077 --> 00:21:20.147 align:middle
<c.magenta>是CALayer的一个特殊子类</c>

00:21:20.214 --> 00:21:23.784 align:middle
<c.magenta>可以和窗口服务或者显示循环交互</c>

00:21:23.851 --> 00:21:25.352 align:middle
<c.magenta>来让你的内容显示到屏幕上</c>

00:21:25.419 --> 00:21:29.256 align:middle
<c.magenta>通过CV或CA显示链</c>

00:21:29.456 --> 00:21:31.892 align:middle
<c.magenta>可管理绘制回调循环</c>

00:21:31.992 --> 00:21:33.627 align:middle
<c.magenta>通过循环触发回调</c>

00:21:34.027 --> 00:21:35.729 align:middle
<c.magenta>来完成你的绘制</c>

00:21:35.796 --> 00:21:38.765 align:middle
<c.magenta>同时它还可以管理要渲染的纹理</c>

00:21:39.766 --> 00:21:41.835 align:middle
<c.magenta>具体的方面我想强调</c>

00:21:42.135 --> 00:21:45.439 align:middle
<c.magenta>它可以做什么和那些绘图资源</c>

00:21:46.306 --> 00:21:50.944 align:middle
<c.magenta>在CA Metal Layer中</c>
<c.magenta>由MTKView管理</c>

00:21:51.011 --> 00:21:52.913 align:middle
<c.magenta>有一个可绘制资源集合</c>

00:21:53.013 --> 00:21:54.848 align:middle
<c.magenta>可绘制资源包含一个纹理</c>

00:21:54.915 --> 00:21:56.717 align:middle
<c.magenta>将要显示到屏幕上</c>

00:21:57.084 --> 00:21:59.486 align:middle
<c.magenta>这些在一个内部的队列中保存</c>
<c.magenta>会在帧间复用</c>

00:21:59.553 --> 00:22:02.155 align:middle
<c.magenta>因为它们相对来说要耗费资源</c>

00:21:59.553 --> 00:22:02.155 align:middle
<c.magenta>因为它们相对来说要耗费资源</c>

00:22:02.489 --> 00:22:05.058 align:middle
<c.magenta>它们需要由系统管理</c>

00:22:05.125 --> 00:22:07.661 align:middle
<c.magenta>因为它们和东西</c>

00:22:07.728 --> 00:22:09.663 align:middle
<c.magenta>如何在屏幕上显示息息相关</c>

00:22:09.730 --> 00:22:12.966 align:middle
<c.magenta>我们替你管理并给你</c>

00:22:13.033 --> 00:22:15.636 align:middle
<c.magenta>包含纹理的可绘制对象</c>
<c.magenta>让你来绘制</c>

00:22:16.470 --> 00:22:18.272 align:middle
<c.magenta>这里有几个属性</c>

00:22:18.338 --> 00:22:20.340 align:middle
<c.magenta>你可以给MTKView设置</c>

00:22:20.407 --> 00:22:24.044 align:middle
<c.magenta>来定义如何管理纹理并往里面绘制</c>

00:22:24.111 --> 00:22:26.914 align:middle
<c.magenta>特别是 你还可以设置一个纯色</c>

00:22:26.980 --> 00:22:29.483 align:middle
<c.magenta>让主色更清楚</c>

00:22:29.950 --> 00:22:32.753 align:middle
<c.magenta>可以指定颜色像素格式</c>

00:22:33.120 --> 00:22:36.123 align:middle
<c.magenta>需要匹配你指定的</c>

00:22:36.190 --> 00:22:37.791 align:middle
<c.magenta>固定管线的状态对象的颜色格式</c>

00:22:37.858 --> 00:22:41.161 align:middle
<c.magenta>同时制定深度或模板颜色格式</c>

00:22:41.562 --> 00:22:43.630 align:middle
<c.magenta>最后一个属性可能是最重要的一个了</c>

00:22:43.697 --> 00:22:45.699 align:middle
<c.magenta>我们在这里设置代理</c>

00:22:45.832 --> 00:22:49.603 align:middle
<c.magenta>MTKView实际上不会做任何绘制</c>

00:22:49.670 --> 00:22:51.071 align:middle
<c.magenta>你可以将它归为一个子类别</c>

00:22:51.205 --> 00:22:54.341 align:middle
<c.magenta>或者你实现一个代理负责绘制</c>

00:22:54.708 --> 00:22:56.577 align:middle
<c.magenta>我们通过接下来的例子来介绍</c>

00:22:56.844 --> 00:22:59.346 align:middle
<c.magenta>我们看看你需要怎么做</c>

00:22:59.413 --> 00:23:02.382 align:middle
<c.magenta>才能实现一个MTKView代理</c>

00:22:59.413 --> 00:23:02.382 align:middle
<c.magenta>才能实现一个MTKView代理</c>

00:23:03.584 --> 00:23:06.119 align:middle
<c.magenta>可归结需要实现两个方法</c>

00:23:06.353 --> 00:23:09.423 align:middle
<c.magenta>绘制大小变化和绘制</c>

00:23:10.023 --> 00:23:13.126 align:middle
<c.magenta>在绘制大小变化里你负责</c>

00:23:13.193 --> 00:23:18.031 align:middle
<c.magenta>响应如窗口大小发生变化</c>
<c.magenta>或者设备旋转</c>

00:23:18.098 --> 00:23:20.667 align:middle
<c.magenta>比如 如果你的投影矩阵依赖</c>

00:23:20.734 --> 00:23:23.604 align:middle
<c.magenta>窗口大小 那么它可以让你</c>

00:23:23.670 --> 00:23:26.240 align:middle
<c.magenta>响应来替代重建所有帧</c>

00:23:27.140 --> 00:23:30.511 align:middle
<c.magenta>绘制方法会固定的被调用</c>

00:23:30.611 --> 00:23:33.514 align:middle
<c.magenta>可以让你编码你想的执行指令</c>

00:23:33.580 --> 00:23:36.116 align:middle
<c.magenta>包括绘制调用</c>

00:23:36.183 --> 00:23:39.920 align:middle
<c.magenta>我们没有展示这个方法的</c>
<c.magenta>完整的内部内容</c>

00:23:41.255 --> 00:23:44.324 align:middle
<c.magenta>但是这是对指令提交的简单介绍</c>

00:23:44.558 --> 00:23:48.529 align:middle
<c.magenta>你要创建commandBuffer</c>
<c.magenta>做些事情 然后提交</c>

00:23:48.829 --> 00:23:50.964 align:middle
<c.magenta>稍后我们会做更多介绍</c>

00:23:51.031 --> 00:23:55.068 align:middle
<c.magenta>但是这是一种使用MTKView</c>
<c.magenta>的绘制功能的hook函数</c>

00:23:55.903 --> 00:23:58.238 align:middle
<c.magenta>我们推荐使用MTKView</c>
<c.magenta>尤其是在开始时</c>

00:23:58.305 --> 00:24:00.507 align:middle
<c.magenta>因为它已经为你做了不少其他的东西</c>

00:23:58.305 --> 00:24:00.507 align:middle
<c.magenta>因为它已经为你做了不少其他的东西</c>

00:24:01.408 --> 00:24:03.810 align:middle
<c.magenta>我们说下Metal的指令提交模型</c>

00:24:04.244 --> 00:24:06.079 align:middle
<c.magenta>这里有张我们要做的图</c>

00:24:06.146 --> 00:24:07.714 align:middle
<c.magenta>在接下来几张幻灯片中</c>

00:24:08.682 --> 00:24:12.052 align:middle
<c.magenta>你不需要记住所有的东西</c>

00:24:12.119 --> 00:24:14.188 align:middle
<c.magenta>我们将要把这个图绘出来</c>

00:24:14.288 --> 00:24:15.756 align:middle
<c.magenta>这仅是个大体介绍</c>

00:24:15.822 --> 00:24:19.359 align:middle
<c.magenta>我们会创建这个对象</c>

00:24:20.627 --> 00:24:24.464 align:middle
<c.magenta>Metal的指令提交模型非常明确</c>

00:24:24.698 --> 00:24:26.934 align:middle
<c.magenta>表示你需要自己构造</c>

00:24:27.000 --> 00:24:28.969 align:middle
<c.magenta>和提交commandBuffers</c>

00:24:29.336 --> 00:24:32.005 align:middle
<c.magenta>可把commandBuffer当作</c>

00:24:32.072 --> 00:24:34.007 align:middle
<c.magenta>一个打包的工作交给GPU执行</c>

00:24:34.208 --> 00:24:37.744 align:middle
<c.magenta>不同于我们存数据的Metal缓存</c>

00:24:38.078 --> 00:24:40.380 align:middle
<c.magenta>指令缓冲存了GPU需要完成的工作</c>

00:24:40.848 --> 00:24:43.817 align:middle
<c.magenta>同时commandBuffer的</c>
<c.magenta>提交完全由你控制</c>

00:24:43.884 --> 00:24:46.019 align:middle
<c.magenta>就是当你构造了一个</c>
<c.magenta>commandBuffer</c>

00:24:46.086 --> 00:24:49.289 align:middle
<c.magenta>你负责告诉GPU何时执行</c>

00:24:49.590 --> 00:24:51.258 align:middle
<c.magenta>稍后会详细介绍</c>

00:24:51.491 --> 00:24:53.594 align:middle
<c.magenta>我们先说说指令编码器</c>

00:24:53.660 --> 00:24:56.363 align:middle
<c.magenta>把对象的API调用翻译成</c>

00:24:56.763 --> 00:24:58.432 align:middle
<c.magenta>GPU需要做的工作</c>

00:24:58.498 --> 00:24:59.399 align:middle
<c.magenta>你要明白这很重要</c>

00:24:59.466 --> 00:25:02.603 align:middle
<c.magenta>这些指令编码器不会有状态验证延时</c>

00:24:59.466 --> 00:25:02.603 align:middle
<c.magenta>这些指令编码器不会有状态验证延时</c>

00:25:02.669 --> 00:25:05.305 align:middle
<c.magenta>所以所有预验证状态捆绑到</c>

00:25:05.372 --> 00:25:07.140 align:middle
<c.magenta>管线的状态对象里了</c>

00:25:07.908 --> 00:25:10.878 align:middle
<c.magenta>我们假设它是合法的</c>
<c.magenta>因为我们已经提前验证了</c>

00:25:11.144 --> 00:25:13.981 align:middle
<c.magenta>所以这里没有额外的工作要做</c>

00:25:14.047 --> 00:25:17.117 align:middle
<c.magenta>在你的编码器或驱动</c>
<c.magenta>调用渲染指令的时候</c>

00:25:19.920 --> 00:25:22.856 align:middle
<c.magenta>还有 Metal的指令提交模型</c>
<c.magenta>是多线程的</c>

00:25:22.923 --> 00:25:26.326 align:middle
<c.magenta>你可以并行的创建多个指令缓存</c>

00:25:26.493 --> 00:25:28.896 align:middle
<c.magenta>让应用决定执行顺序</c>

00:25:29.162 --> 00:25:33.534 align:middle
<c.magenta>这可以让你的每一帧的绘制</c>
<c.magenta>执行上万次调用</c>

00:25:33.934 --> 00:25:36.370 align:middle
<c.magenta>使用Metal 第二部分会深入探讨</c>

00:25:36.470 --> 00:25:40.374 align:middle
<c.magenta>但这里因为提到了所以说一下</c>

00:25:41.775 --> 00:25:44.211 align:middle
<c.magenta>让我们深入了解下这些对象</c>

00:25:44.978 --> 00:25:47.548 align:middle
<c.magenta>首先是指令队列</c>

00:25:48.081 --> 00:25:50.317 align:middle
<c.magenta>指令队列这里是说</c>

00:25:50.384 --> 00:25:52.519 align:middle
<c.magenta>一个叫做</c>
<c.magenta>MTLCommandQueue的类</c>

00:25:52.586 --> 00:25:55.822 align:middle
<c.magenta>它把设备需要执行的指令</c>
<c.magenta>都放在队列里执行</c>

00:25:56.924 --> 00:25:59.493 align:middle
<c.magenta>像设备和资源和管线状态</c>

00:25:59.826 --> 00:26:02.796 align:middle
<c.magenta>队列是一直存在的对象</c>

00:25:59.826 --> 00:26:02.796 align:middle
<c.magenta>队列是一直存在的对象</c>

00:26:02.963 --> 00:26:06.200 align:middle
<c.magenta>在程序的整个生命周期会保持引用</c>

00:26:06.266 --> 00:26:07.935 align:middle
<c.magenta>通常你只需要创建一个</c>

00:26:08.502 --> 00:26:12.072 align:middle
<c.magenta>这样可以保证Metal API</c>
<c.magenta>是线程安全的</c>

00:26:12.239 --> 00:26:16.310 align:middle
<c.magenta>你可以创建指令缓冲渲染</c>

00:26:16.376 --> 00:26:18.445 align:middle
<c.magenta>并在多线程中使用它</c>

00:26:18.745 --> 00:26:22.349 align:middle
<c.magenta>队列可以让你创建和提交它们</c>

00:26:22.583 --> 00:26:25.752 align:middle
<c.magenta>并在自己不加锁的情况下</c>
<c.magenta>保证是线程安全的</c>

00:26:27.354 --> 00:26:29.323 align:middle
<c.magenta>创建一个指令队列很简单</c>

00:26:29.790 --> 00:26:32.159 align:middle
<c.magenta>用设备调用</c>
<c.magenta>newCommandQueue()</c>

00:26:32.459 --> 00:26:34.328 align:middle
<c.magenta>你将会得到一个Metal指令队列</c>

00:26:36.463 --> 00:26:39.466 align:middle
<c.magenta>当然只有你往里放入</c>
<c.magenta>指令的时候它才会工作</c>

00:26:39.666 --> 00:26:41.101 align:middle
<c.magenta>我们说一下</c>

00:26:44.137 --> 00:26:45.405 align:middle
<c.magenta>我已经提过指令缓冲了</c>

00:26:45.472 --> 00:26:48.809 align:middle
<c.magenta>指令缓冲是GPU要执行的打包的工作</c>

00:26:48.876 --> 00:26:51.512 align:middle
<c.magenta>在Metal中 它们用</c>

00:26:51.578 --> 00:26:53.680 align:middle
<c.magenta>一个叫做MTLCommandBuffer的类表示</c>

00:26:54.014 --> 00:26:55.983 align:middle
<c.magenta>MTLCommandBuffer</c>
<c.magenta>包含一系列指令</c>

00:26:56.049 --> 00:26:59.920 align:middle
<c.magenta>由GPU来执行 它们被放进</c>

00:26:59.987 --> 00:27:02.322 align:middle
<c.magenta>一个指令队列等待驱动来调度</c>

00:26:59.987 --> 00:27:02.322 align:middle
<c.magenta>一个指令队列等待驱动来调度</c>

00:27:02.789 --> 00:27:04.858 align:middle
<c.magenta>根据我们目前讲的这些</c>

00:27:04.925 --> 00:27:07.060 align:middle
<c.magenta>它是临时对象</c>

00:27:07.127 --> 00:27:09.630 align:middle
<c.magenta>就是说每一帧你都要</c>
<c.magenta>创建一个或多个</c>

00:27:10.230 --> 00:27:12.466 align:middle
<c.magenta>然后往里给它编码指令</c>

00:27:12.533 --> 00:27:15.135 align:middle
<c.magenta>然后让让它们脱离GPU</c>

00:27:15.202 --> 00:27:17.905 align:middle
<c.magenta>你不会重用它们 不用引用它们</c>

00:27:18.272 --> 00:27:19.640 align:middle
<c.magenta>它们会自己消失</c>

00:27:20.774 --> 00:27:22.376 align:middle
<c.magenta>创建一个commandBuffer</c>

00:27:22.442 --> 00:27:25.078 align:middle
<c.magenta>调用commandQueue.commandBuffer()</c>

00:27:28.182 --> 00:27:31.385 align:middle
<c.magenta>我们已经说了缓冲和队列</c>

00:27:31.451 --> 00:27:33.187 align:middle
<c.magenta>我们讨论下如何把数据和指令</c>

00:27:33.654 --> 00:27:36.089 align:middle
<c.magenta>放到指令缓冲中</c>

00:27:36.156 --> 00:27:38.825 align:middle
<c.magenta>通过一个叫做指令编码器的类</c>

00:27:39.026 --> 00:27:40.861 align:middle
<c.magenta>这里有几种类型的指令编码器</c>

00:27:40.961 --> 00:27:43.163 align:middle
<c.magenta>包括渲染 位传输和计算</c>

00:27:43.597 --> 00:27:45.766 align:middle
<c.magenta>这些分别实现不同的功能</c>

00:27:45.832 --> 00:27:49.002 align:middle
<c.magenta>它们都差不多 都可以把你的</c>

00:27:49.069 --> 00:27:51.638 align:middle
<c.magenta>工作编码到指令缓存中</c>

00:27:51.905 --> 00:27:55.576 align:middle
<c.magenta>比如 一个渲染指令编码器</c>

00:27:55.642 --> 00:27:57.644 align:middle
<c.magenta>可以设置状态和执行绘制调用</c>

00:27:57.911 --> 00:28:00.514 align:middle
<c.magenta>一个计算指令编码器可以</c>

00:27:57.911 --> 00:28:00.514 align:middle
<c.magenta>一个计算指令编码器可以</c>

00:28:00.848 --> 00:28:05.319 align:middle
<c.magenta>把工作添加到队列中</c>
<c.magenta>并像数据一样并行计算 不像渲染工作</c>

00:28:05.385 --> 00:28:07.955 align:middle
<c.magenta>它像GP GPU或者类似的东西</c>

00:28:08.655 --> 00:28:11.058 align:middle
<c.magenta>位传输指令编码器用来</c>

00:28:11.124 --> 00:28:13.927 align:middle
<c.magenta>在缓存和纹理之间相互拷贝数据</c>

00:28:16.330 --> 00:28:19.766 align:middle
<c.magenta>这节课中我们会详细</c>
<c.magenta>看看渲染指令编码器</c>

00:28:20.467 --> 00:28:24.605 align:middle
<c.magenta>我刚才提到 它负责编码指令</c>

00:28:24.671 --> 00:28:26.673 align:middle
<c.magenta>每一个渲染指令编码器</c>

00:28:27.040 --> 00:28:30.210 align:middle
<c.magenta>单独编码每个工作</c>

00:28:30.544 --> 00:28:32.579 align:middle
<c.magenta>如果你触发状态变化</c>

00:28:32.946 --> 00:28:35.916 align:middle
<c.magenta>然后触发绘制</c>

00:28:36.149 --> 00:28:39.887 align:middle
<c.magenta>然后管理一个渲染附件集合 代表</c>

00:28:39.953 --> 00:28:42.923 align:middle
<c.magenta>将要绘制的纹理</c>

00:28:43.924 --> 00:28:48.028 align:middle
<c.magenta>概要来说 我们说的是最后这个阶段</c>

00:28:48.095 --> 00:28:50.364 align:middle
<c.magenta>你能看到我们有这些附件</c>

00:28:50.430 --> 00:28:55.169 align:middle
<c.magenta>被挂到管线的帧缓存合适的阶段</c>

00:28:55.802 --> 00:28:58.972 align:middle
<c.magenta>如果我们做多通道渲染</c>

00:28:59.039 --> 00:29:02.643 align:middle
<c.magenta>那么一个或多个渲染目标可能</c>
<c.magenta>会变为接下来的输入</c>

00:28:59.039 --> 00:29:02.643 align:middle
<c.magenta>那么一个或多个渲染目标可能</c>
<c.magenta>会变为接下来的输入</c>

00:29:02.709 --> 00:29:05.846 align:middle
<c.magenta>这里只有一个通道 比较简单</c>

00:29:06.780 --> 00:29:09.816 align:middle
<c.magenta>附件表示纹理贴图</c>

00:29:09.883 --> 00:29:13.320 align:middle
<c.magenta>我们将要这个阶段的最后绘制</c>

00:29:14.521 --> 00:29:17.157 align:middle
<c.magenta>就是说 实际上创建一个</c>
<c.magenta>渲染指令编码器</c>

00:29:17.224 --> 00:29:20.561 align:middle
<c.magenta>使用另一种类型描述对象</c>
<c.magenta>一个RenderPassDescriptor</c>

00:29:21.028 --> 00:29:24.031 align:middle
<c.magenta>一个RenderPassDescriptor</c>
<c.magenta>包含一系列的附件</c>

00:29:24.331 --> 00:29:28.602 align:middle
<c.magenta>每一个都有加载存储操作 纯色和值</c>

00:29:28.669 --> 00:29:31.205 align:middle
<c.magenta>和将要被渲染的Metal纹理</c>

00:29:31.939 --> 00:29:35.442 align:middle
<c.magenta>我们用几页讲一下加载和存储操作</c>

00:29:35.776 --> 00:29:37.945 align:middle
<c.magenta>这里有很重要的一点需要明白</c>

00:29:38.145 --> 00:29:41.815 align:middle
<c.magenta>你需要构造一个</c>
<c.magenta>RenderPassDescriptor</c>

00:29:42.115 --> 00:29:45.352 align:middle
<c.magenta>在帧开始的时候并且把需要它</c>

00:29:45.419 --> 00:29:47.454 align:middle
<c.magenta>和将要绘制的纹理相关联</c>

00:29:47.688 --> 00:29:53.527 align:middle
<c.magenta>相比只需要知道像素格式</c>
<c.magenta>的renderPipelineState</c>

00:29:53.694 --> 00:29:55.295 align:middle
<c.magenta>这是最重要的部分</c>

00:29:55.362 --> 00:29:58.799 align:middle
<c.magenta>而你必须有我们将在</c>
<c.magenta>其中进行绘制的纹理</c>

00:30:01.235 --> 00:30:03.637 align:middle
<c.magenta>RenderPassDescriptor包含</c>

00:30:03.704 --> 00:30:06.406 align:middle
<c.magenta>渲染通道附件</c>
<c.magenta>每一个可能是一个颜色</c>

00:30:06.473 --> 00:30:07.774 align:middle
<c.magenta>深度或者模型目标</c>

00:30:08.041 --> 00:30:09.943 align:middle
<c.magenta>或者指向需要渲染的纹理</c>

00:30:10.577 --> 00:30:13.380 align:middle
<c.magenta>指定这些东西叫做加载和存储操作</c>

00:30:13.680 --> 00:30:16.383 align:middle
<c.magenta>我们更深入的说下是什么意思</c>

00:30:16.950 --> 00:30:19.987 align:middle
<c.magenta>开始的通道中你有颜色缓存</c>

00:30:20.053 --> 00:30:23.590 align:middle
<c.magenta>有深度缓存它们包含未知的内容</c>

00:30:24.258 --> 00:30:27.995 align:middle
<c.magenta>为了做些真正的工作</c>
<c.magenta>我们先清空它</c>

00:30:28.295 --> 00:30:30.898 align:middle
<c.magenta>我们通过设置和其相关的加载动作</c>

00:30:31.231 --> 00:30:33.033 align:middle
<c.magenta>在RenderPassDescriptor中</c>

00:30:34.101 --> 00:30:37.638 align:middle
<c.magenta>我们颜色和深度目标</c>
<c.magenta>设置一个清空加载动作</c>

00:30:38.105 --> 00:30:40.807 align:middle
<c.magenta>那它会把相应的颜色设置为清空色</c>

00:30:40.874 --> 00:30:42.643 align:middle
<c.magenta>或者值 根据实际情况</c>

00:30:43.410 --> 00:30:44.711 align:middle
<c.magenta>然后我们开始绘制</c>

00:30:44.845 --> 00:30:46.113 align:middle
<c.magenta>会把我们作用的结果</c>

00:30:46.180 --> 00:30:48.048 align:middle
<c.magenta>绘制到纹理上</c>

00:30:48.582 --> 00:30:50.984 align:middle
<c.magenta>然后存储操作会触发</c>

00:30:51.251 --> 00:30:53.820 align:middle
<c.magenta>存储操作包含两部分</c>

00:30:54.188 --> 00:30:57.424 align:middle
<c.magenta>存储操作的存储</c>

00:30:57.491 --> 00:30:59.193 align:middle
<c.magenta>渲染的结果应该被写会</c>

00:30:59.259 --> 00:31:00.894 align:middle
<c.magenta>内存并且存储</c>

00:30:59.259 --> 00:31:00.894 align:middle
<c.magenta>内存并且存储</c>

00:31:00.961 --> 00:31:03.263 align:middle
<c.magenta>对于颜色缓存</c>

00:31:03.330 --> 00:31:05.032 align:middle
<c.magenta>我们尽可能的在屏幕上展现</c>

00:31:05.199 --> 00:31:07.968 align:middle
<c.magenta>对于深度缓存 我们只在</c>

00:31:08.035 --> 00:31:11.438 align:middle
<c.magenta>实际绘制和渲染时用到</c>

00:31:11.638 --> 00:31:15.209 align:middle
<c.magenta>所以我们在最后的通道中</c>
<c.magenta>不关心它的结果</c>

00:31:15.409 --> 00:31:18.779 align:middle
<c.magenta>我们可以设置一个存储动作为不关心</c>
<c.magenta>为了节省些带宽</c>

00:31:19.112 --> 00:31:21.014 align:middle
<c.magenta>这也是你可以做的优化</c>

00:31:21.081 --> 00:31:23.450 align:middle
<c.magenta>如果你并不需要</c>

00:31:23.517 --> 00:31:25.152 align:middle
<c.magenta>渲染的结果写会渲染对象</c>

00:31:27.087 --> 00:31:29.556 align:middle
<c.magenta>再深入说下加载和存储操作</c>

00:31:29.623 --> 00:31:31.391 align:middle
<c.magenta>它决定了纹理内容如何被处理</c>

00:31:31.458 --> 00:31:32.960 align:middle
<c.magenta>在开始和结束的时候</c>

00:31:33.293 --> 00:31:36.597 align:middle
<c.magenta>另外对清空操作</c>

00:31:36.730 --> 00:31:39.366 align:middle
<c.magenta>也有加载操作让你</c>

00:31:39.433 --> 00:31:43.136 align:middle
<c.magenta>加载纹理的像素内容</c>

00:31:43.370 --> 00:31:44.972 align:middle
<c.magenta>用之前的处理结果</c>

00:31:45.072 --> 00:31:46.373 align:middle
<c.magenta>它也不用关心</c>

00:31:46.573 --> 00:31:49.843 align:middle
<c.magenta>比如 你想从头到尾渲染一个目标</c>

00:31:49.910 --> 00:31:53.180 align:middle
<c.magenta>所有的像素 那么你不用关心</c>

00:31:53.247 --> 00:31:56.583 align:middle
<c.magenta>之前的纹理 你也不用清空它</c>

00:31:57.017 --> 00:31:58.619 align:middle
<c.magenta>因为你知道你将会设置</c>

00:31:58.685 --> 00:32:00.954 align:middle
<c.magenta>每一个像素为一些值</c>

00:31:58.685 --> 00:32:00.954 align:middle
<c.magenta>每一个像素为一些值</c>

00:32:01.255 --> 00:32:02.823 align:middle
<c.magenta>还一种你可以做的优化</c>

00:32:02.890 --> 00:32:04.458 align:middle
<c.magenta>如果你知道你会</c>

00:32:04.525 --> 00:32:07.261 align:middle
<c.magenta>在这个阶段处理每个像素</c>

00:32:10.063 --> 00:32:13.534 align:middle
<c.magenta>我会告诉你 如何创建</c>
<c.magenta>RenderPassDescriptor</c>

00:32:13.734 --> 00:32:16.370 align:middle
<c.magenta>然后创建一个渲染器指令编码器</c>
<c.magenta>幸运的是</c>

00:32:16.603 --> 00:32:18.872 align:middle
<c.magenta>MTKView使这些变得很简单</c>

00:32:19.273 --> 00:32:21.708 align:middle
<c.magenta>之前我们配置MTKView</c>

00:32:21.942 --> 00:32:23.076 align:middle
<c.magenta>用几个属性</c>

00:32:23.143 --> 00:32:25.612 align:middle
<c.magenta>我希望你们熟悉它</c>
<c.magenta>像清空色</c>

00:32:25.679 --> 00:32:27.948 align:middle
<c.magenta>还有渲染目标的纹理格式</c>

00:32:28.248 --> 00:32:30.317 align:middle
<c.magenta>实际上你可以通过请求视图得到</c>

00:32:30.417 --> 00:32:32.319 align:middle
<c.magenta>当前的RenderPassDescriptor</c>

00:32:32.386 --> 00:32:35.122 align:middle
<c.magenta>你会获得一个设置的</c>
<c.magenta>RenderPassDescriptor</c>

00:32:35.422 --> 00:32:36.890 align:middle
<c.magenta>接下来你就可以使用它</c>

00:32:36.957 --> 00:32:39.960 align:middle
<c.magenta>创建渲染指令编码器了</c>

00:32:41.929 --> 00:32:44.364 align:middle
<c.magenta>你该这么做 调用渲染指令编码器</c>

00:32:44.431 --> 00:32:46.033 align:middle
<c.magenta>在你的指令缓存上</c>

00:32:46.099 --> 00:32:49.269 align:middle
<c.magenta>你需要重点关注当前的</c>
<c.magenta>RenderPassDescriptor是</c>

00:32:49.336 --> 00:32:50.804 align:middle
<c.magenta>一个潜在的块调用</c>

00:32:51.038 --> 00:32:53.540 align:middle
<c.magenta>这样的原因是 实际上它会调用</c>

00:32:53.607 --> 00:32:57.144 align:middle
<c.magenta>CA Metal Layers的</c>
<c.magenta>下一个可绘制函数</c>

00:32:57.444 --> 00:33:00.280 align:middle
<c.magenta>我们不会详细介绍</c>
<c.magenta>但它是用来</c>

00:32:57.444 --> 00:33:00.280 align:middle
<c.magenta>我们不会详细介绍</c>
<c.magenta>但它是用来</c>

00:33:00.347 --> 00:33:02.516 align:middle
<c.magenta>获取包含纹理的可绘制对象</c>

00:33:02.583 --> 00:33:04.184 align:middle
<c.magenta>来展示到屏幕上</c>

00:33:04.318 --> 00:33:06.620 align:middle
<c.magenta>因为那是个有限的资源</c>

00:33:06.854 --> 00:33:09.756 align:middle
<c.magenta>如果当前没有可绘制的对象</c>

00:33:09.823 --> 00:33:12.993 align:middle
<c.magenta>如果他们所有的在运行</c>
<c.magenta>然后这个调用会阻塞</c>

00:33:13.293 --> 00:33:14.995 align:middle
<c.magenta>所以这里需要注意</c>

00:33:16.597 --> 00:33:18.866 align:middle
<c.magenta>我们已经说了加载资源到内存</c>

00:33:18.932 --> 00:33:21.034 align:middle
<c.magenta>我们说了创建预验证状态</c>

00:33:21.101 --> 00:33:24.137 align:middle
<c.magenta>和创建渲染通道</c>

00:33:24.304 --> 00:33:25.739 align:middle
<c.magenta>和渲染指令编码器</c>

00:33:25.806 --> 00:33:28.141 align:middle
<c.magenta>如何把数据弄到着色器中</c>

00:33:29.376 --> 00:33:32.212 align:middle
<c.magenta>第一我们需要说下参数表</c>

00:33:33.146 --> 00:33:36.617 align:middle
<c.magenta>参数表是Metal资源到</c>

00:33:37.484 --> 00:33:38.819 align:middle
<c.magenta>着色器参数的映射</c>

00:33:39.152 --> 00:33:41.755 align:middle
<c.magenta>你用的每一种资源</c>

00:33:41.822 --> 00:33:43.323 align:middle
<c.magenta>如缓存或者纹理</c>

00:33:43.390 --> 00:33:45.459 align:middle
<c.magenta>都有他们自己的缓存参数表</c>

00:33:45.726 --> 00:33:46.994 align:middle
<c.magenta>在右面你能看到</c>

00:33:47.060 --> 00:33:49.396 align:middle
<c.magenta>我们有缓存参数表</c>

00:33:49.463 --> 00:33:52.466 align:middle
<c.magenta>和纹理参数表</c>
<c.magenta>它们中每个都包含几个</c>

00:33:52.533 --> 00:33:56.837 align:middle
<c.magenta>缓存对应着参数表中的索引</c>

00:33:57.671 --> 00:33:59.473 align:middle
<c.magenta>给定参数表的插槽的可用数量</c>

00:33:59.540 --> 00:34:02.743 align:middle
<c.magenta>根据设备决定</c>

00:33:59.540 --> 00:34:02.743 align:middle
<c.magenta>根据设备决定</c>

00:34:02.843 --> 00:34:04.378 align:middle
<c.magenta>你需要先查询</c>

00:34:05.579 --> 00:34:07.481 align:middle
<c.magenta>我们具体说下</c>

00:34:07.548 --> 00:34:10.150 align:middle
<c.magenta>在渲染指令编码器有个函数</c>

00:34:10.217 --> 00:34:11.918 align:middle
<c.magenta>叫setVerTextBuffer</c>

00:34:12.252 --> 00:34:14.188 align:middle
<c.magenta>它有三个参数</c>

00:34:14.254 --> 00:34:17.257 align:middle
<c.magenta>一个buffer 一个offset</c>
<c.magenta>一个index</c>

00:34:17.491 --> 00:34:19.893 align:middle
<c.magenta>最后一个是我们最关心的</c>

00:34:19.960 --> 00:34:23.297 align:middle
<c.magenta>因为它是我们的参数表索引</c>

00:34:25.264 --> 00:34:29.735 align:middle
<c.magenta>这是主机端设置资源</c>

00:34:29.803 --> 00:34:31.638 align:middle
<c.magenta>在使用着色器的时候</c>

00:34:31.839 --> 00:34:34.608 align:middle
<c.magenta>也有个对应的着色器端</c>

00:34:34.875 --> 00:34:36.243 align:middle
<c.magenta>像这样</c>

00:34:36.443 --> 00:34:38.645 align:middle
<c.magenta>在着色器语言中间</c>

00:34:38.745 --> 00:34:41.882 align:middle
<c.magenta>在你的着色文件中 你指定</c>

00:34:42.248 --> 00:34:46.453 align:middle
<c.magenta>每一个给定的参数</c>
<c.magenta>对应一个你要访问的资源</c>

00:34:46.520 --> 00:34:50.123 align:middle
<c.magenta>有个属性像这样</c>

00:34:50.591 --> 00:34:52.993 align:middle
<c.magenta>这是第一个缓存索引</c>

00:34:53.060 --> 00:34:54.995 align:middle
<c.magenta>索引0在参数表中</c>

00:34:55.161 --> 00:34:59.533 align:middle
<c.magenta>代表我们刚才在渲染指令编码器的缓存</c>

00:35:02.069 --> 00:35:04.538 align:middle
<c.magenta>我们详细看下</c>

00:35:04.605 --> 00:35:06.974 align:middle
<c.magenta>当在2D绘制中</c>

00:35:10.744 --> 00:35:12.212 align:middle
<c.magenta>我们创建了renderPipelineState</c>

00:35:12.279 --> 00:35:14.815 align:middle
<c.magenta>我们需要告诉渲染指令编码器</c>

00:35:14.882 --> 00:35:17.584 align:middle
<c.magenta>在绘制前需要用哪个管线状态</c>

00:35:17.718 --> 00:35:18.986 align:middle
<c.magenta>这个API就是干这个的</c>

00:35:19.419 --> 00:35:21.288 align:middle
<c.magenta>我们调用setRenderPipelineState</c>

00:35:21.355 --> 00:35:23.790 align:middle
<c.magenta>用刚才创建的</c>
<c.magenta>PipelineState对象</c>

00:35:23.957 --> 00:35:27.194 align:middle
<c.magenta>用我们创建的着色器配置</c>

00:35:27.261 --> 00:35:30.364 align:middle
<c.magenta>我们用先前创建的来绘制</c>

00:35:31.164 --> 00:35:32.666 align:middle
<c.magenta>现在RenderPipelineState</c>

00:35:32.733 --> 00:35:36.170 align:middle
<c.magenta>有相关的顶点和片段函数了</c>

00:35:36.403 --> 00:35:38.639 align:middle
<c.magenta>我们看看顶点和片段函数</c>

00:35:38.705 --> 00:35:40.941 align:middle
<c.magenta>我们在2D绘图中主要用这个</c>

00:35:41.975 --> 00:35:44.311 align:middle
<c.magenta>回到Metal着色语言</c>
<c.magenta>看起来像这样</c>

00:35:44.645 --> 00:35:48.482 align:middle
<c.magenta>大体上是一个直接的顶点函数</c>

00:35:48.549 --> 00:35:51.018 align:middle
<c.magenta>没有复杂的数学操作</c>

00:35:51.084 --> 00:35:53.954 align:middle
<c.magenta>它会复制所有的属性 直接连接</c>

00:35:54.555 --> 00:35:59.860 align:middle
<c.magenta>函数的第一个参数是一个顶点列表</c>

00:35:59.927 --> 00:36:02.162 align:middle
<c.magenta>我们刚才创建的缓存</c>

00:35:59.927 --> 00:36:02.162 align:middle
<c.magenta>我们刚才创建的缓存</c>

00:36:02.629 --> 00:36:05.165 align:middle
<c.magenta>第二个参数是属于</c>

00:36:05.232 --> 00:36:08.202 align:middle
<c.magenta>顶点ID的属性</c>

00:36:08.268 --> 00:36:11.638 align:middle
<c.magenta>表示正Metal在处理的定点的</c>

00:36:11.705 --> 00:36:13.073 align:middle
<c.magenta>索引</c>

00:36:13.473 --> 00:36:15.342 align:middle
<c.magenta>它比较重要的原因</c>

00:36:15.409 --> 00:36:17.544 align:middle
<c.magenta>vertexBuffer</c>
<c.magenta>包含所有的点</c>

00:36:17.611 --> 00:36:19.046 align:middle
<c.magenta>我们可以随机获得</c>

00:36:19.479 --> 00:36:22.883 align:middle
<c.magenta>实际上我们想在我们顶点函数</c>

00:36:22.950 --> 00:36:24.985 align:middle
<c.magenta>一次对一个点操作</c>

00:36:25.052 --> 00:36:27.321 align:middle
<c.magenta>这告诉我们正在操作哪一个</c>

00:36:27.554 --> 00:36:30.691 align:middle
<c.magenta>我们创建一个</c>
<c.magenta>VertexOut结构的实例</c>

00:36:30.791 --> 00:36:34.294 align:middle
<c.magenta>代表定顶点的各种属性</c>

00:36:34.728 --> 00:36:36.964 align:middle
<c.magenta>然后我们传给给光栅</c>

00:36:37.097 --> 00:36:39.900 align:middle
<c.magenta>我们创建一个实例 并设置位置</c>

00:36:40.000 --> 00:36:44.371 align:middle
<c.magenta>为向量位置vertexId的顶点</c>

00:36:44.671 --> 00:36:46.039 align:middle
<c.magenta>颜色也是类似</c>

00:36:46.106 --> 00:36:48.909 align:middle
<c.magenta>这里进传递了</c>
<c.magenta>vertexBuffer数据</c>

00:36:49.243 --> 00:36:52.112 align:middle
<c.magenta>给结构体供光栅来做插值</c>

00:36:52.579 --> 00:36:55.816 align:middle
<c.magenta>然后我们返回这个结构</c>

00:36:57.384 --> 00:36:59.219 align:middle
<c.magenta>让我们看看</c>
<c.magenta>fragmentFunction</c>

00:36:59.286 --> 00:37:00.954 align:middle
<c.magenta>它更简单</c>

00:36:59.286 --> 00:37:00.954 align:middle
<c.magenta>它更简单</c>

00:37:01.088 --> 00:37:05.759 align:middle
<c.magenta>所以我们得到了插值结构</c>

00:37:05.826 --> 00:37:07.761 align:middle
<c.magenta>它表示</c>

00:37:07.828 --> 00:37:10.464 align:middle
<c.magenta>光栅化得来的数据</c>

00:37:10.998 --> 00:37:12.466 align:middle
<c.magenta>我们刚抽取了颜色</c>

00:37:12.699 --> 00:37:15.702 align:middle
<c.magenta>颜色来自结构</c>

00:37:16.036 --> 00:37:17.304 align:middle
<c.magenta>然后再传回去</c>

00:37:17.604 --> 00:37:20.541 align:middle
<c.magenta>这个过程中顶点发生了什么</c>

00:37:20.607 --> 00:37:23.277 align:middle
<c.magenta>在这个例子里截取空间指定的</c>

00:37:23.710 --> 00:37:27.514 align:middle
<c.magenta>被插值然后光栅化然后</c>

00:37:27.581 --> 00:37:29.283 align:middle
<c.magenta>被每个片段处理</c>

00:37:29.349 --> 00:37:32.753 align:middle
<c.magenta>我们返回由光栅创建的插值颜色</c>

00:37:34.988 --> 00:37:37.558 align:middle
<c.magenta>一旦我们指定RenderPipelineState</c>

00:37:37.624 --> 00:37:39.693 align:middle
<c.magenta>包含我们的顶点和片段函数</c>

00:37:39.760 --> 00:37:42.930 align:middle
<c.magenta>我们可以设置额外状态</c>
<c.magenta>就像我之前介绍的</c>

00:37:42.996 --> 00:37:45.832 align:middle
<c.magenta>包括front facing状态</c>

00:37:46.066 --> 00:37:49.203 align:middle
<c.magenta>如果你想指定不同的</c>
<c.magenta>front facing顺序</c>

00:37:49.269 --> 00:37:52.005 align:middle
<c.magenta>而不用Metal默认的</c>

00:37:52.139 --> 00:37:53.240 align:middle
<c.magenta>你可以在这里实现</c>

00:37:54.808 --> 00:37:56.810 align:middle
<c.magenta>这里有许多配置项</c>
<c.magenta>但我们只看</c>

00:37:56.877 --> 00:37:58.478 align:middle
<c.magenta>一些绘制调用</c>

00:37:59.613 --> 00:38:00.547 align:middle
<c.magenta>现在</c>

00:37:59.613 --> 00:38:00.547 align:middle
<c.magenta>现在</c>

00:38:00.647 --> 00:38:02.049 align:middle
<c.magenta>Metal有很多函数</c>

00:38:02.115 --> 00:38:05.152 align:middle
<c.magenta>绘制几何图形包括indexed</c>
<c.magenta>instance和indirect</c>

00:38:05.219 --> 00:38:07.287 align:middle
<c.magenta>我们只看基本的索引绘制</c>

00:38:07.654 --> 00:38:10.224 align:middle
<c.magenta>这里我们想画一个三角形</c>

00:38:10.757 --> 00:38:13.393 align:middle
<c.magenta>我们调用drawIndexedPrimitives</c>

00:38:13.760 --> 00:38:16.663 align:middle
<c.magenta>我们指定原型为三角形</c>

00:38:16.830 --> 00:38:18.365 align:middle
<c.magenta>因为我们想画三角形</c>

00:38:18.498 --> 00:38:21.201 align:middle
<c.magenta>我们传递三个索引</c>

00:38:21.268 --> 00:38:22.603 align:middle
<c.magenta>来画一个三角形</c>

00:38:23.203 --> 00:38:26.907 align:middle
<c.magenta>我们同时需要制定索引的类型</c>

00:38:26.974 --> 00:38:31.044 align:middle
<c.magenta>我们之前声明了一个Swift</c>
<c.magenta>的数组集合</c>

00:38:31.111 --> 00:38:32.746 align:middle
<c.magenta>我们这里复制一下</c>

00:38:32.813 --> 00:38:36.550 align:middle
<c.magenta>我们还要把</c>
<c.magenta>indexBuffer传递下去</c>

00:38:36.650 --> 00:38:38.285 align:middle
<c.magenta>来表示哪些点应该绘制</c>

00:38:38.385 --> 00:38:40.220 align:middle
<c.magenta>我们把位移设置为0</c>

00:38:40.621 --> 00:38:42.589 align:middle
<c.magenta>这会画一个</c>

00:38:42.656 --> 00:38:45.058 align:middle
<c.magenta>三角形在屏幕上</c>

00:38:46.693 --> 00:38:48.695 align:middle
<c.magenta>我们可以添加些其他状态</c>

00:38:48.762 --> 00:38:50.731 align:middle
<c.magenta>触发一些其他绘制调用</c>

00:38:50.797 --> 00:38:53.066 align:middle
<c.magenta>但第一个演示我们就做这些</c>

00:38:53.600 --> 00:38:55.402 align:middle
<c.magenta>为了完成一个渲染过程</c>

00:38:55.802 --> 00:38:59.606 align:middle
<c.magenta>我们调用Render Command</c>
<c.magenta>Encoder的endEncoding</c>

00:39:00.641 --> 00:39:03.977 align:middle
<c.magenta>回顾一下</c>
<c.magenta>你需要创建一个请求</c>

00:39:04.044 --> 00:39:06.680 align:middle
<c.magenta>在开始时获得RenderPassDescriptor</c>

00:39:07.614 --> 00:39:10.918 align:middle
<c.magenta>用这个描述符创建</c>
<c.magenta>一个Render Command Encoder</c>

00:39:11.752 --> 00:39:13.520 align:middle
<c.magenta>设置RenderPipelineState</c>

00:39:14.054 --> 00:39:15.589 align:middle
<c.magenta>设置其他必要的状态</c>

00:39:15.856 --> 00:39:18.559 align:middle
<c.magenta>触发调用最后结束编码</c>

00:39:19.359 --> 00:39:21.862 align:middle
<c.magenta>这是我们看到的代码的一个概括</c>

00:39:22.262 --> 00:39:23.263 align:middle
<c.magenta>没有啥新东西</c>

00:39:23.330 --> 00:39:26.099 align:middle
<c.magenta>和刚才我说的一样</c>

00:39:26.834 --> 00:39:31.738 align:middle
<c.magenta>创建一个Render Command Encoder</c>
<c.magenta>设置状态 设置状态</c>

00:39:33.006 --> 00:39:34.575 align:middle
<c.magenta>绑定缓存 然后绘制</c>

00:39:36.243 --> 00:39:38.212 align:middle
<c.magenta>你已经渲染了这些内容</c>

00:39:38.412 --> 00:39:40.147 align:middle
<c.magenta>怎么样让它显示在屏幕上</c>

00:39:40.214 --> 00:39:41.682 align:middle
<c.magenta>非常简单</c>

00:39:41.949 --> 00:39:44.585 align:middle
<c.magenta>首先 渲染路径的颜色附件</c>

00:39:44.651 --> 00:39:47.154 align:middle
<c.magenta>通常是可绘制的纹理</c>

00:39:47.287 --> 00:39:50.824 align:middle
<c.magenta>你可从CA Metal Layer</c>
<c.magenta>或者MKTView获得</c>

00:39:51.525 --> 00:39:54.862 align:middle
<c.magenta>为了获得在实际上显示的纹理</c>

00:39:55.662 --> 00:39:57.197 align:middle
<c.magenta>你可调用commandBuffer</c>
<c.magenta>的present</c>

00:39:57.264 --> 00:39:59.533 align:middle
<c.magenta>并给它传递那个drawable</c>

00:39:59.600 --> 00:40:01.535 align:middle
<c.magenta>它将会显示到屏幕</c>

00:39:59.600 --> 00:40:01.535 align:middle
<c.magenta>它将会显示到屏幕</c>

00:40:01.602 --> 00:40:04.638 align:middle
<c.magenta>一旦所有的处理路径完成</c>

00:40:06.740 --> 00:40:08.642 align:middle
<c.magenta>要向实际完成这一帧</c>

00:40:08.709 --> 00:40:10.811 align:middle
<c.magenta>由于我们把指令编码进</c>
<c.magenta>commandBuffer</c>

00:40:10.878 --> 00:40:11.979 align:middle
<c.magenta>我们要表明下我们完成了</c>

00:40:12.045 --> 00:40:14.047 align:middle
<c.magenta>通过调用commandBuffer.commit()</c>

00:40:14.448 --> 00:40:16.483 align:middle
<c.magenta>提交告诉驱动</c>
<c.magenta>commandBuffer</c>

00:40:16.550 --> 00:40:18.085 align:middle
<c.magenta>已经准备好给GPU运行了</c>

00:40:19.853 --> 00:40:21.421 align:middle
<c.magenta>总结一下</c>

00:40:22.856 --> 00:40:24.391 align:middle
<c.magenta>我们创建了一个指令队列开始</c>

00:40:24.458 --> 00:40:27.861 align:middle
<c.magenta>它是一个持久对象</c>
<c.magenta>我们需要引用它</c>

00:40:28.462 --> 00:40:30.697 align:middle
<c.magenta>每一帧我们创建一个</c>
<c.magenta>commandBuffer</c>

00:40:30.764 --> 00:40:33.834 align:middle
<c.magenta>使用渲染指令编码器编码</c>
<c.magenta>一个或多个渲染路径</c>

00:40:34.935 --> 00:40:37.738 align:middle
<c.magenta>通过提交commandBuffer</c>
<c.magenta>来在屏幕上显示</c>

00:40:39.273 --> 00:40:41.508 align:middle
<c.magenta>现在交给我同事Matt</c>

00:40:41.575 --> 00:40:43.610 align:middle
<c.magenta>带我们完成这个2D demo绘制</c>

00:40:43.944 --> 00:40:45.012 align:middle
<c.magenta>谢谢 Warren</c>

00:40:53.120 --> 00:40:54.388 align:middle
<c.magenta>这里是验证部分</c>

00:40:54.454 --> 00:40:57.524 align:middle
<c.magenta>一个2D的三角形</c>
<c.magenta>这是Metal三角形演示</c>

00:40:57.591 --> 00:40:58.959 align:middle
<c.magenta>从题目可以看出</c>

00:40:59.459 --> 00:41:01.562 align:middle
<c.magenta>非常简单 就是一个三角形</c>
<c.magenta>三种颜色</c>

00:40:59.459 --> 00:41:01.562 align:middle
<c.magenta>非常简单 就是一个三角形</c>
<c.magenta>三种颜色</c>

00:41:01.628 --> 00:41:03.931 align:middle
<c.magenta>在边上被插值</c>

00:41:05.165 --> 00:41:06.667 align:middle
<c.magenta>我们看下代码</c>

00:41:07.835 --> 00:41:11.171 align:middle
<c.magenta>首先是MTKView的代理</c>

00:41:11.538 --> 00:41:13.507 align:middle
<c.magenta>Warren说我们需要实现个函数</c>

00:41:13.607 --> 00:41:17.044 align:middle
<c.magenta>这里是MTKView的drawable</c>
<c.magenta>和sizeable change</c>

00:41:17.344 --> 00:41:19.112 align:middle
<c.magenta>它将会在window变化时</c>

00:41:19.179 --> 00:41:21.181 align:middle
<c.magenta>响应</c>

00:41:21.949 --> 00:41:24.318 align:middle
<c.magenta>例子很简单我们不会实现它</c>

00:41:24.384 --> 00:41:27.120 align:middle
<c.magenta>你们在应用中自己实现</c>

00:41:28.121 --> 00:41:29.890 align:middle
<c.magenta>另一个是绘制</c>

00:41:31.325 --> 00:41:33.327 align:middle
<c.magenta>我们选择把它放到渲染函数</c>

00:41:33.493 --> 00:41:34.928 align:middle
<c.magenta>当我们的绘制被调用</c>

00:41:35.929 --> 00:41:37.231 align:middle
<c.magenta>我们进入渲染</c>

00:41:39.333 --> 00:41:41.702 align:middle
<c.magenta>渲染也很简单</c>

00:41:43.270 --> 00:41:46.139 align:middle
<c.magenta>当我们拿到MTKView的</c>
<c.magenta>当前RenderPassDescriptor</c>

00:41:46.673 --> 00:41:48.642 align:middle
<c.magenta>你把它弄出来 如Warren所说</c>

00:41:48.876 --> 00:41:50.344 align:middle
<c.magenta>然后你创建RenderPassDescriptor</c>

00:41:50.410 --> 00:41:51.678 align:middle
<c.magenta>然后用它编码</c>

00:41:51.745 --> 00:41:53.380 align:middle
<c.magenta>大家注意这里</c>

00:41:53.447 --> 00:41:54.715 align:middle
<c.magenta>“pushDebugGroup.”</c>

00:41:55.015 --> 00:41:57.251 align:middle
<c.magenta>这里你可以和Metal工具交互</c>

00:41:57.351 --> 00:42:00.287 align:middle
<c.magenta>当你做帧捕获</c>

00:41:57.351 --> 00:42:00.287 align:middle
<c.magenta>当你做帧捕获</c>

00:42:00.354 --> 00:42:02.623 align:middle
<c.magenta>这里会列出调试组信息</c>

00:42:02.689 --> 00:42:04.892 align:middle
<c.magenta>这里 我们有一个绘制和</c>
<c.magenta>一个绘制三角形</c>

00:42:06.760 --> 00:42:08.795 align:middle
<c.magenta>绘制完我们会弹出调试组</c>

00:42:08.862 --> 00:42:11.398 align:middle
<c.magenta>所以绘制显示标签为</c>
<c.magenta>Draw Triangle</c>

00:42:13.634 --> 00:42:15.169 align:middle
<c.magenta>我们看下着色器</c>

00:42:17.504 --> 00:42:18.939 align:middle
<c.magenta>正如Warren说的</c>

00:42:19.006 --> 00:42:21.041 align:middle
<c.magenta>我们已经有了结构</c>
<c.magenta>有顶点结构</c>

00:42:21.108 --> 00:42:23.143 align:middle
<c.magenta>这是我们放入着色器的数据格式</c>

00:42:23.210 --> 00:42:24.945 align:middle
<c.magenta>只有位置和颜色</c>

00:42:25.345 --> 00:42:26.947 align:middle
<c.magenta>有vertex out结构</c>

00:42:27.147 --> 00:42:29.249 align:middle
<c.magenta>我们会传给光栅</c>

00:42:29.316 --> 00:42:31.185 align:middle
<c.magenta>你看到位置被</c>

00:42:31.251 --> 00:42:32.786 align:middle
<c.magenta>位置属性标记</c>

00:42:32.920 --> 00:42:35.088 align:middle
<c.magenta>这里代表截取空间位置</c>

00:42:35.189 --> 00:42:37.758 align:middle
<c.magenta>每个点着色器或点函数 抱歉</c>

00:42:37.824 --> 00:42:39.059 align:middle
<c.magenta>都需要有一个</c>

00:42:40.327 --> 00:42:43.197 align:middle
<c.magenta>看起来都很熟悉 都很简单</c>

00:42:43.530 --> 00:42:45.632 align:middle
<c.magenta>顶点进来 我们有个路径</c>

00:42:46.266 --> 00:42:47.401 align:middle
<c.magenta>同时你把它们写出去</c>

00:42:47.568 --> 00:42:50.938 align:middle
<c.magenta>在片段函数里我们拿到顶点</c>

00:42:51.004 --> 00:42:54.474 align:middle
<c.magenta>被光栅化后 我们读取颜色并且传下去</c>

00:42:55.275 --> 00:42:56.910 align:middle
<c.magenta>这个三角形演示很简单</c>

00:42:56.977 --> 00:42:58.545 align:middle
<c.magenta>下面由Warren继续</c>

00:42:58.712 --> 00:42:59.913 align:middle
<c.magenta>谢谢 Matt</c>

00:43:03.817 --> 00:43:06.520 align:middle
<c.magenta>我们已经展示了如何绘制2D内容</c>

00:43:07.321 --> 00:43:10.090 align:middle
<c.magenta>2D非常酷</c>
<c.magenta>什么更酷呢</c>

00:43:12.025 --> 00:43:15.729 align:middle
<c.magenta>3D 我么说说Metal中的</c>
<c.magenta>动画和纹理绘图</c>

00:43:18.398 --> 00:43:19.933 align:middle
<c.magenta>进入3D前</c>

00:43:21.068 --> 00:43:22.936 align:middle
<c.magenta>我们会经过几个阶段</c>

00:43:23.003 --> 00:43:24.371 align:middle
<c.magenta>我们讨论如何真正实现3D</c>

00:43:24.905 --> 00:43:27.107 align:middle
<c.magenta>我们用constant缓冲实现动画</c>

00:43:27.174 --> 00:43:29.910 align:middle
<c.magenta>我们还会介绍纹理绘图样例</c>

00:43:30.611 --> 00:43:31.812 align:middle
<c.magenta>为了进入3D</c>

00:43:32.446 --> 00:43:34.948 align:middle
<c.magenta>我们已经指定了我们的顶点在截图空间</c>

00:43:35.015 --> 00:43:37.751 align:middle
<c.magenta>我们现在需要在一个模型本地空间指定</c>

00:43:38.185 --> 00:43:42.923 align:middle
<c.magenta>然后用一个合适的模型视图做投影矩阵</c>

00:43:43.190 --> 00:43:45.158 align:middle
<c.magenta>为了回到截取空间</c>

00:43:45.926 --> 00:43:48.929 align:middle
<c.magenta>同时我们将给普通顶点添加属性</c>

00:43:49.196 --> 00:43:51.665 align:middle
<c.magenta>和纹理坐标 这样我们可以</c>

00:43:51.732 --> 00:43:54.601 align:middle
<c.magenta>在我们的fragmentFunction中</c>
<c.magenta>设置光照</c>

00:43:54.735 --> 00:43:57.070 align:middle
<c.magenta>和设置纹理映射</c>

00:43:58.272 --> 00:44:00.641 align:middle
<c.magenta>这里是我们扩展过的顶点</c>

00:43:58.272 --> 00:44:00.641 align:middle
<c.magenta>这里是我们扩展过的顶点</c>

00:44:00.941 --> 00:44:05.012 align:middle
<c.magenta>我们移去了颜色属性 添加进一个向量</c>

00:44:05.345 --> 00:44:07.381 align:middle
<c.magenta>和一组纹理坐标</c>

00:44:08.549 --> 00:44:11.185 align:middle
<c.magenta>和2D中的相似</c>

00:44:11.585 --> 00:44:16.857 align:middle
<c.magenta>我们会添加一个新的缓冲</c>
<c.magenta>存储所有需要的常量</c>

00:44:17.224 --> 00:44:21.395 align:middle
<c.magenta>引用我们的顶点和片段函数</c>

00:44:21.828 --> 00:44:25.165 align:middle
<c.magenta>用来合适的转换那些顶点</c>

00:44:25.899 --> 00:44:27.167 align:middle
<c.magenta>你会发现这个缓存的轮廓</c>

00:44:27.234 --> 00:44:30.704 align:middle
<c.magenta>是虚线 这是有原因的</c>

00:44:31.805 --> 00:44:34.308 align:middle
<c.magenta>因为我们不想创建另一个Metal缓存</c>

00:44:34.775 --> 00:44:37.277 align:middle
<c.magenta>仅仅是出于要管理这一小部分数据</c>

00:44:37.344 --> 00:44:38.879 align:middle
<c.magenta>只有几个矩阵</c>

00:44:38.946 --> 00:44:41.648 align:middle
<c.magenta>实际上Metal也有很棒的API</c>

00:44:41.915 --> 00:44:45.452 align:middle
<c.magenta>用来绑定和管理非常小缓存</c>

00:44:47.387 --> 00:44:49.523 align:middle
<c.magenta>所以 对于小数据</c>

00:44:49.590 --> 00:44:51.258 align:middle
<c.magenta>小于4K的</c>

00:44:51.725 --> 00:44:54.261 align:middle
<c.magenta>你可以用这些API设置顶点字节</c>

00:44:54.628 --> 00:44:57.397 align:middle
<c.magenta>直接把数据的指针传给他</c>

00:44:57.731 --> 00:44:59.399 align:middle
<c.magenta>当然需要告诉我们大小</c>

00:44:59.900 --> 00:45:04.204 align:middle
<c.magenta>Metal会创建和重用缓存</c>

00:44:59.900 --> 00:45:04.204 align:middle
<c.magenta>Metal会创建和重用缓存</c>

00:45:04.271 --> 00:45:05.472 align:middle
<c.magenta>包含那些数据</c>

00:45:06.039 --> 00:45:10.244 align:middle
<c.magenta>你可以指定表的索引</c>

00:45:10.911 --> 00:45:12.012 align:middle
<c.magenta>这里设置为1</c>

00:45:12.079 --> 00:45:14.781 align:middle
<c.magenta>因为我们的顶点已经被</c>
<c.magenta>绑定在索引0</c>

00:45:15.249 --> 00:45:18.018 align:middle
<c.magenta>所以我们绑定在1</c>
<c.magenta>这样我能从其中读取</c>

00:45:18.085 --> 00:45:20.087 align:middle
<c.magenta>在我们的函数中</c>

00:45:20.721 --> 00:45:24.458 align:middle
<c.magenta>我们看看函数如何响应</c>

00:45:25.158 --> 00:45:27.327 align:middle
<c.magenta>开始之前 我们看一个例子</c>

00:45:27.394 --> 00:45:29.997 align:middle
<c.magenta>如何在应用中调用</c>
<c.magenta>setForTextBytes</c>

00:45:30.664 --> 00:45:32.799 align:middle
<c.magenta>我们创建了Constant结构</c>

00:45:32.866 --> 00:45:34.034 align:middle
<c.magenta>同时创建</c>

00:45:34.101 --> 00:45:37.171 align:middle
<c.magenta>包含两个矩阵相乘</c>

00:45:37.237 --> 00:45:40.641 align:middle
<c.magenta>通过模型视图投影和普通矩阵</c>

00:45:40.707 --> 00:45:42.409 align:middle
<c.magenta>这个矩阵会变换</c>

00:45:42.476 --> 00:45:45.078 align:middle
<c.magenta>本地空间为iSpace</c>

00:45:45.546 --> 00:45:47.581 align:middle
<c.magenta>我们用自己的矩阵工具构造</c>

00:45:47.648 --> 00:45:50.284 align:middle
<c.magenta>然后把它们相乘</c>

00:45:50.450 --> 00:45:53.987 align:middle
<c.magenta>最后用setVertexBytes</c>
<c.magenta>传递结构引用</c>

00:45:54.054 --> 00:45:57.124 align:middle
<c.magenta>然后Metal会拷贝</c>

00:45:57.191 --> 00:46:00.194 align:middle
<c.magenta>这个缓存用于绘制</c>

00:45:57.191 --> 00:46:00.194 align:middle
<c.magenta>这个缓存用于绘制</c>

00:46:00.327 --> 00:46:01.995 align:middle
<c.magenta>在接下的绘制调用</c>

00:46:03.830 --> 00:46:04.731 align:middle
<c.magenta>现在</c>

00:46:05.832 --> 00:46:09.803 align:middle
<c.magenta>在去年的 WWDC</c>
<c.magenta>我们介绍了Model I/O框架</c>

00:46:10.237 --> 00:46:13.574 align:middle
<c.magenta>Model I/O包含许多工具</c>

00:46:13.974 --> 00:46:16.043 align:middle
<c.magenta>最棒的是Model I/O包含</c>

00:46:16.109 --> 00:46:19.980 align:middle
<c.magenta>可以让你生成常用图形的方法</c>

00:46:20.581 --> 00:46:22.449 align:middle
<c.magenta>由于MetalKit</c>

00:46:22.516 --> 00:46:25.352 align:middle
<c.magenta>和Metal集成非常紧密</c>

00:46:25.419 --> 00:46:29.990 align:middle
<c.magenta>你可以创建顶点数据Metal</c>
<c.magenta>可以直接渲染</c>

00:46:30.991 --> 00:46:34.494 align:middle
<c.magenta>我们可以不必手动指定所有顶点</c>

00:46:34.561 --> 00:46:37.731 align:middle
<c.magenta>我们可以这样</c>
<c.magenta>在一些内容创建包</c>

00:46:38.065 --> 00:46:40.067 align:middle
<c.magenta>里面绘制模型 导出</c>

00:46:40.133 --> 00:46:41.368 align:middle
<c.magenta>然后用Model I/O加载</c>

00:46:41.435 --> 00:46:43.737 align:middle
<c.magenta>或在这个例子中 用程序生成</c>

00:46:44.938 --> 00:46:46.640 align:middle
<c.magenta>我们看看代码</c>

00:46:46.740 --> 00:46:49.843 align:middle
<c.magenta>想生成些vertexBuffers</c>
<c.magenta>表示立方体</c>

00:46:50.477 --> 00:46:53.547 align:middle
<c.magenta>为了在Metal中</c>
<c.magenta>使用Model I/O</c>

00:46:53.881 --> 00:46:56.450 align:middle
<c.magenta>我会创建一个MeshBufferAllocator</c>

00:46:57.384 --> 00:47:02.055 align:middle
<c.magenta>MeshBufferAllocator作为</c>
<c.magenta>Model I/O和Metal间的胶水程序</c>

00:46:57.384 --> 00:47:02.055 align:middle
<c.magenta>MeshBufferAllocator作为</c>
<c.magenta>Model I/O和Metal间的胶水程序</c>

00:47:02.923 --> 00:47:05.893 align:middle
<c.magenta>传递一个设备给</c>
<c.magenta>MeshBufferAllocator</c>

00:47:06.193 --> 00:47:09.263 align:middle
<c.magenta>然后我们可以让Model I/O</c>
<c.magenta>直接创建Metal缓存</c>

00:47:09.329 --> 00:47:10.898 align:middle
<c.magenta>然后传回给我们</c>

00:47:12.999 --> 00:47:16.136 align:middle
<c.magenta>所以我们用工具方法创建了</c>
<c.magenta>MDLMesh</c>

00:47:16.236 --> 00:47:20.174 align:middle
<c.magenta>boxWithExtent等等</c>
<c.magenta>传进我们的分配器</c>

00:47:20.240 --> 00:47:23.143 align:middle
<c.magenta>这将会创建一个MDLMesh</c>
<c.magenta>一个Model I/O网</c>

00:47:23.644 --> 00:47:26.346 align:middle
<c.magenta>包含相关数据</c>

00:47:26.780 --> 00:47:30.450 align:middle
<c.magenta>我们然后用MetalKit的工具类</c>
<c.magenta>提取出来</c>

00:47:31.051 --> 00:47:32.853 align:middle
<c.magenta>就是为我们提供的</c>

00:47:32.953 --> 00:47:34.154 align:middle
<c.magenta>这看起来像这样</c>

00:47:34.254 --> 00:47:36.523 align:middle
<c.magenta>首先 我们生成了MTKMesh</c>

00:47:36.590 --> 00:47:39.760 align:middle
<c.magenta>包含我们刚才创建的MDLMesh</c>
<c.magenta>同时包含设备</c>

00:47:42.162 --> 00:47:45.065 align:middle
<c.magenta>为了得到vertexBuffer</c>

00:47:45.132 --> 00:47:46.733 align:middle
<c.magenta>把它放进mesh然后抽出来</c>

00:47:47.267 --> 00:47:49.102 align:middle
<c.magenta>对于indexBuffer</c>
<c.magenta>需要进行类似操作</c>

00:47:49.670 --> 00:47:51.071 align:middle
<c.magenta>这里还有几个参数</c>

00:47:51.138 --> 00:47:52.139 align:middle
<c.magenta>我们见过</c>

00:47:52.206 --> 00:47:53.574 align:middle
<c.magenta>绘制调用的时候用的</c>

00:47:54.174 --> 00:47:56.910 align:middle
<c.magenta>这里强调一下</c>

00:47:57.077 --> 00:47:59.847 align:middle
<c.magenta>用Model I/O</c>
<c.magenta>生成进程几何图形很容易</c>

00:48:00.013 --> 00:48:03.717 align:middle
<c.magenta>然后可以将缓冲提取出来</c>
<c.magenta>直接在Metal中应用</c>

00:48:05.352 --> 00:48:07.287 align:middle
<c.magenta>下面说说纹理</c>

00:48:07.354 --> 00:48:08.455 align:middle
<c.magenta>我们有了顶点数据</c>

00:48:08.522 --> 00:48:11.792 align:middle
<c.magenta>我们想用纹理映射上去 并添加些细节</c>

00:48:11.992 --> 00:48:14.494 align:middle
<c.magenta>像你知道的那样</c>
<c.magenta>纹理是一块内存</c>

00:48:14.595 --> 00:48:16.830 align:middle
<c.magenta>用特定的像素格式预先指定</c>

00:48:16.997 --> 00:48:19.867 align:middle
<c.magenta>主要用来存储图像数据</c>

00:48:20.968 --> 00:48:24.671 align:middle
<c.magenta>在Metal中 创建一个纹理</c>

00:48:24.738 --> 00:48:25.973 align:middle
<c.magenta>用描述符对象 很常见</c>

00:48:26.240 --> 00:48:28.509 align:middle
<c.magenta>特别是Metal纹理描述符</c>

00:48:29.109 --> 00:48:31.245 align:middle
<c.magenta>纹理描述符是参数对象</c>

00:48:31.311 --> 00:48:34.381 align:middle
<c.magenta>它把纹理属性弄在一起 比如高和宽</c>

00:48:34.448 --> 00:48:37.918 align:middle
<c.magenta>还有像素格式 设备会用</c>

00:48:37.985 --> 00:48:41.588 align:middle
<c.magenta>它们生成纹理对象：Metal纹理</c>

00:48:42.155 --> 00:48:43.557 align:middle
<c.magenta>我们看看</c>

00:48:44.525 --> 00:48:46.059 align:middle
<c.magenta>我们有这些方便的函数</c>

00:48:46.126 --> 00:48:48.695 align:middle
<c.magenta>在Metal Texture</c>
<c.magenta>Descriptor中</c>

00:48:48.762 --> 00:48:51.398 align:middle
<c.magenta>可以让你得到一个2D的描述符</c>

00:48:51.932 --> 00:48:55.369 align:middle
<c.magenta>仅提供必要的参数：高 宽</c>

00:48:55.769 --> 00:48:58.605 align:middle
<c.magenta>像素格式或者你是否想</c>
<c.magenta>mipmapped</c>

00:49:00.641 --> 00:49:04.211 align:middle
<c.magenta>你可调用设备的newTexture</c>
<c.magenta>创建一个新纹理</c>

00:49:04.811 --> 00:49:07.714 align:middle
<c.magenta>这是一个不包含实际图像的纹理</c>

00:49:07.781 --> 00:49:11.218 align:middle
<c.magenta>你需要使用替换区域或者相似的方法</c>

00:49:11.618 --> 00:49:14.321 align:middle
<c.magenta>你可以查查文档怎么做</c>
<c.magenta>这里我们用</c>

00:49:14.388 --> 00:49:17.257 align:middle
<c.magenta>另一个简单点的工具</c>

00:49:17.591 --> 00:49:19.293 align:middle
<c.magenta>叫做TKTextureLoader</c>

00:49:19.359 --> 00:49:22.496 align:middle
<c.magenta>这是MetalKit提供的工具</c>
<c.magenta>用来加载图像</c>

00:49:22.563 --> 00:49:24.898 align:middle
<c.magenta>从资源包中 包括资源目录</c>

00:49:24.965 --> 00:49:27.768 align:middle
<c.magenta>或者从一个文件URL 还有CG图像</c>

00:49:27.835 --> 00:49:29.336 align:middle
<c.magenta>内存中已经有了</c>

00:49:29.403 --> 00:49:31.638 align:middle
<c.magenta>以NSImage或UIImage</c>
<c.magenta>的形式</c>

00:49:32.105 --> 00:49:34.541 align:middle
<c.magenta>它们生成填充Metal纹理</c>

00:49:34.608 --> 00:49:36.610 align:middle
<c.magenta>用合适的大小和格式</c>

00:49:36.677 --> 00:49:38.612 align:middle
<c.magenta>与你已经有的的图像数据有关</c>

00:49:39.513 --> 00:49:41.114 align:middle
<c.magenta>我们看看代码</c>

00:49:41.181 --> 00:49:43.684 align:middle
<c.magenta>你可以创建一个</c>
<c.magenta>MTKTextureLoader</c>

00:49:43.750 --> 00:49:45.252 align:middle
<c.magenta>通过传入Metal设备</c>

00:49:45.686 --> 00:49:47.354 align:middle
<c.magenta>你会得到一个</c>
<c.magenta>TextureLoader</c>

00:49:47.554 --> 00:49:50.958 align:middle
<c.magenta>同时你可以接着或许一个数据集合</c>

00:49:51.024 --> 00:49:52.559 align:middle
<c.magenta>或你的集合目录中的其他东西</c>

00:49:52.626 --> 00:49:54.127 align:middle
<c.magenta>一旦你拿到了数据</c>

00:49:54.194 --> 00:49:57.197 align:middle
<c.magenta>你可调用textureLoader.newTexture</c>

00:49:57.531 --> 00:50:00.434 align:middle
<c.magenta>然后传递数据</c>
<c.magenta>那么将会返回一个Metal纹理</c>

00:49:57.531 --> 00:50:00.434 align:middle
<c.magenta>然后传递数据</c>
<c.magenta>那么将会返回一个Metal纹理</c>

00:50:03.971 --> 00:50:07.508 align:middle
<c.magenta>你可能熟悉取样的概念</c>

00:50:07.574 --> 00:50:10.143 align:middle
<c.magenta>Samplers和Metal</c>
<c.magenta>从纹理来说不同</c>

00:50:10.210 --> 00:50:12.112 align:middle
<c.magenta>他们没有绑定在一起</c>

00:50:13.313 --> 00:50:16.550 align:middle
<c.magenta>Samplers只包含</c>
<c.magenta>纹理相关的取样状态</c>

00:50:16.617 --> 00:50:20.454 align:middle
<c.magenta>一些如过滤模式 地址模式</c>

00:50:20.521 --> 00:50:22.322 align:middle
<c.magenta>还有层级详细的参数</c>

00:50:22.489 --> 00:50:24.791 align:middle
<c.magenta>这里展示的我们都支持</c>

00:50:26.126 --> 00:50:28.996 align:middle
<c.magenta>为了获得我们竟来要绑定</c>
<c.magenta>的Sampler状态</c>

00:50:29.062 --> 00:50:31.765 align:middle
<c.magenta>在Render Command</c>
<c.magenta>encoder中做纹理绘制</c>

00:50:32.266 --> 00:50:34.668 align:middle
<c.magenta>我们会创建一个</c>
<c.magenta>Metal Sampler Descriptor</c>

00:50:34.735 --> 00:50:36.036 align:middle
<c.magenta>像这样</c>

00:50:36.436 --> 00:50:39.072 align:middle
<c.magenta>我们创建了个空的Metal Sampler Descriptor</c>

00:50:39.139 --> 00:50:40.707 align:middle
<c.magenta>拥有默认的属性</c>

00:50:40.774 --> 00:50:42.643 align:middle
<c.magenta>我们可以设置想要的属性</c>

00:50:42.709 --> 00:50:45.412 align:middle
<c.magenta>这里我们让纹理在各个轴</c>

00:50:45.479 --> 00:50:46.747 align:middle
<c.magenta>上重复</c>

00:50:47.314 --> 00:50:50.050 align:middle
<c.magenta>当缩小的时候使用</c>
<c.magenta>nearest filtering</c>

00:50:50.117 --> 00:50:52.219 align:middle
<c.magenta>当放大时用</c>
<c.magenta>linear filtering</c>

00:50:52.853 --> 00:50:54.988 align:middle
<c.magenta>一旦我们创建了描述符对象</c>

00:50:55.355 --> 00:50:56.523 align:middle
<c.magenta>我们调用</c>
<c.magenta>newSamplerState</c>

00:50:56.590 --> 00:50:59.193 align:middle
<c.magenta>得到</c>
<c.magenta>Metal Sampler State对象</c>

00:50:59.493 --> 00:51:03.630 align:middle
<c.magenta>我们可以用来在纹理中绑定采样</c>

00:50:59.493 --> 00:51:03.630 align:middle
<c.magenta>我们可以用来在纹理中绑定采样</c>

00:51:04.765 --> 00:51:07.367 align:middle
<c.magenta>在Render Command Encoder中</c>
<c.magenta>API看起来像这样</c>

00:51:07.434 --> 00:51:11.338 align:middle
<c.magenta>我们创建一个纹理 把它放在</c>
<c.magenta>插槽0</c>

00:51:11.839 --> 00:51:13.774 align:middle
<c.magenta>在片段纹理参数表中</c>

00:51:14.808 --> 00:51:18.745 align:middle
<c.magenta>然后我们绑定Sampler</c>
<c.magenta>State在索引0</c>

00:51:18.912 --> 00:51:21.849 align:middle
<c.magenta>在Sampler State</c>
<c.magenta>参数表中</c>

00:51:23.750 --> 00:51:25.886 align:middle
<c.magenta>我们看看这些函数</c>

00:51:26.720 --> 00:51:29.122 align:middle
<c.magenta>顶点函数这次会和</c>

00:51:29.189 --> 00:51:32.893 align:middle
<c.magenta>MVP矩阵相乘</c>
<c.magenta>矩阵从constant buffer中获得</c>

00:51:33.360 --> 00:51:35.229 align:middle
<c.magenta>它会变换顶点的位置</c>

00:51:35.295 --> 00:51:37.197 align:middle
<c.magenta>从本地空间到截取空间</c>

00:51:37.497 --> 00:51:40.701 align:middle
<c.magenta>我们会从顶点函数返回</c>

00:51:40.767 --> 00:51:42.736 align:middle
<c.magenta>同时它还会变换那些顶点</c>

00:51:42.803 --> 00:51:44.505 align:middle
<c.magenta>从Models Local</c>
<c.magenta>Space到Eye Space</c>

00:51:44.571 --> 00:51:46.240 align:middle
<c.magenta>然后我们做光照渲染</c>

00:51:46.406 --> 00:51:47.975 align:middle
<c.magenta>代码里看起来是这样</c>

00:51:48.108 --> 00:51:51.612 align:middle
<c.magenta>我们添加了一个参数属性通过缓存1</c>

00:51:51.678 --> 00:51:54.815 align:middle
<c.magenta>像我之前说的通过</c>
<c.magenta>constants缓存获得</c>

00:51:54.882 --> 00:51:56.283 align:middle
<c.magenta>我们已创建了一个结构类型</c>

00:51:56.850 --> 00:51:58.752 align:middle
<c.magenta>在我们的Metal着色代码中</c>

00:51:58.819 --> 00:52:01.455 align:middle
<c.magenta>和SWF代码中创建</c>
<c.magenta>constant结构关联起来</c>

00:51:58.819 --> 00:52:01.455 align:middle
<c.magenta>和SWF代码中创建</c>
<c.magenta>constant结构关联起来</c>

00:52:01.622 --> 00:52:04.958 align:middle
<c.magenta>这样我们可得到</c>
<c.magenta>MVP通过普通的矩阵</c>

00:52:05.192 --> 00:52:08.028 align:middle
<c.magenta>再一次 这个绑定在索引1的参数表</c>

00:52:08.328 --> 00:52:11.031 align:middle
<c.magenta>和你看到的属性关联起来</c>

00:52:12.199 --> 00:52:16.103 align:middle
<c.magenta>为了进入截取空间</c>

00:52:16.170 --> 00:52:18.605 align:middle
<c.magenta>获取vertexBuffer</c>
<c.magenta>位于VertexID的索引</c>

00:52:18.872 --> 00:52:20.107 align:middle
<c.magenta>得到一个位置向量</c>

00:52:20.207 --> 00:52:23.343 align:middle
<c.magenta>和MVP矩阵相乘然后赋值给结构</c>

00:52:23.944 --> 00:52:25.445 align:middle
<c.magenta>对普通的 进行相同的操作</c>

00:52:27.281 --> 00:52:29.283 align:middle
<c.magenta>我们还拷贝纹理坐标</c>

00:52:29.349 --> 00:52:31.051 align:middle
<c.magenta>给传出结构</c>

00:52:31.118 --> 00:52:33.954 align:middle
<c.magenta>这些都会被光栅插值</c>

00:52:34.021 --> 00:52:35.889 align:middle
<c.magenta>我们接着进行返回结构</c>

00:52:36.256 --> 00:52:39.359 align:middle
<c.magenta>fragmentFunction</c>
<c.magenta>比之前更参与</c>

00:52:39.760 --> 00:52:42.095 align:middle
<c.magenta>我们想要计算些光照</c>

00:52:42.162 --> 00:52:44.865 align:middle
<c.magenta>我们引用两种环境光和漫反射</c>

00:52:45.399 --> 00:52:48.001 align:middle
<c.magenta>同时从纹理中采样</c>

00:52:48.435 --> 00:52:50.838 align:middle
<c.magenta>应用到表面纹理中</c>

00:52:51.405 --> 00:52:52.439 align:middle
<c.magenta>像这样</c>

00:52:52.506 --> 00:52:55.142 align:middle
<c.magenta>我们不会详细介绍</c>

00:52:55.742 --> 00:52:57.244 align:middle
<c.magenta>需要注意的是</c>

00:52:57.311 --> 00:52:59.413 align:middle
<c.magenta>我们添加了一个参数</c>

00:52:59.479 --> 00:53:00.981 align:middle
<c.magenta>我们创建和绑定的</c>

00:52:59.479 --> 00:53:00.981 align:middle
<c.magenta>我们创建和绑定的</c>

00:53:01.181 --> 00:53:03.617 align:middle
<c.magenta>我们给它一个访问标识符</c>

00:53:03.717 --> 00:53:05.185 align:middle
<c.magenta>我们用来采样</c>

00:53:05.586 --> 00:53:07.788 align:middle
<c.magenta>在Argument Table Index的0位置</c>

00:53:07.855 --> 00:53:09.556 align:middle
<c.magenta>我们创建的</c>
<c.magenta>Sampler State在</c>

00:53:09.623 --> 00:53:13.827 align:middle
<c.magenta>samplers的Argument</c>
<c.magenta>Slot Zero</c>

00:53:13.894 --> 00:53:18.098 align:middle
<c.magenta>想获得实际的文本</c>

00:53:18.565 --> 00:53:20.601 align:middle
<c.magenta>调用纹理的Sample</c>

00:53:20.667 --> 00:53:24.004 align:middle
<c.magenta>Text2D.Sample</c>
<c.magenta>有个采样状态</c>

00:53:24.872 --> 00:53:28.442 align:middle
<c.magenta>和纹理坐标给到颜色向量</c>

00:53:30.344 --> 00:53:33.580 align:middle
<c.magenta>我们接着做光照</c>

00:53:33.647 --> 00:53:35.382 align:middle
<c.magenta>我不会详细介绍</c>

00:53:35.449 --> 00:53:39.119 align:middle
<c.magenta>它根据正常和光照方向的积来得到</c>

00:53:39.186 --> 00:53:41.922 align:middle
<c.magenta>我们设置了一些常量</c>

00:53:42.022 --> 00:53:45.559 align:middle
<c.magenta>在我们之前的着色文件</c>
<c.magenta>演示中可以看到</c>

00:53:46.126 --> 00:53:47.494 align:middle
<c.magenta>这相当多</c>

00:53:47.561 --> 00:53:52.165 align:middle
<c.magenta>我们构造特定片段的颜色</c>

00:53:52.366 --> 00:53:54.835 align:middle
<c.magenta>通过乘以从纹理中采样的值</c>

00:53:54.935 --> 00:54:00.340 align:middle
<c.magenta>通过光照反映到动画纹理的立方体上</c>

00:53:54.935 --> 00:54:00.340 align:middle
<c.magenta>通过光照反映到动画纹理的立方体上</c>

00:54:00.707 --> 00:54:03.510 align:middle
<c.magenta>现在让Matt给大家展示下</c>

00:54:05.379 --> 00:54:07.481 align:middle
<c.magenta>好的 我们看看演示</c>

00:54:07.881 --> 00:54:09.583 align:middle
<c.magenta>这里有个Metal纹理网</c>

00:54:09.683 --> 00:54:11.718 align:middle
<c.magenta>你可以看到</c>
<c.magenta>它是个很复杂的立方体</c>

00:54:11.952 --> 00:54:13.854 align:middle
<c.magenta>一些简单的光照和纹理贴图</c>

00:54:13.921 --> 00:54:15.923 align:middle
<c.magenta>在一个设置好颜色的背景上</c>

00:54:18.458 --> 00:54:19.860 align:middle
<c.magenta>欣赏下它</c>

00:54:19.927 --> 00:54:22.563 align:middle
<c.magenta>我们看看着色器</c>

00:54:23.297 --> 00:54:26.233 align:middle
<c.magenta>比起上一次 你能看到一些新的东西</c>

00:54:26.300 --> 00:54:28.869 align:middle
<c.magenta>首先是Constants结构体</c>

00:54:29.136 --> 00:54:30.704 align:middle
<c.magenta>是Swift写的</c>

00:54:30.771 --> 00:54:33.173 align:middle
<c.magenta>有4 X 4的模型投影矩阵</c>

00:54:33.473 --> 00:54:37.010 align:middle
<c.magenta>和3 X 3的普通矩阵</c>
<c.magenta>它们是用来做变换的</c>

00:54:37.744 --> 00:54:40.714 align:middle
<c.magenta>如Warren所说</c>
<c.magenta>我们有些光照数据</c>

00:54:41.215 --> 00:54:43.350 align:middle
<c.magenta>环境光强度 这里很弱</c>

00:54:43.417 --> 00:54:45.452 align:middle
<c.magenta>但漫射光 却很高</c>

00:54:45.519 --> 00:54:47.321 align:middle
<c.magenta>光的方向</c>

00:54:47.387 --> 00:54:49.256 align:middle
<c.magenta>我们用来计算点积</c>

00:54:51.158 --> 00:54:52.893 align:middle
<c.magenta>输入和输出结构有点不同</c>

00:54:52.960 --> 00:54:55.762 align:middle
<c.magenta>我们现在有更多的信息需要向下传递</c>

00:54:55.829 --> 00:54:56.697 align:middle
<c.magenta>我们有position</c>

00:54:56.763 --> 00:54:58.298 align:middle
<c.magenta>有normal 用来光照</c>

00:54:58.365 --> 00:55:01.368 align:middle
<c.magenta>和纹理坐标 用来纹理贴图</c>

00:54:58.365 --> 00:55:01.368 align:middle
<c.magenta>和纹理坐标 用来纹理贴图</c>

00:55:01.435 --> 00:55:04.137 align:middle
<c.magenta>相似的 当从顶点函数输出时</c>

00:55:05.472 --> 00:55:06.640 align:middle
<c.magenta>我们需要相似的数据</c>

00:55:06.773 --> 00:55:08.575 align:middle
<c.magenta>我们看下顶点函数</c>

00:55:08.642 --> 00:55:09.476 align:middle
<c.magenta>如Warren所说</c>

00:55:10.010 --> 00:55:12.679 align:middle
<c.magenta>就是些简单的矩阵 乘法运算</c>

00:55:12.746 --> 00:55:15.315 align:middle
<c.magenta>然后传给纹理坐标</c>

00:55:16.083 --> 00:55:18.151 align:middle
<c.magenta>快速的看下片段函数</c>

00:55:18.218 --> 00:55:20.287 align:middle
<c.magenta>就是刚才给你展示的</c>

00:55:22.256 --> 00:55:24.291 align:middle
<c.magenta>我们看看渲染器</c>

00:55:26.326 --> 00:55:27.828 align:middle
<c.magenta>接着往前</c>

00:55:28.962 --> 00:55:30.097 align:middle
<c.magenta>我们有个小动画</c>

00:55:30.163 --> 00:55:33.867 align:middle
<c.magenta>所以我们需要每段时间更新</c>
<c.magenta>我们需要知道立方体需要旋转多少</c>

00:55:34.568 --> 00:55:36.069 align:middle
<c.magenta>这里有个帮助函数</c>

00:55:36.136 --> 00:55:38.305 align:middle
<c.magenta>来更是时间间隔</c>

00:55:41.308 --> 00:55:43.043 align:middle
<c.magenta>这将修改Constants</c>

00:55:43.777 --> 00:55:45.946 align:middle
<c.magenta>像Warren说的</c>
<c.magenta>我们不想让很多数据通过GPU传递</c>

00:55:46.013 --> 00:55:48.448 align:middle
<c.magenta>所以当你设置顶点字节</c>

00:55:48.849 --> 00:55:51.885 align:middle
<c.magenta>传一个小的结构 之前的两个矩阵</c>

00:55:52.519 --> 00:55:57.090 align:middle
<c.magenta>我们用来计算变动的位置</c>

00:55:58.325 --> 00:56:00.827 align:middle
<c.magenta>放入纹理和采样 触发绘制</c>

00:55:58.325 --> 00:56:00.827 align:middle
<c.magenta>放入纹理和采样 触发绘制</c>

00:56:01.195 --> 00:56:02.763 align:middle
<c.magenta>我建议你们记住</c>

00:56:02.829 --> 00:56:04.631 align:middle
<c.magenta>用你的调试组 这样你可以知道</c>

00:56:04.865 --> 00:56:07.935 align:middle
<c.magenta>现在在什么位置</c>
<c.magenta>如果你想稍后捕获帧的话</c>

00:56:08.001 --> 00:56:11.104 align:middle
<c.magenta>展示绘制内容 提交 然后就可以了</c>

00:56:14.741 --> 00:56:15.909 align:middle
<c.magenta>很棒 谢谢 Matt</c>

00:56:19.847 --> 00:56:21.782 align:middle
<c.magenta>通过这些使用Metal的课程</c>

00:56:22.349 --> 00:56:25.586 align:middle
<c.magenta>我们想充分利用我们这几年的</c>

00:56:25.652 --> 00:56:27.087 align:middle
<c.magenta>成果 教授Metal</c>

00:56:27.454 --> 00:56:29.323 align:middle
<c.magenta>同时介绍非常棒的新工具</c>

00:56:29.590 --> 00:56:31.225 align:middle
<c.magenta>让Metal更容易使用</c>

00:56:31.325 --> 00:56:32.793 align:middle
<c.magenta>我们希望</c>

00:56:33.126 --> 00:56:35.395 align:middle
<c.magenta>这两部分课程对此有帮助</c>

00:56:35.696 --> 00:56:38.799 align:middle
<c.magenta>你看到Metal是强大的低负载的</c>

00:56:38.866 --> 00:56:42.369 align:middle
<c.magenta>GPU编程技术 幸运的</c>

00:56:42.436 --> 00:56:45.172 align:middle
<c.magenta>你现在已经熟悉它</c>

00:56:45.239 --> 00:56:46.707 align:middle
<c.magenta>其中的一些API</c>

00:56:48.242 --> 00:56:50.143 align:middle
<c.magenta>Metal非常接近</c>

00:56:50.210 --> 00:56:52.980 align:middle
<c.magenta>和符合GPU的实际运转情况</c>

00:56:53.347 --> 00:56:57.584 align:middle
<c.magenta>概念上也是这样 我们想把</c>

00:56:57.651 --> 00:57:00.654 align:middle
<c.magenta>耗费资源的操作尽可能提前</c>

00:56:57.651 --> 00:57:00.654 align:middle
<c.magenta>耗费资源的操作尽可能提前</c>

00:57:00.754 --> 00:57:02.389 align:middle
<c.magenta>你已经看到了几种方式</c>

00:57:02.456 --> 00:57:04.892 align:middle
<c.magenta>怎么安排这些API</c>

00:57:05.325 --> 00:57:09.429 align:middle
<c.magenta>这个课程不是强调一些限制和细节</c>

00:57:09.496 --> 00:57:10.564 align:middle
<c.magenta>主要是</c>

00:57:10.631 --> 00:57:12.132 align:middle
<c.magenta>想给你灌输些能力</c>

00:57:12.533 --> 00:57:14.401 align:middle
<c.magenta>你已经看到如何明确的</c>
<c.magenta>进行内存管理</c>

00:57:14.468 --> 00:57:17.337 align:middle
<c.magenta>和指令提交 可以让你的工作更智能些</c>

00:57:17.404 --> 00:57:19.740 align:middle
<c.magenta>如果你知道你的应用是怎么回事</c>

00:57:19.806 --> 00:57:22.209 align:middle
<c.magenta>你知道它在做什么 然后你可以</c>

00:57:22.409 --> 00:57:25.479 align:middle
<c.magenta>直接控制GPU</c>

00:57:26.713 --> 00:57:30.117 align:middle
<c.magenta>当然接下来的几节关于Metal课程</c>

00:57:30.517 --> 00:57:33.420 align:middle
<c.magenta>在今年的 WWDC</c>
<c.magenta>我们会给你展示更多</c>

00:57:33.487 --> 00:57:34.821 align:middle
<c.magenta>的Metal的内容</c>

00:57:35.055 --> 00:57:38.492 align:middle
<c.magenta>当然 它会让你创建有更好体验的应用</c>

00:57:38.825 --> 00:57:41.328 align:middle
<c.magenta>想要了解更多的关于602会话的信息</c>

00:57:41.395 --> 00:57:44.998 align:middle
<c.magenta>你可以访问这个URL</c>
<c.magenta>同时可以参考其他相关课程</c>

00:57:45.332 --> 00:57:48.936 align:middle
<c.magenta>第二部分还会在这个教室</c>

00:57:49.736 --> 00:57:53.307 align:middle
<c.magenta>明天我们会有</c>
<c.magenta>Metal的新东西Parts I和II</c>

00:57:54.007 --> 00:57:57.377 align:middle
<c.magenta>和高级Metal着色优化课程</c>

00:57:57.711 --> 00:57:59.947 align:middle
<c.magenta>谢谢</c>
<c.magenta>祝你们在 WWDC 中大有收获</c>
