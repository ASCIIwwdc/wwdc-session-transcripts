WEBVTT

00:00:19.353 --> 00:00:23.357
<c.magenta>Core Data的新特性</c>

00:00:23.423 --> 00:00:24.892
<c.magenta>大家好</c>

00:00:30.964 --> 00:00:33.367
<c.magenta>我是Melissa</c>
<c.magenta>Core Data工程师</c>

00:00:33.767 --> 00:00:35.903
<c.magenta>不夸张地说这是第一年</c>
<c.magenta>上台前没有人跟我说</c>

00:00:35.969 --> 00:00:37.971
<c.magenta>祝你好运</c>

00:00:38.038 --> 00:00:41.575
<c.magenta>因为我实际一个月前腿折了</c>
<c.magenta>这是我第一天脱离石膏绷带</c>

00:00:41.975 --> 00:00:44.311
<c.magenta>所以如果我一瘸一拐</c>
<c.magenta>你们知道是怎么回事</c>

00:00:47.915 --> 00:00:49.917
<c.magenta>在Core Data团队工作</c>
<c.magenta>最好的是</c>

00:00:49.983 --> 00:00:52.286
<c.magenta>实际上每年能站在这个舞台上</c>

00:00:52.352 --> 00:00:55.289
<c.magenta>告诉大家我们都做了</c>
<c.magenta>哪些新鲜有趣的事情</c>

00:00:55.355 --> 00:00:58.292
<c.magenta>不可思议 我们今年做了</c>
<c.magenta>很多 而且都非常有用</c>

00:00:58.358 --> 00:00:59.960
<c.magenta>我们希望大家喜欢这些新内容</c>

00:01:01.195 --> 00:01:03.630
<c.magenta>好 我要介绍一项新功能</c>
<c.magenta>查询生成</c>

00:01:03.997 --> 00:01:06.099
<c.magenta>Core Data并发领域的</c>
<c.magenta>一些变化</c>

00:01:06.633 --> 00:01:08.502
<c.magenta>我要介绍我们</c>
<c.magenta>在Core Data堆栈配置领域</c>

00:01:08.569 --> 00:01:10.704
<c.magenta>的一些新进展</c>

00:01:10.771 --> 00:01:12.206
<c.magenta>及我们新添加的一些API</c>

00:01:12.806 --> 00:01:15.542
<c.magenta>我们也会简单介绍下</c>
<c.magenta>为了更灵巧利落地</c>

00:01:15.609 --> 00:01:17.744
<c.magenta>与Swift集成</c>
<c.magenta>我们都做了哪些事情</c>

00:01:18.011 --> 00:01:21.782
<c.magenta>还有我们在Xcode集成</c>
<c.magenta>方面的一些改进</c>

00:01:22.683 --> 00:01:26.420
<c.magenta>内容不少 现在第一项 查询生成</c>

00:01:27.554 --> 00:01:29.423
<c.magenta>查询生成是我们添加的一项新功能</c>

00:01:29.489 --> 00:01:32.059
<c.magenta>不过在开始介绍查询生成前</c>

00:01:32.125 --> 00:01:33.727
<c.magenta>我需要简单介绍下fault</c>

00:01:34.394 --> 00:01:37.264
<c.magenta>可能有人知道</c>
<c.magenta>Core Data常使用fault</c>

00:01:38.265 --> 00:01:41.602
<c.magenta>管理对象可能是fault</c>
<c.magenta>它们之间的关系可能是fault</c>

00:01:41.668 --> 00:01:43.470
<c.magenta>如果你在使用批量提取</c>

00:01:43.537 --> 00:01:45.005
<c.magenta>那你执行抓取请求获得的阵列</c>

00:01:45.072 --> 00:01:47.708
<c.magenta>从NSManagedObjectContext</c>

00:01:47.774 --> 00:01:49.510
<c.magenta>也会是</c>
<c.magenta>一种非常特殊的fault</c>

00:01:49.910 --> 00:01:52.746
<c.magenta>话虽这么说 什么是fault？</c>

00:01:53.013 --> 00:01:57.351
<c.magenta>现在 在屏幕上</c>
<c.magenta>有一张对象图</c>

00:01:57.417 --> 00:01:59.486
<c.magenta>其中有国家 美国</c>

00:01:59.920 --> 00:02:03.457
<c.magenta>州 加利福尼亚 若干的郡</c>
<c.magenta>圣克拉拉和旧金山</c>

00:01:59.920 --> 00:02:03.457
<c.magenta>州 加利福尼亚 若干的郡</c>
<c.magenta>圣克拉拉和旧金山</c>

00:02:03.790 --> 00:02:07.861
<c.magenta>以及圣克拉拉的若干</c>
<c.magenta>城市 圣何塞和库比蒂诺</c>

00:02:08.662 --> 00:02:11.765
<c.magenta>这很像是旅游指南</c>
<c.magenta>指南书籍的一部分</c>

00:02:12.099 --> 00:02:15.502
<c.magenta>你可以翻开 浏览</c>
<c.magenta>从而在你计划游玩的</c>

00:02:15.569 --> 00:02:18.505
<c.magenta>城市中找到</c>
<c.magenta>你感兴趣的地方</c>

00:02:19.606 --> 00:02:22.476
<c.magenta>不过 仅基于我们</c>
<c.magenta>对美国的了解</c>

00:02:22.543 --> 00:02:23.911
<c.magenta>这不是完整的对象图</c>

00:02:23.977 --> 00:02:26.780
<c.magenta>实际上只是对象图的一部分</c>
<c.magenta>是子图</c>

00:02:26.847 --> 00:02:29.283
<c.magenta>因为我们知道美国有其他州</c>

00:02:29.349 --> 00:02:31.618
<c.magenta>这些州有其他郡</c>

00:02:31.685 --> 00:02:34.054
<c.magenta>这些郡有其他城市</c>

00:02:34.454 --> 00:02:35.756
<c.magenta>你也知道 除此之外</c>

00:02:35.822 --> 00:02:38.792
<c.magenta>我们知道美国只是</c>
<c.magenta>众多国家之一</c>

00:02:40.627 --> 00:02:42.996
<c.magenta>即使是在指南书籍中</c>
<c.magenta>我一次想看的</c>

00:02:43.063 --> 00:02:44.464
<c.magenta>也仅是一个数据集</c>

00:02:44.531 --> 00:02:46.166
<c.magenta>如果我计划到圣何塞旅行</c>

00:02:46.233 --> 00:02:49.703
<c.magenta>我不会关心俄勒冈或华盛顿</c>
<c.magenta>或其它类似的地方</c>

00:02:49.770 --> 00:02:51.505
<c.magenta>我甚至不会关心旧金山</c>

00:02:52.072 --> 00:02:55.676
<c.magenta>我需要能够锁定这些对象</c>
<c.magenta>到达这些目的地</c>

00:02:55.742 --> 00:02:56.910
<c.magenta>如果我感兴趣</c>

00:02:56.977 --> 00:02:59.613
<c.magenta>我可以随后改主意</c>
<c.magenta>改变想要浏览的内容</c>

00:02:59.680 --> 00:03:01.915
<c.magenta>但就目前短期而言</c>
<c.magenta>当我在计划</c>

00:02:59.680 --> 00:03:01.915
<c.magenta>但就目前短期而言</c>
<c.magenta>当我在计划</c>

00:03:01.982 --> 00:03:05.452
<c.magenta>到圣克拉拉的旅行时</c>
<c.magenta>我不在意其它地方</c>

00:03:06.386 --> 00:03:09.890
<c.magenta>这种不在意</c>
<c.magenta>在内存中表示为</c>

00:03:09.957 --> 00:03:12.860
<c.magenta>fault</c>
<c.magenta>它是一种对象</c>

00:03:12.926 --> 00:03:16.530
<c.magenta>了解在随后的某个</c>
<c.magenta>时间点如何开始检索数据</c>

00:03:16.597 --> 00:03:18.098
<c.magenta>如果我确定我想使用它</c>

00:03:18.165 --> 00:03:20.267
<c.magenta>比如 我发现我朋友</c>
<c.magenta>要结婚了</c>

00:03:20.334 --> 00:03:22.402
<c.magenta>婚礼在西雅图 我想去</c>

00:03:22.469 --> 00:03:23.837
<c.magenta>计划到西雅图的旅行</c>

00:03:24.271 --> 00:03:26.440
<c.magenta>此时 我会再次浏览美国</c>

00:03:26.507 --> 00:03:28.308
<c.magenta>下一层</c>
<c.magenta>我想浏览华盛顿州</c>

00:03:28.375 --> 00:03:31.445
<c.magenta>Core Data会自动检索</c>

00:03:31.512 --> 00:03:35.182
<c.magenta>关于华盛顿的信息</c>
<c.magenta>即使当我首次加载子图时</c>

00:03:35.249 --> 00:03:37.317
<c.magenta>华盛顿信息不在内存中</c>

00:03:37.751 --> 00:03:41.021
<c.magenta>你知道 我可以接着向下浏览</c>
<c.magenta>等等...</c>

00:03:41.655 --> 00:03:44.992
<c.magenta>这就是fault</c>
<c.magenta>它是未来 或承诺</c>

00:03:45.058 --> 00:03:46.193
<c.magenta>或延迟加载</c>

00:03:46.260 --> 00:03:49.196
<c.magenta>这些不同的名称</c>
<c.magenta>指的都是同样的东西</c>

00:03:49.263 --> 00:03:51.498
<c.magenta>Core Data可进行这操作</c>
<c.magenta>帮你尽量减少</c>

00:03:51.565 --> 00:03:53.333
<c.magenta>在任意给定时间点</c>
<c.magenta>内存中的数据量</c>

00:03:54.635 --> 00:03:55.569
<c.magenta>我们为什么使用fault？</c>

00:03:55.636 --> 00:03:58.805
<c.magenta>答案是 性能 性能 性能</c>
<c.magenta>还是性能</c>

00:04:00.007 --> 00:04:01.942
<c.magenta>性能最好的应用</c>

00:04:02.009 --> 00:04:03.944
<c.magenta>是那些不做任何额外功的应用</c>

00:04:04.711 --> 00:04:07.948
<c.magenta>你不会在iobus上加载</c>
<c.magenta>任何不需要的对象</c>

00:04:08.015 --> 00:04:11.051
<c.magenta>你不会在不需要的对象上</c>
<c.magenta>花费任何时间</c>

00:04:11.552 --> 00:04:14.955
<c.magenta>你也不想</c>
<c.magenta>在用户不注意的时候</c>

00:04:15.022 --> 00:04:16.656
<c.magenta>这些对象闲置在那里</c>

00:04:17.057 --> 00:04:18.926
<c.magenta>推高你的内存占用</c>

00:04:19.159 --> 00:04:21.528
<c.magenta>不过fault有一个小问题</c>

00:04:22.262 --> 00:04:23.564
<c.magenta>基本上是这样的</c>

00:04:23.864 --> 00:04:25.999
<c.magenta>这里我们再看对象图</c>

00:04:26.500 --> 00:04:28.902
<c.magenta>在这个案例中</c>
<c.magenta>我们有很多fault</c>

00:04:29.369 --> 00:04:31.872
<c.magenta>我顺着树形结构向下浏览</c>
<c.magenta>来到圣克拉拉</c>

00:04:31.939 --> 00:04:34.041
<c.magenta>我想启动</c>
<c.magenta>库比蒂诺fault</c>

00:04:34.508 --> 00:04:35.609
<c.magenta>但同时</c>

00:04:36.076 --> 00:04:38.612
<c.magenta>一个外部过程已经</c>
<c.magenta>开始从网站导入数据</c>

00:04:38.679 --> 00:04:40.881
<c.magenta>而且不知为何</c>
<c.magenta>库比蒂诺被删除了</c>

00:04:41.315 --> 00:04:42.916
<c.magenta>发生了什么？</c>

00:04:42.983 --> 00:04:44.518
<c.magenta>我有一个fault</c>
<c.magenta>它应开始</c>

00:04:44.585 --> 00:04:47.254
<c.magenta>检索关于</c>
<c.magenta>库比蒂诺的信息</c>

00:04:47.321 --> 00:04:49.223
<c.magenta>但那里却没有任何信息了</c>

00:04:50.390 --> 00:04:53.126
<c.magenta>我说过 我多次介绍</c>
<c.magenta>不要加载不需要的数据</c>

00:04:53.193 --> 00:04:55.195
<c.magenta>但在这个案例中</c>
<c.magenta>你会问自己</c>

00:04:55.262 --> 00:04:58.432
<c.magenta>我是不是实际上需要</c>
<c.magenta>那个数据呢？</c>

00:04:59.499 --> 00:05:00.334
<c.magenta>哎哟</c>

00:04:59.499 --> 00:05:00.334
<c.magenta>哎哟</c>

00:05:02.736 --> 00:05:03.937
<c.magenta>现在Core Data中</c>

00:05:04.071 --> 00:05:06.840
<c.magenta>通过NSManagedObjectContext</c>
<c.magenta>上的shouldDeleteInaccessibleFaults</c>

00:05:06.907 --> 00:05:08.642
<c.magenta>属性 你可以应对这种情况</c>

00:05:09.142 --> 00:05:11.478
<c.magenta>如果你设置了这个属性</c>
<c.magenta>然后当上下文注意到</c>

00:05:11.545 --> 00:05:14.147
<c.magenta>你正在试图启动</c>
<c.magenta>已删除对象的fault</c>

00:05:14.214 --> 00:05:16.049
<c.magenta>上下文会将fault</c>
<c.magenta>标记为已删除</c>

00:05:16.116 --> 00:05:18.819
<c.magenta>并将fault的所有属性</c>
<c.magenta>标记为零</c>

00:05:19.186 --> 00:05:22.189
<c.magenta>大多情况下 这就是你需要的</c>
<c.magenta>但有时候这也会不便利</c>

00:05:22.256 --> 00:05:25.726
<c.magenta>因为你的UI不知道如何处理</c>
<c.magenta>为零的标识符</c>

00:05:26.293 --> 00:05:28.562
<c.magenta>另一种方法是</c>
<c.magenta>预提取所有内容</c>

00:05:28.629 --> 00:05:31.431
<c.magenta>使用关系小键盘进行预提取</c>
<c.magenta>从而加载你认为你用户</c>

00:05:31.498 --> 00:05:33.800
<c.magenta>可能需要的所有对象</c>

00:05:34.034 --> 00:05:35.736
<c.magenta>这样 你的任务就升级了</c>

00:05:35.802 --> 00:05:38.071
<c.magenta>你需要更努力了解</c>
<c.magenta>确切地</c>

00:05:38.505 --> 00:05:40.107
<c.magenta>预测用户未来可能的需要</c>

00:05:40.340 --> 00:05:42.676
<c.magenta>这会很棘手 我们都知道</c>
<c.magenta>用户是不可预测的</c>

00:05:43.277 --> 00:05:44.945
<c.magenta>另一种方法</c>
<c.magenta>存在第三种方法</c>

00:05:45.012 --> 00:05:47.181
<c.magenta>始终都存在第三种方法</c>
<c.magenta>就是写很多代码</c>

00:05:47.381 --> 00:05:49.349
<c.magenta>首先在管理对象上下文中</c>

00:05:49.416 --> 00:05:51.919
<c.magenta>使用带ID的既有对象</c>
<c.magenta>确保在尝试fault前</c>

00:05:51.985 --> 00:05:53.787
<c.magenta>对象位于数据库中</c>

00:05:54.488 --> 00:05:55.956
<c.magenta>编写很多try catch</c>

00:05:56.156 --> 00:05:58.859
<c.magenta>围绕着所有fault启动的</c>
<c.magenta>异常处理程序</c>

00:05:58.926 --> 00:06:01.028
<c.magenta>实话说 这个代码写起来</c>
<c.magenta>可不怎么有意思</c>

00:05:58.926 --> 00:06:01.028
<c.magenta>实话说 这个代码写起来</c>
<c.magenta>可不怎么有意思</c>

00:06:01.094 --> 00:06:03.463
<c.magenta>你实际上会更愿意</c>
<c.magenta>写一些用户会使用的</c>

00:06:03.530 --> 00:06:05.766
<c.magenta>有趣功能</c>
<c.magenta>因为那才是用户</c>

00:06:05.832 --> 00:06:08.001
<c.magenta>使用你应用的原因</c>
<c.magenta>即你的应用提供灵巧功能</c>

00:06:08.635 --> 00:06:09.970
<c.magenta>不过让我们后退一步</c>

00:06:10.037 --> 00:06:13.006
<c.magenta>稍稍想一下你的用户</c>
<c.magenta>与你应用的交互</c>

00:06:14.308 --> 00:06:16.510
<c.magenta>用户视图和UI</c>
<c.magenta>通常不关心</c>

00:06:16.577 --> 00:06:20.180
<c.magenta>是否看到绝对的最近</c>
<c.magenta>最新和最快的数据</c>

00:06:20.247 --> 00:06:21.448
<c.magenta>我们怎么知道这一点？</c>

00:06:22.449 --> 00:06:24.284
<c.magenta>让我们先想想气泵</c>

00:06:24.852 --> 00:06:28.322
<c.magenta>大多数人对气泵很熟悉</c>
<c.magenta>你有时会给汽车加油</c>

00:06:28.822 --> 00:06:30.858
<c.magenta>气泵的显示屏会告诉你</c>

00:06:30.924 --> 00:06:33.627
<c.magenta>你实际已经给汽车加了</c>
<c.magenta>多少加仑或升的油</c>

00:06:34.127 --> 00:06:36.763
<c.magenta>显示数字有千分位</c>

00:06:37.197 --> 00:06:40.634
<c.magenta>我想问下大家</c>
<c.magenta>在给车加油时</c>

00:06:41.301 --> 00:06:43.537
<c.magenta>谁能实时读到</c>
<c.magenta>千分位请举手</c>

00:06:44.071 --> 00:06:46.240
<c.magenta>正如我所料</c>
<c.magenta>没有人能做到</c>

00:06:46.306 --> 00:06:48.775
<c.magenta>人类大脑喜欢数字</c>

00:06:48.842 --> 00:06:50.577
<c.magenta>以一定间隔整齐排列</c>
<c.magenta>这样容易理解</c>

00:06:51.111 --> 00:06:54.648
<c.magenta>所以用户实际不需要最近</c>
<c.magenta>最新的数据 他们只需要数据...</c>

00:06:55.482 --> 00:06:56.884
<c.magenta>合理快速地更新</c>

00:06:57.918 --> 00:07:00.320
<c.magenta>保存数据的用户</c>
<c.magenta>对此也不在乎</c>

00:06:57.918 --> 00:07:00.320
<c.magenta>保存数据的用户</c>
<c.magenta>对此也不在乎</c>

00:07:00.420 --> 00:07:02.189
<c.magenta>正因如此</c>
<c.magenta>Core Data才有合并策略</c>

00:07:02.256 --> 00:07:04.658
<c.magenta>这些策略规定进行一连串</c>
<c.magenta>编辑并将这些编辑保存</c>

00:07:04.725 --> 00:07:06.493
<c.magenta>并与数据库中的内容混合</c>

00:07:06.560 --> 00:07:07.928
<c.magenta>以及产生预期的效果</c>

00:07:08.529 --> 00:07:11.665
<c.magenta>你可以选择你需要的合并策略</c>
<c.magenta>因为你比我们更了解你的用户</c>

00:07:13.100 --> 00:07:16.069
<c.magenta>那么 如果我们能够汲取这个</c>
<c.magenta>洞见并进一步延伸会怎样？</c>

00:07:16.737 --> 00:07:19.306
<c.magenta>如果我们有方法</c>
<c.magenta>使你通过UI看到数据库中</c>

00:07:19.373 --> 00:07:21.508
<c.magenta>数据的稳定视图</c>
<c.magenta>会怎样？</c>

00:07:22.543 --> 00:07:24.344
<c.magenta>如果我们有方法</c>
<c.magenta>应对变化</c>

00:07:24.411 --> 00:07:26.146
<c.magenta>更确定地更新变化</c>
<c.magenta>会怎样？</c>

00:07:27.347 --> 00:07:30.284
<c.magenta>如果我们能做到所有这些</c>
<c.magenta>你不会再看到这个 会怎样？</c>

00:07:36.590 --> 00:07:38.559
<c.magenta>现在 我可以介绍</c>
<c.magenta>查询生成了</c>

00:07:39.660 --> 00:07:40.928
<c.magenta>查询生成是一种方法</c>

00:07:40.994 --> 00:07:43.397
<c.magenta>能使你的管理对象上下文</c>

00:07:43.463 --> 00:07:46.366
<c.magenta>基本上 执行读取数据库中</c>
<c.magenta>数据的操作</c>

00:07:46.834 --> 00:07:48.802
<c.magenta>所有向管理对象</c>
<c.magenta>上下文的读取操作</c>

00:07:48.869 --> 00:07:52.606
<c.magenta>都将看到同样的数据视图</c>
<c.magenta>直到你选择向前进</c>

00:07:52.840 --> 00:07:55.576
<c.magenta>你永远不会再看到</c>
<c.magenta>无法完成fault的消息</c>

00:07:56.043 --> 00:07:57.978
<c.magenta>而且重要的是</c>
<c.magenta>我们能高效完成这一操作</c>

00:07:58.345 --> 00:08:00.080
<c.magenta>这永远都是棘手的部分</c>

00:07:58.345 --> 00:08:00.080
<c.magenta>这永远都是棘手的部分</c>

00:08:01.348 --> 00:08:02.182
<c.magenta>这些是怎么实现的？</c>

00:08:02.249 --> 00:08:06.153
<c.magenta>这里有一个数据库 里面有</c>
<c.magenta>一个对象id是1名字是fred</c>

00:08:06.220 --> 00:08:07.988
<c.magenta>因为这些是幻灯片</c>

00:08:08.488 --> 00:08:09.356
<c.magenta>我将进行删减</c>

00:08:09.423 --> 00:08:11.491
<c.magenta>因为我需要完成此构建</c>
<c.magenta>需要的所有资产</c>

00:08:12.826 --> 00:08:15.262
<c.magenta>在传统数据库中</c>
<c.magenta>这就是你得到的</c>

00:08:15.329 --> 00:08:17.698
<c.magenta>你有一个文件 该文件有</c>
<c.magenta>对所有数据的单一视图</c>

00:08:18.131 --> 00:08:19.800
<c.magenta>但是使用查询生成</c>

00:08:20.367 --> 00:08:23.570
<c.magenta>那就变成了你数据库中的</c>
<c.magenta>第一代数据</c>

00:08:25.038 --> 00:08:27.708
<c.magenta>随着过程的进行</c>
<c.magenta>这可能会成为你的应用</c>

00:08:27.774 --> 00:08:30.978
<c.magenta>它可以是导入程序</c>
<c.magenta>可以是watch上的扩展</c>

00:08:31.044 --> 00:08:33.013
<c.magenta>某物对数据库进行修改</c>

00:08:34.881 --> 00:08:36.383
<c.magenta>新一代创建了</c>

00:08:37.650 --> 00:08:40.754
<c.magenta>而且更多的数据被创建</c>
<c.magenta>新的对象</c>

00:08:41.054 --> 00:08:44.525
<c.magenta>此时 用户启动你的应用</c>

00:08:47.194 --> 00:08:49.696
<c.magenta>创建管理对象上下文</c>
<c.magenta>你加载数据</c>

00:08:50.130 --> 00:08:51.598
<c.magenta>该上下文现在知道</c>

00:08:51.665 --> 00:08:54.535
<c.magenta>它是从数据库中的哪一代</c>
<c.magenta>加载数据</c>

00:08:54.968 --> 00:08:59.306
<c.magenta>所以随着其他过程或上下文</c>
<c.magenta>等的继续进行</c>

00:08:59.373 --> 00:09:01.742
<c.magenta>并进一步修改数据库</c>

00:08:59.373 --> 00:09:01.742
<c.magenta>并进一步修改数据库</c>

00:09:03.143 --> 00:09:06.847
<c.magenta>更多代的数据被创建</c>
<c.magenta>该上下文仍然知道它所属的代</c>

00:09:06.914 --> 00:09:11.685
<c.magenta>第二个上下文出现</c>
<c.magenta>加载一些数据 进行一些编辑</c>

00:09:12.719 --> 00:09:16.223
<c.magenta>进行保存 保存之后</c>
<c.magenta>便创建了新一代</c>

00:09:16.290 --> 00:09:19.493
<c.magenta>并追踪它现在</c>
<c.magenta>代表的一代</c>

00:09:19.560 --> 00:09:21.361
<c.magenta>在本例中</c>
<c.magenta>是数据库中的第6代</c>

00:09:21.828 --> 00:09:25.299
<c.magenta>此时 如果我们</c>
<c.magenta>在上下文1中启动fault</c>

00:09:25.365 --> 00:09:27.167
<c.magenta>即使fault对应的对象</c>

00:09:27.234 --> 00:09:29.570
<c.magenta>可能在第6代中</c>
<c.magenta>已经被删除</c>

00:09:29.636 --> 00:09:32.673
<c.magenta>上下文中仍可看到该对象</c>
<c.magenta>因为它仍然在数据库中</c>

00:09:32.739 --> 00:09:34.341
<c.magenta>就在标签第3代下</c>

00:09:35.576 --> 00:09:39.313
<c.magenta>此时 用户可以</c>
<c.magenta>在上下文1中略微编辑</c>

00:09:39.379 --> 00:09:43.383
<c.magenta>删除一些对象 更改一些对象</c>
<c.magenta>插入新的对象</c>

00:09:43.684 --> 00:09:47.054
<c.magenta>当保存上下文时</c>
<c.magenta>Core Data将使用合并策略</c>

00:09:47.120 --> 00:09:50.190
<c.magenta>将所有这些变更</c>
<c.magenta>与数据库中的内容合并</c>

00:09:50.991 --> 00:09:53.260
<c.magenta>并创建新的第7代</c>

00:09:55.462 --> 00:09:57.197
<c.magenta>以与上下文1</c>
<c.magenta>相同的</c>

00:10:00.367 --> 00:10:03.604
<c.magenta>上下文1</c>
<c.magenta>在固定到第3代时</c>

00:10:03.670 --> 00:10:05.672
<c.magenta>能够看到第3代</c>
<c.magenta>同样地</c>

00:10:06.240 --> 00:10:09.810
<c.magenta>上下文2能够对其对象</c>
<c.magenta>作出任意操作</c>

00:10:09.877 --> 00:10:12.212
<c.magenta>将对象变成fault</c>
<c.magenta>重新启动这些fault</c>

00:10:12.279 --> 00:10:14.448
<c.magenta>且上下文2将仍能看到</c>

00:10:14.515 --> 00:10:16.550
<c.magenta>数据库第6代中的数据</c>

00:10:17.618 --> 00:10:20.387
<c.magenta>所以 基本上</c>
<c.magenta>它是管理对象上下文级别的</c>

00:10:20.454 --> 00:10:22.155
<c.magenta>完全读取事务</c>

00:10:22.923 --> 00:10:25.993
<c.magenta>我们长篇介绍了</c>
<c.magenta>为什么上下文</c>

00:10:26.426 --> 00:10:27.928
<c.magenta>本质上是对的事务</c>

00:10:27.995 --> 00:10:30.030
<c.magenta>现在我们也将它们变成读取事务</c>

00:10:30.097 --> 00:10:34.001
<c.magenta>使你能够在上下文的</c>
<c.magenta>级别上立即隔离你的工作</c>

00:10:34.067 --> 00:10:38.205
<c.magenta>并最小化预防性预提取等</c>
<c.magenta>这意味着 所有人都获益</c>

00:10:40.274 --> 00:10:41.108
<c.magenta>基本要点</c>

00:10:41.175 --> 00:10:43.844
<c.magenta>单个上下文</c>
<c.magenta>可以选择想要的行为</c>

00:10:44.311 --> 00:10:46.914
<c.magenta>它可以决定它想要</c>

00:10:46.980 --> 00:10:51.251
<c.magenta>你在iOS 9和macOS 11上</c>
<c.magenta>适应的当前行为</c>

00:10:52.553 --> 00:10:55.689
<c.magenta>我们称为已取消固定 注意看</c>
<c.magenta>加载数据时树形结构顶端</c>

00:10:55.756 --> 00:10:57.624
<c.magenta>你也可以指定</c>
<c.magenta>上下文应固定到</c>

00:10:57.691 --> 00:10:59.893
<c.magenta>数据库中任意当前的世代</c>

00:10:59.960 --> 00:11:02.362
<c.magenta>当数据首次加载到</c>
<c.magenta>该上下文时</c>

00:10:59.960 --> 00:11:02.362
<c.magenta>当数据首次加载到</c>
<c.magenta>该上下文时</c>

00:11:02.429 --> 00:11:05.832
<c.magenta>或者 你可以指定</c>
<c.magenta>你想要它固定到特定世代</c>

00:11:05.899 --> 00:11:08.402
<c.magenta>如果另一个上下文</c>
<c.magenta>固定到该世代</c>

00:11:09.570 --> 00:11:12.639
<c.magenta>嵌套上下文</c>
<c.magenta>将继承父级的世代</c>

00:11:12.940 --> 00:11:15.676
<c.magenta>它们悄悄取消固定</c>
<c.magenta>但是能够看到</c>

00:11:15.742 --> 00:11:18.145
<c.magenta>通过父级世代查看的数据</c>

00:11:18.212 --> 00:11:21.949
<c.magenta>以及父级闲置未保存的</c>
<c.magenta>任何挂起的变更</c>

00:11:24.818 --> 00:11:27.187
<c.magenta>更新一定程度上很重要</c>
<c.magenta>我们都认可这一点</c>

00:11:27.254 --> 00:11:28.488
<c.magenta>用户不想看到更新</c>

00:11:28.555 --> 00:11:30.991
<c.magenta>最终 他们不希望看到10年前的数据</c>

00:11:32.526 --> 00:11:35.262
<c.magenta>世代的更新</c>
<c.magenta>发生在你通过设置</c>

00:11:35.329 --> 00:11:37.664
<c.magenta>新世代标记</c>
<c.magenta>明确告诉上下文更新时</c>

00:11:37.731 --> 00:11:38.999
<c.magenta>它们在保存时更新</c>

00:11:39.466 --> 00:11:42.703
<c.magenta>它们在你调用mergeChanges时更新</c>
<c.magenta>这时它们将更新至树的顶端</c>

00:11:42.769 --> 00:11:44.371
<c.magenta>既然你已经告诉上下文</c>

00:11:44.438 --> 00:11:47.541
<c.magenta>你知道它应该在查看</c>
<c.magenta>数据库中的一组新变化</c>

00:11:47.841 --> 00:11:50.711
<c.magenta>它的更新是调用重置引起的</c>

00:11:53.714 --> 00:11:55.382
<c.magenta>需要注意的是</c>

00:11:55.983 --> 00:11:57.618
<c.magenta>当你更新世代时</c>

00:11:57.684 --> 00:12:00.420
<c.magenta>已注册的对象不会被刷新</c>
<c.magenta>你可能不想要那样</c>

00:11:57.684 --> 00:12:00.420
<c.magenta>已注册的对象不会被刷新</c>
<c.magenta>你可能不想要那样</c>

00:12:00.654 --> 00:12:02.623
<c.magenta>我们可以很轻松地</c>
<c.magenta>让你这么做</c>

00:12:02.689 --> 00:12:05.759
<c.magenta>如果我们选择代你做</c>
<c.magenta>再让你取消难度会加大很多</c>

00:12:06.727 --> 00:12:08.095
<c.magenta>如果你想要刷新数据</c>

00:12:08.161 --> 00:12:10.831
<c.magenta>你必须调用fetch或</c>
<c.magenta>refreshAllObjects</c>

00:12:10.898 --> 00:12:14.334
<c.magenta>但是当数据实际得到更新时</c>
<c.magenta>这样会使你获得控制</c>

00:12:16.069 --> 00:12:19.173
<c.magenta>如果你想使用查询生成</c>
<c.magenta>你必须使用SQL store</c>

00:12:19.239 --> 00:12:21.175
<c.magenta>且SQL store应在</c>
<c.magenta>wall模式下</c>

00:12:21.241 --> 00:12:22.843
<c.magenta>尽管如果你</c>
<c.magenta>尝试使用查询生成</c>

00:12:22.910 --> 00:12:25.846
<c.magenta>你并未满足上述两项要求</c>
<c.magenta>系统会正常退出</c>

00:12:25.913 --> 00:12:27.614
<c.magenta>只是恢复到</c>
<c.magenta>已取消固定的行为</c>

00:12:29.216 --> 00:12:30.184
<c.magenta>我们是如何做的？</c>

00:12:30.250 --> 00:12:33.420
<c.magenta>好 现在有一种opaque</c>
<c.magenta>标记 你可以使用它</c>

00:12:33.487 --> 00:12:34.755
<c.magenta>跟踪查询生成</c>

00:12:34.821 --> 00:12:39.059
<c.magenta>这将告诉上下文 什么时候</c>
<c.magenta>从什么存储加载了数据</c>

00:12:40.594 --> 00:12:43.463
<c.magenta>查询生成标记</c>
<c.magenta>有一个方法current</c>

00:12:43.530 --> 00:12:45.399
<c.magenta>你可以使用它检索标记</c>

00:12:45.465 --> 00:12:47.801
<c.magenta>以表明在它加载数据时</c>
<c.magenta>上下文应固定</c>

00:12:50.070 --> 00:12:52.439
<c.magenta>ManagedObjectContext</c>
<c.magenta>我们有若干新方法</c>

00:12:52.506 --> 00:12:54.274
<c.magenta>有一个属性</c>
<c.magenta>QueryGenerationToken</c>

00:12:54.341 --> 00:12:58.078
<c.magenta>它将会告诉你 上下文</c>
<c.magenta>正在使用哪个查询生成</c>

00:12:58.478 --> 00:13:00.547
<c.magenta>如果上下文取消固定</c>
<c.magenta>则该属性为零</c>

00:12:58.478 --> 00:13:00.547
<c.magenta>如果上下文取消固定</c>
<c.magenta>则该属性为零</c>

00:13:01.048 --> 00:13:03.283
<c.magenta>你可以由标记设置查询生成</c>

00:13:03.350 --> 00:13:07.020
<c.magenta>或者是来自类属性的</c>
<c.magenta>current标记</c>

00:13:07.354 --> 00:13:09.122
<c.magenta>或是在另一个管理对象上下文调用</c>

00:13:09.189 --> 00:13:10.958
<c.magenta>queryGenerationToken的结果</c>

00:13:12.993 --> 00:13:16.496
<c.magenta>一个世代创建后</c>
<c.magenta>该世代不会包含添加到</c>

00:13:16.563 --> 00:13:18.232
<c.magenta>存储协调器的存储</c>

00:13:18.498 --> 00:13:21.134
<c.magenta>如果你将数据加载</c>
<c.magenta>到管理对象上下文</c>

00:13:21.201 --> 00:13:23.403
<c.magenta>将存储添加到</c>
<c.magenta>协调器然后进行提取</c>

00:13:23.470 --> 00:13:25.539
<c.magenta>你不会从该新存储</c>
<c.magenta>看到结果</c>

00:13:26.139 --> 00:13:28.575
<c.magenta>但是它不会阻止你</c>
<c.magenta>从协调器移除存储</c>

00:13:28.642 --> 00:13:29.810
<c.magenta>尽管当你已移除</c>
<c.magenta>从中加载数据的所有存储时</c>

00:13:29.877 --> 00:13:33.814
<c.magenta>如果你尝试将数据加载到上下文</c>

00:13:33.881 --> 00:13:36.750
<c.magenta>你会发现错误</c>

00:13:38.886 --> 00:13:41.288
<c.magenta>现在 我将谈论并发</c>
<c.magenta>因为</c>

00:13:41.722 --> 00:13:43.557
<c.magenta>我们总是谈论并发</c>

00:13:45.425 --> 00:13:47.694
<c.magenta>这是Core Data</c>
<c.magenta>当前的情况</c>

00:13:47.761 --> 00:13:49.830
<c.magenta>它的管理对象</c>
<c.magenta>上下文是执行者</c>

00:13:51.865 --> 00:13:54.568
<c.magenta>你使用perform以及</c>
<c.magenta>performAndWait与它交互</c>

00:13:54.635 --> 00:13:58.138
<c.magenta>做调度块 以便</c>
<c.magenta>执行管理对象上下文队列</c>

00:13:58.472 --> 00:14:00.574
<c.magenta>还有第三个模型</c>
<c.magenta>或者说另一个模型</c>

00:13:58.472 --> 00:14:00.574
<c.magenta>还有第三个模型</c>
<c.magenta>或者说另一个模型</c>

00:14:00.641 --> 00:14:02.676
<c.magenta>它使用</c>
<c.magenta>confinementConcurrencyType</c>

00:14:02.743 --> 00:14:04.511
<c.magenta>允许你直接对上下文</c>
<c.magenta>发出通知</c>

00:14:04.578 --> 00:14:08.415
<c.magenta>不过我们不推荐使用</c>
<c.magenta>因为在任何线程情景下</c>

00:14:08.482 --> 00:14:10.817
<c.magenta>它都很难操作正确</c>

00:14:11.585 --> 00:14:14.788
<c.magenta>永久性存储协调器</c>
<c.magenta>也是执行者</c>

00:14:14.855 --> 00:14:17.624
<c.magenta>拥有同样的API</c>
<c.magenta>perform和performAndWait</c>

00:14:17.691 --> 00:14:19.793
<c.magenta>协调器将对来自</c>
<c.magenta>单个管理对象上下文的</c>

00:14:19.860 --> 00:14:22.462
<c.magenta>请求进行序列化操作</c>

00:14:22.529 --> 00:14:24.898
<c.magenta>同样也对你在坐标上使用</c>
<c.magenta>perform和performAndWait API</c>

00:14:24.965 --> 00:14:28.402
<c.magenta>直接安排的任何请求</c>
<c.magenta>进行序列化操作</c>

00:14:30.571 --> 00:14:32.773
<c.magenta>现在 我想宣布一件</c>
<c.magenta>重要的事情</c>

00:14:33.240 --> 00:14:36.009
<c.magenta>我们为在ObjC中编程</c>

00:14:36.076 --> 00:14:39.213
<c.magenta>并使用手动保留释放的</c>
<c.magenta>开发者</c>

00:14:39.279 --> 00:14:40.814
<c.magenta>在执行、阻拦和等待</c>
<c.magenta>周围添加了自动释放池</c>

00:14:41.381 --> 00:14:43.150
<c.magenta>这意味着 你将负责</c>

00:14:43.217 --> 00:14:46.553
<c.magenta>延长你安排的组块内</c>

00:14:46.620 --> 00:14:48.088
<c.magenta>创建的任何对象的寿命</c>

00:14:48.155 --> 00:14:50.591
<c.magenta>如果你想要在组块外</c>
<c.magenta>使用这些对象</c>

00:14:50.958 --> 00:14:52.693
<c.magenta>要记住进行这个操作</c>
<c.magenta>很简单</c>

00:14:52.759 --> 00:14:54.328
<c.magenta>对于 比如执行提取</c>
<c.magenta>导致的结果</c>

00:14:55.829 --> 00:14:57.431
<c.magenta>有一点不是特别明显</c>

00:14:57.497 --> 00:14:59.466
<c.magenta>你还需对可能返回的NSErrors</c>

00:14:59.533 --> 00:15:00.601
<c.magenta>进行此操作</c>

00:14:59.533 --> 00:15:00.601
<c.magenta>进行此操作</c>

00:15:01.368 --> 00:15:03.837
<c.magenta>这不仅影响使用</c>
<c.magenta>手动保留释放的开发者</c>

00:15:03.904 --> 00:15:06.373
<c.magenta>我们有链接时间检查</c>
<c.magenta>这样你就不会看到此行为</c>

00:15:06.440 --> 00:15:10.143
<c.magenta>直到你针对iOS X</c>
<c.magenta>或macOS 12进行重新编译</c>

00:15:11.979 --> 00:15:14.948
<c.magenta>不过让我们讨论下</c>
<c.magenta>当今世界中存在的并发</c>

00:15:15.749 --> 00:15:18.986
<c.magenta>或者说截止昨天为止</c>
<c.magenta>世界上存在的并发</c>

00:15:20.187 --> 00:15:25.626
<c.magenta>上下文1试图进行进入</c>
<c.magenta>永久性存储所需的操作</c>

00:15:25.959 --> 00:15:27.628
<c.magenta>所以它通知协调器</c>

00:15:28.228 --> 00:15:30.797
<c.magenta>协调器由于清理请求</c>
<c.magenta>锁定了</c>

00:15:30.864 --> 00:15:32.065
<c.magenta>而此时 上下文2</c>

00:15:32.132 --> 00:15:35.068
<c.magenta>可能作为你的UIContext</c>
<c.magenta>想要采取些行动</c>

00:15:35.135 --> 00:15:36.837
<c.magenta>并试图通知协调器</c>

00:15:37.070 --> 00:15:40.607
<c.magenta>但由于协调器被锁定</c>
<c.magenta>所以上下文2必须等待</c>

00:15:40.841 --> 00:15:45.646
<c.magenta>同时来自上下文1的请求</c>
<c.magenta>传递到永久性存储</c>

00:15:45.712 --> 00:15:49.716
<c.magenta>任何需要被评估的工作</c>
<c.magenta>得到评估</c>

00:15:49.983 --> 00:15:53.887
<c.magenta>只有当这些工作完成</c>
<c.magenta>并且执行线程返回时</c>

00:15:54.888 --> 00:15:57.291
<c.magenta>上下文2才能锁定协调器</c>

00:15:57.357 --> 00:15:59.960
<c.magenta>并将其工作向下分派给存储</c>

00:16:00.027 --> 00:16:02.196
<c.magenta>这意味着上下文2基本上</c>

00:16:02.262 --> 00:16:04.798
<c.magenta>对于上下文1在进行的</c>
<c.magenta>所有工作都会被锁定</c>

00:16:06.266 --> 00:16:08.435
<c.magenta>最终会恢复</c>
<c.magenta>但同时你的IU</c>

00:16:08.502 --> 00:16:10.370
<c.magenta>可能会比较慢</c>

00:16:11.972 --> 00:16:15.709
<c.magenta>新东西 SQL存储目前有</c>
<c.magenta>连接池</c>

00:16:15.776 --> 00:16:18.679
<c.magenta>并且能够处理多个并发请求</c>

00:16:18.745 --> 00:16:22.549
<c.magenta>具体地 它现在能够处理</c>
<c.magenta>多个读取器和单个编写器</c>

00:16:23.116 --> 00:16:26.086
<c.magenta>不同平台的连接池</c>
<c.magenta>大小各异</c>

00:16:26.620 --> 00:16:30.824
<c.magenta>我们已经采用了它 并将通过</c>
<c.magenta>几张幻灯片向你展示如何更改</c>

00:16:31.158 --> 00:16:32.459
<c.magenta>现在这是怎么实现的？</c>

00:16:33.026 --> 00:16:36.263
<c.magenta>上下文1分派到协调器</c>

00:16:37.064 --> 00:16:39.066
<c.magenta>且没有任何锁定</c>

00:16:39.766 --> 00:16:44.538
<c.magenta>上下文2 可能仍然作为你的</c>
<c.magenta>UIContext 也分派协调器</c>

00:16:45.405 --> 00:16:49.776
<c.magenta>两条消息同时都向下发送给</c>
<c.magenta>永久性存储</c>

00:16:50.544 --> 00:16:52.980
<c.magenta>永久性存储随后会进行</c>
<c.magenta>所有必要工作以发现</c>

00:16:53.046 --> 00:16:55.616
<c.magenta>需要将什么消息</c>
<c.magenta>发送到SQLite</c>

00:16:55.883 --> 00:16:57.417
<c.magenta>这些消息发送到SQLite</c>

00:16:57.484 --> 00:16:59.620
<c.magenta>只有在这时才进行锁定</c>

00:16:59.686 --> 00:17:02.155
<c.magenta>这是标准的</c>
<c.magenta>SQLite文件锁</c>

00:16:59.686 --> 00:17:02.155
<c.magenta>这是标准的</c>
<c.magenta>SQLite文件锁</c>

00:17:03.090 --> 00:17:07.194
<c.magenta>SQLite进行所有必要的操作</c>
<c.magenta>开始打开事务</c>

00:17:07.261 --> 00:17:09.896
<c.magenta>对了 就是一堆SQL</c>
<c.magenta>关闭事务</c>

00:17:11.131 --> 00:17:14.800
<c.magenta>在此时结束 返回</c>

00:17:15.301 --> 00:17:18.105
<c.magenta>所以 现在 我们确实</c>
<c.magenta>已经缩小了</c>

00:17:18.172 --> 00:17:20.273
<c.magenta>关键部分的范围</c>

00:17:21.175 --> 00:17:22.175
<c.magenta>为什么要在意这一点？</c>

00:17:22.242 --> 00:17:24.678
<c.magenta>这会使你的UI反应更灵敏</c>

00:17:25.412 --> 00:17:27.915
<c.magenta>比如 当后台工作</c>
<c.magenta>在不同的上下文进行时</c>

00:17:27.981 --> 00:17:31.385
<c.magenta>你可以在主UI上</c>

00:17:31.451 --> 00:17:32.920
<c.magenta>进行fault和提取操作</c>

00:17:33.520 --> 00:17:35.222
<c.magenta>这直接的附带结果是</c>

00:17:35.289 --> 00:17:37.524
<c.magenta>简化了应用架构</c>

00:17:37.591 --> 00:17:41.361
<c.magenta>一个相当标准的模式是</c>

00:17:41.662 --> 00:17:45.332
<c.magenta>人们会有一个导入程序上下文</c>
<c.magenta>其正在从网页加载数据</c>

00:17:45.499 --> 00:17:49.536
<c.magenta>而另外 主UIContext正在</c>
<c.magenta>将数据传送到主UI</c>

00:17:50.504 --> 00:17:52.773
<c.magenta>最终它们的数据</c>
<c.magenta>位于不同的堆栈上</c>

00:17:52.840 --> 00:17:54.508
<c.magenta>这是因为UI需要快速响应</c>

00:17:54.575 --> 00:17:58.111
<c.magenta>它们需要关键部分的锁定</c>
<c.magenta>尽可能小</c>

00:17:59.379 --> 00:18:03.283
<c.magenta>而以前 当你必须锁定整个堆栈</c>
<c.magenta>唯一做到的方法是</c>

00:17:59.379 --> 00:18:03.283
<c.magenta>而以前 当你必须锁定整个堆栈</c>
<c.magenta>唯一做到的方法是</c>

00:18:03.350 --> 00:18:04.885
<c.magenta>有两个不同的堆栈</c>

00:18:05.352 --> 00:18:07.654
<c.magenta>这就导致了要在两者</c>
<c.magenta>之间倒换的问题</c>

00:18:07.721 --> 00:18:10.090
<c.magenta>比如 有一个管理对象</c>
<c.magenta>上下文完成保存的通知</c>

00:18:10.157 --> 00:18:12.593
<c.magenta>但它是来自完全不同的</c>
<c.magenta>永久性存储协调器</c>

00:18:12.659 --> 00:18:14.194
<c.magenta>我需要将它迁移过来</c>

00:18:15.062 --> 00:18:18.398
<c.magenta>现在这不再是问题</c>
<c.magenta>你现在可以将两个上下文</c>

00:18:18.465 --> 00:18:22.469
<c.magenta>都附加到同一永久性</c>
<c.magenta>存储协调器 它们将同时执行</c>

00:18:22.970 --> 00:18:25.639
<c.magenta>你仅需进行标准的合并</c>

00:18:25.706 --> 00:18:29.076
<c.magenta>而这其中的一大好处是</c>
<c.magenta>这意味着它们共享行缓存</c>

00:18:29.142 --> 00:18:31.044
<c.magenta>这样将大大降低你的</c>
<c.magenta>内存占用</c>

00:18:31.111 --> 00:18:33.480
<c.magenta>这将内存占用减半</c>

00:18:33.547 --> 00:18:35.415
<c.magenta>因为 我们现在只有</c>
<c.magenta>一个行缓存</c>

00:18:41.622 --> 00:18:44.658
<c.magenta>默认情况下它是打开的</c>
<c.magenta>它只针对SQL存储</c>

00:18:46.460 --> 00:18:48.562
<c.magenta>它只有</c>
<c.magenta>在永久性存储协调器上的</c>

00:18:48.629 --> 00:18:51.098
<c.magenta>所有协调存储是SQL存储时</c>
<c.magenta>才有效</c>

00:18:51.765 --> 00:18:54.434
<c.magenta>你可以配置连接池的大小</c>

00:18:54.501 --> 00:18:56.970
<c.magenta>使用NSPersistentStore</c>
<c.magenta>ConnectionPoolMax SizeKey</c>

00:18:58.305 --> 00:19:01.742
<c.magenta>你将能够确切地知道</c>
<c.magenta>连接池的最大容量</c>

00:18:58.305 --> 00:19:01.742
<c.magenta>你将能够确切地知道</c>
<c.magenta>连接池的最大容量</c>

00:19:01.808 --> 00:19:05.379
<c.magenta>如果你想要串行请求处理</c>
<c.magenta>旧有行为 你可以设置为1</c>

00:19:06.013 --> 00:19:08.215
<c.magenta>我们确实保留权利</c>
<c.magenta>你已经尝试将它设置为</c>

00:19:08.282 --> 00:19:09.850
<c.magenta>一百万 而这有点蠢</c>

00:19:09.917 --> 00:19:11.885
<c.magenta>所以我们会使用</c>
<c.magenta>更合理的数字</c>

00:19:13.787 --> 00:19:16.790
<c.magenta>它应该立即</c>
<c.magenta>可为你们大多数人所见</c>

00:19:16.857 --> 00:19:19.426
<c.magenta>你的UI可能会响应更快</c>

00:19:20.360 --> 00:19:22.863
<c.magenta>将此功能打开后</c>
<c.magenta>我们内部最大的发现是</c>

00:19:22.930 --> 00:19:26.099
<c.magenta>很多人说</c>
<c.magenta>哇 我能写出</c>

00:19:26.800 --> 00:19:29.136
<c.magenta>几百 几千行的代码</c>

00:19:29.236 --> 00:19:31.572
<c.magenta>你应该试试 因为</c>
<c.magenta>天啊 这太过瘾了</c>

00:19:34.308 --> 00:19:35.175
<c.magenta>有些人...</c>

00:19:39.313 --> 00:19:43.717
<c.magenta>有些人可能注意到</c>
<c.magenta>一些小小的时间问题</c>

00:19:43.784 --> 00:19:47.354
<c.magenta>若你有一个上下文</c>
<c.magenta>上下文1有执行、阻拦和等待</c>

00:19:47.421 --> 00:19:49.823
<c.magenta>上下文2也有执行</c>
<c.magenta>阻拦和等待</c>

00:19:49.890 --> 00:19:53.360
<c.magenta>最初 上下文2不会</c>
<c.magenta>开始执行其数据块</c>

00:19:53.427 --> 00:19:56.697
<c.magenta>直到上下文1的数据块返回</c>
<c.magenta>现在事实不是如此了</c>

00:19:56.763 --> 00:20:00.133
<c.magenta>所以 对于大概1%</c>
<c.magenta>遇到这种情况的人</c>

00:19:56.763 --> 00:20:00.133
<c.magenta>所以 对于大概1%</c>
<c.magenta>遇到这种情况的人</c>

00:20:00.200 --> 00:20:01.301
<c.magenta>你的时间会发生改变</c>

00:20:01.368 --> 00:20:05.038
<c.magenta>你可能需要降低带宽</c>
<c.magenta>连接池rearchitect</c>

00:20:05.439 --> 00:20:06.340
<c.magenta>而其他人</c>

00:20:07.474 --> 00:20:09.910
<c.magenta>你们只需编写更新</c>
<c.magenta>更有趣更简单的代码就行了</c>

00:20:10.944 --> 00:20:13.580
<c.magenta>现在 我将邀请我的同事</c>
<c.magenta>Scott上台</c>

00:20:13.647 --> 00:20:15.682
<c.magenta>他会介绍很多其它内容</c>

00:20:22.789 --> 00:20:23.757
<c.magenta>谢谢Melissa</c>

00:20:27.494 --> 00:20:31.098
<c.magenta>早上好</c>
<c.magenta>让我们介绍下Core Data设置</c>

00:20:32.599 --> 00:20:34.468
<c.magenta>首先添加永久性存储</c>

00:20:35.169 --> 00:20:36.970
<c.magenta>要对协调器</c>
<c.magenta>添加永久性存储</c>

00:20:37.037 --> 00:20:39.173
<c.magenta>你需要四块数据</c>

00:20:39.239 --> 00:20:41.408
<c.magenta>而完成大多数操作</c>
<c.magenta>你至少需要两块</c>

00:20:42.176 --> 00:20:44.912
<c.magenta>今年新内容中 Core Data</c>
<c.magenta>引入了一种新类型</c>

00:20:44.978 --> 00:20:48.515
<c.magenta>叫做NSPersistentStoreDescription</c>
<c.magenta>可以将所有</c>

00:20:48.582 --> 00:20:50.184
<c.magenta>描述存储所需要的数据封装</c>

00:20:50.250 --> 00:20:53.687
<c.magenta>同时包含方便的API</c>
<c.magenta>可用于一般的选项</c>

00:20:53.754 --> 00:20:56.256
<c.magenta>比如存储是否应以只读</c>
<c.magenta>形式打开</c>

00:20:56.323 --> 00:20:58.258
<c.magenta>协调器应使用的超时</c>

00:20:58.926 --> 00:21:02.529
<c.magenta>现在默认情况下均已启用的</c>
<c.magenta>自动迁移和映射选项</c>

00:20:58.926 --> 00:21:02.529
<c.magenta>现在默认情况下均已启用的</c>
<c.magenta>自动迁移和映射选项</c>

00:21:02.930 --> 00:21:05.699
<c.magenta>以及一个新增选项</c>
<c.magenta>用于异步添加存储</c>

00:21:07.501 --> 00:21:11.104
<c.magenta>这种新类型适用于永久性</c>
<c.magenta>存储协调器上的一种新方法</c>

00:21:11.171 --> 00:21:15.242
<c.magenta>该方法采取记录圈号</c>
<c.magenta>附有用于描述存储的参数</c>

00:21:15.309 --> 00:21:18.712
<c.magenta>以及一个可选NSError</c>
<c.magenta>该NSError在操作失败时非零</c>

00:21:19.713 --> 00:21:21.248
<c.magenta>如果你异步添加存储</c>

00:21:21.315 --> 00:21:23.417
<c.magenta>你可以在回调函数中</c>
<c.magenta>扩展条件</c>

00:21:23.684 --> 00:21:27.454
<c.magenta>针对的是发布通知</c>
<c.magenta>或推送应用UI等</c>

00:21:27.521 --> 00:21:29.623
<c.magenta>时间是在成功添加存储后</c>

00:21:30.090 --> 00:21:33.760
<c.magenta>这样 你应用的模型设置</c>
<c.magenta>可以在主要线程外发生</c>

00:21:33.827 --> 00:21:36.029
<c.magenta>这在启动应用时尤其有用</c>

00:21:36.096 --> 00:21:38.031
<c.magenta>因为迁移可能导致延迟</c>

00:21:38.332 --> 00:21:41.134
<c.magenta>记住 如果iOS注意到</c>
<c.magenta>你的应用在启动后</c>

00:21:41.201 --> 00:21:43.604
<c.magenta>一段时间仍不响应</c>
<c.magenta>则iOS将关闭应用</c>

00:21:44.171 --> 00:21:46.507
<c.magenta>这可能使迁移无法完成</c>

00:21:46.573 --> 00:21:49.910
<c.magenta>但现在如果你在异步</c>
<c.magenta>添加存储 这不再是问题</c>

00:21:52.045 --> 00:21:54.515
<c.magenta>所以 那是</c>
<c.magenta>永久性存储描述 不过</c>

00:21:54.581 --> 00:21:57.050
<c.magenta>设置Core Data堆栈</c>
<c.magenta>还涉及更多的东西</c>

00:21:57.417 --> 00:21:59.987
<c.magenta>要代表Core Data堆栈</c>
<c.magenta>你至少需要三个对象</c>

00:22:00.053 --> 00:22:02.589
<c.magenta>及将它们互相联系的</c>
<c.magenta>boilerplate样板</c>

00:22:03.757 --> 00:22:06.026
<c.magenta>今年新内容中</c>
<c.magenta>Core Data有另一类型</c>

00:22:06.093 --> 00:22:07.528
<c.magenta>可以封装这些对象</c>

00:22:07.594 --> 00:22:10.564
<c.magenta>及叫做NSPersistentContainer</c>
<c.magenta>的大多boilerplate样板</c>

00:22:11.565 --> 00:22:12.399
<c.magenta>它不仅...</c>

00:22:17.538 --> 00:22:20.874
<c.magenta>我想很多人自己</c>
<c.magenta>已经写过这种类型 不过...</c>

00:22:21.808 --> 00:22:25.746
<c.magenta>这个不仅封装建模配置</c>
<c.magenta>它还有名称</c>

00:22:26.280 --> 00:22:31.251
<c.magenta>存储描述列表 以及</c>
<c.magenta>从该列表中加载</c>

00:22:31.318 --> 00:22:33.387
<c.magenta>尚未添加到协调器的</c>
<c.magenta>存储描述的方法</c>

00:22:34.121 --> 00:22:36.557
<c.magenta>这意味着设置Core Data所需</c>
<c.magenta>项目boilerplate样板</c>

00:22:36.623 --> 00:22:40.961
<c.magenta>从一整页代码</c>
<c.magenta>缩减到了仅几行代码</c>

00:22:51.872 --> 00:22:54.775
<c.magenta>所以现在少了很多代码</c>
<c.magenta>让我们看看这是如何实现的</c>

00:22:55.209 --> 00:22:57.444
<c.magenta>容器保证其属性始终有效</c>

00:22:57.511 --> 00:23:00.314
<c.magenta>所以协调器和模型等的</c>
<c.magenta>接收方</c>

00:22:57.511 --> 00:23:00.314
<c.magenta>所以协调器和模型等的</c>
<c.magenta>接收方</c>

00:23:00.380 --> 00:23:03.383
<c.magenta>能够始终返回可安全使用的</c>
<c.magenta>新对象</c>

00:23:04.084 --> 00:23:06.820
<c.magenta>容器的初始值设定项基于</c>
<c.magenta>你输入初始值设定项的</c>

00:23:06.887 --> 00:23:08.355
<c.magenta>名称找到模型</c>

00:23:09.189 --> 00:23:12.526
<c.magenta>还有另外一个初始值设定项</c>
<c.magenta>它采取明确的模型参数</c>

00:23:13.660 --> 00:23:17.631
<c.magenta>默认情况下 新容器在列表中</c>
<c.magenta>仅有一个存储描述</c>

00:23:17.698 --> 00:23:19.967
<c.magenta>它是SQLite</c>
<c.magenta>附有默认选项</c>

00:23:20.033 --> 00:23:23.170
<c.magenta>以及基于容器名称的</c>
<c.magenta>文件名称</c>

00:23:23.637 --> 00:23:25.439
<c.magenta>它存储在一个目录中</c>

00:23:25.506 --> 00:23:27.774
<c.magenta>目录由容器上的</c>
<c.magenta>类方法定义</c>

00:23:28.509 --> 00:23:30.511
<c.magenta>而默认情况下 永久性容器</c>

00:23:30.978 --> 00:23:34.348
<c.magenta>将基于你使用的平台</c>
<c.magenta>向你返回目录</c>

00:23:34.414 --> 00:23:37.117
<c.magenta>所以它会在macOS上使用</c>
<c.magenta>应用支持目录</c>

00:23:37.451 --> 00:23:40.487
<c.magenta>在iOS和launchOS上使用</c>
<c.magenta>你的容器文档结构</c>

00:23:40.554 --> 00:23:44.024
<c.magenta>以及tvOS上使用你的</c>
<c.magenta>容器缓存目录</c>

00:23:45.459 --> 00:23:47.828
<c.magenta>若你想设置自己的目录</c>
<c.magenta>那么你可在永久性容器中</c>

00:23:47.895 --> 00:23:50.230
<c.magenta>划分子类并替代直接</c>

00:23:50.297 --> 00:23:53.100
<c.magenta>不好意思 默认的</c>
<c.magenta>目录URL类方法</c>

00:23:54.401 --> 00:23:56.803
<c.magenta>容器在设置</c>
<c.magenta>Core Data时真很有用</c>

00:23:56.870 --> 00:23:59.606
<c.magenta>不过它们也</c>
<c.magenta>给一般操作带来了便利</c>

00:24:00.207 --> 00:24:02.843
<c.magenta>容器有一个主队列</c>
<c.magenta>上下文属性</c>

00:24:02.910 --> 00:24:05.712
<c.magenta>叫做查看上下文</c>
<c.magenta>你可以使用它驱动你的UI</c>

00:24:06.246 --> 00:24:09.116
<c.magenta>还有一种工厂方法</c>
<c.magenta>可以提供随时可用的</c>

00:24:09.183 --> 00:24:11.885
<c.magenta>后台上下文</c>
<c.magenta>但大多时候</c>

00:24:11.952 --> 00:24:14.154
<c.magenta>你可能要使用容器的方法</c>

00:24:14.221 --> 00:24:17.791
<c.magenta>来执行叫做performBackgroundTask的</c>
<c.magenta>后台任务</c>

00:24:19.626 --> 00:24:22.095
<c.magenta>所以你无需安装</c>
<c.magenta>新的后台上下文 进行连接</c>

00:24:22.162 --> 00:24:24.331
<c.magenta>然后排列数据块</c>
<c.magenta>以便在后台进行操作</c>

00:24:24.398 --> 00:24:26.200
<c.magenta>你只需将数据块</c>
<c.magenta>传送到容器</c>

00:24:27.167 --> 00:24:30.137
<c.magenta>使用performBackgroundTask的</c>
<c.magenta>优势远不止获得简洁的代码</c>

00:24:30.204 --> 00:24:33.106
<c.magenta>使用它可以使Core Data</c>
<c.magenta>减少为完成你作业而</c>

00:24:33.173 --> 00:24:36.643
<c.magenta>创建的上下文数目</c>
<c.magenta>同时能够与连接池一起</c>

00:24:36.710 --> 00:24:39.646
<c.magenta>确保你的应用响应快速</c>
<c.magenta>即使是在重负载的情况下</c>

00:24:41.782 --> 00:24:43.884
<c.magenta>说到一般上下文工作流</c>

00:24:44.117 --> 00:24:47.020
<c.magenta>NSManagedObjectContext</c>
<c.magenta>今年有一个新属性 叫做</c>

00:24:47.087 --> 00:24:49.189
<c.magenta>自动合并来自父级的变更</c>

00:24:49.723 --> 00:24:51.425
<c.magenta>它是布尔值</c>
<c.magenta>当你将它设置为真</c>

00:24:51.491 --> 00:24:54.795
<c.magenta>上下文会自动合并</c>
<c.magenta>保存其父级数据的更改</c>

00:24:55.262 --> 00:24:56.129
<c.magenta>这可以用于...</c>

00:25:00.534 --> 00:25:02.903
<c.magenta>这真的很便利</c>
<c.magenta>它可在父级</c>

00:25:02.970 --> 00:25:05.005
<c.magenta>保存变化时用于子上下文</c>

00:25:05.539 --> 00:25:09.710
<c.magenta>它也可以在同级保存到存储时</c>
<c.magenta>用于顶层上下文</c>

00:25:10.244 --> 00:25:12.179
<c.magenta>它尤其适用于世代标记</c>

00:25:12.246 --> 00:25:13.881
<c.magenta>这个Melissa之前介绍过</c>

00:25:14.781 --> 00:25:18.485
<c.magenta>所以如果你把UI上下文固定到</c>
<c.magenta>最近的世代</c>

00:25:18.552 --> 00:25:21.154
<c.magenta>并且启用自动合并</c>
<c.magenta>你可以不必维护你的UI</c>

00:25:21.221 --> 00:25:23.190
<c.magenta>你的fault会很安全</c>
<c.magenta>你的对象绑定</c>

00:25:23.257 --> 00:25:26.126
<c.magenta>以及提取结果控制器</c>
<c.magenta>将保持最新</c>

00:25:30.364 --> 00:25:31.398
<c.magenta>好</c>

00:25:33.967 --> 00:25:35.469
<c.magenta>让我们讨论下泛型</c>

00:25:36.136 --> 00:25:37.971
<c.magenta>Core Data今年采用了泛型</c>

00:25:38.038 --> 00:25:40.541
<c.magenta>而且它们在ObjC</c>
<c.magenta>和Swift中都很好用</c>

00:25:41.008 --> 00:25:43.911
<c.magenta>有一种新的协议叫做</c>
<c.magenta>NSFetchRequestResult</c>

00:25:44.111 --> 00:25:47.314
<c.magenta>所有你可能看到的类型</c>

00:25:47.381 --> 00:25:49.516
<c.magenta>都采用了这种新协议</c>
<c.magenta>从提取请求</c>

00:25:49.583 --> 00:25:52.853
<c.magenta>如NSManagedObject</c>
<c.magenta>或所有的实体子类</c>

00:25:53.320 --> 00:25:57.291
<c.magenta>对象ID、NSDictionary</c>
<c.magenta>以及NSNumber</c>

00:25:58.692 --> 00:26:01.995
<c.magenta>NSFetchRequest</c>
<c.magenta>现基于结果类型被参数化</c>

00:25:58.692 --> 00:26:01.995
<c.magenta>NSFetchRequest</c>
<c.magenta>现基于结果类型被参数化</c>

00:26:02.062 --> 00:26:04.998
<c.magenta>协议一致性限制结果类型</c>
<c.magenta>在Swift中</c>

00:26:05.065 --> 00:26:08.869
<c.magenta>NSManagedObjectContext上的提取</c>
<c.magenta>方法探究提取请求的类型</c>

00:26:08.936 --> 00:26:10.571
<c.magenta>一直探究到你的结果</c>

00:26:12.139 --> 00:26:13.640
<c.magenta>最后 提取结果控制器</c>

00:26:13.707 --> 00:26:16.910
<c.magenta>它采取了对创建</c>
<c.magenta>它的提取请求的参数化</c>

00:26:18.879 --> 00:26:20.547
<c.magenta>说到</c>
<c.magenta>NSFetchResultsController</c>

00:26:20.614 --> 00:26:23.817
<c.magenta>如果你正在使用UICollection</c>
<c.magenta>视图 不好意思 在这儿</c>

00:26:23.884 --> 00:26:25.385
<c.magenta>UICollection视图</c>
<c.magenta>若你使用Core Data</c>

00:26:25.452 --> 00:26:28.222
<c.magenta>采用新数据元预提取功能</c>

00:26:28.288 --> 00:26:29.656
<c.magenta>会非常简单</c>

00:26:29.723 --> 00:26:31.425
<c.magenta>你需要做的只是</c>
<c.magenta>异步提取请求</c>

00:26:31.491 --> 00:26:34.061
<c.magenta>从而从主要线程获得请求</c>
<c.magenta>而且你应该确保</c>

00:26:34.127 --> 00:26:36.129
<c.magenta>不会将对象作为fault</c>
<c.magenta>返回</c>

00:26:37.397 --> 00:26:39.199
<c.magenta>关于数据源预提取的</c>
<c.magenta>详细信息</c>

00:26:39.266 --> 00:26:41.235
<c.magenta>请查看Steve和Peter</c>
<c.magenta>昨天的分享</c>

00:26:41.301 --> 00:26:43.170
<c.magenta>UICollection视图新特点</c>

00:26:44.771 --> 00:26:47.374
<c.magenta>如果你是Mac开发者</c>
<c.magenta>我也有好消息告诉你</c>

00:26:47.441 --> 00:26:50.010
<c.magenta>现在macOS提供</c>
<c.magenta>提取结果控制器</c>

00:26:54.948 --> 00:26:58.352
<c.magenta>好 让我们讨论下</c>
<c.magenta>Core Data中的一些常见操作</c>

00:26:58.418 --> 00:27:00.687
<c.magenta>从获取实体描述开始</c>

00:26:58.418 --> 00:27:00.687
<c.magenta>从获取实体描述开始</c>

00:27:01.555 --> 00:27:03.257
<c.magenta>额 这个 好了</c>

00:27:04.858 --> 00:27:06.727
<c.magenta>为此 你需要</c>
<c.magenta>实体的字符串名称</c>

00:27:06.793 --> 00:27:08.495
<c.magenta>以及一个管理对象上下文</c>

00:27:09.463 --> 00:27:11.798
<c.magenta>创建提取请求同样</c>
<c.magenta>需要字符串常数</c>

00:27:11.865 --> 00:27:15.068
<c.magenta>以及类型转换</c>
<c.magenta>如果你想利用新的泛型</c>

00:27:15.536 --> 00:27:18.071
<c.magenta>最后是</c>
<c.magenta>创建新的管理对象</c>

00:27:18.138 --> 00:27:20.207
<c.magenta>其中三样都有 包括</c>
<c.magenta>字符串常数</c>

00:27:20.274 --> 00:27:23.310
<c.magenta>上下文参数</c>
<c.magenta>以及类型转换</c>

00:27:23.944 --> 00:27:25.879
<c.magenta>今年 这些操作都变得简单了</c>

00:27:25.946 --> 00:27:28.715
<c.magenta>因为我们改进了</c>
<c.magenta>对象子类的管理</c>

00:27:29.449 --> 00:27:32.319
<c.magenta>实体描述现在是子类上的</c>
<c.magenta>类方法</c>

00:27:39.092 --> 00:27:40.327
<c.magenta>别担心 这样更好</c>

00:27:41.328 --> 00:27:42.863
<c.magenta>这一类也有工厂方法</c>

00:27:42.930 --> 00:27:45.365
<c.magenta>可用于创建新的</c>
<c.magenta>完全键入的提取请求</c>

00:27:50.704 --> 00:27:52.739
<c.magenta>最后 你可以创建</c>
<c.magenta>新的管理对象</c>

00:27:53.407 --> 00:27:56.109
<c.magenta>只需直接使用子类的</c>
<c.magenta>初始值设定项</c>

00:28:04.384 --> 00:28:06.420
<c.magenta>还有一件事值得介绍</c>

00:28:06.486 --> 00:28:08.322
<c.magenta>那就是执行提取请求</c>

00:28:08.388 --> 00:28:11.725
<c.magenta>我之前提到过 上下文提取</c>
<c.magenta>方法在Swift经过参数化</c>

00:28:11.792 --> 00:28:14.461
<c.magenta>但ObjC不支持方法级别的泛型</c>

00:28:14.528 --> 00:28:17.831
<c.magenta>所以我们也添加了像语义</c>
<c.magenta>之类的执行者以提取请求</c>

00:28:17.998 --> 00:28:20.000
<c.magenta>所以你只需从提交</c>
<c.magenta>到上下文的数据块内</c>

00:28:20.067 --> 00:28:22.035
<c.magenta>调用执行方法</c>

00:28:22.102 --> 00:28:24.404
<c.magenta>就会返回正确键入的结果</c>

00:28:29.576 --> 00:28:32.946
<c.magenta>针对模型子类的新API</c>
<c.magenta>可以简化很多事情</c>

00:28:33.013 --> 00:28:34.748
<c.magenta>不过我猜想</c>
<c.magenta>你可能真正期待的是</c>

00:28:34.815 --> 00:28:36.850
<c.magenta>重新生成你所有的子类</c>

00:28:37.417 --> 00:28:39.219
<c.magenta>但不用担心 因为</c>

00:28:39.286 --> 00:28:41.688
<c.magenta>这应该是你需要</c>
<c.magenta>处理它们的最后一年</c>

00:28:41.955 --> 00:28:44.992
<c.magenta>因为Xcode 8现在能够</c>
<c.magenta>为你自动生成该代码</c>

00:28:49.696 --> 00:28:51.865
<c.magenta>你可以按实体配置代码世代</c>

00:28:51.932 --> 00:28:55.068
<c.magenta>Xcode会把生成的代码写入</c>
<c.magenta>你项目导出的数据</c>

00:28:55.135 --> 00:28:57.571
<c.magenta>所以不会导致未经你手的代码</c>
<c.magenta>对源树造成污染</c>

00:28:58.405 --> 00:28:59.773
<c.magenta>你无需编辑这些文件</c>

00:28:59.840 --> 00:29:01.341
<c.magenta>因为当你变更模型时</c>

00:28:59.840 --> 00:29:01.341
<c.magenta>因为当你变更模型时</c>

00:29:01.408 --> 00:29:02.342
<c.magenta>代码会自动重新生成</c>

00:29:02.409 --> 00:29:04.444
<c.magenta>但如果你想进行</c>

00:29:04.511 --> 00:29:07.281
<c.magenta>在子类中添加自己的</c>
<c.magenta>实例变量等操作</c>

00:29:07.347 --> 00:29:10.384
<c.magenta>那么你也可以告诉Xcode</c>
<c.magenta>仅生成一个类别或扩展</c>

00:29:10.450 --> 00:29:12.219
<c.magenta>然后你可以拥有类本身</c>

00:29:15.189 --> 00:29:17.658
<c.magenta>在Swift中 为使用该功能</c>
<c.magenta>你需进行的操作是</c>

00:29:17.724 --> 00:29:19.726
<c.magenta>导入你实体所属的模块</c>

00:29:19.793 --> 00:29:21.728
<c.magenta>该模块通常也是你代码</c>
<c.magenta>所属的模块</c>

00:29:22.062 --> 00:29:25.532
<c.magenta>但是在ObjC中 你还需要了解</c>
<c.magenta>一些其中的工作原理</c>

00:29:26.266 --> 00:29:31.004
<c.magenta>ObjC中最需要了解的是</c>
<c.magenta>Core Data模型标题文件</c>

00:29:31.638 --> 00:29:33.974
<c.magenta>每个模型都有自己的标题文件</c>
<c.magenta>你需要将它导入</c>

00:29:34.041 --> 00:29:36.743
<c.magenta>以便访问所有</c>
<c.magenta>该模型生成的类</c>

00:29:37.544 --> 00:29:40.047
<c.magenta>如果我们放大 看一下</c>
<c.magenta>生成的其他文件</c>

00:29:40.113 --> 00:29:42.149
<c.magenta>了解为生成类而配置的实体</c>

00:29:42.216 --> 00:29:45.018
<c.magenta>Xcode创建了两个标题</c>
<c.magenta>你在自己生成类时</c>

00:29:45.085 --> 00:29:46.520
<c.magenta>可能已看见过</c>
<c.magenta>因而可识别出</c>

00:29:46.887 --> 00:29:48.355
<c.magenta>其中一个声明类界面</c>

00:29:48.422 --> 00:29:50.724
<c.magenta>另一个声明管理属性</c>

00:29:52.025 --> 00:29:53.861
<c.magenta>在ObjC中了解这点通常很重要</c>

00:29:53.927 --> 00:29:55.829
<c.magenta>因为如果你在生成</c>
<c.magenta>一个类别</c>

00:29:55.896 --> 00:29:58.298
<c.magenta>那么Xcode不会生成</c>
<c.magenta>类界面</c>

00:29:58.799 --> 00:30:01.235
<c.magenta>模型的标题将会</c>
<c.magenta>直接导入类别</c>

00:29:58.799 --> 00:30:01.235
<c.magenta>模型的标题将会</c>
<c.magenta>直接导入类别</c>

00:30:02.302 --> 00:30:04.338
<c.magenta>没有类界面</c>
<c.magenta>就无法声明类别</c>

00:30:04.404 --> 00:30:06.773
<c.magenta>所以生成的代码的</c>
<c.magenta>预期是能够</c>

00:30:06.840 --> 00:30:09.476
<c.magenta>在以该类命名的项目中</c>
<c.magenta>找到标题</c>

00:30:09.710 --> 00:30:12.846
<c.magenta>这是你拥有的文件</c>
<c.magenta>如果它不在你的项目中</c>

00:30:12.913 --> 00:30:14.481
<c.magenta>那么你就无法构建</c>
<c.magenta>你的目标</c>

00:30:16.016 --> 00:30:18.118
<c.magenta>让我们稍稍离开幻灯片</c>
<c.magenta>看一看</c>

00:30:18.185 --> 00:30:20.187
<c.magenta>这些新东西能为你带来什么</c>

00:30:24.858 --> 00:30:26.260
<c.magenta>我打开了Xcode 8</c>

00:30:26.326 --> 00:30:28.495
<c.magenta>我们将创建新的</c>
<c.magenta>Xcode项目</c>

00:30:29.830 --> 00:30:32.399
<c.magenta>并使用iOS</c>
<c.magenta>主明细应用</c>

00:30:33.133 --> 00:30:36.203
<c.magenta>我们今年更新了模块</c>
<c.magenta>以便使用新UI</c>

00:30:36.436 --> 00:30:42.576
<c.magenta>所以 如果我们将这个保存在</c>
<c.magenta>某位置 然后转至应用代理</c>

00:30:43.177 --> 00:30:44.945
<c.magenta>接着我们会看到</c>

00:30:45.712 --> 00:30:47.948
<c.magenta>我们这里使用的是</c>
<c.magenta>永久性容器</c>

00:30:48.182 --> 00:30:52.219
<c.magenta>我们将母版视图控制器</c>

00:30:52.286 --> 00:30:54.354
<c.magenta>与容器的视图上下文连接</c>

00:30:56.123 --> 00:30:57.824
<c.magenta>如果我们切换到</c>
<c.magenta>母版视图控制器</c>

00:30:57.891 --> 00:31:00.961
<c.magenta>我们可以看到</c>
<c.magenta>在创建新对象的地方</c>

00:30:57.891 --> 00:31:00.961
<c.magenta>我们可以看到</c>
<c.magenta>在创建新对象的地方</c>

00:31:01.028 --> 00:31:05.132
<c.magenta>我们已经在使用</c>
<c.magenta>Core Data生成的子类</c>

00:31:05.599 --> 00:31:07.267
<c.magenta>初始值设定项</c>

00:31:07.534 --> 00:31:09.903
<c.magenta>我们不再使用KVC</c>

00:31:09.970 --> 00:31:12.506
<c.magenta>我们可以在管理对象上</c>
<c.magenta>直接设置属性</c>

00:31:12.573 --> 00:31:15.709
<c.magenta>如果我们命令单击</c>
<c.magenta>就会转到生成的文件</c>

00:31:19.046 --> 00:31:22.349
<c.magenta>如果我们返回 看一下如何</c>
<c.magenta>设置提取结果控制器</c>

00:31:22.916 --> 00:31:23.951
<c.magenta>好了</c>

00:31:25.752 --> 00:31:28.188
<c.magenta>我们能看到</c>
<c.magenta>在事件分类上</c>

00:31:28.255 --> 00:31:29.790
<c.magenta>引发提取请求工厂方法</c>

00:31:29.990 --> 00:31:33.927
<c.magenta>这里没有额外明确的键入</c>

00:31:33.994 --> 00:31:37.631
<c.magenta>当我们创建提取结果控制器</c>
<c.magenta>但是它的类型</c>

00:31:38.131 --> 00:31:40.200
<c.magenta>非常小</c>
<c.magenta>如果我们在这儿放大</c>

00:31:41.068 --> 00:31:42.936
<c.magenta>它的类型通过提取请求</c>
<c.magenta>传递</c>

00:31:43.937 --> 00:31:45.739
<c.magenta>这意味着 其它地方</c>

00:31:46.240 --> 00:31:48.775
<c.magenta>比如</c>
<c.magenta>prepare for segue</c>

00:31:51.578 --> 00:31:52.579
<c.magenta>好了</c>

00:31:53.847 --> 00:31:55.682
<c.magenta>当我们从提取结果控制器</c>
<c.magenta>获得对象</c>

00:31:55.749 --> 00:31:57.518
<c.magenta>会返回正确的类型</c>

00:31:58.886 --> 00:32:01.221
<c.magenta>这样 都好了</c>
<c.magenta>我们不再有任何类型转换</c>

00:31:58.886 --> 00:32:01.221
<c.magenta>这样 都好了</c>
<c.magenta>我们不再有任何类型转换</c>

00:32:03.423 --> 00:32:06.527
<c.magenta>不过 我不想让这个应用</c>
<c.magenta>像默认设置这样</c>

00:32:06.593 --> 00:32:08.729
<c.magenta>在母版视图控制器中</c>
<c.magenta>显示时间戳</c>

00:32:08.795 --> 00:32:12.733
<c.magenta>所以让我们在这里给事件</c>
<c.magenta>实体添加一个标题属性</c>

00:32:15.235 --> 00:32:18.205
<c.magenta>我们希望它是字符串类型</c>

00:32:20.541 --> 00:32:22.943
<c.magenta>好了 我们重建并保存了模型</c>

00:32:23.010 --> 00:32:25.979
<c.magenta>如果我们返回到这儿</c>
<c.magenta>转至配置单元格</c>

00:32:28.315 --> 00:32:29.750
<c.magenta>我们可在这里删除相应代码</c>

00:32:31.552 --> 00:32:33.453
<c.magenta>使用Xcode的</c>
<c.magenta>自动完成功能</c>

00:32:33.520 --> 00:32:36.290
<c.magenta>获取我们刚刚在模型中</c>
<c.magenta>设置的新属性</c>

00:32:43.063 --> 00:32:44.998
<c.magenta>同样 如果我们命令单击它</c>

00:32:45.065 --> 00:32:46.567
<c.magenta>将更新所有的代码</c>

00:32:52.639 --> 00:32:54.641
<c.magenta>这其中最大一个隐性的好处是</c>

00:32:54.708 --> 00:32:56.777
<c.magenta>如果你使用手动生成的子类</c>

00:32:56.844 --> 00:33:00.080
<c.magenta>甚至KVC 如果你更改</c>
<c.magenta>属性的名称</c>

00:32:56.844 --> 00:33:00.080
<c.magenta>甚至KVC 如果你更改</c>
<c.magenta>属性的名称</c>

00:33:00.247 --> 00:33:01.882
<c.magenta>你最后可能遇到非常奇怪的故障</c>

00:33:01.949 --> 00:33:03.617
<c.magenta>因为你的项目会编译</c>

00:33:03.684 --> 00:33:08.789
<c.magenta>但如果实际调用时</c>
<c.magenta>你会遇到运行时错误</c>

00:33:08.856 --> 00:33:10.924
<c.magenta>因为注册表项路径</c>
<c.magenta>不再存在</c>

00:33:11.458 --> 00:33:14.127
<c.magenta>子类生成自动处理所有这些</c>

00:33:17.197 --> 00:33:18.732
<c.magenta>这就是自动分类生成</c>

00:33:18.799 --> 00:33:21.835
<c.magenta>以及Core Data新API的</c>
<c.magenta>一些工作实例</c>

00:33:24.872 --> 00:33:27.407
<c.magenta>最后 让我们介绍下</c>
<c.magenta>SQLite的新特性</c>

00:33:28.742 --> 00:33:31.011
<c.magenta>操作系统附带的</c>
<c.magenta>SQLite库</c>

00:33:31.078 --> 00:33:33.347
<c.magenta>有一些你在其它地方</c>
<c.magenta>找不到的新功能</c>

00:33:33.413 --> 00:33:35.949
<c.magenta>首先是多线程声明</c>

00:33:37.317 --> 00:33:40.587
<c.magenta>Apple平台上的SQLite</c>
<c.magenta>没有线程安全连接</c>

00:33:40.654 --> 00:33:43.056
<c.magenta>多线程故障很难诊断</c>

00:33:43.123 --> 00:33:45.926
<c.magenta>有时是因为它们</c>
<c.magenta>通常显示为崩溃报告</c>

00:33:45.993 --> 00:33:48.495
<c.magenta>SQLite深处只有一个线程</c>

00:33:49.463 --> 00:33:51.698
<c.magenta>为使这些问题更容易被</c>
<c.magenta>识别和重现</c>

00:33:51.765 --> 00:33:54.067
<c.magenta>系统SQLite支持新的</c>
<c.magenta>环境变量</c>

00:33:54.134 --> 00:33:56.103
<c.magenta>该变量可以启用</c>
<c.magenta>多线程声明</c>

00:33:56.170 --> 00:33:59.139
<c.magenta>当它们启用时</c>
<c.magenta>你将在SQLite中看到两个线程</c>

00:33:59.206 --> 00:34:01.375
<c.magenta>两个线程均使用同一连接</c>

00:33:59.206 --> 00:34:01.375
<c.magenta>两个线程均使用同一连接</c>

00:34:03.911 --> 00:34:06.446
<c.magenta>SQLite始终通过可使用</c>
<c.magenta>SQLite3 config进行配置</c>

00:34:06.513 --> 00:34:09.882
<c.magenta>支持用户定义的记录功能</c>

00:34:09.949 --> 00:34:12.985
<c.magenta>但是应在库初始化之前</c>
<c.magenta>调用该功能</c>

00:34:13.053 --> 00:34:14.688
<c.magenta>而库初始化可能已经发生</c>

00:34:15.422 --> 00:34:17.157
<c.magenta>SQLite的可配置性很棒</c>

00:34:17.224 --> 00:34:20.194
<c.magenta>不过我们在运行建模系统</c>
<c.magenta>该系统有内置记录设施</c>

00:34:20.260 --> 00:34:22.429
<c.magenta>所以现在有另一个环境变量</c>

00:34:22.496 --> 00:34:25.032
<c.magenta>将SQLite记录送到系统日志</c>

00:34:27.266 --> 00:34:30.938
<c.magenta>最后 我要介绍下文件操作</c>

00:34:32.072 --> 00:34:34.741
<c.magenta>所有的数据库</c>
<c.magenta>由一组文件表示</c>

00:34:34.808 --> 00:34:37.444
<c.magenta>当文件操作在多个文件中</c>
<c.magenta>进行时</c>

00:34:37.511 --> 00:34:39.045
<c.magenta>文件操作不可能是原子的</c>

00:34:39.112 --> 00:34:41.014
<c.magenta>这样的结果是</c>
<c.magenta>所有的文件操作</c>

00:34:41.081 --> 00:34:42.449
<c.magenta>本身都是不安全的</c>

00:34:42.850 --> 00:34:45.953
<c.magenta>从Unix文件API</c>
<c.magenta>到NSFileManager 所有的</c>

00:34:46.587 --> 00:34:47.688
<c.magenta>这一点确实很重要</c>

00:34:47.754 --> 00:34:49.889
<c.magenta>我想分享几个实际的例子</c>

00:34:49.956 --> 00:34:51.024
<c.magenta>表明问题如何产生</c>

00:34:52.458 --> 00:34:55.362
<c.magenta>比如 我发现目录中</c>
<c.magenta>有两个数据库文件</c>

00:34:56.263 --> 00:34:58.465
<c.magenta>我的代码要进行清理</c>
<c.magenta>所以删除了两个文件</c>

00:34:58.532 --> 00:35:00.000
<c.magenta>在删除数据库时</c>

00:35:00.067 --> 00:35:02.236
<c.magenta>日志之类的东西</c>
<c.magenta>连接到数据库文件</c>

00:35:03.170 --> 00:35:05.405
<c.magenta>该数据库无法访问日志</c>

00:35:05.539 --> 00:35:07.474
<c.magenta>所以系统无法识别数据库</c>

00:35:07.541 --> 00:35:09.409
<c.magenta>就立即报告错误</c>

00:35:09.476 --> 00:35:10.978
<c.magenta>因此影响你的应用</c>

00:35:11.745 --> 00:35:13.914
<c.magenta>除非你能保证</c>
<c.magenta>目前没有任何东西</c>

00:35:13.981 --> 00:35:16.083
<c.magenta>将来也不会有任何东西试图</c>
<c.magenta>连接到数据库</c>

00:35:16.149 --> 00:35:18.018
<c.magenta>否则删除文件都是不安全的</c>

00:35:19.887 --> 00:35:21.588
<c.magenta>比如 我有wall模式的数据库</c>

00:35:21.655 --> 00:35:23.357
<c.magenta>该数据库正在使用中</c>

00:35:23.757 --> 00:35:26.426
<c.magenta>由于某种原因 数据库最终</c>
<c.magenta>被移开</c>

00:35:27.661 --> 00:35:29.496
<c.magenta>当数据库在新位置打开时</c>

00:35:29.563 --> 00:35:31.899
<c.magenta>相应的连接创建了</c>
<c.magenta>新的日志和锁定文件</c>

00:35:32.266 --> 00:35:33.200
<c.magenta>现在你就有两个连接</c>

00:35:33.267 --> 00:35:34.902
<c.magenta>分别使用不同日志和锁定</c>

00:35:34.968 --> 00:35:37.571
<c.magenta>不久 它们就会损坏数据库</c>

00:35:40.073 --> 00:35:42.042
<c.magenta>这些例子可能有些</c>
<c.magenta>牵强不常见</c>

00:35:42.109 --> 00:35:44.011
<c.magenta>但是总共有超过十亿的设备</c>

00:35:44.077 --> 00:35:45.279
<c.magenta>可能发生问题</c>

00:35:45.345 --> 00:35:47.781
<c.magenta>对每个可能文件的</c>
<c.magenta>每个可能的操作</c>

00:35:47.848 --> 00:35:49.583
<c.magenta>都可能导致使用你应用的</c>
<c.magenta>用户遇到问题</c>

00:35:49.650 --> 00:35:52.319
<c.magenta>如果用户数据丢失 就会很慌乱</c>

00:35:53.787 --> 00:35:55.489
<c.magenta>硬链接非常不好</c>

00:35:55.556 --> 00:35:57.424
<c.magenta>不要对数据库文件</c>
<c.magenta>使用硬链接</c>

00:35:59.126 --> 00:36:02.996
<c.magenta>所以 今年的新内容是</c>
<c.magenta>操作系统附带的SQLite库</c>

00:35:59.126 --> 00:36:02.996
<c.magenta>所以 今年的新内容是</c>
<c.magenta>操作系统附带的SQLite库</c>

00:36:03.063 --> 00:36:05.199
<c.magenta>充分利用分派源</c>

00:36:05.399 --> 00:36:07.501
<c.magenta>如果非法操作</c>
<c.magenta>对文件产生影响</c>

00:36:07.568 --> 00:36:10.204
<c.magenta>数据库连接会报告错误</c>

00:36:10.771 --> 00:36:13.240
<c.magenta>系统自身解决</c>
<c.magenta>数据损坏问题</c>

00:36:13.307 --> 00:36:15.609
<c.magenta>大多情况下 损坏已经发生</c>

00:36:15.876 --> 00:36:18.412
<c.magenta>所以为帮助你识别</c>
<c.magenta>并纠正这些问题</c>

00:36:18.478 --> 00:36:22.516
<c.magenta>我们添加了另一个环境变量</c>
<c.magenta>该变量可以使连接</c>

00:36:22.583 --> 00:36:25.452
<c.magenta>在发现非法操作影响其文件时</c>
<c.magenta>立即作出声明</c>

00:36:26.653 --> 00:36:27.754
<c.magenta>如果你想知道</c>

00:36:27.821 --> 00:36:29.056
<c.magenta>数据库损坏的更多原因</c>

00:36:29.122 --> 00:36:31.425
<c.magenta>SQLite在网站上有指导手册</c>

00:36:31.491 --> 00:36:34.228
<c.magenta>名称是“如何损坏</c>
<c.magenta>SQLite数据库文件”</c>

00:36:39.867 --> 00:36:41.668
<c.magenta>幸运地是 这些问题是</c>
<c.magenta>可以避免的</c>

00:36:42.302 --> 00:36:44.204
<c.magenta>如果你直接使用SQLite</c>
<c.magenta>你应确保</c>

00:36:44.271 --> 00:36:46.807
<c.magenta>只有一段代码拥有该数据库</c>

00:36:46.874 --> 00:36:49.376
<c.magenta>该段代码应进入</c>
<c.magenta>专门的文件访问</c>

00:36:49.443 --> 00:36:51.278
<c.magenta>所以文件在打开时无法被修改</c>

00:36:52.212 --> 00:36:54.181
<c.magenta>若你正使用Core Data</c>
<c.magenta>你应该是在用</c>

00:36:54.248 --> 00:36:56.216
<c.magenta>永久性存储协调器内</c>
<c.magenta>有一个API</c>

00:36:56.283 --> 00:36:58.318
<c.magenta>可以始终安全地用于</c>
<c.magenta>SQLite数据库</c>

00:36:58.385 --> 00:36:59.686
<c.magenta>无论是数据库打开与否</c>

00:36:59.853 --> 00:37:02.789
<c.magenta>replacePersistentStore</c>
<c.magenta>可将一个数据库更换为</c>

00:36:59.853 --> 00:37:02.789
<c.magenta>replacePersistentStore</c>
<c.magenta>可将一个数据库更换为</c>

00:37:02.856 --> 00:37:04.024
<c.magenta>另一个数据库的内容</c>

00:37:04.258 --> 00:37:05.826
<c.magenta>而destroyPersistentStore</c>

00:37:05.893 --> 00:37:07.928
<c.magenta>可以安全删除数据库中</c>
<c.magenta>所有内容</c>

00:37:07.995 --> 00:37:09.663
<c.magenta>并留下空白的数据库</c>

00:37:12.866 --> 00:37:16.103
<c.magenta>好 上述就是今年</c>
<c.magenta>Core Data的新特性</c>

00:37:16.170 --> 00:37:18.739
<c.magenta>简要回顾下 我们新增了一项</c>
<c.magenta>叫做查询生成的功能</c>

00:37:18.805 --> 00:37:21.942
<c.magenta>这种功能可以使你</c>
<c.magenta>即刻看到数据的稳定视图</c>

00:37:23.076 --> 00:37:25.646
<c.magenta>我们现在使用支持连接池</c>
<c.magenta>以及永久性存储协调器</c>

00:37:25.712 --> 00:37:27.781
<c.magenta>这样可以同时允许多个读取器</c>

00:37:27.848 --> 00:37:30.551
<c.magenta>作为单个编写器</c>
<c.magenta>使你在进行大量数据操作的同时</c>

00:37:30.617 --> 00:37:32.486
<c.magenta>能够保持漂亮的界面</c>

00:37:33.820 --> 00:37:35.656
<c.magenta>Core Data设置更简单了</c>

00:37:35.722 --> 00:37:38.025
<c.magenta>新API也使Core Data</c>
<c.magenta>使用更简单</c>

00:37:38.091 --> 00:37:39.860
<c.magenta>它在Swift中尤其好用</c>

00:37:40.327 --> 00:37:43.330
<c.magenta>这得到Xcode全新集成的</c>
<c.magenta>全面支持</c>

00:37:43.397 --> 00:37:46.166
<c.magenta>我们在SQLite中</c>
<c.magenta>也有新功能</c>

00:37:46.333 --> 00:37:49.069
<c.magenta>可以使一般问题的</c>
<c.magenta>调试更简单</c>

00:37:52.472 --> 00:37:53.340
<c.magenta>要了解更多信息</c>

00:37:53.407 --> 00:37:56.810
<c.magenta>请查看我们的开发者网站</c>
<c.magenta>是在演讲242</c>

00:37:57.878 --> 00:38:00.247
<c.magenta>如果你想了解更多</c>
<c.magenta>可以参考Swift新特性</c>

00:37:57.878 --> 00:38:00.247
<c.magenta>如果你想了解更多</c>
<c.magenta>可以参考Swift新特性</c>

00:38:00.314 --> 00:38:01.982
<c.magenta>以及Cocoa的新特性</c>

00:38:02.482 --> 00:38:03.417
<c.magenta>感谢大家的到来</c>
