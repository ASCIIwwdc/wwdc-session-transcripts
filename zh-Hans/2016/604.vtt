WEBVTT

00:00:19.720 --> 00:00:22.990
<c.magenta>Metal的新特性 第一部分</c>

00:00:24.558 --> 00:00:25.692
<c.magenta>各位早上好</c>

00:00:26.727 --> 00:00:27.628
<c.magenta>谢谢</c>

00:00:30.497 --> 00:00:32.266
<c.magenta>我叫Aaftab Munshi</c>

00:00:32.698 --> 00:00:34.601
<c.magenta>我和我的同事十分激动地</c>

00:00:34.668 --> 00:00:36.770
<c.magenta>与大家分享Metal的新特性</c>

00:00:36.870 --> 00:00:39.039
<c.magenta>macOS Sierra</c>
<c.magenta>和iOS 10中</c>

00:00:39.273 --> 00:00:44.311
<c.magenta>不过开始我先着重说说</c>
<c.magenta>今年我们关于Metal的演讲</c>

00:00:44.378 --> 00:00:45.379
<c.magenta>在 WWDC</c>

00:00:45.445 --> 00:00:49.383
<c.magenta>昨天我们有两场演讲</c>
<c.magenta>谈论了将Metal采用到</c>

00:00:49.449 --> 00:00:50.817
<c.magenta>你的应用程序中</c>

00:00:51.084 --> 00:00:53.253
<c.magenta>今天我们有三场演讲</c>

00:00:53.320 --> 00:00:58.458
<c.magenta>所以这一场 外加两场演讲</c>
<c.magenta>覆盖了Metal的新特性</c>

00:00:58.525 --> 00:01:01.628
<c.magenta>之后还有另一场演讲</c>
<c.magenta>其中我们会讲</c>

00:00:58.525 --> 00:01:01.628
<c.magenta>之后还有另一场演讲</c>
<c.magenta>其中我们会讲</c>

00:01:01.695 --> 00:01:03.130
<c.magenta>Metal着色器优化</c>

00:01:04.364 --> 00:01:06.466
<c.magenta>那么我们...</c>

00:01:08.335 --> 00:01:10.504
<c.magenta>看看我们将要讲的功能</c>

00:01:10.571 --> 00:01:14.074
<c.magenta>在第二场演讲中</c>
<c.magenta>我们要谈的功能是</c>

00:01:14.141 --> 00:01:18.612
<c.magenta>函数或着色器特殊化</c>
<c.magenta>以及写入资源的能力</c>

00:01:18.679 --> 00:01:22.583
<c.magenta>例如来自片段和顶点</c>
<c.magenta>着色器的缓冲和纹理</c>

00:01:23.016 --> 00:01:27.187
<c.magenta>广色域 在你的应用程序中</c>
<c.magenta>使用广色域显示 以及纹理资源</c>

00:01:27.254 --> 00:01:30.691
<c.magenta>还有在Metal性能着色器上</c>
<c.magenta>添加的一些新内容</c>

00:01:30.757 --> 00:01:34.928
<c.magenta>具体是通过Metal在GPU上</c>
<c.magenta>使用辅助卷积神经网络</c>

00:01:35.195 --> 00:01:36.230
<c.magenta>本次演讲中</c>

00:01:37.264 --> 00:01:38.732
<c.magenta>我们将谈谈</c>

00:01:39.066 --> 00:01:41.735
<c.magenta>我们在工具上</c>
<c.magenta>加入的一些改进</c>

00:01:41.802 --> 00:01:43.670
<c.magenta>我们认为大家一定会喜欢的</c>

00:01:43.937 --> 00:01:48.075
<c.magenta>我们也让资源堆</c>
<c.magenta>和资源分配更加快速</c>

00:01:48.175 --> 00:01:49.343
<c.magenta>给你更多的控制</c>

00:01:49.409 --> 00:01:52.446
<c.magenta>我们将谈谈那个资源堆</c>
<c.magenta>和无记忆渲染目标</c>

00:01:52.613 --> 00:01:54.648
<c.magenta>然后我将谈谈曲面细分</c>

00:01:54.982 --> 00:01:56.016
<c.magenta>所以开始吧</c>

00:01:56.650 --> 00:01:58.085
<c.magenta>好了 首先</c>

00:01:58.385 --> 00:02:01.989
<c.magenta>我们花一点时间去理解</c>

00:01:58.385 --> 00:02:01.989
<c.magenta>我们花一点时间去理解</c>

00:02:02.122 --> 00:02:04.057
<c.magenta>为什么需要</c>
<c.magenta>曲面细分</c>

00:02:04.224 --> 00:02:07.861
<c.magenta>我们看到应用程序</c>
<c.magenta>例如游戏</c>

00:02:08.095 --> 00:02:10.531
<c.magenta>渲染越来越多的</c>
<c.magenta>逼真视觉内容</c>

00:02:10.597 --> 00:02:13.033
<c.magenta>所以这意味着</c>
<c.magenta>为了渲染那么多内容</c>

00:02:13.100 --> 00:02:16.737
<c.magenta>我们需要能将精细的</c>
<c.magenta>几何图形发送给GPU</c>

00:02:16.837 --> 00:02:18.572
<c.magenta>我们要将输入发送过去</c>

00:02:19.039 --> 00:02:22.910
<c.magenta>这意味着需要处理</c>
<c.magenta>非常多的三角形</c>

00:02:23.143 --> 00:02:25.345
<c.magenta>这会极大增加存储带宽</c>

00:02:25.412 --> 00:02:27.080
<c.magenta>一件非常好的事是</c>

00:02:27.514 --> 00:02:31.084
<c.magenta>如果我们能将</c>
<c.magenta>这个发送给GPU的</c>

00:02:31.151 --> 00:02:33.921
<c.magenta>几何图形只描述成</c>
<c.magenta>一个低分辨率的模型</c>

00:02:33.987 --> 00:02:35.489
<c.magenta>名为Core Smash</c>

00:02:35.556 --> 00:02:39.726
<c.magenta>然后让GPU生成</c>
<c.magenta>高分辨率的模型</c>

00:02:39.793 --> 00:02:43.130
<c.magenta>事实上 这就是</c>
<c.magenta>曲面细分的功能</c>

00:02:43.463 --> 00:02:46.800
<c.magenta>曲面细分这种技术</c>
<c.magenta>你可以用它来放大并细化</c>

00:02:46.867 --> 00:02:48.836
<c.magenta>几何对象的细节</c>

00:02:49.002 --> 00:02:51.672
<c.magenta>我们必须要符合</c>
<c.magenta>两个重要的要求</c>

00:02:51.972 --> 00:02:55.175
<c.magenta>第一个是</c>
<c.magenta>那个生成的高分辨率</c>

00:02:55.242 --> 00:02:59.213
<c.magenta>三角形模型</c>
<c.magenta>不能存储在显存中</c>

00:02:59.279 --> 00:03:01.081
<c.magenta>我们不想占用带宽</c>

00:02:59.279 --> 00:03:01.081
<c.magenta>我们不想占用带宽</c>

00:03:01.148 --> 00:03:04.585
<c.magenta>第二 所使用的方法</c>
<c.magenta>需要是可编程的</c>

00:03:04.651 --> 00:03:06.987
<c.magenta>所以我们来看一个例子</c>

00:03:07.054 --> 00:03:10.724
<c.magenta>这是GFXBench 4.0的截图</c>

00:03:10.891 --> 00:03:13.060
<c.magenta>是一款由Kishonti</c>
<c.magenta>发布的测试程序</c>

00:03:13.126 --> 00:03:15.696
<c.magenta>其注重的一个关键功能</c>
<c.magenta>就是曲面细分</c>

00:03:15.796 --> 00:03:19.666
<c.magenta>这张截图是没有使用</c>
<c.magenta>曲面细分而渲染出的汽车</c>

00:03:19.766 --> 00:03:21.235
<c.magenta>你看看那些轮圈</c>

00:03:21.602 --> 00:03:23.470
<c.magenta>多边形很明显</c>
<c.magenta>你不会开种车的</c>

00:03:23.537 --> 00:03:24.538
<c.magenta>对吧？</c>

00:03:24.938 --> 00:03:27.975
<c.magenta>就连车身板件上都有裂纹</c>

00:03:28.041 --> 00:03:33.213
<c.magenta>因为这就是实际</c>
<c.magenta>发送过去的几何图形</c>

00:03:33.280 --> 00:03:35.516
<c.magenta>你能看到 没有很多三角形</c>

00:03:36.450 --> 00:03:38.418
<c.magenta>这很好</c>
<c.magenta>--正是我们想要的</c>

00:03:38.552 --> 00:03:41.388
<c.magenta>曲面细分的功能是</c>
<c.magenta>将那个输入的几何图形</c>

00:03:41.455 --> 00:03:42.756
<c.magenta>变成这个样子</c>

00:03:44.324 --> 00:03:45.726
<c.magenta>我认为这十分炫酷</c>

00:03:46.693 --> 00:03:51.098
<c.magenta>如果你看看线框图</c>
<c.magenta>你可以看到是GPU负责生成</c>

00:03:51.164 --> 00:03:53.934
<c.magenta>现在我们渲染出</c>
<c.magenta>非常多的三角形 是吧？</c>

00:03:54.001 --> 00:03:55.402
<c.magenta>这就是曲面细分的威力</c>

00:03:55.903 --> 00:03:59.306
<c.magenta>好了 我们来看看曲面细分</c>
<c.magenta>如何在Metal中工作的</c>

00:04:00.307 --> 00:04:03.944
<c.magenta>所以就像Metal那样</c>

00:04:04.044 --> 00:04:07.381
<c.magenta>我们想采用</c>
<c.magenta>全新的设计方法</c>

00:04:07.447 --> 00:04:09.950
<c.magenta>我们想设计出--</c>

00:04:10.117 --> 00:04:13.420
<c.magenta>即使现在有支持</c>
<c.magenta>曲面细分的API</c>

00:04:13.554 --> 00:04:14.888
<c.magenta>你可能很熟悉</c>

00:04:14.955 --> 00:04:17.925
<c.magenta>我们想要的是</c>
<c.magenta>易于表达的东西</c>

00:04:18.024 --> 00:04:19.226
<c.magenta>易于使用</c>

00:04:19.293 --> 00:04:21.995
<c.magenta>而且我们不想保留任何性能</c>

00:04:22.996 --> 00:04:25.666
<c.magenta>我们认为我们做到了</c>
<c.magenta>希望你也会认同</c>

00:04:25.732 --> 00:04:27.067
<c.magenta>在这次展示之后</c>

00:04:28.302 --> 00:04:32.005
<c.magenta>曲面细分在macOS Sierra</c>
<c.magenta>和iOS上可以使用</c>

00:04:32.072 --> 00:04:33.473
<c.magenta>搭载A9处理器</c>

00:04:33.774 --> 00:04:37.211
<c.magenta>好了 我想谈论的是</c>

00:04:37.277 --> 00:04:41.248
<c.magenta>用于曲面细分的Metal</c>
<c.magenta>图形管线是什么样的？</c>

00:04:41.548 --> 00:04:43.517
<c.magenta>如何使用曲面细分</c>
<c.magenta>渲染我的几何图形？</c>

00:04:43.617 --> 00:04:46.153
<c.magenta>以及如何将它应用到</c>
<c.magenta>我的应用程序中？</c>

00:04:46.253 --> 00:04:47.287
<c.magenta>所以开始吧</c>

00:04:48.255 --> 00:04:52.326
<c.magenta>现在 当你用Metal将</c>
<c.magenta>基元发送给GPU</c>

00:04:52.693 --> 00:04:56.029
<c.magenta>你发送的是三角形</c>
<c.magenta>线条或者是点</c>

00:04:56.163 --> 00:04:59.633
<c.magenta>有了曲面细分 你发送</c>
<c.magenta>的东西我们称其为面片</c>

00:04:59.733 --> 00:05:03.270
<c.magenta>简单来说</c>
<c.magenta>面片就是参数曲面</c>

00:04:59.733 --> 00:05:03.270
<c.magenta>简单来说</c>
<c.magenta>面片就是参数曲面</c>

00:05:03.337 --> 00:05:05.272
<c.magenta>是由样条曲线构成</c>
<c.magenta>但这意味着什么？</c>

00:05:05.339 --> 00:05:08.976
<c.magenta>你可能听过Bezier面片</c>
<c.magenta>或B样条面片之类的东西</c>

00:05:09.142 --> 00:05:12.412
<c.magenta>你通过一组控制点来描述面片</c>

00:05:12.513 --> 00:05:16.383
<c.magenta>所以这个图中</c>
<c.magenta>你看到的是B样条面片</c>

00:05:16.450 --> 00:05:20.187
<c.magenta>所以你有16个控制点</c>
<c.magenta>或者是控制顶点</c>

00:05:20.287 --> 00:05:25.158
<c.magenta>曲面细分的作用是</c>
<c.magenta>简单来说 允许你控制</c>

00:05:25.359 --> 00:05:28.762
<c.magenta>使用多少个三角形</c>
<c.magenta>来渲染这个面片</c>

00:05:28.829 --> 00:05:32.065
<c.magenta>所以你会决定</c>
<c.magenta>“我不想要很多的三角形”</c>

00:05:32.132 --> 00:05:33.600
<c.magenta>“我不在乎它什么样”</c>

00:05:33.667 --> 00:05:36.770
<c.magenta>所以你可以决定</c>
<c.magenta>四个三角形就足够了</c>

00:05:36.837 --> 00:05:38.305
<c.magenta>然后你会得到</c>
<c.magenta>多边形的外观</c>

00:05:38.505 --> 00:05:42.242
<c.magenta>或你决定 “我真的</c>
<c.magenta>想让它看起来精致又平滑”</c>

00:05:43.310 --> 00:05:46.313
<c.magenta>这会需要更多的三角形</c>
<c.magenta>不过这是由你控制</c>

00:05:48.081 --> 00:05:48.949
<c.magenta>所以我们开始</c>

00:05:49.016 --> 00:05:52.686
<c.magenta>当我们做曲面细分时</c>
<c.magenta>图形管线中的第一阶段</c>

00:05:52.753 --> 00:05:54.454
<c.magenta>我们称之为曲面细分内核</c>

00:05:54.721 --> 00:05:56.590
<c.magenta>它的作用是将面片</c>

00:05:56.657 --> 00:05:59.426
<c.magenta>我们讲了带有</c>
<c.magenta>控制点的面片 作为输入</c>

00:05:59.493 --> 00:06:03.096
<c.magenta>并决定</c>
<c.magenta>“我需要将它细分成多少？”</c>

00:05:59.493 --> 00:06:03.096
<c.magenta>并决定</c>
<c.magenta>“我需要将它细分成多少？”</c>

00:06:03.163 --> 00:06:06.200
<c.magenta>“我想让GPU生成</c>
<c.magenta>多少个三角形” 对吧？</c>

00:06:06.300 --> 00:06:10.370
<c.magenta>这种信息是在</c>
<c.magenta>曲面细分因子中捕捉到的</c>

00:06:10.437 --> 00:06:14.408
<c.magenta>我会在几个幻灯片之后</c>
<c.magenta>稍微谈谈这些因子</c>

00:06:15.042 --> 00:06:18.445
<c.magenta>你还可以生成额外面片数据</c>

00:06:18.512 --> 00:06:20.414
<c.magenta>如果在随后阶段中需要的话</c>

00:06:20.480 --> 00:06:22.282
<c.magenta>关键的是</c>
<c.magenta>这是一个可编程阶段</c>

00:06:22.349 --> 00:06:23.750
<c.magenta>意味着你要写代码</c>

00:06:24.885 --> 00:06:28.388
<c.magenta>一旦你写完了</c>
<c.magenta>生成了曲面细分因子</c>

00:06:28.455 --> 00:06:30.657
<c.magenta>下一阶段叫做镶嵌器</c>

00:06:30.858 --> 00:06:33.760
<c.magenta>这是一个固定函数阶段</c>
<c.magenta>所以没有代码可写</c>

00:06:33.827 --> 00:06:37.297
<c.magenta>不过你确实会得到</c>
<c.magenta>配置它的旋钮</c>

00:06:37.531 --> 00:06:42.569
<c.magenta>所以它使用那些曲面细分因子</c>
<c.magenta>然后将面片分解成三角形</c>

00:06:43.437 --> 00:06:46.907
<c.magenta>镶嵌器在这里的</c>
<c.magenta>关键作用是它不将</c>

00:06:46.974 --> 00:06:49.543
<c.magenta>生成的三角形列表</c>
<c.magenta>存储在显存中</c>

00:06:50.010 --> 00:06:52.713
<c.magenta>除了其生成的三角形列表之外</c>

00:06:52.779 --> 00:06:56.483
<c.magenta>对于三角形列表中的每个顶点</c>
<c.magenta>它会生成我们所称的</c>

00:06:56.550 --> 00:06:59.253
<c.magenta>参数坐标 U和V值</c>

00:06:59.319 --> 00:07:02.956
<c.magenta>它将这个和控制点一起使用</c>

00:06:59.319 --> 00:07:02.956
<c.magenta>它将这个和控制点一起使用</c>

00:07:03.624 --> 00:07:06.393
<c.magenta>来计算在表面上的实际位置</c>

00:07:06.793 --> 00:07:09.263
<c.magenta>镶嵌器会生成三角形</c>

00:07:09.329 --> 00:07:13.834
<c.magenta>今天在Metal中</c>
<c.magenta>当你想渲染基元时</c>

00:07:13.934 --> 00:07:16.136
<c.magenta>你将三角形发送给GPU</c>

00:07:16.270 --> 00:07:21.074
<c.magenta>首先会发生什么？</c>
<c.magenta>执行顶点着色器</c>

00:07:21.141 --> 00:07:23.777
<c.magenta>在这里是镶嵌器生成</c>
<c.magenta>三角形 所以...</c>

00:07:24.745 --> 00:07:28.315
<c.magenta>如果你逻辑思考一下</c>
<c.magenta>下一阶段就会是顶点着色器</c>

00:07:28.382 --> 00:07:29.416
<c.magenta>确实如此</c>

00:07:29.550 --> 00:07:32.452
<c.magenta>我们将其称为</c>
<c.magenta>后曲面细分顶点着色器</c>

00:07:32.519 --> 00:07:36.790
<c.magenta>因为它在由镶嵌器</c>
<c.magenta>生成的三角形上运行</c>

00:07:37.090 --> 00:07:41.128
<c.magenta>所以它会在</c>
<c.magenta>三角形的顶点上执行</c>

00:07:41.195 --> 00:07:42.896
<c.magenta>三角形由镶嵌器生成的</c>

00:07:42.963 --> 00:07:45.933
<c.magenta>然后会输出变换位置</c>

00:07:45.999 --> 00:07:51.171
<c.magenta>如果你熟悉DirectX</c>
<c.magenta>这个着色器所扮演的角色</c>

00:07:51.238 --> 00:07:53.473
<c.magenta>和DirectX中的域着色器相似</c>

00:07:54.975 --> 00:07:57.444
<c.magenta>好了 之后剩下的</c>
<c.magenta>管线都是一样的</c>

00:07:57.511 --> 00:08:00.080
<c.magenta>我们有光栅器和</c>
<c.magenta>片段着色器</c>

00:07:57.511 --> 00:08:00.080
<c.magenta>我们有光栅器和</c>
<c.magenta>片段着色器</c>

00:08:00.147 --> 00:08:03.717
<c.magenta>你可能会问 “所以</c>
<c.magenta>我需要写这个计算内核</c>

00:08:03.784 --> 00:08:05.586
<c.magenta>来生成曲面细分因子吗？”</c>

00:08:05.819 --> 00:08:08.388
<c.magenta>“我能使用顶点或</c>
<c.magenta>片段着色器吗？”</c>

00:08:08.722 --> 00:08:09.857
<c.magenta>你当然可以</c>

00:08:09.923 --> 00:08:14.061
<c.magenta>事实上 你根本不需要编写</c>
<c.magenta>着色器来生成这些因子</c>

00:08:14.127 --> 00:08:15.796
<c.magenta>你可能预先计算好它们了</c>

00:08:15.863 --> 00:08:18.565
<c.magenta>你就能将它们加载到缓冲中</c>
<c.magenta>然后将其传给镶嵌器</c>

00:08:18.632 --> 00:08:20.200
<c.magenta>所以你有很多控制</c>

00:08:20.300 --> 00:08:24.404
<c.magenta>不过如果你在GPU中</c>
<c.magenta>生成这些因子</c>

00:08:24.471 --> 00:08:26.273
<c.magenta>我们建议你使用计算内核</c>

00:08:26.340 --> 00:08:27.441
<c.magenta>因为你知道吗？</c>

00:08:27.508 --> 00:08:32.145
<c.magenta>这会允许我们将那个内核</c>
<c.magenta>和其他绘制指令异步运行</c>

00:08:32.412 --> 00:08:36.116
<c.magenta>所以让你提高性能</c>
<c.magenta>我认为你们会喜欢的</c>

00:08:36.850 --> 00:08:38.986
<c.magenta>让我们更进一步</c>

00:08:39.052 --> 00:08:41.087
<c.magenta>你不需要每一帧</c>
<c.magenta>都运行这个内核</c>

00:08:41.355 --> 00:08:42.489
<c.magenta>因为你知道吗？</c>

00:08:42.556 --> 00:08:44.491
<c.magenta>如果你已经计算了</c>
<c.magenta>曲面细分因子--</c>

00:08:44.558 --> 00:08:45.626
<c.magenta>假如你决定</c>

00:08:45.692 --> 00:08:49.496
<c.magenta>“离镜头更近的物体</c>
<c.magenta>会有更多的曲面细分”</c>

00:08:49.563 --> 00:08:51.865
<c.magenta>“更远的物体就没那么多”</c>

00:08:51.932 --> 00:08:55.602
<c.magenta>一旦计算完了 之后</c>
<c.magenta>根据物体的运动方式</c>

00:08:55.669 --> 00:08:58.872
<c.magenta>我可以应用一个刻度</c>
<c.magenta>然后镶嵌器会接受它</c>

00:08:59.039 --> 00:09:03.343
<c.magenta>所以管线真的十分简单</c>
<c.magenta>我们有四个阶段</c>

00:08:59.039 --> 00:09:03.343
<c.magenta>所以管线真的十分简单</c>
<c.magenta>我们有四个阶段</c>

00:09:03.410 --> 00:09:07.047
<c.magenta>我们拿它和没有</c>
<c.magenta>曲面细分的图形管线相比</c>

00:09:08.081 --> 00:09:10.384
<c.magenta>没有曲面细分的话</c>
<c.magenta>我们有三个阶段--</c>

00:09:10.450 --> 00:09:13.887
<c.magenta>顶点着色器 光栅器</c>
<c.magenta>和片段着色器阶段</c>

00:09:14.188 --> 00:09:16.757
<c.magenta>有曲面细分的话</c>
<c.magenta>我们添加了新的阶段 镶嵌器</c>

00:09:16.823 --> 00:09:19.259
<c.magenta>这是固定函数 所以</c>
<c.magenta>你不需要写任何着色器</c>

00:09:19.459 --> 00:09:22.663
<c.magenta>然后顶点着色器成为了</c>
<c.magenta>后曲面细分顶点着色器</c>

00:09:23.397 --> 00:09:26.333
<c.magenta>我们认为这很容易理解</c>

00:09:26.800 --> 00:09:28.068
<c.magenta>希望你们会认同</c>

00:09:29.203 --> 00:09:32.339
<c.magenta>好了 如何用曲面细分</c>
<c.magenta>来渲染我的几何图形？</c>

00:09:33.173 --> 00:09:34.975
<c.magenta>这里我要讲四点</c>

00:09:35.042 --> 00:09:37.110
<c.magenta>我们先看看后曲面细分</c>

00:09:37.177 --> 00:09:38.979
<c.magenta>或后曲面细分</c>
<c.magenta>顶点着色器</c>

00:09:39.046 --> 00:09:41.515
<c.magenta>这与普通的</c>
<c.magenta>顶点着色器有何不同？</c>

00:09:41.715 --> 00:09:43.617
<c.magenta>如何传递我的面片输入</c>

00:09:43.684 --> 00:09:46.220
<c.magenta>我跟你说过镶嵌器是可以配置的</c>

00:09:46.320 --> 00:09:49.256
<c.magenta>我们来看看如何配置</c>
<c.magenta>之后绘制面片</c>

00:09:50.891 --> 00:09:53.393
<c.magenta>看看这就是新的着色器</c>
<c.magenta>跟旧的着色器一样</c>

00:09:53.460 --> 00:09:56.230
<c.magenta>事实上 你声明</c>
<c.magenta>后曲面细分顶点着色器</c>

00:09:56.296 --> 00:09:57.898
<c.magenta>要使用顶点限定符</c>

00:09:57.965 --> 00:10:01.468
<c.magenta>除此之外</c>
<c.magenta>你还要指定这个属性</c>

00:09:57.965 --> 00:10:01.468
<c.magenta>除此之外</c>
<c.magenta>你还要指定这个属性</c>

00:10:01.535 --> 00:10:03.470
<c.magenta>写着</c>
<c.magenta>“这是作用于面片的”</c>

00:10:03.537 --> 00:10:06.807
<c.magenta>这里有两种面片</c>
<c.magenta>--四边形和三角形面片</c>

00:10:06.874 --> 00:10:08.542
<c.magenta>你看到它边上的数字了吗？</c>

00:10:08.709 --> 00:10:12.412
<c.magenta>那个数字就是告诉你</c>
<c.magenta>那个面片作用于多少个控制点</c>

00:10:13.013 --> 00:10:15.949
<c.magenta>如果你有普通的顶点着色器</c>
<c.magenta>你会传递</c>

00:10:16.016 --> 00:10:17.684
<c.magenta>一个顶点ID输入</c>

00:10:17.784 --> 00:10:20.187
<c.magenta>现在你将patchID</c>
<c.magenta>作为输入传递</c>

00:10:20.587 --> 00:10:24.758
<c.magenta>还记得我告诉你镶嵌器</c>
<c.magenta>生成参数UV坐标吗？</c>

00:10:24.825 --> 00:10:28.595
<c.magenta>那就这个</c>
<c.magenta>position_in_patch输入</c>

00:10:28.729 --> 00:10:31.198
<c.magenta>之后 如果你有</c>
<c.magenta>普通顶点着色器</c>

00:10:31.298 --> 00:10:33.433
<c.magenta>你要将其作为</c>
<c.magenta>stage_in传递</c>

00:10:33.500 --> 00:10:35.769
<c.magenta>我们在stage_in</c>
<c.magenta>传递的面片输入</c>

00:10:36.036 --> 00:10:37.638
<c.magenta>其他东西</c>
<c.magenta>你就进行计算</c>

00:10:37.704 --> 00:10:41.308
<c.magenta>然后就生成</c>
<c.magenta>变换的顶点输出</c>

00:10:41.575 --> 00:10:43.644
<c.magenta>这实际上会完全相同</c>

00:10:43.710 --> 00:10:48.615
<c.magenta>因为下一阶段 无论</c>
<c.magenta>有没有曲面细分 都是光栅器</c>

00:10:50.250 --> 00:10:52.152
<c.magenta>好了 我们看看面片输入</c>

00:10:52.953 --> 00:10:57.224
<c.magenta>如果你有普通顶点着色器</c>
<c.magenta>你会在着色器中将顶点输入</c>

00:10:57.291 --> 00:10:59.393
<c.magenta>描述为结构体</c>

00:10:59.459 --> 00:11:02.229
<c.magenta>如果你将数据类型</c>
<c.magenta>解耦合了 这意味着</c>

00:10:59.459 --> 00:11:02.229
<c.magenta>如果你将数据类型</c>
<c.magenta>解耦合了 这意味着</c>

00:11:02.296 --> 00:11:05.199
<c.magenta>布局和产生顶点输入的缓冲</c>

00:11:05.265 --> 00:11:08.202
<c.magenta>无法匹配着色器中的声明</c>

00:11:08.268 --> 00:11:10.838
<c.magenta>之后你要使用</c>
<c.magenta>MTLVertexDescriptor</c>

00:11:11.004 --> 00:11:12.506
<c.magenta>来描述布局</c>

00:11:12.573 --> 00:11:17.744
<c.magenta>这里有两种面片输入</c>
<c.magenta>一种是每面片输入</c>

00:11:17.811 --> 00:11:21.014
<c.magenta>还记得我告诉你的</c>
<c.magenta>这里有一个或以上的控制点吗？</c>

00:11:21.114 --> 00:11:23.717
<c.magenta>所以我们也需要</c>
<c.magenta>将它们指定为输入</c>

00:11:24.284 --> 00:11:27.588
<c.magenta>不过你指定</c>
<c.magenta>它们的方法看起来一样</c>

00:11:27.688 --> 00:11:31.325
<c.magenta>你用MTLVertexDescriptor</c>
<c.magenta>将面片输入数据的</c>

00:11:31.391 --> 00:11:33.827
<c.magenta>布局在内存中指定</c>

00:11:34.194 --> 00:11:38.599
<c.magenta>我之前展示过这个幻灯片</c>
<c.magenta>我们还将输入作为stage_in声明</c>

00:11:38.832 --> 00:11:44.271
<c.magenta>你使用属性索引在着色器中</c>
<c.magenta>将元素识别为输入</c>

00:11:44.338 --> 00:11:48.175
<c.magenta>通过MTLVertexDescriptor中</c>
<c.magenta>相应的声明</c>

00:11:49.309 --> 00:11:51.678
<c.magenta>因为会有不止一个控制点</c>

00:11:52.546 --> 00:11:55.949
<c.magenta>基本上 我们要使用</c>
<c.magenta>模板类型来对其声明</c>

00:11:56.016 --> 00:11:57.518
<c.magenta>我会在下一个幻灯片上讲的</c>

00:11:57.584 --> 00:11:59.186
<c.magenta>我们来看一个例子</c>

00:11:59.286 --> 00:12:02.289
<c.magenta>这里我有我的控制点数据</c>
<c.magenta>上面有两个元素</c>

00:11:59.286 --> 00:12:02.289
<c.magenta>这里我有我的控制点数据</c>
<c.magenta>上面有两个元素</c>

00:12:02.356 --> 00:12:04.424
<c.magenta>我使用0和1属性</c>

00:12:04.992 --> 00:12:08.095
<c.magenta>每面片数据</c>
<c.magenta>是2和3属性</c>

00:12:08.262 --> 00:12:09.730
<c.magenta>我们将这两个组合一起</c>

00:12:09.796 --> 00:12:12.900
<c.magenta>这是每个面片的面片输入</c>

00:12:13.100 --> 00:12:17.471
<c.magenta>注意那个控制模板类型</c>
<c.magenta>patch_control_point</c>

00:12:17.571 --> 00:12:19.573
<c.magenta>这就在告诉</c>
<c.magenta>Metal的着色编译器</c>

00:12:19.640 --> 00:12:22.676
<c.magenta>“这是引用控制点输入”</c>

00:12:23.177 --> 00:12:26.780
<c.magenta>还记得我告诉你的这个</c>
<c.magenta>数字16吗？数字多少无所谓</c>

00:12:26.914 --> 00:12:30.717
<c.magenta>这也在告诉Metal着色编译器</c>
<c.magenta>这里有多少个控制点</c>

00:12:30.884 --> 00:12:34.655
<c.magenta>现在我们有了为获取</c>
<c.magenta>面片输入所需的所有信息</c>

00:12:35.189 --> 00:12:37.157
<c.magenta>所以我们将它</c>
<c.magenta>作为stage_in传递</c>

00:12:37.991 --> 00:12:38.892
<c.magenta>非常简单</c>

00:12:40.861 --> 00:12:41.795
<c.magenta>我认为</c>

00:12:42.129 --> 00:12:43.030
<c.magenta>好了</c>

00:12:43.530 --> 00:12:45.532
<c.magenta>我如何配置旋钮呢？</c>

00:12:45.732 --> 00:12:46.767
<c.magenta>这里有属性</c>

00:12:46.834 --> 00:12:49.603
<c.magenta>你可以设置在</c>
<c.magenta>MTLRenderPipelineDescriptor中</c>

00:12:50.404 --> 00:12:53.640
<c.magenta>几个例子是</c>
<c.magenta>你可以告诉镶嵌器</c>

00:12:53.707 --> 00:12:56.476
<c.magenta>你想用的三角形生成方法</c>

00:12:56.543 --> 00:12:58.312
<c.magenta>叫做分区模式</c>

00:12:58.579 --> 00:13:01.849
<c.magenta>你还可以指定</c>
<c.magenta>最高曲面细分等级</c>

00:12:58.579 --> 00:13:01.849
<c.magenta>你还可以指定</c>
<c.magenta>最高曲面细分等级</c>

00:13:01.915 --> 00:13:04.685
<c.magenta>我们认为这是非常有用的</c>

00:13:04.751 --> 00:13:08.355
<c.magenta>因为这允许你控制</c>
<c.magenta>所生成的几何图形最大量</c>

00:13:08.422 --> 00:13:11.258
<c.magenta>由GPU为曲面细分物体生成</c>

00:13:12.292 --> 00:13:15.095
<c.magenta>记住镶嵌器需要读取这些因子</c>

00:13:15.162 --> 00:13:17.664
<c.magenta>所以你需要指定</c>
<c.magenta>产生它们的缓冲</c>

00:13:17.731 --> 00:13:21.268
<c.magenta>所以使用</c>
<c.magenta>setTessellationFactorBuffer API</c>

00:13:21.335 --> 00:13:22.202
<c.magenta>来完成</c>

00:13:22.269 --> 00:13:28.909
<c.magenta>这些因子会说明沿着边缘</c>
<c.magenta>将这些面片细分成什么程度</c>

00:13:28.976 --> 00:13:30.344
<c.magenta>还有在内部</c>

00:13:30.444 --> 00:13:32.079
<c.magenta>所以我们有两种面片</c>

00:13:32.145 --> 00:13:36.016
<c.magenta>如果是三角形面片</c>
<c.magenta>会有三个边和一个内部</c>

00:13:36.116 --> 00:13:39.686
<c.magenta>如果是四边形</c>
<c.magenta>那就会有四个边和两个内部</c>

00:13:39.920 --> 00:13:43.690
<c.magenta>所以你将它们指定为</c>
<c.magenta>半精度浮点值</c>

00:13:43.757 --> 00:13:44.791
<c.magenta>传递进去</c>

00:13:47.494 --> 00:13:48.629
<c.magenta>然后是绘制</c>

00:13:48.695 --> 00:13:51.765
<c.magenta>现在 当你绘制基元时</c>

00:13:51.832 --> 00:13:54.067
<c.magenta>你发送的三角形由GPU渲染</c>

00:13:54.134 --> 00:13:57.671
<c.magenta>你要么调用drawPrimitives</c>
<c.magenta>或者drawIndexPrimitives</c>

00:13:57.905 --> 00:14:01.175
<c.magenta>你指定起始顶点</c>
<c.magenta>顶点数量</c>

00:13:57.905 --> 00:14:01.175
<c.magenta>你指定起始顶点</c>
<c.magenta>顶点数量</c>

00:14:01.308 --> 00:14:05.546
<c.magenta>如果你的顶点索引不是连续的</c>
<c.magenta>你就传递一个索引缓冲</c>

00:14:05.646 --> 00:14:08.315
<c.magenta>要想绘制面片</c>
<c.magenta>你就调用drawPatches</c>

00:14:08.649 --> 00:14:09.816
<c.magenta>或者drawIndexedPatches</c>

00:14:10.184 --> 00:14:13.453
<c.magenta>你指定起始面片</c>
<c.magenta>面片数量</c>

00:14:13.620 --> 00:14:17.624
<c.magenta>如果你的控制点索引不是连续的</c>
<c.magenta>你就指定一个索引缓冲</c>

00:14:17.824 --> 00:14:19.059
<c.magenta>所以这是一对一映射</c>

00:14:19.893 --> 00:14:22.996
<c.magenta>然后这里有</c>
<c.magenta>DrawIndirect变体</c>

00:14:23.063 --> 00:14:25.866
<c.magenta>它们的功能是</c>
<c.magenta>你不指定出</c>

00:14:25.966 --> 00:14:28.135
<c.magenta>哪个是起始面片</c>
<c.magenta>以及面片数量</c>

00:14:28.202 --> 00:14:31.071
<c.magenta>以及当你进行</c>
<c.magenta>绘制调用时的其他信息</c>

00:14:31.238 --> 00:14:32.906
<c.magenta>相反 你传递一个缓冲</c>

00:14:33.373 --> 00:14:35.776
<c.magenta>这些信息会填写在其上面</c>

00:14:35.843 --> 00:14:38.645
<c.magenta>通过一个在GPU上</c>
<c.magenta>运行的指令 就像你在</c>

00:14:38.712 --> 00:14:40.013
<c.magenta>drawPrimitives</c>
<c.magenta>上做得那样</c>

00:14:40.314 --> 00:14:43.517
<c.magenta>如果你不知道如何</c>
<c.magenta>使用drawPrimitives</c>

00:14:43.884 --> 00:14:46.787
<c.magenta>drawPatches的</c>
<c.magenta>效果非常相似</c>

00:14:47.020 --> 00:14:49.489
<c.magenta>所以我们认为</c>
<c.magenta>这非常易于使用</c>

00:14:50.290 --> 00:14:51.191
<c.magenta>好了</c>

00:14:52.025 --> 00:14:52.860
<c.magenta>稍等</c>

00:14:57.464 --> 00:15:00.534
<c.magenta>我给你展示了</c>
<c.magenta>什么是Metal曲面细分</c>

00:14:57.464 --> 00:15:00.534
<c.magenta>我给你展示了</c>
<c.magenta>什么是Metal曲面细分</c>

00:15:00.601 --> 00:15:01.735
<c.magenta>以及使用方法</c>

00:15:02.669 --> 00:15:05.172
<c.magenta>在座很多人可能熟悉</c>

00:15:05.239 --> 00:15:09.443
<c.magenta>或者已经在你的应用程序中</c>
<c.magenta>使用了曲面细分 通过DirectX</c>

00:15:09.776 --> 00:15:10.844
<c.magenta>或者OpenGL</c>

00:15:10.911 --> 00:15:13.347
<c.magenta>你会注意到Metal</c>
<c.magenta>曲面细分有点不同</c>

00:15:13.514 --> 00:15:14.381
<c.magenta>别担心</c>

00:15:14.448 --> 00:15:17.484
<c.magenta>我们设计的Metal曲面细分</c>
<c.magenta>可以极其直截了当地</c>

00:15:17.551 --> 00:15:20.187
<c.magenta>将你现有的曲面细分</c>
<c.magenta>代码转移到Metal上</c>

00:15:20.287 --> 00:15:24.491
<c.magenta>例如 在过去几周里</c>
<c.magenta>我们与Unity合作</c>

00:15:24.791 --> 00:15:27.928
<c.magenta>在极短的时间里</c>
<c.magenta>他们能够</c>

00:15:27.995 --> 00:15:30.931
<c.magenta>将Metal曲面细分</c>
<c.magenta>整合到他们的引擎中</c>

00:15:31.231 --> 00:15:32.866
<c.magenta>他们是这样评价的</c>

00:15:35.602 --> 00:15:39.072
<c.magenta>我们非常激动地宣布</c>
<c.magenta>对Metal曲面细分</c>

00:15:39.139 --> 00:15:42.142
<c.magenta>Metal Compute和在Unity中</c>
<c.magenta>编写原生Metal着色器的功能支持</c>

00:15:42.209 --> 00:15:45.512
<c.magenta>将于今年晚些时候推出</c>
<c.magenta>这十分令人激动</c>

00:15:46.513 --> 00:15:50.517
<c.magenta>而且我们也与Epic合作</c>
<c.magenta>来有效地将</c>

00:15:50.584 --> 00:15:52.853
<c.magenta>Metal曲面细分整合到</c>
<c.magenta>Unreal Engine 4中</c>

00:15:53.820 --> 00:15:58.358
<c.magenta>而且Epic计划将于今年</c>
<c.magenta>晚些时候发布对UE4的支持</c>

00:16:00.093 --> 00:16:04.331
<c.magenta>所以我们有UE4 我们有</c>
<c.magenta>Unity支持Metal曲面细分</c>

00:16:05.299 --> 00:16:11.171
<c.magenta>让我给你展示曲面细分在</c>
<c.magenta>这些游戏引擎中的实际效果</c>

00:16:11.238 --> 00:16:14.741
<c.magenta>通过演示</c>
<c.magenta>两种常用的渲染技术</c>

00:16:14.842 --> 00:16:18.679
<c.magenta>叫做适配曲面细分</c>
<c.magenta>和置换贴图</c>

00:16:19.813 --> 00:16:20.814
<c.magenta>好了</c>

00:16:25.719 --> 00:16:29.489
<c.magenta>我们有一个简单的演示...</c>

00:16:31.291 --> 00:16:33.760
<c.magenta>由几位Apple工程师开发的</c>

00:16:33.827 --> 00:16:35.062
<c.magenta>使用Unreal Engine 4</c>

00:16:35.128 --> 00:16:39.066
<c.magenta>我们已经关上曲面细分</c>
<c.magenta>然后看看线框图模式</c>

00:16:39.166 --> 00:16:42.769
<c.magenta>你能看到没有很多的</c>
<c.magenta>三角形发送给GPU</c>

00:16:42.836 --> 00:16:44.338
<c.magenta>非常好</c>
<c.magenta>这正是我们想要的</c>

00:16:44.404 --> 00:16:48.375
<c.magenta>我们要将发送给GPU的</c>
<c.magenta>几何图形量维持得越少越好</c>

00:16:48.509 --> 00:16:51.245
<c.magenta>我们启用曲面细分</c>
<c.magenta>看看会发生什么</c>

00:16:52.179 --> 00:16:55.649
<c.magenta>你能看到现在GPU</c>
<c.magenta>生成了非常多的三角形</c>

00:16:56.083 --> 00:16:59.987
<c.magenta>适配曲面细分这种技术</c>
<c.magenta>允许你控制</c>

00:17:00.053 --> 00:17:02.022
<c.magenta>重要地方的几何细节</c>

00:17:02.089 --> 00:17:03.524
<c.magenta>在这个例子中</c>

00:17:03.624 --> 00:17:07.027
<c.magenta>我们决定离镜头更近的</c>
<c.magenta>物体需要更多的细节</c>

00:17:07.094 --> 00:17:09.061
<c.magenta>所以绘制上更多的三角形</c>

00:17:09.128 --> 00:17:11.231
<c.magenta>相反 远处的物体则不会</c>

00:17:11.298 --> 00:17:16.236
<c.magenta>蓝色的区域代表着</c>
<c.magenta>曲面细分量最少的区域</c>

00:17:16.303 --> 00:17:18.438
<c.magenta>然后红色的区域代表着</c>

00:17:18.505 --> 00:17:19.873
<c.magenta>曲面细分量最大的区域</c>

00:17:19.940 --> 00:17:22.309
<c.magenta>我可以展示</c>
<c.magenta>随着我将滑动器向右滑动</c>

00:17:22.376 --> 00:17:24.278
<c.magenta>我可以用它来增加</c>
<c.magenta>曲面细分级别</c>

00:17:24.344 --> 00:17:27.513
<c.magenta>你能看到更近的</c>
<c.magenta>物体变成了红色</c>

00:17:27.580 --> 00:17:30.284
<c.magenta>好了 我们将线框图关掉</c>

00:17:31.351 --> 00:17:34.154
<c.magenta>如果你跑动</c>
<c.magenta>随着我们通过这个洞穴</c>

00:17:34.488 --> 00:17:36.456
<c.magenta>你可以看到这里有</c>
<c.magenta>更多的细节 对吧？</c>

00:17:36.523 --> 00:17:40.294
<c.magenta>如果我将曲面细分关掉</c>
<c.magenta>所有的细节都没了 丢失了</c>

00:17:41.028 --> 00:17:44.164
<c.magenta>打开曲面细分</c>
<c.magenta>看起来非常惊艳</c>

00:17:44.264 --> 00:17:49.603
<c.magenta>所以这个例子演示了</c>
<c.magenta>如何使用曲面细分</c>

00:17:50.304 --> 00:17:53.874
<c.magenta>在我的应用程序中</c>
<c.magenta>构建丰富的视觉场景</c>

00:17:54.274 --> 00:17:58.078
<c.magenta>我想感谢那些在Epic的能人</c>
<c.magenta>他们让这一切成为现实</c>

00:17:58.712 --> 00:17:59.780
<c.magenta>所以下一个演示...</c>

00:18:02.449 --> 00:18:03.917
<c.magenta>是置换贴图...</c>

00:18:07.821 --> 00:18:09.923
<c.magenta>在Unity上运行</c>

00:18:10.123 --> 00:18:12.025
<c.magenta>这里我们渲染出一个球体</c>

00:18:12.326 --> 00:18:15.329
<c.magenta>我们看看用了多少个</c>
<c.magenta>三角形来渲染这个球体</c>

00:18:16.363 --> 00:18:17.364
<c.magenta>不多 对吧？</c>

00:18:17.431 --> 00:18:19.299
<c.magenta>大概有3000个三角形</c>

00:18:19.766 --> 00:18:22.202
<c.magenta>置换贴图指的是</c>
<c.magenta>一种技术</c>

00:18:22.269 --> 00:18:27.641
<c.magenta>允许你置换几何图形</c>
<c.magenta>来创建惊人的细节</c>

00:18:28.141 --> 00:18:33.780
<c.magenta>其做法是使用</c>
<c.magenta>一个置换贴图 是一种纹理</c>

00:18:33.847 --> 00:18:36.283
<c.magenta>所以你从纹理查找</c>
<c.magenta>从这个纹理</c>

00:18:36.350 --> 00:18:39.052
<c.magenta>之后用它将顶点位置偏移</c>

00:18:39.453 --> 00:18:41.855
<c.magenta>或者如果你想的话</c>
<c.magenta>你可以按顺序地做</c>

00:18:42.556 --> 00:18:45.726
<c.magenta>不过置换贴图需要</c>

00:18:45.792 --> 00:18:48.028
<c.magenta>你要绘制数量众多的</c>

00:18:48.095 --> 00:18:49.496
<c.magenta>非常小的三角形</c>

00:18:49.563 --> 00:18:52.366
<c.magenta>否则不会有效</c>
<c.magenta>它创建一个工件 只是裂纹</c>

00:18:52.499 --> 00:18:53.700
<c.magenta>不过这没问题的</c>

00:18:53.767 --> 00:18:55.736
<c.magenta>我们可使用曲面细分</c>
<c.magenta>它是专门做这个的</c>

00:18:55.802 --> 00:18:58.305
<c.magenta>因为我们还想要</c>
<c.magenta>将3000个三角形</c>

00:18:58.372 --> 00:19:01.441
<c.magenta>更小的三角形发送给GPU</c>
<c.magenta>然后用曲面细分来生成它</c>

00:18:58.372 --> 00:19:01.441
<c.magenta>更小的三角形发送给GPU</c>
<c.magenta>然后用曲面细分来生成它</c>

00:19:01.508 --> 00:19:03.076
<c.magenta>我们将线框图模式关掉</c>

00:19:03.143 --> 00:19:05.145
<c.magenta>我们启用置换贴图</c>

00:19:06.180 --> 00:19:09.283
<c.magenta>如你所见 现在</c>
<c.magenta>球体上的细节非常惊人</c>

00:19:09.383 --> 00:19:11.318
<c.magenta>如果我将线框图模式打开</c>

00:19:11.485 --> 00:19:16.123
<c.magenta>你可以看到我们生成了</c>
<c.magenta>非常多的三角形 而且都非常小</c>

00:19:16.290 --> 00:19:18.725
<c.magenta>实际上 我们看看这个</c>
<c.magenta>置换贴图的动画效果</c>

00:19:18.792 --> 00:19:22.963
<c.magenta>你能看到形状变化</c>
<c.magenta>我们放大来看看细节</c>

00:19:25.065 --> 00:19:26.934
<c.magenta>你可以看到自阴影的出现</c>

00:19:27.801 --> 00:19:30.504
<c.magenta>自阴影在这里出现的原因是</c>

00:19:30.571 --> 00:19:33.440
<c.magenta>因为我们在改变几何图形</c>

00:19:33.507 --> 00:19:37.177
<c.magenta>与在座很多人可能熟悉的</c>
<c.magenta>凹凸贴图技术不同</c>

00:19:37.244 --> 00:19:39.313
<c.magenta>那只是创建虚假的现实</c>

00:19:39.379 --> 00:19:42.516
<c.magenta>所以这是另一种技术</c>
<c.magenta>你可以用上曲面细分</c>

00:19:42.583 --> 00:19:46.553
<c.magenta>在所渲染的应用程序中</c>
<c.magenta>创建出惊人的细节</c>

00:19:46.620 --> 00:19:49.089
<c.magenta>还有 非常感谢Unity</c>
<c.magenta>提供这个演示</c>

00:19:50.123 --> 00:19:53.927
<c.magenta>演示</c>
<c.magenta>曲面细分实际效果</c>

00:19:58.165 --> 00:19:59.132
<c.magenta>好了 所以...</c>

00:20:05.205 --> 00:20:10.110
<c.magenta>Metal曲面细分还可以</c>
<c.magenta>用于加速数字内容创作工具</c>

00:20:10.344 --> 00:20:15.516
<c.magenta>例如 OpenSubdiv是由</c>
<c.magenta>Pixar发布的开源库</c>

00:20:15.649 --> 00:20:19.253
<c.magenta>它会实现高性能细分表面</c>

00:20:19.553 --> 00:20:20.921
<c.magenta>实际上 它集成到了多个</c>

00:20:20.988 --> 00:20:23.924
<c.magenta>第三方数字内容创作工具</c>

00:20:23.991 --> 00:20:25.826
<c.magenta>例如Autodesk的Maya</c>

00:20:26.627 --> 00:20:30.964
<c.magenta>OpenSubdiv使用曲面细分</c>
<c.magenta>来渲染这些细分表面</c>

00:20:31.231 --> 00:20:35.936
<c.magenta>Apple在OpenSubdiv中</c>
<c.magenta>加入了Metal曲面细分</c>

00:20:36.003 --> 00:20:39.573
<c.magenta>我很激动地在这里宣布</c>
<c.magenta>我们计划将这些变更</c>

00:20:39.640 --> 00:20:43.010
<c.magenta>今夏晚些时候在OpenSubdiv</c>
<c.magenta>开源项目上发布</c>

00:20:43.677 --> 00:20:45.412
<c.magenta>这是Pixar的评价</c>

00:20:46.513 --> 00:20:50.150
<c.magenta>如你所见 Pixar非常激动</c>
<c.magenta>看到在iOS和macOS中</c>

00:20:50.284 --> 00:20:54.321
<c.magenta>实现了OpenSubdiv上的</c>
<c.magenta>原生Metal</c>

00:20:55.856 --> 00:20:58.992
<c.magenta>好了 现在你可能会问</c>
<c.magenta>“那我呢？”</c>

00:20:59.092 --> 00:21:02.629
<c.magenta>“我如何将现有的曲面细分</c>
<c.magenta>代码转移到Metal中？”</c>

00:20:59.092 --> 00:21:02.629
<c.magenta>“我如何将现有的曲面细分</c>
<c.magenta>代码转移到Metal中？”</c>

00:21:02.863 --> 00:21:04.064
<c.magenta>我来展示给你看</c>

00:21:04.431 --> 00:21:08.302
<c.magenta>所以我们以DirectX为例</c>
<c.magenta>不过对OpenGL的规则也是一样的</c>

00:21:08.435 --> 00:21:12.639
<c.magenta>这是带有曲面细分的</c>
<c.magenta>DirectX图形管线</c>

00:21:12.806 --> 00:21:15.375
<c.magenta>我们有三个新的阶段--</c>
<c.magenta>其中两个是可编程的</c>

00:21:15.442 --> 00:21:17.344
<c.magenta>它们叫做外壳和域着色器</c>

00:21:17.444 --> 00:21:18.946
<c.magenta>然后我们在中间有镶嵌器</c>

00:21:19.046 --> 00:21:21.281
<c.magenta>那我如何</c>
<c.magenta>将它转移到Metal中？</c>

00:21:21.348 --> 00:21:24.785
<c.magenta>注意域着色器的位置</c>
<c.magenta>正好在镶嵌器的后面</c>

00:21:25.285 --> 00:21:28.488
<c.magenta>这让你想起其他我在</c>
<c.magenta>Metal管线中展示的着色器吗？</c>

00:21:28.856 --> 00:21:29.890
<c.magenta>“我想是吧”</c>

00:21:29.957 --> 00:21:32.826
<c.magenta>没错 后曲面细分顶点着色器</c>
<c.magenta>不过你知道吗？</c>

00:21:32.893 --> 00:21:37.497
<c.magenta>曲面细分的域着色器</c>
<c.magenta>就会成为新的顶点着色器</c>

00:21:38.332 --> 00:21:44.404
<c.magenta>就像你可很容易将HLSL或</c>
<c.magenta>GLSL顶点函数移动至Metal中</c>

00:21:44.471 --> 00:21:47.174
<c.magenta>你可以非常容易地</c>
<c.magenta>将这些域着色器移动到</c>

00:21:47.274 --> 00:21:49.776
<c.magenta>后曲面细分顶点着色器</c>

00:21:49.843 --> 00:21:52.746
<c.magenta>镶嵌器是完全相同的</c>
<c.magenta>没有改变</c>

00:21:52.880 --> 00:21:55.549
<c.magenta>所以就是这个东西</c>
<c.magenta>这两个着色器</c>

00:21:55.616 --> 00:21:56.850
<c.magenta>顶点和外壳着色器</c>

00:21:56.917 --> 00:21:58.552
<c.magenta>我们要将它们放入内核中</c>

00:21:58.685 --> 00:22:00.854
<c.magenta>那么我们看看如何去做</c>

00:21:58.685 --> 00:22:00.854
<c.magenta>那么我们看看如何去做</c>

00:22:02.189 --> 00:22:07.027
<c.magenta>我们看看一些</c>
<c.magenta>因为我们已经有了顶点着色器</c>

00:22:07.294 --> 00:22:10.797
<c.magenta>这意味着这里可能</c>
<c.magenta>有顶点描述符在运行时</c>

00:22:10.864 --> 00:22:12.866
<c.magenta>由应用程序所描述</c>

00:22:13.267 --> 00:22:17.304
<c.magenta>因为数据可能会解耦合</c>

00:22:17.437 --> 00:22:22.242
<c.magenta>这意味着我要声明stage_in</c>
<c.magenta>但我无法在内核中stage_in</c>

00:22:22.309 --> 00:22:24.244
<c.magenta>对吧？不过现在可以了</c>

00:22:24.311 --> 00:22:25.646
<c.magenta>我们添加了支持</c>

00:22:25.846 --> 00:22:29.016
<c.magenta>所以就像在顶点着色器中</c>
<c.magenta>你使用stage_in来说</c>

00:22:29.082 --> 00:22:32.452
<c.magenta>“这是我的顶点输入”</c>
<c.magenta>你可以用stage_in来说</c>

00:22:32.519 --> 00:22:34.755
<c.magenta>“这是我的每线程输入”</c>

00:22:34.821 --> 00:22:38.258
<c.magenta>而且你可以指定</c>
<c.magenta>实际数据布局</c>

00:22:38.425 --> 00:22:40.961
<c.magenta>在MTLStage</c>
<c.magenta>inputOutputDescriptor中</c>

00:22:41.028 --> 00:22:42.229
<c.magenta>表现相同</c>

00:22:42.296 --> 00:22:44.998
<c.magenta>非常相似于</c>
<c.magenta>MTLVertexDescriptor</c>

00:22:45.098 --> 00:22:48.735
<c.magenta>有一些你指定的东西</c>
<c.magenta>有一点不同</c>

00:22:48.802 --> 00:22:51.538
<c.magenta>因为这是用于计算的</c>
<c.magenta>而不是顶点的</c>

00:22:56.476 --> 00:22:58.946
<c.magenta>然后 要观察两点</c>

00:23:00.714 --> 00:23:04.551
<c.magenta>DirectX或OpenGL的</c>
<c.magenta>曲面细分顶点着色器执行于</c>

00:23:04.618 --> 00:23:06.553
<c.magenta>面片的控制点</c>

00:23:06.753 --> 00:23:10.224
<c.magenta>外壳着色器有这两个函数</c>

00:23:10.290 --> 00:23:12.526
<c.magenta>一个是在控制点上执行</c>

00:23:12.593 --> 00:23:14.394
<c.magenta>另一个是在面片上执行</c>

00:23:14.494 --> 00:23:16.997
<c.magenta>每面片外壳函数才是真正生成</c>

00:23:17.064 --> 00:23:18.465
<c.magenta>你的曲面细分因子</c>

00:23:18.632 --> 00:23:20.634
<c.magenta>那最好的做法是？</c>

00:23:20.701 --> 00:23:23.403
<c.magenta>将所有这三个函数</c>
<c.magenta>转化成Metal函数</c>

00:23:23.604 --> 00:23:26.573
<c.magenta>然后我们写一个Metal内核</c>
<c.magenta>来调用这些函数</c>

00:23:26.640 --> 00:23:28.675
<c.magenta>不过别担心</c>
<c.magenta>我们不会做函数调用</c>

00:23:28.742 --> 00:23:31.144
<c.magenta>Metal编译器</c>
<c.magenta>会将它们内联的</c>

00:23:32.246 --> 00:23:33.981
<c.magenta>我们来看看这是怎么起作用的</c>

00:23:34.047 --> 00:23:38.986
<c.magenta>基本上 每个线程会</c>
<c.magenta>调用控制点函数 用于顶点的</c>

00:23:39.052 --> 00:23:40.721
<c.magenta>和外壳的</c>

00:23:40.821 --> 00:23:44.925
<c.magenta>假设这里有16个控制点</c>
<c.magenta>所有第一个线程调用顶点</c>

00:23:44.992 --> 00:23:46.593
<c.magenta>和控制点外壳函数</c>

00:23:46.760 --> 00:23:50.163
<c.magenta>第二个也是一样</c>
<c.magenta>如此类推</c>

00:23:50.230 --> 00:23:53.634
<c.magenta>它们产生的任何间歇数据</c>
<c.magenta>如果想分享的话</c>

00:23:53.700 --> 00:23:55.169
<c.magenta>会放入线程组内存中</c>

00:23:55.235 --> 00:24:00.274
<c.magenta>就是高性能</c>
<c.magenta>极低延迟的本地内存</c>

00:23:55.235 --> 00:24:00.274
<c.magenta>就是高性能</c>
<c.magenta>极低延迟的本地内存</c>

00:24:00.340 --> 00:24:02.176
<c.magenta>我们不会去使用显存</c>

00:24:02.442 --> 00:24:06.413
<c.magenta>之后 如果有16个控制点</c>
<c.magenta>这就会有16个线程</c>

00:24:06.480 --> 00:24:07.614
<c.magenta>在上面运行</c>

00:24:07.748 --> 00:24:10.984
<c.magenta>只需其中一个执行</c>
<c.magenta>每面片外壳函数</c>

00:24:11.051 --> 00:24:14.321
<c.magenta>这意味着通常会遇到栅栏</c>
<c.magenta>之后你只会执行</c>

00:24:14.388 --> 00:24:16.657
<c.magenta>其中的一个线程</c>
<c.magenta>会执行外壳函数</c>

00:24:16.723 --> 00:24:18.058
<c.magenta>你会遇到条件性检查 会说</c>

00:24:18.125 --> 00:24:22.629
<c.magenta>“我的线程是在线程组ID0吗？</c>
<c.magenta>之后调用这个”</c>

00:24:22.829 --> 00:24:27.668
<c.magenta>这个函数会将</c>
<c.magenta>曲面细分因子输出到</c>

00:24:27.734 --> 00:24:29.002
<c.magenta>显存中</c>

00:24:29.069 --> 00:24:33.006
<c.magenta>如果你有额外想要输出</c>
<c.magenta>的面片数据 你可以做到</c>

00:24:33.173 --> 00:24:38.212
<c.magenta>如果你真的非常想输出</c>
<c.magenta>控制点数据 你可以做到</c>

00:24:38.278 --> 00:24:42.115
<c.magenta>但我们发现在大多数情况中</c>
<c.magenta>控制点数据只是通过</c>

00:24:42.216 --> 00:24:47.187
<c.magenta>是这些现有API中</c>
<c.magenta>图形管线的性质</c>

00:24:47.254 --> 00:24:48.956
<c.magenta>需要你将它们传递过去</c>

00:24:49.022 --> 00:24:51.291
<c.magenta>不过你只是让它们传递过去</c>
<c.magenta>不要写出来</c>

00:24:51.358 --> 00:24:53.861
<c.magenta>你已经在缓冲中有了</c>

00:24:54.895 --> 00:24:56.163
<c.magenta>好了 让我总结一下</c>

00:24:56.230 --> 00:25:02.503
<c.magenta>我希望给你展示了</c>
<c.magenta>MetalTessellation是很简单的</c>

00:24:56.230 --> 00:25:02.503
<c.magenta>我希望给你展示了</c>
<c.magenta>MetalTessellation是很简单的</c>

00:25:02.569 --> 00:25:03.604
<c.magenta>而且易于使用</c>

00:25:03.704 --> 00:25:07.241
<c.magenta>我们从头开始设计</c>
<c.magenta>专注性能</c>

00:25:07.641 --> 00:25:12.713
<c.magenta>我展示了将你现有的曲面细分</c>
<c.magenta>代码应用到Metal中是很简单的</c>

00:25:13.280 --> 00:25:15.115
<c.magenta>在iOS和macOS上可用</c>

00:25:15.182 --> 00:25:16.383
<c.magenta>现在轮到你们了</c>

00:25:18.352 --> 00:25:23.056
<c.magenta>展示出来 使用曲面细分</c>
<c.magenta>并创建一些惊艳的画面</c>

00:25:23.123 --> 00:25:24.958
<c.magenta>在你的应用程序中渲染</c>

00:25:26.126 --> 00:25:29.029
<c.magenta>我想感谢大家抽出宝贵时间</c>
<c.magenta>我将请上我的同事 James</c>

00:25:29.096 --> 00:25:31.164
<c.magenta>他将谈谈关于资源堆</c>

00:25:31.231 --> 00:25:33.233
<c.magenta>和无记忆渲染目标</c>
<c.magenta>谢谢大家</c>

00:25:41.008 --> 00:25:42.276
<c.magenta>好了 谢谢你 Aaftab</c>

00:25:43.443 --> 00:25:46.280
<c.magenta>本次演讲的下一部分</c>
<c.magenta>我很激动地介绍</c>

00:25:46.346 --> 00:25:50.417
<c.magenta>在iOS和tvOS上</c>
<c.magenta>可用的两项新Metal功能</c>

00:25:50.684 --> 00:25:53.554
<c.magenta>资源堆和无记忆渲染目标</c>

00:25:54.154 --> 00:25:57.457
<c.magenta>这些功能可以让你</c>
<c.magenta>控制你的资源管理</c>

00:25:57.524 --> 00:26:00.194
<c.magenta>从而实现更大的</c>
<c.magenta>CPU和内存效率</c>

00:25:57.524 --> 00:26:00.194
<c.magenta>从而实现更大的</c>
<c.magenta>CPU和内存效率</c>

00:26:00.861 --> 00:26:04.631
<c.magenta>我将首先介绍资源堆</c>
<c.magenta>之后再讲无记忆渲染目标</c>

00:26:06.133 --> 00:26:10.704
<c.magenta>资源堆是Metal中的一个</c>
<c.magenta>新的较低开销资源管理选项</c>

00:26:11.205 --> 00:26:13.607
<c.magenta>你早就可以在Metal中</c>
<c.magenta>创建缓冲和纹理了</c>

00:26:13.674 --> 00:26:15.475
<c.magenta>那为什么还要</c>
<c.magenta>另一种方式？</c>

00:26:16.076 --> 00:26:18.478
<c.magenta>在设备上通过现有Metal API</c>

00:26:18.545 --> 00:26:21.348
<c.magenta>创建资源是既容易又方便的</c>

00:26:21.415 --> 00:26:23.917
<c.magenta>而且很多开发者</c>
<c.magenta>很赞赏这种简单</c>

00:26:24.351 --> 00:26:25.385
<c.magenta>另一方面</c>

00:26:25.452 --> 00:26:29.857
<c.magenta>随着Metal应用渲染</c>
<c.magenta>越来越丰富复杂的场景</c>

00:26:29.923 --> 00:26:33.126
<c.magenta>你会寻求更完善的</c>
<c.magenta>Metal资源控制</c>

00:26:33.193 --> 00:26:35.929
<c.magenta>来解锁更大的</c>
<c.magenta>CPU和内存效率</c>

00:26:36.430 --> 00:26:38.699
<c.magenta>这就是我们推出资源堆的原因</c>

00:26:39.466 --> 00:26:43.370
<c.magenta>资源堆可以实现</c>
<c.magenta>快速的资源创建和绑定</c>

00:26:43.437 --> 00:26:45.339
<c.magenta>通过资源子分配</c>

00:26:45.772 --> 00:26:49.142
<c.magenta>资源堆的灵活性</c>
<c.magenta>会节省你的内存</c>

00:26:49.209 --> 00:26:52.412
<c.magenta>通过允许多个资源</c>
<c.magenta>在内存中取别名</c>

00:26:53.380 --> 00:26:57.417
<c.magenta>最后 资源堆的效率</c>
<c.magenta>和灵活性的实现是靠</c>

00:26:57.484 --> 00:27:01.088
<c.magenta>你控制资源依赖性跟踪</c>

00:26:57.484 --> 00:27:01.088
<c.magenta>你控制资源依赖性跟踪</c>

00:27:01.188 --> 00:27:03.223
<c.magenta>通过使用显式指令同步</c>

00:27:03.891 --> 00:27:05.526
<c.magenta>我们来深入了解这些功能</c>

00:27:05.959 --> 00:27:07.828
<c.magenta>从资源子分配开始</c>

00:27:09.196 --> 00:27:11.431
<c.magenta>在谈子分配的细节之前</c>

00:27:11.765 --> 00:27:16.170
<c.magenta>我们首先讨论为什么</c>
<c.magenta>基于设备的资源创建耗费巨大</c>

00:27:17.337 --> 00:27:18.939
<c.magenta>创建单个资源</c>

00:27:19.006 --> 00:27:21.241
<c.magenta>使用Metal设备</c>
<c.magenta>涉及多个步骤</c>

00:27:21.775 --> 00:27:24.912
<c.magenta>分配内存</c>
<c.magenta>准备内存用于GPU</c>

00:27:25.412 --> 00:27:27.181
<c.magenta>清除内存保证安全</c>

00:27:27.247 --> 00:27:29.917
<c.magenta>最后</c>
<c.magenta>创建Metal对象</c>

00:27:30.551 --> 00:27:32.920
<c.magenta>每一步都需要时间</c>
<c.magenta>而大多数时间</c>

00:27:32.986 --> 00:27:35.122
<c.magenta>都花在内存操作上</c>

00:27:36.156 --> 00:27:38.792
<c.magenta>不过也有这种情况</c>
<c.magenta>当你需要创建资源</c>

00:27:38.859 --> 00:27:42.496
<c.magenta>在性能关键的路径上</c>
<c.magenta>并且不出现性能故障</c>

00:27:43.297 --> 00:27:45.132
<c.magenta>纹理流就是一个例子</c>

00:27:45.332 --> 00:27:47.901
<c.magenta>或者也许你有</c>
<c.magenta>一个图像处理应用</c>

00:27:47.968 --> 00:27:51.405
<c.magenta>需要生产多个临时纹理</c>
<c.magenta>来执行一个滤镜</c>

00:27:53.340 --> 00:27:55.008
<c.magenta>绑定资源的成本</c>

00:27:55.209 --> 00:27:58.178
<c.magenta>对于指令编码器来说</c>
<c.magenta>也会成为性能问题</c>

00:27:58.779 --> 00:28:01.481
<c.magenta>Metal必须跟踪</c>
<c.magenta>每个绑定到指令编码器</c>

00:27:58.779 --> 00:28:01.481
<c.magenta>Metal必须跟踪</c>
<c.magenta>每个绑定到指令编码器</c>

00:28:01.548 --> 00:28:05.285
<c.magenta>的独特资源来确保</c>
<c.magenta>GPU能够访问内存</c>

00:28:05.686 --> 00:28:08.589
<c.magenta>对于复制的场景</c>
<c.magenta>这个成本也会水涨船高</c>

00:28:09.990 --> 00:28:13.594
<c.magenta>资源子分配解决了</c>
<c.magenta>这两个性能问题</c>

00:28:14.161 --> 00:28:16.797
<c.magenta>记住资源创建中</c>
<c.magenta>开销大的部分</c>

00:28:16.864 --> 00:28:18.432
<c.magenta>是在内存操作中</c>

00:28:18.966 --> 00:28:21.502
<c.magenta>有了资源堆</c>
<c.magenta>你可以提前执行</c>

00:28:21.568 --> 00:28:23.770
<c.magenta>内存操作</c>
<c.magenta>在游戏循环之外</c>

00:28:24.905 --> 00:28:27.508
<c.magenta>资源堆解决了绑定成本</c>
<c.magenta>做法是允许你</c>

00:28:27.574 --> 00:28:31.211
<c.magenta>从单个堆中对许多</c>
<c.magenta>逻辑资源进行子分配</c>

00:28:31.979 --> 00:28:34.615
<c.magenta>通过从一个堆中</c>
<c.magenta>对多个资源进行子分配</c>

00:28:34.681 --> 00:28:39.052
<c.magenta>Metal跟踪的是一个内存分配</c>
<c.magenta>而不是每个资源的内存分配</c>

00:28:39.419 --> 00:28:41.822
<c.magenta>这会显著降低</c>
<c.magenta>你的驱动过载</c>

00:28:43.457 --> 00:28:44.825
<c.magenta>我们给资源创建做对比</c>

00:28:44.892 --> 00:28:47.528
<c.magenta>在Metal设备和</c>
<c.magenta>新的Metal资源堆之间</c>

00:28:48.629 --> 00:28:50.831
<c.magenta>当你使用设备创建资源</c>

00:28:50.898 --> 00:28:53.300
<c.magenta>Metal会分配并准备</c>
<c.magenta>一个内存块</c>

00:28:53.367 --> 00:28:54.868
<c.magenta>然后创建Metal对象</c>

00:28:55.335 --> 00:28:59.239
<c.magenta>对于四个资源 Metal会</c>
<c.magenta>分配并准备四个内存块</c>

00:29:00.474 --> 00:29:01.942
<c.magenta>这与MTLHeap相比</c>

00:29:02.376 --> 00:29:04.144
<c.magenta>将MTLHeap</c>
<c.magenta>用于资源创建时</c>

00:29:04.211 --> 00:29:06.580
<c.magenta>你首先要提前创建堆对象</c>

00:29:07.614 --> 00:29:11.084
<c.magenta>内存会按请求的大小</c>
<c.magenta>分配并准备一个内存块</c>

00:29:11.385 --> 00:29:14.054
<c.magenta>如果你在渲染循环</c>
<c.magenta>之外提前做了这件事</c>

00:29:14.321 --> 00:29:17.057
<c.magenta>资源创建中</c>
<c.magenta>开销大的部分就完成了</c>

00:29:18.091 --> 00:29:20.594
<c.magenta>要从MTLHeap中</c>
<c.magenta>创建出四个资源</c>

00:29:20.928 --> 00:29:23.797
<c.magenta>Metal只需要保留</c>
<c.magenta>一块堆的内存</c>

00:29:23.864 --> 00:29:25.332
<c.magenta>然后创建资源元数据</c>

00:29:25.532 --> 00:29:26.733
<c.magenta>这会更加快速</c>

00:29:27.434 --> 00:29:30.103
<c.magenta>现在来看看当我们想释放</c>
<c.magenta>一些资源时会发生什么</c>

00:29:31.205 --> 00:29:35.008
<c.magenta>当基于设备的资源释放后</c>
<c.magenta>Metal对象就会被破坏</c>

00:29:35.242 --> 00:29:38.412
<c.magenta>不过设备也会释放</c>
<c.magenta>内存资源分配</c>

00:29:39.179 --> 00:29:41.281
<c.magenta>另一方面</c>
<c.magenta>当释放堆资源时</c>

00:29:41.548 --> 00:29:45.352
<c.magenta>只有对象被破坏</c>
<c.magenta>内存还由堆所占有</c>

00:29:45.786 --> 00:29:47.588
<c.magenta>所以在设备上创建新资源</c>

00:29:47.654 --> 00:29:50.257
<c.magenta>会引起另一次</c>
<c.magenta>高开销内存分配</c>

00:29:50.524 --> 00:29:55.362
<c.magenta>而堆可以快速将闲置内存</c>
<c.magenta>再分配给另一个资源</c>

00:29:56.763 --> 00:29:58.031
<c.magenta>我给你展示这有多容易</c>

00:29:58.098 --> 00:30:00.200
<c.magenta>用Swift对Metal资源</c>
<c.magenta>进行子分配</c>

00:29:58.098 --> 00:30:00.200
<c.magenta>用Swift对Metal资源</c>
<c.magenta>进行子分配</c>

00:30:01.869 --> 00:30:04.137
<c.magenta>所以跟很多Metal对象一样</c>

00:30:04.204 --> 00:30:07.875
<c.magenta>Metal资源堆有</c>
<c.magenta>一个相应的描述符对象</c>

00:30:08.842 --> 00:30:11.278
<c.magenta>我们创建堆描述符</c>
<c.magenta>然后将大小设置成</c>

00:30:11.345 --> 00:30:13.213
<c.magenta>支持堆的内存量</c>

00:30:14.781 --> 00:30:16.783
<c.magenta>凭借堆描述符</c>
<c.magenta>我们可以请求设备</c>

00:30:16.850 --> 00:30:18.385
<c.magenta>给我们创建一个堆对象</c>

00:30:18.652 --> 00:30:21.555
<c.magenta>记住 这个操作会比较慢</c>
<c.magenta>所以要提前做</c>

00:30:21.955 --> 00:30:24.691
<c.magenta>例如当应用启动时</c>
<c.magenta>或是内容加载时间</c>

00:30:26.059 --> 00:30:29.363
<c.magenta>有了这个创建出的堆</c>
<c.magenta>我们可以调用其资源创建方法</c>

00:30:29.530 --> 00:30:32.533
<c.magenta>这看起来非常眼熟</c>
<c.magenta>因为名称和参数</c>

00:30:32.599 --> 00:30:35.002
<c.magenta>与设备上的名称和参数相同</c>

00:30:39.439 --> 00:30:41.275
<c.magenta>在进行下一个话题之前</c>

00:30:41.341 --> 00:30:45.045
<c.magenta>我想分享一些使用资源堆</c>
<c.magenta>进行子分配的最佳做法</c>

00:30:46.113 --> 00:30:48.382
<c.magenta>最重要的一点</c>
<c.magenta>就是使用资源堆</c>

00:30:48.448 --> 00:30:51.318
<c.magenta>在性能关键的路径上创建资源</c>

00:30:51.618 --> 00:30:54.354
<c.magenta>使用设备去创建资源不是专门</c>

00:30:54.421 --> 00:30:56.623
<c.magenta>用于游戏循环的</c>
<c.magenta>资源堆是专门的</c>

00:30:58.959 --> 00:31:03.897
<c.magenta>分配大小不同的资源</c>
<c.magenta>可能会导致堆内存出现碎片</c>

00:30:58.959 --> 00:31:03.897
<c.magenta>分配大小不同的资源</c>
<c.magenta>可能会导致堆内存出现碎片</c>

00:31:04.198 --> 00:31:06.500
<c.magenta>如果资源有不同的生命周期</c>

00:31:07.167 --> 00:31:10.404
<c.magenta>所以使用多个堆</c>
<c.magenta>并按照大小将资源装好</c>

00:31:10.470 --> 00:31:12.239
<c.magenta>来限制碎片的影响</c>

00:31:14.041 --> 00:31:17.211
<c.magenta>你可以还在想</c>
<c.magenta>如何选择合适的堆大小</c>

00:31:17.644 --> 00:31:20.380
<c.magenta>Metal在Metal设备上</c>
<c.magenta>提供了两种新的方法</c>

00:31:20.747 --> 00:31:23.984
<c.magenta>来查询纹理和缓冲的大小与排列</c>

00:31:24.952 --> 00:31:27.955
<c.magenta>使用这些查询来帮助你</c>
<c.magenta>计算所需堆的大小</c>

00:31:29.323 --> 00:31:33.093
<c.magenta>好了 我们来看看资源堆的</c>
<c.magenta>下一项功能：资源别名</c>

00:31:34.194 --> 00:31:36.897
<c.magenta>资源别名允许多个动态资源</c>

00:31:37.164 --> 00:31:38.565
<c.magenta>占用相同的内存</c>

00:31:38.832 --> 00:31:41.268
<c.magenta>因此减少了资源的总体</c>

00:31:41.335 --> 00:31:42.336
<c.magenta>内存占用</c>

00:31:42.903 --> 00:31:46.540
<c.magenta>动态资源的内容</c>
<c.magenta>每一帧都是再生成的</c>

00:31:46.607 --> 00:31:50.177
<c.magenta>内容包括阴影贴图</c>
<c.magenta>G缓冲数据</c>

00:31:50.244 --> 00:31:53.780
<c.magenta>或是用于后处理的临时纹理</c>

00:31:55.182 --> 00:31:58.018
<c.magenta>我们这里有一个堆</c>
<c.magenta>包含两个非别名的资源</c>

00:31:58.585 --> 00:32:01.321
<c.magenta>与这个包含两个</c>
<c.magenta>相同资源的堆相比</c>

00:31:58.585 --> 00:32:01.321
<c.magenta>与这个包含两个</c>
<c.magenta>相同资源的堆相比</c>

00:32:01.388 --> 00:32:02.656
<c.magenta>不过现在用了别名</c>

00:32:03.023 --> 00:32:04.992
<c.magenta>你能明显看到</c>
<c.magenta>使用别名的资源</c>

00:32:05.058 --> 00:32:06.760
<c.magenta>可以放入更小的堆中</c>

00:32:10.797 --> 00:32:13.634
<c.magenta>我们将资源别名</c>
<c.magenta>应用到这个游戏帧中</c>

00:32:14.301 --> 00:32:16.570
<c.magenta>阴影贴图过程</c>
<c.magenta>会渲染一组阴影贴图</c>

00:32:16.970 --> 00:32:18.772
<c.magenta>用于场景中的每个光源</c>

00:32:19.373 --> 00:32:21.608
<c.magenta>所以在这里的堆中</c>
<c.magenta>我们有多个阴影贴图</c>

00:32:23.343 --> 00:32:25.846
<c.magenta>在主过程的碎片加工中</c>

00:32:25.979 --> 00:32:28.282
<c.magenta>着色器会采样</c>
<c.magenta>阴影贴图来判定</c>

00:32:28.348 --> 00:32:30.284
<c.magenta>是否每个对象都在阴影中</c>

00:32:31.752 --> 00:32:34.655
<c.magenta>在主过程结束后</c>
<c.magenta>阴影贴图的内容</c>

00:32:34.721 --> 00:32:35.956
<c.magenta>就会被完全消耗</c>

00:32:36.223 --> 00:32:38.425
<c.magenta>它们会在下一帧中再生成</c>

00:32:40.060 --> 00:32:42.663
<c.magenta>在主过程结束后</c>
<c.magenta>我们会执行后处理链</c>

00:32:42.729 --> 00:32:45.732
<c.magenta>这个可能包含多个</c>
<c.magenta>离屏渲染过程</c>

00:32:45.799 --> 00:32:48.569
<c.magenta>每个都执行特定的滤镜</c>
<c.magenta>像是模糊或者高光</c>

00:32:49.803 --> 00:32:52.139
<c.magenta>这些滤镜会将其内容</c>
<c.magenta>存储进纹理中</c>

00:32:52.206 --> 00:32:55.142
<c.magenta>来将滤镜结果传递给</c>
<c.magenta>链中的下一个阶段</c>

00:32:55.943 --> 00:32:58.645
<c.magenta>这里的要点是</c>
<c.magenta>阴影贴图的</c>

00:32:58.712 --> 00:33:00.714
<c.magenta>内容和后处理纹理</c>

00:32:58.712 --> 00:33:00.714
<c.magenta>内容和后处理纹理</c>

00:33:00.781 --> 00:33:02.382
<c.magenta>从来不是同时使用的</c>

00:33:02.983 --> 00:33:04.618
<c.magenta>所以为何不共享内存呢？</c>

00:33:07.087 --> 00:33:10.824
<c.magenta>我来给你展示如何用Swift</c>
<c.magenta>创建这些别名资源集</c>

00:33:11.258 --> 00:33:12.960
<c.magenta>这第一部分</c>
<c.magenta>应该看起来眼熟</c>

00:33:13.327 --> 00:33:14.962
<c.magenta>首先我们请求设备创建一个堆</c>

00:33:15.796 --> 00:33:17.664
<c.magenta>然后我们创建三个阴影贴图</c>

00:33:18.999 --> 00:33:21.802
<c.magenta>现在我们看到了一个新方法</c>
<c.magenta>makeAliasable</c>

00:33:22.469 --> 00:33:24.671
<c.magenta>通过在堆资源上</c>
<c.magenta>调用makeAliasable</c>

00:33:24.805 --> 00:33:28.342
<c.magenta>你告诉那个堆</c>
<c.magenta>将资源的内存视为闲置的</c>

00:33:29.309 --> 00:33:32.980
<c.magenta>阴影贴图仍在启用中</c>
<c.magenta>但是它们的内存可以自由</c>

00:33:33.046 --> 00:33:35.482
<c.magenta>被堆再分配给新的资源</c>

00:33:36.650 --> 00:33:39.553
<c.magenta>现在当我们在相同的堆上</c>
<c.magenta>创建后处理纹理时</c>

00:33:40.087 --> 00:33:43.023
<c.magenta>它们可以作为阴影贴图</c>
<c.magenta>占用相同的内存</c>

00:33:45.526 --> 00:33:47.794
<c.magenta>现在我们来谈谈</c>
<c.magenta>一些最佳做法</c>

00:33:47.861 --> 00:33:48.996
<c.magenta>用于资源别名</c>

00:33:50.163 --> 00:33:53.433
<c.magenta>为了实现动态资源的</c>
<c.magenta>内存再使用最大化</c>

00:33:53.834 --> 00:33:56.703
<c.magenta>调用资源创建方法</c>

00:33:56.770 --> 00:34:00.040
<c.magenta>在一个帧里</c>
<c.magenta>资源所使用的相同序列中</c>

00:33:56.770 --> 00:34:00.040
<c.magenta>在一个帧里</c>
<c.magenta>资源所使用的相同序列中</c>

00:34:00.574 --> 00:34:02.876
<c.magenta>允许你调用</c>
<c.magenta>makeAliasable</c>

00:34:03.544 --> 00:34:06.547
<c.magenta>会允许你交错</c>
<c.magenta>makeAliasable调用</c>

00:34:06.947 --> 00:34:09.216
<c.magenta>当资源内容被消耗的时候</c>

00:34:11.717 --> 00:34:15.121
<c.magenta>而且你要将动态资源和</c>
<c.magenta>静态资源保持在分隔的堆中</c>

00:34:15.822 --> 00:34:18.926
<c.magenta>静态资源一般无法进行别名</c>
<c.magenta>而且会导致</c>

00:34:18.992 --> 00:34:22.596
<c.magenta>动态资源无法互相使用别名</c>

00:34:22.663 --> 00:34:24.331
<c.magenta>由于堆的内存碎片</c>

00:34:25.866 --> 00:34:28.735
<c.magenta>接下来我将谈谈如何</c>
<c.magenta>实现堆资源的</c>

00:34:28.802 --> 00:34:30.237
<c.magenta>同步指令访问</c>

00:34:32.973 --> 00:34:36.643
<c.magenta>目前我们讨论了</c>
<c.magenta>凭借子分配实现的快速资源创建</c>

00:34:36.976 --> 00:34:39.713
<c.magenta>以及通过资源别名</c>
<c.magenta>实现的高效内存使用</c>

00:34:39.947 --> 00:34:42.482
<c.magenta>但要记住资源堆是快速灵活的</c>

00:34:42.549 --> 00:34:45.252
<c.magenta>因为你控制</c>
<c.magenta>堆资源的同步</c>

00:34:45.819 --> 00:34:48.522
<c.magenta>你在设备资源上不必这样做</c>

00:34:49.656 --> 00:34:52.226
<c.magenta>但与设备资源不同</c>
<c.magenta>Metal不知道</c>

00:34:52.292 --> 00:34:54.895
<c.magenta>指令会什么时候</c>
<c.magenta>修改堆资源的内容</c>

00:34:55.395 --> 00:34:59.032
<c.magenta>例如当渲染过程</c>
<c.magenta>将新内容存储到纹理中</c>

00:35:00.267 --> 00:35:02.503
<c.magenta>Metal也不知道</c>
<c.magenta>你何时会将堆内存的</c>

00:35:02.569 --> 00:35:05.506
<c.magenta>解释从一个别名集</c>
<c.magenta>改成另一个</c>

00:35:07.174 --> 00:35:10.944
<c.magenta>不过为了正确性 Metal需要</c>
<c.magenta>知道何时指令会更新堆资源</c>

00:35:11.011 --> 00:35:14.114
<c.magenta>这样其他指令</c>
<c.magenta>可以安全地读取结果</c>

00:35:14.915 --> 00:35:16.250
<c.magenta>这尤为重要</c>

00:35:16.316 --> 00:35:18.986
<c.magenta>因为GPU可以并行</c>
<c.magenta>执行多个指令</c>

00:35:20.654 --> 00:35:22.789
<c.magenta>为了实现堆资源的同步访问</c>

00:35:22.856 --> 00:35:25.926
<c.magenta>你的应用程序会创建</c>
<c.magenta>并管理GPU栅栏</c>

00:35:26.393 --> 00:35:29.196
<c.magenta>来在指令之间</c>
<c.magenta>沟通资源依赖性</c>

00:35:30.197 --> 00:35:32.132
<c.magenta>我们深入看看</c>
<c.magenta>GPU栅栏的工作原理</c>

00:35:33.333 --> 00:35:35.536
<c.magenta>GPU栅栏就是时间戳</c>

00:35:35.903 --> 00:35:39.506
<c.magenta>是GPU执行时间轴上的</c>
<c.magenta>一个参考点</c>

00:35:40.240 --> 00:35:43.310
<c.magenta>你可以用栅栏</c>
<c.magenta>编码两种行动来同步指令</c>

00:35:43.810 --> 00:35:47.214
<c.magenta>指令可以更新栅栏</c>
<c.magenta>将时间戳向前移</c>

00:35:47.281 --> 00:35:48.649
<c.magenta>当指令完成后</c>

00:35:49.483 --> 00:35:51.351
<c.magenta>而且指令可以等待栅栏</c>

00:35:51.552 --> 00:35:55.255
<c.magenta>在执行之前 等到</c>
<c.magenta>GPU触及最新的栅栏更新</c>

00:35:56.623 --> 00:35:58.759
<c.magenta>那我们回来看看</c>
<c.magenta>之前的游戏帧</c>

00:35:58.926 --> 00:36:00.561
<c.magenta>我会展示给你</c>
<c.magenta>如何使用栅栏</c>

00:35:58.926 --> 00:36:00.561
<c.magenta>我会展示给你</c>
<c.magenta>如何使用栅栏</c>

00:36:00.661 --> 00:36:03.530
<c.magenta>来实现别名堆资源的</c>
<c.magenta>同步指令访问</c>

00:36:05.132 --> 00:36:08.702
<c.magenta>这就是示例帧</c>
<c.magenta>这个帧有三部分</c>

00:36:08.802 --> 00:36:11.505
<c.magenta>但现在我们有五个方框</c>
<c.magenta>因为两个渲染阶段</c>

00:36:11.572 --> 00:36:15.409
<c.magenta>渲染过程分成了</c>
<c.magenta>顶点和片段处理步骤</c>

00:36:16.043 --> 00:36:18.178
<c.magenta>我们有阴影过程</c>
<c.magenta>主过程</c>

00:36:18.245 --> 00:36:21.815
<c.magenta>最后是后处理过程</c>
<c.magenta>我们会使用计算来执行</c>

00:36:23.584 --> 00:36:27.855
<c.magenta>Metal指令是按顺序</c>
<c.magenta>提交给指令队列的</c>

00:36:28.488 --> 00:36:29.790
<c.magenta>所以可能目前不清楚</c>

00:36:29.857 --> 00:36:32.059
<c.magenta>为什么我们需要</c>
<c.magenta>指令间的同步</c>

00:36:32.993 --> 00:36:35.429
<c.magenta>不过GPU是并行机</c>
<c.magenta>可以并行地</c>

00:36:35.495 --> 00:36:36.930
<c.magenta>执行多个指令</c>

00:36:38.232 --> 00:36:41.902
<c.magenta>我们iOS和tvOS产品中的</c>
<c.magenta>GPU可以执行顶点</c>

00:36:42.302 --> 00:36:45.372
<c.magenta>片段和计算指令</c>
<c.magenta>全部并行执行</c>

00:36:45.439 --> 00:36:47.841
<c.magenta>将GPU的利用率最大化</c>

00:36:48.709 --> 00:36:52.412
<c.magenta>GPU甚至可以同时</c>
<c.magenta>执行多个帧</c>

00:36:53.247 --> 00:36:55.015
<c.magenta>好了 现在你可能</c>
<c.magenta>会发现一个问题</c>

00:36:56.049 --> 00:36:57.885
<c.magenta>看看这两个突出显示的指令</c>

00:36:58.519 --> 00:37:00.153
<c.magenta>它们都是在同时更新</c>

00:36:58.519 --> 00:37:00.153
<c.magenta>它们都是在同时更新</c>

00:37:00.220 --> 00:37:01.922
<c.magenta>别名堆资源</c>

00:37:02.923 --> 00:37:04.925
<c.magenta>我们要使用栅栏来修复它</c>

00:37:06.193 --> 00:37:07.794
<c.magenta>首先我们将栅栏带入</c>

00:37:09.162 --> 00:37:11.632
<c.magenta>后处理指令更新栅栏</c>

00:37:12.933 --> 00:37:16.036
<c.magenta>所以阴影指令片段处理阶段</c>

00:37:16.103 --> 00:37:17.304
<c.magenta>可以等待栅栏</c>

00:37:18.539 --> 00:37:22.442
<c.magenta>现在这两个指令</c>
<c.magenta>不再同时执行了</c>

00:37:23.510 --> 00:37:25.179
<c.magenta>我将展示给你如何使用Swift</c>

00:37:25.245 --> 00:37:27.481
<c.magenta>给栅栏更新和栅栏等待编码</c>

00:37:29.483 --> 00:37:31.685
<c.magenta>首先 我们用设备创建栅栏</c>

00:37:32.352 --> 00:37:34.154
<c.magenta>这是新方法</c>
<c.magenta>--不带参数</c>

00:37:34.955 --> 00:37:37.724
<c.magenta>接下来 我们编码</c>
<c.magenta>后处理计算编码器</c>

00:37:37.824 --> 00:37:39.193
<c.magenta>在第一帧的结尾</c>

00:37:39.693 --> 00:37:43.363
<c.magenta>我们首先创建</c>
<c.magenta>computeCommandEncoder</c>

00:37:43.597 --> 00:37:44.865
<c.magenta>然后编码分派</c>

00:37:46.567 --> 00:37:51.104
<c.magenta>在我们结束编码器之前</c>
<c.magenta>我们首先更新栅栏</c>

00:37:51.205 --> 00:37:55.843
<c.magenta>这样后续指令可以等待</c>
<c.magenta>直到这个指令执行完成</c>

00:37:57.444 --> 00:38:01.248
<c.magenta>在下一个帧中我们会</c>
<c.magenta>编码阴影渲染</c>

00:37:57.444 --> 00:38:01.248
<c.magenta>在下一个帧中我们会</c>
<c.magenta>编码阴影渲染</c>

00:38:01.648 --> 00:38:03.283
<c.magenta>我们创建</c>
<c.magenta>renderCommandEncoder</c>

00:38:03.884 --> 00:38:06.353
<c.magenta>在commandBufB中</c>
<c.magenta>代表指令缓冲</c>

00:38:06.420 --> 00:38:07.521
<c.magenta>用于下一帧</c>

00:38:08.555 --> 00:38:12.159
<c.magenta>不过在绘制场景之前</c>
<c.magenta>我们首先编码栅栏等待</c>

00:38:13.160 --> 00:38:16.196
<c.magenta>来等待到GPU上的后处理完成</c>

00:38:16.496 --> 00:38:18.565
<c.magenta>注意这一次</c>
<c.magenta>这里有两个参数</c>

00:38:18.632 --> 00:38:21.168
<c.magenta>第二个参数</c>
<c.magenta>叫做beforeStages</c>

00:38:22.436 --> 00:38:25.439
<c.magenta>渲染指令在两个阶段中执行</c>
<c.magenta>--顶点和片段</c>

00:38:25.539 --> 00:38:29.209
<c.magenta>所以Metal允许你指定</c>
<c.magenta>特定的需要</c>

00:38:29.276 --> 00:38:30.444
<c.magenta>等待栅栏的阶段</c>

00:38:30.978 --> 00:38:32.980
<c.magenta>在我们的例子中</c>
<c.magenta>只有片段阶段需要</c>

00:38:33.046 --> 00:38:36.583
<c.magenta>访问堆资源</c>
<c.magenta>所以我们指定片段阶段</c>

00:38:38.352 --> 00:38:40.654
<c.magenta>最后 我们可以安全地</c>
<c.magenta>渲染我们的阴影贴图</c>

00:38:41.021 --> 00:38:43.390
<c.magenta>因为我们知道</c>
<c.magenta>这个指令只有在</c>

00:38:43.457 --> 00:38:46.293
<c.magenta>前一帧的后处理</c>
<c.magenta>完成后才会执行</c>

00:38:48.395 --> 00:38:51.265
<c.magenta>让我谈谈一些</c>
<c.magenta>指令同步的最佳做法</c>

00:38:52.332 --> 00:38:55.202
<c.magenta>你知道如果使用堆</c>
<c.magenta>你必须使用栅栏</c>

00:38:55.269 --> 00:38:56.970
<c.magenta>来同步指令访问</c>

00:38:57.037 --> 00:39:00.207
<c.magenta>但你有这个控制是因为</c>
<c.magenta>你非常清楚</c>

00:38:57.037 --> 00:39:00.207
<c.magenta>但你有这个控制是因为</c>
<c.magenta>你非常清楚</c>

00:39:00.274 --> 00:39:02.476
<c.magenta>你的资源是如何使用的</c>

00:39:02.776 --> 00:39:05.879
<c.magenta>而且你的应用程序</c>
<c.magenta>会有更高的CPU效率</c>

00:39:06.180 --> 00:39:08.515
<c.magenta>如果使用Metal</c>
<c.magenta>为你进行跟踪</c>

00:39:09.449 --> 00:39:11.785
<c.magenta>例如</c>
<c.magenta>只初始化一次的纹理</c>

00:39:11.852 --> 00:39:14.588
<c.magenta>并且未被修改</c>
<c.magenta>是不需要跟踪的</c>

00:39:15.856 --> 00:39:17.057
<c.magenta>另一个例子</c>

00:39:17.324 --> 00:39:21.228
<c.magenta>一起使用的资源可以</c>
<c.magenta>通过单个栅栏一同跟踪</c>

00:39:24.131 --> 00:39:27.067
<c.magenta>所以让我总结</c>
<c.magenta>资源堆的主旨</c>

00:39:28.268 --> 00:39:31.071
<c.magenta>凭借子分配</c>
<c.magenta>更快速创建资源</c>

00:39:32.239 --> 00:39:35.642
<c.magenta>通过资源别名</c>
<c.magenta>更加有效使用内存预算</c>

00:39:36.710 --> 00:39:43.083
<c.magenta>然后使用GPU栅栏</c>
<c.magenta>实现GPU指令间的堆更新同步</c>

00:39:45.953 --> 00:39:50.991
<c.magenta>好了 现在我想介绍另一项</c>
<c.magenta>在iOS和tvOS上可用的新功能</c>

00:39:51.058 --> 00:39:52.693
<c.magenta>无记忆渲染目标</c>

00:39:53.560 --> 00:39:55.162
<c.magenta>这听起来有点魔幻</c>

00:39:55.295 --> 00:39:58.498
<c.magenta>不过我会给你展示几乎</c>
<c.magenta>所有Metal应用都能使用该功能</c>

00:39:58.565 --> 00:40:02.703
<c.magenta>只通过一行代码</c>
<c.magenta>就节省大量的内存</c>

00:39:58.565 --> 00:40:02.703
<c.magenta>只通过一行代码</c>
<c.magenta>就节省大量的内存</c>

00:40:04.571 --> 00:40:06.974
<c.magenta>无记忆渲染目标</c>
<c.magenta>这种纹理</c>

00:40:07.040 --> 00:40:10.077
<c.magenta>不将任何系统内存</c>
<c.magenta>分配给纹理内容</c>

00:40:10.811 --> 00:40:14.615
<c.magenta>没有任何内存</c>
<c.magenta>存储纹理内容</c>

00:40:14.848 --> 00:40:16.950
<c.magenta>剩下的就是纹理元数据</c>

00:40:17.017 --> 00:40:20.020
<c.magenta>例如纹理尺寸和内部纹理格式</c>

00:40:20.454 --> 00:40:22.956
<c.magenta>很明显 这节省了大量的内存</c>

00:40:23.290 --> 00:40:25.526
<c.magenta>但什么时候能用</c>
<c.magenta>无记忆渲染目标呢？</c>

00:40:26.426 --> 00:40:29.696
<c.magenta>你可以将它们用于</c>
<c.magenta>未保存的渲染过程附件</c>

00:40:30.497 --> 00:40:34.468
<c.magenta>大多数Metal应用</c>
<c.magenta>会有一些附件与</c>

00:40:34.535 --> 00:40:38.105
<c.magenta>存储不在意行动</c>
<c.magenta>或多重采样解析有关</c>

00:40:38.672 --> 00:40:42.109
<c.magenta>而且用于那些渲染过程附件</c>
<c.magenta>的纹理可以是无记忆的</c>

00:40:43.610 --> 00:40:46.180
<c.magenta>要制作无记忆渲染目标</c>

00:40:46.480 --> 00:40:49.116
<c.magenta>你可以像平常创建纹理那样</c>

00:40:49.249 --> 00:40:51.185
<c.magenta>使用额外存储模式标记</c>

00:40:51.351 --> 00:40:53.487
<c.magenta>MTLStorageModeMemoryless</c>

00:40:53.554 --> 00:40:54.454
<c.magenta>这就行了</c>

00:40:55.222 --> 00:40:59.193
<c.magenta>该功能只支持iOS和tvOS</c>
<c.magenta>因为它依靠于</c>

00:40:59.259 --> 00:41:03.564
<c.magenta>A7及其之后GPU的</c>
<c.magenta>砖墙式渲染架构</c>

00:40:59.259 --> 00:41:03.564
<c.magenta>A7及其之后GPU的</c>
<c.magenta>砖墙式渲染架构</c>

00:41:04.531 --> 00:41:06.233
<c.magenta>我来给你展示其工作原理</c>

00:41:07.201 --> 00:41:09.970
<c.magenta>在你的右边我们有</c>
<c.magenta>两个渲染过程附件</c>

00:41:10.070 --> 00:41:12.039
<c.magenta>一个色彩附件</c>
<c.magenta>一个深度附件</c>

00:41:13.073 --> 00:41:16.376
<c.magenta>A7及其之后GPU</c>
<c.magenta>以每次一个分块执行渲染过程</c>

00:41:16.710 --> 00:41:20.380
<c.magenta>利用快速的GPU分块存储</c>

00:41:20.614 --> 00:41:22.015
<c.magenta>在GPU的核心</c>

00:41:23.050 --> 00:41:25.719
<c.magenta>GPU分块存储包含</c>
<c.magenta>分块大小的</c>

00:41:25.786 --> 00:41:28.388
<c.magenta>深度 模板以及</c>
<c.magenta>色彩附件的代表</c>

00:41:28.856 --> 00:41:31.191
<c.magenta>这个分块存储</c>
<c.magenta>是完全隔离于</c>

00:41:31.491 --> 00:41:33.594
<c.magenta>纹理支持和系统内存</c>

00:41:34.995 --> 00:41:37.331
<c.magenta>在Metal中 你的</c>
<c.magenta>加载和存储动作控制着</c>

00:41:37.397 --> 00:41:40.000
<c.magenta>如何初始化GPU</c>
<c.magenta>分块存储 以及是否</c>

00:41:40.067 --> 00:41:44.004
<c.magenta>将GPU分块存储的结果</c>
<c.magenta>复制回系统内存里</c>

00:41:45.205 --> 00:41:47.207
<c.magenta>如果附件未从内存中加载</c>

00:41:47.274 --> 00:41:49.042
<c.magenta>而且未保存在内存中</c>

00:41:49.343 --> 00:41:52.012
<c.magenta>你可以使那个附件的</c>
<c.magenta>纹理变得无记忆</c>

00:41:52.079 --> 00:41:54.615
<c.magenta>来消除内存分配</c>

00:41:55.716 --> 00:41:57.851
<c.magenta>接下来 我会描述</c>
<c.magenta>一些很常见的情景</c>

00:41:57.918 --> 00:42:00.587
<c.magenta>你可以将该功能</c>
<c.magenta>应用到你的应用上</c>

00:41:57.918 --> 00:42:00.587
<c.magenta>你可以将该功能</c>
<c.magenta>应用到你的应用上</c>

00:42:02.789 --> 00:42:06.894
<c.magenta>深度附件经常在3D场景中</c>
<c.magenta>用于启用深度测试</c>

00:42:07.895 --> 00:42:10.898
<c.magenta>不过A7及其之后GPU</c>
<c.magenta>的深度测试是完全在</c>

00:42:10.964 --> 00:42:13.433
<c.magenta>GPU分块存储中进行</c>
<c.magenta>每次一个分块</c>

00:42:13.834 --> 00:42:16.503
<c.magenta>深度测试不需要</c>
<c.magenta>使用系统内存</c>

00:42:17.171 --> 00:42:19.940
<c.magenta>如果你不保存深度纹理</c>
<c.magenta>为之后过程所用</c>

00:42:20.507 --> 00:42:22.709
<c.magenta>那就将纹理变得无记忆</c>
<c.magenta>并节省下内存</c>

00:42:24.311 --> 00:42:25.979
<c.magenta>我来给你展示另一个机会</c>

00:42:27.147 --> 00:42:29.049
<c.magenta>当执行多重采样渲染时</c>

00:42:29.116 --> 00:42:32.786
<c.magenta>A7及其之后GPU在</c>
<c.magenta>GPU分块存储中进行所有渲染</c>

00:42:33.053 --> 00:42:35.789
<c.magenta>MSAA色彩附件纹理</c>
<c.magenta>会被使用</c>

00:42:35.856 --> 00:42:38.625
<c.magenta>只有在你选择</c>
<c.magenta>保存采样数据以备后用</c>

00:42:39.593 --> 00:42:43.397
<c.magenta>不过大多数应用会选择</c>
<c.magenta>多重采样解析存储动作</c>

00:42:43.764 --> 00:42:46.133
<c.magenta>这直接源于从GPU分块存储</c>

00:42:46.200 --> 00:42:48.068
<c.magenta>到解析色彩附件纹理</c>

00:42:49.203 --> 00:42:52.739
<c.magenta>在那种情况下 确保多重采样</c>
<c.magenta>色彩附件纹理是无记忆的</c>

00:42:52.806 --> 00:42:54.675
<c.magenta>而且这会节省大量的内存</c>

00:42:56.009 --> 00:42:59.346
<c.magenta>如你所见 采用该功能</c>
<c.magenta>所带来的节省是显著的</c>

00:42:59.613 --> 00:43:02.449
<c.magenta>通过将1080p</c>
<c.magenta>深度纹理变成无记忆的</c>

00:42:59.613 --> 00:43:02.449
<c.magenta>通过将1080p</c>
<c.magenta>深度纹理变成无记忆的</c>

00:43:02.783 --> 00:43:04.952
<c.magenta>你的应用会省下将近8MB空间</c>

00:43:05.586 --> 00:43:09.223
<c.magenta>若你在12.9英寸iPad Pro</c>
<c.magenta>上渲染原始分辨率</c>

00:43:09.489 --> 00:43:11.959
<c.magenta>深度缓存的节省会高达20MB</c>

00:43:12.759 --> 00:43:15.395
<c.magenta>而且将四倍多重采样</c>
<c.magenta>渲染目标变得</c>

00:43:15.462 --> 00:43:18.498
<c.magenta>无记忆 会节省下更多</c>
<c.magenta>4倍之多</c>

00:43:19.733 --> 00:43:23.303
<c.magenta>所以使用无记忆渲染目标</c>
<c.magenta>来最大程度使用</c>

00:43:23.370 --> 00:43:25.772
<c.magenta>你的应用程序的内存预算</c>

00:43:26.340 --> 00:43:29.409
<c.magenta>使用这省下的空间降低</c>
<c.magenta>你游戏的内存占用</c>

00:43:29.510 --> 00:43:31.812
<c.magenta>或更好</c>
<c.magenta>用省下的空间</c>

00:43:31.879 --> 00:43:34.248
<c.magenta>在游戏中加入更加</c>
<c.magenta>精美独特的内容</c>

00:43:36.350 --> 00:43:40.754
<c.magenta>我想邀请Jose上台告诉大家</c>
<c.magenta>关于Metal工具上的所有改进</c>

00:43:47.394 --> 00:43:48.262
<c.magenta>谢谢 James</c>

00:43:48.595 --> 00:43:50.898
<c.magenta>除了Metal API上</c>
<c.magenta>新加的出色功能</c>

00:43:50.964 --> 00:43:54.234
<c.magenta>我们在Metal Developer Tool上</c>
<c.magenta>有一些出色的改进 给大家展示</c>

00:43:56.904 --> 00:43:59.239
<c.magenta>首先我们会谈谈</c>
<c.magenta>Metal System Trace的新功能</c>

00:43:59.773 --> 00:44:02.309
<c.magenta>之后介绍一项新功能</c>
<c.magenta>叫做GPU Overrides</c>

00:43:59.773 --> 00:44:02.309
<c.magenta>之后介绍一项新功能</c>
<c.magenta>叫做GPU Overrides</c>

00:44:03.076 --> 00:44:05.279
<c.magenta>我们有一些非常</c>
<c.magenta>激动人心的新功能</c>

00:44:05.345 --> 00:44:07.514
<c.magenta>登录到</c>
<c.magenta>GPU Frame Debugger</c>

00:44:11.785 --> 00:44:13.253
<c.magenta>什么是</c>
<c.magenta>Metal System Trace？</c>

00:44:14.254 --> 00:44:16.990
<c.magenta>在之前的Metal演讲中</c>
<c.magenta>我们出示了这个图表</c>

00:44:17.591 --> 00:44:21.295
<c.magenta>展示了Metal在CPU和GPU</c>
<c.magenta>上的工作情况</c>

00:44:22.062 --> 00:44:25.866
<c.magenta>Metal System Trace</c>
<c.magenta>这一套工具可以将其可视化</c>

00:44:26.633 --> 00:44:29.503
<c.magenta>帮助你了解你的</c>
<c.magenta>Metal应用程序的时间轴</c>

00:44:29.803 --> 00:44:33.340
<c.magenta>通过整体图形管线</c>
<c.magenta>从CPU</c>

00:44:33.740 --> 00:44:36.643
<c.magenta>到GPU</c>
<c.magenta>再到显示器</c>

00:44:38.812 --> 00:44:43.016
<c.magenta>去年 WWDC 我们推出了</c>
<c.magenta>iOS平台的Metal System Trace</c>

00:44:43.750 --> 00:44:46.253
<c.magenta>我极力推荐去观看去年的展示</c>

00:44:46.320 --> 00:44:48.388
<c.magenta>来更好地总览Metal</c>
<c.magenta>System Trace</c>

00:44:49.690 --> 00:44:52.392
<c.magenta>之后在秋季</c>
<c.magenta>我们加入了tvOS支持</c>

00:44:53.160 --> 00:44:55.662
<c.magenta>今天我们很高兴宣布Metal</c>
<c.magenta>System Trace</c>

00:44:55.729 --> 00:44:59.199
<c.magenta>登录macOS 帮助你</c>
<c.magenta>榨干最后一滴性能</c>

00:44:59.733 --> 00:45:01.168
<c.magenta>在所有Metal平台上</c>

00:44:59.733 --> 00:45:01.168
<c.magenta>在所有Metal平台上</c>

00:45:06.406 --> 00:45:08.642
<c.magenta>我们全方位地改进了Metal</c>
<c.magenta>System Trace</c>

00:45:08.709 --> 00:45:10.377
<c.magenta>扩展我们报告的事件</c>

00:45:12.145 --> 00:45:13.213
<c.magenta>对于资源事件</c>

00:45:13.280 --> 00:45:16.116
<c.magenta>我们将高开销的资源操作</c>
<c.magenta>变得直观 例如选取数据</c>

00:45:16.183 --> 00:45:18.085
<c.magenta>从系统内存到显存</c>

00:45:20.053 --> 00:45:24.324
<c.magenta>这种案例中</c>
<c.magenta>我们能看到macOS中的绘制</c>

00:45:24.391 --> 00:45:26.426
<c.magenta>这导致了GPU执行延迟</c>

00:45:29.463 --> 00:45:32.666
<c.magenta>Metal System</c>
<c.magenta>Trace还显示调试组</c>

00:45:32.833 --> 00:45:36.937
<c.magenta>这让你更容易让你了解</c>
<c.magenta>跟踪中的指令编码关系</c>

00:45:38.839 --> 00:45:42.509
<c.magenta>在macOS上 我们支持</c>
<c.magenta>同时跟踪多个GPU</c>

00:45:42.776 --> 00:45:44.678
<c.magenta>这对一些使用案例来说</c>
<c.magenta>这难以置信</c>

00:45:44.745 --> 00:45:47.481
<c.magenta>比如你在不同GPU之间分配工作</c>

00:45:49.349 --> 00:45:52.052
<c.magenta>在iOS上</c>
<c.magenta>我们现在显示定标器工作量</c>

00:45:52.119 --> 00:45:54.922
<c.magenta>所以当你遇到延迟时</c>
<c.magenta>可以进行诊断</c>

00:45:55.222 --> 00:45:57.558
<c.magenta>通过旋转或缩放你的视图</c>

00:46:01.094 --> 00:46:03.363
<c.magenta>你现在可以将种类更多的工具</c>

00:46:03.430 --> 00:46:05.132
<c.magenta>与Metal System</c>
<c.magenta>Trace一同使用</c>

00:46:05.599 --> 00:46:09.970
<c.magenta>例如Time Profiler</c>
<c.magenta>File Activity</c>

00:46:10.838 --> 00:46:13.273
<c.magenta>Allocations 还有更多</c>

00:46:13.607 --> 00:46:18.078
<c.magenta>甚至不同的视图 例如CPU数据</c>
<c.magenta>这会展示CPU核心时间片段</c>

00:46:19.713 --> 00:46:23.483
<c.magenta>这会帮助你将Metal事件</c>
<c.magenta>与内容进行关联</c>

00:46:23.550 --> 00:46:25.152
<c.magenta>深入了解</c>

00:46:25.219 --> 00:46:27.888
<c.magenta>系统运行应用程序的情况</c>

00:46:27.955 --> 00:46:34.895
<c.magenta>允许你诊断像是由</c>
<c.magenta>CPU停滞引起的GPU饥饿</c>

00:46:35.429 --> 00:46:37.264
<c.magenta>由于错误的I/O操作</c>

00:46:40.767 --> 00:46:43.136
<c.magenta>Metal System</c>
<c.magenta>Trace会捕捉大量的数据</c>

00:46:43.504 --> 00:46:45.939
<c.magenta>所以我们让解释和</c>
<c.magenta>导航变得更容易</c>

00:46:47.441 --> 00:46:49.243
<c.magenta>使用新的工作量突出显示</c>

00:46:49.443 --> 00:46:52.279
<c.magenta>你可以注重于任何</c>
<c.magenta>指令编码器或编码缓冲</c>

00:46:53.113 --> 00:46:54.848
<c.magenta>随着它在管线中通过</c>

00:46:55.182 --> 00:46:56.783
<c.magenta>通过键盘导航支持</c>

00:46:56.850 --> 00:46:59.219
<c.magenta>你可以将你的选择</c>
<c.magenta>快速地在跟踪中移动</c>

00:47:01.655 --> 00:47:04.625
<c.magenta>最后我想介绍Performance</c>
<c.magenta>Observation</c>

00:47:04.958 --> 00:47:07.761
<c.magenta>Performance</c>
<c.magenta>Observation是给你呈现</c>

00:47:07.828 --> 00:47:10.764
<c.magenta>潜在问题的完整列表</c>
<c.magenta>这是我们在</c>

00:47:10.831 --> 00:47:12.499
<c.magenta>跟踪中通过分析找到的</c>

00:47:13.934 --> 00:47:16.470
<c.magenta>从显示面耗时过长</c>

00:47:17.504 --> 00:47:20.140
<c.magenta>到意外着色器汇编</c>

00:47:21.241 --> 00:47:23.510
<c.magenta>或者高GPU执行时间</c>

00:47:24.344 --> 00:47:27.781
<c.magenta>Performance Observations</c>
<c.magenta>替你发现你在寻找的事件</c>

00:47:28.215 --> 00:47:31.451
<c.magenta>你能从Performance</c>
<c.magenta>Observation列表直接导航</c>

00:47:32.619 --> 00:47:33.887
<c.magenta>所有这些新功能</c>
<c.magenta>会允许你</c>

00:47:33.954 --> 00:47:37.457
<c.magenta>调整你的Metal应用程序</c>
<c.magenta>使其如你所想的那样流畅运行</c>

00:47:38.358 --> 00:47:41.595
<c.magenta>现在为了展示我们在</c>
<c.magenta>GPU调试上做出的出色改进</c>

00:47:41.662 --> 00:47:43.430
<c.magenta>让我交给我的同事 Alp</c>

00:47:43.897 --> 00:47:47.434
<c.magenta>演示GPU</c>
<c.magenta>Frame Debugger</c>

00:47:56.977 --> 00:47:57.878
<c.magenta>谢谢 Jose</c>

00:47:58.779 --> 00:48:01.181
<c.magenta>我今天有很多</c>
<c.magenta>出色的功能要给大家展示</c>

00:47:58.779 --> 00:48:01.181
<c.magenta>我今天有很多</c>
<c.magenta>出色的功能要给大家展示</c>

00:48:01.348 --> 00:48:02.716
<c.magenta>我们直接开始吧</c>

00:48:04.117 --> 00:48:05.652
<c.magenta>我的应用在这里运行</c>

00:48:05.819 --> 00:48:09.590
<c.magenta>漫游过美丽的地形</c>
<c.magenta>细节由曲面细分做到了极致</c>

00:48:10.657 --> 00:48:12.993
<c.magenta>在线框图中查看这个地形该多好</c>

00:48:13.060 --> 00:48:14.862
<c.magenta>去查看每一个三角形</c>

00:48:15.896 --> 00:48:19.499
<c.magenta>好消息是 我们最新的功能</c>
<c.magenta>GPU Overrides</c>

00:48:19.600 --> 00:48:22.069
<c.magenta>让你能够修改你的Metal渲染</c>

00:48:22.169 --> 00:48:24.705
<c.magenta>直接从调试栏</c>
<c.magenta>当应用还在运行时</c>

00:48:26.039 --> 00:48:28.775
<c.magenta>我们有多个不同的</c>
<c.magenta>覆盖你可以混搭使用</c>

00:48:28.842 --> 00:48:30.210
<c.magenta>包括线框图模式</c>

00:48:31.445 --> 00:48:35.015
<c.magenta>我们切换到线框图模式</c>
<c.magenta>来看看地形的曲面细分程度</c>

00:48:37.184 --> 00:48:38.785
<c.magenta>显示每个三角形</c>

00:48:39.019 --> 00:48:41.922
<c.magenta>你可能想要调整</c>
<c.magenta>曲面细分来找到</c>

00:48:41.989 --> 00:48:44.558
<c.magenta>性能和视觉品质之间平衡</c>

00:48:45.259 --> 00:48:49.263
<c.magenta>通常你需要回去更改你的代码</c>
<c.magenta>重新编译 然后运行</c>

00:48:49.796 --> 00:48:52.332
<c.magenta>但是有了GPU Overrides</c>
<c.magenta>你可以</c>

00:48:52.399 --> 00:48:55.636
<c.magenta>直接从Overrides菜单</c>
<c.magenta>试验曲面细分比例</c>

00:48:57.070 --> 00:48:59.406
<c.magenta>我们将比例设置到25%</c>

00:49:02.242 --> 00:49:06.313
<c.magenta>现在我们有更少的三角形</c>
<c.magenta>而且还丢失了一些有趣的细节</c>

00:49:07.648 --> 00:49:09.283
<c.magenta>我们试试75%</c>

00:49:11.685 --> 00:49:14.688
<c.magenta>我认为这个效果更好</c>
<c.magenta>我们看看没有线框图的样子</c>

00:49:16.757 --> 00:49:18.091
<c.magenta>可以 我喜欢这个</c>

00:49:18.525 --> 00:49:21.161
<c.magenta>这比开始少了很多三角形</c>

00:49:21.461 --> 00:49:23.130
<c.magenta>不过还是有全部的细节</c>

00:49:23.197 --> 00:49:27.167
<c.magenta>外加提升的性能 我可以</c>
<c.magenta>在场景中加入更多炫酷效果</c>

00:49:28.702 --> 00:49:32.539
<c.magenta>如你所见 GPU</c>
<c.magenta>Overrides这工具非常有助于</c>

00:49:32.606 --> 00:49:34.775
<c.magenta>初次诊断场景中的</c>

00:49:34.842 --> 00:49:36.877
<c.magenta>一些视觉和性能问题</c>

00:49:38.345 --> 00:49:43.016
<c.magenta>接下来我们捕捉这一帧</c>
<c.magenta>来给你展示一些功能</c>

00:49:43.083 --> 00:49:45.452
<c.magenta>来极大提升你的调试工作流</c>

00:49:47.988 --> 00:49:49.323
<c.magenta>帧捕捉已经完成</c>

00:49:49.556 --> 00:49:55.362
<c.magenta>我在查看地形资源</c>
<c.magenta>来看看地形面片的情况</c>

00:49:57.397 --> 00:50:00.467
<c.magenta>在Resource Center</c>
<c.magenta>中切换到所有GPU对象</c>

00:49:57.397 --> 00:50:00.467
<c.magenta>在Resource Center</c>
<c.magenta>中切换到所有GPU对象</c>

00:50:00.868 --> 00:50:03.303
<c.magenta>你能看到所有的纹理和缓冲</c>

00:50:06.206 --> 00:50:08.141
<c.magenta>我们这里有全部的资源</c>

00:50:08.442 --> 00:50:10.577
<c.magenta>我要一个个地查看</c>

00:50:10.644 --> 00:50:13.614
<c.magenta>来找地形资源</c>
<c.magenta>会花一些时间</c>

00:50:14.615 --> 00:50:17.117
<c.magenta>这就是新的筛选条</c>
<c.magenta>发挥作用的时刻</c>

00:50:17.985 --> 00:50:21.421
<c.magenta>你可以按这里的任何属性</c>
<c.magenta>进行筛选 例如标签</c>

00:50:21.922 --> 00:50:23.790
<c.magenta>类型 大小或者细节</c>

00:50:25.559 --> 00:50:29.029
<c.magenta>因为我标注了所有的资源</c>
<c.magenta>我就只按地形筛选</c>

00:50:29.897 --> 00:50:33.834
<c.magenta>在这里 我有所有</c>
<c.magenta>用于渲染地形的资源</c>

00:50:35.569 --> 00:50:37.704
<c.magenta>现在我找到了</c>
<c.magenta>地形面片缓冲</c>

00:50:38.005 --> 00:50:41.108
<c.magenta>我想做的是</c>
<c.magenta>看看它用在什么地方</c>

00:50:42.409 --> 00:50:47.014
<c.magenta>通过简单的拖放</c>
<c.magenta>我可以筛选功能导航器</c>

00:50:47.080 --> 00:50:51.785
<c.magenta>给我展示所有用于地形面片</c>
<c.magenta>缓冲的调用 就像这样</c>

00:50:52.586 --> 00:50:56.323
<c.magenta>在这个案例中 我使用计算</c>
<c.magenta>得知了它的计算位置</c>

00:50:56.823 --> 00:50:59.793
<c.magenta>以及当渲染地形时</c>
<c.magenta>它的读取位置</c>

00:51:01.662 --> 00:51:03.230
<c.magenta>这个筛选十分强大</c>

00:51:03.697 --> 00:51:06.066
<c.magenta>我还可以使用绑定资源的</c>

00:51:06.133 --> 00:51:08.168
<c.magenta>其他任何属性</c>
<c.magenta>来筛选绘制调用</c>

00:51:09.069 --> 00:51:12.239
<c.magenta>例如 如果你按sRGB筛选</c>

00:51:12.706 --> 00:51:16.343
<c.magenta>你会看到所有绘制调用</c>
<c.magenta>使用的纹理</c>

00:51:16.410 --> 00:51:18.478
<c.magenta>都是sRGB像素格式</c>

00:51:19.613 --> 00:51:22.850
<c.magenta>这是很自然的方式</c>
<c.magenta>快速地在帧上导航</c>

00:51:25.085 --> 00:51:28.388
<c.magenta>接下来 我们进入</c>
<c.magenta>绑定GPU对象</c>

00:51:28.455 --> 00:51:31.859
<c.magenta>来看看我们是如何</c>
<c.magenta>使用资源来渲染地形的</c>

00:51:34.194 --> 00:51:36.864
<c.magenta>在绑定模式中</c>
<c.magenta>你的资源归入在</c>

00:51:36.930 --> 00:51:39.032
<c.magenta>不同的部分中</c>
<c.magenta>基于使用它们的</c>

00:51:39.099 --> 00:51:43.036
<c.magenta>Metal管线阶段</c>
<c.magenta>所以你知道到哪里去找</c>

00:51:44.404 --> 00:51:46.073
<c.magenta>看看顶点阶段</c>

00:51:46.139 --> 00:51:49.443
<c.magenta>地形面片是一个</c>
<c.magenta>绑定到多个绑定点的缓冲</c>

00:51:49.510 --> 00:51:50.744
<c.magenta>拥有不同的偏移量</c>

00:51:52.279 --> 00:51:55.482
<c.magenta>我们使用唯一的</c>
<c.magenta>缓冲来检查数据</c>

00:51:57.918 --> 00:51:59.953
<c.magenta>所有的顶点数据的布局</c>

00:52:00.020 --> 00:52:03.390
<c.magenta>排列整齐 除了这是</c>
<c.magenta>来自带有面片的Metal函数</c>

00:52:03.957 --> 00:52:07.828
<c.magenta>所以这使用了与</c>
<c.magenta>后顶点函数完全相同的结构体</c>

00:52:09.863 --> 00:52:11.498
<c.magenta>我们这里有颜色数据</c>

00:52:11.899 --> 00:52:15.435
<c.magenta>它识别颜色单词</c>
<c.magenta>然后在这里显示</c>

00:52:15.502 --> 00:52:17.070
<c.magenta>值的真正颜色</c>

00:52:19.640 --> 00:52:22.976
<c.magenta>因为这是包含</c>
<c.magenta>不同数据类型的大型缓冲</c>

00:52:23.210 --> 00:52:27.080
<c.magenta>我用新的MTLBuffer API</c>
<c.magenta>添加了一些调试标记</c>

00:52:27.247 --> 00:52:30.117
<c.magenta>这会让你极其轻松地</c>
<c.magenta>找到你想要的东西</c>

00:52:32.719 --> 00:52:35.389
<c.magenta>通过布局菜单</c>
<c.magenta>你可以直接跳入</c>

00:52:35.455 --> 00:52:38.125
<c.magenta>其他你想检查的可用布局</c>

00:52:43.230 --> 00:52:45.098
<c.magenta>查看单个缓冲是很好的</c>

00:52:45.866 --> 00:52:48.836
<c.magenta>更好的是</c>
<c.magenta>新的输入属性视图</c>

00:52:49.469 --> 00:52:52.172
<c.magenta>让你看到所有的顶点数据</c>

00:52:52.239 --> 00:52:53.974
<c.magenta>与顶点着色器的视角一样</c>

00:52:55.943 --> 00:52:58.979
<c.magenta>输入属性从你的实例</c>
<c.magenta>中收集所有数据</c>

00:52:59.413 --> 00:53:02.749
<c.magenta>曲面细分因子缓冲</c>
<c.magenta>和stage_in数据</c>

00:52:59.413 --> 00:53:02.749
<c.magenta>曲面细分因子缓冲</c>
<c.magenta>和stage_in数据</c>

00:53:03.283 --> 00:53:06.954
<c.magenta>之后提供给你单个视图</c>
<c.magenta>来一同查看它们</c>

00:53:10.190 --> 00:53:14.061
<c.magenta>在这个案例中</c>
<c.magenta>我们用多个面片渲染实例</c>

00:53:14.361 --> 00:53:18.699
<c.magenta>我可以看出什么数据</c>
<c.magenta>属于实例的哪个面片</c>

00:53:20.601 --> 00:53:22.269
<c.magenta>所以这简短介绍了</c>

00:53:22.336 --> 00:53:25.005
<c.magenta>GPU Frame</c>
<c.magenta>Debugger上的一些最新功能</c>

00:53:25.072 --> 00:53:27.407
<c.magenta>我们切回幻灯片</c>
<c.magenta>做个总结</c>

00:53:32.212 --> 00:53:35.449
<c.magenta>演示GPU</c>
<c.magenta>Frame Debugger</c>

00:53:37.784 --> 00:53:41.421
<c.magenta>你刚才看到了一些最新的GPU</c>
<c.magenta>Frame Debugger功能</c>

00:53:41.588 --> 00:53:43.590
<c.magenta>我想再告诉大家两个</c>

00:53:46.326 --> 00:53:49.596
<c.magenta>有了新Extended Validation模式</c>
<c.magenta>GPU Frame Debugger可以</c>

00:53:49.663 --> 00:53:52.533
<c.magenta>进行更加深入的应用分析</c>

00:53:53.333 --> 00:53:57.271
<c.magenta>在选择最佳纹理使用上</c>
<c.magenta>提供推荐</c>

00:53:57.371 --> 00:53:59.573
<c.magenta>或者资源的存储模式</c>

00:54:01.275 --> 00:54:04.278
<c.magenta>你可以从Xcode方案编辑器</c>
<c.magenta>中启用这个模式</c>

00:54:07.548 --> 00:54:10.384
<c.magenta>独立Metal Library</c>
<c.magenta>Projects的新支持</c>

00:54:10.450 --> 00:54:14.354
<c.magenta>让你创建Metal库</c>
<c.magenta>在多个应用中共享</c>

00:54:14.755 --> 00:54:17.157
<c.magenta>或者将多个库</c>
<c.magenta>包含在一个应用中</c>

00:54:17.658 --> 00:54:19.960
<c.magenta>就像其他任何框架或库</c>

00:54:22.729 --> 00:54:24.331
<c.magenta>使用我们讲的功能</c>

00:54:24.398 --> 00:54:26.333
<c.magenta>能极大提升</c>
<c.magenta>你的工具体验</c>

00:54:26.900 --> 00:54:30.037
<c.magenta>现在我们总结</c>
<c.magenta>本次演讲中看到的内容</c>

00:54:32.840 --> 00:54:36.410
<c.magenta>我们看到通过曲面细分</c>
<c.magenta>给Metal API新增的功能</c>

00:54:36.844 --> 00:54:39.646
<c.magenta>资源堆和无记忆渲染目标</c>

00:54:40.147 --> 00:54:42.216
<c.magenta>之后我们展示了改进的工具</c>

00:54:42.282 --> 00:54:44.685
<c.magenta>Metal System Trace</c>
<c.magenta>和GPU Frame Debugger</c>

00:54:45.519 --> 00:54:47.754
<c.magenta>一定要看看</c>
<c.magenta>下午的第二部分</c>

00:54:47.821 --> 00:54:50.991
<c.magenta>我会讲讲关于函数特殊化</c>

00:54:51.124 --> 00:54:52.826
<c.magenta>和函数资源读写</c>

00:54:53.760 --> 00:54:55.696
<c.magenta>广色域和纹理资源</c>

00:54:56.230 --> 00:54:58.765
<c.magenta>以及Metal性能</c>
<c.magenta>着色器的增加功能</c>

00:55:00.868 --> 00:55:04.204
<c.magenta>有关更多本次演讲的信息</c>
<c.magenta>请访问这个网络连接</c>

00:55:04.605 --> 00:55:09.142
<c.magenta>你可以补看视频 并得到</c>
<c.magenta>资料和示例代码链接</c>

00:55:11.812 --> 00:55:15.148
<c.magenta>我们昨天的演讲十分精彩</c>
<c.magenta>你可以在线观看</c>

00:55:15.816 --> 00:55:19.219
<c.magenta>这个下午 我们有</c>
<c.magenta>Metal的新功能 第二部分</c>

00:55:19.419 --> 00:55:22.155
<c.magenta>之后高级Metal着色器优化</c>
<c.magenta>就在这个演讲厅</c>

00:55:23.190 --> 00:55:25.492
<c.magenta>感谢大家的到来</c>
<c.magenta>祝各位 WWDC 过得愉快</c>
