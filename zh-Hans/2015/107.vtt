WEBVTT

00:00:24.391 --> 00:00:25.292 align:middle
杰森·比弗: 下午好

00:00:27.828 --> 00:00:29.429 align:middle
欢迎来到Cocoa Touch讲座

00:00:29.530 --> 00:00:30.731 align:middle
我是杰森·比弗

00:00:30.797 --> 00:00:33.033 align:middle
是高级工程经理在iOS小组工作

00:00:35.202 --> 00:00:37.571 align:middle
iOS 9的最新内容有很多

00:00:37.771 --> 00:00:42.242 align:middle
不过 我首先希望来回
顾一下在过去几年所做的改进

00:00:44.178 --> 00:00:48.015 align:middle
自从iOS 6起 我们开始
为怎样构建iOS应用等

00:00:48.081 --> 00:00:52.152 align:middle
较大改进奠定基础我们开始在
所推出的每个主要版本中

00:00:52.352 --> 00:00:53.854 align:middle
都体现了这样的改进

00:00:55.689 --> 00:00:57.791 align:middle
在iOS 6中 我们增加了自动布局

00:00:58.325 --> 00:01:00.561 align:middle
以便于轻松构建动态和多功能界面

00:00:58.325 --> 00:01:00.561 align:middle
以便于轻松构建动态和多功能界面

00:01:00.627 --> 00:01:03.230 align:middle
以便对适用尺寸和屏幕方向

00:01:03.664 --> 00:01:06.400 align:middle
以及本地化等方面的改进

00:01:06.733 --> 00:01:07.801 align:middle
做出反应

00:01:10.604 --> 00:01:12.639 align:middle
在 iOS 7中 我们
推出了动态类型

00:01:13.473 --> 00:01:15.375 align:middle
这可以帮助在用户可选的

00:01:15.442 --> 00:01:18.745 align:middle
文字大小应用中实现漂亮的印刷样式

00:01:19.546 --> 00:01:20.914 align:middle
与自动布局一道

00:01:21.748 --> 00:01:24.017 align:middle
界面可以与用户所选文本
大小的改变自动适应

00:01:24.084 --> 00:01:25.619 align:middle
通过采用动态类型系统

00:01:26.286 --> 00:01:31.458 align:middle
可以在文本渲染应用中免费

00:01:31.525 --> 00:01:33.360 align:middle
为文本的可读性实现改进

00:01:35.662 --> 00:01:38.999 align:middle
在iOS 8 我们做出的改进
可能算得上是最大

00:01:39.099 --> 00:01:40.901 align:middle
我们引入了适应性概念

00:01:42.603 --> 00:01:44.905 align:middle
这是指应用应该

00:01:45.172 --> 00:01:46.807 align:middle
在运行环境下适应改变

00:01:47.574 --> 00:01:50.410 align:middle
这一概念的基础就是尺寸类别

00:01:52.246 --> 00:01:54.882 align:middle
尺寸类别会根据

00:01:54.948 --> 00:01:58.385 align:middle
空间是否会受到具体的尺寸束缚导致

00:01:58.452 --> 00:02:00.220 align:middle
应用的用户界面发生结构改变

00:01:58.452 --> 00:02:00.220 align:middle
应用的用户界面发生结构改变

00:02:01.488 --> 00:02:05.058 align:middle
在这里所显示的设置应用中
在iPad和iPhone

00:02:05.125 --> 00:02:08.328 align:middle
运行的代码完全相同

00:02:08.395 --> 00:02:12.633 align:middle
尺寸类别的不同
导致用户界面的结构变化

00:02:14.234 --> 00:02:17.337 align:middle
尺寸类别iKit视图控制
器许多部件的适应性

00:02:17.404 --> 00:02:21.441 align:middle
视图控制器的呈现搜索结果

00:02:22.276 --> 00:02:25.179 align:middle
上拉菜单等等所有这些都

00:02:25.612 --> 00:02:30.684 align:middle
与尺寸分类和必须配合使用的
可用空间相适应

00:02:32.886 --> 00:02:34.555 align:middle
我们去年引入

00:02:34.621 --> 00:02:38.559 align:middle
适应性概念的时候我们为何会往
这方面发展还不是很清晰

00:02:39.326 --> 00:02:42.663 align:middle
在应用中我们通常是全屏

00:02:43.163 --> 00:02:46.934 align:middle
在应用运行的时候一般
不需要改变用户界面结构

00:02:48.402 --> 00:02:50.170 align:middle
随着多任务处理的引入

00:02:50.871 --> 00:02:52.739 align:middle
做出上述改进的原因就很清晰了

00:02:53.273 --> 00:02:57.611 align:middle
你无需针对具体硬件

00:02:57.878 --> 00:02:59.313 align:middle
构建两种不同的体验

00:02:59.980 --> 00:03:02.783 align:middle
针对用户运行的app你可以提供

00:02:59.980 --> 00:03:02.783 align:middle
针对用户运行的app你可以提供

00:03:03.250 --> 00:03:05.485 align:middle
根据尺寸打造的体验连续性

00:03:06.687 --> 00:03:08.655 align:middle
应用这些基础性基础不仅app

00:03:08.722 --> 00:03:12.793 align:middle
可以用于我们所推出的所用硬件

00:03:13.760 --> 00:03:16.396 align:middle
也可以支持这些多任务处理的新功能

00:03:17.097 --> 00:03:20.901 align:middle
以及我们已有合作的
已采纳所有这些改变的开发人员

00:03:21.735 --> 00:03:25.506 align:middle
在某种情况下真是只需要
几分钟时间就可以让他们的app

00:03:25.739 --> 00:03:28.208 align:middle
与我们的app无缝对接

00:03:30.511 --> 00:03:33.113 align:middle
需要特殊处理的是Picture
in Picture功能

00:03:33.480 --> 00:03:36.149 align:middle
如果应用支持背景媒体播放
可以在iOS 9中

00:03:36.783 --> 00:03:39.853 align:middle
使用新的API启动播放器

00:03:39.920 --> 00:03:41.922 align:middle
支持 Picture in
Picture 功能

00:03:42.556 --> 00:03:44.658 align:middle
要记住 Picture in
Picture 功能

00:03:44.725 --> 00:03:46.326 align:middle
和所有多任务处理一样应用

00:03:47.094 --> 00:03:50.063 align:middle
需要作为“良民”确保

00:03:50.130 --> 00:03:52.032 align:middle
不会干扰整体用户体验

00:03:53.934 --> 00:03:56.970 align:middle
本周 还有几场多任务处理的讲座

00:03:57.137 --> 00:03:59.206 align:middle
《iPad多任务处理入门》

00:03:59.573 --> 00:04:02.142 align:middle
《基于媒体的App多任务处理要点》

00:03:59.573 --> 00:04:02.142 align:middle
《基于媒体的App多任务处理要点》

00:04:02.476 --> 00:04:04.745 align:middle
以及《为多任务处理优化App》

00:04:06.713 --> 00:04:09.550 align:middle
我们来继续介绍iOS 9的最新内容

00:04:11.218 --> 00:04:12.586 align:middle
首先是自动布局

00:04:14.054 --> 00:04:17.423 align:middle
我们先来讲讲最新的UI布局指南分类

00:04:18.257 --> 00:04:21.428 align:middle
以免你在自动布局束缚中用到了

00:04:21.495 --> 00:04:25.165 align:middle
额外的视图 现在可以使用布局指南

00:04:25.232 --> 00:04:27.100 align:middle
以避免视图层次搞乱

00:04:29.069 --> 00:04:32.439 align:middle
我们介绍的是默认的两个布局指南

00:04:33.440 --> 00:04:36.410 align:middle
布局边界指南和可读内容指南

00:04:36.910 --> 00:04:39.012 align:middle
可以在UIView使用这些属性

00:04:39.546 --> 00:04:41.248 align:middle
在定义视图内容方面

00:04:41.715 --> 00:04:44.218 align:middle
允许更多的表达性

00:04:45.919 --> 00:04:49.022 align:middle
这些会替代我们在iOS 8中
所介绍的布局边界

00:04:49.089 --> 00:04:52.092 align:middle
在编写新代码时 都应使用布局指南
在重新访问旧编码时

00:04:52.159 --> 00:04:55.696 align:middle
也应该将边界替换为布局指南

00:04:57.764 --> 00:05:00.033 align:middle
我准备花些时间
介绍一下第二种情况

00:04:57.764 --> 00:05:00.033 align:middle
我准备花些时间
介绍一下第二种情况

00:05:00.100 --> 00:05:01.802 align:middle
可读内容指南

00:05:05.472 --> 00:05:07.107 align:middle
当文本主体很大时

00:05:07.708 --> 00:05:10.043 align:middle
文本行长度与文本的可读性

00:05:10.110 --> 00:05:12.446 align:middle
和易读性都有很大关系

00:05:13.847 --> 00:05:16.583 align:middle
如果文本行太宽就像这样

00:05:17.084 --> 00:05:19.319 align:middle
就很难看到文本行起始位置阅读时

00:05:19.686 --> 00:05:22.856 align:middle
也就很难接上下一行

00:05:23.757 --> 00:05:25.659 align:middle
相反 如果文本行太窄

00:05:26.193 --> 00:05:29.997 align:middle
目光太过频繁地来回转移
则会打断阅读节奏

00:05:31.098 --> 00:05:33.967 align:middle
文本行的理想长度取决于许多因素

00:05:34.034 --> 00:05:36.603 align:middle
包括字体 大小 行距

00:05:38.038 --> 00:05:39.773 align:middle
不过通过使用可读内容指南

00:05:40.440 --> 00:05:43.076 align:middle
可以确保无论用户文本大小

00:05:43.143 --> 00:05:44.678 align:middle
或应用渲染文本的可用空间

00:05:45.078 --> 00:05:48.682 align:middle
如何文本的可读性都不会有问题

00:05:51.919 --> 00:05:54.221 align:middle
我们来谈谈怎样使用布局指南

00:05:54.288 --> 00:05:56.757 align:middle
减少应用中的视图数量

00:05:57.791 --> 00:06:00.494 align:middle
比如说有个视图是要展示若干星球

00:05:57.791 --> 00:06:00.494 align:middle
比如说有个视图是要展示若干星球

00:06:00.561 --> 00:06:03.630 align:middle
我们希望以父视图为中心来展示

00:06:04.064 --> 00:06:06.667 align:middle
或是沿着x轴排开

00:06:07.201 --> 00:06:09.736 align:middle
在使用自动布局束缚之前

00:06:09.803 --> 00:06:11.505 align:middle
我们要先在视图层次中引入一系列

00:06:11.772 --> 00:06:13.073 align:middle
额外视图来实现这一点

00:06:13.607 --> 00:06:16.443 align:middle
现在先来定义布局指南

00:06:16.510 --> 00:06:20.514 align:middle
这定义的是视图安排的空间

00:06:23.851 --> 00:06:25.886 align:middle
比例我们也生成了另一组束缚

00:06:25.953 --> 00:06:27.588 align:middle
是以这些视图为中心

00:06:29.389 --> 00:06:34.828 align:middle
然后只需改变活动状态的束缚
就可以实现漂亮的动画是这个样子

00:06:35.529 --> 00:06:38.465 align:middle
本例中 我们同时改变了所有的束缚

00:06:39.199 --> 00:06:41.301 align:middle
但是如果我们是在不同的时间

00:06:41.368 --> 00:06:44.838 align:middle
使用框架动画改变束缚

00:06:45.072 --> 00:06:47.241 align:middle
就会实现诸多非常有趣的效果

00:06:51.311 --> 00:06:55.382 align:middle
在iOS 9我们还将
StackView引入iOS

00:06:56.283 --> 00:06:59.820 align:middle
以便于将子视图作为堆栈管理

00:06:59.887 --> 00:07:02.122 align:middle
可以实现垂直或水平排布

00:06:59.887 --> 00:07:02.122 align:middle
可以实现垂直或水平排布

00:07:02.389 --> 00:07:05.826 align:middle
StackView在覆盖下
使用自动布局

00:07:05.893 --> 00:07:07.394 align:middle
不过可以管理所有的束缚

00:07:08.862 --> 00:07:11.265 align:middle
可以调整间隔对齐

00:07:11.532 --> 00:07:14.801 align:middle
可以在可用空间允许均等

00:07:14.868 --> 00:07:18.138 align:middle
或按比例调整视图分配方法

00:07:19.239 --> 00:07:21.842 align:middle
StackViews还可以嵌套

00:07:24.011 --> 00:07:26.914 align:middle
可以将StackView
作为另一个StackView的元素

00:07:26.980 --> 00:07:29.183 align:middle
以便生成非常丰富的布局

00:07:30.918 --> 00:07:32.653 align:middle
这些布局将自动调整

00:07:32.719 --> 00:07:35.923 align:middle
内容显示方式并根据可用空间

00:07:36.190 --> 00:07:37.824 align:middle
进行调整像这样

00:07:40.160 --> 00:07:42.629 align:middle
我们还引入了快捷栏

00:07:43.163 --> 00:07:45.199 align:middle
连上硬件键盘后在屏幕底边

00:07:45.666 --> 00:07:48.535 align:middle
或软件键盘上有显示

00:07:49.536 --> 00:07:53.440 align:middle
快捷栏包括字体控制 如黑体 斜体

00:07:53.507 --> 00:07:55.509 align:middle
下划线 剪切 复制和粘贴

00:07:55.976 --> 00:07:58.212 align:middle
还可以根据应用自定义

00:07:59.680 --> 00:08:02.716 align:middle
符合UI文本输入协议的任何内容

00:07:59.680 --> 00:08:02.716 align:middle
符合UI文本输入协议的任何内容

00:08:03.317 --> 00:08:06.019 align:middle
可以返回至使用该方法的辅助输入项

00:08:08.188 --> 00:08:11.558 align:middle
UI文本辅助输入项
是iOS 9中的新分类

00:08:12.492 --> 00:08:15.796 align:middle
有着两个属性用于确定

00:08:15.863 --> 00:08:17.531 align:middle
引导和追踪栏-按钮组

00:08:17.598 --> 00:08:19.566 align:middle
这样就可以轻松
在这里加入自己的元素

00:08:23.270 --> 00:08:26.840 align:middle
现在正如在State of
the Union专题会所见

00:08:26.974 --> 00:08:29.209 align:middle
我们不再必须在单一的故事板上

00:08:29.276 --> 00:08:30.344 align:middle
为应用准备整个界面

00:08:31.011 --> 00:08:33.447 align:middle
可以将故事板彼此相连

00:08:34.648 --> 00:08:37.183 align:middle
我们还提供了解开引线的方法

00:08:44.024 --> 00:08:48.095 align:middle
我们现在可以在操作系统实现
完全的从右至左支持

00:08:49.062 --> 00:08:51.732 align:middle
如果曾做过从右至左的语言本地化

00:08:52.165 --> 00:08:53.967 align:middle
并在iOS 9上连接了app

00:08:54.034 --> 00:08:56.436 align:middle
这一切也都将在app上自动实现

00:08:57.504 --> 00:09:00.240 align:middle
所有的UI Kit控件都将自动反转

00:08:57.504 --> 00:09:00.240 align:middle
所有的UI Kit控件都将自动反转

00:09:00.807 --> 00:09:02.676 align:middle
注意导航也发生了反转

00:09:03.443 --> 00:09:05.179 align:middle
所有的动画也都反转

00:09:05.546 --> 00:09:08.882 align:middle
列表视图单元格布局
甚至滑块和开关

00:09:08.949 --> 00:09:10.384 align:middle
也都发生反转

00:09:11.752 --> 00:09:14.454 align:middle
集合视图也会自动反转布局

00:09:14.521 --> 00:09:16.190 align:middle
流向改为从右至左

00:09:16.256 --> 00:09:18.892 align:middle
这里我们看到起始标记的滑动
要求向右滑动

00:09:18.959 --> 00:09:22.362 align:middle
未读标记要求是向左滑动

00:09:29.303 --> 00:09:32.906 align:middle
视图控制器和视图上有两个属性

00:09:32.973 --> 00:09:34.908 align:middle
名为语义内容属性

00:09:35.709 --> 00:09:39.246 align:middle
可以确定内容如何排布

00:09:39.413 --> 00:09:42.249 align:middle
默认状态下 所有内容都会自动反转

00:09:43.150 --> 00:09:45.786 align:middle
不过可以按照应用中

00:09:45.853 --> 00:09:48.522 align:middle
所需通过自定义覆盖这些属性

00:09:49.189 --> 00:09:51.558 align:middle
还有一种方法

00:09:52.059 --> 00:09:54.428 align:middle
可以为具体的内容属性获取布局方向

00:09:58.165 --> 00:10:02.135 align:middle
语义内容属性有着5个值之一

00:09:58.165 --> 00:10:02.135 align:middle
语义内容属性有着5个值之一

00:10:02.269 --> 00:10:04.471 align:middle
第一个未明确这是默认状态

00:10:05.105 --> 00:10:07.407 align:middle
除非有理由改变
UI Kit做的事情

00:10:07.474 --> 00:10:09.176 align:middle
这个值不用管它

00:10:10.811 --> 00:10:15.282 align:middle
如果有一组控件代表播放

00:10:15.949 --> 00:10:17.417 align:middle
快进和倒退等播放控件

00:10:17.918 --> 00:10:20.387 align:middle
可以使用播放获取布局方向

00:10:21.488 --> 00:10:24.057 align:middle
如果有一组控件代表或导致

00:10:25.125 --> 00:10:27.961 align:middle
UI中出现部分方向改变

00:10:28.495 --> 00:10:32.699 align:middle
例如 文本对齐控件
文本编辑器中的左中右

00:10:33.200 --> 00:10:35.269 align:middle
可以使用获取布局方向

00:10:36.270 --> 00:10:38.272 align:middle
最后 还有两个额外的值

00:10:38.605 --> 00:10:40.407 align:middle
可以执行从左至右

00:10:40.474 --> 00:10:41.675 align:middle
或从右至左的布局

00:10:46.380 --> 00:10:49.316 align:middle
对于图像而言 UI Kit不清楚

00:10:49.383 --> 00:10:51.685 align:middle
图像是否应该在任何情况下都默认反转

00:10:51.919 --> 00:10:53.754 align:middle
比如照片这类用户内容

00:10:53.820 --> 00:10:56.490 align:middle
就不应反转而在应用中的控件部分

00:10:56.557 --> 00:10:58.158 align:middle
则应该进行反转

00:10:59.826 --> 00:11:02.663 align:middle
因此在UI图像的
从左到右有属性或方法

00:10:59.826 --> 00:11:02.663 align:middle
因此在UI图像的
从左到右有属性或方法

00:11:02.763 --> 00:11:07.334 align:middle
可以让你告诉我们
是否想反转图像

00:11:07.901 --> 00:11:10.637 align:middle
另外还有一个属性可以
询问图像是否已经反转

00:11:11.538 --> 00:11:14.107 align:middle
鼓励大家都到国际界面的

00:11:14.174 --> 00:11:16.243 align:middle
最新UI Kit支持看看了解一下

00:11:16.310 --> 00:11:19.613 align:middle
怎么让app支持从右至左的语言

00:11:23.450 --> 00:11:26.153 align:middle
关于用户友好性现在可以使用

00:11:26.220 --> 00:11:28.655 align:middle
更多的语音 比如
亚历克斯那样以及AV

00:11:28.722 --> 00:11:31.592 align:middle
语音合成中的高质量语音

00:11:33.493 --> 00:11:36.396 align:middle
我鼓励大家在关于 iOS
Accessibility 方面

00:11:36.463 --> 00:11:38.765 align:middle
了解更多怎样让app
实现用户友好性的内容

00:11:42.102 --> 00:11:44.371 align:middle
大家可以看到过我们在iOS 9中

00:11:44.838 --> 00:11:47.474 align:middle
引入一系列最新文本编辑手势

00:11:48.242 --> 00:11:52.779 align:middle
这些手势可以在屏幕底部的键盘上操作

00:11:52.980 --> 00:11:54.715 align:middle
或也可以在文本区操作

00:11:55.382 --> 00:11:58.752 align:middle
它们可以实现间接移动插入点

00:11:59.686 --> 00:12:02.389 align:middle
可以轻松实现选择词语句子或段落

00:11:59.686 --> 00:12:02.389 align:middle
可以轻松实现选择词语句子或段落

00:12:02.456 --> 00:12:05.559 align:middle
只需多次点击即可

00:12:06.393 --> 00:12:09.196 align:middle
还可以轻松扩展现有的选择

00:12:10.430 --> 00:12:12.599 align:middle
连同我们介绍的快捷栏

00:12:13.066 --> 00:12:17.004 align:middle
你可以轻松访问 复制和粘贴
而无需移动到文本

00:12:17.804 --> 00:12:20.641 align:middle
文本互动操控可以相当轻松便捷

00:12:21.508 --> 00:12:24.645 align:middle
现在在应用中什么都不用做

00:12:24.711 --> 00:12:26.780 align:middle
来运用这些文本编辑手势

00:12:27.314 --> 00:12:30.317 align:middle
不过如果在自己应用中的文本视图中

00:12:30.384 --> 00:12:31.451 align:middle
自定义了这些手势

00:12:31.852 --> 00:12:33.320 align:middle
应该确认不要与

00:12:33.387 --> 00:12:34.922 align:middle
最新的系统文本手势发生冲突

00:12:37.925 --> 00:12:41.228 align:middle
在iOS 7中 我们增加了

00:12:41.395 --> 00:12:43.864 align:middle
发现键盘硬件键盘命令的应用支持

00:12:44.865 --> 00:12:46.200 align:middle
App可以有自己的命令

00:12:46.266 --> 00:12:48.302 align:middle
比如生成新文档的命令

00:12:49.369 --> 00:12:50.804 align:middle
这对已经了解这些命令的用户

00:12:50.871 --> 00:12:53.006 align:middle
很是方便但是无法发现

00:12:53.073 --> 00:12:54.708 align:middle
这些命令是什么

00:12:55.642 --> 00:12:59.947 align:middle
在 iOS 9中 我们引入了
最新键盘命令探索功能

00:13:00.647 --> 00:13:05.052 align:middle
HUD 如果持续按下硬件键盘上的
命令键并且保持片刻

00:13:06.553 --> 00:13:09.656 align:middle
HUD将会显现告知此刻

00:13:09.723 --> 00:13:11.992 align:middle
可用的命令组是什么

00:13:12.259 --> 00:13:14.595 align:middle
注意 这取决于上下文

00:13:15.462 --> 00:13:17.164 align:middle
根据当时应用的状态不同

00:13:17.231 --> 00:13:19.233 align:middle
你会获得不同的命令组

00:13:19.366 --> 00:13:22.870 align:middle
因此 并不是看到整个命令组
部分启动 部分关闭

00:13:22.936 --> 00:13:25.672 align:middle
而是只能看到
目前可以应用的部分

00:13:26.507 --> 00:13:29.009 align:middle
在应用中运用 只需要为
为每个主要命令

00:13:29.176 --> 00:13:33.180 align:middle
设置可探索功能标题

00:13:33.413 --> 00:13:35.749 align:middle
UI Kit可以自动找出

00:13:36.049 --> 00:13:38.085 align:middle
哪些命令在当时可以使用

00:13:42.322 --> 00:13:44.258 align:middle
我们可以聊一聊触屏事件

00:13:45.392 --> 00:13:48.362 align:middle
在屏幕上跟踪在手指和屏幕上

00:13:48.996 --> 00:13:53.433 align:middle
产生的笔触之间会有一些固有延迟

00:13:54.401 --> 00:13:57.404 align:middle
需要花些时间扫描硬件

00:13:58.105 --> 00:14:01.208 align:middle
完成所有中间处理和绘图

00:13:58.105 --> 00:14:01.208 align:middle
完成所有中间处理和绘图

00:14:01.275 --> 00:14:03.010 align:middle
再将结果完全显示出来

00:14:03.744 --> 00:14:05.879 align:middle
这就是所谓触屏显示延迟

00:14:06.313 --> 00:14:08.782 align:middle
大部分用户在大多数情况

00:14:08.849 --> 00:14:10.584 align:middle
不会注意到这个延迟

00:14:11.185 --> 00:14:13.587 align:middle
当用户移动手指足够快时
延迟才会明显

00:14:14.621 --> 00:14:18.058 align:middle
尽管iOS已经具备
业界领先的触屏显示延迟

00:14:18.125 --> 00:14:23.230 align:middle
在iOS 9中我们将延迟水平
又做了大幅改进

00:14:25.299 --> 00:14:26.967 align:middle
在屏幕上跟踪跟踪触控时

00:14:27.868 --> 00:14:30.404 align:middle
UI Kit会
随着每次屏幕刷新

00:14:30.470 --> 00:14:33.273 align:middle
通知应用这样应用就可以更新状态

00:14:34.441 --> 00:14:36.877 align:middle
在部分更新款的硬件中

00:14:37.678 --> 00:14:40.881 align:middle
触屏更新的频率要超过显示器

00:14:41.949 --> 00:14:45.018 align:middle
因此在上一次显示器刷新后
现在有新方法

00:14:45.085 --> 00:14:47.221 align:middle
可以访问任何中间触屏

00:14:48.522 --> 00:14:52.392 align:middle
对于绘图应用而言这
可以更流畅更准确地绘图

00:14:54.728 --> 00:14:57.264 align:middle
作为改善触屏显示延迟的第一步

00:14:57.331 --> 00:14:59.833 align:middle
我们现在还可以实现触控预测

00:15:01.001 --> 00:15:03.804 align:middle
这会用到高级算法考虑触控速度

00:15:03.871 --> 00:15:06.673 align:middle
加速度以及曲率

00:15:06.974 --> 00:15:08.675 align:middle
来预测触控的走向

00:15:09.610 --> 00:15:13.180 align:middle
这就可以明显减少绘图时的延迟
因为可以预测出触控

00:15:13.247 --> 00:15:16.517 align:middle
将发生的位置而不是后知后觉

00:15:25.626 --> 00:15:26.860 align:middle
我们其实还不止于此

00:15:27.027 --> 00:15:28.829 align:middle
除了提供触控预测

00:15:29.096 --> 00:15:32.065 align:middle
我们在整个软件堆栈都做了调整

00:15:32.132 --> 00:15:36.537 align:middle
以便进一步降低延迟
我说过60毫秒以上

00:15:36.603 --> 00:15:38.405 align:middle
已经是业界领先水平

00:15:38.972 --> 00:15:40.774 align:middle
我们降到了不足30毫秒

00:15:49.449 --> 00:15:52.886 align:middle
我们还引入了
UI Kit动态的一系列改变

00:15:54.121 --> 00:15:57.824 align:middle
首先是我们支持非矩形碰撞边界

00:16:04.932 --> 00:16:07.301 align:middle
除了矩形我们现在还支持椭圆形

00:16:07.367 --> 00:16:08.669 align:middle
和基于路径的碰撞

00:16:08.969 --> 00:16:12.406 align:middle
这样就会更为接近真实的碰撞相互作用

00:16:14.007 --> 00:16:18.145 align:middle
我们还支持大量的现场行为

00:16:19.213 --> 00:16:22.082 align:middle
我们现在有线性和放射性引力就像这样

00:16:22.482 --> 00:16:27.688 align:middle
弹力 阻力和速度或是噪音和湍流场

00:16:27.754 --> 00:16:31.992 align:middle
就像这样 以及电场和磁场等

00:16:32.926 --> 00:16:37.431 align:middle
我们还支持 定义
自己的场效的能力

00:16:40.701 --> 00:16:42.936 align:middle
最后 我们添加

00:16:43.136 --> 00:16:45.239 align:middle
一些新增额外附件类型

00:16:46.106 --> 00:16:48.942 align:middle
在简单附上两个对象之前

00:16:49.009 --> 00:16:51.044 align:middle
如果想以某种方式束缚它们的运动

00:16:51.111 --> 00:16:53.947 align:middle
必须要设置若干外部束缚

00:16:54.414 --> 00:16:56.650 align:middle
有了这些新增附件类型

00:16:56.917 --> 00:17:01.288 align:middle
可以极大简化构建UI动态模型的过程

00:16:56.917 --> 00:17:01.288 align:middle
可以极大简化构建UI动态模型的过程

00:17:05.157 --> 00:17:08.996 align:middle
我们也添加了模糊半径动画的能力

00:17:15.202 --> 00:17:17.938 align:middle
为实现漂亮的效果就像这样

00:17:18.005 --> 00:17:20.073 align:middle
聚光灯效果的进出

00:17:21.808 --> 00:17:25.179 align:middle
我们还iOS 9中引入了
一系列EPI改进

00:17:25.945 --> 00:17:28.182 align:middle
以优化在Swift中的应用

00:17:29.449 --> 00:17:32.953 align:middle
这是利用Swift的更好表达能力

00:17:33.253 --> 00:17:37.858 align:middle
并改善编译时间类型检查功能

00:17:41.094 --> 00:17:44.231 align:middle
在可空性方面 可以明确属性行为

00:17:44.298 --> 00:17:46.400 align:middle
以及返回值能否为零值

00:17:46.466 --> 00:17:49.837 align:middle
我们已经介绍了整个API定义了

00:17:49.903 --> 00:17:52.673 align:middle
零论证或返回零值

00:17:52.973 --> 00:17:54.575 align:middle
是否担保不为零值

00:17:58.111 --> 00:17:59.746 align:middle
我们还有轻量级泛型

00:17:59.880 --> 00:18:02.416 align:middle
这是轻量级形式的类型参数化

00:17:59.880 --> 00:18:02.416 align:middle
这是轻量级形式的类型参数化

00:18:02.816 --> 00:18:06.153 align:middle
可以实现Cocoa和Cocoa
Touch API的更好表达

00:18:06.987 --> 00:18:10.657 align:middle
例如 UI视图的子视图方式

00:18:10.891 --> 00:18:15.295 align:middle
可以返回UI视图数组
而不仅仅是ID数组

00:18:17.231 --> 00:18:19.600 align:middle
在《Swift最新内容》
讲座中有更多相关内容

00:18:23.937 --> 00:18:27.774 align:middle
iOS 9新增了通知能力
可以实现针对用户的文本输入

00:18:27.841 --> 00:18:32.412 align:middle
或是来自客户的文本输入
速度可以等同于回复文本消息

00:18:38.285 --> 00:18:41.889 align:middle
UI用户通知动作分类
具备新的行为属性

00:18:41.955 --> 00:18:44.992 align:middle
如果设置文本输入行为

00:18:46.660 --> 00:18:49.663 align:middle
通知会有文本字段允许快速回复

00:18:55.969 --> 00:18:58.438 align:middle
还有一个额外的动作参数字典

00:18:58.505 --> 00:19:01.275 align:middle
可允许自定义Send按钮的名称

00:18:58.505 --> 00:19:01.275 align:middle
可允许自定义Send按钮的名称

00:19:04.845 --> 00:19:07.514 align:middle
我们还要介绍最新的
SF Safari视图控制器

00:19:08.415 --> 00:19:11.618 align:middle
这可以实现
用原生语言app显示网络内容

00:19:12.419 --> 00:19:15.155 align:middle
并用所有主要
Safari UI元素所包围

00:19:15.222 --> 00:19:17.291 align:middle
用户对此已经非常熟悉

00:19:18.192 --> 00:19:19.760 align:middle
甚至还可以支持高级功能

00:19:19.826 --> 00:19:21.161 align:middle
比如Reader和自动填表

00:19:24.198 --> 00:19:26.700 align:middle
在《Safari视图控制器介绍》
讲座中 会有更多内容

00:19:26.767 --> 00:19:28.869 align:middle
在iOS 9中 我们引入了
一系列最新扩展点

00:19:28.936 --> 00:19:31.371 align:middle
可实现在系统中扩展其他应用

00:19:33.006 --> 00:19:35.375 align:middle
对于VPN 我们有三个新扩展点

00:19:36.009 --> 00:19:38.579 align:middle
有包隧道提供者可以帮助你

00:19:38.645 --> 00:19:41.582 align:middle
构建自己的
VPN隧道协议客户端

00:19:43.250 --> 00:19:46.887 align:middle
还有app-代理提供者
可以帮助你执行

00:19:46.954 --> 00:19:50.524 align:middle
自己的自定义透明网络代理协议客户端

00:19:52.059 --> 00:19:54.494 align:middle
还有过滤器控制提供方
和过滤器数据提供方

00:19:54.595 --> 00:19:57.965 align:middle
可允许实现动态装置上内容过滤

00:19:58.999 --> 00:20:01.068 align:middle
对于Safari有两个新扩展点

00:19:58.999 --> 00:20:01.068 align:middle
对于Safari有两个新扩展点

00:20:02.336 --> 00:20:05.005 align:middle
Shared Links可以让应用
明确可以在共享链接

00:20:05.072 --> 00:20:08.575 align:middle
用户种子上显现的内容

00:20:10.811 --> 00:20:14.481 align:middle
内容拦截扩展可允许定义

00:20:14.548 --> 00:20:17.818 align:middle
内容或页面资源的子集

00:20:19.853 --> 00:20:23.590 align:middle
并防止其显现

00:20:28.362 --> 00:20:32.399 align:middle
对于Spotlight
还有一个扩展可以允许系统

00:20:34.201 --> 00:20:36.537 align:middle
对应用数据进行索引
而且还可以在背景完成

00:20:37.738 --> 00:20:40.908 align:middle
这样就无需启动应用来重新对

00:20:40.974 --> 00:20:43.110 align:middle
app内容进行索引

00:20:44.745 --> 00:20:46.914 align:middle
在《App搜索介绍》讲座中
有更多相关内容

00:20:50.417 --> 00:20:54.321 align:middle
最后 音频单元或核心音频插件
可以作为乐器 音效

00:20:54.388 --> 00:20:57.457 align:middle
或音频发生器来使用

00:20:58.892 --> 00:21:01.228 align:middle
直至现在 iOS用户还在仅限于

00:20:58.892 --> 00:21:01.228 align:middle
直至现在 iOS用户还在仅限于

00:21:01.295 --> 00:21:03.864 align:middle
Apple提供的内置音频单元

00:21:05.232 --> 00:21:07.434 align:middle
在iOS 9中 我们增加了新扩展点

00:21:07.501 --> 00:21:10.003 align:middle
可以将自己的音频单元连入iOS

00:21:15.442 --> 00:21:17.811 align:middle
大家在《音频单元扩展》讲座中
可以了解更多内容

00:21:20.047 --> 00:21:22.816 align:middle
很多人都问到我我也很高兴地宣布

00:21:22.883 --> 00:21:26.153 align:middle
我们已经发布全新Swift
和Objective-C API

00:21:26.220 --> 00:21:27.621 align:middle
用于联系人互动

00:21:32.459 --> 00:21:33.126 align:middle
谢谢

00:21:35.596 --> 00:21:38.365 align:middle
大家在《iOS 10的iOS联系人
框架介绍》中

00:21:38.432 --> 00:21:39.566 align:middle
可以了解更多内容

00:21:42.069 --> 00:21:46.373 align:middle
对于Wallet和Passkit
在银行和商家应用中

00:21:46.440 --> 00:21:48.141 align:middle
现在可以从零开始提供卡片

00:21:48.208 --> 00:21:49.610 align:middle
如果有特殊授权

00:21:51.712 --> 00:21:54.748 align:middle
还可以静默Apple Pay
如果出现了

00:21:54.948 --> 00:21:57.551 align:middle
会影响应用的情况

00:21:57.818 --> 00:22:00.954 align:middle
因此 比如在应用在某种条件下

00:21:57.818 --> 00:22:00.954 align:middle
因此 比如在应用在某种条件下

00:22:01.255 --> 00:22:03.557 align:middle
需要显示条码而且还连有NFC终端

00:22:03.891 --> 00:22:05.592 align:middle
通常会使得Apple Pay显现

00:22:05.659 --> 00:22:08.095 align:middle
可以静默这个功能这样才能扫描条码

00:22:08.829 --> 00:22:12.499 align:middle
在核心位置app连接到iOS 9

00:22:12.566 --> 00:22:13.834 align:middle
或是晚些时候

00:22:13.901 --> 00:22:16.203 align:middle
背景位置跟踪会有些改变

00:22:17.604 --> 00:22:21.875 align:middle
在CL Location
Manager上还有新的API

00:22:22.743 --> 00:22:24.711 align:middle
要求一次位置更新

00:22:24.778 --> 00:22:28.282 align:middle
如果不需要持续更新位置

00:22:28.348 --> 00:22:29.783 align:middle
这是更为有效方式

00:22:29.917 --> 00:22:31.151 align:middle
来获得用户的当前位置

00:22:37.024 --> 00:22:40.227 align:middle
对于MapKit 有若干新功能
具备地图视图

00:22:40.394 --> 00:22:42.963 align:middle
第一是访问
3d Flyover View

00:22:47.968 --> 00:22:50.971 align:middle
现在可以显示流量
以及量表和刻度尺

00:22:51.839 --> 00:22:54.341 align:middle
已生成自己的自定义调出

00:23:00.047 --> 00:23:03.684 align:middle
在HealthKit中 可以直接
实时访问 Watch OS 2

00:23:03.750 --> 00:23:05.252 align:middle
传感器数据还有若干新数据类型

00:23:06.820 --> 00:23:08.822 align:middle
跟踪用户水分的摄入量

00:23:09.423 --> 00:23:13.160 align:middle
跟踪其在阳光下暴露的时间

00:23:13.393 --> 00:23:14.595 align:middle
以及生殖健康

00:23:15.863 --> 00:23:18.632 align:middle
新款API可实现
更好的HealthKit

00:23:18.699 --> 00:23:21.502 align:middle
数据设备跟踪更好地支持删除数据

00:23:22.102 --> 00:23:25.172 align:middle
以及跟踪锻炼的新款练习会话API

00:23:25.572 --> 00:23:28.876 align:middle
几个月前 我们公布了
ResearchKit

00:23:28.976 --> 00:23:30.577 align:middle
可以用于开发人员和研究人员

00:23:31.144 --> 00:23:32.913 align:middle
创建医药研究app

00:23:34.248 --> 00:23:36.717 align:middle
ResearchKit现在包括
iPad支持...

00:23:36.783 --> 00:23:38.952 align:middle
PureTone
Audiometry

00:23:39.019 --> 00:23:41.388 align:middle
的新活动任务可用于确定

00:23:41.455 --> 00:23:44.024 align:middle
听力阈值水平

00:23:44.691 --> 00:23:47.094 align:middle
以及简单反应时任务

00:23:47.160 --> 00:23:49.630 align:middle
以便衡量用户
对事件的反应时间

00:23:50.464 --> 00:23:52.999 align:middle
还有一种
图像捕捉步骤可供使用

00:23:53.901 --> 00:23:57.037 align:middle
正如大家昨天所见
我们对HomeKit做了部分调整

00:23:58.939 --> 00:24:01.441 align:middle
我们现在可以支持详细
变更通知

00:23:58.939 --> 00:24:01.441 align:middle
我们现在可以支持详细
变更通知

00:24:01.975 --> 00:24:03.243 align:middle
灯亮起时

00:24:03.744 --> 00:24:07.681 align:middle
就可以获得具体的委托信息

00:24:08.315 --> 00:24:12.152 align:middle
明确特点和改动的配件

00:24:12.319 --> 00:24:15.689 align:middle
因此现在可以让具体的灯亮起

00:24:15.756 --> 00:24:18.725 align:middle
而不是泛泛地房间里有改动通知

00:24:21.261 --> 00:24:24.364 align:middle
HomeKit有4个预定义动作组

00:24:24.631 --> 00:24:28.268 align:middle
早上醒来出门到家

00:24:28.335 --> 00:24:31.738 align:middle
上床睡觉你可以完成
这些标准动作

00:24:31.805 --> 00:24:34.908 align:middle
关灯 锁门这类事情

00:24:34.975 --> 00:24:36.410 align:middle
确保车库门关好

00:24:36.510 --> 00:24:39.780 align:middle
所有这类问题都无需用户另行配置

00:24:43.717 --> 00:24:46.854 align:middle
在iOS 8可以生成定时触发器

00:24:46.920 --> 00:24:48.522 align:middle
实现执行计划场景

00:24:49.556 --> 00:24:53.360 align:middle
在iOS 9可以生成
更为复杂的触发器

00:24:53.994 --> 00:24:56.063 align:middle
例如 要知道 当门锁打开时

00:24:56.230 --> 00:24:58.565 align:middle
动作传感器检测到动作

00:24:58.665 --> 00:25:02.002 align:middle
这是在日出后30分钟发生的事情

00:24:58.665 --> 00:25:02.002 align:middle
这是在日出后30分钟发生的事情

00:25:05.138 --> 00:25:07.608 align:middle
当然 Watch上还有
HomeKit 可以用手表

00:25:07.674 --> 00:25:10.210 align:middle
直接控制家中的设备

00:25:12.346 --> 00:25:15.516 align:middle
有Wi-fi功能的附件
可以远程连接

00:25:15.749 --> 00:25:17.818 align:middle
即便没有Apple TV也没关系

00:25:18.852 --> 00:25:20.988 align:middle
还可以与它们通过iCloud

00:25:21.722 --> 00:25:22.823 align:middle
直接沟通

00:25:22.990 --> 00:25:25.092 align:middle
有蓝牙功能的配件

00:25:25.692 --> 00:25:27.661 align:middle
可以自动连上Wi-Fi

00:25:28.795 --> 00:25:31.265 align:middle
即便超出了配件的蓝牙有效范围

00:25:31.331 --> 00:25:32.633 align:middle
也依然可以控制

00:25:34.134 --> 00:25:36.937 align:middle
最后我们在家中的若干新项中

00:25:37.004 --> 00:25:38.472 align:middle
加入标准定义

00:25:42.910 --> 00:25:46.146 align:middle
对于CloudKit而言我们更新了

00:25:46.213 --> 00:25:48.081 align:middle
公共数据库的限制和定价

00:25:48.415 --> 00:25:50.784 align:middle
但是更令人兴奋的是
我们可以实现...

00:25:50.851 --> 00:25:52.886 align:middle
CloudKit
WebServices

00:25:53.120 --> 00:25:54.521 align:middle
来整合网络应用

00:25:59.459 --> 00:26:01.562 align:middle
本周还有两个讲座
是关于CloudKit

00:25:59.459 --> 00:26:01.562 align:middle
本周还有两个讲座
是关于CloudKit

00:26:02.296 --> 00:26:05.299 align:middle
《CloudKit最新内容》
和《CloudKit诀窍和技巧》

00:26:08.535 --> 00:26:10.270 align:middle
至此为止 UI文档

00:26:10.337 --> 00:26:12.105 align:middle
和动作控制器
会将发送给其他app的

00:26:12.172 --> 00:26:14.074 align:middle
每个文档都进行备份

00:26:15.475 --> 00:26:18.278 align:middle
现在 只要打开到位
只要是在iCloud中储存

00:26:18.345 --> 00:26:21.148 align:middle
app可以要求直接打开文档

00:26:22.282 --> 00:26:25.419 align:middle
可以在info.plist中

00:26:25.819 --> 00:26:26.820 align:middle
添加秘钥

00:26:26.887 --> 00:26:28.655 align:middle
声明适合执行新的代理方式

00:26:28.722 --> 00:26:29.923 align:middle
来直接打开文件即可

00:26:32.326 --> 00:26:35.128 align:middle
我们将在《构建基于文档的app》
讲座中详细讨论这个问题

00:26:39.466 --> 00:26:42.536 align:middle
现在 许多应用包括的资源在用户首次

00:26:42.603 --> 00:26:44.638 align:middle
开启应用时并不需要

00:26:45.873 --> 00:26:48.675 align:middle
将app可能会用到的每个资源
都包括在内  会令app

00:26:48.742 --> 00:26:52.346 align:middle
捆绑包太过庞大影响安装速度

00:26:52.412 --> 00:26:54.381 align:middle
甚至会导致超出OTA限制

00:26:54.448 --> 00:26:55.949 align:middle
这会影响销售

00:26:57.417 --> 00:27:00.888 align:middle
为解决这个问题我们来介绍按需资源

00:26:57.417 --> 00:27:00.888 align:middle
为解决这个问题我们来介绍按需资源

00:27:01.822 --> 00:27:05.526 align:middle
应用会上传单一的文件包
恰巧是满足当天

00:27:07.427 --> 00:27:09.396 align:middle
所需 但是当应用有需求时

00:27:09.463 --> 00:27:10.797 align:middle
内容可以动态下载

00:27:11.465 --> 00:27:14.868 align:middle
这些资产都是运用基于输入信息

00:27:14.935 --> 00:27:17.571 align:middle
以及用户行为的启发式逻辑
处于智能化缓存状态

00:27:21.408 --> 00:27:25.145 align:middle
在Xcode中 资产都是
使用简单标签分组

00:27:25.212 --> 00:27:26.113 align:middle
我们先来讲讲...

00:27:26.180 --> 00:27:29.049 align:middle
NS BundleResource
Request 的新分类

00:27:29.516 --> 00:27:32.452 align:middle
这可以实现用给定的标签要求所有资源

00:27:33.720 --> 00:27:37.357 align:middle
一旦这些资源得以下载
你可以使用熟悉的API去访问

00:27:37.424 --> 00:27:39.826 align:middle
　比如UI图像命名图像等

00:27:41.628 --> 00:27:44.431 align:middle
还有办法在Xcode中进行检测

00:27:44.498 --> 00:27:47.534 align:middle
模拟并未获得资源
而对服务器提出要求

00:27:47.601 --> 00:27:49.736 align:middle
Xcode可以像服务器一般工作

00:27:49.870 --> 00:27:52.172 align:middle
向应用发送相应资源

00:27:53.340 --> 00:27:55.375 align:middle
现在 我们介绍另一种新技术

00:27:55.542 --> 00:27:58.312 align:middle
来解决应用大小的问题就是app分割

00:28:00.881 --> 00:28:05.018 align:middle
现在 应用常带有与用户安装的硬件

00:28:05.085 --> 00:28:06.486 align:middle
不相关的资产和可执行内容

00:28:06.920 --> 00:28:11.058 align:middle
这一分割技术可以提供用户设备

00:28:11.124 --> 00:28:14.728 align:middle
所需的资源和可执行内容部分

00:28:16.296 --> 00:28:18.966 align:middle
使用应用分割技术
处理App Store

00:28:19.066 --> 00:28:23.470 align:middle
可以自动生成并为运行

00:28:24.738 --> 00:28:26.673 align:middle
iOS 9的设备提供应用的定制变量

00:28:26.740 --> 00:28:28.876 align:middle
这其中只包括设备相关的资源
和可执行内容部分

00:28:30.477 --> 00:28:31.678 align:middle
在服务器运用这种技术

00:28:31.745 --> 00:28:34.214 align:middle
不相关的内容甚至都不会下载

00:28:35.749 --> 00:28:37.184 align:middle
这会节省安装时间

00:28:37.251 --> 00:28:39.286 align:middle
并有希望将app处于OTA限制以下

00:28:41.688 --> 00:28:45.025 align:middle
我们还要介绍最新的
NS数据资产分类

00:28:45.092 --> 00:28:48.095 align:middle
和设备上的这可以轻松获取根据内存

00:28:48.161 --> 00:28:50.030 align:middle
图像处理能力定制的内容

00:28:50.797 --> 00:28:54.401 align:middle
现在来看Game Center
我们加入了嘉宾玩家功能

00:28:54.468 --> 00:28:57.104 align:middle
在Game Center的多玩家
模式中 实现了新的配置

00:28:58.839 --> 00:29:01.909 align:middle
我们还统一了Game Center
服务器环境

00:28:58.839 --> 00:29:01.909 align:middle
我们还统一了Game Center
服务器环境

00:29:01.975 --> 00:29:03.977 align:middle
以便于开发和测试的流线化

00:29:05.679 --> 00:29:07.714 align:middle
最后 我们来介绍ReplayKit

00:29:07.881 --> 00:29:11.585 align:middle
这可以提供
分享游戏体验的新方法

00:29:12.853 --> 00:29:15.756 align:middle
可以实现app轻松录制视频和音频

00:29:15.822 --> 00:29:17.958 align:middle
并与其他用户分享

00:29:20.160 --> 00:29:23.063 align:middle
在iOS 9中 SpriteKit
支持Metal

00:29:23.130 --> 00:29:24.731 align:middle
适用于相应的系统支持

00:29:25.365 --> 00:29:28.068 align:middle
对于不支持Metal的系统
它是开放式GL

00:29:28.502 --> 00:29:30.804 align:middle
这些都是自动完成无需人工干预

00:29:32.472 --> 00:29:34.441 align:middle
还有一个全新的动作编辑器

00:29:36.176 --> 00:29:39.680 align:middle
当然它与按需资源紧密整合

00:29:42.482 --> 00:29:44.885 align:middle
在《SpriteKit最新内容》
讲座中有更多详情

00:29:47.554 --> 00:29:51.558 align:middle
对于SceneKit在Xcode中
有全新的场景编辑器

00:29:51.625 --> 00:29:54.361 align:middle
可以支持粒子 物理

00:29:54.661 --> 00:29:56.029 align:middle
动作等等

00:29:56.930 --> 00:29:59.867 align:middle
SceneKit还有相当多的新功能

00:30:01.235 --> 00:30:05.305 align:middle
场景转换 音频节点 模型i/o

00:30:05.973 --> 00:30:09.943 align:middle
环境光遮蔽 光照图
以及许多其它功能

00:30:12.846 --> 00:30:15.916 align:middle
SpriteKit和
SceneKit是构建游戏

00:30:15.983 --> 00:30:18.085 align:middle
图形界面的强大框架

00:30:18.719 --> 00:30:21.455 align:middle
对于游戏它的强大之处
不仅在于图像能力

00:30:23.590 --> 00:30:25.926 align:middle
游戏有实体和组件部分

00:30:26.159 --> 00:30:31.131 align:middle
还有代理在游戏中都有着目标和行为

00:30:32.666 --> 00:30:35.402 align:middle
需要发现路径算法
允许代理在游戏附近导航

00:30:35.469 --> 00:30:39.206 align:middle
还需要AI允许代理决定之后

00:30:39.606 --> 00:30:41.842 align:middle
要采取怎样的行动

00:30:44.278 --> 00:30:45.379 align:middle
参与游戏所需的所有

00:30:45.445 --> 00:30:48.615 align:middle
这些元素现在都可在
GameplayKit中找到

00:30:48.682 --> 00:30:52.085 align:middle
在《GameplayKit介绍》
讲座中还可以了解更多详情

00:30:52.719 --> 00:30:55.656 align:middle
最后当然 我们要谈谈
WatchOS 2

00:30:56.123 --> 00:30:59.092 align:middle
除了直接访问现有的框架

00:30:59.193 --> 00:31:01.828 align:middle
还有新框架如Watch连结性

00:30:59.193 --> 00:31:01.828 align:middle
还有新框架如Watch连结性

00:31:02.229 --> 00:31:07.301 align:middle
将app与电话和WatchKit
连结 来搭建Watch表盘组件

00:31:09.837 --> 00:31:12.039 align:middle
在《WatchOS 2
WatchKit介绍》中

00:31:12.105 --> 00:31:13.240 align:middle
可以了解更多详情

00:31:13.307 --> 00:31:15.509 align:middle
本周所有讲座
的综述在《探讨WatchOS 2》

00:31:15.876 --> 00:31:17.377 align:middle
中有介绍

00:31:19.580 --> 00:31:21.782 align:middle
若要了解更多信息
当然有文件资料

00:31:22.549 --> 00:31:25.552 align:middle
有在线论坛开发人员技术支持

00:31:26.753 --> 00:31:28.188 align:middle
谢谢希望大家这周过得愉快
