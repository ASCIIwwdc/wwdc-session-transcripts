WEBVTT

00:00:20.521 --> 00:00:23.857 align:middle
SpriteKit 新功能

00:00:29.663 --> 00:00:32.332 align:middle
大家好欢迎来到“SpriteKit
新功能 ”讲座

00:00:32.900 --> 00:00:35.536 align:middle
今天 我们将要告诉大家一系列很棒的

00:00:35.602 --> 00:00:36.470 align:middle
新功能和改进

00:00:37.171 --> 00:00:40.908 align:middle
我知道在座的各位中有很多人
是第一次来听SpriteKit讲座

00:00:40.974 --> 00:00:43.143 align:middle
首先 我想要花几分钟来

00:00:43.544 --> 00:00:45.679 align:middle
回顾我们所要讲的是什么

00:00:48.849 --> 00:00:52.986 align:middle
SpriteKit是苹果2D游戏
和图形的框架

00:00:53.420 --> 00:00:56.290 align:middle
我们将给你提供集成的物理运动

00:00:56.924 --> 00:00:58.825 align:middle
离子运动模拟 动作

00:00:58.892 --> 00:01:00.727 align:middle
以及动画 当然 还有计算机子图

00:00:58.892 --> 00:01:00.727 align:middle
以及动画 当然 还有计算机子图

00:01:01.695 --> 00:01:06.133 align:middle
我们启动（这个项目）是想要将
SpriteKit做得不仅仅是强大

00:01:06.400 --> 00:01:08.769 align:middle
而且要非常容易上手使用

00:01:09.002 --> 00:01:12.472 align:middle
我们希望一个之前
完全没有做过游戏的人

00:01:13.040 --> 00:01:14.641 align:middle
能够来到我们的平台

00:01:14.975 --> 00:01:16.343 align:middle
开始使用SpriteKit

00:01:16.410 --> 00:01:17.911 align:middle
并且能够花很少的时间得到提高
并熟悉（SpriteKit）

00:01:18.679 --> 00:01:20.881 align:middle
我们非常期望能够传达出一些东西

00:01:20.948 --> 00:01:23.217 align:middle
能够使你专心致志地做你最擅长的事情

00:01:23.283 --> 00:01:25.319 align:middle
那就是做出最棒的游戏

00:01:28.021 --> 00:01:29.857 align:middle
我们将SpriteKit设计成

00:01:29.923 --> 00:01:32.559 align:middle
可以在iPhone、
iPad以及Mac上工作

00:01:33.093 --> 00:01:35.863 align:middle
并且
你也能够通过这个平台将你的app

00:01:35.929 --> 00:01:38.599 align:middle
应用到多个平台上
这也就意味着

00:01:38.665 --> 00:01:40.300 align:middle
你能够
直接在Mac上设计原型

00:01:40.367 --> 00:01:42.402 align:middle
并测试你的SpriteKit游戏

00:01:42.669 --> 00:01:44.538 align:middle
在你将它（游戏）安装到
一个设备上之前

00:01:47.574 --> 00:01:50.611 align:middle
可以说 有了SpriteKit
游戏构架的开发能够做到事半功倍

00:01:51.211 --> 00:01:54.615 align:middle
在刚开始的时候我们花费了
大量的精力在我们的工具上

00:01:54.781 --> 00:01:57.451 align:middle
在后续的几年里我们
也在持续地进行投资

00:01:57.885 --> 00:01:59.186 align:middle
就是为了能够

00:01:59.286 --> 00:02:01.188 align:middle
让你能够像编辑整个画面
一样编辑粒子效果

00:01:59.286 --> 00:02:01.188 align:middle
让你能够像编辑整个画面
一样编辑粒子效果

00:02:01.622 --> 00:02:03.524 align:middle
直到今年年初也同样

00:02:03.590 --> 00:02:06.326 align:middle
能够对运动和动画进行编辑

00:02:06.393 --> 00:02:08.095 align:middle
只需要在写代码前

00:02:08.161 --> 00:02:10.997 align:middle
加入一段Xcode即可

00:02:13.867 --> 00:02:15.969 align:middle
现在 我们可以开始讲解
这个构架有哪些新功能了

00:02:17.037 --> 00:02:19.573 align:middle
第一点 也是开发人员强烈要求的一点

00:02:20.240 --> 00:02:22.609 align:middle
就是视窗

00:02:22.676 --> 00:02:25.279 align:middle
视窗是指

00:02:25.345 --> 00:02:27.981 align:middle
当我们在讨论你的场景的时候
这部分（场景）是可见的

00:02:28.048 --> 00:02:29.850 align:middle
在任何时候
通过SpriteKit视角

00:02:31.351 --> 00:02:34.321 align:middle
现在的这种工作方式是
如果你想要移动你的镜头

00:02:34.821 --> 00:02:38.358 align:middle
你不得不移动
你游戏中的每一块几何图案

00:02:38.425 --> 00:02:40.994 align:middle
或者
如果你想要跟随你的一个英雄人物

00:02:41.061 --> 00:02:42.829 align:middle
穿越你的整个游戏界面

00:02:43.197 --> 00:02:44.765 align:middle
你就需要做这些计算

00:02:45.399 --> 00:02:46.633 align:middle
现在这样的工作

00:02:46.700 --> 00:02:48.368 align:middle
但是它并不像我们想象中的那样直观

00:02:49.303 --> 00:02:51.605 align:middle
如果你想要对这些游戏实体进行物理模
拟

00:02:51.672 --> 00:02:54.741 align:middle
当你移动他们的实际位置时

00:02:54.808 --> 00:02:57.077 align:middle
你可以从中看到一些伪影

00:02:59.046 --> 00:03:00.914 align:middle
我们认为我们能够做的更好

00:02:59.046 --> 00:03:00.914 align:middle
我们认为我们能够做的更好

00:03:01.982 --> 00:03:04.084 align:middle
接下来我们介绍
SKCameraNode.

00:03:05.485 --> 00:03:07.020 align:middle
通过CameraNode

00:03:07.087 --> 00:03:10.524 align:middle
我们允许你能够简单的指定你看到的部
分

00:03:10.591 --> 00:03:13.393 align:middle
变得可视化 镜头通过

00:03:13.460 --> 00:03:14.561 align:middle
展现你的场景中所包含的

00:03:14.628 --> 00:03:16.029 align:middle
可视化中心来达到这样的效果

00:03:16.630 --> 00:03:18.332 align:middle
这样你就可以在你的画面中任意移动

00:03:18.398 --> 00:03:19.800 align:middle
CameraNode

00:03:20.234 --> 00:03:22.035 align:middle
同样的
你也可以在你的画面中移动其他的

00:03:22.102 --> 00:03:23.804 align:middle
所有的游戏实体

00:03:24.705 --> 00:03:26.673 align:middle
我们在SKScene中
设置了一个属性

00:03:26.740 --> 00:03:29.142 align:middle
这个属性将允许你选择
你想使用的包含这些场景的镜头

00:03:29.209 --> 00:03:31.812 align:middle
在你的场景中你可以选择多个镜头

00:03:32.112 --> 00:03:34.581 align:middle
同样你也可以通过属性选择活动的镜头

00:03:35.983 --> 00:03:38.685 align:middle
如果你不理会属性 即其缺省值为零

00:03:39.152 --> 00:03:41.388 align:middle
我们将会保存所有你今天的使用记录

00:03:41.455 --> 00:03:43.390 align:middle
并且所有的
SpriteKit渲染效果

00:03:43.457 --> 00:03:44.625 align:middle
都和从前一样不会改变

00:03:45.792 --> 00:03:48.862 align:middle
但是SKCameraNode
中最棒的功能是

00:03:49.997 --> 00:03:50.898 align:middle
它作为一个节点存在

00:03:51.632 --> 00:03:54.301 align:middle
这就意味着你能够
使用SpriteKit节点中

00:03:54.368 --> 00:03:55.435 align:middle
所有伟大的功能

00:03:55.702 --> 00:03:57.771 align:middle
你可以访问我们的动作数据库

00:03:57.838 --> 00:04:00.073 align:middle
这样你就能够在
镜头上运行这样的动作（数据）

00:03:57.838 --> 00:04:00.073 align:middle
这样你就能够在
镜头上运行这样的动作（数据）

00:04:00.140 --> 00:04:02.009 align:middle
你也可以使用我们的约束系统

00:04:02.075 --> 00:04:03.877 align:middle
这样你就能够对镜头进行约束

00:04:04.244 --> 00:04:06.280 align:middle
你可以让它与游戏实体相结合

00:04:06.346 --> 00:04:08.715 align:middle
你也可以让它总是保留在

00:04:08.782 --> 00:04:10.184 align:middle
距离你游戏中物体的一定范围内

00:04:10.617 --> 00:04:13.587 align:middle
除了移动镜头之外
你还能够通过这些节点的属性

00:04:13.654 --> 00:04:16.055 align:middle
来控制旋转和尺度

00:04:17.291 --> 00:04:18.392 align:middle
例如

00:04:18.458 --> 00:04:20.560 align:middle
在这样一个游戏中

00:04:20.627 --> 00:04:22.729 align:middle
我想将镜头放到一
旁

00:04:22.796 --> 00:04:24.698 align:middle
我可能应用一些移动动画

00:04:24.765 --> 00:04:26.500 align:middle
来揭示我的视线中有坏人

00:04:26.567 --> 00:04:28.435 align:middle
在我将我的游戏角色
放在视线中央之前

00:04:28.936 --> 00:04:31.104 align:middle
之后我可以应用一些尺度命令

00:04:31.171 --> 00:04:32.506 align:middle
来实现镜头的变焦操作

00:04:33.440 --> 00:04:35.943 align:middle
我甚至可以使用我们的跟踪路径运动

00:04:36.009 --> 00:04:37.744 align:middle
如果我想要镜头跟踪一个贝塞尔曲线

00:04:38.645 --> 00:04:40.547 align:middle
如果我真的非常想让我的用户感到恶心

00:04:40.614 --> 00:04:41.748 align:middle
我可以旋转镜头

00:04:41.815 --> 00:04:43.450 align:middle
或者将镜头在场景中到处扔来扔去

00:04:43.750 --> 00:04:46.620 align:middle
所以现在在SpriteKit中
你完全可以控制你的游戏

00:04:46.687 --> 00:04:48.822 align:middle
哪些部分是可见的

00:04:49.122 --> 00:04:51.425 align:middle
我认为这将会是
你的工具中的一件很棒的新品

00:04:57.731 --> 00:04:59.266 align:middle
对镜头的改进

00:04:59.333 --> 00:05:01.001 align:middle
同样的我们也针对音频做了很多工作

00:04:59.333 --> 00:05:01.001 align:middle
同样的我们也针对音频做了很多工作

00:05:01.502 --> 00:05:03.804 align:middle
我们添加了一个
SKAudioNode

00:05:03.871 --> 00:05:05.873 align:middle
允许你在你的SpriteKit
游戏中

00:05:06.039 --> 00:05:07.975 align:middle
添加位置和环境的背景音

00:05:13.113 --> 00:05:16.316 align:middle
我们借助了我们去年
发布的Apple强大的

00:05:16.383 --> 00:05:18.118 align:middle
AV音频引擎构架

00:05:18.519 --> 00:05:19.853 align:middle
如果你对这个并不熟悉

00:05:19.920 --> 00:05:22.322 align:middle
它允许你指定你的语气音量

00:05:22.723 --> 00:05:24.892 align:middle
并能够作为特定环境中的声音发射器

00:05:25.259 --> 00:05:27.828 align:middle
它可以回放你制定位置

00:05:27.895 --> 00:05:29.563 align:middle
侦听器获得的声音

00:05:30.697 --> 00:05:33.600 align:middle
在SpriteKit中我们将为
你做好所有的画线工作

00:05:34.368 --> 00:05:37.571 align:middle
所有你需要做的工作就是
通过文件名或者URL指定

00:05:37.638 --> 00:05:40.707 align:middle
你想要播放的背景音乐

00:05:41.141 --> 00:05:44.444 align:middle
我们将会使用AudioNodes

00:05:44.511 --> 00:05:46.747 align:middle
跟随你指定的侦听器的位置
在你的场景中定位

00:05:46.813 --> 00:05:50.617 align:middle
并画出音频曲线 让你能够更容易地

00:05:50.884 --> 00:05:53.086 align:middle
身临其境地在游戏中定位你的音频

00:05:53.954 --> 00:05:56.557 align:middle
如果你想深入一点 亲自动手

00:05:56.990 --> 00:06:00.093 align:middle
你也可以通过
底层AVAudioNode的

00:05:56.990 --> 00:06:00.093 align:middle
你也可以通过
底层AVAudioNode的

00:06:00.427 --> 00:06:02.796 align:middle
一个节点的属性 去掉所有的约束

00:06:02.863 --> 00:06:04.264 align:middle
在那里设置所有的你想要的东西

00:06:05.966 --> 00:06:07.668 align:middle
为了掩饰这种效果

00:06:07.734 --> 00:06:09.570 align:middle
你能够使用

00:06:09.670 --> 00:06:12.639 align:middle
最新的技术将其添加
到你的SpriteKit游戏中

00:06:12.840 --> 00:06:14.441 align:middle
现在我又一个例子

00:06:14.775 --> 00:06:16.009 align:middle
这里是我的制作的一个地精

00:06:16.076 --> 00:06:17.911 align:middle
我打算让他作为我的听众

00:06:18.178 --> 00:06:20.047 align:middle
所以我把我的侦听器位置放在这里

00:06:21.081 --> 00:06:23.050 align:middle
我已经在我的场景中添加了一个火球

00:06:23.283 --> 00:06:24.685 align:middle
这是我的音频资源

00:06:24.751 --> 00:06:27.020 align:middle
在这里我已经将其作为一个
SKAudioNode添加了进来

00:06:27.287 --> 00:06:29.389 align:middle
我重新播放这个音乐的时候

00:06:29.456 --> 00:06:31.358 align:middle
注意听这个音频的效果怎么样

00:06:31.425 --> 00:06:33.360 align:middle
当火球在整个场景中来回运动的时候

00:06:33.427 --> 00:06:34.795 align:middle
你能够注意到

00:06:34.862 --> 00:06:37.397 align:middle
它变得更加饱满 更加集中 声音也更
大了

00:06:37.464 --> 00:06:39.166 align:middle
当它靠近我们的侦听器时

00:06:39.233 --> 00:06:41.502 align:middle
从远到近

00:06:41.568 --> 00:06:44.304 align:middle
直到来到场景这一边
现在我们听一下

00:06:59.820 --> 00:07:00.988 align:middle
很酷 不是吗？

00:06:59.820 --> 00:07:00.988 align:middle
很酷 不是吗？

00:07:05.726 --> 00:07:07.327 align:middle
除了这些额外的设置

00:07:07.394 --> 00:07:09.630 align:middle
我不需要做任何事情来处理这些特效

00:07:09.696 --> 00:07:11.698 align:middle
当他们在游戏场景中运动的时候
他们已经和

00:07:12.065 --> 00:07:14.001 align:middle
驱动游戏运行的逻辑联系在了一起

00:07:16.403 --> 00:07:20.774 align:middle
同样的
今年我们也重点关注了引用和实例化

00:07:21.208 --> 00:07:25.512 align:middle
我们知道你花了很多时间
为你的游戏设计

00:07:25.746 --> 00:07:29.983 align:middle
内容和动画 我们也希望你能够在

00:07:30.050 --> 00:07:33.320 align:middle
任何你想用的地方重新使用这些内容

00:07:33.387 --> 00:07:36.823 align:middle
我们将允许你能够为你的节点
和动作创建序列化数据文件

00:07:37.257 --> 00:07:39.259 align:middle
创建序列化数据文件

00:07:39.326 --> 00:07:41.862 align:middle
并将其作为一个引用参数添加进来

00:07:41.929 --> 00:07:44.998 align:middle
而不是简单的加载到你的场景中

00:07:45.065 --> 00:07:45.899 align:middle
这样

00:07:45.966 --> 00:07:48.335 align:middle
你每次对资源文件进行修改之后

00:07:48.669 --> 00:07:51.939 align:middle
将会自动地对你的游戏内容产生影响

00:07:54.474 --> 00:07:55.909 align:middle
我怎么做这个节点呢?

00:07:56.743 --> 00:07:59.680 align:middle
我设计了一部分场景作为节点

00:07:59.746 --> 00:08:02.749 align:middle
可以是一个背景元素
或者是Xcode编辑器中的一些画面

00:07:59.746 --> 00:08:02.749 align:middle
可以是一个背景元素
或者是Xcode编辑器中的一些画面

00:08:02.816 --> 00:08:07.354 align:middle
接下来我可以通过
Xcode将这些文件

00:08:07.721 --> 00:08:08.856 align:middle
拖放到主场景中

00:08:08.922 --> 00:08:10.624 align:middle
接下来它会自动地创建一个参数

00:08:10.891 --> 00:08:12.025 align:middle
这些都是为你设置好的

00:08:13.093 --> 00:08:15.229 align:middle
如果你想写代码来完成这些事情
同样可以

00:08:15.662 --> 00:08:18.699 align:middle
你可以手动构建一个
SKReferenceNode

00:08:19.066 --> 00:08:23.036 align:middle
为其分配一个文件名或者URL

00:08:23.103 --> 00:08:25.973 align:middle
当这些内容在
你的游戏中是第一次发布时

00:08:26.039 --> 00:08:28.542 align:middle
我们会将你的包中
这些内容的最新版本的

00:08:28.809 --> 00:08:29.977 align:middle
文件进行上传

00:08:31.945 --> 00:08:34.014 align:middle
我们同样能够这样处理一些动作

00:08:34.515 --> 00:08:37.384 align:middle
通过这些动作作品

00:08:37.985 --> 00:08:40.654 align:middle
能够看出我们的
新动作编辑器是多么的伟大

00:08:40.721 --> 00:08:43.323 align:middle
同时那些你在Xcode中创作的动作
你都 有命名的权利

00:08:43.756 --> 00:08:46.059 align:middle
这些名字将是你在游戏中
使用它们时候的关键字

00:08:46.727 --> 00:08:48.996 align:middle
我们在SKAction中添加了

00:08:49.329 --> 00:08:50.631 align:middle
一个名叫actionNamed
的筛选器

00:08:51.031 --> 00:08:51.932 align:middle
它的作用就像

00:08:51.999 --> 00:08:54.935 align:middle
textureNamed
对于SKTexture一样

00:08:55.068 --> 00:08:56.770 align:middle
你可以输入你想要的动作的名字

00:08:57.404 --> 00:09:01.008 align:middle
我们将自动在你的App包中的

00:08:57.404 --> 00:09:01.008 align:middle
我们将自动在你的App包中的

00:09:01.708 --> 00:09:04.278 align:middle
序列化动作文件中 找到

00:09:04.344 --> 00:09:06.446 align:middle
一个最合适的文件

00:09:06.513 --> 00:09:07.948 align:middle
然后将其在应用程序中呈现出来

00:09:08.515 --> 00:09:11.218 align:middle
在你的游戏中请频繁使用这个功能

00:09:11.285 --> 00:09:14.955 align:middle
我们做了所有的关于内存的工作

00:09:15.355 --> 00:09:17.724 align:middle
我们可以保证
你的游戏中所有相同的动作绝对不会

00:09:17.791 --> 00:09:21.428 align:middle
从硬盘中重复地加载多次

00:09:21.662 --> 00:09:24.631 align:middle
有时候你可能会想要
让同一个动作重复多次

00:09:24.698 --> 00:09:26.867 align:middle
但它会播放得时快时慢

00:09:27.467 --> 00:09:29.536 align:middle
我们添加了一个额外的选择器

00:09:29.603 --> 00:09:31.338 align:middle
它将允许你能够覆盖操作的持续时间

00:09:32.105 --> 00:09:34.007 align:middle
这是一个智能时间轴

00:09:34.107 --> 00:09:37.277 align:middle
所以即使你使用的是嵌套组和序列中的
嵌套 动作

00:09:37.344 --> 00:09:39.746 align:middle
它将动态规划新的时间轴

00:09:39.813 --> 00:09:43.550 align:middle
这样 每个时间区间内的动作组件

00:09:43.617 --> 00:09:45.285 align:middle
都将会是一样的大小

00:09:46.653 --> 00:09:50.224 align:middle
这些都是为可重复使用组件设计的工具

00:09:50.591 --> 00:09:53.560 align:middle
这些可重复使用组件你
可以在同一个游戏的同一个场景

00:09:53.627 --> 00:09:55.095 align:middle
或者跨越多个不同的游戏中使用

00:09:56.563 --> 00:09:58.966 align:middle
我们同样在构架中
添加了一系列新的动作

00:09:59.032 --> 00:10:01.468 align:middle
所以现在我们有了这些位置
AudioNodes

00:09:59.032 --> 00:10:01.468 align:middle
所以现在我们有了这些位置
AudioNodes

00:10:01.535 --> 00:10:04.271 align:middle
就能够通过动作更好的控制回放

00:10:04.471 --> 00:10:10.010 align:middle
我们已经添加了播放,暂停,回放速度

00:10:10.110 --> 00:10:12.079 align:middle
以及操作体积和立体平移等开关

00:10:13.881 --> 00:10:17.584 align:middle
我们也在帧动画中做了一些改动

00:10:18.252 --> 00:10:21.421 align:middle
在SpriteKit中我们一直
都有通过纹理动作运动

00:10:21.488 --> 00:10:24.525 align:middle
做出来的基于帧的动画

00:10:25.559 --> 00:10:28.395 align:middle
但是去年我们在SpriteKit中
引入了lighting

00:10:28.462 --> 00:10:29.530 align:middle
通过lighting

00:10:29.596 --> 00:10:31.899 align:middle
你不仅能够在你的场景中为
Sprites自动生成

00:10:32.232 --> 00:10:34.401 align:middle
也能够自主添加常规的纹理动作

00:10:34.468 --> 00:10:37.871 align:middle
然后我们可以在运行时动态的点亮他们

00:10:37.938 --> 00:10:40.207 align:middle
通过在你的场景中移动光节点

00:10:41.608 --> 00:10:43.877 align:middle
这种做法对于稳定的元素来讲很方便

00:10:43.944 --> 00:10:46.914 align:middle
但是如果我有一个基于帧的动画
例如这个东西

00:10:47.681 --> 00:10:49.816 align:middle
我们想要这些高亮和阴影部分

00:10:49.883 --> 00:10:50.751 align:middle
在当前位置分开

00:10:50.817 --> 00:10:53.654 align:middle
我们不想要腿前面所在的区域高亮

00:10:54.655 --> 00:10:56.056 align:middle
所以 我们添加了一个

00:10:56.123 --> 00:10:58.258 align:middle
正常纹理运动的动画

00:10:58.492 --> 00:11:01.228 align:middle
所以你可以使用这个 在正常的动画

00:10:58.492 --> 00:11:01.228 align:middle
所以你可以使用这个 在正常的动画

00:11:01.728 --> 00:11:04.598 align:middle
与每一帧之间 进行同步

00:11:04.698 --> 00:11:08.836 align:middle
如果我在我的人物上运行了这种动画
并给场景添加了lighting

00:11:09.136 --> 00:11:11.905 align:middle
你就会看到所有的高亮区域 阴影都能
与每一帧保 持同步

00:11:11.972 --> 00:11:15.209 align:middle
无论我的人物如何跑动

00:11:24.918 --> 00:11:27.387 align:middle
这些就是我们添加到构架中的新功能

00:11:27.454 --> 00:11:29.489 align:middle
我们也做了很多其他的工作
使这些功能能够与

00:11:29.823 --> 00:11:32.993 align:middle
系统的其他部分更好的结合在一起

00:11:33.060 --> 00:11:35.229 align:middle
更好的发挥已经添加到我们平台上的

00:11:35.295 --> 00:11:36.797 align:middle
新硬件和构架的优势

00:11:37.898 --> 00:11:40.133 align:middle
首先我想讲的是Metal

00:11:40.767 --> 00:11:43.437 align:middle
我们正在开发SpriteKit

00:11:43.504 --> 00:11:48.041 align:middle
并且我们正准备将它直接链接到IOS
和 Mac的Metal平台上

00:11:48.842 --> 00:11:51.311 align:middle
将能够在任何
支持Metal的设备上使用

00:11:51.378 --> 00:11:53.647 align:middle
以及那些不会自动降级
到OpenGL的设备上

00:11:54.815 --> 00:11:58.285 align:middle
这意味着你的CPU使用率会降低

00:11:58.585 --> 00:12:01.188 align:middle
这意味着作为一个开发人员
你将会得到更好的绘制调用性能

00:11:58.585 --> 00:12:01.188 align:middle
这意味着作为一个开发人员
你将会得到更好的绘制调用性能

00:12:01.255 --> 00:12:02.823 align:middle
以及更好的电池使用寿命

00:12:02.890 --> 00:12:04.658 align:middle
因为将能够做到零运动请求

00:12:10.531 --> 00:12:12.633 align:middle
我们将自动升级所有的
SpriteKit程序

00:12:12.699 --> 00:12:13.734 align:middle
你不需要重新编译

00:12:13.800 --> 00:12:15.269 align:middle
或重新提交

00:12:15.702 --> 00:12:17.538 align:middle
只要它支持Metal 你就能够运行

00:12:18.505 --> 00:12:21.041 align:middle
如果你对自定义着色器感兴趣的话

00:12:21.108 --> 00:12:22.442 align:middle
我们也同样顾及到了

00:12:23.010 --> 00:12:25.579 align:middle
如果你的游戏中有自定义着色器

00:12:25.646 --> 00:12:28.315 align:middle
我们几乎支持
所有的Metal变体的升级

00:12:28.515 --> 00:12:30.984 align:middle
同样能够在
支持Metal的设备上很好地运行

00:12:36.456 --> 00:12:37.391 align:middle
接下来是Swift

00:12:38.192 --> 00:12:39.960 align:middle
我们看了整个API的文件

00:12:40.127 --> 00:12:42.362 align:middle
并且我们向其中添加了可空性限定符

00:12:42.663 --> 00:12:45.866 align:middle
我们采用了
Objective-C泛型数组类型

00:12:45.933 --> 00:12:47.701 align:middle
用作参数或者返回类型

00:12:48.368 --> 00:12:50.504 align:middle
这将是你能够很方便的

00:12:50.571 --> 00:12:53.373 align:middle
从Swift中访问
SpriteKit的所有功能

00:12:54.408 --> 00:12:56.243 align:middle
这也能够给你的软件
提供增强版的安全性

00:12:56.310 --> 00:12:58.545 align:middle
增强版的安全性
无论你是使用Swift

00:12:59.146 --> 00:13:00.347 align:middle
还是Objective C

00:12:59.146 --> 00:13:00.347 align:middle
还是Objective C

00:13:02.049 --> 00:13:03.750 align:middle
现在我想讲一下SceneKit

00:13:03.951 --> 00:13:06.486 align:middle
或许你并不知道Scenekit

00:13:06.553 --> 00:13:09.056 align:start position:10%
我们允许你用SceneKit体现
SpriteKit

00:13:09.122 --> 00:13:10.891 align:start position:10%
也可以用SpriteKit
体现SceneKit

00:13:11.325 --> 00:13:13.894 align:middle
今年我们允许你能做到的更多一点

00:13:13.961 --> 00:13:16.463 align:middle
可以直接在
SceneKits游戏中使用

00:13:16.530 --> 00:13:18.932 align:middle
所有你知道和
你喜欢的SpriteKit过渡效果

00:13:19.933 --> 00:13:21.935 align:middle
你甚至都不需要
用SpriteKit去做

00:13:22.769 --> 00:13:26.740 align:middle
你可以像使用门一样使用这个转换器
剪辑

00:13:27.040 --> 00:13:29.710 align:middle
甚至你的SceneKit游戏中
基于转换效果的核心图片

00:13:30.177 --> 00:13:33.180 align:middle
同样能够有很好的效果

00:13:34.281 --> 00:13:36.016 align:middle
这个版本的SceneKit同样支持

00:13:36.083 --> 00:13:38.185 align:middle
Metal背景下的内容

00:13:38.886 --> 00:13:41.054 align:middle
我们可以自动匹配好

00:13:41.121 --> 00:13:43.924 align:middle
如果你有一个支持在Metal上运行
的SceneKit游戏

00:13:44.258 --> 00:13:45.425 align:middle
我们通过使用Metal

00:13:45.492 --> 00:13:47.227 align:middle
可以使你得到SpriteKit内容

00:13:47.294 --> 00:13:49.696 align:middle
去过你有一个支持GL上运行的
SceneKit游戏

00:13:49.763 --> 00:13:52.466 align:middle
我们可以通过使用OpenGL使你得
到SpriteKit

00:13:52.533 --> 00:13:54.735 align:middle
你永远不会产生额外的开销

00:13:54.801 --> 00:13:57.337 align:middle
在两个API之间进行转换时

00:14:00.207 --> 00:14:03.410 align:middle
今年我们也发布了一个全新的构架

00:14:03.610 --> 00:14:04.912 align:middle
叫做 GameplayKit

00:14:05.112 --> 00:14:06.780 align:middle
这个构架很棒

00:14:06.847 --> 00:14:09.750 align:middle
它将提供给你创建一个游戏逻辑结构所
需的所有基础

00:14:09.983 --> 00:14:12.920 align:middle
就像Entity/
Component系统一样

00:14:13.587 --> 00:14:15.088 align:middle
作为状态机

00:14:15.155 --> 00:14:18.258 align:middle
而且还提供了非常棒的工具

00:14:18.392 --> 00:14:21.528 align:middle
例如AI对手和确定性随机源

00:14:22.462 --> 00:14:24.498 align:middle
有一点我非常喜欢

00:14:24.565 --> 00:14:26.967 align:middle
那就是它能够为你的游戏
提供一个路径寻找的解决方案

00:14:27.034 --> 00:14:29.636 align:middle
我相信很多SpriteKit工程师
会对这个功能感兴趣

00:14:30.470 --> 00:14:32.506 align:middle
GameplayKit中寻路
的工作方式是

00:14:32.573 --> 00:14:34.741 align:middle
你指定一个可穿越的导航图

00:14:35.409 --> 00:14:37.644 align:middle
在你的游戏世界中

00:14:38.212 --> 00:14:41.448 align:middle
之后你将会在这些节点之间连线

00:14:41.782 --> 00:14:43.350 align:middle
并给出一个相关成本

00:14:44.618 --> 00:14:46.019 align:middle
只要你给出了这个地图

00:14:46.587 --> 00:14:48.689 align:middle
GameplayKit
将计算出地图上

00:14:48.822 --> 00:14:50.090 align:middle
这两个点之间的最优路径

00:14:50.991 --> 00:14:52.759 align:middle
我怎样在游戏中设置呢？

00:14:53.994 --> 00:14:56.263 align:middle
加入我这里
有一个SpriteKit游戏

00:14:56.330 --> 00:14:58.165 align:start position:10%
我的英雄在下面的这个角
我...嗯…

00:14:58.632 --> 00:15:01.668 align:middle
假如我想让他移动到某一个目的地

00:14:58.632 --> 00:15:01.668 align:middle
假如我想让他移动到某一个目的地

00:15:02.202 --> 00:15:05.806 align:middle
然后在我的地图上指定几个障碍物

00:15:05.873 --> 00:15:07.441 align:middle
障碍物是不可穿越的地区

00:15:07.841 --> 00:15:12.045 align:middle
将这些数据
给GameplayKit之后

00:15:12.112 --> 00:15:14.715 align:middle
给我的想要穿越地图的角色
周围设置一个缓冲半径

00:15:15.048 --> 00:15:17.684 align:middle
GameplayKit 会将
缓冲半径计算进去

00:15:17.751 --> 00:15:20.420 align:middle
自动扩展所有的障碍物

00:15:20.487 --> 00:15:22.556 align:middle
这样我们不会
进入任何障碍物的缓冲半径中

00:15:23.257 --> 00:15:25.359 align:middle
然后在地图中创建有效的连接图

00:15:25.425 --> 00:15:27.694 align:middle
并且只创建有效的连接

00:15:27.861 --> 00:15:29.863 align:middle
所以我们永远不会穿越这些障碍物

00:15:30.430 --> 00:15:33.567 align:middle
然后你就可以在你的游戏中
使用这些来进行

00:15:33.967 --> 00:15:35.035 align:middle
寻路操作

00:15:35.602 --> 00:15:37.704 align:middle
这个功能并不专属于
SpriteKit

00:15:37.771 --> 00:15:40.707 align:middle
所以你可以在SceneKit
中使用GameplayKits

00:15:40.774 --> 00:15:43.110 align:middle
SpriteKit,
OpenGL, Metal

00:15:43.177 --> 00:15:44.378 align:middle
等等任何类型的游戏都可以

00:15:45.212 --> 00:15:47.948 align:middle
如果你使用的是SpriteKit
我们可以使它变得更容易

00:15:48.015 --> 00:15:49.249 align:middle
你甚至都不需要创建障碍物

00:15:50.050 --> 00:15:53.687 align:middle
你可以使用Sprite界限
直接创建障碍物

00:15:55.422 --> 00:15:57.691 align:middle
你可以根据你在Sprite上
设置的物理主体

00:15:57.758 --> 00:16:01.261 align:middle
创建障碍物

00:15:57.758 --> 00:16:01.261 align:middle
创建障碍物

00:16:01.328 --> 00:16:03.363 align:middle
甚至从与你游戏中
Sprite相关纹理的

00:16:03.597 --> 00:16:05.999 align:start position:10%
Alpha透明度信息中创建障碍物

00:16:06.300 --> 00:16:09.203 align:middle
这给了你一种非常简单的
在SpriteKit软件中利用

00:16:09.469 --> 00:16:11.972 align:middle
GameplayKits寻路的方法

00:16:18.345 --> 00:16:19.813 align:middle
就像我之前说的

00:16:20.147 --> 00:16:22.182 align:middle
构架只是我们工作的一部分

00:16:22.649 --> 00:16:25.118 align:middle
今年我们对我们的工具进行了
大量非常棒的改进

00:16:25.185 --> 00:16:27.855 align:middle
接下来我想将这些交给Norman

00:16:27.921 --> 00:16:28.989 align:middle
来讲解

00:16:34.761 --> 00:16:35.963 align:middle
谢谢你 提姆

00:16:37.364 --> 00:16:40.467 align:middle
开发游戏是一个复杂
并且不断迭代的过程

00:16:40.934 --> 00:16:44.271 align:middle
游戏的各个部分需要
像玩游戏一样不断迭代

00:16:44.872 --> 00:16:47.474 align:middle
以保证一个游戏的趣味性

00:16:48.075 --> 00:16:50.244 align:middle
动画 用来确保一个角色移动的流畅性

00:16:50.811 --> 00:16:53.213 align:middle
艺术性 用来保证屏幕上的像素点

00:16:53.280 --> 00:16:56.049 align:middle
能够流行起来

00:16:56.250 --> 00:16:58.685 align:middle
作为一个游戏工程师
你不仅会遇到迭代问题

00:16:58.752 --> 00:17:01.522 align:middle
你还会遇到可伸缩性问题

00:16:58.752 --> 00:17:01.522 align:middle
你还会遇到可伸缩性问题

00:17:01.922 --> 00:17:05.325 align:middle
我要怎样才能跨越多个等级
复制我的设计呢？

00:17:06.292 --> 00:17:09.695 align:middle
在苹果公司我们当初启动设计
SpriteKit 的工程时

00:17:09.762 --> 00:17:13.200 align:middle
我们不仅想要为你提供
一个高性能

00:17:13.267 --> 00:17:15.435 align:middle
且易用的API

00:17:15.502 --> 00:17:18.405 align:middle
而且要为你提供
一个可伸缩和迭代的工具

00:17:18.872 --> 00:17:21.575 align:middle
这样我们就能专注于
开发游戏

00:17:22.542 --> 00:17:25.244 align:middle
从SpriteKit 构架的
第一个版本发布

00:17:25.311 --> 00:17:26.780 align:middle
我们已经开发并

00:17:26.847 --> 00:17:28.582 align:middle
持续向Xcode中

00:17:28.649 --> 00:17:30.584 align:middle
添加了多个工具

00:17:31.051 --> 00:17:34.521 align:middle
让我来给你们展示一下
作为一个SpriteKit用户

00:17:34.688 --> 00:17:36.390 align:middle
你能够使用哪些工具

00:17:37.691 --> 00:17:40.160 align:middle
第一个要介绍的是纹理地图集

00:17:41.161 --> 00:17:43.730 align:middle
使用texture atlas的
第一个主要好处就是

00:17:44.131 --> 00:17:45.866 align:middle
能够提升性能

00:17:46.767 --> 00:17:49.736 align:middle
SpriteKit通过纹理地图集将
大量的图片调用命令最小化

00:17:49.803 --> 00:17:53.106 align:middle
并发送给GPU以达到优化效率的目的

00:17:53.740 --> 00:17:57.811 align:middle
我们不想强迫我们的用户适应手动

00:17:58.145 --> 00:18:01.815 align:middle
创建这些纹理地图集的过程

00:17:58.145 --> 00:18:01.815 align:middle
创建这些纹理地图集的过程

00:18:02.549 --> 00:18:05.018 align:middle
每次对资源进行修改的时候

00:18:05.118 --> 00:18:07.487 align:middle
这些手动的过程都必须从头再来一遍

00:18:08.188 --> 00:18:10.591 align:middle
所以我们开发了一个
自动的纹理地图集生成器

00:18:10.657 --> 00:18:12.159 align:middle
在Xcode中

00:18:12.793 --> 00:18:15.195 align:middle
创建一个这种地图集

00:18:15.262 --> 00:18:17.798 align:middle
就像拖拽一个文件夹
到你的工作区中一样简单

00:18:18.699 --> 00:18:22.469 align:middle
同样的我们在开发的时候
也会自动做一些事情

00:18:22.536 --> 00:18:25.138 align:middle
每一张资源图片

00:18:25.205 --> 00:18:27.341 align:middle
都会自动经历一个复杂的后期处理过程

00:18:27.741 --> 00:18:31.912 align:middle
例如我们会为图片
修剪Alpha透明像素

00:18:32.479 --> 00:18:34.381 align:middle
但是这并不会在屏幕上有任何体现

00:18:34.915 --> 00:18:38.852 align:middle
如果旋转90度能够让这些图片更紧凑

00:18:39.353 --> 00:18:41.421 align:middle
或者能得到一个更小的地图集的话
我们会进行这样的旋转

00:18:41.989 --> 00:18:43.690 align:middle
对于每一个资源图片

00:18:43.757 --> 00:18:47.461 align:middle
我们都会对其进行其边缘的审查

00:18:47.895 --> 00:18:49.596 align:middle
如果其实完全不透明的

00:18:49.663 --> 00:18:51.398 align:middle
我们将会对其边缘进行压缩

00:18:51.465 --> 00:18:53.400 align:middle
当你在场景中堆叠这些图片时

00:18:53.467 --> 00:18:55.736 align:middle
你不会看到任何接缝

00:18:57.237 --> 00:18:59.439 align:middle
这就是纹理地图集自动生成器

00:19:00.440 --> 00:19:02.543 align:middle
今年我们将它做得更好了

00:19:03.277 --> 00:19:05.479 align:middle
现在你可以生成纹理地图集

00:19:05.546 --> 00:19:07.147 align:middle
来代替资源目录了

00:19:07.681 --> 00:19:09.116 align:middle
使用资源目录生成地图集

00:19:09.183 --> 00:19:11.919 align:middle
有两个主要好处

00:19:12.286 --> 00:19:13.153 align:middle
第一

00:19:14.087 --> 00:19:15.923 align:middle
你可以精确地

00:19:15.989 --> 00:19:18.192 align:middle
为你的目标设备

00:19:18.258 --> 00:19:19.860 align:middle
适配到合适分辨率的图片

00:19:20.427 --> 00:19:23.730 align:middle
你不需要严格
按照你的图片名字的后缀来查找

00:19:24.231 --> 00:19:28.502 align:middle
例如添加2X或者
添加2X到iphone

00:19:29.203 --> 00:19:31.538 align:middle
所有的这些都能在在UI中设计好

00:19:32.372 --> 00:19:33.640 align:middle
第二个

00:19:33.707 --> 00:19:36.343 align:middle
有点就是我们现在支持 ...

00:19:36.410 --> 00:19:37.611 align:middle
在资源目录中

00:19:38.245 --> 00:19:41.181 align:middle
每一组的目标分辨率

00:19:41.248 --> 00:19:43.851 align:middle
将会根据他们设备的独立纹理来生成

00:19:44.351 --> 00:19:45.786 align:middle
当用户打开App Store

00:19:45.853 --> 00:19:48.088 align:middle
并下载下来
你的SpriteKit授权游戏时

00:19:48.856 --> 00:19:51.124 align:middle
只有与他或她的设备

00:19:51.191 --> 00:19:53.393 align:middle
相适配的地图集才会被下载下来

00:19:54.061 --> 00:19:56.864 align:middle
这不仅能够使下载时的带宽最小

00:19:57.297 --> 00:20:01.068 align:middle
同样能够使其安装到
用户手机的时间最短

00:19:57.297 --> 00:20:01.068 align:middle
同样能够使其安装到
用户手机的时间最短

00:20:01.401 --> 00:20:04.872 align:middle
同样能够最小化应用程序的存储开销

00:20:07.241 --> 00:20:10.444 align:middle
另外 纹理地图集支持基于命令资源

00:20:10.911 --> 00:20:13.680 align:start position:10%
基于命令的资源是一个全新的API

00:20:13.981 --> 00:20:17.317 align:middle
它使你能够在游戏运行的情况下

00:20:17.384 --> 00:20:19.219 align:middle
从网上下载艺术资源流

00:20:20.053 --> 00:20:22.089 align:middle
SpriteKit也集成了这种功能

00:20:22.489 --> 00:20:24.892 align:middle
这种资源是通过标签来识别的

00:20:25.259 --> 00:20:26.126 align:middle
例如

00:20:26.193 --> 00:20:28.295 align:middle
这是我的Inspector中的Xc
ode写的背景元素

00:20:28.362 --> 00:20:32.432 align:middle
我可以指定一个与其相关联的标签

00:20:33.133 --> 00:20:35.536 align:middle
我把它叫做一级背景

00:20:35.602 --> 00:20:38.505 align:middle
这些就是标签 你可以通过这些标签

00:20:38.572 --> 00:20:40.440 align:middle
检索这个资源

00:20:40.507 --> 00:20:42.242 align:middle
并且开启背景流媒体

00:20:42.476 --> 00:20:44.044 align:middle
当你的程序调用它的时候

00:20:46.813 --> 00:20:48.348 align:middle
粒子效果

00:20:48.415 --> 00:20:50.150 align:middle
可以有效地帮助你准确的建立起游戏

00:20:52.186 --> 00:20:54.555 align:middle
我们将这个构架中的
SKEmitterNode

00:20:54.621 --> 00:20:56.924 align:middle
作为一个强大且灵活的APIs

00:20:56.990 --> 00:20:58.692 align:middle
提供给你来使用

00:20:59.593 --> 00:21:02.196 align:middle
强大并灵活也有缺点

00:20:59.593 --> 00:21:02.196 align:middle
强大并灵活也有缺点

00:21:02.763 --> 00:21:05.832 align:middle
那就是你需要设置49个属性

00:21:07.134 --> 00:21:09.069 align:middle
你需要对这49个属性

00:21:09.136 --> 00:21:11.038 align:middle
进行排列组合

00:21:11.104 --> 00:21:12.739 align:middle
来达到你想要的视觉和感觉效果

00:21:12.806 --> 00:21:15.442 align:middle
你需要做的就是花费更多的时间

00:21:16.109 --> 00:21:18.045 align:middle
因为我们在Xcode中

00:21:18.111 --> 00:21:20.314 align:middle
开发了一个粒子编辑器

00:21:20.747 --> 00:21:23.083 align:middle
它是使用同一个
SpriteKit呈现驱动

00:21:23.417 --> 00:21:25.252 align:middle
可以让你能够

00:21:25.319 --> 00:21:27.120 align:middle
在你的工作区中直观的看到它

00:21:27.754 --> 00:21:31.124 align:middle
所以你无需编写任何代码

00:21:31.491 --> 00:21:33.227 align:middle
就能够对这49个属性进行调整和改变

00:21:33.293 --> 00:21:34.995 align:middle
也无需重建你的游戏

00:21:35.863 --> 00:21:37.865 align:middle
这些粒子将作为一个
很小的数据文件导出

00:21:37.931 --> 00:21:39.800 align:middle
并能够被序列化

00:21:40.133 --> 00:21:44.671 align:middle
也能够部署在多个等级或者多个项目中

00:21:47.841 --> 00:21:50.177 align:middle
SpriteKit同样支持
Quick Look.

00:21:50.377 --> 00:21:53.180 align:middle
例如 我正在努力学习新的Swift

00:21:53.680 --> 00:21:56.617 align:middle
我创建了一个全新的场景

00:21:56.850 --> 00:21:59.987 align:middle
并努力地在
SpriteKit API中使用

00:22:00.053 --> 00:22:01.688 align:middle
全新的Swift 2.0语言

00:22:03.724 --> 00:22:06.593 align:middle
我正在做的事情就是创建一个坏蛋角色

00:22:07.261 --> 00:22:09.162 align:middle
就叫坏人 这是一个Sprite节点

00:22:09.329 --> 00:22:12.232 align:middle
它是一个叫做车罩的
单独纹理复制出来的

00:22:13.200 --> 00:22:15.702 align:middle
另外 我创建两个子节点

00:22:15.769 --> 00:22:18.839 align:middle
在这个坏人节点之下

00:22:18.906 --> 00:22:21.175 align:middle
一个有屋顶的纹理

00:22:21.675 --> 00:22:23.610 align:middle
另一个有树干的纹理

00:22:24.711 --> 00:22:25.712 align:middle
这里会发生什么呢？

00:22:26.180 --> 00:22:29.249 align:middle
SpriteKit的部分屏幕中将
会呈现这些看不见的东西

00:22:29.316 --> 00:22:31.151 align:middle
当你努力去

00:22:31.218 --> 00:22:32.753 align:middle
内观一个Sprite节点的时候

00:22:33.086 --> 00:22:36.256 align:middle
它会将结果为你呈现在窗口中

00:22:36.323 --> 00:22:39.493 align:middle
这样 你试着学习一个新的语言或者

00:22:39.560 --> 00:22:42.396 align:middle
更改一个对象的每一步都会呈现出来

00:22:42.796 --> 00:22:45.599 align:middle
你将会在窗口中看到实时的变化

00:22:47.534 --> 00:22:49.002 align:middle
另外SpriteKit中
的Quicklook

00:22:49.369 --> 00:22:50.737 align:middle
同样支持

00:22:50.804 --> 00:22:52.539 align:middle
在你调试程序的时候

00:22:52.606 --> 00:22:54.274 align:middle
无论你是使用Swift

00:22:54.842 --> 00:22:56.143 align:middle
还是Objective-C

00:22:56.210 --> 00:22:57.978 align:middle
无论他们是在IOS设备上运行

00:22:58.278 --> 00:22:59.580 align:middle
还是在Mac OS X上运行

00:23:00.447 --> 00:23:03.951 align:middle
这里我想试着去调试一个我写的程序

00:23:05.052 --> 00:23:06.353 align:middle
我触发了一个断点

00:23:06.420 --> 00:23:08.856 align:middle
目标过程其实停止了

00:23:09.223 --> 00:23:10.591 align:middle
但是我们仍然能够

00:23:10.958 --> 00:23:14.094 align:middle
隐藏这部分显示
并呈现出目前的纹理

00:23:14.695 --> 00:23:15.929 align:middle
并在调试器中显示出来

00:23:16.363 --> 00:23:18.432 align:middle
所以你能够清楚地知道

00:23:18.498 --> 00:23:20.767 align:middle
这个纹理是我之前调试的

00:23:20.834 --> 00:23:23.403 align:middle
并将它抓取出来分配给了
一个SKSpriteNode

00:23:26.440 --> 00:23:29.743 align:middle
去年 IOS
8中我们发布了一个虚拟场景编辑器

00:23:29.810 --> 00:23:32.813 align:middle
他允许你建立一个完整的场景布局

00:23:32.880 --> 00:23:34.114 align:middle
并不需要编写任何代码

00:23:38.018 --> 00:23:41.588 align:middle
你不仅可以设置场景中每一个

00:23:41.655 --> 00:23:43.991 align:middle
可选节点的位置 旋转和尺度

00:23:44.391 --> 00:23:47.761 align:middle
你同样可以定义其物理属性例如

00:23:47.828 --> 00:23:51.498 align:middle
图片 重力 质量和摩擦

00:23:53.166 --> 00:23:55.769 align:middle
你也可以进行这些物理仿真的

00:23:56.203 --> 00:23:59.072 align:middle
实时模拟

00:23:59.139 --> 00:24:01.642 align:middle
而这些并不需要你登陆游戏
或者重新编译你的程序

00:23:59.139 --> 00:24:01.642 align:middle
而这些并不需要你登陆游戏
或者重新编译你的程序

00:24:03.110 --> 00:24:06.880 align:middle
SpriteKit也将支持
一些先进的渲染技术

00:24:06.947 --> 00:24:08.081 align:middle
例如自定义着色器等

00:24:08.782 --> 00:24:12.853 align:middle
在这一层上 这个瀑布的背景和

00:24:12.920 --> 00:24:15.322 align:middle
雾的底部实际上我使用了

00:24:15.389 --> 00:24:16.256 align:middle
两个自定义着色器

00:24:16.723 --> 00:24:20.060 align:middle
要添加着色器

00:24:20.561 --> 00:24:22.829 align:middle
他就像打开帮助编辑器一样简单

00:24:22.963 --> 00:24:25.065 align:middle
它会自动在你的当前场景中显示出来

00:24:25.632 --> 00:24:27.601 align:middle
当然这是渲染过后的

00:24:27.668 --> 00:24:30.070 align:middle
并向你展示附有源代码的

00:24:30.137 --> 00:24:31.138 align:middle
助理编辑器

00:24:31.538 --> 00:24:32.606 align:middle
你在助理编辑器中

00:24:32.673 --> 00:24:34.208 align:middle
所做的任何实时的修改

00:24:34.274 --> 00:24:35.909 align:middle
都会自动进行编译

00:24:35.976 --> 00:24:38.011 align:middle
打开OpenGL或者Metal

00:24:38.412 --> 00:24:41.648 align:middle
会为你提供一个真正实时的视窗

00:24:42.015 --> 00:24:44.418 align:middle
而不是都建整个游戏

00:24:44.952 --> 00:24:46.086 align:middle
跨越整个层

00:24:46.587 --> 00:24:48.589 align:middle
以及特定的节点

00:24:48.889 --> 00:24:52.359 align:middle
触发这个事件来确定我是否真的发送了
一个流给OpenGL或者Metal

00:24:52.426 --> 00:24:54.294 align:middle
无论是否编译成功

00:24:54.661 --> 00:24:56.396 align:middle
这将节省很多迭代的时间

00:24:58.398 --> 00:25:00.901 align:middle
今年我们花了大量的时间来

00:24:58.398 --> 00:25:00.901 align:middle
今年我们花了大量的时间来

00:25:00.968 --> 00:25:02.569 align:middle
对虚拟场景编辑器进行改进升级

00:25:02.636 --> 00:25:05.239 align:middle
第一个请求的类型是自定义的

00:25:06.273 --> 00:25:09.710 align:middle
现在 在我的英雄角色所处的这一层

00:25:10.344 --> 00:25:12.379 align:middle
我可以将它指定为一个类

00:25:12.446 --> 00:25:14.615 align:middle
这个类的名字叫做角色类

00:25:16.149 --> 00:25:18.652 align:middle
当场景被反序列化运行时

00:25:19.019 --> 00:25:22.489 align:middle
无论你的程序是用Objective
-C还是用Swift写的

00:25:23.957 --> 00:25:26.860 align:middle
正确的类将会被创建并实例化

00:25:27.494 --> 00:25:30.998 align:middle
并加载到场景中 在场景运行的时候

00:25:32.900 --> 00:25:34.434 align:middle
另外

00:25:35.869 --> 00:25:38.505 align:middle
从SKNodes项目开始的第一天起

00:25:38.572 --> 00:25:41.141 align:middle
我们就一直忙于它的支撑工作

00:25:41.575 --> 00:25:44.077 align:middle
现在你能够使用编辑其中的

00:25:44.144 --> 00:25:45.012 align:middle
镜头节点

00:25:45.379 --> 00:25:46.647 align:middle
音频节点定位

00:25:47.014 --> 00:25:48.549 align:middle
以及Referenc
eNode

00:25:48.615 --> 00:25:50.150 align:middle
来设计你的场景

00:25:50.617 --> 00:25:53.453 align:middle
能够在编辑器中看到镜头发送

00:25:53.520 --> 00:25:55.989 align:middle
准确的时间轴、缩放因子

00:25:56.056 --> 00:25:57.391 align:middle
以及动作

00:25:57.457 --> 00:25:59.092 align:middle
而并不需要

00:25:59.927 --> 00:26:01.528 align:middle
编译整个游戏是多么酷炫的一件事

00:25:59.927 --> 00:26:01.528 align:middle
编译整个游戏是多么酷炫的一件事

00:26:02.095 --> 00:26:03.363 align:middle
你也可以

00:26:03.430 --> 00:26:06.200 align:middle
设置SKAudioNode的位置

00:26:06.700 --> 00:26:08.302 align:middle
并将之移动

00:26:08.368 --> 00:26:10.304 align:middle
来亲自听实时的音效变化

00:26:11.104 --> 00:26:14.174 align:middle
以确定你在场景中
想要的效果是否设置正确

00:26:16.710 --> 00:26:20.013 align:middle
今年 前端工具中最激动人心的功能是

00:26:20.080 --> 00:26:21.348 align:middle
能够设计

00:26:21.415 --> 00:26:23.083 align:middle
复杂的动作

00:26:23.951 --> 00:26:26.653 align:middle
你可以通过基础构建模块

00:26:27.054 --> 00:26:28.789 align:middle
设计出一个非常复杂的动作

00:26:28.856 --> 00:26:32.192 align:middle
我们已经将其作为SpriteKit
的动作部分提供给了大家

00:26:33.961 --> 00:26:35.629 align:middle
它是基于时间线的

00:26:36.129 --> 00:26:39.633 align:middle
和Xcode中的其他编辑器一样

00:26:40.133 --> 00:26:42.369 align:middle
他也支持实时可视化

00:26:43.370 --> 00:26:44.905 align:middle
你不仅可以

00:26:44.972 --> 00:26:47.107 align:middle
用它来开发2D动作

00:26:47.808 --> 00:26:50.110 align:middle
也可以用来为
SceneKit设计3D动画

00:26:50.277 --> 00:26:52.713 align:middle
都是同样的编辑器

00:26:53.814 --> 00:26:56.216 align:middle
你也可以创建电影动画

00:26:56.750 --> 00:26:59.553 align:middle
电影动画可以作为场景动画的一部分

00:26:59.620 --> 00:27:02.623 align:middle
当场景加载的时候
任何包含这种动作的节点

00:26:59.620 --> 00:27:02.623 align:middle
当场景加载的时候
任何包含这种动作的节点

00:27:02.689 --> 00:27:05.325 align:middle
都会自动运行起来

00:27:06.627 --> 00:27:09.596 align:middle
你也可以创建交互式动画

00:27:10.063 --> 00:27:11.365 align:middle
例如循环动画

00:27:11.698 --> 00:27:14.535 align:middle
或者跳转动画
从窗台掉落

00:27:15.636 --> 00:27:19.006 align:middle
通过一行或两行代码出发折叠动画

00:27:19.940 --> 00:27:21.375 align:middle
在不同的游戏场景中

00:27:25.546 --> 00:27:27.181 align:middle
这里有一个场景

00:27:27.247 --> 00:27:28.916 align:middle
我将镜头设计为移动的

00:27:28.982 --> 00:27:30.384 align:middle
现在锁定游戏角色

00:27:30.450 --> 00:27:32.052 align:middle
角色开始运动

00:27:32.119 --> 00:27:33.654 align:middle
运行行走动作循环

00:27:33.720 --> 00:27:35.656 align:middle
穿越整个场景 这就是开场

00:27:35.722 --> 00:27:38.625 align:middle
你也可以在五分钟之完成这些

00:27:42.529 --> 00:27:45.432 align:middle
今年2D和3D的前端工具中

00:27:45.499 --> 00:27:48.035 align:middle
另一个主要关注点就是

00:27:48.101 --> 00:27:50.537 align:middle
能够做引用和实例化

00:27:51.438 --> 00:27:53.307 align:middle
在SpriteKit上

00:27:53.373 --> 00:27:56.643 align:middle
一直是支持对动作或节点的引用

00:27:56.944 --> 00:28:00.280 align:middle
这些都是你场景中的艺术资源

00:27:56.944 --> 00:28:00.280 align:middle
这些都是你场景中的艺术资源

00:28:01.381 --> 00:28:03.050 align:middle
这些都是可重复使用的组件

00:28:03.150 --> 00:28:05.385 align:middle
这些都是数据文件

00:28:05.652 --> 00:28:07.621 align:middle
能够在不同的工程中

00:28:07.888 --> 00:28:10.057 align:middle
不同的人之间 不同的层次上共享

00:28:10.924 --> 00:28:12.359 align:middle
在使用这些引用文件时

00:28:12.426 --> 00:28:14.127 align:middle
你不需要写任何代码

00:28:16.930 --> 00:28:19.399 align:middle
创建引用动画非常简单

00:28:19.733 --> 00:28:24.171 align:middle
我们在Xcode中提供一种
全新的SK动作文件模板

00:28:24.238 --> 00:28:27.074 align:middle
你可以打包一个纯粹的动画文件

00:28:27.474 --> 00:28:30.143 align:middle
设计好所有的复杂的动画

00:28:30.210 --> 00:28:31.144 align:middle
将之命名

00:28:31.478 --> 00:28:34.781 align:middle
使这些动作可以
被SKAction检索

00:28:34.848 --> 00:28:36.550 align:middle
使用actionNamed选择器

00:28:37.017 --> 00:28:39.253 align:middle
创建正确的实例
并将之添加到你的场景中

00:28:40.020 --> 00:28:44.224 align:middle
任何引用的动作
都将会被自动筛选出来

00:28:44.291 --> 00:28:46.226 align:middle
放到一个对象库中

00:28:46.360 --> 00:28:48.629 align:middle
如果你想在不同的场景中

00:28:48.695 --> 00:28:50.931 align:middle
或者不同的层中

00:28:50.998 --> 00:28:54.034 align:middle
再次使用这些动作 这只是一个

00:28:54.101 --> 00:28:55.169 align:middle
从对象库中拖放的问题

00:28:56.770 --> 00:28:59.406 align:middle
创建一个引用节点也很简单

00:29:00.807 --> 00:29:04.211 align:middle
就像在你的工作区中拖一个SKS文件

00:29:04.278 --> 00:29:06.680 align:middle
放到你的场景中一样简单

00:29:07.681 --> 00:29:08.882 align:middle
对于这些引用

00:29:08.949 --> 00:29:10.551 align:middle
我们会自动在编辑器中

00:29:10.617 --> 00:29:12.553 align:middle
生成SKReferenceNode
实例

00:29:12.786 --> 00:29:14.621 align:middle
并为你分配合适的URL

00:29:16.223 --> 00:29:19.893 align:middle
你同样可以使用API创建
一个自定义节点收藏夹

00:29:20.394 --> 00:29:22.629 align:middle
例如 我有一个鸟笼

00:29:22.696 --> 00:29:24.231 align:middle
我打算用它作为一个

00:29:24.298 --> 00:29:26.633 align:middle
不同的层之间的层道具

00:29:26.700 --> 00:29:28.802 align:middle
我可以在多个层之间建立起来

00:29:28.869 --> 00:29:31.305 align:middle
并将其实例化

00:29:31.371 --> 00:29:33.941 align:middle
任何对鸟笼原设计的修改

00:29:34.007 --> 00:29:36.443 align:middle
都会被自动地反映到

00:29:36.510 --> 00:29:39.146 align:middle
每一个引用了这个设计的实例中

00:29:42.115 --> 00:29:45.619 align:middle
这样你就能够在编辑器中手动地

00:29:45.686 --> 00:29:48.522 align:middle
修改和更新引用文件了

00:29:50.757 --> 00:29:54.928 align:middle
接下来
我想邀请泰勒上台来给大家

00:29:55.062 --> 00:29:56.964 align:middle
演示一下Xcode中的这些新功能

00:30:03.136 --> 00:30:04.004 align:middle
谢谢你诺曼

00:30:04.071 --> 00:30:04.905 align:middle
就像你看到的那样

00:30:04.972 --> 00:30:07.941 align:middle
我们为SpriteKit和
Xcode 7增加了很多优秀的功能

00:30:08.008 --> 00:30:09.543 align:middle
我想通过展示一个简单地例子向

00:30:09.610 --> 00:30:12.112 align:middle
你们展示它们是如何
在你的开发流中集成工作的

00:30:12.179 --> 00:30:15.249 align:middle
这个例子展示了创建一个简单的层
添加场景

00:30:15.582 --> 00:30:17.351 align:middle
创建一些互动的游戏等内容

00:30:22.189 --> 00:30:25.459 align:middle
好的
看这里 我刚刚创建了一个游戏工程

00:30:25.526 --> 00:30:28.529 align:middle
我在这个工程中添加了一个层

00:30:28.595 --> 00:30:31.565 align:middle
我们创建了一些平台和一个角色

00:30:32.065 --> 00:30:35.669 align:middle
我想做的第一件事就是在其中创建环境

00:30:35.903 --> 00:30:39.072 align:middle
添加一些背景和前景元素

00:30:39.640 --> 00:30:42.409 align:middle
放在从前
我会直接在场景中做这些事情

00:30:42.476 --> 00:30:45.512 align:middle
然后一个个复制我所需要的实例

00:30:45.913 --> 00:30:48.615 align:middle
如果我需要修改一些东西的话
这很快就会变得非常麻烦

00:30:48.682 --> 00:30:51.018 align:middle
因为我需要对非常多不同的点进行修改

00:30:51.318 --> 00:30:52.519 align:middle
并且很难重复使用

00:30:52.586 --> 00:30:54.388 align:middle
现在我们用
ReferenceNode

00:30:54.454 --> 00:30:55.522 align:middle
解决了这个问题

00:30:56.190 --> 00:30:58.659 align:middle
所以在这里我创建了我的环境中

00:30:58.725 --> 00:31:00.861 align:middle
所需要的所有的元素并
将其放在单独的文件中

00:30:58.725 --> 00:31:00.861 align:middle
所需要的所有的元素并
将其放在单独的文件中

00:31:01.094 --> 00:31:03.564 align:middle
这样我就得到了一个有瀑布的背景

00:31:03.630 --> 00:31:05.632 align:middle
和一个有雾气效果的前景

00:31:06.400 --> 00:31:08.101 align:middle
引用这些内容文件所需要进行的操作

00:31:08.168 --> 00:31:10.838 align:middle
就是将其拖放到我的层中

00:31:11.238 --> 00:31:13.373 align:middle
现在 我们自动创建一个

00:31:13.574 --> 00:31:16.276 align:middle
包含所有元素的Reference
Node你会注意到

00:31:16.343 --> 00:31:18.745 align:middle
前景的Z值被保留了下来

00:31:18.812 --> 00:31:20.447 align:middle
当我们将它添加到我的场景中的时候

00:31:21.215 --> 00:31:23.684 align:middle
接下来创建一些复制来填充起来这一层

00:31:23.750 --> 00:31:26.653 align:middle
你会注意到
我复制了ReferenceNode

00:31:26.720 --> 00:31:28.322 align:middle
其本身

00:31:28.589 --> 00:31:31.191 align:middle
而不是我所引用的场景中的

00:31:31.325 --> 00:31:33.260 align:middle
单独的元素

00:31:33.894 --> 00:31:37.297 align:middle
这在我之后的工程中会显得很棒

00:31:37.598 --> 00:31:39.900 align:middle
例如 当我想要跟换背景纹理时

00:31:39.967 --> 00:31:41.168 align:middle
因为它并不是特别合适

00:31:41.235 --> 00:31:43.003 align:middle
我做的这个平台

00:31:43.070 --> 00:31:45.772 align:middle
我不需要改变我现有的三个实例

00:31:46.139 --> 00:31:48.141 align:middle
我可以打开我单独的资源

00:31:48.475 --> 00:31:50.677 align:middle
只需要做一次修改

00:31:51.512 --> 00:31:53.213 align:middle
改动的地方就会自动送给所有的实例

00:31:53.280 --> 00:31:55.249 align:middle
在这个层中

00:32:01.154 --> 00:32:01.989 align:middle
接下来

00:32:02.055 --> 00:32:03.790 align:middle
我想在我的层中创建一个跳转场景

00:32:03.857 --> 00:32:07.060 align:middle
我会使用我们刚才介绍的

00:32:07.261 --> 00:32:08.195 align:middle
新的动作编辑器来做

00:32:08.562 --> 00:32:10.764 align:middle
放在从前 你只能在代码中创建动作

00:32:10.831 --> 00:32:13.467 align:middle
这非常不容易看到

00:32:13.534 --> 00:32:16.637 align:middle
所以我们想要开发一中编辑器
能够很容易的创建复杂的动作

00:32:16.703 --> 00:32:19.072 align:middle
并给你实时的

00:32:19.139 --> 00:32:20.140 align:middle
你正在创建的图像信息

00:32:20.774 --> 00:32:22.309 align:middle
访问动作编辑器

00:32:22.376 --> 00:32:23.944 align:middle
你可以点击左下角的按钮

00:32:24.011 --> 00:32:26.246 align:middle
你会看到显示出来

00:32:26.313 --> 00:32:29.082 align:middle
你的场景中的所有节点以及时间轴

00:32:29.149 --> 00:32:30.884 align:middle
其中包含所有的动作

00:32:31.251 --> 00:32:33.353 align:middle
我们能够看到我们的角色
已经有了一个动作

00:32:33.420 --> 00:32:35.122 align:middle
这是一个由纹理动作组成的动画

00:32:35.656 --> 00:32:37.357 align:middle
我们将它放在一个空闲的帧内

00:32:37.491 --> 00:32:38.759 align:middle
现在点击播放

00:32:39.026 --> 00:32:41.862 align:middle
我们可以看到我们的角色
在我们的场景中

00:32:42.162 --> 00:32:42.996 align:middle
动了起来

00:32:43.964 --> 00:32:46.300 align:middle
接下来
在我们的层中创建一个跳转场景

00:32:46.366 --> 00:32:49.269 align:middle
我们准备让角色穿过这一层

00:32:50.103 --> 00:32:51.939 align:middle
要做到这些

00:32:52.005 --> 00:32:54.174 align:middle
我们需要过滤出来
我们的玩家互动编辑器和

00:32:54.975 --> 00:32:57.511 align:middle
我们的对象库中的动作

00:32:57.711 --> 00:33:01.215 align:middle
我们为你提供了一组动作构件

00:32:57.711 --> 00:33:01.215 align:middle
我们为你提供了一组动作构件

00:33:01.281 --> 00:33:02.983 align:middle
可以用来创建更加复杂的动作

00:33:03.050 --> 00:33:04.651 align:middle
这正是我接下来要做到的事情

00:33:05.052 --> 00:33:07.054 align:middle
我们首先添加一个移动的动作

00:33:07.120 --> 00:33:08.155 align:middle
到我们的跳转场景中

00:33:08.222 --> 00:33:10.958 align:middle
我需要做的所有事情就是拖放
从对象库拖放到时间轴中

00:33:11.992 --> 00:33:13.260 align:middle
现在对于这个运动

00:33:13.327 --> 00:33:16.196 align:middle
我们可以看到在X方向上有850个单
位组成

00:33:16.263 --> 00:33:18.165 align:middle
我们想要将这个动作做得更缓慢更自然

00:33:18.565 --> 00:33:20.033 align:middle
现在点击这个播放

00:33:20.100 --> 00:33:22.236 align:middle
我们可以看到我们的角色是这样跑的

00:33:22.569 --> 00:33:24.605 align:middle
这有点快
所以我们需要修改持续的时间

00:33:24.671 --> 00:33:27.441 align:middle
将这个动作拖长大概2秒

00:33:27.741 --> 00:33:29.276 align:middle
我想要调整一下时间轴

00:33:29.843 --> 00:33:30.777 align:middle
所以现在运行一下

00:33:30.844 --> 00:33:32.513 align:middle
这时的运动就有了一个更合理的速率

00:33:33.780 --> 00:33:37.251 align:middle
现在我想让角色
在穿越屏幕的时候跑起来

00:33:37.317 --> 00:33:39.520 align:middle
所以我要添加一个带有纹理动作的动画

00:33:40.320 --> 00:33:42.823 align:middle
要定义我们准备使用的动画

00:33:42.990 --> 00:33:45.359 align:middle
我可以打开媒体库

00:33:45.425 --> 00:33:46.760 align:middle
过滤下来我们的奔跑的框架

00:33:47.327 --> 00:33:49.897 align:middle
我可以选择之后将其简单地
拖动到我们的运动中

00:33:50.397 --> 00:33:51.298 align:middle
现在我们运行一下

00:33:52.332 --> 00:33:55.002 align:middle
可以看到角色将会做这个动作

00:33:55.402 --> 00:33:58.005 align:middle
当然 如果我们只使用一次的话

00:33:58.071 --> 00:34:00.407 align:middle
我们可以添加一个循环

00:33:58.071 --> 00:34:00.407 align:middle
我们可以添加一个循环

00:34:00.474 --> 00:34:01.475 align:middle
这样就能在其移动的整个
时间段中持续下来

00:34:01.542 --> 00:34:03.844 align:middle
我可以点击角落里的
这个循环按钮创建一个循环

00:34:03.911 --> 00:34:05.212 align:middle
我能够看到

00:34:05.279 --> 00:34:06.647 align:middle
循环的所有控制参数

00:34:06.947 --> 00:34:10.350 align:middle
我可以增加迭代的次数

00:34:10.417 --> 00:34:11.784 align:middle
也可以减少 也可以自定义循环

00:34:12.186 --> 00:34:14.454 align:middle
在这个例子中我想要让它循环两次

00:34:14.521 --> 00:34:16.822 align:middle
接下来我将调整一下持续时间
来适应我们的运动过程

00:34:17.024 --> 00:34:19.426 align:middle
现在我们就得到了我们的角色
跑着穿越整个场景的动画

00:34:20.360 --> 00:34:22.862 align:middle
接下来 我们在层中添加两个沟

00:34:22.929 --> 00:34:24.565 align:middle
让这个角色跳过它们

00:34:24.630 --> 00:34:30.003 align:middle
在动作编辑器中我们可以
定向清除我们动作中的时间点

00:34:30.070 --> 00:34:33.806 align:middle
在刚刚到达沟的旁边的时候
我可以清除掉

00:34:33.940 --> 00:34:35.876 align:middle
然后添加一个其他的动作

00:34:36.342 --> 00:34:38.045 align:middle
我们可以正好对齐我们刚才擦除的地方

00:34:39.913 --> 00:34:43.350 align:middle
对于这个移动
我们会在Y轴方向移动100个单位

00:34:43.417 --> 00:34:44.885 align:middle
我将其设置成缓慢输出

00:34:45.351 --> 00:34:47.688 align:middle
这样在到达我们跳跃的顶部的时候
角色的动作会变慢

00:34:48.422 --> 00:34:51.225 align:middle
在到达沟的中间的时候
我会再做一次擦除

00:34:51.291 --> 00:34:53.360 align:middle
调整一下持续时间 使角色能够在

00:34:53.427 --> 00:34:56.063 align:middle
达到最高点的时候刚好到达沟的中间

00:34:56.797 --> 00:35:00.734 align:middle
然后复制我们动作的第一部分
然后翻转

00:34:56.797 --> 00:35:00.734 align:middle
然后复制我们动作的第一部分
然后翻转

00:35:00.901 --> 00:35:02.903 align:middle
得到一个完整的跳跃运动

00:35:03.871 --> 00:35:05.405 align:middle
跳跃的最后一步

00:35:05.472 --> 00:35:07.741 align:middle
我准备再创建一个动画

00:35:07.808 --> 00:35:11.011 align:middle
包含跳跃的构架

00:35:11.078 --> 00:35:14.081 align:middle
同样的方法
打开媒体库 过滤下来我们的跳跃构架

00:35:14.147 --> 00:35:15.282 align:middle
添加到动作中

00:35:16.316 --> 00:35:18.919 align:middle
现在我们的角色就能够
从第一个沟上面跳过去

00:35:20.354 --> 00:35:23.257 align:middle
当然 我们还有一个沟

00:35:23.323 --> 00:35:25.826 align:middle
我需要做的就是复制我刚刚添加的动作

00:35:25.893 --> 00:35:28.629 align:middle
然后替换
但是接下来我们会碰到同样的问题

00:35:28.695 --> 00:35:31.031 align:middle
那就是在地图上的哪里进行修改

00:35:31.098 --> 00:35:33.767 align:middle
我将要对每一个复制的实例进行修改

00:35:34.101 --> 00:35:37.037 align:middle
很可能我会在不同的层中

00:35:37.104 --> 00:35:38.005 align:middle
重复使用这些动作

00:35:38.071 --> 00:35:39.740 align:middle
甚至可能在不同的工程中

00:35:40.374 --> 00:35:41.875 align:middle
我们用同样的方式解决了这个问题

00:35:41.942 --> 00:35:44.077 align:middle
就是允许你引用运动

00:35:44.411 --> 00:35:46.647 align:middle
我们在Xcode中引入一个新文件

00:35:46.813 --> 00:35:48.615 align:middle
这是一个
SpriteKit动作文件夹

00:35:49.416 --> 00:35:51.251 align:middle
这个文件夹中放了一些动作文件

00:35:51.318 --> 00:35:53.086 align:middle
这些动作文件的名字

00:35:53.153 --> 00:35:55.822 align:middle
你可以在场景、工程或者代码中
全局引用

00:35:56.290 --> 00:35:57.824 align:middle
接下来 选定动作文件

00:35:58.225 --> 00:36:00.594 align:middle
创建一个这样的文件夹

00:35:58.225 --> 00:36:00.594 align:middle
创建一个这样的文件夹

00:36:00.661 --> 00:36:01.762 align:middle
并将其转换成引用的形式

00:36:02.162 --> 00:36:04.798 align:middle
我准备给它命名 将其命名为跳跃

00:36:05.232 --> 00:36:07.367 align:middle
我们可以选择一个动作文件夹放进去

00:36:07.434 --> 00:36:09.336 align:middle
在这个例子中
我会新建一个新的文件夹

00:36:10.871 --> 00:36:13.674 align:middle
我给这个文件夹命名为角色动作

00:36:13.740 --> 00:36:16.376 align:middle
因为我打算将所有的跟角色有关的动作
都放进这个文件夹

00:36:17.911 --> 00:36:19.479 align:middle
将这个文件添加到我们的工程

00:36:19.546 --> 00:36:21.982 align:middle
现在你会看到我们创建的这些动作

00:36:22.049 --> 00:36:24.418 align:middle
例如跳跃已经在跳跃文件夹的下面了

00:36:24.818 --> 00:36:25.919 align:middle
并且在我们的场景中

00:36:26.620 --> 00:36:28.622 align:middle
我们可以引用
这些动作

00:36:29.690 --> 00:36:31.225 align:middle
现在你放到这个文件夹中的动作

00:36:31.291 --> 00:36:33.360 align:middle
已经完全从所有的场景
或者工程中独立了出来

00:36:33.427 --> 00:36:35.195 align:middle
但是在一些场景中某些背景下

00:36:35.262 --> 00:36:36.897 align:middle
你经常会想要修改他们

00:36:37.431 --> 00:36:39.533 align:middle
我们允许你设置一个预览窗口

00:36:39.600 --> 00:36:42.469 align:middle
你可以分配你文件夹中的任何动作
在你的场景中的任何节点

00:36:42.536 --> 00:36:45.372 align:middle
例如我可以在这个场景中的任何节点预
览我 的跳跃动作

00:36:45.572 --> 00:36:46.874 align:middle
或者打开一个自己的场景

00:36:46.940 --> 00:36:48.709 align:middle
在角色的不同角度

00:36:48.976 --> 00:36:51.979 align:middle
例如 我可以预览角色左边或者

00:36:52.045 --> 00:36:55.115 align:middle
右边跳跃动作是怎样的

00:36:56.984 --> 00:36:59.119 align:middle
所以现在 在这里 我们继续

00:36:59.186 --> 00:37:02.623 align:middle
回到擦除第二个沟的地方 在对象库中

00:36:59.186 --> 00:37:02.623 align:middle
回到擦除第二个沟的地方 在对象库中

00:37:02.689 --> 00:37:04.391 align:middle
我们可以用可以引用的动作

00:37:04.458 --> 00:37:05.792 align:middle
自动填充进去

00:37:05.893 --> 00:37:08.929 align:middle
因为我刚才创建的跳跃动作

00:37:08.996 --> 00:37:11.565 align:middle
已经自动放在了对象库中
我就能够将它拖放进去

00:37:11.899 --> 00:37:14.101 align:middle
现在我们就完成了我们的跳转场景
让我们欣赏一下

00:37:16.937 --> 00:37:17.838 align:middle
看起来很棒

00:37:18.372 --> 00:37:20.607 align:middle
现在我想向你展示一下
怎样在代码中使用

00:37:20.674 --> 00:37:23.143 align:middle
而不仅仅是一个跳转场景

00:37:23.844 --> 00:37:26.446 align:middle
我想要做的就是在每一个角色
可能存在的地图中

00:37:26.513 --> 00:37:29.983 align:middle
都创建一个动作 然后通过代码引用它

00:37:31.051 --> 00:37:33.654 align:middle
我要创建一个引用

00:37:33.720 --> 00:37:35.355 align:middle
这个可引用的动作叫跑

00:37:35.489 --> 00:37:36.523 align:middle
其中包含我们动画

00:37:37.090 --> 00:37:38.992 align:middle
我也同样对对空文件这么处理

00:37:41.061 --> 00:37:42.129 align:middle
现在开始 删除这些

00:37:42.196 --> 00:37:44.364 align:middle
因为现在我们要把这些做成交互式的

00:37:44.698 --> 00:37:45.933 align:middle
现在你可以看到

00:37:45.999 --> 00:37:48.101 align:middle
我们的动作文件夹中

00:37:48.168 --> 00:37:50.270 align:middle
包含了三个地图

00:37:50.671 --> 00:37:52.573 align:middle
现在通过代码使用这些动作

00:37:52.639 --> 00:37:54.641 align:middle
你所要做的就是使用
我们刚才介绍的新选择器

00:37:54.975 --> 00:37:57.010 align:middle
动作名称选择器

00:37:57.077 --> 00:37:58.946 align:middle
给它们提供我们刚刚创建的动作的名称

00:37:59.279 --> 00:38:00.981 align:middle
空 跑 和跳跃

00:37:59.279 --> 00:38:00.981 align:middle
空 跑 和跳跃

00:38:01.682 --> 00:38:04.451 align:middle
现在当我运行我们的游戏时

00:38:04.518 --> 00:38:07.354 align:middle
你能够看到我刚才创建的动作
现在正在游戏中使用着

00:38:08.188 --> 00:38:09.022 align:middle
交互式的

00:38:09.857 --> 00:38:11.792 align:middle
这一点最强大的地方在于

00:38:11.859 --> 00:38:12.960 align:middle
当你想要修改你的动作时

00:38:13.026 --> 00:38:14.928 align:middle
我可以直接打开动作文件夹

00:38:14.995 --> 00:38:18.065 align:middle
例如 让角色在跳跃的时候翻个筋斗

00:38:18.131 --> 00:38:22.636 align:middle
我可以打开这里
然后添加一个旋转的动作到跳跃上

00:38:23.337 --> 00:38:26.406 align:middle
给它赋值负360 缓进缓出

00:38:27.007 --> 00:38:30.143 align:middle
现在我们不编译就运行我们的游戏

00:38:30.544 --> 00:38:32.212 align:middle
我们可以看到发生了改变

00:38:32.279 --> 00:38:33.981 align:middle
我刚做的修改已经提交给了角色

00:38:41.154 --> 00:38:42.723 align:middle
现在这一层看起来已经很棒了

00:38:42.789 --> 00:38:45.225 align:middle
所以最后要做的事情就是
创建一个漂亮的电影动画开场

00:38:45.325 --> 00:38:47.060 align:middle
将角色引入到这一层

00:38:47.494 --> 00:38:51.698 align:middle
我可以通过创建一个SKCamera
Node到场景中的方式实现

00:38:52.199 --> 00:38:54.968 align:middle
让我们在镜头节点中
定义一个Viewport

00:38:55.135 --> 00:38:57.104 align:middle
我们可以开始使用我刚添加的镜头

00:38:57.304 --> 00:38:59.306 align:middle
来分配我们的场景

00:39:00.174 --> 00:39:02.643 align:middle
作为电影动画开场
我想用从这个角落开始

00:39:02.709 --> 00:39:05.512 align:middle
使用镜头放大

00:39:10.450 --> 00:39:12.252 align:middle
我准备放大这里的雾气

00:39:12.719 --> 00:39:15.389 align:middle
最棒的是
因为这只是一个SKNode

00:39:15.455 --> 00:39:16.590 align:middle
我可以向镜头中添加动作

00:39:17.191 --> 00:39:19.159 align:middle
过滤下来适应我们的镜头

00:39:20.260 --> 00:39:21.929 align:middle
之后添加一个有两个动作的移动

00:39:22.262 --> 00:39:24.698 align:middle
我准备要做的电影动画开场

00:39:24.765 --> 00:39:26.433 align:middle
就是讲镜头平移到这一层的中心

00:39:26.600 --> 00:39:28.001 align:middle
同时缩放

00:39:28.535 --> 00:39:30.571 align:middle
第二步我将要把X轴的值

00:39:30.637 --> 00:39:33.841 align:middle
设置为507
作为中 心

00:39:35.042 --> 00:39:37.177 align:middle
同时将Y轴的值设置为
384个单位并作为中心

00:39:37.244 --> 00:39:39.513 align:middle
并将这些设置为

00:39:39.580 --> 00:39:40.881 align:middle
缓进缓出

00:39:41.782 --> 00:39:44.184 align:middle
我打算在我们打开我们的场景半秒钟后

00:39:44.251 --> 00:39:46.019 align:middle
开始移动我们的动画

00:39:46.086 --> 00:39:48.455 align:middle
并耗时3秒将其平移过去

00:39:48.922 --> 00:39:52.893 align:middle
同样我添加了第二个动作
并给其半秒钟从我们的动画中抵消

00:39:52.960 --> 00:39:57.631 align:middle
在动画结束后同时结束

00:39:58.031 --> 00:39:59.333 align:middle
现在 在短短时间内

00:39:59.399 --> 00:40:01.001 align:middle
我们创建了一个电影动画式的开场

00:39:59.399 --> 00:40:01.001 align:middle
我们创建了一个电影动画式的开场

00:40:01.134 --> 00:40:02.236 align:middle
我们也已经结束了这一层

00:40:02.402 --> 00:40:04.004 align:middle
接下来让我们看一下它现在什么样子

00:40:11.879 --> 00:40:14.481 align:middle
这就是你现在可以使用
SpriteKit和Xcode 7

00:40:14.581 --> 00:40:16.917 align:middle
做的事情了

00:40:23.657 --> 00:40:25.292 align:middle
与此同时 我想将话题重新交给提姆

00:40:25.392 --> 00:40:27.961 align:middle
让它来为你们总结一下

00:40:29.396 --> 00:40:30.564 align:middle
谢谢泰勒

00:40:30.664 --> 00:40:32.266 align:middle
这真的是一个非常棒的工作

00:40:32.666 --> 00:40:35.335 align:middle
我相信大家有目共睹

00:40:35.402 --> 00:40:37.237 align:middle
这对于SpriteKit工程师来讲

00:40:37.304 --> 00:40:38.472 align:middle
将会是超级棒的一年

00:40:38.772 --> 00:40:41.675 align:middle
我们新增了AudioNode,
也新增了CameraNode

00:40:41.742 --> 00:40:43.243 align:middle
我们也有了可以引用的动作和节点

00:40:43.510 --> 00:40:45.345 align:middle
也有了一个全新的

00:40:45.412 --> 00:40:47.548 align:middle
基于运动编辑器的
集成在Xcode中的时间轴

00:40:47.781 --> 00:40:50.851 align:middle
我们整合了纹理地图集和资源目录

00:40:50.918 --> 00:40:52.619 align:middle
并给你提供了新的功能

00:40:52.853 --> 00:40:55.088 align:middle
例如基于命令的资源库
和更加简洁的App

00:40:55.656 --> 00:40:59.059 align:middle
同时也使SpriteKit适配
所有的支持Metal的设备

00:40:59.126 --> 00:41:01.962 align:middle
让你能够更容易地访问

00:40:59.126 --> 00:41:01.962 align:middle
让你能够更容易地访问

00:41:02.095 --> 00:41:03.830 align:middle
全新的GamePlayKit构架

00:41:06.300 --> 00:41:08.101 align:middle
如果你需要更多的信息

00:41:08.168 --> 00:41:09.837 align:middle
请访问我们的开发者网站

00:41:09.903 --> 00:41:11.138 align:middle
或者拨打咨询电话

00:41:11.271 --> 00:41:13.774 align:middle
联系我们的图形专家Allan
Schaffer

00:41:15.342 --> 00:41:16.543 align:middle
还有几个与之相关的会议

00:41:16.610 --> 00:41:18.212 align:middle
如果你想对GamePlayKit

00:41:18.278 --> 00:41:19.880 align:middle
或者SceneKit了解更多的话

00:41:21.014 --> 00:41:22.749 align:middle
我们也有一些实验室

00:41:22.850 --> 00:41:24.585 align:middle
第一个就是SpriteKit实验室

00:41:24.651 --> 00:41:25.786 align:middle
现在马上就会启动

00:41:26.053 --> 00:41:28.689 align:middle
大家放松 跟我们一起下楼

00:41:28.755 --> 00:41:30.390 align:middle
我们将很乐意回答你们的所有问题

00:41:31.091 --> 00:41:32.960 align:middle
非常感谢
请享受您的会议
