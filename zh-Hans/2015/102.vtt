WEBVTT

00:00:16.633 --> 00:00:17.733 align:middle
女士们先生们

00:00:18.033 --> 00:00:23.233 align:middle
欢迎OS X系统平台副总裁
安卓思·温克尔

00:00:31.433 --> 00:00:32.567 align:middle
安卓思·温克尔:
下午好

00:00:33.033 --> 00:00:35.433 align:middle
欢迎来到2015
全球开发者大会

00:00:37.167 --> 00:00:39.700 align:middle
作为苹果开发者
今年又是一个欣喜之年

00:00:39.767 --> 00:00:42.367 align:middle
加上watchOS
SDK的开发数据包

00:00:42.433 --> 00:00:44.867 align:middle
现在苹果产品有三大主要平台

00:00:46.200 --> 00:00:47.800 align:middle
我们开发这些平台的方法是

00:00:47.867 --> 00:00:51.067 align:middle
将好产品与独特的用户体验
结合在一起

00:00:51.567 --> 00:00:54.533 align:middle
同时使用与苹果系统一样的
优先科技

00:00:54.600 --> 00:00:56.733 align:middle
程序语言设计和编程概念

00:00:57.067 --> 00:00:59.900 align:middle
以便这些平台
之间能够轻易地代码共享

00:01:00.267 --> 00:01:02.933 align:middle
并使平台之间的应用实现协作

00:01:03.000 --> 00:01:05.633 align:middle
但我们也保持
每一个平台的特色

00:01:07.600 --> 00:01:09.367 align:middle
这些平台的数据开发包将会在

00:01:09.433 --> 00:01:12.967 align:middle
今年稍后安装到
Xcode IDE新版本

00:01:13.200 --> 00:01:14.300 align:middle
形成版本7

00:01:15.333 --> 00:01:17.233 align:middle
它包含了很多新的特色

00:01:17.300 --> 00:01:19.600 align:middle
在这里我只想
强调其中一个

00:01:20.267 --> 00:01:23.067 align:middle
那就是
我们允许用户AppleID

00:01:23.133 --> 00:01:24.200 align:middle
下载Xcode

00:01:24.267 --> 00:01:26.400 align:middle
并在他们的设备上运行应用

00:01:36.967 --> 00:01:38.733 align:middle
如果你们真的想让
成为开发者的梦想

00:01:38.800 --> 00:01:41.733 align:middle
更容易
尤其对年轻的学生来说

00:01:42.033 --> 00:01:44.500 align:middle
那么 需要三个平台的协作

00:01:46.267 --> 00:01:49.000 align:middle
如果你习惯使用某个应用
并想进行拓展

00:01:49.067 --> 00:01:50.600 align:middle
我们为你准备了
另外一个好消息

00:01:51.067 --> 00:01:54.300 align:middle
现在 一项单向支付的
开发者计划会员身份

00:01:54.367 --> 00:01:58.200 align:middle
可以让你展开苹果产品中
所有的应用

00:01:58.267 --> 00:01:59.600 align:middle
你不需要注册

00:01:59.667 --> 00:02:01.100 align:middle
且不需要购买支付会员资格

00:01:59.667 --> 00:02:01.100 align:middle
且不需要购买支付会员资格

00:02:09.733 --> 00:02:11.600 align:middle
当然
使用一次性支付会员身份的话

00:02:11.667 --> 00:02:14.200 align:middle
你还可以得到其它好处

00:02:14.267 --> 00:02:16.033 align:middle
比如获取预发行版本微软

00:02:16.400 --> 00:02:19.267 align:middle
接入强大的数据库 报表工具

00:02:21.133 --> 00:02:22.967 align:middle
现在
我想说说软件方面的更新

00:02:25.700 --> 00:02:29.600 align:middle
iOS创新曲线一直是
整个行业的骄傲

00:02:29.833 --> 00:02:31.767 align:middle
对美国开发者而言
是巨大的优势

00:02:32.233 --> 00:02:34.800 align:middle
因为你不需要处理来自

00:02:34.867 --> 00:02:36.367 align:middle
其它应用生态系
统的相同数据碎片

00:02:38.200 --> 00:02:40.267 align:middle
但是在iOS8中
我们发现

00:02:40.333 --> 00:02:42.567 align:middle
大量使用者在升级方面有困难

00:02:42.633 --> 00:02:43.600 align:middle
因为安装程序

00:02:43.667 --> 00:02:45.733 align:middle
需要很大的可用空间

00:02:46.467 --> 00:02:47.300 align:middle
我们已经采取措施

00:02:47.367 --> 00:02:49.600 align:middle
在iOS8更新中
减少了占用空间

00:02:50.200 --> 00:02:52.200 align:middle
在iOS9中
我们会继续降低该数值

00:02:52.433 --> 00:02:54.067 align:middle
正如你们今早
在主旨发言中听到的

00:02:54.433 --> 00:02:57.533 align:middle
iOS9只需要
1.3G的可用空间

00:02:58.967 --> 00:03:02.200 align:middle
我们也改变了
软件升级的提醒方式

00:02:58.967 --> 00:03:02.200 align:middle
我们也改变了
软件升级的提醒方式

00:03:02.600 --> 00:03:05.633 align:middle
用户可以选择立即安装
或者在不方便的时候

00:03:05.700 --> 00:03:08.300 align:middle
选择稍后安装

00:03:08.367 --> 00:03:11.433 align:middle
所以 我们认为

00:03:11.500 --> 00:03:14.967 align:middle
这将确保用户快速更新iOS

00:03:15.133 --> 00:03:20.467 align:middle
使用最新版本的iOS

00:03:20.667 --> 00:03:22.567 align:middle
现在 我们还在研究一些技术

00:03:22.633 --> 00:03:25.033 align:middle
我们称为应用瘦身

00:03:25.100 --> 00:03:26.933 align:middle
让用户获得更多可用空间

00:03:28.000 --> 00:03:31.167 align:middle
应用瘦身包括三项技术
应用切割

00:03:31.500 --> 00:03:33.700 align:middle
需加载资源和位码

00:03:34.433 --> 00:03:35.900 align:middle
我们一个一个地看一下

00:03:36.000 --> 00:03:36.900 align:middle
先来看应用切割

00:03:39.600 --> 00:03:41.800 align:middle
为iOS系统开发应用

00:03:41.867 --> 00:03:43.500 align:middle
其实就是开发
同一款应用的不同变体

00:03:43.567 --> 00:03:45.167 align:middle
然后将它们包装在一起

00:03:45.233 --> 00:03:46.433 align:middle
放在一个应用程序包里

00:03:47.100 --> 00:03:49.067 align:middle
所以 如果你打开一个应用
你会发现

00:03:49.133 --> 00:03:52.767 align:middle
有很多相似的其他组件
占用设备的有限空间

00:03:53.867 --> 00:03:57.100 align:middle
这是32位和64位
的处理器结构

00:03:58.033 --> 00:04:00.400 align:middle
不同屏幕尺寸和分辨率的图像

00:03:58.033 --> 00:04:00.400 align:middle
不同屏幕尺寸和分辨率的图像

00:04:01.500 --> 00:04:03.633 align:middle
以及工具 比如着色器

00:04:03.700 --> 00:04:06.267 align:middle
用不同语言编写
而成的图形编辑器

00:04:07.567 --> 00:04:09.867 align:middle
但是 要在特定的
设备中运行一款应用

00:04:10.300 --> 00:04:12.633 align:middle
你只需要其中的一个即可

00:04:13.933 --> 00:04:15.967 align:middle
所以为了充分利用储存空间

00:04:16.033 --> 00:04:18.466 align:middle
我们将删除设备中

00:04:18.533 --> 00:04:19.632 align:middle
所有的应用

00:04:19.700 --> 00:04:21.166 align:middle
所不需要的所有组件

00:04:22.733 --> 00:04:26.633 align:middle
所以你可以继续开发
并且使用你已习惯的应用

00:04:27.400 --> 00:04:31.967 align:middle
但是商店只会安装时传输
经过瘦身应用给到用户

00:04:41.667 --> 00:04:44.033 align:middle
这就是大大缩减了空间

00:04:44.967 --> 00:04:48.000 align:middle
正如你们在表格中看到的
一般的应用可以节省

00:04:48.067 --> 00:04:49.867 align:middle
20%到40%的空间

00:04:51.100 --> 00:04:53.933 align:middle
应用瘦身的作用
在一些应用中

00:04:54.000 --> 00:04:56.133 align:middle
体现的尤其明显
比如在安装单元应用中时

00:04:56.200 --> 00:04:58.967 align:middle
经常突然出现游戏下载限制

00:04:59.600 --> 00:05:02.867 align:middle
瘦身版本可以更加容易地
在限制范围内安装完成

00:04:59.600 --> 00:05:02.867 align:middle
瘦身版本可以更加容易地
在限制范围内安装完成

00:05:03.367 --> 00:05:05.967 align:middle
所以你可以将更多的特定资源

00:05:06.033 --> 00:05:07.633 align:middle
放到应用中并且提供给用户

00:05:07.700 --> 00:05:08.967 align:middle
提供更加完美的体验

00:05:10.567 --> 00:05:13.767 align:middle
最棒的一点是
在使用Xcode的资产目录

00:05:14.000 --> 00:05:15.967 align:middle
你不需要
改变程序中的任何东西

00:05:16.033 --> 00:05:20.033 align:middle
在你下次登陆的时候
后台将会自动为你备份更新等

00:05:21.033 --> 00:05:23.200 align:middle
如果你在使用
其他自定义数据格式

00:05:23.500 --> 00:05:26.967 align:middle
我们要求你通过
创建资产目录以分成程序片

00:05:27.433 --> 00:05:30.333 align:middle
并且使用我们为你的设备

00:05:30.400 --> 00:05:32.700 align:middle
添加的其所需的新的资产目录

00:05:36.367 --> 00:05:39.333 align:middle
一些应用可以通过使用
更多资源得到好处

00:05:39.467 --> 00:05:41.567 align:middle
因为不需要
同时使用各种程序片

00:05:42.200 --> 00:05:44.167 align:middle
在这种情况下
我们推荐

00:05:44.333 --> 00:05:46.900 align:middle
按需资源 简称ODR

00:05:48.467 --> 00:05:51.067 align:middle
使用ODR按需资源时
储备会将你的资源分为

00:05:51.133 --> 00:05:52.933 align:middle
恰当程序片

00:05:53.000 --> 00:05:54.867 align:middle
然后将它们
放置在苹果服务器中

00:05:55.733 --> 00:05:56.800 align:middle
但是下载过程会被延迟

00:05:56.867 --> 00:05:58.833 align:middle
直到你的应用明确需要他们

00:05:59.167 --> 00:06:01.767 align:middle
然后iOS将释放空间

00:05:59.167 --> 00:06:01.767 align:middle
然后iOS将释放空间

00:06:01.833 --> 00:06:03.800 align:middle
当你的应用不再需要资源时

00:06:05.733 --> 00:06:09.400 align:middle
按需资源的
典型类型是关卡游戏

00:06:09.567 --> 00:06:12.433 align:middle
但是很多其它应用
也可以在其中得到益处

00:06:12.833 --> 00:06:15.667 align:middle
比如 你可能想要下载教程

00:06:16.033 --> 00:06:17.333 align:middle
到ODR资产中

00:06:17.467 --> 00:06:20.900 align:middle
当用户真正想看
的时候才会开始下载

00:06:23.567 --> 00:06:26.100 align:middle
使用ODR
需要你懂得规划

00:06:26.400 --> 00:06:27.500 align:middle
但重要的是

00:06:27.567 --> 00:06:31.600 align:middle
你可以在不同时间
使用多于4G的资源

00:06:33.867 --> 00:06:35.833 align:middle
因此 应用切割和需加载资源

00:06:36.167 --> 00:06:38.700 align:middle
将会极大地帮助应用节省空间

00:06:40.167 --> 00:06:41.833 align:middle
我们还在研究一项新技术

00:06:41.900 --> 00:06:43.200 align:middle
它是更有远见的技术

00:06:43.433 --> 00:06:46.333 align:middle
我们现在将位码引入到
AppStore提交过程中

00:06:47.733 --> 00:06:51.100 align:middle
位码是二进制中的
一种框架系统中间代码

00:06:51.400 --> 00:06:54.633 align:middle
它可以让商店先
优化你的设备应用

00:06:54.700 --> 00:06:58.133 align:middle
然后再传输给用户

00:06:59.200 --> 00:07:01.900 align:middle
你在Xcode中
正常开发和调试应用

00:06:59.200 --> 00:07:01.900 align:middle
你在Xcode中
正常开发和调试应用

00:07:02.533 --> 00:07:03.867 align:middle
但是商店将会进入一种状态

00:07:04.733 --> 00:07:08.833 align:middle
不断运行
我们更新的编译器优化

00:07:09.333 --> 00:07:11.900 align:middle
这样你的应用能够在
所有的设备中运行顺畅

00:07:13.200 --> 00:07:14.467 align:middle
应用将不断更新

00:07:15.300 --> 00:07:18.633 align:middle
因为App Store
会不断让你的应用

00:07:19.100 --> 00:07:22.833 align:middle
获得也许会加入未来
新处理器的运算优势

00:07:23.300 --> 00:07:26.000 align:middle
所有这一切你都不需要
向AppStore重新提交

00:07:35.233 --> 00:07:38.767 align:middle
所以位码的形成可以
通过Xcode进行设置

00:07:39.233 --> 00:07:42.667 align:middle
从一开始这便强制对
所有watchOS系统执行

00:07:43.067 --> 00:07:44.967 align:middle
对与iOS系统来说
现在属于可选项

00:07:45.767 --> 00:07:47.633 align:middle
尽管我们认为优势很好

00:07:47.867 --> 00:07:50.500 align:middle
因此我们准备默认
对所有项目采用该服务

00:07:52.367 --> 00:07:53.533 align:middle
这就是应用瘦身

00:07:54.067 --> 00:07:57.233 align:middle
它包括了应用切割
按需资源以及位码

00:07:57.633 --> 00:07:59.333 align:middle
这些将会极大地优化应用

00:08:00.733 --> 00:08:02.200 align:middle
尤其是储存空间方面

00:08:03.200 --> 00:08:04.567 align:middle
现在 我们来看一下

00:08:04.767 --> 00:08:06.200 align:middle
应用中的二进制

00:08:06.267 --> 00:08:10.333 align:middle
AppStore目前要求你
应用使用32位和64位版本

00:08:11.500 --> 00:08:13.267 align:middle
在过去的几年中
我们见证了

00:08:13.333 --> 00:08:16.567 align:middle
我们系统设备
在处理器能力上的发展

00:08:17.167 --> 00:08:20.000 align:middle
我们的中央处理器
和图形处理器

00:08:20.567 --> 00:08:23.433 align:middle
以及引入
64位处理器体系结构

00:08:23.500 --> 00:08:24.600 align:middle
之后的所有设备

00:08:25.433 --> 00:08:28.300 align:middle
所以该应用目录

00:08:28.733 --> 00:08:30.767 align:middle
仅仅适用64位处理器

00:08:32.033 --> 00:08:33.366 align:middle
和64位体系结构

00:08:33.467 --> 00:08:37.232 align:middle
因此用户
只可以提交64位应用

00:08:37.732 --> 00:08:39.799 align:middle
这将从今年稍晚
系统9开始使用之后

00:08:46.033 --> 00:08:48.333 align:middle
接着我们来说watchOS
软件开发工具包

00:08:48.400 --> 00:08:50.133 align:middle
为了解说 我想把舞台交给

00:08:50.200 --> 00:08:51.800 align:middle
我的同事：
易丽扎·布洛克

00:09:01.500 --> 00:09:02.767 align:middle
易丽扎·布洛克
谢谢 安卓思

00:09:04.833 --> 00:09:07.700 align:middle
我们很高兴
Watch系统在研发者社区

00:09:07.767 --> 00:09:09.000 align:middle
得到了认可

00:09:11.000 --> 00:09:12.467 align:middle
在苹果商店中很早就已经有

00:09:12.533 --> 00:09:15.133 align:middle
上千种手表的应用

00:09:15.667 --> 00:09:17.567 align:middle
今天 我很高兴地
告诉大家

00:09:17.900 --> 00:09:22.267 align:middle
更多关于WatchOS 2
软件开发工具包的一些新特点

00:09:26.767 --> 00:09:30.633 align:middle
首先我们来讨论一下
watchOS现有构架

00:09:32.000 --> 00:09:34.733 align:middle
应用有个用户界面
你可以将它作为

00:09:34.800 --> 00:09:37.333 align:middle
一个故事版
这会被安装在手表中

00:09:38.833 --> 00:09:42.533 align:middle
点击应用程序扩展
来打开用户界面

00:09:42.833 --> 00:09:44.167 align:middle
它在手机上运行

00:09:47.633 --> 00:09:52.467 align:middle
在watchOS2中我们
在结构上做了一个重大改变

00:09:53.667 --> 00:09:56.500 align:middle
用户界面依旧一样
应用扩展将

00:09:56.567 --> 00:09:58.333 align:middle
在手表中运行

00:09:58.700 --> 00:10:00.367 align:middle
这产生了很多益处

00:09:58.700 --> 00:10:00.367 align:middle
这产生了很多益处

00:10:03.233 --> 00:10:05.900 align:middle
因为这与手表应用
相互作用

00:10:05.967 --> 00:10:08.833 align:middle
不再需要绑定在手机中
使用应用的用户

00:10:10.333 --> 00:10:15.367 align:middle
用户会在速度和应用反应上
感受到实质性的改进

00:10:16.500 --> 00:10:18.133 align:middle
当然 因为同样的原因

00:10:18.400 --> 00:10:22.033 align:middle
你的手表应用
也可以在手机不在的时候运行

00:10:23.867 --> 00:10:26.333 align:middle
由此应用扩展
直接在手表运行

00:10:26.600 --> 00:10:28.367 align:middle
它直接连接手表硬件

00:10:28.700 --> 00:10:30.600 align:middle
这就产生了无数可能性

00:10:36.367 --> 00:10:40.167 align:middle
现在
你编写手表应用时

00:10:40.667 --> 00:10:42.200 align:middle
你会用什么程序设计语言？

00:10:43.533 --> 00:10:46.133 align:middle
好消息是和其他很多框架一样

00:10:46.467 --> 00:10:50.133 align:middle
和你已经非常熟悉
的iOS开发框架一样

00:10:54.867 --> 00:10:56.433 align:middle
还有另外一个重点

00:10:58.567 --> 00:11:02.700 align:middle
手表的连接框架可以使你
与手机应用对接

00:10:58.567 --> 00:11:02.700 align:middle
手表的连接框架可以使你
与手机应用对接

00:11:02.767 --> 00:11:04.767 align:middle
当然了
现在正在其他设备中运行

00:11:08.900 --> 00:11:11.433 align:middle
另外 你的应用扩展可以直接

00:11:11.500 --> 00:11:14.733 align:middle
与使用网络接口语言程序的
网络服务对接

00:11:16.400 --> 00:11:21.133 align:middle
即使你的手机不在范围内
这种交接也可以进行

00:11:34.033 --> 00:11:38.000 align:middle
在当前watchOS应用中
有三种方法可以查看数据

00:11:38.200 --> 00:11:42.233 align:middle
快捷视图 通知以及应用本身

00:11:43.700 --> 00:11:44.733 align:middle
但是 这样会不会很棒

00:11:45.433 --> 00:11:47.533 align:middle
假设你只要抬起手腕
甚至不需要触碰屏幕

00:11:47.600 --> 00:11:50.767 align:middle
就可以看到你的应用目录

00:11:51.967 --> 00:11:54.100 align:middle
在watchOS 2中
这有可能实现

00:11:54.200 --> 00:11:57.167 align:middle
因为现在你可以
在手表界面创建一个程序

00:12:00.967 --> 00:12:04.500 align:middle
我们为手表设计了
简短对接

00:12:04.767 --> 00:12:06.900 align:middle
并且以最快的方式
看到你的目录

00:12:06.967 --> 00:12:09.867 align:middle
那就是通过程序
快捷视图以及通知

00:12:10.433 --> 00:12:11.933 align:middle
所以 让我们进一步了解一下

00:12:18.600 --> 00:12:19.767 align:middle
不要理会这些名字

00:12:19.833 --> 00:12:21.733 align:middle
程序其实很简单

00:12:22.433 --> 00:12:24.400 align:middle
它们信息片段

00:12:24.467 --> 00:12:26.467 align:middle
出现在你手表界面上而已

00:12:28.400 --> 00:12:31.667 align:middle
因此 如果我们打开
手表界面并去掉时间

00:12:32.000 --> 00:12:33.833 align:middle
就只剩一个程序

00:12:35.367 --> 00:12:38.167 align:middle
现在 你在这里看到的
是OS系统的内部情况

00:12:39.367 --> 00:12:40.833 align:middle
现在你可以自行创建了

00:12:43.433 --> 00:12:46.300 align:middle
现在 你可能还不太了解

00:12:46.367 --> 00:12:49.633 align:middle
比如
旧金山足球俱落部正在举行

00:12:49.700 --> 00:12:51.033 align:middle
2015年锦标赛

00:12:52.933 --> 00:12:55.467 align:middle
所以 我们可以创建一个程序

00:12:55.533 --> 00:12:59.433 align:middle
来模块化提醒我们
接下来是进行哪场比赛

00:13:03.233 --> 00:13:05.167 align:middle
如果我安装到我的手表上

00:13:05.933 --> 00:13:09.400 align:middle
每次抬起手腕我都会看到

00:13:10.000 --> 00:13:13.300 align:middle
这很好
但要做到一个好的体验

00:13:13.867 --> 00:13:16.933 align:middle
很重要的是
随着时间变化以及程序所需

00:13:17.000 --> 00:13:19.133 align:middle
程序需要作出相应变化

00:13:19.700 --> 00:13:22.900 align:middle
一打开屏幕这些就会出现

00:13:25.200 --> 00:13:26.467 align:middle
为了达到这个效果

00:13:26.967 --> 00:13:30.833 align:middle
我们为你的程序
以时间线的方式收集数据

00:13:34.733 --> 00:13:37.633 align:middle
那样 当我那天看看我的手表

00:13:38.033 --> 00:13:40.400 align:middle
程序就会提示信息

00:13:40.467 --> 00:13:42.467 align:middle
告诉我此时此刻的信息

00:13:49.000 --> 00:13:51.567 align:middle
所以在日程中
创建一个时间线

00:13:51.800 --> 00:13:54.500 align:middle
来提示足球比赛非常简单

00:13:54.967 --> 00:13:56.900 align:middle
一方面 我制作一个日程

00:13:57.567 --> 00:14:00.433 align:middle
另一方面 这不太可能改变

00:13:57.567 --> 00:14:00.433 align:middle
另一方面 这不太可能改变

00:14:01.033 --> 00:14:03.533 align:middle
但是 这可能不是
你创建程序的理由

00:14:05.767 --> 00:14:08.500 align:middle
世界上事物在变化你可能需要

00:14:08.567 --> 00:14:10.400 align:middle
随时更新你的时间表

00:14:11.600 --> 00:14:13.633 align:middle
我们为此
提供了几种方法

00:14:14.667 --> 00:14:16.400 align:middle
第一种是计划更新

00:14:20.767 --> 00:14:21.967 align:middle
计划更新

00:14:23.367 --> 00:14:25.567 align:middle
对程序而言非常完美
它的数据变化

00:14:25.633 --> 00:14:29.600 align:middle
会根据预测而变化
像天气预报一样

00:14:30.933 --> 00:14:33.267 align:middle
如果你写了天气预报的程序

00:14:33.667 --> 00:14:35.533 align:middle
那么服务器每小时

00:14:35.600 --> 00:14:38.633 align:middle
都会提供更加准确的天气数据

00:14:39.433 --> 00:14:41.933 align:middle
所以你下载时间线时
你可以告诉我们

00:14:42.000 --> 00:14:44.567 align:middle
你下一次更新数据的准确时间

00:14:46.467 --> 00:14:48.300 align:middle
那么应用将在后台

00:14:48.367 --> 00:14:49.300 align:middle
保持运行

00:14:49.533 --> 00:14:52.667 align:middle
你可以点击服务器
更新新的天气数据

00:14:53.133 --> 00:14:54.433 align:middle
重新下载时间线

00:14:59.000 --> 00:15:01.067 align:middle
但是在预计的时间内

00:14:59.000 --> 00:15:01.067 align:middle
但是在预计的时间内

00:15:01.133 --> 00:15:02.333 align:middle
并非所有的数据都可以更新

00:15:03.300 --> 00:15:06.300 align:middle
假如我想要在我的足球程序中

00:15:07.200 --> 00:15:08.267 align:middle
加入直播得分

00:15:09.067 --> 00:15:10.567 align:middle
我要是每个小时
或者每十五分钟

00:15:10.633 --> 00:15:14.333 align:middle
都点击服务器以获得目前得分

00:15:14.733 --> 00:15:17.433 align:middle
这么做不方便
因为每一次进球

00:15:17.667 --> 00:15:20.467 align:middle
都需要立即在我的程序中更新

00:15:21.733 --> 00:15:24.967 align:middle
为了解决这种麻烦
接下来介绍一种

00:15:25.033 --> 00:15:27.200 align:middle
新的高优先级的推送通知

00:15:30.033 --> 00:15:33.067 align:middle
如果你为程
提供所需要的数据

00:15:33.333 --> 00:15:36.100 align:middle
你可以发送
推送通知到你的手机

00:15:36.167 --> 00:15:38.233 align:middle
它将会马上被传输

00:15:38.300 --> 00:15:39.667 align:middle
到你手表上的应用扩展中

00:15:45.833 --> 00:15:48.433 align:middle
所以要确定的是

00:15:48.500 --> 00:15:50.367 align:middle
程序目录总是最新的
因此时间线非常重要

00:15:50.933 --> 00:15:54.100 align:middle
而且
这样做还有其他重要目的

00:15:54.467 --> 00:15:56.100 align:middle
如果你看到了今早的主旨发言

00:15:57.500 --> 00:16:00.333 align:middle
你会听到
我们在watchOS2中

00:15:57.500 --> 00:16:00.333 align:middle
你会听到
我们在watchOS2中

00:16:00.400 --> 00:16:03.300 align:middle
介绍的时空之旅
它让你回到数码皇冠时代

00:16:03.500 --> 00:16:05.333 align:middle
可以回顾过去 展望未来

00:16:05.400 --> 00:16:07.367 align:middle
让你看到在一天不同时刻

00:16:07.433 --> 00:16:08.533 align:middle
你的程序将会显示什么

00:16:09.700 --> 00:16:11.133 align:middle
比如 这里

00:16:11.500 --> 00:16:14.500 align:middle
看上去
海洋诺伊谷游戏已经结束

00:16:14.667 --> 00:16:17.467 align:middle
而我错过了
因为我站在台上谈论苹果手表

00:16:18.400 --> 00:16:21.900 align:middle
我可以通过时空之旅
回到当时 看看发生了什么

00:16:30.167 --> 00:16:32.667 align:middle
看起来好像
诺伊谷好像为我暂停了一样

00:16:32.733 --> 00:16:34.167 align:middle
真是激动人心

00:16:36.100 --> 00:16:38.133 align:middle
这就是程序

00:16:38.200 --> 00:16:41.033 align:middle
方便进行快速查看重要数据

00:16:41.733 --> 00:16:42.633 align:middle
小部分数据

00:16:43.533 --> 00:16:45.467 align:middle
但是如果你想要
看到更多信息怎么办

00:16:46.233 --> 00:16:47.667 align:middle
这时候你就可能需要快捷视图

00:16:52.000 --> 00:16:54.767 align:middle
你可以向上移动表盘表面
来获得快捷视图

00:16:56.967 --> 00:16:58.833 align:middle
快捷视图提供了一个机会

00:16:58.900 --> 00:17:01.533 align:middle
让整个屏幕充满用户数据

00:16:58.900 --> 00:17:01.533 align:middle
让整个屏幕充满用户数据

00:17:01.967 --> 00:17:04.599 align:middle
比如 我的足球俱乐部
快捷视图告诉我

00:17:04.700 --> 00:17:07.867 align:middle
比赛中A队的状况

00:17:11.133 --> 00:17:13.200 align:middle
程序和快捷视图

00:17:13.267 --> 00:17:16.067 align:middle
让我进入计划表中的应用数据

00:17:17.833 --> 00:17:20.099 align:middle
但是 有时候你需要在

00:17:20.166 --> 00:17:22.233 align:middle
用户面前获得信息

00:17:22.767 --> 00:17:25.233 align:middle
这时候你需要一个通知

00:17:29.433 --> 00:17:32.167 align:middle
手表中的通知非常强大

00:17:32.667 --> 00:17:35.067 align:middle
你可以充分利用屏幕

00:17:35.833 --> 00:17:37.700 align:middle
显示整个自定义用户界面

00:17:39.333 --> 00:17:41.167 align:middle
比如 通知我

00:17:41.733 --> 00:17:46.467 align:middle
这是最后机会选出今天下午
在索玛奶牛低地游戏的冠军

00:17:48.300 --> 00:17:49.800 align:middle
除了自定义用户界面外

00:17:50.033 --> 00:17:51.667 align:middle
你还可以添加自定义动作

00:17:52.567 --> 00:17:55.233 align:middle
按下其中一个按钮

00:17:55.300 --> 00:17:56.133 align:middle
则进行应用注册

00:17:57.333 --> 00:17:58.167 align:middle
但这还不是全部

00:17:58.700 --> 00:18:00.300 align:middle
因为watchOS 2系统

00:17:58.700 --> 00:18:00.300 align:middle
因为watchOS 2系统

00:18:00.367 --> 00:18:04.000 align:middle
我们根据文本回复推送通知

00:18:05.367 --> 00:18:07.967 align:middle
所以我可以在
通知中添加一个按钮

00:18:08.033 --> 00:18:10.300 align:middle
让我能够编辑信息并且发送

00:18:10.367 --> 00:18:13.033 align:middle
我是个真正的索玛迷
我想让全世界都知道

00:18:13.300 --> 00:18:14.767 align:middle
所以我要选择这个按钮

00:18:16.567 --> 00:18:20.300 align:middle
当我选择回复
我得到快速回复表

00:18:20.633 --> 00:18:23.400 align:middle
我甚至可以
使用口述来形成一条信息

00:18:23.467 --> 00:18:26.400 align:middle
这些都在通知内部
形成不需要变换目录

00:18:29.467 --> 00:18:31.367 align:middle
谢谢你们
你们真好

00:18:35.633 --> 00:18:37.033 align:middle
这就是通知

00:18:37.967 --> 00:18:41.333 align:middle
程序快捷视图
以及通知都很简单

00:18:41.533 --> 00:18:44.500 align:middle
这也可能是
你的用户在你的应用中

00:18:44.567 --> 00:18:45.533 align:middle
最常见的交流方式

00:18:46.033 --> 00:18:48.033 align:middle
但有时候你需要更多时间

00:18:49.067 --> 00:18:51.767 align:middle
而且你要一种交互性更好
更加逼真的体验

00:18:52.100 --> 00:18:53.967 align:middle
这时候你需要
启动完整的应用程序

00:18:55.167 --> 00:18:59.800 align:middle
在watchOS 2中
你可以做很多事情

00:19:00.900 --> 00:19:04.800 align:middle
举个例子 既然你可以

00:19:04.867 --> 00:19:08.167 align:middle
使用数码皇冠时代
那么你可以用让屏幕

00:19:08.233 --> 00:19:09.633 align:middle
快速显示全部比赛队伍

00:19:10.300 --> 00:19:13.000 align:middle
可以快速找到你最喜欢的队伍
并且得到他们的信息

00:19:15.133 --> 00:19:18.467 align:middle
然而这只是你
使用watchOS 2之后

00:19:18.533 --> 00:19:20.267 align:middle
带来的诸多优势其中之一

00:19:22.067 --> 00:19:24.667 align:middle
你也可以给你的
用户界面添加动画

00:19:25.033 --> 00:19:26.933 align:middle
你可以使用振动马达

00:19:28.333 --> 00:19:30.633 align:middle
你可以通过手表录音

00:19:30.833 --> 00:19:33.667 align:middle
你可以嵌入
声音信号和回放录像

00:19:34.933 --> 00:19:37.133 align:middle
你可以通过应用打电话

00:19:37.700 --> 00:19:39.600 align:middle
你可以通过直播访问

00:19:39.667 --> 00:19:42.067 align:middle
医疗传感器和加速计获取数据

00:19:42.833 --> 00:19:46.633 align:middle
能够看到你们这么会玩
我们很高兴

00:19:46.900 --> 00:19:48.800 align:middle
现在我想展示
在watchOS 2

00:19:48.867 --> 00:19:50.567 align:middle
安装应用的方法有多简单

00:19:50.800 --> 00:19:52.467 align:middle
让我们邀请乔什·谢弗

00:20:00.000 --> 00:20:01.300 align:middle
乔什·谢弗:
谢谢 易丽扎

00:20:02.333 --> 00:20:04.333 align:middle
我很高兴能够向大家展示

00:20:04.400 --> 00:20:09.733 align:middle
将watchOS 1中应用
升级到watchOS 2中

00:20:09.800 --> 00:20:11.133 align:middle
在手机本机上运行

00:20:12.400 --> 00:20:15.133 align:middle
如果你已经下载过
今年开发者大会上的应用

00:20:15.600 --> 00:20:19.167 align:middle
你可能会注意到
其中有一个手表应用扩展

00:20:19.600 --> 00:20:21.600 align:middle
可以在你手表上安装和运行

00:20:22.333 --> 00:20:25.533 align:middle
所以接下来我们
要看一下怎样升级应用

00:20:25.933 --> 00:20:29.433 align:middle
并且在手表2中运行这些应用

00:20:29.500 --> 00:20:32.733 align:middle
我们在其中会使用一些
易丽扎刚刚介绍的特色

00:20:34.267 --> 00:20:37.733 align:middle
在这里你可以看到

00:20:37.800 --> 00:20:41.367 align:middle
开发者大会应用的Xcode

00:20:41.800 --> 00:20:42.833 align:middle
Xcode会注意到

00:20:42.900 --> 00:20:44.967 align:middle
我有一个watchOS 1
应用扩展

00:20:45.033 --> 00:20:47.900 align:middle
并且主动帮我升级到
watchOS 2应用扩展

00:20:48.900 --> 00:20:49.733 align:middle
我要点击这里

00:20:49.800 --> 00:20:51.067 align:middle
让它执行这些变化

00:20:51.700 --> 00:20:53.600 align:middle
它会注意到所有的目标

00:20:53.967 --> 00:20:56.200 align:middle
并且升级
使原始资料生成代码

00:20:56.267 --> 00:21:00.333 align:middle
将故事版准备就绪
我就可以重新使用所有的应用

00:20:56.267 --> 00:21:00.333 align:middle
将故事版准备就绪
我就可以重新使用所有的应用

00:21:02.233 --> 00:21:04.733 align:middle
我们看一下这里
检验一下控制器内容

00:21:05.333 --> 00:21:08.800 align:middle
首先我们要改变一些代码

00:21:08.867 --> 00:21:10.200 align:middle
来改变我们获取数据的方法

00:21:10.767 --> 00:21:12.333 align:middle
既然我们在不同的设备中运行

00:21:12.767 --> 00:21:16.000 align:middle
我们需要能够将
数据从手机移动到手表

00:21:16.233 --> 00:21:18.100 align:middle
我们可以
使用新的手表连接框架

00:21:18.200 --> 00:21:19.033 align:middle
实现这项功能

00:21:19.800 --> 00:21:22.567 align:middle
所以我要开始
添加手表连接框架

00:21:23.300 --> 00:21:25.967 align:middle
我们要替换开源原应用调用

00:21:26.033 --> 00:21:28.067 align:middle
我曾经在
watchOS 1版本使用

00:21:28.433 --> 00:21:31.533 align:middle
新的手表连接
代码将会要求数据

00:21:31.600 --> 00:21:34.067 align:middle
从手机复制到手表

00:21:35.800 --> 00:21:38.633 align:middle
这样 现在
我们可以添加一些附加功能

00:21:39.067 --> 00:21:40.600 align:middle
比较酷的一项功能是

00:21:40.667 --> 00:21:43.233 align:middle
与数据皇冠时代的交互

00:21:44.467 --> 00:21:46.367 align:middle
现在数据皇冠时代
与手表应用中交互方式

00:21:46.433 --> 00:21:50.967 align:middle
是利用一种
新的界面选择器控制

00:21:52.233 --> 00:21:54.667 align:middle
我们要在一分钟内
将其从故事板中拖出

00:21:54.767 --> 00:21:57.000 align:middle
但首先我们要
添加一些搭建代码

00:21:58.100 --> 00:22:01.267 align:middle
我们要做一些参照
将其连接到故事板中

00:21:58.100 --> 00:22:01.267 align:middle
我们要做一些参照
将其连接到故事板中

00:22:01.333 --> 00:22:02.733 align:middle
一旦我们将其拖出

00:22:03.467 --> 00:22:05.600 align:middle
然后你需要对选择器编程

00:22:05.667 --> 00:22:07.500 align:middle
把你想要的项目添加进去

00:22:08.000 --> 00:22:10.667 align:middle
所以我们要追踪的是

00:22:10.733 --> 00:22:12.400 align:middle
一周内存在的所有会话踪迹

00:22:12.600 --> 00:22:15.133 align:middle
并且在每个踪迹
的选择器中添加一个入口

00:22:15.400 --> 00:22:17.567 align:middle
这样 我们
就可以整理会话列表

00:22:17.800 --> 00:22:20.267 align:middle
寻找我们感兴趣的会话踪迹

00:22:21.200 --> 00:22:23.767 align:middle
最后
我们要添加IBAction

00:22:23.833 --> 00:22:26.600 align:middle
连接我们的控制
之后每次变化它都会被调用

00:22:27.267 --> 00:22:28.467 align:middle
所以我们要在那里添加代码

00:22:29.133 --> 00:22:33.067 align:middle
现在我们可以切换到故事板
在应用中找到安置它的地方

00:22:34.367 --> 00:22:36.467 align:middle
所以我在这里
找到新的选择器控制

00:22:37.467 --> 00:22:39.700 align:middle
我们要把它拖出来
并且安置在会话控制器中

00:22:40.233 --> 00:22:42.700 align:middle
会话控制器
可以显示所有的会话

00:22:42.767 --> 00:22:45.533 align:middle
所以通过添加置顶

00:22:45.600 --> 00:22:46.967 align:middle
它会提供过滤会话列表的方法

00:22:47.433 --> 00:22:49.400 align:middle
将它稍微缩短一点
这样它不会那么高

00:22:50.033 --> 00:22:51.733 align:middle
现在 选择器控制真的很灵活

00:22:52.067 --> 00:22:53.433 align:middle
并且有三种不同的形式

00:22:53.500 --> 00:22:55.767 align:middle
可供你选择列表 堆叠和序列

00:22:56.100 --> 00:22:57.367 align:middle
你可以了解整整一周的情况

00:22:58.800 --> 00:23:00.800 align:middle
列表1是一个非常好的选择

00:22:58.800 --> 00:23:00.800 align:middle
列表1是一个非常好的选择

00:23:00.867 --> 00:23:02.633 align:middle
因为这里是我们
要在这里做的事情列表

00:23:03.133 --> 00:23:04.867 align:middle
我们要打开一个重点概览

00:23:04.933 --> 00:23:07.233 align:middle
以便我们可以保证用户

00:23:07.300 --> 00:23:09.533 align:middle
在转换到数码皇冠
时代的时候可以区分

00:23:11.033 --> 00:23:13.200 align:middle
因为有了这些变化我们就可以

00:23:13.267 --> 00:23:15.033 align:middle
连接到我们刚刚结束的代码

00:23:16.067 --> 00:23:18.100 align:middle
我们要将连接拖出
到我们的IBOUTLET

00:23:18.733 --> 00:23:20.867 align:middle
并且将一个连接
拖至我们的IBAction

00:23:20.933 --> 00:23:22.733 align:middle
因此每次选择器
变化它都会被调用

00:23:24.133 --> 00:23:25.000 align:middle
就这样

00:23:25.200 --> 00:23:26.633 align:middle
所以 我们要点击构建和运行

00:23:27.200 --> 00:23:29.000 align:middle
然后我们可以
切换到手表模拟器

00:23:29.333 --> 00:23:30.567 align:middle
看到它如何运行

00:23:30.967 --> 00:23:33.600 align:middle
在watchOS 2中关于
手表模拟器很重要的东西是

00:23:33.667 --> 00:23:36.000 align:middle
它是手表中一个完整的模拟器

00:23:36.400 --> 00:23:38.400 align:middle
所以你可以
一起运行你的整个手表

00:23:38.667 --> 00:23:41.867 align:middle
在手机应用中同时调试

00:23:42.067 --> 00:23:44.033 align:middle
并且测试他们之间的连接代码

00:23:51.833 --> 00:23:53.033 align:middle
所以现在我们可以跳过这里

00:23:53.100 --> 00:23:56.167 align:middle
在会话列表中你可以看到
我们可以滚动会话列表

00:23:56.600 --> 00:23:59.033 align:middle
我们也可以根据
我们想看的踪迹进行过滤

00:23:59.633 --> 00:24:01.067 align:middle
我们改变的时候就在升级

00:23:59.633 --> 00:24:01.067 align:middle
我们改变的时候就在升级

00:24:02.100 --> 00:24:04.533 align:middle
现在 我想说的
最后一个特点是

00:24:04.933 --> 00:24:07.967 align:middle
在手表屏幕上展示会话的能力

00:24:08.267 --> 00:24:10.800 align:middle
为了能实现这项功能
我们要在应用中添加一个程序

00:24:11.300 --> 00:24:13.367 align:middle
现在
我提前为此编写了大部分代码

00:24:13.533 --> 00:24:15.567 align:middle
所以我只要将文件拖出去
并且将其添加到

00:24:15.633 --> 00:24:16.867 align:middle
这里我的程序中

00:24:18.400 --> 00:24:20.867 align:middle
我唯一没做的
事情就是添加代码

00:24:20.933 --> 00:24:23.500 align:middle
它会循环访问并且构建时间线

00:24:24.000 --> 00:24:25.100 align:middle
现在 易丽扎刚刚提到的

00:24:25.167 --> 00:24:28.300 align:middle
我们要以时间线
的形式提供数据

00:24:28.700 --> 00:24:31.300 align:middle
所以我们要循环访问

00:24:31.400 --> 00:24:32.267 align:middle
这是我最爱的部分

00:24:32.467 --> 00:24:35.400 align:middle
在手表屏幕上我可以
看到整个星期我喜欢的会话

00:24:36.333 --> 00:24:37.633 align:middle
现在 为了节省时间

00:24:37.700 --> 00:24:39.800 align:middle
今天我提前在
手表上构建且安装了

00:24:40.300 --> 00:24:42.833 align:middle
切换到这里 看一下如何添加

00:24:42.900 --> 00:24:44.033 align:middle
到我们的手表屏幕中

00:24:44.900 --> 00:24:46.167 align:middle
所以开始的时候

00:24:46.533 --> 00:24:49.033 align:middle
我在手表屏幕
上中间配置了日历

00:24:49.667 --> 00:24:51.833 align:middle
但因为我在WWDC
做完了这些

00:24:52.300 --> 00:24:54.067 align:middle
我们只要切换到这里
并且将其自定义

00:24:54.433 --> 00:24:57.433 align:middle
然后我们可以将
其滚动至程序列表的底端

00:24:57.800 --> 00:25:01.333 align:middle
你们可以看到现在大会上
的应用可以通过底部进入

00:24:57.800 --> 00:25:01.333 align:middle
你们可以看到现在大会上
的应用可以通过底部进入

00:25:02.067 --> 00:25:03.833 align:middle
我们可以点击那里打开

00:25:04.400 --> 00:25:06.533 align:middle
然后返回
查看我们的会话列表

00:25:06.867 --> 00:25:08.033 align:middle
现在 很明显美国平台

00:25:08.100 --> 00:25:10.233 align:middle
是我现在喜欢的会话

00:25:10.867 --> 00:25:14.167 align:middle
我们可以毫不费力
地向前进行时空之旅

00:25:14.400 --> 00:25:15.967 align:middle
通过会话列表

00:25:16.233 --> 00:25:18.267 align:middle
接下来看到的是苹果设计奖

00:25:18.500 --> 00:25:19.667 align:middle
这是我绝对不想错过的

00:25:20.267 --> 00:25:23.200 align:middle
往明天继续推进

00:25:23.667 --> 00:25:26.300 align:middle
可以看到早上
watchOS 2的介绍

00:25:26.367 --> 00:25:27.633 align:middle
这也绝对是我想要看的

00:25:28.833 --> 00:25:31.467 align:middle
所以更新你的
手表应用就这么简单

00:25:31.867 --> 00:25:34.867 align:middle
在watchOS上运行就像
本来就是其中的应用

00:25:35.467 --> 00:25:37.600 align:middle
非常好的特色

00:25:38.400 --> 00:25:39.233 align:middle
所以接下来

00:25:46.067 --> 00:25:47.967 align:middle
接下来
塞巴斯蒂安会告诉我们

00:25:48.033 --> 00:25:50.133 align:middle
一些非常好的新的基础技术

00:25:50.467 --> 00:25:51.467 align:middle
塞巴·斯蒂安:
谢谢 乔什

00:25:52.500 --> 00:25:53.333 align:middle
非常好

00:25:54.600 --> 00:25:57.600 align:middle
现在我们来谈论一些基础技术

00:25:58.067 --> 00:26:01.367 align:middle
应用在我们的平台中的技术

00:25:58.067 --> 00:26:01.367 align:middle
应用在我们的平台中的技术

00:26:01.433 --> 00:26:04.033 align:middle
我会从第一个性能开始说

00:26:04.567 --> 00:26:05.800 align:middle
和其压缩性

00:26:05.867 --> 00:26:07.333 align:middle
我们将会让压缩变得很有趣

00:26:08.167 --> 00:26:11.433 align:middle
苹果的产品一向使用许多

00:26:11.500 --> 00:26:14.967 align:middle
压缩算法作为
我们核心框架的一部分

00:26:15.033 --> 00:26:17.233 align:middle
优化速度的LZ4

00:26:17.300 --> 00:26:21.633 align:middle
高度的压缩性的LZMA
以及很多人用过的zlib

00:26:21.700 --> 00:26:24.833 align:middle
它可以找到压缩
和速度之间的最优点

00:26:25.167 --> 00:26:28.267 align:middle
我们开始构建
一个更好的压缩算法

00:26:28.333 --> 00:26:29.700 align:middle
使其在压缩库上更加进步

00:26:29.900 --> 00:26:32.500 align:middle
你可能知道
压缩库已经二十多年之久

00:26:32.767 --> 00:26:34.800 align:middle
处理器体系结构
改变之时就需要重建

00:26:34.867 --> 00:26:38.000 align:middle
所以我们认为
可以创建可以优化

00:26:38.300 --> 00:26:41.233 align:middle
现在处理器
和微体系结构的事物

00:26:42.100 --> 00:26:44.433 align:middle
现在 我们称这个新算法为
Lempel Ziv

00:26:44.500 --> 00:26:47.367 align:middle
Finite State
Entropy

00:26:47.433 --> 00:26:48.267 align:middle
你可能知道

00:26:48.700 --> 00:26:50.167 align:middle
他们还是
一个非常好的独立乐队

00:26:50.800 --> 00:26:52.400 align:middle
你应该到
Connect上去找看看

00:26:52.700 --> 00:26:56.900 align:middle
为避免任何困惑
我们简单称其为LZFSE

00:27:00.700 --> 00:27:03.800 align:middle
现在 LZFSE 谢谢

00:27:04.400 --> 00:27:07.333 align:middle
在压缩中 压缩库有所改进
但更重要的是

00:27:07.833 --> 00:27:11.133 align:middle
它比压缩库速度快三倍

00:27:11.600 --> 00:27:13.567 align:middle
这是一次巨大的进步

00:27:13.633 --> 00:27:15.967 align:middle
可以使你的应用更加敏感

00:27:16.567 --> 00:27:18.733 align:middle
另外它还延长电池寿命

00:27:19.400 --> 00:27:22.600 align:middle
在能量消耗
上它可以减少60%

00:27:23.067 --> 00:27:24.267 align:middle
在相同的压缩算法中

00:27:24.333 --> 00:27:26.833 align:middle
它在速度上快了三倍

00:27:27.333 --> 00:27:29.833 align:middle
最后
我们使用起来相当容易

00:27:30.033 --> 00:27:31.700 align:middle
我们已经将其添加
我们的标准框架中

00:27:32.100 --> 00:27:35.933 align:middle
你需要做的就是
改变算法 使用LZFSE

00:27:36.167 --> 00:27:38.200 align:middle
我们已经完成
了所有困难的工作

00:27:38.567 --> 00:27:40.200 align:middle
你和你的用户
可以享用其中的益处

00:27:40.467 --> 00:27:44.200 align:middle
这就是LZFSE
真正重新定义了最优点

00:27:44.300 --> 00:27:45.733 align:middle
在主流压缩中

00:27:46.700 --> 00:27:48.833 align:middle
接下来 我要说一下电池寿命

00:27:49.200 --> 00:27:50.767 align:middle
克雷格
今早提到了电池寿命

00:27:52.367 --> 00:27:55.733 align:middle
现在在这个行业中
我们测试电池寿命时

00:27:55.967 --> 00:27:59.100 align:middle
经常是重复性测试

00:27:59.200 --> 00:28:00.767 align:middle
举个例子
我们测试时在浏览器中

00:27:59.200 --> 00:28:00.767 align:middle
举个例子
我们测试时在浏览器中

00:28:00.833 --> 00:28:04.133 align:middle
一次又一次的浏览网页

00:28:04.500 --> 00:28:05.900 align:middle
我们知道现实生活中

00:28:06.700 --> 00:28:08.600 align:middle
我们使用这些设备的方法
与这些综合实验测试

00:28:08.667 --> 00:28:10.467 align:middle
的方法不一样 对吗？

00:28:10.533 --> 00:28:13.400 align:middle
我们将设备装进口袋再取出来

00:28:13.467 --> 00:28:17.333 align:middle
我们接收通知和信息
我们可能使用很多应用

00:28:17.400 --> 00:28:19.300 align:middle
我们连接网络 断开网络

00:28:19.600 --> 00:28:21.400 align:middle
所以在iOS 9上做的事

00:28:21.700 --> 00:28:25.133 align:middle
主要集中在最佳化基板组上

00:28:25.200 --> 00:28:28.867 align:middle
这样可以适用
在平台所有最流行的应用

00:28:29.867 --> 00:28:31.433 align:middle
这是第一步
第二步

00:28:31.500 --> 00:28:34.000 align:middle
我们关注
一些基础设施的改善

00:28:34.067 --> 00:28:37.500 align:middle
比如 一些算法
可以增亮背光灯

00:28:37.867 --> 00:28:40.800 align:middle
朝下检测
所以如果你接收到一条通知

00:28:41.100 --> 00:28:43.633 align:middle
当时不能看到它
由于手机屏幕朝下

00:28:43.700 --> 00:28:45.433 align:middle
我们无需让屏幕发亮

00:28:45.733 --> 00:28:47.467 align:middle
还有其它一些优化

00:28:47.533 --> 00:28:52.867 align:middle
比如系统如何进入睡眠状态
如何优化最低电源状态

00:28:53.900 --> 00:28:56.467 align:middle
所有的这些
最优化加起来可增加

00:28:56.533 --> 00:29:01.833 align:middle
一个小时额外使用时间
是针对一般用户的普通使用

00:28:56.533 --> 00:29:01.833 align:middle
一个小时额外使用时间
是针对一般用户的普通使用

00:29:02.167 --> 00:29:03.000 align:middle
真是巨大改善

00:29:03.167 --> 00:29:06.267 align:middle
今早克雷格还提到了省电模式

00:29:07.800 --> 00:29:10.167 align:middle
我们要开启省电模式很简单

00:29:10.500 --> 00:29:12.100 align:middle
只需要进入设置 开启

00:29:12.967 --> 00:29:16.267 align:middle
激活了一部分内部杠杆

00:29:16.800 --> 00:29:19.100 align:middle
比如
保护中央处理器和图形处理器

00:29:19.167 --> 00:29:21.133 align:middle
不受进入最高性能的破坏

00:29:21.567 --> 00:29:23.033 align:middle
除了最耗电的状态

00:29:23.567 --> 00:29:26.400 align:middle
保护应用免受
后台过度运行的影响

00:29:26.933 --> 00:29:30.367 align:middle
阻止它们进行
不必要的网络活动

00:29:30.867 --> 00:29:35.067 align:middle
最后关闭一些耗电的动画

00:29:35.433 --> 00:29:36.533 align:middle
总而言之
当你开始充电时

00:29:36.600 --> 00:29:42.133 align:middle
省电模式将会
为你增加三小时的使用时间

00:29:42.367 --> 00:29:43.833 align:middle
所以再次强调
这是巨大的进步

00:29:44.567 --> 00:29:47.200 align:middle
现在我开始保护客户数据

00:29:48.767 --> 00:29:50.700 align:middle
所以从一开始
苹果系统就真正

00:29:50.767 --> 00:29:52.300 align:middle
关注客户数据的保护

00:29:52.367 --> 00:29:56.567 align:middle
在iOS9中我们采取了
一些重要措施保护数据

00:29:56.633 --> 00:29:58.733 align:middle
包括设备中的和云端的

00:29:59.067 --> 00:30:00.067 align:middle
所以我们从云端说起吧

00:29:59.067 --> 00:30:00.067 align:middle
所以我们从云端说起吧

00:30:01.400 --> 00:30:05.100 align:middle
当然
用你的Apple ID进入

00:30:05.167 --> 00:30:07.233 align:middle
云端的一些服务中 你的照片

00:30:07.300 --> 00:30:11.367 align:middle
可能你有一些文档
存在云端中 你的购买记录

00:30:11.633 --> 00:30:13.867 align:middle
可以利用它在即时通讯和
视频通话中发送信息

00:30:14.167 --> 00:30:17.967 align:middle
云端对你的数据最大的威胁是

00:30:18.033 --> 00:30:20.500 align:middle
有人获得你的密码

00:30:21.167 --> 00:30:23.100 align:middle
可能是因为你在其他共享网站

00:30:23.367 --> 00:30:25.167 align:middle
分享过你的密码

00:30:25.700 --> 00:30:28.200 align:middle
或者可能攻击者
通过捕钓式的攻击

00:30:28.367 --> 00:30:30.033 align:middle
获得密码

00:30:30.567 --> 00:30:33.533 align:middle
这种情况的解决
办法是双因素认证

00:30:34.167 --> 00:30:36.333 align:middle
我们尽量把它做的简单
以使每个人都可以使用

00:30:36.733 --> 00:30:38.033 align:middle
我来向大家展示它如何运作

00:30:39.133 --> 00:30:42.433 align:middle
在iOS9中
当你得到一个新的设备

00:30:42.500 --> 00:30:45.067 align:middle
你就想要在
你的云端账户中登记

00:30:45.333 --> 00:30:47.567 align:middle
你将需要输入密码

00:30:47.633 --> 00:30:50.233 align:middle
此外 你还会输入验证码

00:30:51.100 --> 00:30:56.233 align:middle
同时我们向我们已有的
信任的设备发送通知

00:30:56.300 --> 00:31:01.133 align:middle
通知包括注册新设备的地址

00:30:56.300 --> 00:31:01.133 align:middle
通知包括注册新设备的地址

00:31:01.767 --> 00:31:03.267 align:middle
所以如果那是你在注册

00:31:03.667 --> 00:31:05.733 align:middle
你可以输入验证码

00:31:06.100 --> 00:31:08.667 align:middle
如果是攻击者
试图用你的账户注册

00:31:09.000 --> 00:31:10.867 align:middle
你可以凭借踪迹阻止他们

00:31:12.233 --> 00:31:14.767 align:middle
这是关于云端
现在说关于设备上的设备密码

00:31:14.833 --> 00:31:16.700 align:middle
设备密码是保护

00:31:16.767 --> 00:31:19.333 align:middle
私人数据的最后一道防线

00:31:20.100 --> 00:31:24.300 align:middle
在浏览历史中
我们保留四位数密码

00:31:24.400 --> 00:31:27.600 align:middle
因为你每次使用手机
都需要输入

00:31:28.433 --> 00:31:30.900 align:middle
但是当然
我们不会输入密码

00:31:30.967 --> 00:31:31.800 align:middle
太过频繁

00:31:32.267 --> 00:31:36.767 align:middle
我们使用指纹识别
中的指纹完美注册

00:31:36.833 --> 00:31:37.833 align:middle
我们的手机

00:31:38.333 --> 00:31:42.900 align:middle
所以现在在iOS9中
我们可以将密码

00:31:42.967 --> 00:31:45.133 align:middle
由四位数增至六位数

00:31:45.200 --> 00:31:48.233 align:middle
密码强度增至一百倍

00:31:48.700 --> 00:31:51.933 align:middle
不需要缓和设备使用的妥协

00:31:53.233 --> 00:31:54.567 align:middle
既然我们说到设备

00:31:55.033 --> 00:31:59.000 align:middle
我介绍一种用
在所有平台中的新技术

00:31:59.067 --> 00:32:00.733 align:middle
我们称之为苹果安全传输

00:31:59.067 --> 00:32:00.733 align:middle
我们称之为苹果安全传输

00:32:01.133 --> 00:32:04.267 align:middle
苹果安全传输是
真正关于所有的安全数据

00:32:04.333 --> 00:32:07.500 align:middle
它从一个设备传输到网络

00:32:07.567 --> 00:32:10.133 align:middle
或者从你的应用传输到
你的终端服务器

00:32:11.233 --> 00:32:14.333 align:middle
因此我们当然想要需要的信息

00:32:14.400 --> 00:32:15.700 align:middle
在网络传输中安全

00:32:16.233 --> 00:32:17.767 align:middle
但是结果证明现在

00:32:17.833 --> 00:32:19.333 align:middle
对大家来说真的很难

00:32:19.500 --> 00:32:20.400 align:middle
很难将其做好

00:32:20.900 --> 00:32:21.867 align:middle
你不能使用传输协议

00:32:21.933 --> 00:32:24.667 align:middle
你必须使用一个安全协议

00:32:24.733 --> 00:32:27.600 align:middle
然后需要担心协议
的版本降级攻击

00:32:28.100 --> 00:32:29.733 align:middle
数据加密 保密性

00:32:30.133 --> 00:32:33.367 align:middle
最佳规范

00:32:33.767 --> 00:32:34.833 align:middle
这些做法非常难

00:32:34.900 --> 00:32:39.533 align:middle
在苹果安全传输中
我们核心框架搭建它

00:32:39.967 --> 00:32:43.100 align:middle
所以现在当你使用我们的
标准网络框架

00:32:43.500 --> 00:32:47.500 align:middle
我们会建立一个最好的
安全实践连接

00:32:47.767 --> 00:32:50.533 align:middle
在你的应用和后台服务器之间

00:32:51.367 --> 00:32:55.033 align:middle
现在最佳实践是安全传输层
协议1.2和正向保密

00:32:55.100 --> 00:32:58.767 align:middle
但是因为标准和
的发展最高技术

00:32:59.200 --> 00:33:01.300 align:middle
框架当然要使用最新技术

00:32:59.200 --> 00:33:01.300 align:middle
框架当然要使用最新技术

00:33:01.367 --> 00:33:05.200 align:middle
并且自动为你执行

00:33:13.200 --> 00:33:15.867 align:middle
所以 要从哪里开始？

00:33:16.133 --> 00:33:17.900 align:middle
如果你用完了标准网络框架

00:33:17.967 --> 00:33:20.900 align:middle
比如 NSURL会话
那么它会被马上创建

00:33:21.200 --> 00:33:23.367 align:middle
这是iOS9默认的

00:33:23.433 --> 00:33:25.067 align:middle
所以你下载开发者系数时

00:33:25.133 --> 00:33:27.033 align:middle
我敢肯定
很多人都已经下载过了

00:33:27.800 --> 00:33:29.200 align:middle
你就会重新编译你的应用

00:33:29.267 --> 00:33:31.633 align:middle
我们会在后台执行
最佳实践

00:33:31.700 --> 00:33:32.533 align:middle
安全连接

00:33:32.933 --> 00:33:35.767 align:middle
可能你
还没与更新你的后台

00:33:35.833 --> 00:33:37.433 align:middle
至最佳实践

00:33:37.500 --> 00:33:39.500 align:middle
或者你在使用
第三方数据库

00:33:39.967 --> 00:33:43.167 align:middle
如果是这样 我们
提供了异常机制

00:33:43.233 --> 00:33:47.300 align:middle
给你时间来通过位置服务平台
更新你的后台

00:33:48.300 --> 00:33:50.100 align:middle
这就是苹果安全传输

00:33:50.400 --> 00:33:52.567 align:middle
让我们转换到计算机

00:33:52.900 --> 00:33:54.233 align:middle
介绍一种新技术

00:33:54.300 --> 00:33:56.567 align:middle
我们称之为
系统完整性保护

00:33:57.633 --> 00:34:01.133 align:middle
在个人消费型电脑中
用户账户有明显的

00:33:57.633 --> 00:34:01.133 align:middle
在个人消费型电脑中
用户账户有明显的

00:34:01.200 --> 00:34:03.733 align:middle
管理特权
并且这种管理特权是

00:34:03.800 --> 00:34:05.500 align:middle
真的等同于内核访问

00:34:05.933 --> 00:34:08.800 align:middle
这就使保护系统
的完整性变得很难

00:34:09.766 --> 00:34:11.300 align:middle
在系统的完整性保护中

00:34:11.667 --> 00:34:13.167 align:middle
我们破坏了等同的状态

00:34:13.632 --> 00:34:17.533 align:middle
管理级别的访问不再充分

00:34:17.600 --> 00:34:19.300 align:middle
为了在系统中做一些运作

00:34:19.367 --> 00:34:20.766 align:middle
我来举一些例子

00:34:21.567 --> 00:34:24.533 align:middle
比如 如果你有管理级别
访问的特权

00:34:24.833 --> 00:34:26.733 align:middle
你不能梗更改系统文件

00:34:27.333 --> 00:34:29.333 align:middle
你不能将程序安装至
系统的位置

00:34:29.833 --> 00:34:33.667 align:middle
你不能依附系统程序 比如

00:34:33.733 --> 00:34:35.699 align:middle
内省记忆
或者改变控制程序

00:34:36.467 --> 00:34:39.132 align:middle
所以对于现在出现的
数据库 我们希望

00:34:39.199 --> 00:34:40.933 align:middle
大家下载下来 测试你的应用

00:34:41.000 --> 00:34:46.400 align:middle
以确保你基本上可以将其
粘附在所有的规则上

00:34:48.632 --> 00:34:50.367 align:middle
现在 你可能还想知道

00:34:50.433 --> 00:34:52.167 align:middle
这是如何影响我的应用开发

00:34:52.233 --> 00:34:54.199 align:middle
好消息是
我们已经更新了XCode

00:34:54.266 --> 00:34:57.633 align:middle
发展了工具链
对大多数人来说

00:34:57.700 --> 00:34:58.800 align:middle
你们看不出什么不同

00:34:59.567 --> 00:35:02.133 align:middle
对那些有明确
开发要求的人来说

00:34:59.567 --> 00:35:02.133 align:middle
对那些有明确
开发要求的人来说

00:35:02.200 --> 00:35:05.467 align:middle
比如 你在开发X系统
的内核功能扩展

00:35:05.767 --> 00:35:08.833 align:middle
我们也提供了一种功用
这也是恢复分区的一部分

00:35:09.167 --> 00:35:11.600 align:middle
它可以让你失去
系统完整性保护的能力

00:35:13.367 --> 00:35:16.733 align:middle
这就指向了我要说的
最后一种技术

00:35:16.800 --> 00:35:20.067 align:middle
一种巩固现代网络的技术
互联网协议6

00:35:21.567 --> 00:35:23.067 align:middle
为什么
互联网协议6这么重要？

00:35:23.567 --> 00:35:26.400 align:middle
我们都听说过
互联网协议4地址的不足

00:35:26.833 --> 00:35:27.667 align:middle
猜猜看

00:35:27.967 --> 00:35:28.967 align:middle
最终在这里

00:35:29.233 --> 00:35:31.367 align:middle
实际上
2011年在中国和亚洲

00:35:31.433 --> 00:35:34.633 align:middle
已经不用互联网协议4地址

00:35:34.700 --> 00:35:37.833 align:middle
在美国 我们也将在
接下来的几个月中放弃

00:35:39.067 --> 00:35:41.233 align:middle
意味着实践中一些

00:35:41.300 --> 00:35:44.333 align:middle
媒介物现在在配置
只用互联网协议6的网络

00:35:44.867 --> 00:35:47.933 align:middle
如果你的应用在互联网
协议6中不能正常运作

00:35:48.000 --> 00:35:51.100 align:middle
它在那些媒介
网络也不会运作

00:35:51.167 --> 00:35:52.167 align:middle
对那些客户也不会运作

00:35:52.300 --> 00:35:54.033 align:middle
所以支持互联网协议6
真的很重要

00:35:55.000 --> 00:35:57.833 align:middle
好消息是
一直以来作为平台的一部分

00:35:57.900 --> 00:36:01.300 align:middle
互联网协议6
已经得到了支持超过了10%

00:35:57.900 --> 00:36:01.300 align:middle
互联网协议6
已经得到了支持超过了10%

00:36:01.833 --> 00:36:03.233 align:middle
已得到现场证实

00:36:03.300 --> 00:36:06.700 align:middle
很多使用我们的标准
网络框架的人在使用

00:36:06.767 --> 00:36:07.833 align:middle
互联网协议6

00:36:08.300 --> 00:36:09.633 align:middle
但是我们希望得到进一步发展

00:36:09.700 --> 00:36:11.500 align:middle
我们想确保
每个人都创建一款应用

00:36:11.867 --> 00:36:13.900 align:middle
能在互联网协议6网络中运行

00:36:14.100 --> 00:36:16.500 align:middle
所以我们为大家准备了秘诀

00:36:17.433 --> 00:36:19.233 align:middle
使用标准网络框架

00:36:19.700 --> 00:36:21.300 align:middle
我们已经提到过NSUL会话

00:36:22.033 --> 00:36:24.700 align:middle
这真的关系到
获得网络的复杂性

00:36:25.300 --> 00:36:28.033 align:middle
避免使用互联网协议4
的程序语言系统

00:36:28.500 --> 00:36:32.600 align:middle
很多甚至在构思互联网协议6
之前就已经得到发展

00:36:33.167 --> 00:36:35.100 align:middle
最后
不要将地址进行硬式编码

00:36:36.000 --> 00:36:38.167 align:middle
一旦你按照这个秘诀
你会说

00:36:38.233 --> 00:36:39.867 align:middle
我如何测试它是否正常运行

00:36:40.400 --> 00:36:43.133 align:middle
因为并非所有人
都可以进入互联网协议6网络

00:36:44.000 --> 00:36:47.033 align:middle
好消息是大家
为了研发都使用个人电脑

00:36:47.500 --> 00:36:48.600 align:middle
我们正在用最新的数据库

00:36:48.667 --> 00:36:52.600 align:middle
将你们的电脑变为
互联网协议6 网络模拟器

00:36:53.600 --> 00:36:55.300 align:middle
所以你所需要的就是

00:36:55.367 --> 00:36:58.267 align:middle
通过一个新连接分享模式
简历一个个人热点

00:36:58.333 --> 00:37:00.900 align:middle
你只要查看
互联网协议6的盒子

00:36:58.333 --> 00:37:00.900 align:middle
你只要查看
互联网协议6的盒子

00:37:01.233 --> 00:37:04.200 align:middle
你就可以连接你的测试设备
测试你的应用

00:37:04.300 --> 00:37:07.100 align:middle
确保它们在互联网协议6
中运行很简单

00:37:15.633 --> 00:37:18.533 align:middle
最后因为互联网协议6的
支持很关键

00:37:18.600 --> 00:37:21.267 align:middle
对保证世界上
大家应用的运行来说

00:37:21.833 --> 00:37:22.833 align:middle
对每位客户而言

00:37:23.200 --> 00:37:26.567 align:middle
我们将它作为一个
苹果储备提交要求

00:37:26.633 --> 00:37:27.467 align:middle
从iOS9开始

00:37:29.267 --> 00:37:32.200 align:middle
所以这就是我要说的
基础技术

00:37:32.567 --> 00:37:36.000 align:middle
现在我把它交给我的同伴
加拿大人 托比·帕特森

00:37:36.233 --> 00:37:38.033 align:middle
他将会说到更高水平的
程序语言系统

00:37:38.500 --> 00:37:39.333 align:middle
托比？

00:37:47.367 --> 00:37:48.800 align:middle
托比·帕特森:
我知道大家都来自

00:37:48.867 --> 00:37:51.033 align:middle
世界各地
一些人甚至来自

00:37:51.100 --> 00:37:53.300 align:middle
跟加拿大一样遥远的地方

00:37:55.867 --> 00:37:58.500 align:middle
你们的客户就
像大家一样各种各样

00:37:59.467 --> 00:38:02.233 align:middle
有趣的是 你们可能没注意到

00:37:59.467 --> 00:38:02.233 align:middle
有趣的是 你们可能没注意到

00:38:02.733 --> 00:38:05.767 align:middle
这个表格显示了世界上
苹果专卖店

00:38:05.833 --> 00:38:06.767 align:middle
是按国家划分的

00:38:07.367 --> 00:38:09.300 align:middle
它告诉我们一件有趣的事情

00:38:09.533 --> 00:38:11.900 align:middle
如果你的商店没有
在正确的位置

00:38:12.267 --> 00:38:15.467 align:middle
你就不会得到
除了你的客户之外的

00:38:15.533 --> 00:38:16.900 align:middle
大多数潜在客户

00:38:17.733 --> 00:38:19.933 align:middle
现在 有个好消息
这对大家来说并不难

00:38:21.133 --> 00:38:24.267 align:middle
我们有国际化和地区化指导

00:38:24.467 --> 00:38:26.433 align:middle
它可以告诉你
你想知道的一切

00:38:26.767 --> 00:38:28.500 align:middle
当然
我们已经得到很大的支持

00:38:28.567 --> 00:38:30.800 align:middle
在框架以及微软
软件开发工具包方面

00:38:31.567 --> 00:38:33.767 align:middle
我们有数据
和数字的格式化程序

00:38:34.400 --> 00:38:36.800 align:middle
今年 我们介绍
一种新的格式化程序

00:38:37.133 --> 00:38:39.333 align:middle
来帮助你
正确显示人们的名字

00:38:40.567 --> 00:38:42.100 align:middle
名字是一件很棘手的事情

00:38:42.367 --> 00:38:44.000 align:middle
每个人都有

00:38:44.433 --> 00:38:46.767 align:middle
但不同的文化 有不同的意义

00:38:46.833 --> 00:38:49.133 align:middle
关于他们的用途有不同的习俗

00:38:50.233 --> 00:38:53.800 align:middle
在英语中 我们
先写名字 中间姓 姓氏

00:38:54.333 --> 00:38:56.933 align:middle
在中国 却不一样
先写姓氏

00:38:57.033 --> 00:38:59.800 align:middle
而且根本没有中间字

00:39:01.067 --> 00:39:03.867 align:middle
NSP的名字组成很格式化

00:39:04.267 --> 00:39:06.633 align:middle
我保证看起来
比听起来更像编码

00:39:06.700 --> 00:39:07.867 align:middle
当你大神说出它时

00:39:12.500 --> 00:39:14.967 align:middle
这关系到大家的所有细节

00:39:15.400 --> 00:39:17.733 align:middle
它甚至还有一些文化智慧

00:39:17.800 --> 00:39:20.633 align:middle
所以如果你问一个人
有没有短一点的名字吗

00:39:21.000 --> 00:39:24.400 align:middle
可能不太合适
使用一个人的姓

00:39:24.933 --> 00:39:26.033 align:middle
或者就直接使用它本身

00:39:28.133 --> 00:39:32.100 align:middle
对于阿拉伯和犹太人
我们有一些好消息

00:39:32.700 --> 00:39:35.967 align:middle
我们已经得到了初步的支持
不客气

00:39:36.633 --> 00:39:38.633 align:middle
我们已经得到了初步支持

00:39:38.700 --> 00:39:40.200 align:middle
近年来在这些语言方面

00:39:40.267 --> 00:39:43.033 align:middle
在系统中
文本被严格限制

00:39:43.100 --> 00:39:46.000 align:middle
但是 个人电脑
已经有了更复杂的布局

00:39:46.067 --> 00:39:47.300 align:middle
在用户界面元素中

00:39:48.000 --> 00:39:50.433 align:middle
我很高兴能够
告诉你们在苹果iOS9中

00:39:50.500 --> 00:39:54.600 align:middle
我们已经全面检测了
用户界面对右向语言的支持

00:40:00.100 --> 00:40:01.767 align:middle
这是它在跳板里的样子

00:40:03.500 --> 00:40:05.600 align:middle
现在 我们还未撤销

00:40:05.667 --> 00:40:07.367 align:middle
屏幕上的用户界面元素

00:40:07.433 --> 00:40:09.500 align:middle
这是一种深层次的切换

00:40:09.867 --> 00:40:12.767 align:middle
在视图控制器 用户交互

00:40:13.133 --> 00:40:16.233 align:middle
和系统手势间
进行的程序切换

00:40:16.767 --> 00:40:19.800 align:middle
如果换做希伯来或阿拉伯人

00:40:19.867 --> 00:40:22.133 align:middle
设计的话
用户界面应该是这样

00:40:23.167 --> 00:40:25.300 align:middle
我们来看看它在手机上的样子

00:40:25.500 --> 00:40:27.533 align:middle
我想介绍沙拉·卡迪

00:40:27.600 --> 00:40:28.867 align:middle
你们可以快速地看一下

00:40:35.500 --> 00:40:39.067 align:middle
我们体验一下iOS 9系统
支持的从右到左新式语言

00:40:39.567 --> 00:40:41.600 align:middle
现在
我的手机语言是阿拉伯语

00:40:41.667 --> 00:40:44.400 align:middle
我们先锁屏
从右向左滑屏

00:40:44.467 --> 00:40:45.867 align:middle
解开手机锁

00:40:46.433 --> 00:40:50.167 align:middle
这里
从右向左是应用程序图标

00:40:50.900 --> 00:40:52.767 align:middle
页面视图自然地

00:40:52.833 --> 00:40:54.867 align:middle
从第一页过渡到第二页

00:40:56.900 --> 00:41:00.633 align:middle
整个系统和所有自带软件都支

00:40:56.900 --> 00:41:00.633 align:middle
整个系统和所有自带软件都支

00:41:00.700 --> 00:41:03.733 align:middle
持用户界面镜像
或从右向左定位

00:41:04.100 --> 00:41:06.367 align:middle
以照片应用程序为例

00:41:07.833 --> 00:41:11.867 align:middle
这些照片是按照我意愿排列的

00:41:12.200 --> 00:41:15.967 align:middle
整个用户界面位于导航栏右侧

00:41:16.033 --> 00:41:19.233 align:middle
而导航栏位于
下方菜单栏的顶部

00:41:20.700 --> 00:41:22.200 align:middle
现在 我们体验一下电子邮件

00:41:24.700 --> 00:41:28.233 align:middle
它的标准布局 导航栏

00:41:28.300 --> 00:41:30.833 align:middle
手势浏览和动画都可随意设置

00:41:31.333 --> 00:41:34.033 align:middle
所以 点击邮件
快速获取信息

00:41:34.433 --> 00:41:36.367 align:middle
从屏幕左侧

00:41:36.433 --> 00:41:38.167 align:middle
拖动至右侧

00:41:39.833 --> 00:41:42.933 align:middle
会出现
表视图单元格的排版流程

00:41:44.167 --> 00:41:48.033 align:middle
手势导航也会

00:41:48.333 --> 00:41:49.900 align:middle
从屏幕右侧进入页面

00:41:52.033 --> 00:41:53.433 align:middle
现在
把手机旋转到竖屏模式

00:41:53.533 --> 00:41:55.833 align:middle
出现的消息窗口

00:41:56.300 --> 00:41:59.233 align:middle
让我这个母语人士感到很自然

00:41:59.433 --> 00:42:01.633 align:middle
因为所有的邮件标题在右侧

00:41:59.433 --> 00:42:01.633 align:middle
因为所有的邮件标题在右侧

00:42:02.233 --> 00:42:03.600 align:middle
而信息详情在左侧

00:42:04.400 --> 00:42:07.033 align:middle
因为所有的Email
都已置入UIKit中

00:42:07.367 --> 00:42:10.100 align:middle
所以您也可免费操作这一流程

00:42:10.200 --> 00:42:12.033 align:middle
进行从右向左定位

00:42:13.300 --> 00:42:15.567 align:middle
接下来
我向您展示一下苹果

00:42:15.633 --> 00:42:16.833 align:middle
软件商店的第三方应用程序

00:42:19.167 --> 00:42:21.467 align:middle
您们一定认为
我们不选择

00:42:21.533 --> 00:42:23.433 align:middle
Kayak
因为它的名字是个回文

00:42:23.500 --> 00:42:26.767 align:middle
或者说您
可以从右向左阅读信息

00:42:33.333 --> 00:42:36.233 align:middle
因其采用自动布局和耗能最小

00:42:36.300 --> 00:42:40.267 align:middle
新式应用程序接口
所以添加上翻译

00:42:40.333 --> 00:42:42.300 align:middle
软件这个程序就能如期运行

00:42:43.067 --> 00:42:46.233 align:middle
所以 在WWDC结束后
我打算去旅行

00:42:46.300 --> 00:42:47.533 align:middle
我来浏览一些消息

00:42:49.567 --> 00:42:53.167 align:middle
所以 拖动第一个滑块
可选择旅游的时间

00:42:53.233 --> 00:42:56.700 align:middle
往右滑动

00:42:56.767 --> 00:42:57.800 align:middle
可减少旅行的天数

00:42:57.867 --> 00:43:00.800 align:middle
它采用了股票用户界面滑块

00:42:57.867 --> 00:43:00.800 align:middle
它采用了股票用户界面滑块

00:43:00.900 --> 00:43:02.267 align:middle
所以您可免费使用这一软件

00:43:03.567 --> 00:43:05.933 align:middle
因为我只喜欢直达航班

00:43:06.000 --> 00:43:09.867 align:middle
所以
打开下面的按键 你可以看到

00:43:09.933 --> 00:43:11.467 align:middle
它会从右侧移动到左侧

00:43:11.700 --> 00:43:15.967 align:middle
右侧呈现整个用户界面

00:43:16.300 --> 00:43:17.733 align:middle
因为采用的是母语
所以很直观

00:43:18.533 --> 00:43:22.333 align:middle
把从左向右定位
添加到iOS 9

00:43:22.400 --> 00:43:23.900 align:middle
软件是多么容易啊

00:43:24.067 --> 00:43:24.900 align:middle
谢谢大家

00:43:27.400 --> 00:43:28.300 align:middle
现在我们再讲讲托比

00:43:30.033 --> 00:43:30.933 align:middle
托比 帕特森
谢谢 莎拉

00:43:33.567 --> 00:43:36.533 align:middle
正如莎拉所讲
我们全力支持UIKit

00:43:36.600 --> 00:43:38.500 align:middle
和其他系统框架

00:43:38.867 --> 00:43:40.700 align:middle
你的应用程序可以免费安装

00:43:40.767 --> 00:43:42.133 align:middle
这些软件

00:43:42.800 --> 00:43:45.333 align:middle
您如果有自定义
视图或手势识别

00:43:45.667 --> 00:43:47.567 align:middle
您确实该好好考虑

00:43:47.733 --> 00:43:49.167 align:middle
从右向左语言给您带来的好处

00:43:50.033 --> 00:43:52.733 align:middle
我不会向您
展示和推销这里的API

00:43:52.800 --> 00:43:55.900 align:middle
也不会赘述UI的流动方式

00:43:55.967 --> 00:43:59.033 align:middle
您可以为您的
UI做出自己合理的选择

00:44:00.700 --> 00:44:02.867 align:middle
下面我讲讲链接

00:44:03.533 --> 00:44:06.400 align:middle
这里是指您从
朋友信息或邮件里

00:44:06.467 --> 00:44:07.667 align:middle
获得的链接

00:44:08.467 --> 00:44:11.533 align:middle
点击链接
您就会打开一个网页

00:44:12.133 --> 00:44:14.333 align:middle
这正是您想
从电脑上获取的网页

00:44:14.400 --> 00:44:17.767 align:middle
Safari就是为
网站应用程序所开发的

00:44:18.933 --> 00:44:21.700 align:middle
另一方面
IOS是唯一的本地应用程序

00:44:21.800 --> 00:44:24.333 align:middle
在相关应用程序点击同样链接

00:44:24.400 --> 00:44:28.333 align:middle
可以进入同一网页
这不是很棒么

00:44:29.833 --> 00:44:33.800 align:middle
这正是iOS 9做出的突破

00:44:34.467 --> 00:44:39.967 align:middle
点击软件的链接同样可以

00:44:41.100 --> 00:44:43.933 align:middle
打开您想打开的页面

00:44:44.000 --> 00:44:45.433 align:middle
这在您当前的页面操作就可以

00:44:45.800 --> 00:44:48.700 align:middle
电脑的Safari浏览器
或iOS系统的本地应用

00:44:49.367 --> 00:44:50.233 align:middle
这是它的运行过程

00:44:51.433 --> 00:44:55.333 align:middle
将文件托管
到URL服务器的网页

00:44:55.400 --> 00:44:57.533 align:middle
您的应用程序便可本地化处理

00:44:58.200 --> 00:45:00.467 align:middle
当用户点击
其中某一URL服务器时

00:44:58.200 --> 00:45:00.467 align:middle
当用户点击
其中某一URL服务器时

00:45:00.933 --> 00:45:04.333 align:middle
我们把它包装在NSUser
Activity

00:45:04.400 --> 00:45:06.600 align:middle
以切换的方式交付给应用软件

00:45:06.667 --> 00:45:08.967 align:middle
这就是运行过程

00:45:09.033 --> 00:45:09.867 align:middle
就这样简单

00:45:11.833 --> 00:45:14.667 align:middle
我愿意谈谈
关于iOS 9新奇的事

00:45:15.500 --> 00:45:17.300 align:middle
先从HomeKit智能家居平台说起

00:45:18.200 --> 00:45:20.867 align:middle
今天早晨我们
公布了HomeKit平台

00:45:20.933 --> 00:45:22.333 align:middle
的几个新特点

00:45:22.400 --> 00:45:26.200 align:middle
当然我们将继续
提高HomeKit运营体系

00:45:27.933 --> 00:45:29.667 align:middle
现在 特定级别的配件

00:45:30.000 --> 00:45:33.700 align:middle
可以向你的设备直接推送

00:45:34.100 --> 00:45:36.267 align:middle
门窗及报警系统推送信息

00:45:37.033 --> 00:45:38.867 align:middle
而且 我们的新系统界面

00:45:38.933 --> 00:45:41.933 align:middle
可以和智能家居
网络实现共享管理

00:45:42.867 --> 00:45:44.367 align:middle
在设置中进行设置

00:45:44.433 --> 00:45:48.733 align:middle
另外 你还可以通过
程序编程接口对接自己的应用

00:45:50.267 --> 00:45:52.533 align:middle
不过
我认为真正有趣的事情是

00:45:52.600 --> 00:45:53.467 align:middle
事件触发器

00:45:54.200 --> 00:45:58.233 align:middle
你可以设置
“如果…那么…”的动作程序

00:45:58.300 --> 00:46:00.133 align:middle
这样你可以
设定激活报警系统的时候

00:45:58.300 --> 00:46:00.133 align:middle
这样你可以
设定激活报警系统的时候

00:46:00.200 --> 00:46:02.700 align:middle
选择关闭灯光

00:46:02.767 --> 00:46:05.133 align:middle
或者
可以在早晨的时候开启咖啡机

00:46:05.733 --> 00:46:07.567 align:middle
我认为
这些功能以后将会非常有用

00:46:09.267 --> 00:46:10.767 align:middle
现在我们
在搜索方面也有了新突破

00:46:10.833 --> 00:46:12.667 align:middle
我想大家会感兴趣

00:46:13.833 --> 00:46:15.800 align:middle
当然 重磅消息是

00:46:15.867 --> 00:46:18.433 align:middle
iSO现在可以
对你的应用内容进行搜索了

00:46:19.000 --> 00:46:20.300 align:middle
我们有了丰富的搜索结果

00:46:20.367 --> 00:46:22.000 align:middle
当用户点击时

00:46:22.067 --> 00:46:25.033 align:middle
将直接对应
到应用中的具体位置

00:46:26.233 --> 00:46:29.267 align:middle
对应用数据
进行索引一共有三种方法

00:46:29.967 --> 00:46:33.067 align:middle
核心聚焦可以直接搜索

00:46:33.133 --> 00:46:35.300 align:middle
全部的应用内容

00:46:36.033 --> 00:46:39.300 align:middle
现在 某些数据有时限性

00:46:39.767 --> 00:46:43.100 align:middle
这样你可以选择
对一款应用进行索引扩展

00:46:43.500 --> 00:46:45.400 align:middle
核心聚焦会在特定时间启动

00:46:45.467 --> 00:46:49.667 align:middle
以确保索引更新索引更新

00:46:51.200 --> 00:46:55.067 align:middle
索引数据的另一种方式是
NSUerActivity

00:46:55.767 --> 00:46:58.967 align:middle
NSUerActivity
对应用内的用户所见

00:46:59.033 --> 00:47:00.300 align:middle
及行为进行索引

00:46:59.033 --> 00:47:00.300 align:middle
及行为进行索引

00:47:00.500 --> 00:47:04.167 align:middle
这样方便循迹并返回应用

00:47:05.333 --> 00:47:08.567 align:middle
最后 如果应用
正在生成网站镜像

00:47:08.633 --> 00:47:10.133 align:middle
你可以对网站进行加示

00:47:10.200 --> 00:47:15.300 align:middle
这样网络爬虫
会找到网站编入索引

00:47:15.500 --> 00:47:18.867 align:middle
之后在设备上进行本地搜索时
则直接提供结果

00:47:20.967 --> 00:47:25.367 align:middle
正如大家今早
看到的新搜索界面

00:47:26.000 --> 00:47:28.100 align:middle
现在我们有了新系列搜索建议

00:47:28.167 --> 00:47:29.167 align:middle
可供使用

00:47:29.233 --> 00:47:30.800 align:middle
这是无需手动输入的

00:47:32.000 --> 00:47:34.567 align:middle
当然
Siri甚至可以在应用内部

00:47:34.633 --> 00:47:36.100 align:middle
进行结果建议

00:47:38.167 --> 00:47:40.100 align:middle
如果您正用NSUser
Activity

00:47:40.167 --> 00:47:43.200 align:middle
进行用户应用行为记录

00:47:43.633 --> 00:47:47.900 align:middle
那么在出现预设建议时
Siri可以对记录进行搜索

00:47:48.467 --> 00:47:50.600 align:middle
会注意到我们在NSUser
Activity

00:47:50.667 --> 00:47:52.200 align:middle
基础上做足了功夫

00:47:52.267 --> 00:47:53.667 align:middle
有Handoff功能

00:47:53.967 --> 00:47:57.300 align:middle
还有通用连接 搜索 建议等

00:47:57.733 --> 00:48:02.000 align:middle
这正是我们在现有基础上
进行开发的绝佳实例

00:47:57.733 --> 00:48:02.000 align:middle
这正是我们在现有基础上
进行开发的绝佳实例

00:48:02.067 --> 00:48:04.600 align:middle
从而让应用和
整个行业系统有更多成果

00:48:06.400 --> 00:48:09.667 align:middle
今天早上的重大消息
是多任务功能

00:48:09.767 --> 00:48:12.100 align:middle
我们很高兴能
在今天和大家分享

00:48:13.633 --> 00:48:16.567 align:middle
有滑屏和拆分视图

00:48:17.200 --> 00:48:21.267 align:middle
这些功能让你在同一时间
进行多任务应用处理

00:48:21.733 --> 00:48:24.833 align:middle
我想大家肯定会有疑问

00:48:24.900 --> 00:48:27.000 align:middle
我该怎么做

00:48:27.067 --> 00:48:29.167 align:middle
才能让好好使用新功能呢

00:48:30.200 --> 00:48:33.900 align:middle
其实 答案不言而喻

00:48:34.700 --> 00:48:38.567 align:middle
大家可能还记得
去年我们推出自适应用户界面

00:48:38.633 --> 00:48:40.167 align:middle
这是一个非常简单的概念

00:48:40.633 --> 00:48:42.900 align:middle
与其设计一种布局

00:48:42.967 --> 00:48:45.233 align:middle
与其设计固
定屏幕尺寸的用户界面的

00:48:45.300 --> 00:48:50.067 align:middle
然后根据
窗口大小进行适应变化

00:48:50.733 --> 00:48:53.300 align:middle
而且我们还
提供了一些工具进行协助

00:48:53.833 --> 00:48:56.433 align:middle
可对文字进行动态布局

00:48:56.500 --> 00:49:01.133 align:middle
以及根据用户界面
的变化进行自动布局

00:48:56.500 --> 00:49:01.133 align:middle
以及根据用户界面
的变化进行自动布局

00:49:01.867 --> 00:49:03.067 align:middle
当然 现在我们知道

00:49:03.133 --> 00:49:05.233 align:middle
只有一个布局是无法满足

00:49:05.300 --> 00:49:07.433 align:middle
不同尺寸的屏幕要求

00:49:07.733 --> 00:49:11.333 align:middle
所以我们推出了尺寸分级

00:49:11.600 --> 00:49:14.700 align:middle
就可以选择合适的布局尺寸

00:49:14.767 --> 00:49:17.633 align:middle
无需查看设备

00:49:19.067 --> 00:49:23.433 align:middle
这是通过尺寸分类
屏幕大小实现的

00:49:23.500 --> 00:49:26.067 align:middle
分为两大类
常规级别和压缩级别

00:49:26.133 --> 00:49:30.500 align:middle
在这里你可以看到
iPad屏幕尺寸是常规级别

00:49:30.767 --> 00:49:34.100 align:middle
而iPhone则是紧凑级别

00:49:34.800 --> 00:49:37.200 align:middle
我们使用完全相同的机制

00:49:37.267 --> 00:49:38.933 align:middle
设计多任务用户界面

00:49:40.000 --> 00:49:41.833 align:middle
你可以在这里看到滑屏视图

00:49:41.900 --> 00:49:44.600 align:middle
的尺寸是紧凑级别

00:49:44.900 --> 00:49:48.067 align:middle
当我在分屏视图中
显示两个应用程序

00:49:48.967 --> 00:49:52.000 align:middle
我们调整了
左边的主应用的边界

00:49:52.567 --> 00:49:55.567 align:middle
调整到常规级别

00:49:56.233 --> 00:50:00.667 align:middle
现在 有趣的是
当你平均调整拆分视图

00:49:56.233 --> 00:50:00.667 align:middle
现在 有趣的是
当你平均调整拆分视图

00:50:01.167 --> 00:50:03.833 align:middle
不仅是调整这里的窗口边界

00:50:03.900 --> 00:50:07.267 align:middle
同时也会将左边主应用尺寸

00:50:07.333 --> 00:50:09.200 align:middle
由常规调整好紧凑级别

00:50:10.100 --> 00:50:12.200 align:middle
我们发现在自己的应用中

00:50:12.267 --> 00:50:15.533 align:middle
这样的窗口尺寸是最佳的

00:50:16.867 --> 00:50:20.567 align:middle
所以如果
你已经适应了应用的界面

00:50:21.033 --> 00:50:23.400 align:middle
那么其他的可以交给该功能了

00:50:24.900 --> 00:50:26.600 align:middle
你需要使用分镜功能

00:50:26.667 --> 00:50:30.100 align:middle
用于灵活替代默认ping

00:50:31.033 --> 00:50:33.733 align:middle
然后就可以支持所有其的了

00:50:33.900 --> 00:50:34.733 align:middle
就是这样

00:50:35.067 --> 00:50:37.867 align:middle
克雷格今天上午提到
我们可以在数分钟内转换应用

00:50:37.933 --> 00:50:41.200 align:middle
并启动运行

00:50:41.333 --> 00:50:42.200 align:middle
这真的很棒

00:50:43.567 --> 00:50:45.900 align:middle
今天早上
我们还宣布了画中画功能

00:50:46.233 --> 00:50:49.133 align:middle
让你可以在
不关闭其它应用的情况下

00:50:49.200 --> 00:50:50.633 align:middle
观看视频

00:50:51.067 --> 00:50:53.567 align:middle
如果你开发的是视频应用

00:50:53.633 --> 00:50:56.733 align:middle
那么这项功能
真的是为你量身定制的

00:50:57.833 --> 00:50:59.133 align:middle
当然 你的设备必须

00:50:59.200 --> 00:51:01.633 align:middle
支持背景媒体播放

00:50:59.200 --> 00:51:01.633 align:middle
支持背景媒体播放

00:51:02.267 --> 00:51:05.933 align:middle
然后启用画中画功能就可以了

00:51:06.700 --> 00:51:10.433 align:middle
我们将该功能内置到
标准媒体播放控制中

00:51:10.933 --> 00:51:15.733 align:middle
这样图形控制器能对画中画

00:51:16.300 --> 00:51:18.467 align:middle
进行精细控制

00:51:20.167 --> 00:51:22.167 align:middle
接下来我想谈谈Mac系统

00:51:23.033 --> 00:51:26.333 align:middle
当然OS X系统
已经有了多任务

00:51:26.400 --> 00:51:28.067 align:middle
多窗口功能

00:51:28.600 --> 00:51:31.667 align:middle
而且今年我们
还宣布了新的窗口管理功能

00:51:31.967 --> 00:51:33.933 align:middle
这实在让人激动

00:51:35.033 --> 00:51:36.367 align:middle
这里的关键是

00:51:36.600 --> 00:51:40.800 align:middle
在拆分视图里
并排显示两个应用界面

00:51:41.267 --> 00:51:43.067 align:middle
正如这张截图所见

00:51:44.767 --> 00:51:47.533 align:middle
现在 大家都容易适应

00:51:48.500 --> 00:51:52.433 align:middle
另外
可变窗口也可以支持该功能了

00:51:52.500 --> 00:51:56.600 align:middle
你只需要确保你的窗口

00:51:56.667 --> 00:51:59.900 align:middle
形状美观和宽度适中

00:52:00.300 --> 00:52:01.833 align:middle
以便和系统中的其他窗口适应

00:52:01.900 --> 00:52:03.800 align:middle
不会产生不良效果

00:52:04.633 --> 00:52:07.933 align:middle
当然 之前增加的
新程序接口AppKit功能

00:52:08.067 --> 00:52:09.567 align:middle
能够使这项功能更为便利

00:52:09.967 --> 00:52:13.733 align:middle
包括在NS拆分视图控制器
自动隐藏工具条

00:52:15.433 --> 00:52:19.033 align:middle
Mac系统的
另一突破是压力触控

00:52:19.433 --> 00:52:22.233 align:middle
这在几个月前已经发布了

00:52:23.267 --> 00:52:26.733 align:middle
压力触控开辟了
触控的全新领域

00:52:27.067 --> 00:52:30.867 align:middle
有了触控板的
压力感应和触觉反馈

00:52:32.000 --> 00:52:33.900 align:middle
我们在自己的
应用中使用该技术

00:52:33.967 --> 00:52:37.167 align:middle
如文本查找 压感播放控制

00:52:37.233 --> 00:52:40.233 align:middle
同时还有预览
和标记等精确控制

00:52:42.567 --> 00:52:45.900 align:middle
当然
我们还添加了一些程序接口

00:52:45.967 --> 00:52:47.467 align:middle
方便大家的
应用可以使用该功能

00:52:48.200 --> 00:52:50.467 align:middle
你可以设置压力触控

00:52:50.533 --> 00:52:51.933 align:middle
压力配置的预设值

00:52:52.267 --> 00:52:55.533 align:middle
配置触控板的默认触觉反馈

00:52:56.067 --> 00:52:58.867 align:middle
以及视图和手势识别事件

00:52:58.933 --> 00:53:00.567 align:middle
压力变化

00:52:58.933 --> 00:53:00.567 align:middle
压力变化

00:53:01.233 --> 00:53:04.767 align:middle
我们相信Mac系统的
压力触控新功能会很受欢迎

00:53:05.233 --> 00:53:07.167 align:middle
我们很期待

00:53:07.233 --> 00:53:08.367 align:middle
大家如何充分利用该功能

00:53:10.033 --> 00:53:12.567 align:middle
现在 iCloud也更新了

00:53:14.167 --> 00:53:16.333 align:middle
去年我们推出了
iCloud Drive

00:53:16.500 --> 00:53:18.200 align:middle
极大方便访问移动设备

00:53:18.267 --> 00:53:23.300 align:middle
电脑和网络上的所有文件

00:53:25.067 --> 00:53:28.800 align:middle
现在在iOS系统中
应用能够提供强大功能

00:53:28.867 --> 00:53:30.400 align:middle
用于管理你的文档

00:53:30.800 --> 00:53:33.700 align:middle
并且我们认为
这种简单以应用为中心的模式

00:53:33.767 --> 00:53:35.167 align:middle
对用户非常有用

00:53:36.100 --> 00:53:38.533 align:middle
但是 Mac用户习惯

00:53:38.600 --> 00:53:41.733 align:middle
直接在iCloud
Drive上直接处理文件

00:53:42.767 --> 00:53:45.467 align:middle
因此我们将新应用
iCloud Drive

00:53:45.533 --> 00:53:48.367 align:middle
应用添加到iOS系统中

00:53:55.467 --> 00:53:56.533 align:middle
看起来是这样子的

00:53:56.600 --> 00:53:58.033 align:middle
现在 你可以方便查看

00:53:58.100 --> 00:54:01.033 align:middle
iCloud Drive
上的所有文件

00:53:58.100 --> 00:54:01.033 align:middle
iCloud Drive
上的所有文件

00:54:01.667 --> 00:54:05.167 align:middle
你可以在应用中预览文件

00:54:05.833 --> 00:54:09.667 align:middle
当然
你可以使用应用打开文件

00:54:11.400 --> 00:54:13.267 align:middle
在之前的iOS 9系统

00:54:13.333 --> 00:54:18.067 align:middle
只能将文件复制
到应用程序中才能打开

00:54:18.367 --> 00:54:22.100 align:middle
这正是用户不想在
iCloudDrive储存

00:54:22.567 --> 00:54:24.633 align:middle
或者处理文件的原因

00:54:25.700 --> 00:54:29.333 align:middle
我们真正想要的
是可以对文件进行编辑

00:54:29.400 --> 00:54:31.067 align:middle
无需移动或者复制就

00:54:31.900 --> 00:54:34.133 align:middle
因此如果你开发的
是一款基于文件的应用

00:54:34.333 --> 00:54:36.167 align:middle
这正是你们需要的

00:54:37.300 --> 00:54:38.900 align:middle
你需要能够进行文件协调

00:54:38.967 --> 00:54:41.633 align:middle
因为现在有了多进程

00:54:41.700 --> 00:54:43.600 align:middle
可以同步进行处理

00:54:44.200 --> 00:54:46.833 align:middle
而你只需要在记录中进行添加

00:54:47.167 --> 00:54:49.700 align:middle
列出并使用应用打开回调

00:54:50.133 --> 00:54:50.967 align:middle
就是这样

00:54:52.267 --> 00:54:55.400 align:middle
iCloud Drive
是基于CloudKit的

00:54:55.867 --> 00:54:59.100 align:middle
集iCloude服务于一身

00:54:59.633 --> 00:55:02.533 align:middle
CloudKit是
一个公共接口

00:54:59.633 --> 00:55:02.533 align:middle
CloudKit是
一个公共接口

00:55:02.833 --> 00:55:04.833 align:middle
我们开放接口

00:55:04.900 --> 00:55:06.300 align:middle
现在对所有人都开放了

00:55:06.700 --> 00:55:09.267 align:middle
那么这实际上有什么用途了

00:55:10.567 --> 00:55:14.433 align:middle
你可以在iCloud
Drive上免费储存文件

00:55:14.500 --> 00:55:15.567 align:middle
无需成为用户

00:55:16.200 --> 00:55:18.533 align:middle
当你的应用用户越来越多

00:55:18.833 --> 00:55:23.400 align:middle
数据马上就会装满 直到最大限度

00:55:25.100 --> 00:55:27.767 align:middle
现在 我们搭建了
CloudKitDashboard

00:55:27.833 --> 00:55:31.133 align:middle
方便向大家介绍这些功能

00:55:31.500 --> 00:55:34.700 align:middle
其中包括一些免费功能

00:55:35.367 --> 00:55:38.067 align:middle
我们将在未来
不断增加付费服务

00:55:38.133 --> 00:55:41.067 align:middle
这样 用户在使用
付费之前也会收到通知

00:55:41.700 --> 00:55:43.233 align:middle
另外 如果你使用付费服务

00:55:43.700 --> 00:55:47.167 align:middle
这里有价格单和说明

00:55:48.333 --> 00:55:51.000 align:middle
你还可以在这里找到
CloudKit其他信息

00:55:51.067 --> 00:55:52.533 align:middle
新功能的介绍等

00:55:52.600 --> 00:55:56.000 align:middle
如我们今年推出新功能

00:55:56.800 --> 00:55:58.500 align:middle
CloudKitWeb服务

00:55:59.267 --> 00:56:03.867 align:middle
这可以让CloudKit
在网络应用上实现运行

00:55:59.267 --> 00:56:03.867 align:middle
这可以让CloudKit
在网络应用上实现运行

00:56:04.767 --> 00:56:06.067 align:middle
你可以做的是

00:56:06.467 --> 00:56:10.533 align:middle
CloudKit接口对接
可以通过JSON实现

00:56:11.067 --> 00:56:14.100 align:middle
我们提供与CloudKit
接口相当工具

00:56:14.167 --> 00:56:17.000 align:middle
JavaScript函式库

00:56:17.567 --> 00:56:19.400 align:middle
我还提供了
Web login flow

00:56:19.467 --> 00:56:21.800 align:middle
这样可以对用户进行安全验证

00:56:22.567 --> 00:56:24.500 align:middle
我们认为这会变的很简单

00:56:24.567 --> 00:56:26.900 align:middle
开发基于CloudKit
的网络应用

00:56:27.200 --> 00:56:30.767 align:middle
和你的ipadiphone
mac一起运行

00:56:31.967 --> 00:56:34.167 align:middle
这就是
CloudKit 谢谢

00:56:38.333 --> 00:56:40.433 align:middle
现在我把现场交给
克里斯·拉特纳

00:56:40.633 --> 00:56:42.500 align:middle
他将介绍Swift

00:56:42.767 --> 00:56:43.900 align:middle
克里斯·拉特纳：好的

00:56:43.967 --> 00:56:45.033 align:middle
谢谢

00:56:50.033 --> 00:56:50.967 align:middle
谢谢你 托比

00:56:51.267 --> 00:56:53.100 align:middle
Swift现在
的相应很不可思议

00:56:53.367 --> 00:56:55.533 align:middle
真的很难想象

00:56:55.600 --> 00:56:57.367 align:middle
才过了一年的时间

00:56:58.467 --> 00:57:00.400 align:middle
当我们谈到Swift

00:56:58.467 --> 00:57:00.400 align:middle
当我们谈到Swift

00:57:00.467 --> 00:57:01.800 align:middle
我们会谈到
它的一些主要特征

00:57:01.867 --> 00:57:05.833 align:middle
如性能 安全性和互动性

00:57:06.500 --> 00:57:10.067 align:middle
但我们希望每个人
都可以使用Swift

00:57:10.633 --> 00:57:14.200 align:middle
所以
我们开放编译器和标准库

00:57:14.633 --> 00:57:16.933 align:middle
甚至
简化Linux board

00:57:25.267 --> 00:57:27.833 align:middle
将在OSI认证的协议下运行

00:57:28.100 --> 00:57:32.267 align:middle
今年晚些时候
搭建好的Swift2之后

00:57:33.000 --> 00:57:35.433 align:middle
我们期待与大家的更多合作

00:57:36.467 --> 00:57:39.633 align:middle
期待大家的贡献和主意

00:57:41.400 --> 00:57:43.600 align:middle
现在关于Swift
已经有很多资料

00:57:44.167 --> 00:57:45.800 align:middle
我们不会一一说明

00:57:46.000 --> 00:57:51.467 align:middle
最喜欢的是Swift现在
是最佳的栈溢出编程语言

00:57:53.067 --> 00:57:55.067 align:middle
喜欢Swift的理由很多

00:57:55.900 --> 00:57:58.300 align:middle
其中之一是它的成功搭建

00:57:58.367 --> 00:57:59.700 align:middle
能够高速运行应用

00:57:59.767 --> 00:58:02.233 align:middle
在过去的一年中
Swift代码性突飞猛进

00:57:59.767 --> 00:58:02.233 align:middle
在过去的一年中
Swift代码性突飞猛进

00:58:02.300 --> 00:58:04.367 align:middle
因为我们已经
在编译器中实现新的优化

00:58:05.500 --> 00:58:07.633 align:middle
另外
Swift2也有许多新改进

00:58:07.767 --> 00:58:09.667 align:middle
特别是在基板方面

00:58:11.167 --> 00:58:12.767 align:middle
现在我们简单谈谈其中几个

00:58:12.967 --> 00:58:15.633 align:middle
先从最热门的一项开始吧

00:58:15.700 --> 00:58:16.967 align:middle
新的错误处理模式

00:58:18.867 --> 00:58:21.967 align:middle
错误处理是非常热门的领域

00:58:22.333 --> 00:58:23.900 align:middle
已知的方法很多

00:58:24.867 --> 00:58:27.533 align:middle
但是这些方法也有一些问题

00:58:27.967 --> 00:58:30.700 align:middle
我们对现行方法并不满意

00:58:30.767 --> 00:58:33.400 align:middle
因此
我们找到新方法 非常类似

00:58:34.100 --> 00:58:36.633 align:middle
但是可以处理好这些问题

00:58:37.133 --> 00:58:38.333 align:middle
我们现在谈谈

00:58:39.633 --> 00:58:40.500 align:middle
先从简单的说起

00:58:41.333 --> 00:58:44.900 align:middle
Swift的功能或者方法是
标记错误

00:58:45.800 --> 00:58:48.700 align:middle
这极大简化了
通用Cocoa API

00:58:49.033 --> 00:58:51.267 align:middle
以及允许编译器验证错误

00:58:51.333 --> 00:58:53.167 align:middle
是否得到合适的处理

00:58:54.533 --> 00:58:57.367 align:middle
Swift现在可以用类似的
catch语法处理错误

00:58:57.767 --> 00:59:01.267 align:middle
并且
使用功能强大的匹配模式

00:58:57.767 --> 00:59:01.267 align:middle
并且
使用功能强大的匹配模式

00:59:01.333 --> 00:59:03.100 align:middle
表达丰富的cache条件

00:59:04.633 --> 00:59:07.300 align:middle
Swift独辟蹊径
使用尝试性关键字

00:59:08.267 --> 00:59:10.567 align:middle
用于标记调用

00:59:10.633 --> 00:59:11.800 align:middle
产生错误的方法

00:59:12.733 --> 00:59:15.967 align:middle
这重新对错误类型进行定义

00:59:16.033 --> 00:59:17.800 align:middle
当发生非预期控制流时

00:59:18.200 --> 00:59:20.133 align:middle
可以让
该控制流在代码中显现出来

00:59:20.200 --> 00:59:21.633 align:middle
这样可以对其进行分析处理

00:59:23.000 --> 00:59:25.933 align:middle
当然
处理错误将预期地简单

00:59:26.533 --> 00:59:30.067 align:middle
而且Swift在
对用户错误条件类型进行类型

00:59:30.300 --> 00:59:32.900 align:middle
和分类自定义
方面可谓完美无缺

00:59:33.400 --> 00:59:34.267 align:middle
真的很棒

00:59:35.467 --> 00:59:36.667 align:middle
现在 我们认为Swift

00:59:36.933 --> 00:59:40.167 align:middle
错误处理功能将不再陌生

00:59:40.233 --> 00:59:41.700 align:middle
很容易接受

00:59:41.767 --> 00:59:43.733 align:middle
但是这也会极大提高

00:59:43.800 --> 00:59:45.400 align:middle
Swift代码
在基板中的传输质量

00:59:46.567 --> 00:59:48.467 align:middle
现在我们可以
继续谈谈下一个重大特色

00:59:48.533 --> 00:59:49.500 align:middle
接入性检查

00:59:51.400 --> 00:59:55.333 align:middle
为此 我们增加了全新的接口

00:59:55.867 --> 00:59:58.467 align:middle
经常我们也会
想要调用新的接口

00:59:58.533 --> 01:00:00.833 align:middle
增加应用的性能

00:59:58.533 --> 01:00:00.833 align:middle
增加应用的性能

01:00:01.267 --> 01:00:02.700 align:middle
但是我们
仍需要支持OS X

01:00:02.767 --> 01:00:05.067 align:middle
或者iOS的更早版本

01:00:05.967 --> 01:00:07.300 align:middle
这带来一项挑战

01:00:07.633 --> 01:00:11.600 align:middle
因为你可以无条件
使用的某些符号

01:00:12.367 --> 01:00:14.567 align:middle
但是其他符号则对应用运行

01:00:15.133 --> 01:00:18.333 align:middle
所运行的OS系统
进行了条件限制

01:00:19.467 --> 01:00:21.267 align:middle
有了Swift 2
解决这问题轻而易举

01:00:22.033 --> 01:00:24.433 align:middle
现在
如果你想直接使用一个符号

01:00:24.500 --> 01:00:25.367 align:middle
而不想进行检查

01:00:25.667 --> 01:00:27.233 align:middle
那么
编译器将产生一条错误信息

01:00:27.833 --> 01:00:28.667 align:middle
这样方便区分

01:00:29.467 --> 01:00:32.767 align:middle
另外 Xcode在这方面走得更远
它提供了其他更好的方法

01:00:33.367 --> 01:00:36.467 align:middle
首次是你可以
使用新的“如有”语句

01:00:36.767 --> 01:00:39.133 align:middle
在需要的地方进行精确查找

01:00:46.233 --> 01:00:47.867 align:middle
但我认为比那更好的是

01:00:48.133 --> 01:00:51.500 align:middle
你也可以标出整个方法

01:00:51.733 --> 01:00:55.567 align:middle
甚至整个类
根据OS新特征

01:00:55.967 --> 01:00:58.033 align:middle
可消除在你的代码中将出现的

01:00:58.300 --> 01:01:01.733 align:middle
细微检查的需求
直接表达多种普通情况

01:00:58.300 --> 01:01:01.733 align:middle
细微检查的需求
直接表达多种普通情况

01:01:02.033 --> 01:01:04.133 align:middle
是一种非常棒的解决方法
可以很好的一起使用

01:01:05.033 --> 01:01:06.433 align:middle
现在
Swift 2差错处理特征

01:01:06.500 --> 01:01:07.867 align:middle
和可用性检查特征

01:01:07.933 --> 01:01:10.800 align:middle
是更容易写出正确代码的

01:01:10.867 --> 01:01:12.000 align:middle
两大方法

01:01:13.000 --> 01:01:16.167 align:middle
但 当然
我也想要你的代码也很漂亮

01:01:17.533 --> 01:01:20.633 align:middle
所以在Swift 2中
我们做了数个大变动

01:01:21.300 --> 01:01:22.400 align:middle
Swift 1 引入一些

01:01:22.467 --> 01:01:24.700 align:middle
真正强大的整体通用函数

01:01:25.133 --> 01:01:28.200 align:middle
用算法做强大的东西

01:01:31.200 --> 01:01:32.467 align:middle
强大的 极好的

01:01:32.833 --> 01:01:35.567 align:middle
问题是 这些总是不够用

01:01:36.000 --> 01:01:38.633 align:middle
比如说 我有一组数据
想按比例增加数字

01:01:38.700 --> 01:01:39.867 align:middle
并丢掉某些结果

01:01:40.367 --> 01:01:42.267 align:middle
用Swift 2这很简单

01:01:42.733 --> 01:01:45.300 align:middle
但写出来需要重排很多代码

01:01:45.900 --> 01:01:48.800 align:middle
当你考虑时
你必须彻底地阅览

01:01:48.867 --> 01:01:50.367 align:middle
这使得它很难被推出来

01:01:51.167 --> 01:01:53.300 align:middle
Swift 2
引进一种新的语言程序

01:01:53.367 --> 01:01:54.300 align:middle
叫协议扩展

01:01:55.300 --> 01:01:56.600 align:middle
使用协议扩展

01:01:57.000 --> 01:02:00.233 align:middle
可通过彻底改动这些
整体通用函数

01:01:57.000 --> 01:02:00.233 align:middle
可通过彻底改动这些
整体通用函数

01:02:00.333 --> 01:02:01.933 align:middle
让它们至始至终都一样

01:02:03.167 --> 01:02:05.600 align:middle
意思是说
你写的新代码很漂亮

01:02:05.667 --> 01:02:07.433 align:middle
很容易写 也很容易读

01:02:15.500 --> 01:02:17.333 align:middle
让我们谈谈早退出

01:02:18.500 --> 01:02:21.067 align:middle
经常看到因为某些原因
想要早点退出作用域

01:02:21.200 --> 01:02:23.200 align:middle
或许你有办法 比如使用参数

01:02:23.467 --> 01:02:26.533 align:middle
可能是0 如果是0
它不起作用

01:02:26.600 --> 01:02:29.600 align:middle
好吧 如果让的表述
为你提供一种很熟悉

01:02:29.667 --> 01:02:32.133 align:middle
很舒服 很棒的方法
来检查这些条件

01:02:32.333 --> 01:02:35.067 align:middle
但它需要你将所有的代码
缩排成额外行

01:02:36.067 --> 01:02:39.067 align:middle
为解决这个问题
我们引进了一种新的防护说明

01:02:39.133 --> 01:02:40.467 align:middle
允许你检查条件

01:02:40.533 --> 01:02:41.833 align:middle
然后早点将其摆脱

01:02:41.900 --> 01:02:44.433 align:middle
允许你写出漂亮的直接式程序

01:02:44.500 --> 01:02:45.933 align:middle
无需额外的缩进

01:02:53.133 --> 01:02:54.967 align:middle
下一个Swift
如何运作的一个大元件

01:02:55.033 --> 01:02:57.567 align:middle
和Cocoa配合使用
可达到什么程度

01:02:58.800 --> 01:03:01.100 align:middle
但对于普通的
Objective-C API

01:02:58.800 --> 01:03:01.100 align:middle
但对于普通的
Objective-C API

01:03:01.167 --> 01:03:03.367 align:middle
Swift
编译程序是否有指示器

01:03:03.433 --> 01:03:04.700 align:middle
毫无影响

01:03:04.767 --> 01:03:06.667 align:middle
或一个序列的单元类型是什么

01:03:07.333 --> 01:03:09.800 align:middle
引入new features
subjective C

01:03:09.867 --> 01:03:10.800 align:middle
来解决这个问题

01:03:10.867 --> 01:03:13.300 align:middle
包括可以将指针类型
表达为空性的能力

01:03:13.867 --> 01:03:17.867 align:middle
在Xcode 7
我们引入整个全新的

01:03:17.933 --> 01:03:20.367 align:middle
一级的基因体系

01:03:20.433 --> 01:03:23.900 align:middle
可让你在
Objective-C中

01:03:23.967 --> 01:03:24.967 align:middle
表示单元类型

01:03:25.033 --> 01:03:27.233 align:middle
和许多其他的事

01:03:34.067 --> 01:03:37.067 align:middle
尽管采用了这个
和其他整组特征

01:03:37.433 --> 01:03:39.033 align:middle
Cocoa感觉还是相当快

01:03:40.833 --> 01:03:42.500 align:middle
最后
让我们来说说Xcode

01:03:43.533 --> 01:03:48.700 align:middle
Xcode 7引入
修改后的Swift移植器

01:03:49.400 --> 01:03:52.333 align:middle
它可自动将Swift 1
代码移到Swift 2序列

01:03:52.633 --> 01:03:54.800 align:middle
包括采用新差错处理模型

01:03:55.567 --> 01:03:58.133 align:middle
只要Swift语言继
续演变发展

01:03:58.333 --> 01:04:00.500 align:middle
移植器也将
继续发展与之匹配

01:03:58.333 --> 01:04:00.500 align:middle
移植器也将
继续发展与之匹配

01:04:01.967 --> 01:04:04.333 align:middle
下面 我们谈谈头文件

01:04:06.000 --> 01:04:09.500 align:middle
但 等一下 有无头文件

01:04:09.567 --> 01:04:11.033 align:middle
是Swift的明显特征
是吧

01:04:11.533 --> 01:04:13.967 align:middle
问题是 是否有时候你确实想

01:04:14.033 --> 01:04:16.800 align:middle
扫一眼一堆的代码
看看它究竟是什么

01:04:17.067 --> 01:04:20.000 align:middle
并以这种方式获得
所有执行细节

01:04:21.233 --> 01:04:23.167 align:middle
Xcode
已经解决这个问题

01:04:23.233 --> 01:04:24.967 align:middle
通过引入新辅助编辑器

01:04:25.267 --> 01:04:26.833 align:middle
它提供
任意Swift源文件的

01:04:26.900 --> 01:04:28.633 align:middle
一个类似头文件的意见

01:04:29.367 --> 01:04:32.000 align:middle
给于你所有头文件略读优势

01:04:32.200 --> 01:04:36.000 align:middle
没有写保持
以及自己编辑的维护压力

01:04:37.133 --> 01:04:38.000 align:middle
好极了

01:04:44.433 --> 01:04:45.733 align:middle
下一个 丰富的注释

01:04:46.867 --> 01:04:48.233 align:middle
Xcode让你写出

01:04:48.867 --> 01:04:50.833 align:middle
漂亮的Swift
Playgrounds

01:04:50.900 --> 01:04:54.467 align:middle
通过
直接向Xcode编辑器

01:04:55.500 --> 01:04:58.833 align:middle
这些丰富评论使用非常流行的
Markdown syntax

01:04:59.233 --> 01:05:00.833 align:middle
现在我们已将它
应用到syntax

01:04:59.233 --> 01:05:00.833 align:middle
现在我们已将它
应用到syntax

01:05:00.900 --> 01:05:02.567 align:middle
用来进行文档注释

01:05:03.533 --> 01:05:06.600 align:middle
我们也增加对新特征的支持
比如内嵌图像和链接

01:05:06.833 --> 01:05:08.867 align:middle
提供很棒的
始终如一的体验

01:05:08.933 --> 01:05:10.967 align:middle
在Playgrounds
和doc注释之间

01:05:11.500 --> 01:05:12.333 align:middle
最后

01:05:16.567 --> 01:05:18.400 align:middle
最后
来说Playgrounds

01:05:19.067 --> 01:05:21.100 align:middle
Playgrounds
对我们来说很重要

01:05:21.300 --> 01:05:23.733 align:middle
我们知道利用API
是一种很棒的体验

01:05:24.033 --> 01:05:25.867 align:middle
也和Swift程式语言本身

01:05:26.467 --> 01:05:29.333 align:middle
认为Playgrounds
也是教和学习

01:05:29.400 --> 01:05:30.767 align:middle
程序编制的一种好方法

01:05:31.267 --> 01:05:33.467 align:middle
所以
我们对其增加了一些特征

01:05:33.800 --> 01:05:37.067 align:middle
包括
为多重页面增加最新的支持

01:05:38.167 --> 01:05:41.433 align:middle
为了更好地进行展示
我要邀请麦斯·杜克曼上台

01:05:46.767 --> 01:05:48.133 align:middle
麦斯·杜克曼:
谢谢克里斯

01:05:48.467 --> 01:05:52.533 align:middle
今天我要展示的是在
Xcode7中教和学习使用

01:05:52.933 --> 01:05:54.800 align:middle
Playgrounds
多么简单

01:05:57.600 --> 01:06:00.367 align:middle
让我们从这开始我开发了
一个playground

01:05:57.600 --> 01:06:00.367 align:middle
让我们从这开始我开发了
一个playground

01:06:00.433 --> 01:06:04.167 align:middle
关于Apple的制图
API用来教学生

01:06:05.533 --> 01:06:06.967 align:middle
在这个部分

01:06:07.033 --> 01:06:10.733 align:middle
我为他们介绍一个全新的
GameplayKit

01:06:12.033 --> 01:06:14.967 align:middle
如Playground所说
GameplayKit用来

01:06:15.033 --> 01:06:17.267 align:middle
开发技术以驱动游戏设置

01:06:17.767 --> 01:06:19.600 align:middle
我们马上就可以看到更多东西

01:06:21.800 --> 01:06:25.267 align:middle
Playground
使用形象化的飞车追逐

01:06:25.333 --> 01:06:28.100 align:middle
表现GameplayKit
部分功能

01:06:28.933 --> 01:06:30.567 align:middle
我创造了这个
Playground

01:06:30.633 --> 01:06:35.467 align:middle
所以我的学生
可以编辑坏蛋的车辆

01:06:36.500 --> 01:06:39.100 align:middle
只需调整这三个精灵节点变量
（SpriteNode）

01:06:40.700 --> 01:06:44.567 align:middle
现在Playgrounds
可以为你

01:06:44.633 --> 01:06:45.900 align:middle
展示每个代码行的结果

01:06:46.533 --> 01:06:50.367 align:middle
我们增加了联机的功能

01:06:55.600 --> 01:06:57.600 align:middle
现在 我可以开始了

01:06:57.667 --> 01:07:00.233 align:middle
用学生将要用的方式编辑我的
Playground

01:06:57.667 --> 01:07:00.233 align:middle
用学生将要用的方式编辑我的
Playground

01:07:01.333 --> 01:07:02.700 align:middle
通过改变数值

01:07:03.433 --> 01:07:05.333 align:middle
改变坏蛋的外貌

01:07:06.733 --> 01:07:08.733 align:middle
你可以看到 在我编辑时

01:07:09.200 --> 01:07:10.700 align:middle
变化也随之更新

01:07:14.400 --> 01:07:16.033 align:middle
那是一辆坏蛋的车

01:07:18.133 --> 01:07:19.967 align:middle
至此 我让我的学生

01:07:20.233 --> 01:07:21.833 align:middle
写了点代码

01:07:22.367 --> 01:07:26.633 align:middle
将坏蛋一起放到精灵中

01:07:28.000 --> 01:07:29.767 align:middle
现在 当我开始写代码

01:07:32.300 --> 01:07:36.900 align:middle
坏蛋就开始聚集了
我准备好了

01:07:38.000 --> 01:07:39.333 align:middle
这就是为设置所做的

01:07:39.567 --> 01:07:41.533 align:middle
是时候开始重要的事情了

01:07:41.900 --> 01:07:43.733 align:middle
它会让材料移动

01:07:44.367 --> 01:07:46.267 align:middle
这个我放在了其他页面

01:07:47.333 --> 01:07:50.300 align:middle
页面是一种好方法

01:07:50.567 --> 01:07:53.000 align:middle
可将Playgrounds
划分成像书一样的小主题

01:07:53.700 --> 01:07:57.367 align:middle
你可以使用页面底部的

01:07:57.433 --> 01:07:58.700 align:middle
手动导航连接转到其他页面

01:07:59.700 --> 01:08:00.900 align:middle
你也可以使用跳转栏

01:07:59.700 --> 01:08:00.900 align:middle
你也可以使用跳转栏

01:08:02.433 --> 01:08:04.200 align:middle
当然 还可以使用导航

01:08:05.367 --> 01:08:07.367 align:middle
这是我Playground
中所有的页面

01:08:08.067 --> 01:08:12.700 align:middle
每个页面都有软件源和资源

01:08:13.033 --> 01:08:16.433 align:middle
所以你可以如你所愿启动
你的Playground

01:08:18.300 --> 01:08:19.600 align:middle
我们来检查下一页

01:08:21.767 --> 01:08:24.533 align:middle
现在存好导航 放到一边

01:08:26.000 --> 01:08:28.200 align:middle
这个页面是关于

01:08:28.267 --> 01:08:30.733 align:middle
GameplayKit
的集群行为

01:08:31.367 --> 01:08:34.033 align:middle
集群是讲坏蛋聚集在一起

01:08:34.267 --> 01:08:36.200 align:middle
并使之移动的单位

01:08:38.100 --> 01:08:39.800 align:middle
现在
不需要进一步的数据对象

01:08:40.167 --> 01:08:43.100 align:middle
我将
打开Xcode的时间抽助手

01:08:43.832 --> 01:08:46.133 align:middle
看看聚集者

01:08:48.633 --> 01:08:50.399 align:middle
好了 这就是所有的罪犯

01:08:50.466 --> 01:08:53.832 align:middle
各种坏蛋在追踪
英勇无畏的英雄

01:08:54.399 --> 01:08:56.933 align:middle
但你可以看到 他们四处乱撞

01:08:57.867 --> 01:08:59.300 align:middle
真是集群灾难

01:09:00.899 --> 01:09:02.033 align:middle
来看看是否可以修正一下

01:09:04.133 --> 01:09:07.300 align:middle
这里有数个参数 可以用来

01:09:07.367 --> 01:09:08.899 align:middle
管理集群行为

01:09:09.500 --> 01:09:11.167 align:middle
这个有意思 内聚性

01:09:11.800 --> 01:09:15.733 align:middle
用来控制坏蛋团结一致的程度

01:09:16.233 --> 01:09:17.966 align:middle
我可以立马试试那个数值

01:09:18.332 --> 01:09:20.399 align:middle
立刻就可以看到效果

01:09:21.433 --> 01:09:23.332 align:middle
内聚性有点太大了

01:09:23.399 --> 01:09:24.767 align:middle
所以 让它稍微小点

01:09:29.933 --> 01:09:31.832 align:middle
这个间隔好多了

01:09:31.899 --> 01:09:35.466 align:middle
但仍不是我想要的那种
目标一致

01:09:36.033 --> 01:09:38.567 align:middle
所以 我要试试寻找参数

01:09:39.899 --> 01:09:42.000 align:middle
设置一个不同的数值

01:09:42.067 --> 01:09:44.267 align:middle
看看能不能达到我想要的聚集

01:09:46.633 --> 01:09:47.466 align:middle
好了

01:09:48.367 --> 01:09:49.367 align:middle
现在他们聚集在一起了

01:09:50.733 --> 01:09:54.567 align:middle
现在我知道我想要的数值范围

01:09:54.633 --> 01:09:56.433 align:middle
就可以告诉我的学生开始玩了

01:09:58.133 --> 01:09:59.633 align:middle
将助手储存好 放一边

01:10:01.100 --> 01:10:05.433 align:middle
将编辑器切换到原始标记

01:10:07.467 --> 01:10:10.400 align:middle
现在使用熟悉的
Markdown syntax

01:10:10.467 --> 01:10:13.367 align:middle
编辑Playground
的PROSE

01:10:14.600 --> 01:10:18.700 align:middle
我可以回到寻找参数

01:10:19.333 --> 01:10:22.667 align:middle
我也可以增加
额外的PROSE

01:10:22.733 --> 01:10:25.300 align:middle
让我的学生和这些数值玩一玩

01:10:27.400 --> 01:10:29.000 align:middle
我也可以来到这里

01:10:29.767 --> 01:10:34.000 align:middle
用图表的形式增加一些品牌

01:10:35.167 --> 01:10:38.433 align:middle
现在 无论何时
有人问我是否知道聚集

01:10:38.500 --> 01:10:40.600 align:middle
我就可以说
我写了一本关于聚集的书

01:10:42.967 --> 01:10:44.667 align:middle
谢谢 你很好

01:10:50.433 --> 01:10:53.400 align:middle
我们在Xcode 7中的
Playgrounds

01:10:53.467 --> 01:10:55.000 align:middle
仅加了少数的程序编写特征

01:10:55.500 --> 01:10:57.467 align:middle
等不及要看看
你们可以用它们做些什么出来

01:10:57.667 --> 01:11:00.667 align:middle
现在为告诉你一些
非常棒的Xcode特征

01:10:57.667 --> 01:11:00.667 align:middle
现在为告诉你一些
非常棒的Xcode特征

01:11:00.900 --> 01:11:02.900 align:middle
有请马太·菲力克上台

01:11:09.900 --> 01:11:11.400 align:middle
马太·菲力克：谢谢 麦斯

01:11:13.200 --> 01:11:17.333 align:middle
伴随着watchOS
iOS和OSX新版本的发布

01:11:17.733 --> 01:11:20.200 align:middle
我们很兴奋为你
提供Xcode 7

01:11:21.267 --> 01:11:26.067 align:middle
这个新发布的版本包括特征
并支持所有平台

01:11:26.633 --> 01:11:29.633 align:middle
且每个平台的独特体验

01:11:29.700 --> 01:11:31.367 align:middle
已经被合并到工具中

01:11:31.533 --> 01:11:34.533 align:middle
使你能够锁定和释放你的应用

01:11:34.900 --> 01:11:36.567 align:middle
到所有设备中

01:11:38.200 --> 01:11:40.167 align:middle
我今天将从独特的体验开始

01:11:40.467 --> 01:11:42.667 align:middle
使用设计工具 即界面生成器

01:11:43.433 --> 01:11:47.100 align:middle
首先是一种
展示你的应用的新方法

01:11:47.200 --> 01:11:48.267 align:middle
叫做堆栈视图

01:11:53.900 --> 01:11:54.800 align:middle
对于堆栈视图

01:11:54.867 --> 01:11:58.767 align:middle
你可以使用水平和垂直堆栈
设计你的应用

01:11:59.467 --> 01:12:01.267 align:middle
你可以从选择方向开始

01:11:59.467 --> 01:12:01.267 align:middle
你可以从选择方向开始

01:12:01.600 --> 01:12:02.600 align:middle
增加你的控制

01:12:03.600 --> 01:12:04.933 align:middle
每增加一个控制

01:12:05.000 --> 01:12:08.367 align:middle
堆栈视图
将自动调整大小和定位

01:12:09.067 --> 01:12:10.833 align:middle
为你提供正确的样子

01:12:12.233 --> 01:12:15.100 align:middle
堆栈视图出色的嵌套

01:12:15.167 --> 01:12:16.333 align:middle
可允许你改变方向

01:12:16.400 --> 01:12:19.033 align:middle
这样 你就可以获得
你完全想要的那个布局

01:12:20.900 --> 01:12:23.300 align:middle
现在 我们已在自动版面配置
顶端建立堆栈视图

01:12:23.533 --> 01:12:25.867 align:middle
它为你处理所有的约束

01:12:26.900 --> 01:12:30.533 align:middle
0约束可以使你控制堆栈的

01:12:30.767 --> 01:12:32.367 align:middle
队列 空间和分布

01:12:33.900 --> 01:12:36.133 align:middle
堆栈视图同样灵活

01:12:36.200 --> 01:12:37.833 align:middle
你可以在界面生成器上

01:12:38.167 --> 01:12:40.533 align:middle
在运行时 和你的界面玩

01:12:41.833 --> 01:12:44.967 align:middle
当你在堆栈视图增加控制时
你可对它们重新排序

01:12:45.133 --> 01:12:48.633 align:middle
尝试不同的布局
或许最好的情况是

01:12:48.967 --> 01:12:50.467 align:middle
当你在运行时隐藏视图

01:12:51.000 --> 01:12:53.067 align:middle
堆栈视图将自动调整

01:13:00.533 --> 01:13:03.233 align:middle
堆栈视图是
界面生成器上的新方法

01:13:03.300 --> 01:13:05.533 align:middle
可使你完全获得你想要的布局

01:13:06.333 --> 01:13:07.833 align:middle
下一个是
Storyboard

01:13:07.900 --> 01:13:09.433 align:middle
references

01:13:10.867 --> 01:13:13.733 align:middle
使用Storyboard
你可以创造设计场景

01:13:13.800 --> 01:13:15.667 align:middle
用0代码将他们连接在一起

01:13:15.933 --> 01:13:17.800 align:middle
以构成完整的用户界面

01:13:19.033 --> 01:13:21.567 align:middle
现在 你的场景和界面进化了

01:13:21.633 --> 01:13:23.367 align:middle
变得有点复杂

01:13:23.667 --> 01:13:25.433 align:middle
你想要更容易的控制它

01:13:26.133 --> 01:13:28.133 align:middle
Storyboard
references

01:13:28.200 --> 01:13:30.167 align:middle
允许你截取一部分界面

01:13:30.300 --> 01:13:32.667 align:middle
并移动以分离
storyboard文件

01:13:33.000 --> 01:13:36.400 align:middle
保持连接

01:13:43.000 --> 01:13:45.067 align:middle
storyboard
references

01:13:45.133 --> 01:13:47.533 align:middle
使你的界面重点突出并模块化

01:13:47.633 --> 01:13:49.600 align:middle
和你处理应用代码相同的方式

01:13:50.033 --> 01:13:52.867 align:middle
也可很容易地设计你的应用流

01:13:54.933 --> 01:13:58.200 align:middle
和应用流
应用布局同样重要的

01:13:58.267 --> 01:14:00.600 align:middle
是应用外观

01:13:58.267 --> 01:14:00.600 align:middle
是应用外观

01:14:01.333 --> 01:14:04.467 align:middle
在此次发布我们制作了
值得一看的界面生成器

01:14:06.133 --> 01:14:07.000 align:middle
在接下来的场景中

01:14:07.067 --> 01:14:11.400 align:middle
你将看到
更多应用在界面生成器中

01:14:11.467 --> 01:14:12.667 align:middle
iOS 和OS X的可视化

01:14:13.967 --> 01:14:17.100 align:middle
画布内将对模糊和阴影着色

01:14:18.600 --> 01:14:21.533 align:middle
振动则成为展示的标准

01:14:22.900 --> 01:14:26.533 align:middle
而可设计的控制
可以展示隐蔽和阴影

01:14:26.700 --> 01:14:29.233 align:middle
组成你的场景中的其他视图

01:14:30.900 --> 01:14:35.233 align:middle
结合这些可视化
以及先前的编辑器

01:14:35.567 --> 01:14:40.267 align:middle
可使你进一步
改进特殊界面的外观和布局

01:14:40.833 --> 01:14:42.433 align:middle
意思是 现在比以往更加可以

01:14:42.800 --> 01:14:45.533 align:middle
直接在界面生成器中
编辑界面

01:14:45.933 --> 01:14:48.367 align:middle
看看你的使用者
会在他们的设备上做什么

01:14:56.433 --> 01:15:00.267 align:middle
创建应用的另一方面是
管理资产

01:14:56.433 --> 01:15:00.267 align:middle
创建应用的另一方面是
管理资产

01:15:00.833 --> 01:15:03.100 align:middle
含有工具的Xcode可与新

01:15:03.333 --> 01:15:04.667 align:middle
按需资源API配合使用

01:15:07.067 --> 01:15:09.100 align:middle
使用Xcode 7
你可以连接资产

01:15:09.167 --> 01:15:10.833 align:middle
发送到整个项目

01:15:11.500 --> 01:15:13.500 align:middle
以供下载和使用

01:15:14.600 --> 01:15:16.933 align:middle
每个标签代表一个资源聚集

01:15:17.233 --> 01:15:18.600 align:middle
我们把它叫做包

01:15:19.700 --> 01:15:23.267 align:middle
每个单独的资源
可申请多个标签

01:15:23.467 --> 01:15:25.000 align:middle
这可使你

01:15:25.200 --> 01:15:26.333 align:middle
在不同的环境中使用资源

01:15:27.533 --> 01:15:29.933 align:middle
帮助你管理标记的资源

01:15:30.233 --> 01:15:33.267 align:middle
在项目编辑器中
Xcode包括一个标签概述

01:15:34.267 --> 01:15:37.133 align:middle
在这里 你可以很容易地增加
移除重命名标签名

01:15:37.767 --> 01:15:39.267 align:middle
你可以改变包的内容

01:15:39.733 --> 01:15:43.033 align:middle
你也可以
安装按需资源各个方面

01:15:43.300 --> 01:15:44.500 align:middle
比如下载命令

01:15:44.833 --> 01:15:46.000 align:middle
下载优先次序

01:15:47.700 --> 01:15:49.233 align:middle
当你建立应用时

01:15:49.500 --> 01:15:53.333 align:middle
你的标记资产
自动集合成资源包

01:15:53.800 --> 01:15:56.467 align:middle
你只需标记你的资产
然后就可以开始了

01:15:57.867 --> 01:15:59.500 align:middle
当你配置你的应用时

01:15:59.800 --> 01:16:02.500 align:middle
你的按需资源
将由App Store主导

01:15:59.800 --> 01:16:02.500 align:middle
你的按需资源
将由App Store主导

01:16:03.500 --> 01:16:05.767 align:middle
在调试时
Xcode将在你的Mac上

01:16:05.833 --> 01:16:08.667 align:middle
主导按需资源

01:16:08.733 --> 01:16:10.400 align:middle
并根据要求输到你的设备中

01:16:10.667 --> 01:16:12.500 align:middle
以模仿Store的下载行为

01:16:13.833 --> 01:16:16.433 align:middle
对于使用
Xcode持续集成的人

01:16:16.900 --> 01:16:20.100 align:middle
程式即将建立
并主导你的按需资源

01:16:20.500 --> 01:16:23.700 align:middle
所以 你可以在你的团队中
通过无线电进行测试App

01:16:25.233 --> 01:16:29.033 align:middle
最后 为帮助你追踪包

01:16:29.633 --> 01:16:32.500 align:middle
在进行调试时
调试计量表将显示

01:16:32.567 --> 01:16:35.167 align:middle
所有按需资源进度和状态

01:16:36.533 --> 01:16:39.533 align:middle
所有工具的组合

01:16:39.600 --> 01:16:42.767 align:middle
将让你很容易的在
App上使用按需资源

01:16:45.467 --> 01:16:49.667 align:middle
Xcode 7还有很棒的
调试和性能分析工具

01:16:49.733 --> 01:16:53.000 align:middle
可以帮助你
进一步强化应用的质量

01:16:54.767 --> 01:16:57.767 align:middle
塞巴斯蒂安刚提到
我们重点放在电池寿命

01:16:58.500 --> 01:17:00.200 align:middle
摆脱你的大部分设备

01:16:58.500 --> 01:17:00.200 align:middle
摆脱你的大部分设备

01:17:00.300 --> 01:17:03.100 align:middle
充一次电即可支撑一整天
这很重要

01:17:03.700 --> 01:17:05.067 align:middle
所以 我们让

01:17:05.133 --> 01:17:07.400 align:middle
能源使用跟踪应用变得简单

01:17:08.767 --> 01:17:12.300 align:middle
iOS新能量
计量器将显示CPU使用

01:17:12.767 --> 01:17:15.900 align:middle
调用API联网
以及定位服务

01:17:16.333 --> 01:17:18.600 align:middle
还将显示你的App

01:17:18.733 --> 01:17:20.767 align:middle
从前台到后台的转换

01:17:21.800 --> 01:17:26.267 align:middle
你可获得应用行为的内部信息
使用其它调试测量表

01:17:26.733 --> 01:17:28.233 align:middle
当你需要更多信息时

01:17:28.567 --> 01:17:31.567 align:middle
可通过仪器获取所有细节

01:17:32.800 --> 01:17:35.533 align:middle
说到设备 设备已经更新

01:17:35.600 --> 01:17:37.000 align:middle
比以前更好了

01:17:38.033 --> 01:17:39.933 align:middle
目前 追踪视野更紧凑

01:17:40.000 --> 01:17:44.067 align:middle
使用流动姿势
可让数据形象化更简单

01:17:45.300 --> 01:17:48.367 align:middle
我们还有不少更新后的工具
以及新工具

01:17:48.433 --> 01:17:51.367 align:middle
可供你使用
比如核心位置分析

01:17:51.667 --> 01:17:53.700 align:middle
新CPU系统追踪

01:17:55.900 --> 01:17:57.433 align:middle
在次次发布中 我们将

01:17:57.500 --> 01:17:59.833 align:middle
Clang's Address
Sanitizer

01:17:59.900 --> 01:18:01.133 align:middle
整合到调试工作流程中

01:17:59.900 --> 01:18:01.133 align:middle
整合到调试工作流程中

01:18:02.300 --> 01:18:05.267 align:middle
Address Sanitizer
是C语言的一种

01:18:05.533 --> 01:18:06.767 align:middle
内存错误检测系统

01:18:07.967 --> 01:18:11.667 align:middle
一旦激活Xcode将监视应
用的内存使用情况

01:18:11.967 --> 01:18:15.400 align:middle
检测普通问题 比如缓冲超限

01:18:16.433 --> 01:18:18.533 align:middle
检测出来时
Xcode将通知你

01:18:18.700 --> 01:18:21.733 align:middle
并提供基本细节
帮助你进行诊断

01:18:22.033 --> 01:18:23.100 align:middle
调试问题

01:18:24.100 --> 01:18:26.633 align:middle
和其他类似的工具不同

01:18:26.833 --> 01:18:28.933 align:middle
Address
Sanitizer速度很快

01:18:29.300 --> 01:18:32.767 align:middle
速度快到
你可以在你的交互应用中使用

01:18:35.800 --> 01:18:38.800 align:middle
但是尽管有
如此出色的调试和分析工具

01:18:39.100 --> 01:18:40.333 align:middle
有时

01:18:40.800 --> 01:18:43.567 align:middle
漏洞会泄露 并造成崩溃

01:18:44.300 --> 01:18:45.867 align:middle
为帮助你尽快解决这个问题

01:18:46.167 --> 01:18:48.733 align:middle
Xcode
为崩溃日志整合支持

01:18:51.167 --> 01:18:53.533 align:middle
将你的App提交到
提交到TestFlight

01:18:53.600 --> 01:18:54.433 align:middle
谢谢

01:18:55.133 --> 01:18:57.733 align:middle
提交到TestFlight
和app store

01:18:57.800 --> 01:18:58.667 align:middle
Xcode会提供

01:18:58.733 --> 01:19:00.267 align:middle
symbolicated
crashes

01:18:58.733 --> 01:19:00.267 align:middle
symbolicated
crashes

01:19:00.333 --> 01:19:01.500 align:middle
服务于每一项任务

01:19:03.267 --> 01:19:05.567 align:middle
整合后
将为你提供一份更新清单

01:19:05.633 --> 01:19:09.167 align:middle
关于apps最常见的崩溃
告诉你回溯

01:19:09.767 --> 01:19:13.467 align:middle
崩溃的细节
以及最近发生崩溃的排行榜

01:19:14.467 --> 01:19:16.700 align:middle
你可以重新命名崩溃
以方便追踪

01:19:17.267 --> 01:19:18.567 align:middle
你也可以增加备注

01:19:18.833 --> 01:19:22.000 align:middle
当你搞定崩溃时
可以对其做记号

01:19:23.533 --> 01:19:26.433 align:middle
当你回顾回溯时
你想让它变得简单些

01:19:27.033 --> 01:19:29.367 align:middle
所以Xcode有Open
In Project键

01:19:29.767 --> 01:19:33.367 align:middle
可使你将回溯
下载到程序中的调试导航

01:19:33.667 --> 01:19:35.367 align:middle
提供熟悉的工作程序

01:19:35.500 --> 01:19:38.100 align:middle
为崩溃帧引导源代码

01:19:38.433 --> 01:19:40.033 align:middle
找出问题 并解决问题

01:19:49.200 --> 01:19:52.933 align:middle
早春时我们为
你们的iOS应用提供崩溃日志

01:19:53.633 --> 01:19:55.467 align:middle
今天以Xcode7开头

01:19:55.533 --> 01:19:57.800 align:middle
你将拿到OS X
应用的崩溃日志

01:19:58.400 --> 01:20:01.700 align:middle
watchOS
应用的崩溃日志也将很快出来

01:19:58.400 --> 01:20:01.700 align:middle
watchOS
应用的崩溃日志也将很快出来

01:20:02.900 --> 01:20:05.367 align:middle
这此次发布 我们还将提供

01:20:05.433 --> 01:20:09.033 align:middle
应用扩展到所有平台的
app的崩溃日志

01:20:09.267 --> 01:20:11.300 align:middle
你就可以很好的
进行追踪和改善

01:20:17.933 --> 01:20:20.800 align:middle
另一种改善应用的方法是测试

01:20:21.333 --> 01:20:23.067 align:middle
我都喜欢测试 对吧

01:20:25.433 --> 01:20:26.267 align:middle
我再试一下

01:20:26.333 --> 01:20:28.067 align:middle
我都喜欢测试 对吧

01:20:32.433 --> 01:20:36.800 align:middle
很好 因为测试
是传送好应用的基本

01:20:37.200 --> 01:20:39.333 align:middle
今年 你有两个显眼的新添置

01:20:40.900 --> 01:20:43.933 align:middle
测试方法的核心是
XE测试框架

01:20:44.200 --> 01:20:47.233 align:middle
和测试导航
这些都将为你进行设计

01:20:47.300 --> 01:20:49.667 align:middle
组织测试提供不错的方法

01:20:50.800 --> 01:20:53.567 align:middle
在这之上
Xcode为你提供了不少

01:20:53.633 --> 01:20:54.800 align:middle
测试应用的方法

01:20:56.400 --> 01:20:58.333 align:middle
你可以检测你API的正确性

01:20:58.667 --> 01:21:00.833 align:middle
随时测量追踪它们的性能

01:20:58.667 --> 01:21:00.833 align:middle
随时测量追踪它们的性能

01:21:02.167 --> 01:21:05.333 align:middle
你可以在测试代码评估
代码的同步行为和异步行为

01:21:06.233 --> 01:21:11.267 align:middle
不断的测试木马集成

01:21:12.567 --> 01:21:14.067 align:middle
所有这些组合在一起

01:21:14.133 --> 01:21:17.167 align:middle
可以做出一个
强大的测试解决方案

01:21:18.167 --> 01:21:19.633 align:middle
但我们
想要启发一个Notch

01:21:19.933 --> 01:21:23.333 align:middle
所以今年
我们增加了用户界面测试

01:21:31.500 --> 01:21:33.633 align:middle
这建立在相同的测试基础之上

01:21:33.867 --> 01:21:35.533 align:middle
现在
你可以进行正确性和性能测试

01:21:35.700 --> 01:21:38.867 align:middle
这些测试在用户界面上完成

01:21:39.100 --> 01:21:41.433 align:middle
将进一步扩大测试覆盖

01:21:42.467 --> 01:21:45.800 align:middle
说到覆盖 我们也增加了

01:21:52.733 --> 01:21:54.500 align:middle
代码覆盖是一种很棒的新方法

01:21:54.567 --> 01:21:56.267 align:middle
可用来评估测试进展

01:21:56.500 --> 01:21:58.700 align:middle
确保你能做所有你想要的测试

01:21:59.667 --> 01:22:01.667 align:middle
所以 让我们来快速的看一下

01:21:59.667 --> 01:22:01.667 align:middle
所以 让我们来快速的看一下

01:22:01.733 --> 01:22:05.300 align:middle
新UI测试和Xcode
7中代码覆盖率特征的演示

01:22:10.033 --> 01:22:12.967 align:middle
这里有一个
我和我的团队正在做的应用

01:22:13.500 --> 01:22:15.600 align:middle
是iOS和
iOS X中的一个

01:22:15.667 --> 01:22:18.033 align:middle
SpriteKit游戏
叫做Demo Bots

01:22:18.967 --> 01:22:22.100 align:middle
在我们开发应用时
我们同样做了测试

01:22:22.167 --> 01:22:24.067 align:middle
从这里可以看到
在测试导航中

01:22:24.133 --> 01:22:25.933 align:middle
有不少测试很有用

01:22:27.167 --> 01:22:31.067 align:middle
我们可以知道
哪个部分的代码还未进行测试

01:22:31.433 --> 01:22:33.500 align:middle
或因为我们还未写测试

01:22:33.867 --> 01:22:36.533 align:middle
或因为目前的测试
并不完整

01:22:38.000 --> 01:22:40.833 align:middle
对于Xcode 7
这正是可获得的

01:22:40.900 --> 01:22:42.767 align:middle
带代码覆盖率测试的内部信息

01:22:44.033 --> 01:22:46.533 align:middle
一测试Xcode
就会收集覆盖率数据

01:22:47.100 --> 01:22:49.167 align:middle
跳到测试报告

01:22:49.733 --> 01:22:51.633 align:middle
我们可以
看到有一个新覆盖率部分

01:22:53.167 --> 01:22:54.833 align:middle
覆盖率部分的内部

01:22:55.133 --> 01:22:57.533 align:middle
应用中的所有文件被列出

01:22:57.933 --> 01:22:59.300 align:middle
它们的右边有一个指示器

01:22:59.367 --> 01:23:02.100 align:middle
显示每个文件的覆盖率百分比

01:22:59.367 --> 01:23:02.100 align:middle
显示每个文件的覆盖率百分比

01:23:03.033 --> 01:23:05.900 align:middle
现在 在这个清单中
我按照从高到低进行分类

01:23:06.200 --> 01:23:07.333 align:middle
这样看起来好多了

01:23:07.400 --> 01:23:10.533 align:middle
往下滚动
可以看到这里还有些工作要做

01:23:12.500 --> 01:23:15.600 align:middle
对于列表中的每个文件
你可以公开内容

01:23:15.667 --> 01:23:17.167 align:middle
看看方法的覆盖率

01:23:17.233 --> 01:23:19.033 align:middle
以及此处说包含的功能

01:23:19.767 --> 01:23:21.000 align:middle
对于这个我已经公开的文件

01:23:21.067 --> 01:23:23.700 align:middle
前两个功能覆盖率100%

01:23:24.000 --> 01:23:26.233 align:middle
但其他三个的覆盖率为0

01:23:28.100 --> 01:23:32.067 align:middle
对于项目 报告为你提供
覆盖率的高度概括

01:23:32.500 --> 01:23:35.033 align:middle
但是我们想
直接为你提供信息

01:23:35.767 --> 01:23:38.700 align:middle
看看这里
当我操作一个源文件时

01:23:38.900 --> 01:23:40.567 align:middle
我们直接将代码覆盖率信息

01:23:40.633 --> 01:23:41.800 align:middle
带到源编辑器中

01:23:42.500 --> 01:23:43.800 align:middle
黑色的这部分

01:23:43.867 --> 01:23:46.100 align:middle
是还未进行测试的代码

01:23:46.967 --> 01:23:49.767 align:middle
非常好
这样我就知道该关注哪里

01:23:50.600 --> 01:23:52.767 align:middle
它和助理编辑器也配合得很好

01:23:53.167 --> 01:23:56.367 align:middle
因为你可以有源代码
并一起进行测试

01:23:56.733 --> 01:23:59.633 align:middle
一旦测试持续进行
就更新信息

01:24:01.833 --> 01:24:04.467 align:middle
如果我们回到报告
看看未覆盖的类

01:24:04.533 --> 01:24:07.933 align:middle
大部分是用户界面类

01:24:08.033 --> 01:24:09.367 align:middle
它们是视图自控器 等等

01:24:10.200 --> 01:24:11.067 align:middle
所以 帮我一下

01:24:11.133 --> 01:24:13.100 align:middle
我要创建一个用户界面测试

01:24:14.700 --> 01:24:18.033 align:middle
我已经建立一个用户
界面测试bundle和类

01:24:18.600 --> 01:24:19.833 align:middle
我将从这里挑选

01:24:20.867 --> 01:24:24.233 align:middle
我想要写的测试程序是
用来测试游戏选择板

01:24:25.433 --> 01:24:30.467 align:middle
新API和XE测试可使你与
用户转换元件互动

01:24:30.733 --> 01:24:31.967 align:middle
访问他们的设备

01:24:32.233 --> 01:24:34.933 align:middle
触发行动
真的很容易写出来

01:24:36.000 --> 01:24:38.967 align:middle
但比写UI
测试更简单的是什么 知道吗

01:24:39.033 --> 01:24:41.733 align:middle
记录一个
让我来告诉你怎么做

01:24:43.067 --> 01:24:44.667 align:middle
我先解除项目导航

01:24:44.733 --> 01:24:46.267 align:middle
为自己释放一些空间

01:24:46.867 --> 01:24:49.567 align:middle
以及测试中我想进行的插入点

01:24:50.067 --> 01:24:52.200 align:middle
我将点击一下编辑器底部的

01:24:52.267 --> 01:24:53.133 align:middle
小记录按钮

01:24:54.400 --> 01:24:56.767 align:middle
你可以看到在我操作时
Xcode开始应用

01:24:57.767 --> 01:24:59.400 align:middle
请注意

01:24:59.467 --> 01:25:01.033 align:middle
左上角的测试

01:24:59.467 --> 01:25:01.033 align:middle
左上角的测试

01:25:01.967 --> 01:25:04.833 align:middle
首先我想要你点击
应用中的选择按钮

01:25:05.600 --> 01:25:06.467 align:middle
你可以看到

01:25:06.767 --> 01:25:09.167 align:middle
Xcode
正在记录测试代码的

01:25:09.233 --> 01:25:10.067 align:middle
插入对应线

01:25:18.600 --> 01:25:20.200 align:middle
你可以看到API非常简单

01:25:20.433 --> 01:25:23.033 align:middle
它正在为窗口和按钮询问应用

01:25:23.333 --> 01:25:24.267 align:middle
告诉我们点击

01:25:25.833 --> 01:25:27.600 align:middle
测试的下一步

01:25:27.667 --> 01:25:28.933 align:middle
我要填上玩家的名字

01:25:29.000 --> 01:25:31.500 align:middle
我开始在标准玩家把手这打字

01:25:31.667 --> 01:25:34.033 align:middle
你可以看到这里
两件很酷的事情发生了

01:25:34.533 --> 01:25:36.367 align:middle
第一 当我在文本域打字时

01:25:36.433 --> 01:25:39.267 align:middle
编辑器也跟着更新
并展示数值

01:25:39.667 --> 01:25:40.500 align:middle
非常的酷

01:25:41.400 --> 01:25:42.600 align:middle
另一个是

01:25:42.667 --> 01:25:44.900 align:middle
UI记录注意到我正在和

01:25:44.967 --> 01:25:47.767 align:middle
同一用户的界面因素
进行不止一次的互动

01:25:48.067 --> 01:25:50.633 align:middle
它重构测试代码
为它创建一个局部变量

01:25:51.400 --> 01:25:54.467 align:middle
这使得测试可读

01:25:54.533 --> 01:25:56.967 align:middle
意味着后续很容易
重构并重新使用代码

01:25:58.400 --> 01:26:00.867 align:middle
我们继续从这挑选一些选择项

01:25:58.400 --> 01:26:00.867 align:middle
我们继续从这挑选一些选择项

01:26:00.933 --> 01:26:02.100 align:middle
你可以看到测试升级了

01:26:02.833 --> 01:26:05.500 align:middle
对于最后一个要素
我要从这选一个不同的机器人

01:26:05.833 --> 01:26:08.833 align:middle
我将按这个按钮
选择蓝色机器人

01:26:10.100 --> 01:26:12.267 align:middle
点击完成
回去看我的测试

01:26:13.600 --> 01:26:17.233 align:middle
和记录一样
很容易就可追踪我所有的行动

01:26:18.033 --> 01:26:20.233 align:middle
测试还可以做更多的事

01:26:20.300 --> 01:26:22.533 align:middle
我们可验证一些数值

01:26:23.200 --> 01:26:25.867 align:middle
在点击完成按钮之前
让我们先插入一些代码

01:26:26.100 --> 01:26:27.767 align:middle
检查设置是否正确

01:26:29.100 --> 01:26:31.267 align:middle
我将在这插入一些代码

01:26:31.333 --> 01:26:34.067 align:middle
从界面获取有效机器人的数值

01:26:34.267 --> 01:26:35.100 align:middle
这是在文本域中

01:26:35.400 --> 01:26:38.600 align:middle
我将和我预料的数值进行对比
蓝色机器人

01:26:40.067 --> 01:26:42.633 align:middle
没有进一步的动态数据对象
可以开始测试了

01:26:43.700 --> 01:26:44.600 align:middle
我不介入

01:26:45.667 --> 01:26:47.233 align:middle
这里可以看到它正在更新数值

01:26:47.533 --> 01:26:48.500 align:middle
选择正确的机器人

01:26:48.867 --> 01:26:50.967 align:middle
验证测试 测试通过了

01:27:00.733 --> 01:27:03.200 align:middle
所以记录产生编写
UI测试真的很容易

01:27:04.567 --> 01:27:07.433 align:middle
我们可以看看Xcode
内部的测试并局部运作

01:27:07.767 --> 01:27:10.367 align:middle
我们也可以
让它在持续集成木马上运作

01:27:11.133 --> 01:27:14.500 align:middle
我为应用iOS和OSX版本
设置一些木马

01:27:15.200 --> 01:27:19.000 align:middle
如果选择iOS版本
看看测试

01:27:19.667 --> 01:27:21.033 align:middle
当我过滤掉失败的测试

01:27:21.100 --> 01:27:22.100 align:middle
我看到一些有趣的东西

01:27:22.933 --> 01:27:26.167 align:middle
我有四个界面测试
它们iPhone上通过测试

01:27:26.500 --> 01:27:27.867 align:middle
但在iPad上 测试失败

01:27:29.567 --> 01:27:31.967 align:middle
为方便诊断测试失败原因

01:27:32.067 --> 01:27:34.567 align:middle
每个运行测试包括
所有运行过的测试行为的副本

01:27:34.633 --> 01:27:39.367 align:middle
看到这些
我可以通过扩展测试

01:27:39.967 --> 01:27:41.667 align:middle
这是一份清单测试的所有行为

01:27:41.733 --> 01:27:43.200 align:middle
是关于刚才就开始运行的

01:27:44.767 --> 01:27:46.667 align:middle
因为可以看到用户界面测试

01:27:46.733 --> 01:27:48.133 align:middle
我想要更进一步

01:27:48.633 --> 01:27:51.233 align:middle
每一个行动都包含平面截图

01:27:52.167 --> 01:27:54.800 align:middle
如果我检查
iPhone上通过的测试

01:27:55.067 --> 01:27:57.433 align:middle
我可以得到一个平面截图
关于测试如何开始的

01:27:57.700 --> 01:27:58.667 align:middle
这是我们游戏的开始

01:27:59.400 --> 01:28:01.733 align:middle
我也可以查看测试的中间部分

01:27:59.400 --> 01:28:01.733 align:middle
我也可以查看测试的中间部分

01:28:02.100 --> 01:28:03.000 align:middle
这里 我们用键盘

01:28:03.067 --> 01:28:04.700 align:middle
在文本域中敲入一个数值

01:28:05.467 --> 01:28:07.333 align:middle
我同样可以看测试的最后部分

01:28:07.667 --> 01:28:10.633 align:middle
这是在点击
完成按钮前UI的情形

01:28:11.933 --> 01:28:14.400 align:middle
如果我将其翻过来
在iPad上看测试

01:28:14.467 --> 01:28:16.733 align:middle
并一直跳过 直到最后部分

01:28:17.433 --> 01:28:20.433 align:middle
可看到这是iPad UI
所有设置都正确

01:28:21.033 --> 01:28:21.867 align:middle
但没有完成按钮

01:28:22.500 --> 01:28:24.500 align:middle
显然 在UI中
我们错误安装了一些东西

01:28:24.567 --> 01:28:28.033 align:middle
屏幕截图可以很快地
帮我们缩小范围

01:28:29.533 --> 01:28:31.600 align:middle
代码覆盖率告诉我
在哪里写测试

01:28:32.067 --> 01:28:33.600 align:middle
UI测试和记录让我可以

01:28:33.667 --> 01:28:34.867 align:middle
很容易的获取更多的覆盖率

01:28:34.933 --> 01:28:36.867 align:middle
新测试记录帮我

01:28:36.933 --> 01:28:37.967 align:middle
缩小问题范围

01:28:38.733 --> 01:28:40.167 align:middle
以上是关于Xcode 7

01:28:40.267 --> 01:28:42.233 align:middle
代码覆盖率和UI
测试的信息

01:28:52.167 --> 01:28:56.400 align:middle
用户界面测试
使系统可达性的使用与

01:28:56.667 --> 01:28:58.267 align:middle
UI要素相互作用

01:28:58.967 --> 01:29:02.367 align:middle
意思是如果你已经
让你的app具有可达性

01:28:58.967 --> 01:29:02.367 align:middle
意思是如果你已经
让你的app具有可达性

01:29:02.833 --> 01:29:05.167 align:middle
那么你也已经
让你的app具有可测试性

01:29:06.633 --> 01:29:11.533 align:middle
UI测试同样可用于根据尺寸
和定位设计的Uis中

01:29:11.600 --> 01:29:13.133 align:middle
包括从右到左的支持

01:29:13.600 --> 01:29:14.933 align:middle
也就是说你的UI测试

01:29:15.000 --> 01:29:18.467 align:middle
可以
测量你的UI中所有的演示

01:29:20.400 --> 01:29:23.067 align:middle
新API 是的
你可以为它鼓掌

01:29:27.833 --> 01:29:33.200 align:middle
新API和XE测试
使用于

01:29:33.267 --> 01:29:34.967 align:middle
Swift和
Objective-C

01:29:35.267 --> 01:29:37.967 align:middle
UI记录
将生成你所使用的任何一个

01:29:39.733 --> 01:29:43.000 align:middle
这些是你在
Xcode7可找到的新特征

01:29:43.067 --> 01:29:47.067 align:middle
在你为我们平台创建
App时就可以看到

01:29:55.633 --> 01:29:58.733 align:middle
现在 我们要和你们
分享一些令人兴奋的新技术

01:29:58.800 --> 01:30:00.500 align:middle
它们可用在游戏和制图中

01:29:58.800 --> 01:30:00.500 align:middle
它们可用在游戏和制图中

01:30:00.567 --> 01:30:03.467 align:middle
我将邀请我的同事
杰夫· 斯特尔上台

01:30:07.233 --> 01:30:08.933 align:middle
杰夫· 斯特尔：
谢谢你马太·菲力克

01:30:10.100 --> 01:30:11.733 align:middle
我很激动
Xcode 7实在令人惊讶

01:30:12.800 --> 01:30:15.433 align:middle
能在
这里和你们谈论游戏和制图

01:30:16.067 --> 01:30:18.533 align:middle
似乎就在不久前
我们在这里介绍了

01:30:18.600 --> 01:30:22.200 align:middle
我们首个与游戏有关的
API Game Center

01:30:22.267 --> 01:30:23.633 align:middle
或社交类游戏网络

01:30:24.667 --> 01:30:28.133 align:middle
从那之后
我们一直为API的键盘输入

01:30:28.200 --> 01:30:31.600 align:middle
和制图技术忙碌像
游戏控制器SceneKit

01:30:31.967 --> 01:30:34.100 align:middle
SpriteKit
以及最近的Metal

01:30:35.567 --> 01:30:39.033 align:middle
今年我们推出了
不少新游戏技术

01:30:39.767 --> 01:30:43.733 align:middle
包括使你的绘图
现代化的Model I/O

01:30:44.667 --> 01:30:47.533 align:middle
ReplayKit用来
拓展游戏的社会范围

01:30:48.333 --> 01:30:52.933 align:middle
Game Center用来为你的
游戏增加超级厉害的大脑

01:30:53.500 --> 01:30:57.967 align:middle
而且 我们把所有的这些
都放在GameKit里

01:30:58.833 --> 01:31:02.567 align:middle
只要有一个GameKit
所有功能均触手可及

01:30:58.833 --> 01:31:02.567 align:middle
只要有一个GameKit
所有功能均触手可及

01:31:03.233 --> 01:31:04.333 align:middle
很棒的解决方法

01:31:04.633 --> 01:31:08.000 align:middle
在我们平台上发展游戏的
极其完整的解决方法

01:31:09.767 --> 01:31:12.467 align:middle
让我们来看看GameKit
上的某些很酷的新特征

01:31:12.900 --> 01:31:13.767 align:middle
从Metal开始

01:31:14.933 --> 01:31:16.367 align:middle
你知道Metal是

01:31:16.433 --> 01:31:19.367 align:middle
去年我们为
iOS推出的3DAPI

01:31:19.867 --> 01:31:23.467 align:middle
我们真的很兴奋
今年我们将它引进OS X

01:31:25.000 --> 01:31:28.000 align:middle
作为翻新产品
让我们来看一个例子

01:31:28.067 --> 01:31:32.167 align:middle
我们最近从OpenGL移到
Metal的游戏开发

01:31:33.533 --> 01:31:35.900 align:middle
这里有个游戏 开始时

01:31:36.500 --> 01:31:38.933 align:middle
是在OpenGL上运行
你可以看到

01:31:39.100 --> 01:31:44.267 align:middle
OpenGL处理命令使得
一个CPU完全饱和

01:31:44.500 --> 01:31:46.700 align:middle
这使得游戏
玩法进入第二个CPU

01:31:47.100 --> 01:31:50.600 align:middle
这个CPU并不繁忙
事实上 在这个例子中

01:31:50.667 --> 01:31:52.900 align:middle
我们看到CPU有
40%处于闲置状态

01:31:55.400 --> 01:31:56.600 align:middle
移到Metal

01:31:56.667 --> 01:31:59.533 align:middle
我们彻底地减少
处理命令的时间

01:31:59.800 --> 01:32:01.067 align:middle
我们有API

01:31:59.800 --> 01:32:01.067 align:middle
我们有API

01:32:01.133 --> 01:32:02.900 align:middle
你可以更直接的为GPU编程

01:32:02.967 --> 01:32:05.533 align:middle
如果你选择
你可以将处理命令分开

01:32:05.800 --> 01:32:07.033 align:middle
穿过多重芯部

01:32:07.500 --> 01:32:12.600 align:middle
在这个例子中
我们释放了GPU的全部性能

01:32:14.667 --> 01:32:18.200 align:middle
我们和第三方开发人员合作
为OSX开发Metal

01:32:19.467 --> 01:32:20.400 align:middle
让我们花一分钟

01:32:20.467 --> 01:32:23.667 align:middle
看看他们在Mac上所做的

01:32:24.933 --> 01:32:27.633 align:middle
很高兴为你们介绍
大卫·麦克德兰

01:32:27.700 --> 01:32:28.967 align:middle
他来自
Adobe Systems

01:32:29.033 --> 01:32:30.300 align:middle
将为我们展示

01:32:30.367 --> 01:32:32.333 align:middle
他们使用OSX
对Metal做了什么

01:32:38.167 --> 01:32:39.467 align:middle
大卫·麦克德兰:
非常感谢

01:32:39.533 --> 01:32:42.167 align:middle
去年春天
Adobe曾很激动

01:32:42.267 --> 01:32:44.533 align:middle
当Apple把iOS引进
Metal的iOS时

01:32:44.700 --> 01:32:46.933 align:middle
事实上 我们已经用它来优化

01:32:47.000 --> 01:32:48.267 align:middle
部分流行的iOS App

01:32:48.333 --> 01:32:50.667 align:middle
Premier Flip
Photoshop Mix

01:32:50.733 --> 01:32:51.767 align:middle
而且看到了很好的结果

01:32:52.567 --> 01:32:55.000 align:middle
当Apple告诉我们
Metal被引入到OSX

01:32:55.067 --> 01:32:56.167 align:middle
我们非常的激动

01:32:56.867 --> 01:32:59.400 align:middle
这样一来 我们就可以
在这些平台分享我们的代码

01:33:00.100 --> 01:33:02.467 align:middle
今天我将展示
我们的一些进展

01:33:02.533 --> 01:33:04.933 align:middle
Mac OS的两款旗舰产品

01:33:05.000 --> 01:33:06.833 align:middle
Illustrator
和After Effects

01:33:06.900 --> 01:33:08.267 align:middle
我们来看一下

01:33:15.300 --> 01:33:18.200 align:middle
这是当前版本的
Adobe Illustrator

01:33:18.867 --> 01:33:23.033 align:middle
里面有大量的原图
超过三十万点

01:33:23.500 --> 01:33:25.200 align:middle
渐变和合成模式

01:33:27.333 --> 01:33:29.800 align:middle
我将继续
并对这张原图做缩放

01:33:31.667 --> 01:33:33.467 align:middle
你可以看到

01:33:34.100 --> 01:33:36.233 align:middle
在处理那张复杂的原图时
速度有点慢

01:33:37.200 --> 01:33:38.767 align:middle
我真想看看我们能否做些改善

01:33:40.067 --> 01:33:42.567 align:middle
用这个版本 我们将展示

01:33:42.633 --> 01:33:45.400 align:middle
在我们用了整个绘制引擎
并将它放到Metal上时

01:33:45.467 --> 01:33:47.000 align:middle
我们可以用Metal做什么

01:33:47.400 --> 01:33:49.000 align:middle
事实上 它很好用

01:33:49.067 --> 01:33:54.233 align:middle
它们将展示出
有不断缩放功能的全新特征

01:33:55.133 --> 01:33:58.467 align:middle
当你考虑我们可以用
Metal做什么的时候

01:33:59.033 --> 01:34:00.600 align:middle
你可以看到结果出人意料

01:33:59.033 --> 01:34:00.600 align:middle
你可以看到结果出人意料

01:34:01.400 --> 01:34:05.200 align:middle
事实上 我可以一直缩放
放大很多

01:34:07.533 --> 01:34:08.967 align:middle
直到你可以看到文本信息

01:34:17.333 --> 01:34:19.967 align:middle
这也很大程度上改变了艺术家
使用我们产品时的工作方式

01:34:21.333 --> 01:34:23.100 align:middle
现在我想谈一下
后遗效应

01:34:23.267 --> 01:34:25.900 align:middle
这里有一盘录像来自极限运动
团videographer

01:34:25.967 --> 01:34:27.800 align:middle
Devin
Supertramp

01:34:27.867 --> 01:34:28.867 align:middle
让我们快速浏览一遍

01:34:42.833 --> 01:34:43.667 align:middle
十分有趣

01:34:44.133 --> 01:34:46.300 align:middle
我们要的是
从中选择一个镜头

01:34:46.367 --> 01:34:48.400 align:middle
用后遗效应进行分析
加入一些效果

01:34:48.467 --> 01:34:49.667 align:middle
将其制作成商品广告插播

01:34:50.700 --> 01:34:52.267 align:middle
所以在这里 我将做一些

01:34:52.333 --> 01:34:54.467 align:middle
色彩校正 波纹特效

01:34:54.800 --> 01:34:56.833 align:middle
和镜头光斑特效
接下来

01:34:56.900 --> 01:34:58.400 align:middle
脱离Metal重新播放一遍

01:35:01.167 --> 01:35:03.433 align:middle
你可以看到它在
中央处理器中运行十分困难

01:35:03.967 --> 01:35:04.833 align:middle
也不能产生

01:35:04.900 --> 01:35:06.600 align:middle
我们所倾向的交互性能

01:35:06.667 --> 01:35:08.033 align:middle
并提供给文字编排人员

01:35:09.233 --> 01:35:11.600 align:middle
这也是对程序员的一种挑战
他们要时刻注意这一点

01:35:11.667 --> 01:35:13.500 align:middle
看看
能利用Metal做些什么

01:35:14.167 --> 01:35:15.367 align:middle
所以短时间内 他们需要

01:35:15.433 --> 01:35:18.333 align:middle
将这三个
效应转移给Metal之后

01:35:18.400 --> 01:35:20.600 align:middle
你们会发现
相当惊人的不同

01:35:20.667 --> 01:35:22.867 align:middle
现在我切换到
相同的编制

01:35:23.167 --> 01:35:24.600 align:middle
但这次
那些特效将会被替换

01:35:24.667 --> 01:35:26.667 align:middle
转变为Metal版本
下面我再重播一遍

01:35:27.567 --> 01:35:29.567 align:middle
你可以马上看到实时运行

01:35:30.300 --> 01:35:33.433 align:middle
不需要降低框架
我们看到

01:35:33.500 --> 01:35:35.933 align:middle
这些特效达到
八倍的性能优化

01:35:36.167 --> 01:35:38.700 align:middle
很大程度上减少
处理器使用量

01:35:39.467 --> 01:35:41.933 align:middle
因此奥多比公司
致力于将Metal

01:35:42.000 --> 01:35:44.767 align:middle
引入到Mac操作系统
创新云应用中

01:35:44.833 --> 01:35:47.333 align:middle
如Illustrator
及我今天为你展示的后遗效应

01:35:47.467 --> 01:35:49.900 align:middle
当然还有Photoshop
和Premier Pro

01:35:50.067 --> 01:35:51.433 align:middle
我们很激动看到Metal

01:35:51.500 --> 01:35:52.567 align:middle
为云用户所做的一切

01:35:52.833 --> 01:35:53.667 align:middle
非常感谢

01:35:59.800 --> 01:36:01.833 align:middle
杰夫 斯特尔：
大卫 谢谢你 这不可思议

01:35:59.800 --> 01:36:01.833 align:middle
杰夫 斯特尔：
大卫 谢谢你 这不可思议

01:36:01.900 --> 01:36:03.833 align:middle
我同意克雷格的观点
这十分有趣 因为

01:36:03.900 --> 01:36:07.833 align:middle
你可以进行
非实时交互作用并转换为

01:36:07.900 --> 01:36:10.433 align:middle
流畅的用户交互

01:36:11.000 --> 01:36:13.400 align:middle
但Metal不仅适用于
应用程序

01:36:13.700 --> 01:36:15.067 align:middle
当我们说到今天早上

01:36:15.633 --> 01:36:19.267 align:middle
iOS系统中关键的图形技术

01:36:19.500 --> 01:36:22.533 align:middle
接入就将OS
X系统以及应用程序界面

01:36:23.333 --> 01:36:25.933 align:middle
直到现在
像核心动画技术

01:36:26.300 --> 01:36:28.133 align:middle
以及硬件加速的核心图像

01:36:28.433 --> 01:36:31.700 align:middle
移文档Safari页面显示
都已被置于开放图形语言顶端

01:36:32.433 --> 01:36:36.700 align:middle
这意味着中央处理器
疲于应对图形处理器的指令

01:36:38.233 --> 01:36:41.667 align:middle
运用Metal我们
可以提高效率改进性能

01:36:41.900 --> 01:36:43.833 align:middle
尤其是关键的用户级别任务

01:36:46.300 --> 01:36:48.300 align:middle
此外 我们不想仅仅

01:36:54.033 --> 01:36:55.467 align:middle
提升系统性能

01:36:55.567 --> 01:36:59.133 align:middle
我们真正想做的
是想让所有人可以很轻松地

01:36:59.200 --> 01:37:00.133 align:middle
使用Metal

01:36:59.200 --> 01:37:00.133 align:middle
使用Metal

01:37:00.400 --> 01:37:01.867 align:middle
因此
我们引入MetalKit

01:37:02.667 --> 01:37:04.533 align:middle
通过它可以了解Metal

01:37:04.833 --> 01:37:06.700 align:middle
这对你来说是一份重担

01:37:07.233 --> 01:37:09.500 align:middle
MetalKit可以做
很多事从绘制渲染循环

01:37:09.900 --> 01:37:13.367 align:middle
到通过交互作用加载3D模型

01:37:13.433 --> 01:37:15.133 align:middle
主要是同艺术家
I/O模式的交互作用

01:37:15.200 --> 01:37:17.633 align:middle
事实上
MetalKit可以将网格

01:37:17.700 --> 01:37:19.000 align:middle
直接输入Metal缓冲器

01:37:19.067 --> 01:37:22.500 align:middle
运用所能做的去渲染场景

01:37:23.767 --> 01:37:24.700 align:middle
不仅如此

01:37:25.400 --> 01:37:28.333 align:middle
Metal着色器是高性能

01:37:28.400 --> 01:37:30.633 align:middle
图像处理着色器主要
应用于Metal应用程序

01:37:31.167 --> 01:37:34.600 align:middle
这些都是基于图形处理器的
平行计算着色器

01:37:34.667 --> 01:37:39.500 align:middle
个别再次转变为
我们的图形处理器使我们更易

01:37:39.800 --> 01:37:41.000 align:middle
使用Metal

01:37:42.367 --> 01:37:44.200 align:middle
所以现在 你拥有极佳的
渲染管道

01:37:44.267 --> 01:37:46.267 align:middle
但也需要丰富的储存信息

01:37:46.767 --> 01:37:48.200 align:middle
因此我们使用I/O模型

01:37:48.767 --> 01:37:51.400 align:middle
有时使用3D模型
加载和运行比较难处理

01:37:52.733 --> 01:37:54.000 align:middle
这都多亏了I/O模型

01:37:54.333 --> 01:37:56.633 align:middle
简化了内容加载

01:37:56.700 --> 01:38:00.167 align:middle
使不同文件格式的内容
可直接输入SceneKit

01:37:56.700 --> 01:38:00.167 align:middle
使不同文件格式的内容
可直接输入SceneKit

01:38:00.233 --> 01:38:02.833 align:middle
或通过与MetalKit
交互作用输入到Metal中

01:38:02.900 --> 01:38:05.933 align:middle
但它将自己区分在于
处理光照的方式

01:38:07.400 --> 01:38:12.433 align:middle
I/O模型向你提供
最先进光线跟踪的

01:38:15.300 --> 01:38:17.567 align:middle
材料照明方式

01:38:17.833 --> 01:38:20.867 align:middle
这意味着
它惊人地提供

01:38:20.933 --> 01:38:21.933 align:middle
纹理映射

01:38:22.067 --> 01:38:22.900 align:middle
让我们看一下

01:38:23.267 --> 01:38:24.367 align:middle
从基线开始

01:38:24.700 --> 01:38:27.233 align:middle
这仅是一个模型
它是通过纹理载入

01:38:28.067 --> 01:38:29.233 align:middle
这很难让人感兴趣

01:38:29.300 --> 01:38:30.133 align:middle
事实上 它比较单调

01:38:30.267 --> 01:38:33.400 align:middle
我认为九零后
希望重新启用该模型

01:38:33.700 --> 01:38:35.200 align:middle
如果我们除去纹理

01:38:35.267 --> 01:38:37.433 align:middle
并应用全球
照明方式

01:38:37.500 --> 01:38:38.367 align:middle
那么我们看到的

01:38:38.433 --> 01:38:40.133 align:middle
是那些看起来
十分真实的事物

01:38:41.067 --> 01:38:43.200 align:middle
我们再将纹理添加进来
就会得到一些

01:38:43.267 --> 01:38:44.267 align:middle
看起来很棒的东西

01:38:44.467 --> 01:38:47.000 align:middle
最后 当然
即使使用I/O模型

01:38:47.067 --> 01:38:49.000 align:middle
以及它的照明方式
你也可以添加自定义照明

01:38:49.067 --> 01:38:52.267 align:middle
和阴影
使事物看起来更加真实

01:38:52.333 --> 01:38:55.033 align:middle
你可以得到
一些惊人的结论从普通

01:38:55.400 --> 01:38:58.433 align:middle
到非凡 I/O模型
可以向你提供卓越的解决方案

01:38:58.800 --> 01:39:00.700 align:middle
帮助你的模型和照明

01:38:58.800 --> 01:39:00.700 align:middle
帮助你的模型和照明

01:39:01.600 --> 01:39:03.433 align:middle
所以现在
你拥有极佳的渲染管道

01:39:03.867 --> 01:39:05.533 align:middle
也有极佳的模型和储存信息

01:39:05.767 --> 01:39:06.833 align:middle
现在只需好的游戏设置

01:39:07.000 --> 01:39:08.767 align:middle
因此我们有了
GameplayKit

01:39:09.667 --> 01:39:11.900 align:middle
游戏设置可分为两个领域

01:39:11.967 --> 01:39:14.800 align:middle
我们有导航
否则你如何在游戏里移动目标

01:39:15.167 --> 01:39:17.833 align:middle
我们也有策略
否则游戏如何思考

01:39:17.933 --> 01:39:20.133 align:middle
GameplayKit
对这两方面都有解决方案

01:39:21.000 --> 01:39:24.300 align:middle
GameplayKit基于
组件的应用程序界面完全保障

01:39:24.533 --> 01:39:25.700 align:middle
游戏设置的对策

01:39:25.767 --> 01:39:28.333 align:middle
不论你是想追踪
其他玩家的黄金

01:39:28.800 --> 01:39:31.433 align:middle
还是想从甲地到乙地追踪敌人

01:39:31.500 --> 01:39:33.100 align:middle
并且消除途中的障碍

01:39:33.600 --> 01:39:35.800 align:middle
就需要生成确定随机数

01:39:35.867 --> 01:39:38.100 align:middle
以便下次进行在线联机游戏

01:39:38.433 --> 01:39:39.833 align:middle
游戏设置也为你提供解决方案

01:39:39.900 --> 01:39:42.467 align:middle
从简单游戏到复杂游戏

01:39:42.700 --> 01:39:44.933 align:middle
我们认为游戏设置
可以有效地帮助你们

01:39:45.000 --> 01:39:45.933 align:middle
开发游戏

01:39:48.167 --> 01:39:51.833 align:middle
我们从社会组成开始
即游戏中心

01:39:52.733 --> 01:39:55.333 align:middle
ReplayKit可以扩展
到社会交互作用

01:39:55.667 --> 01:39:59.800 align:middle
ReplayKit允许玩家
录制电视节目重播

01:39:59.867 --> 01:40:00.867 align:middle
主要针对游戏开放

01:39:59.867 --> 01:40:00.867 align:middle
主要针对游戏开放

01:40:01.200 --> 01:40:03.400 align:middle
他们可以保存或分享录像

01:40:03.700 --> 01:40:06.167 align:middle
它属于硬件加速具有高性能

01:40:06.900 --> 01:40:09.167 align:middle
十分便于你们操作

01:40:09.533 --> 01:40:11.800 align:middle
便于将其添加到游戏中
也许

01:40:11.867 --> 01:40:14.200 align:middle
它可以开展下一次的
病毒式市场营销活动

01:40:14.567 --> 01:40:15.567 align:middle
来推广游戏项目

01:40:18.100 --> 01:40:20.233 align:middle
最后是SceneKit
和SpriteKit

01:40:20.600 --> 01:40:22.400 align:middle
我们对他们进行了一些伟大的更新

01:40:22.467 --> 01:40:25.000 align:middle
但我觉得最有趣的
或者说最引人注目的

01:40:25.767 --> 01:40:26.933 align:middle
是我们创建了一些工具

01:40:27.233 --> 01:40:30.667 align:middle
可以让SceneKit
和SpriteKit

01:40:30.733 --> 01:40:34.400 align:middle
直接导入Xcode 7系统
接下来由我的同事

01:40:34.467 --> 01:40:36.000 align:middle
Jacques Gasselin
de Richebourg

01:40:36.067 --> 01:40:38.933 align:middle
向你们展示Xcode 7
内部工具

01:40:46.567 --> 01:40:49.467 align:middle
去年的Xcode 6系统
我们引进了视觉场景编辑

01:40:49.533 --> 01:40:51.833 align:middle
添加进Xcode 系统的
SpriteKit

01:40:51.900 --> 01:40:53.300 align:middle
今年 我们引进了一个缺口

01:40:53.567 --> 01:40:56.500 align:middle
并将动画编辑
添加进Xcode系统

01:40:56.800 --> 01:40:59.367 align:middle
所以在这里
我会做一些场景剪切

01:40:59.667 --> 01:41:03.100 align:middle
你们会看到可爱的红色小熊
他将往前走

01:40:59.667 --> 01:41:03.100 align:middle
你们会看到可爱的红色小熊
他将往前走

01:41:03.167 --> 01:41:05.233 align:middle
穿过两条峡谷走到另一边

01:41:05.300 --> 01:41:07.267 align:middle
这些都是基础的动画技术
我在这里呈现一下

01:41:07.633 --> 01:41:11.333 align:middle
我想要将此分层导入到动画中

01:41:11.767 --> 01:41:13.933 align:middle
很明显 我们首先让它运行

01:41:14.633 --> 01:41:16.400 align:middle
接下来 抓取一个动作

01:41:16.533 --> 01:41:18.600 align:middle
现在
让我们进行最有趣的操作

01:41:18.800 --> 01:41:19.933 align:middle
这是一个参考行为

01:41:20.367 --> 01:41:22.733 align:middle
意味着它实际上
储存在另一个文件里

01:41:22.833 --> 01:41:24.833 align:middle
即
actions.sks文件

01:41:25.333 --> 01:41:28.133 align:middle
我在这里进行参考
就可以进行排版操作

01:41:28.733 --> 01:41:29.733 align:middle
所以我打算抓取下来

01:41:30.100 --> 01:41:32.500 align:middle
当然
这和复制粘贴或一样简单

01:41:33.067 --> 01:41:36.267 align:middle
我打算多做几次
它就会很自然地附加

01:41:36.667 --> 01:41:37.600 align:middle
在相同的轨道后

01:41:38.533 --> 01:41:39.967 align:middle
让我们看一下
接下来

01:41:40.033 --> 01:41:42.567 align:middle
这次我们使用清除器
所以它是一个时间线

01:41:42.633 --> 01:41:45.500 align:middle
一个有清除器的时间线
你可以随时预览

01:41:45.567 --> 01:41:47.367 align:middle
动画的大致模样

01:41:49.267 --> 01:41:52.067 align:middle
这不仅
是一个极佳的预览工具

01:41:52.333 --> 01:41:53.867 align:middle
实际上
它也是不错的编辑工具

01:41:54.367 --> 01:41:56.433 align:middle
你可以注意到他没有跳过峡谷

01:41:56.500 --> 01:41:59.233 align:middle
这是个问题 我们将进行调整

01:42:00.133 --> 01:42:02.267 align:middle
让我们想出 他跳跃的好时机

01:42:03.267 --> 01:42:05.067 align:middle
看起来这里是最好的

01:42:06.000 --> 01:42:07.567 align:middle
之后
我们要抓取一个移动瞬间

01:42:08.400 --> 01:42:09.800 align:middle
让他在这里跳跃

01:42:09.867 --> 01:42:11.533 align:middle
现在
注意是如何抓取时间线的

01:42:12.233 --> 01:42:15.467 align:middle
好 下面让它
增长100个单元

01:42:16.467 --> 01:42:18.567 align:middle
再次使用时间线

01:42:19.267 --> 01:42:20.233 align:middle
计算出顶点值

01:42:20.300 --> 01:42:21.133 align:middle
大约在这里

01:42:21.200 --> 01:42:23.433 align:middle
现在看一下持续时间

01:42:24.200 --> 01:42:25.533 align:middle
好了吗？这很简单

01:42:26.367 --> 01:42:29.200 align:middle
很明显 当他跳起来
我想让他减速

01:42:29.267 --> 01:42:31.067 align:middle
这意味着
在一开始 他速度很快

01:42:31.133 --> 01:42:32.700 align:middle
在顶点时却很慢

01:42:33.267 --> 01:42:35.467 align:middle
复制 粘贴 反过来

01:42:36.867 --> 01:42:37.700 align:middle
达到负100

01:42:38.767 --> 01:42:39.867 align:middle
然后开始加速

01:42:39.933 --> 01:42:42.067 align:middle
使他能够在顶点停滞

01:42:42.933 --> 01:42:44.333 align:middle
好 让我们对此净化

01:42:44.867 --> 01:42:46.167 align:middle
这是抛物线式跳跃

01:42:46.300 --> 01:42:48.833 align:middle
完美 现在 可以看到
它有点怪异

01:42:48.900 --> 01:42:52.133 align:middle
如果他在空中停留的话
所以让我们添加一个动画

01:42:52.733 --> 01:42:55.467 align:middle
注意 我在每个动画顶端
进行分层

01:42:55.567 --> 01:42:57.467 align:middle
这次我们使用
SpriteKit进行操作

01:42:57.800 --> 01:43:01.933 align:middle
现在我要抓取
跳跃长度的动画

01:42:57.800 --> 01:43:01.933 align:middle
现在我要抓取
跳跃长度的动画

01:43:02.600 --> 01:43:04.267 align:middle
进入媒体库

01:43:04.767 --> 01:43:05.900 align:middle
取出跳跃画面

01:43:06.633 --> 01:43:10.800 align:middle
过滤掉跳跃
选中它 就可以选中全部

01:43:11.633 --> 01:43:13.567 align:middle
拖拽 好的

01:43:14.167 --> 01:43:15.267 align:middle
很好 现在对此净化

01:43:15.700 --> 01:43:16.867 align:middle
好 一个完美的跳跃

01:43:18.233 --> 01:43:20.167 align:middle
现在 这里有两个峡谷

01:43:20.233 --> 01:43:21.500 align:middle
重复两次操作

01:43:21.767 --> 01:43:24.700 align:middle
最简单的方式
是将此转变为参考

01:43:25.467 --> 01:43:27.400 align:middle
选中 点击右键

01:43:28.333 --> 01:43:31.433 align:middle
转变为参考
将此命名为Jump

01:43:32.233 --> 01:43:34.600 align:middle
储存进
actions.sks文件

01:43:34.767 --> 01:43:35.967 align:middle
我之前运行过

01:43:36.733 --> 01:43:37.600 align:middle
好 很好 这就是跳跃

01:43:37.667 --> 01:43:40.900 align:middle
再次使用清除器
设置另一次跳跃

01:43:41.100 --> 01:43:42.700 align:middle
参考最大的用途

01:43:43.033 --> 01:43:45.133 align:middle
是它们在这里出现
直接显示在目标程序库中

01:43:45.433 --> 01:43:47.367 align:middle
我只需将它拖拽进来

01:43:48.567 --> 01:43:50.433 align:middle
现在就完成了
我们的最终剪辑画面

01:43:52.200 --> 01:43:53.633 align:middle
好 跳跃 再跳跃

01:43:54.133 --> 01:43:57.633 align:middle
很好 好的 谢谢大家

01:44:02.533 --> 01:44:06.233 align:middle
最棒的一点 对于参考而言
就是它们不仅帮助你

01:44:06.300 --> 01:44:07.800 align:middle
设置其他场景 还有编码

01:44:08.400 --> 01:44:11.900 align:middle
接下来这里我们运用Sk操作

01:44:11.967 --> 01:44:13.833 align:middle
加载相同的操作过程
将它们连接过去

01:44:13.900 --> 01:44:16.900 align:middle
连接到左右键
以及空格键来跳跃

01:44:17.433 --> 01:44:18.667 align:middle
让我们操作一下
看一下过程

01:44:20.500 --> 01:44:22.200 align:middle
现在利用熊猫进行剪辑场景

01:44:22.667 --> 01:44:24.233 align:middle
完美 现在我来控制它

01:44:24.300 --> 01:44:25.967 align:middle
看着 左 右

01:44:26.533 --> 01:44:27.500 align:middle
跳跃

01:44:29.267 --> 01:44:30.267 align:middle
很简单

01:44:35.567 --> 01:44:37.867 align:middle
大家都很忙

01:44:38.567 --> 01:44:41.133 align:middle
所以转化到下一个动画

01:44:42.500 --> 01:44:45.533 align:middle
对Xcode 7系统不熟悉
我们拥有完整的视觉场景编辑

01:44:45.900 --> 01:44:47.700 align:middle
运用SceneKit编辑
3D储存信息

01:44:48.933 --> 01:44:51.433 align:middle
这个编辑程序很像
SpriteKit2D程序

01:44:51.733 --> 01:44:52.567 align:middle
同样的工作原理

01:44:52.900 --> 01:44:54.300 align:middle
拖拉
以添加新信息

01:44:55.100 --> 01:44:57.800 align:middle
也可以使用3D中的调制器
环绕拖动

01:44:58.367 --> 01:44:59.767 align:middle
对齐到其他事物

01:45:00.267 --> 01:45:01.300 align:middle
你甚至可以复制

01:45:03.033 --> 01:45:04.433 align:middle
还有一些物理过程

01:45:04.567 --> 01:45:07.700 align:middle
以及编辑器内部的动画

01:45:07.767 --> 01:45:10.467 align:middle
现在我们进行动画绘制

01:45:11.967 --> 01:45:15.167 align:middle
很好
让我们与此进行交互作用

01:45:16.300 --> 01:45:17.367 align:middle
播放

01:45:17.433 --> 01:45:21.433 align:middle
就可以从之前的演示中
看到同样可爱的熊猫

01:45:25.600 --> 01:45:26.467 align:middle
让我们试一下

01:45:29.133 --> 01:45:31.800 align:middle
这是一只红色熊猫
而不是狐狸 是一只红色熊猫

01:45:33.133 --> 01:45:35.633 align:middle
继续操作接下来

01:45:35.700 --> 01:45:37.600 align:middle
将其与之前的小资料块
进行交互作用

01:45:38.233 --> 01:45:40.333 align:middle
好 剔除出去

01:45:40.400 --> 01:45:43.967 align:middle
很好 在这个游戏中
播放这只小红熊

01:45:44.033 --> 01:45:45.700 align:middle
它正在采摘花朵和珍珠

01:45:48.533 --> 01:45:49.533 align:middle
很遗憾

01:45:50.500 --> 01:45:52.900 align:middle
我承诺
在制作过程中不会伤害到熊猫

01:45:56.833 --> 01:45:58.433 align:middle
这不仅是对现阶段的演示

01:45:58.767 --> 01:46:00.700 align:middle
实际上 我们在向你展示

01:45:58.767 --> 01:46:00.700 align:middle
实际上 我们在向你展示

01:46:01.200 --> 01:46:02.233 align:middle
这是个样本

01:46:02.300 --> 01:46:05.233 align:middle
你可以设计下一个
3D SceneKit游戏

01:46:06.033 --> 01:46:07.667 align:middle
使用这个编辑器
SceneKit

01:46:07.733 --> 01:46:09.700 align:middle
以及Xcode7系统
谢谢大家

01:46:09.767 --> 01:46:11.167 align:middle
接下来
让我们欢迎安德里亚斯

01:46:17.967 --> 01:46:18.800 align:middle
好的

01:46:18.967 --> 01:46:22.267 align:middle
让我们快速回顾一下
我们会上讨论过的技术

01:46:23.267 --> 01:46:25.367 align:middle
今天
我们宣布了OSs的新版本

01:46:25.433 --> 01:46:27.533 align:middle
新的本地化watchOS
软体开发套件

01:46:28.633 --> 01:46:32.533 align:middle
该套件含多个新应用程序界面
你可以充分利用

01:46:32.600 --> 01:46:33.767 align:middle
尤其是在游戏过程中

01:46:34.733 --> 01:46:37.133 align:middle
新的最优化技术包括应用瘦身

01:46:37.867 --> 01:46:40.467 align:middle
转换的新版本让软件运行更快

01:46:40.533 --> 01:46:43.167 align:middle
同时
可以让你编写更有效的代码

01:46:44.133 --> 01:46:46.600 align:middle
当然
目前Xcode系统的新版本

01:46:46.667 --> 01:46:49.067 align:middle
具有用户界面记录和检测

01:46:50.333 --> 01:46:52.867 align:middle
这些技术有利于你下载

01:46:52.933 --> 01:46:56.100 align:middle
今天下午全球开发者大会
参与者门户上面的内容

01:46:56.833 --> 01:46:58.500 align:middle
我们希望你可以很快采用它们

01:46:58.567 --> 01:47:01.533 align:middle
甚至为用户设计
更具创新性的应用

01:46:58.567 --> 01:47:01.533 align:middle
甚至为用户设计
更具创新性的应用

01:47:02.233 --> 01:47:04.367 align:middle
请继续载入所有素材

01:47:04.433 --> 01:47:05.867 align:middle
让我们知道你对它的看法

01:47:07.733 --> 01:47:10.933 align:middle
此外 我们也进行一些创新
在今年 使用飞行试验服务

01:47:11.000 --> 01:47:14.100 align:middle
从今天开始 你们可以
对应用进行配置

01:47:14.167 --> 01:47:17.400 align:middle
适用于飞行测试中
iOS 9软件开发工具包

01:47:17.467 --> 01:47:21.500 align:middle
接下来的几周里我们会继续加
大支持 尤其是对分层应用

01:47:22.033 --> 01:47:25.033 align:middle
点播资源以及Bitcodes
所以你可以检测自己的应用

01:47:25.100 --> 01:47:28.433 align:middle
在我们发行iOS 9之前
运用这些新技术

01:47:28.500 --> 01:47:29.333 align:middle
预计今年下半年

01:47:30.333 --> 01:47:31.167 align:middle
超过一百个讲座

01:47:31.233 --> 01:47:33.167 align:middle
超过一百五十个实验室
超过一个apple工程师

01:47:36.900 --> 01:47:39.167 align:middle
当然 在这里
我们有很多机会去学习

01:47:39.233 --> 01:47:41.267 align:middle
在会议上讨论的这些技术

01:47:41.333 --> 01:47:43.300 align:middle
而且 你还可以参加
一百多次会议

01:47:43.800 --> 01:47:46.833 align:middle
去众多实验室获取项目帮助

01:47:46.900 --> 01:47:48.867 align:middle
实际上 有一百多名
苹果公司工程师

01:47:48.933 --> 01:47:51.267 align:middle
在现场回答你的问题

01:47:51.767 --> 01:47:53.300 align:middle
所以 我希望
你们可以享受此次会议

01:47:53.367 --> 01:47:54.800 align:middle
并在此周之后
收到你们的回复
