WEBVTT

00:00:20.354 --> 00:00:22.422 align:middle
App与新一代网络

00:00:29.997 --> 00:00:31.632 align:middle
谢谢 上午好

00:00:32.665 --> 00:00:36.036 align:middle
欢迎参加“App与新一代网络”讲座

00:00:37.004 --> 00:00:41.175 align:middle
我是普拉巴卡尔·拉卡拉
另外还有我的同事斯图尔特·柴歇尔

00:00:42.743 --> 00:00:44.778 align:middle
今天的讲座分为两个部分

00:00:47.614 --> 00:00:49.950 align:middle
第一个主题关于IPv6

00:00:50.450 --> 00:00:52.886 align:middle
在第二个主题中斯图尔特将会介绍

00:00:53.387 --> 00:00:55.956 align:middle
如何让你的APP更快地运行

00:00:57.791 --> 00:00:59.426 align:middle
我们首先讨论IPv6

00:01:02.763 --> 00:01:04.431 align:middle
IPv6有哪些新特性呢？

00:01:05.799 --> 00:01:09.837 align:middle
在大约17年以前
IPv6 RFC就已经发表

00:01:11.338 --> 00:01:15.642 align:middle
你可能会想今天我们
为什么要讨论IPv6？

00:01:17.878 --> 00:01:23.250 align:middle
我们看到IPv6越来越多地

00:01:23.784 --> 00:01:25.118 align:middle
被部署到企业和蜂窝网络之中

00:01:26.186 --> 00:01:27.487 align:middle
你需要确保你的APP

00:01:27.855 --> 00:01:30.724 align:middle
能够在这些网络中运行

00:01:33.160 --> 00:01:38.198 align:middle
因此你的APP应该强制兼容IPv6

00:01:39.466 --> 00:01:42.436 align:middle
现在我们将讨论这个主题
以及它对于开发者的意义

00:01:43.036 --> 00:01:44.371 align:middle
但是在此之前

00:01:44.972 --> 00:01:46.940 align:middle
请让我们先回顾一下历史

00:01:50.277 --> 00:01:53.380 align:middle
在前些年客户端设备具有真实

00:01:53.614 --> 00:01:57.851 align:middle
唯一的IPv4 那是以前的事情了

00:01:57.918 --> 00:01:59.953 align:middle
你需要进行端对端网络连接

00:02:01.855 --> 00:02:04.057 align:middle
但是我们很快发现

00:02:04.258 --> 00:02:06.293 align:middle
IPv4地址就快要用完了

00:02:07.261 --> 00:02:09.496 align:middle
因此我们在中间加入NAT

00:02:10.931 --> 00:02:15.169 align:middle
这个方法是可行的
但是大规模的NAT设备

00:02:15.235 --> 00:02:17.137 align:middle
不仅昂贵而且脆弱

00:02:18.672 --> 00:02:22.042 align:middle
因此现在运营商
在他们的网络中部署IPv6

00:02:25.045 --> 00:02:28.949 align:middle
利用IPv6以继续提供
端对端网络连接，

00:02:29.316 --> 00:02:31.351 align:middle
不需要在数据路径中进行转换

00:02:33.420 --> 00:02:39.059 align:middle
现在 让我们来看美国三个主要
蜂窝运营商的IPv6部署情况

00:02:42.196 --> 00:02:43.530 align:middle
我们可以看到两个特点

00:02:44.264 --> 00:02:47.134 align:middle
首先所有趋势线都是上升的

00:02:48.435 --> 00:02:51.271 align:middle
其次一半以上的用户

00:02:51.338 --> 00:02:53.307 align:middle
现在通过IPv6连接到

00:02:53.373 --> 00:02:55.742 align:middle
蜂窝数据网络

00:02:57.477 --> 00:02:58.378 align:middle
看起来不错是吧

00:02:59.313 --> 00:03:01.148 align:middle
但是对于网络运营商来说

00:02:59.313 --> 00:03:01.148 align:middle
但是对于网络运营商来说

00:03:01.215 --> 00:03:03.350 align:middle
实际情况比以前更加糟糕

00:03:04.284 --> 00:03:09.623 align:middle
原因是他们的网络现在必须同时

00:03:10.023 --> 00:03:12.159 align:middle
支持IPv4和IPv6

00:03:13.427 --> 00:03:16.830 align:middle
他们真正需要的是消除通过IPv4

00:03:17.130 --> 00:03:18.198 align:middle
访问他们的网络

00:03:19.233 --> 00:03:21.735 align:middle
如果这样做将会导致

00:03:21.802 --> 00:03:23.937 align:middle
完全依靠IPv4
连接网络的设备和用户流失

00:03:24.371 --> 00:03:25.606 align:middle
但 他们仍然是主流

00:03:28.041 --> 00:03:31.745 align:middle
现在运营商在他们的网络中
部署NS64和NAT64

00:03:32.312 --> 00:03:35.148 align:middle
其实现方式是当客户端设备上的APP

00:03:35.215 --> 00:03:37.784 align:middle
进行主机名称查询

00:03:38.218 --> 00:03:41.755 align:middle
以获得IPv4-only服务器的
IPv6地址时

00:03:42.623 --> 00:03:47.194 align:middle
DNS64和网络
将合成一个IPv6地址

00:03:47.327 --> 00:03:48.829 align:middle
并提供给客户端设备

00:03:50.564 --> 00:03:53.967 align:middle
现在客户端设备可以
使用这个IPv6地址

00:03:54.234 --> 00:03:56.303 align:middle
发送流量至网络

00:03:57.638 --> 00:03:59.873 align:middle
网络的配置方式

00:04:00.040 --> 00:04:03.710 align:middle
使搜索数据包被发送给NAT64引擎

00:04:04.211 --> 00:04:06.880 align:middle
NAT64引擎
将IPv6流量转换成为IPv4流量

00:04:07.314 --> 00:04:09.983 align:middle
在客户端设备返回流量时
NAT64引擎将进行相反的转换

00:04:12.352 --> 00:04:14.354 align:middle
在这里 必须注意的是

00:04:14.888 --> 00:04:17.457 align:middle
对于客户端设备上运行的APP来说

00:04:18.559 --> 00:04:23.730 align:middle
你的IPv4-only服务器
看去就你是IPv6-only服务器

00:04:24.565 --> 00:04:25.933 align:middle
这个特性很重要

00:04:26.967 --> 00:04:29.303 align:middle
因为你们一些人可能会认为

00:04:30.003 --> 00:04:32.272 align:middle
我的服务器仅配置用于IPv4

00:04:32.773 --> 00:04:37.611 align:middle
因此我不需要针对通过IPv6进行
访问的客户端来测试我的APP

00:04:39.046 --> 00:04:40.747 align:middle
你的假设并不成立

00:04:42.416 --> 00:04:43.584 align:middle
我们很快就会转换到

00:04:43.650 --> 00:04:46.753 align:middle
到这种类型的网络 到那时

00:04:47.754 --> 00:04:51.325 align:middle
我们希望为用户提供无缝的用户体验

00:04:52.292 --> 00:04:58.899 align:middle
因此你的APP必须支持IPv6

00:05:00.200 --> 00:05:02.669 align:middle
APP必须符合这项要求

00:05:04.538 --> 00:05:06.640 align:middle
这是一项新的APP要求

00:05:07.007 --> 00:05:10.344 align:middle
你可能会想我应该如何针对此网络
来测试我的APP呢?

00:05:11.011 --> 00:05:13.280 align:middle
我可以在哪里找到这种
NAT64类型的网络?

00:05:14.348 --> 00:05:16.583 align:middle
我有一个好消息告诉你们

00:05:19.086 --> 00:05:21.922 align:middle
你可以使用基于
IPv4连接的Mac设备

00:05:22.322 --> 00:05:26.793 align:middle
创建你自己的NAT64网络

00:05:27.060 --> 00:05:29.396 align:middle
并可以开始测试你的APP

00:05:31.064 --> 00:05:33.367 align:middle
这项新功能供开发人员使用

00:05:33.767 --> 00:05:37.337 align:middle
它隐藏起来了
让我们来看清楚一点你只需要

00:05:37.404 --> 00:05:44.344 align:middle
点击“Sharing”选项
然后点击

00:05:44.411 --> 00:05:48.549 align:middle
“Internet Sharing”
选项其他保持不变

00:05:49.449 --> 00:05:51.451 align:middle
这里有一个新复选框显示

00:05:51.852 --> 00:05:53.954 align:middle
“create
NAT64 network”

00:05:55.189 --> 00:05:58.158 align:middle
选中之后 可以选择

00:05:58.225 --> 00:06:02.095 align:middle
Internet共享接口
然后使用这个NAT64网络

00:05:58.225 --> 00:06:02.095 align:middle
Internet共享接口
然后使用这个NAT64网络

00:06:03.230 --> 00:06:04.731 align:middle
开始测试你的APP

00:06:05.866 --> 00:06:09.937 align:middle
在这里举例来说我有一个
IPv4 Internet连接

00:06:10.070 --> 00:06:12.339 align:middle
我想要使用NAT64/DNS64

00:06:12.573 --> 00:06:17.311 align:middle
将这个连接作为
IPv6-only访问网络

00:06:17.644 --> 00:06:19.146 align:middle
在我的Wi-Fi
接口上进行共享

00:06:19.813 --> 00:06:25.285 align:middle
当我开始这样做时我看到
Wi-Fi图标变灰

00:06:25.586 --> 00:06:27.154 align:middle
并且变成箭头

00:06:29.389 --> 00:06:31.225 align:middle
这表明Wi-Fi接口

00:06:31.658 --> 00:06:33.827 align:middle
转为接入点模式

00:06:34.528 --> 00:06:37.931 align:middle
其意义在于它成为一个Wi-Fi热点

00:06:38.198 --> 00:06:40.067 align:middle
你可以连接其他客户端设备

00:06:40.200 --> 00:06:41.502 align:middle
并开始测试你的APP

00:06:42.503 --> 00:06:44.505 align:middle
典型的测试平台是这样的

00:06:46.673 --> 00:06:49.843 align:middle
在WAN侧 IPv4
Internet连接已经完成

00:06:50.077 --> 00:06:54.381 align:middle
我的iMac已经在运行
DNS64/NAT64引擎

00:06:54.781 --> 00:06:58.852 align:middle
成为使用Wi-Fi接口的
IPv6网络热点

00:07:00.087 --> 00:07:04.591 align:middle
你想要测试的APP
已经安装在一台客户端机器上

00:07:05.192 --> 00:07:06.960 align:middle
你也可以在其他Mac设备上

00:07:07.060 --> 00:07:09.530 align:middle
运行的模拟器上测试你的APP

00:07:10.130 --> 00:07:12.666 align:middle
这个Mac必须是
此Internet共享环境的客户端

00:07:14.668 --> 00:07:17.237 align:middle
现在 你已经可以

00:07:17.938 --> 00:07:21.308 align:middle
在这种类型的网络进行测试
你真正想做的事情是

00:07:21.675 --> 00:07:25.212 align:middle
确保这种网络成为开发流程的组成部分

00:07:26.346 --> 00:07:28.815 align:middle
也就是说在任何时候
当你编写新的APP

00:07:29.116 --> 00:07:31.385 align:middle
或者编写APP更新版本时

00:07:31.785 --> 00:07:33.086 align:middle
你需要在提交APP之前

00:07:33.153 --> 00:07:37.591 align:middle
确保在NAT64网络环境下
测试你的APP

00:07:39.359 --> 00:07:43.997 align:middle
现在对你们70%的人来说
这是一个好消息

00:07:44.064 --> 00:07:46.500 align:middle
你的APP运行正常

00:07:46.767 --> 00:07:47.968 align:middle
这很不错吧

00:07:48.735 --> 00:07:50.437 align:middle
你可以放心地测试

00:07:50.737 --> 00:07:54.074 align:middle
各个版本的APP
确保不会有功能受到影响

00:07:55.676 --> 00:07:57.244 align:middle
但是有将近三分之一的人

00:07:58.178 --> 00:08:01.782 align:middle
将会看到
在NAT64MQXT网络环境下

00:07:58.178 --> 00:08:01.782 align:middle
将会看到
在NAT64MQXT网络环境下

00:08:01.849 --> 00:08:05.752 align:middle
你的APP要么受到严重的限制
或者根本无法运行

00:08:07.221 --> 00:08:09.790 align:middle
幸运的是大多数问题都容易修复

00:08:10.724 --> 00:08:11.658 align:middle
这里是一个例子

00:08:18.932 --> 00:08:23.203 align:middle
现在如果你只使用
IPv4-only数据结构

00:08:23.437 --> 00:08:28.108 align:middle
或IPv4-only API
或者你使用同时支持

00:08:28.175 --> 00:08:30.711 align:middle
IPv4和IPv6的API

00:08:31.345 --> 00:08:34.414 align:middle
但是你传递一个参数

00:08:34.881 --> 00:08:38.784 align:middle
声明你只想获得IPv4结果

00:08:40.354 --> 00:08:43.657 align:middle
这会导致你的APP仅支持IPv4

00:08:44.324 --> 00:08:48.896 align:middle
这意味着 你的APP将无法在
IPv6-only网络环境下运行

00:08:50.797 --> 00:08:53.567 align:middle
对于这些无法运行的APP

00:08:53.834 --> 00:08:56.203 align:middle
我们看到另外一件有意思的事情

00:08:57.771 --> 00:09:00.107 align:middle
有时候在尝试连接之前

00:08:57.771 --> 00:09:00.107 align:middle
有时候在尝试连接之前

00:09:00.207 --> 00:09:03.877 align:middle
APP会预先选择IPv4连接

00:09:05.045 --> 00:09:08.949 align:middle
因此有时候你会看到这样的错误信息

00:09:10.851 --> 00:09:14.621 align:middle
在这种情况下我的iPhone
确实连接到我的Mac设备上

00:09:14.688 --> 00:09:17.724 align:middle
创建的NAT64网络

00:09:18.492 --> 00:09:20.694 align:middle
我可以使用Safari
浏览互联网内容

00:09:20.761 --> 00:09:22.863 align:middle
我可以观看视频 听音乐...

00:09:23.664 --> 00:09:25.132 align:middle
我的Internet连接正常

00:09:25.666 --> 00:09:30.571 align:middle
但是出于一些原因APP认为我没有
Internet连接

00:09:31.371 --> 00:09:34.308 align:middle
你会看到提示信息

00:09:34.374 --> 00:09:36.410 align:middle
说你的设备处于飞行模式

00:09:37.344 --> 00:09:40.647 align:middle
但是顶部信息栏却不是这样显示的

00:09:42.382 --> 00:09:43.951 align:middle
那么这是为什么呢？

00:09:44.418 --> 00:09:47.254 align:middle
这是因为APP预先

00:09:47.321 --> 00:09:50.824 align:middle
设置成为IPv4连接

00:09:51.291 --> 00:09:54.428 align:middle
但是在IPv6-only访问网络中
例如NAT64网络

00:09:55.062 --> 00:09:57.364 align:middle
并没有IPv4连接

00:09:57.664 --> 00:10:01.168 align:middle
整个网络对你来说
完全是一个IPv6-only网络

00:09:57.664 --> 00:10:01.168 align:middle
整个网络对你来说
完全是一个IPv6-only网络

00:10:01.535 --> 00:10:05.272 align:middle
即使IPv4-only服务器
看上去像是IPv6-only服务器

00:10:05.672 --> 00:10:07.508 align:middle
因此如果选择这样的设置
将会发生失败

00:10:08.375 --> 00:10:11.044 align:middle
在这种情况下APP将会提示你重试

00:10:11.144 --> 00:10:13.881 align:middle
我进行重试但是仍然会
显示相同的错误信息

00:10:14.381 --> 00:10:16.617 align:middle
然后我再重试仍然显示相同的错误信息

00:10:17.251 --> 00:10:20.287 align:middle
这个信息不会消失因此
无法使用APP进行其他操作

00:10:21.221 --> 00:10:22.823 align:middle
对此有什么好方法吗？

00:10:24.391 --> 00:10:26.593 align:middle
应该尝试连接

00:10:27.961 --> 00:10:30.163 align:middle
如果能够连接成功当然是好了

00:10:30.464 --> 00:10:33.400 align:middle
如果不能应该巧妙地进行处理

00:10:34.968 --> 00:10:36.603 align:middle
第二个建议是

00:10:36.670 --> 00:10:40.474 align:middle
使用更高级别的网络框架
例如NSURLSession

00:10:41.041 --> 00:10:42.809 align:middle
或CFNetwork API

00:10:43.577 --> 00:10:50.450 align:middle
原因是像iPhone
和Mac等多址设备的

00:10:51.351 --> 00:10:54.454 align:middle
网络连接有一点复杂

00:10:55.989 --> 00:10:57.791 align:middle
比如iPhone
不仅有Wi-Fi接口

00:10:57.858 --> 00:10:59.393 align:middle
还有蜂窝网络接口

00:10:59.593 --> 00:11:02.029 align:middle
多于Mac设备可能有多个以太网接口

00:10:59.593 --> 00:11:02.029 align:middle
多于Mac设备可能有多个以太网接口

00:11:02.162 --> 00:11:04.731 align:middle
而且也有Wi-Fi接口

00:11:05.199 --> 00:11:07.467 align:middle
在特定的时间

00:11:07.568 --> 00:11:09.870 align:middle
所有这些接口可能有不同类型的连接

00:11:11.371 --> 00:11:16.009 align:middle
你需要考虑使用哪个接口
如何进行这种类型的连接

00:11:16.076 --> 00:11:18.312 align:middle
以连接到特定的目标

00:11:18.879 --> 00:11:22.082 align:middle
自已编写代码可能会费时费力

00:11:22.716 --> 00:11:25.552 align:middle
因此应该使用更高层次的网络框架

00:11:25.886 --> 00:11:29.289 align:middle
这会让你的APP代码更加简洁明了

00:11:31.291 --> 00:11:34.862 align:middle
如果出于某些原因
你不能使用更高层次的网络框架

00:11:35.462 --> 00:11:37.030 align:middle
而且你必须使用socket

00:11:37.965 --> 00:11:41.301 align:middle
我们建议你阅读RFC 4038

00:11:42.202 --> 00:11:45.772 align:middle
此RFC详细地介绍了如何在地址族

00:11:46.039 --> 00:11:47.908 align:middle
不可知的情况下编写APP

00:11:50.611 --> 00:11:54.248 align:middle
我们的最后建议是尽可能使用主机名

00:11:54.314 --> 00:11:57.117 align:middle
而不是直接使用IP地址

00:11:57.284 --> 00:11:58.852 align:middle
无论IPv4或IPv6

00:11:59.786 --> 00:12:02.222 align:middle
当你编写自己的专用协议

00:11:59.786 --> 00:12:02.222 align:middle
当你编写自己的专用协议

00:12:02.289 --> 00:12:04.491 align:middle
或者编写APP时

00:12:04.558 --> 00:12:08.161 align:middle
应确保不要直接使用IP地址

00:12:08.562 --> 00:12:09.730 align:middle
而应该优先使用主机名

00:12:10.364 --> 00:12:11.632 align:middle
其原因是

00:12:11.999 --> 00:12:14.368 align:middle
在NAT64/DNS64网络环境中

00:12:15.469 --> 00:12:17.871 align:middle
客户端设备首先会发出DNS查询请求

00:12:18.405 --> 00:12:20.440 align:middle
以获得IPv4服务器的IPv6地址

00:12:20.641 --> 00:12:22.943 align:middle
因此你必须使用主机名

00:12:23.243 --> 00:12:25.512 align:middle
如果你需要使用IPv4地址

00:12:26.113 --> 00:12:28.415 align:middle
客户端设备将不会进行DNS查询

00:12:28.916 --> 00:12:32.853 align:middle
DNS64网络将不会
为你合成IPv6地址

00:12:35.422 --> 00:12:37.758 align:middle
我们知道有时候可能

00:12:38.725 --> 00:12:45.499 align:middle
无法避免使用IPv4
例如使用Safari进行浏览时

00:12:46.200 --> 00:12:48.669 align:middle
你打开一个网页显示正常

00:12:49.269 --> 00:12:52.139 align:middle
但是在网页内可能有其他一些链接

00:12:53.841 --> 00:12:57.311 align:middle
这些链接可能具有嵌入的IPv4地址

00:12:59.179 --> 00:13:02.249 align:middle
在此之前在Safari浏览器中

00:12:59.179 --> 00:13:02.249 align:middle
在此之前在Safari浏览器中

00:13:02.316 --> 00:13:04.151 align:middle
如果你点击这样的链接
将不会打开网页

00:13:06.053 --> 00:13:10.791 align:middle
从iOS 9
和OS X 10.11开始

00:13:11.225 --> 00:13:13.393 align:middle
不仅Safari而且任何

00:13:13.493 --> 00:13:18.265 align:middle
NSURLSession或
CFNetwork API用户

00:13:18.632 --> 00:13:23.270 align:middle
将能够在NAT64/DNS64
网络中使用IPv4地址

00:13:24.605 --> 00:13:26.740 align:middle
其工作原理是当你使用主机名时

00:13:27.708 --> 00:13:31.111 align:middle
网络中的DNS64将会
为你合成IPv6 地址

00:13:32.546 --> 00:13:35.816 align:middle
但是当你直接使用IPv4地址

00:13:35.883 --> 00:13:38.118 align:middle
并且使用一个更高层次网络API时

00:13:39.019 --> 00:13:42.823 align:middle
操作系统将会发现网络行为

00:13:42.890 --> 00:13:45.425 align:middle
并确定它将如何为你

00:13:45.492 --> 00:13:47.694 align:middle
合成IPv6 地址
并在本地完成此工作

00:13:48.562 --> 00:13:51.565 align:middle
这也是你为什么应该使用更高层次

00:13:51.632 --> 00:13:52.999 align:middle
网络框架的另一个原因

00:13:53.634 --> 00:13:54.468 align:middle
因此应该这样做

00:13:56.670 --> 00:14:00.641 align:middle
希望你能够利用这些数据点

00:13:56.670 --> 00:14:00.641 align:middle
希望你能够利用这些数据点

00:14:01.275 --> 00:14:05.312 align:middle
和新工具找到并解决APP中的问题

00:14:07.748 --> 00:14:12.052 align:middle
我们希望你做的事情是
在本讲座结束之后

00:14:12.419 --> 00:14:14.821 align:middle
在你们的Mac设备上
安装seed build

00:14:15.222 --> 00:14:17.758 align:middle
开始创建自己的NAT64网络

00:14:18.392 --> 00:14:20.160 align:middle
然后使用它们测试你的APP

00:14:21.495 --> 00:14:24.798 align:middle
请记住这是APP应该遵守的一项要求

00:14:25.732 --> 00:14:28.235 align:middle
请将这个信息传达给

00:14:28.902 --> 00:14:31.638 align:middle
未参加本讲座的其他开发人员

00:14:31.705 --> 00:14:35.909 align:middle
并且把这个消息带回你的公司确保使用
NAT64网络测试你的APP

00:14:38.145 --> 00:14:43.016 align:middle
现在请斯图尔特·柴歇尔上台

00:14:43.083 --> 00:14:45.352 align:middle
为大家介绍其他的网络功能

00:14:45.752 --> 00:14:48.121 align:middle
你们可以使用这些功能
更快速地开发APP

00:14:48.455 --> 00:14:50.490 align:middle
并且提高APP的响应速度

00:14:51.358 --> 00:14:52.192 align:middle
有请斯图尔特

00:14:59.132 --> 00:14:59.967 align:middle
谢谢普拉巴卡尔

00:15:02.536 --> 00:15:07.074 align:middle
我们想要讨论
如何让APP加快运行速度

00:15:09.109 --> 00:15:10.544 align:middle
在过去的几十年里

00:15:10.611 --> 00:15:14.081 align:middle
我们看到网络吞吐量飞速增长

00:15:15.048 --> 00:15:18.986 align:middle
我还记得在以前
56k调制解调器就已经

00:15:19.052 --> 00:15:21.321 align:middle
属于尖端科技而现在

00:15:21.388 --> 00:15:24.691 align:middle
50Mb/s网速已经很常见

00:15:25.592 --> 00:15:27.761 align:middle
但是我们并没有感觉到网速成千倍提升

00:15:28.629 --> 00:15:32.132 align:middle
我们仍然需要花大量的时间来
等待网页打开

00:15:32.432 --> 00:15:33.267 align:middle
这是为什么呢？

00:15:34.701 --> 00:15:38.305 align:middle
这是因为我们的行业专注于

00:15:38.405 --> 00:15:40.107 align:middle
提升吞吐量

00:15:41.175 --> 00:15:44.978 align:middle
但是却忽略其他资源延迟

00:15:46.146 --> 00:15:48.148 align:middle
光速不会变得更快

00:15:48.916 --> 00:15:52.019 align:middle
对此我们无能为力但是我们可以

00:15:52.119 --> 00:15:55.355 align:middle
消除其它方面的延迟
现在我们应该致力于这些工作

00:15:56.190 --> 00:15:58.492 align:middle
这就是我今天要讨论的主题

00:15:59.560 --> 00:16:03.297 align:middle
我想要讨论四种类型的资源延迟

00:15:59.560 --> 00:16:03.297 align:middle
我想要讨论四种类型的资源延迟

00:16:03.897 --> 00:16:05.799 align:middle
当用户使用APP可能会遇到这些延迟

00:16:06.967 --> 00:16:09.770 align:middle
首先是当你遇到
信号较弱的WiFi连接

00:16:10.070 --> 00:16:12.940 align:middle
而且连接不成功时

00:16:13.307 --> 00:16:14.975 align:middle
会遇到的延迟

00:16:15.976 --> 00:16:19.780 align:middle
第二个是使用“显式拥塞通知”

00:16:19.847 --> 00:16:21.949 align:middle
即“Explicit Congestion
Notification”技术

00:16:22.015 --> 00:16:25.853 align:middle
和智能队列功能来减少网络延迟

00:16:27.020 --> 00:16:32.092 align:middle
TCP NOTSENT
Low-WaterMark选项

00:16:32.526 --> 00:16:35.429 align:middle
减少发送机器中的延迟

00:16:35.495 --> 00:16:36.964 align:middle
最后我们将了解

00:16:37.097 --> 00:16:39.900 align:middle
一种名为TCP Fast Open的
令人激动新的技术

00:16:40.734 --> 00:16:44.238 align:middle
我们先开始讨论如何进行
可靠的网络回退操作

00:16:45.405 --> 00:16:48.709 align:middle
我相信你们每个人都有这样的经历

00:16:49.076 --> 00:16:52.179 align:middle
下班之后离开办公室

00:16:52.579 --> 00:16:55.048 align:middle
走向你的汽车拿出手机

00:16:55.749 --> 00:17:01.421 align:middle
然后想要查看地图
天气预报和邮件等

00:16:55.749 --> 00:17:01.421 align:middle
然后想要查看地图
天气预报和邮件等

00:17:02.055 --> 00:17:06.859 align:middle
你盯着手机但是
没有载入任何内容你走向汽车

00:17:06.926 --> 00:17:09.195 align:middle
但是仍然没载入内容你感到烦躁不安

00:17:09.262 --> 00:17:11.164 align:middle
于是你进入“设置“关闭Wi-Fi

00:17:11.698 --> 00:17:13.834 align:middle
使用LTE数据连接网页瞬间打开了

00:17:15.068 --> 00:17:17.069 align:middle
然后你忘记打开Wi-FI

00:17:17.137 --> 00:17:20.207 align:middle
一周之后你收到巨额的数据流量账单
这可不是你想要的

00:17:20.374 --> 00:17:22.709 align:middle
对于用户体验来说这是糟糕的事情

00:17:23.911 --> 00:17:28.147 align:middle
现在我们要做的事情是

00:17:28.482 --> 00:17:30.150 align:middle
设置并行连接数字逻辑

00:17:31.018 --> 00:17:33.520 align:middle
这样如果你的iPhone
检测到它在使用Wi-Fi

00:17:34.821 --> 00:17:38.325 align:middle
但是却无法建立TCP连接

00:17:38.892 --> 00:17:44.598 align:middle
这时它会很快地通过蜂窝数据网络

00:17:44.665 --> 00:17:47.367 align:middle
发起第二个并行连接

00:17:47.434 --> 00:17:49.803 align:middle
但是它不会完全中止Wi-Fi连接

00:17:49.870 --> 00:17:51.371 align:middle
并不会放弃Wi-Fi连接

00:17:51.438 --> 00:17:53.373 align:middle
它会并行尝试Wi-Fi连接

00:17:53.907 --> 00:17:56.510 align:middle
如果连接成功

00:17:56.710 --> 00:17:58.111 align:middle
将会转到Wi-Fi连接

00:17:58.812 --> 00:18:02.349 align:middle
如果连接不成功
蜂窝网络连接将率先完成

00:17:58.812 --> 00:18:02.349 align:middle
如果连接不成功
蜂窝网络连接将率先完成

00:18:02.416 --> 00:18:05.752 align:middle
这样APP的网络连接延将

00:18:06.954 --> 00:18:10.190 align:middle
将会很短用户甚至不会发现

00:18:11.258 --> 00:18:13.460 align:middle
当然此功能仅用于

00:18:13.527 --> 00:18:15.462 align:middle
允许使用蜂窝网络的APP

00:18:15.963 --> 00:18:17.631 align:middle
如果用户进入设置

00:18:17.698 --> 00:18:20.901 align:middle
禁止APP连接数据网络
我们将不会进行这种回退

00:18:22.069 --> 00:18:25.172 align:middle
如果我们进行回退将
会隐藏Wi-Fi图标

00:18:25.606 --> 00:18:28.509 align:middle
让用户知道他们没有使用Wi-Fi

00:18:31.545 --> 00:18:32.946 align:middle
如果你使用更高层次的API

00:18:33.347 --> 00:18:36.650 align:middle
这并不会占用额外的资源

00:18:37.317 --> 00:18:40.921 align:middle
而且这并不会影响

00:18:40.988 --> 00:18:42.656 align:middle
用户获得良好的使用体验

00:18:44.024 --> 00:18:45.893 align:middle
你还需要做另外一件事情

00:18:46.827 --> 00:18:50.631 align:middle
也就是当你在蜂窝网络上运行时

00:18:52.099 --> 00:18:54.701 align:middle
无论你首先连接到蜂窝网络

00:18:54.768 --> 00:18:56.537 align:middle
还是回退到蜂窝网络

00:18:57.304 --> 00:19:01.041 align:middle
用户最后还可能会
回到Wi-Fi范围之内

00:18:57.304 --> 00:19:01.041 align:middle
用户最后还可能会
回到Wi-Fi范围之内

00:19:01.275 --> 00:19:04.044 align:middle
那时，你将会看到
“Better Route”通知

00:19:04.611 --> 00:19:06.680 align:middle
然后你可以决定应该怎么做

00:19:07.347 --> 00:19:11.418 align:middle
你可能想要断开数据连接
重新连接到Wi-Fi

00:19:12.486 --> 00:19:15.055 align:middle
或者如果你的邮件
发送进度已经达到99%

00:19:15.122 --> 00:19:17.357 align:middle
你可能想要完成发送

00:19:17.424 --> 00:19:19.626 align:middle
但是
“Better Route”通知

00:19:19.693 --> 00:19:21.161 align:middle
让你能够进行

00:19:21.461 --> 00:19:23.130 align:middle
智能化的决定

00:19:23.430 --> 00:19:26.333 align:middle
从而尽量减少数据流量费用

00:19:31.205 --> 00:19:33.574 align:middle
下一个主题是网络中的延迟

00:19:35.075 --> 00:19:39.546 align:middle
这是我在Apple TV
开发中遇到的问题

00:19:39.646 --> 00:19:43.383 align:middle
我们努力提高Apple TV的
响应速度

00:19:43.717 --> 00:19:45.686 align:middle
和理解延迟来源

00:19:46.420 --> 00:19:50.224 align:middle
我期望你们在座的每个人都听说过
“bufferbloat”即“缓存膨胀”

00:19:51.391 --> 00:19:54.728 align:middle
我做过一些实验并且想和你们分享

00:19:54.795 --> 00:19:56.129 align:middle
这些实验的结果

00:19:56.396 --> 00:20:02.302 align:middle
让你们理解对于我们的
所有APP和产品来说

00:19:56.396 --> 00:20:02.302 align:middle
让你们理解对于我们的
所有APP和产品来说

00:20:02.603 --> 00:20:04.438 align:middle
消除网络中的缓存膨胀问题是多么重要

00:20:05.706 --> 00:20:09.209 align:middle
我测试过一个10Mb下行速度

00:20:09.676 --> 00:20:14.481 align:middle
模拟网络环境，

00:20:14.548 --> 00:20:18.519 align:middle
这种网速对于观看视频来说已经足够了

00:20:18.585 --> 00:20:24.424 align:middle
我将显示使用代表性
网络设置所获得的结果

00:20:25.192 --> 00:20:28.061 align:middle
这是一种简单的先进先出队列

00:20:28.428 --> 00:20:30.597 align:middle
数据包被缓存直到队列变满

00:20:30.664 --> 00:20:34.067 align:middle
不能再容纳更多数据包
新到达的数据包将被丢弃

00:20:35.002 --> 00:20:38.405 align:middle
这是现今的家用网关的典型配置

00:20:39.173 --> 00:20:42.876 align:middle
我将介绍另外一种更智能的
队列处理方法和ECN机制并进行比较

00:20:44.545 --> 00:20:48.081 align:middle
我将介绍一些
使用tcptrace的方案

00:20:49.016 --> 00:20:52.486 align:middle
我期望你们
很多人都使用过tcptrace

00:20:52.819 --> 00:20:56.256 align:middle
如果你们没有使用过
我强烈建议你们访问

00:20:56.323 --> 00:20:58.892 align:middle
TCPtrace.org并下载它

00:20:59.793 --> 00:21:02.829 align:middle
如果你要编写网络代码

00:20:59.793 --> 00:21:02.829 align:middle
如果你要编写网络代码

00:21:03.363 --> 00:21:06.233 align:middle
而且不使用tcptrace
来查看你的数据包

00:21:06.567 --> 00:21:10.604 align:middle
你将没有办法弄清楚

00:21:10.904 --> 00:21:13.106 align:middle
运行机制或理解APP

00:21:13.340 --> 00:21:15.375 align:middle
和协议的性能特征

00:21:16.143 --> 00:21:19.780 align:middle
在我们编写APP时
应该注意内存使用情况

00:21:20.480 --> 00:21:24.184 align:middle
应该分析代码
弄清楚哪些代码占用CPU

00:21:24.618 --> 00:21:26.587 align:middle
然后优化代码

00:21:26.720 --> 00:21:29.756 align:middle
以提高CPU效率
并且延长电池使用时间

00:21:31.191 --> 00:21:36.230 align:middle
为此应该多关注CPU
和内存使用情况

00:21:36.763 --> 00:21:39.766 align:middle
但是也不能忽略网络部分

00:21:39.900 --> 00:21:43.604 align:middle
Tcptrace是一个工具
让你能够方便地

00:21:43.737 --> 00:21:46.106 align:middle
进行网络分析分析网络流量

00:21:48.141 --> 00:21:51.845 align:middle
这是一个流媒体视频的

00:21:52.112 --> 00:21:53.480 align:middle
前10秒的TCPtrace

00:21:53.947 --> 00:21:56.183 align:middle
如果你们一些人
以前没有见过tcptrace

00:21:56.250 --> 00:21:58.252 align:middle
让我来简要介绍一下

00:21:58.952 --> 00:22:01.755 align:middle
这些白色的短线条表示数据包

00:21:58.952 --> 00:22:01.755 align:middle
这些白色的短线条表示数据包

00:22:02.823 --> 00:22:08.929 align:middle
白色线条所处的位置
表示数据包被捕获的时间

00:22:10.364 --> 00:22:15.002 align:middle
白色线条的高度告诉我们

00:22:15.068 --> 00:22:18.305 align:middle
数据包有多少字节线条的垂直位置

00:22:18.372 --> 00:22:21.808 align:middle
告诉我们在整个逻辑TCP序列，
数字空间内的哪些位置

00:22:22.176 --> 00:22:25.946 align:middle
收到这些数据包

00:22:26.980 --> 00:22:30.450 align:middle
在这里我们可以看到
正在按顺序向外发送数据包流

00:22:30.951 --> 00:22:33.287 align:middle
其间隔为数毫秒

00:22:34.655 --> 00:22:37.357 align:middle
在返回数据时
我们看到接收端的应答消息

00:22:37.424 --> 00:22:39.159 align:middle
声称它已经收到数据

00:22:40.360 --> 00:22:44.031 align:middle
绿色线条表示累积应答线条

00:22:44.498 --> 00:22:48.802 align:middle
所有数据包括绿色线条
都得到接收端的确认

00:22:49.636 --> 00:22:53.774 align:middle
因此没有任何白色数据包
位于绿色线条之下

00:22:54.408 --> 00:22:55.542 align:middle
那将表示存在bug

00:22:56.343 --> 00:22:59.680 align:middle
我们看到没有白色数据包
位于绿色线条之下这说明一切正常

00:23:01.381 --> 00:23:04.585 align:middle
黄色线条表示接收窗口

00:23:05.285 --> 00:23:10.390 align:middle
当你打开TCP连接时
接收端将指示它分配多少内存

00:23:11.592 --> 00:23:17.898 align:middle
来接收你的数据
不应该超过这个分配给你的内存量限值

00:23:18.532 --> 00:23:22.035 align:middle
如果你看到白色数据包位于黄色线之上

00:23:22.336 --> 00:23:24.171 align:middle
表示存在bug我们没有看到这种情况

00:23:24.371 --> 00:23:25.205 align:middle
这说明一切正常

00:23:28.041 --> 00:23:30.911 align:middle
数据传输看起来

00:23:30.978 --> 00:23:33.413 align:middle
显示为一条直线

00:23:33.480 --> 00:23:37.084 align:middle
这条曲线的斜率是10Mb/s

00:23:37.818 --> 00:23:41.989 align:middle
这正是我们所期望的但是每隔几秒

00:23:42.089 --> 00:23:43.690 align:middle
我们看到这种情况

00:23:44.358 --> 00:23:48.562 align:middle
让我们来放大仔细观察

00:23:48.795 --> 00:23:50.330 align:middle
发生了什么

00:23:52.933 --> 00:23:56.203 align:middle
这些TCPtrace
图形提供丰富的信息

00:23:56.737 --> 00:23:59.640 align:middle
我可以花上一个小时的时间
来讲解这些幻灯片

00:23:59.973 --> 00:24:01.675 align:middle
但是我们并没有时间这样做

00:23:59.973 --> 00:24:01.675 align:middle
但是我们并没有时间这样做

00:24:02.042 --> 00:24:07.781 align:middle
我会讲解这个图形中的一些重要信息

00:24:09.283 --> 00:24:14.421 align:middle
首先白色数据包线看起来正在

00:24:15.455 --> 00:24:16.990 align:middle
偏离绿色应答线条

00:24:17.724 --> 00:24:20.861 align:middle
这意味着我们将数据发送到

00:24:20.928 --> 00:24:25.699 align:middle
网络的速度快于数据从另一侧被输出

00:24:25.799 --> 00:24:27.601 align:middle
和被应答的数据

00:24:28.068 --> 00:24:29.970 align:middle
如果数据被输入的速度

00:24:30.470 --> 00:24:31.872 align:middle
快于被输出的速度

00:24:33.540 --> 00:24:34.875 align:middle
情况就会变得不一样

00:24:35.409 --> 00:24:40.514 align:middle
数据将会进入缓存网络缓存中的

00:24:40.681 --> 00:24:44.618 align:middle
旧数据将会增大

00:24:45.252 --> 00:24:47.421 align:middle
由于缓存数据量增大

00:24:47.855 --> 00:24:51.692 align:middle
意味着数据包发送与

00:24:51.758 --> 00:24:54.461 align:middle
接收端应答之间的往返延迟增大

00:24:56.597 --> 00:24:58.298 align:middle
当缓存数据量达到一定程度时

00:24:58.599 --> 00:25:01.001 align:middle
网关将无法缓存更多数据

00:24:58.599 --> 00:25:01.001 align:middle
网关将无法缓存更多数据

00:25:01.301 --> 00:25:02.669 align:middle
将开始出现丢包现象

00:25:04.404 --> 00:25:08.141 align:middle
将会发生混乱而且是非常严重的混乱

00:25:08.442 --> 00:25:13.180 align:middle
因此数据包进入队列末尾的速度

00:25:13.247 --> 00:25:18.218 align:middle
将会快于数据包出列的速度
我们收到数据包但是会丢失它们

00:25:18.719 --> 00:25:20.120 align:middle
其他数据包也会被丢失

00:25:20.387 --> 00:25:22.923 align:middle
队列被清空一点
我们获得一个数据包接受它

00:25:23.490 --> 00:25:27.294 align:middle
在队列的末尾是一片混乱

00:25:27.361 --> 00:25:30.664 align:middle
它获得一个数据包就会丢失一个数据包

00:25:31.832 --> 00:25:33.233 align:middle
但是在队列前部

00:25:33.700 --> 00:25:38.005 align:middle
有200个数据包依次排列等待
它们需要有序地

00:25:38.071 --> 00:25:40.207 align:middle
经过10Mb瓶颈链路

00:25:40.340 --> 00:25:42.776 align:middle
不能有间隔不能发生问题

00:25:43.177 --> 00:25:45.946 align:middle
只有在整个队列的数据

00:25:46.380 --> 00:25:48.282 align:middle
发送完之后我们才会看到

00:25:48.348 --> 00:25:50.984 align:middle
反映在发送端选择性应答消息中的

00:25:51.785 --> 00:25:54.988 align:middle
接收端的数据包丢失情况

00:25:55.322 --> 00:25:56.623 align:middle
然后开始进行补包

00:25:57.057 --> 00:25:58.992 align:middle
因此这是严重的混乱现象

00:26:01.795 --> 00:26:04.231 align:middle
由于网络传输API的工作方式

00:26:04.865 --> 00:26:06.266 align:middle
数据必须依次传输

00:26:07.634 --> 00:26:10.771 align:middle
如果一个数据包丢挡住

00:26:10.838 --> 00:26:12.806 align:middle
其后抵达的所有数据包
在内核中将被延迟

00:26:13.040 --> 00:26:14.608 align:middle
直到间隙被填满

00:26:15.075 --> 00:26:17.911 align:middle
这是有道理的

00:26:18.145 --> 00:26:21.114 align:middle
很多人曾经建议使用无序传输方法

00:26:21.515 --> 00:26:24.284 align:middle
但是结果发现几乎所有APP都很难

00:26:24.351 --> 00:26:25.619 align:middle
使用无序数据

00:26:25.919 --> 00:26:29.890 align:middle
如果你要解码H.264视频

00:26:29.957 --> 00:26:33.193 align:middle
只获得数据帧而无法获得它们
所依赖的I-Frame将不会有意义

00:26:33.560 --> 00:26:38.866 align:middle
因此顺序数据传输确实是
APP所需的传输模式

00:26:40.767 --> 00:26:42.336 align:middle
顺序数据传输导致

00:26:42.803 --> 00:26:45.405 align:middle
我们看到这些长时间的空白期
在此期间没有数据传输

00:26:46.173 --> 00:26:49.543 align:middle
对于Apple TV
视频回放流程来说

00:26:50.043 --> 00:26:52.846 align:middle
这相当于一个无信号时间段

00:26:53.013 --> 00:26:54.181 align:middle
在此期间将接收不到数据

00:26:54.815 --> 00:26:58.085 align:middle
我们不想要视频卡住

00:26:58.819 --> 00:27:02.422 align:middle
因此所有流媒体视频
都需要一个回放缓冲区

00:26:58.819 --> 00:27:02.422 align:middle
因此所有流媒体视频
都需要一个回放缓冲区

00:27:03.457 --> 00:27:06.627 align:middle
较大的回放缓冲区意味着

00:27:06.727 --> 00:27:08.262 align:middle
当你观看流媒体视频时

00:27:08.595 --> 00:27:11.532 align:middle
你会看到不断旋转的图标提示正在缓冲

00:27:12.032 --> 00:27:14.134 align:middle
因为缓冲区还有填满

00:27:14.401 --> 00:27:19.239 align:middle
因此当长时间没有数据到达时
可能会始终显示这个图标

00:27:20.240 --> 00:27:23.277 align:middle
当丢失的数据包到达时
我们开始填满间隙

00:27:23.477 --> 00:27:24.745 align:middle
并且立即播放视频

00:27:26.580 --> 00:27:30.884 align:middle
这将会给网络接收线程带来额外的负担

00:27:31.518 --> 00:27:36.089 align:middle
它需要将CPU时间分配给
视频播放线程之外的其他线程

00:27:36.690 --> 00:27:40.327 align:middle
从而造成视频播放卡顿

00:27:40.427 --> 00:27:41.261 align:middle
这不是我们想要的

00:27:43.730 --> 00:27:48.735 align:middle
这种不均衡的网络数据传输
给Apple TV等设备

00:27:48.836 --> 00:27:51.471 align:middle
造成不佳的用户体验在我们努力降低

00:27:52.005 --> 00:27:54.741 align:middle
设备的成本时

00:27:55.542 --> 00:27:59.112 align:middle
这种长时间的数据空白期

00:27:59.346 --> 00:28:02.549 align:middle
相当于我们需要增大设备内存
来缓存更多数据

00:27:59.346 --> 00:28:02.549 align:middle
相当于我们需要增大设备内存
来缓存更多数据

00:28:03.217 --> 00:28:07.421 align:middle
并且推迟视频开始时间和降低用户体验

00:28:08.789 --> 00:28:12.993 align:middle
这种传输不均衡现象

00:28:13.060 --> 00:28:15.562 align:middle
还会导致设备需要更快的CPU

00:28:15.829 --> 00:28:16.930 align:middle
从而抬升设备价格

00:28:17.431 --> 00:28:24.304 align:middle
因此对于流媒体视频来说
这种不均衡的传输是十分有害的

00:28:25.672 --> 00:28:27.741 align:middle
一个有意思的事情是

00:28:28.175 --> 00:28:33.981 align:middle
如果你跟踪观察
黄色应答线条的斜率...

00:28:34.381 --> 00:28:37.117 align:middle
黄色窗口线和和绿色应答线条

00:28:37.651 --> 00:28:41.088 align:middle
你会发现如果不发生丢包在轨迹末端

00:28:41.288 --> 00:28:44.258 align:middle
线条会回到它们原本应该所在的位置

00:28:44.758 --> 00:28:47.494 align:middle
因为TCP协议能够高效率地

00:28:47.561 --> 00:28:51.164 align:middle
一次性填充需要重新传输的数据包

00:28:51.698 --> 00:28:54.735 align:middle
而不会传输其他不需要重新传输的数据

00:28:55.202 --> 00:28:56.937 align:middle
因此它将会返回原本应该所处的位置

00:28:57.905 --> 00:29:00.674 align:middle
如果使用Iperf测量网络速度

00:28:57.905 --> 00:29:00.674 align:middle
如果使用Iperf测量网络速度

00:29:00.741 --> 00:29:01.909 align:middle
并且查看测量值

00:29:02.509 --> 00:29:04.211 align:middle
你将会看到它显示为10Mb/s

00:29:04.545 --> 00:29:07.347 align:middle
你会说很好我的网络一切正常

00:29:08.415 --> 00:29:10.984 align:middle
但是如果你探究这些信息

00:29:11.051 --> 00:29:15.422 align:middle
分析具体的数据

00:29:15.622 --> 00:29:17.224 align:middle
你就会发现实际的网络情况

00:29:22.162 --> 00:29:25.799 align:middle
现在我们知道是什么原因

00:29:25.966 --> 00:29:27.935 align:middle
造成网络性能下降

00:29:28.669 --> 00:29:31.004 align:middle
我决定使用智能网络进行实验

00:29:31.572 --> 00:29:35.142 align:middle
对于这个实验我使用
一种名为CoDel的智能队列算法

00:29:35.209 --> 00:29:38.045 align:middle
它是Controlled
Delay的简称

00:29:39.313 --> 00:29:42.015 align:middle
其工作原理不是填充队列

00:29:42.082 --> 00:29:47.754 align:middle
直到队列溢出并丢失数据
相反它监测队列的状态

00:29:48.388 --> 00:29:51.925 align:middle
当队列快要变满时

00:29:51.992 --> 00:29:56.864 align:middle
将会把它视为一个拥塞信号

00:29:57.764 --> 00:29:59.199 align:middle
对于拥塞很多人认为

00:30:00.267 --> 00:30:03.370 align:middle
我说的是高峰时间出现的情况

00:30:03.437 --> 00:30:05.506 align:middle
实际上不是这样的

00:30:05.572 --> 00:30:09.109 align:middle
必须理解的是在网络数据传输中

00:30:09.610 --> 00:30:12.312 align:middle
拥塞始终存在

00:30:12.846 --> 00:30:14.515 align:middle
它是一种稳定的网络状态

00:30:14.581 --> 00:30:17.584 align:middle
TCP等传输协议的任务是

00:30:18.085 --> 00:30:20.821 align:middle
最大限度地利用网络

00:30:21.321 --> 00:30:23.857 align:middle
以确定网络的最大承载能力

00:30:24.324 --> 00:30:25.626 align:middle
并且最高效地利用网络

00:30:26.560 --> 00:30:28.295 align:middle
传输协议的工作原理是

00:30:28.362 --> 00:30:32.900 align:middle
它越来越快地传输数据

00:30:32.966 --> 00:30:35.502 align:middle
同时始终进行侦测
它尝试不断发送更多的数据

00:30:36.069 --> 00:30:39.573 align:middle
直到发生丢包这时它将
知道负载过大并开始削减流量

00:30:40.040 --> 00:30:42.609 align:middle
它始终进行这种尝试
以找到合适的传输速率

00:30:42.943 --> 00:30:44.478 align:middle
这意味着它始终在尝试

00:30:44.778 --> 00:30:47.381 align:middle
使网络进入拥塞状态

00:30:47.447 --> 00:30:51.618 align:middle
然后降低传输负载从而减少拥塞

00:30:52.452 --> 00:30:56.723 align:middle
CoDel的工作原理并不是
等待网络进入拥塞状态

00:30:57.391 --> 00:30:58.625 align:middle
然后发出拥塞信息

00:30:59.326 --> 00:31:04.298 align:middle
在发现第一个拥塞信号之后
它就会通知发送端

00:30:59.326 --> 00:31:04.298 align:middle
在发现第一个拥塞信号之后
它就会通知发送端

00:31:06.466 --> 00:31:09.403 align:middle
在这个实验中我做的另一事情

00:31:09.469 --> 00:31:12.105 align:middle
不是通过丢包来指示拥塞

00:31:12.172 --> 00:31:13.674 align:middle
这需要重新传输

00:31:14.274 --> 00:31:17.411 align:middle
相反我使用一种名为“显式拥塞通知”
即Explicit Congestion

00:31:17.878 --> 00:31:22.482 align:middle
Notification的新技术
智能队列算法不会丢弃数据包

00:31:22.850 --> 00:31:26.220 align:middle
它设置IP标头中的一个位
声明遇到拥塞

00:31:26.854 --> 00:31:29.923 align:middle
这个消息被传回给发送端
发送端作出响应

00:31:29.990 --> 00:31:33.894 align:middle
降低传输速度
而不会造成破坏性的丢包后果

00:31:37.831 --> 00:31:41.869 align:middle
这是使用CoDel和ECN的

00:31:42.069 --> 00:31:46.173 align:middle
数据传输示意图如果我放大

00:31:46.240 --> 00:31:50.511 align:middle
前面看过的相同部分
你可以看到非常明显的差别

00:31:51.111 --> 00:31:52.646 align:middle
在我进行这些实验时

00:31:52.946 --> 00:31:56.216 align:middle
我计划用一周的时间
来完成这些工作和收集数据

00:31:56.917 --> 00:31:59.419 align:middle
结果只用了两个小时就全部完成了

00:31:59.753 --> 00:32:03.590 align:middle
一个方案使用标准配置来执行
一个方案使用CoDel来执行

00:31:59.753 --> 00:32:03.590 align:middle
一个方案使用标准配置来执行
一个方案使用CoDel来执行

00:32:03.790 --> 00:32:06.693 align:middle
这是我的第一个实验

00:32:06.760 --> 00:32:11.498 align:middle
我预计需要调整参数重试并返回实验

00:32:12.165 --> 00:32:16.436 align:middle
但是没有发生这种情况 差别很明显

00:32:16.570 --> 00:32:18.405 align:middle
只需进行一次试验就够了

00:32:18.972 --> 00:32:20.274 align:middle
好像有人在鼓掌 谢谢

00:32:26.380 --> 00:32:28.882 align:middle
我们没有看到传输中断现象

00:32:28.949 --> 00:32:31.385 align:middle
也没有出现高峰拥塞

00:32:32.052 --> 00:32:35.389 align:middle
每次出现轻微的队列拥塞时

00:32:35.956 --> 00:32:37.991 align:middle
CoDel算法就会发出信号

00:32:38.058 --> 00:32:40.327 align:middle
要求降低传输速度

00:32:40.794 --> 00:32:44.531 align:middle
这个方案的CWR标记
的含义是“减少拥塞窗口期”

00:32:44.598 --> 00:32:47.201 align:middle
这是TCP的应答消息
意思是消息已经被接收和理解

00:32:47.267 --> 00:32:48.836 align:middle
我已经降低传输速率

00:32:49.636 --> 00:32:50.704 align:middle
这确实很不错

00:32:53.507 --> 00:32:56.076 align:middle
总的来说CoDel

00:32:56.143 --> 00:32:58.512 align:middle
和其他队列算法非常有效

00:32:58.846 --> 00:32:59.847 align:middle
ECN十分有效

00:33:00.614 --> 00:33:02.449 align:middle
将它们组合在一起将会功效倍增

00:33:05.519 --> 00:33:07.621 align:middle
那么如果这么有效
应该在哪里使用它们？

00:33:08.222 --> 00:33:11.758 align:middle
从历史来看对于传统的网络应用来说

00:33:11.825 --> 00:33:14.728 align:middle
例如文件传输和发送电子邮件等

00:33:14.795 --> 00:33:19.166 align:middle
丢包和重新传输并不会造成严重的问题

00:33:21.635 --> 00:33:24.905 align:middle
当你传输文件时原则上传输层将会

00:33:24.972 --> 00:33:28.242 align:middle
最后发送第一个数据包

00:33:28.308 --> 00:33:31.111 align:middle
而且最先发送最后一个数据包
其间的所有数据包

00:33:31.178 --> 00:33:33.580 align:middle
将会随机发送 在数据包全部到达之后

00:33:33.647 --> 00:33:37.317 align:middle
将会按照文件的正确顺序重新进行组装
这就是你需要关注的所有事情

00:33:38.519 --> 00:33:40.721 align:middle
但是当你观看流媒体视频时

00:33:41.255 --> 00:33:45.792 align:middle
你并不想先看到结尾最后看到开头

00:33:46.293 --> 00:33:47.494 align:middle
你希望按顺序观看

00:33:47.961 --> 00:33:51.565 align:middle
这时按顺序发送数据
就成为一个更紧迫的问题

00:33:52.032 --> 00:33:54.301 align:middle
现在我们通过
Internet传输流媒体视频

00:33:57.538 --> 00:33:59.773 align:middle
这里的一个特点是在以前的应用中

00:33:59.840 --> 00:34:03.110 align:middle
例如点击发送电子邮件等

00:33:59.840 --> 00:34:03.110 align:middle
例如点击发送电子邮件等

00:34:03.710 --> 00:34:06.246 align:middle
需要发送的数据量是预先确定的

00:34:07.114 --> 00:34:09.315 align:middle
而发送所需要的时间是可变的

00:34:10.250 --> 00:34:13.387 align:middle
基本上网络发送电子邮件

00:34:13.453 --> 00:34:16.389 align:middle
所需要的时间是越少越好

00:34:17.024 --> 00:34:19.193 align:middle
我们并没有邮件发送过快这样的说法

00:34:20.060 --> 00:34:23.130 align:middle
发送时间是可变的你希望它越快越好

00:34:23.463 --> 00:34:25.532 align:middle
现在的应用则有不同

00:34:26.833 --> 00:34:29.136 align:middle
比如你通过Internet

00:34:29.402 --> 00:34:31.103 align:middle
观看两个小时的电影

00:34:32.172 --> 00:34:35.542 align:middle
我们不应该半个小时
或八个小时内看完成

00:34:35.742 --> 00:34:37.210 align:middle
而必须是两个小时

00:34:38.045 --> 00:34:40.013 align:middle
现在我们的应用必须具有适应能力

00:34:40.080 --> 00:34:42.549 align:middle
时间是固定的但是必须调整

00:34:42.616 --> 00:34:45.118 align:middle
这段时间内发送的数据量

00:34:45.219 --> 00:34:47.020 align:middle
以适应网络状况

00:34:50.591 --> 00:34:51.592 align:middle
现在的情况是怎样的？

00:34:52.125 --> 00:34:55.161 align:middle
让人惊奇的是
Linux已经支持此功能

00:34:55.228 --> 00:34:59.433 align:middle
而且在世界性能最强的
一百万台Web服务器中

00:34:59.499 --> 00:35:01.502 align:middle
一半以上默认支持ECN

00:34:59.499 --> 00:35:01.502 align:middle
一半以上默认支持ECN

00:35:02.169 --> 00:35:04.505 align:middle
对于一项无人使用的技术来说

00:35:04.571 --> 00:35:06.240 align:middle
这种应用广泛性是惊人的

00:35:10.043 --> 00:35:14.748 align:middle
客户端并不请求ECN连接

00:35:14.815 --> 00:35:16.984 align:middle
它们不请求ECN在很大程度上

00:35:17.417 --> 00:35:20.721 align:middle
是因为Internet
不支持ECN标记

00:35:21.021 --> 00:35:24.691 align:middle
如果你启用这个选项

00:35:24.758 --> 00:35:27.661 align:middle
可能会带来暴露bug的风险
而且没有直接好处

00:35:29.630 --> 00:35:30.697 align:middle
那么路由器在做什么？

00:35:30.764 --> 00:35:33.600 align:middle
没有路由器进行标记

00:35:33.667 --> 00:35:36.737 align:middle
因为没有客户端请求它们
那么为什么要设计

00:35:36.803 --> 00:35:39.072 align:middle
这样具有风险而且无人使用的功能呢？

00:35:39.339 --> 00:35:43.310 align:middle
今天我高兴地宣布
Apple将首开先河

00:35:43.610 --> 00:35:44.745 align:middle
打破这个僵局

00:35:45.212 --> 00:35:50.250 align:middle
在所有的基本应用中默认情况下

00:35:50.617 --> 00:35:54.888 align:middle
所有应用的所有
TCP连接将支持ECN

00:36:01.895 --> 00:36:05.432 align:middle
我们将不会看到任何问题

00:36:05.933 --> 00:36:07.234 align:middle
在我们的测试中一切运行正常

00:36:07.701 --> 00:36:10.537 align:middle
我已经在我自己的
笔记本电脑上运行很长时间

00:36:11.672 --> 00:36:14.808 align:middle
当然我们希望倾听你们的体会

00:36:14.975 --> 00:36:19.379 align:middle
请接受这些基本应用在你的家庭网络

00:36:20.047 --> 00:36:22.816 align:middle
工作单位酒店和机场使用它们

00:36:23.350 --> 00:36:26.620 align:middle
和以前一样如果发现任何bug
请报告给Apple

00:36:27.421 --> 00:36:30.357 align:middle
如果我们取得成功几个月之后

00:36:30.424 --> 00:36:32.659 align:middle
将会有数百万设备运行ECN

00:36:33.527 --> 00:36:37.231 align:middle
这样ISP将有足够的动力
来提供这项服务

00:36:39.466 --> 00:36:43.036 align:middle
现在我们将主题从网络延迟

00:36:43.337 --> 00:36:45.339 align:middle
转移到终端系统延迟

00:36:46.306 --> 00:36:50.410 align:middle
许多技术进步的出发点是为了

00:36:50.477 --> 00:36:53.447 align:middle
克服我们自己遇到的不便之处
这里也同样如此

00:36:54.681 --> 00:36:59.319 align:middle
我使用屏幕共享功能
连接到我家里的Mac计算机

00:36:59.920 --> 00:37:01.221 align:middle
这种功能真不错

00:36:59.920 --> 00:37:01.221 align:middle
这种功能真不错

00:37:01.855 --> 00:37:05.359 align:middle
我能够远程控制计算机
能够访问计算机上的数据

00:37:06.026 --> 00:37:11.164 align:middle
能够开始费时的视频转码

00:37:11.231 --> 00:37:13.100 align:middle
在我到家时就已经完成转码

00:37:13.734 --> 00:37:14.935 align:middle
这些确实不错

00:37:16.003 --> 00:37:18.405 align:middle
在我进行这些实验时

00:37:19.907 --> 00:37:23.143 align:middle
我使用的是很慢的DSL线路

00:37:24.011 --> 00:37:27.247 align:middle
当然DSL是非对称的

00:37:27.648 --> 00:37:31.919 align:middle
一般来说下行速度比上行速度快十倍

00:37:32.753 --> 00:37:34.755 align:middle
当你进行屏幕共享时

00:37:35.189 --> 00:37:37.391 align:middle
数据传输方向是上行方向

00:37:37.558 --> 00:37:41.662 align:middle
因此速度会比较慢

00:37:42.563 --> 00:37:45.065 align:middle
这有一点像那个众人皆知的
关于熊跳舞的笑话

00:37:45.399 --> 00:37:47.334 align:middle
当你看到熊跳舞时

00:37:47.401 --> 00:37:49.203 align:middle
你不应该惊讶于熊跳舞跳得很好

00:37:49.303 --> 00:37:51.405 align:middle
而应该惊讶于熊会跳舞

00:37:52.172 --> 00:37:58.178 align:middle
多年人与很多人一样
我被这个让人难受的

00:37:58.245 --> 00:38:04.618 align:middle
勉强可用的功能所困扰
我发现当我点击一个菜单时

00:37:58.245 --> 00:38:04.618 align:middle
勉强可用的功能所困扰
我发现当我点击一个菜单时

00:38:04.685 --> 00:38:08.288 align:middle
要花费三到四秒的时间

00:38:08.355 --> 00:38:10.791 align:middle
菜单才会显示出来
这样使用计算机几分钟之后

00:38:10.858 --> 00:38:14.394 align:middle
让人感到非常不舒服

00:38:14.461 --> 00:38:16.430 align:middle
有时候恨不得快点开车回家

00:38:16.496 --> 00:38:17.764 align:middle
亲自在计算机上操作

00:38:19.800 --> 00:38:22.636 align:middle
我曾经研究过
“bufferbloat”

00:38:23.270 --> 00:38:25.606 align:middle
和网络中的过度队列

00:38:25.973 --> 00:38:30.644 align:middle
很自然地我首先感到不满

00:38:30.911 --> 00:38:32.412 align:middle
并且开始研究

00:38:32.713 --> 00:38:35.349 align:middle
我最初认为罪魁祸首

00:38:35.415 --> 00:38:37.851 align:middle
应该是这个愚蠢的DSL调制解调器

00:38:37.918 --> 00:38:39.520 align:middle
产生过度的缓存膨胀

00:38:40.153 --> 00:38:41.455 align:middle
于是我ping计算机

00:38:42.189 --> 00:38:44.391 align:middle
ping时间为35ms

00:38:45.292 --> 00:38:48.729 align:middle
当我点击鼠标时
却需要3秒才能显示鼠标

00:38:49.796 --> 00:38:52.866 align:middle
我意识到情况可能
与我当初设想的不一样

00:38:53.700 --> 00:38:55.169 align:middle
那么延迟来自于哪里呢？

00:38:56.003 --> 00:38:59.139 align:middle
对此我进行了一些研究

00:39:00.641 --> 00:39:04.211 align:middle
当时默认socket发送的
缓存数据是120KB

00:39:04.645 --> 00:39:08.248 align:middle
我的网速率大约是50KB/s

00:39:08.415 --> 00:39:10.250 align:middle
用时约为2.5秒

00:39:10.450 --> 00:39:12.119 align:middle
这与我看到的延迟时间差不多

00:39:14.054 --> 00:39:17.257 align:middle
发送缓冲数据的socket
具有十分重要的意义

00:39:18.492 --> 00:39:21.762 align:middle
当我们使用TCP等协议时

00:39:22.262 --> 00:39:25.666 align:middle
它会发送一个数据包等待应答

00:39:25.732 --> 00:39:27.801 align:middle
然后再发送一个数据包再等待应答

00:39:28.135 --> 00:39:29.503 align:middle
这样的性能十分低下

00:39:29.903 --> 00:39:32.906 align:middle
我们需要一次发送多个数据包
我们需要足够多的数据包

00:39:32.973 --> 00:39:37.110 align:middle
以充分利目的地往返传输路径的带宽

00:39:37.778 --> 00:39:40.881 align:middle
而且必须缓存这些数据包

00:39:40.948 --> 00:39:44.585 align:middle
这样当它们丢失时可以重新进行传输。

00:39:45.085 --> 00:39:47.254 align:middle
最大限度利用连接吐吞率

00:39:47.588 --> 00:39:50.290 align:middle
是一个很好有用而且必要的方法

00:39:51.091 --> 00:39:53.460 align:middle
但于超过需求的缓存

00:39:53.527 --> 00:39:57.865 align:middle
仅仅会增加延迟而不会带来好处

00:39:58.065 --> 00:39:59.366 align:middle
它不会帮助提高吞吐率

00:39:59.867 --> 00:40:00.767 align:middle
而只会增大延迟

00:39:59.867 --> 00:40:00.767 align:middle
而只会增大延迟

00:40:01.635 --> 00:40:04.371 align:middle
最终我们只会得到这样的结果

00:40:05.205 --> 00:40:08.742 align:middle
我们一次仅传输少量的数据
而且这些数据进入缓存

00:40:08.976 --> 00:40:10.544 align:middle
以备在需要时重新传输

00:40:11.211 --> 00:40:15.816 align:middle
而另一方面有大量的数据
在内核中等待被发送出去

00:40:20.287 --> 00:40:22.356 align:middle
这让我明白

00:40:23.824 --> 00:40:27.761 align:middle
不仅网络上存在延迟
而且主机之中存大量延迟

00:40:29.796 --> 00:40:33.066 align:middle
屏幕共享程序会抓取
一个画面帧将它送入缓存

00:40:33.267 --> 00:40:36.370 align:middle
再抓取一个画面帧将它送入缓存
内核将会让这些帧

00:40:36.770 --> 00:40:43.410 align:middle
像葡萄酒那样长时间陈酿然后才会在
特定时间将它们通过网络发送出去

00:40:45.679 --> 00:40:51.185 align:middle
为此我们引入了
TCP_NOTSENT-LOWAT

00:40:51.251 --> 00:40:52.286 align:middle
套接字选项

00:40:53.120 --> 00:40:54.488 align:middle
发送这个选项时

00:40:55.622 --> 00:40:58.625 align:middle
Socket_Send_Buffer
保持不变

00:40:59.693 --> 00:41:02.763 align:middle
区别在于kevent

00:40:59.693 --> 00:41:02.763 align:middle
区别在于kevent

00:41:03.330 --> 00:41:07.768 align:middle
或你的run loop不会报告
Socket正在被写入

00:41:08.135 --> 00:41:10.637 align:middle
直到未发送的数据量

00:41:10.804 --> 00:41:13.040 align:middle
达到很低的阀值

00:41:13.106 --> 00:41:14.808 align:middle
通常为8或16KB

00:41:15.809 --> 00:41:17.477 align:middle
当socket转为可写入状态时

00:41:18.045 --> 00:41:23.217 align:middle
你可以将单个有用的
基本数据块写入缓存

00:41:23.951 --> 00:41:27.621 align:middle
不需要循环操作中
内核中也不会积累过多的数据

00:41:27.688 --> 00:41:30.490 align:middle
因为现在内存已经很便宜
它可以容纳大量的数据

00:41:31.525 --> 00:41:33.360 align:middle
你只需写入一个感应单元

00:41:33.627 --> 00:41:36.363 align:middle
在屏幕共享程序中它是一个帧

00:41:37.231 --> 00:41:38.932 align:middle
现在的情况是这样的

00:41:40.033 --> 00:41:42.102 align:middle
有数据在等待发送它们位于缓存中

00:41:42.436 --> 00:41:44.671 align:middle
需要等待较短的时间让它们发送出去

00:41:45.739 --> 00:41:48.208 align:middle
在发送完毕之后中达到阀值

00:41:49.142 --> 00:41:50.444 align:middle
Socket转为可写入状态

00:41:51.178 --> 00:41:52.479 align:middle
我们写入一个数据块

00:41:52.846 --> 00:41:54.781 align:middle
在它发送完毕之后再写入更多数据块

00:41:55.482 --> 00:41:58.285 align:middle
现在我为你们演示这个过程

00:42:07.094 --> 00:42:08.495 align:middle
在这里我将要在这台计算机上

00:42:08.862 --> 00:42:11.498 align:middle
使用屏幕共享程序连接到这台计算机

00:42:12.432 --> 00:42:15.736 align:middle
我将使用一个运行
sarawert[猜测写法]的网关

00:42:15.903 --> 00:42:18.372 align:middle
来模拟DSL连接

00:42:20.307 --> 00:42:25.312 align:middle
让我们调出终端窗口

00:42:32.252 --> 00:42:33.086 align:middle
看到了

00:42:34.988 --> 00:42:36.657 align:middle
我将移动这个窗口

00:42:37.791 --> 00:42:40.694 align:middle
你可以看到鼠标指针在移动

00:42:40.961 --> 00:42:42.429 align:middle
因为它是本地生成的

00:42:42.829 --> 00:42:45.766 align:middle
实际的图形更新是由远程计算机生成的

00:42:46.200 --> 00:42:48.702 align:middle
让我们窗口移动这里

00:42:48.936 --> 00:42:50.237 align:middle
不 不是这里

00:42:50.304 --> 00:42:53.240 align:middle
让我们移动它 不
我想让它回到原来的地方

00:42:53.307 --> 00:42:54.308 align:middle
双手离开键盘

00:43:02.182 --> 00:43:04.451 align:middle
让我们调出菜单：Shell

00:43:09.122 --> 00:43:11.191 align:middle
它出现了
让我们打开“Edit”

00:43:11.425 --> 00:43:12.659 align:middle
或者“View”

00:43:18.565 --> 00:43:21.568 align:middle
这个演示让人感觉很着急

00:43:21.802 --> 00:43:24.905 align:middle
看起来远程使用我的计算机
是非常费劲的事情

00:43:25.439 --> 00:43:28.842 align:middle
这需要很好的耐心

00:43:31.078 --> 00:43:35.282 align:middle
现在我一个新的方法

00:43:36.383 --> 00:43:41.188 align:middle
我启用
TCP_NOTSENT-LOWAT选项

00:43:49.296 --> 00:43:52.432 align:middle
然后重新进行连接
我可以随意拖动这个窗口

00:44:05.445 --> 00:44:06.280 align:middle
谢谢

00:44:06.446 --> 00:44:13.387 align:middle
多年来 在BSD网络应用中

00:44:13.453 --> 00:44:18.959 align:middle
我们一直忍受着这种极其
糟糕的屏幕共享连接

00:44:20.093 --> 00:44:26.400 align:middle
好消息是我们已经解决这个问题

00:44:27.234 --> 00:44:28.836 align:middle
现在此技术已经在

00:44:33.707 --> 00:44:39.680 align:middle
10.10.3最新版本中得到应用

00:44:39.746 --> 00:44:42.115 align:middle
如果发现屏幕共享得到越来越多的运用

00:44:42.649 --> 00:44:44.451 align:middle
背后的原因就在这里

00:44:44.985 --> 00:44:49.590 align:middle
此技术已经被AirPlay使用
而且也可以在Linux中使用

00:44:50.157 --> 00:44:54.161 align:middle
因为此选项应用于发送端数据源

00:44:54.628 --> 00:44:57.364 align:middle
因此如果你运行Linux服务器

00:44:57.698 --> 00:44:59.800 align:middle
此选项也可以用于你的服务器

00:45:03.170 --> 00:45:08.242 align:middle
对于实时应用来说
这种降低延迟的好处很明显的

00:45:09.843 --> 00:45:13.881 align:middle
在制作本讲座的幻灯片时

00:45:14.014 --> 00:45:15.048 align:middle
我将APP分为两类

00:45:15.115 --> 00:45:18.352 align:middle
一类APP应该使用
tcp_notsent-lowat选项

00:45:18.418 --> 00:45:19.586 align:middle
另一类APP不应该使用

00:45:20.287 --> 00:45:23.590 align:middle
但是我想不出任何APP
应归入不应该使用此选项的类别

00:45:24.391 --> 00:45:28.595 align:middle
每次我们想到哪些传统应用
可能不需要使用此选项例如文件传输

00:45:29.129 --> 00:45:31.899 align:middle
我们发现你们曾经有这样的经历

00:45:31.965 --> 00:45:33.767 align:middle
你想要取消文件传输

00:45:33.834 --> 00:45:37.104 align:middle
你按下Control-C
但是需要大约30秒的时间才能取消

00:45:37.971 --> 00:45:40.507 align:middle
这是因为程序将所有数据

00:45:40.574 --> 00:45:42.609 align:middle
过量载入内核而必须等待数据被清空

00:45:43.010 --> 00:45:44.511 align:middle
因为并没有方法来改变此操作

00:45:45.012 --> 00:45:48.148 align:middle
事实上文件传输

00:45:48.215 --> 00:45:51.885 align:middle
并不会受益于过量载入数据

00:45:51.952 --> 00:45:53.820 align:middle
我们想不出会任何APP

00:45:53.887 --> 00:45:55.622 align:middle
会受益内核中的过量数据堆积

00:45:55.956 --> 00:45:59.993 align:middle
在认识到这种情况之后

00:46:00.460 --> 00:46:04.698 align:middle
我们决定在下一个版本中

00:46:05.566 --> 00:46:09.670 align:middle
使用更高层次的SURLSession
和CFNetwork API

00:46:09.736 --> 00:46:11.538 align:middle
自动为所有连接启用此选项

00:46:12.806 --> 00:46:15.242 align:middle
为了最有效地利它需要做的事情是

00:46:15.642 --> 00:46:20.581 align:middle
当socket变为可写入状态时
在看到EWOULDBLOCK错误码之前

00:46:20.647 --> 00:46:22.950 align:middle
不要循环写入大量的数据

00:46:23.450 --> 00:46:25.552 align:middle
只需要写入合适大小的数据块

00:46:26.253 --> 00:46:28.422 align:middle
然后等待被告知可以写入更多数据块

00:46:28.822 --> 00:46:31.558 align:middle
这样如果用户改变主意

00:46:31.625 --> 00:46:33.794 align:middle
或者网络环境发生变化

00:46:33.994 --> 00:46:36.930 align:middle
下次socket变为可写入状态时

00:46:37.264 --> 00:46:39.466 align:middle
你可以做出明智的决定

00:46:40.467 --> 00:46:42.870 align:middle
你可以即进生成数据

00:46:43.203 --> 00:46:48.642 align:middle
根据当前的信息
而不是5或10秒前的信息

00:46:49.042 --> 00:46:51.912 align:middle
生成最新的数据

00:46:53.814 --> 00:46:58.418 align:middle
现在进入本讲座的最后一部分

00:46:59.319 --> 00:47:01.421 align:middle
让我们来窥探

00:46:59.319 --> 00:47:01.421 align:middle
让我们来窥探

00:47:02.089 --> 00:47:05.759 align:middle
一项名为TCP Fast Open的
全新技术

00:47:07.528 --> 00:47:14.501 align:middle
传统TCP工作原理是这样的
我们通过发送消息和获得应答

00:47:15.068 --> 00:47:16.503 align:middle
设置TCP连接

00:47:17.371 --> 00:47:18.972 align:middle
然后我们第二次发送消息和获得应答

00:47:19.406 --> 00:47:21.675 align:middle
以发送请求和获得响应

00:47:22.776 --> 00:47:26.947 align:middle
TCP Fast Open
将连接设置

00:47:27.014 --> 00:47:30.050 align:middle
与数据交换合并成为一个数据包交换

00:47:31.218 --> 00:47:34.454 align:middle
所有APP并不会默认启用此选项

00:47:34.555 --> 00:47:35.756 align:middle
而这是有原因的

00:47:37.624 --> 00:47:39.593 align:middle
你需要注意这个警告信息

00:47:40.027 --> 00:47:43.497 align:middle
提示说此功能仅对
幂等数据来说是安全的

00:47:43.797 --> 00:47:45.032 align:middle
我将解释这其中的含义

00:47:47.901 --> 00:47:50.070 align:middle
当你使用TFO操作时
握手与数据组合在一起

00:47:51.939 --> 00:47:57.945 align:middle
服务器将收到消息服务器
作出反应发送响应信息

00:47:58.345 --> 00:47:59.580 align:middle
然后你关闭连接

00:48:00.681 --> 00:48:05.552 align:middle
Internet的工作模式并不保证

00:48:05.919 --> 00:48:08.522 align:middle
不会重复发送数据包

00:48:09.356 --> 00:48:11.258 align:middle
Internet的成功得益于

00:48:12.092 --> 00:48:14.461 align:middle
其非常简单的工作模式

00:48:14.728 --> 00:48:18.365 align:middle
即快速低成本地发送数据包

00:48:19.132 --> 00:48:21.502 align:middle
你不需要考虑数据包的发送顺序

00:48:21.935 --> 00:48:24.304 align:middle
不需要担心数据包是否损坏或丢失

00:48:24.371 --> 00:48:26.907 align:middle
或者重复发送数据包
只需实现快速和低成本就可以了

00:48:27.774 --> 00:48:31.879 align:middle
终端系统非常智能化
能够适应这种网络模型

00:48:33.447 --> 00:48:35.549 align:middle
重复发送数据包的原因是多少方面的

00:48:35.616 --> 00:48:37.451 align:middle
可能是因为路由器有bug

00:48:37.985 --> 00:48:40.721 align:middle
也可能是因为Wi-Fi链路层

00:48:41.622 --> 00:48:43.891 align:middle
意外地发送数据包两次

00:48:44.291 --> 00:48:46.693 align:middle
终端系统可能重复发送：

00:48:46.760 --> 00:48:50.397 align:middle
如果你发送数据包

00:48:50.964 --> 00:48:52.900 align:middle
但是应答消息丢失

00:48:53.300 --> 00:48:54.801 align:middle
你将需要重新发送数据包

00:48:55.302 --> 00:48:58.272 align:middle
这样网络中就会出现两个相同的数据包

00:48:58.772 --> 00:49:02.943 align:middle
如果其中一个数据包发生延迟
并且在很久以后出现

00:48:58.772 --> 00:49:02.943 align:middle
如果其中一个数据包发生延迟
并且在很久以后出现

00:49:03.710 --> 00:49:06.380 align:middle
对于服务器来说

00:49:06.446 --> 00:49:09.750 align:middle
这是一个完全有效的TFO请求

00:49:10.150 --> 00:49:12.786 align:middle
无论操作是什么都会再次执行此操作

00:49:13.654 --> 00:49:16.990 align:middle
如果操作是向你发送一幅JPEG图片

00:49:17.324 --> 00:49:19.259 align:middle
进行两次这样的操作
并不会带来严重的后果

00:49:20.060 --> 00:49:23.730 align:middle
但是如果操作是
发送一双Zappos鞋子

00:49:24.164 --> 00:49:25.999 align:middle
两次进行这样的操作可不是你想的

00:49:26.466 --> 00:49:31.205 align:middle
对于这种情况你必须做出明智的决定

00:49:31.305 --> 00:49:32.739 align:middle
哪些操作是合适和安全的

00:49:33.073 --> 00:49:35.409 align:middle
哪些对你的APP来说不合适

00:49:37.377 --> 00:49:41.415 align:middle
你可以通过connectx
系统调用来这样做

00:49:42.349 --> 00:49:48.088 align:middle
这是早期适配器的简要技术预览

00:49:49.122 --> 00:49:52.759 align:middle
让我们来看如何通过更高层API
来展示这个技术

00:49:52.826 --> 00:49:55.629 align:middle
但是目前还不能
使用connectx来实现

00:49:56.463 --> 00:49:59.666 align:middle
与你进行对话的服务器必须支持TFO

00:49:59.733 --> 00:50:01.335 align:middle
APP必须选择加入对话

00:49:59.733 --> 00:50:01.335 align:middle
APP必须选择加入对话

00:50:03.270 --> 00:50:06.507 align:middle
如果你运行Linux服务器
你必须具有几个星期以前

00:50:06.573 --> 00:50:09.676 align:middle
发布的最新Linux内核

00:50:10.110 --> 00:50:15.582 align:middle
此内核支持标准ITF、TFO、

00:50:16.116 --> 00:50:18.685 align:middle
TCP选项代码
OS X操作系统也同样如此

00:50:22.055 --> 00:50:25.125 align:middle
最后作为总结我希望你们
记住今天讲座的要点

00:50:27.694 --> 00:50:28.595 align:middle
即 你应该尽可能地

00:50:29.263 --> 00:50:32.366 align:middle
使用最高层次的网络API

00:50:32.900 --> 00:50:38.005 align:middle
这样你将能够获得
这些API所能提供的全部功能

00:50:39.573 --> 00:50:44.578 align:middle
你绝对必须在NAT64网络上
测试你的APP

00:50:45.212 --> 00:50:48.348 align:middle
幸运的是我们进行了大量的简化工作

00:50:48.482 --> 00:50:50.484 align:middle
你只需要点击“选项”就可以了

00:50:52.586 --> 00:50:59.293 align:middle
可靠的网络回退机制
能够让你的APP提供更好的用户体验

00:51:00.527 --> 00:51:04.231 align:middle
你需要做的是注意
“Better Route”通知

00:51:04.498 --> 00:51:07.201 align:middle
这样当Wi-Fi重新可用时
你可以返回到Wi-Fi连接

00:51:09.169 --> 00:51:13.106 align:middle
“显式拥塞通知”
是一项新的基本功能

00:51:14.474 --> 00:51:19.746 align:middle
它通过降低队列等待和减少丢包

00:51:20.314 --> 00:51:24.751 align:middle
大幅提高网络数据传输的响应速度

00:51:25.419 --> 00:51:28.121 align:middle
我希望你们测试这些功能
并且报告任何问题

00:51:29.489 --> 00:51:31.425 align:middle
利用
CPNOTSENT-LOWAT选项

00:51:31.859 --> 00:51:34.528 align:middle
你可以为自己设置一个
socket选项

00:51:35.229 --> 00:51:37.564 align:middle
在下一个版本中你将可以免费使用它

00:51:38.398 --> 00:51:41.735 align:middle
从而大幅减少发送机中
缓存的迟滞数据量

00:51:43.003 --> 00:51:46.707 align:middle
最后对于喜欢
TCP Fast Open的开发者

00:51:46.773 --> 00:51:48.075 align:middle
我们已经提供此功能

00:51:49.910 --> 00:51:53.013 align:middle
有很多不错的文档资源可供你查看

00:51:53.614 --> 00:51:55.782 align:middle
你们并不需要记下这些URL

00:51:55.849 --> 00:51:57.818 align:middle
可以点击PDF文档中的链接

00:51:59.052 --> 00:52:04.191 align:middle
还有一些不错的论坛
你可以提问并且讨论

00:51:59.052 --> 00:52:04.191 align:middle
还有一些不错的论坛
你可以提问并且讨论

00:52:04.658 --> 00:52:06.593 align:middle
与网络应用相关的问题

00:52:09.596 --> 00:52:11.598 align:middle
我鼓励你们观看

00:52:12.232 --> 00:52:14.968 align:middle
NSURLSession讲座

00:52:15.335 --> 00:52:19.640 align:middle
和Network
Extensions讲座

00:52:20.340 --> 00:52:23.610 align:middle
在网络实验室午餐休息之后
也可以与我们讨论

00:52:23.777 --> 00:52:25.279 align:middle
我们将会回答你的所有问题

00:52:26.079 --> 00:52:26.914 align:middle
谢谢
