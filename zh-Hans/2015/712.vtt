WEBVTT

00:00:20.521 --> 00:00:25.259 align:middle
低能耗，高性能：压缩和加速框架

00:00:27.394 --> 00:00:28.228 align:middle
早上好

00:00:33.233 --> 00:00:35.702 align:middle
欢迎来到矢量数字组讲座

00:00:36.770 --> 00:00:40.407 align:middle
我叫埃里克·比安维尔
现在就职于矢量数字组

00:00:42.476 --> 00:00:47.948 align:middle
我们组提供大家都知道的加速框架

00:00:48.415 --> 00:00:51.718 align:middle
还在系统里的一些库

00:00:53.387 --> 00:00:58.425 align:middle
在加速框架中你会发现图像

00:01:00.127 --> 00:01:03.497 align:middle
是图像操作的数百种

00:01:04.164 --> 00:01:06.867 align:middle
功能集合

00:01:07.801 --> 00:01:10.070 align:middle
你还会看到加速内部的vDSP是用于

00:01:11.071 --> 00:01:17.110 align:middle
信号处理和三层线性代数库

00:01:19.012 --> 00:01:24.418 align:middle
在加速框架以外
我们还维护Math library

00:01:25.085 --> 00:01:27.955 align:middle
LibM和字符串函数

00:01:28.655 --> 00:01:33.093 align:middle
去年 我们引入了SIMD这是一系列

00:01:33.160 --> 00:01:37.364 align:middle
头文件和函数可提供矢量类型

00:01:37.431 --> 00:01:42.703 align:middle
可以向SSC和AVX附近的
CPU矢量单元直接映射

00:01:43.704 --> 00:01:47.808 align:middle
今天 我们要介绍这些函数的三种补充

00:01:48.842 --> 00:01:54.114 align:middle
首先是压缩这是数据压缩库

00:01:54.882 --> 00:01:58.085 align:middle
然后史蒂夫会
介绍SIMD库的补充内容

00:01:59.152 --> 00:02:01.288 align:middle
最后卢克会讲稀疏BLAS的内容

00:01:59.152 --> 00:02:01.288 align:middle
最后卢克会讲稀疏BLAS的内容

00:02:02.189 --> 00:02:04.191 align:middle
稀疏矩阵的线性代数

00:02:05.392 --> 00:02:07.127 align:middle
我们先来看压缩

00:02:08.628 --> 00:02:09.463 align:middle
压缩是什么?

00:02:10.597 --> 00:02:14.668 align:middle
压缩是个新库它可提供统一

00:02:14.768 --> 00:02:17.771 align:middle
和简单的API进行无损数据压缩

00:02:18.438 --> 00:02:20.741 align:middle
在app中想要使用压缩时

00:02:21.508 --> 00:02:24.011 align:middle
为什么会需要这样的东西呢

00:02:24.912 --> 00:02:27.080 align:middle
首先需要找到

00:02:29.249 --> 00:02:32.152 align:middle
压缩读取手册编写代码进行测试

00:02:33.220 --> 00:02:38.025 align:middle
如果不工作就需要另选一个再编写代码

00:02:38.492 --> 00:02:39.459 align:middle
这会非常麻烦

00:02:39.960 --> 00:02:44.264 align:middle
有时 甚至会在你的app中

00:02:44.331 --> 00:02:46.800 align:middle
还包括压缩曲线这对于

00:02:47.167 --> 00:02:49.002 align:middle
维护来说就是噩梦

00:02:49.636 --> 00:02:51.338 align:middle
因此要为常见的压缩算法

00:02:51.405 --> 00:02:55.642 align:middle
和统一的API提供包装

00:02:56.910 --> 00:02:59.713 align:middle
以及诸如优化代码

00:03:00.581 --> 00:03:03.116 align:middle
和算法间的轻松转换类好处

00:03:03.617 --> 00:03:06.320 align:middle
我们先从放入其中的算法开始

00:03:07.688 --> 00:03:12.259 align:middle
当我们谈到压缩算法时
需要考虑两个矩阵

00:03:12.926 --> 00:03:15.462 align:middle
第一个显然是压缩比率

00:03:15.896 --> 00:03:18.332 align:middle
这是原始数据大小和压缩有效

00:03:18.866 --> 00:03:21.001 align:middle
载荷大小之间的比率

00:03:21.802 --> 00:03:26.273 align:middle
我们感兴趣的是编码速度和解码速度

00:03:27.307 --> 00:03:32.379 align:middle
为选择算法他们将其放在同一图形中

00:03:34.081 --> 00:03:37.084 align:middle
在这张图中X轴上显示的是压缩比率

00:03:38.151 --> 00:03:40.787 align:middle
在Y轴上则是编码速度

00:03:40.854 --> 00:03:46.727 align:middle
在中间是参考参考压缩器

00:03:46.894 --> 00:03:49.596 align:middle
所有的算法都要与这个参考进行比较

00:03:51.131 --> 00:03:53.233 align:middle
如果你是在右侧压缩效果较好

00:03:53.367 --> 00:03:56.770 align:middle
如果是在顶部压缩速度较快 就是这样

00:03:57.004 --> 00:03:59.072 align:middle
我们放入一些算法

00:04:00.140 --> 00:04:02.209 align:middle
中间的是zlib

00:04:02.309 --> 00:04:04.444 align:middle
这是最常用的

00:04:05.312 --> 00:04:06.613 align:middle
那我们做了什么呢？

00:04:06.680 --> 00:04:12.119 align:middle
我们选择最好的压缩对就是LZMA

00:04:14.655 --> 00:04:16.423 align:middle
和最快的LZ4

00:04:18.524 --> 00:04:25.065 align:middle
你会看到灰线表明压缩得
越多难度就会越大

00:04:25.732 --> 00:04:27.901 align:middle
压缩更多 意味着

00:04:28.101 --> 00:04:32.639 align:middle
速度越慢压缩越少
则速度越快呈指数关系

00:04:33.574 --> 00:04:36.610 align:middle
正如仔细来看这就是在zlib之上

00:04:37.878 --> 00:04:42.082 align:middle
的第一个点
也就是速度更快 稍靠右侧一点

00:04:42.149 --> 00:04:44.918 align:middle
这是说压缩得更好这就是LZFSE

00:04:45.385 --> 00:04:47.654 align:middle
我们今天要介绍的新压缩器

00:04:49.423 --> 00:04:54.394 align:middle
是对zlib的很好替代
我稍后会谈到这点

00:04:55.629 --> 00:05:00.234 align:middle
在压缩库中我们放了4个压缩器

00:04:55.629 --> 00:05:00.234 align:middle
在压缩库中我们放了4个压缩器

00:05:01.401 --> 00:05:05.606 align:middle
解码是这个样子看似是同样内容

00:05:05.706 --> 00:05:09.810 align:middle
如果压缩得越多也就
需要更多的解压时间

00:05:11.144 --> 00:05:15.349 align:middle
我们的4个压缩器都在同样的位置

00:05:16.049 --> 00:05:20.320 align:middle
这些是我们选择放入压缩库的4个算法

00:05:21.154 --> 00:05:25.192 align:middle
LZMA用于高压缩但它位置却很低

00:05:25.792 --> 00:05:29.763 align:middle
LZ4用于快速压缩
但是它不能压缩很多

00:05:29.830 --> 00:05:35.569 align:middle
在中间位置是zlib和LZFSE

00:05:35.636 --> 00:05:37.571 align:middle
为在压缩比率和速度之间取得平衡

00:05:38.839 --> 00:05:42.309 align:middle
如果是在不同的应用情况中做比较

00:05:42.676 --> 00:05:44.578 align:middle
对于软件分发你会使用LZMA

00:05:44.645 --> 00:05:47.347 align:middle
因为要在服务器上压缩一次 然后发送

00:05:47.948 --> 00:05:51.451 align:middle
这样你会希望发送部分越小越好

00:05:52.853 --> 00:05:54.655 align:middle
那我们做了什么呢？

00:05:54.988 --> 00:05:58.325 align:middle
我们在Apple硬件上做了部分优化

00:05:59.059 --> 00:05:59.927 align:middle
这是什么意思呢？

00:06:00.727 --> 00:06:04.898 align:middle
像这样例如我们优化了zlib解码器

00:06:05.999 --> 00:06:08.735 align:middle
我们提供的zlib解码器的性能

00:06:08.802 --> 00:06:15.242 align:middle
压缩能力几乎比
普通的zlib快1.6倍

00:06:16.009 --> 00:06:17.177 align:middle
LZ4也是如此

00:06:17.244 --> 00:06:20.848 align:middle
因此这是另一个好处

00:06:20.914 --> 00:06:23.116 align:middle
你还会因为无需改变代码

00:06:23.183 --> 00:06:26.019 align:middle
就可以实现数据安全和性能升级而受益

00:06:27.955 --> 00:06:31.758 align:middle
我们简单介绍一下
新的压缩器LZFSE

00:06:32.292 --> 00:06:34.962 align:middle
你为什么会需要新款压缩器呢？

00:06:36.930 --> 00:06:37.764 align:middle
首先它很有趣

00:06:40.434 --> 00:06:44.004 align:middle
然后 为什么我们要优化zlib?

00:06:44.371 --> 00:06:49.643 align:middle
在zlib的熵编码部分
我们得出了结论

00:06:50.077 --> 00:06:55.048 align:middle
这里是个瓶颈问题无法解决

00:06:55.616 --> 00:06:59.419 align:middle
除非是用其他的内容加以取代
我们就是这么做的

00:07:00.120 --> 00:07:03.824 align:middle
我们采用了新技术更精致的状态熵

00:07:03.924 --> 00:07:06.793 align:middle
并用它取代了zlib编码

00:07:07.427 --> 00:07:12.999 align:middle
好消息是LZFSE可以在

00:07:13.066 --> 00:07:17.371 align:middle
现代CPU架构上实现更好的映射

00:07:18.672 --> 00:07:24.011 align:middle
当初的设计目标
是要匹配zlib的压缩比率

00:07:24.077 --> 00:07:26.013 align:middle
使之能实现尽可能快的速度

00:07:26.980 --> 00:07:29.149 align:middle
我来给大家看看相关的数字

00:07:30.551 --> 00:07:35.255 align:middle
这是压缩比率通过设计也是同样的数字

00:07:37.090 --> 00:07:42.262 align:middle
这里是能源效率
编码和解码都有LZFSE

00:07:43.363 --> 00:07:46.500 align:middle
如大家所见 在编码方面

00:07:46.567 --> 00:07:50.737 align:middle
我们快了2倍多
在解码方面我们快了2.5倍

00:07:50.804 --> 00:07:52.172 align:middle
不仅是快是更高效

00:07:52.306 --> 00:07:53.273 align:middle
这是什么意思呢？

00:07:54.074 --> 00:07:58.111 align:middle
假设你有的电池是满格电量
并未进行压缩

00:07:59.246 --> 00:08:03.951 align:middle
通过zlib比如说在电池
没电之前可以压缩5千兆数据

00:07:59.246 --> 00:08:03.951 align:middle
通过zlib比如说在电池
没电之前可以压缩5千兆数据

00:08:04.451 --> 00:08:09.990 align:middle
通过LZFSE 耗费同样的电量
你可以压缩12千兆数据

00:08:10.224 --> 00:08:12.526 align:middle
这就是高能效的意思

00:08:13.894 --> 00:08:15.762 align:middle
实际上 速度方面也不差

00:08:16.096 --> 00:08:20.000 align:middle
因为我们在相同的压缩比率下在编码

00:08:20.067 --> 00:08:22.503 align:middle
速度方面快了2倍多解码速度

00:08:23.036 --> 00:08:24.204 align:middle
则快了3倍

00:08:26.773 --> 00:08:28.275 align:middle
这就是LZFSE

00:08:28.342 --> 00:08:31.378 align:middle
我来给大家展示这个API该怎样使用

00:08:31.445 --> 00:08:36.216 align:middle
共有两个API在一个缓冲区中
立刻出现了所有的数据

00:08:36.283 --> 00:08:37.851 align:middle
则要用到缓冲API

00:08:38.619 --> 00:08:44.291 align:middle
这是从PC中接收数据时
用到的流API

00:08:46.159 --> 00:08:47.694 align:middle
缓冲API非常简单

00:08:47.761 --> 00:08:52.799 align:middle
就像是超级的内存拷贝你提供缓冲

00:08:52.866 --> 00:08:55.936 align:middle
和字节数目的地缓冲

00:08:56.003 --> 00:08:59.873 align:middle
和容量还还可以提供

00:09:00.107 --> 00:09:03.677 align:middle
所需用到的算法

00:09:03.844 --> 00:09:04.878 align:middle
这就是LZFSE

00:09:05.445 --> 00:09:08.982 align:middle
你会看到在压缩器之间的转换

00:09:09.049 --> 00:09:11.885 align:middle
就是改变常数即可不需要重写任何代码

00:09:12.553 --> 00:09:15.489 align:middle
新代码是压缩解码缓冲函数

00:09:15.856 --> 00:09:17.991 align:middle
如果出现错误或者目的地缓冲区

00:09:18.058 --> 00:09:21.562 align:middle
没有足够空间它就会将

00:09:21.628 --> 00:09:25.232 align:middle
返回目的地缓冲区的字节数变为0

00:09:26.366 --> 00:09:28.669 align:middle
解码也是同样道理

00:09:29.269 --> 00:09:32.639 align:middle
你会传递包括压缩有效载荷的缓冲区

00:09:33.507 --> 00:09:36.777 align:middle
和接收解码数据的缓冲区

00:09:38.712 --> 00:09:43.050 align:middle
不同之处在于它放入输出

00:09:43.951 --> 00:09:45.519 align:middle
缓冲区的字节数

00:09:46.587 --> 00:09:50.057 align:middle
如果出现问题它会填充缓冲区

00:09:50.357 --> 00:09:53.594 align:middle
也会截取输出内容

00:09:54.728 --> 00:09:56.763 align:middle
我来给大家展示流API

00:09:57.197 --> 00:09:58.932 align:middle
这稍微有些复杂

00:10:00.133 --> 00:10:02.970 align:middle
因为你需要在调用之间有些状态

00:10:03.070 --> 00:10:08.475 align:middle
我们会用需要压缩的
新原始数据多次调用库

00:10:08.542 --> 00:10:10.477 align:middle
这就像个糖果工厂

00:10:10.544 --> 00:10:13.313 align:middle
从这边送入白糖输出的就是糖果

00:10:16.917 --> 00:10:19.219 align:middle
你需要将流对象进行初始化

00:10:19.286 --> 00:10:21.421 align:middle
然后多次处理函数

00:10:22.055 --> 00:10:29.029 align:middle
最后你会调用函数释放流
对象占用的资源

00:10:30.230 --> 00:10:32.533 align:middle
我来给大家看看代码细节

00:10:33.367 --> 00:10:35.769 align:middle
首先我们初始化流对象你表示认可

00:10:35.836 --> 00:10:39.072 align:middle
我要编码要使用LZFSE初始化

00:10:39.740 --> 00:10:43.744 align:middle
然后你会调用过程

00:10:44.511 --> 00:10:49.750 align:middle
在调用过程之前通常是在其他压缩库中

00:10:50.350 --> 00:10:53.220 align:middle
你需要告知它在哪里压缩字节

00:10:53.287 --> 00:10:55.455 align:middle
在哪里放置输出数据

00:10:56.223 --> 00:11:00.460 align:middle
然后调用过程它会和消费者端一样

00:10:56.223 --> 00:11:00.460 align:middle
然后调用过程它会和消费者端一样

00:11:00.527 --> 00:11:02.362 align:middle
输入或填充输出数据

00:11:03.330 --> 00:11:05.799 align:middle
它还会为你更新这些域

00:11:07.134 --> 00:11:09.903 align:middle
最后你会告知它好了做完了

00:11:09.970 --> 00:11:12.072 align:middle
没有白糖原料了

00:11:13.207 --> 00:11:15.843 align:middle
结束之后你就不得
再发送需要压缩的数据

00:11:15.909 --> 00:11:20.681 align:middle
但是你需要多次调用
清空管道获得输出数据

00:11:21.615 --> 00:11:25.686 align:middle
此刻它会返回结束意思是说

00:11:26.553 --> 00:11:30.657 align:middle
最后你需要调用压缩流销毁来释放资源

00:11:31.992 --> 00:11:34.728 align:middle
这就是编码解码则要更为简单

00:11:35.229 --> 00:11:38.031 align:middle
你需要相同的初始化代码

00:11:39.266 --> 00:11:42.469 align:middle
这次是要解码而不是编码

00:11:43.971 --> 00:11:47.140 align:middle
然后你发送数据它会自行分辨

00:11:47.207 --> 00:11:48.609 align:middle
这是否为流的结束部分

00:11:48.675 --> 00:11:52.312 align:middle
在某些点它会返回结束这意味着

00:11:53.747 --> 00:11:56.450 align:middle
你可以获得所有数据你还要再次销毁
就这样

00:11:56.984 --> 00:11:58.218 align:middle
我们完成了压缩

00:11:59.319 --> 00:12:03.457 align:middle
现在来进行打包有一个新的库

00:11:59.319 --> 00:12:03.457 align:middle
现在来进行打包有一个新的库

00:12:03.524 --> 00:12:06.226 align:middle
可以在几个压缩器上
提供简化和统一的API

00:12:07.461 --> 00:12:09.963 align:middle
LZMA LZ4 zlib
和 LZFSE

00:12:10.030 --> 00:12:14.201 align:middle
哪个在zlib上更受青睐

00:12:15.502 --> 00:12:18.338 align:middle
LZFSE就是新的 高性能压缩器

00:12:19.173 --> 00:12:22.009 align:middle
谢谢大家 有请史蒂夫他会介绍

00:12:23.577 --> 00:12:26.980 align:middle
有关SIMD库的改进内容

00:12:28.115 --> 00:12:28.949 align:middle
谢谢

00:12:34.521 --> 00:12:35.355 align:middle
谢谢 埃里克

00:12:35.722 --> 00:12:39.126 align:middle
我是史蒂夫·坎农
和埃里克一起是矢量数字组的工程师

00:12:39.693 --> 00:12:41.195 align:middle
今天 我想谈谈SIMD

00:12:41.795 --> 00:12:45.432 align:middle
这是个二维三维和四维的矢量数学

00:12:47.100 --> 00:12:50.571 align:middle
去年在Yosemite版本
和iOS中 我们引入了SIMD

00:12:51.471 --> 00:12:54.908 align:middle
它可以用于C
Objective-C

00:12:55.275 --> 00:12:57.544 align:middle
和C++它与Metal着色
语言非常相似

00:12:58.045 --> 00:13:01.415 align:middle
也就是说它很容易编写在GPU上

00:12:58.045 --> 00:13:01.415 align:middle
也就是说它很容易编写在GPU上

00:13:01.481 --> 00:13:04.551 align:middle
运行的Metal代码使用和SIMD

00:13:04.618 --> 00:13:07.020 align:middle
相同的数据结构和相同的CPU代码

00:13:07.855 --> 00:13:11.225 align:middle
它非常接近着色语言的传统

00:13:11.291 --> 00:13:14.161 align:middle
以及与矢量和矩形工作的方式

00:13:14.528 --> 00:13:15.629 align:middle
那么今年的新增

00:13:16.630 --> 00:13:18.031 align:middle
内容是我们也会支持Swift

00:13:23.470 --> 00:13:27.107 align:middle
那么本次讲座中以及我主讲的部分
都是与Swift有关

00:13:27.174 --> 00:13:28.408 align:middle
所有的实例都是Swift

00:13:28.675 --> 00:13:32.613 align:middle
大部分情况下 它与C
Objective-C和C++中

00:13:32.813 --> 00:13:34.982 align:middle
都是完全相同

00:13:35.482 --> 00:13:39.386 align:middle
如果想在深入了解这些语言可以看看

00:13:39.453 --> 00:13:42.322 align:middle
我们去年的讲座视频其中有些很重要的

00:13:42.389 --> 00:13:45.092 align:middle
不同之处我会在讲座中明确指出

00:13:45.225 --> 00:13:46.760 align:middle
但是 所有的实例都是Swift

00:13:48.562 --> 00:13:50.998 align:middle
我们为什么要引入新的矢量库呢?

00:13:51.164 --> 00:13:53.634 align:middle
在平台上有一系列矢量库

00:13:53.700 --> 00:13:55.169 align:middle
我也用过相当多

00:13:55.869 --> 00:13:57.137 align:middle
为什么还要添加新的呢？

00:13:57.204 --> 00:14:01.241 align:middle
我给大家看看几项实例
都是用其他矢量库

00:13:57.204 --> 00:14:01.241 align:middle
我给大家看看几项实例
都是用其他矢量库

00:14:01.508 --> 00:14:04.711 align:middle
小有不便以及使用
SIMD则会好了许多

00:14:06.180 --> 00:14:07.948 align:middle
BLAS是很好的矢量库

00:14:08.115 --> 00:14:10.484 align:middle
它是加速的一部分这是我用到的
第一部分内容

00:14:10.584 --> 00:14:15.222 align:middle
这里是用向量乘以矢量一个例子

00:14:15.355 --> 00:14:17.291 align:middle
并将之加入BLAS的另一个矢量

00:14:17.958 --> 00:14:20.327 align:middle
我们生成了两个Swift数组

00:14:20.661 --> 00:14:21.962 align:middle
这些就我们的矢量

00:14:22.663 --> 00:14:28.402 align:middle
我们称之为C BLAS Saxpy
函数 它会将X乘以2

00:14:28.735 --> 00:14:30.671 align:middle
在加上Y并把结果保存在Y

00:14:31.471 --> 00:14:35.409 align:middle
我们需要传递的还有一些其他信息

00:14:35.509 --> 00:14:38.078 align:middle
因为这里是用到原始生成的API

00:14:38.145 --> 00:14:40.480 align:middle
它对于长度或步幅一无所知

00:14:40.848 --> 00:14:42.182 align:middle
我们需要提供这类信息

00:14:42.683 --> 00:14:44.818 align:middle
若是提出显性调用来做

00:14:44.885 --> 00:14:46.954 align:middle
这项工作效率也会很低

00:14:47.754 --> 00:14:50.657 align:middle
我们来看GLKit
这是另一个很棒的库我喜欢GLKit

00:14:51.458 --> 00:14:53.660 align:middle
它有显性矢量类型这样你就不必

00:14:53.727 --> 00:14:56.663 align:middle
使用原始数组但是函数却非常啰嗦

00:14:56.730 --> 00:15:00.701 align:middle
你必须要调用GLK矢量3乘以向量

00:14:56.730 --> 00:15:00.701 align:middle
你必须要调用GLK矢量3乘以向量

00:15:01.201 --> 00:15:03.971 align:middle
来做算法这非常麻烦

00:15:04.304 --> 00:15:06.206 align:middle
使用SIMD是这样的效果

00:15:09.476 --> 00:15:10.777 align:middle
好多了 对吧？

00:15:12.779 --> 00:15:16.917 align:middle
你可以写下想用的算法它会发挥作用

00:15:16.984 --> 00:15:18.519 align:middle
你不必调用函数

00:15:18.886 --> 00:15:19.987 align:middle
生活真美好

00:15:20.654 --> 00:15:21.855 align:middle
那么这样就好多了

00:15:22.222 --> 00:15:23.090 align:middle
你还能做什么呢？

00:15:24.925 --> 00:15:30.230 align:middle
我们有浮点矢量 双矢量
32bit整数2 3 4的长度

00:15:31.131 --> 00:15:35.869 align:middle
在C Objective-C
和C++还有其他矢量类型可用

00:15:36.803 --> 00:15:39.473 align:middle
现在我们有了Swift的子集

00:15:39.973 --> 00:15:44.878 align:middle
我们选择这个子集是因为
当你想用I/O模型

00:15:45.112 --> 00:15:47.447 align:middle
想使用图形内容这是编写Metal

00:15:47.514 --> 00:15:49.516 align:middle
程序最常用来与其他的库

00:15:49.583 --> 00:15:52.119 align:middle
进行互通的部分这些就是
你希望可用的类型

00:15:53.620 --> 00:15:54.988 align:middle
这些类型可以用来做什么？

00:15:55.055 --> 00:15:56.723 align:middle
首先 你要生成它们

00:15:56.823 --> 00:16:00.027 align:middle
我们有一系列不错的起始程序
你可以生成零矢量

00:15:56.823 --> 00:16:00.027 align:middle
我们有一系列不错的起始程序
你可以生成零矢量

00:16:00.627 --> 00:16:03.363 align:middle
可以显性规定矢量元素

00:16:03.664 --> 00:16:08.635 align:middle
可以有所有组件相等的矢量
有许多不错的初始程序

00:16:09.403 --> 00:16:10.704 align:middle
你可以完成算法

00:16:11.305 --> 00:16:13.340 align:middle
可以有元素方面的算法算子也可以用

00:16:13.407 --> 00:16:16.877 align:middle
如果我用两个矢量相乘
就会得到一个新的矢量

00:16:16.944 --> 00:16:20.047 align:middle
其中的每个元素元素的值

00:16:20.113 --> 00:16:22.616 align:middle
就是输入矢量对应元素相乘的结果

00:16:22.983 --> 00:16:26.353 align:middle
相除也是同样我可以用向量相乘

00:16:26.887 --> 00:16:29.489 align:middle
我可以进行向量点积向量叉积等等

00:16:30.257 --> 00:16:33.861 align:middle
我已经给大家看了一个实例
我马上给你们再看一个简单的例子

00:16:34.228 --> 00:16:37.464 align:middle
这是个反射函数我可能
会在图像中经常使用

00:16:37.931 --> 00:16:41.201 align:middle
它用1个矢量X它通过垂直于

00:16:41.535 --> 00:16:43.937 align:middle
标准矢量N来反射N

00:16:45.038 --> 00:16:47.541 align:middle
要写下它需要编写数学表达式

00:16:47.841 --> 00:16:52.980 align:middle
写下X减去2倍的
X向量点积和N倍的N

00:16:53.947 --> 00:16:56.750 align:middle
你实际上不必写下这个函数 对吗？

00:16:56.817 --> 00:16:58.485 align:middle
应该已经有现成的可供使用

00:16:59.286 --> 00:17:03.690 align:middle
对的 我们有一系列几何着色器
数学函数可供使用

00:16:59.286 --> 00:17:03.690 align:middle
对的 我们有一系列几何着色器
数学函数可供使用

00:17:04.290 --> 00:17:07.160 align:middle
我们还有向量点积
向量叉积 反射 折射

00:17:07.361 --> 00:17:10.230 align:middle
距离 等等
所有这些你都会用到

00:17:10.664 --> 00:17:12.299 align:middle
如果你之前写过着色器程序

00:17:12.432 --> 00:17:14.034 align:middle
你就曾多次用过这些函数

00:17:14.101 --> 00:17:17.503 align:middle
这些都是在Metal
或开放式CL或GLSL

00:17:17.971 --> 00:17:21.875 align:middle
你所喜爱的着色器语言中的标准内容

00:17:22.876 --> 00:17:25.811 align:middle
我们还有浮点4类型的加速

00:17:25.878 --> 00:17:29.816 align:middle
的各类数学函数可用
因此可以使用 V sign F

00:17:29.917 --> 00:17:33.520 align:middle
VCosf 用这些类型
进行数学函数计算

00:17:34.154 --> 00:17:36.223 align:middle
我们还有矩阵和矢量

00:17:37.658 --> 00:17:40.527 align:middle
矩阵的类型是浮点数N
乘以N 双精度N乘以M

00:17:41.195 --> 00:17:43.997 align:middle
N是列数M是行数

00:17:44.531 --> 00:17:46.400 align:middle
如果你是个数学家就会感觉很奇怪

00:17:46.934 --> 00:17:49.169 align:middle
如果你是图形编程人员这就很正常

00:17:49.336 --> 00:17:52.506 align:middle
所以大家会感觉轻车熟路

00:17:53.073 --> 00:17:56.977 align:middle
N和M可以是2 3或4但是不一定是
正方矩形例如

00:17:57.044 --> 00:18:02.249 align:middle
浮点2乘3 是个两列三行的矩阵

00:17:57.044 --> 00:18:02.249 align:middle
浮点2乘3 是个两列三行的矩阵

00:18:03.483 --> 00:18:06.687 align:middle
同样 我们有各种初始程序

00:18:07.187 --> 00:18:10.123 align:middle
你可以生成零矩阵可以生成标识矩阵

00:18:10.257 --> 00:18:11.458 align:middle
可以生成对角矩阵

00:18:11.525 --> 00:18:14.528 align:middle
如果你想可以规定对角元素

00:18:14.728 --> 00:18:18.232 align:middle
如果你想还可以规定所有元素
或作为数组的一列

00:18:18.632 --> 00:18:19.867 align:middle
或作为矢量的一列

00:18:23.303 --> 00:18:24.271 align:middle
各种很棒的内容

00:18:27.474 --> 00:18:30.310 align:middle
我给大家展示一个使用
矩阵的小算法实例

00:18:31.345 --> 00:18:33.881 align:middle
我们在对角上用2s生成矩阵

00:18:33.981 --> 00:18:37.818 align:middle
这个矩阵当你相乘时可以用矢量乘以2

00:18:38.418 --> 00:18:41.755 align:middle
我们把最后一列进行调整 放入一些值

00:18:42.189 --> 00:18:46.527 align:middle
这是个变形矩形矢量乘以2

00:18:46.593 --> 00:18:51.298 align:middle
这也使用于偏差可以转化

00:18:52.165 --> 00:18:54.935 align:middle
我们可以把这个用于所有都是1的矢量

00:18:59.072 --> 00:19:00.807 align:middle
还可以用矩阵的反向属性

00:18:59.072 --> 00:19:00.807 align:middle
还可以用矩阵的反向属性

00:19:00.874 --> 00:19:06.413 align:middle
获得相反变形这样就可以
恢复到最初的矢量从而取消变形

00:19:07.748 --> 00:19:09.583 align:middle
当我希望在两种语言之间互通时

00:19:09.650 --> 00:19:12.319 align:middle
可以使用Objective-C
API 如你想要

00:19:12.386 --> 00:19:13.487 align:middle
调用的I/O模型 API

00:19:15.422 --> 00:19:19.259 align:middle
Swfit矢量类型
与Objective-C

00:19:19.459 --> 00:19:20.994 align:middle
矢量类型在布局上兼容

00:19:21.161 --> 00:19:24.231 align:middle
我的意思是说它们在内存中
有着完全相同的表现

00:19:24.631 --> 00:19:26.400 align:middle
编译器了解它们是相同的

00:19:27.467 --> 00:19:31.672 align:middle
这样你就不必考虑
将Swift矢量类型

00:19:31.738 --> 00:19:34.608 align:middle
转变为Objective-C矢量类型
或是将Objective-C矢量类型

00:19:34.675 --> 00:19:38.712 align:middle
转变为Swift矢量类型
我这里有一个返回矢量SIMD矢量的

00:19:38.979 --> 00:19:42.716 align:middle
Objective-C API
我可以立即将之用于Swift

00:19:43.050 --> 00:19:46.620 align:middle
对于矩阵而言我必须从我所获得的

00:19:46.987 --> 00:19:49.423 align:middle
Objective-C矩阵中
初始化Swift矩阵

00:19:49.489 --> 00:19:51.491 align:middle
这是个成本很低的操作基本上是个拷贝

00:19:51.558 --> 00:19:54.561 align:middle
因为布局相同但是我需要调用初始程序

00:19:55.829 --> 00:19:59.499 align:middle
我希望将Swift类型传递给
Objective-C时也是同理

00:20:00.200 --> 00:20:01.702 align:middle
我可以将所用

00:20:02.069 --> 00:20:04.338 align:middle
C矩阵属性的矩阵传递矢量

00:20:04.638 --> 00:20:07.674 align:middle
以获得Objective
矩阵 可以将之传递给

00:20:07.741 --> 00:20:09.209 align:middle
Objective-C API

00:20:10.544 --> 00:20:12.346 align:middle
这就是SIMD

00:20:12.880 --> 00:20:16.116 align:middle
当配合小矢量和矩阵使用时
SIMD效果很好

00:20:16.250 --> 00:20:19.152 align:middle
有时你也会需要使用更大的矢量和矩阵

00:20:20.087 --> 00:20:22.422 align:middle
我就要和大家谈谈LAPACK

00:20:22.556 --> 00:20:23.724 align:middle
BLAS 线性代数

00:20:24.458 --> 00:20:28.195 align:middle
这是很有意思的环节我们需要
离开数学分支片刻

00:20:31.098 --> 00:20:35.202 align:middle
LAPACK和BLAS
是业界标准的数学库

00:20:35.802 --> 00:20:39.773 align:middle
这些是平台上部分最古老的API

00:20:41.508 --> 00:20:44.011 align:middle
也就是说看起来有些晦涩难懂

00:20:44.511 --> 00:20:46.413 align:middle
不过网上有很多文档资料

00:20:46.480 --> 00:20:48.081 align:middle
因为它们已经存在了近40年

00:20:49.750 --> 00:20:53.287 align:middle
很多情况下你可能会从

00:20:53.353 --> 00:20:55.422 align:middle
库中获取部分代码
这就需要依靠这些API

00:20:55.622 --> 00:20:57.858 align:middle
只要连上加速效果很好

00:20:58.358 --> 00:20:59.226 align:middle
用起来很简单

00:20:59.860 --> 00:21:03.730 align:middle
线性代数是我们去年介绍的新界面

00:20:59.860 --> 00:21:03.730 align:middle
线性代数是我们去年介绍的新界面

00:21:04.431 --> 00:21:06.533 align:middle
其中有更简单的API

00:21:06.600 --> 00:21:09.002 align:middle
来完成更常见的线性代数操作

00:21:09.403 --> 00:21:12.806 align:middle
这和上一个幻灯片是完全相同的操作

00:21:12.906 --> 00:21:14.408 align:middle
它在解析线性系统

00:21:14.842 --> 00:21:18.278 align:middle
而不是用8个参数调用晦涩的函数

00:21:18.345 --> 00:21:22.916 align:middle
你调用LA求解 你提供需要
解析的矢量和矩阵

00:21:24.451 --> 00:21:25.619 align:middle
非常好

00:21:26.486 --> 00:21:31.558 align:middle
在过去几年间
我们对LINPACK谈得很少

00:21:32.492 --> 00:21:34.494 align:middle
以及在线性代数方面
我们可以实现多快的速度

00:21:34.928 --> 00:21:37.030 align:middle
LINPACK基准表明
对于系统线性等式

00:21:37.097 --> 00:21:39.366 align:middle
我们可以多快地求解？

00:21:39.433 --> 00:21:43.237 align:middle
这完全是我们
在上一页幻灯片看到的操作

00:21:44.471 --> 00:21:48.942 align:middle
历史上而言该基准共有三种变体

00:21:49.409 --> 00:21:52.779 align:middle
开始是作为可以多快速地
为100x100系统求解？

00:21:54.147 --> 00:21:56.850 align:middle
但是随着电脑
越来越强大 速度越来越快

00:21:57.251 --> 00:22:00.153 align:middle
它不可能通过这样的小问题

00:21:57.251 --> 00:22:00.153 align:middle
它不可能通过这样的小问题

00:22:00.320 --> 00:22:03.957 align:middle
显示自己的速度有多快 因此变成
一个1000x1000的系统

00:22:05.325 --> 00:22:07.194 align:middle
如今 当人们谈到LINPACK

00:22:07.294 --> 00:22:09.429 align:middle
它们实际上不再构成阻碍

00:22:09.496 --> 00:22:13.200 align:middle
你可以随意选择所需的大矩阵
来显示自己能实现多快的速度

00:22:13.834 --> 00:22:16.370 align:middle
当你看到超级计算机排名时

00:22:16.436 --> 00:22:18.305 align:middle
其中提供的LINPACK分数

00:22:18.372 --> 00:22:20.073 align:middle
都是百万x百万的量级

00:22:20.140 --> 00:22:22.176 align:middle
你尽可选择让你的速度可以最快的即可

00:22:23.610 --> 00:22:25.512 align:middle
几周前 我在网上看到

00:22:26.046 --> 00:22:30.417 align:middle
有人在说iPad Air 2的速度
已经相当惊人

00:22:30.817 --> 00:22:35.856 align:middle
LINPACK可以实现每秒1.8个
十亿次浮点运算 相当厉害

00:22:36.757 --> 00:22:39.793 align:middle
这可是每秒1.8个十亿次浮点运算

00:22:40.894 --> 00:22:43.397 align:middle
我知道这个数据不高

00:22:43.797 --> 00:22:49.203 align:middle
有人编写了简单的程式来解决

00:22:49.269 --> 00:22:51.138 align:middle
就是用编译器所能提供的内容

00:22:51.738 --> 00:22:53.874 align:middle
这就是实现的LINPACK分数

00:22:54.441 --> 00:22:58.979 align:middle
我在四周看了看
看到有人在认真优化他们的

00:22:59.346 --> 00:23:01.849 align:middle
LINPACK程式他们编写了矢量代码

00:22:59.346 --> 00:23:01.849 align:middle
LINPACK程式他们编写了矢量代码

00:23:01.982 --> 00:23:04.785 align:middle
做了隐藏层还有多线程

00:23:04.985 --> 00:23:08.455 align:middle
结果实现了LINPACK
每秒5.6个十亿次浮点运算

00:23:08.989 --> 00:23:12.192 align:middle
这要快上3倍改进更多

00:23:13.160 --> 00:23:15.696 align:middle
不用再去做所有这些工作

00:23:16.663 --> 00:23:18.365 align:middle
只需要调用加速即可

00:23:18.565 --> 00:23:22.436 align:middle
在前面的幻灯片中
我展示了D获取RS和LLA解析函数

00:23:22.936 --> 00:23:25.239 align:middle
你可以编写一行代码

00:23:29.810 --> 00:23:35.282 align:middle
如果这么做 就可以实现
每秒25个十亿次浮点运算

00:23:41.889 --> 00:23:43.891 align:middle
我们的确是想这么做

00:23:43.957 --> 00:23:46.026 align:middle
我们就是想为大家带来便利

00:23:46.093 --> 00:23:48.962 align:middle
我们希望让大家只需编写一行代码

00:23:49.162 --> 00:23:51.331 align:middle
而不是去着手优化每项内容

00:23:52.132 --> 00:23:55.502 align:middle
实现更好的能源利用更好的表现

00:23:55.569 --> 00:23:57.037 align:middle
而不需要做太多工作

00:23:58.038 --> 00:24:00.874 align:middle
现在有请卢克回到台上 他会介绍

00:23:58.038 --> 00:24:00.874 align:middle
现在有请卢克回到台上 他会介绍

00:24:00.941 --> 00:24:03.544 align:middle
当矩阵非常巨大时你该怎么做

00:24:06.747 --> 00:24:09.349 align:middle
谢谢 史蒂夫 我是卢克·常

00:24:09.650 --> 00:24:12.119 align:middle
是矢量数字组的工程师

00:24:12.553 --> 00:24:15.122 align:middle
今天我来谈谈
Sparse BLAS的内容

00:24:17.391 --> 00:24:20.794 align:middle
BLAS代表基础线性代数解析程序

00:24:21.562 --> 00:24:24.831 align:middle
稀疏BLAS是稀疏矩阵的BLAS

00:24:25.666 --> 00:24:29.736 align:middle
这是iOS 9和OS X.11的新库

00:24:31.004 --> 00:24:33.841 align:middle
它是为简单的API和优良性能而设计

00:24:34.308 --> 00:24:36.476 align:middle
可以支持单精度和双精度

00:24:38.812 --> 00:24:40.480 align:middle
我们为什么需要稀疏BLAS?

00:24:41.281 --> 00:24:44.751 align:middle
我可以在已经了解具体工作方法的

00:24:45.118 --> 00:24:46.920 align:middle
稀疏BLAS上使用紧密BLAS吗

00:24:47.554 --> 00:24:52.059 align:middle
对的 它可以对不大的矩阵提供维数

00:24:53.093 --> 00:24:56.563 align:middle
但是使用Sparse BLAS
在很多方面会更胜一筹

00:24:57.631 --> 00:24:58.832 align:middle
为了说明这一点

00:24:59.800 --> 00:25:02.436 align:middle
我来给大家
展示一个典型的Sparse矩阵

00:24:59.800 --> 00:25:02.436 align:middle
我来给大家
展示一个典型的Sparse矩阵

00:25:03.170 --> 00:25:05.606 align:middle
这是机器学习的典型矩阵

00:25:06.039 --> 00:25:10.310 align:middle
有着1百万行和20万列

00:25:11.044 --> 00:25:14.648 align:middle
这就是提供了3000亿次的输入

00:25:15.649 --> 00:25:19.520 align:middle
但是矩阵的密度仅为0.05%

00:25:20.721 --> 00:25:23.190 align:middle
这里是视觉化稀疏矩阵的图片

00:25:24.157 --> 00:25:26.326 align:middle
蓝色部分越深密度就会越大

00:25:27.094 --> 00:25:29.930 align:middle
正如大家所见图片上很多
区域都是白色的

00:25:30.531 --> 00:25:31.498 align:middle
这些都是零值

00:25:31.999 --> 00:25:34.067 align:middle
我们不希望把内存耗费在零值上

00:25:35.202 --> 00:25:37.971 align:middle
如果你是在常规的矩阵格式中

00:25:38.038 --> 00:25:39.740 align:middle
存储这个稀疏矩阵

00:25:40.174 --> 00:25:42.442 align:middle
你就可以使用常规紧密的BLAS

00:25:43.177 --> 00:25:45.679 align:middle
假设这是单精度数字 则会

00:25:46.914 --> 00:25:51.385 align:middle
占用1个太字节以上的内存这并不可行

00:25:52.085 --> 00:25:54.421 align:middle
你不会希望在手机和iPad上这么做

00:25:57.090 --> 00:26:03.764 align:middle
这样会节省内存此外稀疏BLAS

00:25:57.090 --> 00:26:03.764 align:middle
这样会节省内存此外稀疏BLAS

00:26:03.830 --> 00:26:05.566 align:middle
还更节能速度更快

00:26:07.968 --> 00:26:13.273 align:middle
我们在MacBook Pro
衡量稀疏BLAS的性能13英寸

00:26:14.074 --> 00:26:17.511 align:middle
密度为0.5%的稀疏

00:26:17.578 --> 00:26:22.182 align:middle
BLAS的能效要比紧密BLAS高18倍

00:26:23.383 --> 00:26:28.455 align:middle
性能方面要快15倍

00:26:29.923 --> 00:26:32.960 align:middle
随着密度的下降性能会提高

00:26:34.661 --> 00:26:39.466 align:middle
在密度为0.05%时
这是我们在之前的矩阵

00:26:40.033 --> 00:26:43.003 align:middle
看到的密度在能效和性能方面

00:26:43.070 --> 00:26:47.107 align:middle
会比使用常规
密度的BLAS高100倍

00:26:48.509 --> 00:26:50.444 align:middle
这样大家看出使用稀疏BLAS

00:26:50.511 --> 00:26:54.681 align:middle
有着许多强有力的原因
节省内存能效更高速度更快

00:26:55.516 --> 00:26:57.584 align:middle
在稀疏BLAS中可以用到什么？

00:26:58.886 --> 00:27:03.290 align:middle
我们有产品 三角解析
我们可以计算范数

00:26:58.886 --> 00:27:03.290 align:middle
我们有产品 三角解析
我们可以计算范数

00:27:03.824 --> 00:27:06.960 align:middle
L1 L2 L 无穷范数等等

00:27:07.995 --> 00:27:10.631 align:middle
我们会看到迹这是对角和

00:27:11.365 --> 00:27:15.869 align:middle
它可以交换行和列为矩阵增加新值

00:27:16.003 --> 00:27:18.405 align:middle
从矩阵中提取行和列

00:27:19.940 --> 00:27:22.409 align:middle
在我介绍操作之前

00:27:22.676 --> 00:27:25.345 align:middle
我们来看如何保存稀疏矢量

00:27:26.613 --> 00:27:30.217 align:middle
正如我之前所说我们不希望把
内存浪费在零值上

00:27:30.517 --> 00:27:34.021 align:middle
我们保存非零值就像这样

00:27:35.489 --> 00:27:39.359 align:middle
然后我们需要了解这些非零值从何而来

00:27:40.027 --> 00:27:42.596 align:middle
因此我们保存非零值的指数

00:27:43.630 --> 00:27:45.899 align:middle
最后 我们需要了解我们保存了多少

00:27:45.999 --> 00:27:48.035 align:middle
这就是非零值非零值的指数

00:27:49.136 --> 00:27:52.306 align:middle
这些是稀疏矢量需要保存的三项内容

00:27:54.141 --> 00:27:58.412 align:middle
为了从常规密度矢量

00:27:58.478 --> 00:28:02.382 align:middle
转化为稀疏矢量
Sparse BLAS提供了效用函数

00:27:58.478 --> 00:28:02.382 align:middle
转化为稀疏矢量
Sparse BLAS提供了效用函数

00:28:02.683 --> 00:28:03.917 align:middle
帮助完成转化

00:28:04.585 --> 00:28:07.387 align:middle
如果想从密度专为稀疏则需要调用压缩

00:28:08.155 --> 00:28:09.990 align:middle
反之 则是需要调用解压

00:28:10.891 --> 00:28:12.893 align:middle
如果你需要了解非零值的数量

00:28:12.960 --> 00:28:15.095 align:middle
可以调用获取矢量非零值数量

00:28:16.363 --> 00:28:19.399 align:middle
现在我们来看稀疏矩阵怎么保存呢？

00:28:20.400 --> 00:28:24.271 align:middle
我们可以将稀疏矩阵视作行的集合

00:28:24.671 --> 00:28:26.440 align:middle
或是列的集合

00:28:26.740 --> 00:28:30.143 align:middle
如果我们压缩稀疏行稀疏列

00:28:30.978 --> 00:28:33.947 align:middle
或是忘记了行和列这就会非常乱

00:28:34.281 --> 00:28:37.584 align:middle
我希望将矩阵视作非零值列表

00:28:37.751 --> 00:28:40.988 align:middle
每个非零值我们都会存储

00:28:41.388 --> 00:28:42.789 align:middle
列索引和行索引

00:28:43.757 --> 00:28:46.994 align:middle
还有许多其他保存格式

00:28:47.227 --> 00:28:49.763 align:middle
每种都有自己的优势和不足

00:28:50.597 --> 00:28:52.766 align:middle
对于你所要进行的具体操作

00:28:52.900 --> 00:28:54.801 align:middle
可能会有最佳的保存格式

00:28:56.370 --> 00:28:58.305 align:middle
我们决定让事情更容易些

00:28:59.506 --> 00:29:01.708 align:middle
我们定义了稀疏矩阵数据类型

00:28:59.506 --> 00:29:01.708 align:middle
我们定义了稀疏矩阵数据类型

00:29:02.910 --> 00:29:05.746 align:middle
这是个不透明指针如果你想用的话

00:29:05.812 --> 00:29:08.582 align:middle
必须先用创建函数来生成

00:29:09.149 --> 00:29:11.952 align:middle
并且可以对其进行操作做完之后

00:29:12.152 --> 00:29:13.020 align:middle
必须销毁

00:29:14.221 --> 00:29:15.656 align:middle
这么做的好处是

00:29:15.722 --> 00:29:17.991 align:middle
我们可以为你管理内存

00:29:18.358 --> 00:29:20.527 align:middle
想在矩阵中添加新值时

00:29:20.594 --> 00:29:22.930 align:middle
你也不必担心分配新内存

00:29:23.363 --> 00:29:27.034 align:middle
或重新调整缓冲区或最后释放缓冲区

00:29:27.267 --> 00:29:28.101 align:middle
我们来做这些

00:29:29.603 --> 00:29:33.040 align:middle
更好的是我们可以选择最好的保存格式

00:29:33.707 --> 00:29:36.877 align:middle
例如如果你在稀疏矩阵中

00:29:36.944 --> 00:29:39.980 align:middle
插入一组行我们会按照稀疏行来保存

00:29:40.747 --> 00:29:45.452 align:middle
当你插入一组列时我们会
按照稀疏列来保存

00:29:46.320 --> 00:29:49.156 align:middle
如果你想做特殊的操作

00:29:49.223 --> 00:29:54.294 align:middle
还有最好的保存格式
我们也会自动转化为该格式

00:29:55.429 --> 00:29:58.765 align:middle
最后 这会让我们在API中

00:29:58.832 --> 00:30:01.635 align:middle
隐藏维数细节让API更为干净

00:29:58.832 --> 00:30:01.635 align:middle
隐藏维数细节让API更为干净

00:30:02.703 --> 00:30:04.605 align:middle
当你调用稀疏函数时

00:30:04.671 --> 00:30:08.308 align:middle
你不必每次传递稀疏矩阵的维数

00:30:09.776 --> 00:30:10.811 align:middle
这里是个示例

00:30:12.379 --> 00:30:14.381 align:middle
首先创建稀疏矩阵

00:30:16.016 --> 00:30:18.986 align:middle
然后你会在稀疏矩阵中插入一个值

00:30:19.553 --> 00:30:23.857 align:middle
或是插入稀疏矢量作为行或列

00:30:25.125 --> 00:30:27.661 align:middle
然后提交稀疏矩阵的更改

00:30:27.895 --> 00:30:31.298 align:middle
在下一个幻灯片中
我来讲详细介绍提交函数

00:30:32.366 --> 00:30:34.034 align:middle
完成之后要调用销毁

00:30:35.302 --> 00:30:37.571 align:middle
好的 为什么需要提交函数？

00:30:39.006 --> 00:30:44.144 align:middle
数据插入造价很高因为
我们以压缩格式保存值

00:30:44.778 --> 00:30:47.614 align:middle
每次你需要在涉及数据移动的

00:30:48.015 --> 00:30:49.850 align:middle
压缩存储中

00:30:50.250 --> 00:30:53.754 align:middle
加入值就会涉及更多
内存分配这样造价很高

00:30:54.821 --> 00:30:58.559 align:middle
我们需要延迟所有的数据插入
这样可以分批处理

00:31:01.228 --> 00:31:04.731 align:middle
好消息是即便你忘记调用提交函数

00:31:05.432 --> 00:31:07.568 align:middle
当你在矩阵中进行操作时

00:31:08.035 --> 00:31:10.037 align:middle
提交函数也会自动启动

00:31:10.704 --> 00:31:13.173 align:middle
现在你可能会问为什么要用提交函数?

00:31:14.541 --> 00:31:16.910 align:middle
如果想要控制代码性能

00:31:17.578 --> 00:31:20.113 align:middle
你显然要用到提交函数

00:31:20.681 --> 00:31:24.384 align:middle
加入你在app启动期间

00:31:24.451 --> 00:31:27.588 align:middle
让稀疏矩阵就绪这样app可以对

00:31:27.654 --> 00:31:29.823 align:middle
用户的数据 尽快做出反应

00:31:30.724 --> 00:31:34.228 align:middle
那么就要在启动代码中加入提交函数

00:31:35.162 --> 00:31:35.996 align:middle
这样相当好用

00:31:37.197 --> 00:31:40.033 align:middle
好 考虑到时间问题
我只介绍稀疏BLAS中

00:31:40.100 --> 00:31:42.903 align:middle
最常见的两个操作

00:31:43.537 --> 00:31:46.173 align:middle
第一个是乘积C=AxB

00:31:46.840 --> 00:31:49.776 align:middle
我们支持矢量内积 矢量外积

00:31:50.310 --> 00:31:52.946 align:middle
矩阵矢量乘积矩阵矩阵乘积

00:31:54.014 --> 00:31:55.883 align:middle
A B C的类型是什么？

00:31:56.250 --> 00:32:01.555 align:middle
对于内积A是稀疏B
为稀疏或紧密C为单一值

00:31:56.250 --> 00:32:01.555 align:middle
对于内积A是稀疏B
为稀疏或紧密C为单一值

00:32:02.489 --> 00:32:05.559 align:middle
对于外积 A为紧密B为稀疏

00:32:05.826 --> 00:32:08.161 align:middle
结果C是稀疏矩阵

00:32:08.962 --> 00:32:11.265 align:middle
对于矩阵矢量和矩阵矩阵乘积

00:32:11.498 --> 00:32:14.034 align:middle
A为稀疏 B为紧密C为稀疏

00:32:15.135 --> 00:32:18.539 align:middle
你需要两个稀疏矩阵
乘积的情况非常罕见

00:32:18.605 --> 00:32:19.573 align:middle
因此不做支持

00:32:21.441 --> 00:32:24.778 align:middle
这里是矩阵乘积的
函数原型

00:32:26.146 --> 00:32:28.148 align:middle
稀疏函数的命名规则是先

00:32:28.415 --> 00:32:33.787 align:middle
是下划线稀疏后面是我们要做的
操作在本例中是矩阵相乘

00:32:34.888 --> 00:32:38.225 align:middle
紧密是指BC为紧密浮点是数据类型

00:32:39.193 --> 00:32:42.162 align:middle
你将会返回成功或错误代码

00:32:42.963 --> 00:32:45.933 align:middle
这个函数的参数正如常规BLAS

00:32:46.033 --> 00:32:49.536 align:middle
你规定B和C的次序是列主序或行主序

00:32:49.770 --> 00:32:52.005 align:middle
你来表示自己是否需要将A换位

00:32:52.773 --> 00:32:55.909 align:middle
B和C的列数 其余则和BLAS一样

00:32:57.711 --> 00:33:00.480 align:middle
下一个操作是三角解析

00:32:57.711 --> 00:33:00.480 align:middle
下一个操作是三角解析

00:33:01.148 --> 00:33:03.183 align:middle
你来为三角系统等式求解

00:33:03.750 --> 00:33:08.121 align:middle
T必须是上或下三角矩阵

00:33:09.189 --> 00:33:13.927 align:middle
我们支持紧密紧密矢量或B矩阵

00:33:15.295 --> 00:33:17.731 align:middle
主要注意的是上或下三角

00:33:17.798 --> 00:33:22.135 align:middle
属性必须在进行数据插入前设置

00:33:23.036 --> 00:33:24.638 align:middle
这里的代码就是强调这一点

00:33:25.639 --> 00:33:29.309 align:middle
设置矩阵属性需要在进行
任何数据插入前完成

00:33:29.810 --> 00:33:32.346 align:middle
在数据插入后可以调用三角求解

00:33:32.813 --> 00:33:35.682 align:middle
参数则和BLAS一样

00:33:38.185 --> 00:33:42.756 align:middle
总之稀疏BLAS
是和简单API一起设计

00:33:42.990 --> 00:33:45.158 align:middle
它有着非常广的操作范围

00:33:45.626 --> 00:33:46.894 align:middle
性能也很好

00:33:48.195 --> 00:33:50.831 align:middle
好的现在就来总结一下讲座内容

00:33:51.765 --> 00:33:53.934 align:middle
我们今天介绍了三个新库

00:33:54.635 --> 00:33:58.605 align:middle
用我们的新压缩器LZFSE进行压缩

00:33:59.673 --> 00:34:01.575 align:middle
现在 你可以在Swift上

00:33:59.673 --> 00:34:01.575 align:middle
现在 你可以在Swift上

00:34:02.109 --> 00:34:04.144 align:middle
使用SIMD还有稀疏BLAS库

00:34:05.445 --> 00:34:07.214 align:middle
它们有着共同的设计目标

00:34:07.848 --> 00:34:11.717 align:middle
都是速度更快能效高便于使用

00:34:12.186 --> 00:34:15.455 align:middle
我们鼓励大家试一试
让我们知道你们是怎么想的

00:34:16.489 --> 00:34:17.791 align:middle
我们很希望能听到大家的反馈

00:34:18.958 --> 00:34:22.529 align:middle
我们对开发人员的要求
和反馈都认真对待

00:34:22.763 --> 00:34:25.431 align:middle
实际上 我们添加到
加速框架中的许多功能

00:34:25.498 --> 00:34:30.070 align:middle
都是根据开发人员的要求进行的

00:34:30.469 --> 00:34:33.507 align:middle
如果你发现自己想用的功能没有

00:34:33.841 --> 00:34:35.208 align:middle
请填写功能申请

00:34:36.909 --> 00:34:39.612 align:middle
若想了解更多详情我们还有vDSP和

00:34:39.679 --> 00:34:41.481 align:middle
压缩的在线文档资料

00:34:42.014 --> 00:34:45.518 align:middle
如果想了解加速框架的其他内容

00:34:45.853 --> 00:34:49.188 align:middle
可以看看我们以往的WWDC讲座视频

00:34:50.724 --> 00:34:53.659 align:middle
我们还有压缩vDSP的简单代码

00:34:54.094 --> 00:34:56.230 align:middle
还可以参加论坛讨论

00:34:56.663 --> 00:35:01.134 align:middle
如果是一般性咨询
可以联系开发顾问保罗·登博

00:34:56.663 --> 00:35:01.134 align:middle
如果是一般性咨询
可以联系开发顾问保罗·登博

00:35:02.536 --> 00:35:06.106 align:middle
这里就是相关讲座
我们介绍过I/0模型

00:35:06.273 --> 00:35:08.976 align:middle
Metal Swift 如果想
了解更多详情

00:35:09.243 --> 00:35:12.012 align:middle
可以去找这些讲座的视频看看

00:35:12.513 --> 00:35:13.347 align:middle
就是这样

00:35:13.580 --> 00:35:15.983 align:middle
感谢大家光临 希望在实验室见到大家

00:35:16.149 --> 00:35:16.984 align:middle
非常感谢！
