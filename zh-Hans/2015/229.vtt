WEBVTT

00:00:21.288 --> 00:00:28.295 align:middle
UIKitDynamics
和视觉效果的最新进展

00:00:31.365 --> 00:00:33.834 align:middle
欢迎参加WWDC
和"UIKitDynamics

00:00:34.601 --> 00:00:37.070 align:middle
和视觉效果的最新进展"
的最后一天的活动

00:00:37.304 --> 00:00:38.405 align:middle
我是麦克·特纳

00:00:38.672 --> 00:00:40.440 align:middle
我将和我的同事大卫·杜汉
一起为大家进行介绍

00:00:40.507 --> 00:00:42.643 align:middle
我们两个都是Apple在这里的
UIKit开发组成员

00:00:43.644 --> 00:00:45.179 align:middle
所以 在我们开始今天的介绍之前

00:00:45.646 --> 00:00:47.314 align:middle
我要向各位推荐几场
非常好的讲座

00:00:47.381 --> 00:00:48.882 align:middle
我只是简要介绍一下

00:00:48.949 --> 00:00:50.651 align:middle
在过去几年里我们
进行过几场非常好的

00:00:50.717 --> 00:00:53.287 align:middle
围绕UIKitDynamics动态
和视觉效果的讲座

00:00:53.620 --> 00:00:56.557 align:middle
所以我们今天就从
简要概述

00:00:56.623 --> 00:00:58.358 align:middle
动态动画模拟系统开始

00:00:58.425 --> 00:01:00.160 align:middle
我们会进行 基本示范 然后

00:00:58.425 --> 00:01:00.160 align:middle
我们会进行 基本示范 然后

00:01:00.327 --> 00:01:03.664 align:middle
我们直接切入今年
UIKit Dynamics的新进展

00:01:04.197 --> 00:01:08.068 align:middle
然后大卫会过来
与我们讨论视觉效果

00:01:09.937 --> 00:01:12.206 align:middle
以及你怎样在你的应用程序中
运用那些效果

00:01:12.706 --> 00:01:14.374 align:middle
最后 我们会稍稍涉及

00:01:14.441 --> 00:01:17.077 align:middle
一些应用UIKit
Dynamics的最佳操作范例

00:01:17.144 --> 00:01:18.779 align:middle
和你的应用程序里的自动布局

00:01:20.681 --> 00:01:22.683 align:middle
所以我们谈论UIKit Dynamics时

00:01:22.749 --> 00:01:25.085 align:middle
我们说的是一个二维的
基于物理启发的

00:01:25.152 --> 00:01:26.553 align:middle
动画交互系统

00:01:27.387 --> 00:01:30.023 align:middle
它有一个非常易于组合的
说明式的API

00:01:30.357 --> 00:01:32.993 align:middle
可以显示你的应用程序
里的高水平动画

00:01:33.727 --> 00:01:37.798 align:middle
我们所说的并非核心动画或用户界面视
图UIView动画的

00:01:38.031 --> 00:01:39.199 align:middle
替代程序 而是另一个

00:01:39.266 --> 00:01:41.702 align:middle
能够帮助你在你的应用程序
创建定制的效果的工具

00:01:42.436 --> 00:01:43.537 align:middle
让我们来看一个示例

00:01:44.238 --> 00:01:46.807 align:middle
这里有一个基础的滑动视图

00:01:47.774 --> 00:01:50.477 align:middle
用户可以平移视图
但是如果你放开它

00:01:50.544 --> 00:01:53.413 align:middle
它就像受到重力
影响一样落下来

00:01:53.780 --> 00:01:55.883 align:middle
现在 它并不会直接
从电话底部消失

00:01:56.083 --> 00:01:57.851 align:middle
相反 它先在底部边缘停止

00:01:57.985 --> 00:01:59.686 align:middle
再稍稍向上反弹 然后停在那里

00:02:00.287 --> 00:02:02.823 align:middle
现在 让我们看一看如何
创建这个基本示例

00:02:03.457 --> 00:02:06.059 align:middle
首先你需要先选定一个很好
的参考视图

00:02:06.326 --> 00:02:08.228 align:middle
在这里 我们选择
视图控制器的视图

00:02:08.294 --> 00:02:09.596 align:middle
其中包含我们的滑动视图

00:02:11.131 --> 00:02:12.766 align:middle
选择引用视图后 我们要

00:02:12.833 --> 00:02:15.602 align:middle
创建一个动态动画并
将它与引用视图关联

00:02:16.136 --> 00:02:18.639 align:middle
这段动态动画
为我们的动画

00:02:18.705 --> 00:02:21.775 align:middle
保持整体背景 它的
主要作用是跟踪

00:02:21.842 --> 00:02:23.544 align:middle
行为和动态项目

00:02:24.711 --> 00:02:27.281 align:middle
对于滑动的例子
我们有一个滑动行为

00:02:27.714 --> 00:02:30.050 align:middle
UI动态行为的
伟大之处之一

00:02:30.450 --> 00:02:32.286 align:middle
是更高层次的行为
可以由相对原始

00:02:32.352 --> 00:02:33.220 align:middle
的行为组成

00:02:34.087 --> 00:02:36.456 align:middle
所以我们的滑动
行为只不过是

00:02:36.523 --> 00:02:38.792 align:middle
重力 碰撞 附件
的组合作品

00:02:39.760 --> 00:02:41.195 align:middle
稍后 我们将向大家展示

00:02:41.261 --> 00:02:44.531 align:middle
我们如何使用UIAttachmen
Behavior和增加的新组件

00:02:44.598 --> 00:02:45.899 align:middle
让滑动
比过去更简单

00:02:47.534 --> 00:02:48.936 align:middle
所以一旦我们
有滑动的行为

00:02:49.036 --> 00:02:50.504 align:middle
我们就需要一个动态的项目

00:02:50.971 --> 00:02:53.574 align:middle
这里我们选择了
滑动视图

00:02:53.941 --> 00:02:56.276 align:middle
它只是一个自动符合动态项
协议的UIView

00:02:56.410 --> 00:02:57.511 align:middle
所以这是一个很好的选择

00:02:57.845 --> 00:02:59.913 align:middle
然后我们选择
动态项 将它与

00:02:59.980 --> 00:03:01.281 align:middle
滑动行为关联 将滑动行为

00:02:59.980 --> 00:03:01.281 align:middle
滑动行为关联 将滑动行为

00:03:01.348 --> 00:03:02.816 align:middle
和animator组件关联

00:03:03.450 --> 00:03:05.886 align:middle
现在animator组件
将自动确定

00:03:05.953 --> 00:03:08.555 align:middle
系统静止或运动的时间
这是要创建这个

00:03:08.622 --> 00:03:10.057 align:middle
伟大的效果你所需要的全部条件

00:03:12.025 --> 00:03:13.527 align:middle
现在我们已经看过了一个基本示范

00:03:14.494 --> 00:03:16.730 align:middle
这就是今年UIKit
dynamics的新变化

00:03:17.431 --> 00:03:18.265 align:middle
我们支持

00:03:18.332 --> 00:03:21.034 align:middle
UIDynamicItem的
非矩形碰撞结合

00:03:21.802 --> 00:03:24.238 align:middle
我们有一个全新的
UIDynamicItemGroup

00:03:24.304 --> 00:03:26.907 align:middle
允许多个项目
就像引擎中的一个部件

00:03:28.141 --> 00:03:29.543 align:middle
一样运转 我们
还有一个全新的

00:03:29.776 --> 00:03:31.178 align:middle
模拟向量力场的行为

00:03:32.746 --> 00:03:35.983 align:middle
我们对UIDynamicItemBehavior
以及UISnapBehavior进行了

00:03:36.049 --> 00:03:37.484 align:middle
一些基础性的优化处理

00:03:38.018 --> 00:03:40.687 align:middle
我们会看到UIAttachmentBehavior
新增了一些很好的功能

00:03:41.355 --> 00:03:43.991 align:middle
我们最后还将介绍
一些新的方法 你们可以

00:03:44.057 --> 00:03:46.093 align:middle
用这些方法调试动画

00:03:49.263 --> 00:03:52.499 align:middle
所以 在iOS 9里 我们
增加了UIDynamicItem

00:03:52.566 --> 00:03:55.569 align:middle
碰撞边界类型
可以提供三个新方法

00:03:55.903 --> 00:03:58.405 align:middle
为动态项指定碰撞边界

00:03:59.506 --> 00:04:02.309 align:middle
在默认情况下你的碰撞
边界是矩形

00:03:59.506 --> 00:04:02.309 align:middle
在默认情况下你的碰撞
边界是矩形

00:04:02.509 --> 00:04:04.811 align:middle
与边界数据访问器
返回的动态项目协议

00:04:05.078 --> 00:04:06.246 align:middle
匹配

00:04:07.381 --> 00:04:10.417 align:middle
现在你可以指定一个
椭圆类型 它来自

00:04:10.484 --> 00:04:12.920 align:middle
协议中的边界
宽度和高度

00:04:13.820 --> 00:04:17.024 align:middle
最后 你可以指定
一个UI BezierPath用于

00:04:17.089 --> 00:04:18.524 align:middle
动态项的碰撞边界

00:04:20.761 --> 00:04:23.597 align:middle
现在 为了实现这一点 我们采用了
现有的动态项目协议

00:04:23.664 --> 00:04:27.067 align:middle
并已经延长两个可选属性

00:04:27.401 --> 00:04:28.435 align:middle
如果你不
应用这两个

00:04:28.502 --> 00:04:30.871 align:middle
可选属性中的任何一个
你将像过去一样

00:04:30.938 --> 00:04:32.372 align:middle
遭遇到矩形碰撞边界

00:04:33.273 --> 00:04:35.409 align:middle
如果你执行第一个
碰撞边界类型

00:04:35.542 --> 00:04:37.411 align:middle
并返回椭圆
就将得到一个

00:04:37.511 --> 00:04:39.279 align:middle
基于边界的宽度
和高度的椭圆

00:04:39.980 --> 00:04:42.082 align:middle
如果你执行
第一碰撞边界类型并返回一个路径

00:04:42.149 --> 00:04:43.884 align:middle
我们会将你调回
执行第二个类型

00:04:44.218 --> 00:04:46.820 align:middle
此时您将需要提供
一个UI BezierPath

00:04:46.887 --> 00:04:47.754 align:middle
用于碰撞边界

00:04:48.822 --> 00:04:51.458 align:middle
所以如果我们要模拟
项目之间的

00:04:51.525 --> 00:04:53.894 align:middle
边界不同的碰撞
为保险起见

00:04:53.961 --> 00:04:56.129 align:middle
我们要多做几次
情况可能看起来像这样

00:04:56.630 --> 00:04:58.932 align:middle
这次碰撞看起来
比过去所有项目

00:04:58.999 --> 00:05:00.033 align:middle
都有矩形碰撞边界

00:04:58.999 --> 00:05:00.033 align:middle
都有矩形碰撞边界

00:05:00.100 --> 00:05:02.436 align:middle
的情况下更现实

00:05:04.872 --> 00:05:07.875 align:middle
现在 为碰撞边界
设定路径时有

00:05:07.941 --> 00:05:09.943 align:middle
一些限制
特别是

00:05:10.010 --> 00:05:13.180 align:middle
BezierPath要求必须是凸起
的逆时针模绕

00:05:13.580 --> 00:05:14.815 align:middle
并且非自相交

00:05:15.415 --> 00:05:17.985 align:middle
这些都是非常基本的
如果你仔细想想

00:05:18.785 --> 00:05:19.987 align:middle
也没有什么太花哨的东西

00:05:20.454 --> 00:05:23.457 align:middle
我们还需要记住
当项目在屏幕上时

00:05:23.524 --> 00:05:26.960 align:middle
BezierPath的
00点将代表

00:05:27.461 --> 00:05:28.462 align:middle
动态项的中心点

00:05:30.230 --> 00:05:33.333 align:middle
这就是碰撞边界的更新内容
让我们来谈谈动态项目组

00:05:33.567 --> 00:05:35.936 align:middle
这是进行
多个项目

00:05:36.170 --> 00:05:38.405 align:middle
并使他们作为一项
在底层引擎运行的基本方式

00:05:39.106 --> 00:05:41.842 align:middle
这个项目组
保留每个项目

00:05:42.042 --> 00:05:45.245 align:middle
的位置和各自的
碰撞边界

00:05:45.479 --> 00:05:49.550 align:middle
所以因为这个原因 你应该
把这些项目与一组

00:05:49.850 --> 00:05:51.218 align:middle
而不是单独的行为
关联起来

00:05:51.285 --> 00:05:52.586 align:middle
与其将它们与组
进行关联

00:05:52.986 --> 00:05:54.288 align:middle
将组与
任何行为进行关联

00:05:54.354 --> 00:05:56.223 align:middle
你更倾向于
与animator组件关联

00:05:56.290 --> 00:05:57.891 align:middle
总的来说 这会
把那些行为

00:05:57.958 --> 00:05:58.992 align:middle
强加在项目上

00:05:59.860 --> 00:06:02.462 align:middle
而一个组却不能被
添加到其他组中

00:05:59.860 --> 00:06:02.462 align:middle
而一个组却不能被
添加到其他组中

00:06:02.529 --> 00:06:03.897 align:middle
这是一个一级抽象

00:06:04.598 --> 00:06:07.668 align:middle
所以要创建凹形或其他

00:06:07.734 --> 00:06:10.737 align:middle
复杂的不能用动
态项目边界路径创建的几何结构

00:06:11.338 --> 00:06:13.941 align:middle
而且总体来说行为能够有此影响

00:06:14.341 --> 00:06:15.809 align:middle
要做
到这些 这是一个很好的方式

00:06:17.077 --> 00:06:19.313 align:middle
那么 让我们暂时
回到滑动示例

00:06:21.481 --> 00:06:24.418 align:middle
我们希望实现更丰富的滑动效果
而不仅仅是简单的平移和回落

00:06:24.484 --> 00:06:27.154 align:middle
比如我们让屏幕
在用户触碰时轻微跳动

00:06:27.221 --> 00:06:28.522 align:middle
显示可以平移

00:06:29.289 --> 00:06:31.124 align:middle
要做到这些 我们只需要

00:06:31.191 --> 00:06:33.293 align:middle
给滑动视图添加一个简短的力

00:06:33.894 --> 00:06:34.995 align:middle
这就是那力

00:06:37.130 --> 00:06:40.067 align:middle
所以我们可以在项目
的中心把这个力

00:06:40.334 --> 00:06:44.471 align:middle
作为一个向量进行模拟在项目的中心
向量的长度对应的这个力

00:06:44.538 --> 00:06:47.374 align:middle
的长度 向量指向上方以说明

00:06:47.441 --> 00:06:49.743 align:middle
这个力的方向 在本例中我们要

00:06:49.810 --> 00:06:51.578 align:middle
向上移动视图 所以这个力指向上方

00:06:52.379 --> 00:06:55.382 align:middle
为了应用这个力我们就要使用
UIPushBehavior

00:06:56.083 --> 00:06:58.118 align:middle
你还记得的话
UIPushBehavior

00:06:58.185 --> 00:06:59.486 align:middle
有两种截然不同的模式

00:06:59.887 --> 00:07:02.990 align:middle
它有一个连续模式
代表了一种跨越时间的力

00:06:59.887 --> 00:07:02.990 align:middle
它有一个连续模式
代表了一种跨越时间的力

00:07:03.056 --> 00:07:05.492 align:middle
另一个模式是瞬时模式

00:07:05.993 --> 00:07:08.395 align:middle
代表一个简短的瞬间的力

00:07:08.529 --> 00:07:09.730 align:middle
或者称为一个脉冲

00:07:10.597 --> 00:07:13.667 align:middle
对于这种交互 我们
只需要一个简短的力 它会反弹回来

00:07:13.734 --> 00:07:15.135 align:middle
然后静止
所以我们要

00:07:15.202 --> 00:07:16.136 align:middle
使用瞬时模式

00:07:16.537 --> 00:07:18.272 align:middle
我们这样做就
得到一个简短的力

00:07:18.338 --> 00:07:20.407 align:middle
但是什么使视图回来？

00:07:20.474 --> 00:07:22.476 align:middle
我们给它一个力
使它向上移动

00:07:22.543 --> 00:07:24.011 align:middle
但它却回落下来

00:07:24.778 --> 00:07:28.382 align:middle
这是我们的复合行为
是由重力

00:07:28.448 --> 00:07:29.750 align:middle
碰撞和附件构成的

00:07:30.083 --> 00:07:31.818 align:middle
所以是重力
使其移动下来

00:07:31.885 --> 00:07:33.487 align:middle
然后它再以
碰撞行为反弹

00:07:34.121 --> 00:07:35.856 align:middle
但让我们来
多了解一些重力

00:07:35.923 --> 00:07:37.324 align:middle
以及它如何影响
我们的项目

00:07:38.091 --> 00:07:39.993 align:middle
我们从开始
施加脉冲力的瞬间

00:07:40.661 --> 00:07:42.963 align:middle
来看滑动视图

00:07:43.030 --> 00:07:44.498 align:middle
的垂直运动

00:07:44.932 --> 00:07:47.401 align:middle
你会发现
这个力是作用于一个点

00:07:47.601 --> 00:07:50.070 align:middle
然后项目向上移动
再以弧形回落

00:07:50.804 --> 00:07:53.073 align:middle
这是因为在我们的
图表中重力

00:07:53.140 --> 00:07:54.575 align:middle
无时无地
不在影响它

00:07:54.875 --> 00:07:57.578 align:middle
如果我们把这些力与重力相加
情况看起来

00:07:57.644 --> 00:08:01.815 align:middle
可能像这样
这个力是应用于

00:07:57.644 --> 00:08:01.815 align:middle
可能像这样
这个力是应用于

00:08:01.882 --> 00:08:03.417 align:middle
所有位置和时间的

00:08:03.617 --> 00:08:04.985 align:middle
所以不容易模拟

00:08:05.419 --> 00:08:07.354 align:middle
也许我们可以试着
使用UI来推动行为

00:08:07.454 --> 00:08:09.289 align:middle
但是这会非常
复杂的 而且很快

00:08:09.990 --> 00:08:12.492 align:middle
所以我们需要更多地
把重力当作一个场加以思考

00:08:13.360 --> 00:08:15.495 align:middle
场非常简单
它只是一个函数

00:08:15.729 --> 00:08:18.832 align:middle
在指定的定义域内
给每一个点分配一个向量

00:08:18.999 --> 00:08:20.701 align:middle
在这个例子中
我们的定义域

00:08:20.767 --> 00:08:21.935 align:middle
是整个参考视图

00:08:22.236 --> 00:08:24.605 align:middle
所以我们希望重力
在整个参考视图里

00:08:24.938 --> 00:08:26.006 align:middle
影响滑动视图

00:08:26.840 --> 00:08:27.674 align:middle
特别简单

00:08:27.875 --> 00:08:30.677 align:middle
所以我们采用了这个场
的想法 并加以扩展

00:08:31.011 --> 00:08:33.780 align:middle
在iOS 9中 我们引入了
UIFieldBehavior

00:08:34.780 --> 00:08:36.283 align:middle
UIFieldBehavior

00:08:36.350 --> 00:08:38.150 align:middle
是一个
可以添加到参考视图的

00:08:38.217 --> 00:08:42.222 align:middle
一个区域中的方法
场在参考视图之内的

00:08:42.289 --> 00:08:43.222 align:middle
每一个点都被赋值

00:08:43.289 --> 00:08:46.393 align:middle
任何产生的力量

00:08:46.460 --> 00:08:48.195 align:middle
自动被动态animator组件应用

00:08:48.262 --> 00:08:49.530 align:middle
到已经与场关联的
项目中

00:08:51.164 --> 00:08:54.134 align:middle
如果你在想
我们现有的UIGravityBehavior

00:08:54.535 --> 00:08:56.203 align:middle
被作为一个场实施

00:08:57.504 --> 00:08:58.805 align:middle
重要的是还要记住

00:08:58.872 --> 00:09:00.073 align:middle
这是简化的物理

00:08:58.872 --> 00:09:00.073 align:middle
这是简化的物理

00:09:00.140 --> 00:09:01.642 align:middle
为适应这个展示进行了调整

00:09:02.009 --> 00:09:03.744 align:middle
我不会用它来建造

00:09:03.810 --> 00:09:05.312 align:middle
星际空间站
或类似的东西

00:09:06.747 --> 00:09:09.283 align:middle
让我们看一看内置场的类型

00:09:09.483 --> 00:09:10.684 align:middle
这里种类非常丰富

00:09:10.784 --> 00:09:12.686 align:middle
有线性和放射重力场、

00:09:12.753 --> 00:09:14.254 align:middle
速度和阻力场、

00:09:14.321 --> 00:09:17.191 align:middle
涡流场以及依据胡克定律的弹簧场

00:09:17.257 --> 00:09:18.525 align:middle
还有电场

00:09:18.592 --> 00:09:20.460 align:middle
和磁场

00:09:21.328 --> 00:09:23.096 align:middle
如果还不能满足你的需要

00:09:23.163 --> 00:09:24.998 align:middle
我们也提供自定义力鉴别器

00:09:25.065 --> 00:09:26.033 align:middle
此话题我们稍后再叙

00:09:26.466 --> 00:09:28.335 align:middle
我们先从线性重力开始

00:09:29.369 --> 00:09:31.371 align:middle
我们首先会注意到它处于一个区域内

00:09:31.638 --> 00:09:33.440 align:middle
就像我们之前讲的那样

00:09:33.907 --> 00:09:36.476 align:middle
而且它有场强
我们使用默认值1

00:09:36.810 --> 00:09:38.412 align:middle
它也是一个方向作用力

00:09:38.478 --> 00:09:41.548 align:middle
我们使用熟悉的重力方向

00:09:42.082 --> 00:09:43.317 align:middle
举例

00:09:43.550 --> 00:09:46.119 align:middle
但它实际可以指向任何方向

00:09:46.720 --> 00:09:50.324 align:middle
让我们看一看放射重力和
线性重力的区别

00:09:51.058 --> 00:09:55.729 align:middle
除存在于一个区域并且有场强外

00:09:55.796 --> 00:09:59.900 align:middle
这儿有一个位置作为一个质点
用放射重力可以模拟

00:10:00.467 --> 00:10:02.503 align:middle
如你所知

00:10:02.569 --> 00:10:04.838 align:middle
两个物体之间重力

00:10:04.905 --> 00:10:09.076 align:middle
与距离的平方成反比

00:10:09.343 --> 00:10:11.945 align:middle
这儿是物体之间距离的平方

00:10:12.012 --> 00:10:14.781 align:middle
这个指数是场的衰减值

00:10:15.148 --> 00:10:17.351 align:middle
距离场的位置越远

00:10:17.851 --> 00:10:21.255 align:middle
场产生的作用力就会减小

00:10:21.822 --> 00:10:23.824 align:middle
这儿也有最小半径

00:10:24.324 --> 00:10:29.296 align:middle
这一方法可以确定
一个物体距离位置点多远

00:10:29.363 --> 00:10:31.832 align:middle
才可以感受到场的作用力

00:10:33.333 --> 00:10:35.002 align:middle
我们还有一个噪声场

00:10:35.502 --> 00:10:37.404 align:middle
在这方面我们注意到的第一个问题是

00:10:37.471 --> 00:10:40.874 align:middle
它随着时间变化 你可以使用动画速度

00:10:40.941 --> 00:10:42.476 align:middle
来调节 默认值为1

00:10:42.809 --> 00:10:44.311 align:middle
0表示静态场

00:10:45.012 --> 00:10:46.914 align:middle
你也可以使用平滑参数

00:10:46.980 --> 00:10:48.448 align:middle
调节噪声程度

00:10:50.717 --> 00:10:52.486 align:middle
让我们看一看自定义场鉴别器

00:10:53.287 --> 00:10:54.721 align:middle
使用起来非常简单

00:10:54.788 --> 00:10:59.026 align:middle
先使用场鉴别框创建一个
UIFieldBehavior并初始化

00:10:59.693 --> 00:11:02.996 align:middle
然后就可以调用该框
使用几个场取样包含相关取样位置

00:10:59.693 --> 00:11:02.996 align:middle
然后就可以调用该框
使用几个场取样包含相关取样位置

00:11:03.163 --> 00:11:05.999 align:middle
速度、质量、负载以及时间

00:11:06.066 --> 00:11:08.368 align:middle
下来你就可以使用它来

00:11:08.435 --> 00:11:10.537 align:middle
判断任何作用力

00:11:11.004 --> 00:11:13.574 align:middle
这里我们需要做的是选择位置 x位置

00:11:13.941 --> 00:11:15.075 align:middle
然后绘成正弦波

00:11:15.676 --> 00:11:16.510 align:middle
一个很酷的结果

00:11:17.878 --> 00:11:20.380 align:middle
这是一些基本的内置场

00:11:20.447 --> 00:11:22.382 align:middle
和UIFieldBehavior
的概述

00:11:22.616 --> 00:11:25.018 align:middle
我想邀请大卫

00:11:25.252 --> 00:11:26.086 align:middle
举例展示

00:11:33.227 --> 00:11:34.995 align:middle
大家好 我们将

00:11:35.062 --> 00:11:36.597 align:middle
带你体验一个

00:11:36.663 --> 00:11:38.632 align:middle
我相信你们以前都见过的一个例子

00:11:40.534 --> 00:11:43.470 align:middle
我确信你们某个时候
都使用过FaceTime

00:11:43.537 --> 00:11:45.572 align:middle
所以这儿的例子是

00:11:45.672 --> 00:11:47.207 align:middle
创建一个相似的UI

00:11:47.274 --> 00:11:49.977 align:middle
管理屏幕中的脸孔

00:11:51.044 --> 00:11:52.813 align:middle
正如你所看到的 在我滑过这儿时

00:11:53.313 --> 00:11:55.716 align:middle
方框移动顺畅

00:11:55.782 --> 00:11:58.952 align:middle
如果我从角上拉开一点 它会弹回

00:11:59.019 --> 00:12:01.021 align:middle
如果我再拉 它会有

00:11:59.019 --> 00:12:01.021 align:middle
如果我再拉 它会有

00:12:01.088 --> 00:12:02.756 align:middle
漂亮的渐入曲线

00:12:02.823 --> 00:12:05.425 align:middle
如果向下抛 它就会

00:12:05.492 --> 00:12:07.628 align:middle
沿着四周边沿弹开

00:12:08.061 --> 00:12:10.297 align:middle
你会注意到在我向下抛时 它并没有

00:12:10.364 --> 00:12:12.432 align:middle
直接到它应到的地方

00:12:12.666 --> 00:12:14.735 align:middle
实际上有一个物理过程 它会弹离

00:12:14.801 --> 00:12:16.503 align:middle
屏幕边沿并回到原位

00:12:17.704 --> 00:12:22.042 align:middle
现在 我可以产生一个调试视图

00:12:22.109 --> 00:12:23.977 align:middle
看看这些作用力场的样子

00:12:24.578 --> 00:12:25.712 align:middle
这样 你可以看到

00:12:31.685 --> 00:12:33.954 align:middle
这儿
你可以看到我们有四个弹簧场在运行

00:12:34.021 --> 00:12:38.158 align:middle
我们可以很容易地解释所发生的事情

00:12:38.225 --> 00:12:40.227 align:middle
如果我们把这个放在边沿

00:12:40.294 --> 00:12:41.562 align:middle
我们知道它会弹回

00:12:42.462 --> 00:12:44.865 align:middle
如果我们跨越两者 那么根据

00:12:44.932 --> 00:12:47.000 align:middle
我们跨越的位置
它会选择一边或另一边

00:12:47.801 --> 00:12:49.336 align:middle
穿过中间

00:12:49.703 --> 00:12:50.971 align:middle
它会选择最近的一边

00:12:51.538 --> 00:12:52.940 align:middle
让我们看看怎样设置

00:12:53.006 --> 00:12:55.909 align:middle
怎样在实际中独立完成

00:12:58.145 --> 00:13:00.848 align:middle
第一就是建立Sticky
Corners 行为

00:12:58.145 --> 00:13:00.848 align:middle
第一就是建立Sticky
Corners 行为

00:13:01.281 --> 00:13:03.750 align:middle
根据麦克的说法
它是由其它行为构成的

00:13:03.817 --> 00:13:06.320 align:middle
这种复杂的行为可以做完成我们的一切
想法

00:13:06.720 --> 00:13:08.288 align:middle
在这种情况下 它会产生冲突行为

00:13:08.355 --> 00:13:09.456 align:middle
因为我们不想让你的面孔

00:13:09.523 --> 00:13:11.091 align:middle
急速离开屏幕边沿

00:13:11.825 --> 00:13:14.161 align:middle
我们有一个动态的项目行为

00:13:14.228 --> 00:13:16.296 align:middle
可以影响面孔的属性

00:13:16.630 --> 00:13:18.165 align:middle
这样 我们可以减小密度

00:13:18.232 --> 00:13:19.900 align:middle
使引擎具光感

00:13:20.334 --> 00:13:22.870 align:middle
但需要增加其对运动的耐受性 这样

00:13:22.936 --> 00:13:25.272 align:middle
它位于某一地点时
就不会绕着那个位置

00:13:25.339 --> 00:13:26.373 align:middle
不断旋转

00:13:27.140 --> 00:13:28.809 align:middle
最后我们禁用旋转

00:13:28.876 --> 00:13:29.910 align:middle
因为这样做没有意义

00:13:29.977 --> 00:13:31.011 align:middle
你并不想让自己的面孔

00:13:31.078 --> 00:13:32.145 align:middle
在屏幕中旋转

00:13:33.947 --> 00:13:35.749 align:middle
最后我们有个这些场行为

00:13:35.816 --> 00:13:38.852 align:middle
四个弹簧场标出了四个角

00:13:38.952 --> 00:13:40.587 align:middle
我们也把它们增添到行为中

00:13:40.988 --> 00:13:44.525 align:middle
现在无论什么时候人们增添这种
StickyCorners 行为

00:13:44.625 --> 00:13:46.260 align:middle
都会免费得到这种行为

00:13:48.629 --> 00:13:50.397 align:middle
接下来 看看视图控制器

00:13:50.964 --> 00:13:53.634 align:middle
我们去看一看建立视图层级需要的一切

00:13:54.368 --> 00:13:56.336 align:middle
但还需增添一个拖动手势识别器

00:13:56.403 --> 00:13:58.605 align:middle
这样 用户可以选择面孔

00:13:58.672 --> 00:13:59.773 align:middle
并在屏幕移动

00:14:00.974 --> 00:14:03.410 align:middle
长按手势识别器则会使我们

00:14:03.477 --> 00:14:05.312 align:middle
开关调试界面

00:14:05.913 --> 00:14:07.281 align:middle
我们创建动态仿真器

00:14:07.447 --> 00:14:09.783 align:middle
并增添StickyCorners行
为

00:14:10.184 --> 00:14:12.252 align:middle
手势识别器是如何工作的？

00:14:12.753 --> 00:14:15.289 align:middle
像往常一样
手势识别在状态之间进行

00:14:15.355 --> 00:14:19.993 align:middle
它从begin开始
开始后 我们做一些记账

00:14:20.060 --> 00:14:23.263 align:middle
这样我们可以跟踪进展但我们也需要禁
用sticky behavior

00:14:23.330 --> 00:14:24.698 align:middle
我马上会演示我们是怎样做的

00:14:25.365 --> 00:14:27.835 align:middle
同样 当它变化时 我们向四周移动

00:14:28.502 --> 00:14:30.137 align:middle
当它取消或结束时

00:14:30.504 --> 00:14:32.072 align:middle
这是比较特殊的地方

00:14:32.573 --> 00:14:35.442 align:middle
当用户停止互动时

00:14:35.509 --> 00:14:37.377 align:middle
我们检查拖动手势识别器的速度

00:14:37.911 --> 00:14:40.247 align:middle
并使用它把速度增添到

00:14:40.314 --> 00:14:41.715 align:middle
动态体系中

00:14:41.782 --> 00:14:44.551 align:middle
这样 当用户离开视图时

00:14:44.718 --> 00:14:47.521 align:middle
它会继续随用户的动作而移动

00:14:47.754 --> 00:14:49.623 align:middle
而不是突然停止并

00:14:49.690 --> 00:14:51.058 align:middle
由场完全接管

00:14:51.725 --> 00:14:53.026 align:middle
禁用和启用

00:14:53.093 --> 00:14:54.494 align:middle
都是由于相同的理由

00:14:54.828 --> 00:14:56.196 align:middle
在用户在活动中时

00:14:56.263 --> 00:14:57.965 align:middle
我们不想让这些场处于活跃状态

00:14:58.031 --> 00:14:58.899 align:middle
否则它会从我们的

00:14:58.966 --> 00:15:00.100 align:middle
指尖下溜走

00:14:58.966 --> 00:15:00.100 align:middle
指尖下溜走

00:15:01.668 --> 00:15:02.970 align:middle
所以我们再回过来看一下

00:15:03.036 --> 00:15:05.239 align:middle
看看是怎样启用的

00:15:05.806 --> 00:15:07.541 align:middle
的确非常简单

00:15:07.941 --> 00:15:10.544 align:middle
在启用时 我们把所有项目增添到

00:15:10.611 --> 00:15:13.080 align:middle
这些行为中 当禁用时
我们再取出来

00:15:13.380 --> 00:15:16.316 align:middle
创建这样一个系统非常简单

00:15:16.383 --> 00:15:18.519 align:middle
你可以在自己的程序中

00:15:18.719 --> 00:15:20.220 align:middle
建立类似
FaceTime的行为

00:15:20.287 --> 00:15:22.990 align:middle
所以 为了告诉你们如何将调试UI

00:15:23.190 --> 00:15:24.258 align:middle
置入你自己的应用程序

00:15:24.324 --> 00:15:25.726 align:middle
我要让麦克上来帮我一下

00:15:32.733 --> 00:15:33.567 align:middle
谢谢 大卫

00:15:34.101 --> 00:15:37.004 align:middle
真的非常好 在大卫的例子中

00:15:37.070 --> 00:15:38.772 align:middle
为了能够一探究竟

00:15:38.972 --> 00:15:41.508 align:middle
将这些场线可视化了

00:15:41.909 --> 00:15:43.810 align:middle
在他打开它之前 这显得很神秘

00:15:44.611 --> 00:15:47.948 align:middle
所以 在你的动画设计参照视图中

00:15:48.315 --> 00:15:50.150 align:middle
这些线基本是用来显示这个场的叠加图

00:15:51.151 --> 00:15:53.820 align:middle
特别是 这个叠加图能够帮助你将

00:15:54.154 --> 00:15:56.924 align:middle
各个场、碰撞边界、附件 以及

00:15:56.990 --> 00:15:59.092 align:middle
某特定组件是运动还是静止可视化

00:16:00.661 --> 00:16:02.930 align:middle
现在 你可能奇怪 这不会是API

00:16:03.864 --> 00:16:06.767 align:middle
但是它在LLDB中可以存取
而我们也正在把它

00:16:06.834 --> 00:16:09.736 align:middle
作为UIDynamicAnimator上的
一个有效的调试功能加以推广

00:16:09.903 --> 00:16:11.071 align:middle
而且它用起来确实很简单

00:16:11.271 --> 00:16:12.606 align:middle
暂停调试程序

00:16:12.673 --> 00:16:14.208 align:middle
为你的动态动画设计找一个参照

00:16:14.641 --> 00:16:16.076 align:middle
激活调试功能 设定在true

00:16:16.376 --> 00:16:18.979 align:middle
然后你将得到这个漂亮的叠加图
它能够给出所有的物理属性

00:16:24.051 --> 00:16:27.287 align:middle
现在 除了激活和灭活调试功能之外

00:16:27.354 --> 00:16:28.956 align:middle
我们还要给出调试间隔

00:16:29.056 --> 00:16:30.457 align:middle
这样你就可以调整

00:16:30.524 --> 00:16:33.160 align:middle
调试叠加图更新的时间间隔了

00:16:33.460 --> 00:16:35.229 align:middle
所以 默认情况下

00:16:35.295 --> 00:16:37.030 align:middle
每个动画帧都会更新
但是如果你有许多

00:16:37.097 --> 00:16:39.867 align:middle
复杂的物理属性 那么可能

00:16:39.933 --> 00:16:41.034 align:middle
例如 最好把间隔改为5

00:16:41.101 --> 00:16:43.237 align:middle
即只是每到第5帧才更新

00:16:44.238 --> 00:16:47.274 align:middle
同时 我们还允许你调节

00:16:47.341 --> 00:16:48.442 align:middle
动态动画设计的动画速度

00:16:48.909 --> 00:16:51.078 align:middle
此时放慢速度可能有利于

00:16:51.211 --> 00:16:52.746 align:middle
观察真实的过程

00:16:53.046 --> 00:16:55.582 align:middle
之后 重要的是要记住 在使用时

00:16:56.116 --> 00:16:57.951 align:middle
如果放慢速度

00:16:58.252 --> 00:16:59.219 align:middle
可能会影响模拟效果

00:16:59.286 --> 00:17:00.854 align:middle
所以一定要确保以1x修正

00:16:59.286 --> 00:17:00.854 align:middle
所以一定要确保以1x修正

00:17:03.490 --> 00:17:06.693 align:middle
那么接下来让我们谈谈
UIDynamicItemBehavior

00:17:06.827 --> 00:17:08.127 align:middle
现在 如果你再次调用

00:17:08.194 --> 00:17:11.498 align:middle
可改变你的视图或动态道具的物理属性

00:17:12.031 --> 00:17:14.535 align:middle
这适用于一个或多个动态道具

00:17:15.035 --> 00:17:16.403 align:middle
在大卫的例子中

00:17:16.470 --> 00:17:18.505 align:middle
他为FaceTime方块选用了低密
度

00:17:18.571 --> 00:17:20.641 align:middle
及高阻力

00:17:20.941 --> 00:17:22.776 align:middle
使其牢牢固定于场的角点

00:17:23.510 --> 00:17:26.012 align:middle
就现有特性 在此多举几个例子

00:17:26.079 --> 00:17:29.883 align:middle
我们有弹性、摩擦力
我们看到了密度和阻力

00:17:29.950 --> 00:17:32.052 align:middle
我们有角阻力 这些都可调节

00:17:32.386 --> 00:17:34.821 align:middle
你的道具在动画引擎中的状态

00:17:35.522 --> 00:17:38.792 align:middle
在iOS 9中
我们增加了两个性能

00:17:38.959 --> 00:17:41.995 align:middle
这影响你的道具

00:17:42.062 --> 00:17:44.131 align:middle
在我们新型电场和磁场中的参与度；

00:17:44.464 --> 00:17:46.466 align:middle
我们还增加了anchored属性

00:17:47.034 --> 00:17:48.001 align:middle
这个略有不同

00:17:48.502 --> 00:17:51.038 align:middle
但是它能让你的道具

00:17:51.104 --> 00:17:54.474 align:middle
参与动态系统 参与碰撞

00:17:54.541 --> 00:17:56.677 align:middle
不过没有自己的速度

00:17:56.743 --> 00:17:59.112 align:middle
所以更像是碰撞边界

00:18:00.280 --> 00:18:01.181 align:middle
那么接下来

00:18:01.248 --> 00:18:03.650 align:middle
我要谈谈UIAttachmentB
ehavior

00:18:03.917 --> 00:18:06.386 align:middle
这让你能够约束两个动态道具

00:18:06.453 --> 00:18:09.156 align:middle
从而让它们彼此
保持特定的距离

00:18:09.690 --> 00:18:13.060 align:middle
你可以利用阻尼和频率进行配置

00:18:13.360 --> 00:18:16.129 align:middle
让它更像一个弹簧 而不是连杆

00:18:16.763 --> 00:18:18.098 align:middle
这是一个很好的附件

00:18:18.165 --> 00:18:20.901 align:middle
你知道 它很有用 但是你也确实

00:18:20.968 --> 00:18:23.203 align:middle
只有一个办法来约束两个道具

00:18:24.438 --> 00:18:27.474 align:middle
所以 在iOS
9中 我们增加了更多附件类型

00:18:28.308 --> 00:18:29.877 align:middle
第一个是限制附件

00:18:30.477 --> 00:18:32.446 align:middle
这与刚讲到的距离附件很像

00:18:32.513 --> 00:18:35.415 align:middle
但不是我们能想到的

00:18:35.482 --> 00:18:37.751 align:middle
像一个连杆或弹簧一样受约束

00:18:38.252 --> 00:18:40.821 align:middle
而是更像两个道具间的一根绳子

00:18:40.921 --> 00:18:43.624 align:middle
唯一约束是彼此间的
最大距离

00:18:44.658 --> 00:18:46.827 align:middle
你对它的配置类似于距离附件

00:18:47.127 --> 00:18:49.863 align:middle
规定从每个道具中心偏移出的两个点

00:18:50.631 --> 00:18:51.465 align:middle
很简单

00:18:51.965 --> 00:18:53.500 align:middle
接下来是一个固定的附件

00:18:54.468 --> 00:18:57.104 align:middle
这与限制附件或距离附件
略有不同

00:18:57.704 --> 00:19:01.041 align:middle
在你创建这种类型的附件时
首先规定一个锚点

00:18:57.704 --> 00:19:01.041 align:middle
在你创建这种类型的附件时
首先规定一个锚点

00:19:01.375 --> 00:19:04.178 align:middle
就每个道具中心而言 这个锚点

00:19:05.012 --> 00:19:07.181 align:middle
位于你的参照视图坐标空间

00:19:08.148 --> 00:19:12.319 align:middle
而这类附件无论如何不会
在两个道具之间运动

00:19:12.653 --> 00:19:18.725 align:middle
相对于允许道具端部旋转的连杆
它更像是两道具间的焊接杆

00:19:20.360 --> 00:19:22.462 align:middle
我们还增加了一种锁销附件

00:19:23.363 --> 00:19:25.399 align:middle
这个类似于固定附件

00:19:25.465 --> 00:19:29.036 align:middle
即你可以
先在两个道具间规定一个锚点

00:19:30.070 --> 00:19:34.441 align:middle
但是这种类型附件允许两个道具
围绕这个锚点在彼此之间旋转

00:19:35.008 --> 00:19:39.379 align:middle
这样你可以规定一个旋转范围
默认状态下无界

00:19:39.680 --> 00:19:42.482 align:middle
但是我们可以给出界限
如缩小范围

00:19:43.417 --> 00:19:46.186 align:middle
最后我们增加了一个滑动附件

00:19:46.787 --> 00:19:49.489 align:middle
这个滑动附件有点复杂

00:19:49.556 --> 00:19:51.058 align:middle
我们等一下看一个例子

00:19:51.558 --> 00:19:53.627 align:middle
和固定附件及锁销附件一样

00:19:53.694 --> 00:19:56.063 align:middle
我们先在参照视图坐标空间

00:19:56.129 --> 00:19:57.631 align:middle
规定附件锚点

00:19:58.866 --> 00:20:00.334 align:middle
但是与这两个类型不同 我们还要

00:19:58.866 --> 00:20:00.334 align:middle
但是与这两个类型不同 我们还要

00:20:00.400 --> 00:20:02.436 align:middle
规定一个平移轴

00:20:02.903 --> 00:20:04.805 align:middle
这里 两个道具之间

00:20:04.872 --> 00:20:07.574 align:middle
相对运动都将沿着这个平移轴

00:20:08.342 --> 00:20:11.245 align:middle
这个类型的附件可阻止两个道具
所有的相对旋转

00:20:11.311 --> 00:20:13.614 align:middle
所以 两个道具不能再旋转

00:20:13.680 --> 00:20:16.550 align:middle
只能沿着这个平移轴
运动

00:20:17.818 --> 00:20:18.852 align:middle
但像锁销附件一样

00:20:19.186 --> 00:20:21.121 align:middle
你可以限制平移范围

00:20:21.288 --> 00:20:23.090 align:middle
这样 如果你规定了一个平移范围

00:20:23.423 --> 00:20:25.559 align:middle
就要把附件锚点

00:20:26.093 --> 00:20:27.494 align:middle
放在确定为范围零点的

00:20:27.561 --> 00:20:29.162 align:middle
锚点位置

00:20:29.897 --> 00:20:32.132 align:middle
所以
如果我们以这种类型附件建立该系统

00:20:32.799 --> 00:20:33.967 align:middle
我们就能够得到

00:20:34.034 --> 00:20:35.569 align:middle
两个道具间直线运动
就是这样

00:20:36.470 --> 00:20:37.437 align:middle
所以 相当复杂

00:20:37.504 --> 00:20:38.906 align:middle
让我们看一个基本示例

00:20:39.940 --> 00:20:41.308 align:middle
为此 我想

00:20:41.375 --> 00:20:43.243 align:middle
再次回到滑动的例子

00:20:44.478 --> 00:20:46.647 align:middle
是说过在过去 如果我们

00:20:46.713 --> 00:20:49.583 align:middle
使其可滑动 将必须

00:20:49.650 --> 00:20:51.985 align:middle
在底部
每一侧以及顶部离开屏面的某处

00:20:52.052 --> 00:20:53.887 align:middle
增加一个碰撞

00:20:54.188 --> 00:20:55.222 align:middle
以限制滑动视图

00:20:55.455 --> 00:20:57.424 align:middle
沿着垂直轴的运动

00:20:58.025 --> 00:21:00.294 align:middle
那么
有了UI附件 我们再无需如此

00:20:58.025 --> 00:21:00.294 align:middle
那么
有了UI附件 我们再无需如此

00:21:00.360 --> 00:21:02.763 align:middle
我们用滑动附件就能做到

00:21:03.030 --> 00:21:04.798 align:middle
所以 我们把系统控制在一次碰撞

00:21:05.165 --> 00:21:06.166 align:middle
使其表现更佳

00:21:06.433 --> 00:21:08.135 align:middle
而代码确实更易读

00:21:08.902 --> 00:21:10.537 align:middle
所以 如果我们在此激活调试视图

00:21:10.971 --> 00:21:13.307 align:middle
你就能够看到

00:21:13.373 --> 00:21:15.375 align:middle
通过沿垂直轴的直线描画的滑动附件

00:21:15.442 --> 00:21:18.412 align:middle
它随我们滑动视图而缩放

00:21:18.879 --> 00:21:20.480 align:middle
但是同时还有一个附件

00:21:20.848 --> 00:21:23.717 align:middle
即距离附件 我们用它

00:21:23.784 --> 00:21:25.586 align:middle
通过一个平移手势识别器

00:21:25.652 --> 00:21:26.820 align:middle
附于一个操控锚点

00:21:27.321 --> 00:21:29.556 align:middle
所以 不同于大卫的演示

00:21:29.623 --> 00:21:30.624 align:middle
这个完全在动态系统内

00:21:30.691 --> 00:21:32.659 align:middle
我们不做任何禁用或启动

00:21:32.826 --> 00:21:33.760 align:middle
我们只是保持动态

00:21:34.361 --> 00:21:35.195 align:middle
好极了

00:21:35.829 --> 00:21:36.897 align:middle
所以最后

00:21:36.964 --> 00:21:39.733 align:middle
让我在UISnapBehav
ior上为你做一个快速更新

00:21:39.800 --> 00:21:42.503 align:middle
如果再次你调用UISnapBeha
vior 它能做的更多

00:21:42.803 --> 00:21:46.139 align:middle
它可以被用来将一个视图从一个位置
移动到另一个位置

00:21:46.206 --> 00:21:47.107 align:middle
并有一种快动效果

00:21:47.941 --> 00:21:50.244 align:middle
通过SnapBehavior
你可以定制快拍阻尼

00:21:50.310 --> 00:21:53.113 align:middle
这样确实可以调节

00:21:53.180 --> 00:21:54.815 align:middle
感觉上的快慢

00:21:55.616 --> 00:21:58.018 align:middle
在iOS 9中 我们也新增了

00:21:58.085 --> 00:22:00.220 align:middle
初始化后定制捕捉点的功能

00:21:58.085 --> 00:22:00.220 align:middle
初始化后定制捕捉点的功能

00:22:00.287 --> 00:22:01.822 align:middle
同样相当不错

00:22:02.089 --> 00:22:03.357 align:middle
这里让我看一个简单的例子

00:22:03.991 --> 00:22:08.262 align:middle
所以 如果我们试着平移视图
那么打开调试功能

00:22:08.629 --> 00:22:11.598 align:middle
就会回到如最初捕捉点的屏面

00:22:12.032 --> 00:22:14.601 align:middle
如果我们轻敲另一个位置
就会对齐到新点

00:22:14.701 --> 00:22:16.203 align:middle
即在现有动态特性基础上

00:22:16.503 --> 00:22:18.105 align:middle
调节捕捉点

00:22:18.472 --> 00:22:19.306 align:middle
相当不错

00:22:19.640 --> 00:22:22.976 align:middle
你还会注意到 有了调试叠加图

00:22:23.544 --> 00:22:25.646 align:middle
这些实际上都是自行合成

00:22:25.712 --> 00:22:29.082 align:middle
这里4个附件 配置如弹簧

00:22:29.516 --> 00:22:31.885 align:middle
把视图对齐到新位置

00:22:31.952 --> 00:22:32.786 align:middle
确实非常棒

00:22:33.554 --> 00:22:34.388 align:middle
所以 这就是

00:22:34.454 --> 00:22:36.857 align:middle
UIKit Dynamics
和iOS 9中新增的内容

00:22:37.391 --> 00:22:38.759 align:middle
我要把它交给大卫

00:22:38.825 --> 00:22:39.927 align:middle
让他谈谈视觉效果

00:22:46.500 --> 00:22:47.334 align:middle
各位早上好

00:22:47.734 --> 00:22:49.870 align:middle
那么我们接下来要谈谈利用视觉效果

00:22:49.937 --> 00:22:51.471 align:middle
为你的应用增加新模式

00:22:52.272 --> 00:22:56.009 align:middle
那么我们用一个简单的图像浏览器应用
示例来形象地加以说明

00:22:56.343 --> 00:23:00.180 align:middle
这里 我们要
向用户额外介绍一下

00:22:56.343 --> 00:23:00.180 align:middle
这里 我们要
向用户额外介绍一下

00:23:00.247 --> 00:23:01.748 align:middle
他们目前正在看的图片

00:23:02.316 --> 00:23:05.519 align:middle
看右边 图像上面

00:23:05.586 --> 00:23:06.553 align:middle
有点叠加部分

00:23:06.620 --> 00:23:09.122 align:middle
是我们图像的文件名

00:23:09.690 --> 00:23:11.892 align:middle
所以我们要看看如何创建

00:23:13.160 --> 00:23:15.229 align:middle
那么 第一步是你要

00:23:15.295 --> 00:23:16.330 align:middle
形成一种模糊效果

00:23:16.864 --> 00:23:19.199 align:middle
我们有3种模式 超亮、

00:23:19.299 --> 00:23:20.467 align:middle
明亮及阴暗模式

00:23:22.302 --> 00:23:25.172 align:middle
你通过这些模式形成一种模糊效果

00:23:25.572 --> 00:23:27.341 align:middle
就是那样

00:23:27.908 --> 00:23:30.444 align:middle
最后 你用模糊模式形成

00:23:30.611 --> 00:23:31.712 align:middle
你的视觉效果图

00:23:32.312 --> 00:23:34.248 align:middle
之后只要添加你需要的布局

00:23:34.548 --> 00:23:36.350 align:middle
你就能够得到屏面上你看到的模糊效果

00:23:38.085 --> 00:23:39.820 align:middle
下一步 我们要添加振动效果

00:23:39.887 --> 00:23:42.523 align:middle
振动的作用是 使某物在模糊模式

00:23:42.589 --> 00:23:44.958 align:middle
突然弹出

00:23:46.159 --> 00:23:47.928 align:middle
所以接下来 我们要

00:23:47.995 --> 00:23:49.763 align:middle
通过模糊效果形成振动效果

00:23:49.930 --> 00:23:51.698 align:middle
如上面提到的 确实要要模糊叠加

00:23:51.765 --> 00:23:54.234 align:middle
所以我们从模糊效果开始

00:23:54.301 --> 00:23:55.536 align:middle
形成振动效果

00:23:56.603 --> 00:23:57.905 align:middle
我们形成振动效果

00:23:57.971 --> 00:23:59.173 align:middle
正如我们之前形成模糊效果

00:24:00.174 --> 00:24:01.742 align:middle
此时 我们要

00:24:01.808 --> 00:24:04.278 align:middle
在模糊视图中添加内容视图

00:24:04.344 --> 00:24:07.147 align:middle
现在 不必直接加到模糊视图上

00:24:07.214 --> 00:24:10.384 align:middle
而应是在视觉效果图后

00:24:10.450 --> 00:24:11.351 align:middle
有一个模糊视图

00:24:12.419 --> 00:24:14.288 align:middle
最后 我们

00:24:14.354 --> 00:24:16.223 align:middle
在振动视图的内容视图上加标签

00:24:16.823 --> 00:24:19.326 align:middle
视觉效果图的内容视图上

00:24:19.393 --> 00:24:21.295 align:middle
加这些东西是要确保

00:24:21.361 --> 00:24:23.797 align:middle
你给出的所有内容

00:24:23.864 --> 00:24:24.698 align:middle
效果无误

00:24:26.166 --> 00:24:27.434 align:middle
所以 当你完成这些之后

00:24:27.901 --> 00:24:30.304 align:middle
模糊视图顶部就有了可爱的标签

00:24:30.404 --> 00:24:31.638 align:middle
正如你在屏面上看到的那样

00:24:32.406 --> 00:24:33.907 align:middle
那么iOS 9有什么新东西呢

00:24:34.541 --> 00:24:37.077 align:middle
首先我们使得

00:24:37.144 --> 00:24:40.380 align:middle
你的视图边界有清新的动画效果

00:24:40.848 --> 00:24:42.783 align:middle
在模糊视图中你可以向用户显示更多信
息

00:24:42.850 --> 00:24:45.919 align:middle
而无需做任何复杂的工作

00:24:46.887 --> 00:24:48.689 align:middle
但是 除此之外 我们让你能够

00:24:48.755 --> 00:24:50.057 align:middle
让模糊视图生动有趣

00:24:52.125 --> 00:24:54.728 align:middle
那么现在 比如
如果你的app有夜间加载模式

00:24:54.795 --> 00:24:56.930 align:middle
你在你的应用中可以日夜都采用非常清
新的动画

00:24:56.997 --> 00:24:58.966 align:middle
并推动用户

00:25:00.267 --> 00:25:02.102 align:middle
接下来我们要简要介绍

00:25:02.169 --> 00:25:04.972 align:middle
我们如何切实地把这些效果搬上屏面

00:25:05.072 --> 00:25:08.008 align:middle
它做什么用 以及你为什么需要知道

00:25:08.075 --> 00:25:09.843 align:middle
这很重要 因为所有这些都会影响

00:25:09.910 --> 00:25:11.345 align:middle
性能和修正

00:25:12.145 --> 00:25:13.881 align:middle
这里 小婴儿Sophia带我们看

00:25:13.947 --> 00:25:18.318 align:middle
如何向她的小UI加一点叠加内容

00:25:19.253 --> 00:25:20.854 align:middle
那么先想想

00:25:20.921 --> 00:25:21.822 align:middle
我们要捕捉哪里

00:25:22.489 --> 00:25:23.957 align:middle
我们只要看到一个视觉效果

00:25:24.024 --> 00:25:26.426 align:middle
就知道我们需要捕捉的内容

00:25:26.860 --> 00:25:27.895 align:middle
我们将它从屏面移开

00:25:28.729 --> 00:25:30.330 align:middle
这样我们就把这个小东西拷贝了出来

00:25:30.964 --> 00:25:33.233 align:middle
现在
它从屏面上下来了 我们可以用它了

00:25:33.300 --> 00:25:34.701 align:middle
但是我们为什么将它从屏面取下

00:25:35.102 --> 00:25:37.304 align:middle
好 有一个原因是我们需要确保

00:25:37.371 --> 00:25:39.139 align:middle
我们获得正确的效果
而且在这种情况下

00:25:39.206 --> 00:25:41.275 align:middle
我们捕获了我们需要用于模糊的所有一
切内容

00:25:41.341 --> 00:25:42.376 align:middle
为了达到那种模糊效果

00:25:42.709 --> 00:25:44.077 align:middle
而且我们经常离屏做这些事情

00:25:44.144 --> 00:25:46.580 align:middle
这样
我们就不会弄乱屏幕上已经做好的内容

00:25:46.647 --> 00:25:48.549 align:middle
当我们正在离屏做出这样效果的时候

00:25:49.783 --> 00:25:51.518 align:middle
于是我们将这个模糊效果应用在它这里

00:25:52.419 --> 00:25:54.354 align:middle
最后 我们把它复制回原来的位置

00:25:54.421 --> 00:25:55.856 align:middle
即效果视图对它所要求的位置

00:25:56.823 --> 00:25:58.825 align:middle
而所有这些给了我们一个定义

00:25:58.892 --> 00:26:01.929 align:middle
它定义的是你以前可能已经听说过的一
个东西 即所谓“离屏通过”

00:25:58.892 --> 00:26:01.929 align:middle
它定义的是你以前可能已经听说过的一
个东西 即所谓“离屏通过”

00:26:01.995 --> 00:26:05.465 align:middle
就是无论什么时候我们获得一个内容
我们将它复制到屏幕以外

00:26:05.866 --> 00:26:07.835 align:middle
做好后 再把它返回到屏幕上

00:26:09.336 --> 00:26:11.805 align:middle
那么有什么其他方法
我们可以得到“离屏通过”？

00:26:12.873 --> 00:26:14.007 align:middle
好
正如你所看到的

00:26:14.074 --> 00:26:15.275 align:middle
我们已经有了Alpha

00:26:15.542 --> 00:26:17.311 align:middle
而且你可以看到你做那种效果的方法

00:26:17.377 --> 00:26:18.946 align:middle
因为如何你有一个复杂的视图层次

00:26:19.179 --> 00:26:20.581 align:middle
其中需要Alpha

00:26:20.647 --> 00:26:23.217 align:middle
那么我们就不能只把Alpha适用于
单个视图

00:26:23.283 --> 00:26:24.551 align:middle
因为你将得不到正确的效果

00:26:25.152 --> 00:26:28.155 align:middle
相反
我们需要获得整个复杂的视图层次

00:26:28.222 --> 00:26:31.391 align:middle
通过离屏获得它渲染它
然后将Alpha应用到整个事情

00:26:32.025 --> 00:26:34.294 align:middle
遮罩在它的背后有一个非常相似的推理

00:26:34.361 --> 00:26:36.263 align:middle
在那个推理中我们需要将所有像素用于
遮罩

00:26:39.166 --> 00:26:42.336 align:middle
正如我们刚才提到的
模糊和虚化也是通过离屏完成的

00:26:43.303 --> 00:26:44.872 align:middle
但快照不是 为什么是这样呢？

00:26:44.938 --> 00:26:45.806 align:middle
你可能会问自己

00:26:46.573 --> 00:26:48.208 align:middle
嗯 首先 什么是快照？

00:26:48.509 --> 00:26:51.345 align:middle
我们已经有了这两种UIView方法
一种是在屏幕更新后

00:26:51.411 --> 00:26:53.614 align:middle
获得屏幕快照
然后以矩形绘制出视图层次

00:26:54.181 --> 00:26:57.150 align:middle
一种是UIScreen方法
即在屏幕更新后获得快照视图

00:26:57.651 --> 00:27:00.621 align:middle
而且所有这些都会把快照上的内容返回
给你

00:26:57.651 --> 00:27:00.621 align:middle
而且所有这些都会把快照上的内容返回
给你

00:27:01.321 --> 00:27:03.857 align:middle
那么 快照基本上是做同样的事情

00:27:03.924 --> 00:27:06.960 align:middle
即如“离屏通过”做的一样
但让你能够控制最后一个步骤

00:27:07.027 --> 00:27:08.195 align:middle
从而将内容复制回屏幕

00:27:09.263 --> 00:27:11.832 align:middle
我们获得了所有你要求我们进行快照的
内容

00:27:11.965 --> 00:27:14.268 align:middle
对它进行离屏渲染
然后返给你一个视图

00:27:14.334 --> 00:27:17.271 align:middle
或者代表那个图像的像素内容

00:27:18.672 --> 00:27:20.974 align:middle
但是 再一次想问的是 这与确保

00:27:21.041 --> 00:27:22.509 align:middle
你的效果必须正确无误有关吗？

00:27:22.843 --> 00:27:23.677 align:middle
好

00:27:23.744 --> 00:27:27.114 align:middle
不幸的是如果你得到的视觉效果陷入了

00:27:27.181 --> 00:27:28.448 align:middle
这一点
正如你可以看到的

00:27:28.515 --> 00:27:29.983 align:middle
索̨菲亚已经
失去了她的模糊度

00:27:30.050 --> 00:27:32.886 align:middle
而这就是你在视觉效果完成后将在屏幕
上所看到的内容

00:27:33.120 --> 00:27:34.755 align:middle
视学效果是你离屏时所得到的

00:27:34.821 --> 00:27:36.223 align:middle
它是你事先没有想到会遇到的

00:27:38.592 --> 00:27:40.527 align:middle
好
重新回到这里

00:27:40.928 --> 00:27:43.130 align:middle
我敢肯定你们今年都已经
参加过多任务会议

00:27:43.197 --> 00:27:45.199 align:middle
如果没有
你可以下课后看看它们的视频

00:27:45.632 --> 00:27:48.101 align:middle
但在所有事情当中
即你需要启动一个非常好的App

00:27:48.168 --> 00:27:49.503 align:middle
以参与多任务处理

00:27:49.570 --> 00:27:51.305 align:middle
其中关键的一点是屏幕上要有好的表现

00:27:51.371 --> 00:27:54.441 align:middle
因为现在你的App的表现
也会影响到其他正在运行的App

00:27:55.042 --> 00:27:57.811 align:middle
所以 既然我们在这个特殊的例子中
没有出现任何滚动

00:27:57.878 --> 00:28:01.048 align:middle
那么我们就可以决定
让我们不要一直保持对模糊进行渲染

00:27:57.878 --> 00:28:01.048 align:middle
那么我们就可以决定
让我们不要一直保持对模糊进行渲染

00:28:01.114 --> 00:28:02.649 align:middle
让我们只是为它照一个快照好了

00:28:02.816 --> 00:28:06.320 align:middle
因此我们决定为那个特殊的视觉效果图
照一个快照

00:28:07.521 --> 00:28:11.658 align:middle
但随后发生的事情是捕捉区域
是离屏完成的

00:28:12.092 --> 00:28:14.561 align:middle
而且由于你只快照了视觉效果图

00:28:15.495 --> 00:28:17.331 align:middle
因此在捕捉区域上什么也没有

00:28:17.898 --> 00:28:21.068 align:middle
这样一来捕捉区域什么也没带给你
而且模糊功能也没有可以模糊的

00:28:21.134 --> 00:28:23.003 align:middle
你得到的是你之前看到的被破坏的效果

00:28:24.037 --> 00:28:25.305 align:middle
所以 既然我们已经看到

00:28:25.639 --> 00:28:28.742 align:middle
你是如何破坏了你的效果
那我们能做些什么来解决这个问题呢？

00:28:29.243 --> 00:28:31.111 align:middle
好了 第一件事就是

00:28:31.178 --> 00:28:33.747 align:middle
我们有了这个简便的方法
即用于视觉效果图上的方法

00:28:34.014 --> 00:28:35.449 align:middle
所谓的“这个效果怎么了？”

00:28:43.357 --> 00:28:46.860 align:middle
就像使用动态调试标志

00:28:46.927 --> 00:28:50.063 align:middle
在SDK中不是这样的 但你可以

00:28:50.130 --> 00:28:51.765 align:middle
从调试器中调用它 就像这个一样

00:28:52.432 --> 00:28:55.736 align:middle
你会得到一个字符串
看起来和这个有点像

00:28:56.270 --> 00:28:58.872 align:middle
在这种情况下
我们发现在层次结构上的某个地方

00:28:58.939 --> 00:29:01.642 align:middle
有一个遮罩视图 它造成的视觉效果

00:28:58.939 --> 00:29:01.642 align:middle
有一个遮罩视图 它造成的视觉效果

00:29:01.708 --> 00:29:04.511 align:middle
需要在屏幕外来完成
因此无法捕获尽可能多的

00:29:04.578 --> 00:29:06.280 align:middle
它所需要的内容
以便进行正确的渲染

00:29:07.848 --> 00:29:09.082 align:middle
那么如何解决这一问题呢？

00:29:10.751 --> 00:29:12.953 align:middle
第一种方式
如果你使用的是Alpha

00:29:13.020 --> 00:29:15.489 align:middle
或者遮罩这项工作实际上是重新排列你
的视图层次

00:29:15.622 --> 00:29:18.792 align:middle
我们在这里所拥有的只是一些容器
或许窗口

00:29:19.026 --> 00:29:19.960 align:middle
和一个容器视图

00:29:20.027 --> 00:29:22.162 align:middle
包含一个模糊和更多的内容

00:29:22.563 --> 00:29:24.631 align:middle
那么
在这种情况下 模糊实际上并不需要

00:29:24.698 --> 00:29:26.733 align:middle
加入我们所拥有的Alpha或者遮罩

00:29:27.501 --> 00:29:30.637 align:middle
所以我们只是重新安排
以便将模糊作为第一个子视图

00:29:30.771 --> 00:29:33.273 align:middle
将容器作为第二个子视图
这样一来容器

00:29:33.340 --> 00:29:35.609 align:middle
和它里面的一切都将渲染于模糊的顶部

00:29:35.909 --> 00:29:38.378 align:middle
而且我们可以将Alpha或
遮罩适用于这个容器视图

00:29:38.445 --> 00:29:39.479 align:middle
却不会搞乱我们的模糊

00:29:40.948 --> 00:29:42.883 align:middle
我们能为遮罩做的第二件事是

00:29:43.383 --> 00:29:45.686 align:middle
不是将容器视图进行遮罩

00:29:46.620 --> 00:29:47.855 align:middle
而且我们可以将那个遮罩

00:29:48.021 --> 00:29:51.091 align:middle
向下移动到我们实际上需要遮罩的内容
上

00:29:51.959 --> 00:29:53.260 align:middle
现在 正如我们前面所提到的

00:29:53.327 --> 00:29:54.995 align:middle
遮罩往往会采取“离屏通过”

00:29:55.195 --> 00:29:56.697 align:middle
所以你在做这样的转换时

00:29:56.763 --> 00:29:58.131 align:middle
应该非常地小心谨慎

00:30:00.667 --> 00:30:02.736 align:middle
最后
通过快照 正如我们前面提到的

00:30:02.803 --> 00:30:05.072 align:middle
快照只会捕获你告诉它需要做的

00:30:05.672 --> 00:30:06.773 align:middle
所以
在这种情况下

00:30:06.840 --> 00:30:09.910 align:middle
我们要求快照的内容视
图中 有一定的透明度

00:30:09.977 --> 00:30:11.678 align:middle
这样
我们就可以看到它背后的东西

00:30:11.745 --> 00:30:14.715 align:middle
但是如果我们只快照了那个视图
那么我们在模糊中将得不到透明度

00:30:14.781 --> 00:30:16.116 align:middle
它会看起来有点滑稽

00:30:16.550 --> 00:30:18.352 align:middle
因此 当我们一直向上移动快照时

00:30:18.418 --> 00:30:20.621 align:middle
窗口通常是最容易做的事情

00:30:21.221 --> 00:30:23.357 align:middle
但有时你可能需要
一直将它向上移动到屏幕上

00:30:23.924 --> 00:30:25.993 align:middle
所以
如果你要快照模糊 你应该确保

00:30:26.059 --> 00:30:28.428 align:middle
你在快照时尽量远离模糊内容

00:30:28.495 --> 00:30:30.998 align:middle
以确保你得到你所需要的
一切

00:30:32.666 --> 00:30:35.936 align:middle
然后有了这些
让我们转到有关动态和自动布局的

00:30:36.003 --> 00:30:37.371 align:middle
一些最佳做法

00:30:41.341 --> 00:30:42.776 align:middle
所以
你可能要做的第一件事是

00:30:42.843 --> 00:30:44.745 align:middle
你可能需要
使相当复杂的

00:30:44.811 --> 00:30:46.847 align:middle
视图层次在动态系统内发生作用

00:30:47.915 --> 00:30:50.150 align:middle
而你想要的是使外部视图加入

00:30:50.217 --> 00:30:52.686 align:middle
动态系统而不是内部视图

00:30:52.753 --> 00:30:53.787 align:middle
它们的布局将正如

00:30:53.854 --> 00:30:55.822 align:middle
你用其他内容所做的布局的一样

00:30:56.056 --> 00:30:59.760 align:middle
所以 你可以将UIKit
Dynamics用于外部视图

00:30:59.960 --> 00:31:02.462 align:middle
这只需要将
“自动调整遮罩大小转变为约束”

00:30:59.960 --> 00:31:02.462 align:middle
这只需要将
“自动调整遮罩大小转变为约束”

00:31:02.529 --> 00:31:03.931 align:middle
变为“真”即可

00:31:04.097 --> 00:31:06.300 align:middle
是的在WWDC中唯一的幻灯片里
讲的是“真”

00:31:09.169 --> 00:31:10.737 align:middle
然后你就可以使用“自动布局”

00:31:10.804 --> 00:31:12.506 align:middle
将所有其他的东西正好放置于视图里面

00:31:12.573 --> 00:31:14.675 align:middle
就像你经常做的一样
或者使用新的句法

00:31:14.741 --> 00:31:15.976 align:middle
即如幻灯片上所显示的一样

00:31:17.411 --> 00:31:20.247 align:middle
你可以做的另一件事是
你在动态系统里经常会有

00:31:20.314 --> 00:31:23.483 align:middle
各种项目
但你可能对它们作了标记

00:31:23.550 --> 00:31:25.819 align:middle
它们不应该参与 但需要跟随

00:31:26.253 --> 00:31:28.522 align:middle
所以在这里Lola有她的小标签

00:31:28.856 --> 00:31:31.458 align:middle
上面写了文件名是什么
而我们只有这个锚点

00:31:31.525 --> 00:31:33.427 align:middle
它代表了我们的自动布局约束

00:31:33.794 --> 00:31:36.830 align:middle
然后当动态图起作用并准备四处移动L
ola时

00:31:37.030 --> 00:31:39.533 align:middle
标签也跟着一起动 但标签最终不会

00:31:39.600 --> 00:31:41.001 align:middle
与动态图有互动

00:31:43.036 --> 00:31:45.472 align:middle
最后你可以使用动态图来操作

00:31:45.539 --> 00:31:47.307 align:middle
其方法是创建一个自定义动态项目

00:31:47.441 --> 00:31:48.675 align:middle
正如麦克前面所提到的

00:31:49.843 --> 00:31:51.545 align:middle
你只需要将
NSObject划入子类

00:31:51.612 --> 00:31:53.580 align:middle
或者其他适当的对象类

00:31:55.048 --> 00:31:57.084 align:middle
只要符合UI动态项目协议

00:31:58.151 --> 00:31:59.753 align:middle
并提供了所需要的方法

00:32:00.654 --> 00:32:02.222 align:middle
对于Bounds 有的尺寸...

00:32:02.289 --> 00:32:04.791 align:middle
它不能是“00”
或者动态系统准备

00:32:06.193 --> 00:32:08.262 align:middle
抛出一个异常...
然后你执行居中和转换

00:32:08.362 --> 00:32:10.764 align:middle
并按顺序使用这些数值

00:32:10.831 --> 00:32:12.999 align:middle
以构建自动布局约束

00:32:13.233 --> 00:32:15.335 align:middle
或者改变你系统外部的一些东西

00:32:16.470 --> 00:32:19.373 align:middle
然后关闭 我们将给你一个演示
你也可以做到这样

00:32:25.812 --> 00:32:27.247 align:middle
所以我们这里得到的是什么？

00:32:28.248 --> 00:32:30.017 align:middle
对 同刚才一样
是一个简单的应用程序

00:32:30.250 --> 00:32:31.585 align:middle
它刚刚显示了一张照片

00:32:31.652 --> 00:32:34.054 align:middle
但是
我们希望能够以某种风格向用户展示

00:32:34.121 --> 00:32:35.789 align:middle
照片里人的面部

00:32:36.056 --> 00:32:37.324 align:middle
所以
当我们点击

00:32:37.391 --> 00:32:39.993 align:middle
我们的动态项目时系统就
会伸出

00:32:40.060 --> 00:32:41.395 align:middle
并且在那个模糊中出现动画

00:32:42.129 --> 00:32:43.830 align:middle
如果你再次点击 当然 它的移动

00:32:43.897 --> 00:32:45.432 align:middle
会出现更好一点的效果

00:32:46.433 --> 00:32:49.036 align:middle
但是如果你继续点击 你就可以看到

00:32:49.102 --> 00:32:51.638 align:middle
它在动态系统上的反应非常流畅

00:32:52.306 --> 00:32:54.741 align:middle
并且不具有非常固定的、僵硬的路径

00:32:55.475 --> 00:32:58.879 align:middle
所以它对于用户正在做的动作做出恰好
的反应

00:32:59.713 --> 00:33:01.148 align:middle
那么 我们是如何做到这个的？

00:32:59.713 --> 00:33:01.148 align:middle
那么 我们是如何做到这个的？

00:33:02.449 --> 00:33:03.884 align:middle
所以
我们做的第一件事是

00:33:03.951 --> 00:33:05.485 align:middle
我们使这个面部
执行布局向导

00:33:06.019 --> 00:33:07.988 align:middle
这正好是UI布局向导的一个子类

00:33:08.288 --> 00:33:11.391 align:middle
而在它的内部是一点点的动态

00:33:11.825 --> 00:33:14.561 align:middle
我们将这个面部布局向导执行动态项目
也就是再一次

00:33:14.628 --> 00:33:17.431 align:middle
将NSObject划入子类
并符合UI动态项目

00:33:18.265 --> 00:33:19.900 align:middle
并且它将管理一个约束

00:33:20.300 --> 00:33:24.037 align:middle
然后通过将该约束的常数
设置为中心点的x值

00:33:24.104 --> 00:33:27.407 align:middle
或y值 不管该约束是如何变化的

00:33:30.043 --> 00:33:33.680 align:middle
在这里 当你设置布局向导时

00:33:34.014 --> 00:33:35.582 align:middle
它就会得到一个中心位置

00:33:35.849 --> 00:33:38.385 align:middle
并且创建了四个额外的动态项目

00:33:38.652 --> 00:33:40.354 align:middle
在系统中表示上、左、下

00:33:40.420 --> 00:33:41.955 align:middle
和右

00:33:43.156 --> 00:33:45.259 align:middle
我们将它分配到约束
而约束刚好从动态项目的

00:33:45.325 --> 00:33:47.861 align:middle
左上角发生作用

00:33:48.495 --> 00:33:50.597 align:middle
以及从动态项目参考视图

00:33:51.565 --> 00:33:54.067 align:middle
而我们使用滑块附件以限制

00:33:54.134 --> 00:33:56.103 align:middle
这四个动态项目相对于该位置

00:33:56.170 --> 00:33:57.237 align:middle
可以去的范围大小

00:33:57.638 --> 00:33:59.973 align:middle
这可保证它避免飞到系统外

00:34:00.040 --> 00:34:01.909 align:middle
或者折叠到一个过小的位置

00:34:03.911 --> 00:34:05.045 align:middle
现在 在视图控制器里

00:34:05.112 --> 00:34:08.014 align:middle
我们得到这种行为的方式
是我们有一个

00:34:08.081 --> 00:34:09.416 align:middle
沿着面部布局向导的重力行为

00:34:09.483 --> 00:34:10.817 align:middle
然后在彼此的顶部将它们居中

00:34:10.884 --> 00:34:12.351 align:middle
因此当重力发生变化时

00:34:12.418 --> 00:34:13.954 align:middle
布局向导将会适当地移动

00:34:15.188 --> 00:34:17.090 align:middle
我们从故事板中得到模糊效果

00:34:17.157 --> 00:34:18.792 align:middle
这样我们不必不断地摆弄它

00:34:18.859 --> 00:34:21.195 align:middle
如果我们决定要改变我们使用的风格

00:34:22.829 --> 00:34:26.099 align:middle
我们使用约束将那个模糊视图

00:34:26.366 --> 00:34:27.568 align:middle
附加到面部布局向导上

00:34:27.900 --> 00:34:29.803 align:middle
因此 当此向导改变了尺寸

00:34:29.870 --> 00:34:31.538 align:middle
模糊视图也会随之改变

00:34:33.005 --> 00:34:35.842 align:middle
现在
为了使它看起来像是模糊视图切割了

00:34:35.909 --> 00:34:38.411 align:middle
除面部以外的所有东西
对此我们确实有一个小窍门

00:34:38.679 --> 00:34:40.813 align:middle
我们做了一个原始图像的顶替图像

00:34:40.981 --> 00:34:44.284 align:middle
刚好切出我们需要的图像
给它们一个遮罩

00:34:44.618 --> 00:34:47.754 align:middle
并创造更多的UI图像视图放置于

00:34:47.821 --> 00:34:48.956 align:middle
已经在那里的视图的顶部

00:34:49.456 --> 00:34:52.125 align:middle
所以它看起来好像模糊刚好遮挡着面部

00:34:52.192 --> 00:34:54.194 align:middle
但实际发生的事情是
你所看到的视图

00:34:54.261 --> 00:34:56.830 align:middle
被放置在顶部
而面部从它们上面切除

00:34:58.465 --> 00:35:01.368 align:middle
最后 我们对这个视图
点击我们设置的手势识别器

00:34:58.465 --> 00:35:01.368 align:middle
最后 我们对这个视图
点击我们设置的手势识别器

00:35:01.435 --> 00:35:04.438 align:middle
得到的正好是
使我们的动态系统发生改变的东西

00:35:06.206 --> 00:35:08.141 align:middle
当我们要暴露面部时

00:35:08.475 --> 00:35:09.743 align:middle
我们只需要改变重力就可以

00:35:09.810 --> 00:35:13.046 align:middle
所以重力通常是造成一切被拉向
中心的原因

00:35:13.347 --> 00:35:16.650 align:middle
但当我们打开它时
它像一个反重力一样想推开一切东西

00:35:18.385 --> 00:35:19.653 align:middle
然后我们利用以下这个事实

00:35:19.720 --> 00:35:21.822 align:middle
即我们通常在这个过程中
始终布局子视图

00:35:22.189 --> 00:35:24.758 align:middle
以实际地触发模糊动画进入或退出

00:35:25.792 --> 00:35:29.162 align:middle
而所有这些都是为了建设
这个非常好的效果

00:35:29.363 --> 00:35:33.300 align:middle
我们所依靠的是自动布局
和动态都可以很容易地提供给你

00:35:33.967 --> 00:35:35.736 align:middle
至此我们将回到幻灯片来做一个结束

00:35:39.373 --> 00:35:40.674 align:middle
总而言之

00:35:41.675 --> 00:35:45.279 align:middle
我们希望你能够使用这些技术
以真正地改善用户体验

00:35:45.746 --> 00:35:47.915 align:middle
所以 当你添加一个模糊
你添加了它

00:35:47.981 --> 00:35:51.985 align:middle
这样你就可以通过其他的信息
来弥补你的内容

00:35:52.319 --> 00:35:53.453 align:middle
当你使用动态

00:35:53.520 --> 00:35:56.990 align:middle
你可以有一个反应刚刚好的用户界面

00:35:57.057 --> 00:35:59.226 align:middle
并且正如用户对他们输入内容
的期待一样

00:35:59.993 --> 00:36:02.629 align:middle
但是你也需要考虑到表现
当你在做这些事情时

00:35:59.993 --> 00:36:02.629 align:middle
但是你也需要考虑到表现
当你在做这些事情时

00:36:02.996 --> 00:36:05.432 align:middle
因为如果你有很多在屏幕上的动态项目

00:36:05.499 --> 00:36:07.501 align:middle
它们能够使用户界面真正陷入困境

00:36:07.835 --> 00:36:10.204 align:middle
而且你不会得到你所期待的的物理现象

00:36:10.537 --> 00:36:11.872 align:middle
所以请谨慎地使用

00:36:13.040 --> 00:36:15.576 align:middle
而且对于视觉效果
如果你有很多这样的效果

00:36:15.642 --> 00:36:17.544 align:middle
你最终将有很多“离屏通过”

00:36:17.711 --> 00:36:19.446 align:middle
并且这也会招致相当高的成本

00:36:21.748 --> 00:36:24.284 align:middle
这些都是与课程相关的内容
这是我们今天为你准备的

00:36:24.518 --> 00:36:26.954 align:middle
不幸的是其中大部分都在之前发生过

00:36:27.187 --> 00:36:29.523 align:middle
仅有一个没有发生
而且是与我们一起出现的

00:36:29.590 --> 00:36:31.892 align:middle
即所谓
“通过GCD建立响应和效率的App”

00:36:33.060 --> 00:36:35.562 align:middle
而且我们在此之后将在实验室里回答
你的所有问题

00:36:35.629 --> 00:36:38.632 align:middle
并帮助你避免出现
你这一年遇到的大部分情况

00:36:40.801 --> 00:36:42.503 align:middle
我们已经有了各种文档

00:36:42.769 --> 00:36:46.139 align:middle
以及你以前在演示中看到的
用于StickyCorners样本的组装代码

00:36:46.206 --> 00:36:47.341 align:middle
将会提供给你

00:36:47.908 --> 00:36:50.677 align:middle
而且 当然 寇特·罗斯特
将通过电子邮件回答大家的提问

00:36:51.979 --> 00:36:53.780 align:middle
我很高兴你们在周五
坚持与我们一起学习

00:36:53.847 --> 00:36:56.550 align:middle
我希望你拥有一个伟大的WWDC
并祝大家一路平安
