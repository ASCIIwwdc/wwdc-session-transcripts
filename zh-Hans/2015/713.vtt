WEBVTT

00:00:20.354 --> 00:00:23.857 align:middle
Watch Connectivity介绍

00:00:31.665 --> 00:00:32.698 align:middle
早上好

00:00:32.966 --> 00:00:35.269 align:middle
欢迎来到
Watch Connectivity介绍

00:00:35.435 --> 00:00:36.336 align:middle
我叫克里斯

00:00:36.403 --> 00:00:38.038 align:middle
今天 我的同事亚历克斯将和我一起

00:00:38.105 --> 00:00:40.040 align:middle
他随后会上台

00:00:40.107 --> 00:00:42.276 align:middle
我们很兴奋为你们展示

00:00:42.342 --> 00:00:47.047 align:middle
我们一直在watchOS 2
和iOS 9上做的东西

00:00:47.481 --> 00:00:49.483 align:middle
今天 我们要说的是

00:00:49.550 --> 00:00:51.718 align:middle
帮助你们为Watch app做出

00:00:51.852 --> 00:00:53.887 align:middle
更好更有反响的用户体验

00:00:55.289 --> 00:00:57.558 align:middle
为了简单说明我们的出发点

00:00:57.624 --> 00:01:00.561 align:middle
watchOS 1
上的世界看起来像什么

00:00:57.624 --> 00:01:00.561 align:middle
watchOS 1
上的世界看起来像什么

00:01:00.627 --> 00:01:04.331 align:middle
之前iOS app
和WatchKit扩展都是依赖

00:01:04.498 --> 00:01:08.302 align:middle
iPhone的 且当时主要处理的是
WatchKit app通信

00:01:08.602 --> 00:01:11.672 align:middle
而且这二者都可以共享数据存储

00:01:12.973 --> 00:01:15.409 align:middle
在watchOS 2
我们已经把WatchKit扩展

00:01:15.475 --> 00:01:19.313 align:middle
扩展到Watch之上
app在Watch可以运行更流畅了

00:01:19.513 --> 00:01:20.848 align:middle
这有不少的好处

00:01:20.914 --> 00:01:23.350 align:middle
但是也意味着它们都
各自使用自己的数据存储

00:01:24.718 --> 00:01:28.155 align:middle
显然 下个问题是 我们如何把数据

00:01:28.322 --> 00:01:29.723 align:middle
搬到Apple Watch上

00:01:29.923 --> 00:01:31.225 align:middle
这是我们今天要讨论的内容

00:01:33.327 --> 00:01:37.464 align:middle
我们将为你展示解决
这个问题的两个主要方法

00:01:37.531 --> 00:01:39.499 align:middle
如何将数据移到Watch上

00:01:39.566 --> 00:01:42.169 align:middle
这是新框架
WatchConnectivity

00:01:42.236 --> 00:01:46.473 align:middle
我们将它引入了
watchOS 2 和iOS 9

00:01:47.708 --> 00:01:53.313 align:middle
然后这是可在Foundation上
获NSURLSession API

00:01:53.580 --> 00:01:55.682 align:middle
也适用于WatchKit扩展

00:01:56.383 --> 00:01:59.419 align:middle
也已经集成到watchOS 2

00:02:00.821 --> 00:02:03.924 align:middle
我想今天要讨论的话题适用于

00:02:03.991 --> 00:02:09.729 align:middle
大多数Watch app
对于多数人来说也是适用的

00:02:10.464 --> 00:02:12.799 align:middle
今天展示中即将用到的大量示例

00:02:12.866 --> 00:02:14.968 align:middle
将会证明这一点

00:02:15.536 --> 00:02:18.405 align:middle
你可以看到 这个范围很广
我们希望每个人

00:02:18.472 --> 00:02:21.208 align:middle
都可以至少辨认出一种

00:02:22.276 --> 00:02:24.912 align:middle
我们先讨论
WatchConnectivity

00:02:24.978 --> 00:02:29.449 align:middle
这是我们引入watchOS 2
和iOS 9的新架构

00:02:29.516 --> 00:02:31.618 align:middle
它在两个平台中都适用

00:02:31.685 --> 00:02:33.921 align:middle
几乎所有的API在两边都适用

00:02:33.987 --> 00:02:39.026 align:middle
我们将会看到不少
iPhone专用的 API

00:02:39.092 --> 00:02:42.329 align:middle
当你开始采用
WatchConnectivity

00:02:42.396 --> 00:02:44.498 align:middle
你想做的第一件事是

00:02:44.565 --> 00:02:46.066 align:middle
仔细设置

00:02:46.633 --> 00:02:49.269 align:middle
我们建议尽早进行设置

00:02:49.336 --> 00:02:52.005 align:middle
在使用app的整个过程中
在两方面都要

00:02:52.072 --> 00:02:57.511 align:middle
在Watch运行的WatchKit
扩展和在iOS 9 app内部

00:02:57.945 --> 00:03:01.081 align:middle
你要确保使用代码路径进行设置

00:02:57.945 --> 00:03:01.081 align:middle
你要确保使用代码路径进行设置

00:03:01.148 --> 00:03:02.616 align:middle
这样一来 尽管是在后台启动

00:03:02.683 --> 00:03:03.851 align:middle
也还是可以被执行

00:03:03.917 --> 00:03:07.321 align:middle
所以不要把它放在里面如视图
控制器View Did Load内

00:03:07.387 --> 00:03:09.790 align:middle
因为当你在后台启动时
这些是不会被调用的

00:03:10.757 --> 00:03:12.659 align:middle
所以在iOS app中

00:03:12.726 --> 00:03:15.162 align:middle
你做的第一件事是查看

00:03:15.229 --> 00:03:16.930 align:middle
是否支持WCSession

00:03:17.164 --> 00:03:19.533 align:middle
你或许有一个通用的iOS app

00:03:19.600 --> 00:03:22.269 align:middle
意思是代码可以在iPad上执行

00:03:22.336 --> 00:03:24.838 align:middle
iPad无法使用
WatchConnectivity

00:03:25.305 --> 00:03:29.009 align:middle
你在Watch上执行任何工作之前
请事先检查一下

00:03:29.076 --> 00:03:34.815 align:middle
因为我们不想你浪费CPU做无用功

00:03:34.882 --> 00:03:36.350 align:middle
下一件事情是创建一个对象实例

00:03:36.416 --> 00:03:39.086 align:middle
你可以通过调用Default
Session进行创建

00:03:39.920 --> 00:03:43.590 align:middle
然后在会话对象上设置指派

00:03:43.957 --> 00:03:45.859 align:middle
最后调用Activate

00:03:45.926 --> 00:03:48.896 align:middle
滴啊用后就可以继续
设置WCSession对象

00:03:48.962 --> 00:03:52.499 align:middle
初始化所有属性
而且一旦调用返回

00:03:52.566 --> 00:03:54.535 align:middle
所有属性将被更新

00:03:54.601 --> 00:03:56.970 align:middle
更新为正确的初始化数值

00:03:58.705 --> 00:04:01.275 align:middle
同样此刻 任何指派回调

00:03:58.705 --> 00:04:01.275 align:middle
同样此刻 任何指派回调

00:04:01.341 --> 00:04:03.610 align:middle
任何向上尾接
的内容会可以开始进入

00:04:03.944 --> 00:04:04.845 align:middle
这是为什么你需要

00:04:04.912 --> 00:04:06.947 align:middle
尽快执行上述步骤的原因

00:04:07.014 --> 00:04:09.983 align:middle
或许有内容正等着上传到你的app上

00:04:10.551 --> 00:04:12.886 align:middle
所以 请确保提前处理这些步骤

00:04:13.687 --> 00:04:15.088 align:middle
一旦这些步骤完成

00:04:15.155 --> 00:04:17.891 align:middle
下一件你将想做的事情是
查看会话状态

00:04:17.958 --> 00:04:22.396 align:middle
然后通知你的app

00:04:22.462 --> 00:04:25.032 align:middle
iOS app和the Watch
之间目前的关系如何

00:04:26.099 --> 00:04:30.070 align:middle
所以这些
属性只适用于iPhone app

00:04:30.137 --> 00:04:33.674 align:middle
它正在通知iOS与Watch的关系

00:04:34.208 --> 00:04:36.510 align:middle
所以没有必要
在你的Watch app上使用

00:04:36.577 --> 00:04:38.011 align:middle
因为基本上不适用

00:04:39.112 --> 00:04:41.281 align:middle
在这个示例中
我们将使用一款新闻app

00:04:41.548 --> 00:04:43.383 align:middle
一款推送最近

00:04:43.450 --> 00:04:44.685 align:middle
有趣文章的应用

00:04:46.053 --> 00:04:49.857 align:middle
首先要做的是
执行我们刚才讨论的设置过程

00:04:49.923 --> 00:04:51.558 align:middle
这应当在使用应用的时候尽快完成

00:04:51.625 --> 00:04:55.629 align:middle
下一步进行设备检查
检查该设备是否与Watch配对？

00:04:55.896 --> 00:04:58.732 align:middle
如果未配对
那么相当于这是在iPad上运行

00:04:58.799 --> 00:05:00.234 align:middle
没什么需要做的了

00:04:58.799 --> 00:05:00.234 align:middle
没什么需要做的了

00:05:00.300 --> 00:05:01.335 align:middle
你无法进行通讯

00:05:01.802 --> 00:05:04.671 align:middle
所以这个时候 你可能
要停止所有在Watch上进行的工作

00:05:05.472 --> 00:05:08.408 align:middle
用户会出去并买个新的Watch

00:05:08.475 --> 00:05:09.977 align:middle
然后执行配对步骤

00:05:10.110 --> 00:05:12.546 align:middle
启动Apple Watch app

00:05:13.680 --> 00:05:14.815 align:middle
操作配对

00:05:14.882 --> 00:05:16.550 align:middle
设置这些设备

00:05:17.985 --> 00:05:20.087 align:middle
现在当你的app启动后

00:05:20.153 --> 00:05:21.955 align:middle
你会得到一个指派回调

00:05:22.422 --> 00:05:24.258 align:middle
说明Watch状态会话改变了

00:05:25.058 --> 00:05:27.294 align:middle
当你检查配对属性的数值时

00:05:27.361 --> 00:05:28.962 align:middle
你会看到返回为真

00:05:29.029 --> 00:05:30.430 align:middle
因为设备已经配对了

00:05:31.298 --> 00:05:32.633 align:middle
所以 这时候你可以继续

00:05:32.699 --> 00:05:34.968 align:middle
检查下个属性 也就是

00:05:35.035 --> 00:05:36.470 align:middle
Watch app是否安装了？

00:05:37.204 --> 00:05:38.739 align:middle
如果还未安装 那么就没法通讯

00:05:38.805 --> 00:05:40.374 align:middle
工作到此为止

00:05:40.674 --> 00:05:44.444 align:middle
但是 通过默认设置
Watch app是默认安装的

00:05:44.511 --> 00:05:46.580 align:middle
但是用户可能会由于某些原因
选择不进行安装

00:05:46.647 --> 00:05:50.150 align:middle
在这种情况下
用户将接续执行并进行重新安装

00:05:50.217 --> 00:05:52.219 align:middle
返回Apple Watch app

00:05:53.287 --> 00:05:56.957 align:middle
打开设备
如果你的Apple正在运行

00:05:57.057 --> 00:05:58.725 align:middle
你将再一次获得指派回调

00:05:58.792 --> 00:06:00.794 align:middle
你就可以检查该属性数值了

00:05:58.792 --> 00:06:00.794 align:middle
你就可以检查该属性数值了

00:06:00.861 --> 00:06:03.497 align:middle
可见Watch App
Installed返回为真

00:06:04.665 --> 00:06:06.800 align:middle
现在 你可以进行通讯了

00:06:06.867 --> 00:06:07.935 align:middle
这时候说明你可以

00:06:08.001 --> 00:06:10.270 align:middle
使用Watch app
开始进行通讯了

00:06:10.337 --> 00:06:13.006 align:middle
你需要输入通讯的内容

00:06:14.641 --> 00:06:17.878 align:middle
无论何时一旦Watch App
Installed值为True

00:06:18.946 --> 00:06:22.249 align:middle
另个属性Watch
Directory URL也可用

00:06:22.416 --> 00:06:25.686 align:middle
你会发现一旦Watch App
Installed值为True

00:06:25.752 --> 00:06:28.889 align:middle
Watch Directory
URL将会有一个非0值

00:06:28.956 --> 00:06:32.926 align:middle
这将指向在
container创建的一个目录

00:06:33.760 --> 00:06:35.662 align:middle
我们稍微深入地讨论一下这个

00:06:36.396 --> 00:06:39.132 align:middle
目录和它的内容 它的使用周期与

00:06:39.199 --> 00:06:41.535 align:middle
Watch App
Installed属性息息相关

00:06:41.602 --> 00:06:45.105 align:middle
WatchAppInstalled
值从True变成False

00:06:45.172 --> 00:06:48.375 align:middle
这个目录和它的所有内容都会消失

00:06:48.742 --> 00:06:50.444 align:middle
无论何时 当值为True时

00:06:50.511 --> 00:06:53.213 align:middle
目录会再次出现 但是是空目录

00:06:54.848 --> 00:06:56.783 align:middle
我们建议你 仅在数据与

00:06:56.850 --> 00:06:58.886 align:middle
你的Watch app
特别实例有关时才使用

00:06:59.152 --> 00:07:00.554 align:middle
实例是要说明什么呢

00:06:59.152 --> 00:07:00.554 align:middle
实例是要说明什么呢

00:07:00.754 --> 00:07:03.023 align:middle
一些事物 比如最后队列项目标记

00:07:03.557 --> 00:07:04.791 align:middle
就可以存储在这

00:07:04.858 --> 00:07:07.227 align:middle
若用户未安装并重新安装app

00:07:07.294 --> 00:07:09.763 align:middle
那么Watch app
是从一个空的容器开始的

00:07:09.863 --> 00:07:12.733 align:middle
因此
这个目录以开始是没有内容的

00:07:12.799 --> 00:07:16.737 align:middle
你需要同步到app通讯的位置

00:07:16.803 --> 00:07:20.274 align:middle
其他你可以保存的事物有偏好设置

00:07:20.340 --> 00:07:25.345 align:middle
当用户首次运行iOS app时

00:07:25.412 --> 00:07:27.881 align:middle
你可能想让他设置一下

00:07:27.948 --> 00:07:29.917 align:middle
想要的Watch app体验

00:07:29.983 --> 00:07:32.519 align:middle
或许他不想显示全部内容

00:07:32.586 --> 00:07:35.122 align:middle
但想要显示特别主题的前十条新闻

00:07:35.189 --> 00:07:37.724 align:middle
比如国际新闻或体育新闻

00:07:37.791 --> 00:07:39.293 align:middle
这个位置就很适合来存储这些设置

00:07:40.460 --> 00:07:43.964 align:middle
同样 如果你正处理全尺寸的资料

00:07:44.031 --> 00:07:46.166 align:middle
想生成适合Watch尺寸的资料

00:07:46.333 --> 00:07:49.670 align:middle
你要压缩图片 音频 视频

00:07:50.470 --> 00:07:53.407 align:middle
在提示传输时可使用
WatchConnectivity

00:07:53.473 --> 00:07:55.909 align:middle
API 将这些资料储存到这里
随后我们会说到这点

00:07:57.311 --> 00:07:58.979 align:middle
所以 这就是Watch 目录

00:07:59.279 --> 00:08:01.114 align:middle
我们建议你将内容存储在这

00:07:59.279 --> 00:08:01.114 align:middle
我们建议你将内容存储在这

00:08:01.181 --> 00:08:03.650 align:middle
因为随后我们会将内容清理掉
如果Watch消失了

00:08:03.717 --> 00:08:07.354 align:middle
如果他未配对他的手表
我们将自动清除这些内容

00:08:07.421 --> 00:08:10.657 align:middle
这样就省去了管理的麻烦

00:08:11.225 --> 00:08:15.262 align:middle
最后会话状态属性是
Complication Enabled

00:08:15.929 --> 00:08:18.832 align:middle
用户并不能
启动Complication

00:08:18.899 --> 00:08:22.536 align:middle
但可编辑Watch表面然后启动

00:08:22.803 --> 00:08:24.805 align:middle
之后你会收到同样的的回调

00:08:24.872 --> 00:08:26.240 align:middle
会话或状态变换信号

00:08:26.840 --> 00:08:29.343 align:middle
当你查看属性时 现在值将是True

00:08:31.879 --> 00:08:35.515 align:middle
你已经设置 会话
WatchConnectivity

00:08:35.982 --> 00:08:38.150 align:middle
已知道watch的状态是什么的

00:08:38.217 --> 00:08:42.054 align:middle
iOS app
和Watch app

00:08:42.121 --> 00:08:43.423 align:middle
之间是什么关系

00:08:43.490 --> 00:08:47.327 align:middle
下一件事情是
开始将信息传输到Watch上

00:08:47.394 --> 00:08:49.496 align:middle
或从Watch
传输到iOS app上

00:08:50.030 --> 00:08:53.033 align:middle
为了这么做 我将邀请亚历山大

00:08:53.100 --> 00:08:54.768 align:middle
他将为我们讲解通讯API

00:09:05.012 --> 00:09:09.082 align:middle
谢谢 好的
所以就像克里斯说 你设置好了会话

00:09:09.583 --> 00:09:12.719 align:middle
也已经检查过 设备已经配对了

00:09:12.786 --> 00:09:15.055 align:middle
Apple Watch app
也已经安装了

00:09:15.422 --> 00:09:17.891 align:middle
现在 我们从如何才能

00:09:18.058 --> 00:09:19.293 align:middle
在两台设备之间进行通讯

00:09:20.894 --> 00:09:23.764 align:middle
关于通讯 我们有不少分类

00:09:24.231 --> 00:09:26.700 align:middle
第一类是后台传输

00:09:27.467 --> 00:09:29.536 align:middle
后台传输意思是说

00:09:29.603 --> 00:09:33.173 align:middle
在收到方看来
内容并不是立即需要的

00:09:34.541 --> 00:09:36.810 align:middle
因为内容不是立即需要的

00:09:37.077 --> 00:09:40.013 align:middle
这意味着在传输这些内容时

00:09:40.080 --> 00:09:42.182 align:middle
系统可以处理其他的事情

00:09:43.917 --> 00:09:46.453 align:middle
除了后台传输外 我们还将讲到

00:09:46.520 --> 00:09:48.055 align:middle
交互式信息传输

00:09:49.256 --> 00:09:52.326 align:middle
交互式信息传输是指

00:09:52.392 --> 00:09:55.429 align:middle
两个实时沟通的app之间的通讯

00:09:55.529 --> 00:09:58.832 align:middle
所以 这时候两个app都在使用中
它们来回发送信息

00:09:59.566 --> 00:10:01.902 align:middle
要求响应 之类的事情

00:09:59.566 --> 00:10:01.902 align:middle
要求响应 之类的事情

00:10:02.703 --> 00:10:04.104 align:middle
这里有你可能需要使用

00:10:04.171 --> 00:10:05.539 align:middle
交互式信息传输的一些情况

00:10:05.606 --> 00:10:09.510 align:middle
假设你有一个游戏 用户正在
同时使用两个app进行游戏时候

00:10:09.977 --> 00:10:11.812 align:middle
或者
你正在Apple Watch上

00:10:12.079 --> 00:10:16.049 align:middle
你需要启动iOS上的一些东西

00:10:16.316 --> 00:10:19.253 align:middle
比如你想要触发iOS设备

00:10:19.319 --> 00:10:21.321 align:middle
以便了解用户位置

00:10:23.190 --> 00:10:26.159 align:middle
我们先来说说第一个 后台传输

00:10:27.294 --> 00:10:31.164 align:middle
关于后台传输 首先要讲的是

00:10:31.231 --> 00:10:34.268 align:middle
app内容的类型 以及用户如何

00:10:34.334 --> 00:10:36.136 align:middle
与这两台设备进行互动

00:10:36.803 --> 00:10:39.106 align:middle
还是用新闻app的示例

00:10:39.173 --> 00:10:40.807 align:middle
这个新闻app有很多内容

00:10:41.308 --> 00:10:44.545 align:middle
它从服务器读取了不少内容

00:10:44.912 --> 00:10:47.181 align:middle
而且它断定这些内容

00:10:47.581 --> 00:10:48.782 align:middle
对于Watch是有用的

00:10:49.583 --> 00:10:53.020 align:middle
现在
用户并未在目前情况下使用Watch

00:10:53.353 --> 00:10:56.690 align:middle
所以在Watch方面来说
这些内容并不是立即需要的

00:10:57.257 --> 00:11:00.694 align:middle
当然啦iOS app
这个新闻app

00:10:57.257 --> 00:11:00.694 align:middle
当然啦iOS app
这个新闻app

00:11:00.761 --> 00:11:03.463 align:middle
想要挑一些新闻 在系统里列队备好

00:11:04.598 --> 00:11:07.134 align:middle
以便系统可以挑选对的内容

00:11:07.201 --> 00:11:08.802 align:middle
进行传输

00:11:09.403 --> 00:11:11.972 align:middle
在用户真的进行接收时

00:11:12.072 --> 00:11:14.641 align:middle
在这个
示例中是Apple Watch

00:11:14.708 --> 00:11:16.510 align:middle
系统将考虑电源和性能的情况

00:11:17.411 --> 00:11:20.647 align:middle
当条件都正确的时候内容将传输

00:11:21.148 --> 00:11:25.152 align:middle
它将在接收方这个示例中的
Apple Watch中等待

00:11:25.419 --> 00:11:28.222 align:middle
直到用户启动接收app

00:11:28.722 --> 00:11:30.057 align:middle
当接收app启动

00:11:30.123 --> 00:11:31.692 align:middle
内容将被传输过去

00:11:32.192 --> 00:11:33.961 align:middle
app也可以更新它的状态

00:11:36.296 --> 00:11:39.166 align:middle
这是后台传输所提供的

00:11:39.433 --> 00:11:41.401 align:middle
它允许内容列队等候

00:11:43.504 --> 00:11:45.939 align:middle
系统将为你传输内容

00:11:46.473 --> 00:11:50.277 align:middle
这允许了发送方 发送方app退出

00:11:50.777 --> 00:11:52.212 align:middle
系统将处理接下来的一切

00:11:52.846 --> 00:11:55.983 align:middle
它允许系统挑选合适时间传输内容

00:11:57.317 --> 00:11:59.653 align:middle
允许系统将信息存储到

00:11:59.720 --> 00:12:03.190 align:middle
接收方 并等待接收app启动

00:11:59.720 --> 00:12:03.190 align:middle
接收方 并等待接收app启动

00:12:04.525 --> 00:12:07.227 align:middle
对于app上有的大部分内容

00:12:07.528 --> 00:12:10.764 align:middle
我们建议你使用后台传输

00:12:12.199 --> 00:12:15.335 align:middle
原因是 对于接收方来说

00:12:15.402 --> 00:12:17.070 align:middle
大部分内容并不是立即所需的

00:12:17.137 --> 00:12:20.741 align:middle
当然啦 一旦接收app打开
就需要这些内容了

00:12:22.643 --> 00:12:24.411 align:middle
所以 我们来讲讲具体细节

00:12:25.512 --> 00:12:28.148 align:middle
我们有三种不同的后台传输类型

00:12:29.283 --> 00:12:31.919 align:middle
第一种是应用上下文

00:12:32.619 --> 00:12:35.289 align:middle
应用上下文代表的是app提供给

00:12:35.389 --> 00:12:37.491 align:middle
另一方的最有趣的

00:12:37.558 --> 00:12:38.692 align:middle
信息单一集合

00:12:39.860 --> 00:12:43.096 align:middle
比如说在iOS方面 有个app

00:12:43.463 --> 00:12:46.633 align:middle
它跟踪用户位置 根据用户位置

00:12:47.100 --> 00:12:50.437 align:middle
app挑选该位置附近的一个饭店

00:12:50.504 --> 00:12:52.072 align:middle
并想推荐给用户

00:12:52.840 --> 00:12:54.942 align:middle
除了在iOS方面分享饭店外

00:12:55.008 --> 00:12:56.977 align:middle
也想在
Apple Watch app上

00:12:57.044 --> 00:12:58.378 align:middle
显示这个饭店

00:12:59.112 --> 00:13:00.647 align:middle
所以你可以将建议打包到

00:12:59.112 --> 00:13:00.647 align:middle
所以你可以将建议打包到

00:13:00.714 --> 00:13:02.616 align:middle
应用上下文中

00:13:03.183 --> 00:13:04.751 align:middle
它将传输信息

00:13:04.818 --> 00:13:07.487 align:middle
然后下次
用户在Apple Watch启用

00:13:07.688 --> 00:13:10.224 align:middle
这个app时 内容就会出现

00:13:10.290 --> 00:13:11.892 align:middle
推荐也会出现

00:13:13.026 --> 00:13:15.796 align:middle
可能想使用应用上下文的其他示例

00:13:16.763 --> 00:13:19.499 align:middle
假设在iOS方面
你有一个社交app

00:13:19.566 --> 00:13:22.836 align:middle
它读取了一堆的帖子 并确定了

00:13:22.903 --> 00:13:27.641 align:middle
10个最有趣的帖子

00:13:27.708 --> 00:13:30.477 align:middle
在Apple Watch设备上展示

00:13:30.711 --> 00:13:32.913 align:middle
用户可看Apple Watch

00:13:32.980 --> 00:13:34.681 align:middle
并立即可以看到有趣的信息了

00:13:35.482 --> 00:13:37.618 align:middle
你也可以将这排名前10的帖子

00:13:37.684 --> 00:13:40.721 align:middle
打包到应用上下文中
他们将传输过去

00:13:41.922 --> 00:13:44.625 align:middle
现在 应用上下文是

00:13:44.691 --> 00:13:46.894 align:middle
后台传输最简单的方法

00:13:46.960 --> 00:13:48.996 align:middle
但如果你需要一些稍微复杂的东西

00:13:49.363 --> 00:13:51.899 align:middle
或你需要进行排队等候
而不是信息的一个单一集合

00:13:51.965 --> 00:13:54.635 align:middle
我们为你提供两种方法

00:13:55.569 --> 00:13:58.138 align:middle
第一种是用户信息传输

00:13:58.972 --> 00:14:01.842 align:middle
这允许你传输你想打包的

00:13:58.972 --> 00:14:01.842 align:middle
这允许你传输你想打包的

00:14:01.909 --> 00:14:04.244 align:middle
用户信息字典的内存内容

00:14:04.344 --> 00:14:07.080 align:middle
举个例子
假设你在Apple Watch上

00:14:07.514 --> 00:14:08.849 align:middle
有一个游戏

00:14:08.916 --> 00:14:10.450 align:middle
用户不断升级继续游戏

00:14:11.318 --> 00:14:14.087 align:middle
当用户升级后继续游戏时

00:14:14.154 --> 00:14:18.091 align:middle
你想将进度后台同步到iOS app

00:14:18.292 --> 00:14:20.494 align:middle
iOS app
将展示一些细微图形

00:14:20.861 --> 00:14:22.629 align:middle
说明用户在每个等级是如何操作的

00:14:23.931 --> 00:14:26.333 align:middle
除了用户信息传输

00:14:26.400 --> 00:14:28.535 align:middle
我们还提供文件传输

00:14:29.069 --> 00:14:29.903 align:middle
非常类似

00:14:29.970 --> 00:14:32.606 align:middle
它允许你让内容进行排队等候

00:14:32.673 --> 00:14:34.708 align:middle
在这个案例中 内容是一个文件

00:14:35.676 --> 00:14:38.178 align:middle
在这个展示中 接下来我们要讲到的

00:14:38.245 --> 00:14:40.447 align:middle
关于文件传输的示例是
假设你有一个iOS app

00:14:40.514 --> 00:14:43.050 align:middle
它可让你对图片进行编辑

00:14:43.584 --> 00:14:45.652 align:middle
在编辑完图片后

00:14:45.719 --> 00:14:47.154 align:middle
用户可挑选他们喜欢的

00:14:47.221 --> 00:14:48.789 align:middle
这些喜欢的图片就是

00:14:48.856 --> 00:14:50.357 align:middle
想在Apple Watch显示的

00:14:50.457 --> 00:14:52.526 align:middle
你可以在喜欢的图片之间

00:14:52.593 --> 00:14:54.361 align:middle
使用文件传输进行传输

00:14:54.428 --> 00:14:56.263 align:middle
图片
可通过Apple Watch查看

00:14:56.330 --> 00:14:59.099 align:middle
用户可以向他们的朋友进行展示之类的

00:15:00.300 --> 00:15:02.636 align:middle
让我们一个一个来说

00:15:04.238 --> 00:15:06.240 align:middle
我们从应用上下文开始

00:15:07.007 --> 00:15:07.875 align:middle
为了示范说明

00:15:07.941 --> 00:15:11.178 align:middle
我们使用社交网络app

00:15:11.245 --> 00:15:15.048 align:middle
刚才我提到 这个在iOS上的app

00:15:15.115 --> 00:15:16.583 align:middle
从社交网络网站读取所有的帖子

00:15:16.650 --> 00:15:19.520 align:middle
然后选出最有趣的

00:15:19.586 --> 00:15:21.355 align:middle
发送到Watch app

00:15:22.089 --> 00:15:26.560 align:middle
关于应用上下文
首先要说的是这两个属性

00:15:28.028 --> 00:15:30.497 align:middle
第一个属性Application
Context

00:15:30.697 --> 00:15:34.201 align:middle
它是这样一种属性 先在发送方

00:15:34.268 --> 00:15:36.803 align:middle
然后在接收方存储最新内容

00:15:36.870 --> 00:15:38.839 align:middle
Received
Application

00:15:38.906 --> 00:15:41.675 align:middle
Context将在接收方存储

00:15:41.742 --> 00:15:43.210 align:middle
最新收到的内容

00:15:44.444 --> 00:15:49.449 align:middle
假设这个iOS app
已经读取了一堆的帖子

00:15:49.750 --> 00:15:53.253 align:middle
它也已经为
Watch打包好最有趣的那些

00:15:53.654 --> 00:15:56.423 align:middle
将调用Update
Application Context

00:15:57.024 --> 00:16:00.427 align:middle
这个方法读取一个词典

00:15:57.024 --> 00:16:00.427 align:middle
这个方法读取一个词典

00:16:00.494 --> 00:16:02.663 align:middle
代表你想要发送的最新最有趣的状态

00:16:04.031 --> 00:16:06.867 align:middle
我们获得这个内容 Update

00:16:06.934 --> 00:16:09.203 align:middle
Application
Context被调用后

00:16:09.336 --> 00:16:11.972 align:middle
将它叠加到Application
Context属性

00:16:12.706 --> 00:16:13.974 align:middle
这样内容就在那里了

00:16:14.041 --> 00:16:17.411 align:middle
系统将决定传输内容的最佳时间

00:16:17.744 --> 00:16:20.314 align:middle
或许是当用户
启动他们的Watch的时候

00:16:21.648 --> 00:16:23.317 align:middle
现在 与此同时

00:16:24.351 --> 00:16:29.089 align:middle
这个iOS app可以读取更多内容

00:16:29.456 --> 00:16:31.792 align:middle
并决定它想发送到Watch

00:16:31.859 --> 00:16:33.794 align:middle
最新的有趣信息

00:16:34.194 --> 00:16:36.196 align:middle
在这个示例中
它将再一次调用Update

00:16:36.263 --> 00:16:38.098 align:middle
Application
Context

00:16:38.832 --> 00:16:40.267 align:middle
然后 我们将把那些内容

00:16:40.334 --> 00:16:42.736 align:middle
叠加到Application
Context属性

00:16:42.970 --> 00:16:45.072 align:middle
它将把旧的相关状态清出

00:16:45.138 --> 00:16:47.574 align:middle
并放入新的相关状态
因为我们真正在意的是

00:16:47.641 --> 00:16:51.578 align:middle
那些最有趣 最新的数据集合

00:16:53.180 --> 00:16:55.249 align:middle
这个新内容就在那里了 再一次

00:16:55.315 --> 00:16:56.650 align:middle
等待系统挑选一个合适的时间

00:16:56.717 --> 00:16:58.418 align:middle
将内容传输过去

00:16:59.319 --> 00:17:01.021 align:middle
一旦系统挑出合适的时间

00:16:59.319 --> 00:17:01.021 align:middle
一旦系统挑出合适的时间

00:17:01.154 --> 00:17:02.422 align:middle
内容就会被传输过去

00:17:02.489 --> 00:17:04.657 align:middle
它将
传输到到Apple Watch方

00:17:05.759 --> 00:17:07.493 align:middle
它将等待用户启动app

00:17:07.961 --> 00:17:09.663 align:middle
即Apple Watch app

00:17:10.664 --> 00:17:13.133 align:middle
当app启动后
我们将把内容转传输到

00:17:13.200 --> 00:17:14.968 align:middle
你的WatchKit扩展

00:17:15.035 --> 00:17:18.238 align:middle
这里是在Apple Watch
上所有代码执行的地方

00:17:20.073 --> 00:17:22.576 align:middle
所以以上是应用上下文的流程

00:17:23.210 --> 00:17:25.746 align:middle
我们来看一些代码

00:17:26.413 --> 00:17:29.383 align:middle
你想做的第一件事是打包

00:17:29.716 --> 00:17:32.886 align:middle
你的上下文词典 代表你想要发送的

00:17:33.120 --> 00:17:34.521 align:middle
最新状态的词典

00:17:34.855 --> 00:17:37.291 align:middle
调用Update
Application

00:17:37.357 --> 00:17:38.358 align:middle
Context 你将使用词典

00:17:39.493 --> 00:17:42.696 align:middle
关于代码示例
需要提的最后一件事情是Update

00:17:42.763 --> 00:17:45.599 align:middle
Application
Context调用被打包到

00:17:45.666 --> 00:17:50.037 align:middle
Do Catch块中
这个调用通过调试是事先引导的

00:17:50.404 --> 00:17:52.506 align:middle
这是Swift的新错误处理方式
Update

00:17:52.573 --> 00:17:55.309 align:middle
Application
Context会返回一个错误

00:17:55.576 --> 00:17:59.079 align:middle
若错误被返回
Catch块将被激发

00:17:59.546 --> 00:18:01.849 align:middle
我们强烈建议你

00:17:59.546 --> 00:18:01.849 align:middle
我们强烈建议你

00:18:01.915 --> 00:18:02.850 align:middle
恰当的处理错误

00:18:04.885 --> 00:18:08.355 align:middle
所以这是应用上下文的发送方

00:18:08.856 --> 00:18:10.591 align:middle
我们来看看接收方

00:18:11.792 --> 00:18:13.026 align:middle
在接收方看来

00:18:13.093 --> 00:18:15.028 align:middle
接收方将得到指派回调

00:18:15.095 --> 00:18:17.364 align:middle
Did Receive
Application Context

00:18:17.865 --> 00:18:19.266 align:middle
它将向发送者

00:18:19.366 --> 00:18:20.634 align:middle
发送打包的字典

00:18:21.268 --> 00:18:26.640 align:middle
然后此时 接收者可以获得内容

00:18:26.707 --> 00:18:27.941 align:middle
并更新它的app状态

00:18:28.775 --> 00:18:30.577 align:middle
关于API中这个指派回调

00:18:30.644 --> 00:18:34.081 align:middle
和所有指派回调
我们需要知道的一件事是

00:18:34.147 --> 00:18:36.250 align:middle
它们按照非主要串行队列被返回

00:18:37.317 --> 00:18:38.852 align:middle
假若由于你因为要更新某些UI

00:18:38.919 --> 00:18:41.755 align:middle
而需要在主要队列中做些事情

00:18:41.822 --> 00:18:44.558 align:middle
需要在此内容或其他事情的基础上

00:18:44.625 --> 00:18:47.361 align:middle
发送到主要队列 从而更新你的UI

00:18:49.997 --> 00:18:51.598 align:middle
以上是应用上下文

00:18:52.299 --> 00:18:54.301 align:middle
它是app为另一方所提供的的

00:18:54.368 --> 00:18:56.303 align:middle
最有趣的相关内容

00:18:56.670 --> 00:18:58.305 align:middle
它的行为优先权确实更高

00:18:58.372 --> 00:19:04.178 align:middle
这是因为你重视接收方在意的内容

00:18:58.372 --> 00:19:04.178 align:middle
这是因为你重视接收方在意的内容

00:19:04.244 --> 00:19:06.980 align:middle
并处理最新内容而任何非最新的内容

00:19:07.047 --> 00:19:10.417 align:middle
都是无关紧要的

00:19:12.019 --> 00:19:13.921 align:middle
应用上下文有一个词典

00:19:14.688 --> 00:19:16.924 align:middle
这个词典有属性清单类型

00:19:17.691 --> 00:19:20.561 align:middle
属性清单类型是基本对象类型
比如数字

00:19:20.627 --> 00:19:24.431 align:middle
字符串 基本集合型 字典 阵列

00:19:25.132 --> 00:19:28.135 align:middle
如果你想要更新属性清单类型

00:19:28.302 --> 00:19:31.371 align:middle
Apple有很棒的在线文件

00:19:33.574 --> 00:19:35.876 align:middle
所以 对于应用上下文

00:19:35.943 --> 00:19:37.377 align:middle
我们有一些特别推荐的使用示例

00:19:38.278 --> 00:19:41.715 align:middle
对于Apple Watch app
来说应用上下文真的很不错

00:19:41.849 --> 00:19:44.384 align:middle
因为不少
Apple Watch app展示

00:19:44.451 --> 00:19:46.553 align:middle
iOS所有信息的一个子集

00:19:47.221 --> 00:19:49.923 align:middle
如果app是这样工作的 我们建议你

00:19:49.990 --> 00:19:53.293 align:middle
将那信息的子集放到应用上下文中

00:19:53.660 --> 00:19:56.496 align:middle
让它可发送到Apple Watch

00:19:57.197 --> 00:19:58.732 align:middle
除了这些app

00:19:59.032 --> 00:20:01.902 align:middle
应用上下文在Glance上也很好用

00:19:59.032 --> 00:20:01.902 align:middle
应用上下文在Glance上也很好用

00:20:03.103 --> 00:20:05.672 align:middle
Glance获得app提供的

00:20:05.739 --> 00:20:07.641 align:middle
单个最有趣的数据段

00:20:08.108 --> 00:20:09.843 align:middle
我们建议你将该数据段

00:20:09.910 --> 00:20:12.913 align:middle
放到iOS方的应用上下文中

00:20:12.980 --> 00:20:14.648 align:middle
这样它就可以被传输到Watch方

00:20:14.815 --> 00:20:17.184 align:middle
当用户扫过
手表表面显示Glance时

00:20:17.818 --> 00:20:20.320 align:middle
就可以看到数据了

00:20:22.356 --> 00:20:25.659 align:middle
结束应用上下文部分 现在将继续谈谈

00:20:25.726 --> 00:20:27.361 align:middle
用户信息传输

00:20:28.729 --> 00:20:31.698 align:middle
我们将用到的一个示例是

00:20:32.232 --> 00:20:33.734 align:middle
Apple Watch上有个游戏

00:20:33.800 --> 00:20:36.170 align:middle
用户不断升级从而进行游戏

00:20:36.436 --> 00:20:39.106 align:middle
当用户升级后 你将把进度

00:20:39.173 --> 00:20:41.608 align:middle
后台同步到iOS方

00:20:41.742 --> 00:20:44.344 align:middle
iOS app展示一些细微图形

00:20:45.112 --> 00:20:47.314 align:middle
是关于用户在该等级
的信息用户信息传输要讲到的

00:20:48.015 --> 00:20:53.053 align:middle
第一件事是未解决的用户信息传输队列

00:20:53.420 --> 00:20:55.956 align:middle
这控制了所有

00:20:56.023 --> 00:20:57.291 align:middle
等待传输的内容

00:20:58.492 --> 00:20:59.593 align:middle
当用户升两级后

00:20:59.660 --> 00:21:01.795 align:middle
这时候的当前状态

00:20:59.660 --> 00:21:01.795 align:middle
这时候的当前状态

00:21:02.596 --> 00:21:04.198 align:middle
进度位于

00:21:04.731 --> 00:21:07.601 align:middle
未解决的用户传输队列中

00:21:08.735 --> 00:21:10.771 align:middle
目前 用户的等级是3级

00:21:11.572 --> 00:21:13.774 align:middle
一旦他们再次升级
你将打包那些内容

00:21:13.841 --> 00:21:18.145 align:middle
调用Transfer
User Info

00:21:18.212 --> 00:21:20.480 align:middle
然后传递一个描述进度的词典

00:21:21.648 --> 00:21:24.117 align:middle
获取到该词典后
系统将对其进行打包

00:21:24.384 --> 00:21:27.721 align:middle
并将它放到未解决用户输入
传输队列中

00:21:29.056 --> 00:21:33.093 align:middle
现在这个内容将在这里等待
然后系统会根据电源情况

00:21:33.493 --> 00:21:35.229 align:middle
或在用户
开始使用iPhone的时候

00:21:35.395 --> 00:21:37.731 align:middle
决定传输内容的最佳时机

00:21:39.166 --> 00:21:42.202 align:middle
内容将被传输和先前的API一样

00:21:42.269 --> 00:21:46.406 align:middle
我们需要等待直到iOS上app启动

00:21:46.940 --> 00:21:49.176 align:middle
当它启动后 我们将传输内容

00:21:49.910 --> 00:21:52.212 align:middle
现在iOS app可以更新这些图形

00:21:52.279 --> 00:21:55.082 align:middle
以显示用户在
Apple Watch游戏中的进度

00:21:56.717 --> 00:21:58.886 align:middle
所以这是用户信息传输流程

00:21:59.319 --> 00:22:01.054 align:middle
我们来看一些代码

00:21:59.319 --> 00:22:01.054 align:middle
我们来看一些代码

00:22:03.590 --> 00:22:07.861 align:middle
首先要做打包所有用户信息词典

00:22:08.395 --> 00:22:10.330 align:middle
这代表的是你想要发送的

00:22:10.397 --> 00:22:11.565 align:middle
目前状态的内容全部

00:22:11.932 --> 00:22:14.301 align:middle
然后你调用带有那个词典的

00:22:14.401 --> 00:22:15.369 align:middle
传输用户信息

00:22:16.436 --> 00:22:19.806 align:middle
传输用户信息
返回一个用户信息传输对象

00:22:20.174 --> 00:22:22.409 align:middle
对象包含你正在发送的字典

00:22:22.476 --> 00:22:26.880 align:middle
倘若传输仍然在未解决队列

00:22:26.947 --> 00:22:28.849 align:middle
你可以选择取消这个传输

00:22:29.917 --> 00:22:32.452 align:middle
除了返回这个传输对象

00:22:32.986 --> 00:22:34.755 align:middle
我们也提供了一个方法用来获取所有

00:22:34.821 --> 00:22:37.157 align:middle
仍在队列中的未解决用户信息传输

00:22:37.958 --> 00:22:40.761 align:middle
这方法返回一个数组
你可以迭代这个数组

00:22:40.827 --> 00:22:42.596 align:middle
查看所有内容

00:22:43.263 --> 00:22:45.165 align:middle
若你需要也可取消

00:22:46.400 --> 00:22:48.535 align:middle
所以这是用户信息传输的发送方

00:22:49.570 --> 00:22:51.271 align:middle
我们来看下接收方

00:22:51.605 --> 00:22:54.408 align:middle
在接收方看来你将调用

00:22:54.575 --> 00:22:56.743 align:middle
Did Receive User
Info Transfer

00:22:57.411 --> 00:23:00.247 align:middle
和应用上下文和
其他所有指派回调一样

00:22:57.411 --> 00:23:00.247 align:middle
和应用上下文和
其他所有指派回调一样

00:23:00.314 --> 00:23:02.382 align:middle
这是在一个非主要串联队列中被返回的

00:23:03.784 --> 00:23:06.019 align:middle
一旦你获得回调 就可以获得

00:23:06.119 --> 00:23:08.589 align:middle
内容和词典内容
然后可以更新app状态

00:23:10.591 --> 00:23:12.392 align:middle
那是用户信息传输

00:23:12.626 --> 00:23:14.261 align:middle
它有用户输入词典

00:23:14.561 --> 00:23:17.164 align:middle
这些词典和应用上下文词典一样

00:23:17.231 --> 00:23:18.699 align:middle
里面有属性清单类型

00:23:19.399 --> 00:23:22.603 align:middle
这对于内存内容 比如游戏进度而言
这种方法很好

00:23:23.704 --> 00:23:25.038 align:middle
我们允许你访问

00:23:25.239 --> 00:23:29.710 align:middle
队列中未解决的用户信息传输

00:23:30.844 --> 00:23:33.180 align:middle
接下来 我们谈谈文件传输

00:23:34.481 --> 00:23:36.550 align:middle
文件传输中要用到的示例是

00:23:36.617 --> 00:23:37.784 align:middle
这个图像编辑app

00:23:38.585 --> 00:23:41.054 align:middle
用户可在iOS编辑图片

00:23:41.788 --> 00:23:43.423 align:middle
然后挑选他们喜欢的图片

00:23:43.490 --> 00:23:45.425 align:middle
这些喜欢的图片就是我们想要

00:23:45.492 --> 00:23:47.661 align:middle
传输到Apple Watch上的

00:23:48.996 --> 00:23:49.863 align:middle
所以首先要说的是

00:23:49.930 --> 00:23:52.533 align:middle
未解决的文件传输队列

00:23:53.133 --> 00:23:54.468 align:middle
这里是所有文件传输

00:23:54.535 --> 00:23:56.170 align:middle
等待发送的地方

00:23:57.204 --> 00:23:59.540 align:middle
然后在接收方 文件在等待被转交到

00:23:59.606 --> 00:24:02.476 align:middle
接收方app时 将被放入

00:23:59.606 --> 00:24:02.476 align:middle
接收方app时 将被放入

00:24:02.543 --> 00:24:04.478 align:middle
Documents/Inbox
文件夹

00:24:06.313 --> 00:24:08.515 align:middle
这时候的状态是
用户有两张喜欢的图片

00:24:08.582 --> 00:24:11.652 align:middle
两个图像正在队列里等待

00:24:12.719 --> 00:24:14.054 align:middle
进程进行到第三个

00:24:15.122 --> 00:24:17.357 align:middle
一旦完成进程并且将它挑选为

00:24:17.424 --> 00:24:20.727 align:middle
喜欢的图片后
你将调用Transfer File

00:24:21.461 --> 00:24:24.131 align:middle
你将传输一个文件URL 它指向

00:24:24.198 --> 00:24:27.267 align:middle
你想要传输的文件
我们提供一个方法

00:24:27.334 --> 00:24:31.405 align:middle
以词典的方式传输附加的元数据

00:24:32.306 --> 00:24:35.676 align:middle
你可能想要增加
一些元数据的一个情况是

00:24:35.742 --> 00:24:39.713 align:middle
通过在
每个元数据词典中放一个标识符

00:24:40.180 --> 00:24:43.417 align:middle
将一些文件集合在一起

00:24:43.750 --> 00:24:46.587 align:middle
接收方可以识别那个标识符

00:24:46.687 --> 00:24:48.055 align:middle
把正在接受的文件聚集在一起

00:24:49.556 --> 00:24:51.692 align:middle
所以这是用户喜欢的图片

00:24:51.859 --> 00:24:53.493 align:middle
我们称之为文件传输

00:24:53.560 --> 00:24:56.029 align:middle
现在我们将获得打包好的内容

00:24:56.430 --> 00:24:58.599 align:middle
我们将把它放入未解决的文件传输队列

00:24:59.299 --> 00:25:01.468 align:middle
它将在这里等待 直到系统确定

00:24:59.299 --> 00:25:01.468 align:middle
它将在这里等待 直到系统确定

00:25:01.535 --> 00:25:02.836 align:middle
传输内容的最佳时间

00:25:03.670 --> 00:25:06.640 align:middle
当系统确定传输内容的最佳时间后

00:25:06.974 --> 00:25:08.675 align:middle
它将开始传输内容

00:25:09.042 --> 00:25:14.114 align:middle
等待接收方启动并接收内容

00:25:15.115 --> 00:25:16.617 align:middle
需要注意文件的一件事是

00:25:16.683 --> 00:25:18.619 align:middle
文件可能会稍微大一些

00:25:19.286 --> 00:25:20.888 align:middle
文件越大

00:25:20.954 --> 00:25:22.589 align:middle
传输的时间就越长

00:25:22.990 --> 00:25:25.225 align:middle
当传输的时候 你可能需要注意

00:25:25.292 --> 00:25:27.227 align:middle
电源和性能的情况

00:25:27.661 --> 00:25:29.796 align:middle
请注意
如果准备传输的是大文件

00:25:29.863 --> 00:25:32.266 align:middle
相比使用其他API 这种方法

00:25:32.633 --> 00:25:34.535 align:middle
可能花费更长的时间

00:25:36.069 --> 00:25:37.971 align:middle
现在接收者将启动设备

00:25:38.071 --> 00:25:39.873 align:middle
然后我们将传输这些图像

00:25:40.407 --> 00:25:43.310 align:middle
现在Apple Watch
app可以显示这些图像了

00:25:45.479 --> 00:25:48.615 align:middle
所以这是文件传输流程

00:25:48.682 --> 00:25:49.917 align:middle
我们来看一下代码

00:25:51.552 --> 00:25:53.787 align:middle
首先你想做的是为你想要传输的文件

00:25:53.854 --> 00:25:55.489 align:middle
获取一个URL

00:25:56.190 --> 00:25:58.992 align:middle
然后打包你的元数据 最后

00:25:59.159 --> 00:26:01.762 align:middle
调用Transfer File
传输URL

00:25:59.159 --> 00:26:01.762 align:middle
调用Transfer File
传输URL

00:26:01.828 --> 00:26:03.297 align:middle
以及元数据词典

00:26:04.298 --> 00:26:06.200 align:middle
之后返回一个文件传输对象

00:26:06.333 --> 00:26:09.503 align:middle
文件传输对象包含URL

00:26:09.570 --> 00:26:12.973 align:middle
元数据词典 同样你也可以

00:26:13.040 --> 00:26:16.176 align:middle
取消任何未解决的文件传输

00:26:18.245 --> 00:26:21.114 align:middle
和用户信息传输一样 我们允许你

00:26:21.181 --> 00:26:25.185 align:middle
撤销所有未解决文件传输的数组

00:26:25.485 --> 00:26:27.988 align:middle
你可以迭代这个数组 检查内容

00:26:28.121 --> 00:26:29.323 align:middle
如若需要 也可以取消

00:26:30.724 --> 00:26:32.793 align:middle
所以这就是文件传输的发送方

00:26:33.260 --> 00:26:36.530 align:middle
现在我们来看看接收方

00:26:36.730 --> 00:26:37.931 align:middle
在接收方看来 接收方会收到

00:26:38.065 --> 00:26:41.168 align:middle
这个指派回调
Did Receive File

00:26:42.069 --> 00:26:44.371 align:middle
关于这个指派回调 需要注意的是

00:26:44.438 --> 00:26:46.406 align:middle
它与前面两个略有不同

00:26:47.474 --> 00:26:50.110 align:middle
首先获得WCSession文件对象

00:26:50.944 --> 00:26:54.581 align:middle
这个对象只包含文件URL和元数据

00:26:56.149 --> 00:26:59.219 align:middle
关于这个回调的第二件事是

00:26:59.820 --> 00:27:02.289 align:middle
文件现在位于
app container的

00:26:59.820 --> 00:27:02.289 align:middle
文件现在位于
app container的

00:27:02.356 --> 00:27:04.258 align:middle
Documents/Inbox
文件夹下

00:27:04.892 --> 00:27:08.962 align:middle
说到控制这个文件 你需要将文件移出

00:27:09.029 --> 00:27:11.131 align:middle
Documents/Inbox
并放到另一个

00:27:11.198 --> 00:27:12.566 align:middle
永久位置

00:27:14.735 --> 00:27:18.972 align:middle
移出文件的主要原因是

00:27:19.039 --> 00:27:20.974 align:middle
在指派返回后

00:27:21.041 --> 00:27:23.877 align:middle
Documents/Inbox
将被清空

00:27:24.211 --> 00:27:28.515 align:middle
意思是文件将和其他内容一起被删除

00:27:29.283 --> 00:27:31.852 align:middle
所以重要的是在文件传输之前

00:27:31.919 --> 00:27:35.522 align:middle
将文件放到其他的位置

00:27:36.590 --> 00:27:38.625 align:middle
需要记住一件事 如果你正在指派到

00:27:38.692 --> 00:27:40.794 align:middle
另一个队列 因为这是在从

00:27:40.861 --> 00:27:44.031 align:middle
非重要串行队列返回的

00:27:44.131 --> 00:27:48.368 align:middle
如果该指派不同步的话

00:27:48.969 --> 00:27:50.804 align:middle
你需要在指派之前移动文件

00:27:53.373 --> 00:27:54.875 align:middle
所以这是文件传输

00:27:55.442 --> 00:27:58.445 align:middle
它和用户信息传输非常相似
但是它允许你

00:27:58.512 --> 00:28:01.782 align:middle
传输文件或文件列队

00:27:58.512 --> 00:28:01.782 align:middle
传输文件或文件列队

00:28:02.583 --> 00:28:03.717 align:middle
我们允许你

00:28:03.817 --> 00:28:06.353 align:middle
访问队列中未解决的文件

00:28:07.521 --> 00:28:12.860 align:middle
我们也允许你传输附加元数据

00:28:13.627 --> 00:28:15.796 align:middle
我们建议你使用较小的元数据体积

00:28:16.263 --> 00:28:17.564 align:middle
另外 这个元数据词典

00:28:17.631 --> 00:28:19.533 align:middle
和其他我们说过的词典一样

00:28:19.600 --> 00:28:20.767 align:middle
有属性清单类型

00:28:22.603 --> 00:28:25.005 align:middle
所以以上是三种后台传输模式

00:28:25.205 --> 00:28:27.474 align:middle
若接收放不是立即需要这些内容

00:28:27.541 --> 00:28:28.942 align:middle
请用这些模式

00:28:30.410 --> 00:28:35.983 align:middle
但如果你需要实时来回传输信息

00:28:36.350 --> 00:28:41.255 align:middle
你可以使用交互信息传输

00:28:42.823 --> 00:28:44.758 align:middle
交互信息传输指的是实时通讯

00:28:44.825 --> 00:28:47.728 align:middle
两个app当前都处于开启状态

00:28:48.061 --> 00:28:49.630 align:middle
而且正在来回发送信息

00:28:51.098 --> 00:28:54.134 align:middle
就像我先前提到的
这里有你可能需要这么做的一些示例

00:28:54.801 --> 00:28:58.305 align:middle
假设我们有一个游戏
游戏中两个UI都处于启动状态

00:28:58.438 --> 00:29:01.508 align:middle
而你想要用户与两个UI同时进行交互

00:28:58.438 --> 00:29:01.508 align:middle
而你想要用户与两个UI同时进行交互

00:29:02.042 --> 00:29:04.244 align:middle
或者你正在
使用Apple Watch 你需要

00:29:04.311 --> 00:29:06.780 align:middle
触发iOS app

00:29:06.847 --> 00:29:08.615 align:middle
比如查询用户的位置

00:29:10.284 --> 00:29:12.619 align:middle
如果要使用交互信息传输

00:29:12.986 --> 00:29:15.956 align:middle
需要满足特定条件

00:29:16.190 --> 00:29:17.791 align:middle
所以我们来说说这些条件

00:29:18.625 --> 00:29:20.194 align:middle
这些条件与我们引进的概念有关

00:29:20.527 --> 00:29:22.362 align:middle
这个概念叫做可达性

00:29:23.430 --> 00:29:24.965 align:middle
可达性意思是

00:29:25.132 --> 00:29:29.069 align:middle
其他app也可以访问内容

00:29:29.870 --> 00:29:33.507 align:middle
这要求其他app是可以访问和启动的

00:29:33.707 --> 00:29:36.610 align:middle
从而可以使用交互信息传输

00:29:37.077 --> 00:29:39.346 align:middle
你查看另一方是否可达的方法是

00:29:40.514 --> 00:29:44.518 align:middle
在默认会话中我们有可达性这个属性
这样你可以进行查看

00:29:45.786 --> 00:29:49.189 align:middle
现在
可达性的条件与之前的有些不同

00:29:49.256 --> 00:29:51.825 align:middle
取决于你所处的平台 不论你的代码

00:29:51.892 --> 00:29:53.093 align:middle
是否在iOS app上执行

00:29:53.160 --> 00:29:55.028 align:middle
或是在WatchKit扩展上执行

00:29:55.729 --> 00:29:57.264 align:middle
我们一个一个来看

00:29:58.031 --> 00:29:59.733 align:middle
我们从iPhone开始

00:30:00.667 --> 00:30:04.271 align:middle
满足可达性为True的第一个条件是

00:30:05.405 --> 00:30:07.274 align:middle
设备需被连接

00:30:07.641 --> 00:30:11.044 align:middle
我们可以通过Bluetooth
或Wi-Fi连接

00:30:11.912 --> 00:30:13.714 align:middle
但是如果用户将Watch放在家里

00:30:14.381 --> 00:30:17.084 align:middle
拿了iPhone去上班
这种情况下设备就无法被连接

00:30:17.417 --> 00:30:19.620 align:middle
交互信息传输就无法进行

00:30:20.621 --> 00:30:23.123 align:middle
iOS上可达性为True

00:30:23.190 --> 00:30:25.359 align:middle
需要满足的第二个条件是

00:30:25.492 --> 00:30:27.995 align:middle
Watch app
必须处于前台操作状态

00:30:28.395 --> 00:30:31.532 align:middle
意思是为了在
iOS上进行交换信息传输

00:30:31.732 --> 00:30:34.735 align:middle
用户必须与Watch app交互

00:30:35.536 --> 00:30:37.137 align:middle
一旦满足以上两个条件

00:30:38.672 --> 00:30:41.475 align:middle
你的iOS app上
可达性属性也将为True

00:30:44.011 --> 00:30:45.412 align:middle
所以这是iPhone方面

00:30:47.181 --> 00:30:49.016 align:middle
来说说Apple Watch方面

00:30:49.683 --> 00:30:51.752 align:middle
在你的WatchKit扩展设备上

00:30:51.952 --> 00:30:53.720 align:middle
可达性为True的第一个条件是

00:30:53.787 --> 00:30:56.256 align:middle
必须连接设备

00:30:57.391 --> 00:30:59.927 align:middle
意思是说倘若用户去跑步
没带iPhone

00:30:59.993 --> 00:31:01.461 align:middle
只带了Watch

00:30:59.993 --> 00:31:01.461 align:middle
只带了Watch

00:31:02.829 --> 00:31:05.299 align:middle
可达性就不会为True
设备将无法被连接

00:31:06.200 --> 00:31:07.167 align:middle
第二个条件是

00:31:07.901 --> 00:31:10.404 align:middle
WatchKit
外设必须处于前台运行状态

00:31:11.305 --> 00:31:13.674 align:middle
提到WatchKit
外设处于前台运行状态

00:31:13.740 --> 00:31:15.275 align:middle
是因为在不少示例中

00:31:15.342 --> 00:31:17.611 align:middle
WatchKit外设可以在后台运行

00:31:18.245 --> 00:31:20.013 align:middle
主要
与complication有关

00:31:20.080 --> 00:31:22.683 align:middle
我们等下会谈到这个

00:31:23.584 --> 00:31:27.788 align:middle
所以现在 当用户使用你的app时

00:31:27.855 --> 00:31:29.389 align:middle
你的WatchKit外设

00:31:29.523 --> 00:31:31.692 align:middle
也将被启动并被置于前台运行状态

00:31:31.792 --> 00:31:33.794 align:middle
这也就是说
你可以使用交互信息传输

00:31:34.328 --> 00:31:36.163 align:middle
并且可达性属性为True

00:31:37.731 --> 00:31:39.867 align:middle
关于这个图表 还需要注意的是

00:31:40.267 --> 00:31:43.003 align:middle
我们并没有
说iOS app当前正在运行

00:31:44.104 --> 00:31:49.276 align:middle
iOS app必须处于运行状态
以对进来的信息作出反应

00:31:49.476 --> 00:31:50.711 align:middle
并发出自己的信息

00:31:51.044 --> 00:31:53.780 align:middle
所以当iOS app
在WatchKit外设之外运行时

00:31:53.847 --> 00:31:55.449 align:middle
我们如何进入一个状态呢

00:31:56.083 --> 00:31:59.887 align:middle
仅针对这个词典将信息
从Watch发送到iPhone

00:32:00.153 --> 00:32:03.857 align:middle
或者允许iOS app

00:32:04.057 --> 00:32:06.460 align:middle
在接收信息的基础上
在后台启动

00:32:07.261 --> 00:32:08.695 align:middle
我们拿这个做例子

00:32:08.795 --> 00:32:10.297 align:middle
你有一个运行追踪器app

00:32:10.764 --> 00:32:13.767 align:middle
它需要发送信息到iPhone

00:32:13.834 --> 00:32:19.506 align:middle
告诉CoreLocation
开始追踪用户的信息

00:32:20.641 --> 00:32:23.911 align:middle
所以这个app将打包一个信息

00:32:23.977 --> 00:32:26.547 align:middle
告诉iOS app开始运行
CoreLocation

00:32:27.281 --> 00:32:29.016 align:middle
它将发出启动信息

00:32:29.082 --> 00:32:31.151 align:middle
当系统受到这个信息时

00:32:31.218 --> 00:32:33.086 align:middle
我们将在后台启动iOS app

00:32:33.554 --> 00:32:34.688 align:middle
并传输那个信息

00:32:35.122 --> 00:32:38.258 align:middle
现在 两个app都在运行
它们可以进行互动了

00:32:38.659 --> 00:32:41.461 align:middle
这个示例中的app

00:32:41.528 --> 00:32:42.596 align:middle
可以开始追踪用户位置

00:32:43.997 --> 00:32:46.466 align:middle
所以那是交互信息传输流

00:32:47.801 --> 00:32:48.802 align:middle
当你可以使用它时

00:32:48.869 --> 00:32:50.604 align:middle
它如何和可达性有关系

00:32:50.771 --> 00:32:52.506 align:middle
现在我们来具体讲讲

00:32:52.573 --> 00:32:53.941 align:middle
如何在你的代码中使用它

00:32:55.509 --> 00:32:57.377 align:middle
我提供两种不同类型的信息

00:32:57.978 --> 00:32:59.746 align:middle
第一种发出一个词典

00:33:00.214 --> 00:33:02.516 align:middle
你使用
词典调用Send Message

00:33:02.749 --> 00:33:03.984 align:middle
这个调用携带词典

00:33:04.051 --> 00:33:06.420 align:middle
加上一个回复处理器
和一个错误处理器

00:33:07.387 --> 00:33:10.057 align:middle
这个词典
和我们先前说过的词典一样

00:33:10.123 --> 00:33:12.359 align:middle
里面有属性清单类型

00:33:14.561 --> 00:33:16.129 align:middle
除了词典外

00:33:16.196 --> 00:33:18.999 align:middle
我们还引入了发送数据的方法

00:33:19.533 --> 00:33:21.935 align:middle
可调用Send
Message Data发送数据

00:33:22.002 --> 00:33:24.605 align:middle
这个携带数据 相同的回复处理器

00:33:24.805 --> 00:33:25.939 align:middle
和错误处理器

00:33:26.807 --> 00:33:30.410 align:middle
关于发送数据

00:33:30.477 --> 00:33:32.079 align:middle
如果你有存储自己信息的
自定义数据

00:33:32.412 --> 00:33:34.548 align:middle
或你自己的序列化格式
我们建议你使用这个

00:33:35.983 --> 00:33:38.418 align:middle
若你使用自己的序列化格式

00:33:38.485 --> 00:33:41.755 align:middle
我们强烈建议你使用小而快的格式

00:33:42.155 --> 00:33:45.025 align:middle
这样用户体验更快

00:33:45.092 --> 00:33:46.927 align:middle
因为内容可以更快进行传输

00:33:48.729 --> 00:33:52.533 align:middle
关于这些调用
我想要指出一点 就是回复

00:33:53.100 --> 00:33:56.103 align:middle
你或许注意
到了先前两个调用中有回复处理器

00:33:57.571 --> 00:33:59.173 align:middle
这个处理器是可选的

00:33:59.673 --> 00:34:02.543 align:middle
然而 在多数情况下
我们建议你使用它

00:33:59.673 --> 00:34:02.543 align:middle
然而 在多数情况下
我们建议你使用它

00:34:03.377 --> 00:34:05.746 align:middle
原因是

00:34:05.812 --> 00:34:07.714 align:middle
这可让接收者确认进来的信息

00:34:08.447 --> 00:34:10.551 align:middle
接收者可以确认它接收到信息

00:34:10.650 --> 00:34:13.020 align:middle
信息包含正确的内容

00:34:13.085 --> 00:34:14.321 align:middle
它也可以处理那些内容

00:34:14.955 --> 00:34:18.525 align:middle
这样一来 发送方就知道
它不需要再发送任何东西了

00:34:18.792 --> 00:34:20.293 align:middle
它不需要在发送新信息了

00:34:20.360 --> 00:34:21.527 align:middle
因为它发的是错误的信息

00:34:23.996 --> 00:34:27.601 align:middle
回复需要谈到的另一部分是

00:34:28.302 --> 00:34:30.003 align:middle
接收方这边的情况

00:34:31.938 --> 00:34:36.043 align:middle
如果发送者说 我想要回复
所以我将提供一个回复处理器

00:34:36.109 --> 00:34:38.712 align:middle
与之相反的 如果发送者说

00:34:38.779 --> 00:34:41.614 align:middle
我不想回复 不提供一个回复处理器
这时会发生什么呢

00:34:42.616 --> 00:34:43.617 align:middle
这种情况下

00:34:43.684 --> 00:34:46.920 align:middle
接收方会收到单独指派回调

00:34:46.987 --> 00:34:49.022 align:middle
这取决于
我们是否应该提供回复

00:34:51.058 --> 00:34:53.226 align:middle
我们来说说这些指派回调

00:34:53.760 --> 00:34:56.797 align:middle
第一种情况 发送者说

00:34:57.164 --> 00:34:59.032 align:middle
我需要回复
我为系统提供一个回复处理器

00:34:59.466 --> 00:35:01.969 align:middle
意思是接收方将收到
这个指派回调

00:34:59.466 --> 00:35:01.969 align:middle
意思是接收方将收到
这个指派回调

00:35:02.035 --> 00:35:06.039 align:middle
Did Receive
Message它有一个回复块

00:35:06.440 --> 00:35:10.277 align:middle
你可以在接收者接收
并处理信息之后调用回复块

00:35:10.644 --> 00:35:12.346 align:middle
接收者就可以决定

00:35:12.412 --> 00:35:14.281 align:middle
是否发回一些内容

00:35:14.348 --> 00:35:17.184 align:middle
或者如果信息是错误的
就发回一个错误

00:35:18.785 --> 00:35:19.953 align:middle
现在 从另一方面来说

00:35:20.020 --> 00:35:24.124 align:middle
倘若发送者
并未提供一个回复处理器

00:35:25.359 --> 00:35:26.493 align:middle
接收者将获得

00:35:26.560 --> 00:35:29.930 align:middle
指派回调
Did Receive Message

00:35:30.330 --> 00:35:31.932 align:middle
它没有回复块

00:35:31.999 --> 00:35:34.134 align:middle
接收方可以处理进来的内容

00:35:34.368 --> 00:35:35.269 align:middle
然后就结束了

00:35:36.470 --> 00:35:37.638 align:middle
关于这两个指派回调

00:35:37.704 --> 00:35:40.741 align:middle
需要注意的
最后一件事是他们通过一个词典

00:35:41.842 --> 00:35:45.612 align:middle
意思是说发送者使用发送信息

00:35:45.712 --> 00:35:49.249 align:middle
从发送方这边发送出一个词典

00:35:49.783 --> 00:35:54.888 align:middle
倘若 发送者使用发送信息数据
发送数据

00:35:55.522 --> 00:35:59.593 align:middle
在接收方会收到
一个类似的回调通过数据

00:36:01.895 --> 00:36:05.499 align:middle
现在 我们简单了解了交互信息传输

00:36:05.566 --> 00:36:08.402 align:middle
将所有的这些放在一起
并进行编码

00:36:09.203 --> 00:36:10.470 align:middle
你首先要做的是

00:36:11.004 --> 00:36:12.105 align:middle
检查可达性

00:36:12.573 --> 00:36:15.075 align:middle
确保另一边是确实可达的

00:36:15.742 --> 00:36:20.147 align:middle
然后 倘若可达性为True
那你就可以打包你的信息了

00:36:21.515 --> 00:36:23.050 align:middle
一旦你有了信息

00:36:23.183 --> 00:36:25.419 align:middle
你就可以使用词典
调用Send Message

00:36:26.486 --> 00:36:27.654 align:middle
然后期待收到一个回复

00:36:27.721 --> 00:36:29.723 align:middle
所以我们将提供回复处理器

00:36:31.124 --> 00:36:32.759 align:middle
我们想要处理我们的错误

00:36:32.960 --> 00:36:34.528 align:middle
所以我们将启动错误处理器

00:36:36.296 --> 00:36:38.232 align:middle
使用
WatchConnectivity

00:36:38.298 --> 00:36:40.167 align:middle
传输内容的不同方法

00:36:41.268 --> 00:36:42.369 align:middle
来总结一下所讲的

00:36:42.436 --> 00:36:44.404 align:middle
关于
WatchConnectivity

00:36:46.039 --> 00:36:47.374 align:middle
首先要做的是

00:36:47.441 --> 00:36:48.775 align:middle
设置会话

00:36:50.844 --> 00:36:53.347 align:middle
为做到这个 你设置指派
调用Activate

00:36:53.747 --> 00:36:56.416 align:middle
你需在app的使用周期里今早执行

00:36:56.683 --> 00:36:59.219 align:middle
这样app就可以开始接收内容

00:36:59.553 --> 00:37:01.121 align:middle
然后检查属性

00:36:59.553 --> 00:37:01.121 align:middle
然后检查属性

00:37:02.923 --> 00:37:05.425 align:middle
在检查这些属性时候
你可以查看会话状态

00:37:06.226 --> 00:37:07.561 align:middle
一旦一切都好了

00:37:07.628 --> 00:37:09.263 align:middle
而且你知道Watch已经配对

00:37:09.630 --> 00:37:11.765 align:middle
同时Apple Watch app
也安装了

00:37:12.199 --> 00:37:13.333 align:middle
你就可以开始通讯了

00:37:15.235 --> 00:37:17.671 align:middle
第一种沟通是后台传输

00:37:19.640 --> 00:37:21.241 align:middle
我们提供三种类型

00:37:21.742 --> 00:37:23.477 align:middle
第一种是应用上下文

00:37:23.810 --> 00:37:27.281 align:middle
这是信息的单一子集

00:37:27.347 --> 00:37:28.882 align:middle
这个子集是
为另一方app准备的

00:37:29.349 --> 00:37:30.951 align:middle
或者 倘若你需要列队内容

00:37:31.151 --> 00:37:34.321 align:middle
你可以使用用户信息传输
或文件传输

00:37:36.156 --> 00:37:37.724 align:middle
除了后台传输

00:37:37.791 --> 00:37:39.560 align:middle
在实时沟通方面

00:37:39.960 --> 00:37:41.395 align:middle
我们还可以使用交互信息传输

00:37:42.996 --> 00:37:44.498 align:middle
就是
WatchConnectivity

00:37:44.565 --> 00:37:47.034 align:middle
它允许你的
app进行设备对设备的通讯

00:37:47.501 --> 00:37:49.703 align:middle
我们非常期待

00:37:50.370 --> 00:37:52.806 align:middle
你们会如何使用这个API进行通讯

00:37:52.873 --> 00:37:54.775 align:middle
如何提供更棒的用户体验

00:37:55.843 --> 00:38:00.280 align:middle
接下来...
将简要说说NSURLSession

00:37:55.843 --> 00:38:00.280 align:middle
接下来...
将简要说说NSURLSession

00:38:01.381 --> 00:38:03.050 align:middle
什么是NSURLSession

00:38:03.517 --> 00:38:05.485 align:middle
它是一个现有的基础类

00:38:06.053 --> 00:38:08.755 align:middle
它允许你为服务器提出HTTP请求

00:38:09.089 --> 00:38:10.824 align:middle
从而读取内容

00:38:11.758 --> 00:38:14.895 align:middle
它在watchOS 2上适用
倘若在你的服务器上

00:38:14.962 --> 00:38:17.331 align:middle
有内容需要读取
我强烈建议你使用它

00:38:17.865 --> 00:38:20.801 align:middle
它利用了
Tetherless Wi-Fi特征

00:38:21.401 --> 00:38:24.137 align:middle
在没带iPhone的时候
Tetherless Wi-Fi

00:38:24.204 --> 00:38:26.807 align:middle
允许Apple Watch
连接到已知的Wi-Fi网络

00:38:27.774 --> 00:38:30.444 align:middle
若Apple Watch
已经连接到已知Wi-Fi网络

00:38:30.511 --> 00:38:34.948 align:middle
你可使用NSURLSession
通过Wi-Fi网络

00:38:35.015 --> 00:38:36.917 align:middle
连接到你的服务器并获取信息

00:38:39.152 --> 00:38:41.488 align:middle
所以你会如何
使用NSURLSession呢？

00:38:41.655 --> 00:38:44.925 align:middle
当你的服务器有新内容时
你都可以使用它

00:38:45.592 --> 00:38:47.861 align:middle
这个和你通过
iOS app进行的操作

00:38:47.928 --> 00:38:49.029 align:middle
非常的相似

00:38:49.796 --> 00:38:54.735 align:middle
我们建议
根据Apple Watch的需求

00:38:54.801 --> 00:39:00.674 align:middle
定制发送到
Apple Watch的内容

00:38:54.801 --> 00:39:00.674 align:middle
定制发送到
Apple Watch的内容

00:39:01.108 --> 00:39:03.043 align:middle
若你的服务器上有图片

00:39:03.844 --> 00:39:08.549 align:middle
建议按照Apple Watch
屏幕尺寸按比例决定图片尺寸

00:39:08.815 --> 00:39:10.384 align:middle
若是一个新app

00:39:10.450 --> 00:39:13.554 align:middle
你只想在Apple Watch
上显示部分内容或许只是文本

00:39:13.754 --> 00:39:15.756 align:middle
我们建议你
只截取你所需的部分

00:39:17.357 --> 00:39:20.827 align:middle
以上是关于
NSURLSession的简要介绍

00:39:21.361 --> 00:39:26.466 align:middle
在WWDC会议上
有关于这个API的部分

00:39:26.533 --> 00:39:27.734 align:middle
同样也有在线资源部分

00:39:28.335 --> 00:39:30.604 align:middle
我们建议你看看这些

00:39:31.205 --> 00:39:32.706 align:middle
关于NSURLSession

00:39:32.773 --> 00:39:35.676 align:middle
最后要讲的是使用
WatchConnectivity

00:39:36.343 --> 00:39:37.778 align:middle
NSURLSession

00:39:38.645 --> 00:39:41.081 align:middle
再一次 我们有新app的示例

00:39:42.149 --> 00:39:45.719 align:middle
这个新app从它的
服务器上读取一些内容

00:39:46.186 --> 00:39:47.254 align:middle
而且它知道

00:39:47.321 --> 00:39:51.024 align:middle
Apple Watch app
可能将读取这些相同内容

00:39:51.391 --> 00:39:54.228 align:middle
下次用户启动
Apple Watch app时

00:39:54.595 --> 00:39:58.131 align:middle
为了不让Apple Watch
app重新获取内容

00:39:58.732 --> 00:40:01.969 align:middle
我将利用应用上下文

00:39:58.732 --> 00:40:01.969 align:middle
我将利用应用上下文

00:40:02.169 --> 00:40:04.671 align:middle
将内容从iOS传输到Watch

00:40:06.874 --> 00:40:09.076 align:middle
内容会不断被传输进来

00:40:09.142 --> 00:40:11.612 align:middle
再启动Apple Watch
app会被传输到它上

00:40:11.678 --> 00:40:13.547 align:middle
Apple Watch app可以

00:40:13.614 --> 00:40:16.550 align:middle
显示在iOS上看到的相同内容

00:40:16.917 --> 00:40:19.253 align:middle
而且它提供更多的细微体验

00:40:20.754 --> 00:40:23.624 align:middle
用户下次启动
Apple Watch app时

00:40:23.690 --> 00:40:25.993 align:middle
可能是数小时后

00:40:26.193 --> 00:40:29.129 align:middle
这也就说

00:40:29.196 --> 00:40:30.397 align:middle
服务器有更新的内容要读取

00:40:30.797 --> 00:40:31.965 align:middle
所以 我们建议

00:40:32.032 --> 00:40:35.602 align:middle
除了在应用上下文
获取已经发送的内容外

00:40:36.403 --> 00:40:39.306 align:middle
使用带NSURLSession
的HTTP请求

00:40:39.373 --> 00:40:43.076 align:middle
从你的服务器上
读取绝对最新的内容

00:40:44.411 --> 00:40:47.447 align:middle
这样
在用户等待新内容时

00:40:47.514 --> 00:40:50.450 align:middle
他们将看到
在iOS上看到的相同内容

00:40:50.517 --> 00:40:53.954 align:middle
这样将有更好的体验

00:40:55.756 --> 00:40:57.624 align:middle
所以这是NSURLSession和

00:40:57.691 --> 00:40:59.526 align:middle
WatchConnectivity

00:40:59.860 --> 00:41:03.530 align:middle
现在 我们想要采用这两种API
我们想要为你展示

00:40:59.860 --> 00:41:03.530 align:middle
现在 我们想要采用这两种API
我们想要为你展示

00:41:03.597 --> 00:41:06.633 align:middle
如何使用它们获取数据
放到complication中

00:41:07.067 --> 00:41:09.469 align:middle
关于这部分

00:41:09.536 --> 00:41:11.605 align:middle
有请克里斯上台为我们讲解

00:41:18.512 --> 00:41:20.781 align:middle
谢谢你 亚历克斯
这些东西很酷 是吧

00:41:21.248 --> 00:41:24.618 align:middle
我想你们使用
Watch Connectivity API

00:41:24.718 --> 00:41:26.720 align:middle
和NSURLSession API

00:41:26.787 --> 00:41:28.856 align:middle
做的东西 一定很棒

00:41:29.590 --> 00:41:31.592 align:middle
现在我们来讨论
complications

00:41:31.658 --> 00:41:34.161 align:middle
在深入讲解之前

00:41:34.228 --> 00:41:35.896 align:middle
先确定大家看的是一个内容

00:41:36.763 --> 00:41:38.866 align:middle
这些是在Apple Watch上的

00:41:38.932 --> 00:41:41.535 align:middle
三个Watch表面 三个时钟画面

00:41:41.802 --> 00:41:43.470 align:middle
若你移除时钟

00:41:43.971 --> 00:41:45.806 align:middle
剩下的就是
complications

00:41:46.707 --> 00:41:48.475 align:middle
每次用户看时钟画面时

00:41:48.542 --> 00:41:53.647 align:middle
他们会看到少量信息

00:41:54.281 --> 00:41:57.317 align:middle
这将让用户可以快速获得

00:41:57.384 --> 00:41:59.853 align:middle
最重要的信息

00:42:02.222 --> 00:42:04.157 align:middle
当你使用complication时

00:42:04.224 --> 00:42:06.460 align:middle
你将需要解决两个主要任务

00:42:07.494 --> 00:42:09.997 align:middle
你需要知道如何更新时钟画面

00:42:10.430 --> 00:42:14.134 align:middle
第二件事是 你需要拿到
用来更新时钟画面的内容

00:42:16.603 --> 00:42:18.872 align:middle
我们来讨论一下 你如何
简单地更新时钟画面

00:42:18.939 --> 00:42:21.241 align:middle
其他会议上 有深入讨论

00:42:22.176 --> 00:42:24.545 align:middle
在这个示例中

00:42:24.611 --> 00:42:27.181 align:middle
用一个天气app
有个月相complication

00:42:27.447 --> 00:42:29.750 align:middle
这个月相complication
不需外部数据

00:42:29.816 --> 00:42:31.585 align:middle
它已经有它所需的全部信息

00:42:31.652 --> 00:42:33.053 align:middle
因为它只需要数据和时间

00:42:34.054 --> 00:42:37.758 align:middle
所以它所关心的是如何更新时钟画面

00:42:38.892 --> 00:42:41.628 align:middle
为做到这点
它将使用新ClockKit API

00:42:41.962 --> 00:42:44.064 align:middle
watchOS 2
引进的ClockKit框架

00:42:46.500 --> 00:42:50.204 align:middle
流程运作的方式是

00:42:50.270 --> 00:42:52.706 align:middle
我们将在
后台启动WatchKit外设

00:42:55.008 --> 00:42:57.711 align:middle
当这发生时 我们将获取到

00:42:57.811 --> 00:43:00.013 align:middle
一个CLK
complications服务器例

00:42:57.811 --> 00:43:00.013 align:middle
一个CLK
complications服务器例

00:43:00.380 --> 00:43:02.449 align:middle
你调用
Shared Instance来实现

00:43:02.616 --> 00:43:05.786 align:middle
用Extend Timeline
For Complication

00:43:06.186 --> 00:43:08.388 align:middle
进入正在更新的
complication

00:43:10.624 --> 00:43:12.125 align:middle
接下来会发生的是

00:43:12.192 --> 00:43:14.228 align:middle
它们将调用ClockKit激发程序

00:43:14.428 --> 00:43:16.830 align:middle
然后开始问一堆的问题

00:43:17.097 --> 00:43:19.099 align:middle
它们询问现有时间轴项目

00:43:19.499 --> 00:43:21.201 align:middle
这是即将显示的内容之一

00:43:23.003 --> 00:43:25.706 align:middle
它们询问先前的时间轴项目

00:43:26.106 --> 00:43:29.877 align:middle
未来的时间轴项目

00:43:30.043 --> 00:43:32.513 align:middle
最后它们询问你的建议
什么时候这些数据才算过时

00:43:32.679 --> 00:43:35.349 align:middle
这是给系统的建议

00:43:35.616 --> 00:43:37.851 align:middle
这样我们才知道
你什么时候需要再次启动

00:43:38.752 --> 00:43:40.888 align:middle
你可以进一步更新时间轴

00:43:42.256 --> 00:43:45.859 align:middle
以上是更新时钟画面的 简要介绍

00:43:45.926 --> 00:43:48.996 align:middle
你可用ClockKit来做上述事情

00:43:49.329 --> 00:43:50.964 align:middle
你可以提供过去的

00:43:51.031 --> 00:43:52.566 align:middle
现在的 以及未来的内容

00:43:54.501 --> 00:43:57.738 align:middle
你的WatchKit外设将在后台
进行这些更新

00:43:58.238 --> 00:43:59.339 align:middle
而且你可以规定

00:43:59.406 --> 00:44:01.775 align:middle
所提供的的内容什么时候过时

00:43:59.406 --> 00:44:01.775 align:middle
所提供的的内容什么时候过时

00:44:02.876 --> 00:44:04.144 align:middle
需要注意的一点是

00:44:04.278 --> 00:44:07.748 align:middle
WatchKit外设更新

00:44:07.814 --> 00:44:09.583 align:middle
complication动作是预设

00:44:09.950 --> 00:44:12.653 align:middle
所以你尽可能使之尽快完成

00:44:12.719 --> 00:44:15.489 align:middle
这样就可以
一整天保持启动状态

00:44:15.722 --> 00:44:17.457 align:middle
以更新你的complication

00:44:19.026 --> 00:44:21.495 align:middle
正如我提到的关于这个话题
有个很棒的演讲

00:44:21.562 --> 00:44:23.664 align:middle
Creating Complications

00:44:23.730 --> 00:44:26.600 align:middle
with ClockKit
如果你还没看过 我们希望你去看一下

00:44:27.734 --> 00:44:29.436 align:middle
下一个你必须做的事是

00:44:29.503 --> 00:44:32.005 align:middle
如何将内容
放到你的complication

00:44:32.272 --> 00:44:35.843 align:middle
有个特别的示例即初始激活

00:44:35.909 --> 00:44:39.746 align:middle
用户首次进入时钟画面时

00:44:39.880 --> 00:44:41.181 align:middle
他可以进入对其进行编辑

00:44:41.849 --> 00:44:43.550 align:middle
会启动你的complication

00:44:43.617 --> 00:44:45.752 align:middle
这里指的是
新app complication

00:44:45.986 --> 00:44:46.987 align:middle
此刻

00:44:47.054 --> 00:44:50.023 align:middle
那个
complication的时间轴上

00:44:50.090 --> 00:44:51.725 align:middle
数据可能很少或甚至没有数据

00:44:52.392 --> 00:44:54.328 align:middle
所以它对内容有大量的需求

00:44:56.230 --> 00:44:57.965 align:middle
马上要做的是

00:44:58.031 --> 00:45:00.000 align:middle
立即在后台启动WatchKit外设

00:45:00.667 --> 00:45:03.203 align:middle
现在 你有很多方式可以获得内容

00:45:03.470 --> 00:45:06.473 align:middle
所以 你可以初始化时间轴

00:45:09.009 --> 00:45:11.979 align:middle
你可以调用NSURLSession
与服务器通讯

00:45:12.446 --> 00:45:14.248 align:middle
从而获得内容

00:45:15.249 --> 00:45:17.618 align:middle
或可选择使用
WatchConnectivity

00:45:18.352 --> 00:45:20.087 align:middle
若你在这个特别情况下

00:45:20.153 --> 00:45:22.356 align:middle
使用
WatchConnectivity

00:45:22.422 --> 00:45:26.226 align:middle
设备是连接的
你会发现可达性为True

00:45:26.293 --> 00:45:28.328 align:middle
这是亚历克斯先前提到的

00:45:28.629 --> 00:45:30.030 align:middle
在特定情况下

00:45:30.097 --> 00:45:32.332 align:middle
这时候的这个属性是True

00:45:32.399 --> 00:45:33.300 align:middle
这是其中之一

00:45:33.934 --> 00:45:37.204 align:middle
在这个示例中
另外可调用Send Message

00:45:37.471 --> 00:45:40.507 align:middle
它将把信息传输到iPhone上

00:45:40.941 --> 00:45:44.845 align:middle
我们将在后台启动天气app

00:45:45.646 --> 00:45:48.382 align:middle
此时 iOS上的天气app

00:45:48.448 --> 00:45:52.119 align:middle
可以使用任何
WatchConnectivity

00:45:52.186 --> 00:45:54.721 align:middle
API返回信息并填充到时间轴

00:45:58.358 --> 00:45:59.226 align:middle
总的来说

00:45:59.293 --> 00:46:01.295 align:middle
当你运行初始激活时

00:45:59.293 --> 00:46:01.295 align:middle
当你运行初始激活时

00:46:01.528 --> 00:46:03.830 align:middle
WatchKit外设将在后台启动

00:46:03.964 --> 00:46:06.733 align:middle
你可以使用
NSURLSession或者

00:46:06.800 --> 00:46:09.736 align:middle
因为这是非常特殊的情况

00:46:10.070 --> 00:46:13.207 align:middle
WatchConnectivity
API启动iOS app

00:46:13.340 --> 00:46:14.775 align:middle
因为可达性为True

00:46:15.442 --> 00:46:16.710 align:middle
我建议你用这个

00:46:16.777 --> 00:46:19.780 align:middle
尽可能多
的填充ClockKit时间轴

00:46:19.980 --> 00:46:22.316 align:middle
因为开始时 里面没有数据

00:46:23.717 --> 00:46:26.854 align:middle
接下来是如何保持最新状态

00:46:28.088 --> 00:46:29.656 align:middle
你的时间轴现在已被填满

00:46:29.723 --> 00:46:31.758 align:middle
而更新也即将开始

00:46:31.825 --> 00:46:33.794 align:middle
如何
保持更新complication

00:46:35.295 --> 00:46:36.496 align:middle
有很多不同的方法

00:46:36.563 --> 00:46:39.566 align:middle
可以用来
更新你的complication

00:46:40.033 --> 00:46:42.436 align:middle
你可以将
内容传输到complication

00:46:43.036 --> 00:46:45.372 align:middle
也就是说 若你有个外部源

00:46:45.439 --> 00:46:48.175 align:middle
比如说web服务器
它知道新内容出现的具体时间

00:46:48.242 --> 00:46:51.144 align:middle
而且是不定期更新的

00:46:51.812 --> 00:46:53.714 align:middle
你将做的是

00:46:53.780 --> 00:46:55.849 align:middle
将内容从云中拿出 放到iPhone

00:46:56.183 --> 00:46:57.985 align:middle
然后传输到Apple Watch

00:46:58.952 --> 00:47:02.155 align:middle
我们比较容易理解这点的
一个示例是比如体育app

00:46:58.952 --> 00:47:02.155 align:middle
我们比较容易理解这点的
一个示例是比如体育app

00:47:02.356 --> 00:47:05.792 align:middle
显示比赛
分数时就是complication

00:47:06.693 --> 00:47:07.561 align:middle
多数时间里

00:47:07.628 --> 00:47:10.697 align:middle
分数只在一天当中
很短的一段时间内发生改变

00:47:10.764 --> 00:47:12.766 align:middle
所以可以很快进行更新

00:47:13.066 --> 00:47:15.435 align:middle
然后 接下来我们认为
更合理的方法是使用推送方法

00:47:15.569 --> 00:47:18.205 align:middle
另一个方法是我正在调用请求间隔读取

00:47:18.672 --> 00:47:20.674 align:middle
这个更多的是用在
你知道有定期更新的情况

00:47:20.774 --> 00:47:23.076 align:middle
这样你可以保持
更新你的complication

00:47:23.143 --> 00:47:24.912 align:middle
可用
像NSURLSession

00:47:24.978 --> 00:47:27.147 align:middle
直接进入云

00:47:27.781 --> 00:47:32.152 align:middle
有些冲浪app带有
潮汐complication

00:47:32.319 --> 00:47:34.454 align:middle
显示潮汐模式

00:47:34.521 --> 00:47:37.724 align:middle
这样你就可以知道
什么时候可以冲浪了

00:47:38.959 --> 00:47:40.961 align:middle
我们先来看一下这个例子

00:47:44.665 --> 00:47:47.701 align:middle
你想用NSURLSession
和ClockKit

00:47:47.768 --> 00:47:49.236 align:middle
更新complication

00:47:49.303 --> 00:47:51.505 align:middle
从时钟画面的角落可看到

00:47:51.572 --> 00:47:53.941 align:middle
冲浪complication
已经启动

00:47:55.776 --> 00:47:58.045 align:middle
这个流程看起来是这样的

00:47:58.111 --> 00:48:00.647 align:middle
在后台启动的WatchKit外设

00:47:58.111 --> 00:48:00.647 align:middle
在后台启动的WatchKit外设

00:48:01.181 --> 00:48:04.084 align:middle
你想创建一个
NSURLSession请求

00:48:04.151 --> 00:48:06.453 align:middle
并将它发送到服务器
以获取内容

00:48:07.287 --> 00:48:09.056 align:middle
服务器将生成一个响应

00:48:09.122 --> 00:48:11.625 align:middle
并将传输回WatchKit外设

00:48:12.359 --> 00:48:15.229 align:middle
现在你想打开并更新ClockKit

00:48:15.295 --> 00:48:18.732 align:middle
你将要求他们
扩展你的时间轴

00:48:19.466 --> 00:48:22.002 align:middle
它们将通过问问题开始

00:48:22.069 --> 00:48:24.538 align:middle
你将提供过去 现在的
时间轴更新

00:48:24.638 --> 00:48:28.141 align:middle
最后 你将给出一个建议时间

00:48:28.208 --> 00:48:29.610 align:middle
什么时候应该再次启动

00:48:31.979 --> 00:48:35.282 align:middle
最后一件事

00:48:35.349 --> 00:48:37.484 align:middle
当你提供下次启动时间时

00:48:37.551 --> 00:48:39.419 align:middle
系统会获得
你的工作已经做完的提示

00:48:40.020 --> 00:48:43.390 align:middle
你的WatchKit外设也将被隔离

00:48:44.892 --> 00:48:47.060 align:middle
现在 我们假设经过一段时间后

00:48:47.494 --> 00:48:50.898 align:middle
系统根据你的提示和系统条件

00:48:51.031 --> 00:48:53.534 align:middle
认为现在是
重启complication的

00:48:53.600 --> 00:48:55.502 align:middle
最好时间

00:48:56.303 --> 00:48:58.405 align:middle
再一次 你将在后台启动

00:48:59.106 --> 00:49:01.341 align:middle
你将调用NSURLSession
生成一个请求

00:48:59.106 --> 00:49:01.341 align:middle
你将调用NSURLSession
生成一个请求

00:49:01.408 --> 00:49:03.043 align:middle
你将把它发送到服务器

00:49:03.710 --> 00:49:05.479 align:middle
服务器将生成一个响应

00:49:05.679 --> 00:49:09.650 align:middle
你将使用ClockKit打开并
更新你的complication

00:49:14.154 --> 00:49:17.491 align:middle
概括一下 我们建议你

00:49:17.558 --> 00:49:20.561 align:middle
如果可能的话就使
NSURLSession后台会话

00:49:21.328 --> 00:49:23.931 align:middle
这是因为 在下次外设运作之后

00:49:23.997 --> 00:49:25.866 align:middle
NSURLSession
请求才会完成

00:49:26.099 --> 00:49:27.534 align:middle
使用后台会话

00:49:27.601 --> 00:49:29.603 align:middle
可使它在下次运作时传输内容

00:49:32.172 --> 00:49:35.342 align:middle
提供的请求时间只是给系统的一个建议

00:49:35.409 --> 00:49:36.577 align:middle
并不能保证确实如此

00:49:37.010 --> 00:49:40.380 align:middle
我们将尽可能逼近准确时间
而且使用条件

00:49:40.747 --> 00:49:43.116 align:middle
在这时候也不一定总是满足

00:49:44.251 --> 00:49:46.553 align:middle
我们建议你让运作时间
尽可能的短

00:49:46.887 --> 00:49:49.723 align:middle
你调用ClockKit更新时钟画面

00:49:50.123 --> 00:49:52.059 align:middle
你想让运行时间尽可能的短

00:49:52.459 --> 00:49:58.232 align:middle
而且让下次更新请求的
时间间隔尽可能的大

00:49:58.298 --> 00:50:01.935 align:middle
因为这是预设的
你不想在一天结束之前就用完这些安排

00:49:58.298 --> 00:50:01.935 align:middle
因为这是预设的
你不想在一天结束之前就用完这些安排

00:50:03.437 --> 00:50:06.206 align:middle
另一个获得内容的方法

00:50:06.273 --> 00:50:08.775 align:middle
比如在使用体育app的示例中

00:50:09.176 --> 00:50:10.577 align:middle
是推送这些内容

00:50:14.581 --> 00:50:16.383 align:middle
我们将在不同数个阶段中查看内容

00:50:16.450 --> 00:50:19.820 align:middle
因为这会用到两个非常独特的进程

00:50:19.887 --> 00:50:23.590 align:middle
首先 你用PushKit

00:50:23.690 --> 00:50:26.660 align:middle
将内容从云推送到iPhone

00:50:29.897 --> 00:50:32.199 align:middle
第二部分是用
WatchConnectivity

00:50:32.266 --> 00:50:35.936 align:middle
将内容从iPhone
推送到Apple Watch

00:50:36.737 --> 00:50:37.871 align:middle
我们分别来看一下

00:50:39.173 --> 00:50:41.441 align:middle
所以第一部分是

00:50:41.575 --> 00:50:43.577 align:middle
用PushKit
将内容传输到iPhone

00:50:44.311 --> 00:50:46.780 align:middle
你已更新PushKit框架

00:50:47.648 --> 00:50:50.350 align:middle
从而支持
complication推送

00:50:50.417 --> 00:50:53.453 align:middle
使用方法是创建一个
PKPushRegistry实例

00:50:55.289 --> 00:50:57.791 align:middle
接下来 你将自己设置成指派

00:50:57.858 --> 00:51:00.427 align:middle
这样 你就可以接收回调了

00:50:57.858 --> 00:51:00.427 align:middle
这样 你就可以接收回调了

00:51:01.695 --> 00:51:04.097 align:middle
最后 你将设置推送类型

00:51:04.164 --> 00:51:06.400 align:middle
并传输新PK推送类型
complication

00:51:06.466 --> 00:51:08.402 align:middle
这是之前添加到iOS9中的

00:51:09.102 --> 00:51:12.606 align:middle
一旦完成 你将收到
带新Push记号的指派回调

00:51:12.673 --> 00:51:16.310 align:middle
之后上传到你的服务器

00:51:16.376 --> 00:51:19.213 align:middle
也将让服务器可以将推送发送到设备上

00:51:20.013 --> 00:51:21.682 align:middle
最后 当服务器发出推送时

00:51:21.748 --> 00:51:23.283 align:middle
将收到携带负载
Did Receive

00:51:23.350 --> 00:51:24.751 align:middle
Incoming Push回调

00:51:24.818 --> 00:51:26.086 align:middle
这是你可以返回来

00:51:26.687 --> 00:51:28.822 align:middle
使用
WatchConnectivity

00:51:28.889 --> 00:51:30.924 align:middle
API 将内容发送到iPhone时

00:51:36.697 --> 00:51:37.965 align:middle
所以 第二部分 这时候

00:51:38.031 --> 00:51:40.868 align:middle
可以使用
WatchConnectivity

00:51:40.934 --> 00:51:42.836 align:middle
将在iOS app上收到的内容

00:51:42.903 --> 00:51:44.638 align:middle
发送到
Apple Watch app

00:51:47.741 --> 00:51:49.376 align:middle
首先要用到的是

00:51:49.443 --> 00:51:52.880 align:middle
亚历克斯先前说到的
传输用户信息API

00:51:54.181 --> 00:51:56.517 align:middle
这种方式可让你项目排队等候

00:51:56.884 --> 00:51:59.853 align:middle
Watchcomplication
可能需要的

00:51:59.920 --> 00:52:02.789 align:middle
为过去和未来的时间轴

00:51:59.920 --> 00:52:02.789 align:middle
为过去和未来的时间轴

00:52:04.091 --> 00:52:06.660 align:middle
一旦所有的时间轴项目排完队

00:52:07.127 --> 00:52:09.496 align:middle
在完成工作前需要做的
最后一件事是

00:52:09.563 --> 00:52:11.732 align:middle
调用一个专门的API

00:52:12.099 --> 00:52:13.901 align:middle
WatchConnectivity
的一部分

00:52:13.967 --> 00:52:16.670 align:middle
它调用了传输当前
complication用户信息

00:52:16.770 --> 00:52:19.039 align:middle
这是传输用户信息的专门版本

00:52:19.106 --> 00:52:20.174 align:middle
不管在什么时候

00:52:20.240 --> 00:52:22.809 align:middle
只允许存在一个当前
complication用户信息

00:52:22.876 --> 00:52:24.611 align:middle
若你调用两次

00:52:24.678 --> 00:52:27.814 align:middle
只有最后一次被标记为当前
complication用户信息

00:52:29.349 --> 00:52:30.450 align:middle
当你调用时

00:52:30.517 --> 00:52:32.419 align:middle
对于系统来说 意思是事情已经做完了

00:52:32.886 --> 00:52:36.356 align:middle
在接收方 所有的回调
将生成这个指派回调

00:52:36.423 --> 00:52:38.358 align:middle
Did Receive
User Info

00:52:41.929 --> 00:52:44.998 align:middle
所以 总体而言

00:52:45.065 --> 00:52:47.434 align:middle
这流程看起来像什么呢 好的

00:52:48.268 --> 00:52:52.606 align:middle
所以 当用户第一次启动
一个体育app时

00:52:53.607 --> 00:52:55.843 align:middle
app在其使用周期的知哦啊其

00:52:55.909 --> 00:52:59.146 align:middle
将建立PK推送注册表
并设置期待类型

00:52:59.546 --> 00:53:02.482 align:middle
然后注册该推送类型

00:52:59.546 --> 00:53:02.482 align:middle
然后注册该推送类型

00:53:02.583 --> 00:53:04.785 align:middle
即带Apple推送服务器的设备

00:53:05.252 --> 00:53:07.287 align:middle
然后类型推送到Apple服务器上

00:53:08.088 --> 00:53:10.257 align:middle
随后将反过来生成一个Push记号

00:53:10.324 --> 00:53:12.693 align:middle
然后你将在你的iOS app上
收到指派回调

00:53:14.895 --> 00:53:17.998 align:middle
你需要收到该记号
并上传到你的服务器

00:53:18.765 --> 00:53:20.100 align:middle
这样以后 你的服务器

00:53:20.167 --> 00:53:21.902 align:middle
就可以发送推送到这个设备了

00:53:22.536 --> 00:53:25.839 align:middle
这个时候
PushKit初始化设置就已经完成

00:53:26.707 --> 00:53:27.808 align:middle
不需要用到你的app了

00:53:28.675 --> 00:53:31.745 align:middle
假设这一切开始了 服务器决定

00:53:31.812 --> 00:53:33.514 align:middle
更新complication

00:53:33.580 --> 00:53:36.683 align:middle
它将发送一个推送到你的设备上

00:53:38.452 --> 00:53:40.721 align:middle
设备将收到推送

00:53:40.787 --> 00:53:43.624 align:middle
我们将在后台启动体育app
传输推送

00:53:43.790 --> 00:53:45.092 align:middle
那是另一个指派调用

00:53:46.426 --> 00:53:49.329 align:middle
这时候 你需看看
推送负载上的数据

00:53:49.463 --> 00:53:52.266 align:middle
确定如果要使用
WatchConnectivity

00:53:52.332 --> 00:53:53.700 align:middle
需要发送些什么

00:53:55.369 --> 00:53:57.070 align:middle
你将调用
Transfer User Info

00:53:57.137 --> 00:54:00.474 align:middle
将过去和未来的时间轴项目加入列队

00:53:57.137 --> 00:54:00.474 align:middle
将过去和未来的时间轴项目加入列队

00:54:00.874 --> 00:54:03.377 align:middle
然后我们可以访问
未解决用户信息传输列队

00:54:03.911 --> 00:54:07.581 align:middle
然后调用专门传输当前

00:54:08.048 --> 00:54:09.516 align:middle
complication
用户信息的重要队列

00:54:09.583 --> 00:54:11.852 align:middle
这也是将在Watch表面显示的队列

00:54:13.387 --> 00:54:15.455 align:middle
它将进入
未解决用户信息传输队列

00:54:15.522 --> 00:54:16.790 align:middle
但会跳过开头

00:54:16.890 --> 00:54:18.425 align:middle
因为它是最重要的队列

00:54:19.426 --> 00:54:22.963 align:middle
而且被指定为紧急优先

00:54:23.297 --> 00:54:25.899 align:middle
我们将立即把它传输到
Apple Watch

00:54:26.533 --> 00:54:29.036 align:middle
然后在后台启动WatchKit外设

00:54:29.303 --> 00:54:32.005 align:middle
传输当前complication
用户信息

00:54:33.473 --> 00:54:36.810 align:middle
如满足相关条件
部分内容也会同时传输

00:54:36.877 --> 00:54:38.712 align:middle
你将获得其他时间轴项目

00:54:38.779 --> 00:54:41.248 align:middle
但是最重要的队列一定会被传输

00:54:42.916 --> 00:54:45.886 align:middle
最后 可以使用ClockKit

00:54:46.153 --> 00:54:48.388 align:middle
更新你的complication

00:54:55.562 --> 00:54:58.966 align:middle
就是这样你已使用PushKit
更新了complication

00:54:59.466 --> 00:55:02.302 align:middle
我们已经添加新PK
推送类型complication

00:54:59.466 --> 00:55:02.302 align:middle
我们已经添加新PK
推送类型complication

00:55:02.369 --> 00:55:05.105 align:middle
你可以使用服务器上的信息

00:55:05.572 --> 00:55:07.808 align:middle
快速更新complication

00:55:08.609 --> 00:55:09.710 align:middle
使用这些推送类型

00:55:09.776 --> 00:55:11.245 align:middle
还有很多限制条件

00:55:11.311 --> 00:55:14.047 align:middle
complication在时钟画面
必须是处于活跃状态

00:55:14.448 --> 00:55:16.149 align:middle
否则将无法进行推送

00:55:17.284 --> 00:55:19.386 align:middle
且每天的推送数量也是有限的

00:55:19.453 --> 00:55:20.621 align:middle
所以 请节约使用

00:55:20.687 --> 00:55:23.156 align:middle
平均大概是每小时1到2个推动

00:55:23.223 --> 00:55:26.260 align:middle
但体育app可能在很短的时间内
全部用光

00:55:27.794 --> 00:55:29.229 align:middle
你可使用传输用户信息

00:55:29.296 --> 00:55:30.564 align:middle
对时间轴项目进行列队

00:55:30.631 --> 00:55:32.933 align:middle
最后 你可以使用
传输当前complication

00:55:32.999 --> 00:55:34.668 align:middle
用户信息列队当前

00:55:34.735 --> 00:55:36.136 align:middle
或现有的时间轴项目

00:55:37.137 --> 00:55:40.240 align:middle
可使用ClockKit更新时钟画面

00:55:40.874 --> 00:55:43.577 align:middle
请记住 很多这些事都是有预算限制的

00:55:43.644 --> 00:55:46.680 align:middle
在iOS和WatchKit上执行的

00:55:46.747 --> 00:55:49.583 align:middle
complication
更新的任何操作

00:55:49.650 --> 00:55:50.951 align:middle
都会消耗预算

00:55:51.485 --> 00:55:54.354 align:middle
我推荐 将你需要用来
更新complication的

00:55:54.421 --> 00:55:56.657 align:middle
任何信息都包括在推送中

00:55:57.324 --> 00:56:01.662 align:middle
complication
推送类型有4K有效负载

00:55:57.324 --> 00:56:01.662 align:middle
complication
推送类型有4K有效负载

00:56:01.728 --> 00:56:04.798 align:middle
大于标准负载
所以你可以将需要的大部分

00:56:04.865 --> 00:56:05.732 align:middle
信息放入其中

00:56:05.799 --> 00:56:07.734 align:middle
若你收到其中一个推送

00:56:07.801 --> 00:56:11.004 align:middle
并打开iOS app
提交NSURLSession请求

00:56:11.238 --> 00:56:12.873 align:middle
你将很快就消耗完预算

00:56:12.940 --> 00:56:16.143 align:middle
请确保所有你需要的内容都在推送中

00:56:19.413 --> 00:56:20.981 align:middle
这部分就到此结束

00:56:22.049 --> 00:56:23.984 align:middle
简要地讨论下我们今天所说的

00:56:24.051 --> 00:56:26.353 align:middle
我们说了框架
WatchConnectivity

00:56:26.420 --> 00:56:27.321 align:middle
和API

00:56:27.754 --> 00:56:30.424 align:middle
我们很期待看到
你们用这些API做出来的东西

00:56:31.124 --> 00:56:33.560 align:middle
简要地讨论了
NSURLSession和使用方法

00:56:33.627 --> 00:56:35.796 align:middle
还有其他部分

00:56:35.929 --> 00:56:39.600 align:middle
深入地讨论NSURLSession
及如何使用NSURLSession

00:56:40.100 --> 00:56:43.103 align:middle
最后 我们讨论了如何
把数据放到complication

00:56:43.270 --> 00:56:44.605 align:middle
这是个更为高级的话题

00:56:46.540 --> 00:56:49.076 align:middle
还有很多可以查看的重要资源

00:56:49.142 --> 00:56:50.644 align:middle
我们有一些很棒的样本代码

00:56:50.711 --> 00:56:54.948 align:middle
我们也有专员
他们已经准备好回答你的问题了

00:56:56.950 --> 00:56:58.585 align:middle
关于其他的内容

00:56:58.886 --> 00:57:01.388 align:middle
建议你看Creating
Complications

00:56:58.886 --> 00:57:01.388 align:middle
建议你看Creating
Complications

00:57:01.455 --> 00:57:04.124 align:middle
with ClockKit以及
Networking with NSURLSession

00:57:04.191 --> 00:57:06.326 align:middle
因为他们
与我们今天讨论的内容紧密相关

00:57:07.394 --> 00:57:08.495 align:middle
谢谢
