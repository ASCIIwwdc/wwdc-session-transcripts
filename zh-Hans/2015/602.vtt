WEBVTT

00:00:20.287 --> 00:00:23.423 align:middle
以Model I/O
进行3D资源管理

00:00:24.958 --> 00:00:25.792 align:middle
大家好

00:00:25.859 --> 00:00:28.495 align:middle
欢迎来到这场关于以Model
I/O进行3D资源管理的演讲

00:00:28.562 --> 00:00:31.798 align:middle
我是尼克 来自图像 媒体 和图形组

00:00:33.567 --> 00:00:38.505 align:middle
今天我很高兴向大家介绍新的
Model I/O框架

00:00:38.972 --> 00:00:43.110 align:middle
我们正在提高...
或者说我们其实是正在让大家

00:00:43.177 --> 00:00:46.580 align:middle
能够提高交互式的真实感图形的品质

00:00:47.047 --> 00:00:53.720 align:middle
到目前为止你们一直使用的
图形框架和硬件都是过去开发的

00:00:53.954 --> 00:00:56.957 align:middle
当时的硬件与现在相比有太多的局限

00:00:57.558 --> 00:00:59.860 align:middle
而现在你们口袋里的设备
拥有的功能绝对令人惊艳

00:01:00.160 --> 00:01:04.697 align:middle
现在我们有了新的框架
使你们能够充分发挥硬件的作用

00:01:04.765 --> 00:01:08.468 align:middle
为客户服务但是你们
必须不断给这个框架

00:01:09.002 --> 00:01:11.071 align:middle
增添真正好看的元素

00:01:11.638 --> 00:01:16.410 align:middle
所以既然现在有了高性能

00:01:17.411 --> 00:01:21.114 align:middle
和低功耗图形应用程序接口
你们就需要一种方法来把

00:01:21.181 --> 00:01:24.985 align:middle
图片制作得具有真实感真实感意味着
图片要基于现实存在源于现实存在

00:01:25.552 --> 00:01:29.890 align:middle
那么你们需要做有很多的研究
还要有大量相关的知识

00:01:30.057 --> 00:01:31.158 align:middle
才能实现这个目标

00:01:31.692 --> 00:01:33.760 align:middle
你们需要了解相机的物理原理

00:01:33.827 --> 00:01:36.263 align:middle
各种材料的物理特性光的物理特性

00:01:37.364 --> 00:01:39.633 align:middle
当然你们也可以多读相关的资料

00:01:39.700 --> 00:01:41.034 align:middle
我很赞成这种做法

00:01:41.468 --> 00:01:45.806 align:middle
要有效运用那些材料和光需要
做大量繁琐的工作

00:01:46.440 --> 00:01:49.042 align:middle
阅读大量的资料然后再进行集成运用

00:01:50.010 --> 00:01:53.747 align:middle
那么我们对Model I/O所做的
就是我们已经着手进行这些工作

00:01:54.248 --> 00:01:57.484 align:middle
我们已经进行了大量的研究
我们已做了一大堆的集成

00:01:57.985 --> 00:02:01.221 align:middle
我们已经准备了一套统一的数据结构

00:01:57.985 --> 00:02:01.221 align:middle
我们已经准备了一套统一的数据结构

00:02:01.288 --> 00:02:05.158 align:middle
来连贯一致地描述这些性能我们还
开发了一个使用简便的应用程序接口

00:02:06.460 --> 00:02:10.030 align:middle
所以说Model I/O是一个处理

00:02:10.097 --> 00:02:12.332 align:middle
3D资源和数据的框架

00:02:12.999 --> 00:02:17.337 align:middle
所以在最基本的层面上
你们可以利用Model I/O

00:02:17.604 --> 00:02:20.874 align:middle
导入和输出常见格式的文件

00:02:21.675 --> 00:02:25.679 align:middle
你们可以以现实的方式描述采光情况

00:02:25.913 --> 00:02:27.381 align:middle
各种材料 环境条件

00:02:28.182 --> 00:02:31.351 align:middle
你们可以将美工人员提供的资源和作品

00:02:31.785 --> 00:02:35.022 align:middle
导入Model I/O
再进行一些有趣的处理

00:02:35.088 --> 00:02:37.858 align:middle
在演讲过程中我们会讲到处理方法

00:02:38.492 --> 00:02:42.095 align:middle
现在有很多可以运用的工具

00:02:42.229 --> 00:02:47.401 align:middle
其主要关注点都是进行
基于物理特性的渲染和材料属性

00:02:47.835 --> 00:02:52.039 align:middle
I/O模型让你们可以通过
自己的管道利用那些工具

00:02:54.141 --> 00:02:57.244 align:middle
Model I/O已经集
成到Xcode 7里

00:02:57.311 --> 00:02:59.213 align:middle
还有GameKit的应用程序接口里

00:02:59.279 --> 00:03:03.417 align:middle
可以在iOS 9
和OS10.11中运行

00:02:59.279 --> 00:03:03.417 align:middle
可以在iOS 9
和OS10.11中运行

00:03:04.785 --> 00:03:09.590 align:middle
所以概括地说这个绿色的大盒子是

00:03:10.090 --> 00:03:12.192 align:middle
Model I/O与你们的框架

00:03:12.593 --> 00:03:13.961 align:middle
或应用程序想融合的地方

00:03:14.561 --> 00:03:17.831 align:middle
我们就从联系创建工具讲起
首先美工人员制作一些很好的作品

00:03:18.465 --> 00:03:20.601 align:middle
然后你们要将其
导入Model I/O

00:03:21.201 --> 00:03:26.607 align:middle
接下来由Model I/O快速完成那些
原本繁琐乏味又容易出现错误的步骤

00:03:26.807 --> 00:03:32.112 align:middle
为各种框架创建缓冲区进行快速渲染

00:03:32.646 --> 00:03:36.416 align:middle
在这个盒子之外我们所支持的
框架有SceneKit

00:03:36.650 --> 00:03:37.885 align:middle
Metal 和 OpenGL

00:03:40.621 --> 00:03:45.058 align:middle
现在Model I/O不仅可以
加载文件和保存文件

00:03:45.692 --> 00:03:48.462 align:middle
它还让你们能够进行原本有用

00:03:48.595 --> 00:03:50.731 align:middle
但耗时太长或有其他弊端的操作

00:03:51.098 --> 00:03:53.534 align:middle
来改善资源的外观

00:03:54.201 --> 00:03:56.470 align:middle
你们可以选取一项资源

00:03:56.770 --> 00:03:59.339 align:middle
对其进行接下来我会谈到
的各种热处理操作的其中一项

00:03:59.573 --> 00:04:02.342 align:middle
再把这项资源恢复成统一
的表示形式导回Model I/O

00:03:59.573 --> 00:04:02.342 align:middle
再把这项资源恢复成统一
的表示形式导回Model I/O

00:04:03.076 --> 00:04:05.746 align:middle
再把它放到硬件准备缓冲区

00:04:07.381 --> 00:04:12.786 align:middle
你也可以先利用Model I/O

00:04:13.187 --> 00:04:15.222 align:middle
提供的独特的功能对资源进行处理

00:04:15.322 --> 00:04:18.225 align:middle
完成这里的循环然后把它发送回

00:04:18.291 --> 00:04:20.260 align:middle
内容创作工具让美工人员

00:04:20.793 --> 00:04:24.398 align:middle
进行调整也许再添加一些
比如细节处理或进行其他改进

00:04:24.865 --> 00:04:28.502 align:middle
然后你可以不断重复这个循环
直到达到你的app

00:04:28.635 --> 00:04:30.971 align:middle
所需要的外观和质量水平为止

00:04:33.240 --> 00:04:37.611 align:middle
那么我们今天要讲的是这些功能是什么

00:04:38.579 --> 00:04:39.446 align:middle
其数据类型是什么

00:04:39.513 --> 00:04:41.982 align:middle
那些数据类型的物理动机从何而来

00:04:42.683 --> 00:04:47.521 align:middle
我们将谈论如何支持
各种几何功能三维像素

00:04:48.121 --> 00:04:52.726 align:middle
和一些先进的光照技巧
以及我们的热处理步骤

00:04:56.897 --> 00:05:00.534 align:middle
好的 我们开始面包和黄油资料读取中

00:04:56.897 --> 00:05:00.534 align:middle
好的 我们开始面包和黄油资料读取中

00:05:01.435 --> 00:05:05.272 align:middle
导入格式我们从

00:05:05.672 --> 00:05:09.109 align:middle
一些最常用的格式开始

00:05:11.211 --> 00:05:14.915 align:middle
蒸馏器是一种性能非常高的格式

00:05:15.148 --> 00:05:19.453 align:middle
它来自电影行业现在
也大量在游戏中使用

00:05:20.020 --> 00:05:23.824 align:middle
这这里所列出的格式中它是最现代的

00:05:23.891 --> 00:05:28.629 align:middle
它包括了关于动画和材料绑定的信息

00:05:28.695 --> 00:05:30.797 align:middle
还有其他各种各样的有趣的信息

00:05:31.331 --> 00:05:34.735 align:middle
多边形是多边形的
标准格式使用这个格式

00:05:34.801 --> 00:05:36.770 align:middle
需要进行大量的学术研究

00:05:37.271 --> 00:05:43.777 align:middle
三角形通常用CAD和CAM这两种
应用程序制作和摄取

00:05:44.278 --> 00:05:47.681 align:middle
而且Wavefront .obj
文件可以得到普遍的读写支持

00:05:48.382 --> 00:05:50.250 align:middle
如果要在此刻进行导出

00:05:50.484 --> 00:05:54.521 align:middle
你可以导出你的
CAD / CAM材料

00:05:57.758 --> 00:05:59.760 align:middle
所以导入很容易

00:06:00.027 --> 00:06:02.930 align:middle
你使用URL通过内核自行启动
得到一个MDL资源

00:06:03.430 --> 00:06:07.034 align:middle
然后你可以用“输出资源到URL”
把它导出到其他位置

00:06:09.837 --> 00:06:12.706 align:middle
关于物理真实感我还要再说几句

00:06:12.840 --> 00:06:16.376 align:middle
但是不做太细致的解释

00:06:16.610 --> 00:06:20.280 align:middle
光照一直以来都要有一个位置

00:06:20.547 --> 00:06:23.584 align:middle
比如一个锥角衰减区

00:06:24.151 --> 00:06:26.420 align:middle
还要有其他一些从物理
角度来看不真实的参数

00:06:26.486 --> 00:06:28.622 align:middle
这些参数只是在数学上与过去的硬件和

00:06:28.689 --> 00:06:30.324 align:middle
图形应用程序接口相统一

00:06:30.858 --> 00:06:36.029 align:middle
我们现在要为大家提供的
是对IES概要文件的访问方法

00:06:36.263 --> 00:06:39.499 align:middle
现在如果你去五金店并且发现

00:06:39.633 --> 00:06:41.068 align:middle
比如你非常喜欢的一款灯具

00:06:41.168 --> 00:06:43.904 align:middle
比如说我真的很喜欢那里的那款灯
而且我在商店里看到了它

00:06:44.204 --> 00:06:48.108 align:middle
我可以先读一下旁边的标签
再去生产商的网站

00:06:48.609 --> 00:06:51.111 align:middle
在网上我可以找到一个IES概要文件

00:06:51.178 --> 00:06:54.681 align:middle
它是一个数据文件
里面有关于这种灯的各种数据

00:06:54.781 --> 00:06:57.851 align:middle
我能了解每一个角度灯光的辐照度

00:06:58.919 --> 00:07:01.321 align:middle
我们把那个文件读入到
一个所谓的轻型网络

00:06:58.919 --> 00:07:01.321 align:middle
我们把那个文件读入到
一个所谓的轻型网络

00:07:01.655 --> 00:07:04.992 align:middle
就是一组很容易加载到着色器里的数据

00:07:05.459 --> 00:07:09.029 align:middle
那么如果你愿意你可以在你的着色器里

00:07:09.229 --> 00:07:11.832 align:middle
亲自点亮可与真实世界的灯媲美的灯

00:07:12.466 --> 00:07:14.701 align:middle
现在你在五金店里买灯时

00:07:15.002 --> 00:07:17.971 align:middle
不会专门提出RGB值或类似的要求

00:07:18.038 --> 00:07:21.742 align:middle
灯的特点通常由温度描述
比如4000开氏度或其他度数

00:07:22.309 --> 00:07:25.512 align:middle
那么你也可以用开氏度来指定这些高度

00:07:26.046 --> 00:07:28.815 align:middle
我们还可以提供基于那边正在工作的

00:07:28.949 --> 00:07:30.384 align:middle
挖掘机的灯光的图像

00:07:31.084 --> 00:07:35.289 align:middle
这些材料以前都需要使用传感器

00:07:35.455 --> 00:07:38.325 align:middle
这意味着随角度衰减现象

00:07:38.792 --> 00:07:40.594 align:middle
并且在Blinn-Phong高光区

00:07:40.661 --> 00:07:42.896 align:middle
会有可调节的亮点

00:07:43.430 --> 00:07:44.498 align:middle
我们还为你们提供

00:07:44.598 --> 00:07:48.035 align:middle
一个基线物理双向反射函数

00:07:48.101 --> 00:07:52.806 align:middle
也可以叫做BRDF如果你想要取得

00:07:53.006 --> 00:07:54.641 align:middle
绝对逼真的效果你绝度需要这个函数

00:07:55.075 --> 00:07:59.413 align:middle
请注意那台挖掘机上就有BDRF

00:08:00.314 --> 00:08:03.350 align:middle
相机历来是针孔相机

00:08:03.717 --> 00:08:06.820 align:middle
描述相机时我们
从镜头一直介绍到传感器

00:08:07.221 --> 00:08:09.356 align:middle
现在我们为你们提供一些实用程序

00:08:09.456 --> 00:08:12.926 align:middle
来处理照片和程序中的各种环境元素

00:08:16.029 --> 00:08:19.600 align:middle
现在你们会看到
用Xcode中的工具做热处理

00:08:19.967 --> 00:08:23.203 align:middle
在这张幻灯片上我要告诉你们

00:08:24.238 --> 00:08:26.206 align:middle
在Xcode中你可以用来

00:08:26.340 --> 00:08:29.943 align:middle
执行这些操作的工具你也可以
通过框架在Model I/O中使用

00:08:30.511 --> 00:08:32.044 align:middle
所以如果你想制作自己的管线

00:08:32.179 --> 00:08:35.682 align:middle
你自己的离线管道以便对自己的资源

00:08:35.749 --> 00:08:39.019 align:middle
进行彻底的热处理无论批次大小

00:08:39.419 --> 00:08:41.321 align:middle
都可以通过应用程序接口框架

00:08:41.922 --> 00:08:43.056 align:middle
使用那些工具

00:08:45.626 --> 00:08:47.561 align:middle
我们已经介绍了三维像素

00:08:47.828 --> 00:08:50.864 align:middle
你们可以选取一个又大又旧的网格
把它变成巨大的索引缓存

00:08:50.931 --> 00:08:52.666 align:middle
你们可以把自己的数据与它关联起来

00:08:53.066 --> 00:08:54.168 align:middle
稍后我们会就此多谈一些

00:08:55.002 --> 00:08:56.904 align:middle
再说一次在资源的基础上

00:08:57.271 --> 00:09:01.441 align:middle
创建三维像素以及
在特定区域找到三维像素非常简单

00:08:57.271 --> 00:09:01.441 align:middle
创建三维像素以及
在特定区域找到三维像素非常简单

00:09:01.675 --> 00:09:03.610 align:middle
你们可以运用实体几何构造法

00:09:03.677 --> 00:09:05.946 align:middle
还可以把三维像素导回到一个网格

00:09:06.446 --> 00:09:07.948 align:middle
期间可以利用数据平滑法

00:09:08.415 --> 00:09:09.249 align:middle
类似的做法吧

00:09:11.118 --> 00:09:16.190 align:middle
所以通过系统集成
将Model I/O直接集成到

00:09:16.990 --> 00:09:21.395 align:middle
SceneKit中可以在
MetalKit和GLKit中使用

00:09:22.596 --> 00:09:26.600 align:middle
在取景器和快速浏览功能中
Model I/O是用来做预览的

00:09:26.667 --> 00:09:30.470 align:middle
所以你可以去找一个蒸馏器
abc缓存文件按下空格键

00:09:30.537 --> 00:09:32.806 align:middle
然后会弹出取景器
你可反复查看你的资源

00:09:32.873 --> 00:09:36.643 align:middle
甚至不用打开任何类型的
试镜环境对其进行预览

00:09:37.411 --> 00:09:39.646 align:middle
您可以在Xcode中编辑资源

00:09:39.913 --> 00:09:43.750 align:middle
这张图片中的挖掘机就是
用Xcode进行加载的

00:09:44.284 --> 00:09:48.021 align:middle
Model I/O使用Swift
语言在Playgrounds中工作

00:09:50.757 --> 00:09:54.161 align:middle
好 这一切可以归结到数据类型的本质

00:09:55.395 --> 00:10:00.601 align:middle
所以从一个URL得到的是MDL资源

00:09:55.395 --> 00:10:00.601 align:middle
所以从一个URL得到的是MDL资源

00:10:01.001 --> 00:10:04.071 align:middle
它包含了你们往往会处理的所有对象

00:10:04.671 --> 00:10:08.242 align:middle
它是一个你知道
快速列举素材资料的索引容器

00:10:08.709 --> 00:10:11.311 align:middle
它有变换层次结构 网格

00:10:11.578 --> 00:10:14.748 align:middle
相机和灯光 这些你可以
利用应用程序接口进行制作

00:10:15.148 --> 00:10:17.284 align:middle
或通过URL加载

00:10:18.285 --> 00:10:20.754 align:middle
所以一项典型的
你可以利用的asset

00:10:21.088 --> 00:10:24.958 align:middle
比如一个又大又旧的蒸馏器文件
会包含很多有趣的东西

00:10:26.026 --> 00:10:31.098 align:middle
这个举一个例子里面有几个摄像头

00:10:31.298 --> 00:10:34.234 align:middle
一盏灯 一个根变换

00:10:34.301 --> 00:10:36.470 align:middle
以及右上角的蓝色框

00:10:36.837 --> 00:10:39.740 align:middle
下面是挖掘机的信息

00:10:39.806 --> 00:10:42.409 align:middle
橙色的框显示 是的

00:10:42.476 --> 00:10:45.312 align:middle
橙色的框只是表明你也可以显示
你的材料赋值情况

00:10:45.913 --> 00:10:47.581 align:middle
这就是资源所包含的信息

00:10:48.015 --> 00:10:50.784 align:middle
这都是逻辑上的应为一体的东西

00:10:50.851 --> 00:10:53.420 align:middle
所以你就有了很多的资源
把它们组合成一个场景

00:10:55.756 --> 00:11:00.360 align:middle
asset有内存分配器

00:10:55.756 --> 00:11:00.360 align:middle
asset有内存分配器

00:11:00.794 --> 00:11:04.865 align:middle
你需要的话可以添加分配器
自己管理内存

00:11:05.499 --> 00:11:10.470 align:middle
Asset有内部事务描述符

00:11:10.971 --> 00:11:13.040 align:middle
这是导入导出工具

00:11:13.407 --> 00:11:14.775 align:middle
和大量子工具

00:11:15.342 --> 00:11:17.811 align:middle
这些子工具都是MDL对象

00:11:19.713 --> 00:11:23.050 align:middle
MDL对象自身可以组成一个层

00:11:24.685 --> 00:11:28.856 align:middle
现在完成了一个典型的标准图
当然应该有转换层

00:11:30.490 --> 00:11:35.162 align:middle
MDL对象有转换组件

00:11:36.296 --> 00:11:39.333 align:middle
我们并没有执行转换

00:11:39.399 --> 00:11:41.368 align:middle
你知道这是放置矩阵的标准步骤

00:11:41.435 --> 00:11:43.003 align:middle
实际上我们有转换组件

00:11:43.537 --> 00:11:45.706 align:middle
这种组件非常有意思

00:11:45.839 --> 00:11:47.741 align:middle
因为它允许我们创建一种场景图

00:11:47.808 --> 00:11:52.479 align:middle
这种场景图不必有父/子的类型关系

00:11:52.946 --> 00:11:55.349 align:middle
另外可以定义自己的组件

00:11:56.717 --> 00:12:00.687 align:middle
现在我想我应该已经提到了那个好东西

00:11:56.717 --> 00:12:00.687 align:middle
现在我想我应该已经提到了那个好东西

00:12:01.088 --> 00:12:04.691 align:middle
编写自定义导入导出器的
API已经设计出来了

00:12:05.125 --> 00:12:08.629 align:middle
你可以编写如果你有自定义的文件格式

00:12:09.363 --> 00:12:12.399 align:middle
你可以编写倒入导出气让我们回来

00:12:12.866 --> 00:12:17.838 align:middle
这里有个自定义的触发器组件

00:12:17.905 --> 00:12:21.241 align:middle
它拥有了一组你自己的功能
会发生一系列相应的动作

00:12:21.708 --> 00:12:24.978 align:middle
这个编写自定义导入导出器的API
可以让你自己创建功能

00:12:25.045 --> 00:12:28.515 align:middle
并定义它的动作是什么定义它连接什么

00:12:29.383 --> 00:12:33.587 align:middle
现在一个网格包含一个
或多个顶点缓冲区

00:12:33.954 --> 00:12:38.158 align:middle
这是需要GPU进行位图化的位置

00:12:38.859 --> 00:12:41.228 align:middle
法向下面是子网格

00:12:42.262 --> 00:12:45.999 align:middle
要想知道子网格实际是什么

00:12:46.667 --> 00:12:50.637 align:middle
你应该有一个驱动挖掘器的功能

00:12:51.071 --> 00:12:53.740 align:middle
这个功能应该有些像
安全帽一样的可选组件

00:12:54.074 --> 00:12:55.876 align:middle
这个组件不应该是可选的但它确实是

00:12:56.443 --> 00:13:01.181 align:middle
在一个索引缓存中
我应该有整个没有可选组建功能

00:12:56.443 --> 00:13:01.181 align:middle
在一个索引缓存中
我应该有整个没有可选组建功能

00:13:01.315 --> 00:13:03.417 align:middle
在另一个索引缓存中

00:13:03.483 --> 00:13:05.953 align:middle
我应该有所有指向
原始网格顶点缓存的索引

00:13:06.353 --> 00:13:08.222 align:middle
它里面应该有可选组件

00:13:08.789 --> 00:13:10.791 align:middle
所以通过渲染或者不渲染子网格

00:13:11.024 --> 00:13:12.759 align:middle
网格会有可选组件或者没有可选组件

00:13:14.895 --> 00:13:17.130 align:middle
子网格之间可以用顶点缓存共享数据

00:13:17.197 --> 00:13:20.000 align:middle
所以这将会允许你向硬件单独提交

00:13:21.735 --> 00:13:26.039 align:middle
因此网格除了有顶点和索引缓存

00:13:27.140 --> 00:13:30.511 align:middle
还有功能函数以及产生

00:13:30.577 --> 00:13:32.913 align:middle
常用事物的生成模板
例如盒子 球等等

00:13:34.214 --> 00:13:35.349 align:middle
还有调节器

00:13:35.716 --> 00:13:39.419 align:middle
如果一个网格没有法线或切线基值

00:13:39.486 --> 00:13:43.090 align:middle
或是类似的东西 你可以在需求中生成

00:13:43.390 --> 00:13:47.561 align:middle
回想一下烘焙和导出循环
我前面提到过的

00:13:48.362 --> 00:13:50.163 align:middle
当然得有烘烤师

00:13:52.699 --> 00:13:57.437 align:middle
现在一个网格缓存必须访问硬件

00:13:57.838 --> 00:13:59.540 align:middle
因为它要去硬件取数据

00:14:00.807 --> 00:14:01.708 align:middle
取硬件中的真实值

00:14:02.242 --> 00:14:04.645 align:middle
缓存有多大取决于你如何分配它

00:14:06.313 --> 00:14:09.650 align:middle
你必须描述这些顶点缓存

00:14:09.716 --> 00:14:13.887 align:middle
你必须说出缓存的用途
比如是存储位置吗

00:14:14.354 --> 00:14:15.822 align:middle
它有多大？

00:14:15.889 --> 00:14:18.091 align:middle
它占用多少字节等等 等等

00:14:19.359 --> 00:14:23.864 align:middle
最后从一个顶点切到另一个
硬件需要知道这些

00:14:24.364 --> 00:14:26.700 align:middle
子网格也一样

00:14:26.900 --> 00:14:28.435 align:middle
确定你需要什么样的索引

00:14:28.635 --> 00:14:30.971 align:middle
是16s还是32s或是其它

00:14:31.205 --> 00:14:35.742 align:middle
下面讲几何类型三角带？点？还是线？

00:14:36.376 --> 00:14:37.277 align:middle
最后是材质

00:14:38.612 --> 00:14:45.519 align:middle
如果你使用这些类库能生产积极性

00:14:46.053 --> 00:14:47.821 align:middle
为了告诉你这意味着什么

00:14:48.088 --> 00:14:51.058 align:middle
我们使用了双向反射函数

00:14:51.124 --> 00:14:55.362 align:middle
它有十个简单参数这是
为了让艺术家有更加直观的感受

00:14:56.029 --> 00:15:01.535 align:middle
一个更重要的功能是
设定物体是否贴合实际

00:14:56.029 --> 00:15:01.535 align:middle
一个更重要的功能是
设定物体是否贴合实际

00:15:01.602 --> 00:15:03.036 align:middle
像黏土或是金属

00:15:03.604 --> 00:15:06.373 align:middle
如果你向一头设定这个值

00:15:06.573 --> 00:15:07.875 align:middle
它就会像是黏土

00:15:08.909 --> 00:15:10.110 align:middle
如果向另一头调

00:15:10.477 --> 00:15:12.779 align:middle
它就会表现得像是金属

00:15:15.349 --> 00:15:20.120 align:middle
在这里我把这两者结合起来
把一个丙烯酸透明的外套

00:15:22.289 --> 00:15:27.194 align:middle
放在金属底座上面我调整了
一个参数给出缎面的效果

00:15:31.031 --> 00:15:34.201 align:middle
这是一个真正艺术家般的作品

00:15:34.268 --> 00:15:37.204 align:middle
一个有着各种不同材料的太空船

00:15:37.471 --> 00:15:40.207 align:middle
只是给你一点思路只需很少的

00:15:40.374 --> 00:15:43.010 align:middle
参数就可以给出多种多样的外观

00:15:44.811 --> 00:15:50.951 align:middle
那么材质应该有个名字类似于所有在
Model I/O中配置属性的东西

00:15:51.018 --> 00:15:54.121 align:middle
无论你是否想要
Lambert Blinn-Phong

00:15:54.188 --> 00:15:55.822 align:middle
都要设定散射函数

00:15:56.156 --> 00:16:00.794 align:middle
因为需要向下兼容旧系统
并且真实可信

00:15:56.156 --> 00:16:00.794 align:middle
因为需要向下兼容旧系统
并且真实可信

00:16:00.961 --> 00:16:04.331 align:middle
当然如果你想进入真实可信的
勇敢新世界的话

00:16:05.465 --> 00:16:08.435 align:middle
这些材质是单独继承的这意味着

00:16:08.902 --> 00:16:15.342 align:middle
你可以通过改变每个功能的
一个值或是某些东西

00:16:15.409 --> 00:16:18.545 align:middle
你可以指定基础材质和跨越属性

00:16:18.979 --> 00:16:20.747 align:middle
以及子类材质

00:16:21.415 --> 00:16:24.718 align:middle
材质属性有名称用来说明

00:16:24.785 --> 00:16:27.521 align:middle
它们如何使用的释义

00:16:27.588 --> 00:16:30.324 align:middle
以及说明它是浮动值或是颜色值的类型

00:16:31.725 --> 00:16:32.559 align:middle
下面是光

00:16:33.026 --> 00:16:36.997 align:middle
光有物理参数

00:16:37.164 --> 00:16:40.434 align:middle
和物理属性以及几何形状

00:16:40.634 --> 00:16:42.436 align:middle
它们有扩展度和宽度

00:16:42.836 --> 00:16:46.874 align:middle
光以特定的方式传播

00:16:47.140 --> 00:16:49.343 align:middle
你可以指定它的流明和色温

00:16:49.743 --> 00:16:52.513 align:middle
在整个Model I/O中
真正让我激动的

00:16:52.779 --> 00:16:55.682 align:middle
是得到了色彩方面的支持

00:16:56.016 --> 00:17:00.153 align:middle
可以指定使用现代色彩

00:16:56.016 --> 00:17:00.153 align:middle
可以指定使用现代色彩

00:17:00.654 --> 00:17:04.290 align:middle
如果你想用SRGB
我们有设定好的SRGB

00:17:04.358 --> 00:17:06.425 align:middle
如果你想用Rec.709

00:17:06.492 --> 00:17:08.662 align:middle
或者是新的Asus CG色彩配置

00:17:09.128 --> 00:17:11.198 align:middle
这种色彩配置可以保证你的色彩

00:17:11.565 --> 00:17:14.535 align:middle
以一定的方式在app的内容里加载

00:17:14.601 --> 00:17:17.704 align:middle
它自始至终表现稳定

00:17:18.038 --> 00:17:21.742 align:middle
不会发生奇特的变化这可能会给你
你知道意想不到的色彩

00:17:24.810 --> 00:17:28.782 align:middle
我们现在有了类似物理光

00:17:29.516 --> 00:17:32.719 align:middle
各种子类程序区光源

00:17:32.986 --> 00:17:35.556 align:middle
应该说是程序描述的区域光源

00:17:36.089 --> 00:17:41.161 align:middle
IES光度分析计

00:17:41.495 --> 00:17:44.498 align:middle
反光贴图或发光贴图的光探测器

00:17:44.598 --> 00:17:49.102 align:middle
你可以用它们来计算球面谐波
诸如此类的代表正在发生什么的东西

00:17:50.404 --> 00:17:57.077 align:middle
我们的相机也不仅仅是
针孔无限聚焦相机

00:17:57.711 --> 00:18:01.982 align:middle
我们描述的相机发生了巨大的变化

00:17:57.711 --> 00:18:01.982 align:middle
我们描述的相机发生了巨大的变化

00:18:02.416 --> 00:18:08.222 align:middle
我的照片这里应该有个镜头
这里应该有个传感器

00:18:08.589 --> 00:18:12.826 align:middle
我们描述镜头可以看到的范围
描述镜头属性

00:18:12.893 --> 00:18:15.495 align:middle
失真的种类 桶形失真

00:18:15.596 --> 00:18:18.532 align:middle
或者是色差之类的东西镜头的几何形状

00:18:18.599 --> 00:18:21.201 align:middle
镜片的有多大 镜筒有多长

00:18:21.702 --> 00:18:22.870 align:middle
出口孔径

00:18:22.936 --> 00:18:27.040 align:middle
你关了多少光圈 传感器有多大

00:18:27.341 --> 00:18:30.077 align:middle
传感器的曝光功能是什么

00:18:30.644 --> 00:18:34.781 align:middle
所有上述设置的结果是

00:18:34.848 --> 00:18:41.054 align:middle
如果你装载了一个35或者
说50毫米F1.8光圈的相机

00:18:41.121 --> 00:18:45.392 align:middle
去查维基百科

00:18:45.592 --> 00:18:47.928 align:middle
一个这样的镜头有什么功能

00:18:47.995 --> 00:18:51.832 align:middle
视野是多大 离焦光怎样

00:18:52.032 --> 00:18:55.602 align:middle
突出尺寸及MDL相机的
实用功能等类似的东西

00:18:55.669 --> 00:18:59.006 align:middle
这个相机将和你在书上看到的一样

00:18:59.173 --> 00:19:01.942 align:middle
所以这是一个方便而且有趣东西

00:18:59.173 --> 00:19:01.942 align:middle
所以这是一个方便而且有趣东西

00:19:02.209 --> 00:19:06.880 align:middle
我鼓励你把这一类的
计算整合到你的着色器和通道

00:19:08.348 --> 00:19:09.650 align:middle
这里只是一个简短的例子

00:19:10.784 --> 00:19:13.153 align:middle
当我第一次将它加载到我的查看器中

00:19:13.453 --> 00:19:15.389 align:middle
使用默认的曝光设置

00:19:15.689 --> 00:19:18.692 align:middle
有些细节的丢失

00:19:18.892 --> 00:19:23.463 align:middle
挖掘机的黑暗区域很多细节看不到

00:19:24.431 --> 00:19:29.503 align:middle
对不起 这里的亮度不好
我这图像曝光不足

00:19:29.570 --> 00:19:32.105 align:middle
然后 使用闪关灯以

00:19:32.172 --> 00:19:36.577 align:middle
给出阴影的细节在
减少炫光的同时提升整体水平

00:19:37.711 --> 00:19:39.246 align:middle
就像一个摄影师做的那样

00:19:40.514 --> 00:19:43.150 align:middle
如果你玩的是自己真正的相机

00:19:45.819 --> 00:19:46.653 align:middle
现在 该天空了

00:19:47.888 --> 00:19:49.656 align:middle
我们有两种方法创造天空

00:19:49.990 --> 00:19:53.927 align:middle
第一种方法是使用一个程序天空发生器

00:19:54.194 --> 00:19:55.395 align:middle
它使用物理学

00:19:56.496 --> 00:19:59.399 align:middle
你给出当天的时间本质上太阳有多高

00:19:59.700 --> 00:20:03.403 align:middle
天气如何有没有很多地面上来的背散射

00:19:59.700 --> 00:20:03.403 align:middle
天气如何有没有很多地面上来的背散射

00:20:03.470 --> 00:20:05.272 align:middle
空气中是不是有很多垃圾

00:20:05.906 --> 00:20:09.643 align:middle
我们通过大量的数学运算

00:20:09.943 --> 00:20:12.145 align:middle
精确计算天空的样子

00:20:13.480 --> 00:20:15.015 align:middle
另外一条路是

00:20:15.315 --> 00:20:19.853 align:middle
它创建一个立方体你知道使用...

00:20:20.354 --> 00:20:24.491 align:middle
现在你可以在这个基于物理的领域

00:20:24.591 --> 00:20:27.461 align:middle
创造天空的另一种方法是摄影

00:20:27.828 --> 00:20:29.596 align:middle
你可以用手机或DSLR

00:20:29.663 --> 00:20:33.200 align:middle
摄制一个球形全景图
我用IPHONE制作了这张图

00:20:35.435 --> 00:20:39.606 align:middle
你可以使用mdltexture
和initwithurl API

00:20:39.673 --> 00:20:44.711 align:middle
创建一个立方体

00:20:45.045 --> 00:20:46.246 align:middle
反射或发光地图

00:20:46.313 --> 00:20:48.549 align:middle
从图像中我们可以推断出光是入射光

00:20:48.649 --> 00:20:51.818 align:middle
所以这已经转换成一个立方体

00:20:54.254 --> 00:20:58.325 align:middle
然后从这些里面你可以计算出辐照度

00:20:58.859 --> 00:21:02.863 align:middle
这三条显示的是原始图像

00:20:58.859 --> 00:21:02.863 align:middle
这三条显示的是原始图像

00:21:03.163 --> 00:21:09.636 align:middle
中间线是纹理贴图以一定的
卷积或水平的模糊度发光

00:21:10.237 --> 00:21:14.775 align:middle
第三个真的很好玩
中间是一个纹理它使用大量的内存

00:21:15.142 --> 00:21:18.111 align:middle
第三个实际是球谐系数

00:21:18.478 --> 00:21:24.418 align:middle
所以他是27浮动重现的光照环境

00:21:24.484 --> 00:21:29.556 align:middle
之前用数十个K代表中间线或中间地带

00:21:30.891 --> 00:21:32.059 align:middle
把这些放在一起

00:21:32.559 --> 00:21:36.530 align:middle
这个挖掘机和它周围的环境非常和谐

00:21:36.897 --> 00:21:41.902 align:middle
我画的这些作品我认为
另人激动我希望你们可以

00:21:42.503 --> 00:21:44.705 align:middle
用这些工具做出非常酷的作品

00:21:46.840 --> 00:21:49.276 align:middle
现在我只是想多说一点

00:21:49.376 --> 00:21:51.678 align:middle
关于如何整合Model I/O
和SceneKit

00:21:52.613 --> 00:21:55.349 align:middle
本质上在Model I/O
和SceneKit元素的顶层

00:21:55.682 --> 00:21:59.219 align:middle
有一对一的依赖关系

00:21:59.786 --> 00:22:02.556 align:middle
mdlasset对
应SceneKit根节点

00:21:59.786 --> 00:22:02.556 align:middle
mdlasset对
应SceneKit根节点

00:22:03.457 --> 00:22:07.127 align:middle
MDLMesh 和SCNNode
通过SCN坐标联系起来

00:22:07.427 --> 00:22:11.365 align:middle
MDLLight
有SCNLight的相机和材质

00:22:12.032 --> 00:22:16.203 align:middle
在SceneKit参数
和Model I/O参数间

00:22:16.603 --> 00:22:19.806 align:middle
没有一致的模型我们就通过翻译

00:22:20.040 --> 00:22:21.842 align:middle
得到一个近似的模型

00:22:23.677 --> 00:22:26.747 align:middle
现在Model I/O
实际上没有做渲染

00:22:26.813 --> 00:22:31.552 align:middle
你可能收集了既然
我提到过其它渲染APIS

00:22:32.252 --> 00:22:35.088 align:middle
所以在metalkit更接近金属

00:22:36.023 --> 00:22:39.126 align:middle
你将MDLMesh作为

00:22:39.426 --> 00:22:46.133 align:middle
MetalK
和Model I/O间的模型阵

00:22:46.733 --> 00:22:49.603 align:middle
网格阵列一旦你有了网格阵列

00:22:49.903 --> 00:22:52.639 align:middle
你就可以自己写阴影遍历网格

00:22:52.706 --> 00:22:55.409 align:middle
和照明条件并做渲染

00:22:55.876 --> 00:23:00.180 align:middle
但是得到这些为你准备的
金属缓存是绝对透明的

00:22:55.876 --> 00:23:00.180 align:middle
但是得到这些为你准备的
金属缓存是绝对透明的

00:23:01.181 --> 00:23:06.353 align:middle
说到这个我想把麦克风给
克劳迪娅·罗伯茨

00:23:06.520 --> 00:23:09.623 align:middle
分享关于几何图形和体素的内容

00:23:18.332 --> 00:23:21.668 align:middle
大家好 我的名字是
克劳迪娅·罗伯茨 尼克已经提到了

00:23:21.735 --> 00:23:25.339 align:middle
我将概述一些不同的方法以便你可以

00:23:25.405 --> 00:23:28.208 align:middle
描述和个性化
Model I/O中的几何图形

00:23:28.876 --> 00:23:35.148 align:middle
帮助你创造更加有
真实外观和感觉的游戏和应用

00:23:37.351 --> 00:23:39.253 align:middle
给你们讲一下我们将要分享的重点

00:23:39.520 --> 00:23:42.556 align:middle
首先我将讨论Model I/O
如何支持正常平滑

00:23:43.090 --> 00:23:48.562 align:middle
然后进入细分曲面
讨论体素和一个快速的演示

00:23:50.664 --> 00:23:52.566 align:middle
好的 开始吧法线平滑

00:23:53.567 --> 00:23:55.202 align:middle
法线平滑是非常酷的技术

00:23:55.402 --> 00:24:00.073 align:middle
能让人相信你的模型有更多几何形状

00:23:55.402 --> 00:24:00.073 align:middle
能让人相信你的模型有更多几何形状

00:24:01.008 --> 00:24:04.845 align:middle
默认情况下
多边形的顶点都有相同的法线

00:24:05.412 --> 00:24:08.916 align:middle
这样多边形的表面也有相同的法线

00:24:09.816 --> 00:24:12.886 align:middle
这会造成相邻多边形之间的
一个明显的褶皱

00:24:13.187 --> 00:24:17.691 align:middle
这是突然变化和顶点法线的
光栅化过程的结果

00:24:18.892 --> 00:24:21.128 align:middle
这种颜色的强烈对比可以减轻

00:24:21.295 --> 00:24:24.298 align:middle
通过引入一个共享的法线值

00:24:24.364 --> 00:24:27.901 align:middle
其值是共享相同的
坐标位置顶点法线的平均值

00:24:28.836 --> 00:24:33.707 align:middle
现在在GPU轻度计算下
多边形表面每个点的正常值

00:24:33.774 --> 00:24:36.643 align:middle
将是顶点法线插值

00:24:36.710 --> 00:24:40.247 align:middle
不再是同样的值展现出
很好的平滑明暗效果

00:24:41.982 --> 00:24:46.887 align:middle
使用mdlmesh API你可以通过调用
addNormalsWithAttributeNamed方法

00:24:46.954 --> 00:24:50.324 align:middle
给对象添加平滑法线

00:24:50.757 --> 00:24:53.193 align:middle
你还可以通过设置皱纹阀值

00:24:53.493 --> 00:24:55.495 align:middle
控制什么时候使用正常平滑

00:24:56.830 --> 00:25:01.869 align:middle
在我们的飞船上我们看到左边有
默认的平面阴影网格

00:24:56.830 --> 00:25:01.869 align:middle
在我们的飞船上我们看到左边有
默认的平面阴影网格

00:25:02.402 --> 00:25:03.904 align:middle
右边有平滑阴影

00:25:06.373 --> 00:25:08.208 align:middle
下面是细分曲面

00:25:09.109 --> 00:25:12.045 align:middle
细分曲面是一项普通技术

00:25:12.246 --> 00:25:15.782 align:middle
用来使用低细度的几何图形产生

00:25:15.849 --> 00:25:18.252 align:middle
和渲染平滑表面

00:25:19.152 --> 00:25:22.489 align:middle
这种技术可以让你使用
一个简单的多边形控制网格

00:25:22.689 --> 00:25:25.192 align:middle
创建所需的不同级别的细节

00:25:25.859 --> 00:25:27.828 align:middle
举例来说当一个物体远的时候

00:25:27.895 --> 00:25:30.664 align:middle
它以少量的多边形来渲染

00:25:31.098 --> 00:25:34.034 align:middle
当物体离镜头越来越近的时候

00:25:34.401 --> 00:25:35.769 align:middle
它会提高颗粒度

00:25:36.970 --> 00:25:38.839 align:middle
通过改变模型的细分层次

00:25:38.906 --> 00:25:40.908 align:middle
你可以产生不同的网格

00:25:40.974 --> 00:25:42.276 align:middle
不需要全部人工创建

00:25:43.544 --> 00:25:46.013 align:middle
在Model I/O中
你可以通过调用新的

00:25:46.380 --> 00:25:51.818 align:middle
SubdividedMesh程序
或者MDLMesh来创建细分层次

00:25:52.853 --> 00:25:55.489 align:middle
在下面我们将细分级别设置为2

00:25:55.889 --> 00:25:58.325 align:middle
实现了右边的光滑网格

00:25:58.625 --> 00:26:01.428 align:middle
多边形数显著增加

00:25:58.625 --> 00:26:01.428 align:middle
多边形数显著增加

00:26:04.398 --> 00:26:05.999 align:middle
最后是体素

00:26:06.834 --> 00:26:09.636 align:middle
除了提供各种以多边形展示

00:26:09.736 --> 00:26:12.072 align:middle
3D模型的先进技术

00:26:12.573 --> 00:26:15.709 align:middle
Model I/O还支持容量展示

00:26:17.044 --> 00:26:19.279 align:middle
通过以物体近似真实世界

00:26:19.346 --> 00:26:24.318 align:middle
的情况展示模型这是
一系列空间粒子或点

00:26:24.384 --> 00:26:28.155 align:middle
有固有的性质
如体积 质量 速度 颜色

00:26:28.689 --> 00:26:32.559 align:middle
以一系列的物理现实技术分析和操作

00:26:32.759 --> 00:26:34.494 align:middle
的大门向你敞开了

00:26:35.829 --> 00:26:38.832 align:middle
与多边形网格一样很难建模

00:26:38.899 --> 00:26:42.536 align:middle
和展现表面不规则的现象
如云 水 火

00:26:42.936 --> 00:26:45.706 align:middle
有了体积表现就变得非常容易了

00:26:46.607 --> 00:26:49.643 align:middle
现在与其试图混合和扭转

00:26:49.743 --> 00:26:52.646 align:middle
多边形的刚性外壳
该模型成为一个变形的物质

00:26:52.713 --> 00:26:54.915 align:middle
任何时间都可以改变它的属性

00:26:56.083 --> 00:26:58.819 align:middle
沿着相同的路线 这表示

00:26:58.952 --> 00:27:02.122 align:middle
允许程序生成建模意味着它可以制造

00:26:58.952 --> 00:27:02.122 align:middle
允许程序生成建模意味着它可以制造

00:27:02.256 --> 00:27:04.658 align:middle
让人兴奋和感到新奇的机会和游戏

00:27:05.125 --> 00:27:08.762 align:middle
考虑修改和毁坏对象和飞地

00:27:11.665 --> 00:27:14.801 align:middle
因为体素模型能更准确地表现

00:27:14.868 --> 00:27:18.138 align:middle
真实世界它可以让自己以

00:27:18.205 --> 00:27:22.776 align:middle
更自然和真实的方式
被探索和操纵就像是切片技术

00:27:23.944 --> 00:27:25.946 align:middle
这事实上被证明在医学影像领域

00:27:26.013 --> 00:27:28.849 align:middle
是特别有用的非常幸运

00:27:28.916 --> 00:27:34.354 align:middle
科学家已经证明我们
头骨不是一个三角形空壳

00:27:36.089 --> 00:27:39.126 align:middle
最后鉴于你已经有了固体体素模型

00:27:39.193 --> 00:27:41.628 align:middle
你可以执行构造实体几何布尔

00:27:41.695 --> 00:27:43.797 align:middle
操作以便创建大量

00:27:43.864 --> 00:27:45.933 align:middle
更有趣复杂的模型

00:27:48.535 --> 00:27:50.437 align:middle
在Model I/O中我们以

00:27:50.504 --> 00:27:53.507 align:middle
MDLVoxelArray API
暴露体素

00:27:54.274 --> 00:27:56.276 align:middle
我们的作品以稀疏网格表现

00:27:56.343 --> 00:27:59.146 align:middle
空间模型稀疏网格可以

00:27:59.213 --> 00:28:01.048 align:middle
使用简单的空间索引访问

00:27:59.213 --> 00:28:01.048 align:middle
使用简单的空间索引访问

00:28:02.249 --> 00:28:06.019 align:middle
这个表现形式具有快速找到并
访问邻居的功能

00:28:07.588 --> 00:28:11.625 align:middle
网格除了连接得每个体素外
还包含壳等级值

00:28:11.925 --> 00:28:16.230 align:middle
壳等级值是表明体素在正外部方向

00:28:16.697 --> 00:28:21.301 align:middle
和负内部方向离模型表面的远近

00:28:22.603 --> 00:28:24.638 align:middle
Model I/O也支持

00:28:24.805 --> 00:28:28.308 align:middle
创建封闭网格模型的清理
及转回多边形网格

00:28:29.510 --> 00:28:31.778 align:middle
我将向你展示少量你需要的API调用

00:28:31.845 --> 00:28:34.281 align:middle
以便能引入体素和Model I/O

00:28:36.083 --> 00:28:39.253 align:middle
假设有一个初始化的
MDLVoxelArray

00:28:39.319 --> 00:28:42.055 align:middle
你可以通过调用
setVoxelsForMesh方法

00:28:42.623 --> 00:28:44.925 align:middle
从MDMMesh模型产生体素数据

00:28:45.993 --> 00:28:49.830 align:middle
分离参数的作用是
设置分辨率设定层的数量

00:28:50.130 --> 00:28:54.201 align:middle
将你的模型在垂直方向分开

00:28:55.269 --> 00:29:00.340 align:middle
你也可以设置模型内墙和外墙的厚度
就用最后的这两个参数

00:28:55.269 --> 00:29:00.340 align:middle
你也可以设置模型内墙和外墙的厚度
就用最后的这两个参数

00:29:02.442 --> 00:29:04.211 align:middle
一旦你建立了体素数组对象

00:29:04.878 --> 00:29:06.947 align:middle
你可以在它们上面执行各种各样的操作

00:29:07.014 --> 00:29:10.083 align:middle
例如体素的交集合集及差分

00:29:10.150 --> 00:29:12.653 align:middle
这些是基本布林操作

00:29:14.621 --> 00:29:16.823 align:middle
要实际加工和处理

00:29:16.890 --> 00:29:20.527 align:middle
检查体素数据只需调用
getvoxelindices方法

00:29:21.628 --> 00:29:24.565 align:middle
做完了上面的操作
用meshUsingAllocator程序

00:29:24.631 --> 00:29:26.500 align:middle
就可以将体素模型

00:29:26.733 --> 00:29:28.836 align:middle
转换回多边形模型

00:29:31.104 --> 00:29:31.939 align:middle
非常简单

00:29:32.673 --> 00:29:35.342 align:middle
现在我将用快速
展示来展现一个动态的体素

00:29:54.728 --> 00:29:55.996 align:middle
让我们看这个展示

00:29:56.463 --> 00:29:58.765 align:middle
它会用一个小时的时间来展示

00:29:58.832 --> 00:30:00.934 align:middle
如何使用
SceneKit editor来创建

00:29:58.832 --> 00:30:00.934 align:middle
如何使用
SceneKit editor来创建

00:30:01.001 --> 00:30:02.936 align:middle
我们只需要在地面上拖拽

00:30:03.337 --> 00:30:08.308 align:middle
同样地像昨天在华盛顿
看到的红色熊猫那样

00:30:08.642 --> 00:30:12.779 align:middle
这是规则的多边形网格
你可以使用任意的网格来制作

00:30:13.747 --> 00:30:16.984 align:middle
下面是使用MDLVoxelArray
API它仅用两条线的代码

00:30:17.150 --> 00:30:19.486 align:middle
就把网格变成了体素

00:30:20.354 --> 00:30:25.158 align:middle
那么对于每个体素
我们都创建一个SCN盒子 就像这样

00:30:30.230 --> 00:30:32.666 align:middle
现在我们有了在
SceneKit中的体素

00:30:33.066 --> 00:30:36.637 align:middle
让人激动的是我们可以使用

00:30:36.703 --> 00:30:39.640 align:middle
SceneKit所提供的
所有非常酷的东西

00:30:40.040 --> 00:30:42.910 align:middle
举例来说使用一条线的代码

00:30:42.976 --> 00:30:45.846 align:middle
我们可以把SCN盒子变成SCN球

00:30:47.614 --> 00:30:50.050 align:middle
让大家开心下
我们将SceneKit体素

00:30:50.117 --> 00:30:52.386 align:middle
提供给所有节点然后引爆它

00:30:53.921 --> 00:30:56.456 align:middle
现在由Remi来接着讲

00:30:56.523 --> 00:30:59.293 align:middle
关于照明和Xcode支持的高级主体

00:31:09.002 --> 00:31:10.704 align:middle
大家好 谢谢克劳迪娅

00:31:11.271 --> 00:31:16.276 align:middle
如克里斯所说我将分享关于烘焙

00:31:16.343 --> 00:31:18.946 align:middle
以及Model I/O
工作原理的高级内容

00:31:20.113 --> 00:31:23.283 align:middle
所以就是高级照明和烘焙目的是什么

00:31:23.884 --> 00:31:27.187 align:middle
目的是介绍框架和喧染通道

00:31:27.254 --> 00:31:29.423 align:middle
在你的游戏中叫做全局照明

00:31:30.290 --> 00:31:31.124 align:middle
是什么呢？

00:31:31.592 --> 00:31:34.561 align:middle
这么说不好立即 好吧
我这里有点的高度

00:31:34.628 --> 00:31:38.498 align:middle
有三角形让我们用点工具照亮它就是了

00:31:39.099 --> 00:31:41.401 align:middle
我们将试图让场景看上去是真的

00:31:41.635 --> 00:31:45.005 align:middle
我们将要在光线因为不能穿过三角板

00:31:45.172 --> 00:31:47.441 align:middle
而在墙上反射的和阻挡的场景中

00:31:47.741 --> 00:31:50.177 align:middle
仿真光线实际移动

00:31:51.178 --> 00:31:53.647 align:middle
问题是这消耗非常大

00:31:53.780 --> 00:31:58.185 align:middle
在影片中会花费很长的时间
如果你想花费半个小时去重构的话

00:31:58.685 --> 00:32:00.120 align:middle
但这不适合我们

00:31:58.685 --> 00:32:00.120 align:middle
但这不适合我们

00:32:00.487 --> 00:32:03.857 align:middle
请看这张图片你可以看到举例来说

00:32:04.391 --> 00:32:07.528 align:middle
这里的墙左边的红墙

00:32:07.594 --> 00:32:09.663 align:middle
在球上投射了一些红色的光

00:32:10.197 --> 00:32:14.001 align:middle
墙不是真的光但光在

00:32:14.201 --> 00:32:17.638 align:middle
真实世界里是从墙上反射到球上的

00:32:18.438 --> 00:32:23.143 align:middle
回到球上它有点暗
因为球吸收了墙上反射的光

00:32:23.210 --> 00:32:26.079 align:middle
它不是真实的直接阴影
但是还有一些事情发生

00:32:27.848 --> 00:32:30.150 align:middle
问题是很难做到实时

00:32:30.484 --> 00:32:32.886 align:middle
所以我们将展示如何在

00:32:32.953 --> 00:32:36.557 align:middle
预编译期间游戏运行之前做一些预运算

00:32:37.191 --> 00:32:40.127 align:middle
这样你可以得到近似真实的景象

00:32:40.494 --> 00:32:42.429 align:middle
而不用任何性能的回落

00:32:42.829 --> 00:32:44.298 align:middle
我们将平衡性能和质量

00:32:44.631 --> 00:32:48.268 align:middle
所以你可以用很少的性能开销
得到你想要的效果

00:32:49.770 --> 00:32:52.873 align:middle
因此今天的全局照明将有两个点

00:32:52.940 --> 00:32:56.710 align:middle
首先我们将展示环境遮挡

00:32:57.377 --> 00:32:58.679 align:middle
然后是光照贴图

00:32:59.446 --> 00:33:01.949 align:middle
为了介绍环境遮挡我会展示一个示例

00:32:59.446 --> 00:33:01.949 align:middle
为了介绍环境遮挡我会展示一个示例

00:33:03.350 --> 00:33:07.321 align:middle
请看这个飞船它是默认的
SceneKit飞船 看上去不错

00:33:07.654 --> 00:33:11.225 align:middle
是一个大飞船
我喜欢玩这个游戏但是它有点平

00:33:11.325 --> 00:33:12.960 align:middle
如果你看看翅膀和发动机

00:33:13.627 --> 00:33:18.398 align:middle
它的翅膀尾部
和发动机的开端部位有点不清楚

00:33:18.465 --> 00:33:20.734 align:middle
如果你看右边图像的两翅片

00:33:21.602 --> 00:33:24.171 align:middle
它有点怪异因为你给它的光

00:33:24.238 --> 00:33:26.974 align:middle
和前面的飞船的光一样
但是翅片应该挡住光线

00:33:27.641 --> 00:33:30.277 align:middle
如果你要添加环境遮挡 它会变成这样

00:33:31.778 --> 00:33:34.481 align:middle
同样的渐变但是看上去更真实了

00:33:34.548 --> 00:33:37.484 align:middle
因为现在在翅膀和发动机之间的

00:33:37.751 --> 00:33:38.986 align:middle
遮挡有了阴影

00:33:39.520 --> 00:33:41.522 align:middle
如果我在第二个上面添加环境遮挡

00:33:41.755 --> 00:33:43.423 align:middle
它会这样 同样的

00:33:43.690 --> 00:33:46.527 align:middle
但你可以看到光的遮挡

00:33:46.860 --> 00:33:49.162 align:middle
这是更让人信服的体验

00:33:49.229 --> 00:33:53.200 align:middle
这是一个更好看的图片
环境遮挡实际是什么

00:33:54.501 --> 00:33:58.739 align:middle
环境遮挡是非常简单的
几何图形遮挡测量

00:33:59.039 --> 00:34:02.009 align:middle
意思是我的点或是网格

00:33:59.039 --> 00:34:02.009 align:middle
意思是我的点或是网格

00:34:02.442 --> 00:34:04.244 align:middle
在我的世界里有多少光

00:34:04.311 --> 00:34:07.614 align:middle
可以真正的落在我的点

00:34:07.681 --> 00:34:10.951 align:middle
有多少光被我的网格
或是它周围的网格遮住了

00:34:11.752 --> 00:34:17.858 align:middle
所以它基本上是一个信号 1
代表白色说明我完全无遮挡

00:34:17.991 --> 00:34:22.062 align:middle
全部的光发散出去了大多的光不能到那

00:34:22.462 --> 00:34:23.630 align:middle
如果我们看信号

00:34:23.964 --> 00:34:24.831 align:middle
是这样的

00:34:25.532 --> 00:34:28.101 align:middle
几何全白因为大多数光都不能到那儿

00:34:28.335 --> 00:34:30.904 align:middle
但是你看一些...那里的物理数据

00:34:32.739 --> 00:34:33.774 align:middle
我们如何计算？

00:34:34.507 --> 00:34:37.143 align:middle
使用离线光线追踪

00:34:37.210 --> 00:34:41.882 align:middle
网格变成...
我们把光线射向各个方向

00:34:42.081 --> 00:34:44.284 align:middle
然后计算如果我在我的点周围照射光线

00:34:44.618 --> 00:34:46.520 align:middle
有多少光线

00:34:46.786 --> 00:34:50.489 align:middle
有多少光线射在网格上
有多少射在天空盒子上

00:34:50.791 --> 00:34:53.193 align:middle
两者之间的区别在于我的环境遮挡信号

00:34:54.328 --> 00:34:55.728 align:middle
我们需要什么？

00:34:56.530 --> 00:34:59.199 align:middle
输入 网格 我的太空船

00:34:59.633 --> 00:35:00.701 align:middle
一系列的遮挡网格

00:34:59.633 --> 00:35:00.701 align:middle
一系列的遮挡网格

00:35:01.268 --> 00:35:02.703 align:middle
这里它只是一个太空船

00:35:02.769 --> 00:35:05.439 align:middle
举个例子如果我表现那个场景的光

00:35:06.039 --> 00:35:09.376 align:middle
我想做地面场景的
它将计算地面的环境遮挡

00:35:09.610 --> 00:35:14.014 align:middle
我还要所有的椅子 人 地板

00:35:14.515 --> 00:35:18.819 align:middle
所有阻挡光线的东西
这样我就有了一个非常好看的网格

00:35:19.052 --> 00:35:19.887 align:middle
这是非常好的设定

00:35:20.888 --> 00:35:21.955 align:middle
我的输出是

00:35:22.523 --> 00:35:25.859 align:middle
一组每个点的遮挡值

00:35:26.627 --> 00:35:27.728 align:middle
点的遮挡

00:35:29.196 --> 00:35:30.397 align:middle
我们如何存储

00:35:30.831 --> 00:35:34.168 align:middle
2种方式顶点或纹理

00:35:34.668 --> 00:35:36.537 align:middle
如果我的网格有很多顶点

00:35:36.637 --> 00:35:40.207 align:middle
举例来说一个有大量三角形的太空船

00:35:40.507 --> 00:35:42.075 align:middle
我们可以用顶点来存储非常好

00:35:42.309 --> 00:35:45.679 align:middle
因为它非常节省资源
每个顶点只要一浮动

00:35:46.246 --> 00:35:52.286 align:middle
栅格化你的金属或管道
非常节省的渲染

00:35:53.587 --> 00:35:57.024 align:middle
举例来说太空船是少量三角形

00:35:57.391 --> 00:35:58.292 align:middle
我们需要纹理来存储

00:35:59.693 --> 00:36:02.396 align:middle
我们已经内建在Model I/O

00:35:59.693 --> 00:36:02.396 align:middle
我们已经内建在Model I/O

00:36:02.796 --> 00:36:08.235 align:middle
一个UV映射创建二维纹理
以其包裹3D网格

00:36:08.869 --> 00:36:12.506 align:middle
这样这个纹理的每个
象素都有了环境遮挡

00:36:12.940 --> 00:36:15.442 align:middle
我们要看看这个飞船的纹理是什么样子

00:36:15.709 --> 00:36:16.543 align:middle
它是这样的

00:36:17.845 --> 00:36:20.814 align:middle
你可以看到纹理环绕在太空船周围

00:36:21.415 --> 00:36:24.117 align:middle
你可以看到翅膀和发动机的基座等等

00:36:26.887 --> 00:36:28.722 align:middle
我们怎么计算 非常简单

00:36:28.922 --> 00:36:30.057 align:middle
简单得不行

00:36:30.390 --> 00:36:32.693 align:middle
举例来说你可以看最上边的这个船网格

00:36:33.260 --> 00:36:35.028 align:middle
产生环境遮挡

00:36:35.896 --> 00:36:37.030 align:middle
这是纹理

00:36:37.631 --> 00:36:41.001 align:middle
我们有2个参数质量和衰减因子

00:36:41.668 --> 00:36:44.872 align:middle
如果我们提升质量
它将会将会发射更多的光线

00:36:44.938 --> 00:36:48.408 align:middle
得到更好看的信号 但是它
将会花费更多的时间去计算

00:36:49.276 --> 00:36:53.080 align:middle
因为这是烘焙它会在游戏加载前运行
但问题还没解决

00:36:53.547 --> 00:36:56.550 align:middle
如何我们做一个纹理烘焙
那么纹理会更大

00:36:56.683 --> 00:36:59.019 align:middle
所以它会提升一点内存消耗

00:36:59.653 --> 00:37:01.755 align:middle
那么衰减仅仅会衰减信号

00:36:59.653 --> 00:37:01.755 align:middle
那么衰减仅仅会衰减信号

00:37:01.822 --> 00:37:03.657 align:middle
只有暗的部分仍然保持暗

00:37:04.925 --> 00:37:09.897 align:middle
最酷的是我们与SceneKit团队
开发了在SceneKit甚至是

00:37:09.963 --> 00:37:12.366 align:middle
SceneKit编辑器中的功能

00:37:12.432 --> 00:37:14.134 align:middle
大家在华盛顿看到过了

00:37:14.701 --> 00:37:16.203 align:middle
我将立刻向你展示这个

00:37:20.174 --> 00:37:22.876 align:middle
它有效了

00:37:23.310 --> 00:37:26.747 align:middle
这里我只加载了一点场景

00:37:27.080 --> 00:37:31.351 align:middle
太空船和天空盒子

00:37:31.752 --> 00:37:33.787 align:middle
太空船在太空飞得非常好

00:37:34.188 --> 00:37:40.961 align:middle
我在这里没有加光
所以非常平唯一可见的是环境光

00:37:41.895 --> 00:37:45.199 align:middle
你可以看到环境光线对

00:37:45.265 --> 00:37:47.067 align:middle
太空船的外观没有作用

00:37:47.301 --> 00:37:49.937 align:middle
它没有以几何图形位置的形式

00:37:50.003 --> 00:37:52.139 align:middle
反馈给用户 所以它非常平

00:37:52.940 --> 00:37:53.774 align:middle
我们要改变

00:37:54.241 --> 00:37:55.843 align:middle
我先点击网格

00:37:55.909 --> 00:37:58.612 align:middle
我将看到实际上这里有些顶点

00:37:58.812 --> 00:37:59.880 align:middle
所以我们做个顶点烘焙

00:38:01.014 --> 00:38:02.349 align:middle
我会带入几何选项卡

00:38:03.984 --> 00:38:06.854 align:middle
我将在这儿在环境烘焙下面 选择顶点

00:38:07.721 --> 00:38:10.991 align:middle
这些值非常好 点烘焙

00:38:11.725 --> 00:38:12.559 align:middle
发生了什么

00:38:12.993 --> 00:38:16.530 align:middle
对于船上的每一个小的顶点
我们将发送100

00:38:16.597 --> 00:38:20.334 align:middle
到200光线到它的周围
看上去是这样

00:38:21.401 --> 00:38:23.170 align:middle
看 更好的方式

00:38:24.771 --> 00:38:26.306 align:middle
我们有了这个 现在又有了这个

00:38:27.241 --> 00:38:28.242 align:middle
它感觉上更好了

00:38:28.375 --> 00:38:30.577 align:middle
如果你看 例如 这 顶板

00:38:30.944 --> 00:38:34.314 align:middle
在1号底部有遮挡
因为光线不能很容易的到达那里

00:38:34.815 --> 00:38:36.850 align:middle
如果我们看这里面的窗户 在这里

00:38:37.718 --> 00:38:40.554 align:middle
窗口的内口比外部有更多的遮挡

00:38:41.355 --> 00:38:42.890 align:middle
如果我们看这

00:38:43.323 --> 00:38:44.157 align:middle
缩小

00:38:44.725 --> 00:38:46.793 align:middle
如果 我们看下面的大炮

00:38:47.160 --> 00:38:48.862 align:middle
大炮的顶部非常暗

00:38:48.929 --> 00:38:51.532 align:middle
因为整个船阻止光到达那里

00:38:51.965 --> 00:38:53.767 align:middle
如果我们看底部

00:38:54.568 --> 00:38:55.936 align:middle
都是白的 有意义 是吗

00:38:56.803 --> 00:39:00.407 align:middle
所以每个顶点增加一浮动，我们能

00:38:56.803 --> 00:39:00.407 align:middle
所以每个顶点增加一浮动，我们能

00:39:00.474 --> 00:39:05.712 align:middle
用环境光照亮我们的场景更好看了

00:39:07.247 --> 00:39:09.149 align:middle
在SceneKit中是可用的

00:39:09.950 --> 00:39:12.586 align:middle
让我们回到幻灯片

00:39:14.288 --> 00:39:15.122 align:middle
这是环境遮挡

00:39:16.023 --> 00:39:20.227 align:middle
今天关于以高级光贴图照射
就分享到这里

00:39:21.261 --> 00:39:22.829 align:middle
光贴图是什么

00:39:23.330 --> 00:39:27.167 align:middle
光贴图是一种方法让你的漫射照明

00:39:27.234 --> 00:39:30.204 align:middle
进入游戏并预计算实时
还是非实时情况下

00:39:30.270 --> 00:39:33.207 align:middle
扩散照明对纹理的影响

00:39:33.607 --> 00:39:35.976 align:middle
正如你们知道的
如果你做了一些游戏编程

00:39:36.510 --> 00:39:38.579 align:middle
光照是非常耗资源的

00:39:38.745 --> 00:39:41.815 align:middle
如果你有十个光源那么每一帧

00:39:41.915 --> 00:39:46.553 align:middle
你需要计算光的方面
以及它是如何干扰你的游戏的

00:39:46.920 --> 00:39:48.155 align:middle
这非常耗资源

00:39:48.755 --> 00:39:52.693 align:middle
这里我拖拽了仿真器中的一个飞机

00:39:52.759 --> 00:39:55.896 align:middle
两只盒子八个光源

00:39:56.396 --> 00:39:58.298 align:middle
然后 我计算 在我加载游戏前

00:39:58.365 --> 00:40:03.570 align:middle
使用光贴图烘焙
光贴图如何照亮场景及照亮纹理

00:39:58.365 --> 00:40:03.570 align:middle
使用光贴图烘焙
光贴图如何照亮场景及照亮纹理

00:40:05.005 --> 00:40:08.141 align:middle
如果我们看这个场景

00:40:08.642 --> 00:40:09.810 align:middle
看上去这样

00:40:09.877 --> 00:40:11.211 align:middle
非常真实

00:40:11.578 --> 00:40:13.113 align:middle
我们有了阴影和光

00:40:13.480 --> 00:40:16.550 align:middle
但是这实际耗费一个纹理获取

00:40:18.352 --> 00:40:19.186 align:middle
这样

00:40:19.786 --> 00:40:22.289 align:middle
通常渲染八个光特别是如果你有阴影

00:40:22.356 --> 00:40:23.690 align:middle
阴影贴图非常耗资源

00:40:24.358 --> 00:40:25.325 align:middle
纹理看上去这样

00:40:25.559 --> 00:40:29.096 align:middle
很简单你看中间的箱子和阴影

00:40:31.698 --> 00:40:33.700 align:middle
这非常酷 只是一个纹理获取 是吗？

00:40:34.201 --> 00:40:35.369 align:middle
它支持非常多的光

00:40:35.636 --> 00:40:37.771 align:middle
我能有100,000个光源

00:40:37.905 --> 00:40:41.508 align:middle
它将具有相同的运行成本

00:40:41.675 --> 00:40:43.844 align:middle
甚至阴影看上去也很酷

00:40:44.278 --> 00:40:47.481 align:middle
当你象这样做出个点光源
它非常贴近地面

00:40:47.548 --> 00:40:50.784 align:middle
你会遇到精确性问题
除非你这样做

00:40:50.951 --> 00:40:54.655 align:middle
发送光线到这个东西上的每个象素

00:40:54.988 --> 00:40:58.225 align:middle
看看哪个象素有光哪个象素没有光

00:40:58.492 --> 00:41:01.628 align:middle
你的阴影看上去将非常真实离线计算

00:40:58.492 --> 00:41:01.628 align:middle
你的阴影看上去将非常真实离线计算

00:41:03.397 --> 00:41:07.100 align:middle
我们支持超复杂的实时幻灯片

00:41:07.201 --> 00:41:11.138 align:middle
你甚至无法想像 这非常酷

00:41:11.572 --> 00:41:14.842 align:middle
举个例子我们实际的
光照在很长的时间里很难

00:41:14.908 --> 00:41:17.344 align:middle
做到实时因为用一般的点光

00:41:17.411 --> 00:41:21.582 align:middle
很难做到三角反射处理

00:41:21.882 --> 00:41:23.717 align:middle
这里我们用的是光线追踪

00:41:23.784 --> 00:41:27.387 align:middle
所以我们只要发出光线
看看哪些有光哪些没有光

00:41:28.055 --> 00:41:30.057 align:middle
我们也支持冷IS光源

00:41:30.524 --> 00:41:31.892 align:middle
尼克之前说过的

00:41:33.327 --> 00:41:34.261 align:middle
这是光贴图

00:41:35.762 --> 00:41:38.665 align:middle
让我们总结一下

00:41:39.233 --> 00:41:42.336 align:middle
今天我们介绍了一种非常新的框架
对于它 我们非常高兴

00:41:43.270 --> 00:41:47.407 align:middle
首先它做了基本的3D文件导入导出

00:41:47.875 --> 00:41:49.343 align:middle
但是对你来说做得非常多

00:41:49.843 --> 00:41:52.479 align:middle
它使用基于真实世界

00:41:52.880 --> 00:41:56.984 align:middle
而不是以浮动定义的
模型 光 相机 物质和天空

00:41:57.317 --> 00:41:59.553 align:middle
介绍了渲染的物理基础概念

00:42:00.387 --> 00:42:03.190 align:middle
我们有系统集成在Xcode中

00:42:03.257 --> 00:42:05.392 align:middle
的框架和工具中你可以玩 玩得很开心

00:42:07.160 --> 00:42:10.197 align:middle
为得到更多的信息
我们邀请你看我们的文档

00:42:10.264 --> 00:42:12.432 align:middle
视频 论坛和技术支持

00:42:12.866 --> 00:42:15.636 align:middle
任何一般的查询
您可以联系艾伦·谢弗

00:42:16.603 --> 00:42:21.508 align:middle
相关的会议有明天的
“SceneKit进阶”

00:42:21.575 --> 00:42:23.076 align:middle
和周二的Metal新功能

00:42:23.510 --> 00:42:27.014 align:middle
一会儿和明天早上9点

00:42:27.080 --> 00:42:28.782 align:middle
我们将在
Model I/O实验室见面

00:42:29.349 --> 00:42:31.685 align:middle
谢谢你们
希望你们有一个伟大的WWDC
