WEBVTT

00:00:19.720 --> 00:00:22.990 align:middle
《LLDB最新内容》
以自己的方式调试达至名利双收

00:00:23.056 --> 00:00:23.891 align:middle
下午好

00:00:23.991 --> 00:00:26.026 align:middle
欢迎参加
《LLDB最新内容》讲座

00:00:26.326 --> 00:00:27.361 align:middle
我是凯特

00:00:34.001 --> 00:00:36.436 align:middle
我负责管理Xcode
的运行时间分析工具

00:00:36.503 --> 00:00:37.771 align:middle
也包括LLDB

00:00:38.071 --> 00:00:40.040 align:middle
今天我来为大家介绍
但我还带来

00:00:40.107 --> 00:00:41.074 align:middle
两位工程师

00:00:41.475 --> 00:00:42.509 align:middle
西恩和恩里科

00:00:42.576 --> 00:00:44.611 align:middle
他们会更深入
介绍部分内容

00:00:45.345 --> 00:00:47.814 align:middle
但是开始之前
我想谈谈

00:00:47.881 --> 00:00:49.449 align:middle
自上次WWDC以来

00:00:49.516 --> 00:00:51.885 align:middle
今年的亮点有些或大

00:00:52.152 --> 00:00:53.487 align:middle
或小的改变

00:00:54.354 --> 00:00:55.189 align:middle
最著名的是...

00:00:56.423 --> 00:00:58.559 align:middle
我们推出首个Swift调试器

00:00:58.926 --> 00:01:01.461 align:middle
显然这是向前迈出了一步
可以编写和开发

00:00:58.926 --> 00:01:01.461 align:middle
显然这是向前迈出了一步
可以编写和开发

00:01:01.595 --> 00:01:04.298 align:middle
Swift代码 大家一定会
逐渐熟悉并喜爱

00:01:05.666 --> 00:01:08.035 align:middle
但更重要的是
不会就此为止

00:01:08.302 --> 00:01:10.137 align:middle
我们会进一步
改善调试器

00:01:10.204 --> 00:01:12.206 align:middle
希望大家继续反馈

00:01:12.272 --> 00:01:13.674 align:middle
帮我们实现尽善尽美

00:01:14.208 --> 00:01:15.175 align:middle
与此同时

00:01:15.409 --> 00:01:17.110 align:middle
我们还
推出了Swift REPL

00:01:17.244 --> 00:01:21.281 align:middle
它稍稍不同于标准请求回复
REPL环境

00:01:21.548 --> 00:01:24.985 align:middle
实际上是伪装的LLDB

00:01:25.219 --> 00:01:28.856 align:middle
大家不仅可以通过REPL
在Swift中提出问题

00:01:28.922 --> 00:01:31.358 align:middle
还可以通过它
来调试那些问题

00:01:31.425 --> 00:01:33.126 align:middle
你实际上是在REPL中
设置断点

00:01:33.327 --> 00:01:34.394 align:middle
实现想在调试环境下

00:01:34.494 --> 00:01:35.662 align:middle
完成的任何事情

00:01:35.829 --> 00:01:37.531 align:middle
因为它是LLDB

00:01:37.898 --> 00:01:39.199 align:middle
如果还没有
这么深入研究

00:01:39.333 --> 00:01:41.902 align:middle
我建议大家看看看
这一问题的相关博客

00:01:43.003 --> 00:01:44.605 align:middle
但是 这不是...
最终结果

00:01:44.671 --> 00:01:47.140 align:middle
之后 我们做了
无数的改进

00:01:47.207 --> 00:01:48.675 align:middle
自从首次推出产品以来

00:01:48.742 --> 00:01:50.244 align:middle
我们已经在Swift

00:01:50.310 --> 00:01:51.979 align:middle
调试体验方面
进行了百余项改进

00:01:52.045 --> 00:01:55.816 align:middle
而且我们还在继续提高
Objective-C的调试体验

00:01:56.116 --> 00:01:57.518 align:middle
我们今天也会
提到部分内容

00:01:57.851 --> 00:02:00.988 align:middle
不过只会介绍
自去年起做出的改进

00:01:57.851 --> 00:02:00.988 align:middle
不过只会介绍
自去年起做出的改进

00:02:02.322 --> 00:02:04.291 align:middle
Swift类型
起初并未显示出

00:02:04.358 --> 00:02:05.993 align:middle
继承了Objective-C域

00:02:06.159 --> 00:02:07.294 align:middle
我们后来对此作了更正

00:02:07.995 --> 00:02:10.631 align:middle
Help现在
包括了指令别名

00:02:10.697 --> 00:02:12.299 align:middle
需要理解的是

00:02:12.366 --> 00:02:16.170 align:middle
因为当LLDB看似语法
比较冗长

00:02:16.570 --> 00:02:17.971 align:middle
我们可能会让你输入help

00:02:18.405 --> 00:02:20.140 align:middle
实际上有许多快捷方式

00:02:20.207 --> 00:02:23.677 align:middle
在这次讲座中
我们会使用下列符号来描述它们

00:02:24.311 --> 00:02:28.382 align:middle
Help实际上可以
缩写为第一个独特序列

00:02:28.715 --> 00:02:31.084 align:middle
在这种情况下
H就足以调出帮助

00:02:31.852 --> 00:02:34.354 align:middle
更重要的是
对于更复杂的例子而言

00:02:34.421 --> 00:02:39.293 align:middle
如表达式-O--
是指评价表达式

00:02:39.693 --> 00:02:41.962 align:middle
告知结果
就像它是通过发送方法

00:02:42.062 --> 00:02:44.231 align:middle
来描述自己的
一个对象

00:02:45.098 --> 00:02:46.667 align:middle
随后在该表达之后

00:02:46.800 --> 00:02:48.268 align:middle
并无其他选项

00:02:48.902 --> 00:02:50.170 align:middle
但你可以输入PO

00:02:50.571 --> 00:02:52.739 align:middle
PO是个方便的别名
可以对左边的

00:02:52.806 --> 00:02:54.274 align:middle
所有内容进行速记

00:02:54.675 --> 00:02:56.643 align:middle
那么如果你习惯于
用帮助

00:02:56.710 --> 00:02:58.212 align:middle
应该学习使用这些别名

00:02:58.278 --> 00:02:59.947 align:middle
因为它们可以最快捷地

00:03:00.013 --> 00:03:03.050 align:middle
帮你获得LLDB中的
部分强大功能

00:03:04.184 --> 00:03:05.786 align:middle
我们还改善了
数据格式

00:03:05.986 --> 00:03:08.488 align:middle
因为告知你相关的数据情况

00:03:08.555 --> 00:03:10.257 align:middle
对于调试体验而言
是非常重要的

00:03:10.724 --> 00:03:12.626 align:middle
那么设置

00:03:12.826 --> 00:03:14.261 align:middle
和NSNS Index Path

00:03:14.328 --> 00:03:15.729 align:middle
目前就有了默认格式

00:03:15.796 --> 00:03:17.364 align:middle
可以帮助理解数据

00:03:17.464 --> 00:03:18.966 align:middle
而不是仅仅展示

00:03:19.032 --> 00:03:20.801 align:middle
底层结构的回收机制

00:03:21.802 --> 00:03:23.670 align:middle
表达式的Printf原型

00:03:24.171 --> 00:03:27.608 align:middle
如果曾尝试以Printf对它
进行计算 可能会发现

00:03:27.941 --> 00:03:30.043 align:middle
有一些稍微可疑的结果

00:03:30.544 --> 00:03:32.813 align:middle
这是因为调试器对它

00:03:32.880 --> 00:03:34.414 align:middle
不了解的表达式

00:03:34.481 --> 00:03:36.450 align:middle
声明做了很多假设

00:03:36.650 --> 00:03:39.319 align:middle
而之前它在很多情况下
也不了解printf

00:03:39.786 --> 00:03:42.022 align:middle
因此之前不知道
它是个可变参数函数

00:03:42.089 --> 00:03:44.525 align:middle
也就是可以采取
可变数量的特殊参数

00:03:44.825 --> 00:03:47.728 align:middle
也不了解特别是在
64位设备上

00:03:47.794 --> 00:03:49.530 align:middle
如何正确传递
这些特殊参数

00:03:49.897 --> 00:03:51.465 align:middle
这些都已得到改正
这样所有的

00:03:51.532 --> 00:03:55.068 align:middle
涉及C和Objective-C
的printf表达式

00:03:55.135 --> 00:03:56.970 align:middle
都应该另行执行

00:03:57.538 --> 00:03:59.640 align:middle
那么最后
这次是真的最后

00:03:59.873 --> 00:04:01.508 align:middle
我们改善了分解格式

00:03:59.873 --> 00:04:01.508 align:middle
我们改善了分解格式

00:04:01.575 --> 00:04:03.310 align:middle
使其更方便阅读

00:04:05.412 --> 00:04:07.981 align:middle
来深入了解
部分更有趣的改进

00:04:08.715 --> 00:04:10.851 align:middle
今年春天实现了
断点改进

00:04:10.918 --> 00:04:12.686 align:middle
大家可能还没有意识到

00:04:12.819 --> 00:04:15.322 align:middle
具体而言 大家现在
可以命名断点了

00:04:15.956 --> 00:04:18.024 align:middle
命名的断点可能
会比其他断点

00:04:18.091 --> 00:04:20.360 align:middle
更易于使用
这可能开始并不明显

00:04:20.427 --> 00:04:23.063 align:middle
不过 这些命名不一定
具备独特性

00:04:23.163 --> 00:04:25.732 align:middle
可以对单个断点
使用多个名称 这就很不简单

00:04:25.999 --> 00:04:28.168 align:middle
可以把它们想象成标签

00:04:29.570 --> 00:04:32.506 align:middle
所有的断点指令
都使用这些名称

00:04:32.606 --> 00:04:35.843 align:middle
那么设置断点时
可以提供断点设置

00:04:36.210 --> 00:04:38.145 align:middle
短线N 大写N

00:04:38.412 --> 00:04:39.613 align:middle
加上名称

00:04:39.680 --> 00:04:41.715 align:middle
还可以加上另一个短线大写N

00:04:41.782 --> 00:04:43.317 align:middle
和额外的名称等等

00:04:44.151 --> 00:04:46.720 align:middle
但更重要的是
一旦为断点

00:04:46.787 --> 00:04:48.789 align:middle
或多个断点命名

00:04:48.856 --> 00:04:50.390 align:middle
我就可以对它们

00:04:50.457 --> 00:04:51.825 align:middle
通过所有其他的指令来操作

00:04:51.892 --> 00:04:55.028 align:middle
断点可以命名
这会使得所有断点

00:04:55.262 --> 00:04:58.632 align:middle
都是可以共享命名
或者就把它当作是标签

00:05:00.033 --> 00:05:02.469 align:middle
这其实非常有趣
因为我们现在可以

00:05:02.536 --> 00:05:05.839 align:middle
实现在LLDBinit中
设置断点

00:05:06.273 --> 00:05:08.008 align:middle
如果你还不熟悉
LLDBinit

00:05:08.208 --> 00:05:09.276 align:middle
这是一种文件...

00:05:09.676 --> 00:05:11.979 align:middle
名前缀有个句号

00:05:12.045 --> 00:05:13.780 align:middle
会进入主目录

00:05:13.847 --> 00:05:16.183 align:middle
告知LLDB 这里有一束指令

00:05:16.250 --> 00:05:19.553 align:middle
每次打开LLDB会话都需要执行

00:05:20.254 --> 00:05:22.823 align:middle
如果这么使用
则会在LLDB启动时

00:05:22.890 --> 00:05:24.992 align:middle
生成一组 默认断点

00:05:25.158 --> 00:05:28.762 align:middle
所有设置的断点
在实际生成目标之前

00:05:29.129 --> 00:05:31.532 align:middle
都会被
所生成的每个目标所继承

00:05:32.633 --> 00:05:33.901 align:middle
那么结合两方面因素

00:05:34.201 --> 00:05:37.037 align:middle
我可以在这些
代码行编写LLDBinit

00:05:37.571 --> 00:05:39.540 align:middle
一组断点 -n
都命名为malloc

00:05:39.706 --> 00:05:41.441 align:middle
一个断点 -n
都命名为free

00:05:41.642 --> 00:05:43.844 align:middle
把所有断点命名为
memory

00:05:44.077 --> 00:05:45.245 align:middle
然后再关闭

00:05:45.479 --> 00:05:48.015 align:middle
这就可以很方便的
获得所有处理断点的内存

00:05:48.081 --> 00:05:49.650 align:middle
只要在我之后用到的

00:05:49.716 --> 00:05:50.884 align:middle
任何会话中输入

00:05:50.951 --> 00:05:54.988 align:middle
"breakpoint
enablememory"即可

00:05:55.422 --> 00:05:58.225 align:middle
这样就有了自己的
一组非常方便的断点

00:05:58.292 --> 00:05:59.793 align:middle
我肯定大家会经常使用

00:06:00.027 --> 00:06:02.262 align:middle
现在可以给它们
一些好记的名称

00:06:05.098 --> 00:06:07.601 align:middle
但是 当然大家在这里
不仅是来学习

00:06:07.668 --> 00:06:09.102 align:middle
我们已经完成
并推出的内容

00:06:09.369 --> 00:06:11.705 align:middle
还有我们刚开始
预览的内容

00:06:11.772 --> 00:06:12.873 align:middle
Xcode 7

00:06:13.273 --> 00:06:14.775 align:middle
是个很重要的版本

00:06:15.108 --> 00:06:16.510 align:middle
包括许多改进

00:06:16.643 --> 00:06:18.512 align:middle
最重要的是表达式求值

00:06:18.612 --> 00:06:21.348 align:middle
西恩会为大家
详细介绍这方面内容

00:06:21.682 --> 00:06:23.483 align:middle
Swift 2支持...
当然...

00:06:23.550 --> 00:06:26.453 align:middle
语言会不断发展
以及Objective-C

00:06:26.520 --> 00:06:29.590 align:middle
支持模块的高级处理

00:06:30.657 --> 00:06:32.292 align:middle
这些内容
我们也会深入讲解

00:06:32.559 --> 00:06:34.728 align:middle
但是部分内容
其实就在后台

00:06:34.795 --> 00:06:36.463 align:middle
如果继续深入研究
你可能会注意到

00:06:36.530 --> 00:06:37.998 align:middle
例如在Xcode 7中

00:06:38.398 --> 00:06:40.267 align:middle
大家都知道模块

00:06:40.734 --> 00:06:44.238 align:middle
我们实际上可以
在为模块构建调试信息一次后

00:06:44.371 --> 00:06:46.573 align:middle
再不必在其他位置重复进行

00:06:46.840 --> 00:06:50.577 align:middle
这可以大幅减少调试信息的

00:06:50.744 --> 00:06:54.181 align:middle
数量 并提高汇编的
性能表现

00:06:54.681 --> 00:06:56.717 align:middle
一旦进入
实际的.dSYM文件

00:06:56.783 --> 00:06:58.452 align:middle
这个.dSYM文件就会

00:06:58.519 --> 00:07:00.053 align:middle
将你所需的
所有内容都包括在内

00:06:58.519 --> 00:07:00.053 align:middle
将你所需的
所有内容都包括在内

00:07:00.687 --> 00:07:03.023 align:middle
但是其中还包括
部分其它优化

00:07:03.090 --> 00:07:06.126 align:middle
例如 不为C++类型
复制信息

00:07:06.360 --> 00:07:07.895 align:middle
这多亏了定义法则的规定

00:07:08.128 --> 00:07:10.464 align:middle
否则我们会有多个副本

00:07:10.797 --> 00:07:13.033 align:middle
实际上 我们看到
调试信息

00:07:13.233 --> 00:07:17.104 align:middle
要比Xcode 6中
少了1/6

00:07:18.238 --> 00:07:20.107 align:middle
特别是对C++项目更是如此

00:07:20.807 --> 00:07:23.577 align:middle
我们还在多方面
改进了数据格式

00:07:23.710 --> 00:07:26.980 align:middle
在Objective-C和
Swift中矢量类型有着

00:07:27.047 --> 00:07:28.482 align:middle
独特的自动数据格式

00:07:29.049 --> 00:07:30.651 align:middle
也许更重要的是

00:07:30.717 --> 00:07:32.819 align:middle
如果有Swift自定义类型

00:07:33.120 --> 00:07:35.088 align:middle
现在可以自定义它们的
表现方式

00:07:35.155 --> 00:07:37.057 align:middle
只要编写Swift代码即可

00:07:37.291 --> 00:07:38.992 align:middle
恩里科会介绍更多详情

00:07:40.260 --> 00:07:43.664 align:middle
我们还在LLDB中整合了
地址消毒剂支持

00:07:43.730 --> 00:07:45.999 align:middle
那么地址消毒剂
不只会在

00:07:46.066 --> 00:07:47.701 align:middle
参考内存无效时会告知

00:07:47.801 --> 00:07:49.636 align:middle
你还可以
针对内存提出问题

00:07:49.837 --> 00:07:52.639 align:middle
比如可以问
例如 内存历史

00:07:52.706 --> 00:07:55.576 align:middle
从LLDB控制台
了解它分配到哪里

00:07:55.776 --> 00:07:57.678 align:middle
以及何时释放

00:07:57.911 --> 00:07:59.780 align:middle
那么你可能想了解更多

00:07:59.980 --> 00:08:02.382 align:middle
指令的内存系列
并想知道相关帮助

00:07:59.980 --> 00:08:02.382 align:middle
指令的内存系列
并想知道相关帮助

00:08:03.917 --> 00:08:06.620 align:middle
我们还增加了
类型查找指令

00:08:06.820 --> 00:08:08.889 align:middle
类型查找指令
可以获取

00:08:08.956 --> 00:08:10.991 align:middle
系统的任何类型信息

00:08:11.425 --> 00:08:13.660 align:middle
基本上
这就是个类似头文件的表示

00:08:13.727 --> 00:08:15.495 align:middle
可以在调试器中获得

00:08:15.629 --> 00:08:17.798 align:middle
以便提醒你类型的内容

00:08:19.132 --> 00:08:20.734 align:middle
因此 从LLDB提示中

00:08:21.101 --> 00:08:24.605 align:middle
我只需要把类型变为
"type lookup"随后加上

00:08:24.838 --> 00:08:26.807 align:middle
类型名称 然后我会
获得类型快速说明

00:08:26.974 --> 00:08:29.076 align:middle
本例中 新的错误类型

00:08:29.142 --> 00:08:31.178 align:middle
用于Swift错误处理机制

00:08:31.345 --> 00:08:33.046 align:middle
我知道 在幕后

00:08:33.113 --> 00:08:34.615 align:middle
通常会执行一对

00:08:34.748 --> 00:08:38.018 align:middle
一般已执行了的属性
只要使用EDAM类型即可

00:08:38.217 --> 00:08:40.721 align:middle
但是不管怎样
都可以从控制台看到细节详情

00:08:41.221 --> 00:08:44.124 align:middle
同理 如果我感兴趣
"Comparable"类型

00:08:44.191 --> 00:08:45.025 align:middle
是个协议

00:08:45.225 --> 00:08:47.995 align:middle
它会告诉这个协议
实际上是来自另外两个

00:08:48.295 --> 00:08:50.264 align:middle
这样你会看到
我们从Equatable

00:08:50.330 --> 00:08:51.765 align:middle
<br/>
得到了等号运算符

00:08:52.065 --> 00:08:54.935 align:middle
下划线Comparable
可以提供小于比较

00:08:55.102 --> 00:08:58.438 align:middle
而导出运算符是
Comparable协议的一部分

00:08:58.772 --> 00:09:01.341 align:middle
这里还可获取许多
便捷信息

00:08:58.772 --> 00:09:01.341 align:middle
这里还可获取许多
便捷信息

00:09:01.508 --> 00:09:02.843 align:middle
和所有内容一样

00:09:03.644 --> 00:09:06.680 align:middle
提醒你不必输入完整命令
"type lookup"

00:09:06.847 --> 00:09:10.217 align:middle
TY空格L
便足以使用这个指令

00:09:11.251 --> 00:09:12.786 align:middle
但是要想知道更多详情

00:09:12.886 --> 00:09:15.856 align:middle
特别是谈到
怎样计算表达式

00:09:15.989 --> 00:09:18.258 align:middle
我想有请
西恩•卡拉南[

00:09:19.426 --> 00:09:20.260 align:middle
大家好

00:09:21.595 --> 00:09:24.631 align:middle
我来讲讲
LLDB中的LLDB

00:09:25.666 --> 00:09:27.067 align:middle
大家可能会觉得

00:09:27.267 --> 00:09:29.036 align:middle
有那么多编译器会话

00:09:29.303 --> 00:09:30.804 align:middle
为什么要在乎编译器？

00:09:31.572 --> 00:09:34.541 align:middle
编译器是
LLDB的关键内容

00:09:35.309 --> 00:09:37.945 align:middle
会使得LLDB功能强大

00:09:38.345 --> 00:09:40.647 align:middle
会令LLDB简单易用

00:09:41.481 --> 00:09:42.916 align:middle
它的强大是

00:09:43.116 --> 00:09:45.719 align:middle
因为编译器对程序运行

00:09:46.019 --> 00:09:47.955 align:middle
对配置数据的方法

00:09:48.388 --> 00:09:49.957 align:middle
以及当你说想看看

00:09:51.692 --> 00:09:53.861 align:middle
这个变量或调用函数时等

00:09:53.927 --> 00:09:55.462 align:middle
有着独特的理解

00:09:56.964 --> 00:10:00.067 align:middle
编译器很重要
还有一个原因是

00:09:56.964 --> 00:10:00.067 align:middle
编译器很重要
还有一个原因是

00:10:00.133 --> 00:10:03.070 align:middle
它们可以与调试器
轻松配合使用

00:10:03.904 --> 00:10:05.372 align:middle
如果想要打印

00:10:05.839 --> 00:10:07.774 align:middle
只要使用你熟悉

00:10:07.841 --> 00:10:09.109 align:middle
输入的代码

00:10:10.110 --> 00:10:11.778 align:middle
交给表达式指令

00:10:12.646 --> 00:10:14.915 align:middle
编译器就会从中拿到指令

00:10:17.784 --> 00:10:18.619 align:middle
今天

00:10:18.719 --> 00:10:20.153 align:middle
我来讲讲在编译器整合方面

00:10:20.220 --> 00:10:21.421 align:middle
有两个重要

00:10:21.822 --> 00:10:23.490 align:middle
相关领域

00:10:23.690 --> 00:10:25.259 align:middle
获得了的改进

00:10:27.094 --> 00:10:27.961 align:middle
首先

00:10:28.095 --> 00:10:29.396 align:middle
有个好消息要告诉各位

00:10:29.463 --> 00:10:31.665 align:middle
长期从事Objective-C
的开发人员

00:10:32.499 --> 00:10:33.333 align:middle
接下来

00:10:33.467 --> 00:10:34.301 align:middle
我要告诉...

00:10:34.801 --> 00:10:36.336 align:middle
Swift开发人员

00:10:36.670 --> 00:10:38.338 align:middle
希望现在各位都是

00:10:39.439 --> 00:10:40.274 align:middle
聊聊...

00:10:40.407 --> 00:10:42.042 align:middle
我们所做的这些改进

00:10:43.777 --> 00:10:45.679 align:middle
现在就开始
讲讲Objective-C

00:10:48.749 --> 00:10:49.716 align:middle
LLDB

00:10:49.850 --> 00:10:50.684 align:middle
包括...

00:10:50.784 --> 00:10:52.519 align:middle
两个独立的编译器

00:10:54.288 --> 00:10:55.122 align:middle
Clang

00:10:55.255 --> 00:10:57.057 align:middle
强大的Objective-C
编译器

00:10:58.025 --> 00:10:59.626 align:middle
当然 从去年起

00:10:59.993 --> 00:11:01.128 align:middle
是Swift编译器

00:10:59.993 --> 00:11:01.128 align:middle
是Swift编译器

00:11:02.596 --> 00:11:04.698 align:middle
我们的Objective-C
编译器支持

00:11:05.365 --> 00:11:06.900 align:middle
多年来一直在改进

00:11:07.434 --> 00:11:09.570 align:middle
我们加入了非常出色的新功能

00:11:10.771 --> 00:11:11.605 align:middle
比如

00:11:11.939 --> 00:11:14.007 align:middle
Objective-C
运行时间整合

00:11:14.842 --> 00:11:18.111 align:middle
那么 如果Objective-C
运行时间有部分信息

00:11:18.312 --> 00:11:20.380 align:middle
并未显示在
调试信息中

00:11:21.048 --> 00:11:23.317 align:middle
我们知道该向编译器提供

00:11:23.383 --> 00:11:25.319 align:middle
这样可以使用很多类

00:11:25.619 --> 00:11:27.221 align:middle
而不必特别做些什么

00:11:28.755 --> 00:11:29.723 align:middle
当然 去年

00:11:29.923 --> 00:11:31.892 align:middle
我们在LLDB中

00:11:32.226 --> 00:11:33.427 align:middle
引入了Swift编译器

00:11:34.294 --> 00:11:36.163 align:middle
Swift编译器已经是

00:11:36.430 --> 00:11:37.831 align:middle
是很强的工具

00:11:39.499 --> 00:11:41.101 align:middle
我们把从Swift编译器中

00:11:41.368 --> 00:11:43.570 align:middle
整合所学内容都用到其中

00:11:44.505 --> 00:11:46.273 align:middle
我们对二者都做了改进

00:11:47.641 --> 00:11:48.509 align:middle
我们来谈谈

00:11:48.575 --> 00:11:50.644 align:middle
表达式剖析器与Swift

00:11:51.578 --> 00:11:52.412 align:middle
怎么配合

00:11:52.846 --> 00:11:54.781 align:middle
从Objective-C的角度

00:11:57.551 --> 00:11:59.953 align:middle
我们现在来看
简单的打印指令

00:12:00.687 --> 00:12:03.557 align:middle
这里说到打印
因为我用了p快捷方式

00:12:04.491 --> 00:12:05.659 align:middle
实际上是指

00:12:05.926 --> 00:12:07.327 align:middle
表达式

00:12:08.228 --> 00:12:09.530 align:middle
注意短线

00:12:10.330 --> 00:12:11.164 align:middle
这是指

00:12:11.231 --> 00:12:14.168 align:middle
在p指令编码后的
所有内容

00:12:14.468 --> 00:12:17.838 align:middle
不能这样把额外的选项
交给指令

00:12:18.405 --> 00:12:20.240 align:middle
这里有其他方法
恩里科会给大家介绍

00:12:20.307 --> 00:12:21.608 align:middle
而且凯特刚刚给大家看过

00:12:22.676 --> 00:12:25.712 align:middle
这里是些循环运行的
简单代码

00:12:25.879 --> 00:12:27.481 align:middle
并会每次打印出
循环计数

00:12:28.048 --> 00:12:29.483 align:middle
的确 如果运行它

00:12:30.117 --> 00:12:32.019 align:middle
你会得到自己预期的数字

00:12:33.287 --> 00:12:34.254 align:middle
这个功能好在哪里？

00:12:36.523 --> 00:12:39.826 align:middle
LLDB和程序
是单独的进程

00:12:40.761 --> 00:12:43.197 align:middle
LLDB内部有
swift编译器

00:12:44.231 --> 00:12:45.999 align:middle
程序已经在运行

00:12:46.633 --> 00:12:48.435 align:middle
但是有了LLDB的帮助

00:12:48.869 --> 00:12:52.406 align:middle
Swift编译器可以
把你刚输入程序运行的

00:12:52.606 --> 00:12:54.041 align:middle
代码添加进来

00:12:55.709 --> 00:12:56.844 align:middle
如果喜欢打印...

00:12:57.211 --> 00:12:58.846 align:middle
循环计数器 这就相当棒

00:12:59.446 --> 00:13:01.315 align:middle
但是还有
要调试的内容

00:12:59.446 --> 00:13:01.315 align:middle
但是还有
要调试的内容

00:13:03.517 --> 00:13:06.086 align:middle
Swift可以和
变量配合

00:13:07.721 --> 00:13:09.056 align:middle
输入一些代码

00:13:10.724 --> 00:13:13.293 align:middle
数组的内容就打印出来

00:13:14.628 --> 00:13:15.963 align:middle
现在 这里的数组

00:13:16.363 --> 00:13:18.432 align:middle
正好有一些
在程序中的代码

00:13:19.433 --> 00:13:21.969 align:middle
LLDB安排在编译器上...

00:13:22.436 --> 00:13:23.403 align:middle
显示数据

00:13:23.637 --> 00:13:25.939 align:middle
这样可以生成
你所需的代码

00:13:28.242 --> 00:13:31.445 align:middle
我还想简单...介绍一下

00:13:31.745 --> 00:13:34.348 align:middle
就是Swift怎么和SDK配合

00:13:35.415 --> 00:13:39.353 align:middle
当你输入
NSApplication.sharedApplication

00:13:40.621 --> 00:13:41.588 align:middle
这样的表达式时

00:13:42.556 --> 00:13:44.024 align:middle
首先 你会看到

00:13:44.091 --> 00:13:46.460 align:middle
NSApplication.sharedApplication

00:13:46.527 --> 00:13:47.394 align:middle
是按照预期的方式

00:13:48.395 --> 00:13:50.130 align:middle
但是LLDB要去

00:13:50.697 --> 00:13:54.168 align:middle
发现包括它的SDK模块

00:13:55.369 --> 00:13:56.970 align:middle
让编译器可以访问它

00:13:57.571 --> 00:14:00.007 align:middle
然后编译器找到
NSApplication

00:13:57.571 --> 00:14:00.007 align:middle
然后编译器找到
NSApplication

00:14:00.240 --> 00:14:02.543 align:middle
并想出如何使用
sharedApplication

00:14:04.244 --> 00:14:05.078 align:middle
这非常好

00:14:05.345 --> 00:14:06.780 align:middle
而且都是在Swift中...

00:14:06.914 --> 00:14:07.748 align:middle
自动完成

00:14:08.682 --> 00:14:09.983 align:middle
在Objective-C

00:14:10.851 --> 00:14:11.919 align:middle
它并非总是工作

00:14:13.887 --> 00:14:16.957 align:middle
让我们在Objective-C
尝试所有这些

00:14:17.658 --> 00:14:20.928 align:middle
有些人此刻可能有些担心

00:14:21.595 --> 00:14:24.831 align:middle
因为你知道
NSLog有时并不像

00:14:24.898 --> 00:14:26.934 align:middle
调试器中那么简单

00:14:30.103 --> 00:14:32.539 align:middle
过去 当输入NSLog时

00:14:32.773 --> 00:14:34.274 align:middle
会看到像这样的错误提示:

00:14:34.341 --> 00:14:36.310 align:middle
NS日志存在未知返回类型

00:14:38.045 --> 00:14:40.013 align:middle
这是因为
在SDK肯定会

00:14:40.080 --> 00:14:41.715 align:middle
存在NSLog的定义

00:14:42.115 --> 00:14:43.617 align:middle
但是LLDB发现

00:14:43.750 --> 00:14:46.186 align:middle
符号中只有调试信息中的内容

00:14:46.486 --> 00:14:48.188 align:middle
在本例中
它看到一个符号

00:14:48.822 --> 00:14:51.291 align:middle
这个符号 我们不知道
它的返回类型是什么

00:14:51.391 --> 00:14:53.660 align:middle
我们甚至不知道
它还用了格式字符串

00:14:55.362 --> 00:14:57.164 align:middle
好消息是
问题已经得到解决

00:14:58.131 --> 00:14:59.833 align:middle
NSLog是按照
预期的方式工作

00:15:06.773 --> 00:15:11.545 align:middle
我们再做些
更隐秘的内容

00:15:11.612 --> 00:15:13.080 align:middle
打印NSMakeRect

00:15:13.514 --> 00:15:14.348 align:middle
稍等！

00:15:14.414 --> 00:15:15.649 align:middle
为什么是隐秘的内容呢？

00:15:15.716 --> 00:15:17.251 align:middle
就在这里框架中

00:15:19.319 --> 00:15:23.090 align:middle
可惜的是
看似标识符并不存在

00:15:23.757 --> 00:15:26.693 align:middle
现在大家就会了解
如果使用NSLog

00:15:26.760 --> 00:15:28.328 align:middle
可以转换结果

00:15:28.395 --> 00:15:29.263 align:middle
对 可以这么用

00:15:30.097 --> 00:15:32.566 align:middle
但是NSMakeRect
不能这么用

00:15:33.667 --> 00:15:34.635 align:middle
这是因为

00:15:34.801 --> 00:15:37.604 align:middle
NSMakeRect
是确定的NS-Inline

00:15:37.971 --> 00:15:39.373 align:middle
没有符号

00:15:39.806 --> 00:15:42.276 align:middle
LLDB什么也看不到

00:15:44.044 --> 00:15:44.878 align:middle
不错

00:15:45.345 --> 00:15:47.014 align:middle
没问题了

00:15:53.954 --> 00:15:55.656 align:middle
还剩一个问题

00:15:56.790 --> 00:15:57.958 align:middle
我们现在来看

00:15:58.725 --> 00:16:00.961 align:middle
原先NSApplicationsh
aredApplication

00:15:58.725 --> 00:16:00.961 align:middle
原先NSApplicationsh
aredApplication

00:16:01.028 --> 00:16:01.862 align:middle
的情况

00:16:01.929 --> 00:16:03.463 align:middle
当然 若你是自己运行
这个表达式

00:16:03.530 --> 00:16:05.465 align:middle
当然会在Objective-C
中运行

00:16:05.532 --> 00:16:08.035 align:middle
我们已经在为
Objective-C运行时间整合

00:16:08.101 --> 00:16:08.936 align:middle
做了很多工作

00:16:09.436 --> 00:16:12.272 align:middle
但是如果想找出
undo.Manager

00:16:12.439 --> 00:16:14.608 align:middle
你很快会发现运行时间
并未告诉你所有内容

00:16:15.242 --> 00:16:17.744 align:middle
特别是你发现的这个
关于undo.Manager的

00:16:17.811 --> 00:16:21.548 align:middle
奇怪错误提示
在类型id对象中并未发现

00:16:22.549 --> 00:16:23.817 align:middle
是什么情况？

00:16:24.117 --> 00:16:24.952 align:middle
在SDK肯定

00:16:25.018 --> 00:16:27.154 align:middle
sharedApplication
会返回一个

00:16:27.221 --> 00:16:28.722 align:middle
NSApplication星级

00:16:28.789 --> 00:16:30.724 align:middle
但如果来看
运行时间

00:16:31.024 --> 00:16:32.693 align:middle
返回的是id

00:16:33.060 --> 00:16:33.894 align:middle
是个一般的

00:16:34.895 --> 00:16:36.563 align:middle
Objective-C对象

00:16:38.966 --> 00:16:39.800 align:middle
好消息

00:16:40.200 --> 00:16:41.568 align:middle
这不再是问题了

00:16:41.935 --> 00:16:46.607 align:middle
实际上 我们会看到
只能从SDK得到的信息

00:16:46.773 --> 00:16:48.942 align:middle
例如
指针为可空值

00:16:49.076 --> 00:16:51.879 align:middle
这就是SDK支持Swift的
最新功能

00:16:52.079 --> 00:16:54.515 align:middle
也会进入
Objective-C

00:16:57.684 --> 00:17:00.187 align:middle
不过信息就在这里

00:16:57.684 --> 00:17:00.187 align:middle
不过信息就在这里

00:17:00.454 --> 00:17:02.723 align:middle
这就是我们
所应用的理念

00:17:03.524 --> 00:17:05.692 align:middle
从SDK直接读出

00:17:06.193 --> 00:17:08.494 align:middle
代码会一直
在LLDB中运行

00:17:08.694 --> 00:17:13.433 align:middle
我们了解本地变量
函数 自己的类

00:17:15.002 --> 00:17:17.171 align:middle
SDK函数
另一方面

00:17:17.671 --> 00:17:19.540 align:middle
我们还有更多
问题 如大家所见

00:17:21.241 --> 00:17:24.278 align:middle
SDK类就像NSView
和NSApplication

00:17:24.344 --> 00:17:25.746 align:middle
我们看到了 但是如你所见

00:17:25.811 --> 00:17:27.414 align:middle
因为运行时间整合

00:17:28.015 --> 00:17:29.716 align:middle
这里有个小星号

00:17:31.185 --> 00:17:33.153 align:middle
现在SDK包括
如果你试着在表达式用过

00:17:33.220 --> 00:17:35.522 align:middle
NSASCIIStringEnc
oding

00:17:35.822 --> 00:17:37.958 align:middle
就会了解这永远不行

00:17:39.126 --> 00:17:42.229 align:middle
如果使用宏 如int-max

00:17:42.429 --> 00:17:43.764 align:middle
那么 max

00:17:43.830 --> 00:17:46.200 align:middle
利用两个数字中最大值

00:17:46.600 --> 00:17:48.368 align:middle
这样也不会奏效

00:17:50.537 --> 00:17:53.140 align:middle
所有这些在
最新的LLDB中都已解决

00:18:00.280 --> 00:18:02.349 align:middle
我们也删掉了烦人的星号

00:18:05.886 --> 00:18:10.057 align:middle
大家可能会说那么
每月要付多少个39.95才能用上

00:18:10.190 --> 00:18:11.358 align:middle
这个功能呢？

00:18:11.425 --> 00:18:13.093 align:middle
好消息 这完全免费

00:18:13.160 --> 00:18:15.996 align:middle
你只需要
@import AppKit即可

00:18:17.130 --> 00:18:18.966 align:middle
运行一个表达式

00:18:19.032 --> 00:18:21.768 align:middle
表明输入
我关心的框架

00:18:22.536 --> 00:18:24.571 align:middle
如果用到AppKit
或是在诸位中间的

00:18:24.638 --> 00:18:25.806 align:middle
两三位...

00:18:26.273 --> 00:18:28.175 align:middle
iOS程编写人员

00:18:28.242 --> 00:18:29.710 align:middle
输入UIKit...

00:18:30.878 --> 00:18:32.112 align:middle
就可以了

00:18:34.715 --> 00:18:35.549 align:middle
现在

00:18:36.917 --> 00:18:38.986 align:middle
我们并未将
Swift放在那里不管

00:18:40.153 --> 00:18:44.491 align:middle
Swift2.0可实现
强大的错误处理支持

00:18:44.658 --> 00:18:48.529 align:middle
LLDB马上就可以
支持the bat

00:18:48.862 --> 00:18:50.197 align:middle
正如大家所期待的那样

00:18:52.999 --> 00:18:55.068 align:middle
我们可以处理Swift错误

00:18:56.236 --> 00:18:58.205 align:middle
当调用可能在

00:18:58.272 --> 00:19:00.507 align:middle
表达式引发错误的函数时

00:18:58.272 --> 00:19:00.507 align:middle
表达式引发错误的函数时

00:19:00.574 --> 00:19:02.543 align:middle
你不必调用"try"

00:19:03.410 --> 00:19:04.311 align:middle
因为...

00:19:04.578 --> 00:19:07.047 align:middle
我们为大家抓取内容

00:19:08.515 --> 00:19:09.550 align:middle
如果你输入

00:19:10.083 --> 00:19:11.685 align:middle
这个函数"throws"

00:19:12.019 --> 00:19:13.387 align:middle
并把它交给表达式

00:19:13.453 --> 00:19:15.522 align:middle
注意这和p指令
完全一样

00:19:16.657 --> 00:19:17.591 align:middle
你会获得

00:19:18.225 --> 00:19:19.660 align:middle
为你生成的...

00:19:19.993 --> 00:19:21.128 align:middle
错误变量

00:19:21.261 --> 00:19:23.797 align:middle
其中包括函数引发的错误

00:19:26.233 --> 00:19:28.735 align:middle
也可以在
REPL中...完成这些

00:19:30.571 --> 00:19:32.940 align:middle
如果从REPL提示中
你做了同样的事情

00:19:34.575 --> 00:19:36.710 align:middle
则会得到...错误变量

00:19:39.780 --> 00:19:42.649 align:middle
我们再来看看
LLDB支持的...

00:19:43.183 --> 00:19:44.218 align:middle
更多内容

00:19:45.352 --> 00:19:47.554 align:middle
也就是说 你不希望
总是看到

00:19:47.621 --> 00:19:49.423 align:middle
最后出现的是错误

00:19:49.923 --> 00:19:53.160 align:middle
你需要了解
产生错误的代码是什么

00:19:54.561 --> 00:19:56.063 align:middle
不过 在Objective-C中

00:19:56.129 --> 00:19:57.564 align:middle
你用到了断点来完成

00:19:58.699 --> 00:20:02.202 align:middle
具体而言你在Objective-C
异常中设置了断点

00:19:58.699 --> 00:20:02.202 align:middle
具体而言你在Objective-C
异常中设置了断点

00:20:03.170 --> 00:20:04.505 align:middle
方法是...

00:20:04.671 --> 00:20:06.807 align:middle
你用了断点来设置指令

00:20:08.575 --> 00:20:11.178 align:middle
确定了希望为...

00:20:12.012 --> 00:20:14.314 align:middle
异常Objective-C...

00:20:15.115 --> 00:20:15.949 align:middle
设置断点

00:20:16.650 --> 00:20:18.852 align:middle
我们来为你设置了断点

00:20:19.119 --> 00:20:21.121 align:middle
那么一旦Objective-C代码

00:20:21.655 --> 00:20:22.956 align:middle
要引发异常

00:20:23.290 --> 00:20:24.124 align:middle
我们就会停下来

00:20:25.192 --> 00:20:27.494 align:middle
在Swift错误中
你可以做同样的事情

00:20:28.195 --> 00:20:30.764 align:middle
只要用Swift
替代Objective-C

00:20:31.498 --> 00:20:33.734 align:middle
我们就会停止
程序要...

00:20:33.934 --> 00:20:34.968 align:middle
引发的...

00:20:35.335 --> 00:20:36.403 align:middle
Swift错误

00:20:37.471 --> 00:20:38.605 align:middle
但是还可以...

00:20:39.006 --> 00:20:40.974 align:middle
做另一件很酷的事

00:20:42.309 --> 00:20:45.646 align:middle
你可以停止
具体的错误类型

00:20:46.647 --> 00:20:48.549 align:middle
这是我们支持
Swift的一个功能

00:20:49.149 --> 00:20:51.151 align:middle
这么做的方法很简单

00:20:51.218 --> 00:20:54.955 align:middle
和你在设置表达式断点
非常相似

00:20:56.490 --> 00:20:58.825 align:middle
可以使用短线O参数

00:20:59.459 --> 00:21:01.628 align:middle
来明确你希望捕捉的

00:20:59.459 --> 00:21:01.628 align:middle
来明确你希望捕捉的

00:21:01.929 --> 00:21:03.497 align:middle
错误类型名称

00:21:04.831 --> 00:21:09.303 align:middle
如果这么做
那么只有在出现

00:21:10.003 --> 00:21:12.573 align:middle
你感兴趣的错误类型时

00:21:13.006 --> 00:21:13.907 align:middle
才会停下来

00:21:15.876 --> 00:21:16.844 align:middle
最后

00:21:18.312 --> 00:21:19.213 align:middle
当然

00:21:20.314 --> 00:21:22.883 align:middle
你可以按照
正常代码中...

00:21:23.217 --> 00:21:24.785 align:middle
的方法捕捉错误

00:21:24.852 --> 00:21:26.420 align:middle
毕竟 部分而言

00:21:26.653 --> 00:21:30.757 align:middle
REPL是指了解和发现语言
运行的方法

00:21:32.025 --> 00:21:33.794 align:middle
如果输入Foundation

00:21:34.127 --> 00:21:35.395 align:middle
来获取NSError

00:21:36.330 --> 00:21:39.533 align:middle
然后编写会产生
NSError的代码

00:21:40.334 --> 00:21:43.704 align:middle
就可以捕捉
NSError...并打印出来

00:21:45.439 --> 00:21:46.440 align:middle
如果这么做

00:21:46.707 --> 00:21:48.675 align:middle
结果就和你在自己的程序中

00:21:48.742 --> 00:21:50.577 align:middle
捕捉的效果完全相同

00:21:52.613 --> 00:21:54.081 align:middle
我希望大家...

00:21:54.548 --> 00:21:55.983 align:middle
记住两点

00:21:56.116 --> 00:21:57.117 align:middle
首先

00:21:57.684 --> 00:21:58.685 align:middle
添加输入...

00:21:58.886 --> 00:21:59.853 align:middle
自己的模块

00:22:00.754 --> 00:22:01.922 align:middle
第二

00:22:02.422 --> 00:22:05.359 align:middle
试着用LLDB进行错误处理

00:22:05.425 --> 00:22:06.560 align:middle
这是个不错的办法

00:22:07.694 --> 00:22:09.863 align:middle
要想了解更多详情

00:22:09.930 --> 00:22:12.132 align:middle
不是说告诉程序该做什么

00:22:12.766 --> 00:22:17.304 align:middle
而是如何在程序
产生资料完成后打印信息

00:22:17.905 --> 00:22:19.740 align:middle
有请恩里科·格拉纳塔

00:22:22.709 --> 00:22:23.544 align:middle
大家好

00:22:24.378 --> 00:22:26.246 align:middle
上午我还在实验室

00:22:26.313 --> 00:22:29.082 align:middle
我们在想办法
解决一个问题

00:22:29.816 --> 00:22:33.487 align:middle
问题是...为什么
我看不到这个变量？

00:22:33.787 --> 00:22:34.955 align:middle
出什么事了？

00:22:35.556 --> 00:22:38.125 align:middle
为了帮助大家找到问题

00:22:38.525 --> 00:22:39.860 align:middle
我们试了几个指令

00:22:39.927 --> 00:22:42.896 align:middle
试了表达式 还有
PO 我们还试了帧变量

00:22:43.564 --> 00:22:46.166 align:middle
此刻 人们通常会问

00:22:46.466 --> 00:22:49.570 align:middle
为什么有那么多指令来做几乎
相同的事情？

00:22:49.636 --> 00:22:52.072 align:middle
来看我的数据
看看程序中在发生什么

00:22:53.373 --> 00:22:56.443 align:middle
大家来这里
就是了解内部消息的

00:22:56.710 --> 00:22:59.847 align:middle
我们来看一下
LLDB让你看数据的指令

00:23:00.614 --> 00:23:02.482 align:middle
共有三个

00:23:02.850 --> 00:23:03.884 align:middle
帧变量

00:23:04.151 --> 00:23:05.485 align:middle
表达式指令

00:23:05.886 --> 00:23:07.187 align:middle
是个p指令

00:23:07.721 --> 00:23:09.790 align:middle
表达式
短线大写O

00:23:09.857 --> 00:23:10.691 align:middle
这个...

00:23:10.757 --> 00:23:12.092 align:middle
刚才讲过

00:23:12.292 --> 00:23:15.195 align:middle
是作为PO指令

00:23:15.896 --> 00:23:16.730 align:middle
首先

00:23:16.864 --> 00:23:18.165 align:middle
帧变量指令

00:23:18.699 --> 00:23:22.402 align:middle
帧变量指令
可以缩写为frv

00:23:22.469 --> 00:23:26.106 align:middle
输入时
基本是Xcode变量视图

00:23:26.607 --> 00:23:29.743 align:middle
它让你...看所有的
本地变量

00:23:30.410 --> 00:23:31.612 align:middle
让你看...

00:23:32.012 --> 00:23:33.947 align:middle
几个本地变量

00:23:34.748 --> 00:23:36.083 align:middle
此外

00:23:36.250 --> 00:23:37.951 align:middle
也可以应用...

00:23:38.118 --> 00:23:40.454 align:middle
带有短线 短线格式旗标的格式

00:23:41.755 --> 00:23:43.156 align:middle
要强调的一点是

00:23:43.490 --> 00:23:44.925 align:middle
因为在看到首次输出时

00:23:45.926 --> 00:23:48.729 align:middle
有Tuple的话
我会回到这里

00:23:48.996 --> 00:23:49.830 align:middle
这是个...

00:23:49.963 --> 00:23:50.864 align:middle
聚合

00:23:51.098 --> 00:23:53.800 align:middle
是包括其他对象的对象

00:23:54.134 --> 00:23:56.737 align:middle
聚合当中的内容

00:23:57.004 --> 00:23:58.005 align:middle
我们称之为...

00:23:58.572 --> 00:23:59.406 align:middle
子对象

00:24:01.241 --> 00:24:02.609 align:middle
这个表达式指令

00:24:03.577 --> 00:24:05.379 align:middle
在本次会话中你会多次看到

00:24:05.479 --> 00:24:06.580 align:middle
我会简要介绍一下

00:24:06.980 --> 00:24:07.814 align:middle
当然

00:24:08.215 --> 00:24:09.283 align:middle
有了表达式指令

00:24:09.349 --> 00:24:11.919 align:middle
可以简单算一下
正如你猜测的一样

00:24:12.519 --> 00:24:16.223 align:middle
完全可能...使用之前的结果

00:24:16.657 --> 00:24:19.259 align:middle
并用它们
完成更多内容

00:24:20.327 --> 00:24:22.462 align:middle
当然 表达式指令
也知道如何

00:24:22.529 --> 00:24:24.698 align:middle
自定义结果的格式

00:24:25.732 --> 00:24:27.968 align:middle
需要再次强调的一点是

00:24:28.836 --> 00:24:29.803 align:middle
子对象

00:24:30.771 --> 00:24:31.839 align:middle
第三个指令

00:24:32.339 --> 00:24:33.507 align:middle
po指令

00:24:34.141 --> 00:24:38.345 align:middle
这个可能是...在座各位
Objective-C开发员的指令

00:24:38.545 --> 00:24:40.914 align:middle
我猜测
在Objective-C代码之前

00:24:41.315 --> 00:24:43.383 align:middle
大家都知道是PO指令

00:24:43.784 --> 00:24:46.887 align:middle
你可以生成对象
把说明打印出来

00:24:47.788 --> 00:24:50.991 align:middle
可以生成NSArray
或打印现有的NSArray

00:24:51.058 --> 00:24:52.492 align:middle
你就会看到其中的内容

00:24:53.060 --> 00:24:54.461 align:middle
要知道

00:24:54.528 --> 00:24:56.763 align:middle
对于字符串而言非常简单

00:24:57.698 --> 00:24:58.532 align:middle
那么

00:24:58.599 --> 00:24:59.533 align:middle
三条指令

00:24:59.900 --> 00:25:02.135 align:middle
它们并非是完全一样的功能

00:24:59.900 --> 00:25:02.135 align:middle
它们并非是完全一样的功能

00:25:02.202 --> 00:25:04.004 align:middle
大家估计此刻也猜到了

00:25:04.705 --> 00:25:05.539 align:middle
实际上

00:25:06.540 --> 00:25:07.941 align:middle
它们只是有些相似

00:25:08.008 --> 00:25:09.209 align:middle
但不是完全相同

00:25:09.409 --> 00:25:10.244 align:middle
例如

00:25:10.811 --> 00:25:12.880 align:middle
表达式指令和po指令

00:25:13.213 --> 00:25:15.749 align:middle
是...
"run my code"指令

00:25:16.083 --> 00:25:17.551 align:middle
无论代码类型是什么

00:25:17.618 --> 00:25:19.386 align:middle
这些指令都会运行

00:25:20.888 --> 00:25:22.990 align:middle
但是 接下来的
帧变量指令

00:25:23.056 --> 00:25:25.359 align:middle
和表达式指令
第二步则不相同

00:25:25.726 --> 00:25:27.728 align:middle
当它们不得不显示结果时

00:25:27.861 --> 00:25:30.230 align:middle
会用到LLDB格式器系统

00:25:31.331 --> 00:25:34.301 align:middle
我们在以往的WWDC
讲座中

00:25:34.368 --> 00:25:36.603 align:middle
介绍过LLDB格式器系统

00:25:37.004 --> 00:25:38.672 align:middle
大家应该都去找来看看

00:25:39.072 --> 00:25:40.240 align:middle
不过简单而言

00:25:40.641 --> 00:25:43.744 align:middle
LLDB掌握部分嵌入系统类型

00:25:43.944 --> 00:25:45.479 align:middle
并对其自动格式化

00:25:45.779 --> 00:25:48.582 align:middle
NSArray NSDictionaries
加字符串

00:25:49.116 --> 00:25:53.654 align:middle
还可以提供...在Python中
编写的自己的格式

00:25:54.688 --> 00:25:55.789 align:middle
另一方面

00:25:55.989 --> 00:25:58.392 align:middle
po指令并不使用
LLDB格式器

00:25:58.659 --> 00:26:02.930 align:middle
po指令在...后面
在幕后

00:25:58.659 --> 00:26:02.930 align:middle
po指令在...后面
在幕后

00:26:03.130 --> 00:26:04.031 align:middle
运行更多的代码

00:26:04.398 --> 00:26:05.832 align:middle
实际上会生成为

00:26:05.899 --> 00:26:07.301 align:middle
为你显示的真实结果

00:26:08.202 --> 00:26:10.537 align:middle
你可能已经在
一个Objective-C类中

00:26:10.604 --> 00:26:12.272 align:middle
至少编写了一个
说明方法

00:26:12.506 --> 00:26:15.275 align:middle
然后意识到
这就是po打印的内容

00:26:16.276 --> 00:26:17.110 align:middle
现在

00:26:17.444 --> 00:26:18.946 align:middle
我希望大家想一想

00:26:19.213 --> 00:26:20.047 align:middle
这两个模型

00:26:20.113 --> 00:26:23.217 align:middle
实际上在用你的对象
并为之生产数据

00:26:24.151 --> 00:26:26.019 align:middle
LLDB格式器模型

00:26:26.220 --> 00:26:27.688 align:middle
我们称之为

00:26:27.955 --> 00:26:29.857 align:middle
"out of process"
格式模型

00:26:29.923 --> 00:26:30.757 align:middle
为什么呢

00:26:30.824 --> 00:26:33.694 align:middle
因为格式器位于进程之外

00:26:33.961 --> 00:26:36.430 align:middle
它或者将
内容构建到调试器中

00:26:36.830 --> 00:26:39.933 align:middle
或者你用部分Python
脚本表现对象

00:26:40.267 --> 00:26:42.069 align:middle
这是不同的语言
不同的文件

00:26:42.135 --> 00:26:43.904 align:middle
存在于不同的作用域中

00:26:44.638 --> 00:26:45.672 align:middle
另一方面

00:26:46.306 --> 00:26:48.742 align:middle
外部格式器位于调试器中

00:26:48.976 --> 00:26:50.978 align:middle
这就很容易...

00:26:51.178 --> 00:26:54.448 align:middle
让他访问调试器所具备
程序的所有内容

00:26:54.748 --> 00:26:57.384 align:middle
就像是可以鸟瞰所有进程

00:26:58.519 --> 00:27:02.189 align:middle
因此 这类格式器
也可以很容易...

00:26:58.519 --> 00:27:02.189 align:middle
因此 这类格式器
也可以很容易...

00:27:02.523 --> 00:27:05.225 align:middle
确定程序状态并未改变

00:27:05.659 --> 00:27:08.028 align:middle
你若是看到
调试器中的数据后

00:27:08.095 --> 00:27:10.397 align:middle
不想改变程序状态

00:27:10.764 --> 00:27:12.699 align:middle
调试器相当于是阶段...

00:27:13.033 --> 00:27:13.867 align:middle
检测器

00:27:13.934 --> 00:27:16.103 align:middle
它来看内容
并试图不做改变

00:27:17.671 --> 00:27:18.839 align:middle
在另外的模型中

00:27:19.206 --> 00:27:20.240 align:middle
po模型

00:27:20.374 --> 00:27:22.743 align:middle
writeadescription
method模型

00:27:23.010 --> 00:27:25.212 align:middle
是个进程格式模型

00:27:25.612 --> 00:27:28.415 align:middle
你同时编写数据和格式器

00:27:28.682 --> 00:27:30.617 align:middle
再用相同的语言
编写一遍

00:27:31.118 --> 00:27:33.754 align:middle
可能甚至都在相同的
文件中编写

00:27:34.621 --> 00:27:36.757 align:middle
因为格式器是在应用中

00:27:36.823 --> 00:27:38.625 align:middle
运行的代码

00:27:38.692 --> 00:27:40.661 align:middle
可以轻松并完全

00:27:40.727 --> 00:27:42.829 align:middle
访问应用的对象模型

00:27:44.031 --> 00:27:45.999 align:middle
但是功能更强大

00:27:46.200 --> 00:27:47.901 align:middle
责任也更大

00:27:48.535 --> 00:27:51.071 align:middle
需要确保格式器

00:27:51.138 --> 00:27:53.040 align:middle
并没有改变程序的状态

00:27:53.540 --> 00:27:56.710 align:middle
要确保并未在
格式器中...

00:27:56.910 --> 00:27:59.680 align:middle
对准备表现的对象
做了任何改变

00:28:00.981 --> 00:28:03.750 align:middle
那好 Objective-C

00:28:03.817 --> 00:28:05.319 align:middle
具备进程进程格式模型

00:28:05.452 --> 00:28:06.787 align:middle
我可以编写说明方式

00:28:06.854 --> 00:28:08.222 align:middle
调试器会用到

00:28:08.789 --> 00:28:10.123 align:middle
那Swift会怎样？

00:28:11.358 --> 00:28:13.827 align:middle
结果是 演讲厅里
在座的各位

00:28:13.894 --> 00:28:15.195 align:middle
又一次知道了内部消息

00:28:15.462 --> 00:28:18.398 align:middle
从一开始Swift已有了

00:28:18.632 --> 00:28:20.000 align:middle
进程格式模型

00:28:20.701 --> 00:28:21.535 align:middle
但是 在哪儿呢？

00:28:21.602 --> 00:28:22.736 align:middle
怎么用呢？

00:28:23.537 --> 00:28:26.673 align:middle
希望大家
都用过Swift开发环境

00:28:27.107 --> 00:28:29.142 align:middle
如果用过Swift开发环境

00:28:29.510 --> 00:28:32.145 align:middle
那就用过进程格式模型

00:28:32.479 --> 00:28:34.147 align:middle
从一开始它就在这里

00:28:35.849 --> 00:28:36.817 align:middle
那有什么新奇的呢？

00:28:37.784 --> 00:28:41.355 align:middle
现在 在Xcode 7
我们会采取完全相同的模型

00:28:41.788 --> 00:28:44.024 align:middle
把它作为公共API

00:28:44.791 --> 00:28:46.560 align:middle
大家可以使用它

00:28:47.694 --> 00:28:50.230 align:middle
它仍然支持...开发环境

00:28:50.664 --> 00:28:54.034 align:middle
不过现在也支持
LLDB po指令

00:28:54.501 --> 00:28:56.603 align:middle
现在 你有着正确的
Swift格式器

00:28:56.670 --> 00:28:58.071 align:middle
针对Swift对象

00:28:58.705 --> 00:28:59.540 align:middle
怎么弄？

00:28:59.806 --> 00:29:01.608 align:middle
我们来详细讲一下

00:28:59.806 --> 00:29:01.608 align:middle
我们来详细讲一下

00:29:02.476 --> 00:29:04.144 align:middle
这个模型基于...

00:29:04.411 --> 00:29:05.746 align:middle
4个协议

00:29:06.980 --> 00:29:08.348 align:middle
这些是各自的名称

00:29:09.283 --> 00:29:11.718 align:middle
对 我说是四个协议

00:29:12.085 --> 00:29:13.954 align:middle
它们的名称相当长

00:29:14.621 --> 00:29:16.823 align:middle
但是...我不会
过分担心

00:29:16.957 --> 00:29:20.127 align:middle
可能是这个模型的可选项

00:29:20.360 --> 00:29:21.595 align:middle
4个协议

00:29:21.662 --> 00:29:23.630 align:middle
并非是指必须符合所有要求

00:29:23.964 --> 00:29:27.000 align:middle
可以选择子集
来获得所需要的结果

00:29:27.167 --> 00:29:29.203 align:middle
符合使用的协议部分

00:29:29.436 --> 00:29:30.571 align:middle
就可以了

00:29:31.471 --> 00:29:32.639 align:middle
我们来看一下协议

00:29:33.774 --> 00:29:35.809 align:middle
CustomStringConvertible

00:29:35.876 --> 00:29:37.611 align:middle
是协议名称

00:29:37.911 --> 00:29:39.046 align:middle
表示...

00:29:39.613 --> 00:29:42.482 align:middle
怎样把对象作为
字符串打印？

00:29:43.584 --> 00:29:45.419 align:middle
它并未告知LLDB

00:29:45.719 --> 00:29:47.354 align:middle
它还告知了Swift

00:29:47.855 --> 00:29:48.689 align:middle
怎么弄？

00:29:48.755 --> 00:29:50.457 align:middle
Swift打印功函数

00:29:50.824 --> 00:29:53.594 align:middle
以及Swift字符串
插值功能

00:29:53.760 --> 00:29:56.697 align:middle
二者都用了CustomString
Convertible协议

00:29:57.297 --> 00:29:58.465 align:middle
非常好用

00:29:58.599 --> 00:30:00.133 align:middle
实现这些很难吗？

00:29:58.599 --> 00:30:00.133 align:middle
实现这些很难吗？

00:30:01.602 --> 00:30:02.436 align:middle
非常简单

00:30:02.836 --> 00:30:05.906 align:middle
我有个数据结构
代表啤酒歌的瓶子

00:30:05.973 --> 00:30:08.041 align:middle
因为我自己正在
准备bash脚本

00:30:08.408 --> 00:30:10.210 align:middle
我想把歌词打印出来

00:30:10.878 --> 00:30:12.713 align:middle
就生成了一个实例

00:30:12.779 --> 00:30:14.781 align:middle
并看墙上有多少啤酒瓶

00:30:15.449 --> 00:30:17.451 align:middle
但是要等到
app的...

00:30:17.784 --> 00:30:19.086 align:middle
所有内容都没问题的时候

00:30:19.152 --> 00:30:21.255 align:middle
如果我做调试
也许我需要更多信息

00:30:21.788 --> 00:30:25.092 align:middle
那就需要Custom Debug
String Convertible

00:30:25.392 --> 00:30:28.729 align:middle
这是调试器对这个对象的
具体表示

00:30:29.429 --> 00:30:31.598 align:middle
调试器具体表示是什么

00:30:32.032 --> 00:30:33.834 align:middle
则要取决你的app

00:30:33.901 --> 00:30:35.769 align:middle
完全取决于对象
模型的语义

00:30:36.503 --> 00:30:37.571 align:middle
但是作为提示

00:30:37.638 --> 00:30:39.206 align:middle
debugPrint函数

00:30:39.506 --> 00:30:41.642 align:middle
将默认选择这个协议

00:30:42.242 --> 00:30:43.143 align:middle
当然

00:30:43.510 --> 00:30:45.345 align:middle
打印和debugPrint

00:30:45.412 --> 00:30:47.814 align:middle
不会满足其他一致性要求

00:30:48.015 --> 00:30:49.683 align:middle
如果它们的兴趣点不在此

00:30:50.484 --> 00:30:51.518 align:middle
怎么运行呢？

00:30:51.885 --> 00:30:53.153 align:middle
很简单

00:30:53.954 --> 00:30:55.923 align:middle
我们把啤酒瓶进行扩展

00:30:56.423 --> 00:30:58.425 align:middle
因为我们在做调试

00:30:58.492 --> 00:31:00.360 align:middle
希望了解墙上啤酒瓶的更多信息

00:30:58.492 --> 00:31:00.360 align:middle
希望了解墙上啤酒瓶的更多信息

00:31:00.594 --> 00:31:03.230 align:middle
这样我们可以确定啤酒类型
是否正确

00:31:03.463 --> 00:31:05.766 align:middle
这就会成为不错的bash脚本
因为它们都很出色

00:31:06.967 --> 00:31:08.268 align:middle
第三个协议

00:31:08.535 --> 00:31:11.205 align:middle
是CustomPlayground
Quick Lookable

00:31:11.772 --> 00:31:13.106 align:middle
正如名称所示

00:31:13.373 --> 00:31:16.376 align:middle
这个协议是主要
为环境而定

00:31:16.977 --> 00:31:20.747 align:middle
是指为环境中的
对象提供

00:31:20.814 --> 00:31:22.916 align:middle
丰富的图形表示

00:31:23.717 --> 00:31:24.651 align:middle
想要看举例吗？

00:31:24.718 --> 00:31:26.019 align:middle
当然有

00:31:26.787 --> 00:31:29.823 align:middle
我可以编写代表一个人的
数据结构

00:31:30.157 --> 00:31:32.259 align:middle
然后我可以获得
一个人的描述

00:31:32.326 --> 00:31:34.394 align:middle
在环境的侧边工具栏显示

00:31:34.695 --> 00:31:36.930 align:middle
以此作为生成这个类型
对象的结果

00:31:38.899 --> 00:31:41.068 align:middle
不好意思
让你们失望了

00:31:41.134 --> 00:31:42.870 align:middle
我的确想做成的

00:31:43.136 --> 00:31:45.706 align:middle
但是 大会上不会销售

00:31:45.772 --> 00:31:48.008 align:middle
带有人像的T恤衫

00:31:48.342 --> 00:31:49.376 align:middle
不好意思

00:31:50.244 --> 00:31:52.379 align:middle
不过 我有个弥补的办法

00:31:52.679 --> 00:31:54.181 align:middle
其中最后的协议

00:31:54.481 --> 00:31:56.416 align:middle
Custom
Reflectable协议

00:31:56.483 --> 00:31:58.619 align:middle
它可以让我
生成完全自定义的

00:31:58.685 --> 00:31:59.786 align:middle
子对象层次

00:32:00.087 --> 00:32:03.056 align:middle
好 我说过 我会回到
"children"这里 说到做到

00:32:04.024 --> 00:32:07.227 align:middle
当我说到完全自定义
子对象层次时

00:32:08.262 --> 00:32:09.730 align:middle
我是说

00:32:10.364 --> 00:32:12.199 align:middle
我可以
做个新的...

00:32:12.266 --> 00:32:14.801 align:middle
我可以为对象
制作新的结构

00:32:15.135 --> 00:32:17.204 align:middle
可以告知语言
可以告知调试器

00:32:17.271 --> 00:32:18.338 align:middle
可以告知环境

00:32:18.639 --> 00:32:20.774 align:middle
我的对象实际上是用什么来造的

00:32:20.874 --> 00:32:22.109 align:middle
大家会看到

00:32:22.576 --> 00:32:24.044 align:middle
你做此事的方法

00:32:24.311 --> 00:32:26.580 align:middle
交易用的货币

00:32:26.880 --> 00:32:30.083 align:middle
在想要对Swift描述
对象的结构时

00:32:30.417 --> 00:32:31.251 align:middle
被称为

00:32:31.451 --> 00:32:32.386 align:middle
Mirror

00:32:32.486 --> 00:32:33.487 align:middle
可反射的镜像

00:32:35.222 --> 00:32:37.925 align:middle
我们来看个例子
不要费时费事

00:32:38.525 --> 00:32:40.727 align:middle
我有个应用用来

00:32:40.827 --> 00:32:42.996 align:middle
搜集温度样本

00:32:43.864 --> 00:32:45.199 align:middle
它有两个数据结构

00:32:45.699 --> 00:32:46.934 align:middle
一个用来描述

00:32:47.267 --> 00:32:48.435 align:middle
此刻的时间

00:32:48.735 --> 00:32:51.205 align:middle
它说在给定的时刻

00:32:51.538 --> 00:32:53.507 align:middle
这就是我得到的温度信息

00:32:54.508 --> 00:32:56.543 align:middle
接着当然我们
获得温度样本

00:32:57.244 --> 00:32:58.745 align:middle
现在我来调试app

00:32:59.079 --> 00:33:00.781 align:middle
我想看看是什么情况

00:32:59.079 --> 00:33:00.781 align:middle
我想看看是什么情况

00:33:00.848 --> 00:33:02.249 align:middle
怎么来处理样本

00:33:02.683 --> 00:33:03.584 align:middle
所以我提出

00:33:04.251 --> 00:33:05.485 align:middle
po温度

00:33:06.587 --> 00:33:07.654 align:middle
我得到的是这个

00:33:08.856 --> 00:33:11.792 align:middle
实话讲 我看着它
觉得

00:33:12.025 --> 00:33:13.894 align:middle
作为默认值还不错

00:33:14.394 --> 00:33:17.297 align:middle
不过 我立刻发现
我想调整两个问题

00:33:17.931 --> 00:33:20.133 align:middle
为什么在把时间堆在两行？

00:33:20.200 --> 00:33:22.469 align:middle
我想把所有内容
都放在一行

00:33:22.836 --> 00:33:24.538 align:middle
而且如果是用a.m.
p.m.格式

00:33:24.605 --> 00:33:25.939 align:middle
表示上下午最好

00:33:26.573 --> 00:33:28.375 align:middle
还有温度

00:33:28.809 --> 00:33:29.943 align:middle
我看着它 觉得

00:33:30.043 --> 00:33:31.678 align:middle
标度是什么呢？

00:33:31.745 --> 00:33:32.579 align:middle
我不知道

00:33:32.679 --> 00:33:35.816 align:middle
是开氏
列氏还是兰氏温标？

00:33:36.016 --> 00:33:39.486 align:middle
我们在美国想用的是华氏温度

00:33:42.022 --> 00:33:45.192 align:middle
好消息是
我们可以用两步骤

00:33:45.859 --> 00:33:47.628 align:middle
解决所有这些问题

00:33:48.328 --> 00:33:49.162 align:middle
开始

00:33:49.630 --> 00:33:52.633 align:middle
第一步 我们把
时间按照一行打印

00:33:54.301 --> 00:33:56.870 align:middle
我做了这些
来实现这一点

00:33:57.171 --> 00:33:59.206 align:middle
用了NSDate格式器

00:34:00.741 --> 00:34:03.911 align:middle
因为我要在...
自己的应用中运行

00:34:04.178 --> 00:34:07.114 align:middle
因为我运行的对象格式代码

00:34:07.514 --> 00:34:09.783 align:middle
实际就是
正常的Swift代码

00:34:09.983 --> 00:34:12.553 align:middle
就是我通常编写app

00:34:12.853 --> 00:34:14.087 align:middle
所用的代码不论是什么框架

00:34:14.288 --> 00:34:15.121 align:middle
什么库

00:34:15.389 --> 00:34:18.859 align:middle
还是我的app完成任务
通常所用的技术

00:34:19.359 --> 00:34:21.428 align:middle
我在格式器中用就好了

00:34:21.862 --> 00:34:23.797 align:middle
在本例中 是NSDate格式器

00:34:24.931 --> 00:34:25.866 align:middle
第二步

00:34:26.400 --> 00:34:28.569 align:middle
选用华氏温度

00:34:29.837 --> 00:34:31.038 align:middle
怎么实现？

00:34:31.705 --> 00:34:33.172 align:middle
我们生成镜像

00:34:33.639 --> 00:34:34.507 align:middle
好了

00:34:34.875 --> 00:34:38.045 align:middle
现在我们可以说
温度数据对象

00:34:38.110 --> 00:34:41.815 align:middle
是作为包括三项内容
来构建

00:34:42.248 --> 00:34:44.251 align:middle
时间 摄氏温度

00:34:44.318 --> 00:34:45.585 align:middle
以及华氏温度

00:34:46.219 --> 00:34:48.722 align:middle
时间是存储在
对象内部的

00:34:48.922 --> 00:34:51.757 align:middle
真实时间数据的
字符串插值

00:34:52.659 --> 00:34:54.828 align:middle
因为是用字符串插值

00:34:54.895 --> 00:34:57.931 align:middle
因为我们提供了
自定义字符串可转换一致性

00:34:58.398 --> 00:35:00.567 align:middle
这些可以自动提取

00:34:58.398 --> 00:35:00.567 align:middle
这些可以自动提取

00:35:01.835 --> 00:35:03.837 align:middle
这里还要
注意的一点是

00:35:04.304 --> 00:35:08.108 align:middle
当我获得两种温标
用摄氏度

00:35:08.175 --> 00:35:10.677 align:middle
和华氏度
来进行结果打印

00:35:11.278 --> 00:35:14.114 align:middle
我不能改变
存储在对象内的数值

00:35:14.715 --> 00:35:16.016 align:middle
当然 你会说 不要改

00:35:17.050 --> 00:35:19.520 align:middle
实际上
要注意的是

00:35:19.686 --> 00:35:21.522 align:middle
不要用编写
进程格式器的

00:35:21.588 --> 00:35:23.557 align:middle
方法改变程序的状态

00:35:24.892 --> 00:35:27.661 align:middle
现在我们做了这么些工作
得到了这些东西

00:35:28.662 --> 00:35:30.697 align:middle
会怎样从中受益呢？

00:35:31.732 --> 00:35:33.967 align:middle
我们可以试着再做po

00:35:35.702 --> 00:35:36.970 align:middle
来吧

00:35:37.337 --> 00:35:38.705 align:middle
现在我再来看

00:35:38.772 --> 00:35:39.673 align:middle
我看到了对象

00:35:40.174 --> 00:35:42.109 align:middle
可以看到现在是

00:35:42.176 --> 00:35:44.444 align:middle
6:30 p.m.

00:35:44.711 --> 00:35:47.047 align:middle
是93.2度

00:35:49.049 --> 00:35:50.951 align:middle
大家可能会奇怪 的确

00:35:51.018 --> 00:35:52.753 align:middle
昨天库柏蒂诺是很热

00:35:54.821 --> 00:35:58.125 align:middle
现在我们完成了
但是这么做

00:35:58.192 --> 00:35:59.927 align:middle
是因为我们很聪明
提前完成了工作

00:36:00.594 --> 00:36:03.497 align:middle
有时 我会试着
调试一些内容

00:36:04.631 --> 00:36:07.167 align:middle
把自己的程序调试到位

00:36:07.367 --> 00:36:09.803 align:middle
结果有这样一个
很难复制的问题

00:36:10.003 --> 00:36:11.505 align:middle
最后发生了

00:36:12.406 --> 00:36:15.008 align:middle
不过现在真的
很难找到这数据

00:36:15.309 --> 00:36:17.211 align:middle
数据非常令人头痛
非常很复杂

00:36:17.277 --> 00:36:20.414 align:middle
真希望自己
之前做过这事儿

00:36:20.480 --> 00:36:23.217 align:middle
这样我就可以更简单地
看待我的数据了

00:36:24.051 --> 00:36:25.352 align:middle
不过 可惜没有

00:36:26.186 --> 00:36:27.588 align:middle
所有的希望都落空

00:36:28.622 --> 00:36:30.424 align:middle
不 没有

00:36:30.691 --> 00:36:33.427 align:middle
还可以添加一致性
和运行时间

00:36:33.493 --> 00:36:36.663 align:middle
通过表达式剖析器
可以添加这些一致性

00:36:36.897 --> 00:36:38.866 align:middle
并运转 同时调试你的app

00:36:39.867 --> 00:36:40.701 align:middle
另一方面

00:36:41.401 --> 00:36:42.870 align:middle
你还不能改变它们

00:36:43.237 --> 00:36:45.239 align:middle
现有的一致性保留

00:36:47.207 --> 00:36:49.476 align:middle
你在REPL做尝试

00:36:50.010 --> 00:36:51.945 align:middle
你真希望自己能做po

00:36:52.179 --> 00:36:54.248 align:middle
我希望自己能
添加一致性

00:36:55.315 --> 00:36:57.017 align:middle
在REPL中也可以这么做

00:36:58.986 --> 00:37:02.089 align:middle
当然 但是我确定
大家都期望这样

00:36:58.986 --> 00:37:02.089 align:middle
当然 但是我确定
大家都期望这样

00:37:02.523 --> 00:37:03.357 align:middle
为什么？

00:37:04.091 --> 00:37:05.759 align:middle
在环境中 也是如此

00:37:07.160 --> 00:37:08.428 align:middle
来看

00:37:11.298 --> 00:37:12.699 align:middle
看似...

00:37:13.967 --> 00:37:15.836 align:middle
我们在过去一年
在调试器方面

00:37:15.903 --> 00:37:17.371 align:middle
所做了许多动作

00:37:17.604 --> 00:37:20.541 align:middle
你们从凯特 西恩和我这里听到的

00:37:20.974 --> 00:37:26.713 align:middle
这些都离不开要在调试的同时
确保能够轻松访问

00:37:26.780 --> 00:37:28.815 align:middle
尽可能多的相关信息

00:37:30.284 --> 00:37:32.219 align:middle
访问Objective-C
运行时间

00:37:32.352 --> 00:37:36.156 align:middle
会让你在域无法获取之前
对之有更多了解

00:37:37.124 --> 00:37:38.659 align:middle
SDK模块

00:37:39.026 --> 00:37:44.698 align:middle
为应用所运行的操作环境

00:37:44.765 --> 00:37:47.201 align:middle
更多类型 更多函数
甚至有宏观

00:37:47.367 --> 00:37:48.669 align:middle
提供了
前所未有的访问程度

00:37:49.203 --> 00:37:51.471 align:middle
还有进程格式

00:37:52.739 --> 00:37:55.175 align:middle
进程格式是用来生成

00:37:55.242 --> 00:37:58.879 align:middle
跨界应用类型的
编译表示的

00:37:59.112 --> 00:38:00.848 align:middle
极好方法

00:37:59.112 --> 00:38:00.848 align:middle
极好方法

00:38:01.181 --> 00:38:03.750 align:middle
它们可以应用在环境中
在REPL中

00:38:03.817 --> 00:38:05.352 align:middle
也可以是在调试器中

00:38:06.620 --> 00:38:08.355 align:middle
若要了解更多详情

00:38:08.755 --> 00:38:09.590 align:middle
可以随时

00:38:09.656 --> 00:38:12.392 align:middle
浏览我们的网站
Swift语言文件

00:38:12.492 --> 00:38:14.928 align:middle
或开发人员论坛
当然还有实验室

00:38:14.995 --> 00:38:17.798 align:middle
还可以给开发顾问
斯特凡发邮件

00:38:19.366 --> 00:38:22.402 align:middle
非常感谢
希望大家喜欢WWDC
