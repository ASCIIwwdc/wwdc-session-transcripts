WEBVTT

00:00:20.053 --> 00:00:23.590 align:middle
在Metal中有什么新内容
第二部分

00:00:23.657 --> 00:00:24.491 align:middle
谢谢

00:00:28.495 --> 00:00:31.832 align:middle
早上好 欢迎来到第二部分的讲座
Metal展示中有什么新内容

00:00:32.031 --> 00:00:33.467 align:middle
我叫丹·大町市

00:00:33.867 --> 00:00:36.603 align:middle
我是苹果GPU软件架构团队的工程师

00:00:37.237 --> 00:00:40.407 align:middle
今天我的同事 安娜·吉洪诺夫
和我将会谈一谈

00:00:40.474 --> 00:00:42.809 align:middle
基于Metal的技术

00:00:43.143 --> 00:00:46.313 align:middle
有助于在
iOS 和OS X上向你提供令人

00:00:46.380 --> 00:00:48.448 align:middle
惊叹的渲染体验

00:00:50.717 --> 00:00:53.520 align:middle
因此这是三个讲座中的第二部分

00:00:53.587 --> 00:00:56.690 align:middle
在本年度讨论Metal的WWDC上

00:00:57.524 --> 00:00:58.492 align:middle
第一个讲座中

00:00:58.892 --> 00:01:03.263 align:middle
罗布·多啦夫 谈论了
去年对Metal的开发

00:00:58.892 --> 00:01:03.263 align:middle
罗布·多啦夫 谈论了
去年对Metal的开发

00:01:04.031 --> 00:01:08.235 align:middle
他还描述了我们刚刚
发布的Metal的新功能

00:01:09.469 --> 00:01:14.308 align:middle
他还描述了它的瘦身功能
如何与Metal应用完美匹配

00:01:16.577 --> 00:01:19.847 align:middle
在本次讲座中 我首先要谈到

00:01:20.180 --> 00:01:26.687 align:middle
Metalkit方便的APIs使你
更快捷地使用Metal应用

00:01:27.487 --> 00:01:32.392 align:middle
然后 安娜 将会
谈论Metal性能着色器架构

00:01:32.926 --> 00:01:36.096 align:middle
在具有A8处理器的iOS设备上

00:01:36.797 --> 00:01:39.333 align:middle
它可为可用的公用数据并行操作

00:01:39.399 --> 00:01:42.669 align:middle
提供很好的着色器

00:01:45.205 --> 00:01:46.640 align:middle
明天你将有机会

00:01:47.040 --> 00:01:50.477 align:middle
来听取Metal性能优化技术讲座

00:01:50.878 --> 00:01:54.181 align:middle
在那里将介绍Metal系统追踪工具

00:01:54.915 --> 00:02:00.087 align:middle
且向你提供一些有效的
Metal应用的最好的范例

00:01:54.915 --> 00:02:00.087 align:middle
且向你提供一些有效的
Metal应用的最好的范例

00:02:03.123 --> 00:02:05.025 align:middle
现在就开始介绍用于Metal应用的

00:02:05.225 --> 00:02:07.528 align:middle
Metalkit实用功能

00:02:09.930 --> 00:02:16.003 align:middle
因为Metal是一个低级的API
你要做许多事情来建立和运行

00:02:17.771 --> 00:02:20.274 align:middle
MetalKit希望使用这个

00:02:20.340 --> 00:02:22.609 align:middle
来为经常使用的场景

00:02:22.843 --> 00:02:24.945 align:middle
提供有效的实现

00:02:26.013 --> 00:02:29.149 align:middle
这样你就可以很容易创建和渲染

00:02:29.917 --> 00:02:31.952 align:middle
并且我们对标准的库存代码

00:02:32.019 --> 00:02:35.689 align:middle
增强了性能和稳定性

00:02:35.856 --> 00:02:37.424 align:middle
你自己就可以实现

00:02:38.158 --> 00:02:40.327 align:middle
你需要很少的维护

00:02:40.794 --> 00:02:43.530 align:middle
因为维护的负担从你转到了我们

00:02:46.033 --> 00:02:49.970 align:middle
这样MetalKit由三部分组成

00:02:50.938 --> 00:02:53.240 align:middle
第一部分是MetalKit视图

00:02:53.841 --> 00:02:57.644 align:middle
一个介于iOS
和OSX之间的统一的视图类

00:02:58.212 --> 00:02:59.580 align:middle
用于渲染你的Metal场景

00:03:01.114 --> 00:03:03.083 align:middle
第二部分是纹理载入器

00:03:03.684 --> 00:03:08.989 align:middle
用于创建磁盘上的图像文件的纹理对象

00:03:09.957 --> 00:03:13.493 align:middle
最后
Metal Kit的模块I/O集成

00:03:13.861 --> 00:03:17.164 align:middle
上载和管理
来自Metal渲染的网格数据

00:03:20.501 --> 00:03:25.572 align:middle
MetalKit视图是获Metal
视频渲染的最简单的方法

00:03:27.407 --> 00:03:31.144 align:middle
它是iOS和OS X的统一类

00:03:32.012 --> 00:03:35.749 align:middle
它在这个两个操作
系统上提供了几乎相同的接口

00:03:36.149 --> 00:03:42.289 align:middle
但是它本身是iOS的UI视图
的子类以及OSX上的NS视图的子类

00:03:44.725 --> 00:03:48.462 align:middle
它的主要工作是
为你管理可显示渲染目标

00:03:49.396 --> 00:03:51.265 align:middle
并且为这些渲染目标

00:03:51.331 --> 00:03:53.534 align:middle
自动产生渲染路径描述符

00:03:55.936 --> 00:03:59.206 align:middle
它的超级灵活之处在于

00:03:59.273 --> 00:04:02.209 align:middle
它可以执行你的绘制代码

00:03:59.273 --> 00:04:02.209 align:middle
它可以执行你的绘制代码

00:04:03.443 --> 00:04:06.079 align:middle
你可以使用一个基于定时器的模式

00:04:06.213 --> 00:04:09.216 align:middle
该模式可以在有规律的间隔内

00:04:09.449 --> 00:04:11.618 align:middle
与显示同步执行你的绘制代码

00:04:12.819 --> 00:04:14.288 align:middle
或者你可以使用基于事件的模式

00:04:14.354 --> 00:04:18.158 align:middle
每当发生触摸或UI事件时
该模式在就将触发你的绘制代码

00:04:18.225 --> 00:04:20.093 align:middle
这样你就可以对那个事件做出响应

00:04:21.060 --> 00:04:22.162 align:middle
最后也许你可以在

00:04:22.229 --> 00:04:27.067 align:middle
你的帧频率下第二线程上的开放环路下

00:04:27.701 --> 00:04:29.102 align:middle
驱动你的绘制代码

00:04:32.072 --> 00:04:35.676 align:middle
因此有两种
方法使用MetalKit视图

00:04:37.144 --> 00:04:39.580 align:middle
最简单的方法是执行一个代表

00:04:39.713 --> 00:04:42.549 align:middle
来处理你的绘制及重新调整运行的大小

00:04:43.350 --> 00:04:46.687 align:middle
在这个实例中
你可以执行在视图中绘制方法

00:04:47.221 --> 00:04:50.390 align:middle
来处理你的包括对任何渲染命令编码

00:04:50.724 --> 00:04:52.459 align:middle
的每帧的更新

00:04:53.861 --> 00:04:57.464 align:middle
你还可以执行按尺寸布局视图的方法

00:04:58.599 --> 00:05:00.834 align:middle
来处理你的视图的尺寸的改变

00:04:58.599 --> 00:05:00.834 align:middle
来处理你的视图的尺寸的改变

00:05:01.502 --> 00:05:04.705 align:middle
在这里你可以更新投影矩阵

00:05:05.005 --> 00:05:06.940 align:middle
或者改变纹理的大小

00:05:07.007 --> 00:05:09.376 align:middle
以更好地匹配你的显示区域

00:05:10.844 --> 00:05:15.315 align:middle
如果你有其它的需要改写的视图

00:05:16.183 --> 00:05:18.552 align:middle
可将MetalKit视图设为子类

00:05:19.620 --> 00:05:21.321 align:middle
在iOS的这个实例中

00:05:21.655 --> 00:05:23.757 align:middle
你将要改写绘制矩形方法

00:05:25.125 --> 00:05:26.460 align:middle
来处理你的每帧更新

00:05:27.327 --> 00:05:30.330 align:middle
以及布局视图方法来处理大小调整

00:05:31.164 --> 00:05:33.834 align:middle
同样的在OSX上你要处理

00:05:34.101 --> 00:05:36.637 align:middle
你要改写这两种方法绘制矩形

00:05:36.703 --> 00:05:38.805 align:middle
和设置桢大小方法

00:05:44.845 --> 00:05:49.750 align:middle
在这里有个设置视图控制器的例子

00:05:49.950 --> 00:05:53.153 align:middle
也可以作为我们视图的代表

00:05:54.454 --> 00:05:59.660 align:middle
在视图无法加载方法中
我们在接收到针对视图的一个引用后

00:06:00.561 --> 00:06:02.963 align:middle
我们将我们自己指定为代表

00:06:06.900 --> 00:06:11.438 align:middle
在OS上特别重要的是我们需要选择

00:06:11.505 --> 00:06:13.373 align:middle
和设置一个Metal设备

00:06:15.375 --> 00:06:18.078 align:middle
一旦我们完成了 我们就可以配置

00:06:18.145 --> 00:06:19.980 align:middle
一些视图的功能包括

00:06:20.314 --> 00:06:23.517 align:middle
针对色彩、深度和模板缓冲

00:06:23.584 --> 00:06:24.852 align:middle
的自定义像素格式

00:06:27.054 --> 00:06:28.655 align:middle
我们还可以通过将

00:06:28.722 --> 00:06:32.526 align:middle
采样计数功能增加
到数值1以上来使用多重采样

00:06:34.695 --> 00:06:37.231 align:middle
或者我们还可以
设置我们的自定义清除色彩

00:06:41.201 --> 00:06:45.639 align:middle
这里有个实现每帧更新的

00:06:45.806 --> 00:06:48.575 align:middle
MetalKit视图
的最基本的使用方法

00:06:49.510 --> 00:06:53.447 align:middle
在我们的绘制视图方法中
我们叫做视图渲染

00:06:53.714 --> 00:06:55.916 align:middle
是render
past descriptor

00:06:55.983 --> 00:06:59.653 align:middle
你首次访问每个画面的这个功能

00:07:00.087 --> 00:07:02.523 align:middle
该视图就会调用核心动画

00:07:02.823 --> 00:07:04.658 align:middle
并且获得一个可绘制返回

00:07:05.259 --> 00:07:08.395 align:middle
在这里你可以
对渲染命令编码来进行渲染

00:07:10.497 --> 00:07:12.966 align:middle
这样我们就渲染了
我们最终的render pass

00:07:13.467 --> 00:07:15.202 align:middle
就会在这个可绘制中展现出来

00:07:16.670 --> 00:07:18.939 align:middle
然后我们就将展现这个可绘制

00:07:19.006 --> 00:07:20.741 align:middle
它保存在视图的当前的可绘制功能中

00:07:21.808 --> 00:07:23.343 align:middle
并且我们将提交我们的指令缓冲器

00:07:25.045 --> 00:07:26.914 align:middle
因为构建你的每帧更新很重要

00:07:27.281 --> 00:07:30.384 align:middle
让我花一分钟

00:07:30.651 --> 00:07:33.053 align:middle
来说说管理这些可绘制

00:07:34.588 --> 00:07:36.890 align:middle
这样这个系统中有有限的可绘制

00:07:37.424 --> 00:07:40.027 align:middle
都由核心动画来管理

00:07:41.562 --> 00:07:44.164 align:middle
由于它们通常只有几个 因为

00:07:44.231 --> 00:07:45.566 align:middle
它们的大小占用了一些空间

00:07:46.567 --> 00:07:49.269 align:middle
这些可绘制通过许多级别的

00:07:49.603 --> 00:07:52.472 align:middle
显示管道层被同时使用

00:07:53.907 --> 00:07:55.209 align:middle
这里大致说下它是如何工作的

00:07:55.642 --> 00:07:57.644 align:middle
首先
你的应用程序对要在可绘制上渲染的

00:07:57.711 --> 00:07:58.912 align:middle
指令进行编码

00:08:00.013 --> 00:08:02.216 align:middle
当你的应用程序对下个帧进行编码时

00:08:02.583 --> 00:08:05.652 align:middle
它将那个可绘制向下发送到GPU

00:08:05.886 --> 00:08:09.690 align:middle
GPU对那个画面进行渲染 核心动画

00:08:09.756 --> 00:08:11.592 align:middle
在这个阶段可以和其他层一起

00:08:11.658 --> 00:08:15.028 align:middle
对那个可绘制进行合成

00:08:17.364 --> 00:08:19.666 align:middle
最后显示器获取了可绘制

00:08:19.733 --> 00:08:21.001 align:middle
把它放在屏幕上

00:08:21.969 --> 00:08:24.004 align:middle
显示器不能用任何东西来替代它

00:08:24.071 --> 00:08:25.806 align:middle
直到可获得另一个可绘制

00:08:26.106 --> 00:08:29.109 align:middle
如果前面的任何阶段花费了很长时间

00:08:29.409 --> 00:08:31.178 align:middle
它只能等一会儿

00:08:31.612 --> 00:08:36.817 align:middle
显示器不能将那个可绘制反向循环

00:08:36.884 --> 00:08:38.952 align:middle
直到你的帧上有它有可用的东西

00:08:42.322 --> 00:08:47.528 align:middle
让我们来看看
你的带有这些可绘制的应用框架

00:08:49.296 --> 00:08:51.732 align:middle
首先你调用保留有一个 可绘制的

00:08:51.798 --> 00:08:54.268 align:middle
MetalKit视图当前渲染描述符

00:08:57.070 --> 00:09:00.107 align:middle
然后用你想要的渲染
指令对那个可绘制进行编码

00:08:57.070 --> 00:09:00.107 align:middle
然后用你想要的渲染
指令对那个可绘制进行编码

00:09:00.774 --> 00:09:06.413 align:middle
最后你呈现和提交
那个会将它发回到核心动画中的可绘制

00:09:07.981 --> 00:09:11.985 align:middle
一切都好如果我们只是渲染一个
单独的render pass

00:09:12.753 --> 00:09:16.256 align:middle
但是很有可能我们将做其他的操作

00:09:18.058 --> 00:09:20.994 align:middle
如一些应用逻辑对

00:09:22.196 --> 00:09:26.300 align:middle
无须可绘制 用offscreen
render pass进行编码

00:09:27.734 --> 00:09:31.171 align:middle
或运行一些
物理计算核心程序或其他程序

00:09:33.640 --> 00:09:37.411 align:middle
在这种情况下
我们本质上是在占用我们未来可绘制

00:09:37.811 --> 00:09:39.346 align:middle
因为在后续帧中

00:09:39.613 --> 00:09:41.815 align:middle
我们会调用这个当前的渲染描述符

00:09:42.249 --> 00:09:43.750 align:middle
它会呆在那儿

00:09:43.851 --> 00:09:47.454 align:middle
等待成为可用的 可能等不到

00:09:47.521 --> 00:09:50.858 align:middle
因为我们正在做其它的操作并且将它

00:09:50.924 --> 00:09:52.526 align:middle
保留了比我们所需的更长的时间

00:09:52.593 --> 00:09:54.228 align:middle
因此要解决这个问题

00:09:54.862 --> 00:09:59.867 align:middle
让我们在访问当前渲染描述符之前
进行这些操作

00:10:00.434 --> 00:10:04.304 align:middle
我们注意到这不是

00:10:04.404 --> 00:10:05.839 align:middle
MetalKit特有的问题

00:10:05.906 --> 00:10:11.078 align:middle
如果你在直接访问核心动画的时候
滚动视图 你会注意到这个问题

00:10:12.179 --> 00:10:17.651 align:middle
因此在任何情况下这种信息都很有用

00:10:18.519 --> 00:10:23.190 align:middle
这里有个每帧渲染更新的更完整的例子

00:10:23.824 --> 00:10:27.327 align:middle
首先 如所述我们想要
更新我们的应用程序的渲染状态

00:10:28.061 --> 00:10:30.097 align:middle
对任何的offscreen
passes进行编码

00:10:30.163 --> 00:10:31.999 align:middle
做任何我们不需要 可绘制的东西

00:10:34.101 --> 00:10:36.203 align:middle
然后我们就能够继续像以前那样

00:10:36.670 --> 00:10:39.206 align:middle
获取当前渲染通道描述符

00:10:39.273 --> 00:10:42.276 align:middle
为最终的pass的指令进行编码
然后呈现和提交我们的指令缓冲器

00:10:43.010 --> 00:10:45.646 align:middle
关键点是这两个阶段

00:10:45.846 --> 00:10:48.248 align:middle
越靠近越好

00:10:49.016 --> 00:10:52.152 align:middle
它是我们保持资源的临界区段

00:10:52.719 --> 00:10:55.055 align:middle
我们不想将它保留时间过长

00:10:57.624 --> 00:10:58.825 align:middle
关于视图的就说这么多

00:11:00.227 --> 00:11:01.895 align:middle
让我们开始讨论纹理载入器

00:11:04.131 --> 00:11:06.033 align:middle
纹理载入很简单

00:11:07.100 --> 00:11:11.338 align:middle
你给一个引用
然后你就得到一个成形

00:11:11.672 --> 00:11:12.840 align:middle
的Metal纹理

00:11:14.141 --> 00:11:18.579 align:middle
它不只是简单而且功能齐全

00:11:19.646 --> 00:11:22.216 align:middle
它异步解码文件

00:11:22.983 --> 00:11:26.486 align:middle
并且在分别的线程上创建纹理

00:11:27.921 --> 00:11:31.325 align:middle
它支持许多通用图像文件格式包括

00:11:31.391 --> 00:11:36.230 align:middle
JPG、TIF和PNG还支持PVR

00:11:36.330 --> 00:11:38.632 align:middle
和KTX纹理文件格式

00:11:38.999 --> 00:11:41.068 align:middle
这些格式的有趣之处

00:11:41.568 --> 00:11:43.203 align:middle
是它们以原始形式保存数据

00:11:43.270 --> 00:11:47.107 align:middle
并且可以上传到你的Metal纹理中

00:11:47.174 --> 00:11:48.609 align:middle
不需要任何的改变

00:11:49.543 --> 00:11:53.580 align:middle
另你可以将MIT maps数据编码

00:11:54.314 --> 00:11:57.484 align:middle
成其他类型的纹理

00:11:57.551 --> 00:12:01.355 align:middle
包括3D纹理、立体地图
和纹理数组

00:11:57.551 --> 00:12:01.355 align:middle
包括3D纹理、立体地图
和纹理数组

00:12:06.026 --> 00:12:07.194 align:middle
它的用法很简单

00:12:08.729 --> 00:12:10.964 align:middle
首先我们通过提供一个设备

00:12:11.431 --> 00:12:13.400 align:middle
来创建了一个纹理上载器对象

00:12:15.202 --> 00:12:20.374 align:middle
然后一旦我们有了那个纹理上载器对象
我们就能用它创建许多的纹理

00:12:21.175 --> 00:12:25.646 align:middle
首先提供一个图像文件的URL地址

00:12:26.747 --> 00:12:28.849 align:middle
然后就可提供许多的选项

00:12:28.916 --> 00:12:33.020 align:middle
包括 如何处理文件中的sRGB信息

00:12:33.220 --> 00:12:36.290 align:middle
或者是我们是否想
在创建这个纹理的时候

00:12:36.523 --> 00:12:37.991 align:middle
为MIT maps分配内存

00:12:39.693 --> 00:12:42.496 align:middle
最后我们要提供一个完成处理块

00:12:42.930 --> 00:12:44.631 align:middle
只要纹理载入器已经完成了

00:12:45.098 --> 00:12:48.969 align:middle
上载纹理并且创建了它
就会执行块

00:12:49.169 --> 00:12:52.639 align:middle
它会将纹理处理器发回给你
你可以将它保存在以后

00:12:53.140 --> 00:12:55.676 align:middle
需要时用来渲染

00:12:57.344 --> 00:12:59.379 align:middle
纹理载入器非常简单

00:12:59.513 --> 00:13:01.949 align:middle
让我们继续进行Model I/O

00:12:59.513 --> 00:13:01.949 align:middle
让我们继续进行Model I/O

00:13:04.952 --> 00:13:07.154 align:middle
模型I/0是一个新的结构是与

00:13:07.221 --> 00:13:09.790 align:middle
iOS 9和OS X
El Capitan一块引入的

00:13:11.225 --> 00:13:12.960 align:middle
它的一个关键特点是

00:13:13.060 --> 00:13:17.698 align:middle
它可以为你上载许多的模型文件格式

00:13:18.999 --> 00:13:21.768 align:middle
如果你需要可以为你专门格式创建

00:13:21.969 --> 00:13:25.005 align:middle
你自己的导入器和导出器

00:13:27.007 --> 00:13:28.242 align:middle
这里非常酷的特点是

00:13:28.642 --> 00:13:33.013 align:middle
做offline baking操作

00:13:33.814 --> 00:13:38.018 align:middle
可创建静态环境光遮蔽地图生成光照图

00:13:39.052 --> 00:13:42.055 align:middle
它还包括你的网格的立体像素化

00:13:43.457 --> 00:13:48.462 align:middle
它提供了一种集中于你的渲染代码

00:13:48.529 --> 00:13:49.630 align:middle
和写入你的着色器的方法

00:13:49.696 --> 00:13:52.266 align:middle
你不需要创建一些parchers

00:13:52.332 --> 00:13:53.700 align:middle
来将一些东西从磁盘中取出

00:13:53.767 --> 00:13:57.104 align:middle
你必须少和串行打交道

00:13:57.771 --> 00:14:00.607 align:middle
你只需要上载一个
带有Model I/O的模型文件

00:13:57.771 --> 00:14:00.607 align:middle
你只需要上载一个
带有Model I/O的模型文件

00:14:01.642 --> 00:14:03.577 align:middle
把它放入你可用它做渲染的一些构成中

00:14:04.244 --> 00:14:06.813 align:middle
开始写入你的着色器

00:14:09.650 --> 00:14:12.152 align:middle
MetalKit
在这种情况下提供了什么

00:14:12.219 --> 00:14:15.455 align:middle
它的程序有效使用
Metal的Model I/O

00:14:16.790 --> 00:14:20.561 align:middle
它提供了将Model I/O
网格优化上载到Metal缓冲器中

00:14:21.695 --> 00:14:25.933 align:middle
MetalKit
对象内部的网格数据封装

00:14:27.000 --> 00:14:29.803 align:middle
有许多函数用于为网格数据

00:14:30.537 --> 00:14:31.672 align:middle
的Metal管道做准备

00:14:34.741 --> 00:14:38.145 align:middle
让我来指导

00:14:38.245 --> 00:14:42.482 align:middle
如何用Model I/O
来上载一个模型文件的步骤

00:14:43.517 --> 00:14:46.019 align:middle
并且用Metal来将它渲染到屏幕上

00:14:48.388 --> 00:14:49.690 align:middle
这里就是我们要采取的步骤

00:14:53.861 --> 00:14:58.932 align:middle
首先创建一个Metal渲染状态管道

00:14:58.999 --> 00:15:01.869 align:middle
我们将用来创建我们的网格
来渲染我们的网格

00:14:58.999 --> 00:15:01.869 align:middle
我们将用来创建我们的网格
来渲染我们的网格

00:15:03.604 --> 00:15:06.240 align:middle
然后通过初始化
Model I/O asset

00:15:06.340 --> 00:15:08.942 align:middle
用asset来上载模型文件

00:15:10.777 --> 00:15:14.448 align:middle
我们就可以创建MetalKit网格

00:15:14.515 --> 00:15:16.083 align:middle
以及子网格对象

00:15:17.484 --> 00:15:19.853 align:middle
最后用Metal来渲染那些对象

00:15:22.623 --> 00:15:26.159 align:middle
因此集中于创建
一个Metal渲染状态管道

00:15:27.327 --> 00:15:29.429 align:middle
我们要特别注意

00:15:29.763 --> 00:15:31.498 align:middle
创建一个顶点描述器

00:15:31.965 --> 00:15:37.971 align:middle
该描述器将会对需要的网格
提供给管道的顶点的布局进行描述

00:15:39.473 --> 00:15:43.210 align:middle
这里是顶点着色器的基本内容

00:15:45.379 --> 00:15:48.248 align:middle
它使用限制符级基本上

00:15:48.315 --> 00:15:51.785 align:middle
说明了我们每个顶点的输入它们的布局

00:15:52.319 --> 00:15:55.656 align:middle
用我们的objective-C代码
使用顶点描述符

00:15:56.757 --> 00:15:58.158 align:middle
对着色器以外进行描述

00:15:59.626 --> 00:16:02.396 align:middle
它使用了这里所定义的

00:15:59.626 --> 00:16:02.396 align:middle
它使用了这里所定义的

00:16:03.564 --> 00:16:04.865 align:middle
顶点输入架构

00:16:06.099 --> 00:16:09.403 align:middle
这个顶点输入架构的主要部分是

00:16:09.503 --> 00:16:12.973 align:middle
这些功能
我们要使用这些指数来连接

00:16:13.040 --> 00:16:16.310 align:middle
Objective-C
编码的外部和内部

00:16:17.144 --> 00:16:23.684 align:middle
注意这些浮点矢量
类型定义了数据在着色器中的样子

00:16:24.351 --> 00:16:27.387 align:middle
不是实际上数据从我们的

00:16:27.454 --> 00:16:29.356 align:middle
Objective-C编码送入

00:16:29.423 --> 00:16:30.691 align:middle
着色器的样子

00:16:38.899 --> 00:16:41.235 align:middle
对此需要创建一个顶点描述符

00:16:43.070 --> 00:16:46.240 align:middle
我将把这个顶点输入结构

00:16:46.306 --> 00:16:49.743 align:middle
放在这作为参考但是我要提醒你

00:16:49.810 --> 00:16:53.380 align:middle
它定义的不是被送入到着色器时

00:16:53.447 --> 00:16:54.715 align:middle
的数据的布局

00:16:55.115 --> 00:17:01.188 align:middle
我们实际上创建的是下面
的Metal顶点描述符

00:16:55.115 --> 00:17:01.188 align:middle
我们实际上创建的是下面
的Metal顶点描述符

00:17:01.822 --> 00:17:06.260 align:middle
我们要做的是针对属性0

00:17:08.729 --> 00:17:15.068 align:middle
用三个浮点 三个浮点值

00:17:16.002 --> 00:17:17.271 align:middle
来定义这个位置

00:17:17.738 --> 00:17:23.210 align:middle
对于属性1 色彩将由

00:17:23.277 --> 00:17:26.747 align:middle
四个无符号的字符组成

00:17:26.980 --> 00:17:29.650 align:middle
不是上面的四个浮点 四个无符号字符

00:17:29.917 --> 00:17:31.385 align:middle
它紧接在位置数据之后

00:17:32.519 --> 00:17:36.823 align:middle
有12个比特的相位差

00:17:41.094 --> 00:17:44.531 align:middle
对于属性2的纹理坐标

00:17:45.399 --> 00:17:49.036 align:middle
我们将定义它用了两个半浮点

00:17:50.637 --> 00:17:55.742 align:middle
它紧跟在位置和颜色数据之后

00:17:55.843 --> 00:17:57.544 align:middle
有16比特的相位差

00:17:59.913 --> 00:18:04.384 align:middle
通过将
缓存器的stride设置设为20

00:17:59.913 --> 00:18:04.384 align:middle
通过将
缓存器的stride设置设为20

00:18:04.651 --> 00:18:05.819 align:middle
将每个顶点的大小

00:18:05.886 --> 00:18:07.654 align:middle
规定为20比特

00:18:12.059 --> 00:18:15.729 align:middle
这样就定义了我们的顶点阵列

00:18:15.796 --> 00:18:17.698 align:middle
内的每个顶点的布局

00:18:21.368 --> 00:18:23.570 align:middle
这样我们就得到了
我们的Metal顶点描述符

00:18:23.971 --> 00:18:26.106 align:middle
我们能够将
它分配到我们的渲染状态管道

00:18:27.641 --> 00:18:31.011 align:middle
并且用渲染
对不起 用渲染管道描述符

00:18:31.311 --> 00:18:34.248 align:middle
我们就能够
创建一个Metal渲染状态管道

00:18:36.617 --> 00:18:39.586 align:middle
现在我们开始上载我们的asset

00:18:41.388 --> 00:18:44.591 align:middle
用Model I/O来完成那个任务

00:18:46.326 --> 00:18:49.029 align:middle
我们实际上使用我们在

00:18:49.096 --> 00:18:50.364 align:middle
前一步创建的顶点描述符

00:18:51.331 --> 00:18:55.068 align:middle
一个MetalKit网格缓冲器对象

00:18:55.502 --> 00:18:58.005 align:middle
一个网格缓冲器分配器对象

00:18:59.339 --> 00:19:00.874 align:middle
在我们继续向下讲时

00:18:59.339 --> 00:19:00.874 align:middle
在我们继续向下讲时

00:19:01.441 --> 00:19:03.877 align:middle
我多说几句强调一下它的重要性

00:19:06.547 --> 00:19:11.418 align:middle
Model I/O顶点描述器

00:19:11.685 --> 00:19:14.521 align:middle
以及Metal顶点描述器非常类似

00:19:15.689 --> 00:19:18.659 align:middle
但是尽管
Model I/O顶点描述器描述了

00:19:18.725 --> 00:19:20.794 align:middle
网格内的顶点属性的布局

00:19:22.663 --> 00:19:24.998 align:middle
但是Metal顶点描述器描述了

00:19:25.065 --> 00:19:27.167 align:middle
作为渲染状态管道的输入

00:19:27.668 --> 00:19:29.169 align:middle
的顶点属性的布局

00:19:30.537 --> 00:19:33.707 align:middle
它们专门设计成看起来相似

00:19:34.441 --> 00:19:38.512 align:middle
因为它们包含属性和缓冲器布局对象

00:19:39.379 --> 00:19:44.952 align:middle
原因是这样就简化了
将一个对象翻译成另一个的过程

00:19:47.354 --> 00:19:51.758 align:middle
在Model I/O顶点
描述器中的每个属性

00:19:52.025 --> 00:19:53.861 align:middle
都有一个可识别的字符串库名称

00:19:54.828 --> 00:19:59.433 align:middle
Model I/O分配了一个
缺省的名称 如果模型内不存在

00:19:59.499 --> 00:20:03.237 align:middle
或者是那个模型文件不支持这些名称

00:19:59.499 --> 00:20:03.237 align:middle
或者是那个模型文件不支持这些名称

00:20:03.770 --> 00:20:08.041 align:middle
这些名称包括位置、
法向量、纹理、坐标颜色等

00:20:09.376 --> 00:20:11.512 align:middle
Model I/O用
基于MDLVertex

00:20:11.578 --> 00:20:14.748 align:middle
属性常数的字符串来定义这些

00:20:15.849 --> 00:20:19.887 align:middle
有许多文件
包括你可以自定义那些名称的

00:20:19.953 --> 00:20:23.123 align:middle
Alembic文件格式

00:20:23.857 --> 00:20:26.960 align:middle
注意 如果你要改变名称

00:20:27.027 --> 00:20:31.798 align:middle
你需要用那些
自定义名称来访问这些属性

00:20:33.734 --> 00:20:39.072 align:middle
所以我们建议你创建一个
自定义Model I/O顶点描述器

00:20:39.139 --> 00:20:42.376 align:middle
因为在缺省下
Model I/O上载的顶点

00:20:42.576 --> 00:20:43.810 align:middle
为高精度

00:20:44.077 --> 00:20:47.181 align:middle
而且占用大量内存的浮点类型

00:20:48.182 --> 00:20:52.452 align:middle
这是使用
Model I/O的优势之一

00:20:52.920 --> 00:20:58.926 align:middle
你实际上可以上载一个模型格式

00:20:58.992 --> 00:21:03.463 align:middle
具有你所喜爱的任何形式的顶点数据

00:20:58.992 --> 00:21:03.463 align:middle
具有你所喜爱的任何形式的顶点数据

00:21:03.530 --> 00:21:06.600 align:middle
将那个数据变成你能够实际使用的格式

00:21:07.301 --> 00:21:09.770 align:middle
在这种情况下我们想用最小的类型

00:21:10.137 --> 00:21:11.205 align:middle
提供给管道

00:21:11.605 --> 00:21:13.941 align:middle
以满足你们的精确性要求

00:21:14.174 --> 00:21:17.678 align:middle
这将提高你们的顶点带宽效率

00:21:18.045 --> 00:21:20.714 align:middle
当你们在将每个顶点提供给管道的时候

00:21:21.081 --> 00:21:23.083 align:middle
你实际上不想要一个膨胀的顶点

00:21:25.886 --> 00:21:28.689 align:middle
这里就是我们前面定义的

00:21:28.755 --> 00:21:30.891 align:middle
当创建我们的
Metal顶点描述符时的布局

00:21:33.560 --> 00:21:37.197 align:middle
现在我们通过从Metal中调用
MTKModel I/O顶点格式

00:21:37.598 --> 00:21:42.569 align:middle
来创建我们的
Model I/O顶点描述符

00:21:43.303 --> 00:21:45.439 align:middle
我们所提供
我们的Metal顶点描述符

00:21:45.706 --> 00:21:51.545 align:middle
就构建了这个Model I/O
顶点描述符的大部分

00:21:52.379 --> 00:21:55.716 align:middle
然而我们还需要
为每个属性标个名字

00:21:55.782 --> 00:21:59.152 align:middle
这样Model I/O
就知道我们谈论的是什么

00:22:00.053 --> 00:22:03.590 align:middle
因此对于属性0我们用顶点

00:22:03.657 --> 00:22:06.226 align:middle
属性位置名称来标记

00:22:07.461 --> 00:22:10.764 align:middle
类似地如属性1和2 我们用

00:22:10.831 --> 00:22:13.700 align:middle
颜色和纹理坐标属性来做标记

00:22:17.371 --> 00:22:20.107 align:middle
这里我们要做的另外的事是我们要创建

00:22:20.340 --> 00:22:24.478 align:middle
一个MetalKit
并且我们会提供一个Metal设备

00:22:25.012 --> 00:22:29.383 align:middle
这个对象所做的
就是允许Model I/O来

00:22:29.917 --> 00:22:35.122 align:middle
直接将顶点
数据上载到GPU备份内存中

00:22:35.923 --> 00:22:39.059 align:middle
你不一定要使用一个
MetalKit网格缓冲器分配器

00:22:39.860 --> 00:22:44.198 align:middle
但是它所做的是为网格内的

00:22:44.665 --> 00:22:49.870 align:middle
这些顶点和指标缓冲器分配系统内存

00:22:50.137 --> 00:22:53.574 align:middle
当你想真的要渲染它
我们需要从系统内存拷贝到

00:22:53.640 --> 00:22:56.743 align:middle
GPU备份内存中

00:22:56.810 --> 00:23:01.615 align:middle
因此为了更有效最好使用这些网格

00:22:56.810 --> 00:23:01.615 align:middle
因此为了更有效最好使用这些网格

00:23:01.715 --> 00:23:05.018 align:middle
缓存分配器中的一个
这里我们要说下如何使用它

00:23:06.119 --> 00:23:08.422 align:middle
我们要上载我们的asset文件

00:23:10.090 --> 00:23:13.126 align:middle
我们将提供URL地址

00:23:15.295 --> 00:23:17.231 align:middle
将会告诉Model I/O如何对

00:23:17.297 --> 00:23:20.000 align:middle
每个顶点进行布局的
Model I/O顶点描述符

00:23:21.368 --> 00:23:24.404 align:middle
我们还将提供该网格缓存分配器

00:23:25.005 --> 00:23:27.941 align:middle
这样Model I/O
就能直接上载数据到

00:23:28.008 --> 00:23:29.142 align:middle
GPU备份内存中

00:23:31.712 --> 00:23:33.680 align:middle
现在我们获得的我们的asset

00:23:35.549 --> 00:23:37.918 align:middle
让我们真正地
来创建一些MetalKit网格

00:23:37.985 --> 00:23:39.419 align:middle
以及一些网格对象

00:23:41.421 --> 00:23:43.557 align:middle
这里是通过Model I/O

00:23:43.624 --> 00:23:46.293 align:middle
来创建asset的一个例子

00:23:47.861 --> 00:23:51.598 align:middle
在asset的内部
我们可能会有相机对象

00:23:53.200 --> 00:23:54.368 align:middle
光照对象...

00:23:55.435 --> 00:24:00.040 align:middle
以及对我们
目前非常重要的网格对象

00:23:55.435 --> 00:24:00.040 align:middle
以及对我们
目前非常重要的网格对象

00:24:00.307 --> 00:24:04.044 align:middle
MetalKit首先与
这些网格对象相关

00:24:04.111 --> 00:24:08.215 align:middle
它并不直接与光线
和相机对象打交道

00:24:08.282 --> 00:24:14.021 align:middle
因为那种数据取决于
你的自定义的着色器和你的引擎

00:24:14.655 --> 00:24:19.459 align:middle
你可以真的探究这个对象
或者向内查看这个对象

00:24:19.526 --> 00:24:23.797 align:middle
取出相机和光亮信息
插入到你的着色器中

00:24:24.064 --> 00:24:27.100 align:middle
但是MetalKit并不
直接参与到那个过程中

00:24:28.068 --> 00:24:34.708 align:middle
因此我们所能做的就是
直接将这个asset

00:24:37.611 --> 00:24:42.382 align:middle
传到这个网格中
网格来自asset类函数

00:24:42.716 --> 00:24:46.253 align:middle
将会创建MetalKit网格的阵列

00:24:51.024 --> 00:24:53.994 align:middle
让我们看看这个网格对象内部都有什么

00:24:55.229 --> 00:24:57.397 align:middle
首先是这些顶点缓存器

00:24:57.464 --> 00:25:00.100 align:middle
包括位置属性

00:24:57.464 --> 00:25:00.100 align:middle
包括位置属性

00:25:00.367 --> 00:25:04.004 align:middle
法向量属性 纹理属性等等

00:25:04.404 --> 00:25:07.508 align:middle
在我们的例子中 我们只需要一个阵列

00:25:07.708 --> 00:25:09.376 align:middle
因为我们对所有我们的数据进行交错

00:25:09.943 --> 00:25:13.614 align:middle
然而我们用多重阵列来定义布局

00:25:13.680 --> 00:25:16.283 align:middle
因此你就会有多重顶点缓存器

00:25:16.783 --> 00:25:21.321 align:middle
你可以定义那个属性0可以在

00:25:21.421 --> 00:25:23.957 align:middle
一个单独阵列的内部
这样你就会在一个阵列

00:25:24.491 --> 00:25:28.161 align:middle
中有一阵列的位置
在下一个中有一阵列的纹理坐标

00:25:28.629 --> 00:25:31.398 align:middle
下一个是色彩阵列等等

00:25:35.569 --> 00:25:37.638 align:middle
该网格还包括一个定义了这个

00:25:37.704 --> 00:25:39.339 align:middle
布局的顶点描述符

00:25:39.439 --> 00:25:41.842 align:middle
与我们初始化我们的asset时

00:25:41.909 --> 00:25:44.478 align:middle
刚刚创建的和送入的是相同的对象

00:25:46.413 --> 00:25:49.716 align:middle
网格包含有许多的子网格对象

00:25:50.083 --> 00:25:54.021 align:middle
每个子网格对象的
主要部分是这个变址缓存器

00:25:54.621 --> 00:25:58.425 align:middle
它引用顶点缓存器内部的顶点

00:26:00.027 --> 00:26:03.063 align:middle
另外你能够使用许多属性

00:26:03.564 --> 00:26:05.599 align:middle
来用Metal调用一个绘制

00:26:08.702 --> 00:26:14.041 align:middle
获得了Metal kit网格
和子网格对象

00:26:16.844 --> 00:26:18.512 align:middle
让我们继续来渲染它们

00:26:21.582 --> 00:26:26.053 align:middle
首先我们要循环访问每个顶点缓冲器

00:26:27.421 --> 00:26:29.723 align:middle
可能有稀疏阵列 因此需要确定

00:26:29.790 --> 00:26:32.326 align:middle
每个缓存器里真的有东西

00:26:33.460 --> 00:26:35.896 align:middle
但是一旦我们确定了
我们就可以继续

00:26:35.963 --> 00:26:39.700 align:middle
并且在我们的渲染
编码器中设置顶点缓存器

00:26:40.701 --> 00:26:43.337 align:middle
顶点缓存器实际上有两个属性

00:26:43.570 --> 00:26:47.140 align:middle
缓存器本身
以及缓存器内部的相位差

00:26:47.608 --> 00:26:50.244 align:middle
它是你的顶点数据驻留的地方

00:26:52.079 --> 00:26:57.050 align:middle
我们还需要提供一个缓冲索引
告诉管道

00:26:57.551 --> 00:26:59.319 align:middle
数据的精确位置

00:27:01.788 --> 00:27:03.824 align:middle
就可以真正地渲染我们的网格了

00:27:04.892 --> 00:27:06.460 align:middle
我们将循环访问每个子网格

00:27:07.895 --> 00:27:10.163 align:middle
并且调用我们的绘制指数基元

00:27:11.131 --> 00:27:13.166 align:middle
注意这个子网格具有

00:27:13.700 --> 00:27:18.505 align:middle
这个绘制指数参数的所有参数

00:27:21.041 --> 00:27:25.412 align:middle
今天将这个MetalKit基本样本

00:27:25.746 --> 00:27:28.682 align:middle
发布到WWDC 2015网站上

00:27:29.383 --> 00:27:31.285 align:middle
我希望你们将它下载下来

00:27:31.351 --> 00:27:34.121 align:middle
它描述了许多我介绍的技术

00:27:34.521 --> 00:27:38.926 align:middle
它使用Model I/O来上载
这个塞入一个OBJ文件中的

00:27:38.992 --> 00:27:44.665 align:middle
小型飞机对象
并且创建一了个MetalKit网格

00:27:45.132 --> 00:27:47.234 align:middle
并且将它在屏幕上进行渲染

00:27:47.534 --> 00:27:51.171 align:middle
这样你就能明白究竟如何去做

00:27:51.672 --> 00:27:53.640 align:middle
我鼓励你们多看看

00:27:56.210 --> 00:27:58.545 align:middle
我的就这么多
我叫丹·大町市

00:27:58.612 --> 00:28:02.015 align:middle
如果对我今天讨论的题目有什么问题

00:27:58.612 --> 00:28:02.015 align:middle
如果对我今天讨论的题目有什么问题

00:28:02.082 --> 00:28:03.684 align:middle
我明天就在Metal实验室

00:28:03.951 --> 00:28:07.287 align:middle
我想要欢迎我的同事
安娜·吉洪诺夫

00:28:07.354 --> 00:28:13.126 align:middle
上台来谈Metal性能着色器架构
谢谢

00:28:18.832 --> 00:28:19.666 align:middle
早晨好

00:28:20.267 --> 00:28:22.669 align:middle
谢谢你 丹
谢谢你的介绍 我叫 安娜

00:28:23.203 --> 00:28:26.206 align:middle
我将和你们谈谈Metal性能着色器

00:28:26.273 --> 00:28:27.274 align:middle
让我们开始

00:28:27.941 --> 00:28:29.910 align:middle
首先Metal性能着色器是什么

00:28:30.410 --> 00:28:34.214 align:middle
它是Metal内 的用于GPU的

00:28:34.281 --> 00:28:35.916 align:middle
优化性能数据并行算法

00:28:37.050 --> 00:28:38.719 align:middle
你什么时候和为什么要使用它？

00:28:39.553 --> 00:28:41.388 align:middle
如果你在写C代码并且你要

00:28:41.455 --> 00:28:42.923 align:middle
填加一个C代码排序算法

00:28:42.990 --> 00:28:44.691 align:middle
到你的CPU应用中

00:28:44.958 --> 00:28:49.329 align:middle
你肯定不会抓来一个就用
除非出于你自身的利益

00:28:49.963 --> 00:28:53.066 align:middle
你更有可能使用函数库提供给你的实现

00:28:53.400 --> 00:28:58.005 align:middle
因为它已经经过了调试和优化

00:28:59.006 --> 00:29:01.975 align:middle
同样如果你想要在我们的平台上

00:28:59.006 --> 00:29:01.975 align:middle
同样如果你想要在我们的平台上

00:29:02.042 --> 00:29:05.445 align:middle
添加一个图像处理
操作到你的CPU应用程序中

00:29:05.512 --> 00:29:07.080 align:middle
你将会使用加速架构

00:29:07.481 --> 00:29:08.715 align:middle
因为它使用了vlmage

00:29:09.583 --> 00:29:10.717 align:middle
它是一个强大的

00:29:10.784 --> 00:29:14.988 align:middle
高性能的调整图像处理架构

00:29:16.256 --> 00:29:19.126 align:middle
因为它使用了CPU的向量处理

00:29:20.194 --> 00:29:21.662 align:middle
这只是几个例子

00:29:22.529 --> 00:29:25.566 align:middle
重要的是可以为你的CPU应用程序

00:29:25.632 --> 00:29:26.834 align:middle
提供丰富的环境

00:29:27.868 --> 00:29:30.103 align:middle
对于GPU情况有些不同

00:29:30.871 --> 00:29:32.239 align:middle
你的选择变少

00:29:32.973 --> 00:29:34.474 align:middle
但是我们将会改变这种情况

00:29:34.908 --> 00:29:38.145 align:middle
我们的目标是丰富
我们的Metal编程环境

00:29:40.447 --> 00:29:42.683 align:middle
我们选择了一系列的通用过滤器

00:29:42.749 --> 00:29:45.986 align:middle
我们知道这些通用过滤器通常使用

00:29:46.053 --> 00:29:47.955 align:middle
在你的图像处理应用和游戏中

00:29:49.723 --> 00:29:53.660 align:middle
这些算法为iOS进行了优化并且

00:29:53.894 --> 00:29:55.963 align:middle
可以使用于A8处理器的IOS 9中

00:29:57.798 --> 00:30:00.434 align:middle
Metal性能着色器架构有两个目标

00:29:57.798 --> 00:30:00.434 align:middle
Metal性能着色器架构有两个目标

00:30:00.801 --> 00:30:03.103 align:middle
性能和容易使用

00:30:03.337 --> 00:30:05.405 align:middle
将它设计成容易融合到

00:30:05.506 --> 00:30:06.907 align:middle
你的Metal应用中

00:30:07.474 --> 00:30:10.143 align:middle
让它直接在Metal资源上进行操作

00:30:10.611 --> 00:30:12.079 align:middle
它们是输入和输出

00:30:13.180 --> 00:30:15.148 align:middle
我们不只是给你提供一批的这些高性能

00:30:15.215 --> 00:30:19.753 align:middle
优化的极好的核心程序

00:30:19.920 --> 00:30:21.688 align:middle
我们还十分关注

00:30:21.755 --> 00:30:25.125 align:middle
启动这些核心程序的必要的宿主代码

00:30:25.726 --> 00:30:28.028 align:middle
我们对如何将并行计算分离

00:30:28.362 --> 00:30:30.998 align:middle
的决策流程也很重视

00:30:32.032 --> 00:30:34.401 align:middle
你所要做的工作就是将这个架构的优势

00:30:34.468 --> 00:30:36.670 align:middle
应用到你的应用程序中

00:30:36.870 --> 00:30:38.872 align:middle
通常只需要几行的代码

00:30:40.440 --> 00:30:42.643 align:middle
它简单地就像是调用一个库函数

00:30:44.211 --> 00:30:46.180 align:middle
现在我就像你们介绍这个架构

00:30:46.380 --> 00:30:48.448 align:middle
让我们看看可用的操作

00:30:49.750 --> 00:30:52.386 align:middle
这里是个完整的列表 我们从头开始

00:30:52.653 --> 00:30:54.421 align:middle
实际上我只是挑几个说

00:30:54.488 --> 00:30:55.589 align:middle
并且我还要举例说明

00:30:57.224 --> 00:30:59.726 align:middle
首先该架构支持直方图过滤器

00:31:00.027 --> 00:31:02.729 align:middle
直方图均衡和规格过滤器

00:31:03.830 --> 00:31:06.099 align:middle
均衡和规格过滤器

00:31:06.567 --> 00:31:10.537 align:middle
允许你改变你的图像

00:31:10.604 --> 00:31:12.206 align:middle
中的色彩强度的分布

00:31:12.840 --> 00:31:15.075 align:middle
均衡过滤器是个很特殊的例子

00:31:15.542 --> 00:31:16.944 align:middle
它将当前的分布

00:31:17.411 --> 00:31:20.013 align:middle
改变为统一的分布

00:31:20.881 --> 00:31:22.983 align:middle
而规格过滤器使你能够设置

00:31:23.050 --> 00:31:24.852 align:middle
你所选择的任何分布

00:31:25.219 --> 00:31:27.621 align:middle
你指定将要在过滤器中使用的直方图

00:31:30.591 --> 00:31:34.394 align:middle
这是均衡过滤器的一个例子

00:31:37.998 --> 00:31:40.200 align:middle
它增加了图像的整体对比度

00:31:40.367 --> 00:31:43.203 align:middle
这里它描绘的天空中的彩虹非常美丽

00:31:43.971 --> 00:31:45.439 align:middle
我想提醒的一件事是

00:31:45.839 --> 00:31:48.609 align:middle
这些过滤器并不是其本身的结束

00:31:49.576 --> 00:31:51.612 align:middle
它们可以在一个更加复杂的算法中

00:31:52.012 --> 00:31:53.480 align:middle
用作中间步骤

00:31:53.881 --> 00:31:57.284 align:middle
直方图过滤器可以用来实现

00:31:57.351 --> 00:31:58.886 align:middle
tune mapping的中间步骤

00:31:58.952 --> 00:32:01.655 align:middle
这种技术常用于图形开发者来

00:31:58.952 --> 00:32:01.655 align:middle
这种技术常用于图形开发者来

00:32:02.089 --> 00:32:05.092 align:middle
接近高动态范围的外观继续

00:32:06.159 --> 00:32:09.763 align:middle
我们还支持Lancos重采样

00:32:10.230 --> 00:32:12.466 align:middle
它是高质量的重采样算法

00:32:12.599 --> 00:32:16.703 align:middle
可以用来缩减 放大
压缩和拉伸图像

00:32:18.071 --> 00:32:21.909 align:middle
在这个例子中 我垂直地拉伸图片

00:32:22.075 --> 00:32:24.511 align:middle
并且水平地挤压图片同时还保存

00:32:24.578 --> 00:32:25.512 align:middle
图像的内容

00:32:27.748 --> 00:32:29.616 align:middle
你还可以支持阀值过滤器

00:32:30.150 --> 00:32:31.952 align:middle
如果与Sobel过滤器链接在一起

00:32:32.085 --> 00:32:33.487 align:middle
它还可以被用来查找图像的边缘

00:32:35.122 --> 00:32:36.290 align:middle
让我们来看个例子

00:32:37.824 --> 00:32:39.693 align:middle
这是阀值过滤器的输出

00:32:40.294 --> 00:32:44.932 align:middle
现在它进入Sobel过滤器
来给你提供图像的边缘

00:32:46.633 --> 00:32:50.904 align:middle
最后支持整个范围的卷积核

00:32:50.971 --> 00:32:53.841 align:middle
包括通用卷积
在这里你可以指定你自己的

00:32:53.907 --> 00:32:55.275 align:middle
卷积矩阵

00:32:55.742 --> 00:32:57.711 align:middle
我们还支持高斯模糊

00:32:57.945 --> 00:32:59.780 align:middle
box tent和Sobel过滤器

00:33:00.180 --> 00:33:03.150 align:middle
我最后的例子将是高斯模糊

00:33:03.750 --> 00:33:05.319 align:middle
你们都应该很熟悉

00:33:05.719 --> 00:33:07.354 align:middle
我们想在我们的UL中使用

00:33:07.821 --> 00:33:09.857 align:middle
你想要在你自己的应用程序中

00:33:09.923 --> 00:33:11.425 align:middle
使用高斯模糊会怎么样呢

00:33:12.526 --> 00:33:15.395 align:middle
性能着色器架构会使它非常简单

00:33:16.730 --> 00:33:17.798 align:middle
你要问有多简单？

00:33:18.732 --> 00:33:20.601 align:middle
我预先告诉你

00:33:20.667 --> 00:33:22.703 align:middle
只有两行代码

00:33:23.537 --> 00:33:28.408 align:middle
首先你必须创建一个模糊过滤器对象

00:33:28.475 --> 00:33:33.347 align:middle
然后你必须将这个
过滤器编码到指令缓存器中

00:33:37.451 --> 00:33:38.552 align:middle
谢谢大家

00:33:41.188 --> 00:33:43.924 align:middle
有一件事我想再次指出和提醒的是

00:33:44.424 --> 00:33:47.594 align:middle
API将你的通用
Metal资源看作是输入

00:33:48.161 --> 00:33:50.030 align:middle
你的设备、你的指令缓存器、你的纹理

00:33:51.098 --> 00:33:53.433 align:middle
这些都是你已经在你的应用程序中

00:33:53.500 --> 00:33:55.169 align:middle
创建的Metal资源

00:33:57.271 --> 00:33:59.106 align:middle
现在我已经向你展示了这两行代码

00:33:59.540 --> 00:34:02.075 align:middle
让我们看看它们插入到你

00:33:59.540 --> 00:34:02.075 align:middle
让我们看看它们插入到你

00:34:02.342 --> 00:34:04.278 align:middle
当前的Metal工作流程的哪个位置

00:34:04.745 --> 00:34:07.147 align:middle
这是你的指令缓存器的图解表示法

00:34:08.447 --> 00:34:10.617 align:middle
它包括你将要提交到

00:34:10.684 --> 00:34:12.186 align:middle
设备中的所有命令

00:34:12.719 --> 00:34:14.288 align:middle
你就像平时那样操作就行了

00:34:15.054 --> 00:34:17.157 align:middle
你通过发送绘制调用来渲染你的屏幕

00:34:18.292 --> 00:34:21.328 align:middle
你通过发送核心程序来进行效果处理

00:34:22.129 --> 00:34:26.199 align:middle
现在你已经决定
你的处理效果之一是模糊过滤器

00:34:26.934 --> 00:34:29.770 align:middle
正好是这个地方

00:34:31.938 --> 00:34:36.310 align:middle
不要忘记你还要像平时那样
提交你的命令到设备中

00:34:36.376 --> 00:34:37.411 align:middle
这里什么都没有改变

00:34:39.279 --> 00:34:43.417 align:middle
现在如果你想要看我刚才
完成的例子中的示例代码

00:34:43.483 --> 00:34:46.320 align:middle
你可以上网
developer.Apple.com

00:34:46.553 --> 00:34:50.056 align:middle
下载叫做Metal性能着色器的例子
世界你好

00:34:52.226 --> 00:34:53.293 align:middle
我前面已经提到过

00:34:53.360 --> 00:34:57.731 align:middle
Metal性能着色器架构
有两个目的性能和易于使用

00:34:58.232 --> 00:35:00.300 align:middle
我刚才展示了它是多么容易使用

00:34:58.232 --> 00:35:00.300 align:middle
我刚才展示了它是多么容易使用

00:35:01.168 --> 00:35:03.070 align:middle
让我们快速地看看幕后

00:35:03.537 --> 00:35:05.472 align:middle
将要告诉你的性能的秘密

00:35:07.641 --> 00:35:09.476 align:middle
对于这些过滤器的每一个

00:35:09.543 --> 00:35:13.647 align:middle
包括高斯模糊过滤器
我们要选择恰当的算法

00:35:14.081 --> 00:35:18.852 align:middle
恰当的这里的意思
是正确的并且是最快的

00:35:19.319 --> 00:35:24.591 align:middle
对于输入数据、输入参数

00:35:24.825 --> 00:35:27.361 align:middle
设备GPU的特别组合是最快的

00:35:28.262 --> 00:35:29.496 align:middle
我这样说是什么意思

00:35:30.364 --> 00:35:32.633 align:middle
有许多方法可以实现高斯模糊

00:35:33.100 --> 00:35:36.270 align:middle
有constant cost
log 2 linear

00:35:36.336 --> 00:35:37.738 align:middle
以及强力运算

00:35:39.273 --> 00:35:40.841 align:middle
所有这些方法的启动费用和

00:35:40.908 --> 00:35:42.309 align:middle
日常开支都不相同

00:35:42.676 --> 00:35:45.646 align:middle
一种方法可能对于小的核半径

00:35:45.979 --> 00:35:48.815 align:middle
非常好但在大的核半径上表现不佳

00:35:49.983 --> 00:35:54.321 align:middle
重要的是我们要实现每一种方法

00:35:54.421 --> 00:35:57.057 align:middle
并且通过实验来发现哪个

00:35:57.124 --> 00:35:59.459 align:middle
对于一个特别的输入问题、输入参数

00:35:59.526 --> 00:36:04.097 align:middle
和设备GPU的组合是最快的

00:35:59.526 --> 00:36:04.097 align:middle
和设备GPU的组合是最快的

00:36:05.265 --> 00:36:06.500 align:middle
在这个过程之后

00:36:07.000 --> 00:36:11.538 align:middle
所有的核都被调整成为你的核半径

00:36:12.439 --> 00:36:13.841 align:middle
你的像素格式

00:36:14.408 --> 00:36:16.944 align:middle
你的基础硬件结构的存储层次的参数

00:36:17.311 --> 00:36:19.279 align:middle
以及每个线程的像素数目

00:36:19.346 --> 00:36:21.148 align:middle
以及线程组规模的参数

00:36:21.215 --> 00:36:23.584 align:middle
这决定了如何将你的工作并行分离

00:36:25.018 --> 00:36:26.486 align:middle
最后我将会提到

00:36:27.187 --> 00:36:30.624 align:middle
该架构还为你做CPU优化工作

00:36:32.526 --> 00:36:35.028 align:middle
它优化了程序上载速度

00:36:36.263 --> 00:36:40.634 align:middle
它还重复使用中间纹理

00:36:41.201 --> 00:36:45.072 align:middle
它还为你做计算编码优化

00:36:45.472 --> 00:36:47.241 align:middle
特别的是它还能察觉

00:36:47.641 --> 00:36:51.044 align:middle
你是否是在连续使用多重计算编码器

00:36:51.111 --> 00:36:52.412 align:middle
如果是这样它就会将它们合并

00:36:55.048 --> 00:36:57.417 align:middle
我们为你完成了所有的这些步骤

00:36:58.418 --> 00:37:01.021 align:middle
非常酷
但以代码的角度来看是什么样子

00:36:58.418 --> 00:37:01.021 align:middle
非常酷
但以代码的角度来看是什么样子

00:37:01.088 --> 00:37:03.724 align:middle
如对于我刚刚向你们展示的

00:37:03.790 --> 00:37:04.725 align:middle
优化高斯模糊着色器

00:37:07.427 --> 00:37:08.862 align:middle
好了 你准备好了么？

00:37:09.696 --> 00:37:11.131 align:middle
这就是代码

00:37:12.499 --> 00:37:13.534 align:middle
现在你们都知道了

00:37:13.600 --> 00:37:15.936 align:middle
如何实现你们自己的优化高斯模糊

00:37:16.203 --> 00:37:17.337 align:middle
对么我敢打赌 你没想到

00:37:17.404 --> 00:37:19.573 align:middle
在这个讲座中能学到这个

00:37:19.840 --> 00:37:23.010 align:middle
言归正传这是49 Metal
kernels

00:37:23.076 --> 00:37:25.245 align:middle
2,000行的kernel代码

00:37:25.312 --> 00:37:29.750 align:middle
以及821个不同的
Metal高斯模糊实现

00:37:30.584 --> 00:37:35.789 align:middle
每个实现都是这些49个Metal
kernels一些组合

00:37:35.856 --> 00:37:37.424 align:middle
因此看起来我们做了很多的工作

00:37:37.691 --> 00:37:38.692 align:middle
现在不必由你来做

00:37:39.493 --> 00:37:40.894 align:middle
让我们看看

00:37:40.961 --> 00:37:44.665 align:middle
运行中的Metal性能着色器架构

00:37:51.238 --> 00:37:53.273 align:middle
首先我将演示一个简单的

00:37:53.373 --> 00:37:58.545 align:middle
可分离高斯模糊实现的教科书

00:37:59.947 --> 00:38:01.715 align:middle
只需要1分钟就可写入到Metal

00:37:59.947 --> 00:38:01.715 align:middle
只需要1分钟就可写入到Metal

00:38:01.782 --> 00:38:03.951 align:middle
这可能是你刚开始时应该使用的东西

00:38:04.017 --> 00:38:05.586 align:middle
如果你要实现你的模糊

00:38:05.652 --> 00:38:08.188 align:middle
并且你手头没有Metal性能着色器

00:38:08.922 --> 00:38:11.258 align:middle
现在我们非常愉快地
在每秒60帧在运行着

00:38:11.325 --> 00:38:13.193 align:middle
但是我们实际上还没有做任何工作

00:38:13.994 --> 00:38:15.195 align:middle
sigma数值是0

00:38:15.596 --> 00:38:19.399 align:middle
让我们改变sigma数值到6

00:38:19.466 --> 00:38:21.134 align:middle
我们就降到了每秒8帧

00:38:21.969 --> 00:38:23.303 align:middle
我们还敢继续么

00:38:23.370 --> 00:38:24.738 align:middle
让我们试着sigma 20

00:38:27.307 --> 00:38:30.844 align:middle
好了 现在我们降到了每秒3帧

00:38:30.911 --> 00:38:32.179 align:middle
那样就无法工作了

00:38:33.013 --> 00:38:34.748 align:middle
让我们转换到Metal性能

00:38:34.815 --> 00:38:35.949 align:middle
着色器实现

00:38:37.551 --> 00:38:39.887 align:middle
现在我们返回到了每秒60帧

00:38:39.953 --> 00:38:42.789 align:middle
没有做任何工作sigma为6

00:38:43.423 --> 00:38:44.858 align:middle
每秒仍然是60帧

00:38:45.592 --> 00:38:46.560 align:middle
Sigma为20

00:38:47.127 --> 00:38:48.595 align:middle
仍然是每秒60帧

00:38:49.863 --> 00:38:53.367 align:middle
我们还得继续 真的模糊它

00:38:53.700 --> 00:38:55.169 align:middle
仍然是每秒60帧

00:38:55.235 --> 00:38:56.470 align:middle
看起来我们赢了

00:39:13.053 --> 00:39:15.322 align:middle
这样你的屏幕刷新速率是60赫兹

00:39:17.090 --> 00:39:20.994 align:middle
这就意味着我们以每秒60帧在运行

00:39:21.061 --> 00:39:24.898 align:middle
这样你在演示中
所看到的优化高斯模糊着色器

00:39:24.965 --> 00:39:28.335 align:middle
的性能最高是每秒60帧

00:39:29.102 --> 00:39:33.941 align:middle
这就意味着你有
16.6毫秒来画你的帧

00:39:34.575 --> 00:39:36.543 align:middle
这还包括你的系统可能要做的

00:39:36.610 --> 00:39:38.779 align:middle
合成工作

00:39:39.813 --> 00:39:43.584 align:middle
这个图表显示你在不同的sigma值

00:39:43.650 --> 00:39:47.254 align:middle
的优化高斯模糊过滤器的执行时间

00:39:47.321 --> 00:39:48.422 align:middle
你可以看到执行时间

00:39:49.656 --> 00:39:52.759 align:middle
要比16.6毫秒少得多

00:39:53.794 --> 00:39:56.363 align:middle
这就意味着你仍然有额外的时间

00:39:56.430 --> 00:39:57.965 align:middle
来做多余的GPU工作

00:39:59.499 --> 00:40:02.769 align:middle
而且仍然能达到希望的每秒60帧

00:39:59.499 --> 00:40:02.769 align:middle
而且仍然能达到希望的每秒60帧

00:40:05.472 --> 00:40:07.708 align:middle
现在还有一些细节需要说明

00:40:09.476 --> 00:40:12.212 align:middle
有时候你需要在很大的图片上工作

00:40:12.279 --> 00:40:13.380 align:middle
你需要并列式显示

00:40:14.548 --> 00:40:15.983 align:middle
有时候你需要只在你的

00:40:16.049 --> 00:40:17.317 align:middle
图像的一部分上工作

00:40:17.718 --> 00:40:18.986 align:middle
针对那个有个机制

00:40:19.486 --> 00:40:21.889 align:middle
它叫做源偏移和
destination剪裁矩形

00:40:23.090 --> 00:40:25.626 align:middle
剪裁矩形有起始点和大小

00:40:26.193 --> 00:40:28.795 align:middle
它决定了目的纹理的区域

00:40:28.862 --> 00:40:30.697 align:middle
将由过滤器来进行更新

00:40:31.899 --> 00:40:34.334 align:middle
源偏移只有起始点

00:40:35.135 --> 00:40:37.905 align:middle
大小是隐含的
由剪裁矩形来决定的

00:40:37.971 --> 00:40:41.542 align:middle
它只是你的目的纹理的
左上角的一个相位差

00:40:42.309 --> 00:40:45.379 align:middle
它们共同工作给你提供了最后的图像

00:40:48.448 --> 00:40:50.651 align:middle
在Metal性能着色器架构中

00:40:50.717 --> 00:40:53.654 align:middle
你的来源和目的是相同纹理中的一个

00:40:54.621 --> 00:40:56.590 align:middle
在这种情况下剪裁矩形

00:40:56.890 --> 00:40:59.560 align:middle
以同样的方式工作

00:41:03.463 --> 00:41:06.233 align:middle
当来源和目的是相同的

00:41:06.400 --> 00:41:08.235 align:middle
我们管它叫in-place操作

00:41:08.836 --> 00:41:10.037 align:middle
用它来节约内存

00:41:11.271 --> 00:41:14.208 align:middle
你怎样做才能对这些in-place
过滤器进行编码呢

00:41:15.175 --> 00:41:17.878 align:middle
你必须要使用编码命令缓冲区方法

00:41:17.945 --> 00:41:20.614 align:middle
和一个分配器
fall by back copy

00:41:22.382 --> 00:41:25.285 align:middle
有一件事要记住的是
着色器并不总是可能

00:41:25.352 --> 00:41:27.020 align:middle
运行in place

00:41:27.087 --> 00:41:28.922 align:middle
它取决于你的过滤器

00:41:28.989 --> 00:41:30.791 align:middle
过滤器参数和性能

00:41:31.425 --> 00:41:32.893 align:middle
如果你希望这个操作永远成功

00:41:32.960 --> 00:41:35.495 align:middle
使用一个复制分配器

00:41:36.063 --> 00:41:37.664 align:middle
它就会被自动调用

00:41:38.432 --> 00:41:41.635 align:middle
除非在in place
操作不可能的情况下

00:41:42.035 --> 00:41:44.872 align:middle
我们将为你创建一个新的目的纹理

00:41:46.206 --> 00:41:47.674 align:middle
这样在必要情况下操作

00:41:47.741 --> 00:41:49.276 align:middle
可在out of place 进行

00:41:50.811 --> 00:41:54.214 align:middle
有简单fall back copy
分配器的例子

00:41:55.816 --> 00:41:58.952 align:middle
这个例子只是创建了一个
新的具有相同的像素格式和大小

00:41:59.720 --> 00:42:02.823 align:middle
的目的纹理

00:41:59.720 --> 00:42:02.823 align:middle
的目的纹理

00:42:02.890 --> 00:42:04.625 align:middle
因为源纹理非常简单

00:42:05.792 --> 00:42:07.961 align:middle
之前我向你们
展示了一个in place 操作

00:42:08.028 --> 00:42:10.731 align:middle
在这个操作中 你只对目的纹理的

00:42:10.797 --> 00:42:12.099 align:middle
一部分进行了更改

00:42:12.766 --> 00:42:15.869 align:middle
在剪裁矩形之外的任何东西都没有改变

00:42:16.236 --> 00:42:18.372 align:middle
在复制分配器中你还可以这样做

00:42:19.339 --> 00:42:21.675 align:middle
只需要用你的源纹理的环境

00:42:21.742 --> 00:42:23.544 align:middle
来初始化你的目的纹理

00:42:26.346 --> 00:42:28.615 align:middle
我还想提到的是所有常见

00:42:28.682 --> 00:42:31.118 align:middle
的Metal资源如你的设备和

00:42:31.185 --> 00:42:32.252 align:middle
你的指令缓冲器

00:42:32.319 --> 00:42:34.288 align:middle
你都可在复制分配器中获得

00:42:35.322 --> 00:42:37.090 align:middle
现在我对细节进行了说明

00:42:37.157 --> 00:42:38.292 align:middle
让我们来总结一下

00:42:39.660 --> 00:42:43.363 align:middle
我想说的是请使用Metal支持架构

00:42:43.430 --> 00:42:45.499 align:middle
MetalKit和Metal性能着色器

00:42:45.766 --> 00:42:47.601 align:middle
它们非常强健
它们经过优化

00:42:47.868 --> 00:42:49.002 align:middle
正如我向你们展示的

00:42:49.069 --> 00:42:51.605 align:middle
它们很容易融入
你们的Metal的应用程序中

00:42:52.005 --> 00:42:54.641 align:middle
它们会给你的应用程序带来更多的时间

00:42:54.908 --> 00:42:57.644 align:middle
你可以把时间用在
制作独特的应用程序上

00:42:57.911 --> 00:43:00.047 align:middle
而不是浪费在一般的工作上

00:42:57.911 --> 00:43:00.047 align:middle
而不是浪费在一般的工作上

00:43:00.547 --> 00:43:02.482 align:middle
另外的好处是

00:43:02.716 --> 00:43:04.952 align:middle
你可以花更少的代码来编写和维护

00:43:05.886 --> 00:43:10.424 align:middle
到我们的实验室来向我们提出反馈意见
让我们知道如何开始或者向我们提问

00:43:10.791 --> 00:43:15.963 align:middle
让我们知道是否想让新的工具或着色器
添加到支持架构中

00:43:17.564 --> 00:43:19.700 align:middle
你随时可以在网上发现更多的信息

00:43:19.766 --> 00:43:21.602 align:middle
我们可以提供文档视频

00:43:21.969 --> 00:43:25.205 align:middle
充分利用苹果开发论坛和技术支持

00:43:25.706 --> 00:43:26.840 align:middle
对于一般的疑问

00:43:26.907 --> 00:43:29.843 align:middle
请联系我们的游戏技术大师
阿伦·谢弗

00:43:31.879 --> 00:43:35.015 align:middle
你可以在网上观看以前的讲座

00:43:35.249 --> 00:43:38.785 align:middle
但如果你想
学习新Metal性能优化技术

00:43:39.319 --> 00:43:41.688 align:middle
明天上午11:00来听我们的讲座

00:43:41.788 --> 00:43:42.623 align:middle
谢谢
