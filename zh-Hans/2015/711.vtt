WEBVTT

00:00:26.326 --> 00:00:29.730 align:middle
《网络与NSURL会话》

00:00:32.299 --> 00:00:33.133 align:middle
早上好！

00:00:34.101 --> 00:00:37.204 align:middle
感谢您来到
《网络与NSURL会话》会议

00:00:37.704 --> 00:00:40.274 align:middle
我是盧克·卡斯
我是一个CF网络组的工程师

00:00:40.641 --> 00:00:42.809 align:middle
今天早上我为与
会的各位罗列了一些很棒的东西

00:00:44.578 --> 00:00:47.514 align:middle
首先
我们要讲一些应用程序传输安全问题

00:00:48.148 --> 00:00:52.219 align:middle
接着我们会讲在NSURL会话中
添加了哪些新的协议

00:00:54.121 --> 00:00:56.123 align:middle
周一我们看到了WatchOS的发布

00:00:56.557 --> 00:01:01.662 align:middle
我们将会介绍为WatchOS
添加的NSURL会话功能

00:00:56.557 --> 00:01:01.662 align:middle
我们将会介绍为WatchOS
添加的NSURL会话功能

00:01:02.029 --> 00:01:05.632 align:middle
之后我们会梳理一下API有哪些变化

00:01:05.632 --> 00:01:07.534 align:middle
以及我们在NSURL会话中
添加了哪些新功能

00:01:09.636 --> 00:01:15.475 align:middle
首先我想要讲一下NSURL会话
和HTTP协议的背景

00:01:16.176 --> 00:01:18.779 align:middle
NSURL会话是一个网络API

00:01:18.846 --> 00:01:23.650 align:middle
主要用于从网站
下载内容或者HTTP内容

00:01:25.052 --> 00:01:27.154 align:middle
它包含很多委托方法

00:01:27.387 --> 00:01:32.025 align:middle
可以用来认证或者
处理一些其他的重要事情

00:01:32.626 --> 00:01:35.362 align:middle
NSURL会话有一个非常强大的功能

00:01:35.662 --> 00:01:38.298 align:middle
那就是它允许你的程序

00:01:38.365 --> 00:01:44.438 align:middle
在没有后台下载API的情况下
做网络层任务

00:01:46.106 --> 00:01:48.709 align:middle
如果你对NSURL会话不熟悉的话

00:01:49.042 --> 00:01:51.612 align:middle
建议你可以回顾一下

00:01:51.945 --> 00:01:55.983 align:middle
几年前的WWDC会议中
对NSURL会话的介绍

00:01:58.252 --> 00:02:01.522 align:middle
现在让我们讨论一下超文本传输协议

00:01:58.252 --> 00:02:01.522 align:middle
现在让我们讨论一下超文本传输协议

00:02:01.755 --> 00:02:05.659 align:middle
这是一个非常有名的协议
你们中的很多人可能都很熟悉

00:02:06.860 --> 00:02:11.365 align:middle
基本上其核心就是
你向服务器发送请求

00:02:11.565 --> 00:02:14.401 align:middle
然后你会拉回一个数据包作为回应

00:02:15.202 --> 00:02:18.338 align:middle
现在HTTP其本身

00:02:19.540 --> 00:02:23.577 align:middle
你们中间有些人可能知道发送的是明码
所以其从根本上来讲就不安全

00:02:24.912 --> 00:02:26.146 align:middle
在今天的网络环境中

00:02:26.680 --> 00:02:32.653 align:middle
有很多攻击团体追踪你的APP数据
并将其发布到网络上

00:02:38.492 --> 00:02:42.362 align:middle
曾经有一段时间单独使用明码HTTP
这是完全合理的

00:02:42.729 --> 00:02:44.598 align:middle
但是这段时间已经过去

00:02:45.232 --> 00:02:46.600 align:middle
现在我们所有人都是幸运的

00:02:46.667 --> 00:02:50.904 align:middle
这个问题在多年以前就被解决

00:02:51.104 --> 00:02:52.873 align:middle
就是HTTPS

00:02:56.343 --> 00:03:01.048 align:middle
但HTTPS本质上
是HTTPS的上一层协议

00:02:56.343 --> 00:03:01.048 align:middle
但HTTPS本质上
是HTTPS的上一层协议

00:03:01.114 --> 00:03:02.749 align:middle
属于传输层安全协议

00:03:03.417 --> 00:03:06.653 align:middle
传输层安全协议会通过公钥密码学方式

00:03:07.120 --> 00:03:09.857 align:middle
进行一个多点的信号交换之后

00:03:10.257 --> 00:03:11.792 align:middle
会创建一个安全的连接

00:03:12.726 --> 00:03:16.797 align:middle
这种连接的安全性
是基于三个属性来讲

00:03:17.564 --> 00:03:21.134 align:middle
第一 从你的APP发出

00:03:21.568 --> 00:03:24.271 align:middle
并在网络上传输的数据是加密过的
所以其不可读

00:03:25.138 --> 00:03:28.041 align:middle
第二 其提供了消息完整性参数

00:03:28.675 --> 00:03:31.111 align:middle
所以消息在检测之前是不可以修改的

00:03:31.912 --> 00:03:34.815 align:middle
最后第三点 它支持身份验证

00:03:35.082 --> 00:03:38.552 align:middle
所以你可以验证
到底是谁在和你会话

00:03:43.023 --> 00:03:47.528 align:middle
现在NSURL会话
有非常好的HTTPS嵌入性支持

00:03:48.061 --> 00:03:51.098 align:middle
通常在你的客户端代码中

00:03:51.398 --> 00:03:54.034 align:middle
这就像使用HTTPS
代替HTTP一样简单

00:03:54.935 --> 00:03:58.038 align:middle
现在请注意
需要一些额外的服务器支持

00:03:58.605 --> 00:04:02.075 align:middle
但HTTPS是大多数服务器
供应商都支持的

00:03:58.605 --> 00:04:02.075 align:middle
但HTTPS是大多数服务器
供应商都支持的

00:04:04.211 --> 00:04:05.412 align:middle
还请记住

00:04:06.880 --> 00:04:09.550 align:middle
大多数数据都应该被标记为敏感数据

00:04:10.551 --> 00:04:13.287 align:middle
那是因为即使你认为

00:04:13.921 --> 00:04:17.991 align:middle
你在网络上传输的数据
并不属于敏感数据

00:04:18.825 --> 00:04:21.728 align:middle
但是事实上
你的客户可能认为它是敏感数据

00:04:21.995 --> 00:04:24.631 align:middle
假如你有一个TV流APP

00:04:26.099 --> 00:04:27.968 align:middle
你可能认为这只是一个电视

00:04:28.101 --> 00:04:30.404 align:middle
你知道吗？他只是看电视

00:04:30.771 --> 00:04:34.141 align:middle
他或她仅仅是看电视
但是对他们来说...

00:04:36.610 --> 00:04:39.179 align:middle
他们事实上并不想
让人们知道他们在看什么电视

00:04:39.246 --> 00:04:40.247 align:middle
让我们用这种方式解释

00:04:42.950 --> 00:04:46.587 align:middle
现在为什么说
使用HPPTS如此重要？

00:04:46.954 --> 00:04:49.089 align:middle
事实上从本质上来讲

00:04:49.423 --> 00:04:52.359 align:middle
你的客户相信你
能够保证他们的数据和个人隐私

00:04:53.527 --> 00:04:56.597 align:middle
在Apple
我们非常想要和你们一起努力

00:04:56.597 --> 00:04:59.867 align:middle
并确保我们能够
建立并维持这种信任关系

00:05:00.234 --> 00:05:03.570 align:middle
所以今天我非常自豪能够介绍
App Transport Security

00:05:05.239 --> 00:05:07.941 align:middle
App Transport Security

00:05:08.208 --> 00:05:12.012 align:middle
是Apple在IOS 9和OS X
和EI旗舰版中的一个新功能

00:05:12.846 --> 00:05:19.720 align:middle
从本质上来讲其核心是防止
用户的个人隐私数据被意外泄露

00:05:22.122 --> 00:05:26.193 align:middle
现在ATS也加强了
NSURL会话的默认方法

00:05:27.327 --> 00:05:29.863 align:middle
可以在默认设置下
最重要的增强的方面

00:05:30.831 --> 00:05:33.433 align:middle
就是现在的NSURL会话

00:05:33.734 --> 00:05:36.270 align:middle
它不允许明码HTTP进行加载

00:05:36.637 --> 00:05:38.772 align:middle
它将只使用HPPTS连接

00:05:39.439 --> 00:05:42.509 align:middle
现在这种连接方式
确实是当下最可靠且最好的实现方法

00:05:43.210 --> 00:05:46.213 align:middle
所以ATS对TLS的版本进行了限制

00:05:47.014 --> 00:05:52.753 align:middle
密码组合 信任证书 证书密钥的大小
等都是被作为限制条件

00:05:54.555 --> 00:05:58.825 align:middle
现在ATS能很容易地通过应用程序的
Info.plist进行配置

00:05:59.693 --> 00:06:00.961 align:middle
这里有一个例子

00:05:59.693 --> 00:06:00.961 align:middle
这里有一个例子

00:06:02.162 --> 00:06:07.601 align:middle
事实上我们让你做的就是
声明你在应用程序中有目的的网络行为

00:06:10.838 --> 00:06:16.376 align:middle
核心上来讲
ATS希望你能描述使用网络做什么

00:06:16.710 --> 00:06:21.648 align:middle
我们真心希望你能够放心
你的应用程序安全问题

00:06:21.982 --> 00:06:23.617 align:middle
并且做事情的时候更加信赖这个系统

00:06:23.917 --> 00:06:28.822 align:middle
当网络交易是安全的时候
这些都是最简单的事情

00:06:30.757 --> 00:06:34.962 align:middle
所以 如果你的程序只使用安全的连接

00:06:35.162 --> 00:06:37.264 align:middle
并且其只使用最佳安全属性

00:06:37.931 --> 00:06:40.968 align:middle
那么你就不需要做任何事情
来为你的应用程序配置ATS

00:06:42.936 --> 00:06:46.406 align:middle
因此 如果你在编写一个新的应用程序
这就是我们想要你做的事情

00:06:47.241 --> 00:06:50.043 align:middle
如果你有一个现成的应用程序
或者有一段遗留代码

00:06:50.511 --> 00:06:52.579 align:middle
这就是你应该注意的地方

00:06:55.048 --> 00:07:00.554 align:middle
现在我们明白实际情况
可能并不总是这样

00:06:55.048 --> 00:07:00.554 align:middle
现在我们明白实际情况
可能并不总是这样

00:07:00.554 --> 00:07:06.493 align:middle
假如你有一个服务器可以遵守
这些TLS版本或者密码套件的新限制

00:07:06.960 --> 00:07:11.131 align:middle
所以我们允许例外情况的出现

00:07:11.532 --> 00:07:14.968 align:middle
事实上你可以通过ATS声明异常原因

00:07:16.003 --> 00:07:18.605 align:middle
让我们知道你想
使用什么版本的TLS

00:07:18.605 --> 00:07:21.675 align:middle
或者你也可以选择正向保密
或者其他的选项

00:07:24.011 --> 00:07:27.881 align:middle
我们理解现存的程序可能有不同的限制

00:07:29.783 --> 00:07:32.686 align:middle
假设大多数情况下你都使用安全连接

00:07:33.387 --> 00:07:35.322 align:middle
但是特殊情况下

00:07:36.523 --> 00:07:41.228 align:middle
你可能会使用一些并不支持HTTPS
或者最佳实践的服务器

00:07:42.095 --> 00:07:44.298 align:middle
假如你有一个多媒体服务器

00:07:44.598 --> 00:07:47.367 align:middle
它并不支持HTTPS
只支持HTTP

00:07:47.801 --> 00:07:52.039 align:middle
你能够很方便地用异常来描述这种情况

00:07:53.273 --> 00:07:57.811 align:middle
基本上所有你需要做的事情就是
声明哪些域名需要加载HTTP

00:07:58.145 --> 00:08:01.248 align:middle
NSURL仍然允许明码加载

00:07:58.145 --> 00:08:01.248 align:middle
NSURL仍然允许明码加载

00:08:05.452 --> 00:08:09.122 align:middle
现在我们了解到你们中一些人
可能会支持使用一个通用的网页浏览器

00:08:09.189 --> 00:08:12.993 align:middle
或者一个基于
动态用户输入加载URL的程序

00:08:13.527 --> 00:08:14.962 align:middle
现在我们已经允许了这种情况

00:08:15.395 --> 00:08:21.134 align:middle
在这种情况下
你不可能提前描述的安全连接的种类

00:08:21.602 --> 00:08:25.606 align:middle
所以你可以简单地
选择声明允许所有的方法

00:08:26.740 --> 00:08:28.709 align:middle
现在这个允许所有的方法

00:08:29.576 --> 00:08:35.381 align:middle
能够允许NSURL会话加载
任何的HTTP或者HTTPS资源

00:08:36.616 --> 00:08:40.087 align:middle
我相信这是目前互联网上现有的工具中

00:08:40.520 --> 00:08:42.222 align:middle
一个非常有用的调试工具

00:08:42.655 --> 00:08:44.725 align:middle
所以我们希望

00:08:44.858 --> 00:08:48.829 align:middle
如果你用它做调试
可以对显而易见的原因进行临时调试

00:08:51.498 --> 00:08:52.833 align:middle
现在即使你就处于这种状态

00:08:52.833 --> 00:08:56.470 align:middle
你仍然能够保护特定的服务器和域

00:08:57.771 --> 00:08:59.673 align:middle
如果你的设置的是允许所有

00:08:59.907 --> 00:09:04.511 align:middle
但是如果你有一个
用来拉取配置数据和元数据的服务器

00:08:59.907 --> 00:09:04.511 align:middle
但是如果你有一个
用来拉取配置数据和元数据的服务器

00:09:05.179 --> 00:09:08.649 align:middle
并且用ATS来做调试
这种情况是个例外

00:09:09.616 --> 00:09:13.153 align:middle
当你对一种例外情况
进行允许所有的设置时

00:09:13.754 --> 00:09:16.056 align:middle
只需要简单地声明
想要保护的域就行了

00:09:16.657 --> 00:09:23.030 align:middle
这样允许NSURL会话 继续通过
只加载HTTPS或者最优方法

00:09:23.730 --> 00:09:25.265 align:middle
来保护这些资源

00:09:29.069 --> 00:09:29.903 align:middle
现在

00:09:30.771 --> 00:09:32.539 align:middle
从周一开始
这个SDK已经发布了

00:09:33.807 --> 00:09:37.211 align:middle
可能有一部分人
已经在这个糟糕的时间醒了

00:09:37.578 --> 00:09:41.415 align:middle
仅仅就是想知道ATS是干什么用的
以及为什么你的网络会加载失败

00:09:42.282 --> 00:09:43.550 align:middle
我们明白

00:09:43.617 --> 00:09:46.253 align:middle
我们只是想和你一起工作
所以才把你叫起来

00:09:49.356 --> 00:09:53.994 align:middle
所以请注意 ATS只有在你构建
当前SDK时是活跃的

00:09:54.828 --> 00:09:56.630 align:middle
如果你针对的是之前的版本

00:09:57.064 --> 00:09:58.665 align:middle
ATS规则不适用

00:10:00.934 --> 00:10:05.005 align:middle
NSURL会话会将HTTP资源

00:10:05.472 --> 00:10:08.942 align:middle
或者URL自动转换成HTTPS

00:10:11.879 --> 00:10:15.716 align:middle
就像我之前说的
你们中有人已经对这个开关有所了解

00:10:16.683 --> 00:10:18.452 align:middle
我们允许你暂时使用这个功能

00:10:18.685 --> 00:10:21.922 align:middle
来判断你的程序中新发生的网络错误

00:10:22.155 --> 00:10:23.790 align:middle
是不是因为ATS

00:10:24.358 --> 00:10:26.093 align:middle
这能够帮助你将范围缩小

00:10:28.562 --> 00:10:32.332 align:middle
接下来
如果你打开了允许所有的ATS

00:10:32.599 --> 00:10:33.867 align:middle
允许所有开始加载

00:10:35.435 --> 00:10:37.571 align:middle
那么你就能够确定问题出在ATS

00:10:38.438 --> 00:10:42.409 align:middle
接下来就是
查找你看到的NSURL会话的错误

00:10:42.709 --> 00:10:44.344 align:middle
所以你可以试着确定并缩小范围

00:10:44.344 --> 00:10:46.079 align:middle
到底哪个加载过程失败了

00:10:46.413 --> 00:10:47.681 align:middle
以及潜在的错误是什么

00:10:50.784 --> 00:10:53.554 align:middle
还有一个很棒的调试工具

00:10:54.421 --> 00:10:57.057 align:middle
是一个被叫做CF网络诊断的环境变量

00:10:58.692 --> 00:11:01.195 align:middle
如果你将CF网络诊断设置为一级

00:10:58.692 --> 00:11:01.195 align:middle
如果你将CF网络诊断设置为一级

00:11:01.929 --> 00:11:04.031 align:middle
所有失败的URL开始加载

00:11:04.164 --> 00:11:07.201 align:middle
所有加载失败的任务
都能被确定是URL错误

00:11:07.568 --> 00:11:09.436 align:middle
或者是底层TLS错误

00:11:10.270 --> 00:11:11.705 align:middle
这样接下来你能做的就是

00:11:12.005 --> 00:11:16.410 align:middle
查找底层TLS错误并
确认transport.h的安全性

00:11:16.910 --> 00:11:19.746 align:middle
确定究竟是什么底层问题

00:11:21.014 --> 00:11:26.153 align:middle
通常是客户端和服务器端
在TLS层的协商失败

00:11:31.124 --> 00:11:35.863 align:middle
所以现在弄明白这是一个新的API
它仍然在发展

00:11:36.463 --> 00:11:43.070 align:middle
所以我们强烈建议你们
关注种子笔记和发行说明

00:11:43.170 --> 00:11:48.342 align:middle
请将文件广播出来
这样方便我们跟踪你们碰到了什么问题

00:11:49.543 --> 00:11:51.612 align:middle
帮助你们解决并运行起来

00:11:55.782 --> 00:11:58.652 align:middle
所以我希望这是一个网络安全的时代

00:11:59.353 --> 00:12:03.056 align:middle
并且我们非常希望能够与你合作
一起来保护客户的数据安全

00:11:59.353 --> 00:12:03.056 align:middle
并且我们非常希望能够与你合作
一起来保护客户的数据安全

00:12:04.391 --> 00:12:05.225 align:middle
再说一遍

00:12:05.993 --> 00:12:10.163 align:middle
如果你正在开发一个新程序
请使用HTTPS作为开头

00:12:10.631 --> 00:12:14.801 align:middle
并尽可能地使你的服务器运行最优方法

00:12:16.737 --> 00:12:20.040 align:middle
现在如果你使用的是现有的软件

00:12:20.174 --> 00:12:24.344 align:middle
我们希望
你能先把能够移动的移动到HTTPS

00:12:24.611 --> 00:12:25.879 align:middle
那些你不能够移动的地方

00:12:26.613 --> 00:12:31.118 align:middle
可以通过使用例外情况和
你的Info.plist移动

00:12:32.286 --> 00:12:35.322 align:middle
现在请牢记
你的客户相信你能够保护好其数据

00:12:35.956 --> 00:12:39.493 align:middle
并且这些数据在任何时候都是敏感的

00:12:40.327 --> 00:12:42.262 align:middle
所以Apple希望与你合作

00:12:43.230 --> 00:12:45.899 align:middle
共同为你的客户创造
一个更加安全的网络环境

00:12:46.400 --> 00:12:47.234 align:middle
所以再说一遍

00:12:48.836 --> 00:12:50.537 align:middle
请通过雷达给我们反馈

00:12:51.171 --> 00:12:54.007 align:middle
在这个会之后
明天就可以过来实验室拜访我们

00:12:54.541 --> 00:12:57.311 align:middle
我们真的非常希望
与你一起保护我们客户的数据

00:12:58.178 --> 00:13:01.348 align:middle
谢谢所有人的到来
接下来有请安德鲁

00:12:58.178 --> 00:13:01.348 align:middle
谢谢所有人的到来
接下来有请安德鲁

00:13:01.348 --> 00:13:03.951 align:middle
他将会讲新的协议和NSURL会话

00:13:04.251 --> 00:13:05.285 align:middle
祝你有一个愉快的会议

00:13:11.425 --> 00:13:12.326 align:middle
谢谢 卢克

00:13:14.928 --> 00:13:16.063 align:middle
早上好各位

00:13:16.330 --> 00:13:17.364 align:middle
我叫安德鲁

00:13:17.431 --> 00:13:21.201 align:middle
接下来我将介绍NSURL会话中
新的协议支持方法

00:13:23.737 --> 00:13:30.444 align:middle
是的
NSURL会话支持HTTP/2协议

00:13:31.912 --> 00:13:35.048 align:middle
你的程序
可以使用HTTP/2进行通信

00:13:35.182 --> 00:13:36.950 align:middle
并且在适配上非常容易

00:13:37.651 --> 00:13:38.986 align:middle
让我来演示一次

00:13:41.188 --> 00:13:42.022 align:middle
好的

00:13:42.823 --> 00:13:45.659 align:middle
如果在你的代码中
已经使用了NSURL会话

00:13:46.159 --> 00:13:48.729 align:middle
你自动地就已经是其中的一部分了

00:13:49.229 --> 00:13:52.533 align:middle
在网络的未来
网络革命中的重大里程碑中

00:13:52.933 --> 00:13:54.601 align:middle
你的程序已经走在了前列

00:13:55.035 --> 00:13:56.770 align:middle
你不需要修改你的源代码

00:13:57.070 --> 00:13:58.772 align:middle
所有事情都是自动完成的

00:14:01.375 --> 00:14:04.244 align:middle
所以今天我准备讲三件事情

00:14:05.612 --> 00:14:12.419 align:middle
为什么我们需要一个新协议
HTTP/1.1协议有什么问题

00:14:13.554 --> 00:14:17.791 align:middle
我们将要学习一下
HTTP/2最重要的功能

00:14:18.692 --> 00:14:23.997 align:middle
最后我会讲一下HTTP/2协议
在你的程序中的适配性

00:14:27.935 --> 00:14:29.870 align:middle
为什么需要一个新的协议？

00:14:32.739 --> 00:14:36.810 align:middle
我们已经有很多协议
用于各种类型的通信

00:14:37.644 --> 00:14:44.284 align:middle
原因是大多数协议都是在很多年前
响应那个时代的需要设计出来的

00:14:45.052 --> 00:14:47.754 align:middle
看一下Apple的第一个网站

00:14:51.225 --> 00:14:56.597 align:middle
今天需要的和十五年前
看起来是明显不同的

00:14:57.231 --> 00:14:58.765 align:middle
所以是时候进行一次升级了

00:15:00.801 --> 00:15:03.303 align:middle
HTTP从网络的最开始就已经存在了

00:15:03.871 --> 00:15:06.740 align:middle
大家都知道它有很多问题

00:15:07.808 --> 00:15:09.877 align:middle
最有名的HTTP的问题是

00:15:10.277 --> 00:15:14.515 align:middle
每一个TCP连接只有一个优先请求

00:15:16.550 --> 00:15:19.152 align:middle
这个问题的解决办法就是HTTP管道

00:15:19.820 --> 00:15:24.124 align:middle
但是HTTP管道并不适用于
所有的服务器或网络

00:15:24.791 --> 00:15:29.329 align:middle
事实上 大多数桌面主流网页浏览器上
它是被禁用的

00:15:31.665 --> 00:15:34.868 align:middle
另一个解决办法
就是给一个主机开多个连接

00:15:35.802 --> 00:15:39.173 align:middle
这样能够更快的得到多种资源

00:15:39.606 --> 00:15:43.610 align:middle
综合其他情况例如文本协议开销

00:15:44.444 --> 00:15:45.979 align:middle
缺乏头压缩

00:15:46.647 --> 00:15:47.814 align:middle
它只是意味着

00:15:48.081 --> 00:15:54.521 align:middle
对客户端和服务器
更高的系统需求和更低的性能

00:15:58.392 --> 00:16:01.562 align:middle
去年我们在NSURL会话中
加入了SPDY支持

00:15:58.392 --> 00:16:01.562 align:middle
去年我们在NSURL会话中
加入了SPDY支持

00:16:02.596 --> 00:16:04.865 align:middle
SPDY是使网络更快的一种尝试

00:16:05.465 --> 00:16:07.234 align:middle
它是一种实验性协议

00:16:07.534 --> 00:16:13.106 align:middle
但是它被选作
新版HTTP协议的基础之一

00:16:14.208 --> 00:16:20.681 align:middle
新协议的标准版本在上个月
通过了IETF标准

00:16:20.948 --> 00:16:24.551 align:middle
并正式分配到了一个RFC编号

00:16:25.619 --> 00:16:27.688 align:middle
所以今天
就像你已经知道的那样

00:16:28.589 --> 00:16:33.660 align:middle
NSURL会话
扩展支持HTTP/2协议

00:16:36.063 --> 00:16:37.731 align:middle
让我们看一下

00:16:37.731 --> 00:16:40.534 align:middle
HTTP/1.1
和HTTP/2的主要区别

00:16:41.869 --> 00:16:43.770 align:middle
与HTTP/1.1相对

00:16:44.171 --> 00:16:48.141 align:middle
HTTP/2仅支持
一台主机开放一个TCP连接

00:16:49.476 --> 00:16:55.249 align:middle
它是网络友好的
并且对客户端和主机要更少的系统资源

00:16:57.784 --> 00:17:00.254 align:middle
HTTP/2完全多路复用

00:16:57.784 --> 00:17:00.254 align:middle
HTTP/2完全多路复用

00:17:00.988 --> 00:17:01.822 align:middle
这就意味着

00:17:01.889 --> 00:17:08.060 align:middle
一个新的请求不需要等到服务器
对前一个请求回复之后

00:17:09.863 --> 00:17:12.833 align:middle
HTTP/2有请求优先级

00:17:13.400 --> 00:17:18.939 align:middle
所以更多重要的资源可以优先提供给
拥有更高权限的客户端

00:17:24.411 --> 00:17:25.279 align:middle
让我们看一下

00:17:25.345 --> 00:17:30.684 align:middle
HTTP/2多路复用
如何解决队首阻塞问题

00:17:32.085 --> 00:17:35.422 align:middle
在一个服务器上
我们有三个对资源的请求

00:17:36.990 --> 00:17:40.861 align:middle
我们发出第一个请求
并得到一个回复

00:17:41.995 --> 00:17:47.401 align:middle
这之后我们发送第二个请求
并得到第二个回复

00:17:47.901 --> 00:17:51.004 align:middle
对第三个请求也是一样

00:17:53.907 --> 00:17:55.709 align:middle
现在启用通道

00:17:56.610 --> 00:17:58.579 align:middle
我们同时发送所有的请求

00:17:59.213 --> 00:18:03.517 align:middle
一个接一个
不需要等到收到之前的回复

00:17:59.213 --> 00:18:03.517 align:middle
一个接一个
不需要等到收到之前的回复

00:18:05.285 --> 00:18:09.623 align:middle
但是我们仍然按顺序得到了回复

00:18:10.724 --> 00:18:13.794 align:middle
你能够看到
蓝色的图片是第一个回复

00:18:15.229 --> 00:18:17.097 align:middle
阻塞了紧随其后的两个回复

00:18:20.667 --> 00:18:25.572 align:middle
通过HTTP/2
我们给三个请求赋予不同的优先级

00:18:27.007 --> 00:18:30.844 align:middle
我们仍然在开始的时候
同时发送所以的请求

00:18:32.246 --> 00:18:35.415 align:middle
但是我们同时得到了回复

00:18:38.151 --> 00:18:42.089 align:middle
此外 优先级更高的请求

00:18:43.490 --> 00:18:45.659 align:middle
我得到以及发送给客户端的速度更快

00:18:46.860 --> 00:18:52.833 align:middle
你可以看到第二个回复的是中等优先级

00:18:52.833 --> 00:18:56.603 align:middle
并且第三个回复的是高优先级的请求

00:18:57.304 --> 00:19:02.209 align:middle
到达得比第一个回复更早
即使他们在时间表中更靠后

00:18:57.304 --> 00:19:02.209 align:middle
到达得比第一个回复更早
即使他们在时间表中更靠后

00:19:02.910 --> 00:19:05.245 align:middle
图片也不再阻塞他们

00:19:05.412 --> 00:19:08.782 align:middle
这非常棒
且对你的程序和性能来说也非常棒

00:19:10.617 --> 00:19:12.719 align:middle
让我们来继续对比

00:19:15.689 --> 00:19:18.192 align:middle
HTTP/2是一个二进制协议

00:19:20.460 --> 00:19:24.398 align:middle
这使得数据的处理和解析速度更快

00:19:25.599 --> 00:19:30.003 align:middle
HTTP/1.1不使用头压缩

00:19:30.671 --> 00:19:35.409 align:middle
因为安全漏洞的原因
SPDY同样也不能使用头压缩

00:19:36.243 --> 00:19:41.381 align:middle
HTTP/2使用HPACK
这是一种更加安全的头压缩机制

00:19:43.851 --> 00:19:45.118 align:middle
让我来介绍一下HPACk

00:19:48.021 --> 00:19:50.657 align:middle
HPACK头压缩基于两个表

00:19:51.325 --> 00:19:53.760 align:middle
一个静态表
一个动态表

00:19:55.329 --> 00:20:00.767 align:middle
静态表包括最常用的HTTP信息头
并且不可修改

00:19:55.329 --> 00:20:00.767 align:middle
静态表包括最常用的HTTP信息头
并且不可修改

00:20:03.070 --> 00:20:08.876 align:middle
包含在静态表中的信息头
可以添加到动态表中

00:20:10.210 --> 00:20:13.680 align:middle
表中的信息头可以通过指针进行引用

00:20:15.582 --> 00:20:19.486 align:middle
例如你可以看到
一个简单的HTTP/1.1请求

00:20:20.921 --> 00:20:23.991 align:middle
突出显示的部分
是要发送到服务器的数据

00:20:26.460 --> 00:20:31.164 align:middle
这里是一个基于
HTTP/2的相同的请求

00:20:32.232 --> 00:20:33.901 align:middle
接下来让我们将这个请求编码

00:20:36.370 --> 00:20:42.209 align:middle
伪信息头 方法 计划以及路径

00:20:43.377 --> 00:20:46.013 align:middle
都可以通过静态表进行引用

00:20:47.748 --> 00:20:52.653 align:middle
主信息头包括在静态表中
但是并不包含其值

00:20:53.687 --> 00:20:55.255 align:middle
所以要编码这个请求

00:20:55.989 --> 00:21:01.094 align:middle
我们需要三个字节用来存放第一组三头

00:20:55.989 --> 00:21:01.094 align:middle
我们需要三个字节用来存放第一组三头

00:21:01.328 --> 00:21:05.465 align:middle
加上一个告诉你我们想要将主信息头

00:21:05.532 --> 00:21:08.669 align:middle
添加到动态表中的字节

00:21:09.169 --> 00:21:13.006 align:middle
以及主信息头的值和长度

00:21:16.677 --> 00:21:20.214 align:middle
这就是要发送到服务器

00:21:20.614 --> 00:21:24.151 align:middle
添加了额外开销的信息头框架

00:21:26.720 --> 00:21:28.055 align:middle
现在对于第二个请求

00:21:30.290 --> 00:21:33.327 align:middle
你可以看到主信息头存储在
动态表中

00:21:33.961 --> 00:21:35.195 align:middle
所以对于第二个请求

00:21:35.395 --> 00:21:41.335 align:middle
HTTP/1.1将会
一遍又一遍地发送相同的信息头

00:21:43.570 --> 00:21:46.974 align:middle
但是在HTTP/2中
在通常情况下

00:21:47.241 --> 00:21:49.309 align:middle
我们可以通过静态表和动态表

00:21:50.244 --> 00:21:53.213 align:middle
引用所有的信息头

00:21:53.380 --> 00:21:55.582 align:middle
我们只需要一个字节来存放一个信息头

00:21:56.149 --> 00:21:57.918 align:middle
这相当节约带宽

00:21:58.285 --> 00:22:00.921 align:middle
这只需要如此少的字节

00:21:58.285 --> 00:22:00.921 align:middle
这只需要如此少的字节

00:22:01.355 --> 00:22:05.526 align:middle
就能够使用HTTP/2编码
一个请求或者回复信息头

00:22:10.230 --> 00:22:11.365 align:middle
接下来让我讲一下

00:22:11.431 --> 00:22:14.601 align:middle
要为你的程序
适配HTTP/2协议需要做些什么

00:22:16.270 --> 00:22:17.738 align:middle
其工作量并不大

00:22:18.772 --> 00:22:24.077 align:middle
HTTP/2被无缝集成到了
NSURL会话的API中

00:22:25.345 --> 00:22:27.881 align:middle
如果你已经在你的代码中
使用了NSURL会话

00:22:29.550 --> 00:22:34.521 align:middle
你的程序和OS X程序
将会自动获得这种功能

00:22:35.756 --> 00:22:38.091 align:middle
你不需要写另外的代码

00:22:38.358 --> 00:22:43.797 align:middle
或者添加其他的结构来启动它

00:22:44.398 --> 00:22:46.400 align:middle
让我们来看一下源代码实例

00:22:46.967 --> 00:22:51.638 align:middle
这段源代码和你已经在程序中
使用的代码看起来非常相像

00:22:52.139 --> 00:22:55.943 align:middle
可以看到
没有任何不同也没有新的结构标志

00:22:56.176 --> 00:22:57.311 align:middle
这样就可以使用

00:23:06.053 --> 00:23:09.990 align:middle
是的
你只需要一个HTTP/2服务器

00:23:11.725 --> 00:23:12.593 align:middle
但是这不是问题

00:23:17.030 --> 00:23:22.135 align:middle
你的应用程序已经准备好了
使用HTTP/2协议来进行通信

00:23:22.569 --> 00:23:25.639 align:middle
如果你还没有
部署一个HTTP/2服务器

00:23:26.673 --> 00:23:30.777 align:middle
那么你的应用程序
将会直接使用HTTP/1.1

00:23:31.512 --> 00:23:36.483 align:middle
或者会自动选择最优的可选的协议
用来进行网络通信

00:23:37.284 --> 00:23:41.054 align:middle
一旦你开始使用
支持HTTP/2的网络服务器

00:23:41.755 --> 00:23:43.924 align:middle
你就不再需要做额外的工作

00:23:44.725 --> 00:23:48.061 align:middle
你的应用程序将会
自动使用HTTP/2协议

00:23:56.503 --> 00:23:57.371 align:middle
请记住

00:23:57.905 --> 00:24:03.577 align:middle
NSURL会话只在加密连接上
支持HTTP/2协议

00:23:57.905 --> 00:24:03.577 align:middle
NSURL会话只在加密连接上
支持HTTP/2协议

00:24:04.845 --> 00:24:07.414 align:middle
这样你的HTTP/2服务器

00:24:07.748 --> 00:24:12.352 align:middle
需要支持ALPN或者NPN
用来进行协议对接

00:24:16.990 --> 00:24:18.025 align:middle
目前在Apple

00:24:18.292 --> 00:24:20.761 align:middle
通过iCloud
远程访问HomeKit

00:24:20.827 --> 00:24:23.964 align:middle
就是在HomeKit配件
和iCloud之间

00:24:23.964 --> 00:24:27.801 align:middle
使用HTTP/2协议进行通信

00:24:29.036 --> 00:24:32.172 align:middle
很多大公司已经
开始使用HTTP/2协议了

00:24:32.673 --> 00:24:35.175 align:middle
Google为其服务
也配置了HTTP/2

00:24:35.909 --> 00:24:38.278 align:middle
Twitter也使用了HTTP/2

00:24:39.413 --> 00:24:43.450 align:middle
有非常多的HTTP/2
开放资源网络服务器

00:24:44.318 --> 00:24:51.024 align:middle
最后一些CDN服务提供商
也在逐步提供HTTP/2协议支持

00:24:55.062 --> 00:24:59.132 align:middle
我们努力使
HTTP/2能够支持NSURL会话

00:24:59.366 --> 00:25:03.270 align:middle
这样你们就可以非常容易地配置
使用HTTP/2协议

00:24:59.366 --> 00:25:03.270 align:middle
这样你们就可以非常容易地配置
使用HTTP/2协议

00:25:04.137 --> 00:25:07.674 align:middle
HTTP/2今天在
WWDC种子中也是可选的

00:25:08.208 --> 00:25:12.246 align:middle
它无缝集成在NSURL会话API中

00:25:12.746 --> 00:25:17.818 align:middle
并能够在OS X 10.11和
iOS 9中的Safari上使用

00:25:19.553 --> 00:25:20.387 align:middle
谢谢

00:25:21.188 --> 00:25:24.091 align:middle
现在我想邀请丹上台

00:25:24.591 --> 00:25:25.425 align:middle
丹？

00:25:31.598 --> 00:25:32.432 align:middle
早上好各位

00:25:32.733 --> 00:25:33.767 align:middle
我叫丹

00:25:33.767 --> 00:25:36.303 align:middle
我是一个软件工程师
在苹果公司CF网络项目组工作

00:25:36.637 --> 00:25:38.472 align:middle
我想讲的第一件事情是

00:25:38.539 --> 00:25:41.041 align:middle
今天已经可以在WatchOS上
使用NSURL会话了

00:25:42.276 --> 00:25:43.677 align:middle
通过本周前几天

00:25:43.744 --> 00:25:47.281 align:middle
与WatchOS 2测试版
一起发布的WatchKit SDK

00:25:47.614 --> 00:25:48.649 align:middle
我很高兴能告诉大家

00:25:48.715 --> 00:25:51.518 align:middle
WatchOS
完全支持HTTPS加载

00:25:52.686 --> 00:25:54.988 align:middle
这就意味着
我们今天已经讲的所有的东西

00:25:55.055 --> 00:25:58.825 align:middle
例如App Transport Security
和HTTP/2都支持HTTPS

00:26:00.661 --> 00:26:04.198 align:middle
在WatchOS使用NSURL会话

00:26:04.264 --> 00:26:07.301 align:middle
和在其他平台上使用的
主要区别是在后台运行

00:26:07.301 --> 00:26:11.271 align:middle
事实上我们会选择所有选项中
最好的连接机制

00:26:12.005 --> 00:26:14.041 align:middle
这就意味着
在大多数情况下

00:26:14.408 --> 00:26:17.778 align:middle
如果用户的手表
靠近了配对的iPhone设备

00:26:18.212 --> 00:26:21.315 align:middle
我们会利用他们之间的蓝牙连接

00:26:21.481 --> 00:26:27.187 align:middle
通过手机本身的HTTP加载
并将结果通过蓝牙回传给手表

00:26:28.288 --> 00:26:34.394 align:middle
如果带着手表的用户碰巧断开了
或者远离了他们的手机

00:26:34.661 --> 00:26:37.664 align:middle
手表将会连接到已知的Wi-Fi网络
这样我们可以直接使用网络了

00:26:38.332 --> 00:26:42.369 align:middle
好消息是
这些所有的工作都是脱离API进行的

00:26:42.369 --> 00:26:45.072 align:middle
当你在其他平台上的时候
你可以使用API

00:26:45.072 --> 00:26:46.773 align:middle
你不需要关心我们是如何连接的

00:26:47.040 --> 00:26:48.375 align:middle
它就像魔法一样

00:26:50.444 --> 00:26:53.247 align:middle
就如之前所说 在WatchOS
上使用NSURL会话时

00:26:53.247 --> 00:26:55.983 align:middle
只需要关注
少数几个最佳方法和事情即可

00:26:56.717 --> 00:27:00.721 align:middle
首先你应该尽可能的
只下载最小的安装包

00:26:56.717 --> 00:27:00.721 align:middle
首先你应该尽可能的
只下载最小的安装包

00:27:00.721 --> 00:27:02.756 align:middle
这其实是你的程序的功能的要求

00:27:03.390 --> 00:27:06.827 align:middle
请注意 手表只有一个非常小的屏幕

00:27:07.160 --> 00:27:08.495 align:middle
所以如果你要下载图片

00:27:08.562 --> 00:27:13.467 align:middle
不需下载在iPhone6 Plus
或配有Retina显示屏的Mac上

00:27:13.534 --> 00:27:15.335 align:middle
显示的完全分辨率图片

00:27:15.702 --> 00:27:18.272 align:middle
它的屏幕太小了
你可以下载小一点的图片

00:27:18.939 --> 00:27:20.507 align:middle
另外请记住

00:27:20.707 --> 00:27:26.046 align:middle
手表比手机或电脑的处理能力要小很多

00:27:26.580 --> 00:27:31.785 align:middle
并且会经常受到带宽
和与你手机的蓝牙连接的延迟的限制

00:27:32.019 --> 00:27:34.321 align:middle
所以你并不能够真正
如同在其他平台上一样

00:27:34.321 --> 00:27:35.923 align:middle
快速地下载字节到手表上

00:27:35.923 --> 00:27:37.124 align:middle
所以也请记住这一点

00:27:38.859 --> 00:27:40.294 align:middle
另一个需要注意的是

00:27:40.561 --> 00:27:44.431 align:middle
手表上的程序运行时间

00:27:44.498 --> 00:27:46.800 align:middle
比iPhone或Mac上的程序
运行时间短很多

00:27:47.201 --> 00:27:49.269 align:middle
用户会受到严重的时间限制

00:27:49.269 --> 00:27:52.940 align:middle
如果他想要坐着或者站着
并举起手腕盯着手表和它互动

00:27:54.408 --> 00:27:58.645 align:middle
所以如果你使用的是默认会话配置
或者临时会话配置

00:27:59.112 --> 00:28:04.651 align:middle
请记住这些网络传输
只会在你的程序真正运行的时候进行

00:27:59.112 --> 00:28:04.651 align:middle
请记住这些网络传输
只会在你的程序真正运行的时候进行

00:28:05.352 --> 00:28:08.121 align:middle
所以如果你要发送少量的数据
是完全没问题

00:28:08.121 --> 00:28:10.557 align:middle
例如股票报价或者天气数据

00:28:10.924 --> 00:28:12.593 align:middle
亦或者社交网络状态更新

00:28:13.093 --> 00:28:16.029 align:middle
但是对于任何比较大的内容
例如视频

00:28:16.029 --> 00:28:18.165 align:middle
你会想用后台上传或者下载

00:28:18.498 --> 00:28:22.035 align:middle
这样就能在过程结束时继续

00:28:22.302 --> 00:28:24.171 align:middle
要了解更多有关后台上传下载的信息

00:28:24.238 --> 00:28:29.309 align:middle
我强烈建议你看看
前几年基础网络大会上的WWDC会话

00:28:33.347 --> 00:28:37.484 align:middle
接下来我想讲一下
我们在今年发布的API中做的修改

00:28:38.585 --> 00:28:40.954 align:middle
我要讲的第一件事情是NSURL连接

00:28:40.954 --> 00:28:42.890 align:middle
这个东西我们到现在为止都还没有讲过

00:28:43.457 --> 00:28:44.291 align:middle
所以今年

00:28:44.358 --> 00:28:49.196 align:middle
我宣布OS X EI旗舰版及
IOS9将放弃使用NSURL连接

00:28:50.163 --> 00:28:52.599 align:middle
让我们花一点时间
来想一下这意味着什么

00:28:52.666 --> 00:28:56.703 align:middle
放弃使用并不意味着
NSURL连接将会被完全放弃

00:28:56.770 --> 00:29:00.040 align:middle
我知道有很多程序
都在使用NSURL连接

00:28:56.770 --> 00:29:00.040 align:middle
我知道有很多程序
都在使用NSURL连接

00:29:00.240 --> 00:29:01.542 align:middle
我们并不会损坏它们

00:29:01.942 --> 00:29:04.077 align:middle
所以它仍然可以运行
这些传输方法仍然可以使用

00:29:04.945 --> 00:29:09.850 align:middle
但是请记住
新功能只会添加到NSURL会话中

00:29:11.552 --> 00:29:14.855 align:middle
我们强烈建议你
将现存的NSURL连接代码

00:29:15.155 --> 00:29:18.158 align:middle
转换成NSURL会话代码
如果你还没有转换的话

00:29:19.393 --> 00:29:20.928 align:middle
如果你正在写一段新代码

00:29:21.528 --> 00:29:24.364 align:middle
我们真心希望你只使用NSURL会话
而不是NSURL连接

00:29:25.699 --> 00:29:26.834 align:middle
另一件需要注意的事情是

00:29:26.834 --> 00:29:29.937 align:middle
在WatchOS上
完全不支持NSURL连接

00:29:30.070 --> 00:29:33.073 align:middle
所以如果你要从WatchKit
扩展程序上加载HTTP内容

00:29:33.140 --> 00:29:34.708 align:middle
你只能使用NSURL会话

00:29:35.409 --> 00:29:37.544 align:middle
但如果你还没有完成
那你是幸运的

00:29:37.544 --> 00:29:39.947 align:middle
从NSURL连接到
NSURL会话的转换

00:29:39.947 --> 00:29:40.914 align:middle
会非常简单

00:29:41.248 --> 00:29:43.083 align:middle
现在我想通过一个例子向你们展示一下

00:29:44.618 --> 00:29:47.020 align:middle
这是NSURL连接的一个简单使用

00:29:47.087 --> 00:29:49.256 align:middle
<br/>
用来实现一个异步的HTTP请求

00:29:49.256 --> 00:29:52.359 align:middle
它可能和你的程序中
经常使用的方法有点相似

00:29:52.960 --> 00:29:57.931 align:middle
现在我们通过HTTPS连接
www.example.com

00:29:57.965 --> 00:30:00.367 align:middle
我们通过一个NSURL对象来表示

00:29:57.965 --> 00:30:00.367 align:middle
我们通过一个NSURL对象来表示

00:30:01.168 --> 00:30:04.805 align:middle
然后我们构造一个
NSURLRequest对URL进行打包

00:30:05.672 --> 00:30:09.142 align:middle
我们通过NSURL连接的
“发送异步请求”方法

00:30:09.510 --> 00:30:11.979 align:middle
来出发这个异步请求

00:30:12.546 --> 00:30:15.949 align:middle
之后我们以一个闭包的形式接收到结果

00:30:16.817 --> 00:30:21.889 align:middle
接收到的结果包含一个NSURL
响应对象作为HTTP响应信息头

00:30:22.422 --> 00:30:26.360 align:middle
这个相应对象作为HTTP响应信息头
和NSData对象作为响应的主体数据

00:30:26.560 --> 00:30:28.195 align:middle
如果传输发生错误则接收到一个报错

00:30:29.263 --> 00:30:32.232 align:middle
看一下如果使用NSURL会话
实现起来会是什么样子

00:30:33.634 --> 00:30:34.568 align:middle
它非常相似

00:30:34.735 --> 00:30:38.972 align:middle
你会注意到
NSURL和NSURL请求对象仍然在使用

00:30:38.972 --> 00:30:42.743 align:middle
这对于很多其他的NSURL家族对象
来讲是正确的

00:30:42.743 --> 00:30:47.181 align:middle
例如NSURL Credential Storage
和NSHTTP Cookie Storage

00:30:47.447 --> 00:30:48.582 align:middle
其主要区别是

00:30:48.582 --> 00:30:51.885 align:middle
我们不使用NSURL连接
来发送异步请求这种方法

00:30:52.252 --> 00:30:58.392 align:middle
我们使用NSURL会话共享会话中的
“数据任务请求”方法

00:30:59.560 --> 00:31:00.928 align:middle
一旦我们恢复任务

00:30:59.560 --> 00:31:00.928 align:middle
一旦我们恢复任务

00:31:01.028 --> 00:31:05.065 align:middle
我们就能够再次接收到
异步地接收到事务处理的结果

00:31:05.432 --> 00:31:08.635 align:middle
以回复数据的格式
回复信息头

00:31:08.635 --> 00:31:11.171 align:middle
如果传输发生错误则接收到一个报错

00:31:12.272 --> 00:31:14.341 align:middle
在你的程序中

00:31:14.408 --> 00:31:17.177 align:middle
将NSURL连接转换成NSURL会话
非常简单

00:31:19.279 --> 00:31:20.514 align:middle
接下来我想换个话题

00:31:20.514 --> 00:31:24.952 align:middle
讲一下我们在API的
NSURL会话家族中添加的新功能

00:31:26.153 --> 00:31:29.022 align:middle
我要讲的第一件
就是对cookie的处理

00:31:30.324 --> 00:31:31.859 align:middle
在去年的WWDC上

00:31:31.925 --> 00:31:34.795 align:middle
我们介绍了一个新的功能
叫做应用程序扩展

00:31:35.062 --> 00:31:38.599 align:middle
它允许你在系统的其他地方
嵌入你应用程序的部分功能

00:31:38.599 --> 00:31:39.933 align:middle
例如通知中心

00:31:41.602 --> 00:31:47.174 align:middle
但是应用程序和他们的扩展
在默认情况下拥有不同的数据存储器

00:31:47.241 --> 00:31:49.476 align:middle
这就意味着即使你使用NSURL会话

00:31:49.476 --> 00:31:53.213 align:middle
且已经使用了
我们内置的cookie进行支持处理

00:31:53.480 --> 00:31:55.849 align:middle
这些cookie实际上仍然被存储在
不同的地方

00:31:57.751 --> 00:32:00.087 align:middle
但是你可以使用应用程序组

00:31:57.751 --> 00:32:00.087 align:middle
但是你可以使用应用程序组

00:32:00.254 --> 00:32:03.090 align:middle
来访问共享数据存储器

00:32:03.090 --> 00:32:05.692 align:middle
这个存储器无论是你的应用程序
还是其扩展部分都可以访问

00:32:06.059 --> 00:32:08.328 align:middle
今年我们发布了新的API

00:32:08.562 --> 00:32:11.632 align:middle
你能够创建一个与组存储器
相关联的cookie存储

00:32:12.432 --> 00:32:14.034 align:middle
我将要向你们展示一下怎样实现它

00:32:14.601 --> 00:32:19.173 align:middle
这里你需要用到的
是NSHTTP cookie存储中

00:32:19.173 --> 00:32:22.009 align:middle
新增的“共享cookie组存储器
标识符”方法

00:32:22.576 --> 00:32:24.778 align:middle
你只需要简单地
创建一个cookie存储

00:32:24.845 --> 00:32:28.215 align:middle
并输入你的应用程序组的名字

00:32:28.749 --> 00:32:33.086 align:middle
在你用Xcode编辑工程的
编译设置选项和打开功能选项卡时

00:32:33.086 --> 00:32:34.188 align:middle
程序组就已经被配置好了

00:32:35.622 --> 00:32:37.224 align:middle
当你创建好cookie存储的时候

00:32:37.457 --> 00:32:43.330 align:middle
你只需像设置NSURL会话配置对象中的
HTTP cookie存储属性一样设置它

00:32:43.964 --> 00:32:46.500 align:middle
从配置中创建一个NSURL会话

00:32:46.533 --> 00:32:49.903 align:middle
之后你在这个会话中进行的任何任务

00:32:50.070 --> 00:32:52.306 align:middle
都会使用组存储器中的
cookie存储

00:32:56.476 --> 00:32:58.779 align:middle
所以对于今天演示的所有内容

00:32:58.779 --> 00:33:03.183 align:middle
我们讲解了
使用NSURL加载HTTP内容

00:32:58.779 --> 00:33:03.183 align:middle
我们讲解了
使用NSURL加载HTTP内容

00:33:04.218 --> 00:33:08.121 align:middle
但是仍然有一些情况需要你使用一个
除了HTTP或者HTTPS之外的

00:33:08.188 --> 00:33:10.023 align:middle
其他的协议

00:33:10.557 --> 00:33:13.594 align:middle
所以如果你正在开发一个聊天软件

00:33:14.728 --> 00:33:20.434 align:middle
一个视频调用软件
或一切这一类的其他软件

00:33:20.434 --> 00:33:23.637 align:middle
你真的需要...
你可能需要一个非HTTP的协议

00:33:23.637 --> 00:33:28.242 align:middle
你想要直接在
TCP/IP网络上做一些事情

00:33:28.775 --> 00:33:31.845 align:middle
所以今年发布了一个新的API
叫做NSURL会话工作流

00:33:32.012 --> 00:33:35.449 align:middle
这是一个底层提取文件
直接在TCP连接层上

00:33:36.550 --> 00:33:39.753 align:middle
在过去你可能
直接使用NSInput流

00:33:39.753 --> 00:33:42.656 align:middle
或者NSOutput
留来做一些相似的事情

00:33:42.890 --> 00:33:48.061 align:middle
但是我们认为NSURL会话工作流
有在NSStream API的优点

00:33:48.662 --> 00:33:53.033 align:middle
首先它提供了一个
非常简单方便的异步读写接口

00:33:53.767 --> 00:33:55.169 align:middle
通过NSStream

00:33:55.235 --> 00:33:59.640 align:middle
你需要设置一个委托来监听事件
或者何时读入或者何时屏蔽读写

00:33:59.640 --> 00:34:02.509 align:middle
从前这样做会有点乱
但是现在变得简单清晰了很多

00:33:59.640 --> 00:34:02.509 align:middle
从前这样做会有点乱
但是现在变得简单清晰了很多

00:34:03.677 --> 00:34:04.511 align:middle
第二

00:34:05.078 --> 00:34:09.449 align:middle
NSURL会话内置了强大的支持功能
能够自动通过HTTP代理

00:34:09.850 --> 00:34:12.418 align:middle
NSURL会话工作流
可以利用这种支持

00:34:12.418 --> 00:34:14.788 align:middle
这样你就能够连接一个远程的服务器

00:34:15.022 --> 00:34:18.525 align:middle
即使在这之间有一个HTTP代理
但是NSStream不能够这样做

00:34:19.359 --> 00:34:21.428 align:middle
API还有一些其他的新的升级

00:34:21.428 --> 00:34:23.030 align:middle
这些我也将随后进行介绍

00:34:24.498 --> 00:34:26.900 align:middle
我们都知道NSStream
是一个非常流行的API

00:34:26.900 --> 00:34:32.306 align:middle
也有很多其他的构架和API中
兼容并使用了NSStream对象

00:34:32.806 --> 00:34:35.809 align:middle
所以我们也有一些与
NSStream相兼容的支撑部分

00:34:35.809 --> 00:34:37.411 align:middle
这些我也将在之后为你们呈现

00:34:39.513 --> 00:34:43.650 align:middle
所以就像我说的
MNSURL会话工作流支持TCP/IP连接

00:34:43.951 --> 00:34:47.020 align:middle
你可以明确地通过一个主机名称和端口
创建一个连接

00:34:47.321 --> 00:34:50.157 align:middle
或者你可以使用
NSNetService的API

00:34:51.291 --> 00:34:53.193 align:middle
在你的应用程序中
查找Bonjour服务

00:34:53.527 --> 00:34:57.097 align:middle
之后我们能够接受
NSNetService为你自动解决问题

00:34:58.632 --> 00:35:02.503 align:middle
工作流使用了
现存的NSURL会话配置选项

00:34:58.632 --> 00:35:02.503 align:middle
工作流使用了
现存的NSURL会话配置选项

00:35:02.503 --> 00:35:05.839 align:middle
和委托方法来向你传达事件

00:35:07.374 --> 00:35:10.410 align:middle
当然我们支持TLS安全连接

00:35:10.410 --> 00:35:14.214 align:middle
一旦你确实与服务器建立了一个连接
你甚至能够进行动态修改

00:35:16.416 --> 00:35:20.287 align:middle
所以让我们看一下
你怎样使用工作流来实现一个读取操作

00:35:20.854 --> 00:35:22.222 align:middle
首先创建一个工作流

00:35:22.289 --> 00:35:26.493 align:middle
这样你就能够简单地使用
“带有主机地址和端口的工作流”

00:35:26.627 --> 00:35:29.363 align:middle
你只需要输入你想要连接的
主机名和端口号

00:35:30.330 --> 00:35:31.999 align:middle
然后恢复任务后

00:35:32.432 --> 00:35:36.336 align:middle
你可以使用“读取最短长度
最长长度、或者超时”等方法

00:35:37.137 --> 00:35:41.241 align:middle
你需要做的就是
输入一个你要读取的字节范围

00:35:41.441 --> 00:35:42.943 align:middle
或者操作超时的时限

00:35:43.343 --> 00:35:45.579 align:middle
所以如果我们准备
读取范围内的东西

00:35:45.579 --> 00:35:49.416 align:middle
或者我们遇到了一个EOF
或者发生了传输错误或者超时

00:35:49.416 --> 00:35:52.052 align:middle
我们将会调用存储结果的闭包

00:35:53.253 --> 00:35:54.521 align:middle
写入操作非常相似

00:35:55.556 --> 00:35:58.992 align:middle
我们不像...通过NSStream
我们可以直接操作NSData

00:35:58.992 --> 00:36:01.195 align:middle
你只需要输入
你想要我们写入的NSData对象

00:35:58.992 --> 00:36:01.195 align:middle
你只需要输入
你想要我们写入的NSData对象

00:36:01.195 --> 00:36:03.263 align:middle
以及再次输入一个超时门限

00:36:03.530 --> 00:36:05.732 align:middle
在出现错误时
这个内容为零的闭包将会被调用

00:36:05.732 --> 00:36:09.870 align:middle
当这个操作成功或者发生了超时错误
或者发生了传输错误

00:36:11.371 --> 00:36:16.276 align:middle
启用TLS和对这个任务调用
“打开安全连接”的思想一样简单

00:36:19.112 --> 00:36:19.947 align:middle
我之前提到了

00:36:20.013 --> 00:36:25.152 align:middle
我们有配合NSStream工作的
内置支持NSURL会话工作流

00:36:25.586 --> 00:36:27.487 align:middle
我们这样做的原因是

00:36:27.487 --> 00:36:30.591 align:middle
有非常多的API已经
使用了NSStream对象

00:36:30.591 --> 00:36:33.360 align:middle
我们希望为你提供一些东西
能够和这些API兼容

00:36:34.027 --> 00:36:38.065 align:middle
事实上你可以将NSURL会话工作流
转换成NSStream

00:36:38.131 --> 00:36:40.834 align:middle
在下一张幻灯片上我会用
非常简单的代码来为你们演示一下

00:36:41.335 --> 00:36:42.903 align:middle
只需要记住当你做这些的时候

00:36:42.970 --> 00:36:48.041 align:middle
任何你使用工作流加入队列中
挂起的异步读写任务

00:36:48.308 --> 00:36:50.210 align:middle
都将在我们给
你NSStream之前完成

00:36:50.644 --> 00:36:53.647 align:middle
这样的操作也会从会话中分离出任务

00:36:54.014 --> 00:36:55.082 align:middle
所以这个链接

00:36:55.315 --> 00:36:58.619 align:middle
底层链接将不再计入限制

00:36:58.619 --> 00:37:02.022 align:middle
你可以为你的主机
设置一个会话链接的最大数量

00:36:58.619 --> 00:37:02.022 align:middle
你可以为你的主机
设置一个会话链接的最大数量

00:37:03.056 --> 00:37:07.728 align:middle
它也不再在会话设置中突出任务选项

00:37:08.729 --> 00:37:10.697 align:middle
所以要将一个工作流转换成流

00:37:10.697 --> 00:37:13.800 align:middle
你只需要在任务中简单地
调用‘Capture Streams’方法

00:37:14.168 --> 00:37:19.873 align:middle
之后这些输入和输出流将会
给你的委托发送一个新的委托消息

00:37:22.042 --> 00:37:26.780 align:middle
我们同样有许多已经添加到
工作流中的其他委托消息

00:37:26.847 --> 00:37:27.981 align:middle
第一个很有意思

00:37:27.981 --> 00:37:30.517 align:middle
这是一个为工作流寻找更优路径的方法

00:37:31.118 --> 00:37:36.023 align:middle
所以如果你有一个工作流
通过蜂窝数据网络连接到了你的服务器

00:37:36.423 --> 00:37:39.259 align:middle
如果用户新加入一个Wi-Fi网络

00:37:39.426 --> 00:37:43.163 align:middle
之后我们会发送这个通知到你的程序
告诉你可能会有更好的连接路径

00:37:43.830 --> 00:37:46.099 align:middle
在这种情况下你可能想要做的

00:37:46.300 --> 00:37:49.303 align:middle
如果你想要做的话
就是清除你现存的工作流

00:37:49.369 --> 00:37:52.806 align:middle
并创建一个新的工作流
到那台主机和端口

00:37:54.508 --> 00:37:56.610 align:middle
并尝试通过更好的链接进行连接

00:37:56.877 --> 00:37:59.613 align:middle
我们将这个决定权
留给你决定是否要这么做

00:38:00.280 --> 00:38:03.350 align:middle
如果你在传输一个很大的数据
并已经完成了99%

00:38:03.417 --> 00:38:07.054 align:middle
就没有必要清除现存的连接
并创建一个新的连接

00:38:08.021 --> 00:38:10.724 align:middle
当读写双方的后台TCP连接
已经被关闭时

00:38:10.791 --> 00:38:13.861 align:middle
我们也要告诉你一些信息委托方法

00:38:16.763 --> 00:38:21.468 align:middle
我之前也提到了
通过工作流对HTTP代理的自动处理

00:38:21.902 --> 00:38:24.004 align:middle
针对这种情况
你能够做的就是

00:38:24.304 --> 00:38:28.809 align:middle
打开一个正在处理HTTP内容的
NSURL会话数据工作

00:38:29.109 --> 00:38:30.711 align:middle
并将其转换成一个工作流

00:38:31.612 --> 00:38:35.015 align:middle
当接收到数据工作的回复时
你可以做这些

00:38:36.216 --> 00:38:38.519 align:middle
所以要将一个数据工作转换成工作流

00:38:38.519 --> 00:38:42.256 align:middle
让你能不通过HTTP构架
直接在HTTP连接层直接通信

00:38:42.689 --> 00:38:46.126 align:middle
通过“确实接到回复”委托方法

00:38:46.126 --> 00:38:48.161 align:middle
你能够简单地
对这个完成处理器进行回复

00:38:48.161 --> 00:38:50.264 align:middle
利用最新的“成为流”设置

00:38:50.931 --> 00:38:52.866 align:middle
然后你会通知你的委托

00:38:53.166 --> 00:38:55.736 align:middle
通过使用“URL会话数据任务
确实成为了工作流”方法

00:38:55.802 --> 00:38:59.206 align:middle
数据任务已经转换成为工作流

00:39:02.009 --> 00:39:03.110 align:middle
在结束今天的演讲前

00:39:03.177 --> 00:39:06.446 align:middle
我想要回顾一下
今天早上讨论的几件事情

00:39:07.347 --> 00:39:11.018 align:middle
第一件事情是怎样使用
App Transport Security

00:39:11.318 --> 00:39:14.555 align:middle
来保证你的应用程序
能够只建立安全连接

00:39:14.555 --> 00:39:17.457 align:middle
以及在需要的时候怎样申报异常情况

00:39:18.058 --> 00:39:20.127 align:middle
之后我们讲了
通过服务器上支持HTTP/2

00:39:20.127 --> 00:39:22.029 align:middle
怎样让你的应用程序能够更快

00:39:22.262 --> 00:39:25.599 align:middle
其不需要对客户端进行额外的修改

00:39:26.433 --> 00:39:29.970 align:middle
我们讲了在手表应用程序上
使用NSURL会话的最优方法

00:39:30.404 --> 00:39:33.941 align:middle
以及这次发布的新API做了哪些修改

00:39:34.007 --> 00:39:37.144 align:middle
NSURL连接的弃用
和如何迁移到会话

00:39:37.711 --> 00:39:40.280 align:middle
怎样在应用程序
和扩展之间共享cookie

00:39:40.681 --> 00:39:44.151 align:middle
以及如何获得一个很好的基础级别提取

00:39:44.151 --> 00:39:47.254 align:middle
如果你需要一个没有HTTP的服务器

00:39:47.287 --> 00:39:49.122 align:middle
使用TCP连接进行通信

00:39:51.758 --> 00:39:52.726 align:middle
像往常一样

00:39:52.793 --> 00:39:57.364 align:middle
我想提醒你们我们在
网站开放有参考文档

00:39:57.731 --> 00:40:00.801 align:middle
并提醒你参加开发者论坛

00:39:57.731 --> 00:40:00.801 align:middle
并提醒你参加开发者论坛

00:40:00.801 --> 00:40:03.937 align:middle
以及在这周的WWDC大会上
如果你有任何问题

00:40:04.104 --> 00:40:06.707 align:middle
你可以向我们的传播者
Paul Danbold请教

00:40:07.508 --> 00:40:10.978 align:middle
如果你想参加其他的相关会议的话

00:40:10.978 --> 00:40:12.546 align:middle
我强烈建议你参加明天的

00:40:12.713 --> 00:40:15.215 align:middle
“你的应用程序和下一代网络会议”

00:40:15.215 --> 00:40:17.584 align:middle
这是一个低层次的关于网络的讨论会

00:40:18.118 --> 00:40:21.321 align:middle
这周也将开放网络实验室

00:40:21.321 --> 00:40:23.357 align:middle
如果你有任何问题
你都可以直接和我们讨论

00:40:23.824 --> 00:40:25.559 align:middle
谢谢你们今天能够到来

00:40:25.993 --> 00:40:27.494 align:middle
我们希望看到

00:40:27.561 --> 00:40:29.363 align:middle
你们在IOS 9和OS X
和EI旗舰版和WatchOS 2上

00:40:29.429 --> 00:40:32.032 align:middle
能够开发一些惊艳的应用程序

00:40:32.232 --> 00:40:33.066 align:middle
谢谢
