WEBVTT

00:00:20.387 --> 00:00:24.091 align:middle
WatchKit in Depth
第一部分

00:00:31.365 --> 00:00:32.232 align:middle
诸位早上好！

00:00:32.299 --> 00:00:34.835 align:middle
欢迎参加WatchKit in Depth
第一部分的讲座

00:00:34.902 --> 00:00:37.604 align:middle
讲座分为两个环节
这是第一个环节

00:00:37.671 --> 00:00:40.007 align:middle
进一步探讨WatchKit中的变化

00:00:40.374 --> 00:00:41.341 align:middle
我叫安德鲁·普拉兹

00:00:41.408 --> 00:00:45.279 align:middle
将与福里斯特·希尔
一道讲述今天的话题

00:00:45.579 --> 00:00:47.114 align:middle
希望您会感兴趣

00:00:49.116 --> 00:00:50.784 align:middle
我将讲述三个部分

00:00:51.051 --> 00:00:55.923 align:middle
即架构 手表 app内部手表扩展的
基本布局工作原理

00:00:56.590 --> 00:00:58.492 align:middle
我会讲述资源和数据的存放地点

00:00:58.559 --> 00:01:02.296 align:middle
因为它是由两个部分构成的系统
所以开始时可能会有点难以理解

00:00:58.559 --> 00:01:02.296 align:middle
因为它是由两个部分构成的系统
所以开始时可能会有点难以理解

00:01:02.963 --> 00:01:05.331 align:middle
对于那些已经从事过
Watch OS 1开发的朋友

00:01:05.498 --> 00:01:07.434 align:middle
WatchOS 1是WatchKit的一个扩展
是一个手表app

00:01:07.501 --> 00:01:11.305 align:middle
我将会讲到迁移
有哪些变化以及有哪些相同之处

00:01:11.772 --> 00:01:13.106 align:middle
然后福里斯特将继续谈一下

00:01:13.173 --> 00:01:17.611 align:middle
WatchKit中的一些新的API
以及新的类

00:01:17.978 --> 00:01:19.580 align:middle
因此您的手表 app包含三个部分

00:01:19.947 --> 00:01:21.582 align:middle
它有一个iOS应用

00:01:22.082 --> 00:01:25.185 align:middle
你将会在手机上安装它

00:01:25.485 --> 00:01:27.788 align:middle
此外你还将提供一个
WatchKit扩展

00:01:27.855 --> 00:01:28.755 align:middle
这是你自己写的代码

00:01:29.289 --> 00:01:31.325 align:middle
然后是一个手表OS应用

00:01:31.391 --> 00:01:34.127 align:middle
它包含资源和界面描述

00:01:36.597 --> 00:01:39.066 align:middle
您有了手机
下载了您的app

00:01:40.200 --> 00:01:44.338 align:middle
而我们已完成的工作就是
增加一批新的数据

00:01:44.404 --> 00:01:47.741 align:middle
一批附带并与其一道安装的文件

00:01:47.808 --> 00:01:48.976 align:middle
而那就是手表app

00:01:49.042 --> 00:01:52.246 align:middle
它包含您对界面的描述
或许也有一些资源

00:01:52.479 --> 00:01:54.147 align:middle
然后就是您的WatchKit扩展

00:01:54.214 --> 00:01:57.751 align:middle
它包含代码和额外的资源

00:01:58.752 --> 00:02:00.153 align:middle
因此当您把它与您的手表匹配时

00:01:58.752 --> 00:02:00.153 align:middle
因此当您把它与您的手表匹配时

00:02:00.821 --> 00:02:04.191 align:middle
我们将所有的那些信息复制过去
它就会出现在主屏幕上

00:02:04.658 --> 00:02:05.759 align:middle
作为一个完整的应用出现

00:02:08.895 --> 00:02:12.900 align:middle
当然手机上仍然留有备份
以备以后重新安装的不时之需

00:02:14.334 --> 00:02:18.172 align:middle
因此我会谈到两个你将要提供的部分

00:02:18.238 --> 00:02:21.842 align:middle
一个是界面
另一个是实际代码以及扩展

00:02:22.910 --> 00:02:26.880 align:middle
当您创建了一个
新的WatchKit App

00:02:27.281 --> 00:02:29.349 align:middle
您可以看到实际上有两个独立的目标

00:02:29.750 --> 00:02:32.953 align:middle
两个独立的组件
带有interface Storyboard的app

00:02:33.020 --> 00:02:35.122 align:middle
和您的代码
这里的代码即Swift

00:02:35.189 --> 00:02:40.827 align:middle
而你有多达四个不同的
可以向其添加代码的东西

00:02:42.629 --> 00:02:44.831 align:middle
因此对于storyboard
这是它的界面部分

00:02:45.098 --> 00:02:48.101 align:middle
您可以在IB内编辑它
正如编辑一个iOS应用一样

00:02:49.002 --> 00:02:55.042 align:middle
而我们提供相当丰富的
一组界面元素 标签 图像等等

00:02:55.108 --> 00:02:59.112 align:middle
这就是watchOS 1的全部内容
而且我们在watchOS 2里面

00:02:59.179 --> 00:03:02.816 align:middle
添加了几个新特性如Picker视图
这将给您一个丰富的界面以及影片视图

00:02:59.179 --> 00:03:02.816 align:middle
添加了几个新特性如Picker视图
这将给您一个丰富的界面以及影片视图

00:03:04.685 --> 00:03:11.124 align:middle
因此 例如这里有三个带有
你能够看到所有控制按钮的标准控件

00:03:11.191 --> 00:03:13.594 align:middle
它们是在
interface builder内创建的

00:03:14.261 --> 00:03:16.663 align:middle
我们也有针对特定功能的自定义界面

00:03:17.030 --> 00:03:19.967 align:middle
一个是Glances
它有更为具体的布局

00:03:20.033 --> 00:03:22.402 align:middle
另两个是用于通知的界面

00:03:22.469 --> 00:03:24.738 align:middle
一个用于静态通知
另一个用于传送更为动态的

00:03:24.805 --> 00:03:27.474 align:middle
您在运行时提供的信息

00:03:29.376 --> 00:03:32.379 align:middle
因此正如我刚才所言
您的扩展有四个功能

00:03:33.413 --> 00:03:34.448 align:middle
有个应用功能

00:03:34.515 --> 00:03:37.584 align:middle
当您的应用从主屏幕启动的时候
我们调用您的扩展

00:03:37.851 --> 00:03:40.487 align:middle
它也被用于从时钟出现的
单页glance

00:03:40.854 --> 00:03:44.091 align:middle
以及在您接收到通知的时候进行显示

00:03:44.391 --> 00:03:46.393 align:middle
而且现在
也用于complications

00:03:47.361 --> 00:03:50.531 align:middle
对于其中的每一个都有个相关联的控件

00:03:50.597 --> 00:03:54.001 align:middle
对于Glances以及常规应用
有WK Interface Controller

00:03:54.067 --> 00:03:55.369 align:middle
有一个专门的次级类

00:03:55.435 --> 00:03:59.039 align:middle
叫做
WK User Notification Interface Controller

00:03:59.106 --> 00:04:00.541 align:middle
对于通知 您应该使用这个次级类

00:03:59.106 --> 00:04:00.541 align:middle
对于通知 您应该使用这个次级类

00:04:00.974 --> 00:04:02.943 align:middle
还有一个新的数据源对象

00:04:03.377 --> 00:04:05.979 align:middle
即WK Complication Data Source

00:04:06.046 --> 00:04:08.448 align:middle
关于complications
我目前就讲这么多

00:04:08.515 --> 00:04:12.953 align:middle
今天稍后还有一个讲座环节
对此进行更详细探讨

00:04:15.522 --> 00:04:20.459 align:middle
因此您的WK Interface Controller
是与您的界面的主要连接工具

00:04:21.161 --> 00:04:25.399 align:middle
它所做的主要是自动创建界面属性

00:04:25.465 --> 00:04:31.104 align:middle
因此你会在界面设计中
对一个界面元素贴上标签

00:04:31.171 --> 00:04:32.873 align:middle
并声称 类似这是我的标签

00:04:33.140 --> 00:04:37.811 align:middle
然后我们在控件上创建一个关联的对象
并自动为您将其连接好

00:04:39.746 --> 00:04:44.451 align:middle
控件也支持菜单处理
您可以自定义菜单或者使用静态菜单

00:04:44.985 --> 00:04:48.589 align:middle
我们提供对控件的导航
推送等等或者调度

00:04:49.289 --> 00:04:51.091 align:middle
和模态显示

00:04:51.892 --> 00:04:55.095 align:middle
以及警告和action sheet

00:04:56.096 --> 00:05:00.000 align:middle
另外一个我们提供的内容是
几个系统UI表单

00:05:00.067 --> 00:05:03.871 align:middle
文本输入 视频回放 音频录制

00:05:07.074 --> 00:05:10.644 align:middle
那么 比如说
这里有个非常简单的界面控件类

00:05:10.711 --> 00:05:14.448 align:middle
它有一个插座变量app图标
而我们在IB中加载它

00:05:14.982 --> 00:05:19.653 align:middle
当我们运行应用时 我们看到它提取了
图标并将其显示在屏幕上

00:05:21.655 --> 00:05:25.459 align:middle
那么我想谈一下各种东西的位置

00:05:25.526 --> 00:05:28.161 align:middle
你的资源存放在哪里
你从哪里提取数据

00:05:29.963 --> 00:05:33.834 align:middle
因为这个手表app分为两个部分

00:05:33.901 --> 00:05:36.069 align:middle
包括手表app本身
以及WatchKit扩展

00:05:36.470 --> 00:05:38.272 align:middle
有两个地方存放数据

00:05:38.338 --> 00:05:41.208 align:middle
即WatchApp bundle
和WatchKit扩展bundle

00:05:41.275 --> 00:05:44.178 align:middle
而你必须确保记住它存放的位置

00:05:44.478 --> 00:05:46.747 align:middle
比如这里我创建了另一个对象

00:05:46.813 --> 00:05:48.649 align:middle
和以前一样它也有一个
interface storyboard

00:05:48.715 --> 00:05:50.751 align:middle
和一个名为
application image的图像文件

00:05:50.817 --> 00:05:53.053 align:middle
以及本地化的字符串文件

00:05:53.420 --> 00:05:55.589 align:middle
而扩展本身也包含同样的东西

00:05:55.656 --> 00:05:58.792 align:middle
它有另一个png文件
和一个可本地化的字符串

00:06:00.794 --> 00:06:04.364 align:middle
那现在如果我们进行个容易理解的操作
即创建两个插座变量

00:06:04.898 --> 00:06:08.936 align:middle
并使用IB插座变量将其连接起来
表明这些是属性

00:06:09.603 --> 00:06:10.771 align:middle
并调用组图标

00:06:10.838 --> 00:06:12.339 align:middle
哦 我们没有扩展图标

00:06:13.373 --> 00:06:19.079 align:middle
原因是当你调用的组图标
是在WK Interface Image上命名的时候

00:06:19.479 --> 00:06:21.448 align:middle
它并不在应用bundle
内进行搜索

00:06:21.715 --> 00:06:24.284 align:middle
但是扩展图标并不
存放在应用的bundle内

00:06:24.985 --> 00:06:30.057 align:middle
因此你要做的是直接从正在那个特定的
bundle中运行的代码内提取它

00:06:30.123 --> 00:06:34.361 align:middle
因此在扩展代码内
你调用UI图标的名称

00:06:34.728 --> 00:06:36.330 align:middle
而这将在本地提取图标

00:06:36.396 --> 00:06:38.799 align:middle
因为它知道如何在它自己的
bundle内部进行搜索

00:06:38.866 --> 00:06:40.234 align:middle
然后你在系统内执行同样操作

00:06:40.300 --> 00:06:43.203 align:middle
你调用组图标而不是已被命名的组图标

00:06:43.670 --> 00:06:47.207 align:middle
那将传递图标并让两个图标
都出现在您的应用内

00:06:50.310 --> 00:06:51.712 align:middle
那么现在你希望存储一些数据

00:06:51.778 --> 00:06:55.749 align:middle
您不会只希望提取一些静态图片
你拥有一个极其动态的应用

00:06:56.316 --> 00:06:59.586 align:middle
因此有两个你感兴趣的文件夹

00:07:00.087 --> 00:07:01.455 align:middle
一个是文档文件夹

00:07:01.788 --> 00:07:04.424 align:middle
这是你存储更为持久的信息的地方

00:07:05.158 --> 00:07:08.662 align:middle
它是不可删除的
就是说它在重启之间是一直运行的

00:07:09.162 --> 00:07:11.865 align:middle
但是需要注意的一点是
它是不可恢复的

00:07:11.932 --> 00:07:16.670 align:middle
因此你必须检查手表是否被擦除
否则你就要安装新的手表

00:07:17.905 --> 00:07:19.173 align:middle
还有一个缓存文件夹

00:07:19.573 --> 00:07:23.610 align:middle
这个是可以删除的
因此如果系统认为需要更多空间

00:07:23.677 --> 00:07:26.480 align:middle
存储音乐 图片或其他 app

00:07:26.547 --> 00:07:27.881 align:middle
它将删除这些图片

00:07:27.948 --> 00:07:30.951 align:middle
因此你可以认为那些图片可能随时消失

00:07:33.020 --> 00:07:36.089 align:middle
这里有一个例子
我们快速地看一下在哪里找到它

00:07:37.224 --> 00:07:40.294 align:middle
在这个例子中 主要调用的
是document directory类

00:07:40.360 --> 00:07:42.863 align:middle
目录URL的文件管理器

00:07:42.930 --> 00:07:46.466 align:middle
它将请求第一个
而那正是需要的 URL

00:07:46.800 --> 00:07:52.706 align:middle
因此我们创建一个包含我们的文件名的
URL并向其写入一些数据

00:07:56.043 --> 00:07:58.478 align:middle
现在媒体出现了另一个有趣的问题

00:07:59.179 --> 00:08:02.249 align:middle
由于应用负责播放媒体

00:07:59.179 --> 00:08:02.249 align:middle
由于应用负责播放媒体

00:08:02.649 --> 00:08:06.220 align:middle
它也负责将音频录制在某个地方

00:08:06.286 --> 00:08:11.391 align:middle
因此当你的扩展请求播放一个影片
或播放音频 或录制音频的时候

00:08:11.758 --> 00:08:13.126 align:middle
我们将其传送给应用

00:08:14.361 --> 00:08:16.997 align:middle
另一方面扩展负责

00:08:17.064 --> 00:08:21.568 align:middle
从互联网上下载或用其他操作生成媒体

00:08:21.635 --> 00:08:25.572 align:middle
它也负责获取你可能已经设置好的
录制下来的音频文件

00:08:26.039 --> 00:08:28.742 align:middle
并将它们传送到你的服务器上

00:08:30.277 --> 00:08:34.181 align:middle
那么你需要做的就是
设置所谓的共享容器

00:08:34.914 --> 00:08:41.822 align:middle
而那主要是为了让两个过程
即应用和扩展一个能够共同访问的地方

00:08:42.322 --> 00:08:43.590 align:middle
因为出于安全因素

00:08:43.657 --> 00:08:49.329 align:middle
通常你不能从一个过程
进入另一个存储区域

00:08:50.697 --> 00:08:52.032 align:middle
而你启用了这种Xcode

00:08:52.299 --> 00:08:55.536 align:middle
你使用了所谓的‘app群组’

00:08:55.602 --> 00:08:58.071 align:middle
将其用于扩展和你
赋予了独特的识别符的应用

00:08:58.672 --> 00:09:00.541 align:middle
而那就是你的应用群组

00:08:58.672 --> 00:09:00.541 align:middle
而那就是你的应用群组

00:09:03.143 --> 00:09:07.548 align:middle
那么这里你需要真正担心的唯一事情
仍然是有一个函数

00:09:08.015 --> 00:09:09.783 align:middle
即文件管理器

00:09:09.850 --> 00:09:13.754 align:middle
你可以为安全应用群组识别符
请求容器URL

00:09:13.820 --> 00:09:15.756 align:middle
并将其通过你创建的群组
识别符进行传递

00:09:16.190 --> 00:09:19.193 align:middle
而那将把你的URL
赋予到一共享的存储区域

00:09:19.993 --> 00:09:24.431 align:middle
因此从那里你可以存储app

00:09:24.498 --> 00:09:28.535 align:middle
能够从扩展读取或者提取的文件

00:09:28.602 --> 00:09:33.640 align:middle
这里我们有一个例子是当前的音频录制
控件把URL从共享容器取出

00:09:33.707 --> 00:09:35.542 align:middle
那么它将把音频录制到那个文件内

00:09:37.744 --> 00:09:41.014 align:middle
因此现在我希望谈一下
如何从手表提取数据

00:09:42.182 --> 00:09:43.450 align:middle
有两种方法可以实现

00:09:43.517 --> 00:09:46.787 align:middle
一种是NSURL Session
它是在Foundation框架内的

00:09:46.854 --> 00:09:49.756 align:middle
另一种是通过一个新的
Watch Connectivity框架

00:09:50.290 --> 00:09:54.695 align:middle
因此NSURL Session是你
从互联网上获取资源的方法之一

00:09:54.761 --> 00:09:58.832 align:middle
如果你有一个聊天app或类似的东西
你会希望与您的服务器对话

00:10:00.501 --> 00:10:03.904 align:middle
它让你直接通过HTTP和HTTPS
访问互联网

00:10:04.204 --> 00:10:08.609 align:middle
而有多种配置方式

00:10:09.643 --> 00:10:11.912 align:middle
而且它支持以后台方式下载

00:10:11.979 --> 00:10:14.147 align:middle
原因是您的扩展经常不处于运行状态

00:10:14.214 --> 00:10:17.284 align:middle
您的手表屏幕是关闭的
您的扩展是睡眠状态的

00:10:17.551 --> 00:10:19.319 align:middle
您的扩展甚至不运行的时候

00:10:19.386 --> 00:10:20.921 align:middle
而这都是下载数据所需要的

00:10:21.922 --> 00:10:23.690 align:middle
需要注意的一点是

00:10:23.757 --> 00:10:27.227 align:middle
一旦我们告诉您数据已经在那里
一旦文件已被完全下载

00:10:27.294 --> 00:10:32.099 align:middle
您需要立刻拿到它
因为否则的话它就会被从临时缓存删除

00:10:33.867 --> 00:10:35.836 align:middle
因此这里有一些代码
一共有几页

00:10:35.903 --> 00:10:37.504 align:middle
一个简单的downloader类

00:10:38.071 --> 00:10:40.073 align:middle
我们首先要做的是释放NSURLSession

00:10:40.140 --> 00:10:42.876 align:middle
我们慢慢做这件事
以防我们永远不需要调用它

00:10:43.944 --> 00:10:45.812 align:middle
而这里的调用主要是创建会话

00:10:46.180 --> 00:10:49.383 align:middle
而且只有两行代码
一行是为了对后台进行配置

00:10:49.449 --> 00:10:52.619 align:middle
那么你可以说这里是一个后台会话

00:10:52.686 --> 00:10:55.222 align:middle
而我们希望传入一个ID
过一会儿我会谈到它

00:10:56.523 --> 00:10:58.959 align:middle
而我们使用那种配置创建URL会话

00:10:59.026 --> 00:11:02.396 align:middle
而且我们让downloader类本身
成为delegate之后的实例

00:10:59.026 --> 00:11:02.396 align:middle
而且我们让downloader类本身
成为delegate之后的实例

00:11:02.462 --> 00:11:04.631 align:middle
以便我们能够在文件进来时得到通知

00:11:05.599 --> 00:11:07.167 align:middle
然后为了开始URL下载

00:11:07.668 --> 00:11:09.636 align:middle
我们请求一个新的任务

00:11:10.237 --> 00:11:11.705 align:middle
并让其运行

00:11:11.772 --> 00:11:15.943 align:middle
而它将发出请求
并开始下载

00:11:17.611 --> 00:11:22.883 align:middle
正如我刚才所言 通常你的扩展
是关闭的或不处于唤醒状态

00:11:23.217 --> 00:11:24.751 align:middle
在它关闭的情况下

00:11:25.118 --> 00:11:29.489 align:middle
你将需要重新连接到
已经设置好的所有下载任务

00:11:29.990 --> 00:11:36.830 align:middle
因此你要设置的是个在您的WK扩展中
叫做restart的调用的函数

00:11:36.897 --> 00:11:38.165 align:middle
福李斯特之后将谈到那一点

00:11:38.232 --> 00:11:41.702 align:middle
启动调用函数并重新启动下载
以便你能够知道它们会到来

00:11:41.768 --> 00:11:45.105 align:middle
实际上它们也会消失
但是你不会知道它们已经结束了

00:11:47.608 --> 00:11:49.610 align:middle
而这里是实际的delegate方法

00:11:49.676 --> 00:11:53.180 align:middle
这就是你与
NSURLSession连接的方法

00:11:53.480 --> 00:11:56.550 align:middle
当文件完成下载之后就会调用此方法

00:11:56.617 --> 00:11:59.386 align:middle
正如我刚才所言
我们需要立刻将文件复制以防它消失

00:11:59.453 --> 00:12:00.921 align:middle
以防系统将其删除

00:11:59.453 --> 00:12:00.921 align:middle
以防系统将其删除

00:12:01.855 --> 00:12:03.624 align:middle
这种情况下我们将获取缓存目录

00:12:03.690 --> 00:12:05.259 align:middle
因为或许我们过一会可能会需要它

00:12:06.560 --> 00:12:08.695 align:middle
我们将生成一个URL

00:12:08.762 --> 00:12:13.066 align:middle
且我们用文件管理器复制
从被传递进来的原始URL

00:12:13.133 --> 00:12:16.370 align:middle
即从位置URL到缓存目录的URL

00:12:16.970 --> 00:12:20.140 align:middle
我们已经将其复制
并跟踪它以便以后使用

00:12:20.407 --> 00:12:22.910 align:middle
因此我们可以读取你下载的任何数据

00:12:25.179 --> 00:12:27.781 align:middle
此外还有
WatchKit connectivity框架

00:12:27.848 --> 00:12:29.283 align:middle
它实际上存在于双方

00:12:29.650 --> 00:12:31.652 align:middle
比如你在它们之间共享数据

00:12:31.718 --> 00:12:35.489 align:middle
你可以在手表和iPhone之间
建立个共享的字典

00:12:36.056 --> 00:12:38.425 align:middle
它让你传输文件
也是后台运行

00:12:39.293 --> 00:12:43.864 align:middle
它也让你从手表直接
向作为父应用的手机app

00:12:44.164 --> 00:12:46.066 align:middle
向父设备iPhone上的父应用
发送请求

00:12:46.967 --> 00:12:50.771 align:middle
明天将会有一个关于该话题的环节

00:12:51.138 --> 00:12:52.639 align:middle
我建议大家要去听
因为它是新内容

00:12:52.706 --> 00:12:55.342 align:middle
而且是手表和iPhone上都有的

00:12:58.912 --> 00:13:02.449 align:middle
那么这里有几个迁移方面的幻灯片

00:12:58.912 --> 00:13:02.449 align:middle
那么这里有几个迁移方面的幻灯片

00:13:02.516 --> 00:13:06.286 align:middle
对于已经开始开发
watchOS 1 app的朋友

00:13:08.522 --> 00:13:10.123 align:middle
您多半已经见到过这个内容

00:13:10.557 --> 00:13:14.027 align:middle
watchOS 1的WatchKit扩展

00:13:14.094 --> 00:13:16.630 align:middle
是你们已经创建的东西
或是你们的项目内一个目标

00:13:17.431 --> 00:13:20.934 align:middle
但是它使用了SDK中的iOS平台

00:13:21.001 --> 00:13:24.404 align:middle
因此它存在于iPhone内
而不是在手表内

00:13:27.241 --> 00:13:31.612 align:middle
因此它让你在手机上共享一个框架

00:13:31.879 --> 00:13:34.848 align:middle
那么你可能有一些代码
是两种扩展上通用的

00:13:34.915 --> 00:13:36.850 align:middle
比如从网络上获取你的信息

00:13:37.217 --> 00:13:43.023 align:middle
同样的代码在iPhone应用
和手表应用中4都能运行

00:13:44.091 --> 00:13:48.762 align:middle
因为您无法直接读取手表存储器

00:13:49.196 --> 00:13:53.467 align:middle
我们为您提供了一种缓存图像的方法
即一张图片和一个名称

00:13:53.534 --> 00:13:55.636 align:middle
之后当我说“已对上述图像命名”时

00:13:56.570 --> 00:14:01.375 align:middle
我们已把资源下载到了手表上
而且速度将会快得多

00:13:56.570 --> 00:14:01.375 align:middle
我们已把资源下载到了手表上
而且速度将会快得多

00:14:02.509 --> 00:14:05.512 align:middle
因此我们为您提供了一种
直接与应用对话的方法

00:14:06.046 --> 00:14:10.050 align:middle
显然是从手机到手机的过程
因此它是非常迅速的

00:14:11.518 --> 00:14:15.856 align:middle
借助watchOS 2
我们已经添加了一种新的SDK

00:14:16.456 --> 00:14:21.562 align:middle
它是完全独立的
与iPhone和OS 10 SDK类似

00:14:22.496 --> 00:14:24.898 align:middle
它确实为您提供了一套
可用的iOS次级框架

00:14:25.265 --> 00:14:27.835 align:middle
虽然您不会获得
和手机上一样完整的功能性

00:14:28.135 --> 00:14:29.236 align:middle
但是你也获得很多便利

00:14:32.039 --> 00:14:35.976 align:middle
你可以在你的项目中加入一个框架

00:14:36.243 --> 00:14:39.213 align:middle
正如你在iPhone watchOS 1 app
上所做的一样

00:14:40.447 --> 00:14:45.686 align:middle
但是这个框架是使用手表应用
和手表扩展下载的

00:14:45.752 --> 00:14:50.090 align:middle
因此你不会在一个设备上共享代码

00:14:50.390 --> 00:14:55.195 align:middle
但是它确实让你仍然把网络访问
代码分离到一个单独的

00:14:55.629 --> 00:14:56.763 align:middle
手表可以使用的框架内

00:14:57.130 --> 00:14:59.800 align:middle
现在当然 比如说手表
对于你提供的手表框架

00:15:00.501 --> 00:15:04.505 align:middle
可能使用NSURLSession
读取信息

00:15:07.074 --> 00:15:10.544 align:middle
因此如果您已经开发了
一个WatchOS 1应用

00:15:11.211 --> 00:15:13.881 align:middle
您实际上已经做了很多准备
以便接触watchOS 2

00:15:15.082 --> 00:15:18.252 align:middle
它们同样拥有有变化和添加的API

00:15:18.986 --> 00:15:22.256 align:middle
但是您应该能够
不做任何改动编译很大一部分

00:15:22.322 --> 00:15:24.124 align:middle
并且可以将资源复制转移

00:15:24.191 --> 00:15:27.861 align:middle
因此如果在您的
WatchOS 1扩展内有图像

00:15:27.928 --> 00:15:32.566 align:middle
您可将其添加到WatchOS2扩展
的目标并将其复制到手表上

00:15:33.300 --> 00:15:36.103 align:middle
但是你必须确保它们的大小
被调整到适合于手表

00:15:37.104 --> 00:15:38.205 align:middle
有几项新的改进

00:15:39.806 --> 00:15:43.410 align:middle
当然主要的一点是
您的手表app运行于您的手表上

00:15:43.477 --> 00:15:45.445 align:middle
扩展也是如此

00:15:45.512 --> 00:15:48.415 align:middle
而那意味着UI的反应性好得多了

00:15:48.482 --> 00:15:52.519 align:middle
您点击一个按钮它立刻做出反应

00:15:52.920 --> 00:15:56.990 align:middle
当然现在你也可以独立操作
而不必担心手机就在附近

00:15:57.891 --> 00:16:00.761 align:middle
你不必担心手机正在连接中或正在上网

00:15:57.891 --> 00:16:00.761 align:middle
你不必担心手机正在连接中或正在上网

00:16:01.862 --> 00:16:08.502 align:middle
我们也增加了几个UI元素
以及一些新的系统UI表单

00:16:08.569 --> 00:16:12.005 align:middle
我们将在本节讲座
或其他讲座上谈到它们

00:16:12.873 --> 00:16:14.141 align:middle
我们增加了动画

00:16:14.641 --> 00:16:19.546 align:middle
因此现在您可以让切换间的过渡
实现动画效果

00:16:19.613 --> 00:16:22.282 align:middle
如图表或图形的大小

00:16:22.349 --> 00:16:24.651 align:middle
或是类似的东西

00:16:24.718 --> 00:16:26.954 align:middle
或字符串的不透明度
你可以使其具有动画效果

00:16:27.020 --> 00:16:28.755 align:middle
就此内容明天会有一节专门讲座

00:16:29.189 --> 00:16:31.091 align:middle
因此我建议您也看一下那节讲座

00:16:34.494 --> 00:16:38.799 align:middle
那么对于控件
API大体上是相同的

00:16:39.132 --> 00:16:42.436 align:middle
你有相同的界面控件
你会使用glance

00:16:42.503 --> 00:16:43.637 align:middle
没有任何变化

00:16:43.704 --> 00:16:45.038 align:middle
而且通知也是一样的

00:16:45.105 --> 00:16:46.607 align:middle
你无须做出任何改动

00:16:46.874 --> 00:16:49.343 align:middle
有几个API已经不存在了

00:16:49.409 --> 00:16:52.446 align:middle
图像缓存和open parent已被

00:16:52.513 --> 00:16:56.316 align:middle
替代为直接读取图像
和Watch Connectivity

00:16:57.618 --> 00:17:01.889 align:middle
福李斯特将提到
两个新的元素是extension delegate

00:16:57.618 --> 00:17:01.889 align:middle
福李斯特将提到
两个新的元素是extension delegate

00:17:02.789 --> 00:17:09.463 align:middle
及在表盘上显示被用来为
complications提供图像和文本的数据源

00:17:11.298 --> 00:17:15.269 align:middle
最后对于那些
目前有Xcode项目的朋友

00:17:15.736 --> 00:17:18.605 align:middle
您需要做的是增加一个新的目标

00:17:18.672 --> 00:17:20.473 align:middle
可以在使用WatchOS 1的同时

00:17:20.540 --> 00:17:26.613 align:middle
请求增加WatchOS 2
并向其中添加文件

00:17:26.680 --> 00:17:29.116 align:middle
将文件标记为同一个目标的一部分

00:17:29.183 --> 00:17:31.852 align:middle
添加即将在手表上被编译并加载的框架

00:17:33.287 --> 00:17:34.154 align:middle
如果您愿意

00:17:34.221 --> 00:17:38.926 align:middle
您可以从Xcode开始
启动一个全新的项目

00:17:39.193 --> 00:17:42.296 align:middle
而它将会自动创建iOS
和WatchOS 2 app

00:17:42.729 --> 00:17:44.264 align:middle
因此您可以从那里启动填充内容

00:17:44.831 --> 00:17:47.701 align:middle
昨天有一节讲座
我建议大家看一下视频

00:17:48.168 --> 00:17:52.105 align:middle
它们对这一过程的描述要详细得多

00:17:53.040 --> 00:17:54.374 align:middle
我就讲这么多

00:17:54.441 --> 00:17:58.145 align:middle
现在让福里斯特接替我继续
更详细地讨论新课程

00:17:58.212 --> 00:17:59.680 align:middle
以及现有API上发生的变化

00:18:03.483 --> 00:18:05.552 align:middle
我叫福里斯特
是一名WatchKit工程师

00:18:05.619 --> 00:18:06.687 align:middle
我将跟大家谈谈

00:18:06.753 --> 00:18:09.857 align:middle
我们在面向WatchOS 2的
WatchKit中增加的新的API

00:18:11.758 --> 00:18:14.261 align:middle
首先我谈一下
WK extension delegate

00:18:15.028 --> 00:18:20.267 align:middle
在iOS上我们有
UI Application Delegate

00:18:20.868 --> 00:18:23.270 align:middle
作为众多方法之一
它帮您跟踪您的app的生命周期

00:18:23.337 --> 00:18:26.206 align:middle
这包括诸如你的启动
你变得活跃

00:18:26.273 --> 00:18:27.474 align:middle
以及你将停止活跃

00:18:28.008 --> 00:18:30.644 align:middle
我们已经添加了
WK extension delegate

00:18:30.711 --> 00:18:32.846 align:middle
来跟踪您的应用的生命周期

00:18:34.882 --> 00:18:38.485 align:middle
首先我将从
application Did Finish Launching开始

00:18:38.552 --> 00:18:44.591 align:middle
当程序完成启动及扩展完全未运行时
它被调用一次

00:18:45.058 --> 00:18:48.996 align:middle
这可能是您的应用需要的初始化步骤

00:18:49.062 --> 00:18:53.200 align:middle
设置notification observer
并预热任何今后可能需要的服务的地方

00:18:53.267 --> 00:18:56.236 align:middle
重要的一点是注意
此时您的应用尚未进入活跃状态

00:18:58.238 --> 00:19:00.107 align:middle
接下来我们有
application Did Become Active

00:18:58.238 --> 00:19:00.107 align:middle
接下来我们有
application Did Become Active

00:19:00.174 --> 00:19:04.511 align:middle
每次你的应用被从后台转移到前台
或在第一次启动之后

00:19:05.012 --> 00:19:07.114 align:middle
它都会被调用

00:19:08.448 --> 00:19:14.454 align:middle
这是个启动任何仅需在您应用实际活
跃期间运行的代码的好时机

00:19:14.521 --> 00:19:16.356 align:middle
或激活任何您可能需要的定时器

00:19:16.423 --> 00:19:22.095 align:middle
尤其是更新在后台或根本未运行期间
已经发生变化的状态

00:19:24.431 --> 00:19:26.133 align:middle
Application Will Resign Active

00:19:26.200 --> 00:19:30.304 align:middle
是在您的app停止活跃状态
并被移动到后台之前调用的

00:19:30.370 --> 00:19:33.373 align:middle
您希望准备进入不活跃状态

00:19:33.740 --> 00:19:35.475 align:middle
如果您已经启动了任何定时器

00:19:36.076 --> 00:19:37.644 align:middle
这是一个使它们暂停的好时点

00:19:37.711 --> 00:19:40.614 align:middle
如果您选择在此时不将其暂停

00:19:40.681 --> 00:19:42.850 align:middle
它们将不会在后台运行
你不会有后台运行时间

00:19:43.150 --> 00:19:46.153 align:middle
但是你将会失去
对它们的精确运行周期的控制

00:19:46.720 --> 00:19:47.788 align:middle
因此如果您想进行控制

00:19:47.855 --> 00:19:50.123 align:middle
当你不活跃时
暂停它们是个不错的主意

00:19:50.390 --> 00:19:52.860 align:middle
而当你真正变为活跃时再将其重启

00:19:53.327 --> 00:19:55.762 align:middle
而你希望在此时
保存您的应用的状态

00:19:55.829 --> 00:19:58.565 align:middle
因为在此时间点之后
系统中的另一进程需要那些内存

00:19:58.866 --> 00:20:01.001 align:middle
您的扩展将被强制终止

00:19:58.866 --> 00:20:01.001 align:middle
您的扩展将被强制终止

00:20:04.571 --> 00:20:05.405 align:middle
因此总的来说

00:20:05.472 --> 00:20:09.743 align:middle
WK extension delegate
将跟踪您的应用的生命周期

00:20:09.810 --> 00:20:10.644 align:middle
需要注意的是

00:20:10.711 --> 00:20:14.281 align:middle
这与通知UI Glance UI
或complication数据

00:20:14.348 --> 00:20:15.516 align:middle
毫无任何关系

00:20:15.582 --> 00:20:17.584 align:middle
这仅与跟踪应用的生命周期有关

00:20:20.921 --> 00:20:23.524 align:middle
接下来我讲一下
handle User Activity

00:20:23.590 --> 00:20:26.460 align:middle
Handle User Activity是个
来自于WatchOS 1的现有调用方法

00:20:26.527 --> 00:20:29.396 align:middle
在WatchOS 1中它被用于
应用启动的时候

00:20:29.696 --> 00:20:35.669 align:middle
通过点击您的glance而导航
到您的应用内的适当位置

00:20:35.936 --> 00:20:37.471 align:middle
那也从glance得到反映

00:20:37.938 --> 00:20:40.874 align:middle
我们将在watchOS 2内
以两种方式构建它

00:20:41.375 --> 00:20:42.776 align:middle
首先它会在应用启动时被调用

00:20:42.843 --> 00:20:45.646 align:middle
通过点击您的
complication启动应用

00:20:45.946 --> 00:20:49.716 align:middle
任何你在Complication中
反映的状态将需要导航

00:20:49.783 --> 00:20:52.519 align:middle
到您的应用中该状态
对应的适当位置

00:20:53.420 --> 00:20:55.656 align:middle
此外我们将把它移动到
WK extension delegate

00:20:55.722 --> 00:20:58.725 align:middle
而不是我们过去所做的
root Interface Controller

00:20:59.226 --> 00:21:04.298 align:middle
这会给你提供更大的灵活性
让你处理想做的事情从而实现状态维护

00:20:59.226 --> 00:21:04.298 align:middle
这会给你提供更大的灵活性
让你处理想做的事情从而实现状态维护

00:21:11.038 --> 00:21:14.308 align:middle
那么我们在一个名为WK extension
的新对象上进行新的调用

00:21:14.374 --> 00:21:15.976 align:middle
新的调用是root Interface Controller

00:21:16.043 --> 00:21:19.213 align:middle
我必须警告你它将来自于将来的种子
而不是在现有的种子内

00:21:19.279 --> 00:21:20.414 align:middle
因此为了暂时进行估算

00:21:20.480 --> 00:21:23.417 align:middle
您将不得不在您的界面控件的初建之时
在其上进行节省

00:21:24.351 --> 00:21:25.252 align:middle
记住这一点后

00:21:25.319 --> 00:21:27.554 align:middle
你可能会暂时在
WK extension delegate上

00:21:27.621 --> 00:21:29.890 align:middle
执行handle User Activity

00:21:29.957 --> 00:21:32.893 align:middle
我将通过新的调用取得新的根控件

00:21:32.960 --> 00:21:37.764 align:middle
并将跳转回到根部然后我将请求根控件
继续运行并做出任何适当的操作

00:21:37.831 --> 00:21:38.732 align:middle
以恢复您的状态

00:21:39.032 --> 00:21:40.934 align:middle
注意 这里有很多你能做的其他事情

00:21:41.001 --> 00:21:44.204 align:middle
你可以建立模态警告或进行其他操作

00:21:44.905 --> 00:21:46.874 align:middle
以处理传递给你的用户活动

00:21:48.842 --> 00:21:52.646 align:middle
接下来在IOS上
我们有UI application

00:21:53.213 --> 00:21:57.751 align:middle
它是一个单独的对象
代表正在运行中的应用

00:21:58.452 --> 00:22:03.957 align:middle
所以在watchOS 2上我们添加
类似WK extension的东西

00:21:58.452 --> 00:22:03.957 align:middle
所以在watchOS 2上我们添加
类似WK extension的东西

00:22:06.059 --> 00:22:10.264 align:middle
其中这个是主要的界面
用于打开标准的系统URL

00:22:10.831 --> 00:22:13.767 align:middle
因此 您将能够打开
开放系统URL API

00:22:13.834 --> 00:22:18.872 align:middle
而执行诸如打电话 发送文本消息
或显示PassKit UI等操作

00:22:19.706 --> 00:22:21.909 align:middle
那就是开放系统URL
和WK extension

00:22:23.977 --> 00:22:25.779 align:middle
现在我将讲一下关于通知的内容

00:22:28.916 --> 00:22:30.684 align:middle
首先我要说的是远程通知

00:22:31.051 --> 00:22:33.253 align:middle
远程通知来自于互联网

00:22:34.588 --> 00:22:36.390 align:middle
而它们总是先到达你的手机

00:22:36.957 --> 00:22:39.927 align:middle
那时候你的手机将决定是否
显示通知本身内容

00:22:40.894 --> 00:22:43.197 align:middle
或将其继续转发直至它被显示在手表上

00:22:46.433 --> 00:22:50.971 align:middle
现在手机使用了一套规则而做出决定

00:22:51.138 --> 00:22:52.773 align:middle
而这些规则中的标准包括是否

00:22:52.840 --> 00:22:54.241 align:middle
您的手机屏幕已被上锁

00:22:54.842 --> 00:22:57.077 align:middle
或是否您的手表
被戴在您的手腕上并且已被解锁

00:23:01.148 --> 00:23:02.916 align:middle
因此诸如watchOS 1

00:23:02.983 --> 00:23:08.355 align:middle
您的WK用户通知界面控件在接收到
发给不活跃app的通知时便会运行

00:23:09.723 --> 00:23:11.158 align:middle
当发生这种情况的时候

00:23:11.225 --> 00:23:13.727 align:middle
其中的一个调用确实会收到远程通知
或者收到本地通知

00:23:13.794 --> 00:23:15.896 align:middle
它将会在您的控件上被调用

00:23:16.864 --> 00:23:20.567 align:middle
而您自行决定
是否及时调用completion handler

00:23:20.634 --> 00:23:24.938 align:middle
如果您花费太长时间
您的默认界面将被显示

00:23:25.005 --> 00:23:27.140 align:middle
它有点不太生动

00:23:27.207 --> 00:23:30.410 align:middle
因此这由您决定是否
在合理的时间内进行这个操作

00:23:32.746 --> 00:23:34.748 align:middle
接下来我将讲一下本地通知

00:23:35.282 --> 00:23:38.418 align:middle
本地通知必须从手机上
由您的iPhone app发出

00:23:38.819 --> 00:23:41.388 align:middle
但是你可以从WatchKit扩展
向您的iPhone app发出消息

00:23:41.455 --> 00:23:43.023 align:middle
并请求它发出本地通知

00:23:44.391 --> 00:23:47.761 align:middle
同样的逻辑也适用于远程通知

00:23:48.061 --> 00:23:51.598 align:middle
对于远程通知手机将决定
是否显示通知本身

00:23:52.499 --> 00:23:54.501 align:middle
或是否将其传回给手表
并将其显示在那里

00:23:57.938 --> 00:24:00.207 align:middle
那么让我们来查看一个例子
看你如何进行该操作

00:23:57.938 --> 00:24:00.207 align:middle
那么让我们来查看一个例子
看你如何进行该操作

00:24:02.109 --> 00:24:06.980 align:middle
这里我将使用watch connectivity
消息调用从手表向手机app发送消息

00:24:09.383 --> 00:24:12.219 align:middle
当我的iPhone app收到那个消息时
它可以发出本地通知

00:24:12.286 --> 00:24:15.355 align:middle
启动常规逻辑 确定在哪里显示该警告

00:24:16.323 --> 00:24:17.357 align:middle
这是相对简单的代码

00:24:19.660 --> 00:24:21.495 align:middle
那么现在我们可以
在您的手表上看到警告

00:24:21.929 --> 00:24:25.799 align:middle
我要讲一下从您的通知UI
启动您的应用

00:24:26.633 --> 00:24:28.302 align:middle
从这里可以用两种方式启动app

00:24:28.936 --> 00:24:33.240 align:middle
要么你可以从通知动作按钮启动

00:24:33.307 --> 00:24:35.309 align:middle
在这个例子里我已经
通过回复按钮进行了设置

00:24:35.642 --> 00:24:40.647 align:middle
用户也可以通过
点击左上角的应用图标来启动应用

00:24:42.916 --> 00:24:44.484 align:middle
当这些动作其中之一发生时

00:24:44.551 --> 00:24:46.453 align:middle
或者当用户做了这些事情之一时

00:24:48.488 --> 00:24:53.160 align:middle
在您的WK extension delegate上
会进行这些调用其中的一个

00:24:53.427 --> 00:24:58.265 align:middle
两个handle action with identifier
调用之一将被执行发出远程或本地通知

00:24:58.899 --> 00:25:01.702 align:middle
您将会收到被启发的动作的识别符

00:24:58.899 --> 00:25:01.702 align:middle
您将会收到被启发的动作的识别符

00:25:01.768 --> 00:25:04.471 align:middle
如果它们点击了应用图标
你将会收到一个 0

00:25:05.038 --> 00:25:08.842 align:middle
而对于远程通知的情况
你将会收到一个含有通知负载的字典

00:25:09.376 --> 00:25:14.548 align:middle
在本地通知的情况下 您将收到一开始
就创建的UI notification对象

00:25:14.615 --> 00:25:15.916 align:middle
目的是为了发出你的通知

00:25:16.617 --> 00:25:18.352 align:middle
那么 这就是如何从通知启动你的app

00:25:20.754 --> 00:25:23.624 align:middle
接下来我将谈一下
内嵌通知的文本回复

00:25:24.491 --> 00:25:29.396 align:middle
在iOS 9和watchOS 2中
为内嵌通知文本回复增加了第三方支持

00:25:31.899 --> 00:25:36.069 align:middle
在此例中 回复动作已被指定为
发生文本输入行为

00:25:37.271 --> 00:25:39.439 align:middle
当用户启发此动作

00:25:39.806 --> 00:25:41.308 align:middle
而不是启动app时

00:25:41.375 --> 00:25:44.611 align:middle
或向您的iPhone app
发回一个信号时

00:25:45.212 --> 00:25:47.114 align:middle
用户将被呈现一个文本输入UI

00:25:47.581 --> 00:25:52.853 align:middle
因此您在此UI中可以看到
用户能够启动麦克风口述回复

00:25:53.220 --> 00:25:56.590 align:middle
他们可以点击表情符号图标

00:25:56.924 --> 00:26:02.196 align:middle
以便从表情符号选择器内输入
或者从一个提示列表内进行选择

00:25:56.924 --> 00:26:02.196 align:middle
以便从表情符号选择器内输入
或者从一个提示列表内进行选择

00:26:02.529 --> 00:26:05.065 align:middle
而你作为app开发者
将可以提供这样的提示列表

00:26:05.799 --> 00:26:06.867 align:middle
而你实现这个的方式

00:26:06.934 --> 00:26:07.868 align:middle
就是通过执行这个

00:26:08.135 --> 00:26:11.772 align:middle
对suggestions For Response
To Action With Identifier的调用

00:26:12.906 --> 00:26:15.609 align:middle
它是在您的WK用户/通知
界面控件上的

00:26:18.745 --> 00:26:21.014 align:middle
因此一旦用户选择了

00:26:21.081 --> 00:26:23.684 align:middle
或提供了他们的文本输入内容
不管是通过您的选择之一

00:26:23.750 --> 00:26:25.152 align:middle
或是其他某种方法

00:26:25.919 --> 00:26:27.888 align:middle
您的应用将被启动

00:26:28.322 --> 00:26:30.791 align:middle
而你将收到这个
handle Action With Identifier调用

00:26:30.858 --> 00:26:34.428 align:middle
它出现在您的WK或
您的WK extension delegate上

00:26:37.965 --> 00:26:41.134 align:middle
您将注意到这个变量有一个新的参数
即response Info

00:26:41.201 --> 00:26:43.036 align:middle
而response Info将包含

00:26:43.103 --> 00:26:44.071 align:middle
输入的文本

00:26:44.137 --> 00:26:48.308 align:middle
用户在UI User Notification
Action Response Typed Text Key内

00:26:50.777 --> 00:26:54.348 align:middle
那么我将要讲的另一个新特性是
运行中的语言选择

00:26:55.382 --> 00:26:57.251 align:middle
这里您可以看到我们有标准的文本输入

00:26:57.718 --> 00:27:01.388 align:middle
不管何时用户启动了文本输入UI

00:26:57.718 --> 00:27:01.388 align:middle
不管何时用户启动了文本输入UI

00:27:01.455 --> 00:27:04.825 align:middle
他们都能选择通过力度触摸调出
语言选择器

00:27:05.425 --> 00:27:09.963 align:middle
语言选择器将提供所有可用的语言

00:27:10.030 --> 00:27:14.001 align:middle
这些语言根据您在iPhone上
提供的键盘而选择的

00:27:14.868 --> 00:27:17.437 align:middle
那么我将提供英语和西班牙语

00:27:17.704 --> 00:27:19.239 align:middle
那么我将继续进行切换到西班牙语

00:27:19.907 --> 00:27:22.075 align:middle
这将把文本输入UI切换到西班牙语

00:27:22.409 --> 00:27:25.746 align:middle
并可以填充一个西班牙语提示列表
而不是英语提示列表

00:27:26.446 --> 00:27:28.081 align:middle
这就是运行中的语言选择

00:27:31.485 --> 00:27:34.087 align:middle
接下来我会谈一下
如何通过另一种方式处理通知

00:27:34.354 --> 00:27:37.491 align:middle
在watchOS 1中
不管您的app活跃与否

00:27:37.558 --> 00:27:41.295 align:middle
我们总会将您的
WK用户通知界面控件实例化

00:27:41.562 --> 00:27:45.399 align:middle
而系统将在屏幕的上方显示出来
不管屏幕上是什么 包括您的app

00:27:46.099 --> 00:27:49.203 align:middle
在watchOS 2中
如果您的app是活跃的 我们将不再那么做

00:27:49.269 --> 00:27:51.405 align:middle
相反WK extension delegate

00:27:51.705 --> 00:27:54.508 align:middle
将会收到
Did Receive Notification调用

00:27:55.275 --> 00:28:00.113 align:middle
您的app将决定如何适当处理
和显示通知的内容

00:27:55.275 --> 00:28:00.113 align:middle
您的app将决定如何适当处理
和显示通知的内容

00:28:00.814 --> 00:28:03.383 align:middle
比如说 如果你在编写一个聊天app

00:28:03.450 --> 00:28:06.954 align:middle
您可能会把内容附加到聊天记录的末尾

00:28:08.288 --> 00:28:10.490 align:middle
同样系统将不再为你显示警告

00:28:10.557 --> 00:28:12.826 align:middle
因此如果您希望用户
了解出现了什么样的通知

00:28:12.893 --> 00:28:14.862 align:middle
您需要将其
呈现在您的UI里面

00:28:16.230 --> 00:28:17.698 align:middle
这个就是我要说的通知内容

00:28:18.232 --> 00:28:19.733 align:middle
接下来我将讲一下模态警告

00:28:22.102 --> 00:28:24.638 align:middle
在WatchOS 1中

00:28:25.072 --> 00:28:29.209 align:middle
您可以取消
隐藏群组的隐藏状态而显示警告

00:28:30.110 --> 00:28:32.846 align:middle
在watchOS 2中我们
允许使用present Alert Controller With Title

00:28:32.913 --> 00:28:36.583 align:middle
这会让对用户呈现模态警告的操作
变得容易得多

00:28:38.318 --> 00:28:42.089 align:middle
在这个调用里面有三个变量
第一个是警告

00:28:42.456 --> 00:28:45.158 align:middle
这是一个简单的调用
告诉用户发生了某些事情

00:28:47.294 --> 00:28:49.396 align:middle
接下来我们有
Side By Side Buttons Alert

00:28:49.463 --> 00:28:54.568 align:middle
这是当前在iOS中向用户
呈现二选一选择的非常流行的方式

00:28:54.635 --> 00:28:59.072 align:middle
我们认为第三方开发者
也希望在他们的应用中使用它

00:29:00.841 --> 00:29:02.643 align:middle
最后我们谈一下 action sheet

00:29:02.776 --> 00:29:06.413 align:middle
action sheet最多有四种
动作外加一个可定制的取消动作

00:29:06.480 --> 00:29:08.282 align:middle
您可以看到Nevermind动作

00:29:08.348 --> 00:29:10.884 align:middle
我已经把Cancel动作定制为Nevermind

00:29:10.951 --> 00:29:13.487 align:middle
各种动作可被选择标记为“毁灭性的”

00:29:13.554 --> 00:29:15.055 align:middle
我是通过delete按钮实现的

00:29:15.122 --> 00:29:16.790 align:middle
目前那意味着它们将以红色显示

00:29:18.025 --> 00:29:22.296 align:middle
一旦用户从Cancel
或四个主要动作中做出选择

00:29:22.362 --> 00:29:25.065 align:middle
您将会收到一个回调
表明哪个按钮被选中

00:29:28.101 --> 00:29:31.839 align:middle
因此总的来说 我们在
watchOS 2中有一个新的架构

00:29:33.607 --> 00:29:35.375 align:middle
我们增加了WK extension delegate

00:29:35.442 --> 00:29:37.311 align:middle
帮您管理您的应用的生命周期

00:29:38.645 --> 00:29:40.247 align:middle
我们有大量的新API

00:29:41.915 --> 00:29:43.250 align:middle
而且当然还会有更多的到来

00:29:45.018 --> 00:29:48.255 align:middle
如果您希望了解关于安德鲁和我
刚才在此所谈内容的更多信息

00:29:48.722 --> 00:29:51.558 align:middle
请查阅
文稿和示例代码

00:29:51.859 --> 00:29:53.360 align:middle
而如果你有具体的疑问

00:29:53.427 --> 00:29:57.197 align:middle
请联系Jake Behrens
地址如下

00:29:57.564 --> 00:29:59.132 align:middle
而且会有大量的相关讲座

00:29:59.766 --> 00:30:03.003 align:middle
包括这里将进行的下一节讲座
也就是我们的讲座的第二部分

00:29:59.766 --> 00:30:03.003 align:middle
包括这里将进行的下一节讲座
也就是我们的讲座的第二部分

00:30:04.004 --> 00:30:05.405 align:middle
那么非常感谢大家的莅临
