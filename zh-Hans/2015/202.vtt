WEBVTT

00:00:20.087 --> 00:00:23.223 align:middle
Cocoa最新内容

00:00:23.290 --> 00:00:23.957 align:middle
下午好

00:00:24.358 --> 00:00:26.059 align:middle
欢迎参加《Cocoa最新内容》讲座

00:00:30.464 --> 00:00:31.832 align:middle
我是阿里•厄泽尔

00:00:32.299 --> 00:00:36.370 align:middle
我是来介绍
今年Cocoa新增了什么内容

00:00:36.570 --> 00:00:37.337 align:middle
主要在三方面：

00:00:37.404 --> 00:00:40.707 align:middle
Swiftificaiton
AppKit和Foundation

00:00:40.908 --> 00:00:43.243 align:middle
我们有许多学习内容
大家一起来深入研究吧

00:00:45.179 --> 00:00:48.549 align:middle
Swiftification 是指
刚完成的API增强版

00:00:48.615 --> 00:00:52.853 align:middle
在多个框架之间
支持Swift语言

00:00:53.153 --> 00:00:56.590 align:middle
这些改进同时完善了
Objective-C API功能

00:00:58.692 --> 00:01:00.494 align:middle
要知道 Swift语言
的功能是

00:00:58.692 --> 00:01:00.494 align:middle
要知道 Swift语言
的功能是

00:01:00.561 --> 00:01:02.429 align:middle
更准确表达API特性

00:01:02.829 --> 00:01:05.299 align:middle
例如可以
声明这是个数组

00:01:05.364 --> 00:01:07.134 align:middle
子视图属性
是NSView数组

00:01:07.201 --> 00:01:09.169 align:middle
但不仅仅是个数组

00:01:09.736 --> 00:01:12.472 align:middle
还可以声明System Font
Of Size方法

00:01:12.539 --> 00:01:15.309 align:middle
返回到NSFont
而且永远不会返回空

00:01:16.043 --> 00:01:18.345 align:middle
例如在Image For
Resource方法中　

00:01:18.412 --> 00:01:20.914 align:middle
NSBundle可以返回零值空
因为它被声明

00:01:20.981 --> 00:01:22.249 align:middle
作为可选的NSImage

00:01:24.518 --> 00:01:27.020 align:middle
我们在Objective-C
启动这些功能

00:01:27.087 --> 00:01:28.455 align:middle
具备通用列的为空性

00:01:28.922 --> 00:01:31.491 align:middle
我会简要介绍
这两方面内容

00:01:31.758 --> 00:01:33.961 align:middle
接着再做
几处调整

00:01:34.194 --> 00:01:37.231 align:middle
让我们的Objective-C和
Swift API效果更好

00:01:38.565 --> 00:01:41.335 align:middle
我们将这些用于
许多框架的API中

00:01:41.401 --> 00:01:44.605 align:middle
不仅是AppKit
和Foundation

00:01:45.072 --> 00:01:48.041 align:middle
这样不仅可以更好地
接触到Swift语言中的API

00:01:48.108 --> 00:01:51.912 align:middle
而且会让
API更为清晰

00:01:52.112 --> 00:01:54.114 align:middle
还能提供编译时间
类型检查功能

00:01:54.181 --> 00:01:55.649 align:middle
这一点当然
很重要

00:01:57.551 --> 00:02:00.888 align:middle
为空性是指
值能否为零

00:01:57.551 --> 00:02:00.888 align:middle
为空性是指
值能否为零

00:02:02.890 --> 00:02:06.093 align:middle
若是使用Swift语言
X v10或iOS 8 SDK

00:02:06.159 --> 00:02:09.930 align:middle
大家已经了解Swift API
具有适当的为空性

00:02:09.997 --> 00:02:11.431 align:middle
和可选的声明
内容

00:02:11.698 --> 00:02:15.169 align:middle
我们已经管理过
手工端数据

00:02:15.235 --> 00:02:16.370 align:middle
以及端文件这方面的内容

00:02:16.436 --> 00:02:19.773 align:middle
在X v11和iOS 9中我们将这
种能力赋予了Objective-C

00:02:20.040 --> 00:02:23.010 align:middle
并有了若干新的关键词这些都加在了O
bjective-C上

00:02:23.443 --> 00:02:27.681 align:middle
非零表示永远不为零值
可为零表示可以为零值

00:02:28.182 --> 00:02:31.652 align:middle
可重置零表示
属性可以设为零值

00:02:31.718 --> 00:02:33.187 align:middle
不过不会返回归零值

00:02:33.320 --> 00:02:35.956 align:middle
马上会给出
一个例子

00:02:36.023 --> 00:02:38.625 align:middle
最后一项也很重要就
是Null Unspecified

00:02:38.692 --> 00:02:39.826 align:middle
也就是未指定的意思

00:02:40.194 --> 00:02:43.063 align:middle
这个用于
不支持的内容

00:02:43.130 --> 00:02:45.065 align:middle
或未经审查的内容

00:02:47.434 --> 00:02:51.471 align:middle
由于API大部分
是非零值的状态

00:02:51.538 --> 00:02:52.906 align:middle
我们还有这样
两种声明：

00:02:52.973 --> 00:02:55.475 align:middle
Assume Nonnull
Begin and End

00:02:55.542 --> 00:02:57.377 align:middle
假设首尾为零
中间即为我们的页眉文件

00:02:57.444 --> 00:02:59.446 align:middle
这样 非零值声明
就没有必要

00:02:59.513 --> 00:03:00.547 align:middle
继续存在了

00:02:59.513 --> 00:03:00.547 align:middle
继续存在了

00:03:00.614 --> 00:03:03.150 align:middle
非零就没必要了

00:03:03.217 --> 00:03:05.419 align:middle
我们在API上
还有另外的声明

00:03:05.752 --> 00:03:08.188 align:middle
我们建议你在页眉文件中
这样使用

00:03:08.255 --> 00:03:10.090 align:middle
如果你有很多
自己的页眉文件

00:03:11.992 --> 00:03:15.262 align:middle
来看部分实例
看看这会怎样影响API

00:03:15.762 --> 00:03:18.265 align:middle
你会看到
NSColorWell的颜色属性

00:03:18.699 --> 00:03:22.102 align:middle
我们没有发布任何声明
那它就该是非零值

00:03:22.503 --> 00:03:25.539 align:middle
在Swift语言中
作为非可选值

00:03:25.606 --> 00:03:26.507 align:middle
色彩属性

00:03:27.040 --> 00:03:29.276 align:middle
另外一方面
NSImageView的图像属性

00:03:29.343 --> 00:03:33.747 align:middle
是可以为零值
也就是说可以设为零值

00:03:33.814 --> 00:03:36.383 align:middle
在Swift语言中
可以作为可选值

00:03:36.783 --> 00:03:39.553 align:middle
最后声明的是
NSMenu的字体属性

00:03:39.620 --> 00:03:42.556 align:middle
是可重置零
这就会成为

00:03:42.623 --> 00:03:44.224 align:middle
隐式解析
可选值

00:03:44.925 --> 00:03:48.095 align:middle
在本例中 这说明
我们可以将值设为零

00:03:48.595 --> 00:03:50.030 align:middle
不过它永远不会返回零值归零

00:03:50.230 --> 00:03:53.700 align:middle
如果从来都不把它设为零
那么NSMenu就会

00:03:53.767 --> 00:03:56.737 align:middle
恢复系统已有的
默认字体

00:03:56.803 --> 00:03:58.672 align:middle
因此 永远不会返回零值归零

00:04:00.407 --> 00:04:03.010 align:middle
存在为空性 你可能会看到
一些建造时间警告

00:04:03.744 --> 00:04:04.878 align:middle
我来给大家看一个例子

00:04:05.179 --> 00:04:07.848 align:middle
如果你有这样的代码
设置颜色属性

00:04:07.915 --> 00:04:11.151 align:middle
ColorWell为零
编译器现在就会给出警告

00:04:11.451 --> 00:04:13.153 align:middle
因为我们做过声明
这个值是非零

00:04:13.720 --> 00:04:16.790 align:middle
这非常好 因为就会成为
如果你有这个代码

00:04:16.857 --> 00:04:19.493 align:middle
并且经过运行
就应该提出一个

00:04:19.560 --> 00:04:20.459 align:middle
参数断言才对

00:04:20.861 --> 00:04:22.863 align:middle
这种情况下
你会收到有关

00:04:22.930 --> 00:04:23.830 align:middle
编译器的警告

00:04:23.897 --> 00:04:24.565 align:middle
非常好

00:04:25.999 --> 00:04:31.071 align:middle
你也许知道 一般而言
在我们的API中

00:04:31.138 --> 00:04:32.306 align:middle
零不是有效目标值

00:04:32.506 --> 00:04:36.076 align:middle
NSString NSArray
NSDictionary等等很容易

00:04:36.143 --> 00:04:40.848 align:middle
表达空值
接受或归零的API

00:04:40.914 --> 00:04:43.951 align:middle
应该把零作为
特殊情况

00:04:44.017 --> 00:04:45.219 align:middle
记录下来

00:04:45.586 --> 00:04:47.721 align:middle
我从API中给出
几个例子来

00:04:48.322 --> 00:04:51.491 align:middle
如果将NSTextView目标
背景色设为零

00:04:51.625 --> 00:04:53.126 align:middle
表示不得有
背景颜色

00:04:53.927 --> 00:04:55.429 align:middle
在许多API的零区域设置

00:04:55.495 --> 00:04:58.632 align:middle
都表示
未经区域设置处理

00:04:58.699 --> 00:04:59.900 align:middle
因此 可以确定一个区域设置

00:04:59.967 --> 00:05:02.703 align:middle
但是如果确定为零
则表示未经区域设置处理

00:04:59.967 --> 00:05:02.703 align:middle
但是如果确定为零
则表示未经区域设置处理

00:05:05.272 --> 00:05:07.341 align:middle
再来谈谈泛型

00:05:08.542 --> 00:05:12.312 align:middle
泛型正如听上去那样
是个轻量级的

00:05:12.379 --> 00:05:16.316 align:middle
参数化类型我们将之加到Object
ive-C上

00:05:16.383 --> 00:05:19.720 align:middle
这对具体元素种类集合
效果很好

00:05:20.687 --> 00:05:23.123 align:middle
这里是个NSSearchField
方面的例子

00:05:23.190 --> 00:05:26.059 align:middle
NSSearchField的
Recent Search属性

00:05:26.126 --> 00:05:27.794 align:middle
是这样声明的
X v10

00:05:27.861 --> 00:05:31.598 align:middle
Recent Searches这一
名称并不十分清晰

00:05:31.665 --> 00:05:33.066 align:middle
其中包括什么内容？

00:05:33.133 --> 00:05:34.635 align:middle
字符串？URL?

00:05:34.701 --> 00:05:35.903 align:middle
搜索目标是什么？

00:05:36.370 --> 00:05:39.907 align:middle
通过X v11 SDK
我们可以进行澄清

00:05:39.973 --> 00:05:42.009 align:middle
这里是NSString数组

00:05:42.376 --> 00:05:45.512 align:middle
Swift声明就是
从任何目标数组

00:05:45.779 --> 00:05:47.281 align:middle
到任何字符串数组

00:05:49.650 --> 00:05:53.187 align:middle
我们采取的方法就是从Foundat
ion中取得NSArray

00:05:53.520 --> 00:05:56.190 align:middle
在加上Object Type数据
等等之类

00:05:56.256 --> 00:05:59.393 align:middle
我们把这个目标类型适用于
所有API

00:05:59.893 --> 00:06:02.763 align:middle
适当的API
以往都是获取或恢复ID

00:05:59.893 --> 00:06:02.763 align:middle
适当的API
以往都是获取或恢复ID

00:06:02.829 --> 00:06:06.133 align:middle
诸如索引目标
包括目标等等

00:06:06.533 --> 00:06:09.903 align:middle
还有许多其他的API
这都适用于NSArray

00:06:10.237 --> 00:06:13.874 align:middle
有了这样的代码
连同Recent Searches

00:06:14.474 --> 00:06:15.809 align:middle
可以说你是有
这样的代码

00:06:16.276 --> 00:06:19.012 align:middle
Recent Searches包括
目标 部分URL

00:06:19.947 --> 00:06:21.181 align:middle
我们在传递NSURL

00:06:21.481 --> 00:06:24.551 align:middle
编译器现在就会给出警告
你在传递URL

00:06:25.118 --> 00:06:27.321 align:middle
这种方式可能会出现
字符串数组

00:06:27.688 --> 00:06:30.190 align:middle
这里非常棒的是
这个代码永远不会出问题

00:06:30.257 --> 00:06:32.626 align:middle
或是出现崩溃
因为URL从来不会

00:06:32.693 --> 00:06:33.861 align:middle
在之前被发现

00:06:33.927 --> 00:06:36.496 align:middle
编译器在告诉你
编码中存在潜在的bug

00:06:36.563 --> 00:06:39.233 align:middle
我们在Foundation中增加了
泛型支持

00:06:39.299 --> 00:06:40.868 align:middle
不仅是对NSArray

00:06:40.934 --> 00:06:43.937 align:middle
而是对所有其他集合
NSEnumerator也包括在内

00:06:44.004 --> 00:06:48.108 align:middle
严格来讲 当然
甚至不止是集合

00:06:48.542 --> 00:06:50.477 align:middle
将之适用于
非集合也同样可行

00:06:51.078 --> 00:06:55.249 align:middle
现在连同泛型一起
也可以通过不同的声明

00:06:55.315 --> 00:06:57.451 align:middle
使用这些
按照自己的分类

00:06:57.885 --> 00:07:00.854 align:middle
如果你拿到Recent
Searches的结果 并将之

00:06:57.885 --> 00:07:00.854 align:middle
如果你拿到Recent
Searches的结果 并将之

00:07:00.921 --> 00:07:04.691 align:middle
赋予自己的属性
那就可以继续 并且声明

00:07:04.758 --> 00:07:07.861 align:middle
这是NSArray of
NSString 可以将该类型

00:07:07.961 --> 00:07:09.530 align:middle
通过自己的代码
进行传播

00:07:10.664 --> 00:07:12.065 align:middle
你可以声明
自己的API属性

00:07:12.132 --> 00:07:14.401 align:middle
这里是文件NSS数组

00:07:14.468 --> 00:07:15.235 align:middle
是什么？

00:07:15.302 --> 00:07:16.403 align:middle
字符串还是URL?

00:07:16.904 --> 00:07:17.938 align:middle
可以更明确些

00:07:18.605 --> 00:07:21.275 align:middle
将通用列适用于
自定义集合

00:07:21.341 --> 00:07:23.610 align:middle
如果有任何这样的集合
甚至是在基础集合中

00:07:23.677 --> 00:07:24.811 align:middle
有你的自定义类别

00:07:25.546 --> 00:07:28.215 align:middle
例如
NSArray的类别

00:07:29.082 --> 00:07:32.219 align:middle
你可以直接进入添加
就在自己的代码中即可

00:07:32.286 --> 00:07:34.721 align:middle
这些泛型通用列
也同样适用于类别

00:07:37.991 --> 00:07:43.163 align:middle
现在又有一个功能
加在了Objective-C上

00:07:43.630 --> 00:07:46.200 align:middle
我们来讲解一下
为什么需要这么做

00:07:46.667 --> 00:07:48.235 align:middle
这就是子视图
声明在

00:07:48.302 --> 00:07:49.837 align:middle
X v10中的模样

00:07:49.903 --> 00:07:54.775 align:middle
这是我们第一次尝试
应用泛型

00:07:55.442 --> 00:07:58.145 align:middle
子视图改变为
NSArray of NSView

00:07:58.812 --> 00:08:02.482 align:middle
那么代码就是这样
即把数组之外的元素

00:07:58.812 --> 00:08:02.482 align:middle
那么代码就是这样
即把数组之外的元素

00:08:02.549 --> 00:08:04.117 align:middle
赋值给NSButton

00:08:04.952 --> 00:08:07.221 align:middle
这就轮到编译器
着急了

00:08:07.754 --> 00:08:10.991 align:middle
编译器总是替我们担心
很是操心

00:08:11.458 --> 00:08:12.492 align:middle
它会发出警告

00:08:12.960 --> 00:08:15.562 align:middle
为什么？因为我们在把外明显
声明属于NSView的内容

00:08:15.629 --> 00:08:18.632 align:middle
赋值给了
NSView的子类

00:08:18.832 --> 00:08:20.801 align:middle
难怪编辑器会
有所担心了

00:08:21.335 --> 00:08:23.670 align:middle
但是这类代码
我们使用得很多

00:08:23.737 --> 00:08:25.038 align:middle
而且还常常有效

00:08:25.639 --> 00:08:28.575 align:middle
因此 添加了这类关键字
并且将

00:08:28.842 --> 00:08:33.480 align:middle
子视图属性的声明改为这类NSArr
ay of NSViews的

00:08:33.914 --> 00:08:35.148 align:middle
得出的就是...

00:08:39.886 --> 00:08:40.554 align:middle
谢谢

00:08:41.621 --> 00:08:44.858 align:middle
...感谢大家没注意
这边栏目下的内容

00:08:45.626 --> 00:08:48.028 align:middle
这是说 调用者
可以访问

00:08:48.095 --> 00:08:50.764 align:middle
数组元素
如具体类的例子

00:08:50.831 --> 00:08:54.101 align:middle
或者是说
子类的例子也可

00:08:54.835 --> 00:08:56.937 align:middle
现在来看 效果可以

00:08:57.604 --> 00:09:02.042 align:middle
注意
这类编译时功能

00:08:57.604 --> 00:09:02.042 align:middle
注意
这类编译时功能

00:09:02.109 --> 00:09:04.211 align:middle
和我在这里谈到的
大多数其他内容一样

00:09:04.678 --> 00:09:07.347 align:middle
并没有改变
运行时间代码

00:09:08.382 --> 00:09:11.185 align:middle
例如 并未检查
运行时间类型

00:09:11.585 --> 00:09:13.987 align:middle
有些时候 我们希望
调用者可以考虑一下

00:09:14.054 --> 00:09:16.924 align:middle
元素的情况
再去访问它们

00:09:17.391 --> 00:09:20.460 align:middle
我们将在API中
做少量使用

00:09:20.527 --> 00:09:22.162 align:middle
并推荐大家
也这么做

00:09:22.396 --> 00:09:24.398 align:middle
当调用者可以安全使用时
它们就应该能用了

00:09:24.464 --> 00:09:25.566 align:middle
假设一下

00:09:25.899 --> 00:09:27.434 align:middle
如果你希望调用者
审慎行事

00:09:27.501 --> 00:09:29.803 align:middle
或是进行运行时间查询
那就别这么用

00:09:30.237 --> 00:09:31.872 align:middle
举例来说
NSImage的

00:09:31.939 --> 00:09:33.974 align:middle
Representations法
就是这样

00:09:34.041 --> 00:09:35.876 align:middle
它返还成NSImage
数组表示法

00:09:36.076 --> 00:09:40.080 align:middle
它经常会被细分成子类
而且几乎总是如此

00:09:40.547 --> 00:09:42.082 align:middle
不过我们不会
在这里用到这类

00:09:42.149 --> 00:09:44.618 align:middle
因为这类表示法
并非总是能够

00:09:44.918 --> 00:09:47.621 align:middle
具有可预见性
实际上

00:09:47.688 --> 00:09:50.324 align:middle
可能会在应用运行时间内
在OS发布期间

00:09:50.390 --> 00:09:52.159 align:middle
发生改变

00:09:52.226 --> 00:09:54.494 align:middle
最好是让调用者
在这里多加小心

00:09:54.561 --> 00:09:55.863 align:middle
进行运行时间检查

00:09:59.166 --> 00:10:00.968 align:middle
我们在来谈谈
错误处理

00:09:59.166 --> 00:10:00.968 align:middle
我们在来谈谈
错误处理

00:10:01.034 --> 00:10:03.837 align:middle
昨天大家听到了
Swift 2具备神奇的

00:10:03.904 --> 00:10:06.340 align:middle
错误处理功能

00:10:08.242 --> 00:10:11.345 align:middle
对于这种在NSData上
写入URL选项的错误方法

00:10:11.445 --> 00:10:15.349 align:middle
具体意思就是
在Swift里的样子

00:10:15.415 --> 00:10:18.218 align:middle
Boolean回归值不见了
现在非常明显

00:10:18.552 --> 00:10:21.421 align:middle
错误可以参考
NSError参数

00:10:21.722 --> 00:10:24.525 align:middle
也不见了 因为是被
抛出语句所捕捉

00:10:24.958 --> 00:10:27.861 align:middle
这类代码
就是需要处理的

00:10:28.495 --> 00:10:29.997 align:middle
正如你可以在
捕捉语句中所见

00:10:30.063 --> 00:10:32.933 align:middle
可以捕捉到错误
如果是可以自动

00:10:32.999 --> 00:10:34.835 align:middle
被捕获
或是由你来发出声明

00:10:34.902 --> 00:10:36.737 align:middle
你可以声明不同的
捕捉语句

00:10:36.803 --> 00:10:38.005 align:middle
这也完全可以

00:10:38.071 --> 00:10:39.806 align:middle
非常好 直截了当

00:10:39.873 --> 00:10:41.875 align:middle
现在还有一点

00:10:42.042 --> 00:10:45.145 align:middle
注意这里的所有术语
抛出 异常捕捉

00:10:45.212 --> 00:10:47.447 align:middle
等等 无外乎
就是这些

00:10:47.514 --> 00:10:48.916 align:middle
对Objective-C而言

00:10:48.982 --> 00:10:50.551 align:middle
我们也不会
特殊对待

00:10:50.617 --> 00:10:53.720 align:middle
我们实际是在返回错误
通过这样的堆栈

00:10:53.787 --> 00:10:58.125 align:middle
妥善解决问题
就这么处理NSErrors

00:10:58.825 --> 00:11:01.361 align:middle
实际上 NSError指南
还适用于

00:10:58.825 --> 00:11:01.361 align:middle
实际上 NSError指南
还适用于

00:11:01.461 --> 00:11:03.697 align:middle
Swift错误处理

00:11:03.797 --> 00:11:08.001 align:middle
使用NSErrors和Swift
错误处理应对运行时间问题

00:11:08.068 --> 00:11:10.604 align:middle
准备给用户展示的错误
或是需要处理

00:11:10.671 --> 00:11:12.940 align:middle
运行时间 如文件未能找到
等等

00:11:13.006 --> 00:11:16.510 align:middle
我们继续使用例外
或Swift断言

00:11:16.577 --> 00:11:19.513 align:middle
处理编程问题
如界外索引数组

00:11:20.314 --> 00:11:22.683 align:middle
当然最后一类
错误是

00:11:22.749 --> 00:11:24.751 align:middle
不可能被
捕捉到的

00:11:25.752 --> 00:11:28.388 align:middle
还有一个Swiftificatio
n项叫做清理

00:11:29.189 --> 00:11:32.326 align:middle
你们可能是该走了
我们还有许多名称可以列举

00:11:32.392 --> 00:11:35.829 align:middle
从很久以前开始
我们用公共后缀

00:11:35.896 --> 00:11:38.498 align:middle
而不是公共前缀
在部分情况中

00:11:38.565 --> 00:11:40.501 align:middle
我们做了修改 不是全部
有了公共前缀

00:11:40.567 --> 00:11:41.702 align:middle
也就是说

00:11:41.768 --> 00:11:43.370 align:middle
在Swift语言中
会有更好的名称

00:11:43.437 --> 00:11:45.405 align:middle
不是按照点左边文本对齐
而是改成了

00:11:45.472 --> 00:11:46.807 align:middle
dot.left格式

00:11:46.874 --> 00:11:48.475 align:middle
这样的例子
还有许多

00:11:48.709 --> 00:11:51.378 align:middle
注意很多情况下
我们实际上不支持

00:11:51.445 --> 00:11:54.414 align:middle
旧名称 因此你的源文件
将会继续编译

00:11:54.481 --> 00:11:56.884 align:middle
但是可以改为新名称
重写编码即可

00:11:59.019 --> 00:12:00.621 align:middle
这类还有很多

00:11:59.019 --> 00:12:00.621 align:middle
这类还有很多

00:12:01.021 --> 00:12:03.156 align:middle
这样我们就可以
来谈AppKit

00:12:04.291 --> 00:12:06.193 align:middle
有许多AppKit方面的话题
我都很喜欢

00:12:06.260 --> 00:12:08.028 align:middle
来聊聊
先来谈一部分

00:12:08.095 --> 00:12:13.600 align:middle
说明一点：从这里
我会更多通过Swift

00:12:13.667 --> 00:12:15.602 align:middle
介绍API
和代码样本

00:12:16.203 --> 00:12:18.639 align:middle
如果你对Swift
还不是很习惯

00:12:19.072 --> 00:12:21.408 align:middle
也不必担心
因为我提到的代码

00:12:21.475 --> 00:12:22.643 align:middle
不会那么难

00:12:22.743 --> 00:12:23.911 align:middle
毕竟 我不过是个经理

00:12:24.478 --> 00:12:25.612 align:middle
需要注意的是...

00:12:26.180 --> 00:12:27.314 align:middle
这一点非常重要

00:12:27.381 --> 00:12:31.451 align:middle
这些API在Objective-C
和Swift中均可得到

00:12:31.552 --> 00:12:33.253 align:middle
那么 我们就不是只给
大家展示仅适用于

00:12:33.320 --> 00:12:35.322 align:middle
Objective-C或Swift
的东西

00:12:35.389 --> 00:12:37.090 align:middle
无论是使用哪种语言
均可以适用

00:12:38.492 --> 00:12:43.630 align:middle
要知道 新的Force Touch
触摸板使用压力感应的同时

00:12:43.697 --> 00:12:46.700 align:middle
也用到了
触觉反馈

00:12:46.800 --> 00:12:49.636 align:middle
这就为更多有趣应用
带来了可能

00:12:49.703 --> 00:12:51.471 align:middle
来看部分实例

00:12:53.006 --> 00:12:56.877 align:middle
例如这里在部分文字上使用Force
Click

00:12:56.944 --> 00:12:59.713 align:middle
可以实现查找
或是自动生成

00:12:59.780 --> 00:13:00.881 align:middle
日历活动

00:12:59.780 --> 00:13:00.881 align:middle
日历活动

00:13:01.615 --> 00:13:03.617 align:middle
这种情况下
通过按压

00:13:03.684 --> 00:13:05.752 align:middle
快进按钮
就可以让影片

00:13:05.819 --> 00:13:07.354 align:middle
快进速度加快

00:13:08.488 --> 00:13:12.993 align:middle
这里通过划细线或粗线
进行点压

00:13:13.260 --> 00:13:16.029 align:middle
就可以签上自己的名字
或是在标记中写写画画

00:13:17.331 --> 00:13:20.934 align:middle
最后 在这种情况下
把目标移到程序

00:13:21.001 --> 00:13:23.937 align:middle
比如Xcode的界面
把开发程序或绘图程序

00:13:24.304 --> 00:13:27.574 align:middle
作为对齐目标
就会得到触感反馈

00:13:29.243 --> 00:13:32.613 align:middle
现在还有部分Force Touch
API在 X v10.3中出现

00:13:32.679 --> 00:13:34.781 align:middle
有人可能见过

00:13:35.148 --> 00:13:37.384 align:middle
首先 用加速器
控制API

00:13:38.252 --> 00:13:40.888 align:middle
这些API诠释不同压力
可以用于创建

00:13:40.954 --> 00:13:43.557 align:middle
类似快进按钮
或是在

00:13:43.624 --> 00:13:45.025 align:middle
类似地图应用中
生成放大按钮

00:13:45.092 --> 00:13:48.629 align:middle
还可以在NSButton上在NS
SegmentedControl里

00:13:48.695 --> 00:13:50.063 align:middle
设置加速器控制

00:13:50.230 --> 00:13:51.665 align:middle
如果希望再
玩的高深一些

00:13:51.732 --> 00:13:55.235 align:middle
我们可以提供一个事件
新的压力事件类型

00:13:55.302 --> 00:13:57.704 align:middle
与 NSResponder
和手势识别等

00:13:57.971 --> 00:13:59.706 align:middle
对应方式相匹配
也同样可行

00:13:59.773 --> 00:14:01.842 align:middle
通过事件实现
Pressure Change

00:13:59.773 --> 00:14:01.842 align:middle
通过事件实现
Pressure Change

00:14:01.909 --> 00:14:03.410 align:middle
可以自己来诠释
压力事件

00:14:04.378 --> 00:14:08.215 align:middle
在X v11当中
我们引入了诸多新类型

00:14:08.282 --> 00:14:10.117 align:middle
一个是压力配置
分类

00:14:10.517 --> 00:14:12.452 align:middle
你来设置压力配置
通过视图

00:14:12.519 --> 00:14:13.754 align:middle
或手势识别

00:14:14.021 --> 00:14:16.390 align:middle
表明触摸板
该如何反应

00:14:16.924 --> 00:14:18.926 align:middle
一般来说
为用户提供的触感反馈

00:14:18.992 --> 00:14:20.227 align:middle
将取决于

00:14:20.294 --> 00:14:22.462 align:middle
所确定的
压力配置

00:14:22.963 --> 00:14:26.033 align:middle
还有另外两个分类
触感反馈管理器

00:14:26.099 --> 00:14:28.335 align:middle
和对齐反馈过滤器
允许你对此类

00:14:28.402 --> 00:14:31.038 align:middle
提供给用户的触感反馈
进行定制化处理

00:14:34.074 --> 00:14:38.345 align:middle
很多人可能都用过
弹簧载荷

00:14:38.745 --> 00:14:41.949 align:middle
就是说拖动一下
并且在目标附近

00:14:42.015 --> 00:14:44.651 align:middle
围绕时 目标会
向你开放

00:14:44.818 --> 00:14:46.220 align:middle
在Finder中可以这么使用

00:14:46.687 --> 00:14:47.988 align:middle
通过Force Click

00:14:48.055 --> 00:14:51.124 align:middle
可以肯定的是
只需用力点击目标

00:14:51.191 --> 00:14:54.361 align:middle
弹簧载荷就会
立即启动

00:14:55.128 --> 00:14:59.466 align:middle
我们还有新的API
让弹簧载荷更加便捷

00:14:59.533 --> 00:15:02.703 align:middle
就是个简单的Boolean属性
NSButton和

00:14:59.533 --> 00:15:02.703 align:middle
就是个简单的Boolean属性
NSButton和

00:15:02.769 --> 00:15:05.372 align:middle
NSSegmentedContro
l就启用了弹簧载荷

00:15:05.439 --> 00:15:08.408 align:middle
可以感知附近的动作或是Force
Click给出的指示

00:15:08.475 --> 00:15:09.576 align:middle
非常直观

00:15:09.943 --> 00:15:14.381 align:middle
如果这并不能完全满足需求
我们还有新的协议

00:15:14.448 --> 00:15:17.651 align:middle
NSSpringLoadingDe
stination通过它即可

00:15:17.718 --> 00:15:19.520 align:middle
在任意目标上
实现弹簧载荷

00:15:20.020 --> 00:15:22.322 align:middle
例如 Finder的那个例子
就很适合这里

00:15:24.291 --> 00:15:26.827 align:middle
手指滑动即可删除
大家对这都很熟悉

00:15:26.894 --> 00:15:29.663 align:middle
昨天在主旨演讲中
就见过类似的东西

00:15:29.963 --> 00:15:33.233 align:middle
iOS里这种东西也很常见
可以在桌面视图

00:15:33.300 --> 00:15:37.971 align:middle
例如邮箱信息上
左右滑动

00:15:38.038 --> 00:15:40.908 align:middle
标识信息是否读过
或是否删除等等

00:15:40.974 --> 00:15:43.477 align:middle
我们现在也有这样的API
也是在EI Capitan中

00:15:43.544 --> 00:15:45.312 align:middle
是NSTableView的委托方式

00:15:45.379 --> 00:15:47.047 align:middle
Row Action是
用于Row

00:15:47.548 --> 00:15:50.684 align:middle
只需返回到
NSTableView行处理数组

00:15:51.051 --> 00:15:55.422 align:middle
本类的例子
只是声明这些项和行

00:15:55.489 --> 00:15:59.193 align:middle
应该怎样拖动
当用户选择

00:15:59.259 --> 00:16:01.662 align:middle
当用户选择通过
代码块处理时

00:15:59.259 --> 00:16:01.662 align:middle
当用户选择通过
代码块处理时

00:16:01.762 --> 00:16:02.696 align:middle
最后是代码块

00:16:04.498 --> 00:16:05.832 align:middle
这些话题
简单讲一下即可

00:16:06.233 --> 00:16:08.969 align:middle
有个讲座
《采用触控板新功能》

00:16:09.036 --> 00:16:11.772 align:middle
是周四上午十点
其中会介绍

00:16:11.839 --> 00:16:14.408 align:middle
这类话题的
更多详细内容

00:16:15.576 --> 00:16:18.178 align:middle
全屏部分
昨天已经介绍过了

00:16:18.312 --> 00:16:21.548 align:middle
全屏可以将分散注意
的因素去除 便于集中精力

00:16:21.615 --> 00:16:24.218 align:middle
处理单项任务
就像现在这样

00:16:24.484 --> 00:16:28.956 align:middle
通过在全屏分割视图
可以关注一个任务

00:16:29.022 --> 00:16:30.791 align:middle
但可以打开
其他窗口

00:16:30.858 --> 00:16:33.961 align:middle
例如 你在使用
Xcode 再启用Safari

00:16:34.027 --> 00:16:36.697 align:middle
查询部分文档
或其他论坛

00:16:36.997 --> 00:16:38.899 align:middle
可以想象
把信息放到Xcode旁边

00:16:38.966 --> 00:16:41.969 align:middle
因为你想和
一个朋友聊聊

00:16:42.035 --> 00:16:43.070 align:middle
正在编的代码

00:16:43.704 --> 00:16:45.973 align:middle
这叫做叠加
窗口放在

00:16:46.540 --> 00:16:47.541 align:middle
分割视图中

00:16:48.642 --> 00:16:51.445 align:middle
叠加自动会用于
多个窗口的情况

00:16:52.880 --> 00:16:55.682 align:middle
叠加可以自动适用于
可调整窗口的情况

00:16:55.749 --> 00:16:56.984 align:middle
也就是说 你的应用

00:16:57.050 --> 00:16:58.318 align:middle
应用中
的窗口

00:16:58.385 --> 00:17:01.355 align:middle
将自动在全屏状态
彼此叠加

00:16:58.385 --> 00:17:01.355 align:middle
将自动在全屏状态
彼此叠加

00:17:01.421 --> 00:17:02.789 align:middle
你这边无需
做任何调整

00:17:03.156 --> 00:17:05.392 align:middle
无论是窗口是
可以全屏还是不可

00:17:06.093 --> 00:17:09.162 align:middle
不过有个API
可以选择出入叠加状态

00:17:09.262 --> 00:17:12.065 align:middle
这是NSWindow的
NSWindow集合行为

00:17:12.132 --> 00:17:13.200 align:middle
选项的一部分

00:17:13.700 --> 00:17:15.602 align:middle
例如 你有个
不可调整的窗口

00:17:15.669 --> 00:17:17.237 align:middle
而你以为是可以
进行叠加

00:17:17.704 --> 00:17:19.973 align:middle
可以使用
Allowd Tiling选项

00:17:20.140 --> 00:17:22.075 align:middle
若你有一个非社交窗口

00:17:22.142 --> 00:17:23.277 align:middle
而且不希望
被叠加

00:17:23.343 --> 00:17:25.579 align:middle
可是设置
Disallows Tiling

00:17:25.646 --> 00:17:28.248 align:middle
我不清楚那个例子
不过它就在那里

00:17:28.649 --> 00:17:31.685 align:middle
这些是全屏的
主要设置

00:17:31.752 --> 00:17:34.221 align:middle
这些已经在
X v7中都有

00:17:34.288 --> 00:17:37.024 align:middle
很重要的是
要注意全屏主要是这样

00:17:37.090 --> 00:17:41.361 align:middle
需要确定
需要全屏的窗口

00:17:41.728 --> 00:17:44.097 align:middle
注意还有许多
选择性加入

00:17:44.698 --> 00:17:47.668 align:middle
因为你需要了解窗口
在全屏的整个

00:17:47.801 --> 00:17:50.003 align:middle
屏幕空间
如何反应

00:17:50.337 --> 00:17:53.073 align:middle
还有一个可选择
功能可以考虑

00:17:53.140 --> 00:17:55.142 align:middle
怎样让你的窗口
在全屏工作

00:17:55.209 --> 00:17:56.743 align:middle
这一项仍可以选择

00:18:00.247 --> 00:18:03.116 align:middle
当然也可以在Xcode
属性检查器中设置

00:18:03.183 --> 00:18:04.785 align:middle
当然可以是设置

00:18:04.852 --> 00:18:06.687 align:middle
叠加或窗口是否
该全屏之类

00:18:06.753 --> 00:18:10.190 align:middle
我说过 很多窗口都
可以自动叠加

00:18:10.490 --> 00:18:12.159 align:middle
不过AppKit可以查看

00:18:12.226 --> 00:18:14.795 align:middle
确定窗口是否可以
在同一个屏幕共存

00:18:15.195 --> 00:18:16.964 align:middle
设想你的屏幕
相对较小

00:18:17.030 --> 00:18:20.801 align:middle
还有两个很大的窗口
你希望能把它们叠加

00:18:20.868 --> 00:18:22.970 align:middle
如果窗口无法
缩小到足够小

00:18:23.036 --> 00:18:24.838 align:middle
AppKit将无法
实现叠加窗口

00:18:24.905 --> 00:18:29.176 align:middle
我希望你想想
怎样让窗口足够小

00:18:29.243 --> 00:18:31.812 align:middle
如何才能灵活
处理使其

00:18:31.879 --> 00:18:35.582 align:middle
能在更小的空间
叠加分割视图

00:18:36.149 --> 00:18:38.218 align:middle
为实现这一点
我们有一些API

00:18:39.253 --> 00:18:41.855 align:middle
例如 分割视图项
现在是侧边栏的动作

00:18:42.155 --> 00:18:44.725 align:middle
侧边栏变小
并消失

00:18:44.791 --> 00:18:47.127 align:middle
这样就可以
实现重叠

00:18:47.561 --> 00:18:48.996 align:middle
也可以有适当的震动

00:18:49.830 --> 00:18:53.233 align:middle
NSStackView可以自动
查出隐藏的视图

00:18:53.300 --> 00:18:56.036 align:middle
帮你创建类似
NSToolbar的体验

00:18:56.103 --> 00:18:58.338 align:middle
适用于定制化视图
可以把

00:18:58.405 --> 00:19:00.207 align:middle
拖到边缘的项

00:18:58.405 --> 00:19:00.207 align:middle
拖到边缘的项

00:19:00.340 --> 00:19:04.444 align:middle
放入菜单
诸如此类 还有许多

00:19:04.678 --> 00:19:05.679 align:middle
你可以去听听

00:19:05.746 --> 00:19:07.814 align:middle
《改善全屏视窗体验》
的讲座

00:19:07.881 --> 00:19:09.082 align:middle
时间是周四下午

00:19:11.885 --> 00:19:14.555 align:middle
要知道Auto Layout
也很重要

00:19:14.621 --> 00:19:16.690 align:middle
我们做了部分
重要调整

00:19:16.757 --> 00:19:19.626 align:middle
极大提高了
Auto Layout的表现

00:19:19.960 --> 00:19:21.161 align:middle
首先是堆栈视图

00:19:21.595 --> 00:19:25.265 align:middle
堆栈视图是个
很重要的分类

00:19:25.532 --> 00:19:28.302 align:middle
在满足Auto Layout需求时
应该首先想到这个

00:19:28.368 --> 00:19:29.970 align:middle
如果你可以了解
堆栈视图中

00:19:30.037 --> 00:19:31.104 align:middle
可以做什么

00:19:31.171 --> 00:19:33.140 align:middle
而不是直接使用
种种约束会好得多

00:19:33.507 --> 00:19:36.410 align:middle
这是很大程度上的抽象
非常强大

00:19:36.844 --> 00:19:39.813 align:middle
关于堆栈视图的好消息是
在iOS上也可以使用

00:19:39.880 --> 00:19:43.116 align:middle
因为UI堆栈视图
和在API的效果不相上下

00:19:43.183 --> 00:19:46.119 align:middle
这和我们一直以来的努力
相一致

00:19:46.186 --> 00:19:49.056 align:middle
即在不同平台间
实现奇偶校验效果

00:19:49.122 --> 00:19:50.457 align:middle
这就是具体的
一个实例

00:19:50.858 --> 00:19:52.759 align:middle
第二 现在这方面
比以往做得更好

00:19:52.826 --> 00:19:55.495 align:middle
我已经说过
有个分离功能

00:19:55.929 --> 00:19:58.031 align:middle
还有几个
新视图分布选项

00:19:58.098 --> 00:19:59.600 align:middle
具备这个属性
叫做分布

00:20:01.201 --> 00:20:03.203 align:middle
这里有一个值
是重力区

00:20:03.270 --> 00:20:07.441 align:middle
在介绍X v9的第一天起
大家就见过

00:20:07.508 --> 00:20:09.309 align:middle
堆栈视图的选项

00:20:09.376 --> 00:20:11.245 align:middle
我们已经加上其他设置

00:20:11.311 --> 00:20:12.613 align:middle
这些就不必
继续解释了

00:20:13.046 --> 00:20:14.548 align:middle
给大家看一个短视频

00:20:15.582 --> 00:20:18.452 align:middle
有6个堆栈视图
构成这些设置

00:20:18.519 --> 00:20:20.954 align:middle
我重新调整窗口
稍大一些

00:20:21.021 --> 00:20:22.523 align:middle
小一些 再大些

00:20:22.723 --> 00:20:25.292 align:middle
你们看 还是有些
强大的功能的

00:20:25.359 --> 00:20:27.861 align:middle
比如设定等大
等距这些

00:20:27.928 --> 00:20:31.231 align:middle
等等 希望能够
满足你们的需要

00:20:31.431 --> 00:20:34.334 align:middle
堆栈视图可以
任意放置

00:20:34.401 --> 00:20:36.336 align:middle
方便设置布局

00:20:36.937 --> 00:20:40.140 align:middle
NSLayoutAnchor是个新
类别可以提供

00:20:40.374 --> 00:20:42.643 align:middle
边或尺寸的
精确表示法

00:20:43.043 --> 00:20:44.311 align:middle
比如 你有
两个视图

00:20:44.378 --> 00:20:45.712 align:middle
打算创建
二者间的约束

00:20:46.313 --> 00:20:47.881 align:middle
这就是必须
编写的代码

00:20:48.549 --> 00:20:51.919 align:middle
有着布局锚点
可以编写这个代码

00:20:52.519 --> 00:20:55.355 align:middle
注意 这两项
基本上是布局锚点

00:20:55.422 --> 00:20:58.292 align:middle
是指那些
视图的边缘

00:20:58.659 --> 00:21:00.694 align:middle
结果不仅更短
更好看

00:20:58.659 --> 00:21:00.694 align:middle
结果不仅更短
更好看

00:21:00.761 --> 00:21:03.964 align:middle
而且还提供了
更多编辑时间类型检查

00:21:04.031 --> 00:21:04.698 align:middle
非常好

00:21:10.270 --> 00:21:13.040 align:middle
NSLayout Guide 是又一个新分类

00:21:13.674 --> 00:21:15.809 align:middle
如果你在做
这类事情

00:21:15.876 --> 00:21:20.514 align:middle
创建虚拟视图
实现视图间

00:21:20.581 --> 00:21:24.051 align:middle
等距效果 那么
可以试试创建布局指南

00:21:24.117 --> 00:21:27.187 align:middle
这是个轻量级对象
占据了视图的位置

00:21:27.254 --> 00:21:29.756 align:middle
不过其实它的量级更轻
可以参与

00:21:29.823 --> 00:21:31.792 align:middle
Auto Layout
而不会生成视图

00:21:33.293 --> 00:21:35.863 align:middle
我们已经了解过
集合视图

00:21:36.296 --> 00:21:39.666 align:middle
要知道 UICollection
View 也有过几个

00:21:39.766 --> 00:21:41.368 align:middle
版本了

00:21:41.802 --> 00:21:44.371 align:middle
有着X v11 我们将
NSCollectionView

00:21:44.438 --> 00:21:47.608 align:middle
iOS版本进行奇偶校验
都是保持重要功能

00:21:47.674 --> 00:21:50.210 align:middle
用于桌面 例如
拖拽和批量选择

00:21:50.811 --> 00:21:53.347 align:middle
现在是新的集合视图中
部分功能

00:21:53.814 --> 00:21:56.283 align:middle
有些功能如
异构项

00:21:56.350 --> 00:21:58.385 align:middle
选择性分组
可定制布局

00:21:58.852 --> 00:22:01.622 align:middle
我来给大家看个短视频
是样本应用

00:21:58.852 --> 00:22:01.622 align:middle
我来给大家看个短视频
是样本应用

00:22:02.055 --> 00:22:03.490 align:middle
会有很多图像
显示出来

00:22:03.557 --> 00:22:08.328 align:middle
我首先依照页眉和页脚
进行分组 会用到

00:22:08.395 --> 00:22:10.497 align:middle
部分定制布局
是本款app所提供

00:22:11.665 --> 00:22:14.935 align:middle
来看app的实际应用
了解具体功能

00:22:15.002 --> 00:22:17.204 align:middle
以及如何用于自己的应用中
《集合视图最新内容》

00:22:17.271 --> 00:22:20.207 align:middle
周四下午4:30
会有介绍

00:22:22.442 --> 00:22:23.877 align:middle
在文本方面
我们的改动很多

00:22:24.178 --> 00:22:25.946 align:middle
首先是新的系统UI字体

00:22:27.514 --> 00:22:30.384 align:middle
新系统的字体
是这样San Francisco

00:22:30.450 --> 00:22:35.122 align:middle
要知道　这和iOS和watchOS
上的字体一样

00:22:35.822 --> 00:22:39.092 align:middle
字体是自动
提供应用的

00:22:39.159 --> 00:22:41.895 align:middle
在 El Capitan的
X v11 运行你的应用

00:22:41.962 --> 00:22:42.930 align:middle
就会得到这个字体

00:22:42.996 --> 00:22:44.765 align:middle
不过可能
你做了什么

00:22:44.831 --> 00:22:45.966 align:middle
阻止了这项功能

00:22:46.033 --> 00:22:49.570 align:middle
如果看到这个字体
这是在X v10中推出的

00:22:49.736 --> 00:22:53.540 align:middle
还有些内容在继续
检查一下是否是你所需

00:22:53.607 --> 00:22:56.343 align:middle
确保你是在使用San
Francisco这种字体

00:22:56.443 --> 00:23:00.280 align:middle
如果在用这种字体
我们是在X v0当中推出

00:22:56.443 --> 00:23:00.280 align:middle
如果在用这种字体
我们是在X v0当中推出

00:23:00.347 --> 00:23:02.516 align:middle
还会有更多内容继续

00:23:02.983 --> 00:23:05.886 align:middle
最后 如果你在
使用这款字体...

00:23:08.088 --> 00:23:09.690 align:middle
...那么会有很多工作要做

00:23:09.756 --> 00:23:10.624 align:middle
稍等一下

00:23:11.491 --> 00:23:13.827 align:middle
这就是我们不再
使用的Mac OS 9字体

00:23:16.163 --> 00:23:18.332 align:middle
这是在API可以使用的
NSFont字体

00:23:18.398 --> 00:23:20.734 align:middle
确保自己用的是
最新版本的系统字体

00:23:21.134 --> 00:23:22.769 align:middle
还有系统字体大小等等

00:23:22.836 --> 00:23:25.873 align:middle
这些字体
这些API

00:23:25.939 --> 00:23:27.274 align:middle
我们用了很久

00:23:28.742 --> 00:23:32.212 align:middle
可以通过Xcode属性检查器
设置系统字体

00:23:32.713 --> 00:23:34.748 align:middle
非常简单
会有弹出窗口

00:23:34.815 --> 00:23:36.683 align:middle
选择适当的
系统字体

00:23:36.750 --> 00:23:37.885 align:middle
用于自己的应用

00:23:39.453 --> 00:23:41.922 align:middle
我们还有一款新API
可用于不同粗细的系统字体

00:23:42.489 --> 00:23:45.959 align:middle
如果设计师让你
使用不同粗细字体

00:23:46.426 --> 00:23:49.062 align:middle
现在就可以用这个
API调整系统字体

00:23:49.263 --> 00:23:51.331 align:middle
系统字体大小和粗细

00:23:52.032 --> 00:23:54.635 align:middle
有预设的9种
不同粗细

00:23:54.701 --> 00:23:56.403 align:middle
我只给大家看
其中三种

00:23:56.603 --> 00:23:58.038 align:middle
从超细
到黑体都有

00:23:58.472 --> 00:24:00.574 align:middle
常规设置是
系统字体大小

00:23:58.472 --> 00:24:00.574 align:middle
常规设置是
系统字体大小

00:24:00.641 --> 00:24:02.109 align:middle
默认值

00:24:02.676 --> 00:24:06.914 align:middle
我们还有一款API
单距系统字体大小粗细

00:24:07.481 --> 00:24:08.949 align:middle
我给大家看看
为什么这东西有用

00:24:09.983 --> 00:24:14.221 align:middle
如果调用应用中的
字体大小API

00:24:14.288 --> 00:24:16.590 align:middle
链接是X v11 SDK

00:24:16.657 --> 00:24:19.092 align:middle
在写几个数字
就是这个效果

00:24:19.626 --> 00:24:24.031 align:middle
对字体很敏感的眼睛
估计一下子就会感到不同

00:24:24.131 --> 00:24:26.433 align:middle
这些数字
不是定距

00:24:26.500 --> 00:24:27.467 align:middle
宽度都不同

00:24:28.068 --> 00:24:31.004 align:middle
这就很奇怪了
因为传统的系统字体

00:24:31.071 --> 00:24:33.473 align:middle
一般都是
等宽数字

00:24:33.941 --> 00:24:39.413 align:middle
要确保表格数字
都要井井有条

00:24:39.479 --> 00:24:43.250 align:middle
或是UI文本中数字变化时
不会拧成一团

00:24:43.317 --> 00:24:44.685 align:middle
因为数字是不断变化的

00:24:45.519 --> 00:24:47.154 align:middle
不过现在 如果你的app

00:24:47.221 --> 00:24:50.624 align:middle
连在 X v11上就会
得到这样的系统字体

00:24:50.858 --> 00:24:53.260 align:middle
如果必须
要定距字体

00:24:53.360 --> 00:24:56.830 align:middle
那么在使用这个
API时 就要放弃

00:24:56.897 --> 00:24:59.266 align:middle
等宽数字

00:24:59.733 --> 00:25:02.769 align:middle
从活版印刷角度来看
效果不理想 不过问题解决了

00:24:59.733 --> 00:25:02.769 align:middle
从活版印刷角度来看
效果不理想 不过问题解决了

00:25:03.203 --> 00:25:05.506 align:middle
效果很是不同

00:25:05.772 --> 00:25:08.809 align:middle
现在是按比例
也是固定宽度了

00:25:09.009 --> 00:25:10.077 align:middle
这就是给大家的工具

00:25:10.711 --> 00:25:13.747 align:middle
大家还可以听到
更多API方面的内容

00:25:13.814 --> 00:25:15.349 align:middle
《最新系统字体介绍》

00:25:15.415 --> 00:25:17.284 align:middle
讲座时间 周五下午
2:30

00:25:19.186 --> 00:25:23.123 align:middle
我也提到了新款API
在科技系统有新款API

00:25:23.490 --> 00:25:26.927 align:middle
可以实现新功能以及对TextKit
和iOS进行奇偶校验

00:25:27.427 --> 00:25:28.495 align:middle
这里还有很多项

00:25:28.562 --> 00:25:30.731 align:middle
我只介绍其中
两三种

00:25:31.131 --> 00:25:32.533 align:middle
首先是路径排除

00:25:33.133 --> 00:25:36.203 align:middle
这种功能可以
很容易安排路径

00:25:36.270 --> 00:25:38.739 align:middle
在目标周围
摆好文字 就像这蝴蝶

00:25:38.805 --> 00:25:41.475 align:middle
非常简单

00:25:42.209 --> 00:25:44.845 align:middle
还有一个是文本域的
两个属性：最大线条数

00:25:44.912 --> 00:25:48.115 align:middle
特别适用于
Auto Layout

00:25:48.515 --> 00:25:51.018 align:middle
或是允许
默认缩紧截断

00:25:52.019 --> 00:25:55.389 align:middle
这可以确定文字域

00:25:55.455 --> 00:25:59.726 align:middle
内容是否应该缩紧
然后再真正将之截断

00:25:59.793 --> 00:26:02.496 align:middle
以前有过控制方法
但是现在是

00:25:59.793 --> 00:26:02.496 align:middle
以前有过控制方法
但是现在是

00:26:02.563 --> 00:26:04.164 align:middle
使用Boolean属性控制

00:26:05.232 --> 00:26:07.634 align:middle
还有很多调整变化
以及部分亮点

00:26:10.270 --> 00:26:11.772 align:middle
那么关于AppKit部分

00:26:11.839 --> 00:26:14.641 align:middle
最后讲一点
视觉原子性

00:26:15.275 --> 00:26:17.611 align:middle
大家可能会奇怪
视觉原子性是什么

00:26:18.278 --> 00:26:19.279 align:middle
是山吗？

00:26:19.713 --> 00:26:21.481 align:middle
这和Half Dome
有什么关系?

00:26:21.582 --> 00:26:25.018 align:middle
我给大家看个短片
解释我所说的

00:26:25.085 --> 00:26:28.422 align:middle
视觉原子性或
缺乏视觉原子性是什么意思

00:26:28.755 --> 00:26:30.557 align:middle
两次看到
打开面板

00:26:31.391 --> 00:26:33.093 align:middle
第一次没问题 还可以

00:26:33.760 --> 00:26:35.429 align:middle
第二次 你们自己想

00:26:39.766 --> 00:26:44.938 align:middle
除非你们什么都看不到
否则都明白我的意思

00:26:45.205 --> 00:26:46.740 align:middle
我给大家慢动作播放

00:26:47.241 --> 00:26:50.344 align:middle
阴影部分面板
面板其他部分

00:26:50.677 --> 00:26:53.780 align:middle
这就是打开面板
是在约塞米蒂

00:26:54.548 --> 00:26:57.084 align:middle
打开面板很粗糙
因为是多项进程

00:26:57.150 --> 00:27:00.120 align:middle
在带动
不过这不是借口

00:26:57.150 --> 00:27:00.120 align:middle
在带动
不过这不是借口

00:27:00.454 --> 00:27:03.257 align:middle
这样的UI让用户
感觉仿佛是一次

00:27:03.323 --> 00:27:05.926 align:middle
走一步 一次走一帧
不应该是

00:27:05.993 --> 00:27:08.862 align:middle
这样的视觉
步骤的

00:27:09.563 --> 00:27:11.164 align:middle
这就是我所说的
视觉原子性的意思

00:27:11.231 --> 00:27:14.434 align:middle
需要的时候
一步到位

00:27:15.269 --> 00:27:18.805 align:middle
你们当中视窗 视图

00:27:19.072 --> 00:27:21.575 align:middle
还有Core Animation
层次都很清晰

00:27:21.642 --> 00:27:24.111 align:middle
要知道实现
视觉原子性并非

00:27:24.178 --> 00:27:25.078 align:middle
都那么简单

00:27:26.547 --> 00:27:28.715 align:middle
这些是API
大家不用仔细

00:27:28.782 --> 00:27:30.217 align:middle
看明细
这不是考试

00:27:30.684 --> 00:27:32.886 align:middle
这些就是完成这项任务
所需要的API

00:27:32.953 --> 00:27:35.556 align:middle
但是不一定要一起
工作才行

00:27:35.923 --> 00:27:37.824 align:middle
在X v11中我们解决了问题

00:27:38.258 --> 00:27:41.562 align:middle
所以可以用
NSAnimationContex

00:27:41.628 --> 00:27:42.963 align:middle
实现视觉原子性

00:27:44.097 --> 00:27:47.000 align:middle
可以调用Begin Group
ing或End Grouping

00:27:47.067 --> 00:27:47.801 align:middle
或类似功能

00:27:47.868 --> 00:27:50.470 align:middle
运行Animation Group
周围是一系列

00:27:50.838 --> 00:27:53.507 align:middle
你在做的独立画作
就像这里这样

00:27:53.574 --> 00:27:55.442 align:middle
这就可以实现
视觉原子性

00:27:55.509 --> 00:27:57.778 align:middle
除此之外

00:27:58.011 --> 00:28:00.614 align:middle
我们不鼓励使用Disable
Screen Updates

00:27:58.011 --> 00:28:00.614 align:middle
我们不鼓励使用Disable
Screen Updates

00:28:00.681 --> 00:28:02.716 align:middle
和Enable Screen
Updates

00:28:02.783 --> 00:28:05.352 align:middle
以及Disable Screen
until Flush

00:28:05.419 --> 00:28:07.754 align:middle
并非是不支持
只是不再推荐使用

00:28:07.821 --> 00:28:09.156 align:middle
应该没必要

00:28:11.124 --> 00:28:15.362 align:middle
这样 我们可以继续
介绍Foundation

00:28:15.996 --> 00:28:18.298 align:middle
关于Foundation
可以讲的也很多

00:28:19.700 --> 00:28:20.868 align:middle
首先是管理撤销

00:28:21.835 --> 00:28:25.572 align:middle
用过Swift中管理撤销的
都知道管理撤销

00:28:25.639 --> 00:28:28.509 align:middle
API在Swift中
并不太好用

00:28:29.209 --> 00:28:30.677 align:middle
API是这个样子

00:28:30.978 --> 00:28:34.448 align:middle
第一个有个选择器
部分情况才会管用

00:28:34.515 --> 00:28:36.149 align:middle
第二个是有
指示

00:28:36.550 --> 00:28:39.653 align:middle
NSIndication in
Objective-C当然相当棒

00:28:39.887 --> 00:28:42.990 align:middle
还是Swift里面那些
花哨的种类 它不太清楚

00:28:43.590 --> 00:28:45.959 align:middle
所以我们加上了
基于代码块的撤销

00:28:46.927 --> 00:28:48.829 align:middle
这就是在
Objective-C中的样子

00:28:48.896 --> 00:28:50.097 align:middle
在Swift中
是这个样子

00:28:50.964 --> 00:28:52.633 align:middle
你们看
这有个目标论证

00:28:52.900 --> 00:28:55.135 align:middle
也是个代码块
基本上就是执行

00:28:55.202 --> 00:28:57.938 align:middle
刚做过的
撤销应用

00:28:59.139 --> 00:29:01.808 align:middle
目标方式的不同论证
大家不用

00:28:59.139 --> 00:29:01.808 align:middle
目标方式的不同论证
大家不用

00:29:01.875 --> 00:29:03.443 align:middle
去参考
代码块的目标

00:29:03.510 --> 00:29:05.245 align:middle
以避免循环保留

00:29:05.712 --> 00:29:07.414 align:middle
在Swift声明中
也用到泛型类型

00:29:07.481 --> 00:29:09.616 align:middle
我会告诉大家
具体是怎么工作的

00:29:10.284 --> 00:29:11.251 align:middle
这是个例子

00:29:11.552 --> 00:29:13.654 align:middle
我们有个类别
名为Colorful Shape

00:29:13.720 --> 00:29:15.355 align:middle
还有个属性名为Color

00:29:17.090 --> 00:29:20.060 align:middle
我们为这个属性
加上Did Set属性观察器

00:29:20.427 --> 00:29:22.529 align:middle
这不过是可以实现撤销的
多种方式之一

00:29:22.596 --> 00:29:24.865 align:middle
还可以通过其他方式撤销
不过我们是通过

00:29:24.932 --> 00:29:25.999 align:middle
Did Set属性完成

00:29:26.466 --> 00:29:28.635 align:middle
这里是调用
目标注册撤销

00:29:29.369 --> 00:29:32.272 align:middle
这里是实际上执行
撤销应用的代码

00:29:32.339 --> 00:29:33.607 align:middle
针对我刚做过的事情

00:29:35.042 --> 00:29:38.645 align:middle
注意这里多亏对目标的
注册撤销中用了泛型

00:29:38.712 --> 00:29:41.481 align:middle
这些都发挥了作用

00:29:41.548 --> 00:29:43.617 align:middle
目标被自动识别
为是彩色形状

00:29:43.684 --> 00:29:46.253 align:middle
这要归功于
注册撤销栏的

00:29:46.320 --> 00:29:48.055 align:middle
自参考

00:29:48.121 --> 00:29:50.524 align:middle
你不必将目标转化为
彩色形状

00:29:53.026 --> 00:29:55.162 align:middle
NSCoder现在就可以处理错误

00:29:55.495 --> 00:29:58.699 align:middle
用过NSCoders的人们比如NS
KeyedArchiver之类

00:29:58.765 --> 00:30:01.802 align:middle
要知道并没有对这些东西的
错误论证

00:29:58.765 --> 00:30:01.802 align:middle
要知道并没有对这些东西的
错误论证

00:30:02.569 --> 00:30:04.638 align:middle
我们已经添加了外显
错误处理

00:30:05.405 --> 00:30:07.908 align:middle
这类方式包括Decode
Object for Key

00:30:07.975 --> 00:30:10.711 align:middle
Decode Object of
Classes for Key

00:30:10.777 --> 00:30:11.612 align:middle
都有不同版本

00:30:11.678 --> 00:30:13.981 align:middle
都可以在实际中返还错误
将错误抛入Swift当中

00:30:14.114 --> 00:30:15.916 align:middle
这些叫做
Decode Top Level

00:30:15.983 --> 00:30:17.184 align:middle
Object for Key

00:30:17.251 --> 00:30:18.952 align:middle
以及Decode Top
Level

00:30:19.019 --> 00:30:21.154 align:middle
Object of
Classes for Key

00:30:21.221 --> 00:30:23.290 align:middle
注意它们抛出声明表示了
它们在返回还错误

00:30:23.624 --> 00:30:25.926 align:middle
还要注意它们
返回了可选目标

00:30:25.993 --> 00:30:28.996 align:middle
因为空返回
实际上是有效返回

00:30:29.062 --> 00:30:32.032 align:middle
这表明对象
并不在档案中

00:30:32.999 --> 00:30:33.934 align:middle
注意这些名为

00:30:34.001 --> 00:30:36.603 align:middle
Decode Top Level
Object for Key

00:30:36.670 --> 00:30:39.273 align:middle
我们有意在
未归档的

00:30:39.339 --> 00:30:41.208 align:middle
根对象中
将其放在顶层

00:30:41.508 --> 00:30:44.311 align:middle
我们不想在你实施代码期间

00:30:44.378 --> 00:30:45.279 align:middle
调用这些

00:30:46.713 --> 00:30:48.615 align:middle
请注意 这里
只有两种方式

00:30:48.682 --> 00:30:50.951 align:middle
我们还有两三种
方式可以适用

00:30:51.018 --> 00:30:53.921 align:middle
所有的解码对象
类型方式

00:30:56.190 --> 00:30:59.660 align:middle
现在由NSError提供值
我们以此为模型

00:31:00.260 --> 00:31:04.431 align:middle
通过这种简单的方式
可以生成NSError对象

00:31:04.498 --> 00:31:06.633 align:middle
相当简单
直接 不过

00:31:06.700 --> 00:31:08.235 align:middle
注意 它不可向
用户呈现

00:31:08.569 --> 00:31:10.437 align:middle
如果用户
见过了

00:31:10.504 --> 00:31:11.605 align:middle
那就是这个样子

00:31:12.172 --> 00:31:16.210 align:middle
不太好你们其实是想给
他们看看

00:31:16.276 --> 00:31:17.978 align:middle
是否曾给
用户见过

00:31:18.245 --> 00:31:20.414 align:middle
即便不给用户提供
要知道

00:31:20.480 --> 00:31:22.516 align:middle
除错器中 有这类东西
也会很有帮助

00:31:22.583 --> 00:31:24.618 align:middle
与得到42号错误相反

00:31:25.252 --> 00:31:28.355 align:middle
因此编写的代码
是类似这样

00:31:29.389 --> 00:31:33.460 align:middle
因此要明确各个键的值
如果想要给用户

00:31:33.527 --> 00:31:36.230 align:middle
出示 需要对之
进行本地化

00:31:36.864 --> 00:31:38.398 align:middle
因此这是
一大堆代码

00:31:38.932 --> 00:31:41.001 align:middle
你就可以永远地
创建方式

00:31:41.201 --> 00:31:44.137 align:middle
代码不是问题
编写代码是我们的工作

00:31:44.204 --> 00:31:46.306 align:middle
对 我们就是靠这个挣钱的
不过这不是问题

00:31:46.607 --> 00:31:48.842 align:middle
问题是所有这些
都是发生在

00:31:48.909 --> 00:31:51.879 align:middle
出现错误的时候
即使错误的消费端

00:31:51.945 --> 00:31:53.680 align:middle
和错误没有任何关系
也是如此

00:31:53.747 --> 00:31:55.816 align:middle
因此从性能考虑
这是浪费

00:31:56.450 --> 00:31:58.719 align:middle
因此我们加入了
这种功能

00:31:58.785 --> 00:32:01.088 align:middle
可以按需创建
并返回所需值

00:31:58.785 --> 00:32:01.088 align:middle
可以按需创建
并返回所需值

00:32:02.289 --> 00:32:05.592 align:middle
我们有这个方式
为域名提供方的

00:32:05.659 --> 00:32:07.227 align:middle
用户信息值提供方进行设置

00:32:07.461 --> 00:32:11.131 align:middle
你基本上在应用中
为NSError

00:32:11.198 --> 00:32:13.901 align:middle
明确域名
并提供提供方

00:32:13.967 --> 00:32:17.137 align:middle
即可以将在用户信息字典中
丢失的任何键值

00:32:17.204 --> 00:32:18.238 align:middle
返回的代码块

00:32:18.305 --> 00:32:20.240 align:middle
因此 会按需
惰性生成

00:32:20.574 --> 00:32:24.144 align:middle
你可以回去使用这个
漂亮的短小代码

00:32:24.211 --> 00:32:26.013 align:middle
来生成错误
用户信息

00:32:26.079 --> 00:32:27.548 align:middle
会动态填写

00:32:30.751 --> 00:32:32.819 align:middle
你也许熟悉
NSProgress

00:32:32.953 --> 00:32:35.222 align:middle
这是报告
进度的对象

00:32:35.289 --> 00:32:36.657 align:middle
还有个不错的功能

00:32:36.723 --> 00:32:41.662 align:middle
将在多个操作类型层次中
隐形记录进度

00:32:41.728 --> 00:32:43.564 align:middle
并且它会
作为单独数字

00:32:43.630 --> 00:32:45.666 align:middle
呈现
给用户

00:32:46.133 --> 00:32:47.968 align:middle
相当不错
但是这是隐形的

00:32:48.669 --> 00:32:52.139 align:middle
作为隐形
你可能会

00:32:52.206 --> 00:32:53.207 align:middle
遇到一些问题

00:32:53.540 --> 00:32:55.542 align:middle
我们介绍
管理进度报告的

00:32:55.609 --> 00:32:57.110 align:middle
线性模式

00:32:57.778 --> 00:33:00.380 align:middle
包括两部分
一个是直接向

00:32:57.778 --> 00:33:00.380 align:middle
包括两部分
一个是直接向

00:33:00.447 --> 00:33:03.383 align:middle
操作类型层次
添加并去除子进度对象

00:33:03.450 --> 00:33:06.420 align:middle
第二个就是这个协议

00:33:06.486 --> 00:33:09.423 align:middle
可以让你
直接声明对象进度

00:33:09.857 --> 00:33:12.025 align:middle
例如 如有
NSOperation子类

00:33:12.092 --> 00:33:16.396 align:middle
这可以实现部分一步操作
要知道 它会开始和结束

00:33:16.463 --> 00:33:19.533 align:middle
是这个进度属性
不错的候选

00:33:19.833 --> 00:33:23.270 align:middle
可以实现选择
外显进度报告

00:33:24.438 --> 00:33:27.040 align:middle
NSProgress也可以
从头开始

00:33:27.441 --> 00:33:30.477 align:middle
以前是可以停顿
我们有加入第二部分

00:33:32.079 --> 00:33:34.815 align:middle
NSNotification
Center现在可以

00:33:34.882 --> 00:33:37.451 align:middle
自动解除注册
分配的观察

00:33:43.657 --> 00:33:45.559 align:middle
这就是你们必须
把自己加成

00:33:45.959 --> 00:33:47.394 align:middle
观察者需要
编写的内容

00:33:47.461 --> 00:33:48.328 align:middle
这是需要把自己

00:33:48.395 --> 00:33:49.863 align:middle
作为观察者删除
所需编写的代码

00:33:49.930 --> 00:33:51.465 align:middle
如果想把自己
作为观察者删除

00:33:51.532 --> 00:33:53.367 align:middle
作为观察者删除
所需编写的代码

00:33:53.867 --> 00:33:57.271 align:middle
如果不然 你会被自动
取消注册

00:33:57.404 --> 00:33:59.540 align:middle
相当棒
这样很好

00:34:01.408 --> 00:34:05.879 align:middle
这个类别名称 就是
Toby 昨天在

00:34:05.946 --> 00:34:07.481 align:middle
联盟会议上不敢提到的

00:34:07.714 --> 00:34:09.683 align:middle
NSFirstNameComponentsFormatter

00:34:10.016 --> 00:34:13.053 align:middle
规则是 如果它没有
长到可以在

00:34:13.120 --> 00:34:15.022 align:middle
幻灯片标题上封装起来
那它并不算太长

00:34:15.222 --> 00:34:18.025 align:middle
那么NSFirstName
ComponentsFomatter

00:34:18.091 --> 00:34:20.661 align:middle
它可以让名称的格式
得以恰当本地化

00:34:20.928 --> 00:34:23.563 align:middle
它又和其他
我们过去几年加入的格式器

00:34:23.630 --> 00:34:26.667 align:middle
联合了起来 比如
日期部件格式器

00:34:27.034 --> 00:34:29.369 align:middle
字节数格式器
长度格式器等等

00:34:30.603 --> 00:34:34.208 align:middle
它还为几种不同形式
提供了样式

00:34:34.341 --> 00:34:35.809 align:middle
让我举一个简单的例子

00:34:36.310 --> 00:34:39.612 align:middle
假设你创建了一个基于人名的
实体组件 它有名称的

00:34:39.679 --> 00:34:42.282 align:middle
几部分 你指定
你有的名称部分

00:34:42.482 --> 00:34:45.252 align:middle
但是还剩很多 比如说
在这里 我们指定其中三个

00:34:46.719 --> 00:34:49.322 align:middle
然后 你在格式器中创建
一个人名 然后把它

00:34:49.389 --> 00:34:50.591 align:middle
格式化

00:34:51.190 --> 00:34:54.161 align:middle
取决于你
你给的样式

00:34:54.228 --> 00:34:56.396 align:middle
你会得到不同形式的
名称 如长的

00:34:56.463 --> 00:34:58.298 align:middle
默认的、短的等等

00:34:58.699 --> 00:35:01.802 align:middle
请注意 如果你需要短的
但在其它语言中

00:34:58.699 --> 00:35:01.802 align:middle
请注意 如果你需要短的
但在其它语言中

00:35:01.869 --> 00:35:05.506 align:middle
你可能会得到一个形式完全不同的
名称 这个具体取决于

00:35:05.572 --> 00:35:07.374 align:middle
这种语言的
本地化规则

00:35:07.441 --> 00:35:09.076 align:middle
不要对你会从
这种API得到的

00:35:09.142 --> 00:35:11.345 align:middle
名称的类别
做出假设

00:35:11.912 --> 00:35:14.181 align:middle
这个 API 的目的
主要的目的之一就是

00:35:14.248 --> 00:35:16.216 align:middle
让你从编写全球通用

00:35:16.283 --> 00:35:18.352 align:middle
应用的复杂工作中
解放出来

00:35:19.319 --> 00:35:22.456 align:middle
NSString 有新的 API
其可以帮助你编写全球通用

00:35:22.523 --> 00:35:24.191 align:middle
国际化的
应用

00:35:24.625 --> 00:35:27.494 align:middle
这将促进
有条件的引用

00:35:27.761 --> 00:35:31.565 align:middle
不论其是否为技术词语
其应由引用包围

00:35:31.832 --> 00:35:34.401 align:middle
而其规则会根据
语言不同而变化

00:35:34.768 --> 00:35:37.571 align:middle
更为简单的本地化情况
用于变更和搜索的 API

00:35:38.105 --> 00:35:41.241 align:middle
音译API它们之前
都在 CFString 中

00:35:41.308 --> 00:35:44.244 align:middle
现在它们在 NSString 中
也能更好地协助

00:35:44.311 --> 00:35:47.281 align:middle
自适应字符串
和用户界面表达

00:35:47.614 --> 00:35:51.351 align:middle
在你的字符串文件中
你可以提供多个形式

00:35:51.418 --> 00:35:54.655 align:middle
多种长度
并根据你在

00:35:54.721 --> 00:35:57.357 align:middle
你在用户界面上所剩
空间多少来选择合适的

00:35:58.125 --> 00:36:00.928 align:middle
你会在国际化新特性讲座中
了解到关于名称部件格式器

00:35:58.125 --> 00:36:00.928 align:middle
你会在国际化新特性讲座中
了解到关于名称部件格式器

00:36:01.295 --> 00:36:03.764 align:middle
和所有这些协助方法
的具体信息

00:36:03.830 --> 00:36:06.366 align:middle
当然还有更多内容
它在星期五上午9点开始

00:36:08.268 --> 00:36:10.003 align:middle
我再谈谈
关于热状况的情况

00:36:10.070 --> 00:36:15.075 align:middle
这些 API 是在 X
v10.3 中引入的 也是我们

00:36:15.142 --> 00:36:18.078 align:middle
动感新 MacBook 出来之刻
当然 你们也知道

00:36:18.145 --> 00:36:20.280 align:middle
没有多少人真的喜欢
这个新东西

00:36:20.380 --> 00:36:23.550 align:middle
而事实上它是
一个很好的 API 案例研究

00:36:23.884 --> 00:36:27.654 align:middle
请注意 虽然此 API
和新 MacBook 同时引入

00:36:27.721 --> 00:36:30.757 align:middle
它也适用于我们的其它机器

00:36:30.824 --> 00:36:32.326 align:middle
而且通常都是
可用并能正常运作的

00:36:32.392 --> 00:36:33.927 align:middle
它不仅仅适用于
MacBook

00:36:34.795 --> 00:36:37.831 align:middle
此 API 使用
属性捕获

00:36:37.898 --> 00:36:40.400 align:middle
一种在 NSProcessInfo
上的热状况属性

00:36:40.467 --> 00:36:43.203 align:middle
它有四个值：象征性
普通、 严重 、极其严重

00:36:43.570 --> 00:36:46.840 align:middle
每当值更改时
你都会收到通知

00:36:48.509 --> 00:36:51.411 align:middle
如果值为严重
那么风扇是以

00:36:51.478 --> 00:36:53.780 align:middle
最高速度运作
当然 这是假设你的电脑有风扇

00:36:54.248 --> 00:36:56.884 align:middle
你可以想象如果你没有风扇
那会发生什么事情

00:36:57.184 --> 00:36:59.520 align:middle
严重通常是要
你采取某些行动的时候

00:36:59.586 --> 00:37:02.389 align:middle
例如 你可能
在做自定义的动画

00:36:59.586 --> 00:37:02.389 align:middle
例如 你可能
在做自定义的动画

00:37:03.390 --> 00:37:05.225 align:middle
而且帧数达到 60 FIPS
这时你要考虑

00:37:05.292 --> 00:37:07.361 align:middle
减少你的帧数到
30 FIPS

00:37:07.861 --> 00:37:10.497 align:middle
这就是 NSScrollView
会自动为你做的事情

00:37:10.564 --> 00:37:13.433 align:middle
这样一来 你就不必担心有关
NSScrollView 的情况

00:37:13.500 --> 00:37:16.069 align:middle
假设你正在应用程序中
使用高解析度的材质

00:37:16.136 --> 00:37:18.105 align:middle
而且你收到一个
严重的热状态的提示

00:37:18.172 --> 00:37:21.108 align:middle
也许你需要
使用低解析度的材质

00:37:22.176 --> 00:37:25.245 align:middle
此款 API 在
你需要它时很有帮助 但

00:37:25.312 --> 00:37:28.649 align:middle
但要注意 此款 API 是
反应性的 并不是主动的

00:37:29.183 --> 00:37:31.985 align:middle
此 API 让
系统提示你 告诉你

00:37:32.052 --> 00:37:35.088 align:middle
目前的困难 然后你需要
采取行动 当然

00:37:35.155 --> 00:37:36.890 align:middle
你采取的行动
不能反而

00:37:36.957 --> 00:37:38.058 align:middle
增加对系统的负载

00:37:38.692 --> 00:37:40.894 align:middle
我们有很多其它
主动 API

00:37:40.961 --> 00:37:43.664 align:middle
我们已在
最新的讲座中介绍

00:37:44.398 --> 00:37:46.900 align:middle
这些类型的 API
会告诉系统

00:37:46.967 --> 00:37:51.705 align:middle
你在做什么 然后
系统会基于你

00:37:51.772 --> 00:37:55.676 align:middle
目前的操作
优化你的活动和任务

00:37:56.043 --> 00:37:58.045 align:middle
例如 计时器
公差

00:37:58.412 --> 00:38:01.582 align:middle
处理信息活动
API 并

00:37:58.412 --> 00:38:01.582 align:middle
处理信息活动
API 并

00:38:01.648 --> 00:38:03.784 align:middle
使用 NSURLSession
在后台进行下载

00:38:03.851 --> 00:38:06.520 align:middle
设置服务质量 等等

00:38:07.487 --> 00:38:10.757 align:middle
这些 API 不仅可以允许
高效操作

00:38:10.824 --> 00:38:13.093 align:middle
但它们还能够
引导合适的热行为

00:38:13.160 --> 00:38:17.497 align:middle
它们可以带来更长的电池
使用寿命 并让你的系统冷却

00:38:17.865 --> 00:38:19.833 align:middle
无论是表面上的降温
还是内部降温

00:38:22.135 --> 00:38:26.340 align:middle
最后 我简单地提及下 Core
Data因为讲座剩下时间不多了

00:38:26.707 --> 00:38:29.076 align:middle
Core Data
中有很多强大功能唯一约束

00:38:29.142 --> 00:38:31.812 align:middle
批量删除
和其他 API 增强功能

00:38:32.045 --> 00:38:33.113 align:middle
这就是我要说的

00:38:34.181 --> 00:38:35.682 align:middle
当然 这不算一个
新特性讲座 如果

00:38:35.749 --> 00:38:38.118 align:middle
如果我没有提到很多
新事物

00:38:38.452 --> 00:38:40.587 align:middle
这些都是许多其他
我没时间提到的主题

00:38:40.654 --> 00:38:42.756 align:middle
你应该可以在
发布说明中阅读到

00:38:43.190 --> 00:38:45.659 align:middle
它甚至没有包括
令人惊讶的新技术

00:38:45.726 --> 00:38:48.095 align:middle
比如 Metal 或者
GameplayKit

00:38:50.397 --> 00:38:53.300 align:middle
总的来说 我们有很多
泛型通用 API 改进

00:38:53.367 --> 00:38:55.569 align:middle
在 Swiftification
各个层面上都有

00:38:55.636 --> 00:38:57.971 align:middle
此外 我们有很多
强大的功能和增强功能

00:38:58.672 --> 00:39:03.410 align:middle
看看这些材料 想想如何
采用它们

00:38:58.672 --> 00:39:03.410 align:middle
看看这些材料 想想如何
采用它们

00:39:03.477 --> 00:39:06.113 align:middle
如果你有任何问题
就来我们的实验室来讨论吧

00:39:07.748 --> 00:39:10.384 align:middle
最后 我
再总结下要点

00:39:10.617 --> 00:39:12.553 align:middle
AppKit和Foundation
发布

00:39:12.619 --> 00:39:13.554 align:middle
说明已经可以从

00:39:13.620 --> 00:39:16.223 align:middle
developer.apple.
com.osx上获取

00:39:16.290 --> 00:39:19.526 align:middle
发布说明是为了抛砖引玉
所以它是一个很好的来源

00:39:20.093 --> 00:39:21.428 align:middle
感谢你们今天到场

00:39:21.495 --> 00:39:22.863 align:middle
会议后
好好休息吧
