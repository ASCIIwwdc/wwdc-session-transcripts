WEBVTT

00:00:19.853 --> 00:00:22.890 align:middle
UI Testing在Xcode

00:00:28.128 --> 00:00:28.962 align:middle
早上好

00:00:29.296 --> 00:00:32.366 align:middle
欢迎来到Xcode
Xcode的用户界面测试

00:00:33.133 --> 00:00:34.168 align:middle
我的名字是威尔·特纳

00:00:34.635 --> 00:00:35.969 align:middle
这位是布鲁克·柯兰翰

00:00:36.703 --> 00:00:39.640 align:middle
我们俩都一起在研发
Xcode的开发工具

00:00:40.541 --> 00:00:44.411 align:middle
我们今天非常激动因为
因为我们今天要和你们分享

00:00:44.478 --> 00:00:48.448 align:middle
一个在Xcode开发工具
测试技术上的

00:00:48.515 --> 00:00:50.150 align:middle
很大的突破

00:00:51.318 --> 00:00:52.719 align:middle
就是用户界面的测试

00:00:53.187 --> 00:00:57.991 align:middle
通过用户界面的测试
您可以找到用户界面的一些元素,

00:00:58.559 --> 00:01:03.096 align:middle
与 他们互动 并验证
并验证用户界面属性的状态

00:00:58.559 --> 00:01:03.096 align:middle
与 他们互动 并验证
并验证用户界面属性的状态

00:01:04.263 --> 00:01:07.768 align:middle
除了用户界面测试 我们
我们已经介绍了用户界面记录

00:01:07.901 --> 00:01:10.737 align:middle
这将允许 您为 您的项目

00:01:10.804 --> 00:01:13.006 align:middle
快速设定用户界面测试

00:01:14.241 --> 00:01:17.744 align:middle
最后 我们已经更新了
在Xcode的测试报告

00:01:17.811 --> 00:01:21.515 align:middle
显示了通过和失败的和
测试的结果

00:01:21.648 --> 00:01:24.384 align:middle
以适应用户界面测试的新的数据

00:01:26.153 --> 00:01:29.122 align:middle
所以我想谈谈
核心技术

00:01:29.389 --> 00:01:32.025 align:middle
对于用户界面测试
首先是 XC测试test

00:01:32.459 --> 00:01:34.628 align:middle
其次是辅助功能

00:01:35.762 --> 00:01:38.799 align:middle
所以XC测试test是Xcode的
测试框架

00:01:38.932 --> 00:01:42.503 align:middle
在它的里面  您创建测试用例的子类

00:01:42.870 --> 00:01:46.940 align:middle
您执行测试方法 并
并用断言来验证

00:01:47.040 --> 00:01:49.343 align:middle
您期望的
结果是正确的

00:01:50.944 --> 00:01:54.982 align:middle
XCte测试st集成Xcode
这意味着 您可以

00:01:55.048 --> 00:01:58.552 align:middle
通过这个用户名
完成编码、 测试

00:01:58.819 --> 00:02:01.221 align:middle
和直接从 您的原始编码

00:01:58.819 --> 00:02:01.221 align:middle
和直接从 您的原始编码

00:02:01.321 --> 00:02:04.358 align:middle
测试的能力 和
并直接就在那里看到结果

00:02:05.425 --> 00:02:08.595 align:middle
您也通过Xcode Server
得到连续整合

00:02:08.662 --> 00:02:09.963 align:middle
和Xcodebuild 创建

00:02:11.131 --> 00:02:14.801 align:middle
最后 XC测试test支持
Swift和Objective-C

00:02:14.902 --> 00:02:16.970 align:middle
所以 您可以选择 您最适合的

00:02:17.037 --> 00:02:18.172 align:middle
母语编码语言

00:02:20.407 --> 00:02:22.709 align:middle
Xctest测试在
Xcode 5里是

00:02:22.776 --> 00:02:24.211 align:middle
作为一个单元测试框架存在的

00:02:24.378 --> 00:02:28.715 align:middle
在Xcode 6里 我们扩大了
支持的性能测试

00:02:29.249 --> 00:02:31.785 align:middle
这让 您能捕捉到
您的编码中的回归

00:02:31.985 --> 00:02:33.153 align:middle
并确保 继续

00:02:33.220 --> 00:02:36.290 align:middle
在每次发布时
都有最佳表现

00:02:37.090 --> 00:02:38.659 align:middle
现在的Xcode 7

00:02:38.725 --> 00:02:40.827 align:middle
我们已经介绍了
您可以使用的用户界面测试的

00:02:40.894 --> 00:02:43.096 align:middle
的正确性和性能测试

00:02:44.598 --> 00:02:45.699 align:middle
这就是XCtest 测试

00:02:45.999 --> 00:02:47.668 align:middle
现在让我们再来看一看
在辅助功能

00:02:48.569 --> 00:02:51.471 align:middle
辅助功能是
在我们的平台上的

00:02:51.672 --> 00:02:54.708 align:middle
这给不启用的用户在我们的设备
设备和所有其他用户接受

00:02:54.775 --> 00:02:56.710 align:middle
我们的应用上
提供同样体验的

00:02:57.044 --> 00:02:58.412 align:middle
一种技术

00:02:59.112 --> 00:03:02.282 align:middle
为了能够达到辅助功能
提供了丰富的关于用户界面的

00:02:59.112 --> 00:03:02.282 align:middle
为了能够达到辅助功能
提供了丰富的关于用户界面的

00:03:02.349 --> 00:03:05.886 align:middle
语义数据的设定
这种技术可用语音

00:03:05.953 --> 00:03:08.989 align:middle
来引导用户
使用这个应用

00:03:09.690 --> 00:03:13.327 align:middle
用户界面测试使用 和
和辅助功能与用户界面工具包

00:03:13.393 --> 00:03:16.463 align:middle
和应用程序包的整合
所以 当 您使用这些框架中的控制

00:03:16.530 --> 00:03:19.499 align:middle
您会马上就能
得到大量的免费的

00:03:19.800 --> 00:03:21.335 align:middle
可访问支持

00:03:22.302 --> 00:03:24.137 align:middle
还提供应用程序接口
来让 您可以

00:03:24.204 --> 00:03:27.241 align:middle
微调辅助功能的数据

00:03:28.642 --> 00:03:31.011 align:middle
这里的的关键是
使用用户界面测试

00:03:31.178 --> 00:03:32.513 align:middle
您的测试将与应用程序进行

00:03:32.913 --> 00:03:34.948 align:middle
像普通用户一样的互动互动

00:03:36.650 --> 00:03:38.485 align:middle
用户界面测试
有几个要求

00:03:38.652 --> 00:03:39.887 align:middle
您应该需要了解

00:03:39.953 --> 00:03:44.157 align:middle
首先是 取决于
在操作系统中的新功能

00:03:44.224 --> 00:03:45.959 align:middle
如果您用的是iOS 则需要iOS 9

00:03:46.026 --> 00:03:48.862 align:middle
如果您用X操作系统 则需要操作系
统10和.11

00:03:50.731 --> 00:03:52.432 align:middle
用户界面测试保护
保护您的隐私

00:03:52.866 --> 00:03:57.070 align:middle
这样做意味着 您
需要启用iOS设备

00:03:57.137 --> 00:04:01.141 align:middle
才可以为开发和连接
一个受信的运行主机Xcode

00:03:57.137 --> 00:04:01.141 align:middle
才可以为开发和连接
一个受信的运行主机Xcode

00:04:03.510 --> 00:04:05.946 align:middle
在X操作系统上
您需要给一个特殊的Xcode

00:04:06.013 --> 00:04:09.016 align:middle
帮助程式许可
第一次运行用户界面测试时

00:04:09.082 --> 00:04:11.285 align:middle
会有提示 您这么做

00:04:13.153 --> 00:04:15.956 align:middle
让我们来看看什么
在 您的项目开始用户界面测试时

00:04:16.223 --> 00:04:17.658 align:middle
需要做些什么

00:04:18.524 --> 00:04:20.827 align:middle
首先 有一个
新的Xcode的目标类型

00:04:21.228 --> 00:04:24.598 align:middle
传统来说上 单元测试是
在Xcode中特定的目标类型

00:04:24.932 --> 00:04:27.167 align:middle
现在用户界面测试
也是目标类型

00:04:28.101 --> 00:04:30.871 align:middle
我们还为 您介绍了
一大套的新的应用程序接口

00:04:31.104 --> 00:04:35.475 align:middle
作为用户界面测试和
用户界面记录

00:04:35.642 --> 00:04:37.945 align:middle
这将使 您
很快就可以开始了

00:04:39.980 --> 00:04:43.851 align:middle
因此 Xcode测试目标
支持用户界面测试的

00:04:43.951 --> 00:04:45.018 align:middle
特殊要求

00:04:45.419 --> 00:04:47.654 align:middle
这包括执行
您正在测试的应用程序中的

00:04:47.721 --> 00:04:49.356 align:middle
一个单独的程序

00:04:50.123 --> 00:04:52.559 align:middle
也处理
隐私保护中使用

00:04:52.626 --> 00:04:53.727 align:middle
使用辅助功能的许可权

00:04:55.362 --> 00:04:59.333 align:middle
这些目标都有Cocoa和Cocoa
Touch新的范本

00:04:59.900 --> 00:05:02.069 align:middle
而且这个的助手和
都会将根据 您喜欢的方式

00:04:59.900 --> 00:05:02.069 align:middle
而且这个的助手和
都会将根据 您喜欢的方式

00:05:02.503 --> 00:05:04.171 align:middle
设定好开始

00:05:05.105 --> 00:05:08.175 align:middle
有一个目标要测试
用户界面测试包的设定

00:05:08.242 --> 00:05:10.811 align:middle
以确定 您正在测试
的应用程序

00:05:13.447 --> 00:05:16.483 align:middle
新的应用程序接口有
三个重点类别

00:05:16.950 --> 00:05:18.385 align:middle
首先是应用程序

00:05:19.553 --> 00:05:20.954 align:middle
其次是元素

00:05:21.121 --> 00:05:23.390 align:middle
第三是元素查询

00:05:23.891 --> 00:05:25.926 align:middle
我们将稍后将对这些
应用程序接口

00:05:25.993 --> 00:05:28.762 align:middle
进行一次深入的介绍

00:05:30.364 --> 00:05:32.566 align:middle
用户界面记录让您
与您的应用程序 掌上设备

00:05:32.633 --> 00:05:34.835 align:middle
掌上设备模拟器 或OS X
Mac

00:05:34.902 --> 00:05:38.338 align:middle
进行互动

00:05:38.639 --> 00:05:42.342 align:middle
当 您这样做时
生成必要的编码

00:05:42.409 --> 00:05:43.977 align:middle
重建这些相互作​​用

00:05:44.545 --> 00:05:48.482 align:middle
您可以新建测试
测试或扩展现有测试

00:05:51.118 --> 00:05:54.454 align:middle
让我们来看看
这是什么

00:05:55.055 --> 00:05:56.690 align:middle
布鲁克 让我们看看一个快速演示

00:06:04.765 --> 00:06:05.599 align:middle
谢谢 威尔

00:06:06.800 --> 00:06:07.901 align:middle
所以 事不宜迟

00:06:08.702 --> 00:06:10.170 align:middle
我今天的演示所
使用的项目

00:06:10.237 --> 00:06:12.239 align:middle
是李斯特的应用

00:06:12.306 --> 00:06:13.240 align:middle
这个例子项目

00:06:13.307 --> 00:06:15.809 align:middle
您可以从
developer.apple.com下载

00:06:16.243 --> 00:06:19.246 align:middle
那么我们开始 现在
现在我的目标配置

00:06:19.313 --> 00:06:21.114 align:middle
正是我想要的那样 但
但我想指出的是

00:06:21.181 --> 00:06:23.584 align:middle
要测试的目标
是李斯特应用

00:06:23.650 --> 00:06:24.952 align:middle
这是一个我的测试将能够

00:06:25.018 --> 00:06:26.687 align:middle
与之互动的应用程序

00:06:31.024 --> 00:06:35.329 align:middle
所以现在我得到了我的
新的测试类别

00:06:35.896 --> 00:06:40.467 align:middle
这里还有一个小测试方法
方法和设定功能

00:06:40.601 --> 00:06:43.270 align:middle
这将会被使用

00:06:43.337 --> 00:06:47.508 align:middle
会在我的测试方法被使用之前
启动应用程序

00:06:47.574 --> 00:06:49.710 align:middle
我在这个类别下所添加的
所有测试方法

00:06:49.776 --> 00:06:50.611 align:middle
都会这么做

00:06:51.645 --> 00:06:54.448 align:middle
所以在让我们从李斯特A应用里PP
里添加一个新的测试

00:06:54.648 --> 00:06:59.753 align:middle
我要把鼠标
移到方法中 按一下

00:06:59.820 --> 00:07:01.922 align:middle
按一下调试栏里的
记录按钮

00:06:59.820 --> 00:07:01.922 align:middle
按一下调试栏里的
记录按钮

00:07:04.858 --> 00:07:06.860 align:middle
现在 Xcode已经开始
启动我的应用程序了

00:07:06.927 --> 00:07:07.761 align:middle
启动好了

00:07:08.128 --> 00:07:12.032 align:middle
李斯特应用允许
我来管理一系列的清单

00:07:12.533 --> 00:07:15.235 align:middle
因此可能人们做的
最常见的事情是

00:07:17.638 --> 00:07:19.139 align:middle
从他们的名单中
补充、删除项目

00:07:19.406 --> 00:07:21.074 align:middle
所以我要
点击这里 添加项目

00:07:21.508 --> 00:07:23.510 align:middle
看起来我们在这食品杂货清单中

00:07:23.577 --> 00:07:25.812 align:middle
有很多东西

00:07:25.879 --> 00:07:27.648 align:middle
那我添加饼干

00:07:27.981 --> 00:07:30.417 align:middle
您可以看到 当我在打字时

00:07:31.285 --> 00:07:33.153 align:middle
源标题正在更新

00:07:33.720 --> 00:07:36.857 align:middle
如果我按删除
也从文字栏里删除

00:07:36.924 --> 00:07:37.925 align:middle
我删除的东西

00:07:41.395 --> 00:07:43.263 align:middle
下一件我要做的事

00:07:43.330 --> 00:07:45.866 align:middle
就是点击一下饼干项目

00:07:46.033 --> 00:07:47.034 align:middle
把 标记为完成

00:07:47.601 --> 00:07:49.236 align:middle
我要做的另一件事是

00:07:49.303 --> 00:07:51.738 align:middle
从清单中删除项目

00:07:51.805 --> 00:07:55.375 align:middle
所以我点击编辑
然后删除饼干

00:07:55.843 --> 00:07:58.312 align:middle
删除确认
终于完成

00:07:59.413 --> 00:08:01.915 align:middle
好 现在我有一个
简单的测试从名单上

00:07:59.413 --> 00:08:01.915 align:middle
好 现在我有一个
简单的测试从名单上

00:08:01.982 --> 00:08:03.483 align:middle
从名单上添加、移除项目

00:08:04.284 --> 00:08:05.118 align:middle
所以我点击停止

00:08:05.786 --> 00:08:06.787 align:middle
让我们看看什么情况

00:08:15.028 --> 00:08:16.230 align:middle
新增了饼干

00:08:17.097 --> 00:08:18.031 align:middle
并且正在移除

00:08:18.398 --> 00:08:19.233 align:middle
我们完成了

00:08:27.808 --> 00:08:30.544 align:middle
谢谢 当测试与用户界面元素
进行互动的时候

00:08:30.611 --> 00:08:33.580 align:middle
我们得到间接的验证
这些用户界面元素的存在

00:08:33.914 --> 00:08:36.149 align:middle
但我们没办法
得到验证的是

00:08:36.250 --> 00:08:38.150 align:middle
事物更改应用程序的状态

00:08:38.251 --> 00:08:40.854 align:middle
例如 当我们打开
那个饼干按钮

00:08:41.154 --> 00:08:43.789 align:middle
我们没有得到任何
验证该按钮的状态

00:08:43.857 --> 00:08:45.158 align:middle
实际上改变了

00:08:46.426 --> 00:08:49.630 align:middle
后来的测试中 当你点击

00:08:49.696 --> 00:08:52.432 align:middle
确认删除的按钮时

00:08:52.866 --> 00:08:55.602 align:middle
我们知道删除确认按钮
已经被点击了

00:08:56.036 --> 00:08:58.872 align:middle
但运行测试
无法验证

00:08:58.939 --> 00:09:01.341 align:middle
饼干那一行
实际上被删除了

00:08:58.939 --> 00:09:01.341 align:middle
饼干那一行
实际上被删除了

00:09:02.409 --> 00:09:04.778 align:middle
所以要得到这些验证的话

00:09:04.845 --> 00:09:07.080 align:middle
我需要添加一些断言

00:09:07.915 --> 00:09:11.618 align:middle
首先我要做的是添加一个断言

00:09:11.685 --> 00:09:15.656 align:middle
说这里的饼干按钮
实际上已经改变了 的状态

00:09:15.722 --> 00:09:17.624 align:middle
要这样做的话 我会
我会添加一个新的常数

00:09:17.691 --> 00:09:19.693 align:middle
称这个为饼干按钮吧

00:09:22.296 --> 00:09:24.231 align:middle
我将要改变这个测试

00:09:24.298 --> 00:09:25.299 align:middle
就要点击这个常数

00:09:27.401 --> 00:09:30.537 align:middle
现在 要新增我的断言
我需要一些状态

00:09:30.604 --> 00:09:35.242 align:middle
一些元素属性的断言

00:09:35.609 --> 00:09:38.378 align:middle
还有饼干按钮
是XUI元素的

00:09:39.046 --> 00:09:41.448 align:middle
还有XUI元素
有一个价值的属性

00:09:41.982 --> 00:09:43.851 align:middle
我要做什么 我要
我要在这里设定中断点

00:09:44.718 --> 00:09:45.853 align:middle
并将测试运行到该点

00:09:53.060 --> 00:09:54.862 align:middle
所以我们在这里有
测试状态了

00:09:54.928 --> 00:09:56.630 align:middle
里面有添加
饼干那一行

00:09:57.431 --> 00:09:59.399 align:middle
还没有
点击按钮

00:10:02.503 --> 00:10:03.504 align:middle
所以我要在
调试器那里

00:10:03.937 --> 00:10:08.408 align:middle
列印出这个饼干
按钮的数值

00:10:23.156 --> 00:10:24.691 align:middle
--好

00:10:24.992 --> 00:10:28.562 align:middle
我可以看到饼干按钮的
的价值是

00:10:28.929 --> 00:10:30.030 align:middle
数位为零的字串

00:10:31.999 --> 00:10:34.501 align:middle
下一步我要
跨过那条线

00:10:34.701 --> 00:10:36.069 align:middle
所以现在 点击了
饼干按钮

00:10:36.570 --> 00:10:39.072 align:middle
我又一次将列印出 的数值
现在我可以看到

00:10:40.641 --> 00:10:43.877 align:middle
该按钮的值是
数字一的字串

00:10:44.444 --> 00:10:46.180 align:middle
好 所以现在我有了
我需要的一切资讯

00:10:46.446 --> 00:10:49.183 align:middle
要断言当 被点击时
按钮的数值会变化

00:10:53.353 --> 00:10:54.454 align:middle
所以我要用XCT

00:10:54.988 --> 00:10:57.191 align:middle
断言平衡assert
equal来添加一个断言

00:11:00.294 --> 00:11:02.229 align:middle
我会断言被点击后的数值

00:11:02.296 --> 00:11:04.765 align:middle
是一个数字为一的字串

00:11:05.199 --> 00:11:07.534 align:middle
这个值现在是任何的类型

00:11:07.601 --> 00:11:11.538 align:middle
所以我需要
断言这是一个字串

00:11:11.972 --> 00:11:13.640 align:middle
所以我使用字串

00:11:15.709 --> 00:11:17.444 align:middle
并断言 被点击后是”“一”“

00:11:19.012 --> 00:11:21.782 align:middle
而且我断言
被点击前是

00:11:21.849 --> 00:11:23.617 align:middle
数字零的数位字串

00:11:25.652 --> 00:11:26.553 align:middle
最后

00:11:27.154 --> 00:11:30.858 align:middle
当
当删除按钮确认后

00:11:30.924 --> 00:11:34.261 align:middle
我就断言
饼干那行消失

00:11:34.328 --> 00:11:35.262 align:middle
我启用XCT

00:11:35.329 --> 00:11:37.164 align:middle
断言平衡assert
equal并断言

00:11:37.231 --> 00:11:38.966 align:middle
这个按钮就不再存在了

00:11:44.037 --> 00:11:46.640 align:middle
现在 如果我再运行这个测试我们
我们应该看到同样的东西

00:11:46.707 --> 00:11:48.475 align:middle
但也通过
所有的这些断言

00:11:58.986 --> 00:12:00.621 align:middle
好 我现在刚刚
添加了我的第一次测试

00:11:58.986 --> 00:12:00.621 align:middle
好 我现在刚刚
添加了我的第一次测试

00:12:01.922 --> 00:12:02.756 align:middle
交给  了 威尔

00:12:09.930 --> 00:12:10.864 align:middle
<br/>
那相当厉害

00:12:10.931 --> 00:12:13.367 align:middle
您可以看到布鲁克
就像普通用户一样

00:12:13.433 --> 00:12:16.837 align:middle
非常容易地使用这个应用

00:12:17.437 --> 00:12:19.806 align:middle
而且在很短的时间内就
创建了一个测试

00:12:20.240 --> 00:12:22.609 align:middle
他可以拓展那个测试
用XCT 断言assert来

00:12:22.676 --> 00:12:27.080 align:middle
做了一些额外的验证
就可以用最少小的功夫

00:12:27.147 --> 00:12:29.249 align:middle
给他的项目增加可靠性

00:12:29.917 --> 00:12:30.918 align:middle
那是相当令人兴奋的

00:12:33.220 --> 00:12:36.390 align:middle
所以 您可以看到我们新增的
用户界面测试目标

00:12:36.723 --> 00:12:38.859 align:middle
非常简单明了 就像
就像我们所有其 他目标

00:12:38.926 --> 00:12:40.427 align:middle
是有帮助和范本的

00:12:41.395 --> 00:12:46.567 align:middle
使用记录 与应用程序互动
创建使用元素、

00:12:46.633 --> 00:12:49.203 align:middle
综合事件的编码

00:12:49.303 --> 00:12:53.440 align:middle
然后用XCT断言
来验证

00:12:55.709 --> 00:12:58.846 align:middle
让我们来看一看
这个用户界面测试

00:13:00.581 --> 00:13:02.583 align:middle
我之前提到过
有三个类别

00:13:02.850 --> 00:13:05.452 align:middle
xxx
<br/>
<br/>
<br/>
他们是XCUIApplication

00:13:05.652 --> 00:13:07.421 align:middle
XCUIElement 和

00:13:07.487 --> 00:13:09.857 align:middle
XCUIElementquery

00:13:10.224 --> 00:13:11.258 align:middle
他们是如何工作的？

00:13:11.592 --> 00:13:14.595 align:middle
让我们从一个非常
简单

00:13:14.962 --> 00:13:16.697 align:middle
比布鲁克的例子更简单的例子

00:13:17.264 --> 00:13:19.099 align:middle
一行一行地演示给你们看

00:13:19.900 --> 00:13:21.001 align:middle
首先我先启动

00:13:21.068 --> 00:13:22.069 align:middle
应用对象

00:13:22.469 --> 00:13:24.872 align:middle
这是一个
我的应用代理

00:13:25.572 --> 00:13:26.507 align:middle
然后我启动

00:13:26.874 --> 00:13:27.941 align:middle
启动好了

00:13:29.376 --> 00:13:32.646 align:middle
然后我用元素和
查询去找添加按钮

00:13:33.747 --> 00:13:35.549 align:middle
然后我点击综合事件

00:13:36.984 --> 00:13:40.153 align:middle
最后 我加上了一个
像布鲁克那样的断言

00:13:40.587 --> 00:13:43.056 align:middle
来确保用户界面
在测试结束时

00:13:43.123 --> 00:13:44.024 align:middle
有了预期的状态

00:13:46.159 --> 00:13:48.362 align:middle
所以我提到
UIApplication应用程序

00:13:48.428 --> 00:13:50.464 align:middle
是一个为测试应用程序
的代理

00:13:51.198 --> 00:13:54.067 align:middle
的启动和关闭的

00:13:54.134 --> 00:13:55.869 align:middle
周期是独立的

00:13:56.270 --> 00:13:58.305 align:middle
因为 您的测试是
在一个单独的过程中运行

00:13:58.772 --> 00:14:01.575 align:middle
您可以明确地控制
应用程序什么时候启动

00:13:58.772 --> 00:14:01.575 align:middle
您可以明确地控制
应用程序什么时候启动

00:14:01.942 --> 00:14:03.010 align:middle
及和什么时候被终止

00:14:06.480 --> 00:14:09.983 align:middle
当 您启动时 总是
产生一个新的程序

00:14:10.250 --> 00:14:12.953 align:middle
所以这就是为什么我们

00:14:13.020 --> 00:14:17.024 align:middle
不给 您完全的程序
因为 您有很多

00:14:17.090 --> 00:14:19.593 align:middle
需要 您操控的应用在运行

00:14:20.027 --> 00:14:23.030 align:middle
但通过每次
干净无干扰的地启动

00:14:23.330 --> 00:14:25.933 align:middle
我们帮 您将 您的测试中

00:14:25.999 --> 00:14:27.100 align:middle
必须要处理的变数最小化

00:14:27.901 --> 00:14:29.570 align:middle
所以 如果 已经运行

00:14:29.703 --> 00:14:32.739 align:middle
再次启动将终止
先前正在运行的实体

00:14:34.775 --> 00:14:38.478 align:middle
应用也是寻找元素的开始

00:14:38.979 --> 00:14:40.280 align:middle
让我们谈一谈元素

00:14:40.914 --> 00:14:42.449 align:middle
XCUIElement元素

00:14:42.516 --> 00:14:44.918 align:middle
就像应用程序
是一个代理对象

00:14:45.219 --> 00:14:47.454 align:middle
但这一次是作为测试应用中的

00:14:47.654 --> 00:14:48.922 align:middle
用户界面元素

00:14:49.590 --> 00:14:50.824 align:middle
元素有几种类型

00:14:51.491 --> 00:14:54.194 align:middle
有的类型是按钮 或
或格子、 或视窗 等等

00:14:54.795 --> 00:14:57.064 align:middle
它们有我们所说的
数据的识别字

00:14:57.264 --> 00:15:00.367 align:middle
字串 这些是通过可访问的
系统得到的

00:14:57.264 --> 00:15:00.367 align:middle
字串 这些是通过可访问的
系统得到的

00:15:00.901 --> 00:15:04.371 align:middle
它们是识别字

00:15:05.939 --> 00:15:09.343 align:middle
例如 如果 您添加了一个按钮

00:15:09.710 --> 00:15:12.579 align:middle
您要找这个按钮

00:15:12.646 --> 00:15:16.149 align:middle
键入识别字添加

00:15:17.818 --> 00:15:20.420 align:middle
在您的应用程序
层次结构中的元素

00:15:20.487 --> 00:15:22.990 align:middle
应用程序
就像一棵树的根

00:15:23.290 --> 00:15:25.559 align:middle
如果 您回想以前学习
计算机科学的日子

00:15:25.626 --> 00:15:26.927 align:middle
您就会想起数据的树形结构

00:15:27.728 --> 00:15:32.966 align:middle
李斯特应用中
我们有一棵很简单的树形结构

00:15:33.033 --> 00:15:34.968 align:middle
在应用的顶部 我们有

00:15:35.035 --> 00:15:38.071 align:middle
我们有像导航栏
和“添加”按钮

00:15:39.740 --> 00:15:40.941 align:middle
杂货标签

00:15:41.074 --> 00:15:42.109 align:middle
等等

00:15:42.709 --> 00:15:44.545 align:middle
所以每一个都是在 您的测试中

00:15:45.279 --> 00:15:46.780 align:middle
您可以参考的一个元素

00:15:48.916 --> 00:15:50.317 align:middle
这些都是查询用的

00:15:50.751 --> 00:15:53.587 align:middle
这个层次结构
以及作为类型和识别字

00:15:53.854 --> 00:15:54.955 align:middle
都用来寻找 您的元素

00:15:56.390 --> 00:15:57.991 align:middle
当 您使用元素时

00:15:58.058 --> 00:16:00.160 align:middle
在 您的测试中
它 们必须是独一无二的

00:15:58.058 --> 00:16:00.160 align:middle
在 您的测试中
它 们必须是独一无二的

00:16:00.861 --> 00:16:01.728 align:middle
所以是什么意思？

00:16:02.095 --> 00:16:04.665 align:middle
每一个元素都是由一个查询支持的

00:16:04.998 --> 00:16:07.868 align:middle
查询必须变成一个单一的实体

00:16:09.203 --> 00:16:11.672 align:middle
否则 当我们整合事件时

00:16:11.738 --> 00:16:14.341 align:middle
要点击按键 但很多个按钮

00:16:14.408 --> 00:16:16.543 align:middle
都符合条件 所以没办法确定

00:16:16.610 --> 00:16:18.679 align:middle
我们就不知道
您要我们做什么了

00:16:19.079 --> 00:16:22.482 align:middle
类似的地 如果 您问我们
元素的属性

00:16:22.983 --> 00:16:25.886 align:middle
我们不知道 您到底
指的是哪一个？

00:16:25.953 --> 00:16:27.154 align:middle
也许一个也不是

00:16:27.621 --> 00:16:29.623 align:middle
所以元素查询最重要的是

00:16:29.690 --> 00:16:31.892 align:middle
要缩小到只有一个符合的范围

00:16:33.093 --> 00:16:35.529 align:middle
如果 他们没有做到这一点

00:16:35.929 --> 00:16:37.831 align:middle
当 您访问元素时就会
就会出现失败的信息

00:16:38.966 --> 00:16:40.000 align:middle
这有一个例外

00:16:40.067 --> 00:16:42.269 align:middle
这是一个在
XCUIElement元素上叫做

00:16:42.336 --> 00:16:44.538 align:middle
存在属性的应用程序接口

00:16:44.638 --> 00:16:48.175 align:middle
这让 您测试
元素存在的安全性

00:16:48.742 --> 00:16:50.844 align:middle
您可以用这个
像布鲁克那样验证

00:16:50.911 --> 00:16:52.679 align:middle
用户界面中被删除的元素

00:16:52.779 --> 00:16:56.016 align:middle
您也可以用来处理

00:16:56.083 --> 00:16:57.451 align:middle
可能在某些情况下有条件的

00:16:57.584 --> 00:16:59.319 align:middle
用户界面的案例

00:16:59.386 --> 00:17:02.456 align:middle
例如 如果 您要
保存一个档案到一个位置

00:16:59.386 --> 00:17:02.456 align:middle
例如 如果 您要
保存一个档案到一个位置

00:17:02.523 --> 00:17:05.358 align:middle
另一个档案已存在
这时会出现

00:17:05.425 --> 00:17:06.527 align:middle
确认单

00:17:06.960 --> 00:17:08.762 align:middle
但那不会每次都出现

00:17:08.829 --> 00:17:10.396 align:middle
只在是案件冲突的时候出现

00:17:10.464 --> 00:17:13.834 align:middle
您可以用一个存在属性去
检查这些情况

00:17:14.968 --> 00:17:18.271 align:middle
元素就是事件整合
应用程序接口时出现的​​

00:17:18.872 --> 00:17:22.675 align:middle
事件整合就是我们如何
模拟用户和应用程序的互动

00:17:22.742 --> 00:17:26.113 align:middle
并做到系统的最底层
所以当用户体验的时候

00:17:26.180 --> 00:17:29.716 align:middle
所有东西都
经过了同样的通道

00:17:29.783 --> 00:17:32.486 align:middle
整合事件的应用程序接口
是有具体的平台的

00:17:33.020 --> 00:17:33.987 align:middle
但也有些例外

00:17:34.588 --> 00:17:37.057 align:middle
我们有按钮点击
如在X操作系统中

00:17:37.124 --> 00:17:41.728 align:middle
相应的 在iOS中
在iOS中就是按键敲击

00:17:41.795 --> 00:17:44.731 align:middle
我们有类型文字
这在两个平台都是一样的

00:17:44.798 --> 00:17:46.300 align:middle
并且是字串文字

00:17:48.869 --> 00:17:53.173 align:middle
XCUI元素查询Elementquery
是用于指定元素的

00:17:54.141 --> 00:17:58.745 align:middle
查询最终变成一系列的
可访问的元素

00:17:58.812 --> 00:18:01.849 align:middle
他们只能找到具有
辅助功能的元素

00:17:58.812 --> 00:18:01.849 align:middle
他们只能找到具有
辅助功能的元素

00:18:02.749 --> 00:18:05.152 align:middle
他们将在这一组中
找到答案

00:18:07.588 --> 00:18:10.858 align:middle
这意味着 您可以通过计数属性获得一
些符合条件的答案

00:18:12.259 --> 00:18:14.962 align:middle
您也可以通过下标和识别字

00:18:15.395 --> 00:18:18.165 align:middle
来指定不同的元素

00:18:19.132 --> 00:18:21.001 align:middle
或者使用索引里的
应用程序接口的元素

00:18:21.068 --> 00:18:23.270 align:middle
我们稍后会讨论这个

00:18:25.172 --> 00:18:26.507 align:middle
那么查询是如何工作呢？

00:18:27.741 --> 00:18:29.576 align:middle
我提到元素的层次结构

00:18:30.410 --> 00:18:33.947 align:middle
这个层次结构的一方面是

00:18:34.014 --> 00:18:34.915 align:middle
如何查询

00:18:35.115 --> 00:18:36.817 align:middle
另一方面是过滤

00:18:37.851 --> 00:18:40.387 align:middle
过滤是集中一个组合并

00:18:40.454 --> 00:18:42.990 align:middle
并根据特定的范围条件
减少那个组合里面的内容

00:18:44.424 --> 00:18:48.128 align:middle
我们再次用李斯特的例子
下面是我们如何表达

00:18:48.195 --> 00:18:51.198 align:middle
某些关系
首先是后代关系

00:18:51.265 --> 00:18:54.067 align:middle
我将展示给你们看

00:18:54.768 --> 00:18:57.070 align:middle
所有金色的格子
都是它的​​后代孩子

00:18:58.238 --> 00:19:01.308 align:middle
另一方面孩子孩子是
更具限制性的关系

00:18:58.238 --> 00:19:01.308 align:middle
另一方面孩子孩子是
更具限制性的关系

00:19:01.375 --> 00:19:05.546 align:middle
这些元素都是直接在
您查询这些元素下面的

00:19:05.612 --> 00:19:08.015 align:middle
所以 表格中的孩子们
只是这些格子

00:19:08.982 --> 00:19:11.752 align:middle
最后我们使用的关系
是包含关系

00:19:12.186 --> 00:19:14.621 align:middle
这个关系很有用特别是当

00:19:14.688 --> 00:19:17.324 align:middle
特别是对有些元素 如一些格子
他们没有很多

00:19:17.391 --> 00:19:19.560 align:middle
独特的数据

00:19:19.960 --> 00:19:22.129 align:middle
但它们包含了
独特的元素

00:19:22.429 --> 00:19:25.232 align:middle
例如 第一单元
包含食品标签

00:19:26.700 --> 00:19:31.104 align:middle
过滤让我们采取
像象这种类型的元素

00:19:32.272 --> 00:19:35.609 align:middle
或识别字在之前的

00:19:35.843 --> 00:19:37.811 align:middle
在之前的过滤的基础上创建查询

00:19:38.412 --> 00:19:41.982 align:middle
这样做的话我们可以

00:19:42.282 --> 00:19:45.319 align:middle
越过识别字
直接看数值

00:19:45.652 --> 00:19:47.688 align:middle
或做部分匹配
如“以您开头”

00:19:47.754 --> 00:19:48.789 align:middle
诸如此类

00:19:50.591 --> 00:19:53.894 align:middle
我们在应用程序接口中
结合关系和过滤

00:19:53.961 --> 00:19:56.663 align:middle
第一个是descendants
matchingtype

00:19:56.730 --> 00:19:57.631 align:middle
后代匹配类型

00:19:57.698 --> 00:19:59.166 align:middle
您能想出
那是什么

00:19:59.633 --> 00:20:02.135 align:middle
在它的后代中寻找
匹配的某一类型

00:19:59.633 --> 00:20:02.135 align:middle
在它的后代中寻找
匹配的某一类型

00:20:02.569 --> 00:20:05.272 align:middle
这是您将使用的最常见的查询

00:20:05.672 --> 00:20:09.042 align:middle
比如我能找到在应用程序中

00:20:09.109 --> 00:20:11.578 align:middle
所有的按钮通过

00:20:12.246 --> 00:20:14.147 align:middle
通过descendentsmatchingtype
后代匹配查询按钮

00:20:15.015 --> 00:20:17.751 align:middle
类似的地 我可以找到
表中的所有格子

00:20:18.218 --> 00:20:19.786 align:middle
我只要告诉表格

00:20:19.853 --> 00:20:21.021 align:middle
要找descendents
matchingtype

00:20:21.088 --> 00:20:22.055 align:middle
后代匹配查询的格子

00:20:22.122 --> 00:20:24.124 align:middle
或者
另一个与功能表项目有关的例子

00:20:25.425 --> 00:20:28.996 align:middle
这是非常常见的查询
我们为每一种类型

00:20:29.062 --> 00:20:30.864 align:middle
都提供便利的应用程序接口

00:20:31.732 --> 00:20:34.067 align:middle
descendents
matchingtype

00:20:34.134 --> 00:20:36.370 align:middle
后代匹配查询按钮 就变成了按钮

00:20:37.471 --> 00:20:39.273 align:middle
descendents
matchingtype

00:20:39.339 --> 00:20:40.874 align:middle
后代匹配查询格子
成为格子 等等

00:20:41.208 --> 00:20:43.143 align:middle
等等诸如此类的

00:20:44.011 --> 00:20:48.215 align:middle
这些便利的应用程序接口
能让您的测试变得非常有效

00:20:48.382 --> 00:20:49.349 align:middle
且准确

00:20:56.256 --> 00:20:58.258 align:middle
Children
matchingtype

00:20:58.325 --> 00:21:00.994 align:middle
类型是
过滤关系中的中的另一组合

00:20:58.325 --> 00:21:00.994 align:middle
类型是
过滤关系中的中的另一组合

00:21:01.061 --> 00:21:03.764 align:middle
所以我们要区分

00:21:03.830 --> 00:21:06.466 align:middle
子孙关系间的不同
符合条件的子孙

00:21:06.633 --> 00:21:08.802 align:middle
而且只有特定的子孙关系
是孩子关系

00:21:10.404 --> 00:21:13.707 align:middle
所有的按钮都是Aapp按钮

00:21:13.807 --> 00:21:16.410 align:middle
如果我想找到孩子关系的按钮

00:21:16.476 --> 00:21:18.011 align:middle
我可以打开导航栏并说

00:21:18.078 --> 00:21:21.248 align:middle
并说说childrenmatchingtype
孩子匹配类型按钮

00:21:21.548 --> 00:21:24.017 align:middle
这虽然不如查询那样常用

00:21:24.084 --> 00:21:26.486 align:middle
但有时候用于区分的时候
会很有用

00:21:28.288 --> 00:21:29.756 align:middle
最后 包含类型

00:21:30.357 --> 00:21:34.428 align:middle
这使我们能够找到
描述 他们的后代的元素

00:21:35.295 --> 00:21:37.497 align:middle
所以在我们有些格子里

00:21:37.564 --> 00:21:40.634 align:middle
格子是匿名的

00:21:40.701 --> 00:21:43.070 align:middle
他们没有任何
识别特征

00:21:43.704 --> 00:21:45.772 align:middle
但它们确实包含着
独特标签

00:21:46.440 --> 00:21:48.308 align:middle
标签也被称为
作为静态文字

00:21:49.409 --> 00:21:53.213 align:middle
所以在这里我可以建立一个
格子查询

00:21:53.280 --> 00:21:56.216 align:middle
去查找那些
包含类型静态文字

00:21:56.350 --> 00:21:58.151 align:middle
且识别字是杂货的格子

00:21:58.652 --> 00:21:59.987 align:middle
这将帮我找到
第一个格子

00:22:00.721 --> 00:22:03.223 align:middle
还有与该应用程序接口
不同的属性

00:22:05.492 --> 00:22:07.194 align:middle
那些是我们的三个
结合了关系和过滤的

00:22:07.261 --> 00:22:09.296 align:middle
应用程序接口

00:22:09.596 --> 00:22:12.032 align:middle
后代匹配类型
孩子匹配类型

00:22:12.566 --> 00:22:15.002 align:middle
包含类型
还有所有的

00:22:15.068 --> 00:22:16.904 align:middle
后代匹配类型
的应用程序接口

00:22:19.139 --> 00:22:20.607 align:middle
另一关于查询强大的
的事情是

00:22:20.674 --> 00:22:22.376 align:middle
他们可以
绑在一起

00:22:22.743 --> 00:22:26.847 align:middle
所以我们可以采取
一个查询的输出使它变成

00:22:26.914 --> 00:22:29.483 align:middle
使它变成下一个的输入 就像 您一样
在Unix命令列里

00:22:29.550 --> 00:22:30.651 align:middle
把命令都连接在一起

00:22:31.385 --> 00:22:33.253 align:middle
这是非常强大的
并且让 您建立

00:22:33.320 --> 00:22:35.656 align:middle
复杂的查询 而且

00:22:35.722 --> 00:22:37.157 align:middle
而且这是很准确又而明了的

00:22:38.258 --> 00:22:41.428 align:middle
所以在这里有我们的
应用

00:22:41.495 --> 00:22:43.497 align:middle
我只是想找到
表中的标签

00:22:43.997 --> 00:22:44.932 align:middle
我从应用程序开始

00:22:45.866 --> 00:22:47.000 align:middle
然后我到了表格

00:22:47.634 --> 00:22:50.003 align:middle
然后我寻找静态文字
然后就完成了

00:22:50.170 --> 00:22:51.305 align:middle
我有这三个标签

00:22:54.341 --> 00:22:56.577 align:middle
有时查询会自己结束

00:22:56.643 --> 00:22:59.346 align:middle
您想得到查询的计数
可能断言的项目数量

00:22:59.413 --> 00:23:01.248 align:middle
项目数量是正确的

00:22:59.413 --> 00:23:01.248 align:middle
项目数量是正确的

00:23:01.582 --> 00:23:04.451 align:middle
但往往一个查询目标
是要找到一个元素

00:23:04.518 --> 00:23:06.887 align:middle
我们所有的元素
都由有查询支持着

00:23:07.487 --> 00:23:10.557 align:middle
从查询中得到一个元素
我们提供了的几个

00:23:10.624 --> 00:23:11.491 align:middle
不同的选择

00:23:11.758 --> 00:23:14.761 align:middle
第一个是下标
这使我们能够进行查询

00:23:15.095 --> 00:23:17.331 align:middle
然后使用识别字来下标

00:23:17.598 --> 00:23:20.501 align:middle
那应该会出现杂货标签
的一个元素

00:23:21.735 --> 00:23:23.837 align:middle
也可以用元素和指数这样做

00:23:24.071 --> 00:23:26.507 align:middle
如果我有一套格子 也许
也许一些表中的行

00:23:26.573 --> 00:23:27.774 align:middle
我想

00:23:27.841 --> 00:23:30.577 align:middle
我可以再在一个一个地
启用元素和指数

00:23:31.945 --> 00:23:35.215 align:middle
如果我有一个查询
我知道的唯一解决方法

00:23:35.482 --> 00:23:38.485 align:middle
帽子是一个单一的东西 也许
也许我只有一个导航栏

00:23:38.552 --> 00:23:41.355 align:middle
在我的应用程序中 我可以
我可以使用元素属性

00:23:41.622 --> 00:23:44.091 align:middle
来创建一个受查询的
支持新的元素

00:23:46.660 --> 00:23:48.929 align:middle
我们什么时候评估查询？

00:23:49.496 --> 00:23:51.465 align:middle
所以 他们实际上不是
真正的当您创造他们

00:23:51.532 --> 00:23:52.766 align:middle
在您创造它们的时候的评估

00:23:52.833 --> 00:23:55.135 align:middle
它们是按需评估
或者按他们的需要

00:23:55.702 --> 00:23:59.773 align:middle
这意味着只有当 您整合事件
或读取属性值的时候

00:24:00.073 --> 00:24:04.144 align:middle
才会对一个元素
查询进行评估

00:24:04.211 --> 00:24:06.580 align:middle
您可以创建元素
但在 您使用 之前

00:24:06.647 --> 00:24:07.814 align:middle
该查询都不会被评估

00:24:08.549 --> 00:24:12.052 align:middle
类似的地 如果 您直接
创建一个查询

00:24:12.119 --> 00:24:14.922 align:middle
当 您得到一些
匹配或如果您调用一个

00:24:14.988 --> 00:24:16.924 align:middle
应用程序接口
而得出所有的匹配

00:24:16.990 --> 00:24:19.226 align:middle
则 必须是
在这一点上评估

00:24:20.260 --> 00:24:23.897 align:middle
用户界面更改时
我们将重新评估查询

00:24:24.231 --> 00:24:26.967 align:middle
所以 您总是使用着用
应用中最新的数据

00:24:27.034 --> 00:24:30.237 align:middle
而不是十秒前的数据

00:24:30.304 --> 00:24:32.472 align:middle
或2分钟前的数据
视 您的测试长度而定

00:24:33.941 --> 00:24:36.410 align:middle
您可以思考一下查询

00:24:36.476 --> 00:24:38.946 align:middle
查询和元素类似于网址

00:24:39.646 --> 00:24:42.583 align:middle
他们是有一个网址
您可以创建一个网址

00:24:42.649 --> 00:24:44.818 align:middle
但您不能立即获取资源

00:24:44.885 --> 00:24:48.322 align:middle
直到 您真正
去创建您的网址请求

00:24:48.388 --> 00:24:52.392 align:middle
或实际网址得到解决

00:24:52.860 --> 00:24:55.229 align:middle
即使这样的网址是无效的

00:24:55.395 --> 00:24:57.831 align:middle
只要没到那个点上
都不会有错误提示

00:24:58.732 --> 00:25:03.403 align:middle
类似的 查询和元素
它们只是

00:24:58.732 --> 00:25:03.403 align:middle
类似的 查询和元素
它们只是

00:25:03.570 --> 00:25:06.139 align:middle
在测试中的应用
可访问的元素的规格

00:25:06.874 --> 00:25:09.209 align:middle
所以创建他们

00:25:09.276 --> 00:25:11.745 align:middle
不到您要使用它们的时候不会有任何变
化

00:25:11.879 --> 00:25:13.447 align:middle
等 您要使用时它们才会做出反应

00:25:15.883 --> 00:25:17.050 align:middle
所以这就是应用程序接口

00:25:17.751 --> 00:25:20.320 align:middle
这三个类别：
应用

00:25:20.387 --> 00:25:23.290 align:middle
是启动 您的应用

00:25:23.724 --> 00:25:26.660 align:middle
元素像应用程序但是
元素的在您的应用程序中的

00:25:26.727 --> 00:25:29.363 align:middle
中的一个代理；
最后是查询

00:25:29.696 --> 00:25:32.599 align:middle
是用更复杂的方法
指定元素

00:25:34.368 --> 00:25:35.969 align:middle
所以现在我想
我想讲一下

00:25:36.036 --> 00:25:37.938 align:middle
关于辅助功能
和用户界面测试

00:25:38.405 --> 00:25:39.339 align:middle
我之前提到过

00:25:39.640 --> 00:25:43.076 align:middle
辅助功能数据
使用户界面测试成为可能

00:25:44.611 --> 00:25:48.849 align:middle
所以这是不难看出
辅助功能数据

00:25:49.116 --> 00:25:53.353 align:middle
的质量如何将影响 您的测试

00:25:53.720 --> 00:25:55.489 align:middle
事实上 辅助功能数据
质量越好

00:25:55.556 --> 00:25:58.258 align:middle
您就越更容易写应用程序的测试

00:25:58.325 --> 00:26:01.495 align:middle
随着时间的推移
这些测试也就越更可靠

00:25:58.325 --> 00:26:01.495 align:middle
随着时间的推移
这些测试也就越更可靠

00:26:02.129 --> 00:26:05.232 align:middle
所以当 您提高
辅助功能

00:26:05.299 --> 00:26:07.167 align:middle
您在您的应用程序中

00:26:07.234 --> 00:26:08.168 align:middle
就得到了双倍的好处

00:26:08.836 --> 00:26:11.071 align:middle
您不仅
更容易为 您自己测试

00:26:11.305 --> 00:26:13.307 align:middle
而且也为我们的不启用的用户

00:26:13.373 --> 00:26:14.508 align:middle
体验带来了提升高

00:26:14.908 --> 00:26:17.711 align:middle
我建议您在用户界面测试和
辅助功能工作的时候

00:26:17.778 --> 00:26:19.346 align:middle
要记住这一点

00:26:21.448 --> 00:26:23.317 align:middle
有时需要做一些调试

00:26:23.884 --> 00:26:27.454 align:middle
有时一个元素可能不
可访问 即使 您使用记录功能

00:26:27.521 --> 00:26:29.590 align:middle
也不能显示

00:26:30.457 --> 00:26:32.893 align:middle
那可能是因为
自定义视图子类

00:26:32.960 --> 00:26:34.828 align:middle
可能默认无法访问

00:26:35.529 --> 00:26:38.065 align:middle
或者它实际上不是一个视图

00:26:38.265 --> 00:26:41.468 align:middle
而是一个在低层图形
子系统的图形对象

00:26:41.535 --> 00:26:43.570 align:middle
如涂层之类的

00:26:44.671 --> 00:26:46.573 align:middle
在其 他情况下
元素是可见的

00:26:46.640 --> 00:26:49.042 align:middle
但具有较差的辅助功能数据

00:26:49.343 --> 00:26:50.978 align:middle
我在看的
所有这些包含查询的格子

00:26:51.078 --> 00:26:54.681 align:middle
如果这些格子本身
有更好的辅助功能数据

00:26:54.748 --> 00:26:57.351 align:middle
部分可能已经消失了

00:26:58.485 --> 00:27:01.121 align:middle
当这情况出现时
我想向您指出几点

00:26:58.485 --> 00:27:01.121 align:middle
当这情况出现时
我想向您指出几点

00:27:01.388 --> 00:27:03.991 align:middle
第一个是
用户界面记录

00:27:04.291 --> 00:27:06.793 align:middle
因为用户界面记录将
向给 您最直观地的展示

00:27:07.094 --> 00:27:09.997 align:middle
测试系统是如何看待元素的

00:27:10.430 --> 00:27:14.134 align:middle
但除了那之外 在我们的平台上
还有辅助功能检查员

00:27:14.434 --> 00:27:17.171 align:middle
他们会让 您看到的
在应用程序中的

00:27:17.471 --> 00:27:19.439 align:middle
原始辅助功能数据

00:27:21.642 --> 00:27:23.577 align:middle
当 您需要改进数据

00:27:24.077 --> 00:27:26.013 align:middle
您第一步应该要看界面生成器

00:27:26.613 --> 00:27:31.084 align:middle
界面生成器有很好的
辅助功能检查员

00:27:31.518 --> 00:27:34.121 align:middle
让 您可以启用
或禁用辅助功能

00:27:34.354 --> 00:27:37.124 align:middle
为可访问属性设定值

00:27:37.524 --> 00:27:40.227 align:middle
并配置特征  这些特征
这些特征对元素是如何表达的

00:27:40.294 --> 00:27:43.363 align:middle
作为用户界面测试的一种类型
将产生有直接的影响

00:27:45.132 --> 00:27:47.434 align:middle
如果 您是用不能访问
界面生成器的元素

00:27:47.501 --> 00:27:50.304 align:middle
您还可以使用应用程序接口

00:27:50.904 --> 00:27:52.139 align:middle
您可以在NS可达

00:27:52.206 --> 00:27:54.508 align:middle
NSAccessibility里
用应用程序接口

00:27:54.575 --> 00:27:57.344 align:middle
UIAccessibility
可达直接控制元素的

00:27:57.411 --> 00:27:59.246 align:middle
辅助功能

00:28:01.748 --> 00:28:04.384 align:middle
所以请记住上面的那点
让我们再看一个演示

00:28:04.852 --> 00:28:05.919 align:middle
这一次布鲁克要带我们

00:28:05.986 --> 00:28:09.389 align:middle
通过更复杂的测试再加上一点

00:28:09.456 --> 00:28:10.657 align:middle
再加上一点辅助功能调试

00:28:11.058 --> 00:28:12.526 align:middle
-布鲁克？
-谢谢 威尔

00:28:19.900 --> 00:28:22.469 align:middle
所以在上一个演示中我们看到
添加一个测试

00:28:22.736 --> 00:28:26.306 align:middle
可以添加和删除
清单中的项目

00:28:28.008 --> 00:28:30.444 align:middle
我在这里 我会在这个区域的
用户界面

00:28:30.511 --> 00:28:32.012 align:middle
添加更多一些测试

00:28:32.412 --> 00:28:33.580 align:middle
首先 我要添加一个测试

00:28:34.081 --> 00:28:37.851 align:middle
让您可以在相同的清单
清单新增多个项目

00:28:38.318 --> 00:28:41.889 align:middle
这多个项目是有相同的名称清单

00:28:42.589 --> 00:28:45.592 align:middle
所以我要在这里复制上次测试的

00:28:45.659 --> 00:28:46.527 align:middle
这个编码

00:28:48.195 --> 00:28:51.932 align:middle
我叫这个为新的测试
测试 添加到饼干

00:28:53.033 --> 00:28:54.101 align:middle
我现在把编码粘贴好了

00:28:55.302 --> 00:28:56.136 align:middle
好

00:28:56.570 --> 00:28:59.039 align:middle
现在我有一个测试

00:28:59.506 --> 00:29:01.742 align:middle
要贴在杂货标签上

00:28:59.506 --> 00:29:01.742 align:middle
要贴在杂货标签上

00:29:02.442 --> 00:29:05.345 align:middle
接下来将要添加的
新的饼干到项目清单里

00:29:05.746 --> 00:29:09.716 align:middle
然后就要点击
在那个项目中的饼干按钮

00:29:09.983 --> 00:29:12.085 align:middle
验证
实际上是

00:29:12.152 --> 00:29:14.254 align:middle
连接上的状态

00:29:15.222 --> 00:29:17.057 align:middle
所以要加上第二个项目
在这里项目我就也

00:29:17.124 --> 00:29:18.258 align:middle
我也在这里复制这个编码

00:29:19.927 --> 00:29:23.964 align:middle
然后看看第二个新的按钮
也连接上了吗

00:29:24.598 --> 00:29:26.133 align:middle
现在我要复制这一段

00:29:26.667 --> 00:29:28.669 align:middle
所以让我们运行这个测试
看看这是如何工作的

00:29:34.608 --> 00:29:35.843 align:middle
现在让我添加第一个

00:29:36.944 --> 00:29:37.811 align:middle
第二个

00:29:38.779 --> 00:29:40.547 align:middle
啊 断言失败了

00:29:40.914 --> 00:29:44.551 align:middle
在这一行中说 我们得到的的

00:29:44.751 --> 00:29:47.988 align:middle
的饼干按钮的数值在
在两二次左右

00:29:48.622 --> 00:29:50.257 align:middle
我们的实际上断言实际上是失败的

00:29:50.424 --> 00:29:52.593 align:middle
看来是因为多相匹配而失败的

00:29:53.026 --> 00:29:55.195 align:middle
我想我知道这里发生了什么

00:29:56.530 --> 00:30:00.167 align:middle
饼干按钮常数是指定的

00:29:56.530 --> 00:30:00.167 align:middle
饼干按钮常数是指定的

00:30:00.234 --> 00:30:02.636 align:middle
这个只是寻找表格上所有的按钮

00:30:02.736 --> 00:30:05.739 align:middle
然后找到一个所谓的饼干按钮

00:30:06.206 --> 00:30:07.741 align:middle
通过这一点 在测试中

00:30:07.808 --> 00:30:11.144 align:middle
有两2个按钮被称为饼干

00:30:11.211 --> 00:30:14.948 align:middle
会找它们两个但是

00:30:15.015 --> 00:30:17.885 align:middle
但只返回一个数值

00:30:17.951 --> 00:30:19.253 align:middle
因为有两个匹配的结果

00:30:20.220 --> 00:30:23.257 align:middle
我现在知道了是因为
是因为看到了测试运行

00:30:23.690 --> 00:30:27.361 align:middle
通常 您不会是看到 您的测试运行

00:30:28.362 --> 00:30:30.864 align:middle
所以我们认为我们应该
为 您提供一个

00:30:30.931 --> 00:30:33.967 align:middle
可以看到测试运行的方法

00:30:34.801 --> 00:30:38.138 align:middle
我们已经在Xcode的试验报告中
添加了这个资讯

00:30:39.606 --> 00:30:42.376 align:middle
所以如果我去报告
导航栏和点击

00:30:42.442 --> 00:30:43.677 align:middle
并点击最近的测试报告

00:30:44.077 --> 00:30:47.381 align:middle
您可以看到测试
添加到了饼干测试

00:30:48.348 --> 00:30:51.885 align:middle
如果我展开这个条目  您
您可以看到在测试过程中发生的

00:30:51.952 --> 00:30:53.387 align:middle
所有的活动

00:30:54.221 --> 00:30:57.057 align:middle
在这里我看到了这最后的一条的
饼干按钮项目

00:30:57.324 --> 00:30:59.159 align:middle
这是我们要找的失败
多相匹配

00:30:59.893 --> 00:31:03.564 align:middle
还有一个快速查找按钮
在这里 我可以在这里看

00:30:59.893 --> 00:31:03.564 align:middle
还有一个快速查找按钮
在这里 我可以在这里看

00:31:04.231 --> 00:31:05.666 align:middle
将显示
应用程序发生时的

00:31:05.732 --> 00:31:07.167 align:middle
确切的状态

00:31:07.234 --> 00:31:09.436 align:middle
正如我们所知道的原因一样

00:31:09.503 --> 00:31:10.938 align:middle
有两排都叫做饼干

00:31:11.505 --> 00:31:13.607 align:middle
其中一个被选中
另外一个没被选中

00:31:19.513 --> 00:31:23.650 align:middle
如果我想要看到完整的断言的话

00:31:24.384 --> 00:31:25.319 align:middle
<br/>
我可以去查看日志

00:31:26.653 --> 00:31:28.722 align:middle
在这里我可以展开测试日志

00:31:32.559 --> 00:31:37.264 align:middle
在这里我们可以看到
完整的失败的断言

00:31:37.331 --> 00:31:40.167 align:middle
展示辅助功能等级的
的两个按钮

00:31:42.369 --> 00:31:44.304 align:middle
在这里我可以看到
是的 有一个按钮

00:31:44.371 --> 00:31:46.173 align:middle
没有被选中
另一个被选中了

00:31:47.674 --> 00:31:49.176 align:middle
正如我所预计的一样

00:31:50.010 --> 00:31:51.578 align:middle
让我们返回去
去把那个问题解决好

00:31:52.613 --> 00:31:55.582 align:middle
最简单的
解决这个问题的方法是

00:31:55.649 --> 00:31:56.550 align:middle
再次使用记录

00:31:57.084 --> 00:31:59.520 align:middle
我会在这个断言失败前
设定一个中断点

00:31:59.586 --> 00:32:01.488 align:middle
然后在那个点那里运行测试

00:31:59.586 --> 00:32:01.488 align:middle
然后在那个点那里运行测试

00:32:11.331 --> 00:32:15.102 align:middle
好的
所以现在我得到了我想要获得的

00:32:15.969 --> 00:32:18.172 align:middle
那个为被选中的按钮的数值

00:32:18.338 --> 00:32:20.841 align:middle
我要做的就是
要点击记录

00:32:23.043 --> 00:32:23.877 align:middle
点击按钮

00:32:24.945 --> 00:32:25.879 align:middle
停止记录

00:32:26.513 --> 00:32:29.416 align:middle
现在我有办法关联到那个按钮了

00:32:30.217 --> 00:32:33.387 align:middle
我要用常数用表来
把这个给清除一下

00:32:34.288 --> 00:32:36.690 align:middle
这个就叫做饼干按钮2

00:32:36.790 --> 00:32:38.158 align:middle
新的测试出现了

00:32:45.699 --> 00:32:47.801 align:middle
现在来解决测试问题
我要用那个新的参考

00:32:47.868 --> 00:32:49.670 align:middle
改变以下的每一个三行

00:32:53.874 --> 00:32:56.043 align:middle
当我再次运行测试
就应该是成功的了

00:33:06.887 --> 00:33:07.721 align:middle
好！

00:33:13.327 --> 00:33:14.261 align:middle
好的

00:33:14.328 --> 00:33:16.563 align:middle
现在我有一个测试
可以从清单添加和删除项目

00:33:16.630 --> 00:33:19.066 align:middle
另一个测试可在同一个清单里
添加两2个项目的测试

00:33:19.132 --> 00:33:21.401 align:middle
并验证它们都存在

00:33:22.202 --> 00:33:23.237 align:middle
现在我要建立一个测试

00:33:23.504 --> 00:33:26.306 align:middle
这将清单中的所有项目都删除

00:33:29.510 --> 00:33:30.777 align:middle
我又一次使用记录

00:33:34.748 --> 00:33:39.453 align:middle
点击杂货标签的编辑 然后删除

00:33:40.120 --> 00:33:42.856 align:middle
测试行中的苹果那行

00:33:45.759 --> 00:33:47.261 align:middle
好吧？
点击停止录制

00:33:48.028 --> 00:33:53.100 align:middle
这样的测试差不多就是我想要的

00:33:53.634 --> 00:33:57.704 align:middle
但我想做的是
我想让我的测试与对应用的

00:33:57.771 --> 00:33:59.173 align:middle
数据无关

00:33:59.439 --> 00:34:01.708 align:middle
我想把所有的项目删除
但我不想要它们

00:33:59.439 --> 00:34:01.708 align:middle
我想把所有的项目删除
但我不想要它们

00:34:01.775 --> 00:34:05.245 align:middle
指向它们的标签

00:34:06.480 --> 00:34:08.282 align:middle
因为那会变得很啰嗦

00:34:08.715 --> 00:34:11.952 align:middle
所以首先我要做的是

00:34:13.453 --> 00:34:14.655 align:middle
您看到这些标记在这里

00:34:14.721 --> 00:34:20.494 align:middle
这些标记提供了获得相同的
用户界面元素的多种途径

00:34:20.561 --> 00:34:23.764 align:middle
在这种情况下 首先删除苹果按钮

00:34:23.830 --> 00:34:24.831 align:middle
我可以把这个叫做

00:34:24.898 --> 00:34:27.801 align:middle
桌面按钮
table.button删除苹果

00:34:28.001 --> 00:34:31.038 align:middle
我可以更具体地的

00:34:32.105 --> 00:34:34.041 align:middle
在苹果的格子里

00:34:34.574 --> 00:34:36.342 align:middle
说这是删除苹果按钮

00:34:37.177 --> 00:34:38.445 align:middle
我就采用这个

00:34:40.947 --> 00:34:43.050 align:middle
双击 把它转换为文字

00:34:44.784 --> 00:34:46.085 align:middle
所以现在

00:34:47.821 --> 00:34:48.655 align:middle
我有了两2排

00:34:49.456 --> 00:34:50.991 align:middle
像以前获得一样的元素那样

00:34:51.291 --> 00:34:55.094 align:middle
我想做的是通过索引获取格子

00:34:55.161 --> 00:34:57.664 align:middle
我会加一个常数叫let格 表格

00:34:59.333 --> 00:35:00.367 align:middle
并设定这个

00:34:59.333 --> 00:35:00.367 align:middle
并设定这个

00:35:00.434 --> 00:35:03.470 align:middle
与桌面单元table.cells元
素索引相同

00:35:03.937 --> 00:35:08.742 align:middle
因为自从苹果是索引1
我就用那个

00:35:09.510 --> 00:35:11.144 align:middle
我只需把那个常数

00:35:12.679 --> 00:35:13.814 align:middle
替换成这个关联

00:35:17.417 --> 00:35:18.418 align:middle
好的
我几乎完成了

00:35:19.520 --> 00:35:22.422 align:middle
下一部分我需要改变的是
的是如何把

00:35:22.489 --> 00:35:25.826 align:middle
按钮从格子里弄出来
因为其他行不

00:35:25.993 --> 00:35:27.227 align:middle
不会有删除苹果的按钮

00:35:27.294 --> 00:35:29.897 align:middle
他们会有删除橙子
或删除面包的按钮

00:35:30.264 --> 00:35:33.300 align:middle
我只需要找到那个标签

00:35:33.834 --> 00:35:35.936 align:middle
开头写着删除这个词

00:35:36.637 --> 00:35:38.438 align:middle
我需要使用属性

00:35:41.842 --> 00:35:43.043 align:middle
所以在这里

00:35:44.411 --> 00:35:45.512 align:middle
我用匹配属性

00:35:45.879 --> 00:35:46.847 align:middle
找到了标签

00:35:46.914 --> 00:35:49.550 align:middle
开头为删除的按钮

00:35:51.385 --> 00:35:54.521 align:middle
所以 我最后要改变的是

00:35:54.588 --> 00:35:56.757 align:middle
我想补充一个
像之前一样的断言

00:35:56.823 --> 00:35:59.193 align:middle
我想验证一下
一下在我们删除后

00:35:59.259 --> 00:36:00.627 align:middle
那格子消失了没

00:35:59.259 --> 00:36:00.627 align:middle
那格子消失了没

00:36:01.261 --> 00:36:03.163 align:middle
我将使用XCT
AssertEqual断言匹配

00:36:03.230 --> 00:36:06.600 align:middle
并断言这些格子
存在属性返回是false否的

00:36:06.667 --> 00:36:09.069 align:middle
当我们点击了
确认删除按钮

00:36:11.071 --> 00:36:12.105 align:middle
我要现在要运行测试

00:36:21.615 --> 00:36:23.383 align:middle
苹果那行已被删除

00:36:25.252 --> 00:36:26.320 align:middle
但断言是失败的

00:36:26.720 --> 00:36:28.889 align:middle
我可能知道是怎么回事

00:36:30.457 --> 00:36:33.493 align:middle
要显示是怎么回事
现在我要将使用调试器

00:36:33.594 --> 00:36:36.196 align:middle
我会在这里设置一个断点
并再次运行测试

00:36:36.263 --> 00:36:37.130 align:middle
运行到相同的断点

00:36:45.305 --> 00:36:46.139 align:middle
好

00:36:47.307 --> 00:36:50.644 align:middle
在调试器中 我现在
我现在启用格子的调试说明

00:36:58.886 --> 00:37:01.755 align:middle
调试说明
有大量的信息

00:36:58.886 --> 00:37:01.755 align:middle
调试说明
有大量的信息

00:37:01.822 --> 00:37:03.891 align:middle
是关于有关如何格子是如何运作的

00:37:04.391 --> 00:37:07.127 align:middle
因此 在我启动它的时候
时候可以看到

00:37:07.895 --> 00:37:10.631 align:middle
这个格子第一个
去应用程序里找

00:37:14.368 --> 00:37:16.036 align:middle
然后它再到找到
表格里找

00:37:17.571 --> 00:37:18.639 align:middle
然后到元素里去寻找

00:37:18.972 --> 00:37:21.942 align:middle
然后到所有元素和
索引里去找

00:37:22.609 --> 00:37:24.811 align:middle
我可以看到 它实际上
找到橙子那行

00:37:25.979 --> 00:37:28.015 align:middle
它看起来可能是

00:37:29.183 --> 00:37:34.888 align:middle
当我们调用这个格子的
的存在属性时

00:37:35.822 --> 00:37:37.658 align:middle
它实际上是自己重新启动

00:37:37.858 --> 00:37:40.160 align:middle
虽然我们除去了苹果那排

00:37:40.961 --> 00:37:45.933 align:middle
在索引里又有了新的格子

00:37:46.800 --> 00:37:49.036 align:middle
所以总的来说是没问题的

00:37:50.270 --> 00:37:52.973 align:middle
这只是意味着我需要
另外的方法来

00:37:53.140 --> 00:37:55.442 align:middle
来找出我们是否
已经删除了那行

00:37:56.009 --> 00:37:57.945 align:middle
所以我要添加一个断言

00:37:58.011 --> 00:37:59.947 align:middle
断言格子的数量

00:38:00.147 --> 00:38:01.281 align:middle
到达这一点

00:38:03.250 --> 00:38:05.919 align:middle
所以 我要增加一个新的属性
属性称为“计数”

00:38:08.422 --> 00:38:11.592 align:middle
我把这个设置为等于
表中格子的计数

00:38:14.628 --> 00:38:18.465 align:middle
然后 断言
这等于计数减1

00:38:20.033 --> 00:38:22.569 align:middle
现在 最后一件事我将
会说这个是一个

00:38:22.636 --> 00:38:24.471 align:middle
一个删除所有项目的测试

00:38:25.239 --> 00:38:27.975 align:middle
把它改为添加循环

00:38:30.277 --> 00:38:31.211 align:middle
循环 然后

00:38:31.278 --> 00:38:33.113 align:middle
只要表格里还有一个格子

00:38:33.180 --> 00:38:35.749 align:middle
就一遍又一遍的不停循环

00:38:39.119 --> 00:38:40.153 align:middle
让我们来运行一下

00:38:46.894 --> 00:38:49.429 align:middle
好的它移除了苹果和桔子橘子那排

00:38:55.402 --> 00:38:56.236 align:middle
好

00:39:04.645 --> 00:39:07.681 align:middle
最后一件事
就是添加一个测试

00:39:07.814 --> 00:39:10.751 align:middle
来使用在编辑界面看到的颜色那行

00:39:15.556 --> 00:39:17.791 align:middle
我再一次
使用记录器

00:39:21.395 --> 00:39:23.330 align:middle
我将点击杂货标签和编辑

00:39:24.064 --> 00:39:24.898 align:middle
现在

00:39:25.098 --> 00:39:26.867 align:middle
这里的UI颜色

00:39:27.367 --> 00:39:29.570 align:middle
让我
可以改变列表的颜色

00:39:29.870 --> 00:39:31.305 align:middle
它现在看起来是绿色的

00:39:31.905 --> 00:39:35.742 align:middle
所以我会尝试改变它
红色或者蓝色怎么样？

00:39:37.778 --> 00:39:39.947 align:middle
好了 所以当我点击
这些按钮 看起来

00:39:40.013 --> 00:39:42.749 align:middle
看起来它没有记录我想要的

00:39:42.816 --> 00:39:44.952 align:middle
它看起来像是它
记录了一个

00:39:45.018 --> 00:39:47.821 align:middle
所谓的静态文本颜色
您看在这里

00:39:48.555 --> 00:39:51.825 align:middle
所以 我认为可能是什么
出了问题就是

00:39:51.892 --> 00:39:54.127 align:middle
就是这些UI元素
可能是对辅助功能

00:39:54.194 --> 00:39:55.062 align:middle
不可见

00:39:56.096 --> 00:39:57.130 align:middle
所以 我要停止记录

00:39:58.799 --> 00:40:01.635 align:middle
我可以使用
辅助检查

00:39:58.799 --> 00:40:01.635 align:middle
我可以使用
辅助检查

00:40:01.702 --> 00:40:02.603 align:middle
来告诉我是怎么回事

00:40:03.170 --> 00:40:05.672 align:middle
右键单击Xcode然后
去开启的开发工具

00:40:05.739 --> 00:40:06.840 align:middle
辅助检查

00:40:08.342 --> 00:40:11.411 align:middle
而辅助检查
提供了大量的信息

00:40:11.478 --> 00:40:15.048 align:middle
但我只想使用
快捷方式 命令S7

00:40:15.782 --> 00:40:19.219 align:middle
这将突出
鼠标光标下面的UI元素

00:40:21.321 --> 00:40:22.923 align:middle
如果我把鼠标光标

00:40:22.990 --> 00:40:25.726 align:middle
放在面包这个词这里
按命令F7

00:40:25.993 --> 00:40:27.327 align:middle
它就突出面包

00:40:29.096 --> 00:40:31.431 align:middle
如果我把它放在
面包删除按钮这里

00:40:31.765 --> 00:40:33.066 align:middle
您可以看到
它突出了这一点

00:40:35.802 --> 00:40:37.905 align:middle
现在 让我们看看
如果我把鼠标光标

00:40:37.971 --> 00:40:40.073 align:middle
放在这个黄色按钮
会发生什么

00:40:42.276 --> 00:40:44.178 align:middle
啊哈！它突出了
整排

00:40:45.913 --> 00:40:46.847 align:middle
所以这几乎证实了

00:40:46.914 --> 00:40:49.650 align:middle
这个UI元素根本
对辅助功能是不可见的

00:40:51.084 --> 00:40:52.452 align:middle
幸运的是 我可以用故事板

00:40:52.819 --> 00:40:55.255 align:middle
改变这种情况
解决这个问题

00:41:00.027 --> 00:41:01.161 align:middle
我现在打开故​​事板

00:41:05.532 --> 00:41:07.868 align:middle
在我的故事板这里
我有同样的按钮

00:41:09.703 --> 00:41:12.773 align:middle
如果我打开检查
我可以看到

00:41:12.840 --> 00:41:17.978 align:middle
这些按钮实际上有
一类的可点击的颜色视图

00:41:18.045 --> 00:41:19.913 align:middle
我熟悉这个类别

00:41:19.980 --> 00:41:22.516 align:middle
我知道它实际上
不是用户界面按钮

00:41:24.451 --> 00:41:26.553 align:middle
这是自定义视图如果我再往下
辅助检查的部分

00:41:26.920 --> 00:41:29.823 align:middle
我可以看到
它是没有被启用

00:41:30.257 --> 00:41:33.327 align:middle
我已经过了一遍并且
并且添加了标签

00:41:34.461 --> 00:41:37.731 align:middle
为了解决这个问题  我需要做的
我需要做的是选择所有的按钮

00:41:40.634 --> 00:41:45.339 align:middle
然后我会启用辅助功能的选框

00:41:45.606 --> 00:41:46.740 align:middle
由于它他们像按钮

00:41:46.807 --> 00:41:48.242 align:middle
我纠结要不要给
它们按钮的特性

00:41:51.678 --> 00:41:52.513 align:middle
好吧？

00:41:52.846 --> 00:41:54.381 align:middle
现在让我们再来运行
这个应用程序

00:42:02.656 --> 00:42:05.792 align:middle
而现在我要再次记录
这个测试

00:42:06.093 --> 00:42:08.629 align:middle
点击杂货和编辑

00:42:09.496 --> 00:42:12.533 align:middle
然后红色  然后橙色

00:42:12.799 --> 00:42:15.536 align:middle
黄、 绿、 蓝和灰

00:42:17.371 --> 00:42:19.940 align:middle
好  它实际上
记录所有这些

00:42:21.642 --> 00:42:23.911 align:middle
我会停止记录
让我们来运行它看看

00:42:23.977 --> 00:42:26.313 align:middle
它是否可以回放

00:42:33.020 --> 00:42:35.956 align:middle
好  我已经修复了
访问我的应用程序

00:42:36.657 --> 00:42:38.292 align:middle
而且我也让
它变得更容易测试

00:42:39.026 --> 00:42:40.327 align:middle
如果我要
完成这一测试

00:42:41.461 --> 00:42:43.830 align:middle
我可能会增加
一些断言验证

00:42:43.897 --> 00:42:45.232 align:middle
这些按钮的变化的状态

00:42:45.465 --> 00:42:46.700 align:middle
现在 我将舞台还给威尔

00:42:53.907 --> 00:42:55.375 align:middle
所以这
所以这真的挺棒

00:42:55.475 --> 00:42:58.846 align:middle
尤其是使它变得多么的简易

00:42:58.912 --> 00:43:01.281 align:middle
以前配音用户
用户没能那么幸运地

00:42:58.912 --> 00:43:01.281 align:middle
以前配音用户
用户没能那么幸运地

00:43:01.348 --> 00:43:04.818 align:middle
做到这些  现在只是
现在只是在界面生成器做了

00:43:04.885 --> 00:43:07.154 align:middle
几个简单的变化
布鲁克能够使

00:43:07.221 --> 00:43:09.656 align:middle
能够使它变得可访问
并和UI可测

00:43:12.025 --> 00:43:15.128 align:middle
因此 在演示中
更先进的UI测试

00:43:15.195 --> 00:43:17.731 align:middle
您看到在一些情况下
它如何处理冲突

00:43:17.798 --> 00:43:20.834 align:middle
和一些个查询  以及如何
以及如何纠正这些查询

00:43:20.901 --> 00:43:25.305 align:middle
以及如何调试它
如何建立循环

00:43:25.739 --> 00:43:28.775 align:middle
并对其进行验证  以及如何
还有如何使用存在的属性

00:43:28.842 --> 00:43:32.446 align:middle
并且还强调如何
重新评估查询

00:43:32.679 --> 00:43:35.916 align:middle
他们用标准
创造了它们

00:43:35.983 --> 00:43:39.253 align:middle
这标准就是确定
怎样重新评估

00:43:39.686 --> 00:43:41.922 align:middle
我们使用索引1一的元素

00:43:41.989 --> 00:43:45.058 align:middle
这里要指出的是  苹果
苹果标签在第一时间通过UI改变后

00:43:45.292 --> 00:43:47.427 align:middle
UI改变后它就马上消失了

00:43:47.594 --> 00:43:50.864 align:middle
现在被指向橘子标签
橘子标签 然后最后

00:43:51.565 --> 00:43:52.766 align:middle
如何提高辅助功能

00:43:52.999 --> 00:43:56.904 align:middle
这样做的回报是非常棒的

00:43:59.006 --> 00:44:01.041 align:middle
布鲁克也给你们看了
一眼测试报告

00:43:59.006 --> 00:44:01.041 align:middle
布鲁克也给你们看了
一眼测试报告

00:44:01.108 --> 00:44:03.810 align:middle
我们在Xcode 7
做了一些努力来

00:44:03.911 --> 00:44:07.381 align:middle
检修它他们的UI测试

00:44:07.714 --> 00:44:11.018 align:middle
概括总括来说就是  测试报告
测试报告就是所有的运行测试

00:44:11.084 --> 00:44:12.386 align:middle
您看到的结果

00:44:12.953 --> 00:44:16.323 align:middle
它显示了通过或失败
失败 失败消息

00:44:16.990 --> 00:44:18.192 align:middle
性能测试的

00:44:18.258 --> 00:44:20.294 align:middle
性能指标
都显示在报告里

00:44:21.061 --> 00:44:24.231 align:middle
您在XCode和Xcode
Server里得到相同的用户界面

00:44:24.364 --> 00:44:26.333 align:middle
这是一个一致的
经验

00:44:26.400 --> 00:44:28.869 align:middle
不管您是否正在寻找
整合或

00:44:28.936 --> 00:44:30.571 align:middle
您在本地计算机刚刚做的运行

00:44:31.438 --> 00:44:33.941 align:middle
在Xcode Server
您也能获得每个设备的结果

00:44:34.007 --> 00:44:36.810 align:middle
因为您可以有设备
能可以同时

00:44:36.877 --> 00:44:37.778 align:middle
整合多种设备

00:44:38.478 --> 00:44:41.114 align:middle
对UI测试的一点补充一点是

00:44:41.548 --> 00:44:43.784 align:middle
我们在UI测试中收集了
多余的数据

00:44:43.851 --> 00:44:45.652 align:middle
这包括屏幕截图

00:44:46.320 --> 00:44:50.290 align:middle
您看到了它是如何帮助布鲁克
调试他的查询冲突

00:44:50.357 --> 00:44:53.060 align:middle
通过在查询失败时
拿出屏幕截图

00:44:54.094 --> 00:44:59.066 align:middle
此外 我们还整理了应用程序接口
调用进入这些嵌套活动

00:44:59.132 --> 00:45:02.135 align:middle
来帮助您了解
应用程序接口调用是如何工作的

00:44:59.132 --> 00:45:02.135 align:middle
来帮助您了解
应用程序接口调用是如何工作的

00:45:02.769 --> 00:45:04.638 align:middle
让我们一起来看看
这样的一个例子

00:45:04.972 --> 00:45:06.273 align:middle
这不在名单草案里

00:45:06.340 --> 00:45:07.441 align:middle
它是一个不同的应用程序

00:45:07.875 --> 00:45:11.044 align:middle
但我要告诉您
在嵌套的活动

00:45:11.111 --> 00:45:12.880 align:middle
几个步骤
是如何分解的

00:45:13.580 --> 00:45:15.749 align:middle
这个例子我们
我们输入到测试现场

00:45:15.816 --> 00:45:18.886 align:middle
然后所以您就可以调用高层次的
应用程序接口型式测试

00:45:19.686 --> 00:45:21.221 align:middle
但在内部里它已经分解了

00:45:21.622 --> 00:45:24.258 align:middle
在第一步我们等待
应用程序空闲下来

00:45:24.625 --> 00:45:27.127 align:middle
我们实际上观察
测试的应用程序的

00:45:27.461 --> 00:45:28.762 align:middle
主运行循环

00:45:29.129 --> 00:45:31.265 align:middle
因为我们不希望
在它忙于处理的时候

00:45:31.632 --> 00:45:32.966 align:middle
发送事件给它

00:45:33.033 --> 00:45:35.002 align:middle
我们希望它是
尽可能快速响应的

00:45:35.736 --> 00:45:41.175 align:middle
一旦它的闲置 我们就从辅助功能
那捕捉到我们的数据

00:45:41.575 --> 00:45:42.776 align:middle
然后我们启动查询

00:45:42.843 --> 00:45:45.078 align:middle
确保它的匹配
正好是一个

00:45:46.180 --> 00:45:48.682 align:middle
下一步  我们综合
我们综合真实事件

00:45:48.749 --> 00:45:50.817 align:middle
<br/>
在该区域插入文本

00:45:51.618 --> 00:45:55.088 align:middle
最后 我们在应用程序空闲之后
再等待多一点的时间

00:45:55.155 --> 00:45:58.158 align:middle
因为 再一次 我们要
我们要以可靠的和确定的方式

00:45:58.225 --> 00:46:01.461 align:middle
掌控

00:45:58.225 --> 00:46:01.461 align:middle
掌控

00:46:03.096 --> 00:46:05.532 align:middle
快相是在关键的步骤

00:46:05.599 --> 00:46:07.601 align:middle
截屏用的

00:46:07.968 --> 00:46:11.471 align:middle
您可以在这里看到
我输入的文本后的状态

00:46:11.738 --> 00:46:13.540 align:middle
确保一切都和您预计的样子一样

00:46:16.343 --> 00:46:19.913 align:middle
因此 UI测试显然是
那种您可以为你您的应用程序做的

00:46:19.980 --> 00:46:22.049 align:middle
巨大的扩展

00:46:22.449 --> 00:46:24.051 align:middle
所以您在想什么
时候用它呢 对吗？

00:46:24.451 --> 00:46:26.720 align:middle
我们已经有单元测试了

00:46:27.120 --> 00:46:30.157 align:middle
UI测试是一种补充测试
测试 而不是替代

00:46:30.557 --> 00:46:33.460 align:middle
您应该对您的模拟的目标
继续使用单位测试

00:46:33.527 --> 00:46:35.195 align:middle
和您的控制器逻辑

00:46:35.529 --> 00:46:38.398 align:middle
因为单元测试将更能
精确查明在您的代码中

00:46:38.465 --> 00:46:39.499 align:middle
出现的故障

00:46:40.200 --> 00:46:43.370 align:middle
UI测试可以让您
覆盖更广泛的功能范围

00:46:43.437 --> 00:46:45.672 align:middle
但跟踪故障

00:46:45.739 --> 00:46:47.341 align:middle
却更能会比较困难

00:46:47.741 --> 00:46:51.111 align:middle
这是在您的项目的单元测试之间
和UI测试之间

00:46:51.178 --> 00:46:53.113 align:middle
寻找合适的平衡

00:46:54.781 --> 00:46:56.717 align:middle
适合UI测试的人选

00:46:57.217 --> 00:46:58.352 align:middle
嗯 想想您的应用程序

00:46:58.418 --> 00:47:00.254 align:middle
您有用户客户
您展示给他们看

00:46:58.418 --> 00:47:00.254 align:middle
您有用户客户
您展示给他们看

00:47:00.320 --> 00:47:02.489 align:middle
您很少能展示一系列的
演示给他们的

00:47:02.556 --> 00:47:03.724 align:middle
您给他们过一遍后说“好

00:47:03.790 --> 00:47:04.992 align:middle
这是您要怎么做”
“

00:47:05.492 --> 00:47:08.595 align:middle
一系列的演示是
UI测试的很好的候选人

00:47:08.662 --> 00:47:11.932 align:middle
经过每日每夜的构建之后

00:47:12.266 --> 00:47:13.734 align:middle
您会知道这些演示非常有用

00:47:14.635 --> 00:47:17.070 align:middle
第二 除此之外
常见的工作流程

00:47:17.638 --> 00:47:20.974 align:middle
如果它是一个编辑应用程序
那么这个应用程序是做什么用的

00:47:21.074 --> 00:47:22.376 align:middle
您如何编辑文档

00:47:23.777 --> 00:47:25.913 align:middle
任何自定义视图

00:47:26.513 --> 00:47:29.449 align:middle
最后基于文档的工作流程
工作流程 打开和保存

00:47:29.750 --> 00:47:31.485 align:middle
这些都是可以
自动化的很好的事情

00:47:31.685 --> 00:47:33.921 align:middle
它他们如果进行单元测试的话
的话会很难捕捉

00:47:33.987 --> 00:47:36.657 align:middle
如果它他们出错了
会对用户产生巨大的影响

00:47:39.092 --> 00:47:40.494 align:middle
因此 UI测试

00:47:41.562 --> 00:47:42.696 align:middle
在新的XCode 7中

00:47:43.764 --> 00:47:45.732 align:middle
开启打开了您如何测试
您的应用程序的

00:47:45.799 --> 00:47:48.101 align:middle
的各种可能性

00:47:49.269 --> 00:47:51.905 align:middle
在UI测试您
您查找并和与用户体验元素互动

00:47:52.139 --> 00:47:55.275 align:middle
互动和您整合事件

00:47:55.342 --> 00:47:58.011 align:middle
驱使它他们  就是些
就是些普通用户会做的事情

00:47:58.979 --> 00:48:01.648 align:middle
您可以验证的用户界面
属性和状态

00:47:58.979 --> 00:48:01.648 align:middle
您可以验证的用户界面
属性和状态

00:48:03.517 --> 00:48:06.620 align:middle
和UI记录让您超快速地
创建这些测试

00:48:06.854 --> 00:48:07.888 align:middle
超级简单

00:48:09.489 --> 00:48:11.592 align:middle
最后 我们已经彻底改革了
了测试报告

00:48:12.059 --> 00:48:15.562 align:middle
让您能更好地
了解您的测试是如何工作的

00:48:16.063 --> 00:48:17.698 align:middle
并收集更多
关于它他们的数据

00:48:18.665 --> 00:48:19.700 align:middle
所以这就是UI测试

00:48:28.408 --> 00:48:30.644 align:middle
那么关于更多的信息
我们已经上传到XCtest

00:48:30.711 --> 00:48:32.145 align:middle
XC测试上了

00:48:32.212 --> 00:48:35.215 align:middle
您可以在通过Xcode和
我们的网站中得到它

00:48:35.549 --> 00:48:37.784 align:middle
辅助功能也
有很好的的文件

00:48:37.851 --> 00:48:39.052 align:middle
我建议你们去看看

00:48:40.521 --> 00:48:43.223 align:middle
开发者论坛是提出问题
与交流技巧和与其他

00:48:43.290 --> 00:48:47.060 align:middle
您如何使用方法的好地方

00:48:47.127 --> 00:48:50.330 align:middle
我们的宣传员传道斯特凡·莱斯是
一个可以帮您开始使用的

00:48:50.564 --> 00:48:51.498 align:middle
很好的联系人

00:48:52.733 --> 00:48:55.469 align:middle
这里也有一些相关教程
如果您稍后要观看的话

00:48:55.536 --> 00:48:58.038 align:middle
可以观看昨天早上的关于
关于辅助功能的教程

00:48:58.539 --> 00:49:00.474 align:middle
如果想的话
也可在您的午餐时间观看

00:48:58.539 --> 00:49:00.474 align:middle
如果想的话
也可在您的午餐时间观看

00:49:01.041 --> 00:49:04.478 align:middle
持续整合、代码覆盖率 新技术

00:49:04.811 --> 00:49:08.715 align:middle
在Xcode Server上您可以
在看明天下午观看

00:49:09.082 --> 00:49:10.284 align:middle
希望每一个人都有很大收获
