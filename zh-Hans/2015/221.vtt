WEBVTT

00:00:20.220 --> 00:00:23.857 align:middle
改善全屏窗口体验

00:00:23.924 --> 00:00:24.758 align:middle
嗨！

00:00:25.392 --> 00:00:27.895 align:middle
欢迎莅临《改善全屏窗口体验》
专题讲座

00:00:28.495 --> 00:00:31.298 align:middle
我叫 Corbin Dunn
是一名 AppKit 软件工程师

00:00:31.365 --> 00:00:34.568 align:middle
今天我将与我的同事Taylor Kelly一起
完成这个讲座

00:00:34.701 --> 00:00:36.069 align:middle
就让我们直入主题吧！

00:00:36.637 --> 00:00:38.405 align:middle
那么我们今天要讲些什么呢?

00:00:38.472 --> 00:00:40.240 align:middle
首先我要讲的是全屏幕

00:00:40.307 --> 00:00:42.276 align:middle
它将包括三个部分

00:00:42.676 --> 00:00:44.711 align:middle
我将讨论全屏幕的采用

00:00:44.778 --> 00:00:45.979 align:middle
以及如何正确采用

00:00:46.313 --> 00:00:49.183 align:middle
我将谈到标题栏附件视图控制器

00:00:49.316 --> 00:00:50.884 align:middle
它们是什么以及如何使用它们

00:00:51.318 --> 00:00:53.720 align:middle
然后我将讲一下全屏幕平铺 API

00:00:53.787 --> 00:00:55.556 align:middle
查看并利用一些大家已在

00:00:55.622 --> 00:00:57.524 align:middle
Mac OS 10.11中
看到的新特性

00:00:58.292 --> 00:01:00.294 align:middle
Taylor将会上台 并讲一下

00:00:58.292 --> 00:01:00.294 align:middle
Taylor将会上台 并讲一下

00:01:00.360 --> 00:01:03.530 align:middle
Split View控制器内的
灵活布局 自动布局 堆叠视图

00:01:03.997 --> 00:01:06.099 align:middle
并在最后讲下
关于集合视图方面的内容

00:01:07.668 --> 00:01:09.036 align:middle
那么 全屏幕

00:01:09.903 --> 00:01:11.138 align:middle
全屏幕的目的是什么？

00:01:11.205 --> 00:01:14.641 align:middle
它是为了让您的用户将注意力
集中到某个单一任务上

00:01:14.875 --> 00:01:16.944 align:middle
您可以充分利用您的屏幕空间

00:01:17.311 --> 00:01:18.946 align:middle
其他一切都靠边站

00:01:19.012 --> 00:01:21.882 align:middle
您要全神贯注于一个窗口

00:01:23.083 --> 00:01:26.019 align:middle
那么我们为何使其
成为一个系统特性呢？

00:01:26.687 --> 00:01:27.988 align:middle
我们使其成为一个系统特性

00:01:28.055 --> 00:01:31.291 align:middle
因为它一种非常一贯的用户体验

00:01:31.625 --> 00:01:33.026 align:middle
你进入全屏幕的方式

00:01:33.093 --> 00:01:35.462 align:middle
你退出全屏幕的方式
都是一样的

00:01:35.729 --> 00:01:37.898 align:middle
你在不同的位置之间
导航定位的方式等等

00:01:39.166 --> 00:01:42.636 align:middle
那么 什么是
“可全屏化的窗口”？

00:01:43.036 --> 00:01:45.172 align:middle
这里有一个Safari窗口的例子

00:01:45.606 --> 00:01:48.542 align:middle
我肯定您知道
只要点击绿色按钮

00:01:48.809 --> 00:01:50.110 align:middle
它就会把您带入全屏状态

00:01:51.345 --> 00:01:53.814 align:middle
一旦您进入全屏状态
您可以将鼠标移到窗口的上方

00:01:53.881 --> 00:01:56.717 align:middle
标题栏和工具栏将会向下展开

00:01:57.251 --> 00:01:59.019 align:middle
而你可以再次点击绿色按钮

00:01:59.086 --> 00:02:00.687 align:middle
它将把你带回全屏状态

00:01:59.086 --> 00:02:00.687 align:middle
它将把你带回全屏状态

00:02:02.890 --> 00:02:05.125 align:middle
那么为了采用全屏幕
需要做些什么呢？

00:02:05.325 --> 00:02:06.793 align:middle
希望大家已经对此有所了解

00:02:07.060 --> 00:02:08.228 align:middle
不过它是相当容易的

00:02:08.529 --> 00:02:11.698 align:middle
您将指定哪些窗口
是您希望可以全屏化的

00:02:11.765 --> 00:02:13.967 align:middle
您将为它增加一个菜单项

00:02:14.034 --> 00:02:16.503 align:middle
而且你很可能会
做些额外的事情

00:02:16.570 --> 00:02:17.638 align:middle
你可能希望做的额外的事情

00:02:17.704 --> 00:02:21.708 align:middle
是自动隐藏您的工具栏
修改您的内容

00:02:21.842 --> 00:02:25.746 align:middle
以便更充分地利用
全屏幕带来的空间

00:02:25.812 --> 00:02:28.048 align:middle
利用新的标题栏

00:02:28.115 --> 00:02:28.982 align:middle
辅助视图控制器

00:02:29.049 --> 00:02:31.118 align:middle
而我将谈一下如何
以及为何我要那么做

00:02:31.852 --> 00:02:33.987 align:middle
当然 您希望进行很好的全屏平铺操作

00:02:34.254 --> 00:02:36.557 align:middle
因此我将讨论一些我们已有的API
来实现那种效果

00:02:37.424 --> 00:02:40.627 align:middle
首先 有两种类型的窗口

00:02:41.562 --> 00:02:44.932 align:middle
或者实现全屏化有两种可选窗口

00:02:45.699 --> 00:02:47.401 align:middle
通常当一个窗口是全屏时

00:02:47.935 --> 00:02:49.503 align:middle
就不允许对其进行进一步操作了

00:02:49.570 --> 00:02:52.272 align:middle
而那样的窗口也是
我们所谓的“主窗口”

00:02:52.673 --> 00:02:55.309 align:middle
它是您的应用的

00:02:55.375 --> 00:02:56.210 align:middle
主文件窗口

00:02:56.643 --> 00:02:59.012 align:middle
它是您能够使其全屏化的东西

00:02:59.880 --> 00:03:02.349 align:middle
然而还有另一种选择
如果你已经看到它的话

00:02:59.880 --> 00:03:02.349 align:middle
然而还有另一种选择
如果你已经看到它的话

00:03:02.583 --> 00:03:05.886 align:middle
那就是“辅助窗口”
通常你并不需要这个

00:03:06.086 --> 00:03:09.189 align:middle
它的目的是什么？
如果你在某个应用中有一个窗口

00:03:09.256 --> 00:03:11.758 align:middle
想要占据另一个应用的全屏空间

00:03:11.825 --> 00:03:12.993 align:middle
它允许你那么做

00:03:13.060 --> 00:03:15.095 align:middle
我不会讨论这方面

00:03:15.696 --> 00:03:18.599 align:middle
而我鼓励您查阅几年前的
AppKit  版本说明

00:03:18.665 --> 00:03:20.801 align:middle
了解关于它的一些细节

00:03:21.368 --> 00:03:23.971 align:middle
那么您如何采用全屏窗口呢？

00:03:24.037 --> 00:03:27.341 align:middle
在Xcode和Interface
Builder中它非常简单

00:03:27.407 --> 00:03:30.410 align:middle
您选择您的窗口有一个Full
Screen(全屏)部分

00:03:30.477 --> 00:03:31.612 align:middle
您将菜单项下拉

00:03:31.678 --> 00:03:33.814 align:middle
就有主窗口和辅窗口的选项

00:03:33.881 --> 00:03:35.782 align:middle
那么您将很可能希望

00:03:35.849 --> 00:03:38.285 align:middle
在您作为主窗口的全屏窗口上
设置主窗口

00:03:39.486 --> 00:03:43.490 align:middle
当然您也可以用代码实现,而在Int
erfaceBuilder选项下

00:03:43.557 --> 00:03:46.193 align:middle
它所做的不过是修改

00:03:46.260 --> 00:03:48.529 align:middle
window.collectionBehavior

00:03:48.695 --> 00:03:51.398 align:middle
而它将向窗口添加
.FullScreenPrimary

00:03:51.498 --> 00:03:53.600 align:middle
或.FullScreenAuxiliary

00:03:53.667 --> 00:03:57.371 align:middle
以便让那些选项进入窗口
并让窗口实现全屏化

00:03:59.239 --> 00:04:02.142 align:middle
一旦您进入全屏状态
您可能需要

00:03:59.239 --> 00:04:02.142 align:middle
一旦您进入全屏状态
您可能需要

00:04:02.209 --> 00:04:05.012 align:middle
做各种基于全屏幕的事情

00:04:05.512 --> 00:04:08.415 align:middle
而且您可以通过查看样式蒙板
进行检查

00:04:09.049 --> 00:04:10.584 align:middle
就是当您的窗口进入全屏的时候

00:04:10.918 --> 00:04:12.653 align:middle
我们添加

00:04:12.719 --> 00:04:14.988 align:middle
NSFullScreen
WindowMask

00:04:15.055 --> 00:04:16.757 align:middle
而且您可以在样式蒙板中查看

00:04:16.822 --> 00:04:18.492 align:middle
您的窗口是否处于全屏状态

00:04:18.926 --> 00:04:20.226 align:middle
并有可能做其他的事情

00:04:22.663 --> 00:04:25.966 align:middle
现在让我们谈下
如何自动隐藏工具栏

00:04:26.433 --> 00:04:28.035 align:middle
通常如果您在窗口内
有一个工具栏

00:04:28.202 --> 00:04:30.537 align:middle
它总是可见的
就像这里显示出来的一样

00:04:31.104 --> 00:04:33.407 align:middle
当您把鼠标移到窗口的上部

00:04:33.473 --> 00:04:35.075 align:middle
菜单栏会向下展开

00:04:35.142 --> 00:04:36.710 align:middle
标题栏的控制按钮向下展开

00:04:37.211 --> 00:04:38.946 align:middle
从而露出了工具栏

00:04:40.147 --> 00:04:42.549 align:middle
有一个选项可以让您
将工具栏自动隐藏

00:04:42.916 --> 00:04:45.452 align:middle
所以当你进入全屏的时候
其他什么都看不到

00:04:45.519 --> 00:04:47.588 align:middle
而你可以最充分
利用您的屏幕的空间

00:04:48.856 --> 00:04:50.457 align:middle
当您将鼠标
向上移动到菜单栏的时候

00:04:50.858 --> 00:04:54.228 align:middle
工具栏会与菜单栏
和标题栏一起

00:04:54.294 --> 00:04:55.929 align:middle
同时向下展开

00:04:55.996 --> 00:04:57.764 align:middle
这确实是很容易做的

00:04:58.298 --> 00:04:59.900 align:middle
有一个
windowdelegate方法

00:04:59.967 --> 00:05:04.438 align:middle
Window.WillUse
FullScreenPresentationOptions

00:04:59.967 --> 00:05:04.438 align:middle
Window.WillUse
FullScreenPresentationOptions

00:05:04.671 --> 00:05:06.340 align:middle
再加上
proposedOptions

00:05:06.440 --> 00:05:11.211 align:middle
您选择那些建议的选项并且增加
AutoHideToolbar并将其返回

00:05:11.278 --> 00:05:12.946 align:middle
而工具栏将自动隐藏

00:05:13.413 --> 00:05:15.115 align:middle
因此是非常容易的

00:05:16.550 --> 00:05:20.354 align:middle
那么然后是自定义动画
您可以创建全屏进入和退出

00:05:20.420 --> 00:05:22.523 align:middle
自定义动画

00:05:22.589 --> 00:05:24.525 align:middle
我们有两种
delegate方法实现它

00:05:24.591 --> 00:05:26.593 align:middle
customWindows
ToEnter

00:05:26.660 --> 00:05:28.829 align:middle
FullScreen
ForWindow

00:05:28.896 --> 00:05:31.098 align:middle
这种方法可以返回一系列的窗口
来实现您的动画

00:05:31.231 --> 00:05:33.433 align:middle
然后我们把您叫回来
说 嗨！

00:05:33.500 --> 00:05:35.469 align:middle
开始您的自定义动画
进入全屏状态吧

00:05:35.702 --> 00:05:36.837 align:middle
并请指定持续时间

00:05:37.571 --> 00:05:40.307 align:middle
关于这些操作
我们需要注意的一点是

00:05:40.374 --> 00:05:42.809 align:middle
在 Mac OS 10.11 中
通过我们进入全屏的方式

00:05:42.876 --> 00:05:44.411 align:middle
您可能不会让这些参数得到调用

00:05:44.478 --> 00:05:46.446 align:middle
因此重要的一点是

00:05:46.513 --> 00:05:49.349 align:middle
不要依赖这些参数一直被调用
并设置状态

00:05:49.716 --> 00:05:52.586 align:middle
相反 有更好的方式实现
过一会儿我将讲到这些方式

00:05:55.355 --> 00:05:58.892 align:middle
好了 关于全屏幕以及
如何正确采用就讲这么多

00:05:59.259 --> 00:06:00.594 align:middle
让我们继续往下进行

00:05:59.259 --> 00:06:00.594 align:middle
让我们继续往下进行

00:06:01.094 --> 00:06:03.363 align:middle
谈一下标题栏辅助视图控制器

00:06:05.032 --> 00:06:08.335 align:middle
那么在我讲标题栏
辅助控制器之前

00:06:08.602 --> 00:06:10.604 align:middle
让我们先看一下全屏幕窗口

00:06:10.871 --> 00:06:14.474 align:middle
而且我将对标题栏区域突出显示
以便于您觉察到它

00:06:14.942 --> 00:06:16.410 align:middle
那么这就是全屏中的标题栏

00:06:17.144 --> 00:06:19.546 align:middle
在标题栏下面是工具栏

00:06:19.613 --> 00:06:24.184 align:middle
而在工具栏下面是我们所谓的
“辅助视图”

00:06:24.585 --> 00:06:27.788 align:middle
那么您可以在窗口中的这个位置
增加您自己的标题栏

00:06:27.855 --> 00:06:29.990 align:middle
辅助视图控制器

00:06:30.357 --> 00:06:33.694 align:middle
好在窗口不是全屏状态下

00:06:33.760 --> 00:06:35.329 align:middle
也能添加它们

00:06:35.863 --> 00:06:38.699 align:middle
那么这就是在窗口不是全屏状态下
它们看上去的样子

00:06:39.032 --> 00:06:40.767 align:middle
然后它们被自动地反复管理

00:06:41.535 --> 00:06:44.171 align:middle
为了理解这种模式的重要性

00:06:44.238 --> 00:06:47.574 align:middle
最好先理解
我们为什么会用这种模式

00:06:47.674 --> 00:06:49.443 align:middle
那么让我们看下您的窗口

00:06:50.143 --> 00:06:54.515 align:middle
通常 在工具栏和标题栏
下方的区域

00:06:54.581 --> 00:06:57.150 align:middle
是内容被替换的地方

00:06:57.384 --> 00:06:58.719 align:middle
您的内容就在它下面

00:06:59.620 --> 00:07:01.755 align:middle
但是从Mac OS X.10 开始

00:06:59.620 --> 00:07:01.755 align:middle
但是从Mac OS X.10 开始

00:07:02.556 --> 00:07:07.361 align:middle
您可实际利用一个完整的内容区

00:07:07.961 --> 00:07:11.164 align:middle
它可以在标题栏
和工具栏下面扩展

00:07:11.498 --> 00:07:12.599 align:middle
那么您的标题栏

00:07:12.666 --> 00:07:16.537 align:middle
和工具栏将会在它后面
自动为您进行模糊化处理

00:07:16.603 --> 00:07:18.772 align:middle
而您可以在这个位置为您的视图

00:07:18.839 --> 00:07:21.441 align:middle
放置全屏辅助视图控制器

00:07:23.210 --> 00:07:25.913 align:middle
那么您怎样才能实现
那种全屏蒙板效果呢？

00:07:25.979 --> 00:07:28.482 align:middle
它真的是很容易的
您只需在window.styleMask后面

00:07:28.549 --> 00:07:30.918 align:middle
加上NSFullSize
ContentViewWindowMask

00:07:30.984 --> 00:07:34.421 align:middle
而那将让您的内容在标题栏下
以全尺寸显示

00:07:35.622 --> 00:07:38.825 align:middle
用于使用标题栏
辅助视图控制器的实际API

00:07:38.892 --> 00:07:41.228 align:middle
这些控制器是
NSViewController的

00:07:41.295 --> 00:07:42.362 align:middle
一个非常简单的子类

00:07:42.696 --> 00:07:44.765 align:middle
因此所有的标准视图控制器

00:07:44.831 --> 00:07:46.333 align:middle
将会与它互动
决定如何加载它们

00:07:46.400 --> 00:07:49.603 align:middle
而它增加了两个属性一个是
layoutAttribute

00:07:49.670 --> 00:07:51.972 align:middle
另一个是FullScreenMin
Height

00:07:52.039 --> 00:07:53.907 align:middle
过一会我将谈到它们

00:07:53.974 --> 00:07:55.475 align:middle
但是让我们看一下

00:07:55.542 --> 00:07:58.278 align:middle
标题栏辅助视图控制器
能为您做的几件事情

00:07:58.946 --> 00:08:00.113 align:middle
正如我以前所说的

00:07:58.946 --> 00:08:00.113 align:middle
正如我以前所说的

00:08:00.180 --> 00:08:04.484 align:middle
它们将自动为您模糊化处理
它们后面的一切东西

00:08:04.551 --> 00:08:05.953 align:middle
您无须做任何特别的事情

00:08:06.687 --> 00:08:08.789 align:middle
它自动以某种视觉效果为您呈现

00:08:08.989 --> 00:08:10.691 align:middle
那就是实际的模糊化处理

00:08:11.191 --> 00:08:13.227 align:middle
它们自动以全屏状态显示

00:08:13.594 --> 00:08:15.729 align:middle
因此当您的窗口进入全屏
或退出全屏时

00:08:15.796 --> 00:08:17.264 align:middle
它们被放置在正确的位置

00:08:17.965 --> 00:08:20.200 align:middle
而且在某种程度上
它的大小也是自动为您管理的

00:08:20.267 --> 00:08:22.569 align:middle
而我们稍后将讨论这个内容

00:08:23.370 --> 00:08:27.975 align:middle
那么让我们看一下第一个属性layo
utAttribute（布局属性）

00:08:29.743 --> 00:08:34.313 align:middle
那么这里就是布局属性
当它被设置为“.bottom”时

00:08:34.881 --> 00:08:36.783 align:middle
“.bottom”的意思是您的视图

00:08:36.850 --> 00:08:39.720 align:middle
将被放在标题栏的下方

00:08:40.554 --> 00:08:43.590 align:middle
它的高度是您在NIB文件中
为该视图实际指定的任何高度

00:08:43.657 --> 00:08:45.859 align:middle
或者是您以任何方式指定的高度

00:08:45.926 --> 00:08:48.962 align:middle
而宽度会随着窗口大小的更改
而自动变化

00:08:51.365 --> 00:08:52.900 align:middle
另一个选项是 “.right”

00:08:53.467 --> 00:08:55.269 align:middle
这是一个 Safari 的例子

00:08:55.669 --> 00:08:57.871 align:middle
他们在使用 “.right” 选项

00:08:57.938 --> 00:09:00.274 align:middle
以便当Safari窗口
处于非全屏或全屏时

00:08:57.938 --> 00:09:00.274 align:middle
以便当Safari窗口
处于非全屏或全屏时

00:09:00.340 --> 00:09:02.543 align:middle
向Safari窗口添加
“+” 按钮

00:09:03.477 --> 00:09:06.213 align:middle
宽度是视图已经指定的任何宽度

00:09:06.580 --> 00:09:10.350 align:middle
而高度则是自动设定为
标题栏或工具栏的高度

00:09:11.852 --> 00:09:16.557 align:middle
Mac OS 10.11 的新特性
还包括指定一个“.left”的能力

00:09:17.191 --> 00:09:20.093 align:middle
通过它 你可以把项目

00:09:20.160 --> 00:09:21.862 align:middle
放在窗口按钮旁边

00:09:22.029 --> 00:09:24.998 align:middle
所以您可以在这里
添加一个注册按钮

00:09:25.065 --> 00:09:27.734 align:middle
或者您希望
向用户展示的其他备注

00:09:28.569 --> 00:09:32.806 align:middle
而这就是X.11的另一个新特性

00:09:34.274 --> 00:09:36.910 align:middle
接下来我们有全屏幕最小高度

00:09:38.145 --> 00:09:39.446 align:middle
让我们看一下那个属性

00:09:40.380 --> 00:09:42.749 align:middle
那么全屏幕最小高度
是什么意思呢？

00:09:43.016 --> 00:09:45.519 align:middle
这个属性仅当您

00:09:45.719 --> 00:09:47.855 align:middle
已处于全屏状态时才适用

00:09:48.388 --> 00:09:50.524 align:middle
而这就是您在全屏状态下

00:09:50.724 --> 00:09:52.125 align:middle
能够看见的最小高度

00:09:53.093 --> 00:09:55.529 align:middle
当您将鼠标移动到
工具栏之上时

00:09:55.596 --> 00:09:58.232 align:middle
任何未被显示的内容
将被自动显示

00:09:58.298 --> 00:10:00.601 align:middle
过一会儿我将向您展示
那种情况的一些屏幕快照

00:09:58.298 --> 00:10:00.601 align:middle
过一会儿我将向您展示
那种情况的一些屏幕快照

00:10:01.068 --> 00:10:02.669 align:middle
工具栏的默认高度为 0

00:10:03.670 --> 00:10:05.372 align:middle
那么让我们看一下
它的意思是什么

00:10:06.173 --> 00:10:07.908 align:middle
那么 全屏幕最低高度为 0

00:10:08.442 --> 00:10:09.576 align:middle
这里是一个工具栏

00:10:09.943 --> 00:10:13.914 align:middle
那里是一个辅助视图控制器
但它是隐藏的

00:10:13.981 --> 00:10:15.215 align:middle
因为高度为 0

00:10:15.849 --> 00:10:17.184 align:middle
如果高度不是 0

00:10:17.451 --> 00:10:20.821 align:middle
您在那里将总是会看到
您设定的任何值

00:10:21.788 --> 00:10:23.023 align:middle
用户让其显示的方式是

00:10:23.090 --> 00:10:27.160 align:middle
当你把鼠标移到菜单栏上部时
标题栏将被显示

00:10:27.594 --> 00:10:31.798 align:middle
而您的全屏辅助视图也将随其
自动显示

00:10:33.834 --> 00:10:35.202 align:middle
那样将把该部位突出显示

00:10:37.471 --> 00:10:40.841 align:middle
如果您已经用过 NSToolbar
您可能已经熟悉了

00:10:40.908 --> 00:10:43.110 align:middle
NSToolbar实现的
全屏辅助视图

00:10:43.477 --> 00:10:47.548 align:middle
而这个新的标题栏辅助视图控制器
取代了这个旧的 API

00:10:47.814 --> 00:10:50.050 align:middle
因此我们不鼓励您再使用它

00:10:50.684 --> 00:10:53.120 align:middle
但是最小高度和最大高度属性的
工作原理

00:10:53.187 --> 00:10:56.123 align:middle
与标题栏辅助视图控制器里面的
非常类似

00:10:58.926 --> 00:11:00.460 align:middle
那么您如何实际添加它们呢?

00:10:58.926 --> 00:11:00.460 align:middle
那么您如何实际添加它们呢?

00:11:00.527 --> 00:11:02.863 align:middle
我们在 NSWindow
上有四种方法

00:11:02.930 --> 00:11:06.200 align:middle
我们有一系列的
标题栏辅助视图控制器

00:11:06.266 --> 00:11:08.068 align:middle
您可以读取窗口的附件

00:11:09.036 --> 00:11:09.870 align:middle
您可以添加它们

00:11:10.871 --> 00:11:12.372 align:middle
您可以将它们
作为特殊索引插入

00:11:13.106 --> 00:11:15.008 align:middle
而且您也可以将其
作为特殊索引删除

00:11:15.142 --> 00:11:17.611 align:middle
但它确实是容易
添加和删除的

00:11:17.678 --> 00:11:19.913 align:middle
那么这里是您通常将要做的事情

00:11:20.247 --> 00:11:23.383 align:middle
您将调用Window.AddTitleBar
AccessoryViewController

00:11:23.717 --> 00:11:26.987 align:middle
将您的辅助视图控制器传递给它
然后当您希望去掉它时

00:11:27.054 --> 00:11:29.857 align:middle
您将使用默认的
NSViewController API

00:11:29.923 --> 00:11:32.593 align:middle
将其从父视图控制器中移除
父视图控制器自动确定它的位置

00:11:32.659 --> 00:11:34.795 align:middle
并将其移除

00:11:36.897 --> 00:11:40.067 align:middle
关于标题栏辅助视图控制器
就讲那么多

00:11:40.133 --> 00:11:41.969 align:middle
让我们谈一下全屏幕平铺

00:11:42.336 --> 00:11:45.072 align:middle
以及 Mac OS 10.11
里面的一些新特性

00:11:46.406 --> 00:11:49.243 align:middle
那么全屏幕平铺的目的是什么？

00:11:49.576 --> 00:11:51.512 align:middle
它们仍然让您或用户的注意力

00:11:51.578 --> 00:11:53.680 align:middle
集中在某个单一任务上

00:11:53.747 --> 00:11:55.782 align:middle
但是它可能涉及到多个窗口

00:11:56.617 --> 00:11:58.552 align:middle
您必须利用屏幕的全部空间

00:11:58.952 --> 00:12:01.889 align:middle
那么在这个屏幕快照上
我们有Safari浏览器窗口

00:11:58.952 --> 00:12:01.889 align:middle
那么在这个屏幕快照上
我们有Safari浏览器窗口

00:12:01.955 --> 00:12:06.293 align:middle
在边上有提示信息
让我们同时关注几个任务

00:12:06.360 --> 00:12:09.196 align:middle
那么让我们看一下
当您实际处于这一状态

00:12:09.263 --> 00:12:12.366 align:middle
并调整分割器大小的时候
会发生些什么

00:12:12.766 --> 00:12:16.637 align:middle
请注意 随着我改变其大小
Safari窗口达到了最小状态

00:12:17.204 --> 00:12:18.639 align:middle
并且提醒栏也达到最小状态

00:12:18.705 --> 00:12:23.577 align:middle
而且对于一个给定窗口
不会让它收缩得太厉害

00:12:23.744 --> 00:12:26.547 align:middle
因此它有一个可以达到的
最小和最大状态

00:12:27.915 --> 00:12:29.149 align:middle
那么我将谈一下如何实现

00:12:29.716 --> 00:12:30.717 align:middle
以及您需要做些什么

00:12:31.485 --> 00:12:34.988 align:middle
但是让我们先讨论一下
什么样的窗口

00:12:35.055 --> 00:12:36.323 align:middle
可以进行全屏幕平铺

00:12:37.724 --> 00:12:40.827 align:middle
我们将明确允许任何窗口

00:12:40.894 --> 00:12:46.033 align:middle
进入全屏平铺
只要它的大小可调并且不是面板

00:12:46.200 --> 00:12:48.302 align:middle
那意味着你的窗口不必

00:12:48.368 --> 00:12:49.903 align:middle
一定是可全屏化的

00:12:50.270 --> 00:12:52.439 align:middle
但是它仍可以被添加并平铺到

00:12:52.673 --> 00:12:54.474 align:middle
另一个可全屏化的窗口内

00:12:55.008 --> 00:12:57.244 align:middle
具体我们做些什么

00:12:57.311 --> 00:12:59.246 align:middle
以及如何确定都会随时间改变

00:13:00.013 --> 00:13:02.449 align:middle
因此您可能希望
让这个过程更明确

00:13:03.417 --> 00:13:06.587 align:middle
那么让我们假定
您有一个可调整大小的窗口

00:13:06.687 --> 00:13:09.289 align:middle
它无法被放入平铺窗口
而你希望将它放入平铺窗口

00:13:09.356 --> 00:13:12.025 align:middle
您可以在collection
Behavior后

00:13:12.092 --> 00:13:15.162 align:middle
明确添加FullScreenAll
owsTiling

00:13:15.229 --> 00:13:17.297 align:middle
使其能够被放入平铺窗口

00:13:18.465 --> 00:13:21.034 align:middle
类似地 您可能有一个窗口

00:13:21.101 --> 00:13:22.669 align:middle
您希望它永远不被放入平铺

00:13:23.136 --> 00:13:26.139 align:middle
那么我们就规定...
它可以被放入平铺

00:13:26.206 --> 00:13:27.508 align:middle
但是您不希望它被放入平铺

00:13:27.774 --> 00:13:30.143 align:middle
因此您可以让
FullScreenDisallowsTiling

00:13:30.210 --> 00:13:31.044 align:middle
来防止它被平铺

00:13:32.112 --> 00:13:35.148 align:middle
此外 您可能有一个窗口
您让它全屏化

00:13:35.215 --> 00:13:37.751 align:middle
而且希望它总是独立状态
您可以在那个窗口上设置

00:13:37.818 --> 00:13:40.654 align:middle
FullScreen
DisallowsTiling

00:13:40.721 --> 00:13:43.657 align:middle
以防止任何其他窗口
与它放在一起

00:13:45.025 --> 00:13:47.995 align:middle
那么现在您了解了如何

00:13:48.061 --> 00:13:49.062 align:middle
让一个窗口进入平铺

00:13:49.463 --> 00:13:50.797 align:middle
让我们谈一下那个窗口的

00:13:50.864 --> 00:13:52.633 align:middle
最小和最大尺寸

00:13:52.999 --> 00:13:55.836 align:middle
通常 当您的窗口
未处于全屏状态时

00:13:56.136 --> 00:13:59.540 align:middle
您可以调整其大小
并且自动受到

00:13:59.606 --> 00:14:00.574 align:middle
其最小和最大尺寸限制

00:13:59.606 --> 00:14:00.574 align:middle
其最小和最大尺寸限制

00:14:00.641 --> 00:14:04.778 align:middle
而当你使用 AutoLayout
时那通常是由 AutoLayout

00:14:04.845 --> 00:14:06.146 align:middle
自动确定的

00:14:06.980 --> 00:14:08.982 align:middle
如果您没有使用
AutoLayout

00:14:09.349 --> 00:14:12.486 align:middle
那么窗口的最大和最小尺寸
就发挥作用了

00:14:12.553 --> 00:14:13.987 align:middle
那些只是显示的

00:14:14.054 --> 00:14:15.455 align:middle
您在窗口内设置的属性

00:14:15.522 --> 00:14:17.858 align:middle
或者是内容的最小尺寸
或者是内容的最大尺寸,

00:14:17.925 --> 00:14:19.459 align:middle
都取决于您使用的API

00:14:19.993 --> 00:14:22.229 align:middle
如果您选中一个窗口
并准备将其全屏化

00:14:22.296 --> 00:14:26.066 align:middle
或者您准备全屏平铺
那些就是您

00:14:26.133 --> 00:14:27.568 align:middle
通常应该使用的API

00:14:28.101 --> 00:14:29.803 align:middle
但是那个规则也会有例外

00:14:29.870 --> 00:14:32.339 align:middle
而我们有更多的API来解决例外

00:14:33.073 --> 00:14:36.176 align:middle
首先让我们谈一下该规则的一个例外
以及您将做些什么

00:14:36.376 --> 00:14:38.011 align:middle
那么这里是可能是一个小的

00:14:38.078 --> 00:14:39.479 align:middle
计算器应用

00:14:39.546 --> 00:14:41.215 align:middle
它的尺寸是不可调整的

00:14:41.648 --> 00:14:44.351 align:middle
那么这位开发者就可能说
好吧 我们将让它

00:14:44.418 --> 00:14:45.385 align:middle
放入平铺

00:14:46.320 --> 00:14:49.756 align:middle
但是当它被放入平铺的时候
如这里所示

00:14:50.123 --> 00:14:52.926 align:middle
现在那个计算器应用的高度
比以前高了很多

00:14:52.993 --> 00:14:55.796 align:middle
即使它是不可调整大小的

00:14:56.196 --> 00:14:58.532 align:middle
因此它需要对其进行处理
并做些特殊的事情

00:14:59.333 --> 00:15:02.202 align:middle
您可能还会在那里加些额外视图
以便在其全屏平铺时

00:14:59.333 --> 00:15:02.202 align:middle
您可能还会在那里加些额外视图
以便在其全屏平铺时

00:15:02.269 --> 00:15:04.771 align:middle
向用户显示更多信息

00:15:05.372 --> 00:15:06.874 align:middle
因此您可以动态实现这种效果

00:15:06.940 --> 00:15:09.643 align:middle
而且您只是使用一些
window delegate方法

00:15:09.710 --> 00:15:12.246 align:middle
WindowWillEnter
FullScreen

00:15:12.312 --> 00:15:14.548 align:middle
而在这种特定情况下
当我们进入全屏模式时

00:15:14.615 --> 00:15:16.383 align:middle
我们将取消一些视图的隐藏状态

00:15:16.450 --> 00:15:17.951 align:middle
更改一些约束优先级

00:15:18.018 --> 00:15:20.153 align:middle
当窗口处于全屏化时
它们让系统对窗口大小

00:15:20.220 --> 00:15:21.688 align:middle
实际进行调整

00:15:22.022 --> 00:15:24.525 align:middle
而当它退出全屏幕时
它再将那些工作取消

00:15:24.591 --> 00:15:27.160 align:middle
重要的一点是知道
你实际可能必须

00:15:27.227 --> 00:15:31.832 align:middle
使用这些 delegate 方法
即使您的窗口

00:15:31.899 --> 00:15:33.700 align:middle
通常并不构成一个全屏幕主窗口

00:15:34.168 --> 00:15:36.270 align:middle
因此这可能是为一个平铺窗口调用

00:15:38.305 --> 00:15:42.576 align:middle
现在那些窗口
在进入全屏状态之前

00:15:42.643 --> 00:15:43.944 align:middle
它们的尺寸是尤其厚的

00:15:44.011 --> 00:15:46.013 align:middle
但是当它们处于全屏状态时
尺寸就不同了

00:15:46.747 --> 00:15:49.783 align:middle
当它将进入全屏状态时
您很可能

00:15:49.883 --> 00:15:51.351 align:middle
需要告诉系统那些尺寸

00:15:51.418 --> 00:15:53.187 align:middle
那么我们有一个
显式API来实现

00:15:53.253 --> 00:15:56.190 align:middle
我们有一个minFull
ScreenContentSize

00:15:56.356 --> 00:15:59.526 align:middle
和一个maxFullScreen
ContentSize来实现

00:15:59.593 --> 00:16:02.095 align:middle
您需要及早设置这些参数
因为如果您

00:15:59.593 --> 00:16:02.095 align:middle
您需要及早设置这些参数
因为如果您

00:16:02.162 --> 00:16:04.865 align:middle
曾经尝试 Mac OS 10.11
您可能注意到当您点击并

00:16:04.932 --> 00:16:07.568 align:middle
按住绿色按钮不放的时候
系统会为您提供

00:16:07.634 --> 00:16:10.771 align:middle
尺寸符合可用空间的
其他备选窗口供您选择

00:16:11.538 --> 00:16:14.808 align:middle
因此 作为开发者
您需要及早设置这些最小值

00:16:15.409 --> 00:16:16.476 align:middle
以便让系统能够确定

00:16:16.543 --> 00:16:18.879 align:middle
适合该区域的潜在备选窗口

00:16:20.013 --> 00:16:22.049 align:middle
正如我以前所言
通常您不需要使用这些设置

00:16:22.115 --> 00:16:24.117 align:middle
当您的窗口正好
是通常的尺寸可调窗口的话

00:16:24.184 --> 00:16:25.986 align:middle
它们在很大程度上是自动的

00:16:26.787 --> 00:16:28.555 align:middle
那么这就会导致一种两难困境

00:16:28.722 --> 00:16:32.292 align:middle
如果您的窗口尺寸
比如说是1200

00:16:32.359 --> 00:16:36.563 align:middle
而另外一个窗口
窗口 B 的尺寸是 300

00:16:36.630 --> 00:16:38.699 align:middle
会发生什么?

00:16:40.100 --> 00:16:41.201 align:middle
那么系统将不会

00:16:41.268 --> 00:16:44.137 align:middle
让这两个窗口在一起

00:16:44.538 --> 00:16:48.108 align:middle
它们的minFullScreenC
ontentSize值太大

00:16:48.342 --> 00:16:49.409 align:middle
而无法实现

00:16:50.511 --> 00:16:52.980 align:middle
那么作为开发者
您需要做些什么呢？

00:16:54.515 --> 00:16:56.950 align:middle
对于这方面我将请上我的同事
Taylor Kelly

00:16:57.017 --> 00:16:59.253 align:middle
他将会讨论如何通过灵活布局

00:16:59.319 --> 00:17:00.420 align:middle
而解决那个问题

00:16:59.319 --> 00:17:00.420 align:middle
而解决那个问题

00:17:00.487 --> 00:17:01.922 align:middle
谢谢大家！

00:17:14.201 --> 00:17:15.035 align:middle
大家好！

00:17:15.102 --> 00:17:16.603 align:middle
在这下半个环节中
我们将讨论

00:17:16.670 --> 00:17:19.106 align:middle
如何让您的布局更灵活

00:17:19.173 --> 00:17:22.409 align:middle
尤其当它们处于新的Split
View中时可以被调整到多窄

00:17:23.609 --> 00:17:26.713 align:middle
在 Mac 平台上我们有
多种显示尺寸

00:17:26.780 --> 00:17:27.948 align:middle
供您的应用在其上运行

00:17:28.015 --> 00:17:31.251 align:middle
而在全屏状态下
用户能够将其自身全部浸入

00:17:31.451 --> 00:17:32.686 align:middle
占据整个显示空间

00:17:33.820 --> 00:17:36.390 align:middle
在Split View下
用户现在可以让另外一个窗口

00:17:36.456 --> 00:17:39.326 align:middle
进入这个环境
从而营造一种更丰富的体验

00:17:40.093 --> 00:17:43.163 align:middle
但是这要求两个窗口灵活的

00:17:43.263 --> 00:17:45.499 align:middle
其尺寸大小可以调整

00:17:45.966 --> 00:17:47.334 align:middle
以防止出现冲突的情况

00:17:47.401 --> 00:17:49.102 align:middle
Corbin 早些时候
也谈到了这一点

00:17:49.803 --> 00:17:52.739 align:middle
这对于较小显示尺寸
如Retina MacBook

00:17:52.940 --> 00:17:54.241 align:middle
可能是尤其严格的

00:17:55.008 --> 00:17:58.579 align:middle
它的默认分辨率为1280*800

00:17:59.046 --> 00:18:00.747 align:middle
表示在Split View中

00:17:59.046 --> 00:18:00.747 align:middle
表示在Split View中

00:18:00.814 --> 00:18:03.917 align:middle
当平均分割时
每个窗口大约被分配638

00:18:03.984 --> 00:18:05.552 align:middle
每个窗口大约被分配638个点

00:18:05.619 --> 00:18:07.955 align:middle
如果您的应用的最小宽度

00:18:08.021 --> 00:18:10.791 align:middle
目前比这个大
这些显示尺寸的用户

00:18:10.858 --> 00:18:12.459 align:middle
通常将不能将您的应用平铺

00:18:13.727 --> 00:18:17.030 align:middle
因此我将谈一下
您可以使用的四种技巧

00:18:17.097 --> 00:18:19.566 align:middle
以确保您的窗口在全屏状态下
有令人满意的表现

00:18:20.400 --> 00:18:22.636 align:middle
首先 是使用自动布局和优先条件

00:18:23.504 --> 00:18:26.306 align:middle
其次是自动折叠的新侧栏行为

00:18:27.341 --> 00:18:30.110 align:middle
然后是使用 NSStackView
轻易地构建

00:18:30.177 --> 00:18:32.679 align:middle
您的界面的各个部分
同时将灵活性内置其中

00:18:33.213 --> 00:18:35.849 align:middle
最后是更新过的
NSCollectionView

00:18:35.916 --> 00:18:37.918 align:middle
它有了强大的布局支持

00:18:40.954 --> 00:18:43.223 align:middle
那么自动布局是一个
我们在OSX Lion和iOS 6中

00:18:43.290 --> 00:18:45.926 align:middle
推出的基于约束条件的布局系统

00:18:46.360 --> 00:18:49.062 align:middle
它让您声明不同的
UI 元素之间的关系

00:18:49.129 --> 00:18:51.398 align:middle
比如它们的间隔或者对齐

00:18:52.266 --> 00:18:53.634 align:middle
而它确实是强大的

00:18:53.700 --> 00:18:55.369 align:middle
窗口的视图尺寸被动态调整

00:18:55.636 --> 00:18:56.770 align:middle
比如在进行本地化的时候

00:18:57.771 --> 00:18:59.740 align:middle
您可以在这些约束条件之间
建立优先顺序

00:18:59.806 --> 00:19:01.975 align:middle
让级别高的优先于级别低的

00:18:59.806 --> 00:19:01.975 align:middle
让级别高的优先于级别低的

00:19:03.043 --> 00:19:04.811 align:middle
对此我将不去过多讨论细节

00:19:04.878 --> 00:19:06.346 align:middle
今天早些时候有两个讲座

00:19:06.413 --> 00:19:08.282 align:middle
《自动布局的奥秘》的
第一和第二部分

00:19:08.348 --> 00:19:10.117 align:middle
不管您在自动布局方面
是初次接触还是已有接触

00:19:10.184 --> 00:19:11.652 align:middle
它都有一些确实不错的内容

00:19:12.186 --> 00:19:14.054 align:middle
相反 在这个 UI 例子中

00:19:14.121 --> 00:19:15.222 align:middle
我将重点关注优先顺序

00:19:16.190 --> 00:19:18.625 align:middle
我们在中部有一个标签
它的左右两侧

00:19:18.692 --> 00:19:20.127 align:middle
都有固定按钮

00:19:20.360 --> 00:19:22.829 align:middle
这些可能是您会用来创建
那种效果的水平约束

00:19:23.630 --> 00:19:26.466 align:middle
仅仅使用这些约束的话
如果视图的尺寸动态调整

00:19:26.800 --> 00:19:29.369 align:middle
您最后可能会
让标签和较宽的按钮相互重叠

00:19:30.037 --> 00:19:31.371 align:middle
这是非常容易解决的

00:19:31.438 --> 00:19:34.107 align:middle
您可以在按钮和标签之间
增加一个最小间隔约束

00:19:34.741 --> 00:19:36.310 align:middle
而现在
当容器的尺寸调整时

00:19:36.510 --> 00:19:37.744 align:middle
它的尺寸只能调整到

00:19:37.811 --> 00:19:41.081 align:middle
它能同时满足
居中对齐和最小间隔的程度

00:19:41.882 --> 00:19:44.518 align:middle
这是一个完美的布局
除非这个视图

00:19:44.585 --> 00:19:46.486 align:middle
能够变得更紧凑

00:19:46.720 --> 00:19:49.590 align:middle
去掉较窄按钮和标签之间的
那些空白就太好了

00:19:50.958 --> 00:19:54.194 align:middle
回过来 我们可以让这个
居中对齐成为可选条件

00:19:54.494 --> 00:19:56.864 align:middle
意思是它可以
被更优先的约束条件打破

00:19:57.531 --> 00:19:59.600 align:middle
此外 我们将会
在标签和较窄按钮之间

00:19:59.666 --> 00:20:02.302 align:middle
增加一个最小间隔
以防在那一侧出现重叠

00:19:59.666 --> 00:20:02.302 align:middle
增加一个最小间隔
以防在那一侧出现重叠

00:20:03.170 --> 00:20:05.639 align:middle
这次 标签尽可能居中

00:20:05.973 --> 00:20:08.008 align:middle
直到它触及了最小间隔的填充

00:20:08.075 --> 00:20:11.044 align:middle
而如果我们继续调整容器的大小
我们可以打破居中条件

00:20:11.111 --> 00:20:12.813 align:middle
以便最大化地压缩布局

00:20:12.880 --> 00:20:17.484 align:middle
直到我们
满足两侧的最小填充

00:20:18.185 --> 00:20:20.187 align:middle
您可以仅仅
通过设置优选顺序属性

00:20:20.254 --> 00:20:21.955 align:middle
来为您的约束条件
进行这样的设置

00:20:22.022 --> 00:20:24.992 align:middle
而这也通过Interface
Builder暴露出来

00:20:25.726 --> 00:20:27.761 align:middle
默认情况下
需要满足约束条件

00:20:27.928 --> 00:20:29.096 align:middle
就是说它们必须被满足

00:20:29.162 --> 00:20:32.132 align:middle
但是任何低于那个的
约束条件将成为可选的

00:20:32.933 --> 00:20:35.002 align:middle
我们有些要点
帮您决定您的约束条件

00:20:35.068 --> 00:20:36.303 align:middle
优先顺序应该是什么样子

00:20:36.370 --> 00:20:38.572 align:middle
另外还有Default Low
它是一个优先条件

00:20:38.639 --> 00:20:41.074 align:middle
通常您的约束条件
弱于大多数其他约束软件

00:20:41.141 --> 00:20:43.944 align:middle
还有DragThatCannot
ResizeWindow

00:20:44.011 --> 00:20:45.112 align:middle
它是一个特定的优先条件

00:20:45.179 --> 00:20:47.648 align:middle
在此条件下一个Split
View分割线会被拖动

00:20:47.714 --> 00:20:49.216 align:middle
如果您希望自己的约束条件

00:20:49.283 --> 00:20:51.618 align:middle
比这种行为更加强大
您应让您的优先条件级别更高,

00:20:51.685 --> 00:20:52.886 align:middle
否则更低

00:20:52.953 --> 00:20:55.689 align:middle
您通常永远不会
设置跟这个完全一样的优先条件

00:20:55.756 --> 00:20:58.458 align:middle
此外还有WindowsSize
StayPut

00:20:58.525 --> 00:21:00.427 align:middle
这个优先条件规定
一个窗口维持当前的尺寸

00:20:58.525 --> 00:21:00.427 align:middle
这个优先条件规定
一个窗口维持当前的尺寸

00:21:00.494 --> 00:21:03.730 align:middle
最后是DragThatCanRes
izeWindow

00:21:03.797 --> 00:21:05.432 align:middle
在这个条件下一个窗口被拖拽

00:21:05.499 --> 00:21:08.702 align:middle
但是还有 Default High
它是另外一个优先条件

00:21:08.769 --> 00:21:10.571 align:middle
在此条件下您的约束条件

00:21:10.637 --> 00:21:11.972 align:middle
通常高于多数其他条件

00:21:12.539 --> 00:21:14.608 align:middle
那么这就是Auto Layout的
优先条件

00:21:14.675 --> 00:21:16.844 align:middle
在此后的几个部分内

00:21:16.910 --> 00:21:18.579 align:middle
我将回过头来
参考一下优先权的概念

00:21:18.645 --> 00:21:22.082 align:middle
但是接下来我想谈一下NSSplit
ViewController

00:21:22.149 --> 00:21:24.985 align:middle
这是我们在Yosemite中
推出的一个容器视图控制器类

00:21:25.052 --> 00:21:27.187 align:middle
它让您的子视图控制器

00:21:27.254 --> 00:21:28.989 align:middle
被安排在
NSSplitView 内

00:21:29.389 --> 00:21:31.525 align:middle
并且暴露了
NSSplitView 项目的概念

00:21:31.692 --> 00:21:34.828 align:middle
它概括了那些在Split
View中的子类的状态

00:21:34.895 --> 00:21:37.064 align:middle
这些子类包括
holdingpriority

00:21:37.130 --> 00:21:41.235 align:middle
Collapsed状态而且它允许以
一种真正简单的方式获得动态折叠效果

00:21:41.301 --> 00:21:44.505 align:middle
去年的OSX Storyboard
和控制器讲座更多地讨论了

00:21:44.571 --> 00:21:46.373 align:middle
这个特性以及其他
视图控制器特性

00:21:46.440 --> 00:21:49.176 align:middle
但是我想重点谈一下
OS 10.11中的新内容

00:21:50.143 --> 00:21:52.479 align:middle
首先是侧边栏的显式概念

00:21:52.546 --> 00:21:54.281 align:middle
及其伴随的特殊行为

00:21:54.815 --> 00:21:57.184 align:middle
以及spring loading
它是当一个项目

00:21:57.251 --> 00:22:00.053 align:middle
被在Split View中拖拽时
可能发生的行为

00:21:57.251 --> 00:22:00.053 align:middle
被在Split View中拖拽时
可能发生的行为

00:22:00.387 --> 00:22:02.089 align:middle
以及几个新的度量指标

00:22:02.155 --> 00:22:06.026 align:middle
它们让您在调整大小期间
精确地声明

00:22:06.093 --> 00:22:07.361 align:middle
Split View的行为

00:22:08.662 --> 00:22:11.198 align:middle
我们看一个例子
这里是 Safari 中的侧边栏

00:22:11.899 --> 00:22:14.835 align:middle
随着窗口尺寸的调整
一旦它达到某个点

00:22:14.902 --> 00:22:16.436 align:middle
侧边栏将会自动折叠

00:22:16.603 --> 00:22:19.306 align:middle
而如果它在全屏状态被重新显示

00:22:19.373 --> 00:22:21.842 align:middle
它将覆盖其他窗口内容

00:22:22.543 --> 00:22:24.945 align:middle
这个过程是短暂的
类似于弹出框

00:22:25.012 --> 00:22:26.914 align:middle
因此点击其外侧将使其自动消失

00:22:26.980 --> 00:22:28.282 align:middle
这真的是容易理解的

00:22:28.348 --> 00:22:30.417 align:middle
您只须在
NSSplitViewItem上

00:22:30.484 --> 00:22:33.921 align:middle
使用sidebarWithView
Controller这一构造函数

00:22:33.987 --> 00:22:36.924 align:middle
或者在Interface
Builder中将行为传递给侧边栏

00:22:36.990 --> 00:22:39.359 align:middle
这将返回给您
一个split view项目

00:22:39.426 --> 00:22:41.762 align:middle
您可以把它添加到
您的split view控制器上

00:22:41.828 --> 00:22:44.531 align:middle
而且它也伴随一些特殊行为
比如 Yosemite 中将推出的

00:22:44.598 --> 00:22:47.134 align:middle
内置的半透明材质背景
和醒目的分割线

00:22:47.201 --> 00:22:48.969 align:middle
您不必再加入您自己的
视频效果视图

00:22:49.036 --> 00:22:50.637 align:middle
才能获得这种效果

00:22:50.871 --> 00:22:53.607 align:middle
NSSplitViewItem
将会为您进行添加和管理

00:22:53.774 --> 00:22:55.609 align:middle
此外还有您刚才看到的

00:22:55.676 --> 00:22:58.712 align:middle
autocollapse
和autouncollapse行为

00:22:58.779 --> 00:23:00.514 align:middle
通过它 覆盖层将占据整个屏幕

00:22:58.779 --> 00:23:00.514 align:middle
通过它 覆盖层将占据整个屏幕

00:23:01.915 --> 00:23:03.851 align:middle
此外还有另外几个默认属性

00:23:03.917 --> 00:23:05.352 align:middle
以及侧边栏的标准值

00:23:05.686 --> 00:23:08.288 align:middle
因此您的侧边栏对系统的行为
正如其他要素一样

00:23:09.022 --> 00:23:11.325 align:middle
伴随它的
还有一个split view方面的

00:23:11.391 --> 00:23:13.393 align:middle
新的行为方法
即 toggleSidebar

00:23:13.460 --> 00:23:15.562 align:middle
它将具有动画效果地折叠或

00:23:15.629 --> 00:23:17.564 align:middle
展开它包含的第一个侧边栏

00:23:18.532 --> 00:23:20.667 align:middle
通过这种方式
无须书写一行代码

00:23:20.734 --> 00:23:24.004 align:middle
您就可以关联菜单项
使其具有这种效果 或切换按钮

00:23:25.539 --> 00:23:28.408 align:middle
另外一个确实很酷的行为
是spring loading

00:23:28.475 --> 00:23:31.144 align:middle
这是当用户在您的split
view边缘上存在折叠窗格

00:23:31.211 --> 00:23:34.781 align:middle
并将一个项目向该边缘拖拽时
发生的行为

00:23:35.516 --> 00:23:38.085 align:middle
我们将平移并让侧边栏展开

00:23:38.151 --> 00:23:41.154 align:middle
让它们与其互动在它们的动作完成之后
让侧边栏再次折叠

00:23:41.221 --> 00:23:44.591 align:middle
您可通过将springLoaded
设为True来达到此效果

00:23:44.658 --> 00:23:47.160 align:middle
在您的split view项目中
您将获得此行为效果

00:23:47.227 --> 00:23:49.830 align:middle
且对侧边栏和非侧边栏同样适用

00:23:50.163 --> 00:23:52.566 align:middle
区别在于
侧边栏将默认为 True

00:23:52.866 --> 00:23:54.635 align:middle
我们认为大多数的侧边栏
将希望这种行为

00:23:54.701 --> 00:23:58.572 align:middle
接下来我想谈一下我们在NSSpli
tViewItem控制器上的

00:23:58.739 --> 00:24:00.374 align:middle
几个新的度量指标

00:23:58.739 --> 00:24:00.374 align:middle
几个新的度量指标

00:24:00.440 --> 00:24:02.042 align:middle
我将每次讲两个

00:24:02.109 --> 00:24:04.478 align:middle
首先是
minimumThickness

00:24:04.545 --> 00:24:06.413 align:middle
和maximumThickness

00:24:06.480 --> 00:24:08.649 align:middle
这些与split view项目
正在自我管理的

00:24:08.715 --> 00:24:10.217 align:middle
约束条件直接相关

00:24:10.284 --> 00:24:13.287 align:middle
它们描述了这个项目
可以实际变得多大或多小

00:24:14.021 --> 00:24:15.989 align:middle
侧边栏将默认将这些值
设为标准值

00:24:16.290 --> 00:24:17.424 align:middle
但这的确是一个

00:24:17.491 --> 00:24:20.694 align:middle
您自己设置约束条件的
非常方便的方式

00:24:22.262 --> 00:24:25.632 align:middle
HoldingPriority是OS 10.11中
惟一的一个不是新的度量指标

00:24:25.832 --> 00:24:26.900 align:middle
它描述了split view 项目

00:24:26.967 --> 00:24:29.002 align:middle
维持其当前大小的一个优先权

00:24:29.636 --> 00:24:31.305 align:middle
在本例中
侧边栏被默认设置为

00:24:31.371 --> 00:24:33.640 align:middle
一个略高的值
因此这意味着它们比其他项目

00:24:33.707 --> 00:24:35.375 align:middle
被调整尺寸的可能性更小

00:24:36.243 --> 00:24:38.212 align:middle
那么作为一个例子
当它调整此窗口大小时

00:24:38.312 --> 00:24:40.280 align:middle
尺寸调整的全部权重
都分配给了内容区

00:24:40.347 --> 00:24:42.316 align:middle
而侧边栏的宽度保持不变

00:24:43.884 --> 00:24:45.085 align:middle
回顾一下 你可能也将这个

00:24:45.152 --> 00:24:46.820 align:middle
设置为在两个项目间

00:24:46.920 --> 00:24:48.021 align:middle
具有同样的保持优先权

00:24:48.722 --> 00:24:50.691 align:middle
如果您熟悉自动布局
您可能将这种情况

00:24:50.757 --> 00:24:51.959 align:middle
认为是一种模棱两可的情况

00:24:52.025 --> 00:24:54.595 align:middle
但是NSSplitView
会对这种情况进行特殊处理

00:24:54.661 --> 00:24:55.996 align:middle
这次当您调整其大小时

00:24:56.430 --> 00:24:58.365 align:middle
两个视图会根据
它们在尺寸调整之前的大小

00:24:58.432 --> 00:25:00.701 align:middle
按比例地调整大小

00:24:58.432 --> 00:25:00.701 align:middle
按比例地调整大小

00:25:00.767 --> 00:25:02.803 align:middle
因此两个视图都尺寸
都被调整得稍微大一点

00:25:03.270 --> 00:25:05.339 align:middle
那就是
holdingPriority

00:25:05.405 --> 00:25:08.876 align:middle
下一个度量指标是preferred
ThicknessFraction

00:25:08.942 --> 00:25:11.645 align:middle
它描述了某个split
view项目希望占据的空间

00:25:11.712 --> 00:25:13.313 align:middle
占split view的理想百分比

00:25:13.380 --> 00:25:15.582 align:middle
例如 侧边栏被默认为15 %

00:25:16.383 --> 00:25:18.986 align:middle
当用户进入全屏状态
或双击分割线的时候

00:25:19.052 --> 00:25:21.722 align:middle
该项目将自动跳到那个首选厚度

00:25:21.922 --> 00:25:24.091 align:middle
它们的确非常容易地
就能恢复到那一标准值

00:25:25.459 --> 00:25:28.195 align:middle
作为一个限值 自动最大厚度
对所有这些尺寸调整行为

00:25:28.262 --> 00:25:30.197 align:middle
都发挥作用

00:25:30.631 --> 00:25:32.866 align:middle
如果15%对应于350的话

00:25:32.933 --> 00:25:35.335 align:middle
那么它将被限制为不超过280

00:25:35.802 --> 00:25:38.172 align:middle
那些是NSSplit
ViewItem度量指标

00:25:38.238 --> 00:25:41.508 align:middle
在NSSplitViewContr
oller上还有另一个度量指标

00:25:41.575 --> 00:25:46.346 align:middle
那就是用于内嵌侧边栏的
minimumThicknessForinlineSidebars

00:25:46.413 --> 00:25:49.483 align:middle
它描述了您的split view
控制器中侧边栏将自动折叠的宽度

00:25:49.550 --> 00:25:51.752 align:middle
因此 将尺寸调整到那一数值
将让它们保持内嵌状态

00:25:51.818 --> 00:25:55.122 align:middle
进一步拖拽将让您的侧边栏折叠

00:25:55.189 --> 00:25:57.124 align:middle
这也适用于全屏幕状态

00:25:57.624 --> 00:25:59.593 align:middle
关键区别在于
当处于全屏幕状态时

00:25:59.660 --> 00:26:02.162 align:middle
如果它总是被明确重新显示
它就被显示为叠加状态

00:25:59.660 --> 00:26:02.162 align:middle
如果它总是被明确重新显示
它就被显示为叠加状态

00:26:03.163 --> 00:26:05.065 align:middle
这说明了全屏状态下的
一个重要概念

00:26:05.132 --> 00:26:07.534 align:middle
在全屏状态下
我们希望避免让窗口运行

00:26:07.634 --> 00:26:09.303 align:middle
以防止和相邻元素的可能的冲突

00:26:09.903 --> 00:26:11.872 align:middle
在您的窗口内重新安排各个元素

00:26:11.939 --> 00:26:14.508 align:middle
总是比扩大窗口要好

00:26:14.575 --> 00:26:17.444 align:middle
为支持NSSplit
ViewController中的

00:26:17.511 --> 00:26:19.880 align:middle
这样一些新特性
我们已经对 NSSplitView

00:26:19.947 --> 00:26:23.150 align:middle
做出了一些改进
具体而言是通过对子视图的排列

00:26:24.651 --> 00:26:25.953 align:middle
在 El Capitan 之前

00:26:26.220 --> 00:26:29.122 align:middle
split view中的所有子视图
都被视为分割开来的窗格

00:26:30.090 --> 00:26:31.358 align:middle
这意味着管理它的 API

00:26:31.425 --> 00:26:33.894 align:middle
只是从NSView继承来的
子视图 API

00:26:34.428 --> 00:26:36.997 align:middle
这是方便的但是也带来了
两个确实很大的问题

00:26:37.831 --> 00:26:39.967 align:middle
一个问题是您不能增加

00:26:40.033 --> 00:26:41.768 align:middle
您不希望被视为分割窗格的子视图

00:26:42.436 --> 00:26:43.904 align:middle
例如 分割线

00:26:44.204 --> 00:26:46.340 align:middle
在此模型中
分割线不可以由视图表示

00:26:47.307 --> 00:26:49.676 align:middle
此外 您不能将 Z-顺序

00:26:49.977 --> 00:26:51.512 align:middle
与子视图的排列顺序区别开来

00:26:51.845 --> 00:26:55.215 align:middle
因此您的零索引子视图
是按Z顺序的第一个也是最下的

00:26:55.282 --> 00:26:57.651 align:middle
而没有办法将它们区别

00:26:58.385 --> 00:27:00.721 align:middle
因此 现在在10.11中
您可以指定一定的子视图

00:26:58.385 --> 00:27:00.721 align:middle
因此 现在在10.11中
您可以指定一定的子视图

00:27:00.787 --> 00:27:04.324 align:middle
作为使用NSSplitView的新
API而创建的split view

00:27:04.391 --> 00:27:05.559 align:middle
所排列的子视图

00:27:05.626 --> 00:27:09.062 align:middle
在管理已被排列的子视图方面这个AP
I与NSStackView的API

00:27:09.363 --> 00:27:11.732 align:middle
和UIStackView的
API精确匹配

00:27:11.798 --> 00:27:14.568 align:middle
此外还有这个属性ArrangesA
llSubviews

00:27:14.635 --> 00:27:16.270 align:middle
它默认是 True

00:27:16.336 --> 00:27:18.438 align:middle
意思是说您的子视图
仍总与被排列的子视图相同

00:27:18.505 --> 00:27:20.908 align:middle
并且匹配那种遗留行为

00:27:21.742 --> 00:27:24.912 align:middle
即使您将此属性设为False
NSSplitView 仍会确保

00:27:24.978 --> 00:27:27.047 align:middle
您的已被排列的子视图

00:27:27.114 --> 00:27:29.149 align:middle
永远是子视图的一个子集

00:27:29.783 --> 00:27:32.119 align:middle
例如 如果您添加了
一个还不是子视图的

00:27:32.186 --> 00:27:35.255 align:middle
被排列的子视图
它将被添加为子视图

00:27:36.823 --> 00:27:39.693 align:middle
最后 我们鼓励您开始使用
被排列的子视图

00:27:39.760 --> 00:27:41.795 align:middle
并将ArrangesAllSubviews
设为False

00:27:41.862 --> 00:27:42.829 align:middle
因为当您那么做的

00:27:42.896 --> 00:27:44.798 align:middle
时候NSSplitView
现在能够使用视图

00:27:44.865 --> 00:27:48.001 align:middle
代表分割线
并为分割线的醒目性

00:27:48.235 --> 00:27:50.470 align:middle
和特殊的窗口拖拽行为
创造条件

00:27:51.572 --> 00:27:53.340 align:middle
您可通过Interface
Builder控制它

00:27:53.407 --> 00:27:55.709 align:middle
选中这个Arranges
All Subviews 复选框

00:27:56.009 --> 00:27:58.879 align:middle
更新后的 NIB 文件
将选中此复选框以匹配遗留行为

00:27:59.279 --> 00:28:02.549 align:middle
但是从对象库里面拖拽出来的
新的split view将不会将其选中

00:27:59.279 --> 00:28:02.549 align:middle
但是从对象库里面拖拽出来的
新的split view将不会将其选中

00:28:02.616 --> 00:28:04.351 align:middle
这也是将来我们鼓励的行为

00:28:07.054 --> 00:28:10.457 align:middle
为了帮研究您目前在split view
上可能有的问题或试图理解

00:28:10.524 --> 00:28:11.792 align:middle
您的split view的工作机制

00:28:11.859 --> 00:28:14.561 align:middle
我们已经改进了对调试的描述
以便告诉您

00:28:14.628 --> 00:28:16.396 align:middle
诸如它如何执行布局

00:28:16.463 --> 00:28:18.599 align:middle
以及它将用什么
代表它的分割线

00:28:19.299 --> 00:28:20.968 align:middle
关于布局 有几种可能性

00:28:21.268 --> 00:28:24.004 align:middle
但是我们建议
确保split view使用约束条件

00:28:24.605 --> 00:28:27.641 align:middle
这让它简单地描述
它的分割窗格之间的关系

00:28:27.708 --> 00:28:29.743 align:middle
并与您在窗口中的
其他约束条件互动

00:28:30.377 --> 00:28:34.248 align:middle
此外 它将允许对您的
split view窗格的

00:28:34.548 --> 00:28:35.616 align:middle
从右到左的翻动

00:28:37.184 --> 00:28:39.920 align:middle
而且我们也建议...

00:28:40.387 --> 00:28:43.790 align:middle
开始使用视图代表分割线

00:28:44.358 --> 00:28:45.759 align:middle
原因如我以前所述

00:28:46.827 --> 00:28:49.763 align:middle
为了帮助弄清楚为何您的split view
可以或不可使用约束条件

00:28:49.830 --> 00:28:51.865 align:middle
我们已经添加了
这个DebugReasonForLayoutMode

00:28:51.932 --> 00:28:55.903 align:middle
它将给您提供具有可读性的描述以便了
解它是否会使用约束条件及其原因

00:28:56.737 --> 00:28:59.306 align:middle
最常见的原因是
Delegate将优先于特定的

00:28:59.373 --> 00:29:00.607 align:middle
与自动布局不相容的方法

00:28:59.373 --> 00:29:00.607 align:middle
与自动布局不相容的方法

00:29:00.674 --> 00:29:02.976 align:middle
而且将准确地告诉您
那些方法是什么

00:29:03.977 --> 00:29:05.779 align:middle
它是否在一个
使用自动布局的窗口内

00:29:05.846 --> 00:29:07.881 align:middle
还将决定它是否可以使用约束条件

00:29:07.948 --> 00:29:11.451 align:middle
最后如果它正在被NSSplitVi
ew Controller使用

00:29:11.952 --> 00:29:13.554 align:middle
则要求它使用约束条件

00:29:15.389 --> 00:29:18.125 align:middle
而如果您曾试图调试split
view的一些布局问题

00:29:18.192 --> 00:29:20.060 align:middle
并已输出约束条件

00:29:20.127 --> 00:29:21.962 align:middle
它很可能看上起像是这样

00:29:22.563 --> 00:29:23.697 align:middle
它是很难解读的

00:29:23.764 --> 00:29:25.699 align:middle
如果您确实希望理解它
您必须画一张图

00:29:26.166 --> 00:29:28.535 align:middle
您无法很好地辨别
哪些约束条件是您的app添加的

00:29:28.635 --> 00:29:30.971 align:middle
哪些约束条件是框架添加的

00:29:31.538 --> 00:29:35.342 align:middle
在OS10.11中NSSplitView
目前为所有它添加的约束条件

00:29:35.409 --> 00:29:36.276 align:middle
给出识别符

00:29:36.343 --> 00:29:38.645 align:middle
因此您不仅可以辨别
您在使用哪些约束条件

00:29:38.712 --> 00:29:41.048 align:middle
而且还可知道它在试图
用那个约束条件做些什么

00:29:41.114 --> 00:29:42.182 align:middle
您可以快速地辨别

00:29:42.249 --> 00:29:43.917 align:middle
您的app添加了哪些约束条件

00:29:43.984 --> 00:29:46.086 align:middle
或者是否有怪异的
您无法确定在发生什么的

00:29:46.153 --> 00:29:48.422 align:middle
尺寸调整行为
您可以快速地看出

00:29:48.488 --> 00:29:50.891 align:middle
哪些约束条件可能会
解决那一问题

00:29:50.958 --> 00:29:53.627 align:middle
NSStackView有适用于
其每个约束条件的

00:29:53.961 --> 00:29:55.028 align:middle
类似的识别符

00:29:55.829 --> 00:29:58.065 align:middle
现在我想谈一下
NSStackView

00:29:58.765 --> 00:30:00.868 align:middle
这是一个我们
在 Mavericks中引入的类

00:29:58.765 --> 00:30:00.868 align:middle
这是一个我们
在 Mavericks中引入的类

00:30:00.934 --> 00:30:02.836 align:middle
它确实简化了

00:30:02.903 --> 00:30:05.806 align:middle
使用自动布局进行的
水平或垂直视图堆叠

00:30:06.006 --> 00:30:08.709 align:middle
它完全与您在窗口中使用的
其他约束条件相容

00:30:08.775 --> 00:30:10.777 align:middle
但是它会管理它使用的所有约束条件

00:30:10.844 --> 00:30:13.013 align:middle
来创建堆叠

00:30:13.080 --> 00:30:15.115 align:middle
因此您可以添加或移除视图
而不必担心

00:30:15.182 --> 00:30:16.583 align:middle
对那些约束条件的更新

00:30:17.484 --> 00:30:19.987 align:middle
它内置了对齐和分布的概念

00:30:20.053 --> 00:30:22.189 align:middle
因此您可以控制您的视图

00:30:22.256 --> 00:30:24.391 align:middle
在堆叠视图内的放置方式

00:30:24.458 --> 00:30:26.793 align:middle
以及剪裁和附加行为
因此当堆叠视图

00:30:26.860 --> 00:30:28.862 align:middle
试图建立比它所包含的视图
更小的视图时

00:30:28.929 --> 00:30:30.831 align:middle
您可以控制发生的事情

00:30:31.031 --> 00:30:33.100 align:middle
此外 在 10.11 中
我们做出了一系列性能改进

00:30:33.166 --> 00:30:34.968 align:middle
降低了它使用的约束条件的数量

00:30:35.035 --> 00:30:39.606 align:middle
并且从使用内部专用视图
转换到使用 NS 布局指南

00:30:40.307 --> 00:30:42.709 align:middle
而我们已经看到一些
非常不错的性能改进

00:30:43.677 --> 00:30:45.712 align:middle
《自动布局的奥秘》的第一部分
谈到了这一点

00:30:45.779 --> 00:30:47.915 align:middle
和新的UIStackView 在 iOS

00:30:47.981 --> 00:30:49.850 align:middle
以及对我们现在所拥有的

00:30:49.917 --> 00:30:52.619 align:middle
新的Interface
Builder的很好的支持

00:30:52.686 --> 00:30:54.721 align:middle
我的确想重点谈一下
新的分配形式

00:30:54.988 --> 00:30:58.258 align:middle
它们描述了堆叠视图
如何沿着堆叠轴排列

00:30:58.325 --> 00:31:02.095 align:middle
您可以通过NSStackView的
Distribution属性

00:30:58.325 --> 00:31:02.095 align:middle
您可以通过NSStackView的
Distribution属性

00:31:02.162 --> 00:31:04.531 align:middle
对此进行设置我将逐一说明
它们是如何工作的

00:31:04.598 --> 00:31:07.935 align:middle
那么GravityAreas匹配
10.11 版本之前的行为

00:31:08.001 --> 00:31:10.938 align:middle
通过它您可以指定特定的视图
被吸引到split view的

00:31:11.004 --> 00:31:12.139 align:middle
特定的边缘

00:31:12.206 --> 00:31:14.208 align:middle
对于水平方向
有领先 居中和尾随

00:31:14.575 --> 00:31:16.210 align:middle
对于垂直方向
有顶部 居中和底部

00:31:16.276 --> 00:31:18.445 align:middle
那么在本例中
随着我们让堆叠视图的增加

00:31:18.912 --> 00:31:20.848 align:middle
这些视图将趋向于朝边缘移动

00:31:22.349 --> 00:31:25.052 align:middle
.Fill 是一个新的行为
它要求各个视图

00:31:25.118 --> 00:31:26.420 align:middle
将堆叠视图完全填充

00:31:26.520 --> 00:31:29.957 align:middle
而通过使用其他约束条件
您可以决定它们的增长方式

00:31:30.023 --> 00:31:30.991 align:middle
或尺寸分配方式

00:31:31.892 --> 00:31:35.395 align:middle
在本例中 Tiny 已经设置了
最低的拖拽优先权

00:31:35.462 --> 00:31:37.164 align:middle
因此随着我们让堆叠视图的增长

00:31:37.364 --> 00:31:39.032 align:middle
它获得了全部的尺寸调整权重

00:31:39.499 --> 00:31:41.502 align:middle
.FillEqually 是类似的

00:31:41.568 --> 00:31:43.670 align:middle
只是现在堆叠视图
将增加约束条件

00:31:43.770 --> 00:31:45.472 align:middle
各个视图将有相同的尺寸

00:31:46.206 --> 00:31:48.275 align:middle
在本例中 我们将增加
更强的约束条件

00:31:48.342 --> 00:31:49.443 align:middle
以便将堆叠视图向下挤压

00:31:49.510 --> 00:31:51.311 align:middle
而且它将优先于
这些均等填充的约束条件

00:31:51.378 --> 00:31:53.847 align:middle
但是随着我让堆叠视图增长

00:31:54.248 --> 00:31:56.216 align:middle
它们趋向于朝着尺寸均等化发展

00:31:58.285 --> 00:32:01.188 align:middle
.FillProportional
ly也是类似不过它们是

00:31:58.285 --> 00:32:01.188 align:middle
.FillProportional
ly也是类似不过它们是

00:32:01.255 --> 00:32:03.757 align:middle
根据其自身内容的尺寸
按比例增长

00:32:04.324 --> 00:32:06.393 align:middle
那么在本例中
较大的视图增长得更大

00:32:06.460 --> 00:32:08.962 align:middle
而更小的视图增长不多

00:32:10.230 --> 00:32:13.233 align:middle
.EqualSpacing是一种分
配方式根据此方式

00:32:13.300 --> 00:32:15.302 align:middle
获得额外尺寸的并不是视图

00:32:15.569 --> 00:32:17.104 align:middle
而是视图之间的间隔

00:32:17.905 --> 00:32:20.541 align:middle
在本例中
随着我们让边缘之间的间隔增大

00:32:20.674 --> 00:32:22.543 align:middle
各个视图之间的距离
都被调整到相同大小

00:32:24.244 --> 00:32:27.047 align:middle
.EqualCentering也是
类似不过在这里

00:32:27.514 --> 00:32:30.417 align:middle
不是视图边缘之间的间隔

00:32:30.751 --> 00:32:32.553 align:middle
而是视图中心的间隔
被调整到相同

00:32:33.720 --> 00:32:35.489 align:middle
有了这些新的分配行为

00:32:35.556 --> 00:32:38.192 align:middle
我们认为您可以将堆叠视图
用于您的 UI 中的更多地方

00:32:38.258 --> 00:32:40.827 align:middle
而且真正从
它所带来的变化中获益

00:32:42.329 --> 00:32:45.832 align:middle
堆叠视图的另一个方面是
剪裁行为

00:32:46.200 --> 00:32:48.936 align:middle
堆叠视图可被默认增大到

00:32:49.002 --> 00:32:51.471 align:middle
包含所有其他项目
所需的最小尺寸

00:32:52.239 --> 00:32:54.308 align:middle
但是您可能也需要
设置剪裁抵抗优先权

00:32:54.408 --> 00:32:57.277 align:middle
让视图根据该优先权剪裁其内容

00:32:57.978 --> 00:33:01.315 align:middle
所以 现在我们的堆叠视图
可以被调整到小于它的容器

00:32:57.978 --> 00:33:01.315 align:middle
所以 现在我们的堆叠视图
可以被调整到小于它的容器

00:33:03.584 --> 00:33:05.686 align:middle
通常您并不希望对视图
进行这种部分剪裁

00:33:05.752 --> 00:33:08.188 align:middle
但这比视图被完全丢弃
的情况要好

00:33:08.922 --> 00:33:12.326 align:middle
您可以通过为不同视图
设置可见性优先权进行控制

00:33:13.060 --> 00:33:14.895 align:middle
一旦堆叠视图开始剪裁其中的视图

00:33:14.962 --> 00:33:18.131 align:middle
有最低可见性优先权的视图
将被完全丢弃

00:33:19.032 --> 00:33:21.001 align:middle
在本例中
我们将设置由高到低的顺序

00:33:21.068 --> 00:33:23.170 align:middle
以便随着堆叠视图
开始剪裁某一视图

00:33:23.237 --> 00:33:25.706 align:middle
它只是暂时性的完全脱离

00:33:26.406 --> 00:33:29.343 align:middle
因此在本例中
第6个不再看得见了

00:33:31.011 --> 00:33:32.646 align:middle
如果堆叠视图再次增大

00:33:32.713 --> 00:33:35.582 align:middle
它将重新附加这些项目
因为有了足够的尺寸容纳它们

00:33:36.383 --> 00:33:37.985 align:middle
此外 当这种脱离或重新附加发生时

00:33:38.318 --> 00:33:40.621 align:middle
您会获得回调
告诉您脱离或重新附加何时发生

00:33:40.687 --> 00:33:43.123 align:middle
以便于您对您的UI的其他部分
做出可能的调整

00:33:43.190 --> 00:33:45.225 align:middle
比如增加一个溢出菜单

00:33:46.960 --> 00:33:48.929 align:middle
接下来我想快速地概述一下

00:33:48.996 --> 00:33:50.631 align:middle
最新更新过的集合视图

00:33:50.731 --> 00:33:53.567 align:middle
现在它与 UI 集合视图
有等同的特色

00:33:54.268 --> 00:33:55.802 align:middle
包括项目的可重用性

00:33:55.869 --> 00:33:57.971 align:middle
因此 对那些本部分支持的项目
的大型集合

00:33:58.038 --> 00:34:00.340 align:middle
您可以有真正可扩展的呈现方式

00:33:58.038 --> 00:34:00.340 align:middle
您可以有真正可扩展的呈现方式

00:34:01.241 --> 00:34:03.243 align:middle
此外 有一些真正强大的布局支持

00:34:03.310 --> 00:34:06.580 align:middle
所以不管您的集合视图的尺寸多大
它的行为都是极其良好的

00:34:06.647 --> 00:34:08.447 align:middle
包括内置的网格布局

00:34:08.849 --> 00:34:11.851 align:middle
与 iOS 匹配的流程布局

00:34:11.918 --> 00:34:13.554 align:middle
以及创建您自己的
定制化布局的能力

00:34:13.820 --> 00:34:15.856 align:middle
Troy 将在今天稍晚时
就此做一个很棒的讲座

00:34:15.922 --> 00:34:17.324 align:middle
名为《集合视图中的新特性》

00:34:17.391 --> 00:34:18.824 align:middle
我真心建议您看一下

00:34:20.594 --> 00:34:22.663 align:middle
与此讲座相关联的还有示例代码

00:34:23.931 --> 00:34:25.199 align:middle
它是一个图片浏览app

00:34:25.666 --> 00:34:29.136 align:middle
展示Corbin和我谈到的
各种特性 API 以及行为

00:34:30.070 --> 00:34:32.239 align:middle
例如 它展示各种全屏 API

00:34:32.306 --> 00:34:33.974 align:middle
尤其是最新的平铺 API

00:34:34.308 --> 00:34:35.509 align:middle
我们这个单独的小窗口

00:34:35.576 --> 00:34:38.011 align:middle
通常被要求
尺寸符合宽高比

00:34:38.245 --> 00:34:39.379 align:middle
而且可被全屏化

00:34:39.813 --> 00:34:41.415 align:middle
然而 我们让它可被平铺

00:34:41.614 --> 00:34:43.684 align:middle
且一旦处于平铺状态
便会有自定义布局

00:34:45.052 --> 00:34:46.987 align:middle
它还采用了最新的
split view 控制器特性

00:34:47.054 --> 00:34:49.755 align:middle
比如带有覆盖效果的
自动折叠侧边栏

00:34:50.791 --> 00:34:52.192 align:middle
以及 NSStackView

00:34:52.359 --> 00:34:55.362 align:middle
它使用零约束条件
创建了这个底部工具栏

00:34:55.696 --> 00:34:56.730 align:middle
的的确确是很棒的

00:34:57.497 --> 00:34:59.066 align:middle
它还使用脱离行为

00:34:59.366 --> 00:35:01.702 align:middle
以便能够让菜单调整到更小

00:34:59.366 --> 00:35:01.702 align:middle
以便能够让菜单调整到更小

00:35:02.102 --> 00:35:03.504 align:middle
并显示这个小巧的溢出菜单

00:35:03.570 --> 00:35:05.539 align:middle
以便用户仍能使用
那些被隐藏的菜单项目

00:35:07.307 --> 00:35:10.077 align:middle
它还使用经过更新的
NSCollectionView

00:35:10.244 --> 00:35:13.413 align:middle
用于显示这个小图片网格
它的表现非常可靠

00:35:16.717 --> 00:35:19.987 align:middle
那么 Corbin 带我们概览了
Full Screen 的各种特性

00:35:20.187 --> 00:35:22.656 align:middle
比如如何在我们的应用中采用全屏

00:35:22.956 --> 00:35:24.625 align:middle
以及使用标题栏辅助视图

00:35:24.892 --> 00:35:28.395 align:middle
让那些在工具栏下方的标题栏
在全屏幕状态下有真正不错的表现

00:35:29.363 --> 00:35:31.865 align:middle
此外 他还向我们展示了
一些全屏幕平铺 API

00:35:32.165 --> 00:35:33.333 align:middle
以便让我们能够确保

00:35:33.567 --> 00:35:36.170 align:middle
我们在特定情况下的窗口
是否在全屏状态下表现正常

00:35:37.538 --> 00:35:40.974 align:middle
最后是一些确保我们的布局
真正具有灵活性的方法

00:35:41.041 --> 00:35:42.676 align:middle
尤其是在这种狭窄环境下

00:35:43.343 --> 00:35:46.013 align:middle
比如将新的标题栏
与Split View控制器

00:35:46.713 --> 00:35:48.115 align:middle
自动布局和NSStackView配

00:35:48.182 --> 00:35:50.584 align:middle
合使用以在您的UI的其他部分
构建灵活性

00:35:51.251 --> 00:35:54.621 align:middle
而NSCollectionView
有真正很棒的对布局的支持

00:35:55.856 --> 00:35:58.058 align:middle
若您有任何问题
您可以联系 Paul Marcos

00:35:58.125 --> 00:35:59.293 align:middle
他乐于接收电子邮件

00:36:00.727 --> 00:36:03.230 align:middle
此外我们还有一些相关的讲座环节
我早些时候也提到了

00:36:03.297 --> 00:36:05.832 align:middle
现在它们已经都讲完了
但是您可以在视频上观看它们

00:36:06.567 --> 00:36:08.468 align:middle
此外 我们今天晚些时候
还有一些实验室活动

00:36:08.535 --> 00:36:11.038 align:middle
有的正在进行中
有的将在今天稍晚和明天进行

00:36:11.438 --> 00:36:12.773 align:middle
如果您有任何问题
敬请提出

00:36:13.540 --> 00:36:15.742 align:middle
祝您在WWDC上有美妙体验
敬请欢享盛会！

00:36:16.009 --> 00:36:16.844 align:middle
回头见！
