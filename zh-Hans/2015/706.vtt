WEBVTT

00:00:20.187 --> 00:00:21.154 align:middle
Apps的安全

00:00:21.488 --> 00:00:22.990 align:middle
你们好 谢谢

00:00:26.360 --> 00:00:29.663 align:middle
我是伊凡是Apple公司安全
及隐私策略小组的负责人

00:00:31.098 --> 00:00:32.566 align:middle
今天我们来谈一谈安全

00:00:33.834 --> 00:00:38.639 align:middle
事实上今天将主要谈的是设备安全

00:00:39.439 --> 00:00:43.143 align:middle
现在你们也知道我们
设备的安全性能非常高

00:00:43.310 --> 00:00:47.347 align:middle
有些安全性能是OSX
或IOS所特有的是两个平台兼有的

00:00:48.215 --> 00:00:50.450 align:middle
我们将继续开发这些性能

00:00:50.651 --> 00:00:54.054 align:middle
你们也将看到我们在
这领域会不断地创新

00:00:54.721 --> 00:00:58.492 align:middle
今天我会抽些时间和
你们简单谈谈网络安全

00:01:00.561 --> 00:01:02.696 align:middle
一谈到网络安全你们大部分人都会想到

00:01:02.763 --> 00:01:06.834 align:middle
HTTPS我们多数也是在浏览器的
锁定图标中见过它

00:01:08.502 --> 00:01:13.140 align:middle
在过去网站会使用HTTPS和TLS

00:01:13.207 --> 00:01:15.475 align:middle
来传输一些敏感信息

00:01:17.144 --> 00:01:20.981 align:middle
在我们看来信用卡信息
已算不上敏感信息

00:01:21.782 --> 00:01:25.152 align:middle
所有的用户信息才是真正的敏感信息

00:01:25.219 --> 00:01:29.489 align:middle
而作为开发者认为不敏感的
信息在用户看来可能就是敏感信息

00:01:31.692 --> 00:01:34.595 align:middle
TLS真正重要的一点
也是我们通常想不到的

00:01:34.661 --> 00:01:39.066 align:middle
就是它不仅会保护网络运行的信息安全

00:01:39.666 --> 00:01:42.069 align:middle
而且还保护连接的完整性

00:01:42.769 --> 00:01:44.905 align:middle
网络面临的威胁已经变了

00:01:45.873 --> 00:01:48.842 align:middle
已不再是戴着黑色面罩躲藏

00:01:48.909 --> 00:01:51.345 align:middle
在网络的某些角落
去窃取你信用卡数字那些人

00:01:52.012 --> 00:01:55.182 align:middle
事实上 用户是想保护自己免受
其他威胁攻击

00:01:55.616 --> 00:01:58.151 align:middle
例如 网络服务供应商

00:01:58.218 --> 00:02:00.821 align:middle
他们向每个应用中插入跟踪标头信息

00:01:58.218 --> 00:02:00.821 align:middle
他们向每个应用中插入跟踪标头信息

00:02:01.188 --> 00:02:04.558 align:middle
或直接记录浏览历史
以进行广告定向投放

00:02:06.260 --> 00:02:11.865 align:middle
所以 我们认为TLS在2015年的
最主要职责就是保护消费者

00:02:12.232 --> 00:02:13.066 align:middle
网络信息安全

00:02:15.836 --> 00:02:17.771 align:middle
但是TLS仍有漏洞

00:02:18.539 --> 00:02:20.941 align:middle
很多服务器仍使用TLS 1版本

00:02:21.241 --> 00:02:23.010 align:middle
这个版本太老了已有16年的历史了

00:02:23.377 --> 00:02:26.747 align:middle
连最新版本TLS 1.2
也已经有7年的历史了

00:02:27.080 --> 00:02:31.785 align:middle
TLS 1.2包含了很多重要的
协议加密升级功能能够抵抗我们

00:02:31.852 --> 00:02:35.322 align:middle
正面临或未来要面临的各种威胁

00:02:36.523 --> 00:02:40.027 align:middle
事实上 连TLS1.2版本也有漏洞

00:02:41.562 --> 00:02:43.664 align:middle
根据TLS的运作方式如果黑客

00:02:43.730 --> 00:02:46.200 align:middle
黑掉一个服务器并窃取你的TLS密钥

00:02:46.633 --> 00:02:51.939 align:middle
那么他们就可以破解服务
器曾经加载过的加密数据

00:02:52.439 --> 00:02:53.907 align:middle
毫无疑问这是非常恐怖的

00:02:54.474 --> 00:02:57.411 align:middle
不过有个正向加密的
软件可解决这一问题

00:02:57.511 --> 00:02:59.813 align:middle
有了正向加密即使黑客黑掉一个

00:02:59.880 --> 00:03:03.083 align:middle
服务器窃取了TLS密钥
他们也只能用密钥

00:02:59.880 --> 00:03:03.083 align:middle
服务器窃取了TLS密钥
他们也只能用密钥

00:03:03.150 --> 00:03:04.985 align:middle
破解服务器未来加密传输的数据

00:03:05.152 --> 00:03:07.554 align:middle
不能破解已加密的历史数据

00:03:08.555 --> 00:03:10.824 align:middle
这样非常棒 因为它能减少庞大的网络

00:03:10.891 --> 00:03:11.992 align:middle
加密数据负荷

00:03:13.861 --> 00:03:17.197 align:middle
TLS支持正向加密正向加密过程通过

00:03:17.264 --> 00:03:19.433 align:middle
使用密码组完成而密码组是由启动

00:03:19.499 --> 00:03:22.736 align:middle
服务器所必须的加密基元组合而成

00:03:23.370 --> 00:03:26.773 align:middle
所以 你们的服务器无需运行TLS
只需运行TLS 1.2

00:03:26.840 --> 00:03:31.078 align:middle
为了获得正向加密
你们必须对其进行设置

00:03:32.479 --> 00:03:36.083 align:middle
我为什么告诉你这些呢
引用蒂姆的话我会让你们读一下

00:03:42.789 --> 00:03:44.558 align:middle
我们必须修正这问题

00:03:46.159 --> 00:03:47.594 align:middle
为了帮助你们不出问题

00:03:48.595 --> 00:03:51.265 align:middle
我们将向你们介绍App
Transport Security

00:03:51.832 --> 00:03:52.666 align:middle
它是这样运行的

00:03:53.800 --> 00:03:58.405 align:middle
在OSX EI Capitan
或ISO9打开你们的应用

00:03:59.540 --> 00:04:03.010 align:middle
默认它这样就不会连接到
不受保护的HTTP链接

00:03:59.540 --> 00:04:03.010 align:middle
默认它这样就不会连接到
不受保护的HTTP链接

00:04:03.076 --> 00:04:05.846 align:middle
它们会连接失败
而且程序生成的任何TLS连接

00:04:05.913 --> 00:04:10.184 align:middle
也不会按照我刚才描述的最优做法

00:04:10.450 --> 00:04:12.452 align:middle
这就是带有正向加密的TLS 1.2

00:04:13.020 --> 00:04:16.190 align:middle
任何已知的不安全加
密基元均无法被允许

00:04:16.490 --> 00:04:18.825 align:middle
密钥尺寸也有最低要求

00:04:19.526 --> 00:04:21.695 align:middle
现在你可能不会完全按照这些要求去做

00:04:21.762 --> 00:04:25.132 align:middle
立即遵守这些要求不过没关系

00:04:25.199 --> 00:04:27.367 align:middle
你可以在
Info plist中根据每种情况

00:04:27.434 --> 00:04:31.872 align:middle
指定例外情况或进行全局覆盖

00:04:32.472 --> 00:04:35.742 align:middle
但是就整个行业而言我们必须尽快做到

00:04:35.809 --> 00:04:38.378 align:middle
让用户信息无法接触到未加密网络

00:04:39.479 --> 00:04:40.380 align:middle
我们需要你们的帮助

00:04:41.682 --> 00:04:43.717 align:middle
谢谢大家下面由我的
同事皮埃尔给你们谈谈

00:04:43.784 --> 00:04:46.486 align:middle
System Integration
Protection

00:04:51.491 --> 00:04:52.326 align:middle
谢谢伊凡

00:04:54.795 --> 00:04:57.464 align:middle
嗨 大家好 我是
皮埃尔•奥利佛•马特尔

00:04:57.798 --> 00:05:01.101 align:middle
担任Apple公司
沙盒技术部的技术经理

00:04:57.798 --> 00:05:01.101 align:middle
担任Apple公司
沙盒技术部的技术经理

00:05:02.402 --> 00:05:05.239 align:middle
今天我和大家谈谈 System
Integration Protection

00:05:05.405 --> 00:05:07.140 align:middle
这是我们在
El Capitan引进的

00:05:07.207 --> 00:05:08.942 align:middle
新型硬化机理

00:05:10.344 --> 00:05:14.114 align:middle
在探究细节之前我想退一步

00:05:14.548 --> 00:05:16.650 align:middle
给大家说说我们要达成什么目标

00:05:17.918 --> 00:05:23.123 align:middle
在Apple公司 我们团队的使命
是确保用户能享受到

00:05:23.190 --> 00:05:25.726 align:middle
产品带来的极致体验我们相信

00:05:25.792 --> 00:05:27.995 align:middle
我们可以保护他们的

00:05:28.061 --> 00:05:32.366 align:middle
个人资料即使资料被

00:05:32.666 --> 00:05:35.602 align:middle
恶意软件甚至更糟糕的

00:05:36.103 --> 00:05:39.206 align:middle
编写软件攻击伤害也会很小

00:05:40.807 --> 00:05:44.244 align:middle
为了达到这个目的我们已设计和集成

00:05:44.378 --> 00:05:47.514 align:middle
各项安全技术正如伊凡上面所提到的

00:05:47.981 --> 00:05:50.217 align:middle
这些年研发的iOS和 OS X

00:05:50.884 --> 00:05:52.553 align:middle
研发所采用的一种

00:05:52.619 --> 00:05:56.456 align:middle
配额和原则就是深度防御概念

00:05:57.724 --> 00:06:00.027 align:middle
使用的关键原则你可能也

00:05:57.724 --> 00:06:00.027 align:middle
使用的关键原则你可能也

00:06:00.093 --> 00:06:03.197 align:middle
有所耳闻 那就是安全与层有关

00:06:04.231 --> 00:06:06.900 align:middle
你不能把所有鸡蛋都
放在同一个篮子里

00:06:06.967 --> 00:06:10.571 align:middle
不要指望单层保护设备就完事大吉了

00:06:10.871 --> 00:06:13.006 align:middle
因为不管这个保护层

00:06:13.774 --> 00:06:18.111 align:middle
防弹性 防水性 抗震性有多好

00:06:18.178 --> 00:06:21.648 align:middle
一旦坏掉就

00:06:22.382 --> 00:06:23.984 align:middle
功亏一篑

00:06:25.652 --> 00:06:28.755 align:middle
相反 你们应该依靠多层保护

00:06:29.456 --> 00:06:32.793 align:middle
原则上有了多层安全保护

00:06:33.293 --> 00:06:35.562 align:middle
不仅能推迟黑客入侵时间

00:06:36.096 --> 00:06:37.564 align:middle
还能限制被攻击范围

00:06:39.132 --> 00:06:41.235 align:middle
到现在为止 深度预防

00:06:41.301 --> 00:06:43.637 align:middle
这个古老的军事概念被用来捍卫世界

00:06:43.937 --> 00:06:47.140 align:middle
各地城池已有几百年历史了

00:06:48.642 --> 00:06:49.977 align:middle
我知道你们很喜欢琐事

00:06:50.344 --> 00:06:52.613 align:middle
所以 我可以告诉你们这个概念是

00:06:52.679 --> 00:06:57.417 align:middle
塞巴斯蒂安•德•沃邦
在17世纪70年代正式提出的

00:06:57.484 --> 00:06:59.052 align:middle
那时 他受法国国王邀请

00:06:59.486 --> 00:07:01.555 align:middle
在全国建造堡垒

00:06:59.486 --> 00:07:01.555 align:middle
在全国建造堡垒

00:07:02.155 --> 00:07:04.758 align:middle
以保卫王国安全

00:07:05.692 --> 00:07:08.061 align:middle
你们可能不熟悉这个人

00:07:08.128 --> 00:07:10.130 align:middle
但你们肯定见过他的作品

00:07:11.298 --> 00:07:12.699 align:middle
这就是他其中的一个城堡设计图

00:07:14.034 --> 00:07:15.969 align:middle
你们可以清楚地看到这几个保护层是

00:07:16.036 --> 00:07:17.971 align:middle
用来抵挡不同的袭击

00:07:19.673 --> 00:07:22.075 align:middle
它们可以拖住入侵者然后通过

00:07:22.309 --> 00:07:26.914 align:middle
易守难攻的窄道把入侵者抵挡在外面

00:07:28.649 --> 00:07:31.685 align:middle
我们来看看如何
把这个原理用到OS X的安全模型上

00:07:32.519 --> 00:07:34.922 align:middle
我不知道你们是不是这样
反正我是经常梦想着

00:07:34.988 --> 00:07:36.523 align:middle
建造自己的堡垒就是这样

00:07:37.824 --> 00:07:40.561 align:middle
我们在这之上设置自己的安全层

00:07:42.062 --> 00:07:44.565 align:middle
我们从底部的网闸开始

00:07:45.732 --> 00:07:49.369 align:middle
网闸要确保从网上下载到

00:07:49.436 --> 00:07:54.041 align:middle
用户设备上的应用是经开发者签字的

00:07:54.341 --> 00:07:58.412 align:middle
开发者拥有Apple公司发布的
开发者身份证明

00:07:59.513 --> 00:08:02.583 align:middle
否则程序将无法运行

00:07:59.513 --> 00:08:02.583 align:middle
否则程序将无法运行

00:08:03.884 --> 00:08:06.019 align:middle
网闸要配合系统的其他机制运行

00:08:06.086 --> 00:08:08.856 align:middle
如恶意软件检测机制

00:08:09.323 --> 00:08:11.592 align:middle
这样才能有效

00:08:12.459 --> 00:08:16.096 align:middle
防止恶意软件大规模地
入侵我们生态系统

00:08:18.131 --> 00:08:19.433 align:middle
第二层是沙盒

00:08:20.801 --> 00:08:23.537 align:middle
回到Lion 我们引入了App沙盒

00:08:23.971 --> 00:08:27.207 align:middle
我们强制性规定所有从App Store
下载的应用都要使用App沙盒

00:08:28.909 --> 00:08:32.145 align:middle
对于从App Store
以外下载的应用

00:08:32.212 --> 00:08:35.082 align:middle
比如开发者ID程序
也强推荐使用App沙盒

00:08:36.482 --> 00:08:38.485 align:middle
沙盒是一种控制机制

00:08:39.253 --> 00:08:42.289 align:middle
它能确保即使你们的程序被入侵了

00:08:43.090 --> 00:08:47.160 align:middle
攻击者也只能访问用户提供的资料

00:08:47.794 --> 00:08:50.731 align:middle
而不能窃取用户资料

00:08:51.498 --> 00:08:53.767 align:middle
也不能破坏其他系统

00:08:56.270 --> 00:08:59.640 align:middle
如果你们成功绕开前两层
那么就来到了第三层

00:09:00.307 --> 00:09:02.442 align:middle
经典的POSIX权限方案

00:09:03.210 --> 00:09:05.679 align:middle
在这里 你们的应用

00:09:05.746 --> 00:09:09.216 align:middle
只能在系统授予用户的权限下运行

00:09:10.083 --> 00:09:13.387 align:middle
所以它既不能访问不同用户资料

00:09:14.154 --> 00:09:19.693 align:middle
也不能修改root用户
对系统进行的配置设置

00:09:21.528 --> 00:09:25.365 align:middle
最后 我们把Keychain
看成第三层上面的一层

00:09:25.432 --> 00:09:28.836 align:middle
它是用来保护用户密钥的

00:09:30.504 --> 00:09:33.674 align:middle
它通过加密和应用分离

00:09:34.274 --> 00:09:37.377 align:middle
确保只有在第一层存储秘密的应用

00:09:37.811 --> 00:09:40.747 align:middle
才可以返回此层

00:09:42.983 --> 00:09:44.351 align:middle
所以当你们看到整个方案后

00:09:45.052 --> 00:09:46.486 align:middle
你们会明白很多事情

00:09:47.588 --> 00:09:54.428 align:middle
首先 网闸阻止下载到
机器上的不信任代码

00:09:55.329 --> 00:09:58.165 align:middle
但是它还不是真正的控制机制

00:09:58.532 --> 00:10:01.502 align:middle
因为启动网闸不会阻止任何应用运行

00:09:58.532 --> 00:10:01.502 align:middle
因为启动网闸不会阻止任何应用运行

00:10:02.269 --> 00:10:05.472 align:middle
而且它也不会保护机器已有代码

00:10:05.539 --> 00:10:08.308 align:middle
例如它不会保护OS自带的代码

00:10:10.244 --> 00:10:13.914 align:middle
所以 虽然它可能是

00:10:14.214 --> 00:10:16.149 align:middle
我们平台最有效的控制机制

00:10:17.251 --> 00:10:19.186 align:middle
但沙盒机制是OS X的唯一选择

00:10:19.853 --> 00:10:22.656 align:middle
我们没有要求规定每个过程都

00:10:22.956 --> 00:10:24.525 align:middle
必须在沙盒中运行

00:10:26.593 --> 00:10:30.364 align:middle
最后当你们看到POSIX层时

00:10:31.532 --> 00:10:36.470 align:middle
会发现大部分的Mac系统
都是单用户系统

00:10:37.070 --> 00:10:40.440 align:middle
而系统的用户实际上是临时管理员

00:10:40.507 --> 00:10:42.109 align:middle
一直在行使管理特权

00:10:44.845 --> 00:10:46.914 align:middle
root账户通常要么处于保护状态

00:10:46.980 --> 00:10:50.450 align:middle
要么保护密码较弱甚至没有密码

00:10:51.852 --> 00:10:55.289 align:middle
事实上如果真的有
密码而且你想要的话

00:10:55.522 --> 00:10:56.957 align:middle
用户也可能会给你

00:10:59.860 --> 00:11:03.530 align:middle
而且 当你最后root之后
实际上已经能控制

00:10:59.860 --> 00:11:03.530 align:middle
而且 当你最后root之后
实际上已经能控制

00:11:03.997 --> 00:11:07.000 align:middle
整个机器 因为root文件可以禁用
设备上所有的安全措施

00:11:07.701 --> 00:11:10.971 align:middle
它能替换内核扩展

00:11:11.471 --> 00:11:15.275 align:middle
替代提供其他安全服务

00:11:15.809 --> 00:11:18.545 align:middle
甚至可以扰乱运行中的
Keychain层

00:11:20.681 --> 00:11:24.051 align:middle
所以 事实就是一旦代码在Mac运行

00:11:24.551 --> 00:11:26.720 align:middle
那么很容易进行root

00:11:27.187 --> 00:11:29.056 align:middle
一旦root成功
你就可以完全控制机器

00:11:29.590 --> 00:11:30.457 align:middle
也就是说

00:11:31.358 --> 00:11:33.794 align:middle
任何一段恶意代码实际上就是一个密码

00:11:34.127 --> 00:11:35.562 align:middle
或一个可以完全

00:11:35.929 --> 00:11:37.664 align:middle
控制你机器的漏洞

00:11:40.033 --> 00:11:44.338 align:middle
这表明我们还需要另一个层

00:11:45.405 --> 00:11:49.209 align:middle
一个能消除机器root权限的层

00:11:50.110 --> 00:11:52.045 align:middle
从而在默认情况下保护系统

00:11:52.145 --> 00:11:54.515 align:middle
好像是Apple安装到机器上的一样

00:11:55.349 --> 00:11:57.017 align:middle
硬盘和runtime都进行安装

00:11:58.852 --> 00:12:02.589 align:middle
因为我们现在正讨论限制root权限

00:11:58.852 --> 00:12:02.589 align:middle
因为我们现在正讨论限制root权限

00:12:03.323 --> 00:12:06.860 align:middle
所以我们需要提供一套配置机制

00:12:07.327 --> 00:12:09.897 align:middle
防止root被入侵

00:12:10.831 --> 00:12:13.500 align:middle
而且还能重设root权限

00:12:15.602 --> 00:12:18.438 align:middle
这就是System
Integration Protection

00:12:18.872 --> 00:12:20.440 align:middle
这是一个新的安全策略

00:12:20.908 --> 00:12:24.011 align:middle
适用于系统中的每个进程

00:12:24.645 --> 00:12:26.680 align:middle
不管这个进程是否

00:12:26.947 --> 00:12:29.716 align:middle
具备附加特权或者在沙箱外运行

00:12:31.785 --> 00:12:33.887 align:middle
该策略能为磁盘或runtime中的

00:12:34.221 --> 00:12:37.925 align:middle
系统组件提供额外保护

00:12:39.126 --> 00:12:43.096 align:middle
而且系统如果安装
Apple签字安装包

00:12:43.163 --> 00:12:46.900 align:middle
二进制只能被安装程序

00:12:48.101 --> 00:12:50.003 align:middle
或者软件更新机制修改

00:12:50.704 --> 00:12:54.308 align:middle
这样系统二进制文件就能免受

00:12:54.374 --> 00:12:58.412 align:middle
runtime附件和代码注入的风险

00:12:59.980 --> 00:13:01.715 align:middle
在探究细节之前

00:12:59.980 --> 00:13:01.715 align:middle
在探究细节之前

00:13:01.982 --> 00:13:05.285 align:middle
我们先看一下这是如何影响开发者的

00:13:06.420 --> 00:13:09.456 align:middle
好消息是如果你的应用

00:13:09.523 --> 00:13:12.726 align:middle
是App Store下载的
那么应用就不会受到此类风险

00:13:13.694 --> 00:13:16.496 align:middle
<br/>
因为App Store指南

00:13:16.630 --> 00:13:18.632 align:middle
和沙箱策略可以加以保护

00:13:18.799 --> 00:13:20.534 align:middle
阻止此类行为

00:13:21.502 --> 00:13:23.604 align:middle
然而 如果你们的应用
不是来自App Store

00:13:24.338 --> 00:13:26.607 align:middle
而且需要修改系统的二进制文件

00:13:27.140 --> 00:13:32.880 align:middle
或修改磁盘框架
如果需要将储存信息安装到系统位置

00:13:34.414 --> 00:13:36.283 align:middle
那么应用就会受到影响

00:13:36.683 --> 00:13:39.019 align:middle
我将在这里解释一下

00:13:39.753 --> 00:13:41.755 align:middle
什么是系统位置

00:13:43.023 --> 00:13:46.894 align:middle
最后如果你们的
应用需要检查系统进程中

00:13:46.960 --> 00:13:49.897 align:middle
任一进程的的内存状态

00:13:50.898 --> 00:13:56.537 align:middle
或需要在系统运行的进程中或跨进程

00:13:56.703 --> 00:13:57.704 align:middle
插入库或进行调试

00:13:59.773 --> 00:14:02.576 align:middle
那么让我们看看新机制的核心

00:13:59.773 --> 00:14:02.576 align:middle
那么让我们看看新机制的核心

00:14:03.076 --> 00:14:05.679 align:middle
首先我会了解下新文件系统限制

00:14:05.946 --> 00:14:08.582 align:middle
我们在Capitan系统
引入该文件系统

00:14:09.550 --> 00:14:11.018 align:middle
然后再看一下它是如何扩展到

00:14:11.318 --> 00:14:13.420 align:middle
新runtime保护进程

00:14:15.022 --> 00:14:17.090 align:middle
最后了解一下该系统与

00:14:17.157 --> 00:14:20.060 align:middle
内核扩展开发流程的关系

00:14:20.127 --> 00:14:23.530 align:middle
以及它是如何影响kext开发者的

00:14:24.798 --> 00:14:27.334 align:middle
然后由于这个功能
是能够被完全禁用的

00:14:28.001 --> 00:14:29.503 align:middle
接下来向你们展示一下如何禁用

00:14:31.138 --> 00:14:32.539 align:middle
那就得首先讲讲文件系统

00:14:33.974 --> 00:14:39.880 align:middle
我们想做到的就是
保护系统存储信息不被修改

00:14:41.281 --> 00:14:45.986 align:middle
为达到这一目的
安装程序会标在文件安装过程中

00:14:46.520 --> 00:14:47.855 align:middle
标记系统内容

00:14:48.655 --> 00:14:51.291 align:middle
我们在Capitan系统中加入了
新的文件系统标记

00:14:52.359 --> 00:14:56.530 align:middle
之后在运行过程中内核能阻止任何

00:14:56.830 --> 00:14:58.932 align:middle
企图篡改受保护文件

00:14:58.999 --> 00:15:01.969 align:middle
或文件夹的行为除非该行为是

00:14:58.999 --> 00:15:01.969 align:middle
或文件夹的行为除非该行为是

00:15:02.035 --> 00:15:05.272 align:middle
特别授权的进程发出的

00:15:05.806 --> 00:15:07.908 align:middle
Capitan系统只有几种此类进程

00:15:09.243 --> 00:15:13.881 align:middle
内核还会防止
储存私密内容的块设备被读写

00:15:15.215 --> 00:15:16.783 align:middle
而且还会阻止

00:15:16.950 --> 00:15:18.252 align:middle
私密内容被篡改

00:15:20.187 --> 00:15:22.122 align:middle
现在 必须记住一点是

00:15:22.422 --> 00:15:25.158 align:middle
这只适用于root文件和

00:15:25.592 --> 00:15:26.727 align:middle
当前运行OS的启动卷

00:15:27.995 --> 00:15:30.731 align:middle
所以你应该把它看成系统运行时的

00:15:31.031 --> 00:15:33.066 align:middle
一种自我保护机制

00:15:36.270 --> 00:15:39.206 align:middle
因为我们现在要
保护磁盘上的系统存储信息

00:15:39.273 --> 00:15:41.308 align:middle
所以你们必须明确区分

00:15:41.375 --> 00:15:43.510 align:middle
系统内容和第三方内容

00:15:44.912 --> 00:15:48.849 align:middle
在Capitan 这张图标左侧

00:15:48.916 --> 00:15:51.885 align:middle
所有位置都被默认为系统位置

00:15:52.853 --> 00:15:55.189 align:middle
这意味着系统会阻止你在那里进行读写

00:15:55.923 --> 00:15:57.824 align:middle
即使是安装程序包下载的也一样

00:15:59.493 --> 00:16:01.728 align:middle
因为多年来我们一直建议你们

00:15:59.493 --> 00:16:01.728 align:middle
因为多年来我们一直建议你们

00:16:02.062 --> 00:16:03.697 align:middle
不要读写到这些位置

00:16:03.964 --> 00:16:05.499 align:middle
所以你们当中受影响的人应该不多

00:16:05.732 --> 00:16:08.535 align:middle
如果你们的安装包把存储信息放到这里

00:16:08.602 --> 00:16:10.671 align:middle
Capitan应该不会出现大的故障

00:16:11.471 --> 00:16:13.674 align:middle
如果你想把所有的软件都
安装在/System路径下

00:16:14.007 --> 00:16:17.010 align:middle
那么你需要将此存储信息移到
subfolder of /Library下

00:16:17.077 --> 00:16:20.681 align:middle
如果是系统内的
存储信息或(tilde)/Library

00:16:21.248 --> 00:16:24.318 align:middle
如果是用户存储信息

00:16:26.119 --> 00:16:29.156 align:middle
或者如果你想把软件都安装到
/bin或者/sbin

00:16:29.923 --> 00:16:32.125 align:middle
或者/usr目录下

00:16:32.192 --> 00:16:35.395 align:middle
比如/usr/bin, /usr/lib
或者usr/libexec

00:16:35.996 --> 00:16:39.266 align:middle
那么你要把储存信息移到

00:16:39.600 --> 00:16:44.271 align:middle
/usr/文件夹下的
适当位置 因为这里是

00:16:44.338 --> 00:16:45.939 align:middle
第三方唯一可访问的路径

00:16:47.574 --> 00:16:48.709 align:middle
然后需要注意的是

00:16:49.676 --> 00:16:52.513 align:middle
最佳的存储信息位置仍是
/Applications路径

00:16:52.646 --> 00:16:55.549 align:middle
这是因为这个位置是用户可见位置

00:16:56.149 --> 00:16:58.752 align:middle
方便用户把应用拖入

00:16:58.819 --> 00:17:00.454 align:middle
垃圾箱并删除存储信息

00:16:58.819 --> 00:17:00.454 align:middle
垃圾箱并删除存储信息

00:17:01.855 --> 00:17:07.493 align:middle
要注意的是 当用户升级

00:17:07.694 --> 00:17:10.830 align:middle
Yosemite install到
Capitan install时

00:17:11.431 --> 00:17:14.667 align:middle
安装程序会会把系统内

00:17:14.734 --> 00:17:18.505 align:middle
发现的第三方存储信息移到系统外

00:17:19.640 --> 00:17:23.076 align:middle
所以为了不影响这些用户

00:17:23.143 --> 00:17:26.680 align:middle
务必确保把存储内容尽快转移出去

00:17:29.783 --> 00:17:31.618 align:middle
现在我们看一下runtime保护

00:17:33.086 --> 00:17:35.756 align:middle
能够改变runtime中的进程行为

00:17:35.923 --> 00:17:38.959 align:middle
就相当于能够改变

00:17:39.026 --> 00:17:40.827 align:middle
改变磁盘上的二进制文件

00:17:41.495 --> 00:17:43.263 align:middle
如果想保护磁盘上的二进制文件

00:17:43.530 --> 00:17:46.133 align:middle
或系统存储信息我们必须保证

00:17:46.400 --> 00:17:49.536 align:middle
不能插入代码或改变

00:17:49.603 --> 00:17:51.538 align:middle
这些系统进程的行为

00:17:53.006 --> 00:17:56.710 align:middle
为了实现该目的我们在进程结构中

00:17:57.344 --> 00:18:01.815 align:middle
引入一种新的限定标记这种标记的
内核适用于每个单一进程

00:17:57.344 --> 00:18:01.815 align:middle
引入一种新的限定标记这种标记的
内核适用于每个单一进程

00:18:03.050 --> 00:18:06.086 align:middle
如果磁盘上的

00:18:06.854 --> 00:18:09.990 align:middle
主要可执行文件受程序保护

00:18:11.258 --> 00:18:13.193 align:middle
或写入Apple
特别授权的主要可执行文件

00:18:13.260 --> 00:18:14.695 align:middle
那么内核将在准确时刻做出标记

00:18:19.967 --> 00:18:22.536 align:middle
之后系统将自动区别

00:18:22.836 --> 00:18:26.073 align:middle
该受限进程和常规进程

00:18:26.940 --> 00:18:29.476 align:middle
一方面如果task-for-pid

00:18:29.943 --> 00:18:33.747 align:middle
和processor-set-tasks
SPI需要调用受限进程

00:18:34.014 --> 00:18:36.283 align:middle
那么它们将无法运行

00:18:37.251 --> 00:18:39.419 align:middle
并且会设置EPERM为0

00:18:40.621 --> 00:18:44.191 align:middle
这意味着你的产品需要依靠

00:18:44.324 --> 00:18:48.061 align:middle
系统进程才能运行

00:18:48.262 --> 00:18:51.198 align:middle
例如Finder 你需要
向Finder插入代码

00:18:51.265 --> 00:18:53.634 align:middle
否则它再也无法运行了

00:18:56.270 --> 00:19:03.243 align:middle
如果你插入exec
那么二进制文件将导致子进程受限

00:18:56.270 --> 00:19:03.243 align:middle
如果你插入exec
那么二进制文件将导致子进程受限

00:19:04.611 --> 00:19:07.214 align:middle
然后系统将自动重新设置

00:19:07.281 --> 00:19:08.949 align:middle
子进程的mach特殊接口

00:19:09.650 --> 00:19:11.985 align:middle
这样意味着你将

00:19:12.352 --> 00:19:13.587 align:middle
无法控制子进程

00:19:14.421 --> 00:19:18.158 align:middle
如果你插入一个特权工具

00:19:18.592 --> 00:19:20.961 align:middle
然后想要保持控制
那么它也将不能运行

00:19:23.263 --> 00:19:29.469 align:middle
连接器将忽视所有
保护二进制文件的dyld环境变量

00:19:30.270 --> 00:19:33.407 align:middle
所以在执行过程中如果你在进程中

00:19:33.574 --> 00:19:35.509 align:middle
将库插入二进制文件

00:19:36.109 --> 00:19:38.745 align:middle
连接器忽视新库

00:19:40.314 --> 00:19:44.384 align:middle
最终如果使用
dtrace的话所有针对

00:19:44.551 --> 00:19:49.189 align:middle
受限进程的dtrace
探针将无法匹配

00:19:49.890 --> 00:19:53.994 align:middle
这样就无法看到进程和内核的互动过程

00:19:54.962 --> 00:19:58.732 align:middle
你们也将检测不到受限进程存储空间

00:19:58.932 --> 00:20:00.968 align:middle
也就无法检测到内核内存

00:19:58.932 --> 00:20:00.968 align:middle
也就无法检测到内核内存

00:20:02.836 --> 00:20:05.472 align:middle
当然这适用于调试器LLDB

00:20:06.106 --> 00:20:09.576 align:middle
如果你们试图
调用LLDB作为root

00:20:09.643 --> 00:20:12.179 align:middle
并连接到Finder这样也无济于事

00:20:15.282 --> 00:20:17.384 align:middle
现在接下来是kext签字程序

00:20:17.751 --> 00:20:21.321 align:middle
你们肯定也知道所有带
Kexts开发者ID证书的扩展

00:20:21.622 --> 00:20:25.359 align:middle
都是Apple公司发行的

00:20:26.527 --> 00:20:31.098 align:middle
扩展必须安装到
/Library/Extensions路径下

00:20:32.866 --> 00:20:37.638 align:middle
新鲜的是因为我们把
kext签字程序放置在

00:20:38.472 --> 00:20:41.909 align:middle
System Integrity
Protection之下进行保护

00:20:42.576 --> 00:20:45.479 align:middle
所以kext-dev-mode
boot-arg就被淘汰了

00:20:46.446 --> 00:20:49.983 align:middle
如果你是kext开发者你就需要用

00:20:50.083 --> 00:20:52.419 align:middle
未签字的内核扩展进行测试

00:20:52.486 --> 00:20:55.589 align:middle
你需要禁用保护我马上给你们演示一下

00:20:56.523 --> 00:20:59.693 align:middle
这也意味着为了禁用kext签字

00:20:59.760 --> 00:21:02.829 align:middle
你在那里可能也看不到这个注释行

00:20:59.760 --> 00:21:02.829 align:middle
你在那里可能也看不到这个注释行

00:21:03.096 --> 00:21:04.198 align:middle
它已经无法运行了

00:21:08.702 --> 00:21:10.337 align:middle
下面我们来谈一下配置机制

00:21:12.573 --> 00:21:17.110 align:middle
我们坚信这个新机制
对保护对我们的用户至关重要

00:21:18.679 --> 00:21:21.815 align:middle
话虽这么说但我们也意识到

00:21:21.882 --> 00:21:24.418 align:middle
人无法完全操控他们的机器

00:21:25.385 --> 00:21:26.620 align:middle
因为我之前就说过

00:21:26.887 --> 00:21:28.422 align:middle
它保护着磁盘上的内核

00:21:28.922 --> 00:21:31.525 align:middle
需要所有的内核扩展都必须被签字

00:21:32.192 --> 00:21:34.494 align:middle
而且因此kext开发者

00:21:34.561 --> 00:21:36.363 align:middle
也不能如愿以偿地测试未签字kext

00:21:38.031 --> 00:21:40.200 align:middle
正因如此它被完全弃用了

00:21:41.301 --> 00:21:44.771 align:middle
配置存放在NVRAM配置中

00:21:45.272 --> 00:21:48.141 align:middle
这意味着可以适用于整个机器

00:21:48.475 --> 00:21:50.410 align:middle
所以如果你有几个
Capitan安装程序

00:21:50.777 --> 00:21:52.513 align:middle
它们都会有同样的配置

00:21:53.680 --> 00:21:55.516 align:middle
而且OS安装程序也是如此

00:21:55.649 --> 00:21:59.186 align:middle
所以当你从seed 1升级到
seed 2再升级到GM之后

00:21:59.753 --> 00:22:01.321 align:middle
配置也将保持不变

00:21:59.753 --> 00:22:01.321 align:middle
配置也将保持不变

00:22:01.455 --> 00:22:03.257 align:middle
我们安装时不用每次都进行重新配置

00:22:05.359 --> 00:22:08.161 align:middle
现在 因为root实际上
已经设置了NVRAM

00:22:08.262 --> 00:22:10.631 align:middle
在这里我们不能相信root

00:22:11.098 --> 00:22:14.434 align:middle
也就是我们不能在
OS系统上安装配置机制

00:22:15.068 --> 00:22:17.571 align:middle
我们要进行转移
把它安装在Recovery OS下

00:22:18.305 --> 00:22:21.041 align:middle
所以NVRAM也就只能在
Recovery下进行配置设置

00:22:21.775 --> 00:22:23.010 align:middle
如果你想改变配置

00:22:23.777 --> 00:22:26.346 align:middle
你需要在机器的
Recovery OS中进行重启

00:22:26.413 --> 00:22:29.449 align:middle
在引导画面下按Command+R键
进行开机启动

00:22:30.851 --> 00:22:32.586 align:middle
然后在Utilities菜单中

00:22:32.653 --> 00:22:35.155 align:middle
运行安全配置应用

00:22:36.323 --> 00:22:38.926 align:middle
检测System
IntegrityProtection盒

00:22:39.359 --> 00:22:40.694 align:middle
应用 然后重启

00:22:42.029 --> 00:22:44.464 align:middle
记住我刚才描述的那些类型很有可能

00:22:44.531 --> 00:22:46.300 align:middle
在以后的seed版本中会发生变化

00:22:46.433 --> 00:22:51.038 align:middle
所以务必阅读注释了解新的操作步骤

00:22:54.007 --> 00:22:55.809 align:middle
我们总结一下到到目前
为止所谈论的内容

00:22:57.277 --> 00:22:59.980 align:middle
System Integrity
Protection是一种新的策略

00:23:00.047 --> 00:23:01.181 align:middle
适用于系统的每个进程

00:23:02.282 --> 00:23:06.520 align:middle
Apple公司将其安装
在磁盘和runtime上

00:23:06.620 --> 00:23:10.424 align:middle
通过限制读写系统位置访问权限

00:23:10.858 --> 00:23:14.995 align:middle
以及防止runtime
连接和代码插入

00:23:15.963 --> 00:23:18.599 align:middle
从而保护系统

00:23:20.434 --> 00:23:23.203 align:middle
安装程序能有效地把第三方存储内容

00:23:23.337 --> 00:23:25.172 align:middle
转移到系统位置之外

00:23:25.239 --> 00:23:27.474 align:middle
所以要确保尽快转移你的存储内容

00:23:27.908 --> 00:23:30.110 align:middle
否则 就只能自认倒霉了
因为 你会找不到内容

00:23:31.678 --> 00:23:37.918 align:middle
最后可使用Recovery OS
配置机制禁用该功能

00:23:39.720 --> 00:23:41.388 align:middle
这就是我为大家呈现的内容
谢谢大家

00:23:41.655 --> 00:23:42.789 align:middle
下面我把舞台交给安德鲁

00:23:48.996 --> 00:23:49.830 align:middle
谢谢你 皮埃尔

00:23:51.665 --> 00:23:56.970 align:middle
我是安德鲁·惠利在Core OS
安全功能组负责管理数据安全组

00:23:59.139 --> 00:24:01.475 align:middle
你可能听过app传输安全

00:23:59.139 --> 00:24:01.475 align:middle
你可能听过app传输安全

00:24:02.142 --> 00:24:04.611 align:middle
以及app在连接状态下

00:24:05.012 --> 00:24:07.014 align:middle
是它如何保护传输中的数据的

00:24:08.015 --> 00:24:11.718 align:middle
我将会讨论数据安全的不同保护方式

00:24:13.187 --> 00:24:16.190 align:middle
我会点击Keychain
然后存储用户信息

00:24:17.491 --> 00:24:21.795 align:middle
之后看一下Touch ID
看看你是如何权衡

00:24:21.862 --> 00:24:23.463 align:middle
程序安全与程序便捷的

00:24:25.532 --> 00:24:28.702 align:middle
在这个过程中我将体验一下现有的技术

00:24:28.936 --> 00:24:32.940 align:middle
和iOS 9的新功能以及
如何配合使用

00:24:33.407 --> 00:24:36.577 align:middle
从而提供适合你们
app的安全保护等级

00:24:40.080 --> 00:24:42.649 align:middle
我们首先快速
浏览一下Keychain

00:24:43.217 --> 00:24:46.587 align:middle
你可以把它看作是专业的数据库

00:24:47.454 --> 00:24:51.425 align:middle
通过增加行数来储存数据
我们称为Keychain项目

00:24:51.892 --> 00:24:54.761 align:middle
然后通过属性进行查询

00:24:56.597 --> 00:25:01.301 align:middle
为了优化隐私我这里说的隐私包括密码

00:24:56.597 --> 00:25:01.301 align:middle
为了优化隐私我这里说的隐私包括密码

00:25:01.969 --> 00:25:04.771 align:middle
标记 cookie或秘钥

00:25:06.139 --> 00:25:10.511 align:middle
如果你有成千上万兆字节信息要储存

00:25:10.844 --> 00:25:15.549 align:middle
那么可以考虑使用基于文件的
数据保护或者通过API进行

00:25:16.049 --> 00:25:18.318 align:middle
批量加密方法
如Common Crypto

00:25:18.585 --> 00:25:20.287 align:middle
然后将密钥存储在Keychain中

00:25:25.292 --> 00:25:27.961 align:middle
尽管这些SecItem API
已经存在很长时间了

00:25:28.262 --> 00:25:30.631 align:middle
但它仍是最好的秘密存储工具

00:25:30.931 --> 00:25:33.066 align:middle
包括新Swift apps中的密码

00:25:34.468 --> 00:25:37.838 align:middle
这里我们这里有个秘密
想通过SecItemAdd

00:25:37.905 --> 00:25:40.574 align:middle
把它存在Keychain中

00:25:42.209 --> 00:25:44.344 align:middle
为了这么做我们构建了一个字典

00:25:44.711 --> 00:25:46.480 align:middle
这个字典包括秘密信息

00:25:46.947 --> 00:25:51.818 align:middle
还有今后查询所必须的某些属性

00:25:52.286 --> 00:25:53.554 align:middle
和应当采取的保护措施

00:25:56.256 --> 00:25:59.560 align:middle
这种创建包括描述
项目查询方式字典的方式

00:25:59.626 --> 00:26:04.865 align:middle
也可用于查询删除

00:25:59.626 --> 00:26:04.865 align:middle
也可用于查询删除

00:26:05.098 --> 00:26:10.037 align:middle
更新条目和其他API
我后面会谈到这一点

00:26:11.405 --> 00:26:14.074 align:middle
有关Keychain API的信息

00:26:14.141 --> 00:26:17.711 align:middle
2013年的WWDC
的709会议还有很多

00:26:20.314 --> 00:26:25.152 align:middle
所以在编写访问Keychain
代码的时候你们要注意以下几点

00:26:26.987 --> 00:26:30.290 align:middle
首先处理用户隐私信息
是代码安全信息当中

00:26:30.357 --> 00:26:32.326 align:middle
真正敏感的一个环节

00:26:33.093 --> 00:26:37.464 align:middle
所以你们应该把它分成
小而简单又可测试的小单元

00:26:39.499 --> 00:26:42.069 align:middle
通常可以使用
wrapper class

00:26:44.438 --> 00:26:46.573 align:middle
不管是直接使用
还是使用wrapper

00:26:47.107 --> 00:26:49.710 align:middle
请确保你的应用

00:26:50.410 --> 00:26:52.312 align:middle
受到最高级别的保护

00:26:53.680 --> 00:26:56.984 align:middle
我们描述和讨论的数据保护级别

00:26:57.518 --> 00:27:03.790 align:middle
指的是通过加密访问项目的次数

00:26:57.518 --> 00:27:03.790 align:middle
指的是通过加密访问项目的次数

00:27:03.924 --> 00:27:06.360 align:middle
例如当设备在iOS8系统上

00:27:08.562 --> 00:27:12.766 align:middle
被锁定的时候我们添加了
After First Unlock

00:27:14.434 --> 00:27:18.338 align:middle
再说一遍这功能早就有了
当你必须在背景下

00:27:18.572 --> 00:27:20.941 align:middle
访问这些项目时候你就可以使用它

00:27:21.308 --> 00:27:22.876 align:middle
比例你开发的是一款VoIP应用

00:27:27.147 --> 00:27:30.651 align:middle
iOS 9不支持随时访问

00:27:31.051 --> 00:27:34.688 align:middle
所以你们必须着手
把这些项目移到到更高级别位置

00:27:40.527 --> 00:27:44.498 align:middle
我们已开发出WatchKit 2
所以你的Watch app现在可以

00:27:44.565 --> 00:27:48.969 align:middle
访问SecItem API
虽然在Watch上

00:27:49.036 --> 00:27:52.873 align:middle
输入用户全名和密码的
这种用户体验并非是你想要的

00:27:54.408 --> 00:27:58.512 align:middle
如果你的Watch app
显示的是配对iOS设备的数据

00:27:59.079 --> 00:28:01.415 align:middle
那么你只需发送内容

00:27:59.079 --> 00:28:01.415 align:middle
那么你只需发送内容

00:28:01.748 --> 00:28:03.750 align:middle
而无需使用永久证书

00:28:05.586 --> 00:28:07.955 align:middle
如果你的Watch app
确实需要直接访问证书

00:28:08.822 --> 00:28:14.461 align:middle
那么与其保存完整的用户名和密码

00:28:15.162 --> 00:28:18.065 align:middle
不如让服务器发送
一个许可证或cookie

00:28:18.365 --> 00:28:22.503 align:middle
从而获得权限访问

00:28:22.669 --> 00:28:26.139 align:middle
那些Watch app
所需要的主要功能内容

00:28:30.143 --> 00:28:33.447 align:middle
不仅仅在Watch上提示用户名

00:28:33.514 --> 00:28:35.716 align:middle
和密码非常不方便

00:28:36.416 --> 00:28:42.823 align:middle
在过去的几个版本我们引入了几种
技术减少密码提示的频率

00:28:44.791 --> 00:28:47.060 align:middle
第一个就是共享web证书

00:28:48.896 --> 00:28:51.999 align:middle
我们都了解也都喜欢
Safari保存的密码

00:28:52.266 --> 00:28:54.868 align:middle
以及提示和储存密码的方式

00:28:56.370 --> 00:29:00.340 align:middle
有了iCloud Keychain
密码就可以同步 自动保存

00:28:56.370 --> 00:29:00.340 align:middle
有了iCloud Keychain
密码就可以同步 自动保存

00:29:00.407 --> 00:29:01.475 align:middle
到所有设备上

00:29:03.844 --> 00:29:05.179 align:middle
但是 常见的是一个服务器

00:29:05.245 --> 00:29:08.182 align:middle
同时拥有一个
网站和一个iOS app

00:29:08.782 --> 00:29:12.619 align:middle
所以 如果这些程序都能共享

00:29:12.753 --> 00:29:14.354 align:middle
Safari保存密码那就太棒了

00:29:15.122 --> 00:29:17.391 align:middle
有了共享web证书就可以办到

00:29:19.693 --> 00:29:22.262 align:middle
这些是你们在登录

00:29:22.362 --> 00:29:24.698 align:middle
或注册程序要添加的代码

00:29:27.634 --> 00:29:30.204 align:middle
SecCreate Shared
WebCredential Password将

00:29:30.270 --> 00:29:33.473 align:middle
返回一个随机字符串
和Safari保存的密码格式一样

00:29:33.574 --> 00:29:34.942 align:middle
用于提示密码

00:29:36.310 --> 00:29:39.046 align:middle
你们能调用SecAdd
SharedWeb Credential

00:29:39.112 --> 00:29:42.382 align:middle
告知Safari
需要将新用户名和密码

00:29:42.649 --> 00:29:44.651 align:middle
自动输入到特定域中

00:29:47.721 --> 00:29:51.091 align:middle
在iOS 9我们已经实现这个功能

00:29:51.491 --> 00:29:53.427 align:middle
方式是在模拟器上运行时

00:29:53.493 --> 00:29:54.928 align:middle
降低安全检查等级

00:29:56.530 --> 00:29:57.364 align:middle
我们来体验一下

00:29:59.199 --> 00:30:02.803 align:middle
我从注册程序开始

00:29:59.199 --> 00:30:02.803 align:middle
我从注册程序开始

00:30:03.237 --> 00:30:06.306 align:middle
然后添加刚刚展示过的代码

00:30:09.109 --> 00:30:12.012 align:middle
然后进入Safari设置

00:30:12.145 --> 00:30:15.749 align:middle
确保已启用名称和密码自动输入

00:30:17.518 --> 00:30:19.419 align:middle
搜索Safari等待结果

00:30:22.356 --> 00:30:25.325 align:middle
我们回到程序上来

00:30:25.826 --> 00:30:27.561 align:middle
页面上显示用户名称和密码提示

00:30:29.229 --> 00:30:32.833 align:middle
共享网络凭据允许应用

00:30:32.900 --> 00:30:36.537 align:middle
显示一个选择器这个选择器列出了
Safari在这个域中

00:30:36.603 --> 00:30:37.704 align:middle
保存的所有账号

00:30:40.507 --> 00:30:43.010 align:middle
每当用户选择一个账号 用户名

00:30:43.076 --> 00:30:46.446 align:middle
和密码就会根据
Shared Web Credential

00:30:46.580 --> 00:30:52.252 align:middle
返回到已完成处理的
程序中然后就可以登录了

00:30:55.989 --> 00:30:58.091 align:middle
如果你想要在设备上使用这个功能

00:30:58.158 --> 00:31:02.262 align:middle
而不是只在模拟器上使用
你就需要在你的应用上

00:30:58.158 --> 00:31:02.262 align:middle
而不是只在模拟器上使用
你就需要在你的应用上

00:31:03.363 --> 00:31:06.099 align:middle
添加一个授权你可以在
Xcode的权限标签页的

00:31:06.233 --> 00:31:08.202 align:middle
相关域部分中进行该操作

00:31:10.938 --> 00:31:14.274 align:middle
你需要将JSON文件放在服务器中

00:31:14.942 --> 00:31:16.376 align:middle
不过你可能已经有了

00:31:16.710 --> 00:31:19.246 align:middle
毕竟它跟Handoff和
iOS 9应用链接中

00:31:20.747 --> 00:31:24.685 align:middle
所用的是同一个

00:31:30.157 --> 00:31:31.658 align:middle
我们对iOS 9做了一个改变

00:31:31.725 --> 00:31:33.126 align:middle
让适应性更好这个改变是

00:31:33.460 --> 00:31:35.996 align:middle
你不再需要分别签署该文件

00:31:36.530 --> 00:31:39.399 align:middle
它将由安全TLS连接所保护

00:31:45.539 --> 00:31:49.243 align:middle
我提到过Safari通过
iCloud Keychain保存密码

00:31:49.643 --> 00:31:52.045 align:middle
但是你们也可以在
自己的应用中直接使用它

00:31:53.146 --> 00:31:55.282 align:middle
想象你有一个
iOS iPad

00:31:55.849 --> 00:31:59.052 align:middle
iPhone和OS X
App Store app

00:31:59.386 --> 00:32:03.423 align:middle
你想要只登陆一个
就同时登陆所有这些程序

00:31:59.386 --> 00:32:03.423 align:middle
你想要只登陆一个
就同时登陆所有这些程序

00:32:05.659 --> 00:32:08.028 align:middle
对于能够用于多种设备的应用密码

00:32:08.095 --> 00:32:11.999 align:middle
你们可以考虑将同步性属性

00:32:12.065 --> 00:32:14.034 align:middle
添加到所有的SecItem调用

00:32:15.736 --> 00:32:17.271 align:middle
你还需要考虑几件事情

00:32:17.337 --> 00:32:19.973 align:middle
比如 删除一个项目
就会将所有位置的该项目同时删除掉

00:32:20.107 --> 00:32:22.709 align:middle
所以请确保你只在正确的
情况下进行该操作

00:32:24.578 --> 00:32:28.715 align:middle
这里还有几个注意事项
你可以在SecItem.h.

00:32:30.584 --> 00:32:31.985 align:middle
查看如果你有兴趣想了解更多

00:32:32.052 --> 00:32:34.388 align:middle
关于iCloud Keychaine
安全性的信息

00:32:34.755 --> 00:32:37.925 align:middle
或者想知道同步的密码如何
保护个人隐私

00:32:37.991 --> 00:32:41.128 align:middle
不被其他用户看到
请查看iOS 安全白皮书

00:32:41.528 --> 00:32:43.096 align:middle
会议结束有个链接

00:32:46.700 --> 00:32:51.305 align:middle
我重申下
Keychain存着你所有的秘密

00:32:51.471 --> 00:32:55.309 align:middle
而纯文本文件或plist
文件已经没有密码

00:32:56.510 --> 00:32:58.979 align:middle
所有请尽可能保护好它们

00:33:00.681 --> 00:33:03.050 align:middle
并且如果合适的话请使用
SharedWedCredentials

00:33:03.116 --> 00:33:06.286 align:middle
比如我们的Keychain
以便在用户的设备上将进行同步

00:33:06.453 --> 00:33:08.222 align:middle
同时尽量不用密码提示

00:33:13.026 --> 00:33:16.597 align:middle
所以虽然有些秘密能在
多台设备上同步但你只想它们

00:33:17.264 --> 00:33:18.465 align:middle
在一台设备上安全待着

00:33:18.532 --> 00:33:21.535 align:middle
这时候iCloud
Keychain就派上大用场了

00:33:23.337 --> 00:33:25.639 align:middle
安全通讯应用就是一个例子

00:33:26.006 --> 00:33:29.943 align:middle
这种应用的加密是设备对设备
而不是用户对用户

00:33:32.779 --> 00:33:35.082 align:middle
我已经提到过的不同保护级别中

00:33:35.182 --> 00:33:37.251 align:middle
有一个
ThisDeviceOnly级别

00:33:38.118 --> 00:33:40.921 align:middle
项目会被备份但只能被

00:33:41.088 --> 00:33:42.322 align:middle
恢复到它们最初始的设备中

00:33:44.191 --> 00:33:47.794 align:middle
去年 我们增加了
WhenPassCodeSet级别

00:33:48.295 --> 00:33:50.464 align:middle
确保项目始终处于

00:33:50.564 --> 00:33:52.533 align:middle
本地设备密码保护之下

00:33:54.268 --> 00:33:56.069 align:middle
你可以使用
AccessControl表

00:33:56.136 --> 00:33:59.339 align:middle
以对项目进行更为严密的控制

00:34:03.777 --> 00:34:04.711 align:middle
既然我们在谈论

00:34:04.811 --> 00:34:07.447 align:middle
保护特定设备证书的事情

00:34:07.881 --> 00:34:10.918 align:middle
那么让我们来看一看
iOS设备的安全域

00:34:12.319 --> 00:34:14.821 align:middle
用户空间也就是应用运行的空间

00:34:15.889 --> 00:34:19.092 align:middle
以及皮埃尔提到过的
能够提供进程分离和

00:34:19.159 --> 00:34:21.228 align:middle
其它安全功能的内核

00:34:22.563 --> 00:34:25.831 align:middle
不过它也提供了很多很多其它OS工具

00:34:26.033 --> 00:34:28.335 align:middle
这意味着它有着
一个相当强大的防攻击服务

00:34:29.036 --> 00:34:32.306 align:middle
我们在iPhone 5s中
加入了Secure Enclave

00:34:35.475 --> 00:34:40.681 align:middle
Secure Enclave
是独立运行的在设计之时

00:34:40.813 --> 00:34:42.850 align:middle
始终将安全性视为最高原则

00:34:44.484 --> 00:34:48.222 align:middle
我们在其中放置了
Touch ID来保护隐私

00:34:48.288 --> 00:34:50.924 align:middle
以及你的指纹信息的安全

00:34:52.626 --> 00:34:55.661 align:middle
我们将KeyStore从内核

00:34:55.728 --> 00:34:58.532 align:middle
移进
Secure Enclave就是它

00:34:58.866 --> 00:35:02.069 align:middle
控制着Keychain项目的密码

00:34:58.866 --> 00:35:02.069 align:middle
控制着Keychain项目的密码

00:35:02.169 --> 00:35:03.070 align:middle
以及数据保护

00:35:07.374 --> 00:35:09.409 align:middle
所以让我们现在
着重了解一下Touch ID

00:35:11.311 --> 00:35:13.547 align:middle
我们把它视为一种安全技术

00:35:13.947 --> 00:35:16.350 align:middle
但它真正出色的是它的便利性

00:35:17.150 --> 00:35:20.320 align:middle
你可以不用总是输入密码
就可以解锁你的设备

00:35:21.788 --> 00:35:24.458 align:middle
不过它本身也可以带给我们
一些安全上面的好处

00:35:25.125 --> 00:35:29.029 align:middle
比如如今拥有复杂的长密码
变得更加容易了

00:35:29.897 --> 00:35:32.132 align:middle
它能够提高数据保护的安全性

00:35:33.467 --> 00:35:37.871 align:middle
或者现在你的手机能够立即上锁

00:35:38.038 --> 00:35:40.707 align:middle
从而减少被攻击和解锁状态的时间

00:35:44.745 --> 00:35:48.649 align:middle
在iOS 8我们提供了一些API
所以当你在安全性和便利性之间

00:35:48.715 --> 00:35:52.486 align:middle
做权衡的时候你可以使用
应用里的Touch ID

00:35:53.187 --> 00:35:55.556 align:middle
但为何是这两者它们如何不同？

00:35:56.890 --> 00:35:59.393 align:middle
若想知道首先
你得了解Touch ID

00:35:59.459 --> 00:36:01.495 align:middle
和生物特征识别的工作机制

00:35:59.459 --> 00:36:01.495 align:middle
和生物特征识别的工作机制

00:36:01.862 --> 00:36:05.365 align:middle
幸运的是 这很简单
它可以归结为一个条件句

00:36:06.300 --> 00:36:10.003 align:middle
如果伸出的手指和登记的手指相匹配

00:36:10.537 --> 00:36:11.772 align:middle
就要做出反应

00:36:13.173 --> 00:36:16.376 align:middle
造成差别的原因是这种反应是什么

00:36:16.944 --> 00:36:17.845 align:middle
以及反应在哪里发生

00:36:21.148 --> 00:36:22.816 align:middle
让我们从Local
Authentication开始谈起

00:36:24.785 --> 00:36:27.287 align:middle
当一根手指被放在
Touch ID感应器下

00:36:27.654 --> 00:36:29.556 align:middle
在Secure Enclave
里得到匹配

00:36:32.059 --> 00:36:33.227 align:middle
匹配的消息

00:36:33.327 --> 00:36:36.730 align:middle
会通过Local Authentication
发送到你的应用

00:36:37.297 --> 00:36:38.298 align:middle
从而成功计算出布尔值

00:36:40.067 --> 00:36:43.770 align:middle
你的应用就是这样
对那条信息的做出反应的

00:36:46.740 --> 00:36:50.143 align:middle
进程虽然在Secure
Enclave开始

00:36:50.911 --> 00:36:54.982 align:middle
但最终安全决策却是

00:36:55.449 --> 00:36:58.352 align:middle
用户空间里的应用做出

00:37:01.355 --> 00:37:03.323 align:middle
所以你什么时候可能想要通过
Local Authentication

00:37:03.390 --> 00:37:04.391 align:middle
使用Touch ID呢

00:37:05.826 --> 00:37:09.062 align:middle
想想你的应用如果你有任何安全障碍

00:37:09.530 --> 00:37:12.799 align:middle
比如输入密码来确认一项操作

00:37:13.333 --> 00:37:15.335 align:middle
即使用户已经登录了

00:37:17.004 --> 00:37:19.239 align:middle
使用Touch ID会更容易

00:37:21.108 --> 00:37:23.944 align:middle
或者你可能不想要总是
使用Touch ID

00:37:24.511 --> 00:37:30.484 align:middle
但在验证过程中采取额外的
措施这会是一个大障碍

00:37:34.188 --> 00:37:36.890 align:middle
比如你可以在查看敏感数据前

00:37:37.057 --> 00:37:38.458 align:middle
做出提示

00:37:40.160 --> 00:37:45.766 align:middle
或者在某个操作之前做出提示
比如永久性删除账户

00:37:49.770 --> 00:37:52.372 align:middle
一种模式是在你的应用流中

00:37:52.472 --> 00:37:53.774 align:middle
做出一个Touch ID提示

00:37:55.042 --> 00:37:59.012 align:middle
但这可能导致这种情况发生
那就是 用户刚刚用Touch ID解锁

00:37:59.446 --> 00:38:02.549 align:middle
但没过多久应用又会发来提示

00:37:59.446 --> 00:38:02.549 align:middle
但没过多久应用又会发来提示

00:38:04.785 --> 00:38:09.089 align:middle
在iOS9 我们添加了
TouchIDAuthentication

00:38:09.223 --> 00:38:12.726 align:middle
AllowableReuseDuration
这是在Local Authentication

00:38:12.793 --> 00:38:13.694 align:middle
环境下的一项属性

00:38:14.962 --> 00:38:16.630 align:middle
你可以使用它来指定一个窗口

00:38:17.297 --> 00:38:19.600 align:middle
如果用户最近刚用Touch ID

00:38:20.100 --> 00:38:22.369 align:middle
来解锁他们的设备在期间

00:38:22.536 --> 00:38:23.437 align:middle
你就不需要再次提示

00:38:25.138 --> 00:38:27.875 align:middle
那是让你的策略宽松一些的一种办法

00:38:29.676 --> 00:38:32.379 align:middle
但或许你想让你的策略在某些情况下

00:38:32.513 --> 00:38:33.514 align:middle
更严格一些

00:38:33.580 --> 00:38:37.017 align:middle
比如 对一个新登记的指纹做出反应

00:38:40.420 --> 00:38:44.625 align:middle
同样也是一项新技术我们有
evaluatedPolicyDomainState属性

00:38:46.326 --> 00:38:47.828 align:middle
这是一个完全隐秘的值

00:38:48.262 --> 00:38:51.064 align:middle
代表了已登记指纹的当前情况

00:38:52.833 --> 00:38:55.636 align:middle
你真正能做的是实时做一下比较

00:38:56.403 --> 00:39:00.574 align:middle
如果它改变了
那就是设置里的已登记指纹中

00:38:56.403 --> 00:39:00.574 align:middle
如果它改变了
那就是设置里的已登记指纹中

00:39:00.741 --> 00:39:02.409 align:middle
有一个指纹信息已经被添加或移除

00:39:04.912 --> 00:39:07.047 align:middle
如果你察觉到并且它适合

00:39:07.147 --> 00:39:11.251 align:middle
你的应用或许你可以再次提示

00:39:11.318 --> 00:39:14.054 align:middle
看看用户是否还想
使用应用上的Touch ID

00:39:14.555 --> 00:39:16.623 align:middle
或者输入一个密码来重新启动它

00:39:19.693 --> 00:39:22.863 align:middle
那么我们来看看iOS 9的本地授权
有哪些新功能

00:39:24.731 --> 00:39:27.267 align:middle
我已经提到了
AllowableReuseDuration

00:39:27.334 --> 00:39:29.136 align:middle
和
PolicyDomainState

00:39:30.637 --> 00:39:34.408 align:middle
另外你可以取消本地授权功能

00:39:34.908 --> 00:39:38.812 align:middle
并且如果用户现在会收到
Touch ID提示

00:39:38.879 --> 00:39:42.749 align:middle
那么取消后系统会自动为用户选择取消

00:39:43.183 --> 00:39:44.284 align:middle
并关闭对话框

00:39:46.220 --> 00:39:50.190 align:middle
evaluateAccessControl
让本地授权可以

00:39:50.257 --> 00:39:56.129 align:middle
和Keychain Access Control
Lists一同使用我将稍后介绍

00:39:56.230 --> 00:39:59.566 align:middle
也会给出很多示例和示例代码

00:40:02.302 --> 00:40:05.305 align:middle
所以说起Keychain Access
Control Lists

00:40:05.639 --> 00:40:07.941 align:middle
这是第二种方式你可以
在应用内使用Touch ID

00:40:08.208 --> 00:40:10.978 align:middle
然后用来保护特定的
Keychain项目

00:40:12.312 --> 00:40:13.947 align:middle
这是我们的结构图

00:40:15.382 --> 00:40:18.919 align:middle
和之前一样 Touch ID
在安全区域内发生匹配

00:40:19.653 --> 00:40:22.623 align:middle
但是这次匹配信息会从安全区域内

00:40:23.156 --> 00:40:25.659 align:middle
发送到Keystore

00:40:27.327 --> 00:40:32.499 align:middle
只有在此之后
你的Keychain项目才会

00:40:32.933 --> 00:40:33.767 align:middle
被释放回到应用中

00:40:37.504 --> 00:40:39.840 align:middle
所以如果你想要对特定的
文件进行保护的话

00:40:39.907 --> 00:40:41.808 align:middle
这么这种方式非常有用

00:40:43.477 --> 00:40:46.280 align:middle
另外这也充分利用了安全区域的

00:40:46.680 --> 00:40:48.615 align:middle
额外保护功能

00:40:50.617 --> 00:40:55.522 align:middle
也许有时候你在权衡应用的安全性

00:40:55.789 --> 00:40:58.125 align:middle
然后你发现有些东西你实在不想要保留

00:40:58.192 --> 00:41:00.394 align:middle
不要每次或者经常收到提示

00:40:58.192 --> 00:41:00.394 align:middle
不要每次或者经常收到提示

00:41:01.862 --> 00:41:04.298 align:middle
你可以使用Access
Control Lists进行保存

00:41:04.398 --> 00:41:07.901 align:middle
然后使用Touch ID进行保护
从而提供更好的用户体验

00:41:09.670 --> 00:41:12.406 align:middle
或者你可以将其用来

00:41:12.673 --> 00:41:14.641 align:middle
增加已经保存的项目的安全性

00:41:18.011 --> 00:41:21.682 align:middle
你可以通过指定两项安全属性
创建访问控制列表

00:41:23.250 --> 00:41:25.886 align:middle
第一是数据有效保护类型

00:41:26.653 --> 00:41:30.290 align:middle
指的是需要使用密码

00:41:32.860 --> 00:41:35.329 align:middle
才能访问安全区域里的数据
接下来你可以制定一项策略

00:41:36.697 --> 00:41:38.999 align:middle
该策略指定了一种情况

00:41:39.600 --> 00:41:42.002 align:middle
只有这种情况满足后
安全区域才会释放项目

00:41:42.135 --> 00:41:44.137 align:middle
单单访问密码是无法查阅的

00:41:47.608 --> 00:41:50.177 align:middle
因此我们来看看策略类型

00:41:51.979 --> 00:41:53.580 align:middle
第一种是UserPresence

00:41:54.047 --> 00:41:56.083 align:middle
这种策略会提示需要
Touch ID匹配

00:41:56.149 --> 00:41:58.252 align:middle
然后返回到设备密码

00:41:59.486 --> 00:42:02.389 align:middle
另外你也可以直接
跳转到DevicePasscode

00:41:59.486 --> 00:42:02.389 align:middle
另外你也可以直接
跳转到DevicePasscode

00:42:04.791 --> 00:42:06.994 align:middle
iOS 9的新功能是
TouchIDAny

00:42:08.395 --> 00:42:12.165 align:middle
这种策略需要Touch Id匹配
但是不会有反馈

00:42:13.800 --> 00:42:18.138 align:middle
另外更为严格的新策略是
TouchIDCurrentSet

00:42:19.173 --> 00:42:22.442 align:middle
使用该策略只有在保存项目
时候使用的登记指纹组

00:42:22.509 --> 00:42:24.611 align:middle
不发生变化的情况下

00:42:24.912 --> 00:42:26.346 align:middle
项目才会释放

00:42:28.282 --> 00:42:29.483 align:middle
我想要详细谈谈这种策略

00:42:29.850 --> 00:42:33.353 align:middle
因为你的应用可能用得着

00:42:33.487 --> 00:42:36.423 align:middle
因为这种策略提供多要素授权

00:42:38.492 --> 00:42:40.727 align:middle
当谈到多要素的时候
你可能经常会想到

00:42:40.861 --> 00:42:46.066 align:middle
比如像是密码还有其他一些
你可以想到的东西

00:42:46.133 --> 00:42:49.770 align:middle
比如物理标记智能卡

00:42:50.804 --> 00:42:54.041 align:middle
或者是iOS设备的安全区域
和Touch ID

00:42:56.910 --> 00:42:59.079 align:middle
如果你保存一个文件

00:42:59.179 --> 00:43:03.016 align:middle
然后使用TouchIDCurrentSet
策略进行保护

00:42:59.179 --> 00:43:03.016 align:middle
然后使用TouchIDCurrentSet
策略进行保护

00:43:03.083 --> 00:43:06.253 align:middle
如果无法成功进行Touch ID
匹配那么是无法访问文件的

00:43:07.688 --> 00:43:08.922 align:middle
而且没有其他方式可以访问

00:43:09.323 --> 00:43:13.961 align:middle
另外如果对手有设备密码

00:43:14.628 --> 00:43:17.331 align:middle
他们无法访问设置登记指纹

00:43:17.831 --> 00:43:19.199 align:middle
这样对手就无法访问文件了

00:43:24.705 --> 00:43:27.274 align:middle
最后的两种策略
ApplicationPassword

00:43:27.341 --> 00:43:28.876 align:middle
和
PrivateKeyUsage

00:43:29.376 --> 00:43:32.946 align:middle
让你可以执行高级功能
这是Touch ID之上的高级功能

00:43:34.815 --> 00:43:36.850 align:middle
第一个是
ApplicationPassword

00:43:37.818 --> 00:43:41.822 align:middle
为了说明让我们看看
WhenUnlocked类别的项目

00:43:41.922 --> 00:43:43.156 align:middle
是如何被加密保护的

00:43:45.025 --> 00:43:49.096 align:middle
同样的即使是最好的门锁
如果你忘带钥匙还是白塔

00:43:49.596 --> 00:43:52.032 align:middle
因此如果加密数据
和秘钥保存在同一个地方

00:43:52.466 --> 00:43:54.101 align:middle
那么数据实际上没有得到保护

00:43:56.036 --> 00:43:58.872 align:middle
数据保护和Keychain
安全实质上是使用设备密码保护

00:43:59.373 --> 00:44:01.008 align:middle
而且密码已经保存在我们已知的

00:43:59.373 --> 00:44:01.008 align:middle
而且密码已经保存在我们已知的

00:44:02.042 --> 00:44:06.180 align:middle
最为复杂的系统之中即用户的大脑

00:44:08.549 --> 00:44:10.584 align:middle
用户记得密码
可以使用密码访问设备

00:44:11.151 --> 00:44:14.054 align:middle
在我们输入密码然后
会生成一把密码钥匙

00:44:14.521 --> 00:44:16.690 align:middle
这把秘钥能破解项目密码

00:44:19.993 --> 00:44:23.730 align:middle
现在让我们看看受
ApplicationPassword保护的项目

00:44:28.502 --> 00:44:32.072 align:middle
只有设备密码往往是不够的

00:44:33.640 --> 00:44:36.510 align:middle
你的应用还必须有自己的密码

00:44:37.578 --> 00:44:40.314 align:middle
因此我们生成了密码钥匙

00:44:40.881 --> 00:44:45.352 align:middle
而且只有在设备密码
和应用密码都正确后

00:44:45.953 --> 00:44:48.822 align:middle
密码钥匙才会授权给
Keychain访问项目

00:44:51.825 --> 00:44:55.863 align:middle
正如我提到的如果
你将密码保存到设备上或者应用中

00:44:56.530 --> 00:44:58.732 align:middle
这实际上并没有提供额外的保护功能

00:44:59.600 --> 00:45:02.903 align:middle
因此你必须考虑除了设备
你还可以将密码保存在哪里

00:44:59.600 --> 00:45:02.903 align:middle
因此你必须考虑除了设备
你还可以将密码保存在哪里

00:45:04.404 --> 00:45:07.407 align:middle
也许是服务器服务器
可以执行自己的策略

00:45:07.474 --> 00:45:09.076 align:middle
决定何时反馈密码到你的应用上

00:45:11.111 --> 00:45:15.182 align:middle
或者也许你有物理配件
而且你也觉得用户有物理配件

00:45:16.483 --> 00:45:19.520 align:middle
如果配件无法向你的应用提供密码

00:45:20.387 --> 00:45:22.656 align:middle
那么就无法破解Keychain项目

00:45:23.123 --> 00:45:24.858 align:middle
而你也无法访问数据

00:45:28.996 --> 00:45:34.067 align:middle
如要使用ApplicationPasswords
你需要创建AccessControl列表

00:45:34.668 --> 00:45:36.537 align:middle
和本地授权指令

00:45:37.638 --> 00:45:40.407 align:middle
第一个列表会要求你使用应用密码

00:45:40.874 --> 00:45:43.177 align:middle
第二指令会自行设定密码

00:45:44.978 --> 00:45:47.247 align:middle
然后你可以取下这二者然后添加到

00:45:47.314 --> 00:45:49.449 align:middle
Secltem Call字典之中

00:45:51.218 --> 00:45:56.757 align:middle
这是使用本地授权指令

00:45:56.957 --> 00:45:59.092 align:middle
和Keychain项目的例子

00:46:01.862 --> 00:46:03.130 align:middle
那么这就是
ApplicationPassword

00:46:04.431 --> 00:46:07.034 align:middle
最后的新策略指的是私人秘钥用途

00:46:09.369 --> 00:46:10.637 align:middle
这是比较早的表格

00:46:11.238 --> 00:46:14.308 align:middle
在这里我们可以看到一个Keychain
项目从安全区域内的KeyStore

00:46:14.374 --> 00:46:16.710 align:middle
被释放出来返回到了应用中

00:46:18.445 --> 00:46:22.983 align:middle
很明显如果你将密码
用于登录服务器的话就需要它了

00:46:23.550 --> 00:46:26.987 align:middle
但是这暴露了你的密码
让用户空间存在潜在危险

00:46:28.989 --> 00:46:30.791 align:middle
所以如果有办法在安全区域内

00:46:30.924 --> 00:46:33.460 align:middle
保存密码的话就不妙了

00:46:33.894 --> 00:46:35.095 align:middle
那么这还有用吗？

00:46:35.929 --> 00:46:38.131 align:middle
而且这里使用的是不对称加密技术

00:46:39.499 --> 00:46:43.036 align:middle
这里我们有的不仅仅是
单一的秘钥 而是一组秘钥

00:46:44.671 --> 00:46:47.307 align:middle
公共秘钥并不需要任何保护

00:46:47.841 --> 00:46:49.877 align:middle
但是私人秘钥就必须要好好保护了

00:46:54.114 --> 00:46:57.518 align:middle
使用这种策略会用到
SecKey APi

00:46:57.885 --> 00:47:00.254 align:middle
而且具体说的话几分钟说不完

00:46:57.885 --> 00:47:00.254 align:middle
而且具体说的话几分钟说不完

00:47:00.320 --> 00:47:03.924 align:middle
这里就略过了但是这里
有概括图可以看看流程

00:47:05.492 --> 00:47:09.429 align:middle
如果你设定某些新的额外参数的话

00:47:09.796 --> 00:47:12.065 align:middle
调用SecKeyGeneratePair会让

00:47:12.165 --> 00:47:14.568 align:middle
私人秘钥保存到安全区域中

00:47:15.802 --> 00:47:19.673 align:middle
但是公共秘钥仍会返回到应用中保存

00:47:23.977 --> 00:47:26.613 align:middle
如果你尝试检索使用
SecItemCopyMatching的私人秘钥

00:47:26.680 --> 00:47:28.615 align:middle
那么你会得到一个参数

00:47:30.083 --> 00:47:35.222 align:middle
但是无法在安全区域之外
获得实际的数据

00:47:37.658 --> 00:47:38.926 align:middle
因此实际上该如何使用呢？

00:47:39.726 --> 00:47:42.563 align:middle
好 你也许有一些数据是需要保留的

00:47:43.197 --> 00:47:48.802 align:middle
因此你可以调用SecKeyRawSign
然后将数据传输到安全区域

00:47:50.137 --> 00:47:52.606 align:middle
如果你已经设置了使用
Touch ID保护私人秘钥

00:47:52.673 --> 00:47:53.907 align:middle
那么只有在成功指纹匹配后

00:47:54.875 --> 00:47:59.246 align:middle
私人秘钥才能用于访问数据

00:47:59.413 --> 00:48:02.950 align:middle
之后再返回到应用中

00:47:59.413 --> 00:48:02.950 align:middle
之后再返回到应用中

00:48:09.356 --> 00:48:13.727 align:middle
因此也许你会想使用该策略作为第二
要素加强Touch ID的安全性

00:48:15.429 --> 00:48:18.532 align:middle
我会给你看个示例流程但是请注意

00:48:18.832 --> 00:48:22.469 align:middle
在编写加密协议的时候
这里有很多复杂的细节

00:48:22.903 --> 00:48:24.738 align:middle
所以请别把这个示例当成标准

00:48:26.907 --> 00:48:28.675 align:middle
首先在登记流程中

00:48:29.076 --> 00:48:30.377 align:middle
你会生产一个密钥对

00:48:32.646 --> 00:48:37.751 align:middle
然后将公共秘钥和用户
一般登录信息发送到服务器上

00:48:39.953 --> 00:48:43.790 align:middle
服务器会将公共秘钥
和用户信息相关联并记录

00:48:43.857 --> 00:48:47.194 align:middle
这就是登录流程

00:48:49.429 --> 00:48:52.199 align:middle
之后当服务器想要验证你是

00:48:52.266 --> 00:48:55.135 align:middle
从同一台物理设备登录的

00:48:56.937 --> 00:48:59.039 align:middle
服务器会向应用发送一个挑战

00:48:59.940 --> 00:49:02.342 align:middle
挑战反过来会调用
SecKeyRawSign

00:48:59.940 --> 00:49:02.342 align:middle
挑战反过来会调用
SecKeyRawSign

00:49:04.878 --> 00:49:06.713 align:middle
用户这时候会进行指纹识别

00:49:07.147 --> 00:49:08.348 align:middle
然后匹配Touch ID

00:49:10.717 --> 00:49:14.121 align:middle
这样挑战就通过了
然后应用会将挑战返回到服务器

00:49:16.256 --> 00:49:19.459 align:middle
之后服务器会使用之前保存的公共秘钥

00:49:19.993 --> 00:49:21.061 align:middle
进行验证签字

00:49:25.032 --> 00:49:27.167 align:middle
再具体展开看一下细节

00:49:27.701 --> 00:49:30.571 align:middle
通过验证的秘钥是
Elliptic Curve P256

00:49:31.738 --> 00:49:35.142 align:middle
私人秘钥则无法提取
即使在保护情况下亦不可

00:49:35.709 --> 00:49:38.579 align:middle
然后应用是RawSign
和RawVerify

00:49:43.016 --> 00:49:46.620 align:middle
总结一下 我已经大概讲解了
Keychain的情况

00:49:47.621 --> 00:49:50.057 align:middle
以及大家可能会用到
Keychain的情况

00:49:52.359 --> 00:49:56.396 align:middle
我谈论的技术是我们应当避免
让用户被密码提示反复骚扰

00:49:58.465 --> 00:50:02.336 align:middle
看看这两个Touch
ID API 本地授权

00:49:58.465 --> 00:50:02.336 align:middle
看看这两个Touch
ID API 本地授权

00:50:02.736 --> 00:50:04.705 align:middle
和Keychain
Access Controls

00:50:06.340 --> 00:50:10.043 align:middle
另外之前说的新的高级功能
大家可以开发出新的东西

00:50:10.244 --> 00:50:13.547 align:middle
我们已经添加到
iOS 9的新API之中了

00:50:17.751 --> 00:50:22.289 align:middle
App密码以及安全区
域保护的私人秘钥

00:50:24.391 --> 00:50:25.659 align:middle
我总是非常期待

00:50:25.959 --> 00:50:28.862 align:middle
看看大家会如何利用新的API

00:50:28.929 --> 00:50:30.731 align:middle
开发出什么更好玩的

00:50:31.164 --> 00:50:36.103 align:middle
也想看看大家是如何在应用中
权衡安全性和便捷性的

00:50:39.173 --> 00:50:41.642 align:middle
另外线上还有其他更多的资料

00:50:43.677 --> 00:50:46.213 align:middle
包括我之前提到的iOS安全白皮书

00:50:49.383 --> 00:50:51.919 align:middle
周四的NSURL网络会议上
还会有更多的关于

00:50:52.352 --> 00:50:55.189 align:middle
应用传输安全的内容

00:50:59.593 --> 00:51:02.262 align:middle
另外欢迎明早和周四上午来到

00:50:59.593 --> 00:51:02.262 align:middle
另外欢迎明早和周四上午来到

00:51:02.663 --> 00:51:04.398 align:middle
安全私人实验室会见我们

00:51:05.098 --> 00:51:06.066 align:middle
非常感谢大家
