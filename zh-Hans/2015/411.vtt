WEBVTT

00:00:26.593 --> 00:00:27.728 align:middle
下午好

00:00:29.596 --> 00:00:31.064 align:middle
大家好
感谢大家能来参加讲座

00:00:31.131 --> 00:00:34.001 align:middle
我是泰德·克热梅内克
我在Apple管理Swift团队

00:00:34.067 --> 00:00:37.704 align:middle
阿莱克斯和我很高兴也很荣幸

00:00:38.138 --> 00:00:40.741 align:middle
和大家讲讲在编译时使用Swift

00:00:41.141 --> 00:00:44.444 align:middle
来发现编码的更多问题

00:00:45.212 --> 00:00:46.613 align:middle
这是个相当宽泛的话题 所以我们

00:00:46.680 --> 00:00:48.882 align:middle
所以我们决定主要谈两个问题

00:00:49.683 --> 00:00:53.654 align:middle
首先是利用Swift 2中的
新语言术语供给

00:00:54.588 --> 00:00:58.625 align:middle
以便轻松允许应用利用新的API

00:00:58.725 --> 00:01:00.160 align:middle
与此同时部署更早的版本

00:00:58.725 --> 00:01:00.160 align:middle
与此同时部署更早的版本

00:01:00.594 --> 00:01:02.596 align:middle
在更早的讲座中
我们简要谈过这个话题

00:01:02.663 --> 00:01:04.531 align:middle
我们马上要深入探讨设计

00:01:04.598 --> 00:01:06.867 align:middle
方法的理念所解决的问题

00:01:06.934 --> 00:01:08.535 align:middle
以及如何在代码中实现最佳应用

00:01:09.269 --> 00:01:11.138 align:middle
然后 阿莱克斯会谈谈如何

00:01:11.205 --> 00:01:14.441 align:middle
使用富类型系统协议和枚举

00:01:14.508 --> 00:01:18.312 align:middle
甚至还有协议扩展
以便在在自己的代码中

00:01:18.378 --> 00:01:20.581 align:middle
执行应用不变性
并定义解决许多应用开发模板

00:01:23.050 --> 00:01:24.685 align:middle
我们先来看第一个话题

00:01:24.751 --> 00:01:27.087 align:middle
利用新API

00:01:28.589 --> 00:01:34.761 align:middle
这类话题已经讲了很多遍
很多人对此都很熟悉

00:01:35.429 --> 00:01:37.397 align:middle
对Apple而言 我们继续在

00:01:37.464 --> 00:01:42.836 align:middle
每个OS版本中推出丰富的API

00:01:43.270 --> 00:01:46.673 align:middle
让大家有机会在应用中构建不错的功能

00:01:47.174 --> 00:01:50.377 align:middle
对吗？
这是我们这么做的部分原因 不是吗？

00:01:51.211 --> 00:01:55.482 align:middle
这里的谜题是app具备已有用户
对么？

00:01:55.549 --> 00:01:56.783 align:middle
他们目前...

00:01:57.618 --> 00:01:59.353 align:middle
他们不必使用最新的OS

00:01:59.419 --> 00:02:01.922 align:middle
在iOS 有较快的使用率

00:01:59.419 --> 00:02:01.922 align:middle
在iOS 有较快的使用率

00:02:02.322 --> 00:02:05.225 align:middle
但是这不是说人人都会立刻采用

00:02:05.325 --> 00:02:08.529 align:middle
还有些人出于各种原因完全不会使用

00:02:09.463 --> 00:02:13.100 align:middle
那么你会面临一系列选择
你会怎么做呢？

00:02:14.568 --> 00:02:15.502 align:middle
你是否会继续

00:02:15.569 --> 00:02:18.572 align:middle
并要求app使用最新OS？

00:02:18.639 --> 00:02:22.242 align:middle
好 那你获得所有的新API
可这的确成问题

00:02:22.309 --> 00:02:24.411 align:middle
因为你会搞砸

00:02:24.478 --> 00:02:25.612 align:middle
要知道 你会损失用户

00:02:25.679 --> 00:02:27.281 align:middle
这些是会购买你的app的人群

00:02:29.550 --> 00:02:32.085 align:middle
你是否应该走到相反的极端

00:02:32.152 --> 00:02:34.988 align:middle
控制使用新API？

00:02:35.055 --> 00:02:37.491 align:middle
这样就会获得所支持的

00:02:37.558 --> 00:02:39.359 align:middle
最早版本OS的最小公分母

00:02:39.593 --> 00:02:42.963 align:middle
这样做很糟糕因为你会影响到

00:02:43.030 --> 00:02:45.199 align:middle
原本可以向用户提供的丰富

00:02:45.265 --> 00:02:46.099 align:middle
功能

00:02:47.167 --> 00:02:49.570 align:middle
当然 要知道有鱼和熊掌兼得的办法

00:02:49.636 --> 00:02:54.308 align:middle
可以采用新API与此同时还

00:02:54.374 --> 00:02:55.843 align:middle
可以部署更早的版本

00:02:56.844 --> 00:03:00.380 align:middle
所以很长时间以来 我们在技术上

00:02:56.844 --> 00:03:00.380 align:middle
所以很长时间以来 我们在技术上

00:03:00.480 --> 00:03:01.582 align:middle
都支持这种做法

00:03:02.482 --> 00:03:05.219 align:middle
当然 可以在Objective-C
和Swift中均可如此

00:03:05.285 --> 00:03:08.155 align:middle
可是现实中 如今这是个非常

00:03:08.222 --> 00:03:09.590 align:middle
痛苦的体验

00:03:16.029 --> 00:03:19.700 align:middle
在Swift 2中 我们尽可能
不让它这么痛苦

00:03:19.766 --> 00:03:23.437 align:middle
我们通过开发人员告知的当前问题

00:03:23.670 --> 00:03:27.074 align:middle
关于部署较早版本

00:03:27.140 --> 00:03:29.109 align:middle
并设法解决语言中的问题

00:03:29.176 --> 00:03:30.410 align:middle
来实现这一点

00:03:32.412 --> 00:03:34.848 align:middle
现在基本模型并未改变 对吧？

00:03:34.915 --> 00:03:38.919 align:middle
对于开发而言在我们的平台上

00:03:38.986 --> 00:03:40.387 align:middle
一直希望大家使用最新SDK

00:03:40.754 --> 00:03:43.624 align:middle
对吗？这会导致应用中所有可能

00:03:43.690 --> 00:03:45.792 align:middle
用到的API都混到了

00:03:46.260 --> 00:03:47.160 align:middle
一起

00:03:47.928 --> 00:03:50.430 align:middle
然后 可以切换app的部署目标

00:03:50.497 --> 00:03:52.533 align:middle
说明你想要退回的时间

00:03:53.901 --> 00:03:55.569 align:middle
从画面来看这样就非常简单

00:03:55.669 --> 00:03:57.638 align:middle
就像是版本的滑动视窗

00:03:57.704 --> 00:03:59.506 align:middle
设置最新的基底SDK

00:03:59.907 --> 00:04:02.543 align:middle
把部署目标设置到视窗的

00:03:59.907 --> 00:04:02.543 align:middle
把部署目标设置到视窗的

00:04:02.809 --> 00:04:04.011 align:middle
最早版本 对么？

00:04:04.545 --> 00:04:05.612 align:middle
从概念来讲 很简单

00:04:07.080 --> 00:04:11.752 align:middle
那么在谈到在Swift 2中

00:04:11.818 --> 00:04:15.689 align:middle
如何采用新功能和API之前
我们先来看

00:04:15.756 --> 00:04:17.757 align:middle
现有方法中的问题

00:04:18.257 --> 00:04:21.827 align:middle
基本上而言 你必须编写app

00:04:21.894 --> 00:04:26.033 align:middle
以便应对更早版本的主OS中
API缺失的问题 对吗？

00:04:26.834 --> 00:04:30.504 align:middle
还有几个问题需要单独考虑

00:04:30.938 --> 00:04:33.707 align:middle
整个框架的缺失类方法

00:04:33.774 --> 00:04:37.611 align:middle
函数 甚至部分枚举值

00:04:37.978 --> 00:04:39.112 align:middle
在更早的版本中不得使用

00:04:39.613 --> 00:04:42.349 align:middle
但是令人烦心的是你必须逐一

00:04:42.416 --> 00:04:44.451 align:middle
解释所有这些问题

00:04:45.185 --> 00:04:47.821 align:middle
对框架而言很是麻烦 要决定

00:04:47.888 --> 00:04:50.257 align:middle
我把它连接到应用时 这个

00:04:50.557 --> 00:04:52.392 align:middle
框架是可选项

00:04:52.860 --> 00:04:56.029 align:middle
如果不这样做app就会在启动

00:04:56.096 --> 00:04:57.564 align:middle
较早版本的OS时 出现问题

00:04:59.766 --> 00:05:02.703 align:middle
然后是API本身实际运用

00:04:59.766 --> 00:05:02.703 align:middle
然后是API本身实际运用

00:05:02.769 --> 00:05:05.272 align:middle
我们先来看类

00:05:06.139 --> 00:05:08.275 align:middle
基本上来说你是在编写app

00:05:08.342 --> 00:05:09.943 align:middle
因此它会有不同表现

00:05:10.043 --> 00:05:11.645 align:middle
这将是有条件的行为

00:05:11.712 --> 00:05:15.282 align:middle
例如当新的API
可用app就会做些不同的事情

00:05:15.782 --> 00:05:18.051 align:middle
因此条件逻辑并不是问题

00:05:18.619 --> 00:05:21.788 align:middle
问题在于怎样为行为实现条件化

00:05:22.956 --> 00:05:25.192 align:middle
在这张幻灯片上是用来检测可用性的

00:05:25.259 --> 00:05:26.593 align:middle
典型方法

00:05:26.660 --> 00:05:28.929 align:middle
你来查询
Objective-C的运行时间

00:05:28.996 --> 00:05:32.132 align:middle
这个类会在运行时间出现么？

00:05:33.367 --> 00:05:35.636 align:middle
问题是这有点谎言的味道

00:05:35.936 --> 00:05:38.238 align:middle
对吗？我是说类可以有

00:05:38.705 --> 00:05:41.475 align:middle
但是这不意味着你可以使用

00:05:42.376 --> 00:05:47.214 align:middle
API会经常开始是内部API

00:05:47.948 --> 00:05:49.283 align:middle
在OS中

00:05:49.716 --> 00:05:52.786 align:middle
它们会在生成和演进的
地方呆上一阵在对外发布时

00:05:53.220 --> 00:05:55.923 align:middle
API的行为

00:05:56.290 --> 00:05:58.892 align:middle
可能已经完全改变

00:05:59.359 --> 00:06:01.628 align:middle
即便这样的检测在运行时间成功了

00:05:59.359 --> 00:06:01.628 align:middle
即便这样的检测在运行时间成功了

00:06:02.462 --> 00:06:04.431 align:middle
这也不能说明实际使用

00:06:04.498 --> 00:06:06.900 align:middle
这款API时会绝对安全

00:06:07.634 --> 00:06:13.674 align:middle
而是说 如果在OS版本上
你使用的时间太过于早

00:06:14.141 --> 00:06:16.710 align:middle
基本上会在应用中加上定时炸弹

00:06:16.777 --> 00:06:21.949 align:middle
原本你以为API会按照一定方式
表现 现在会完全遭到破坏

00:06:22.115 --> 00:06:24.351 align:middle
这会令开发人员多次受到打击

00:06:24.985 --> 00:06:27.221 align:middle
因此是个严重问题

00:06:29.189 --> 00:06:31.992 align:middle
另一个问题是太容易出错

00:06:32.659 --> 00:06:34.127 align:middle
来看这个新款API

00:06:34.661 --> 00:06:36.730 align:middle
通过几项特色功能

00:06:36.930 --> 00:06:40.834 align:middle
我的代码完全有效结果却出了差错

00:06:41.435 --> 00:06:45.305 align:middle
数据在NS数据资产之前很久引入的

00:06:45.572 --> 00:06:48.342 align:middle
代码还会编译 若在最新的OS上检测

00:06:48.408 --> 00:06:50.143 align:middle
它甚至会成功运行

00:06:50.410 --> 00:06:53.580 align:middle
那么只是在更早版本的设备上

00:06:53.914 --> 00:06:55.516 align:middle
运行代码 才会出现问题

00:06:55.616 --> 00:06:58.986 align:middle
对吗？这与通常的测试场景完全不符

00:06:59.419 --> 00:07:01.255 align:middle
在部分情况下

00:06:59.419 --> 00:07:01.255 align:middle
在部分情况下

00:07:01.321 --> 00:07:03.123 align:middle
只需要用户来发现这个问题

00:07:03.824 --> 00:07:07.528 align:middle
即将出现的情况是
当你试图使用这个类时运行时间会崩溃

00:07:09.897 --> 00:07:15.102 align:middle
很容易因为简单的小错出现问题

00:07:16.570 --> 00:07:20.174 align:middle
方法和类的问题基本一样

00:07:20.908 --> 00:07:22.910 align:middle
可能会出现输入错误

00:07:23.177 --> 00:07:25.045 align:middle
如果检测属性的可用性

00:07:25.112 --> 00:07:27.681 align:middle
你现在必须了解属性的选择器

00:07:27.748 --> 00:07:29.650 align:middle
同时还要拼写正确

00:07:29.750 --> 00:07:32.519 align:middle
此外语法也完全不同 对吗？

00:07:32.586 --> 00:07:34.888 align:middle
来检测API但是语法不一样

00:07:36.089 --> 00:07:37.724 align:middle
函数也有着同样问题

00:07:37.791 --> 00:07:39.626 align:middle
你会犯同样的错误不过可以有

00:07:39.693 --> 00:07:41.461 align:middle
其他方式来编写

00:07:42.196 --> 00:07:45.299 align:middle
那么 如果有枚举那你就被完全骗到了

00:07:45.365 --> 00:07:47.668 align:middle
你不知道 怎样的解决方案才合适

00:07:47.734 --> 00:07:50.237 align:middle
选择器对映射完全没有反应

00:07:50.637 --> 00:07:54.274 align:middle
那就要手动OS版本检测

00:07:54.708 --> 00:07:57.778 align:middle
来看这个表格感觉就像是你希望

00:07:57.845 --> 00:07:59.079 align:middle
改正的所有簿记问题

00:07:59.146 --> 00:08:00.447 align:middle
都在这里

00:07:59.146 --> 00:08:00.447 align:middle
都在这里

00:08:01.248 --> 00:08:03.717 align:middle
这是个非常伤感的故事

00:08:07.254 --> 00:08:09.456 align:middle
现在我们看到的是的确成问题的

00:08:09.523 --> 00:08:10.390 align:middle
编程模型

00:08:10.457 --> 00:08:13.227 align:middle
对吗？技术上可行但是很难做到

00:08:13.694 --> 00:08:15.329 align:middle
我们希望你利用新款API

00:08:15.395 --> 00:08:18.465 align:middle
与此同时继续支持所有的用户

00:08:19.933 --> 00:08:22.569 align:middle
我们需要解决这些问题

00:08:25.005 --> 00:08:28.108 align:middle
在Swift 2中情况有所改变

00:08:28.175 --> 00:08:29.409 align:middle
把改变构建在语言当中

00:08:30.677 --> 00:08:34.615 align:middle
要以怎样架构app为主 那么

00:08:35.048 --> 00:08:37.150 align:middle
有其他方法可行时可以考虑

00:08:37.251 --> 00:08:38.684 align:middle
使用这些API

00:08:38.751 --> 00:08:40.953 align:middle
你理解 会有条件性行为

00:08:41.355 --> 00:08:42.890 align:middle
但是你会主要关注于此

00:08:43.957 --> 00:08:45.759 align:middle
然后有编译器作为支持

00:08:46.326 --> 00:08:49.897 align:middle
如果用不安全的方式使用API
就会出现错误

00:08:51.064 --> 00:08:53.500 align:middle
还要有统一的句法这样就不必考虑

00:08:53.567 --> 00:08:56.436 align:middle
类 方法函数甚至映射问题

00:08:56.503 --> 00:09:00.073 align:middle
这些都在所用的句法中处理好了

00:08:56.503 --> 00:09:00.073 align:middle
这些都在所用的句法中处理好了

00:09:00.140 --> 00:09:02.676 align:middle
编译器了解你该用的句法

00:09:02.743 --> 00:09:05.546 align:middle
如果你没有做对 它会告诉你正确做法

00:09:07.681 --> 00:09:11.151 align:middle
因为编译器会一直参与其中

00:09:11.218 --> 00:09:12.886 align:middle
在Swift中我们使用模型

00:09:13.420 --> 00:09:16.123 align:middle
所有可选链接可以帮你来处理

00:09:18.759 --> 00:09:22.362 align:middle
那么这样效果如何
这里是来自核心位置的部分API

00:09:24.498 --> 00:09:26.934 align:middle
比如说 我在部署iOS 9

00:09:27.201 --> 00:09:29.469 align:middle
因此使iOS 9 SDK

00:09:29.536 --> 00:09:31.505 align:middle
并设置iOS 9的部署目标

00:09:32.773 --> 00:09:35.542 align:middle
编译器可以在SDK中看到该信息

00:09:35.609 --> 00:09:37.411 align:middle
因此这是在
Objective-C头文件中

00:09:37.477 --> 00:09:39.947 align:middle
还可以作为
Swift中生成的界面来查看

00:09:40.614 --> 00:09:42.716 align:middle
因此类被引入iOS 2中

00:09:43.450 --> 00:09:45.686 align:middle
方法稍后会引入iOS 8

00:09:46.620 --> 00:09:48.121 align:middle
因为我在运行iOS 9

00:09:48.222 --> 00:09:50.457 align:middle
可以无条件使用这款API

00:09:51.558 --> 00:09:54.795 align:middle
如果我在iOS 8
部署也仍然没有问题

00:09:55.562 --> 00:09:58.165 align:middle
但是如果我一路退回iOS 7

00:09:58.599 --> 00:10:01.034 align:middle
编译器可以看到
正如我们可以在幻灯片上看到

00:09:58.599 --> 00:10:01.034 align:middle
编译器可以看到
正如我们可以在幻灯片上看到

00:10:02.002 --> 00:10:04.438 align:middle
使用这种方法并不安全

00:10:04.505 --> 00:10:06.373 align:middle
需要请求使用授权

00:10:09.109 --> 00:10:13.380 align:middle
编译器会告诉你这是不安全代码

00:10:14.047 --> 00:10:15.415 align:middle
是错误

00:10:15.482 --> 00:10:18.218 align:middle
它会禁止你构建这个代码

00:10:19.186 --> 00:10:20.687 align:middle
并会提供不错的安全性检测

00:10:26.660 --> 00:10:29.363 align:middle
它会提供可以解决

00:10:29.997 --> 00:10:31.932 align:middle
这一问题的不同方法

00:10:33.100 --> 00:10:35.502 align:middle
这里有注解 你是否需要安全检测？

00:10:36.203 --> 00:10:38.839 align:middle
会有附上的解决办法 如果接受

00:10:39.273 --> 00:10:40.807 align:middle
代码就重写 像这样

00:10:42.142 --> 00:10:48.382 align:middle
现在有汇编组合静态执行

00:10:48.448 --> 00:10:49.716 align:middle
和运行时间执行

00:10:51.051 --> 00:10:54.121 align:middle
这就是散列可用句法

00:10:54.821 --> 00:10:58.725 align:middle
基本上
编译器扫描可以看到代码块中的

00:10:59.092 --> 00:11:04.364 align:middle
所有内容最新的iOS
OS X或安全执行这些API

00:10:59.092 --> 00:11:04.364 align:middle
所有内容最新的iOS
OS X或安全执行这些API

00:11:04.431 --> 00:11:05.666 align:middle
所需的具体版本

00:11:06.099 --> 00:11:08.235 align:middle
是什么？

00:11:09.369 --> 00:11:12.372 align:middle
然后会使用在散列可用的

00:11:12.439 --> 00:11:15.042 align:middle
所提到版本进行适当的运行时间检测

00:11:15.108 --> 00:11:16.977 align:middle
编译器会把它插入其中

00:11:17.044 --> 00:11:19.346 align:middle
你不必猜测如何完成 会高效完成

00:11:19.680 --> 00:11:22.583 align:middle
并做缓存
这样就可以安全使用

00:11:23.517 --> 00:11:26.553 align:middle
在SDK中使用该信息

00:11:26.620 --> 00:11:30.324 align:middle
会实现高保真
因此会得到真正安全的模式

00:11:32.960 --> 00:11:34.228 align:middle
有些人会问

00:11:34.595 --> 00:11:37.231 align:middle
为什么要在OS版本中
进行检测呢

00:11:37.297 --> 00:11:39.666 align:middle
不是提供过对以往内容

00:11:39.733 --> 00:11:41.201 align:middle
所做的指南么？

00:11:41.935 --> 00:11:46.273 align:middle
原因是做簿记实在太难

00:11:46.673 --> 00:11:49.776 align:middle
至少当你查询运行时间时

00:11:50.077 --> 00:11:53.013 align:middle
你会得到部分真相 但是在很多情况下
即便是真相也会有出入

00:11:54.915 --> 00:11:58.919 align:middle
逻辑上来讲 和app开发人员交谈

00:11:59.887 --> 00:12:02.489 align:middle
要知道 你希望构建在app上的体验

00:11:59.887 --> 00:12:02.489 align:middle
要知道 你希望构建在app上的体验

00:12:02.556 --> 00:12:04.424 align:middle
都发起在用户正在

00:12:04.491 --> 00:12:07.427 align:middle
运行的主OS上 对么？

00:12:07.995 --> 00:12:11.532 align:middle
在每个OS版本中都有一批新的API

00:12:12.599 --> 00:12:14.735 align:middle
这些基本上定义了你可以执行的

00:12:15.002 --> 00:12:18.539 align:middle
各种功能而用户在使用

00:12:18.605 --> 00:12:21.608 align:middle
不同版本的OS 因此 他们在逻辑上

00:12:21.675 --> 00:12:25.245 align:middle
打破了你的app所具备的

00:12:25.312 --> 00:12:27.414 align:middle
行为类别 对么？

00:12:27.481 --> 00:12:30.951 align:middle
所有这些在逻辑一致性上都有区别

00:12:32.052 --> 00:12:35.789 align:middle
同样 它也不会检测某款API的存在

00:12:36.156 --> 00:12:39.193 align:middle
因为你通常准备同时使用若干API

00:12:39.259 --> 00:12:41.128 align:middle
这其实说不过

00:12:41.195 --> 00:12:42.863 align:middle
某款API的存在并非表明其他

00:12:42.930 --> 00:12:44.565 align:middle
也会存在

00:12:44.932 --> 00:12:47.467 align:middle
信息位于SDK中编译器可以为你

00:12:47.534 --> 00:12:48.836 align:middle
完成簿记工作

00:12:49.770 --> 00:12:52.573 align:middle
编译器涉及到真正的规则改变者

00:12:53.140 --> 00:12:55.742 align:middle
它使得可用性检测非常可靠

00:12:56.310 --> 00:12:59.813 align:middle
可以假设编译器在做着正确的事情

00:13:00.047 --> 00:13:01.715 align:middle
你尽可放心是在

00:13:01.782 --> 00:13:05.018 align:middle
通过定义解决整类问题

00:13:05.085 --> 00:13:06.920 align:middle
因为你在用编译执行

00:13:09.256 --> 00:13:13.026 align:middle
而且自然会进入多个平台

00:13:13.827 --> 00:13:17.531 align:middle
比如
我之前有这个NSData资产实例

00:13:18.098 --> 00:13:20.968 align:middle
如果
我想让代码以OS X和iOS为目标

00:13:21.435 --> 00:13:23.971 align:middle
我可以简单扩展句法称我也在

00:13:24.037 --> 00:13:26.540 align:middle
其他平台检测其最小可用性

00:13:27.574 --> 00:13:30.344 align:middle
星级表明基本上在所有其他情况下

00:13:30.410 --> 00:13:32.513 align:middle
在本例中应该是Watch OS

00:13:33.313 --> 00:13:34.781 align:middle
我们把它放在那里显性调用

00:13:34.848 --> 00:13:36.717 align:middle
潜在的流程控制

00:13:36.783 --> 00:13:39.953 align:middle
对于其他没有明显提及的平台

00:13:40.153 --> 00:13:42.489 align:middle
会执行指定条件

00:13:42.556 --> 00:13:45.158 align:middle
基本上是真和假

00:13:45.526 --> 00:13:47.828 align:middle
我们本想调用这些分支

00:13:47.895 --> 00:13:49.196 align:middle
它们仍将被采用

00:13:49.463 --> 00:13:51.031 align:middle
因此 我们想显性调用

00:13:51.098 --> 00:13:53.100 align:middle
可读性行为

00:13:54.668 --> 00:13:58.105 align:middle
现在可读性检测会在Swift 2中

00:13:58.172 --> 00:14:00.541 align:middle
自然构成用于控制流的可供性

00:13:58.172 --> 00:14:00.541 align:middle
自然构成用于控制流的可供性

00:14:01.375 --> 00:14:04.845 align:middle
比如 你之前已经构建了app 希望

00:14:04.912 --> 00:14:08.582 align:middle
进行这类检测 然后执行部分功能

00:14:08.849 --> 00:14:11.451 align:middle
否则什么都不做只要摆脱困境即可

00:14:12.653 --> 00:14:14.855 align:middle
这与新的保安声明相结合

00:14:16.223 --> 00:14:18.192 align:middle
可以像这样调整编码

00:14:18.559 --> 00:14:20.761 align:middle
保安声明下面的的所有内容

00:14:20.827 --> 00:14:22.529 align:middle
都有散列可用标签提供的

00:14:22.596 --> 00:14:23.830 align:middle
可用性

00:14:29.570 --> 00:14:33.340 align:middle
因此自然会找到方法

00:14:33.407 --> 00:14:34.975 align:middle
来构成应用的因素

00:14:36.944 --> 00:14:38.812 align:middle
比如
你之前已经在iOS 7上做过部署

00:14:39.880 --> 00:14:43.517 align:middle
我会把iOS 7中
可用的API代码染成绿色

00:14:43.917 --> 00:14:47.087 align:middle
绿色条代表代码块中

00:14:47.154 --> 00:14:50.057 align:middle
可以安全使用iOS 7或更早版本

00:14:50.123 --> 00:14:51.525 align:middle
因此这基本上是编译器

00:14:52.059 --> 00:14:53.193 align:middle
对世界的看法

00:14:54.661 --> 00:14:57.197 align:middle
如果我想用iOS 8 API
我已经把它的代码

00:14:57.264 --> 00:14:59.700 align:middle
涂成橙色
你需要对它进行可用性检测

00:14:59.766 --> 00:15:01.268 align:middle
否则 你会从编译器收到一个错误

00:14:59.766 --> 00:15:01.268 align:middle
否则 你会从编译器收到一个错误

00:15:01.902 --> 00:15:03.937 align:middle
你可以认为在代码块中

00:15:04.004 --> 00:15:05.706 align:middle
你有特权

00:15:05.772 --> 00:15:07.574 align:middle
决定什么API可以调用

00:15:09.176 --> 00:15:11.912 align:middle
一旦我出了代码块特权就不复存在

00:15:12.045 --> 00:15:14.114 align:middle
就只能调用iOS 7 API

00:15:15.148 --> 00:15:17.885 align:middle
如果我想调用iOS 9 API
我可以进行不同的检测

00:15:17.951 --> 00:15:20.254 align:middle
这会在代码块中提供不同范围的特权

00:15:20.320 --> 00:15:22.256 align:middle
它是极具可组合能力和可读性的模型

00:15:23.690 --> 00:15:25.692 align:middle
比如 我在根据

00:15:25.759 --> 00:15:29.162 align:middle
部分API是否可用构建

00:15:29.229 --> 00:15:31.532 align:middle
具备整套不同功能的app

00:15:32.099 --> 00:15:33.033 align:middle
我想对此进行分解

00:15:33.100 --> 00:15:36.270 align:middle
我不是只把一束代码加入条件语句

00:15:36.336 --> 00:15:38.305 align:middle
我希望把它分解放入不同的函数中

00:15:39.873 --> 00:15:40.841 align:middle
这很容易做到

00:15:41.375 --> 00:15:42.843 align:middle
可以声明另一个函数

00:15:42.910 --> 00:15:46.513 align:middle
比如出于教学目的
我的函数使用iOS 8

00:15:46.880 --> 00:15:50.450 align:middle
我准备从条件代码块中调用

00:15:51.652 --> 00:15:53.987 align:middle
问题在于编译器不知道

00:15:54.054 --> 00:15:55.122 align:middle
你要做什么要知道

00:15:55.189 --> 00:15:59.126 align:middle
只有完成检测才能调用这个

00:16:00.227 --> 00:16:02.196 align:middle
在默认状态下编译器会确认

00:16:02.763 --> 00:16:04.198 align:middle
你锁定iOS 7

00:16:04.264 --> 00:16:06.767 align:middle
我假设你在这个函数中 只使用

00:16:07.601 --> 00:16:08.468 align:middle
iOS 7 API

00:16:09.903 --> 00:16:13.173 align:middle
如果你想用iOS 8
API那么就要进行检测

00:16:14.842 --> 00:16:16.076 align:middle
这不太好 对吧？

00:16:16.143 --> 00:16:18.979 align:middle
这里并未提供方法来真正分析app

00:16:19.913 --> 00:16:21.615 align:middle
还会导致冗余检测

00:16:24.251 --> 00:16:26.119 align:middle
你可以告知编译器你的意图

00:16:27.621 --> 00:16:31.725 align:middle
这样SDK本身会有这些方法和类的

00:16:31.792 --> 00:16:33.360 align:middle
添加可用适应

00:16:33.427 --> 00:16:36.897 align:middle
称这是可以用于API的最小OS

00:16:36.964 --> 00:16:40.601 align:middle
在自己的代码上
也可以使用同样的注解

00:16:41.635 --> 00:16:44.805 align:middle
表示除非已经进行过适当的

00:16:44.872 --> 00:16:46.740 align:middle
可用性检测
否则不得调用该函数

00:16:47.608 --> 00:16:48.842 align:middle
一旦出现这种情况

00:16:50.177 --> 00:16:52.312 align:middle
编译器会以不同方式看待代码

00:16:53.814 --> 00:16:56.617 align:middle
然后可以完全删除检测

00:16:56.683 --> 00:17:00.287 align:middle
即额外的可用性检测
安全使用iOS 8 API

00:16:56.683 --> 00:17:00.287 align:middle
即额外的可用性检测
安全使用iOS 8 API

00:17:01.588 --> 00:17:02.656 align:middle
这可以组合使用

00:17:02.723 --> 00:17:05.192 align:middle
因为其他函数也有相似注解

00:17:05.259 --> 00:17:07.227 align:middle
如果函数有着相同的API特权

00:17:07.294 --> 00:17:10.631 align:middle
可以直接调用它们

00:17:11.431 --> 00:17:14.601 align:middle
如果在进行可用性检测时

00:17:14.701 --> 00:17:16.737 align:middle
想通过更多特权调用API

00:17:17.771 --> 00:17:20.773 align:middle
那么这样很方便构成 很容易理解

00:17:20.840 --> 00:17:22.742 align:middle
代码的构成方法

00:17:25.212 --> 00:17:27.614 align:middle
如大家的预期这也适用于方法

00:17:27.814 --> 00:17:30.150 align:middle
这样可以标注类为可用

00:17:30.417 --> 00:17:32.586 align:middle
但是具体方法 也许不可用

00:17:34.154 --> 00:17:37.958 align:middle
如果需要 你可以在调用更可用的

00:17:38.025 --> 00:17:40.260 align:middle
具体方法前 举例说明该类

00:17:40.327 --> 00:17:41.195 align:middle
你需要进行检测

00:17:43.163 --> 00:17:46.300 align:middle
在要求最小的可用性时 如果想标识

00:17:46.366 --> 00:17:48.168 align:middle
整个类的话这样会奏效

00:17:49.102 --> 00:17:52.639 align:middle
如果这样做 除非进行过可用性检测

00:17:52.706 --> 00:17:54.274 align:middle
否则甚至连举例说明类都不可能

00:17:55.042 --> 00:17:58.612 align:middle
那你会获得API可用性

00:17:58.879 --> 00:18:01.582 align:middle
完整的全部传递闭包

00:17:58.879 --> 00:18:01.582 align:middle
完整的全部传递闭包

00:18:02.883 --> 00:18:05.652 align:middle
这会自然引发 可以使用的更多技巧

00:18:07.521 --> 00:18:14.494 align:middle
比如
你已有较早版本中的自定义模糊视图

00:18:15.362 --> 00:18:21.468 align:middle
Apple会推出
更具体的UI视图子类

00:18:21.602 --> 00:18:22.836 align:middle
你想使用新版本

00:18:22.903 --> 00:18:25.806 align:middle
在主OS上使用它们

00:18:27.641 --> 00:18:30.377 align:middle
你想通过可用性保护实现这类

00:18:30.711 --> 00:18:34.715 align:middle
运行时间多态 那么如果你在

00:18:34.781 --> 00:18:38.151 align:middle
运行OS 要使用原生UI

00:18:38.585 --> 00:18:41.355 align:middle
否则就要使用自定义的

00:18:42.356 --> 00:18:43.790 align:middle
这样获得对象的客户端

00:18:43.857 --> 00:18:47.528 align:middle
并不需要在乎你运行的OS版本

00:18:47.861 --> 00:18:49.930 align:middle
到底是哪个

00:18:50.030 --> 00:18:52.666 align:middle
你已经完全提供了关注点的分离

00:18:54.001 --> 00:18:56.069 align:middle
当用到协议做同样的事情

00:18:56.136 --> 00:18:58.305 align:middle
效果会很好可提供不同的执行

00:18:58.372 --> 00:19:00.941 align:middle
可以有闭包不同的函数

00:18:58.372 --> 00:19:00.941 align:middle
可以有闭包不同的函数

00:19:01.275 --> 00:19:04.745 align:middle
可以实现完全不同的新方法分析代码

00:19:04.811 --> 00:19:06.346 align:middle
并获得你所期待的安全性

00:19:08.248 --> 00:19:10.651 align:middle
我们觉得可用性检测相当棒

00:19:11.251 --> 00:19:14.988 align:middle
我觉得它的确提供了具有凝结力

00:19:15.055 --> 00:19:20.460 align:middle
的安全方法来
使用新款API并部署到更早版本

00:19:21.195 --> 00:19:23.897 align:middle
统一的句法提供了真正安全的编程模型

00:19:24.665 --> 00:19:27.367 align:middle
但是更重要的是它提供了
正常分析app的方法

00:19:27.434 --> 00:19:28.635 align:middle
你可以阅读app

00:19:28.702 --> 00:19:31.572 align:middle
可以阅读代码并理解

00:19:31.638 --> 00:19:33.674 align:middle
可以期待不变性

00:19:34.441 --> 00:19:36.210 align:middle
我觉得这一点 非常强大

00:19:37.578 --> 00:19:39.413 align:middle
接下来我把讲台交给阿莱克斯

00:19:39.479 --> 00:19:42.449 align:middle
他来介绍使用
Swift强大类型系统的其他方法

00:19:42.516 --> 00:19:44.885 align:middle
以便在自己的应用中执行不变性

00:19:51.491 --> 00:19:52.392 align:middle
谢谢 泰德

00:19:52.459 --> 00:19:54.494 align:middle
大家好
我是阿莱克斯•米基科夫斯基

00:19:54.561 --> 00:19:56.063 align:middle
是Apple的示例编码员

00:19:56.797 --> 00:19:58.065 align:middle
在过去的一年半时间

00:19:58.498 --> 00:20:01.869 align:middle
我都在教开发人员如何用
Swift编写Cocoa app

00:19:58.498 --> 00:20:01.869 align:middle
我都在教开发人员如何用
Swift编写Cocoa app

00:20:03.036 --> 00:20:08.742 align:middle
我对于Swift
和Cocoa有着清晰的梦想

00:20:09.877 --> 00:20:13.046 align:middle
怎样才能让二者在一起实现安全的

00:20:13.113 --> 00:20:15.749 align:middle
编译时间 安全应用

00:20:17.150 --> 00:20:20.387 align:middle
今天我想介绍我已有部分想法

00:20:20.787 --> 00:20:22.689 align:middle
并解释大家可以从中使用的

00:20:22.756 --> 00:20:24.958 align:middle
部分范例并把这些概念

00:20:25.025 --> 00:20:27.661 align:middle
运用到各自的应用当中

00:20:27.761 --> 00:20:30.197 align:middle
这样你也可以编译时间安全代码

00:20:31.431 --> 00:20:34.234 align:middle
现在我还没有告知大家
但是在这些想法中

00:20:34.568 --> 00:20:36.770 align:middle
我还想到了独角兽

00:20:38.138 --> 00:20:40.007 align:middle
我开发了独角兽app来看一下

00:20:40.174 --> 00:20:45.312 align:middle
我设想的不同独角兽

00:20:47.014 --> 00:20:50.350 align:middle
首先 我想介绍我应用中的

00:20:51.018 --> 00:20:53.086 align:middle
Asset Catalog 标识符

00:20:53.153 --> 00:20:56.123 align:middle
每个人都在UIKit中用到它

00:20:57.457 --> 00:20:59.993 align:middle
我的独角兽浏览app相对简单

00:21:00.060 --> 00:21:04.398 align:middle
在Asset Catalog中
我已经加入3个独角兽图像

00:21:06.166 --> 00:21:09.136 align:middle
我现在想看看当我从
Asset Catalog生成图像

00:21:09.203 --> 00:21:12.406 align:middle
代码会是什么样

00:21:14.041 --> 00:21:15.776 align:middle
你会注意到

00:21:15.876 --> 00:21:18.312 align:middle
我在搭建的3个图像

00:21:18.812 --> 00:21:20.848 align:middle
每个图像我都向UIKit UI

00:21:20.914 --> 00:21:23.717 align:middle
图像API传递一个字符串

00:21:24.885 --> 00:21:30.190 align:middle
不知道Asset Catalog
UIKit实际上提供了怎样的资产

00:21:30.257 --> 00:21:31.725 align:middle
所以我必须打开这些图像

00:21:31.792 --> 00:21:34.161 align:middle
才能在应用中使用它们

00:21:35.162 --> 00:21:36.463 align:middle
非常不巧

00:21:36.530 --> 00:21:40.701 align:middle
因为已在Asset Catalog
定义Asset Catalog标识

00:21:40.767 --> 00:21:44.304 align:middle
我不希望这里出现重复信息

00:21:45.405 --> 00:21:49.243 align:middle
此外 这里我只会使用3个图像

00:21:50.177 --> 00:21:53.580 align:middle
可是在整个应用中我会用到许许多多

00:21:54.314 --> 00:21:58.085 align:middle
问题是很难找到你的代码中

00:21:58.185 --> 00:21:59.920 align:middle
是否有输入错误幻灯片上是

00:21:59.987 --> 00:22:02.890 align:middle
这些错误会引发的反应

00:21:59.987 --> 00:22:02.890 align:middle
这些错误会引发的反应

00:22:02.990 --> 00:22:05.325 align:middle
基于这些
你可能会希望进行修改我明白

00:22:05.826 --> 00:22:10.297 align:middle
但是确实很难回去把它们都找出来

00:22:10.364 --> 00:22:12.432 align:middle
那么经典的解决方案应该是有个

00:22:12.499 --> 00:22:14.101 align:middle
全局常数

00:22:14.401 --> 00:22:16.970 align:middle
这样可以在应用的各个地方使用

00:22:17.037 --> 00:22:17.938 align:middle
同样的常数

00:22:19.206 --> 00:22:21.008 align:middle
如果使用正确那就可以把独角兽

00:22:21.074 --> 00:22:23.610 align:middle
图像按照你的想法再找回来

00:22:23.677 --> 00:22:25.579 align:middle
但还是要打开图像 因为编译器

00:22:25.913 --> 00:22:27.748 align:middle
不清楚框架也不知道

00:22:27.814 --> 00:22:29.049 align:middle
你是否会

00:22:29.149 --> 00:22:31.552 align:middle
提供有效的常数名称

00:22:32.119 --> 00:22:35.522 align:middle
此外
可以提供随机的为API提供随机流

00:22:35.589 --> 00:22:40.060 align:middle
运行时间会出现致命错误

00:22:41.261 --> 00:22:44.298 align:middle
因为
NSUbiquity身份改变节点

00:22:44.364 --> 00:22:47.267 align:middle
通知还是字符串可以有效传递至

00:22:47.334 --> 00:22:49.469 align:middle
UI图像指定API

00:22:50.737 --> 00:22:52.840 align:middle
我们来看看怎样解决这个问题

00:22:54.174 --> 00:22:56.844 align:middle
我们要做的是严格的类型解决方案

00:22:56.910 --> 00:22:59.146 align:middle
我们在代码中将字符串传递到各处

00:22:59.746 --> 00:23:02.816 align:middle
我们希望的是强大的类型解决方案

00:22:59.746 --> 00:23:02.816 align:middle
我们希望的是强大的类型解决方案

00:23:04.551 --> 00:23:07.020 align:middle
希望可以将字符串映射到

00:23:07.087 --> 00:23:08.355 align:middle
新的类型

00:23:09.857 --> 00:23:13.026 align:middle
这会让我们编码解决

00:23:13.093 --> 00:23:15.529 align:middle
怎样搭建应用至

00:23:15.596 --> 00:23:17.064 align:middle
编辑器的信息

00:23:17.130 --> 00:23:20.434 align:middle
这样可以把非选择性UI图像

00:23:20.701 --> 00:23:21.702 align:middle
返回到代码的各处

00:23:23.203 --> 00:23:24.505 align:middle
解决方案就是

00:23:24.671 --> 00:23:28.141 align:middle
针对应用进行枚举

00:23:28.208 --> 00:23:30.544 align:middle
我们在应用中定义的枚举

00:23:31.545 --> 00:23:34.381 align:middle
如果来看之前定义的代码

00:23:35.449 --> 00:23:38.218 align:middle
我不希望代码是这幅样子

00:23:38.285 --> 00:23:42.789 align:middle
我想每次生成UI图像对象都传递枚举

00:23:42.856 --> 00:23:44.558 align:middle
这样我就不必

00:23:44.625 --> 00:23:48.095 align:middle
在代码中打开返回值

00:23:48.862 --> 00:23:50.397 align:middle
怎么实现呢？

00:23:51.665 --> 00:23:52.666 align:middle
首先我希望

00:23:52.733 --> 00:23:58.005 align:middle
定义UI图像的嵌套类型 以便在

00:23:58.071 --> 00:24:00.774 align:middle
枚举大小写
和Asset Catalog中

00:23:58.071 --> 00:24:00.774 align:middle
枚举大小写
和Asset Catalog中

00:24:01.141 --> 00:24:03.544 align:middle
定义的字符串表达之间提供

00:24:03.610 --> 00:24:04.745 align:middle
映射

00:24:05.979 --> 00:24:09.416 align:middle
我们将之定义为嵌套类型

00:24:09.917 --> 00:24:12.853 align:middle
这样可以存储在Asset
Catalog的其他资产

00:24:13.120 --> 00:24:14.922 align:middle
也可以使用这种方法

00:24:16.123 --> 00:24:18.225 align:middle
一旦这么做就非常简单

00:24:18.292 --> 00:24:22.229 align:middle
我可以在枚举大小写和字符串表达之间

00:24:22.296 --> 00:24:23.664 align:middle
提供大小写映射

00:24:24.164 --> 00:24:26.900 align:middle
对所有其他的情况也可以这样

00:24:28.101 --> 00:24:31.905 align:middle
这种方法的真正好处在于

00:24:31.972 --> 00:24:34.908 align:middle
如果我不小心有输入错误 如果

00:24:34.975 --> 00:24:37.444 align:middle
我不小心从什么地方复制粘贴了字符串

00:24:37.744 --> 00:24:39.646 align:middle
出现了重复编译器就会

00:24:39.713 --> 00:24:42.282 align:middle
警告或者报错 告诉我

00:24:42.616 --> 00:24:47.955 align:middle
在枚举中出现了重复问题

00:24:49.156 --> 00:24:52.125 align:middle
编译器可以这样帮忙 实在太好了

00:24:52.926 --> 00:24:54.795 align:middle
现在我们已经定义了新类型

00:24:54.862 --> 00:24:58.265 align:middle
我所需要做的就是
返回再编写便利初始化函数

00:24:58.332 --> 00:25:01.201 align:middle
其中使用这个枚举而不是字符串

00:24:58.332 --> 00:25:01.201 align:middle
其中使用这个枚举而不是字符串

00:25:01.502 --> 00:25:04.171 align:middle
并将枚举的原始值转至UIKit

00:25:04.438 --> 00:25:07.941 align:middle
定义的UI图像命名初始化函数

00:25:09.409 --> 00:25:11.278 align:middle
如果我们回来再看代码

00:25:11.378 --> 00:25:16.049 align:middle
可以把独角兽放在所希望的任何地方

00:25:16.116 --> 00:25:19.419 align:middle
如果我们再来看像以前
那样出现输入错误会怎样

00:25:19.486 --> 00:25:22.789 align:middle
现在编译器可以告知出现了输入错误

00:25:22.990 --> 00:25:24.725 align:middle
因为我们已经把应用结构的

00:25:24.992 --> 00:25:27.794 align:middle
信息编入了代码之中

00:25:28.729 --> 00:25:31.265 align:middle
如果修复这个问题
编译器错误也不复存在

00:25:32.933 --> 00:25:35.002 align:middle
我们来谈谈这么做的好处

00:25:37.671 --> 00:25:41.308 align:middle
首先是我们的常数位于中心

00:25:41.642 --> 00:25:45.078 align:middle
如果将新的
图像加入Asset Catalog

00:25:45.145 --> 00:25:49.316 align:middle
我准确知道该在哪里添加图像常数

00:25:50.918 --> 00:25:53.053 align:middle
还有一个好处是这样做不会污染

00:25:53.120 --> 00:25:54.354 align:middle
全局命名空间

00:25:54.421 --> 00:25:58.525 align:middle
我可以有在Asset
Catalog中定义的若干对象

00:25:58.592 --> 00:26:02.095 align:middle
可以在其中运用这个办法

00:25:58.592 --> 00:26:02.095 align:middle
可以在其中运用这个办法

00:26:03.530 --> 00:26:06.433 align:middle
最好的一点是 当构建UI图像对象时

00:26:06.500 --> 00:26:08.802 align:middle
在应用中可以只用这些

00:26:08.869 --> 00:26:11.071 align:middle
枚举情况中的一种

00:26:11.371 --> 00:26:13.340 align:middle
所以编译器可以帮你实现这点

00:26:13.707 --> 00:26:16.977 align:middle
现在你可以将非选择性图像返回到

00:26:17.044 --> 00:26:18.445 align:middle
代码中的任何地方 因此不必担心

00:26:18.512 --> 00:26:20.247 align:middle
强行打开的问题

00:26:20.547 --> 00:26:26.019 align:middle
这是我们在独角兽
浏览器app中所用的非常

00:26:26.086 --> 00:26:28.188 align:middle
独特的方式但我希望你们想想

00:26:28.255 --> 00:26:30.657 align:middle
怎样在自己的代码中使用枚举

00:26:30.724 --> 00:26:32.960 align:middle
以提供其他种类的富映射

00:26:33.961 --> 00:26:35.796 align:middle
你们可以不只是作为字符串使用

00:26:35.863 --> 00:26:37.898 align:middle
还可以使用整数甚至是选择器

00:26:38.265 --> 00:26:39.933 align:middle
有很多机会

00:26:40.000 --> 00:26:42.569 align:middle
在自己的代码中定义这些映射

00:26:44.404 --> 00:26:49.409 align:middle
现在来深入探讨枚举 但是我想

00:26:49.476 --> 00:26:52.446 align:middle
先说说联线标识符

00:26:52.513 --> 00:26:54.915 align:middle
因为在代码中始终要

00:26:54.982 --> 00:26:55.983 align:middle
使用到它

00:26:57.251 --> 00:27:00.320 align:middle
现在 我的想法越发强烈

00:26:57.251 --> 00:27:00.320 align:middle
现在 我的想法越发强烈

00:27:00.387 --> 00:27:03.390 align:middle
我必须研制出一款app
让我真正跟踪

00:27:03.824 --> 00:27:06.159 align:middle
独角兽 并在运行中下载它们

00:27:07.361 --> 00:27:09.162 align:middle
我有更复杂的应用

00:27:09.563 --> 00:27:12.032 align:middle
如果来看故事板

00:27:12.432 --> 00:27:13.901 align:middle
就会变得非常简单

00:27:14.568 --> 00:27:16.970 align:middle
我只有单独的视图控制器 可以

00:27:17.037 --> 00:27:18.739 align:middle
联线其他两个视图控制器

00:27:19.206 --> 00:27:23.544 align:middle
对于所有这些视图控制器而言

00:27:23.610 --> 00:27:25.312 align:middle
我定义了一个联线标识符

00:27:26.580 --> 00:27:29.550 align:middle
我需要看看当我们覆盖

00:27:29.616 --> 00:27:32.419 align:middle
联线准备来配置独角兽浏览器

00:27:32.486 --> 00:27:34.788 align:middle
视图将呈现的

00:27:34.922 --> 00:27:37.724 align:middle
视图控制器时 代码会是什么样

00:27:40.327 --> 00:27:43.197 align:middle
我们覆盖了这种方法 执行这一点的

00:27:43.263 --> 00:27:45.365 align:middle
经典办法是打开

00:27:45.432 --> 00:27:48.502 align:middle
联线标识符字符串

00:27:49.369 --> 00:27:53.674 align:middle
现在 在我使用完全相同的字符串之前

00:27:53.740 --> 00:27:56.810 align:middle
我是按照故事板中的联线定义的字符串

00:27:57.344 --> 00:27:59.179 align:middle
编辑器对此还一无所知

00:27:59.513 --> 00:28:02.316 align:middle
当我只打开这两个字符串时

00:27:59.513 --> 00:28:02.316 align:middle
当我只打开这两个字符串时

00:28:02.482 --> 00:28:03.784 align:middle
编译器会告诉我

00:28:04.418 --> 00:28:07.454 align:middle
这并非是穷尽性检测

00:28:07.521 --> 00:28:10.891 align:middle
我必须加入默认情况
因为编译器不知道

00:28:11.558 --> 00:28:14.461 align:middle
我已经提供了有效映射

00:28:15.863 --> 00:28:18.332 align:middle
但是如果我加入了新的视图控制器

00:28:19.166 --> 00:28:22.369 align:middle
必须有个全新的联线 那会怎样？

00:28:22.870 --> 00:28:24.271 align:middle
我怎么才能知道在代码中

00:28:24.338 --> 00:28:25.939 align:middle
哪里需要改变 这个逻辑？

00:28:27.241 --> 00:28:29.810 align:middle
我们来看看再次通过枚举

00:28:29.877 --> 00:28:31.912 align:middle
该怎么解决这个问题

00:28:33.280 --> 00:28:36.917 align:middle
我定义了独角兽浏览器
视图控制器的嵌套类型

00:28:36.984 --> 00:28:38.485 align:middle
它将代表联线标识符的情况

00:28:38.552 --> 00:28:41.021 align:middle
和故事板字符串表达

00:28:41.321 --> 00:28:44.825 align:middle
之间的映射

00:28:45.459 --> 00:28:48.595 align:middle
我们来看 怎么实现用更强大的类型

00:28:48.662 --> 00:28:51.932 align:middle
联线方法准备

00:28:53.600 --> 00:28:54.801 align:middle
首先 我要做的是

00:28:54.868 --> 00:28:57.337 align:middle
从故事板联线对象抓取联线

00:28:57.404 --> 00:28:59.139 align:middle
标识符字符串

00:29:00.240 --> 00:29:02.476 align:middle
并从原始值中构建联线

00:29:02.543 --> 00:29:03.677 align:middle
识别符枚举

00:29:05.412 --> 00:29:07.181 align:middle
我还会提供部分运行时间

00:29:07.247 --> 00:29:09.883 align:middle
检测调试以防我并未

00:29:09.950 --> 00:29:13.353 align:middle
为新的联线识别符 提供有效的

00:29:13.420 --> 00:29:15.355 align:middle
枚举情况

00:29:16.290 --> 00:29:19.660 align:middle
从这里
我可以打开枚举 而不是字符串

00:29:20.394 --> 00:29:23.564 align:middle
这非常棒 因为我必须打开

00:29:23.630 --> 00:29:27.835 align:middle
两种情况 编译器知道我在枚举中

00:29:27.901 --> 00:29:31.605 align:middle
只定义了两种情况
所以我必须在代码中打开

00:29:33.807 --> 00:29:37.711 align:middle
如果我们在枚举中
添加了新的联线标识符

00:29:38.579 --> 00:29:40.747 align:middle
编译器就会告知 我们并未

00:29:41.114 --> 00:29:45.853 align:middle
进行穷尽性转换以便我们在枚举中

00:29:45.919 --> 00:29:49.122 align:middle
打开的代码各处

00:29:49.590 --> 00:29:51.291 align:middle
编译器就会告诉我们

00:29:51.358 --> 00:29:52.826 align:middle
在哪里更新逻辑

00:29:53.327 --> 00:29:56.763 align:middle
这对字符串解决方案来说
是个极大的好处

00:29:58.665 --> 00:30:01.602 align:middle
我们可以这样重写联线准备

00:29:58.665 --> 00:30:01.602 align:middle
我们可以这样重写联线准备

00:30:02.202 --> 00:30:05.305 align:middle
但是 有时需要通过标识符

00:30:05.372 --> 00:30:06.740 align:middle
人工启动执行联线

00:30:08.242 --> 00:30:11.144 align:middle
在本例中 我想要引入一束独角兽

00:30:11.211 --> 00:30:14.214 align:middle
下载它们在Web上 下载图像

00:30:14.281 --> 00:30:15.916 align:middle
显示新的视图控制器

00:30:16.383 --> 00:30:18.485 align:middle
我们来看看 这些代码是什么样子

00:30:20.254 --> 00:30:23.690 align:middle
那么经典的解决方案是将字符串

00:30:23.757 --> 00:30:26.326 align:middle
传递至带有标识符方式的执行联线

00:30:27.694 --> 00:30:29.563 align:middle
我们已经定义了这种枚举

00:30:29.630 --> 00:30:30.964 align:middle
我们只是想使用已经提供的

00:30:31.031 --> 00:30:32.099 align:middle
这种映射

00:30:32.666 --> 00:30:34.368 align:middle
相反 我们想用枚举

00:30:35.769 --> 00:30:36.603 align:middle
怎么做呢？

00:30:36.670 --> 00:30:38.205 align:middle
其实 非常简单

00:30:38.272 --> 00:30:43.777 align:middle
我们可以通过标识符方法定义
UIKit定义执行联线

00:30:44.111 --> 00:30:46.613 align:middle
的过载其中采用了枚举
而不是字符串

00:30:47.381 --> 00:30:53.220 align:middle
然后用枚举的原始值
调用UIKit 定义方法

00:30:53.854 --> 00:30:58.025 align:middle
如果我们返回用枚举调用

00:30:58.825 --> 00:31:02.196 align:middle
方法的代码
它完全是按照我们的预期运转

00:30:58.825 --> 00:31:02.196 align:middle
方法的代码
它完全是按照我们的预期运转

00:31:03.130 --> 00:31:05.232 align:middle
这就是针对独角兽浏览器视图

00:31:05.299 --> 00:31:07.000 align:middle
控制器的绝佳解决方案

00:31:07.935 --> 00:31:09.870 align:middle
但是如果再复杂一点会怎样？

00:31:11.171 --> 00:31:13.807 align:middle
我希望看看我们刚才做的结构

00:31:13.874 --> 00:31:15.542 align:middle
看怎样才能把它应用到

00:31:15.609 --> 00:31:17.911 align:middle
独角兽浏览器以外的视图控制器

00:31:20.314 --> 00:31:22.549 align:middle
我们做的是在枚举情况

00:31:22.616 --> 00:31:25.452 align:middle
及其故事板上的字符串表达之间

00:31:25.519 --> 00:31:26.453 align:middle
提供映射

00:31:27.387 --> 00:31:30.123 align:middle
我们还增加了使用该映射的

00:31:30.257 --> 00:31:33.093 align:middle
执行 以便获得应用中

00:31:33.160 --> 00:31:36.930 align:middle
更强大的类型系统

00:31:37.831 --> 00:31:39.299 align:middle
但如果我们增添新的视图控制器

00:31:39.366 --> 00:31:40.801 align:middle
我们希望做同样的事情

00:31:40.968 --> 00:31:45.339 align:middle
需要不得不复制
所有那些工作我不希望这么做

00:31:46.840 --> 00:31:50.944 align:middle
我真正想做的是从视图控制器提取

00:31:51.211 --> 00:31:54.982 align:middle
执行 并定义松散映射
因为联线标识符的枚举

00:31:55.048 --> 00:31:59.253 align:middle
会具体针对视图控制器

00:31:59.319 --> 00:32:03.090 align:middle
通过这样做 我们可以为多种

00:31:59.319 --> 00:32:03.090 align:middle
通过这样做 我们可以为多种

00:32:03.156 --> 00:32:05.058 align:middle
视图控制器使用该执行

00:32:05.526 --> 00:32:09.830 align:middle
不论其类层次如何

00:32:09.897 --> 00:32:12.299 align:middle
通过重复使用这个执行
可以避免许多

00:32:13.100 --> 00:32:15.769 align:middle
糟糕的类层次

00:32:17.004 --> 00:32:20.007 align:middle
我们会通过协议 来实现这一点

00:32:20.974 --> 00:32:22.409 align:middle
所以我定义了一个新的协议

00:32:22.476 --> 00:32:24.211 align:middle
我们会称之为联线处理类型

00:32:24.745 --> 00:32:26.280 align:middle
我们的视图控制器需要与它

00:32:26.346 --> 00:32:27.181 align:middle
相一致

00:32:28.515 --> 00:32:31.518 align:middle
我希望定义刚提到的映射

00:32:32.085 --> 00:32:34.521 align:middle
现在它将成为联线标识符枚举

00:32:35.389 --> 00:32:38.325 align:middle
我们希望确保联线标识符和

00:32:38.392 --> 00:32:40.327 align:middle
原始可显示协议相一致

00:32:41.261 --> 00:32:44.831 align:middle
这个协议是个关于各类型支持的

00:32:44.898 --> 00:32:48.535 align:middle
枚举的重要执行细节

00:32:49.369 --> 00:32:52.539 align:middle
编译器可以自动为你合成

00:32:53.841 --> 00:32:56.543 align:middle
关于协议定义就是这些

00:32:57.711 --> 00:33:00.714 align:middle
我现在
需要用Swift 2.0的功能

00:32:57.711 --> 00:33:00.714 align:middle
我现在
需要用Swift 2.0的功能

00:33:00.781 --> 00:33:02.482 align:middle
受限制的协议扩展

00:33:02.916 --> 00:33:04.818 align:middle
来实际添加将成为我们的

00:33:05.018 --> 00:33:06.920 align:middle
泛性可重用代码的执行

00:33:07.821 --> 00:33:10.657 align:middle
我们将扩展联线处理类型

00:33:11.325 --> 00:33:12.693 align:middle
接下来我们对之加以限制

00:33:12.759 --> 00:33:15.195 align:middle
如果这些限制条件满足的话
我们只想让执行

00:33:16.830 --> 00:33:18.799 align:middle
加入其中

00:33:19.533 --> 00:33:23.070 align:middle
第一个限制条件是满足协议的类型为

00:33:23.136 --> 00:33:26.139 align:middle
UI视图控制器子类

00:33:26.540 --> 00:33:27.841 align:middle
这将会让我们在协议扩展中

00:33:27.908 --> 00:33:30.010 align:middle
调用UI视图

00:33:30.544 --> 00:33:31.812 align:middle
控制器方法

00:33:33.013 --> 00:33:35.115 align:middle
第二点是我们想确定

00:33:35.182 --> 00:33:38.051 align:middle
联线标识符映射是位于

00:33:38.118 --> 00:33:40.821 align:middle
映射情况和字符串之间

00:33:42.689 --> 00:33:45.425 align:middle
我们已经定义了
有限制条件的协议扩展

00:33:45.492 --> 00:33:47.494 align:middle
我们所需要做的就是添加执行

00:33:48.195 --> 00:33:51.198 align:middle
我们要通过之前定义的标识符

00:33:51.265 --> 00:33:55.002 align:middle
采用联线现有执行

00:33:55.602 --> 00:33:58.872 align:middle
并将完全相同的执行加入代码

00:34:00.807 --> 00:34:03.277 align:middle
如果我们返回
独角兽浏览器视图控制器

00:34:03.710 --> 00:34:06.947 align:middle
我们只需在新类型中加入一致性

00:34:08.014 --> 00:34:11.217 align:middle
我们已经满足了协议的所有
相关类型限制条件

00:34:11.318 --> 00:34:15.155 align:middle
因为我们已经识别了这个联线

00:34:15.222 --> 00:34:16.056 align:middle
标识符枚举

00:34:17.591 --> 00:34:21.360 align:middle
如果我们进入处理行为方法 我们可以

00:34:21.428 --> 00:34:26.166 align:middle
用完全相同的方式调用代码
但我们在联线处理类型中重用执行

00:34:27.568 --> 00:34:29.770 align:middle
我们可以这样通过标识符方式

00:34:29.837 --> 00:34:35.007 align:middle
重用表现联线
但是要是调用联线准备

00:34:35.242 --> 00:34:36.510 align:middle
或联线处理准备会怎样？

00:34:37.811 --> 00:34:40.547 align:middle
我需要定义便捷方式

00:34:40.614 --> 00:34:42.882 align:middle
其中会采用故事板对象

00:34:43.350 --> 00:34:46.520 align:middle
并返回联线标识符枚举

00:34:46.587 --> 00:34:47.855 align:middle
这是在协议扩展中完成

00:34:49.188 --> 00:34:53.092 align:middle
我要再次做的是使用之前定义的执行

00:34:55.295 --> 00:34:56.964 align:middle
返回我们用代码

00:34:57.030 --> 00:34:59.867 align:middle
生成的联线标识符枚举

00:35:00.901 --> 00:35:03.070 align:middle
如果来看为联线方式所做准备

00:35:03.136 --> 00:35:05.739 align:middle
结果就变得非常简单

00:35:06.807 --> 00:35:10.043 align:middle
我们所需要做的就是通过联线的

00:35:10.110 --> 00:35:13.514 align:middle
联线识别符 打开结果返回
这是我们刚定义的方法我们只需要提供

00:35:14.248 --> 00:35:19.086 align:middle
两种情况打开方法和之前的完全相同

00:35:19.987 --> 00:35:21.355 align:middle
但是我们有这个泛型解决方案

00:35:22.489 --> 00:35:24.558 align:middle
我们来谈谈这么做的好处

00:35:27.094 --> 00:35:31.965 align:middle
当我们将之添加到
联线标识符枚举中时

00:35:32.165 --> 00:35:34.201 align:middle
编译器完全了解我们在故事板上

00:35:34.268 --> 00:35:36.069 align:middle
定义的联线

00:35:37.137 --> 00:35:38.705 align:middle
可以确保我们在代码中

00:35:38.772 --> 00:35:40.541 align:middle
处理了所有可能的情况

00:35:41.808 --> 00:35:46.113 align:middle
通过使用协议扩展
我们具有可重新使用的解决方案

00:35:46.180 --> 00:35:49.516 align:middle
我们可以在符合
新协议的任何视图

00:35:49.583 --> 00:35:51.084 align:middle
控制器上使用这个执行

00:35:52.519 --> 00:35:54.521 align:middle
我们还有便捷句法

00:35:54.922 --> 00:35:57.958 align:middle
可以在不同的

00:35:59.826 --> 00:36:01.128 align:middle
视图控制器上使用方法句法

00:35:59.826 --> 00:36:01.128 align:middle
视图控制器上使用方法句法

00:36:01.195 --> 00:36:02.796 align:middle
不一定必须是 自由函数

00:36:04.064 --> 00:36:07.601 align:middle
这是在独角兽浏览器app中
可以使用协议和

00:36:07.668 --> 00:36:10.771 align:middle
有限制方式的协议扩展的

00:36:11.104 --> 00:36:13.574 align:middle
独特方式但是大家都有
许多其他有趣应用

00:36:13.941 --> 00:36:14.908 align:middle
我想让大家做的是思考一下

00:36:14.975 --> 00:36:18.846 align:middle
怎样在自己的应用中使用协议和

00:36:19.112 --> 00:36:22.516 align:middle
相关类型限制条件来编码部分

00:36:22.583 --> 00:36:25.552 align:middle
应用的结构到编译器这样它可以帮你

00:36:26.019 --> 00:36:27.387 align:middle
实现编译时间安全性

00:36:28.488 --> 00:36:30.524 align:middle
我想让你们想想

00:36:30.591 --> 00:36:32.259 align:middle
怎样使用协议扩展

00:36:32.593 --> 00:36:35.462 align:middle
在自己的应用中分享执行

00:36:35.863 --> 00:36:39.066 align:middle
避免一系列糟糕的类层次问题

00:36:41.201 --> 00:36:45.272 align:middle
泰德和我今天说得够多了
但是希望大家从中领会到

00:36:45.339 --> 00:36:47.140 align:middle
编译器是来帮助大家的

00:36:49.142 --> 00:36:52.946 align:middle
泰德说的是如何在新API中
安全利用这一点

00:36:53.280 --> 00:36:55.649 align:middle
现在 这可以通过编译器大部分完成

00:36:56.316 --> 00:36:59.586 align:middle
编译器知道有什么这不是具体针对

00:36:59.987 --> 00:37:01.522 align:middle
哪个OS的版本

00:36:59.987 --> 00:37:01.522 align:middle
哪个OS的版本

00:37:02.856 --> 00:37:05.926 align:middle
我和大家介绍的是应用的强大类型

00:37:05.993 --> 00:37:07.761 align:middle
强迫应用实现不变性

00:37:08.028 --> 00:37:09.396 align:middle
并利用编译器

00:37:09.730 --> 00:37:11.698 align:middle
让它知道应用的限制条件

00:37:11.765 --> 00:37:15.002 align:middle
并把这些信息编入代码

00:37:15.435 --> 00:37:17.971 align:middle
这样编译器可以帮你分析

00:37:18.038 --> 00:37:20.340 align:middle
编译时间的问题而不是在运行时间

00:37:21.875 --> 00:37:23.143 align:middle
若要了解更多详情

00:37:23.210 --> 00:37:29.149 align:middle
建议大家在线观看
《基于协议的Swift编程》

00:37:29.983 --> 00:37:33.620 align:middle
讲座 如果你自己对
Cocoa和Swift

00:37:33.687 --> 00:37:35.789 align:middle
有明晰的梦想建议你仔细看看
这两个示例

00:37:35.856 --> 00:37:40.093 align:middle
编目示例有联线
处理类型协议的实例

00:37:40.394 --> 00:37:41.562 align:middle
DemoBots使用了

00:37:41.628 --> 00:37:45.866 align:middle
在协议中使用
枚举的一系列有趣方法

00:37:47.100 --> 00:37:48.402 align:middle
实现编译时间安全性

00:37:49.269 --> 00:37:51.138 align:middle
若要了解更多详情可以查看

00:37:51.205 --> 00:37:53.006 align:middle
Swift Language
Documentation

00:37:53.073 --> 00:37:55.676 align:middle
我们还有开发人员论坛如有任何问题

00:37:55.742 --> 00:37:56.877 align:middle
你们也可以联系斯特凡

00:37:57.211 --> 00:38:00.013 align:middle
感谢大家希望能在实验室见到大家
