WEBVTT

00:00:20.120 --> 00:00:25.392 align:middle
面向协议 编程序Swift

00:00:34.234 --> 00:00:39.473 align:middle
大家好 我叫戴夫·亞伯拉罕
我是Swift标准库的技术主管

00:00:39.540 --> 00:00:44.144 align:middle
今天站在这里同你们一起是我的荣幸

00:00:44.678 --> 00:00:46.113 align:middle
很高兴看到房间里的你们

00:00:47.548 --> 00:00:49.283 align:middle
接下来的40分钟请

00:00:49.983 --> 00:00:53.320 align:middle
丢掉你们通常思考编程的方式

00:00:55.122 --> 00:00:58.659 align:middle
我们接下来要一起做的事情不一定容易

00:00:58.725 --> 00:01:02.162 align:middle
但我向你们保证如果你们跟着
我的思路这一定是值得的

00:00:58.725 --> 00:01:02.162 align:middle
但我向你们保证如果你们跟着
我的思路这一定是值得的

00:01:04.331 --> 00:01:06.400 align:middle
我现在来和你们谈一谈

00:01:06.733 --> 00:01:11.705 align:middle
Swift设计核心的主题
并介绍一种编程方式

00:01:11.905 --> 00:01:13.607 align:middle
这种编程方式有可能改变一切

00:01:15.075 --> 00:01:17.845 align:middle
但首先请允许我先向你们
介绍我的一位朋友

00:01:20.581 --> 00:01:21.748 align:middle
他是 Crusty

00:01:23.483 --> 00:01:26.286 align:middle
现在可能你们每个人
都正在使用这个家伙的某一个版本

00:01:26.453 --> 00:01:29.256 align:middle
Crusty是个老式的程序员

00:01:29.723 --> 00:01:34.761 align:middle
他不相信调试器不使用集成开发环境

00:01:35.028 --> 00:01:37.564 align:middle
不 他喜欢 80x24的终端窗口

00:01:37.631 --> 00:01:39.366 align:middle
和纯文本 非常感谢

00:01:42.736 --> 00:01:45.506 align:middle
他对最近的编程时尚不以为然

00:01:46.773 --> 00:01:49.309 align:middle
现在我已经学会期待 Crusty

00:01:49.376 --> 00:01:51.979 align:middle
有点愤世嫉俗脾气古怪

00:01:52.446 --> 00:01:55.382 align:middle
但是即便如此有时仍会令我惊讶

00:01:55.883 --> 00:01:59.253 align:middle
比如上个月我们正在讨论应用开发

00:01:59.753 --> 00:02:03.090 align:middle
他坦率地说“我不做面向对象”

00:01:59.753 --> 00:02:03.090 align:middle
他坦率地说“我不做面向对象”

00:02:05.158 --> 00:02:06.627 align:middle
我不敢相信我的耳朵

00:02:07.060 --> 00:02:09.830 align:middle
我的意思是面向对象程序设计

00:02:09.896 --> 00:02:11.298 align:middle
大约起源于20世纪70年代

00:02:11.865 --> 00:02:15.269 align:middle
所以它并不能算是新奇的编程时尚

00:02:15.769 --> 00:02:22.242 align:middle
此外我们一起构建的
很多神奇的东西 我 你 还有那些

00:02:22.876 --> 00:02:26.947 align:middle
我们所站在其肩膀上的工程师们
都由对象构建而成

00:02:28.949 --> 00:02:31.952 align:middle
“来吧”我边走向他的老式黑板边说

00:02:32.286 --> 00:02:35.489 align:middle
“面向对象程序设计棒极了
看看你可以使用类做些什么”

00:02:41.161 --> 00:02:41.995 align:middle
是的

00:02:43.697 --> 00:02:47.234 align:middle
所以首先你可以把
相关数据和操作进行分组

00:02:48.202 --> 00:02:53.207 align:middle
然后就可以建造墙壁将我们的代码内外

00:02:53.607 --> 00:02:56.076 align:middle
分开这样就可以使我们保持不变量

00:02:58.879 --> 00:03:05.118 align:middle
然后我们使用类来
表达相关想法如窗口或通信信道

00:02:58.879 --> 00:03:05.118 align:middle
然后我们使用类来
表达相关想法如窗口或通信信道

00:03:07.988 --> 00:03:12.326 align:middle
它们给我们一个命名空间用于帮助
避免随着软件扩展所带来的冲突

00:03:15.796 --> 00:03:18.031 align:middle
它们有惊人的表达语法

00:03:18.332 --> 00:03:22.769 align:middle
所以我们可以写方法调用和属性
并把它们链接起来

00:03:23.003 --> 00:03:24.304 align:middle
我们可以做下标

00:03:25.339 --> 00:03:27.741 align:middle
我们甚至可以做属性用于计算

00:03:30.244 --> 00:03:32.946 align:middle
最后类的扩展性是开放的

00:03:33.280 --> 00:03:36.149 align:middle
所以如果类作者遗漏了
一些我需要用到的东西

00:03:36.483 --> 00:03:38.085 align:middle
我可以继续向前并在后续将其添加上

00:03:39.019 --> 00:03:41.588 align:middle
此外这些事物一起

00:03:42.990 --> 00:03:44.725 align:middle
这些事物使我们能够管理复杂的事物

00:03:45.392 --> 00:03:47.561 align:middle
而这正是程序设计中最主要的挑战

00:03:49.496 --> 00:03:54.301 align:middle
这些属性它们直接解决了
我们正在努力解决的软件开发中的问题

00:03:55.702 --> 00:03:57.838 align:middle
在这一点上我自己颇受启发

00:03:58.172 --> 00:04:02.409 align:middle
然而 Crusty
只是哼了一声叹了口气

00:03:58.172 --> 00:04:02.409 align:middle
然而 Crusty
只是哼了一声叹了口气

00:04:05.812 --> 00:04:07.214 align:middle
他让我十分泄气

00:04:09.516 --> 00:04:12.753 align:middle
如果这还不够糟糕的话
片刻之后他完成了这个句子

00:04:15.389 --> 00:04:17.357 align:middle
因为这是真的在Swift

00:04:17.891 --> 00:04:21.195 align:middle
任何一种你可以说出的
类型都是一等公民

00:04:21.562 --> 00:04:24.898 align:middle
它能够利用所有这些功能

00:04:26.800 --> 00:04:28.335 align:middle
所以我后退了一步并试图

00:04:29.002 --> 00:04:34.875 align:middle
找出使我们完成的所有事情运行的
核心功能在面向对象程序设计中

00:04:36.777 --> 00:04:42.382 align:middle
很显然它一定是来自于只能用
类来处理的某些事物

00:04:42.716 --> 00:04:44.084 align:middle
比如继承

00:04:46.253 --> 00:04:48.021 align:middle
这让我特别考虑

00:04:48.088 --> 00:04:51.491 align:middle
这些结构是如何做到代码共享

00:04:51.825 --> 00:04:53.393 align:middle
及细密定制的

00:04:54.761 --> 00:04:58.565 align:middle
因此，举个例子一个超类可以定义
一个实质的具有复杂逻辑的方法

00:04:58.632 --> 00:05:03.470 align:middle
而子类无偿得到超类已完成的所有工作

00:04:58.632 --> 00:05:03.470 align:middle
而子类无偿得到超类已完成的所有工作

00:05:04.938 --> 00:05:06.039 align:middle
它们只是继承了这些内容

00:05:07.207 --> 00:05:10.911 align:middle
但真正不可思议的事
发生在当超类的作者

00:05:10.978 --> 00:05:12.980 align:middle
把这个操作的一小部分断为

00:05:13.413 --> 00:05:15.282 align:middle
独立的定制点

00:05:17.651 --> 00:05:18.952 align:middle
这些定制点可被子类覆盖

00:05:20.087 --> 00:05:23.690 align:middle
且这种定制被覆盖在继承的实现上

00:05:25.559 --> 00:05:27.060 align:middle
这使得困难的逻辑

00:05:27.127 --> 00:05:31.798 align:middle
在具备开放的灵活性
和特殊变化的同时可被重新使用

00:05:32.099 --> 00:05:33.800 align:middle
现在我确信我可以说服他

00:05:34.401 --> 00:05:35.936 align:middle
“哈”我对 Crusty 说

00:05:36.170 --> 00:05:39.673 align:middle
“很显然现在你不得不
臣服于类的力量了”

00:05:42.976 --> 00:05:45.412 align:middle
“再坚持该死的一分钟”他回答说

00:05:46.180 --> 00:05:50.350 align:middle
“首先我用你一直说的结构做定制

00:05:51.084 --> 00:05:55.055 align:middle
其次 对 类是很厉害
但让我们来谈一谈用类所需要的代价

00:06:00.427 --> 00:06:04.565 align:middle
我已经有三个重要的
关于类的牢骚”Crusty 说

00:06:05.632 --> 00:06:07.367 align:middle
然后他从列表上开始了抱怨

00:06:08.769 --> 00:06:10.537 align:middle
“首先你有了你的自动共享”

00:06:11.638 --> 00:06:13.106 align:middle
现在你们都知道这是什么样子的

00:06:14.174 --> 00:06:18.178 align:middle
A传递给B一些看起来完全清晰的数据

00:06:20.013 --> 00:06:21.882 align:middle
然后B想“好 会话结束”

00:06:22.983 --> 00:06:25.886 align:middle
但现在我们有一种情形

00:06:26.286 --> 00:06:32.359 align:middle
A和B都有他们自己非常合理的世界观
而这恰好是错误的

00:06:33.994 --> 00:06:39.466 align:middle
因为现实是这样的 最终A厌恶了

00:06:39.533 --> 00:06:42.069 align:middle
严肃的数据取而代之喜欢小马

00:06:42.936 --> 00:06:44.137 align:middle
谁不喜欢一匹好的小马？

00:06:46.440 --> 00:06:50.911 align:middle
一切都很好直到B之后发现了这些数据

00:06:51.044 --> 00:06:53.113 align:middle
很久之后她从A那里得到

00:06:54.014 --> 00:06:55.415 align:middle
且已有一个令人吃惊的变化

00:06:57.284 --> 00:06:59.353 align:middle
B 想要的是她的数据
而不是 A 的小马

00:07:01.054 --> 00:07:03.824 align:middle
好 Crusty 激昂地讲着
这是如何结束的

00:07:06.460 --> 00:07:09.296 align:middle
“首先”他说“你开始疯狂地复制一切

00:07:09.363 --> 00:07:10.864 align:middle
镇压你代码中的错误

00:07:11.131 --> 00:07:12.833 align:middle
但现在你现在做了太多的副本

00:07:13.300 --> 00:07:14.701 align:middle
而这拖慢了代码的运行速度

00:07:15.068 --> 00:07:17.571 align:middle
然后有一天你正在处理
某个调度队列中的事情

00:07:17.838 --> 00:07:19.873 align:middle
突然你进入了一种紊乱状态下

00:07:20.107 --> 00:07:21.975 align:middle
因为线程正在共享可变状态

00:07:22.442 --> 00:07:25.312 align:middle
所以你开始添加锁以保护不变量

00:07:26.180 --> 00:07:28.382 align:middle
但是这些锁更加拖延了代码的运行速度

00:07:28.682 --> 00:07:30.083 align:middle
甚至可能导致死锁

00:07:30.350 --> 00:07:32.286 align:middle
所有的这些都在增加复杂度

00:07:32.586 --> 00:07:36.290 align:middle
其结果可总结为一个词 故障”

00:07:39.259 --> 00:07:41.595 align:middle
不过这些对于Cocoa的
程序员来说都不是新闻

00:07:50.304 --> 00:07:54.041 align:middle
这不是新闻这些年我们已经
在应用一种语言特征的组合

00:07:54.107 --> 00:07:56.910 align:middle
像@property(copy)和编码约定

00:07:56.977 --> 00:07:58.879 align:middle
来解决这个问题

00:08:01.114 --> 00:08:02.216 align:middle
而我们仍然被咬

00:08:03.183 --> 00:08:04.418 align:middle
举个例子

00:08:05.118 --> 00:08:07.321 align:middle
在Cocoa文件中有这样一个警告

00:08:07.521 --> 00:08:10.791 align:middle
关于修改一个可变集合
在你通过它进行迭代时

00:08:12.092 --> 00:08:16.330 align:middle
对吧 所有这些都是由

00:08:16.430 --> 00:08:19.600 align:middle
从类中继承的可变状态的
隐式共享导致的

00:08:21.468 --> 00:08:23.470 align:middle
但这并不适用于Swift

00:08:25.272 --> 00:08:30.878 align:middle
为什么不适用呢？
这是因为Swift集合都是数值类型

00:08:31.512 --> 00:08:32.679 align:middle
所以你正在迭代的这些

00:08:32.746 --> 00:08:34.481 align:middle
和你正在修改的这些是截然不同的

00:08:36.616 --> 00:08:39.385 align:middle
好 Crusty 列表上的第二条

00:08:40.554 --> 00:08:42.222 align:middle
类继承太具有侵入性

00:08:44.157 --> 00:08:48.795 align:middle
首先 它太庞大你有且仅有一个超类

00:08:49.897 --> 00:08:52.232 align:middle
那么假使你需要塑造
多个抽象将会怎样？

00:08:52.699 --> 00:08:56.103 align:middle
可以是一个集合并序列化吗？

00:08:57.137 --> 00:08:59.973 align:middle
当然 除非集合和序列化是类

00:09:01.508 --> 00:09:04.211 align:middle
因为类继承是单继承

00:09:04.745 --> 00:09:08.715 align:middle
类变得臃肿随着所有
相关的事情被放在一起

00:09:09.349 --> 00:09:14.922 align:middle
你也不得不选择超类在你定义类时
而非在后续某些扩展时

00:09:16.790 --> 00:09:20.027 align:middle
其次如果超类存储了属性

00:09:22.596 --> 00:09:23.463 align:middle
你必须接受它们

00:09:24.531 --> 00:09:25.399 align:middle
并且别无选择

00:09:26.733 --> 00:09:29.736 align:middle
然后因为它存储了属性

00:09:30.337 --> 00:09:31.271 align:middle
你必须将其初始化

00:09:32.506 --> 00:09:36.009 align:middle
然后就像 Crusty 所说
“指定便利是必须的 噢天哪”

00:09:37.578 --> 00:09:39.713 align:middle
因此你又必须确信你理解如何

00:09:39.780 --> 00:09:43.383 align:middle
与超类相互作用而不破坏它的常量

00:09:44.218 --> 00:09:48.856 align:middle
对吗 最后对于类作者来说这很自然

00:09:49.523 --> 00:09:53.627 align:middle
写代码就好像他们知道他们的方法

00:09:54.862 --> 00:10:00.501 align:middle
将会做些什么 不用对
方法可能被覆盖负责任

00:09:54.862 --> 00:10:00.501 align:middle
将会做些什么 不用对
方法可能被覆盖负责任

00:10:02.402 --> 00:10:06.573 align:middle
因此经常有至关紧要却有不成文的约定

00:10:06.874 --> 00:10:08.709 align:middle
关于哪些实际是允许

00:10:08.775 --> 00:10:13.480 align:middle
覆盖的以及比如你是否需要
链接到超类方法

00:10:13.747 --> 00:10:16.016 align:middle
如果你要链接到超类方法

00:10:16.316 --> 00:10:19.019 align:middle
那么位置是在方法的开头还是在结尾
抑或是在中间的某处呢

00:10:23.624 --> 00:10:26.693 align:middle
所以，再一次对于Cocoa的
程序设计员来说仍然不是新闻 对吗

00:10:26.994 --> 00:10:30.464 align:middle
这就是为什么我们到处使用
委托模式在Cocoa

00:10:33.033 --> 00:10:35.335 align:middle
好 Crusty 列表上的最后一条

00:10:36.803 --> 00:10:42.776 align:middle
类被证明完全不适合于
类型关系很重要的问题

00:10:44.611 --> 00:10:46.880 align:middle
所以如果你曾经尝试过使用类

00:10:47.214 --> 00:10:51.752 align:middle
来表达一个对称操作
比如比较你知道我的意思

00:10:53.020 --> 00:10:56.857 align:middle
举个例子假设你打算写通用分类

00:10:56.924 --> 00:11:00.327 align:middle
或二进位检索类似这样
你需要一种方法来比较两个元素

00:10:56.924 --> 00:11:00.327 align:middle
或二进位检索类似这样
你需要一种方法来比较两个元素

00:11:00.928 --> 00:11:03.664 align:middle
使用类你最终得到像这样的一些结果

00:11:05.566 --> 00:11:08.602 align:middle
当然你不能用这种
方法只写Ordered

00:11:08.969 --> 00:11:11.371 align:middle
因为Swift会预先要求方法体

00:11:13.707 --> 00:11:14.908 align:middle
那么我们可以放些什么呢？

00:11:16.143 --> 00:11:20.347 align:middle
请记得我们对于Ordered
的任意示例还一无所知

00:11:21.715 --> 00:11:24.318 align:middle
所以如果这个方法没有由子类实现

00:11:25.352 --> 00:11:27.688 align:middle
那么除了陷阱我们什么都做不了

00:11:29.857 --> 00:11:33.493 align:middle
现在这是表明我们可以
对抗类型系统的第一个迹象

00:11:35.095 --> 00:11:36.463 align:middle
如果我们没有认识到这一点

00:11:36.930 --> 00:11:38.932 align:middle
这也是我们欺骗自己的开始

00:11:40.734 --> 00:11:43.136 align:middle
因为我们对这个问题置之不理告诉自己

00:11:43.203 --> 00:11:45.038 align:middle
只要每个Ordered子类

00:11:45.105 --> 00:11:47.307 align:middle
预先执行一切都会好的

00:11:48.809 --> 00:11:51.445 align:middle
对吗？让它成为子类的问题

00:11:52.779 --> 00:11:55.883 align:middle
如此我们继续进行
执行Ordered的一个例子

00:11:57.951 --> 00:11:59.019 align:middle
所以这就是子类

00:11:59.386 --> 00:12:01.121 align:middle
它得到一个双精度类型值

00:11:59.386 --> 00:12:01.121 align:middle
它得到一个双精度类型值

00:12:01.455 --> 00:12:04.925 align:middle
我们覆盖优先来做比较

00:12:06.927 --> 00:12:08.529 align:middle
当然除去它不起作用的情况

00:12:11.231 --> 00:12:14.067 align:middle
看“其它”只是某些任意的
Ordered

00:12:14.434 --> 00:12:16.970 align:middle
不是一个数字因此我们不知道

00:12:17.037 --> 00:12:19.806 align:middle
“其他”有数值属性

00:12:20.440 --> 00:12:22.543 align:middle
事实上它可能是个标签

00:12:23.143 --> 00:12:24.311 align:middle
具有文本属性

00:12:26.013 --> 00:12:28.215 align:middle
所以现在我们需要向
下转型以得到正确的类型

00:12:30.984 --> 00:12:34.121 align:middle
但是等一下假设“其它”
结果是一个标签？

00:12:35.989 --> 00:12:36.990 align:middle
现在我们将要陷阱

00:12:39.059 --> 00:12:42.930 align:middle
对吗 所以这听起来很像

00:12:43.030 --> 00:12:47.267 align:middle
我们在预先写方法体时
遇到的问题在超类中

00:12:49.937 --> 00:12:52.272 align:middle
并且我们现在没有比之前更好的答案

00:12:53.674 --> 00:12:55.242 align:middle
这是静态类型安全漏洞

00:12:56.643 --> 00:12:57.878 align:middle
它为什么会发生？

00:12:58.745 --> 00:13:02.282 align:middle
这是因为类不让我们表达
这种至关紧要的类型关系

00:12:58.745 --> 00:13:02.282 align:middle
这是因为类不让我们表达
这种至关紧要的类型关系

00:13:02.349 --> 00:13:05.853 align:middle
自身的类型和其他的类型之间的关系

00:13:07.688 --> 00:13:09.590 align:middle
事实上你可以把这个用作
“代码异味”

00:13:10.591 --> 00:13:13.794 align:middle
所以任何时候你在
代码中看到强制的向下转型

00:13:14.561 --> 00:13:17.998 align:middle
这很好地象征了有些重要的
类型关系已经丢失

00:13:18.632 --> 00:13:21.535 align:middle
而这通常是由于抽象类的使用所造成的

00:13:23.904 --> 00:13:28.675 align:middle
好 显然我们需要的是更好的抽象机制

00:13:30.711 --> 00:13:33.614 align:middle
不强制我们接受隐式共享

00:13:34.147 --> 00:13:35.983 align:middle
不丢失类型关系

00:13:36.750 --> 00:13:39.586 align:middle
不强制我们只选择一种抽象且

00:13:39.653 --> 00:13:41.321 align:middle
在定义类型时进行选择

00:13:42.456 --> 00:13:45.626 align:middle
不强制我们接受不想要的实例数据

00:13:46.193 --> 00:13:48.862 align:middle
以及相关的初始化复杂度

00:13:51.398 --> 00:13:55.335 align:middle
最后不会留下模棱两可
关于需要覆盖什么

00:13:57.304 --> 00:13:58.705 align:middle
当然我正在讲述的便是协议

00:13:59.940 --> 00:14:03.544 align:middle
协议有所有这些优势这就是为什么

00:13:59.940 --> 00:14:03.544 align:middle
协议有所有这些优势这就是为什么

00:14:03.777 --> 00:14:07.981 align:middle
我们创造Swift时也就是我们创造
第一个面向协议的程序设计语言

00:14:17.791 --> 00:14:21.195 align:middle
是的 Swift是很棒的
面向对象程序设计

00:14:21.762 --> 00:14:25.399 align:middle
但从循环和字符串的工作方式

00:14:25.799 --> 00:14:28.502 align:middle
到泛型标准库的重点

00:14:28.936 --> 00:14:31.238 align:middle
其核心Swift是面向协议的

00:14:33.040 --> 00:14:34.608 align:middle
希望到你离开时

00:14:35.042 --> 00:14:36.977 align:middle
你可以更加面向协议

00:14:40.447 --> 00:14:42.182 align:middle
所以为使你迈出右脚开始

00:14:42.616 --> 00:14:43.917 align:middle
我们在Swift有一种说法

00:14:44.451 --> 00:14:45.552 align:middle
不要从类开始

00:14:46.086 --> 00:14:47.254 align:middle
而要从协议开始

00:14:48.856 --> 00:14:50.424 align:middle
那么让我们来做一下上一个例子

00:14:53.393 --> 00:14:58.165 align:middle
好 首先我们需要一个协议
Swift马上会说

00:14:58.332 --> 00:15:00.200 align:middle
我们不可以在这儿放方法体

00:14:58.332 --> 00:15:00.200 align:middle
我们不可以在这儿放方法体

00:15:01.468 --> 00:15:03.437 align:middle
而这实际上是很好的因为这意味着

00:15:03.504 --> 00:15:07.541 align:middle
我们要以动态运行时间检查换

00:15:08.041 --> 00:15:09.076 align:middle
静态检查

00:15:10.577 --> 00:15:12.412 align:middle
对 在完成时预先执行

00:15:15.282 --> 00:15:20.487 align:middle
好 接下来它会说我们
没有覆盖任何东西

00:15:21.388 --> 00:15:22.222 align:middle
当然我们没有

00:15:22.689 --> 00:15:24.558 align:middle
我们不再有基类 对吗

00:15:24.658 --> 00:15:26.059 align:middle
没有超类 没有覆盖

00:15:27.461 --> 00:15:29.696 align:middle
我们可能根本不希望数字首先是类

00:15:29.763 --> 00:15:31.832 align:middle
因为我们希望它像数字一样操作

00:15:32.699 --> 00:15:37.571 align:middle
对吗 那么让我们马上来做
两件事情把这做成一个结构

00:15:39.940 --> 00:15:43.043 align:middle
好 我想在这儿暂停一下

00:15:43.110 --> 00:15:46.046 align:middle
欣赏一下我们现在来到何处
因为这又是完全有效的代码了

00:15:48.081 --> 00:15:51.051 align:middle
好 协议正完全扮演着相同的角色

00:15:51.585 --> 00:15:55.556 align:middle
就像在我们这个例子的
第一个版本中类的角色一样

00:15:56.223 --> 00:15:57.491 align:middle
这绝对更好

00:15:57.658 --> 00:16:00.294 align:middle
我的意思是我们不再有那致命的错误

00:15:57.658 --> 00:16:00.294 align:middle
我的意思是我们不再有那致命的错误

00:16:01.328 --> 00:16:04.164 align:middle
但是我们没有定位潜在的
静态类型安全漏洞

00:16:04.798 --> 00:16:07.100 align:middle
因为我们仍然需要强制的向下转型

00:16:07.601 --> 00:16:10.838 align:middle
因为“其他”仍然是
某些任意的Ordered

00:16:12.606 --> 00:16:16.643 align:middle
那么让我们用数字替代丢掉类型转换

00:16:19.346 --> 00:16:22.416 align:middle
现在Swift要说签名不匹配

00:16:25.452 --> 00:16:30.324 align:middle
为解决这个问题 我们需要在协议签名
中用Self来替代Ordered

00:16:33.126 --> 00:16:34.661 align:middle
我们称之为Self要求

00:16:35.729 --> 00:16:39.132 align:middle
因此当你在协议中看到Self

00:16:39.433 --> 00:16:42.736 align:middle
它是类型的占位符用来符合
那个协议模型类型

00:16:45.005 --> 00:16:46.573 align:middle
如此现在我们又有了有效的代码了

00:16:47.641 --> 00:16:49.843 align:middle
现在让我们看一下如何使用协议

00:16:53.580 --> 00:16:57.584 align:middle
所以这是二进位检索

00:16:58.919 --> 00:17:03.223 align:middle
它也能够完美运行在我们向
Ordered加入Self要求之前

00:16:58.919 --> 00:17:03.223 align:middle
它也能够完美运行在我们向
Ordered加入Self要求之前

00:17:04.724 --> 00:17:08.795 align:middle
这里的Ordered数组是一个声明

00:17:10.163 --> 00:17:14.268 align:middle
声明我们要处理
Ordered类型的异构数组

00:17:14.734 --> 00:17:18.638 align:middle
因此这个数组可以混合包含数字

00:17:19.138 --> 00:17:21.141 align:middle
与标签 对吧

00:17:23.010 --> 00:17:26.146 align:middle
由于我们对
Ordered做了这个改变

00:17:26.213 --> 00:17:28.482 align:middle
向其添加了Self需求编译器将

00:17:28.549 --> 00:17:33.754 align:middle
强制将其变为同构的 像这样

00:17:35.923 --> 00:17:41.662 align:middle
这个人说“我在使用任意一个
Ordered类型T的同构数组”

00:17:43.864 --> 00:17:45.666 align:middle
现在你可能会想强制使数组

00:17:45.732 --> 00:17:48.702 align:middle
成为同构数组这太限制了

00:17:48.769 --> 00:17:51.939 align:middle
或者有些失去了泛函性或灵活性或其他

00:17:52.339 --> 00:17:53.407 align:middle
但是如果你想一下

00:17:54.041 --> 00:17:56.310 align:middle
原始的签名真的是个谎言

00:17:56.910 --> 00:18:00.981 align:middle
我们从没真正处理过异构情况
除了通过陷阱的方式

00:17:56.910 --> 00:18:00.981 align:middle
我们从没真正处理过异构情况
除了通过陷阱的方式

00:18:01.515 --> 00:18:05.485 align:middle
对吧 同构数组正是我们要的

00:18:08.589 --> 00:18:11.725 align:middle
那么一旦你在协议中添加Self要求

00:18:12.192 --> 00:18:15.462 align:middle
这将使协议进入一个非常不同的世界

00:18:16.230 --> 00:18:21.134 align:middle
在这里功能中大大减少了类的重复

00:18:22.703 --> 00:18:24.638 align:middle
它不再作为类型使用

00:18:26.073 --> 00:18:30.444 align:middle
集合从异构变为同构

00:18:32.012 --> 00:18:37.951 align:middle
实例之间的相互作用不再意味着
所有模型类型之间的相互作用

00:18:40.020 --> 00:18:43.323 align:middle
我们以动多态换静多态

00:18:43.891 --> 00:18:47.060 align:middle
但是作为我们传递给
编译器的额外的类型信息的回报

00:18:47.127 --> 00:18:49.029 align:middle
这样更具可优化性

00:18:50.697 --> 00:18:52.165 align:middle
所以 两个世界

00:18:54.101 --> 00:18:56.236 align:middle
在后续的演讲中我将向你们演示如何

00:18:56.303 --> 00:18:58.272 align:middle
在两者之间搭桥至少一种方式

00:18:59.606 --> 00:19:01.074 align:middle
好

00:18:59.606 --> 00:19:01.074 align:middle
好

00:19:02.442 --> 00:19:07.247 align:middle
我理解了协议静态方面的工作原理

00:19:07.314 --> 00:19:11.585 align:middle
但我还不确定是否
要相信Crusty

00:19:11.652 --> 00:19:14.421 align:middle
协议真的可以取代类

00:19:14.855 --> 00:19:18.492 align:middle
所以我给他设了一个挑战

00:19:19.092 --> 00:19:22.496 align:middle
构建我们通常使用面向
对象程序设计的事物但是要用协议

00:19:24.965 --> 00:19:26.567 align:middle
我脑海中浮现一个小的图表应用

00:19:26.834 --> 00:19:31.772 align:middle
你可以在绘图界面拖拽落成形状
然后可以与它们交互

00:19:32.806 --> 00:19:36.310 align:middle
所以我让 Crusty
构建文档并显示模型

00:19:37.344 --> 00:19:38.345 align:middle
这是他想出来的

00:19:41.281 --> 00:19:43.016 align:middle
首先他构建了一些基本绘图

00:19:43.650 --> 00:19:44.852 align:middle
现在你可以想象

00:19:44.918 --> 00:19:46.620 align:middle
Crusty并不是在做图形用户界面

00:19:46.920 --> 00:19:47.988 align:middle
相较而言他更倾向文本

00:19:48.989 --> 00:19:52.626 align:middle
他的基本绘图只是
输出了你提出的绘图命令 对吗？

00:19:53.126 --> 00:19:56.330 align:middle
我不情愿地承认了这很可能足以

00:19:56.396 --> 00:20:01.435 align:middle
证明他的观点
然后他新建了Drawable协议

00:19:56.396 --> 00:20:01.435 align:middle
证明他的观点
然后他新建了Drawable协议

00:20:01.835 --> 00:20:05.873 align:middle
为我们的所有绘图元素提供通用接口

00:20:06.840 --> 00:20:08.242 align:middle
好 这很简单了

00:20:09.610 --> 00:20:12.279 align:middle
然后他开始创建形状比如多边形

00:20:14.114 --> 00:20:17.484 align:middle
现在这里需要注意的第一件事
关于多边形这是一个数值类型

00:20:18.218 --> 00:20:19.786 align:middle
由其他数值类型创建而成

00:20:20.487 --> 00:20:23.056 align:middle
这是一个包含多点数组的结构

00:20:24.191 --> 00:20:27.761 align:middle
为了画一个多边形
我们来到最后一个拐角

00:20:28.195 --> 00:20:30.931 align:middle
然后我们在所有交角处重复循环 画线

00:20:32.966 --> 00:20:33.834 align:middle
好 下面是圆

00:20:35.335 --> 00:20:38.639 align:middle
同样的圆也是一个数值类型
由其他数值类型创建而成

00:20:38.705 --> 00:20:42.042 align:middle
它是包含中心和半径的结构

00:20:43.310 --> 00:20:46.513 align:middle
现在为了画一个圆

00:20:46.613 --> 00:20:48.215 align:middle
我们从0到2π弧度拽出一个弧形

00:20:51.818 --> 00:20:55.822 align:middle
那么现在我们就可以
通过圆和多边形来创建图表了

00:20:59.092 --> 00:21:01.361 align:middle
“好的” Crusty 说
“我们来将她做个旋转”

00:20:59.092 --> 00:21:01.361 align:middle
“好的” Crusty 说
“我们来将她做个旋转”

00:21:05.365 --> 00:21:06.200 align:middle
他这么做了

00:21:07.568 --> 00:21:08.402 align:middle
接下来就是图表

00:21:10.003 --> 00:21:13.207 align:middle
图表就是一个Drawable类
这是另一个数值类型

00:21:14.241 --> 00:21:17.044 align:middle
它为什么是数值类型呢？这是因为所有
Drawable类都是数值类型

00:21:17.110 --> 00:21:19.479 align:middle
因此Drawable类的
数组也是数值类型

00:21:19.680 --> 00:21:20.848 align:middle
让我们回到之前的话题

00:21:26.486 --> 00:21:27.354 align:middle
好 这里

00:21:28.422 --> 00:21:34.995 align:middle
因此由于这是我的图表中唯一的事物
这个图表也是数值类型

00:21:36.663 --> 00:21:38.899 align:middle
因此要绘制它我们只需要遍历所有

00:21:38.966 --> 00:21:41.969 align:middle
元素并画下来每一个元素

00:21:43.737 --> 00:21:45.639 align:middle
好 现在来作一个旋转

00:21:47.040 --> 00:21:48.175 align:middle
那么 我们要测试一下

00:21:52.646 --> 00:21:54.948 align:middle
所以Crusty新建了一个圆

00:21:55.015 --> 00:21:58.652 align:middle
以非常特别的中心和半径

00:21:59.086 --> 00:22:02.389 align:middle
然后以神秘的Spock一般的精度

00:21:59.086 --> 00:22:02.389 align:middle
然后以神秘的Spock一般的精度

00:22:02.923 --> 00:22:03.891 align:middle
他添加了一个三角形

00:22:05.092 --> 00:22:09.263 align:middle
最后他在其周围创建了
一个图表并让它绘制

00:22:13.133 --> 00:22:14.801 align:middle
“瞧”Crusty 耀武扬威地说

00:22:15.135 --> 00:22:20.674 align:middle
“就像你能明白地看到的
这是一个带圆的等边三角形内切于圆”

00:22:21.808 --> 00:22:25.612 align:middle
也许我不擅长在脑海中做三角学问题

00:22:25.679 --> 00:22:29.449 align:middle
不像 Crusty 那样
但是“不 Crusty ”我说

00:22:29.516 --> 00:22:30.984 align:middle
“我不能很明白地看到这些

00:22:31.385 --> 00:22:33.487 align:middle
我会觉得这个延时更加有趣

00:22:33.554 --> 00:22:35.689 align:middle
如果我做一些实际有用的

00:22:35.889 --> 00:22:38.592 align:middle
比如给我们的应用 画到屏幕上”

00:22:40.460 --> 00:22:41.995 align:middle
我从烦恼中恢复过来之后

00:22:42.429 --> 00:22:46.266 align:middle
我决定使用
CoreGraphics重写渲染器

00:22:49.970 --> 00:22:51.371 align:middle
我告诉他我将要做这些

00:22:51.705 --> 00:22:54.208 align:middle
他说“再等一会儿猴小子

00:22:55.676 --> 00:22:58.078 align:middle
如果你这样做了
我还怎样测试我代码呢？”

00:23:01.348 --> 00:23:04.051 align:middle
然后他展现了一个很有说服力的案例

00:23:04.117 --> 00:23:06.286 align:middle
在测试中使用纯文本

00:23:06.720 --> 00:23:09.723 align:middle
如果我们正在做的
事情中发生了某些改变

00:23:10.190 --> 00:23:12.726 align:middle
我们可以立马在输出中看到

00:23:14.127 --> 00:23:16.129 align:middle
然而他提出我们做一点

00:23:16.330 --> 00:23:17.631 align:middle
面向协议的程序设计

00:23:19.533 --> 00:23:23.136 align:middle
然后他复制了他的
渲染器然后将其写入协议中

00:23:28.942 --> 00:23:32.613 align:middle
然后你必须删除主体 好

00:23:33.080 --> 00:23:37.918 align:middle
这就是了 然后他重命名了
原始的渲染器并将它改为一致

00:23:41.455 --> 00:23:43.924 align:middle
现在 所有的代码重构使得
我变得不耐烦

00:23:43.991 --> 00:23:46.560 align:middle
因为我很想在屏幕上看到这些东西

00:23:47.861 --> 00:23:50.998 align:middle
我想抢过来实现
CoreGraphics的渲染器

00:23:51.765 --> 00:23:54.601 align:middle
但我必须等到
Crusty 再次测试他的代码

00:23:56.069 --> 00:23:58.172 align:middle
等到他终于满意了他说“好了

00:23:59.640 --> 00:24:01.141 align:middle
你打算在渲染器中放些什么呢？”

00:23:59.640 --> 00:24:01.141 align:middle
你打算在渲染器中放些什么呢？”

00:24:02.809 --> 00:24:04.778 align:middle
我说“一个CGContext

00:24:05.212 --> 00:24:08.649 align:middle
CGContext
基本有渲染器需要的一切”

00:24:09.816 --> 00:24:13.020 align:middle
实际上在纯C语言接口范围内

00:24:13.587 --> 00:24:14.755 align:middle
它基本就是一个渲染器

00:24:16.690 --> 00:24:18.659 align:middle
“好” Crusty 说
“把键盘给我”

00:24:18.859 --> 00:24:20.794 align:middle
他从我这儿夺去某样东西然后

00:24:20.861 --> 00:24:23.730 align:middle
极快地做了某些事情
太快以至于我都没有看到做了些什么

00:24:32.673 --> 00:24:33.774 align:middle
“等一下”我说

00:24:35.742 --> 00:24:39.446 align:middle
“你刚刚只是把每个
CGContext写入渲染器吗？”

00:24:41.615 --> 00:24:44.251 align:middle
他...我是说它什么也没做

00:24:45.118 --> 00:24:48.222 align:middle
但是这有些令人吃惊
我甚至不需要添加一种新的类型

00:24:51.058 --> 00:24:52.559 align:middle
“你还在等什么？Crusty说

00:24:52.626 --> 00:24:53.927 align:middle
“在那些大括号中填入内容”

00:24:55.028 --> 00:24:57.631 align:middle
所以我把必要的
CoreGraphics粘着都倒了进去

00:24:57.931 --> 00:25:01.368 align:middle
把所有都扔进了游戏场 这就是了

00:24:57.931 --> 00:25:01.368 align:middle
把所有都扔进了游戏场 这就是了

00:25:02.736 --> 00:25:04.638 align:middle
现在你可以下载这个游戏场

00:25:05.072 --> 00:25:07.708 align:middle
它演示了我在这儿演讲的所有内容

00:25:07.774 --> 00:25:09.710 align:middle
在我们结束之后

00:25:12.713 --> 00:25:13.814 align:middle
不过还是回到我们的例子

00:25:14.915 --> 00:25:17.618 align:middle
为了干扰我Crusty之后做了这些

00:25:20.754 --> 00:25:23.257 align:middle
现在我需要花一点时间了解为什么绘制

00:25:23.323 --> 00:25:25.025 align:middle
在这个点上没有进入无线循环

00:25:26.226 --> 00:25:27.694 align:middle
如果你想了解更多的话

00:25:28.095 --> 00:25:31.031 align:middle
你可以听一下周五的讲习会

00:25:34.234 --> 00:25:36.270 align:middle
但这也并没有改变显示

00:25:37.471 --> 00:25:39.873 align:middle
最终Crusty决定向我
演示正在发生的事情

00:25:39.940 --> 00:25:41.341 align:middle
在他的纯文本输出中

00:25:42.242 --> 00:25:45.946 align:middle
然后事实证明它只
重复了相同的绘制命令

00:25:48.382 --> 00:25:49.216 align:middle
两次

00:25:49.750 --> 00:25:52.686 align:middle
所以作为一个更面向图形的家伙

00:25:52.753 --> 00:25:54.788 align:middle
我很想看到结果

00:25:55.355 --> 00:25:59.793 align:middle
所以我创建了一个小
比例的适配器并用它包裹住图表

00:26:00.761 --> 00:26:03.564 align:middle
这就是结果

00:26:04.031 --> 00:26:08.268 align:middle
你可以在游戏场看到这些所以我不打算
在这儿深究小比例适配器

00:26:11.471 --> 00:26:13.173 align:middle
不过这也是一种

00:26:14.241 --> 00:26:16.543 align:middle
使用协议的演示我们可以做到所有

00:26:16.610 --> 00:26:18.378 align:middle
与使用类可以做到的相同的事情

00:26:18.712 --> 00:26:21.114 align:middle
适配器通常设计模式

00:26:22.816 --> 00:26:25.819 align:middle
好 现在我想反思一下

00:26:25.886 --> 00:26:27.921 align:middle
使用TestRenderer
都做了些什么

00:26:28.522 --> 00:26:29.957 align:middle
因为它事实上是有些杰出的

00:26:32.526 --> 00:26:36.363 align:middle
通过从特定的渲染器中解耦文件模型

00:26:36.964 --> 00:26:40.100 align:middle
他能够插入检测组件

00:26:40.534 --> 00:26:44.905 align:middle
以显示我们正在做的一切
我们的代码正在做的一切详细地

00:26:46.773 --> 00:26:49.209 align:middle
后来我们就在我们的
代码中应用了这种方法

00:26:50.244 --> 00:26:53.146 align:middle
我们发现我们使用协议解耦的事物越多

00:26:53.514 --> 00:26:54.982 align:middle
所有的事物的可测性就越强

00:26:56.517 --> 00:26:57.551 align:middle
这种测试与

00:26:57.951 --> 00:27:01.822 align:middle
使用mock测试得到的结果很像
但这样做更好

00:26:57.951 --> 00:27:01.822 align:middle
使用mock测试得到的结果很像
但这样做更好

00:27:03.090 --> 00:27:04.958 align:middle
mock测试本质上是脆弱的

00:27:07.327 --> 00:27:08.996 align:middle
你需要结合测试中的代码

00:27:09.062 --> 00:27:11.465 align:middle
测试代码的实现细节

00:27:13.100 --> 00:27:16.003 align:middle
正因这种脆弱性它们无法与

00:27:16.069 --> 00:27:18.105 align:middle
Swift 强大的静态类型
系统很好地融合

00:27:20.641 --> 00:27:23.510 align:middle
协议给我们提供了有原则的接口

00:27:23.810 --> 00:27:26.146 align:middle
以供使用这由语言进行实施

00:27:26.680 --> 00:27:30.450 align:middle
但仍会给我们hook以插入所有
我们所需要的检测设备

00:27:32.853 --> 00:27:36.790 align:middle
好 回到我们的例子
因为我们现在需要认真地

00:27:36.857 --> 00:27:37.958 align:middle
讨论一下Bubbles

00:27:40.027 --> 00:27:42.396 align:middle
好我们希望这个图表
应用受孩子们的欢迎

00:27:42.462 --> 00:27:44.631 align:middle
当然孩子们喜欢
Bubbles(气泡)

00:27:45.132 --> 00:27:51.138 align:middle
因此在图表中Bubbles
只是一个内部圆圈偏移量

00:27:51.972 --> 00:27:54.308 align:middle
围绕外围圆圈中心

00:27:55.475 --> 00:27:57.010 align:middle
以此来表现加亮区

00:27:57.845 --> 00:27:58.745 align:middle
所以你有两个圆

00:27:59.479 --> 00:28:00.314 align:middle
就像这样

00:27:59.479 --> 00:28:00.314 align:middle
就像这样

00:28:02.015 --> 00:28:03.917 align:middle
当我把这段代码放到上下文

00:28:03.984 --> 00:28:06.086 align:middle
Crusty 开始变得很激动

00:28:07.120 --> 00:28:09.056 align:middle
所有的代码副本都使他抓狂

00:28:09.723 --> 00:28:11.859 align:middle
如果 Crusty 不高兴
那么没有人可以高兴

00:28:15.095 --> 00:28:18.165 align:middle
“瞧 他们都是完整的圆”他喊道
“我只想写这段”

00:28:19.166 --> 00:28:21.335 align:middle
我说“冷静Crusty冷静

00:28:22.069 --> 00:28:22.903 align:middle
我们可以这么做

00:28:24.171 --> 00:28:28.208 align:middle
我们需要做的就是
再添加一个协议的要求

00:28:29.810 --> 00:28:32.880 align:middle
然后当然我们更新模型来供应它

00:28:33.780 --> 00:28:34.882 align:middle
我们有测试渲染器

00:28:36.250 --> 00:28:37.684 align:middle
然后还有 CGContext”

00:28:39.720 --> 00:28:42.556 align:middle
现在这个点上
Crusty 脱掉了鞋子

00:28:42.623 --> 00:28:45.926 align:middle
拿它敲着桌子因为这里
我们又一次在重复代码

00:28:47.194 --> 00:28:49.630 align:middle
他从我这里把键盘夺了回来抱怨着

00:28:49.696 --> 00:28:51.498 align:middle
说所有的事情都需要他自己完成

00:28:53.066 --> 00:28:55.936 align:middle
他开始教我使用
Swift的一个新特征

00:29:00.440 --> 00:29:01.909 align:middle
这就是协议扩展

00:29:03.277 --> 00:29:05.712 align:middle
据说“渲染器的所有模型

00:29:05.779 --> 00:29:08.248 align:middle
都有circleAt的这个实现”

00:29:09.516 --> 00:29:14.354 align:middle
现在我们有一种实现
渲染器的所有模型都在共享这种实现

00:29:15.022 --> 00:29:18.859 align:middle
注意到我们仍有这个
circleAt 要求在那里

00:29:19.493 --> 00:29:20.994 align:middle
你可能会问“有要求意味着什么？

00:29:21.061 --> 00:29:25.165 align:middle
这个要求也可以在扩展中立即实现”

00:29:26.366 --> 00:29:27.201 align:middle
很好的问题

00:29:28.101 --> 00:29:32.472 align:middle
答案是协议要求新建定制点

00:29:35.876 --> 00:29:38.178 align:middle
为了见证这是如何表现的
让我们先推翻这种方法体

00:29:38.712 --> 00:29:40.547 align:middle
而在扩展中添加另一种方法

00:29:40.848 --> 00:29:43.450 align:middle
添加一种不被要求支持的方法

00:29:45.819 --> 00:29:48.755 align:middle
现在我们可以扩展Crusty的

00:29:49.022 --> 00:29:51.458 align:middle
来实现这两个方法

00:29:54.862 --> 00:29:55.963 align:middle
然后我们只需要调用它们

00:29:57.965 --> 00:30:01.702 align:middle
好 现在发生的事情完全不会令人吃惊

00:29:57.965 --> 00:30:01.702 align:middle
好 现在发生的事情完全不会令人吃惊

00:30:02.202 --> 00:30:04.872 align:middle
我们直接调用
TestRender中的实现

00:30:05.806 --> 00:30:08.408 align:middle
而协议并没有参与其中 对吧？

00:30:08.909 --> 00:30:12.312 align:middle
如果我们删除这种一致性
我们将得到相同的结果

00:30:17.251 --> 00:30:18.919 align:middle
不过现在我们修改下上下文

00:30:18.986 --> 00:30:22.289 align:middle
这样Swift就只知道它是一个渲染器
而不是 TestRenderer

00:30:26.226 --> 00:30:27.160 align:middle
来看一下发生了什么

00:30:28.228 --> 00:30:30.497 align:middle
所以因为circleAt是要求

00:30:31.331 --> 00:30:34.001 align:middle
我们的模型获得了定制它的特权

00:30:34.401 --> 00:30:35.769 align:middle
然后定制被调用

00:30:39.239 --> 00:30:40.073 align:middle
那个

00:30:44.378 --> 00:30:46.480 align:middle
但是rectangleAt不是要求

00:30:46.547 --> 00:30:48.448 align:middle
所以TestRenderer中的实现

00:30:48.849 --> 00:30:52.753 align:middle
只覆盖到协议和上下文

00:30:53.453 --> 00:30:56.089 align:middle
你只知道有渲染器而非
TestRenderer的时候

00:30:56.590 --> 00:30:58.125 align:middle
协议实现被调用

00:30:59.660 --> 00:31:00.627 align:middle
这有点奇怪 不是吗？

00:30:59.660 --> 00:31:00.627 align:middle
这有点奇怪 不是吗？

00:31:03.163 --> 00:31:05.999 align:middle
那么 这是否意味着
rectangleAt应该是要求？

00:31:07.067 --> 00:31:08.402 align:middle
也许在这种情况下它应该

00:31:08.635 --> 00:31:11.205 align:middle
是因为有些渲染器非常有可能

00:31:11.271 --> 00:31:13.674 align:middle
有更有效的方式来画矩形

00:31:13.907 --> 00:31:15.909 align:middle
与坐标系相配合

00:31:17.578 --> 00:31:22.449 align:middle
但是 协议扩展中的所有事物是否也
是由要求支持的呢？

00:31:22.883 --> 00:31:23.750 align:middle
不一定

00:31:26.553 --> 00:31:29.990 align:middle
我是说有些应用程序
界面并不打算作为定制点

00:31:30.724 --> 00:31:32.860 align:middle
所以有时正确的解决方法是

00:31:32.926 --> 00:31:37.264 align:middle
只覆盖到模型中的要求

00:31:38.031 --> 00:31:39.900 align:middle
而不要覆盖到模型中的方法

00:31:44.872 --> 00:31:50.511 align:middle
那么这种新特征偶然地变革了
我们在Swift标准库上的工作

00:31:51.845 --> 00:31:54.348 align:middle
有时我们使用协议扩展所做的事情

00:31:55.349 --> 00:31:56.683 align:middle
感觉很神奇

00:31:57.918 --> 00:32:01.188 align:middle
我真心希望你们可以
享受使用最新的库进行工作

00:31:57.918 --> 00:32:01.188 align:middle
我真心希望你们可以
享受使用最新的库进行工作

00:32:01.522 --> 00:32:03.123 align:middle
就像我们享受应用这些到库

00:32:03.190 --> 00:32:08.228 align:middle
以及更新库一样
我想先撇开我们的故事

00:32:08.295 --> 00:32:11.665 align:middle
这样我就可以向你们展示我们使用
协议扩展在标准库上做的一些事情

00:32:11.999 --> 00:32:14.902 align:middle
还有一些其他的技巧

00:32:16.570 --> 00:32:19.239 align:middle
首先来讲一下新的indexOf方法

00:32:20.707 --> 00:32:23.043 align:middle
这个方法遍历集合的指针

00:32:23.410 --> 00:32:26.613 align:middle
直到它找到与我们
正在查找的相等的元素

00:32:26.947 --> 00:32:28.448 align:middle
然后返回这个指针

00:32:28.982 --> 00:32:30.751 align:middle
如果它没有找到结果那么返回空

00:32:31.552 --> 00:32:32.386 align:middle
非常简单对吧？

00:32:34.488 --> 00:32:36.356 align:middle
但是如果我们这样写
就会有一个问题

00:32:37.891 --> 00:32:40.527 align:middle
一个任意集合的元素

00:32:41.161 --> 00:32:42.462 align:middle
不能对等地比较

00:32:44.998 --> 00:32:48.602 align:middle
因此为了解决这个问题
我们可以约束扩展

00:32:49.369 --> 00:32:51.638 align:middle
这是这个新特征的另一方面

00:32:55.242 --> 00:33:00.180 align:middle
所以这么说扩展应用于
集合元素类型是Equatable时

00:32:55.242 --> 00:33:00.180 align:middle
所以这么说扩展应用于
集合元素类型是Equatable时

00:33:01.381 --> 00:33:05.986 align:middle
我们已经给Swift传递了它所
需要的信息以允许等式比较

00:33:08.422 --> 00:33:10.324 align:middle
现在我们已经看到了

00:33:10.390 --> 00:33:13.894 align:middle
约束扩展的一个简单示例
让我们重温一下二进位检索

00:33:16.997 --> 00:33:18.732 align:middle
我们将其应用到整型数组上

00:33:22.269 --> 00:33:24.671 align:middle
好 整型不符合Ordered类

00:33:25.706 --> 00:33:26.874 align:middle
这是一种简单的解决办法

00:33:27.374 --> 00:33:28.575 align:middle
我们只要添加一致性

00:33:29.977 --> 00:33:31.278 align:middle
好 那对于字符串又会怎样呢？

00:33:33.247 --> 00:33:35.983 align:middle
当然 这对字符串并没有用
所以我们再做一次

00:33:36.683 --> 00:33:40.387 align:middle
现在在Crusty开始敲桌子之前
我们很想分析出其中原因

00:33:41.889 --> 00:33:44.124 align:middle
小于运算符出现在

00:33:44.191 --> 00:33:47.160 align:middle
Comparable协议中
所以我们可以在

00:33:47.227 --> 00:33:48.829 align:middle
Comparable协议中操作

00:33:53.300 --> 00:33:54.134 align:middle
像这样

00:33:55.536 --> 00:33:58.438 align:middle
现在我们正在预先提供那些一致性

00:33:58.739 --> 00:34:00.974 align:middle
所以一方面这是很好的

00:33:58.739 --> 00:34:00.974 align:middle
所以一方面这是很好的

00:34:01.842 --> 00:34:03.744 align:middle
如果我想对双精度数据
进行二进位搜索

00:34:04.111 --> 00:34:07.481 align:middle
我所需要做的就是添加
这个一致性我可以这么做

00:34:08.982 --> 00:34:12.152 align:middle
另一方面这有些讨厌

00:34:12.485 --> 00:34:15.155 align:middle
因为即使我去掉一致性

00:34:15.522 --> 00:34:18.559 align:middle
我还是有这个被双精度获得的优先函数

00:34:19.025 --> 00:34:22.062 align:middle
它已经有了足够的接口 对吗？

00:34:23.163 --> 00:34:28.534 align:middle
我们可能想要更加有选择性地
在双精度数值上添加东西

00:34:30.871 --> 00:34:34.675 align:middle
所以即使我可以这样做

00:34:34.741 --> 00:34:38.277 align:middle
我不能用它来进行二进位检索所以这些
优先函数真的没有给我买入任何东西

00:34:39.813 --> 00:34:43.449 align:middle
幸运的是我可以对哪些东西获得
优先函数应用程序界面更有选择性

00:34:44.251 --> 00:34:46.286 align:middle
通过使用Ordered的约束扩展

00:34:48.222 --> 00:34:52.726 align:middle
所以这就是说一个是
Comparable的类型并被声明

00:34:52.793 --> 00:34:57.164 align:middle
为Ordered将能够
自动地满足优先要求

00:34:57.798 --> 00:34:59.066 align:middle
而这正是我们想要的

00:35:00.567 --> 00:35:02.836 align:middle
抱歉 但我觉得这很酷

00:35:03.237 --> 00:35:05.939 align:middle
我们有了同样的抽象

00:35:07.007 --> 00:35:09.676 align:middle
同样的逻辑抽象
来自于两个不同的地方

00:35:09.977 --> 00:35:12.312 align:middle
而我们已经使它们无缝协作

00:35:13.013 --> 00:35:15.249 align:middle
谢谢你们的掌声
不过我只是我觉得这很酷

00:35:17.651 --> 00:35:19.586 align:middle
好 做好准备来一个味蕾清新剂了吗？

00:35:24.391 --> 00:35:25.225 align:middle
这显示它起作用了

00:35:25.792 --> 00:35:31.398 align:middle
好 这是一个完全通用的
二进位检索的签名

00:35:32.032 --> 00:35:33.734 align:middle
作用于任意一个集合

00:35:34.101 --> 00:35:36.236 align:middle
带有适当的索引和元素类型

00:35:37.971 --> 00:35:40.374 align:middle
现在我已经能听到
你们在那儿越来越不舒服了

00:35:40.641 --> 00:35:42.409 align:middle
我并不准备在这里写主体

00:35:42.476 --> 00:35:44.811 align:middle
因为这已经看起来很糟糕了 对吧

00:35:45.779 --> 00:35:48.782 align:middle
Swift 1有很多像
这样的通用免费函数

00:35:49.983 --> 00:35:52.553 align:middle
在Swift 2中我们像这样
使用协议扩展将它们

00:35:52.619 --> 00:35:55.822 align:middle
变为方法 这很棒

00:35:57.724 --> 00:36:00.961 align:middle
现在每个人都专注于在
这个调用站点的改善

00:35:57.724 --> 00:36:00.961 align:middle
现在每个人都专注于在
这个调用站点的改善

00:36:01.762 --> 00:36:04.598 align:middle
它现在很明显地充满了

00:36:04.898 --> 00:36:06.533 align:middle
方法的精华

00:36:06.967 --> 00:36:08.902 align:middle
但随着这个家伙写二进位检索

00:36:09.469 --> 00:36:11.038 align:middle
我因其签名而爱上了它所做的事情

00:36:11.872 --> 00:36:15.309 align:middle
通过分离情况
这些情况下该方法应用于

00:36:15.609 --> 00:36:17.110 align:middle
声明的其余部分

00:36:17.811 --> 00:36:19.780 align:middle
现在读起来只是一个常规方法

00:36:21.415 --> 00:36:22.816 align:middle
不再有尖括号盲区

00:36:26.587 --> 00:36:27.421 align:middle
非常感谢

00:36:31.191 --> 00:36:34.228 align:middle
好 在我们回到我们的故事前
来讲一下最后一个技巧

00:36:35.829 --> 00:36:39.299 align:middle
这是一个包含最小模型的游戏场

00:36:39.366 --> 00:36:41.768 align:middle
关于Swift的心
OptionSetType协议

00:36:42.769 --> 00:36:45.038 align:middle
它就是一个结构具有只读整型属性

00:36:46.006 --> 00:36:47.007 align:middle
叫做rawValue

00:36:47.474 --> 00:36:53.580 align:middle
现在来看一下一旦你昨晚
即可免费得到的广泛设置界面

00:36:55.249 --> 00:36:57.584 align:middle
所有这些都来自于协议扩展

00:36:58.952 --> 00:37:00.988 align:middle
如果你有机会的话
我邀请你来看一下

00:36:58.952 --> 00:37:00.988 align:middle
如果你有机会的话
我邀请你来看一下

00:37:01.054 --> 00:37:02.856 align:middle
那些扩展是怎样声明的

00:37:03.190 --> 00:37:05.959 align:middle
在标准库中因为几个图层

00:37:06.026 --> 00:37:08.629 align:middle
一起工作来提供这个丰富的
应用程序界面

00:37:11.331 --> 00:37:16.303 align:middle
好 这些就是你可以
使用协议扩展做到的一些很酷的事情

00:37:17.371 --> 00:37:21.408 align:middle
现在 我想回到我们的图表示例中

00:37:24.144 --> 00:37:25.846 align:middle
使值类型可相等

00:37:27.681 --> 00:37:30.083 align:middle
为什么？因为我是这么说的

00:37:30.817 --> 00:37:32.219 align:middle
另外吃蔬菜

00:37:33.954 --> 00:37:35.989 align:middle
不 事实上如果你想
知道为什么去听一下

00:37:36.056 --> 00:37:37.858 align:middle
周五的讲习会我已经跟你们讲过这个

00:37:39.826 --> 00:37:43.397 align:middle
这是一个很酷的演讲
他们准备详细探讨这个问题

00:37:44.965 --> 00:37:47.968 align:middle
总之Equatable对于大多数
类型来说都是很容易的 对吧

00:37:48.035 --> 00:37:51.538 align:middle
你只需要比较相应的部分
以求其对等性 就像这样

00:37:52.940 --> 00:37:55.242 align:middle
但是现在我们来看一下图表发生了什么

00:37:58.612 --> 00:38:03.350 align:middle
啊哦 我们不能对比两个
Drawable类型数组的对等性

00:37:58.612 --> 00:38:03.350 align:middle
啊哦 我们不能对比两个
Drawable类型数组的对等性

00:38:06.286 --> 00:38:11.058 align:middle
好吧 也许我们可以这么做
比较个体元素就好比这样

00:38:15.762 --> 00:38:19.032 align:middle
好 我将给你们过一遍

00:38:19.166 --> 00:38:21.502 align:middle
首先你去顶它们有相同数量的元素

00:38:21.635 --> 00:38:23.937 align:middle
然后把两个数组压缩在一起

00:38:24.004 --> 00:38:25.772 align:middle
如果它们有相同数量的元素

00:38:25.839 --> 00:38:28.575 align:middle
那么你就找一对不相等的

00:38:29.009 --> 00:38:30.410 align:middle
好的你可以相信我的话

00:38:30.477 --> 00:38:33.480 align:middle
这还不是问题有趣的部分

00:38:36.250 --> 00:38:37.084 align:middle
哦 对吧？

00:38:37.217 --> 00:38:40.153 align:middle
这是我们无法比较数组的整个原因就是

00:38:40.220 --> 00:38:43.590 align:middle
因为Drawable类是不对等的

00:38:43.891 --> 00:38:46.593 align:middle
因此两个数组之间没有等于运算符

00:38:47.060 --> 00:38:49.963 align:middle
我们没有等于运算符
给潜在的Drawable属性

00:38:50.030 --> 00:38:52.666 align:middle
我们能不能把Drawable
改为Equatable？

00:38:53.200 --> 00:38:54.601 align:middle
我们改变了设计像这样

00:39:00.274 --> 00:39:03.277 align:middle
这里的问题在于
Equatable有Self要求

00:39:04.344 --> 00:39:07.214 align:middle
这意味着Drawable
现在有了Self要求

00:39:08.382 --> 00:39:11.218 align:middle
而Self要求正好将
Drawable

00:39:11.285 --> 00:39:14.721 align:middle
放进了同构中静态分派的世界

00:39:16.256 --> 00:39:20.894 align:middle
但是图表需要的是
Drawable异构数组

00:39:22.029 --> 00:39:25.232 align:middle
因此我们可以将多边形
和圆放在同一个图表中

00:39:26.099 --> 00:39:29.303 align:middle
那么Drawable必须待在异构的
动态分派的世界

00:39:30.370 --> 00:39:31.305 align:middle
而这带来了矛盾

00:39:31.972 --> 00:39:34.474 align:middle
将Drawable改为
Equatable是行不通的

00:39:37.811 --> 00:39:39.713 align:middle
我们需要这样做

00:39:39.780 --> 00:39:43.350 align:middle
就是说给Drawable添加
isEqualTo要求

00:39:45.919 --> 00:39:48.488 align:middle
但是...不 我们不能用Self

00:39:49.857 --> 00:39:51.825 align:middle
因为我们需要保持异构

00:39:52.192 --> 00:39:53.694 align:middle
而没有了Self

00:39:54.328 --> 00:39:57.831 align:middle
这就像用类完成Ordered一样

00:39:58.765 --> 00:40:00.834 align:middle
现在我们要让所有 Drawable

00:39:58.765 --> 00:40:00.834 align:middle
现在我们要让所有 Drawable

00:40:01.134 --> 00:40:03.403 align:middle
来处理异构比较情况

00:40:06.473 --> 00:40:08.041 align:middle
幸运的是这次有一种方法可以做到

00:40:09.142 --> 00:40:13.280 align:middle
与大多对称运算符不同
等式是特殊的

00:40:14.381 --> 00:40:16.617 align:middle
因为有显而易见的默认的答案

00:40:16.683 --> 00:40:17.784 align:middle
如果类型不匹配的话

00:40:18.385 --> 00:40:22.155 align:middle
可以这么说如果有两个不同的类型
它们是不等的

00:40:24.424 --> 00:40:27.528 align:middle
明白这一点我们可以实现
isEqualTo

00:40:27.594 --> 00:40:29.730 align:middle
为所有Equatable的
Drawable

00:40:31.765 --> 00:40:32.599 align:middle
就像这样

00:40:35.402 --> 00:40:36.370 align:middle
让我来向你们演示

00:40:37.538 --> 00:40:38.906 align:middle
扩展就是我们所说的

00:40:39.106 --> 00:40:41.508 align:middle
它是给所有Equatable的
Drawable的

00:40:49.049 --> 00:40:53.887 align:middle
好 首先我们有条件地将其他
类型向下转型到Self类型

00:40:54.488 --> 00:40:57.090 align:middle
如果这成功了然后我们可以继续下去

00:40:57.157 --> 00:41:00.494 align:middle
使用等式比较
因为我们有Equatable一致性

00:40:57.157 --> 00:41:00.494 align:middle
使用等式比较
因为我们有Equatable一致性

00:41:01.461 --> 00:41:04.064 align:middle
否则实例会被认为不对等

00:41:09.169 --> 00:41:11.705 align:middle
那么大图片这里刚刚发生了什么呢？

00:41:13.207 --> 00:41:16.009 align:middle
我们与Drawable的
实现器达成协议

00:41:16.476 --> 00:41:22.516 align:middle
我们说“如果你真的想
处理异构情况请做我的访客

00:41:22.916 --> 00:41:24.751 align:middle
去实现isEqualTo

00:41:25.652 --> 00:41:30.057 align:middle
但如果你只是想用我们

00:41:30.123 --> 00:41:32.826 align:middle
表达同构比较的常规方式

00:41:33.093 --> 00:41:35.829 align:middle
我们将为你处理所有异构比较的负担”

00:41:38.131 --> 00:41:41.201 align:middle
所以在静态和动态世界之间建立桥梁

00:41:41.268 --> 00:41:44.338 align:middle
是极好的设计空间

00:41:44.838 --> 00:41:47.307 align:middle
我鼓励你们多多观察

00:41:47.875 --> 00:41:51.879 align:middle
我们使用等式的特殊属性
解决了这个特别的问题

00:41:51.945 --> 00:41:54.915 align:middle
但是问题并不都像这样

00:41:56.583 --> 00:41:58.018 align:middle
你还可以做很多很酷的事情

00:42:01.889 --> 00:42:06.193 align:middle
因此等式的这个属性不一定适用
但是什么才是普遍适用的呢？

00:42:07.694 --> 00:42:08.695 align:middle
基于协议的设计

00:42:16.670 --> 00:42:19.473 align:middle
所以我想在我们总结

00:42:19.973 --> 00:42:23.043 align:middle
何时使用类之前说几句
因为他们有他们的位置

00:42:23.977 --> 00:42:26.713 align:middle
好吗？有些时候你真的想要隐式共享

00:42:28.415 --> 00:42:31.318 align:middle
例如值类型的基本操作

00:42:31.385 --> 00:42:33.053 align:middle
没有任何意义时

00:42:33.520 --> 00:42:35.889 align:middle
比如复制副本意味着什么呢？

00:42:35.956 --> 00:42:37.391 align:middle
如果你不明白这是什么意思

00:42:38.025 --> 00:42:40.427 align:middle
那么你可能想使它成为引用类型

00:42:42.095 --> 00:42:43.964 align:middle
或者比较 一样的

00:42:44.031 --> 00:42:46.233 align:middle
这是作为数值的另一个基础部分

00:42:46.800 --> 00:42:48.001 align:middle
那么 比如窗口

00:42:48.969 --> 00:42:50.270 align:middle
复制窗口意味着什么呢？

00:42:50.470 --> 00:42:51.738 align:middle
你真的想看

00:42:52.506 --> 00:42:53.707 align:middle
一个新的图形窗口吗？

00:42:54.041 --> 00:42:55.709 align:middle
就在另一个窗口之上？ 不知道

00:42:57.110 --> 00:42:58.879 align:middle
这不会是你视图层级的一部分

00:42:59.947 --> 00:43:00.781 align:middle
毫无意义

00:42:59.947 --> 00:43:00.781 align:middle
毫无意义

00:43:01.815 --> 00:43:04.117 align:middle
另外一种情况

00:43:04.184 --> 00:43:09.122 align:middle
你的实例的生命周期依赖于
某些外部的副作用

00:43:09.489 --> 00:43:11.158 align:middle
比如磁盘上出现的文件

00:43:13.093 --> 00:43:17.998 align:middle
部分原因是编译器大量地创建值

00:43:18.599 --> 00:43:20.367 align:middle
创建 再销毁

00:43:20.634 --> 00:43:22.769 align:middle
我们试图尽可能地优化

00:43:23.604 --> 00:43:26.707 align:middle
引用类型有这种稳定的特性

00:43:26.773 --> 00:43:28.942 align:middle
所以如果你要做一些对应于

00:43:29.009 --> 00:43:30.110 align:middle
外部实体的事情

00:43:30.844 --> 00:43:33.013 align:middle
你可能会想使它为引用类型

00:43:33.580 --> 00:43:37.217 align:middle
类 另一种情况是

00:43:37.518 --> 00:43:40.354 align:middle
抽象实例是“水槽”

00:43:40.821 --> 00:43:42.523 align:middle
比如渲染器

00:43:43.724 --> 00:43:47.794 align:middle
我们灌注信息给它

00:43:47.861 --> 00:43:50.964 align:middle
给渲染器 我们让它画线

00:43:52.132 --> 00:43:55.435 align:middle
举个例子如果你想做一个
TestRenderer

00:43:55.502 --> 00:44:00.641 align:middle
让它积累文本并将这些命令输出为

00:43:55.502 --> 00:44:00.641 align:middle
让它积累文本并将这些命令输出为

00:44:00.841 --> 00:44:03.610 align:middle
字符串 而不是直接将它们倒给控制台

00:44:04.011 --> 00:44:05.012 align:middle
你可以像这样做

00:44:06.914 --> 00:44:08.882 align:middle
但要注意几件事情

00:44:09.416 --> 00:44:11.518 align:middle
首先这是最后

00:44:13.153 --> 00:44:15.088 align:middle
其次没有基类

00:44:15.422 --> 00:44:16.456 align:middle
这仍然是一个协议

00:44:17.057 --> 00:44:18.992 align:middle
我使用协议来表达抽象

00:44:23.530 --> 00:44:25.299 align:middle
好 额外的几种情况

00:44:27.768 --> 00:44:30.704 align:middle
我们生活在面向对象的世界 对吧？

00:44:30.871 --> 00:44:33.640 align:middle
Cocoa 和
Cocoa Touch致力于对象

00:44:34.741 --> 00:44:37.411 align:middle
他们会给你基类
并期望你将它们编入子类

00:44:37.845 --> 00:44:40.881 align:middle
他们期望应用程序界面中的对象

00:44:41.715 --> 00:44:43.584 align:middle
不要与系统对抗 好吗？

00:44:43.984 --> 00:44:45.085 align:middle
这只会是徒劳的

00:44:46.420 --> 00:44:51.225 align:middle
但是与此同时一定要谨慎

00:44:51.992 --> 00:44:55.062 align:middle
你知道程序中任何事物都不能过大

00:44:55.529 --> 00:44:57.898 align:middle
这对类和其他都适用

00:44:58.832 --> 00:45:02.469 align:middle
所以当你从类中重构或分解时

00:44:58.832 --> 00:45:02.469 align:middle
所以当你从类中重构或分解时

00:45:03.303 --> 00:45:04.738 align:middle
考虑使用值类型

00:45:07.574 --> 00:45:09.610 align:middle
好了 总结一下

00:45:11.378 --> 00:45:14.214 align:middle
协议 对于抽象来讲好过于超类

00:45:16.183 --> 00:45:21.121 align:middle
第二协议扩展这个新特征

00:45:21.588 --> 00:45:23.290 align:middle
让你做很神奇的事情

00:45:25.492 --> 00:45:27.728 align:middle
第三我提到让你们来听周五的演讲吗？

00:45:29.796 --> 00:45:30.731 align:middle
来参加周五的演讲

00:45:32.833 --> 00:45:33.667 align:middle
吃蔬菜

00:45:34.801 --> 00:45:35.702 align:middle
像Crusty一样

00:45:36.737 --> 00:45:37.571 align:middle
非常感谢
