WEBVTT

00:00:19.686 --> 00:00:24.258 align:middle
和DemoBots一起深入GameplayKit

00:00:28.662 --> 00:00:32.064 align:middle
大家好欢迎来到“和DemoBots
一起深入GameplayKit”

00:00:32.933 --> 00:00:36.336 align:middle
今年我们创建了一个新的
游戏示例名字叫DemoBots

00:00:36.870 --> 00:00:38.405 align:middle
如果你想在家玩那么今天你就可以

00:00:38.605 --> 00:00:42.776 align:middle
从developer.apple.com/spritekit
把这个示例下载回来

00:00:44.044 --> 00:00:46.547 align:middle
这个游戏利用了大量你们在
“SpriteKit会话中有什么新料”

00:00:46.613 --> 00:00:48.815 align:middle
以及
“GameplayKit简介”中

00:00:49.183 --> 00:00:53.654 align:middle
学到的东西如果你不会的话就去看看吧

00:00:55.289 --> 00:00:57.491 align:middle
如果不给你们演示我们就无法完成

00:00:58.292 --> 00:00:59.860 align:middle
这个叫做DemoBots的游戏

00:00:59.927 --> 00:01:02.196 align:middle
我们来看一下这个游戏该怎么玩

00:00:59.927 --> 00:01:02.196 align:middle
我们来看一下这个游戏该怎么玩

00:01:07.968 --> 00:01:12.940 align:middle
我们开始一个新游戏 你就是
PlayerBot就是这里的这个人

00:01:13.574 --> 00:01:17.211 align:middle
你的任务是在时间用完之前
找到并干掉每个关卡内的

00:01:17.411 --> 00:01:19.179 align:middle
坏的TaskBots

00:01:20.080 --> 00:01:22.249 align:middle
我们这里还有两个好的TaskBots
因为它们的脸是绿色的

00:01:22.316 --> 00:01:24.117 align:middle
所以你可以知道
是好的TaskBots

00:01:24.551 --> 00:01:27.654 align:middle
如果我在这个角落这里溜达一圈
就可以找到第一个坏TaskBots

00:01:27.721 --> 00:01:29.356 align:middle
在这个例子中他是一个
GroundBot

00:01:29.723 --> 00:01:32.459 align:middle
当他发现我的时候他就会朝我
冲过来并且攻击我

00:01:33.260 --> 00:01:34.094 align:middle
我损失了一些电量

00:01:34.795 --> 00:01:37.097 align:middle
没关系 我要用一道射线搞定他

00:01:37.598 --> 00:01:40.634 align:middle
我用射线照射了它几秒钟后
就搞定了 他就成了绿色

00:01:41.401 --> 00:01:42.302 align:middle
我们看看他要去哪儿

00:01:44.104 --> 00:01:46.139 align:middle
我们又找到了一个
坏的TaskBots

00:01:46.206 --> 00:01:48.175 align:middle
我来把他也搞定

00:01:49.710 --> 00:01:52.913 align:middle
时间走完之前我在这个关卡内还有
两个坏的TaskBots需要搞定

00:01:53.380 --> 00:01:56.517 align:middle
不幸的是 它们也会互相攻击

00:01:57.150 --> 00:01:58.652 align:middle
把对方变成坏的TaskBots

00:02:00.721 --> 00:02:01.855 align:middle
那里就出现了这种情况

00:02:02.589 --> 00:02:04.157 align:middle
把它们全部搞定后

00:02:08.461 --> 00:02:09.429 align:middle
这一关就算完成了

00:02:13.867 --> 00:02:14.835 align:middle
这是第二关

00:02:17.271 --> 00:02:20.240 align:middle
第二关中增加了一种新的
角色 FlyingBot

00:02:20.541 --> 00:02:23.110 align:middle
那里就挂着一台FlyingBot
他正在自娱自乐

00:02:23.744 --> 00:02:25.546 align:middle
当你找到一台坏的FlyingBot时

00:02:25.612 --> 00:02:29.850 align:middle
它们有不同的攻击方式
当我们撞到他的时候

00:02:30.217 --> 00:02:33.487 align:middle
他发起了爆炸攻击
影响到了一定半径范围内的全部角色

00:02:34.321 --> 00:02:37.491 align:middle
好消息是 如果你搞定一台
FlyingBot 那么它们的攻击

00:02:37.558 --> 00:02:40.460 align:middle
就成了善意的攻击 可以搞定
射程内的其它坏的FlyingBot

00:02:40.861 --> 00:02:41.862 align:middle
跟着他到这儿

00:02:43.096 --> 00:02:45.332 align:middle
他肯定要撞上另外一台
坏的FlyingBot了

00:02:47.701 --> 00:02:50.137 align:middle
他躲开了他 好吧 我可以自己搞定他

00:02:50.838 --> 00:02:53.674 align:middle
他肯定要犯个大错了

00:02:54.107 --> 00:02:57.511 align:middle
他正朝着角落那里的一个大巢穴走去了

00:02:58.378 --> 00:02:59.479 align:middle
肯定是这样的

00:03:01.815 --> 00:03:04.751 align:middle
当他被转变成坏的FlyingBot时
我们可以利用他的爆炸攻击

00:03:04.818 --> 00:03:09.890 align:middle
他把一个两个坏的FlyingBot
转变成好的了

00:03:11.825 --> 00:03:17.998 align:middle
就剩一个了 还剩一个

00:03:20.534 --> 00:03:21.735 align:middle
啊 不好！这可不妙

00:03:25.138 --> 00:03:26.006 align:middle
又搞定一个

00:03:27.841 --> 00:03:28.709 align:middle
这一关也完成了

00:03:35.415 --> 00:03:36.517 align:middle
这就是DemoBots

00:03:37.651 --> 00:03:39.486 align:middle
我想看看我们使用了哪些工具

00:03:39.553 --> 00:03:42.322 align:middle
和技术来实现这款游戏

00:03:43.123 --> 00:03:47.294 align:middle
你可以看到当TaskBots
走动时它们有大量的动画状态

00:03:48.095 --> 00:03:52.766 align:middle
我们努力做的一件事
就是把我们需要的纹理 图像

00:03:52.833 --> 00:03:55.536 align:middle
保持在最低程度
从而让app的大小不太夸张

00:03:56.570 --> 00:03:59.873 align:middle
我们决定让SpriteKit中的
新的动作编辑器

00:04:00.274 --> 00:04:03.243 align:middle
把动作创建为...把动画创建为
动作而不是把动画创建为纹理

00:04:03.710 --> 00:04:07.181 align:middle
你们看到的攻击动画 那个攻击射线

00:04:07.648 --> 00:04:10.617 align:middle
是我们制作并应用到GroundBot
以及FlyingBot

00:04:10.684 --> 00:04:12.052 align:middle
上面的参考动作

00:04:12.486 --> 00:04:15.355 align:middle
如果我们点击进到那个动作
我们就可以看到它是由

00:04:15.422 --> 00:04:17.491 align:middle
很多的微小的移动动作
一个接一个组成的

00:04:19.293 --> 00:04:22.829 align:middle
因为它是一个参考动作
我们创建一次后

00:04:23.096 --> 00:04:25.632 align:middle
就可以不考虑TaskBots的
方位 把它应用到

00:04:25.699 --> 00:04:27.501 align:middle
所有的TaskBots上

00:04:28.402 --> 00:04:31.805 align:middle
因为它是一个参考动作
我们创建一次后

00:04:32.172 --> 00:04:34.675 align:middle
还可以对它进行修改对源进行修改

00:04:34.741 --> 00:04:36.844 align:middle
我们可以看到变更在各个地方
都生效了 我们就无需

00:04:36.910 --> 00:04:39.046 align:middle
在多个地方对它进行修改

00:04:40.848 --> 00:04:43.951 align:middle
我们使用动作编辑器来生成射线动画

00:04:44.484 --> 00:04:47.521 align:middle
这个射线持续了这样长的
几秒钟 我们还想让这个射线

00:04:47.588 --> 00:04:51.291 align:middle
随着时间衰减 我们也在
编辑器中创建了那些动作

00:04:51.525 --> 00:04:53.861 align:middle
这样我们就能直观地看到它
并且把它用到游戏中

00:04:55.629 --> 00:04:59.399 align:middle
游戏中所有的资产都是在资产目录中
创建的这些资产目录在Xcode 7

00:04:59.766 --> 00:05:04.605 align:middle
之外 替我们转换成了纹理地图集

00:04:59.766 --> 00:05:04.605 align:middle
之外 替我们转换成了纹理地图集

00:05:05.339 --> 00:05:07.174 align:middle
这就意味着当我们把它们用在游戏中时

00:05:07.241 --> 00:05:08.876 align:middle
我们就可以获得尽可能好的绘制性能

00:05:09.810 --> 00:05:11.144 align:middle
我们有很多这样的图像

00:05:11.411 --> 00:05:14.615 align:middle
它还使得我们可以指定在不同的设备上

00:05:14.815 --> 00:05:15.816 align:middle
使用的正确的图像

00:05:16.917 --> 00:05:18.785 align:middle
它还可以帮助我们
进一步优化图像的尺寸

00:05:19.887 --> 00:05:22.856 align:middle
当我们设计我们的关卡时
我们使用七百六十八点的参考标高

00:05:22.923 --> 00:05:26.660 align:middle
那边的那个黄色框那是我们想在屏幕上

00:05:26.727 --> 00:05:29.463 align:middle
显示多少个关卡的参考

00:05:30.197 --> 00:05:33.300 align:middle
以那个尺寸计算我们的PlayerBot
是一百二十个点 而如果我们

00:05:34.668 --> 00:05:39.840 align:middle
在一台iPad上使用那个关卡
那台iPad就也是七百六十八点

00:05:39.973 --> 00:05:42.910 align:middle
这样我们就知道了PlayerBot
在屏幕上的尺寸他是一百二十个点

00:05:42.976 --> 00:05:45.579 align:middle
我们就可以计算出要想在
屏幕上得到他的清晰图像

00:05:45.646 --> 00:05:47.614 align:middle
他的尺寸应该是多少

00:05:48.715 --> 00:05:52.186 align:middle
如果我们把那个关卡按比例缩小到一部

00:05:52.452 --> 00:05:55.956 align:middle
比如三百二十个点高度的
iPhone上 他就会变小

00:05:56.123 --> 00:05:57.457 align:middle
他的高度就会成为五十个点

00:05:58.258 --> 00:06:00.494 align:middle
在iPad上我们不需要这么高
分辨率的纹理

00:05:58.258 --> 00:06:00.494 align:middle
在iPad上我们不需要这么高
分辨率的纹理

00:06:00.727 --> 00:06:02.529 align:middle
我们就可以节省空间

00:06:03.997 --> 00:06:07.167 align:middle
如果我们观察下我们的
DemoBots支持的设备

00:06:07.467 --> 00:06:11.905 align:middle
iPad iPhone以及Mac
随着场景高度的变化

00:06:12.372 --> 00:06:14.441 align:middle
我们就可以计算出对应的玩家的高度

00:06:15.609 --> 00:06:20.914 align:middle
iPhone 6比4S到5S
都略微大一点

00:06:20.981 --> 00:06:24.518 align:middle
我们使用的也是同样的
资产它太小了 你没注意到

00:06:26.119 --> 00:06:31.191 align:middle
这就意味着你可以计算出
我们需要的1X 2X 3X资产

00:06:31.558 --> 00:06:34.862 align:middle
让图像看起来清晰 同时又避免了
使用超出我们需要的更多的像素

00:06:35.162 --> 00:06:38.966 align:middle
为了简单起见我们把iPhone 6 Plus
向下取整为了一百八十像素

00:06:40.968 --> 00:06:44.238 align:middle
我们可以为每种设备设置
我们想要的资产

00:06:44.872 --> 00:06:46.240 align:middle
游戏中我们有很多这样的资产

00:06:46.773 --> 00:06:49.943 align:middle
我意思是它们的数量非常多数以千计

00:06:51.411 --> 00:06:56.283 align:middle
实际上所有的这些角色资产都是在
一个3D渲染输出上生成的

00:06:56.850 --> 00:06:58.151 align:middle
我们也可以连接那个渲染输出

00:06:58.585 --> 00:07:02.189 align:middle
我们也让那个资产目录的
生成实现了自动化

00:06:58.585 --> 00:07:02.189 align:middle
我们也让那个资产目录的
生成实现了自动化

00:07:02.823 --> 00:07:05.459 align:middle
这里的这个JSON文件
这是PlayerBot

00:07:05.526 --> 00:07:07.761 align:middle
行走动画的一帧

00:07:08.395 --> 00:07:12.900 align:middle
我们同样也可以自动生成这些文件
这就是Xcode使用资产目录生成的

00:07:13.467 --> 00:07:17.104 align:middle
我们也可以让为每种设备拾取
正确的图像这一过程

00:07:18.071 --> 00:07:20.374 align:middle
自动化 我们以后也会公布资产目录

00:07:20.440 --> 00:07:23.844 align:middle
格式参考 以便让你可以更加容易地

00:07:27.147 --> 00:07:29.850 align:middle
自己创建这些文件我们还在游戏中
使用了另外SpriteKit的一项特性

00:07:29.917 --> 00:07:33.620 align:middle
即SKCameraNode
在那之前 如果我们想要

00:07:34.054 --> 00:07:36.190 align:middle
在关卡内移动视图
我们就需要实际移动

00:07:36.590 --> 00:07:39.760 align:middle
整个场景 我们就必须
把关卡自身移动到视图下面

00:07:41.828 --> 00:07:44.431 align:middle
而有了SKCameraNode
事情就变得简单多了

00:07:45.098 --> 00:07:47.634 align:middle
摄像机就是场景中的一个节点
它有自己的位置

00:07:48.202 --> 00:07:50.704 align:middle
因为它有自己的位置
我们就可以通过改变它的位置

00:07:50.771 --> 00:07:52.873 align:middle
来移动摄像机
就像移动其他节点一样

00:07:53.440 --> 00:07:55.742 align:middle
改变当前视图看到的
位置就更加容易了

00:07:57.978 --> 00:08:01.048 align:middle
因为它是一个节点 我们还可以
用它来做节点能做的事

00:07:57.978 --> 00:08:01.048 align:middle
因为它是一个节点 我们还可以
用它来做节点能做的事

00:08:01.515 --> 00:08:03.550 align:middle
举例来说 我们可以向
那个节点应用约束

00:08:04.151 --> 00:08:06.820 align:middle
我们可以用这个把节点的
摄像机位置约束到

00:08:07.120 --> 00:08:10.524 align:middle
一个PlayerBot位置
当他朝着屏幕角落跑去时

00:08:11.992 --> 00:08:16.864 align:middle
我们在他四周就有很多黑色空间

00:08:16.930 --> 00:08:19.933 align:middle
而不是我们想在屏幕上看到的
尽可能多的关卡

00:08:21.001 --> 00:08:23.971 align:middle
我们还可以使用第二个约束
来对它进行改进

00:08:24.738 --> 00:08:27.741 align:middle
这个约束可以确保我们不会
太过于靠近关卡的边缘

00:08:28.141 --> 00:08:29.042 align:middle
看起来就是这样的

00:08:30.210 --> 00:08:32.513 align:middle
一般来说
我们会跟随PlayerBot

00:08:33.145 --> 00:08:35.716 align:middle
但是如果他靠近了边缘
我们就会停止跟随他

00:08:35.782 --> 00:08:37.183 align:middle
让更多的关卡显示在屏幕上

00:08:37.683 --> 00:08:41.922 align:middle
当敌方bots攻击你的时候
这就更容易看出来了

00:08:43.756 --> 00:08:44.858 align:middle
那么我们是怎样实现的？

00:08:45.692 --> 00:08:49.396 align:middle
我们首先计算出整个关卡的封边矩形

00:08:50.597 --> 00:08:53.233 align:middle
然后我们根据它们看到的游戏屏幕的

00:08:53.534 --> 00:08:56.403 align:middle
宽度和高度得到一个较小的矩形

00:08:57.171 --> 00:09:00.641 align:middle
我们再确保摄像机不能
移动到这个框以外

00:08:57.171 --> 00:09:00.641 align:middle
我们再确保摄像机不能
移动到这个框以外

00:09:00.707 --> 00:09:02.209 align:middle
我们把它约束到那个矩形

00:09:03.210 --> 00:09:07.114 align:middle
这样当摄像机跟随玩家
四处移动时它就不会太过于靠近

00:09:07.314 --> 00:09:08.148 align:middle
关卡的边缘

00:09:11.051 --> 00:09:14.855 align:middle
因为摄像机是一个节点了
我们还可以向它添加子节点

00:09:15.389 --> 00:09:19.560 align:middle
这就非常有利于警告信息的显示
比如我们在游戏中的计时器标签

00:09:20.694 --> 00:09:23.297 align:middle
我们不想让计时器标签移动
我们想让它顶部居中显示

00:09:23.897 --> 00:09:27.100 align:middle
因此我们就把它添加为
摄像机的一个子节点

00:09:27.734 --> 00:09:30.170 align:middle
而不是场景的一个子节点
这样的话当摄像机四处移动时

00:09:30.838 --> 00:09:34.208 align:middle
标签也会随之移动在屏幕的适当位置
保持这个固定特效就更加容易了

00:09:37.311 --> 00:09:40.447 align:middle
这些就是我们在游戏中用到的
部分SpriteKit特性

00:09:41.114 --> 00:09:43.717 align:middle
我们再来看看如果我们用的是
GameplayKit的某些特性会怎样

00:09:43.917 --> 00:09:45.619 align:middle
首先是
GKStateMachine

00:09:45.686 --> 00:09:47.955 align:middle
你应该已经在
GameplayKit会议上

00:09:48.455 --> 00:09:51.892 align:middle
见到过它了那场会议讲的是
你如何使用状态机追踪你的游戏内的

00:09:51.959 --> 00:09:54.261 align:middle
角色 关卡以及其他元素
发生了什么情况

00:09:55.095 --> 00:09:57.698 align:middle
我们把这个以及其他一些东西
用在了PlayerBot上

00:09:57.898 --> 00:09:59.066 align:middle
这是他的状态

00:09:59.333 --> 00:10:00.934 align:middle
他首先是处于“出现”阶段

00:09:59.333 --> 00:10:00.934 align:middle
他首先是处于“出现”阶段

00:10:01.435 --> 00:10:03.036 align:middle
也就是说他刚被“传送”到了游戏中

00:10:03.937 --> 00:10:06.874 align:middle
为此使用定制状态很棒的一点就在于

00:10:07.307 --> 00:10:09.309 align:middle
它们可以确保不会发生意外

00:10:09.743 --> 00:10:15.015 align:middle
当他们启动后 就激活了一个
计时器 过了一定时间后

00:10:15.649 --> 00:10:18.418 align:middle
它就会直接移动到玩家控制状态

00:10:18.485 --> 00:10:22.890 align:middle
然后打开输入使用
这样你就可以控制它了

00:10:24.391 --> 00:10:29.096 align:middle
当他命中一个目标后 我们
就把他的状态改为“命中”

00:10:29.162 --> 00:10:32.199 align:middle
当我们被命中后 我们就输入
一个不同的动画 就是那个

00:10:32.266 --> 00:10:36.203 align:middle
跳跃动画 当玩家被命中后
就不能再控制玩家了

00:10:36.637 --> 00:10:39.306 align:middle
输入就会关掉 并且继续跟踪状态

00:10:39.740 --> 00:10:42.709 align:middle
当时间过完后再把他移回
玩家控制状态

00:10:44.378 --> 00:10:47.748 align:middle
如果我们被命中的次数足够多
我们就必须重新充电

00:10:48.048 --> 00:10:50.817 align:middle
我们就到了“重新充电”状态
而不是“命中”状态

00:10:51.618 --> 00:10:53.453 align:middle
那个会追踪我们重新充电了多长时间

00:10:53.921 --> 00:10:55.255 align:middle
那个状态也会真的

00:10:55.489 --> 00:10:57.191 align:middle
给玩家添加更多的电量

00:10:57.858 --> 00:11:01.328 align:middle
最后重新充电结束后它就会回到
PlayerControlled状态

00:10:57.858 --> 00:11:01.328 align:middle
最后重新充电结束后它就会回到
PlayerControlled状态

00:11:03.430 --> 00:11:06.433 align:middle
这就是玩家可以拥有的
一套合理的复杂的行为

00:11:07.201 --> 00:11:10.938 align:middle
使用一台状态机来对状态进行编码

00:11:11.004 --> 00:11:13.841 align:middle
引起状态的发生定义要发生的正确的事

00:11:14.107 --> 00:11:17.277 align:middle
从一个状态移动到另一个状态
这样要确保游戏内仅仅会

00:11:17.344 --> 00:11:19.146 align:middle
发生正确的事就更加容易了

00:11:19.213 --> 00:11:21.715 align:middle
我们的PlayerBot不会做出
我们不想让他做的事

00:11:23.584 --> 00:11:27.821 align:middle
我们同样也把它用到游戏本身上面

00:11:28.355 --> 00:11:30.657 align:middle
当你玩一个关卡时
我们就处于一个活动状态

00:11:31.525 --> 00:11:33.760 align:middle
如果我们点击“暂停”
那么我们就会进入暂停状态

00:11:34.127 --> 00:11:37.197 align:middle
这就会通过在你退出
暂停状态时删除那个

00:11:37.431 --> 00:11:38.599 align:middle
覆盖 从而对覆盖进行处理

00:11:39.566 --> 00:11:41.969 align:middle
如果我通关了一个关卡
我们就处于一个成功状态

00:11:42.503 --> 00:11:45.405 align:middle
同样地 当我们成功时
它就会处理所有的

00:11:45.572 --> 00:11:47.274 align:middle
显示按钮、进行覆盖这些任务

00:11:47.541 --> 00:11:49.510 align:middle
在这些情况中
状态知道应该做什么事情

00:11:52.279 --> 00:11:55.048 align:middle
我们还用到了GameplayKit
的另一个方面

00:11:55.115 --> 00:11:55.949 align:middle
即实体和元件

00:11:56.783 --> 00:11:59.319 align:middle
新的元件是对自含式功能性
在游戏的不同实体上

00:11:59.386 --> 00:12:03.891 align:middle
分享的功能性进行打包的
一种相当不错的方式

00:11:59.386 --> 00:12:03.891 align:middle
分享的功能性进行打包的
一种相当不错的方式

00:12:04.591 --> 00:12:06.960 align:middle
我们有三个实体
我们有PlayerBot

00:12:07.461 --> 00:12:09.463 align:middle
GroundBot
以及FlyingBot

00:12:10.364 --> 00:12:11.765 align:middle
它们有一些共同之处

00:12:12.432 --> 00:12:14.168 align:middle
它们都需要被渲染进场景中

00:12:14.368 --> 00:12:15.335 align:middle
它们都需要一个阴影

00:12:15.669 --> 00:12:18.705 align:middle
所以要完成这些事情我们就有了
一个渲染元件以及一个阴影元件

00:12:19.506 --> 00:12:22.776 align:middle
它们也都有动画 物理现象和智能

00:12:22.843 --> 00:12:25.112 align:middle
这些名称就是我们给予
状态机 让它跟踪的名称

00:12:26.747 --> 00:12:29.416 align:middle
此时你可能会以为它们看起来很像

00:12:30.150 --> 00:12:33.320 align:middle
为什么不用一个基本
Bot类来给这三个实体

00:12:33.387 --> 00:12:35.289 align:middle
提供全部功能性呢？

00:12:36.490 --> 00:12:38.258 align:middle
别忘了 它们实际上并不是相似的

00:12:39.193 --> 00:12:42.663 align:middle
需要对PlayerBot进行输入
我们可以通过一个游戏控制器

00:12:42.963 --> 00:12:46.500 align:middle
键盘或者通过触模控制对它进行控制

00:12:47.467 --> 00:12:51.038 align:middle
GroundBot以及FlyingBot
并不需要进行输入你无法控制这些角色

00:12:51.104 --> 00:12:53.340 align:middle
它们是由一个代理驱动的

00:12:53.707 --> 00:12:57.044 align:middle
稍后你会看到我们是怎样使用代理
来在关卡中驱动这些角色的

00:12:57.611 --> 00:12:59.112 align:middle
PlayerBot
并不需要一个代理

00:12:59.179 --> 00:13:00.581 align:middle
它的动力来自你的输入

00:12:59.179 --> 00:13:00.581 align:middle
它的动力来自你的输入

00:13:01.748 --> 00:13:03.817 align:middle
同样地GroundBot
以及FlyingBot

00:13:03.884 --> 00:13:06.286 align:middle
也需要遵循一些规则 这些
规则会告诉它们在某个指定

00:13:06.353 --> 00:13:08.589 align:middle
情景下 它们应该怎么做
稍后我们也会看看这个

00:13:09.423 --> 00:13:12.125 align:middle
PlayerBot就不需要这些规则
你会告诉他他该怎么做

00:13:12.926 --> 00:13:16.029 align:middle
PlayerBot和GroundBot
确实有一件共同之处

00:13:16.530 --> 00:13:18.599 align:middle
它们都有一个运动元件

00:13:19.633 --> 00:13:21.869 align:middle
这个元件的作用就是说
举个例子 我在这里

00:13:22.402 --> 00:13:24.771 align:middle
我需要以某个角度 移动这个距离

00:13:25.105 --> 00:13:26.707 align:middle
在场景中把我移过去吧

00:13:27.274 --> 00:13:31.512 align:middle
PlayerBot会使用那个输入
在场景中渲染它让他四处运动

00:13:32.379 --> 00:13:34.481 align:middle
而GroundBot则会用它
来进行冲锋攻击

00:13:34.781 --> 00:13:37.150 align:middle
他从这里开始移动 然后发起冲锋

00:13:37.951 --> 00:13:39.686 align:middle
FlyingBot
则不需要那项能力

00:13:39.753 --> 00:13:42.623 align:middle
他不会移动 因此他没有那个元件

00:13:43.757 --> 00:13:46.627 align:middle
这些元件是对功能性进行分解

00:13:46.693 --> 00:13:49.630 align:middle
并且仅仅把它们分配给
需要它们的实体的好方法

00:13:51.965 --> 00:13:56.170 align:middle
这些就是我们在游戏中使用
GameplayKit功能性的一些方法

00:13:56.904 --> 00:13:59.806 align:middle
我想邀请戴夫到台上来
再给你们讲讲我们是如何

00:13:59.873 --> 00:14:01.441 align:middle
使用GameplayKit
来创建我们的

00:13:59.873 --> 00:14:01.441 align:middle
使用GameplayKit
来创建我们的

00:14:01.508 --> 00:14:03.610 align:middle
游戏 “逻辑与玩法”

00:14:09.816 --> 00:14:14.154 align:middle
谢谢 戴夫 当我们想到玩法中的逻辑

00:14:14.321 --> 00:14:18.058 align:middle
当我想到玩法中的逻辑
那么最先浮现在我的脑海中的

00:14:18.458 --> 00:14:20.928 align:middle
就是我的对手的实际智能

00:14:22.329 --> 00:14:25.799 align:middle
关于智能其中非常重要的一点

00:14:25.866 --> 00:14:30.904 align:middle
就是在那个空间内 我到底能做什么？

00:14:31.872 --> 00:14:34.775 align:middle
就像我们之前在演示中
看到的 如果我是一个好Bot

00:14:34.842 --> 00:14:37.945 align:middle
我会在关卡内四处走动沿着
线路巡逻维持秩序

00:14:38.979 --> 00:14:42.115 align:middle
而如果我是一个坏的Bot
我就想要攻击PlayerBot

00:14:44.318 --> 00:14:45.485 align:middle
这次逮到他了

00:14:46.753 --> 00:14:50.991 align:middle
我可能也不会把其它TaskBots
变成坏的TaskBots

00:14:51.625 --> 00:14:53.360 align:middle
因此当它逮到PlayerBot时
我也可以出点力

00:14:53.527 --> 00:14:54.361 align:middle
又逮到一个

00:14:55.829 --> 00:15:01.935 align:middle
最后 我可能会在关卡内
以相反的方向四周走动

00:14:55.829 --> 00:15:01.935 align:middle
最后 我可能会在关卡内
以相反的方向四周走动

00:15:02.002 --> 00:15:05.439 align:middle
干扰线路上的感应 电流 引发问题

00:15:06.940 --> 00:15:08.775 align:middle
这就不那么有趣了

00:15:09.476 --> 00:15:13.847 align:middle
但是既然我们知道了我们能做什么
那么问题就变成了我们怎样

00:15:13.914 --> 00:15:16.750 align:middle
来决定我们应该做什么

00:15:17.818 --> 00:15:19.586 align:middle
DemoBots中 我们选择使用

00:15:19.653 --> 00:15:24.825 align:middle
GKRuleSystem实现了一个
模糊逻辑系统

00:15:25.526 --> 00:15:31.565 align:middle
它的优点在于 我们仍然可以接受
与关卡的当前状态相关的大量信息

00:15:32.032 --> 00:15:36.603 align:middle
发生了什么事情并且让我们的角色
对那个信息做出反应

00:15:37.471 --> 00:15:40.741 align:middle
我们无需使用绵延数百行
代码的if else树

00:15:40.807 --> 00:15:42.943 align:middle
就可以实现这一点

00:15:43.277 --> 00:15:47.414 align:middle
我们有一些简单的规则
我们也依赖这些简单的规则

00:15:47.481 --> 00:15:51.185 align:middle
和他人进行互动允许
出现复杂有趣的行为

00:15:52.452 --> 00:15:57.491 align:middle
如果你不熟悉模糊逻辑 那么我再给你

00:15:57.558 --> 00:15:59.726 align:middle
讲一讲我们在这里谈的是什么

00:16:00.260 --> 00:16:04.364 align:middle
我们提到的“模糊”
指的是这样一个事实

00:16:04.431 --> 00:16:07.868 align:middle
所有的事情并不是非黑即白 非真即假

00:16:08.235 --> 00:16:10.337 align:middle
我们的规则并不是互相排斥的

00:16:12.706 --> 00:16:17.211 align:middle
我们的规则是以自然概念
为模型的 你可以尝试

00:16:17.277 --> 00:16:20.214 align:middle
把它们当做你会对一位同事说的句子

00:16:20.781 --> 00:16:22.549 align:middle
PlayerBot就类似这个...

00:16:23.917 --> 00:16:27.955 align:middle
...在模糊TaskBots
规则类中实现的就是这些

00:16:29.289 --> 00:16:30.991 align:middle
它是GKRule的一个子类

00:16:31.892 --> 00:16:37.164 align:middle
实际上 我们把规则事实
绑定到了这里的等级上

00:16:38.165 --> 00:16:41.268 align:middle
只有当等级大于零时
我们才会断言事实

00:16:42.870 --> 00:16:46.340 align:middle
这很有趣 因为我们会对
那个等级中能够获得的信息的

00:16:46.406 --> 00:16:49.076 align:middle
实际状态函数进行分级

00:16:51.345 --> 00:16:53.914 align:middle
而不是某种当你在创建GKRule时

00:16:53.981 --> 00:16:55.349 align:middle
设置的东西

00:16:56.450 --> 00:16:58.051 align:middle
看看这些

00:16:58.619 --> 00:17:04.358 align:middle
看看邻近规则是什么样的

00:16:58.619 --> 00:17:04.358 align:middle
看看邻近规则是什么样的

00:17:04.758 --> 00:17:07.594 align:middle
它考虑的是远近

00:17:08.462 --> 00:17:11.531 align:middle
让我们来实际通过一个图表看看这个

00:17:11.665 --> 00:17:13.267 align:middle
看看这些函数的工作原理

00:17:14.001 --> 00:17:17.436 align:middle
在上面的起点附近你可以看到
我们有一台PlayerBot

00:17:18.005 --> 00:17:21.208 align:middle
外面远处 我们能够到的地方
我们还有一台TaskBot

00:17:21.808 --> 00:17:24.511 align:middle
如果我拿出一个远处规则的图解表示

00:17:24.645 --> 00:17:29.783 align:middle
那么看出远处规则的分级
就是这个类的分级

00:17:29.850 --> 00:17:31.952 align:middle
这就非常容易了

00:17:32.920 --> 00:17:35.489 align:middle
如果我把中等距离规则
以及近处规则拉进来

00:17:35.989 --> 00:17:39.693 align:middle
那么很明显 它们在这种
情况下的分级就是零

00:17:40.494 --> 00:17:43.630 align:middle
虽然这个阵式看起来不是那么有趣

00:17:43.797 --> 00:17:48.268 align:middle
它看起来也确实是某种程度的
非黑即白 非真即假

00:17:49.236 --> 00:17:54.074 align:middle
如果我们把我们的TaskBot移近
一点 那么你就可以更清楚地

00:17:54.208 --> 00:17:55.609 align:middle
看到我说的是什么

00:17:55.876 --> 00:17:57.778 align:middle
这是远处规则的分级

00:17:58.145 --> 00:18:01.849 align:middle
七十五 而中等距离规则大约是

00:17:58.145 --> 00:18:01.849 align:middle
七十五 而中等距离规则大约是

00:18:02.216 --> 00:18:06.253 align:middle
二十五 如果我们继续让他靠近
那么事情就发生变化了

00:18:07.354 --> 00:18:11.491 align:middle
就同时属于邻近规则中等距离规则了

00:18:13.727 --> 00:18:16.029 align:middle
既然你已经看过了我们会计算

00:18:16.096 --> 00:18:18.699 align:middle
我们的分级的函数是什么样的

00:18:19.967 --> 00:18:24.438 align:middle
那么让我们再来看看 一旦
我们为我们的每一条规则

00:18:24.505 --> 00:18:27.274 align:middle
计算出来那些规则
我们又该怎样做出决定

00:18:27.841 --> 00:18:30.878 align:middle
这是我们在
DemoBots上用的规则

00:18:32.412 --> 00:18:34.815 align:middle
我们的第一步就像我说过的

00:18:34.882 --> 00:18:36.984 align:middle
就是对它们进行评估计算值是什么

00:18:37.985 --> 00:18:41.922 align:middle
我们接下来要做的事情
就是把它们中的几个组合起来

00:18:42.689 --> 00:18:47.127 align:middle
判定它们是否属于当我们在
猎捕PlayerBot时

00:18:47.794 --> 00:18:50.964 align:middle
我们需要注意的影响因素

00:18:51.665 --> 00:18:54.701 align:middle
它读起来就像一个句子
你也就可以看 它的工作原理

00:18:54.768 --> 00:18:56.570 align:middle
就类似讲一个故事那样

00:18:57.504 --> 00:19:00.340 align:middle
如果坏的TaskBots的
百分比较高

00:18:57.504 --> 00:19:00.340 align:middle
如果坏的TaskBots的
百分比较高

00:19:00.874 --> 00:19:03.377 align:middle
PlayerBot离它的
距离是一个中等距离

00:19:04.044 --> 00:19:07.614 align:middle
而好的TaskBot
离它的距离也是一个中等距离

00:19:09.750 --> 00:19:11.785 align:middle
那么我会想要猎捕这个
PlayerBot

00:19:12.586 --> 00:19:14.721 align:middle
在这个例子中我想这样做的原因是

00:19:14.922 --> 00:19:18.792 align:middle
我的思维方式是
如果这一关卡中已经有了很多

00:19:18.859 --> 00:19:22.162 align:middle
坏的TaskBots
那么我就不需要去改造它们

00:19:22.462 --> 00:19:24.698 align:middle
此时我就可以猎捕玩家

00:19:25.866 --> 00:19:30.304 align:middle
麻烦在于我有三个不同的等级

00:19:30.671 --> 00:19:33.707 align:middle
来表示现在猎捕
PlayerBot这个概念

00:19:34.942 --> 00:19:39.880 align:middle
因此我们要使用GKRuleSystems
来把事实的分级最小化

00:19:40.347 --> 00:19:45.853 align:middle
要抓取我们想要组合的
每个事实的最小分级

00:19:47.354 --> 00:19:52.993 align:middle
我们选择最小分级的原因在于
我们猎捕PlayerBot的

00:19:53.393 --> 00:19:56.563 align:middle
指令所基于的信息强度仅仅

00:19:56.630 --> 00:19:59.600 align:middle
与起作用的最弱的事实一样

00:20:01.301 --> 00:20:06.807 align:middle
我们可以以任何方式
对这些规则进行组合

00:20:06.907 --> 00:20:10.878 align:middle
然后得到几个不同的
指示符指示到底是应该

00:20:10.944 --> 00:20:13.780 align:middle
猎捕PlayerBot
还是应该猎捕TaskBots

00:20:14.815 --> 00:20:16.416 align:middle
在这个阶段我们实际上

00:20:17.251 --> 00:20:22.890 align:middle
就需要规则清晰下来
得到一个能够表示猎捕

00:20:23.290 --> 00:20:26.660 align:middle
PlayerBot这一理念的
简单的数字

00:20:28.161 --> 00:20:30.130 align:middle
在这个例子中我们把我们的事实取出来

00:20:30.831 --> 00:20:32.799 align:middle
使用Swift的归约函数

00:20:33.567 --> 00:20:36.036 align:middle
以及最大函数来把事情组合到一起

00:20:36.436 --> 00:20:40.407 align:middle
在这个例子中我们实际上
就需要猎捕PlayerBot

00:20:40.474 --> 00:20:42.709 align:middle
或者猎捕TaskBots
通过我们所有的

00:20:43.043 --> 00:20:46.480 align:middle
最强大的分级来表示

00:20:47.181 --> 00:20:50.851 align:middle
看看这些数字很明显
我们应该猎捕PlayerBot

00:20:53.153 --> 00:20:56.423 align:middle
既然我们知道了我们想要猎捕
PlayerBot那么我们的第一个问题

00:21:02.196 --> 00:21:07.501 align:middle
就是我到底怎样
才能接触到PlayerBot？

00:21:08.202 --> 00:21:10.037 align:middle
一般来说这是非常直接的

00:21:11.205 --> 00:21:14.141 align:middle
只需要直线移动
然后你最终就会接触到它

00:21:16.376 --> 00:21:18.612 align:middle
但是障碍物是一个挑战

00:21:18.745 --> 00:21:22.115 align:middle
这里你可以看到
FlyingBot就悬挂在那里

00:21:22.716 --> 00:21:26.386 align:middle
你回忆起了几年前的
一个示例“冒险”

00:21:26.753 --> 00:21:31.024 align:middle
那个示例中的哥布林
也非常喜欢表现出这种行为

00:21:32.292 --> 00:21:34.461 align:middle
我们决定要采取一些行动

00:21:34.962 --> 00:21:38.699 align:middle
在GameplayKit中我们让你
对某个场景中寻路的利用

00:21:39.099 --> 00:21:43.904 align:middle
变得非常容易了这样
你就可以非常容易地

00:21:44.404 --> 00:21:47.140 align:middle
让你的Bots或者你的敌人
像这样进行移动

00:21:47.774 --> 00:21:50.577 align:middle
当你把SpriteKit用在一款
游戏上时配合其它事情

00:21:50.644 --> 00:21:54.381 align:middle
就非常方便了把事情设置好 运行起来

00:21:54.815 --> 00:21:56.283 align:middle
也就非常容易了

00:21:56.950 --> 00:21:58.819 align:middle
只需要几行代码即可

00:21:59.019 --> 00:22:01.522 align:middle
我们来看看这些代码是什么样的

00:21:59.019 --> 00:22:01.522 align:middle
我们来看看这些代码是什么样的

00:22:04.491 --> 00:22:07.394 align:middle
你要做的第一件事实际上

00:22:08.061 --> 00:22:11.798 align:middle
就是获得组成关卡的多边形障碍物

00:22:12.099 --> 00:22:18.272 align:middle
在我们的例子中 我们首先
要在场景中搜索我们的节点

00:22:18.505 --> 00:22:20.073 align:middle
它们都被命名为障碍物

00:22:20.174 --> 00:22:23.243 align:middle
当我们有了一个那些节点的
阵列后 我们就把它传递到

00:22:23.443 --> 00:22:27.347 align:middle
SKNodes在iOS 9上
的一个便利函数

00:22:27.781 --> 00:22:29.516 align:middle
节点物理实体障碍物

00:22:30.417 --> 00:22:34.755 align:middle
拿出你定义使用的实际物理实体

00:22:34.821 --> 00:22:37.157 align:middle
对障碍物进行定义

00:22:38.091 --> 00:22:40.561 align:middle
有了这些障碍物当我们有了这些障碍物

00:22:41.495 --> 00:22:45.399 align:middle
我们就要用它们来构造一个障碍物图表

00:22:45.866 --> 00:22:48.001 align:middle
并且构造一个缓冲区半径参数

00:22:48.602 --> 00:22:52.940 align:middle
这个参数就是围绕实际障碍物的

00:22:53.307 --> 00:22:55.175 align:middle
一些附加空格

00:22:55.876 --> 00:22:58.278 align:middle
要想理解这一点你可以想想

00:22:58.879 --> 00:23:01.715 align:middle
当你朝着一个门口走去当你穿过门口

00:22:58.879 --> 00:23:01.715 align:middle
当你朝着一个门口走去当你穿过门口

00:23:01.849 --> 00:23:06.687 align:middle
你并没有真的走到门框的某个角落

00:23:07.221 --> 00:23:10.157 align:middle
你要瞄准的是门口中间的某个点

00:23:10.424 --> 00:23:14.061 align:middle
当你穿过门口的时候你的身体的
任何部位并不会真的接触到门

00:23:14.728 --> 00:23:19.032 align:middle
半径可以帮助设置围绕障碍物的空格

00:23:20.267 --> 00:23:26.173 align:middle
接下来我们要取出TaskBot
和PlayerBot的位置

00:23:26.673 --> 00:23:28.408 align:middle
然后把它们连接到图表上

00:23:29.510 --> 00:23:35.148 align:middle
最后我们会让图表
给我们一条从起始节点

00:23:35.883 --> 00:23:37.484 align:middle
终端节点的路径

00:23:38.118 --> 00:23:40.888 align:middle
我们得到的就是单独的节点的阵列

00:23:41.321 --> 00:23:44.658 align:middle
而这些节点对于从A点
到B点来说是必须的

00:23:45.392 --> 00:23:49.329 align:middle
把事情从走路转变成存储器片

00:23:49.396 --> 00:23:52.432 align:middle
同时实际跟着它们走动就是这么简单

00:23:53.767 --> 00:23:57.704 align:middle
我们有了一条路径有了点

00:23:58.071 --> 00:23:59.806 align:middle
但是我怎样才能真的去到那里？

00:24:00.274 --> 00:24:03.110 align:middle
我怎样才能真的优雅地去到那里？

00:24:04.077 --> 00:24:07.981 align:middle
GameplayKit再一次给我们
提供了一个答复

00:24:08.549 --> 00:24:11.385 align:middle
这次是GKAgent 2D

00:24:12.019 --> 00:24:15.689 align:middle
这个类是我最喜欢的
GameplayKit类之一

00:24:16.690 --> 00:24:20.027 align:middle
这是一个GKComponent
它和戴夫之前谈到的实体/元件

00:24:20.093 --> 00:24:22.829 align:middle
系统配合的天衣无缝

00:24:24.731 --> 00:24:27.401 align:middle
把事情设置好非常简单

00:24:28.268 --> 00:24:32.206 align:middle
你有一个GKBehavior
它描述了你想要这个代理去做的事情

00:24:32.506 --> 00:24:35.175 align:middle
它就好比是GKGoals的一个容器

00:24:35.976 --> 00:24:40.714 align:middle
GKGoal 我们很幸运
这个例子中实际上就有几个

00:24:40.781 --> 00:24:46.553 align:middle
不同的构造这些构造允许我们兼容路径

00:24:47.020 --> 00:24:49.289 align:middle
因为代理的世界
GameplayKit的世界

00:24:49.356 --> 00:24:51.525 align:middle
不同于SpriteKit的世界

00:24:52.526 --> 00:24:55.762 align:middle
这里的委托就使得
把它们两个集成到一起

00:24:56.029 --> 00:24:57.164 align:middle
非常容易

00:24:59.199 --> 00:25:03.203 align:middle
我们来看看 实际上...
你懂得看看代码实际是什么样的

00:24:59.199 --> 00:25:03.203 align:middle
我们来看看 实际上...
你懂得看看代码实际是什么样的

00:25:04.271 --> 00:25:07.641 align:middle
我们把我们之前获得的
路径节点阵列拿出来

00:25:10.944 --> 00:25:13.180 align:middle
我们要对它们进行初始化

00:25:15.115 --> 00:25:19.286 align:middle
我们要把它传递到一个初始化
程序来创建我们的路径

00:25:19.853 --> 00:25:22.723 align:middle
这里还有一个参数它就是半径

00:25:22.789 --> 00:25:28.562 align:middle
我想让你们在这里思考下
你想让这个路径怎样为你的代理下定义

00:25:28.896 --> 00:25:33.367 align:middle
太小的值会让你的代理把你的
路径当成类似一根绷紧的绳索来对待

00:25:34.101 --> 00:25:37.938 align:middle
而较大的值 你懂得
就会让它们把它当成类似一条

00:25:38.005 --> 00:25:40.774 align:middle
八车道高速公路来对待
把它们都移动到这个地方

00:25:41.275 --> 00:25:44.411 align:middle
你可能想要调整下看看
哪种最适合你的游戏

00:25:46.380 --> 00:25:47.981 align:middle
接下来我们要创建一个行为

00:25:48.549 --> 00:25:51.485 align:middle
这只是一个空的行为
并没有真的发生什么事情

00:25:52.452 --> 00:25:54.888 align:middle
然后我们向它添加目标

00:25:55.822 --> 00:25:59.092 align:middle
这些是两个路径相关的目标
我之前已经谈到过了

00:25:59.726 --> 00:26:04.064 align:middle
屏幕上的第一个目标
我们跟随路径的目标将会

00:25:59.726 --> 00:26:04.064 align:middle
屏幕上的第一个目标
我们跟随路径的目标将会

00:26:05.232 --> 00:26:09.136 align:middle
确立我们移动我们的阵列的方向

00:26:09.536 --> 00:26:11.572 align:middle
在这个例子中我们会从起始位置

00:26:11.738 --> 00:26:15.475 align:middle
向前移动 把我们的
TaskBots移动到终点位置

00:26:15.542 --> 00:26:17.344 align:middle
也就是我们的
PlayerBot的位置

00:26:18.111 --> 00:26:23.650 align:middle
停留在路径上这个目标
会促使我们的代理

00:26:23.984 --> 00:26:30.624 align:middle
保持在我们之前定义的路径的边界内

00:26:32.326 --> 00:26:37.464 align:middle
既然我们有了一个工作行为我们把它
指定给我们的代理让它开始移动

00:26:39.733 --> 00:26:42.769 align:middle
代理工作的方式

00:26:43.470 --> 00:26:46.707 align:middle
和GameplayKit上
许多其他元件的工作方式类似

00:26:47.207 --> 00:26:48.809 align:middle
它会在一个循环上进行更新

00:26:49.409 --> 00:26:52.179 align:middle
当你把它添加进你的更新循环时

00:26:53.280 --> 00:26:57.751 align:middle
它就会在变更前后通知到你

00:26:57.818 --> 00:27:00.888 align:middle
这个变更前后的委托通知
就是让事情运行起来

00:26:57.818 --> 00:27:00.888 align:middle
这个变更前后的委托通知
就是让事情运行起来

00:27:01.321 --> 00:27:05.559 align:middle
同SpriteKit
连接起来的理想场所

00:27:06.894 --> 00:27:12.833 align:middle
在WillUpdate中这个位置就是
你想从你的SpriteKit节点中

00:27:14.334 --> 00:27:17.571 align:middle
取出信息的位置

00:27:17.738 --> 00:27:20.040 align:middle
这些节点表示场景中你的代理

00:27:20.874 --> 00:27:24.311 align:middle
把那个信息撤回并且更新代理

00:27:25.279 --> 00:27:27.548 align:middle
因为我们是在
SpriteKit更新循环前面

00:27:28.215 --> 00:27:31.552 align:middle
这样做的
最后一个SpriteKit更新循环

00:27:31.919 --> 00:27:34.755 align:middle
就会涉及到

00:27:35.022 --> 00:27:38.625 align:middle
对物理现象进行模拟
对你的节点应用约束

00:27:38.859 --> 00:27:41.028 align:middle
这就可能导致它的位置
从代理最后一次思考时

00:27:41.094 --> 00:27:44.064 align:middle
代理本以为它在的位置上移开

00:27:46.466 --> 00:27:50.304 align:middle
在AgentDidUpdate中
我们会把信息从代理那里拿出来

00:27:51.305 --> 00:27:54.141 align:middle
它的位置它的旋转类似此类的事情

00:27:55.008 --> 00:27:57.911 align:middle
然后把它们撤回
SpriteKit世界

00:27:57.978 --> 00:28:01.949 align:middle
并且在它此时进入
物理现象模拟 约束应用

00:27:57.978 --> 00:28:01.949 align:middle
并且在它此时进入
物理现象模拟 约束应用

00:28:02.349 --> 00:28:04.918 align:middle
之前对你的节点进行更新

00:28:07.221 --> 00:28:11.558 align:middle
此时我们用DemoBots

00:28:12.292 --> 00:28:14.394 align:middle
得到的就是这个

00:28:15.229 --> 00:28:18.232 align:middle
一个工作干的漂亮
轻而易举就可以围绕屏幕进行移动

00:28:18.298 --> 00:28:21.568 align:middle
同你的交互非常平滑的智能

00:28:22.469 --> 00:28:27.241 align:middle
我猜这是附加的东西
我们把调制绘图放到

00:28:27.941 --> 00:28:30.210 align:middle
示例中了你可以去下载

00:28:31.211 --> 00:28:33.947 align:middle
你可以通过点击斜线键来启用它

00:28:35.816 --> 00:28:38.418 align:middle
关于这个很棒的一件事是
它可以帮助你想象出

00:28:38.485 --> 00:28:40.053 align:middle
我们之前谈到的一些参数

00:28:40.420 --> 00:28:44.892 align:middle
黄色框是围绕障碍物的缓冲区半径

00:28:46.393 --> 00:28:51.698 align:middle
你可以看到玩家放射出粗线

00:28:51.765 --> 00:28:54.735 align:middle
TaskBots表示的是

00:28:55.235 --> 00:28:59.973 align:middle
我们之前谈到的路径那里的路径半径

00:29:01.375 --> 00:29:02.943 align:middle
既然我们有了一款游戏

00:29:03.944 --> 00:29:07.047 align:middle
我想邀请我的同事迈克尔上台来

00:29:07.414 --> 00:29:12.452 align:middle
他会和你们讨论一下怎样才能让
你的用户以更快的运行速度玩你的游戏

00:29:13.086 --> 00:29:13.921 align:middle
迈克尔

00:29:19.359 --> 00:29:23.864 align:middle
谢谢 我们来谈谈
怎么制作一个有趣的游戏

00:29:23.931 --> 00:29:27.301 align:middle
怎样给你的用户提供一个
很棒的整体体验

00:29:27.367 --> 00:29:31.638 align:middle
我会把它浓缩成一个短语 也就是
当然就是找乐子时间到了

00:29:31.705 --> 00:29:33.841 align:middle
你的用户需要多久才能真正开始

00:29:33.907 --> 00:29:35.442 align:middle
享受你的游戏？

00:29:36.376 --> 00:29:39.580 align:middle
第一个要迈过的障碍
实际上就是初始下载

00:29:40.013 --> 00:29:43.951 align:middle
如果你提供的app太大了
有些用户就不能通过

00:29:44.017 --> 00:29:45.752 align:middle
蜂窝网数据来下载它

00:29:46.086 --> 00:29:47.988 align:middle
即使通过Wi-Fi下载
可能也需要好一阵

00:29:48.989 --> 00:29:50.624 align:middle
你的用户在App Store中找到

00:29:50.924 --> 00:29:56.597 align:middle
app以及决定下载这个app之间
最大的潜在因素就是这个

00:29:57.531 --> 00:30:01.368 align:middle
但是我们知道对于游戏来说
很难保持在这个一百万下载限制以内

00:29:57.531 --> 00:30:01.368 align:middle
但是我们知道对于游戏来说
很难保持在这个一百万下载限制以内

00:30:01.702 --> 00:30:05.472 align:middle
我们再回到DemoBots看看
我们是如何处理这个问题的

00:30:06.440 --> 00:30:09.243 align:middle
如果你仔细看PlayerBot
你就会注意到 我们并不是绝对

00:30:09.309 --> 00:30:10.777 align:middle
自上而下地看这个角色的

00:30:11.378 --> 00:30:14.281 align:middle
这不是一个带有等距感觉的2D游戏

00:30:14.948 --> 00:30:18.852 align:middle
我们是通过赋予这个
角色多个朝向而实现的

00:30:19.753 --> 00:30:22.456 align:middle
当你让这个角色在地图上四处走动时

00:30:22.789 --> 00:30:25.492 align:middle
我们就会换出代表这个角色的纹理

00:30:25.726 --> 00:30:27.427 align:middle
得到这个透视图

00:30:28.328 --> 00:30:32.432 align:middle
当你在那里添加各个附加帧的
时候 它们会占据空间

00:30:32.499 --> 00:30:34.968 align:middle
它只有六兆字节
对于一个游戏来说不大

00:30:35.035 --> 00:30:38.105 align:middle
当你认为它是六兆字节的
时候 要乘以三个bots

00:30:38.172 --> 00:30:41.575 align:middle
我们还要乘以它们可以执行的不同动作

00:30:41.875 --> 00:30:45.412 align:middle
当PlayerBot闲置 攻击
四处走动时我们还需要定向帧

00:30:45.479 --> 00:30:49.249 align:middle
因此这个数字就开始积少成多了

00:30:50.450 --> 00:30:54.221 align:middle
从传统意义上来说
这就意味着所有的资产再加上

00:30:54.288 --> 00:30:56.823 align:middle
各自的1X 2X 3X版本
都打包进了app

00:30:58.392 --> 00:31:00.294 align:middle
现在我们对此有了一个更好的解决方法

00:30:58.392 --> 00:31:00.294 align:middle
现在我们对此有了一个更好的解决方法

00:31:00.694 --> 00:31:02.229 align:middle
本周早些时候你可以已经听说过了

00:31:02.729 --> 00:31:06.366 align:middle
如果你用的是资产目录的话
你可以利用一项叫做

00:31:06.433 --> 00:31:07.901 align:middle
“app分割”的新的特性

00:31:08.402 --> 00:31:12.906 align:middle
“app分割”所做的
就是为资产实际运行的设备

00:31:14.408 --> 00:31:16.476 align:middle
1X、2X、3X分类

00:31:17.211 --> 00:31:19.880 align:middle
只要使用资产目录让App
Store为你分割你的app

00:31:20.247 --> 00:31:23.550 align:middle
就可以节省我们大量的空间

00:31:24.284 --> 00:31:26.620 align:middle
它不仅仅意味着我们现在可以
节省大量的空间

00:31:26.687 --> 00:31:29.423 align:middle
它还意味着我们可以用我们的app内
多余的存储空间来干什么

00:31:29.489 --> 00:31:31.124 align:middle
我现在看到的是图表这是个空的图表

00:31:31.892 --> 00:31:34.962 align:middle
在DemoBots中
这是有实践含义的

00:31:36.597 --> 00:31:41.134 align:middle
我们一开始有八个朝向
我在这里给你们看一个视频仔细看

00:31:41.201 --> 00:31:44.137 align:middle
看起来PlayerBot
是面朝正前方的

00:31:44.738 --> 00:31:47.574 align:middle
你会注意到 仔细看这个动作
看看你能不能注意到什么事情

00:31:58.785 --> 00:32:01.488 align:middle
具体来说 就是当角色朝着
地图顶部那里向后移动时

00:31:58.785 --> 00:32:01.488 align:middle
具体来说 就是当角色朝着
地图顶部那里向后移动时

00:32:01.555 --> 00:32:04.658 align:middle
我们把那个动作叫做“滑冰”

00:32:05.025 --> 00:32:08.862 align:middle
虽然我们只有八个朝向
来表示角色的运动

00:32:09.029 --> 00:32:13.233 align:middle
玩家提供的却是三百六十度的
输入我们可以稍微倾斜下

00:32:13.300 --> 00:32:16.503 align:middle
那个朝向 但并不触发下一个朝向

00:32:16.803 --> 00:32:19.139 align:middle
然后你就得到了这个轰炸行为

00:32:19.973 --> 00:32:22.876 align:middle
使用八个朝向更令人沮丧的是

00:32:23.410 --> 00:32:27.181 align:middle
你可能最后会出现类似这样的情况

00:32:27.347 --> 00:32:29.483 align:middle
PlayerBot
面朝正前方 看起来它应该

00:32:29.716 --> 00:32:33.086 align:middle
很容易就可以攻击到那个
TaskBot实际上并没有攻击到

00:32:33.153 --> 00:32:36.456 align:middle
因为调试绘制你可以
看到玩家瞄准的是侧面

00:32:36.523 --> 00:32:39.560 align:middle
但是玩家却无法看到这个

00:32:40.227 --> 00:32:43.730 align:middle
有了我们通过“app分割”获得的
多余的空间 我们就可以增加一个缺口

00:32:44.198 --> 00:32:45.999 align:middle
我们增加到十六个朝向

00:32:46.500 --> 00:32:49.603 align:middle
这样游戏内的运动就感觉更平滑了

00:32:50.871 --> 00:32:54.541 align:middle
你可以看到我们在这里有了
更多的动画帧来进行表示

00:32:56.810 --> 00:33:00.180 align:middle
然后当进行瞄准时粒度就更多了

00:32:56.810 --> 00:33:00.180 align:middle
然后当进行瞄准时粒度就更多了

00:33:00.380 --> 00:33:02.683 align:middle
角色朝向的位置基本上精确对应到了

00:33:02.749 --> 00:33:05.319 align:middle
射线将要集中的方向

00:33:06.119 --> 00:33:10.991 align:middle
你在那里点击下用户就可以
更容易地知道游戏内的情况了

00:33:12.726 --> 00:33:15.462 align:middle
“app分割” 我们可以在
DemoBots中简单地通过

00:33:15.529 --> 00:33:18.232 align:middle
把我们的纹理地图册
放进资产目录中来实现

00:33:18.632 --> 00:33:21.568 align:middle
它可以帮助我们大幅度降低
app的整体大小

00:33:22.102 --> 00:33:26.373 align:middle
不仅如此 我们现在还可以实际提高
可玩性这是因为我们有了多余空间

00:33:27.307 --> 00:33:30.777 align:middle
这项特性和你在游戏中时刻需要的资产

00:33:30.844 --> 00:33:32.012 align:middle
配合的非常默契

00:33:32.446 --> 00:33:36.149 align:middle
除非我们有PlayerBot
否则DemoBots就不太像一个游戏了

00:33:36.683 --> 00:33:40.420 align:middle
但是还有一些其他资产这些资产并
不是我们时刻都必须用到的

00:33:40.521 --> 00:33:42.556 align:middle
针对这点 我们还有一项技术

00:33:42.623 --> 00:33:45.759 align:middle
你本周早些时候在“点播资源”
那里可能已经听说过了

00:33:46.159 --> 00:33:49.229 align:middle
简单描述下
你可以通过一个简单的字符串

00:33:49.296 --> 00:33:51.532 align:middle
对你的资源进行标记标记为稍后再下载

00:33:52.232 --> 00:33:54.501 align:middle
我来谈谈我们是怎样在
DemoBots上把这个用起来的

00:33:54.568 --> 00:33:56.236 align:middle
第一个地方就是可能已经很明显了

00:33:56.303 --> 00:34:00.707 align:middle
我们有多个关卡我们可以把这些标记为
关卡一 关卡二 关卡三

00:33:56.303 --> 00:34:00.707 align:middle
我们有多个关卡我们可以把这些标记为
关卡一 关卡二 关卡三

00:34:02.376 --> 00:34:05.312 align:middle
好处在于 我们现在已经用
输出数据寄存器把这些标记出来了

00:34:05.679 --> 00:34:09.917 align:middle
我们就可以说如果用户初始下载游戏
我们知道他们回到关卡一

00:34:09.983 --> 00:34:13.587 align:middle
我们就没有理由把另外
两个关卡也包括到那里去

00:34:14.821 --> 00:34:18.158 align:middle
随着游戏进展事情就更有趣了

00:34:18.692 --> 00:34:21.728 align:middle
因为我们可以用这个线性流进行预测

00:34:21.795 --> 00:34:24.063 align:middle
用户将会继续到达关卡三

00:34:24.431 --> 00:34:30.103 align:middle
我们就能提前下载那个关卡
用户不大可能会重玩关卡一

00:34:30.469 --> 00:34:32.539 align:middle
因此我们就可以回收一些资源

00:34:34.574 --> 00:34:35.842 align:middle
我们来再进一步

00:34:36.310 --> 00:34:40.147 align:middle
如果我们仔细看关卡二你会在这个演示

00:34:40.214 --> 00:34:42.349 align:middle
这个小照片上注意到

00:34:42.416 --> 00:34:44.751 align:middle
FlyingBot只会出现在
这个关卡中

00:34:45.185 --> 00:34:46.553 align:middle
然后在关卡三中又出现了

00:34:47.286 --> 00:34:51.425 align:middle
把它和出现在关卡一以及
关卡三中的GroundBot相对照

00:34:52.726 --> 00:34:57.631 align:middle
但我们单独标记角色时
我们就可以对我们的资源做进一步分类

00:34:57.764 --> 00:34:59.700 align:middle
如果我们知道用户是第一次下载app

00:34:59.766 --> 00:35:02.803 align:middle
我们就只把GroundBot弄到
关卡一中 我们可以稍后再

00:34:59.766 --> 00:35:02.803 align:middle
我们就只把GroundBot弄到
关卡一中 我们可以稍后再

00:35:03.003 --> 00:35:04.872 align:middle
把FlyingBot弄过去

00:35:05.606 --> 00:35:07.541 align:middle
如果你允许的某台
设备存储空间不太富余

00:35:07.608 --> 00:35:10.777 align:middle
那么当用户正在玩第二关的
时候你就可以洗净GroundBot

00:35:11.111 --> 00:35:13.180 align:middle
然后把它们都弄回关卡三

00:35:14.047 --> 00:35:16.116 align:middle
你可以看到我们是怎样在
“项目导航器”中的

00:35:16.450 --> 00:35:19.453 align:middle
资源标签下布置标签的

00:35:20.287 --> 00:35:22.956 align:middle
你可以看到关卡一的资产
被标记为了“预取”

00:35:23.023 --> 00:35:25.692 align:middle
这些资产是app安装完毕之后
很短一段时间内取得的

00:35:25.759 --> 00:35:28.495 align:middle
但是这些资产并没有包括在安装包中

00:35:28.562 --> 00:35:31.798 align:middle
而其他的资源就可以被标记为

00:35:31.865 --> 00:35:33.367 align:middle
当我们需要时再下载

00:35:34.635 --> 00:35:36.603 align:middle
这就是点播资源

00:35:36.837 --> 00:35:40.641 align:middle
我们把它用在DemoBots
用来标记稍后下载的资源

00:35:40.741 --> 00:35:43.076 align:middle
这样我们的初始下载速度就更快了

00:35:43.143 --> 00:35:45.612 align:middle
我们可以把我们不是
立即需要的很多东西删去

00:35:46.246 --> 00:35:49.082 align:middle
总的来说 它也有助于我们
保持一个小的存储覆盖区

00:35:49.349 --> 00:35:54.521 align:middle
这就是传达的更重要信息你可以制作
一个更丰富的游戏可以有更多的资产

00:35:54.855 --> 00:35:57.291 align:middle
因为你可以通过点播访问
所有其它的东西

00:35:57.491 --> 00:35:59.660 align:middle
你就仍然可以在设备上
保持同样的覆盖区

00:36:01.028 --> 00:36:04.198 align:middle
我们认为这确实会增加复杂性

00:36:04.998 --> 00:36:08.669 align:middle
当你提到显示下一个场景时
从传统意义上来说

00:36:08.969 --> 00:36:12.306 align:middle
你知道它们位于本地存储器内
你就可以准备这些资源

00:36:12.372 --> 00:36:14.308 align:middle
然后当用户请求资源时
向他们展示这些资源

00:36:15.342 --> 00:36:17.144 align:middle
现在我们增加了一项额外的复杂状态

00:36:17.211 --> 00:36:19.780 align:middle
你可能需要下载这些资源

00:36:20.113 --> 00:36:23.450 align:middle
当然如果网络连接不佳下载就可能失败

00:36:24.551 --> 00:36:26.486 align:middle
如果你想要节省空间那么在某个时间点

00:36:26.787 --> 00:36:28.388 align:middle
你就需要清除这些资源把它们冲洗掉

00:36:28.989 --> 00:36:30.691 align:middle
然后重复整个周期

00:36:32.159 --> 00:36:35.128 align:middle
这可能会比较复杂
我想看看我们在DemoBots中

00:36:35.195 --> 00:36:36.730 align:middle
是怎么解决这个问题的

00:36:37.164 --> 00:36:39.867 align:middle
具体来说 这就回到了
戴夫在会议开始提到的一项

00:36:39.933 --> 00:36:42.169 align:middle
技术即GKStateMachine

00:36:43.270 --> 00:36:46.907 align:middle
如果我们把它用到这样的模型上
我们就把它成为我们的SceneLoader

00:36:46.974 --> 00:36:48.842 align:middle
它有六个相关的状态

00:36:49.510 --> 00:36:51.178 align:middle
你会注意到 只有两类状态

00:36:51.245 --> 00:36:53.447 align:middle
正在下载资源状态以及下载失败状态

00:36:53.514 --> 00:36:55.115 align:middle
实际上 它们都与输出数据寄存器相关

00:36:55.215 --> 00:36:58.118 align:middle
因为对于模型来说这完全是一个流水线

00:36:58.185 --> 00:37:00.387 align:middle
把你的资源送到内存
无论是来自本地存储

00:36:58.185 --> 00:37:00.387 align:middle
把你的资源送到内存
无论是来自本地存储

00:37:00.654 --> 00:37:01.955 align:middle
还是需要首先下载

00:37:02.923 --> 00:37:08.428 align:middle
使用状态机 我们真正能够获得的
优势在于我们怎样对状态变迁进行模仿

00:37:08.662 --> 00:37:14.601 align:middle
如果我们仔细看正在准备
资源状态我们就可以通过在我们的

00:37:14.668 --> 00:37:18.238 align:middle
GKState子类中覆写
IsValidNextState决定什么

00:37:18.305 --> 00:37:20.307 align:middle
是有效的下一个状态

00:37:21.275 --> 00:37:24.244 align:middle
我们可以说如果场景确实
加载过了 那么状态机

00:37:24.311 --> 00:37:27.414 align:middle
只会转移到准备状态

00:37:28.282 --> 00:37:30.284 align:middle
或者说 如果用户取消这个请求的话

00:37:30.350 --> 00:37:31.885 align:middle
我们就可以移回到可用的状态

00:37:32.352 --> 00:37:34.488 align:middle
当试图准备我们的资源时我们不会回到

00:37:34.555 --> 00:37:37.658 align:middle
下载状态因为我们可以在
IsValidNextState中

00:37:37.724 --> 00:37:41.094 align:middle
决定它这样就会导致更多的
确定性的行为

00:37:42.729 --> 00:37:44.264 align:middle
好了 总结一下

00:37:44.698 --> 00:37:48.302 align:middle
最后我再和你们分享下我们
在开发它时学到的一些窍门

00:37:48.869 --> 00:37:51.171 align:middle
第一如果你用的是点播资源

00:37:51.238 --> 00:37:53.307 align:middle
提前提出下载请求

00:37:53.640 --> 00:37:56.410 align:middle
如果你在游戏中有一个可预测的进展

00:37:56.610 --> 00:37:58.445 align:middle
你就可以在玩家一开始玩关卡一就开始

00:37:58.512 --> 00:38:01.048 align:middle
下载关卡二

00:37:58.512 --> 00:38:01.048 align:middle
下载关卡二

00:38:02.516 --> 00:38:06.186 align:middle
不要忘记Xcode内用于
输出数据寄存器的工具

00:38:06.520 --> 00:38:09.790 align:middle
你可以看一下磁盘报告工具
尤其是看看点播资源

00:38:09.857 --> 00:38:11.291 align:middle
下面那里看看你的标签是否已经

00:38:11.358 --> 00:38:14.094 align:middle
被下载了还是当前正在使用中

00:38:14.161 --> 00:38:17.097 align:middle
亦或是已经被清理掉了这真的很有用

00:38:18.899 --> 00:38:21.869 align:middle
此外如果玩家到了一个接合点

00:38:22.402 --> 00:38:24.404 align:middle
他们需要额外的资源

00:38:24.471 --> 00:38:26.540 align:middle
但是你尚未下载这些资源
尚未准备好这些资源

00:38:26.607 --> 00:38:28.575 align:middle
你就可以修改你的请求的优先级

00:38:29.443 --> 00:38:31.512 align:middle
这就意味着你可以在
打包资源请求上提升

00:38:31.578 --> 00:38:35.349 align:middle
载入的优先级它的比例是从零到一

00:38:35.415 --> 00:38:38.352 align:middle
如果用户被阻塞了 而你又
试图进行下载的话 这里甚至

00:38:38.418 --> 00:38:39.653 align:middle
还有一个供急用的常数

00:38:40.254 --> 00:38:45.325 align:middle
我们使用一个NSOperation队列来模仿
准备的你可以在那里提升服务质量

00:38:48.362 --> 00:38:51.899 align:middle
总的来说 我们在DemoBots上
想做的事情很多

00:38:51.965 --> 00:38:57.304 align:middle
我们十分希望提供一个示例
向你们展示开发游戏的各种不同的方面

00:38:57.504 --> 00:38:59.039 align:middle
我们认为你们都会对这个感兴趣的

00:38:59.540 --> 00:39:02.943 align:middle
戴夫一开始就说过了要针对每种设备

00:38:59.540 --> 00:39:02.943 align:middle
戴夫一开始就说过了要针对每种设备

00:39:03.010 --> 00:39:05.412 align:middle
对你的资产进行微调
也包括针对Mac的特殊资产

00:39:06.446 --> 00:39:08.582 align:middle
我们也讲过了优雅的角色导航

00:39:08.649 --> 00:39:10.784 align:middle
而无需由你自己写一大堆的运动代码

00:39:11.385 --> 00:39:14.922 align:middle
最后 添加额外的资产来提高可玩性

00:39:14.988 --> 00:39:17.024 align:middle
因为我们现在对我们的
app进行了切割

00:39:17.691 --> 00:39:21.161 align:middle
我万分激动地告诉大家
GamePlayKit有一堆很棒的特性

00:39:21.228 --> 00:39:23.630 align:middle
总的来说
iOS 9会帮助你实现这些事情

00:39:24.531 --> 00:39:25.699 align:middle
如果你想看看怎么用它们

00:39:26.033 --> 00:39:29.870 align:middle
你可以通过这个链接来下载这个示例

00:39:30.037 --> 00:39:31.338 align:middle
我鼓励你们这么做

00:39:32.673 --> 00:39:35.676 align:middle
这里还有一些额外的资料链接

00:39:35.742 --> 00:39:37.477 align:middle
你也可以联系我们的福音传道者艾伦

00:39:39.179 --> 00:39:42.015 align:middle
相关的会议 我们在本次会议中
已经提到过了

00:39:42.082 --> 00:39:44.852 align:middle
它们已经结束了你可以在线观看视频

00:39:46.887 --> 00:39:47.721 align:middle
谢谢
