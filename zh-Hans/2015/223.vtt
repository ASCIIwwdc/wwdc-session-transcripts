WEBVTT

00:00:33.033 --> 00:00:34.535 align:middle
下午好！

00:00:34.835 --> 00:00:37.337 align:middle
我叫布鲁斯·斯塔德尼克
来自iOS联络小组

00:00:37.404 --> 00:00:41.074 align:middle
能向你们介绍新“联系人框架”
我十分激动

00:00:46.313 --> 00:00:48.916 align:middle
<br/>
如果你是第一次用Apple平台

00:00:48.982 --> 00:00:52.252 align:middle
你就会知道在你的app
中使用联系人是如何简单

00:00:52.886 --> 00:00:55.422 align:middle
而如果你是Address Book
方面的资深开发者

00:00:55.489 --> 00:00:57.024 align:middle
你就会爱上这个
新框架

00:01:00.294 --> 00:01:02.729 align:middle
那么
这个“联系人框架”是什么？

00:01:03.764 --> 00:01:06.633 align:middle
我们倾听到了你们对
Address Book的反馈

00:01:07.034 --> 00:01:09.536 align:middle
今天我们就来解决提出最多的
请求

00:01:11.238 --> 00:01:13.340 align:middle
Address Book
Framework

00:01:13.407 --> 00:01:15.142 align:middle
提供了
一个访问联系人的

00:01:16.910 --> 00:01:20.147 align:middle
Objective-CAPI这个A
PI在设计上也能兼容Swift

00:01:23.417 --> 00:01:25.986 align:middle
对此我们和你们一样都激动万分

00:01:27.754 --> 00:01:30.591 align:middle
这个新Contacts Framework
有多个设计目标

00:01:30.791 --> 00:01:33.660 align:middle
现在我来看看其中的
几个关键目标

00:01:35.362 --> 00:01:38.332 align:middle
首先 满足大多数
一般仅需要获取联系人、

00:01:38.732 --> 00:01:42.703 align:middle
而不会修改联系人的
app的需求

00:01:43.504 --> 00:01:46.940 align:middle
我们为线程安全只读用途
设计了这个API

00:01:48.642 --> 00:01:51.745 align:middle
总体上 这是通过
常量值对象实现的

00:01:51.912 --> 00:01:53.480 align:middle
这些对象不会引用
数据存储

00:01:55.482 --> 00:01:59.319 align:middle
这样你就可以在你的app的
队列之间非常容易地

00:01:59.386 --> 00:02:02.923 align:middle
传递联系人 而不会出现
意外的输入/输出

00:01:59.386 --> 00:02:02.923 align:middle
传递联系人 而不会出现
意外的输入/输出

00:02:05.259 --> 00:02:07.895 align:middle
此外
OS X、iOS和watchOS

00:02:07.961 --> 00:02:11.632 align:middle
也上架了同样的联系人API

00:02:15.536 --> 00:02:17.738 align:middle
<br/>
你学会了这个API以后

00:02:17.804 --> 00:02:21.175 align:middle
就可以在多个Apple平台上访问
联系人

00:02:23.343 --> 00:02:26.380 align:middle
如果你还用
Address Book的话

00:02:26.847 --> 00:02:27.981 align:middle
那么它就要被弃用了

00:02:36.490 --> 00:02:39.793 align:middle
我们一直没有意
识到我们对我们的设备上的

00:02:39.860 --> 00:02:41.528 align:middle
联系人是多么的
自傲

00:02:42.296 --> 00:02:44.698 align:middle
比如说
当我们接到一通电话时

00:02:45.032 --> 00:02:48.335 align:middle
我们只能看到一个电话号码
我们就会想了：打电话的是谁？

00:02:49.403 --> 00:02:51.004 align:middle
是家人吗？

00:02:51.772 --> 00:02:52.873 align:middle
是朋友吗？

00:02:53.340 --> 00:02:54.441 align:middle
还是又一个电话推销员？

00:02:56.143 --> 00:02:58.946 align:middle
如果能把联系人显示出来
那就更好了

00:02:59.847 --> 00:03:02.382 align:middle
哦 是约翰·阿普尔西德
我的一个最好的朋友

00:02:59.847 --> 00:03:02.382 align:middle
哦 是约翰·阿普尔西德
我的一个最好的朋友

00:03:05.652 --> 00:03:07.821 align:middle
每个人在自己的设备上
都有联系人

00:03:08.622 --> 00:03:11.225 align:middle
它们可以帮助我们知道
正在和我们进行沟通的

00:03:11.825 --> 00:03:14.828 align:middle
是谁 帮助我们
打电话、发电子邮件

00:03:15.128 --> 00:03:17.030 align:middle
进行其它
交流

00:03:18.165 --> 00:03:22.536 align:middle
比如说我可以对我的设备说：你好
Siri

00:03:22.603 --> 00:03:23.937 align:middle
打电话给约翰·阿普尔西德

00:03:24.705 --> 00:03:26.139 align:middle
没问题 搞定了

00:03:26.206 --> 00:03:29.443 align:middle
正在呼叫约翰·阿普尔西德
iPhone的扬声器已经开启

00:03:29.510 --> 00:03:32.145 align:middle
布鲁斯·斯塔德尼克：联系人就是
在我们的设备上的

00:03:32.212 --> 00:03:33.981 align:middle
用户体验的
中心

00:03:37.718 --> 00:03:40.487 align:middle
那么“联系人框架”
是如何处理这一

00:03:40.554 --> 00:03:41.555 align:middle
联系信息呢？

00:03:42.556 --> 00:03:44.892 align:middle
我们再用约翰·阿普尔西德
当一回例子

00:03:46.193 --> 00:03:49.496 align:middle
对于你们中那些熟悉Address
Book的人来说这就是个快速回顾

00:03:51.498 --> 00:03:55.002 align:middle
这是约翰的头像照片
他的名

00:03:56.136 --> 00:03:57.171 align:middle
他的姓

00:04:01.408 --> 00:04:03.243 align:middle
他的私人电子邮箱

00:04:04.278 --> 00:04:05.279 align:middle
他的工作电子邮箱

00:04:06.280 --> 00:04:07.781 align:middle
他的iPhone的
电话号码

00:04:11.985 --> 00:04:14.521 align:middle
这些联系属性
代表了

00:04:14.588 --> 00:04:15.522 align:middle
这个联系信息

00:04:16.990 --> 00:04:19.426 align:middle
这个头像图片
用图像数据表示

00:04:21.094 --> 00:04:22.963 align:middle
名字分成了几个
元件

00:04:23.530 --> 00:04:25.566 align:middle
名字表示
名

00:04:26.133 --> 00:04:27.901 align:middle
姓氏则表示
姓

00:04:29.837 --> 00:04:32.706 align:middle
私人电子邮箱和工作电子邮箱
都由

00:04:32.773 --> 00:04:33.740 align:middle
电子邮件地址表示

00:04:36.543 --> 00:04:38.879 align:middle
电话号码
由电话号码表示

00:04:41.081 --> 00:04:42.850 align:middle
有多个
联系属性

00:04:43.183 --> 00:04:45.752 align:middle
你可以参考联系人资料
了解更多细节

00:04:48.755 --> 00:04:50.557 align:middle
现在
我们来谈谈这个对象

00:04:53.293 --> 00:04:55.062 align:middle
这是CNContact对象

00:04:57.130 --> 00:05:00.901 align:middle
这是联系属性的
常量值对象

00:04:57.130 --> 00:05:00.901 align:middle
这是联系属性的
常量值对象

00:05:02.135 --> 00:05:04.204 align:middle
它是仿照NSDictionary设
计的

00:05:05.172 --> 00:05:08.742 align:middle
有一个可变子类
CNMuteableContact

00:05:09.243 --> 00:05:11.178 align:middle
你可以用它来修改
联系属性

00:05:12.613 --> 00:05:14.915 align:middle
“联系人框架”使用的
都是模型

00:05:18.785 --> 00:05:21.522 align:middle
对于有多个值
像电子邮件地址、

00:05:21.889 --> 00:05:23.857 align:middle
电话号码
的联系属性来说

00:05:24.591 --> 00:05:27.461 align:middle
就该轮到一个
CNLabeled Value阵列出马了

00:05:29.296 --> 00:05:33.967 align:middle
CNLabeledValue是标签
和值的一个常量元组

00:05:35.269 --> 00:05:38.272 align:middle
标签在其中是一个字符串
而值则是一个对象

00:05:38.739 --> 00:05:40.407 align:middle
比如
一个电子邮件地址的字符串

00:05:42.910 --> 00:05:45.913 align:middle
值可以有标签
以便和一个属性的多个

00:05:46.113 --> 00:05:47.814 align:middle
值
进行区分

00:05:48.916 --> 00:05:52.119 align:middle
比如到底是一个私人电子邮箱
还是一个工作电子邮箱

00:05:54.821 --> 00:05:57.257 align:middle
对于你们中那些熟悉
Address Book的人来说

00:05:58.025 --> 00:06:02.496 align:middle
AB多值被这个CNLabeled
Value阵列取代了

00:05:58.025 --> 00:06:02.496 align:middle
AB多值被这个CNLabeled
Value阵列取代了

00:06:03.530 --> 00:06:06.300 align:middle
是的 你听到的没错
没有AB多值了

00:06:11.905 --> 00:06:13.974 align:middle
现在我想再拿
约翰·阿普尔西德举个例子

00:06:14.041 --> 00:06:15.642 align:middle
创建一个
新的联系人

00:06:16.610 --> 00:06:18.145 align:middle
我们首先导入联系人

00:06:19.847 --> 00:06:21.515 align:middle
然后创建一个
可变联系人

00:06:21.582 --> 00:06:22.983 align:middle
正如我们将要增加的
联系人一样

00:06:25.385 --> 00:06:30.023 align:middle
然后我们把约翰的头像设为
NSData到imageData

00:06:32.492 --> 00:06:35.395 align:middle
然后把他的名字设为given
Name到familyName

00:06:39.066 --> 00:06:41.101 align:middle
那么对于约翰的
两个电子邮件地址

00:06:41.268 --> 00:06:45.806 align:middle
我们创建两个CNLabeled值
其中一个是CNLabelHome

00:06:46.340 --> 00:06:48.075 align:middle
另一个是CNLabelWork

00:06:48.809 --> 00:06:50.544 align:middle
“联系人框架”上
有一些

00:06:50.611 --> 00:06:51.778 align:middle
预定义标签

00:06:53.347 --> 00:06:55.516 align:middle
这些预定义标签
有本地字符串

00:06:55.582 --> 00:06:57.584 align:middle
你可以在你的app UI
用这些标签

00:06:58.619 --> 00:07:00.521 align:middle
你还可以创建自己的
定制标签

00:06:58.619 --> 00:07:00.521 align:middle
你还可以创建自己的
定制标签

00:07:02.489 --> 00:07:05.759 align:middle
我们拿出这两个标签值
私人电子邮件和工作

00:07:06.226 --> 00:07:09.162 align:middle
电子邮件 放到一个阵列
在电子邮件地址上设置好

00:07:09.763 --> 00:07:10.864 align:middle
就这么简单

00:07:13.166 --> 00:07:15.502 align:middle
我们也可以同样处理
约翰的电话号码

00:07:16.069 --> 00:07:17.938 align:middle
同样
我们创建一个CNLabeled值

00:07:18.505 --> 00:07:23.510 align:middle
使用iPhone预定义标签
当成一个值、创建一个

00:07:23.677 --> 00:07:27.381 align:middle
CNPhoneNumber对象
把标签值放到阵列

00:07:27.648 --> 00:07:29.183 align:middle
然后设为电话号码

00:07:32.886 --> 00:07:35.455 align:middle
我还知道约翰的家庭住址
我也可以添加家庭住址

00:07:36.957 --> 00:07:39.860 align:middle
我先创建一个CNMuteable
PostalAddress

00:07:40.894 --> 00:07:42.296 align:middle
设好信息

00:07:43.497 --> 00:07:46.066 align:middle
然后再用LabelHome创建
一个标签值

00:07:46.733 --> 00:07:49.369 align:middle
放到阵列中
然后设为通讯地址

00:07:53.574 --> 00:07:55.342 align:middle
最后
我还知道他的生日

00:07:55.409 --> 00:07:58.645 align:middle
我就可以创建一个
NSDateComponent

00:07:58.712 --> 00:07:59.813 align:middle
设置好年、月、日元件

00:08:00.447 --> 00:08:01.882 align:middle
然后把它设为
生日属性

00:08:03.150 --> 00:08:05.986 align:middle
要注意
“联系人框架”中的所有

00:08:06.086 --> 00:08:09.389 align:middle
日期相关的属性都是
NSDate元件

00:08:10.424 --> 00:08:14.294 align:middle
这样就可以灵活设置
日期

00:08:14.361 --> 00:08:15.596 align:middle
比如不足一年的生日

00:08:15.896 --> 00:08:17.364 align:middle
这样你就可以忽略
年份元件

00:08:22.369 --> 00:08:25.405 align:middle
“联系人框架”也可以对
这些联系对象进行

00:08:25.472 --> 00:08:26.840 align:middle
运算

00:08:27.808 --> 00:08:30.110 align:middle
这里 你可能对
格式化联系数据感兴趣

00:08:32.880 --> 00:08:34.681 align:middle
CNContact
Formatter

00:08:34.748 --> 00:08:36.082 align:middle
将会格式化一个联系人的名字

00:08:37.083 --> 00:08:38.919 align:middle
在这个例子中
我们格式化了全名 然后

00:08:38.986 --> 00:08:40.287 align:middle
又得到了约翰·阿普尔西德

00:08:42.054 --> 00:08:43.890 align:middle
CNContact
Formatter

00:08:43.957 --> 00:08:45.492 align:middle
还可以正确格式化国际名字

00:08:48.395 --> 00:08:49.696 align:middle
我们还有一个格式化程序

00:08:49.763 --> 00:08:52.165 align:middle
CNPostalAddress
Formatter

00:08:52.232 --> 00:08:54.501 align:middle
可以格式化通讯地址的
邮件标签

00:08:55.802 --> 00:08:57.738 align:middle
然后就会返回这个

00:08:58.972 --> 00:09:02.910 align:middle
CNPostalAddress
Formatter可以正确格式化

00:08:58.972 --> 00:09:02.910 align:middle
CNPostalAddress
Formatter可以正确格式化

00:09:03.277 --> 00:09:04.178 align:middle
国际化通讯地址

00:09:05.179 --> 00:09:08.348 align:middle
我们建议你尽量在你的
app中使用这些格式化程序

00:09:11.685 --> 00:09:13.954 align:middle
现在
我想请戴夫上台

00:09:14.021 --> 00:09:16.223 align:middle
请他给你们演示下
如何在你的app中使用联系人

00:09:23.197 --> 00:09:24.064 align:middle
谢谢
布鲁斯

00:09:24.131 --> 00:09:27.367 align:middle
我叫戴夫·蒂宾根
是OS X联系人团队的一员

00:09:29.703 --> 00:09:30.537 align:middle
不好意思

00:09:31.738 --> 00:09:33.640 align:middle
刚才布鲁斯已经
向你们演示了如何在代码中

00:09:33.707 --> 00:09:35.976 align:middle
创建、编辑
CNContact

00:09:36.910 --> 00:09:39.279 align:middle
但是在OSX、iOS
和watch OS的

00:09:39.346 --> 00:09:42.883 align:middle
联系人app上
已经有了很多联系人

00:09:44.084 --> 00:09:46.386 align:middle
布鲁斯已经演示了
系统app可以怎样

00:09:46.453 --> 00:09:49.623 align:middle
和这些联系人整合起来
提供更加丰富的用户体验

00:09:50.357 --> 00:09:53.060 align:middle
比如说
电话app可以为来电

00:09:53.126 --> 00:09:54.628 align:middle
显示一个人的名字和照片
而不是

00:09:55.329 --> 00:09:57.397 align:middle
仅仅显示一个电话号码

00:09:58.198 --> 00:10:00.133 align:middle
“联系人框架”让你可以
为你的app提供

00:09:58.198 --> 00:10:00.133 align:middle
“联系人框架”让你可以
为你的app提供

00:10:00.200 --> 00:10:01.969 align:middle
丰富的
用户体验

00:10:05.138 --> 00:10:06.573 align:middle
你要用来访问用户的
联系人的类

00:10:06.640 --> 00:10:09.042 align:middle
叫做
CNContactStore

00:10:09.710 --> 00:10:11.044 align:middle
我们来讲讲
怎样

00:10:11.111 --> 00:10:12.613 align:middle
获取、保存用户的联系人

00:10:13.480 --> 00:10:14.414 align:middle
让我们从获取开始

00:10:16.350 --> 00:10:17.784 align:middle
你要使用的主要方法

00:10:18.018 --> 00:10:19.286 align:middle
叫做统一
Contacts

00:10:19.353 --> 00:10:22.155 align:middle
MatchingPredicate
keysToFetch

00:10:22.556 --> 00:10:25.392 align:middle
这会返回一个
CNContact对象阵列

00:10:27.227 --> 00:10:29.563 align:middle
Keys to
Fetch中的谓词的目的

00:10:29.630 --> 00:10:32.132 align:middle
是为了帮助你的app
尽可能高效地获取联系人

00:10:33.433 --> 00:10:34.535 align:middle
我们先从
声明开始

00:10:36.069 --> 00:10:38.639 align:middle
用户可能有数以百计
甚至数以千计的联系人

00:10:38.705 --> 00:10:41.475 align:middle
你可能只对这些联系人的
一个小子集感兴趣

00:10:42.576 --> 00:10:44.611 align:middle
谓词可以让你...

00:10:44.678 --> 00:10:46.680 align:middle
可以帮助你限制
返回的结果数量

00:10:48.081 --> 00:10:49.283 align:middle
如果你们中有人还不知道

00:10:49.349 --> 00:10:51.818 align:middle
NSPredicate是一个标准的
基础级别对象

00:10:52.319 --> 00:10:54.488 align:middle
可以显示搜索时
某个对象

00:10:54.555 --> 00:10:55.956 align:middle
匹配的
标准

00:10:59.826 --> 00:11:02.863 align:middle
“联系人框架”为你提供了
使用

00:10:59.826 --> 00:11:02.863 align:middle
“联系人框架”为你提供了
使用

00:11:02.930 --> 00:11:03.931 align:middle
联系人存储器的谓词

00:11:04.464 --> 00:11:06.200 align:middle
联系人存储器将会评估
这些信息、

00:11:06.266 --> 00:11:08.168 align:middle
这些
信息

00:11:08.902 --> 00:11:10.237 align:middle
这里的例子中

00:11:10.304 --> 00:11:12.906 align:middle
是谓词ForContacts
MatchingName

00:11:13.106 --> 00:11:15.909 align:middle
它会匹配每个联系
和指定的

00:11:15.976 --> 00:11:18.145 align:middle
名字 在这里例子中
就是阿普尔西德

00:11:19.012 --> 00:11:20.113 align:middle
我们再来快速看个例子

00:11:23.217 --> 00:11:25.018 align:middle
比方说用户有下面三个
联系人

00:11:25.185 --> 00:11:28.222 align:middle
约翰·阿普尔西德、简·阿普
尔西德、克雷格·布罗姆利

00:11:29.556 --> 00:11:32.059 align:middle
联系人存储器会高效评估联系人
约翰·阿普尔西德

00:11:33.093 --> 00:11:34.728 align:middle
和简·阿普尔西德
克雷格·布罗姆利

00:11:34.928 --> 00:11:36.330 align:middle
然后仅仅返回匹配的联系人

00:11:36.563 --> 00:11:37.965 align:middle
在这里返回的就是
约翰和简

00:11:38.031 --> 00:11:39.600 align:middle
而不是克雷格

00:11:43.270 --> 00:11:45.339 align:middle
这样谓词让你可以限制
返回的联系人的数量

00:11:45.472 --> 00:11:47.341 align:middle
但是
一个联系人的

00:11:47.407 --> 00:11:49.176 align:middle
联系信息
仍然很多

00:11:49.243 --> 00:11:51.512 align:middle
而你可能仅仅对它的
一个小子集感兴趣

00:11:52.446 --> 00:11:54.515 align:middle
那么就该
keysToFetch大显身手了

00:11:57.584 --> 00:12:00.254 align:middle
KeysToFetch是一个
字符串阵列

00:11:57.584 --> 00:12:00.254 align:middle
KeysToFetch是一个
字符串阵列

00:12:00.621 --> 00:12:03.690 align:middle
这些是键的字符串
属于键-值编码

00:12:04.224 --> 00:12:06.460 align:middle
如果你只对教名
和姓感兴趣

00:12:06.627 --> 00:12:08.929 align:middle
你就可以把你的
keysToFetch设置成这样

00:12:09.263 --> 00:12:11.665 align:middle
当然了 逐字使用字符串
容易出现错误

00:12:12.266 --> 00:12:13.700 align:middle
为此我们也提供了常数

00:12:16.336 --> 00:12:18.138 align:middle
因此
“联系人存储器”将会

00:12:18.205 --> 00:12:20.541 align:middle
仅仅获取
你指明的属性

00:12:21.642 --> 00:12:23.644 align:middle
在这里例子中
就是名字和姓

00:12:24.778 --> 00:12:27.314 align:middle
你就可以亲眼看到
keysToFetch的谓词是怎样

00:12:27.381 --> 00:12:28.582 align:middle
允许你缩小返回的
信息的

00:12:28.649 --> 00:12:30.184 align:middle
数量
这样你的app就可以

00:12:30.250 --> 00:12:31.485 align:middle
尽可能的高效

00:12:32.519 --> 00:12:33.720 align:middle
让我们来看一个完整的例子

00:12:35.656 --> 00:12:37.791 align:middle
就像之前一样
我们要从一个谓词

00:12:37.858 --> 00:12:39.593 align:middle
和keysToFetch开始
但是

00:12:40.861 --> 00:12:42.930 align:middle
现在你需要把它们用在
一个联系人存储器上

00:12:42.996 --> 00:12:44.531 align:middle
这很容易
你可以用默认初始化程序

00:12:44.631 --> 00:12:45.832 align:middle
创建一个

00:12:47.134 --> 00:12:48.535 align:middle
然后调用统一
Contacts

00:12:48.602 --> 00:12:50.370 align:middle
Matching Predicate

00:12:50.470 --> 00:12:52.773 align:middle
带有这些值的keysToFetch
假设一切正常

00:12:53.207 --> 00:12:55.008 align:middle
你就会得到一个
联系人阵列

00:12:56.143 --> 00:12:57.544 align:middle
然后你就可以按照你的
想法去用

00:12:57.678 --> 00:12:59.880 align:middle
在这里我们是要打印出
姓名和姓氏

00:13:01.281 --> 00:13:02.516 align:middle
关于获取
我还想说几件

00:13:02.583 --> 00:13:03.417 align:middle
重要的事情

00:13:04.051 --> 00:13:06.920 align:middle
第一点
不受CNContact信息的生命期

00:13:06.987 --> 00:13:08.622 align:middle
约束的

00:13:08.689 --> 00:13:10.524 align:middle
CNContact的
生命期

00:13:11.225 --> 00:13:13.227 align:middle
获取结束后
并不需要同存贮器

00:13:13.293 --> 00:13:15.262 align:middle
保持一个
强引用

00:13:16.063 --> 00:13:19.032 align:middle
这就意味着CNContact
上面的数据是有效的

00:13:19.099 --> 00:13:22.102 align:middle
自从取出后就是有效的
基本上就是一个从取出那时

00:13:22.169 --> 00:13:23.904 align:middle
的快照
在那个CNContact的

00:13:23.971 --> 00:13:26.139 align:middle
生命期内
都是有效的

00:13:27.407 --> 00:13:28.442 align:middle
第二个重要的事情是

00:13:28.509 --> 00:13:30.010 align:middle
这是一个
同步方法

00:13:30.544 --> 00:13:32.913 align:middle
相比较而言
取出联系人是一个慢操作

00:13:34.314 --> 00:13:37.818 align:middle
因此 你必须通过一个
后台进程来读取这些联系人

00:13:38.986 --> 00:13:40.654 align:middle
让你的用户界面
保持响应

00:13:41.889 --> 00:13:42.990 align:middle
就像布鲁斯之前提到的

00:13:43.056 --> 00:13:46.727 align:middle
CNContacts是完整的线程安
全 通过后台进程来读取这些

00:13:46.793 --> 00:13:49.196 align:middle
联系人是安全的
然后把它们移到主线程

00:13:49.730 --> 00:13:51.098 align:middle
更新你的用户界面

00:13:53.667 --> 00:13:56.003 align:middle
通过后台进程来读取联系人
还有一个原因

00:13:56.069 --> 00:13:57.538 align:middle
那就是
数据隐私

00:14:03.143 --> 00:14:07.147 align:middle
用户对待他们的联系人
这一隐私非常严肃

00:14:08.081 --> 00:14:10.817 align:middle
因此
我们需要在你的app和用户

00:14:10.884 --> 00:14:12.019 align:middle
联系人之间设立一道势垒

00:14:13.487 --> 00:14:17.124 align:middle
当你的app第一次通过API
访问联系人时

00:14:17.191 --> 00:14:20.160 align:middle
OS会弹出一个对话框
或者警报

00:14:20.227 --> 00:14:22.763 align:middle
让用户选择允许
或者拒绝访问

00:14:22.829 --> 00:14:23.997 align:middle
你之前可能
已经看过了

00:14:25.365 --> 00:14:27.601 align:middle
这就意味着当你第一次
调用联系人存储器上的

00:14:27.668 --> 00:14:30.070 align:middle
方法时
它并不能提供结果

00:14:30.437 --> 00:14:33.073 align:middle
必须等待用户做出响应
这可能需要很长时间

00:14:35.008 --> 00:14:37.945 align:middle
当你通过GCD或者NS操作
把你的联系人储存器访问

00:14:38.011 --> 00:14:41.081 align:middle
移到一个后台
线程中时 我们在这里

00:14:41.515 --> 00:14:42.783 align:middle
提供了一项助手方法

00:14:42.850 --> 00:14:45.085 align:middle
一个叫做请求访问实体类型
完成处理程序的

00:14:45.152 --> 00:14:46.220 align:middle
异步
方法

00:14:48.622 --> 00:14:50.924 align:middle
用户可能会拒绝访问
这样你的app就可以

00:14:50.991 --> 00:14:51.925 align:middle
得体地处理它

00:14:53.093 --> 00:14:54.528 align:middle
如果用户允许访问

00:14:54.695 --> 00:14:56.763 align:middle
那么请务必
谨慎处理联系人数据

00:14:57.631 --> 00:14:59.299 align:middle
更多信息请查看
你的app会话中的

00:14:59.366 --> 00:15:00.534 align:middle
“隐私”部分

00:14:59.366 --> 00:15:00.534 align:middle
“隐私”部分

00:15:02.503 --> 00:15:05.105 align:middle
我想再讲讲keysToFetch
讲讲它们是如何

00:15:05.172 --> 00:15:06.940 align:middle
返回
部分联系人的

00:15:09.209 --> 00:15:11.812 align:middle
就像我之前演示的那样
keysToFetch允许你仅仅

00:15:11.912 --> 00:15:14.181 align:middle
读取你感兴趣的
属性

00:15:15.916 --> 00:15:17.518 align:middle
在这个例子中
就是姓名和姓

00:15:17.684 --> 00:15:19.920 align:middle
如果你试着访问一个你并未
请求的属性 比如说

00:15:20.020 --> 00:15:21.355 align:middle
一个手机号码 会发生什么？

00:15:24.558 --> 00:15:26.093 align:middle
那就会
抛出一个异常

00:15:26.159 --> 00:15:27.694 align:middle
因为数据不在那里

00:15:27.761 --> 00:15:30.264 align:middle
我们调用这些部分联系人
是因为只有部分属性

00:15:30.330 --> 00:15:31.632 align:middle
可用

00:15:33.433 --> 00:15:35.035 align:middle
一般来说
如果你把你的

00:15:35.102 --> 00:15:37.538 align:middle
键设成我们之前的例子中的
那样 这就不是一个问题

00:15:39.373 --> 00:15:41.175 align:middle
但是有时候你获取
一个联系人时 你不确定

00:15:41.241 --> 00:15:42.075 align:middle
获取时使用的是

00:15:42.142 --> 00:15:44.845 align:middle
哪个
keysToFetch

00:15:45.512 --> 00:15:47.281 align:middle
在这些例子中
在访问属性之前

00:15:47.347 --> 00:15:49.917 align:middle
你可能想要校验下
看看键是否可用

00:15:50.517 --> 00:15:52.419 align:middle
就像你在索引之前
校验阵列的

00:15:52.486 --> 00:15:54.087 align:middle
长度那样
这样来避免异常

00:15:55.189 --> 00:15:57.925 align:middle
这里有一个例子是通过
isKeyAvailable方法

00:15:57.991 --> 00:16:00.427 align:middle
看看访问电话号码属性时
PhoneNumbers键

00:15:57.991 --> 00:16:00.427 align:middle
看看访问电话号码属性时
PhoneNumbers键

00:16:00.494 --> 00:16:01.495 align:middle
是否
可用

00:16:02.963 --> 00:16:04.031 align:middle
你可能会想
“那好吧

00:16:04.097 --> 00:16:06.066 align:middle
但是我真的想访问那些
电话号码 ”

00:16:06.834 --> 00:16:07.968 align:middle
在那种情况下

00:16:08.035 --> 00:16:10.804 align:middle
你可以使用附加的keysTo
Fetch来重新读取联系人

00:16:10.871 --> 00:16:11.972 align:middle
我们来看看它的工作原理

00:16:13.874 --> 00:16:15.876 align:middle
我们在这里设置了keysTo
Fetch

00:16:15.943 --> 00:16:17.444 align:middle
但是这次我们使用的是电话号码键

00:16:17.911 --> 00:16:18.946 align:middle
并且使用了一种叫做

00:16:19.012 --> 00:16:22.216 align:middle
unifiedContactWit
hIdentifier的方法

00:16:22.316 --> 00:16:24.718 align:middle
现在每个联系人都有一个
对它进行唯一标识的标识符

00:16:24.785 --> 00:16:26.353 align:middle
<br/>
你可以稍后使用它

00:16:26.420 --> 00:16:27.421 align:middle
重新进行读取

00:16:29.122 --> 00:16:31.024 align:middle
当你重新读取后

00:16:31.291 --> 00:16:32.893 align:middle
你就可以在这个重新读取的
联系人上

00:16:32.960 --> 00:16:33.927 align:middle
安全访问电话号码了

00:16:35.896 --> 00:16:38.065 align:middle
对于部分联系人来说
重要的是理解它们

00:16:38.131 --> 00:16:39.733 align:middle
和其余的框架是怎样
一起工作的

00:16:43.036 --> 00:16:45.405 align:middle
这里展示的上个例子中
我们看到了如何读取姓名

00:16:45.472 --> 00:16:46.840 align:middle
和姓氏
然后把它们打印出来

00:16:47.241 --> 00:16:49.343 align:middle
打印出全名
但是这还不够理想

00:16:49.409 --> 00:16:51.612 align:middle
我们最好使用其中一种
格式化程序 不好意思

00:16:51.778 --> 00:16:54.515 align:middle
布鲁斯之前向我们展示过的
CNContact格式化程序

00:16:55.382 --> 00:16:58.051 align:middle
这个格式化程序可能会访问
其它你还没有读取的属性

00:16:58.118 --> 00:16:59.486 align:middle
比如说
名字、前缀或者后缀

00:16:59.920 --> 00:17:01.755 align:middle
如果它们不在那里
那么就会抛出一个异常

00:16:59.920 --> 00:17:01.755 align:middle
如果它们不在那里
那么就会抛出一个异常

00:17:04.090 --> 00:17:06.627 align:middle
我们可以提供所有你使用这个
格式化程序需要用到的

00:17:06.693 --> 00:17:08.561 align:middle
键 但是这会非常乏味
而且容易出错

00:17:09.363 --> 00:17:11.298 align:middle
因此我们提出了
键描述符的概念

00:17:12.566 --> 00:17:18.137 align:middle
键描述符代表了某个
特定操作的一组键

00:17:18.638 --> 00:17:20.674 align:middle
在这个例子中
格式化程序知道它需要哪个键

00:17:20.741 --> 00:17:23.210 align:middle
才能完成工作
因此它通过描述符

00:17:23.544 --> 00:17:25.846 align:middle
ForRequiredKeys
ForStyle

00:17:25.913 --> 00:17:26.813 align:middle
方法提供了键描述符

00:17:26.880 --> 00:17:28.782 align:middle
你就可以把它直接包含在你的
键中进行读取

00:17:29.349 --> 00:17:32.653 align:middle
这样就可以告诉联系人存储器
所有格式化程序

00:17:32.719 --> 00:17:34.154 align:middle
进行读取需要的
属性

00:17:35.055 --> 00:17:36.156 align:middle
我们来看一个例子

00:17:38.192 --> 00:17:40.594 align:middle
在这个例子中
我们想要读取所有叫

00:17:40.661 --> 00:17:41.628 align:middle
阿普尔西德的联系人

00:17:41.795 --> 00:17:44.298 align:middle
我们想打印他们的
全名和电子邮件地址

00:17:45.599 --> 00:17:47.334 align:middle
我们要想之前一样
设置谓词

00:17:47.401 --> 00:17:49.503 align:middle
并且把keysToFetch设置的
略有不同

00:17:51.004 --> 00:17:55.075 align:middle
我们先看看样式
要求键的描述符

00:17:55.142 --> 00:17:58.045 align:middle
这样就可以允许我们稍后使用
“联系人格式化程序”

00:17:58.111 --> 00:18:00.214 align:middle
来
获得全名

00:17:58.111 --> 00:18:00.214 align:middle
来
获得全名

00:18:01.215 --> 00:18:04.751 align:middle
你也可以直接包括
CNContact电子邮件地址键

00:18:04.818 --> 00:18:06.353 align:middle
因为我们想打印这个
电子邮件地址

00:18:06.820 --> 00:18:09.122 align:middle
你可以把键描述符

00:18:09.389 --> 00:18:11.792 align:middle
和CNContact键混合到
同一阵列

00:18:14.361 --> 00:18:16.964 align:middle
有了这个设置 你就可以
像我们之前那样进行读取

00:18:17.030 --> 00:18:18.465 align:middle
调用统一联系人匹配
谓词

00:18:19.466 --> 00:18:21.835 align:middle
有了结果后
你就可以通过格式化程序

00:18:21.902 --> 00:18:23.904 align:middle
获得全名
和电子邮件地址

00:18:26.807 --> 00:18:27.941 align:middle
关于读取

00:18:28.075 --> 00:18:30.210 align:middle
另一个重点是
统一联系人

00:18:31.478 --> 00:18:33.614 align:middle
你可能在多个账户里
有相同的联系人

00:18:33.680 --> 00:18:36.016 align:middle
比如说你在iCloud账户上有
约翰·阿普尔西德

00:18:36.083 --> 00:18:38.252 align:middle
还有他的工作电子邮件地址、
电话号码

00:18:38.585 --> 00:18:40.787 align:middle
但是你可能在Facebook上
还和约翰是好友

00:18:40.888 --> 00:18:42.523 align:middle
这就可以构成一个
形象

00:18:42.956 --> 00:18:44.992 align:middle
私人电子邮件地址、
生日

00:18:45.592 --> 00:18:48.061 align:middle
这样联系人app就不用在那里
分别显示两个联系人

00:18:48.662 --> 00:18:51.198 align:middle
联系人app将会通过某种
探试程序把这些

00:18:51.265 --> 00:18:54.368 align:middle
链接起来
结合信息

00:18:54.434 --> 00:18:55.636 align:middle
显示一个单一的
联系人

00:18:55.702 --> 00:18:57.371 align:middle
我们称之为
统一联系人

00:18:58.972 --> 00:19:01.475 align:middle
联系人app已经在
最近的几次发版中已经这么做了

00:18:58.972 --> 00:19:01.475 align:middle
联系人app已经在
最近的几次发版中已经这么做了

00:19:02.209 --> 00:19:05.012 align:middle
“联系人框架”默认
将会返回统一联系人

00:19:05.078 --> 00:19:07.548 align:middle
你可能已经从方法名字上面
猜到了这一点

00:19:08.815 --> 00:19:10.717 align:middle
好消息是
这意味着你可以取到

00:19:10.784 --> 00:19:13.153 align:middle
用户在app中
看到的数据

00:19:14.288 --> 00:19:15.255 align:middle
这里 最棒的事情是

00:19:15.322 --> 00:19:17.124 align:middle
这些都是普通的
CNContact对象

00:19:17.191 --> 00:19:20.093 align:middle
它们和任何其它的CNContact
对象的原理、行为都很相似

00:19:20.861 --> 00:19:24.031 align:middle
你甚至可以修改、保存它们
这样也可以

00:19:25.465 --> 00:19:27.935 align:middle
说到保存
我们来看几个代码实例

00:19:28.368 --> 00:19:29.670 align:middle
看看怎样保存联系人

00:19:30.804 --> 00:19:33.106 align:middle
我要先来添加一个
新的联系人

00:19:35.375 --> 00:19:36.944 align:middle
比如说
你有一个C不可变联系人

00:19:37.010 --> 00:19:39.279 align:middle
你用布鲁斯之前向你们展示的
数据把它设置好了

00:19:39.580 --> 00:19:41.915 align:middle
要想把它弄到用户联系人中
你就要使用一个叫做

00:19:41.982 --> 00:19:43.984 align:middle
保存请求的请求
然后你就可以在联系人

00:19:44.051 --> 00:19:46.353 align:middle
存储器上执行那个
保存请求

00:19:48.288 --> 00:19:51.525 align:middle
你要做的第一件事
就是创建一个新的CNSave Request对象

00:19:52.326 --> 00:19:54.094 align:middle
然后你就可以通过标识符
向容器调用

00:19:54.161 --> 00:19:55.662 align:middle
添加联系人

00:19:56.864 --> 00:19:58.732 align:middle
我们现在没有时间讲
容器

00:19:59.233 --> 00:20:01.702 align:middle
不过零容器标识符
指的是默认标识符

00:19:59.233 --> 00:20:01.702 align:middle
不过零容器标识符
指的是默认标识符

00:20:02.069 --> 00:20:04.338 align:middle
更多信息请参见资料

00:20:05.672 --> 00:20:07.975 align:middle
保存请求会给一个联系人
标记为正在添加

00:20:08.041 --> 00:20:10.110 align:middle
但实际上
并不会做出变更

00:20:10.444 --> 00:20:12.446 align:middle
要进行变革 你需要在
联系人储存器上调用执行

00:20:12.513 --> 00:20:13.714 align:middle
SaveRequest

00:20:13.780 --> 00:20:15.282 align:middle
如果顺利完成的话

00:20:15.749 --> 00:20:17.417 align:middle
这就会被添加到
用户的联系人中

00:20:21.321 --> 00:20:23.624 align:middle
更新现有的联系人
也很相似

00:20:23.690 --> 00:20:25.425 align:middle
但是你要先从一个
你通过读取获得的

00:20:25.492 --> 00:20:27.661 align:middle
不可变的联系人
开始

00:20:29.129 --> 00:20:30.697 align:middle
你要做的第一件事

00:20:30.764 --> 00:20:32.232 align:middle
就是创建一个
可变拷贝

00:20:32.799 --> 00:20:34.234 align:middle
然后完成任何你想要的
变更

00:20:34.301 --> 00:20:36.770 align:middle
比如说 我们在这里要添加
一个新的电子邮件地址

00:20:38.005 --> 00:20:39.006 align:middle
现在
重点要注意的是

00:20:39.072 --> 00:20:41.708 align:middle
当你对某个部分联系人制作
可变拷贝时

00:20:42.109 --> 00:20:45.546 align:middle
仅仅修改你读取的
属性

00:20:49.082 --> 00:20:51.351 align:middle
像之前一样
我们需要使用保存请求

00:20:52.286 --> 00:20:53.687 align:middle
创建一个新的保存请求不过这次

00:20:53.754 --> 00:20:55.956 align:middle
我们要使用这个
updateContact方法

00:20:56.623 --> 00:20:58.759 align:middle
同样地 这也仅仅是把
联系人标记为正在更新

00:20:58.825 --> 00:21:00.260 align:middle
但并不会
真正进行变更

00:20:58.825 --> 00:21:00.260 align:middle
但并不会
真正进行变更

00:21:00.961 --> 00:21:03.263 align:middle
直到你调用executeSave
Request

00:21:05.098 --> 00:21:07.034 align:middle
关于保存
还有一些重要的事情要说

00:21:07.601 --> 00:21:10.704 align:middle
首先是保存请求可以
包含多个变更

00:21:10.771 --> 00:21:12.606 align:middle
当你
执行它时

00:21:12.673 --> 00:21:14.842 align:middle
所有这些变更
都会在

00:21:14.908 --> 00:21:15.843 align:middle
执行它们时完成

00:21:18.011 --> 00:21:19.079 align:middle
第二点

00:21:19.446 --> 00:21:22.249 align:middle
保存请求要求多个
可变联系人

00:21:22.449 --> 00:21:23.483 align:middle
你需要小心

00:21:23.550 --> 00:21:25.953 align:middle
当一项保存正在运行时
不要在同一个线程上访问这些

00:21:26.053 --> 00:21:26.987 align:middle
可变联系人

00:21:29.656 --> 00:21:30.958 align:middle
现在你已经知道了如何
读取、

00:21:31.258 --> 00:21:32.960 align:middle
保存一位用户的联系人

00:21:33.026 --> 00:21:34.895 align:middle
我要请朱利安上来

00:21:34.962 --> 00:21:37.464 align:middle
给大家讲讲在用户界面
如何使用联系人

00:21:43.604 --> 00:21:44.605 align:middle
谢谢 戴夫

00:21:47.674 --> 00:21:48.542 align:middle
下午好

00:21:48.609 --> 00:21:51.678 align:middle
我是朱利安
iOS联系人团队的一名工程师

00:21:52.679 --> 00:21:54.681 align:middle
布鲁斯和戴夫

00:21:54.748 --> 00:21:57.217 align:middle
已经让你们
成为了

00:21:57.284 --> 00:21:58.719 align:middle
“联系人框架”方面的专家

00:21:58.785 --> 00:22:00.888 align:middle
我就来谈谈用户界面

00:21:58.785 --> 00:22:00.888 align:middle
我就来谈谈用户界面

00:22:01.622 --> 00:22:03.590 align:middle
向你们演示如何在你的app中

00:22:03.657 --> 00:22:05.759 align:middle
拾取、显示联系人

00:22:07.828 --> 00:22:09.363 align:middle
和“联系人框架”一起

00:22:09.429 --> 00:22:12.599 align:middle
我们还有一个叫做联系人UI的
新UI框架

00:22:13.400 --> 00:22:17.938 align:middle
iOS 9和OS X
El Capitan上都可以用

00:22:19.006 --> 00:22:21.408 align:middle
它会给你提供两个集群

00:22:21.875 --> 00:22:23.410 align:middle
第一个是选择器

00:22:23.644 --> 00:22:27.080 align:middle
选择器会显示一个全部
用户联系人列表

00:22:27.147 --> 00:22:30.083 align:middle
让他选择把联系人信息
导入

00:22:30.150 --> 00:22:31.084 align:middle
你的app

00:22:32.653 --> 00:22:35.122 align:middle
其次是
联系人视图控制器

00:22:35.556 --> 00:22:37.191 align:middle
控制器可以用来显示
一位联系人

00:22:38.325 --> 00:22:40.460 align:middle
本场演示的剩余时间里
我会讲一讲类的

00:22:40.527 --> 00:22:42.829 align:middle
iOS
版本

00:22:43.697 --> 00:22:46.633 align:middle
不过OS X上的
也很相似

00:22:48.869 --> 00:22:50.838 align:middle
我们首先来讲讲
拾取联系人

00:22:51.772 --> 00:22:53.307 align:middle
为此你要用的类是

00:22:53.373 --> 00:22:55.175 align:middle
CNContact选择器
视图控制器

00:22:56.009 --> 00:22:58.879 align:middle
它会直接置换我们之前在
Address Book UI的类

00:22:58.946 --> 00:23:00.314 align:middle
即AB

00:22:58.946 --> 00:23:00.314 align:middle
即AB

00:23:00.380 --> 00:23:02.015 align:middle
People Picker

00:23:02.082 --> 00:23:04.084 align:middle
Navigation
Controller

00:23:04.618 --> 00:23:06.186 align:middle
你从名字上就可以猜到

00:23:06.653 --> 00:23:09.356 align:middle
它是UA视图控制器的一个
直接子类

00:23:09.923 --> 00:23:11.558 align:middle
但你还是必须显示它

00:23:11.658 --> 00:23:13.694 align:middle
而不是把它推入一个
导航控制器

00:23:15.529 --> 00:23:17.731 align:middle
它总是处于进程外

00:23:18.065 --> 00:23:22.169 align:middle
它的优点很明显
不用要求用户允许你的

00:23:22.236 --> 00:23:25.138 align:middle
app访问他们的
联系人了

00:23:26.206 --> 00:23:27.508 align:middle
这样 当你显示一个

00:23:27.808 --> 00:23:29.209 align:middle
联系人选择器时

00:23:29.276 --> 00:23:32.980 align:middle
你就不会看到之前戴夫
展示的对话

00:23:35.649 --> 00:23:36.783 align:middle
其中一件重要的事情是

00:23:36.850 --> 00:23:39.553 align:middle
联系人选择器可能会返回
部分联系人

00:23:40.020 --> 00:23:45.526 align:middle
比如说
如果你设置了显示属性键的有界集

00:23:45.859 --> 00:23:47.494 align:middle
那么你在得到的联系人中

00:23:47.995 --> 00:23:49.530 align:middle
就只会得到
那些键

00:23:51.532 --> 00:23:54.568 align:middle
选择器的行为由两件事
定义

00:23:55.169 --> 00:23:58.605 align:middle
首先是你实现的委托方法
其次是

00:23:58.672 --> 00:24:00.641 align:middle
你设置的
谓词

00:23:58.672 --> 00:24:00.641 align:middle
你设置的
谓词

00:24:00.941 --> 00:24:03.477 align:middle
我们稍后会谈谈
这些

00:24:04.378 --> 00:24:06.480 align:middle
最后一点
选择器必须

00:24:06.547 --> 00:24:07.848 align:middle
支持多选

00:24:13.754 --> 00:24:16.023 align:middle
我们首先来谈谈
委托方法

00:24:17.324 --> 00:24:20.260 align:middle
如果你的app仅对
单个联系人感兴趣

00:24:20.994 --> 00:24:23.864 align:middle
你想让它的风格
和选择器相似

00:24:24.865 --> 00:24:28.435 align:middle
你只需要实现
didSelect Contact委托方法

00:24:28.502 --> 00:24:31.605 align:middle
然后你就会得到一个
CNContact

00:24:32.272 --> 00:24:34.508 align:middle
同样地
这些联系人也可能是部分的

00:24:36.476 --> 00:24:38.545 align:middle
如果你对单个属性
感兴趣

00:24:39.079 --> 00:24:40.214 align:middle
你实现一个确保选择

00:24:40.280 --> 00:24:42.182 align:middle
Contact
Property委托方法

00:24:42.482 --> 00:24:44.918 align:middle
得到一个CNContact
Property对象

00:24:45.552 --> 00:24:47.955 align:middle
这个对象实际上来自
“联系人框架”

00:24:48.021 --> 00:24:50.891 align:middle
不过我们之前没有见过
所以让我们来看看

00:24:52.392 --> 00:24:55.462 align:middle
这是一个简单的包装类
包含了选择的联系人

00:24:55.529 --> 00:24:59.199 align:middle
以及用户
选择的

00:24:59.266 --> 00:25:00.901 align:middle
属性键

00:24:59.266 --> 00:25:00.901 align:middle
属性键

00:25:01.602 --> 00:25:02.669 align:middle
它的值

00:25:02.903 --> 00:25:04.705 align:middle
以及可能的标识符

00:25:04.771 --> 00:25:07.174 align:middle
就是属性
就是标签值

00:25:09.710 --> 00:25:11.879 align:middle
但是 你可能还对多个

00:25:12.346 --> 00:25:14.515 align:middle
联系人感兴趣

00:25:14.982 --> 00:25:17.150 align:middle
你会得到这个

00:25:17.417 --> 00:25:18.252 align:middle
外观

00:25:19.353 --> 00:25:20.587 align:middle
实现它很简单

00:25:20.654 --> 00:25:21.855 align:middle
你只需要实现

00:25:21.922 --> 00:25:25.158 align:middle
didSelectContact委
托方法即可

00:25:25.225 --> 00:25:26.693 align:middle
然后如你所料

00:25:26.760 --> 00:25:28.662 align:middle
你得到了发送的联系人对象的
阵列

00:25:30.063 --> 00:25:32.633 align:middle
这也同样适用于属性

00:25:33.100 --> 00:25:33.934 align:middle
你可以通过实现

00:25:34.001 --> 00:25:36.603 align:middle
didSelect
ContactProperties

00:25:36.670 --> 00:25:37.871 align:middle
委托方法
来得到多个属性

00:25:38.172 --> 00:25:40.040 align:middle
得到一个CNContact

00:25:40.307 --> 00:25:41.642 align:middle
属性
阵列

00:25:43.177 --> 00:25:44.011 align:middle
好了

00:25:44.778 --> 00:25:46.313 align:middle
现在我们再来讲讲
谓词

00:25:46.914 --> 00:25:50.684 align:middle
谓词让你可以定制
面板的行为

00:25:51.552 --> 00:25:52.753 align:middle
我们有三个谓词

00:25:53.720 --> 00:25:56.356 align:middle
第一个是启动联系人
谓词

00:25:57.057 --> 00:25:58.592 align:middle
你可以用它决定用户

00:25:58.659 --> 00:26:01.261 align:middle
可以用哪个联系人、

00:25:58.659 --> 00:26:01.261 align:middle
可以用哪个联系人、

00:26:01.328 --> 00:26:02.696 align:middle
不可以用哪个联系人

00:26:03.430 --> 00:26:05.866 align:middle
我拿之前我们看过的例子
来举例

00:26:07.000 --> 00:26:09.636 align:middle
如果你希望用户仅仅选择
帕克家族的

00:26:09.703 --> 00:26:12.172 align:middle
成员
举例来说

00:26:12.673 --> 00:26:15.943 align:middle
你需要在你想要匹配联系人
和帕克家族的姓氏那里

00:26:16.009 --> 00:26:17.811 align:middle
创建一个谓词

00:26:19.513 --> 00:26:20.414 align:middle
你把它设置成一个

00:26:20.480 --> 00:26:22.549 align:middle
predicate For Enabling Contact

00:26:22.816 --> 00:26:24.551 align:middle
一旦选择器
表述出来后

00:26:24.618 --> 00:26:28.255 align:middle
你可以看到
你只能选择带有

00:26:28.322 --> 00:26:30.023 align:middle
帕克家族的姓氏的人

00:26:31.959 --> 00:26:36.530 align:middle
第二个是谓词
For Selection Of Contact

00:26:37.364 --> 00:26:39.466 align:middle
当用户点击联系人时

00:26:39.833 --> 00:26:41.702 align:middle
会对这个谓词进行评估

00:26:42.302 --> 00:26:43.804 align:middle
如果评估为“真”

00:26:43.871 --> 00:26:46.173 align:middle
那么联系人就会
返回到你的app

00:26:46.607 --> 00:26:49.209 align:middle
如果不是的话
我们就会显示联系卡

00:26:50.811 --> 00:26:52.412 align:middle
类似地
对属性来说我们有谓词

00:26:52.479 --> 00:26:54.815 align:middle
ForSelectionOf
Property

00:26:55.382 --> 00:26:58.852 align:middle
如果评估为“真”
用户点击的属性

00:26:58.919 --> 00:27:01.255 align:middle
也将会
返回到你的app

00:26:58.919 --> 00:27:01.255 align:middle
也将会
返回到你的app

00:27:01.555 --> 00:27:03.657 align:middle
否则就会执行
默认动作

00:27:03.991 --> 00:27:06.827 align:middle
比如说打一通电话
或者创建一封新电子邮件

00:27:08.028 --> 00:27:11.298 align:middle
需要注意的是
最后一个谓词是在

00:27:11.365 --> 00:27:13.667 align:middle
CNContactProperty
对象上评估的

00:27:13.734 --> 00:27:17.404 align:middle
而另外两个谓词则是在
CNContact对象上评估的

00:27:19.840 --> 00:27:22.576 align:middle
我想要指出的是
你需要在你设置的谓词

00:27:23.010 --> 00:27:24.845 align:middle
以及你实现的委托方法之间

00:27:24.912 --> 00:27:26.780 align:middle
保持
连贯

00:27:27.214 --> 00:27:29.716 align:middle
比如说你应该仅实现
didSelectContact

00:27:29.783 --> 00:27:33.720 align:middle
委托方法
但要把选择谓词设置为

00:27:33.887 --> 00:27:37.758 align:middle
属性谓词
但是不太行得通

00:27:37.824 --> 00:27:40.394 align:middle
你可以看到一项日志
你的谓词将会被忽略

00:27:43.630 --> 00:27:45.032 align:middle
那么现在

00:27:45.098 --> 00:27:46.900 align:middle
你已经知道了
应该如何拾取联系人

00:27:46.967 --> 00:27:49.469 align:middle
我们再来谈谈如何在你的
app中查看它们

00:27:50.304 --> 00:27:51.805 align:middle
现在我们有一个类

00:27:51.872 --> 00:27:55.309 align:middle
取代了我们之前在
Address Book UI上的三个类

00:27:57.010 --> 00:27:59.847 align:middle
但是通过适当的创建方法
你还是可以获得

00:28:00.447 --> 00:28:02.716 align:middle
你想要的
行为

00:28:04.351 --> 00:28:05.319 align:middle
第一个是

00:28:05.385 --> 00:28:07.821 align:middle
viewControllerFor
Contact

00:28:07.888 --> 00:28:14.061 align:middle
它可以给你一个和联系人app
和iPhone app一样的视图控制器

00:28:16.096 --> 00:28:18.031 align:middle
如果你想要创建一个新
联系人

00:28:18.098 --> 00:28:18.932 align:middle
你可以使用

00:28:18.999 --> 00:28:20.968 align:middle
viewControllerFor
NewContact

00:28:21.034 --> 00:28:24.404 align:middle
你可以得到这个总是处于
编辑模式的视图控制器

00:28:26.573 --> 00:28:28.842 align:middle
最后
如果你有一位来自

00:28:28.909 --> 00:28:32.312 align:middle
未知来源的 比如说一个vCard
举个例子 的联系人

00:28:32.646 --> 00:28:33.480 align:middle
你可以使用

00:28:33.547 --> 00:28:35.148 align:middle
viewControllerFor
UnknownContact

00:28:35.516 --> 00:28:40.053 align:middle
我们在iOS 9中添加的一件事是
这个更新联系人按钮

00:28:40.654 --> 00:28:42.823 align:middle
如果用户联系人中已有一位
联系人和你显示的

00:28:43.056 --> 00:28:44.525 align:middle
联系人的名字相匹配

00:28:44.591 --> 00:28:46.894 align:middle
这个
按钮

00:28:47.327 --> 00:28:48.662 align:middle
就会
自动显示出来

00:28:49.296 --> 00:28:51.064 align:middle
如果用户点击这个按钮

00:28:51.131 --> 00:28:52.999 align:middle
<br/>
它就会显示UI

00:28:53.066 --> 00:28:55.269 align:middle
使用新信息
更新现有的联系人

00:28:58.272 --> 00:29:01.141 align:middle
这个“联系人视图控制器”
现在通常处于进程外

00:28:58.272 --> 00:29:01.141 align:middle
这个“联系人视图控制器”
现在通常处于进程外

00:29:01.808 --> 00:29:03.043 align:middle
原因在于

00:29:03.477 --> 00:29:05.812 align:middle
我们可能会添加一些
附加信息

00:29:06.213 --> 00:29:08.949 align:middle
比如在邮件中找到的
联系人数据

00:29:11.251 --> 00:29:14.254 align:middle
就像戴夫之前指出的那样
使用正确的键

00:29:14.421 --> 00:29:17.624 align:middle
读取联系人
非常重要

00:29:18.458 --> 00:29:20.928 align:middle
如果你想把它显示在
联系人视图控制器中

00:29:20.994 --> 00:29:24.498 align:middle
那么这个联系人就必须通过
联系人视图控制器的

00:29:24.631 --> 00:29:26.533 align:middle
descriptor For Required Keys获取

00:29:28.902 --> 00:29:32.005 align:middle
我们来快速看一个代码实例
看看如何从一个标识符

00:29:32.072 --> 00:29:34.508 align:middle
显示一个
联系人

00:29:35.442 --> 00:29:37.511 align:middle
首先 你要使用
联系人视图控制器的

00:29:37.578 --> 00:29:41.181 align:middle
descriptorForRequ
iredKeys 读取联系人

00:29:42.749 --> 00:29:45.018 align:middle
然后使用forContact

00:29:45.085 --> 00:29:47.421 align:middle
创建
联系人视图控制器

00:29:47.521 --> 00:29:50.457 align:middle
因为我们想在联系人视图
控制器显示正视图

00:29:51.458 --> 00:29:55.329 align:middle
如果你已经有了一个联系人
存储器 你就应该把它设置到

00:29:55.395 --> 00:29:58.732 align:middle
联系人视图控制器
这样我们就可以重用它

00:29:59.299 --> 00:30:01.101 align:middle
把自身设为一个委托

00:29:59.299 --> 00:30:01.101 align:middle
把自身设为一个委托

00:30:02.336 --> 00:30:03.804 align:middle
推送视图控制

00:30:04.304 --> 00:30:07.641 align:middle
然后当联系人被修改时
你就会在你的委托方法中

00:30:07.708 --> 00:30:09.142 align:middle
被调用到

00:30:11.278 --> 00:30:13.480 align:middle
好了
看一个代码示例很好

00:30:13.547 --> 00:30:17.384 align:middle
但是一起构建一个app
会更好

00:30:18.552 --> 00:30:19.753 align:middle
我们来试试吧

00:30:24.057 --> 00:30:25.626 align:middle
我们要构建的app

00:30:26.026 --> 00:30:26.994 align:middle
叫做“喵喵叫”

00:30:27.961 --> 00:30:32.399 align:middle
这个app让你可以通过
给你的朋友发送猫的

00:30:32.566 --> 00:30:35.536 align:middle
叫声
和你的朋友分享你的情绪

00:30:37.938 --> 00:30:39.206 align:middle
如果我运行它 你在顶部就

00:30:40.607 --> 00:30:43.010 align:middle
可以看到一个情绪选择器

00:30:44.077 --> 00:30:46.346 align:middle
底部是你的朋友列表
现在还是空的

00:30:46.713 --> 00:30:49.383 align:middle
我们要构建的
就是这个

00:30:50.851 --> 00:30:54.388 align:middle
这个app是使用一个邮件地址
来发送猫的叫声的

00:30:55.556 --> 00:30:59.826 align:middle
因此我们只需要一个绰号
和一个电子邮件地址即可

00:31:02.329 --> 00:31:04.665 align:middle
如果我点击“保存”
因为还没有实现

00:31:04.731 --> 00:31:06.667 align:middle
那么
什么也不会发生

00:31:06.967 --> 00:31:08.268 align:middle
我们就要
这样做

00:31:10.237 --> 00:31:12.539 align:middle
当我点击“保存”

00:31:12.773 --> 00:31:14.374 align:middle
<br/>
这个addBuddy函数会调用到

00:31:14.441 --> 00:31:16.577 align:middle
我们现在来把它实现

00:31:17.845 --> 00:31:19.746 align:middle
首先
因为我们要进行修改

00:31:19.813 --> 00:31:21.582 align:middle
我们创建一个
可变联系人

00:31:22.082 --> 00:31:25.118 align:middle
然后我们从文本框把绰号
设置成值

00:31:26.753 --> 00:31:30.724 align:middle
emailAddresses属性
被设置成了一个单一

00:31:31.358 --> 00:31:33.327 align:middle
标签值的阵列

00:31:33.861 --> 00:31:36.330 align:middle
文本框中
也是这个值

00:31:37.764 --> 00:31:41.301 align:middle
最后 我们把这个新联系人
添加到我们的联系人列表

00:31:42.336 --> 00:31:44.004 align:middle
我们运行下

00:31:44.505 --> 00:31:45.672 align:middle
看看它是怎样运作的

00:31:48.675 --> 00:31:51.678 align:middle
我要使用预先填充的值
把埃米莉添加为我的朋友

00:31:51.745 --> 00:31:52.913 align:middle
好了

00:31:53.947 --> 00:31:55.082 align:middle
我的家庭

00:31:55.983 --> 00:31:58.185 align:middle
你可以注意到这里的这个
信息按钮

00:31:58.785 --> 00:32:00.654 align:middle
当我们点击这个
信息按钮时

00:31:58.785 --> 00:32:00.654 align:middle
当我们点击这个
信息按钮时

00:32:01.021 --> 00:32:02.856 align:middle
我们想要展示
联系人视图

00:32:04.157 --> 00:32:06.460 align:middle
我们现在就要实现
这个

00:32:09.396 --> 00:32:11.532 align:middle
当我点击这个按钮时

00:32:12.499 --> 00:32:14.401 align:middle
<br/>
这个showContact函数被调
用了

00:32:15.569 --> 00:32:17.004 align:middle
让我们填进去

00:32:17.838 --> 00:32:21.108 align:middle
首先
我们给我们想要展示的

00:32:21.408 --> 00:32:22.876 align:middle
联系人创建一个

00:32:23.277 --> 00:32:24.645 align:middle
联系人视图控制器

00:32:25.245 --> 00:32:28.048 align:middle
然后我们把联系人存储器设为
我们已有的存储器

00:32:29.316 --> 00:32:30.918 align:middle
最后
我们推送下视图控制器

00:32:35.155 --> 00:32:36.790 align:middle
让我们来试试

00:32:36.857 --> 00:32:39.826 align:middle
好了
我们可以看到埃米莉的信息

00:32:40.594 --> 00:32:44.264 align:middle
太好了 但是如果我们想向我们的列表
添加一个联系人

00:32:44.331 --> 00:32:46.633 align:middle
而这个联系人已经位于用户的
联系人中 该怎么办？

00:32:47.434 --> 00:32:49.303 align:middle
我们在这里要做的
就是这个

00:32:50.170 --> 00:32:52.506 align:middle
为此我们要使用
这个联系人选择器

00:32:55.209 --> 00:32:58.846 align:middle
当我点击addFromContac
ts时 这个函数就会调用到

00:32:59.479 --> 00:33:01.215 align:middle
现在我要把它
实现

00:32:59.479 --> 00:33:01.215 align:middle
现在我要把它
实现

00:33:03.016 --> 00:33:07.387 align:middle
首先我要创建
联系人选择器控制器

00:33:08.222 --> 00:33:10.958 align:middle
因为我们只对电子邮件
地址感兴趣

00:33:11.658 --> 00:33:14.628 align:middle
我限制了电子邮件地址的
属性

00:33:16.597 --> 00:33:23.370 align:middle
然后我们想要让用户选择
至少有一个电子邮件地址的

00:33:23.904 --> 00:33:25.772 align:middle
联系人

00:33:26.273 --> 00:33:29.042 align:middle
我们可以看到 这是
正在实现的谓词的一部分

00:33:29.543 --> 00:33:32.412 align:middle
还可以看到还不在我们的
朋友列表中的人

00:33:32.613 --> 00:33:33.981 align:middle
因为我们不想出现
重复

00:33:36.049 --> 00:33:38.919 align:middle
最后
是已经是联系人的用户

00:33:39.219 --> 00:33:42.489 align:middle
正好有一个电子邮件地址的
用户

00:33:42.556 --> 00:33:45.225 align:middle
我们不需要推送卡
我们想让它直接写

00:33:46.026 --> 00:33:48.428 align:middle
这个谓词做的
就是这个

00:33:49.930 --> 00:33:53.600 align:middle
我们把自身设成一个委托
显示视图控制器

00:33:55.702 --> 00:33:58.205 align:middle
我们也需要委托方法

00:33:59.439 --> 00:34:02.342 align:middle
<br/>
可以把新联系人
添加到我们的联系人列表中

00:33:59.439 --> 00:34:02.342 align:middle
<br/>
可以把新联系人
添加到我们的联系人列表中

00:34:03.610 --> 00:34:04.978 align:middle
现在就非常直接

00:34:07.481 --> 00:34:09.315 align:middle
如果选择约翰·阿普尔西德

00:34:10.350 --> 00:34:11.685 align:middle
我就知道他有两个电子邮件

00:34:12.351 --> 00:34:14.388 align:middle
所以推送的是正确的卡

00:34:14.955 --> 00:34:17.558 align:middle
我会选择一个电子邮件
让约翰在我们的列表中

00:34:21.195 --> 00:34:22.396 align:middle
如果我添加一个联系人

00:34:22.462 --> 00:34:24.598 align:middle
首先你可以看到现在
约翰·阿普尔西德是无效的

00:34:24.665 --> 00:34:26.400 align:middle
因为他已经在我的
朋友列表中了

00:34:27.301 --> 00:34:28.902 align:middle
但是如果我选择大卫

00:34:28.969 --> 00:34:31.038 align:middle
他只有一个电子邮件地址

00:34:31.103 --> 00:34:32.706 align:middle
这个联系人就
直接返回了

00:34:34.975 --> 00:34:38.445 align:middle
如果我想展示约翰的卡
又会发生什么？

00:34:39.679 --> 00:34:41.047 align:middle
我们出现了一个异常

00:34:41.547 --> 00:34:44.885 align:middle
原因是因为在这里展示
联系人时

00:34:45.319 --> 00:34:48.822 align:middle
我们
不够小心

00:34:50.891 --> 00:34:53.393 align:middle
因为联系人选择器返回了
部分联系人

00:34:53.460 --> 00:34:56.063 align:middle
联系人视图控制器
缺失了某些键

00:34:58.198 --> 00:35:00.000 align:middle
我们来把它修复

00:35:01.101 --> 00:35:04.071 align:middle
然后校验联系人是否有了

00:35:04.137 --> 00:35:05.839 align:middle
要用在联系人视图控制器的
要求的

00:35:06.306 --> 00:35:07.841 align:middle
键

00:35:08.442 --> 00:35:12.513 align:middle
如果有 我们只需要使用
我们之前的代码即可

00:35:13.313 --> 00:35:14.781 align:middle
如果没有

00:35:14.848 --> 00:35:16.517 align:middle
我们首先会向存储器请求

00:35:16.583 --> 00:35:18.619 align:middle
请求访问联系人

00:35:19.853 --> 00:35:21.788 align:middle
如果用户允许访问

00:35:22.956 --> 00:35:26.960 align:middle
我们就要通过它的标识符
重新读取联系人

00:35:27.828 --> 00:35:30.397 align:middle
这次使用keysToFetch

00:35:30.864 --> 00:35:33.166 align:middle
CNContactView
Controller

00:35:33.233 --> 00:35:35.536 align:middle
记录键的
描述符

00:35:36.770 --> 00:35:40.240 align:middle
然后我们再次调用同样的
函数 但是这次

00:35:40.307 --> 00:35:43.243 align:middle
完整的联系人
已经准备就绪待用了

00:35:44.578 --> 00:35:45.879 align:middle
我们再来试试

00:35:48.982 --> 00:35:52.152 align:middle
如果我查看埃米莉的
联系卡

00:35:52.886 --> 00:35:54.121 align:middle
不会显示任何对话

00:35:54.188 --> 00:35:58.859 align:middle
这是因为埃米莉
是在代码中创建的

00:35:58.926 --> 00:36:00.360 align:middle
她有各个读取键

00:35:58.926 --> 00:36:00.360 align:middle
她有各个读取键

00:36:00.961 --> 00:36:04.765 align:middle
如果我也查看约翰的联系卡
我就必须重新读取了

00:36:05.532 --> 00:36:08.202 align:middle
此时你的app就会
访问用户的联系人

00:36:09.469 --> 00:36:13.340 align:middle
搞定了 我们可以看到
约翰的所有联系人信息 好了

00:36:16.009 --> 00:36:19.279 align:middle
我们的演示结束了

00:36:19.546 --> 00:36:20.881 align:middle
我有点小伤心

00:36:21.682 --> 00:36:24.184 align:middle
我要和约翰
分享下我的情绪

00:36:32.459 --> 00:36:33.927 align:middle
我要把布鲁斯请回来
请他

00:36:34.228 --> 00:36:35.429 align:middle
结束这次演讲

00:36:39.800 --> 00:36:41.335 align:middle
谢谢
谢谢戴夫和朱利安向我们展示

00:36:41.401 --> 00:36:43.804 align:middle
如何在我们的app中
使用联系人

00:36:45.939 --> 00:36:47.808 align:middle
你们现在有一个
Objective-C

00:36:47.875 --> 00:36:49.409 align:middle
API来访问联系人

00:36:49.843 --> 00:36:52.779 align:middle
它同样也兼容Swift

00:36:54.281 --> 00:36:58.118 align:middle
联系人API在各个Apple平台上
都一样

00:37:00.320 --> 00:37:01.989 align:middle
Address book正在被
弃用

00:37:02.122 --> 00:37:03.790 align:middle
因此换新的API吧

00:37:07.728 --> 00:37:10.230 align:middle
要获取更多信息
你可以参考开发者库上

00:37:10.297 --> 00:37:12.299 align:middle
“ContactsUI框架参考”
的

00:37:12.799 --> 00:37:13.901 align:middle
联系人部分

00:37:15.903 --> 00:37:18.972 align:middle
要获得技术支持
你可以到开发者论坛

00:37:20.040 --> 00:37:22.109 align:middle
如果是普通咨询
保罗会很乐意看邮件

00:37:22.176 --> 00:37:25.546 align:middle
因此你可以给他发邮件 他是
我们的app框架福音传道者

00:37:26.013 --> 00:37:26.847 align:middle
谢谢
