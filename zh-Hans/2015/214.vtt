WEBVTT

00:00:20.220 --> 00:00:23.056 align:middle
《有关On Demand Resources之简介》

00:00:23.123 --> 00:00:23.957 align:middle
下午好

00:00:25.859 --> 00:00:29.029 align:middle
欢迎来到今天关于On Demand
Resources的介绍会议

00:00:29.096 --> 00:00:30.364 align:middle
我是史蒂夫·列瓦伦

00:00:30.764 --> 00:00:32.299 align:middle
我们今天将给你们准备了些什么呢

00:00:32.366 --> 00:00:34.301 align:middle
嗯 我们还是先给你们说说

00:00:34.368 --> 00:00:37.471 align:middle
On Demand Resources
或者是ODR的大致情况

00:00:37.871 --> 00:00:41.909 align:middle
我们来比较一下使用ODR App
与没有使用它的区别吧

00:00:43.010 --> 00:00:45.345 align:middle
我们将为ODR开发人员
以及用户们

00:00:45.412 --> 00:00:48.448 align:middle
列出ODR App的
所有特性和优势

00:00:49.650 --> 00:00:52.753 align:middle
然后我们将
深入研究ODR的细节

00:00:53.020 --> 00:00:55.989 align:middle
结构以及如何构建等问题

00:00:56.957 --> 00:00:59.993 align:middle
接下来我们将给你演示
使用Xcode

00:01:00.360 --> 00:01:03.130 align:middle
并将新的ODR API添加到库里

00:01:04.565 --> 00:01:09.670 align:middle
最后 我们将演示
和构建最优ODR API的最佳实践

00:01:09.736 --> 00:01:11.338 align:middle
并整理成一个小片段

00:01:12.172 --> 00:01:13.006 align:middle
咱们开始吧

00:01:13.874 --> 00:01:16.510 align:middle
我们得先理解

00:01:16.577 --> 00:01:20.013 align:middle
传统App的进展状况
才能理解ODR的进展

00:01:20.514 --> 00:01:23.383 align:middle
这个App现在将会有一个
可执行的部分

00:01:23.450 --> 00:01:27.087 align:middle
这是编译好的Swift
Objective-C C++

00:01:27.354 --> 00:01:29.089 align:middle
以及一些基础资料

00:01:29.523 --> 00:01:32.292 align:middle
和游戏等级资料
例如 假设这是一个游戏

00:01:33.327 --> 00:01:36.163 align:middle
当开发人员对这个游戏
或App感到满意

00:01:36.230 --> 00:01:37.798 align:middle
于是你们上传到App Store里

00:01:38.632 --> 00:01:41.134 align:middle
这样 用户可以购买
这个App或游戏

00:01:41.335 --> 00:01:42.836 align:middle
然后他们得到整个程序

00:01:43.003 --> 00:01:44.605 align:middle
并下载到设备上

00:01:45.138 --> 00:01:46.773 align:middle
然而他们下载的东西
并不单单如此

00:01:47.040 --> 00:01:52.713 align:middle
其中也包含开发人员为所有用户编写的
其他有趣的东西包括App和游戏

00:01:53.480 --> 00:01:55.949 align:middle
他们其实是如此有趣

00:01:56.183 --> 00:02:00.954 align:middle
人们下载得再多也
觉得不够而事实亦如此

00:01:56.183 --> 00:02:00.954 align:middle
人们下载得再多也
觉得不够而事实亦如此

00:02:01.021 --> 00:02:03.690 align:middle
设备上没有足够多的空间

00:02:04.157 --> 00:02:05.325 align:middle
因此我们怎么要做呢

00:02:05.792 --> 00:02:08.695 align:middle
好吧 我们能做的就是
观察每个App

00:02:08.762 --> 00:02:11.632 align:middle
发现并非每个部分都被使用

00:02:11.899 --> 00:02:12.733 align:middle
我举个例子

00:02:12.799 --> 00:02:15.435 align:middle
我的游戏级别是7级

00:02:15.802 --> 00:02:17.871 align:middle
我肯定不想再待在1级

00:02:17.938 --> 00:02:20.941 align:middle
而且长时间内
我可能也到不了30级

00:02:21.341 --> 00:02:22.509 align:middle
如此一来

00:02:22.576 --> 00:02:24.845 align:middle
我们就开始考虑ODR

00:02:25.145 --> 00:02:27.614 align:middle
现在让我们来看ODR的
一个App吧

00:02:28.682 --> 00:02:29.650 align:middle
在这种情况下

00:02:29.850 --> 00:02:31.318 align:middle
我们开始使用相同的比特

00:02:31.385 --> 00:02:32.886 align:middle
没有去掉任何东西

00:02:32.953 --> 00:02:35.122 align:middle
但我们要做的是梳理

00:02:35.189 --> 00:02:37.257 align:middle
每个游戏级别的资料

00:02:37.991 --> 00:02:40.160 align:middle
然后我们将整个东西
上传到商店

00:02:40.794 --> 00:02:43.530 align:middle
现在当客户购买这个App时

00:02:44.264 --> 00:02:46.300 align:middle
他们得到可操作的基础资料

00:02:46.433 --> 00:02:48.535 align:middle
也许有Level 1的游戏装备

00:02:49.236 --> 00:02:50.270 align:middle
这不是双关语

00:02:50.337 --> 00:02:51.839 align:middle
我们已经在游戏中了

00:02:51.905 --> 00:02:55.142 align:middle
因为他们能闯过
游戏的Level 1

00:02:55.342 --> 00:02:57.878 align:middle
购买和使用App与
Level 1的时间

00:02:57.945 --> 00:03:01.515 align:middle
比那些下载整个App更快

00:02:57.945 --> 00:03:01.515 align:middle
比那些下载整个App更快

00:03:01.849 --> 00:03:04.484 align:middle
而且使用更少的磁盘空间

00:03:06.119 --> 00:03:08.188 align:middle
用户现在开始玩这个游戏

00:03:08.655 --> 00:03:10.257 align:middle
并开始玩Level 1

00:03:10.991 --> 00:03:13.327 align:middle
一个设计良好的ODR App

00:03:13.393 --> 00:03:15.929 align:middle
需要能预测
比如下一个等级

00:03:16.063 --> 00:03:17.564 align:middle
因此 需要进行下载资料

00:03:18.332 --> 00:03:19.967 align:middle
用户继续玩

00:03:20.033 --> 00:03:21.869 align:middle
打到Level 2

00:03:22.402 --> 00:03:25.439 align:middle
然后ODR内置的缓存机制

00:03:25.506 --> 00:03:27.608 align:middle
通知你不再使用Level 2

00:03:27.674 --> 00:03:29.209 align:middle
并且作上标记

00:03:29.643 --> 00:03:30.544 align:middle
资料还在那儿

00:03:30.611 --> 00:03:31.545 align:middle
我们什么都不用做

00:03:31.612 --> 00:03:34.548 align:middle
只需要记住不再用它

00:03:34.615 --> 00:03:37.217 align:middle
但会一直保留设备上

00:03:37.284 --> 00:03:38.886 align:middle
这样空间就慢慢少了

00:03:38.952 --> 00:03:40.487 align:middle
无法储存下一个级游戏

00:03:40.721 --> 00:03:43.991 align:middle
我们检查设备上
其他可能释放资源的空间

00:03:44.057 --> 00:03:46.393 align:middle
仅剩下这个游戏的...

00:03:46.660 --> 00:03:49.630 align:middle
ODR内容 仅此而已

00:03:49.696 --> 00:03:50.631 align:middle
在这种情况下

00:03:50.697 --> 00:03:53.534 align:middle
缓存机制可以一步释放空间

00:03:53.600 --> 00:03:55.802 align:middle
比如 我有1级的内容

00:03:55.869 --> 00:03:57.771 align:middle
我可以将它释放

00:03:57.971 --> 00:04:00.073 align:middle
这样然后用户可以
继续玩下一级游戏

00:03:57.971 --> 00:04:00.073 align:middle
这样然后用户可以
继续玩下一级游戏

00:04:00.641 --> 00:04:03.210 align:middle
这是ODR的基本理念

00:04:03.277 --> 00:04:04.344 align:middle
从游戏的购买

00:04:04.411 --> 00:04:07.548 align:middle
到玩游戏时间更短

00:04:07.748 --> 00:04:10.217 align:middle
占据设备空间更小

00:04:10.284 --> 00:04:11.752 align:middle
更易于...

00:04:11.818 --> 00:04:12.653 align:middle
管理

00:04:15.489 --> 00:04:18.591 align:middle
现在让我们谈谈ODR

00:04:18.825 --> 00:04:20.527 align:middle
为开发人员提供的所有亮点

00:04:21.495 --> 00:04:25.365 align:middle
首先 这显然是一个
动态加载的内容体系

00:04:25.432 --> 00:04:27.868 align:middle
你们可能已经使用过
这样的系统

00:04:27.935 --> 00:04:30.070 align:middle
但是我们添加了一些新特性

00:04:30.671 --> 00:04:32.272 align:middle
首先我们可以在App Store中

00:04:32.339 --> 00:04:34.408 align:middle
储存该App的内容

00:04:35.342 --> 00:04:39.513 align:middle
第二 我们可以在安装
和请求安装App时

00:04:39.680 --> 00:04:42.883 align:middle
下载内容
事实上我们可以

00:04:43.784 --> 00:04:45.819 align:middle
随时自动化...

00:04:46.053 --> 00:04:47.554 align:middle
操作下载

00:04:49.389 --> 00:04:52.526 align:middle
最后还包括我提到的
智能缓存机制

00:04:52.593 --> 00:04:53.427 align:middle
正如刚刚提到的

00:04:53.894 --> 00:04:56.763 align:middle
所以 我们可以腾出空间来

00:04:56.964 --> 00:04:58.232 align:middle
加载新的东西

00:04:59.933 --> 00:05:00.968 align:middle
最后

00:04:59.933 --> 00:05:00.968 align:middle
最后

00:05:01.468 --> 00:05:05.072 align:middle
App Store传统App
最大是4千兆字节

00:05:05.906 --> 00:05:07.508 align:middle
但是ODR App

00:05:07.574 --> 00:05:09.977 align:middle
现在可以达到20千兆字节

00:05:10.544 --> 00:05:12.546 align:middle
当然 这些大多数
都是ODR的内容

00:05:13.914 --> 00:05:14.748 align:middle
好的

00:05:15.048 --> 00:05:16.149 align:middle
因此 这是开发者的优势

00:05:16.216 --> 00:05:17.985 align:middle
但对于用户的好处又是什么呢？

00:05:19.186 --> 00:05:21.288 align:middle
首先 我们可以...

00:05:21.655 --> 00:05:23.557 align:middle
改善安装体验

00:05:24.558 --> 00:05:27.094 align:middle
一个传统的DLC系统

00:05:27.160 --> 00:05:28.695 align:middle
使用该技术的游戏

00:05:29.029 --> 00:05:30.931 align:middle
会有这样的体验

00:05:30.998 --> 00:05:32.199 align:middle
用户下载App时

00:05:32.266 --> 00:05:34.735 align:middle
他们都非常期待玩这个游戏

00:05:34.801 --> 00:05:35.636 align:middle
他们启动游戏

00:05:35.736 --> 00:05:38.939 align:middle
然后 不是吧
游戏还需要下载一些新的内容

00:05:39.439 --> 00:05:43.710 align:middle
有了ODR 我们可以确保
新内容就在设备上

00:05:43.777 --> 00:05:45.612 align:middle
App只是看上去已经安装而已

00:05:45.679 --> 00:05:48.649 align:middle
因此用户体验会更好

00:05:50.083 --> 00:05:50.918 align:middle
第二

00:05:51.318 --> 00:05:53.287 align:middle
由于我们在设备上占用的
空间更小

00:05:53.353 --> 00:05:56.190 align:middle
在任何时候都更容易管理

00:05:56.256 --> 00:05:58.358 align:middle
App占用的空间小

00:05:58.425 --> 00:06:02.629 align:middle
我们就可以
存放更多的App在设备上

00:05:58.425 --> 00:06:02.629 align:middle
我们就可以
存放更多的App在设备上

00:06:02.696 --> 00:06:04.998 align:middle
这对用户来说
永远都是一件好事

00:06:06.733 --> 00:06:08.435 align:middle
最后
对于用户来说

00:06:08.635 --> 00:06:10.370 align:middle
同样的
由于有更多的空间

00:06:10.437 --> 00:06:12.706 align:middle
我们可以在App Store云端

00:06:12.940 --> 00:06:14.675 align:middle
存储更多App或是游戏

00:06:15.642 --> 00:06:19.279 align:middle
例如 我们可以有更丰富和
昂贵的游戏等级

00:06:19.580 --> 00:06:22.349 align:middle
对于用户
同样是一件好事

00:06:23.717 --> 00:06:24.551 align:middle
好的

00:06:25.052 --> 00:06:27.988 align:middle
现在让我们深究
一些关于ODR的细节

00:06:29.289 --> 00:06:32.092 align:middle
首先
对于IOS 9系统是应用瘦身

00:06:33.227 --> 00:06:36.063 align:middle
而且可以很好地与应用分割兼容

00:06:36.129 --> 00:06:37.898 align:middle
如果你错过了之前

00:06:37.965 --> 00:06:39.433 align:middle
关于应用分割会议

00:06:39.499 --> 00:06:43.871 align:middle
讨论如何将App 下载到
特定设备

00:06:44.404 --> 00:06:45.539 align:middle
让我给你举一个例子

00:06:45.739 --> 00:06:46.640 align:middle
你编写一个App

00:06:46.707 --> 00:06:49.943 align:middle
目标是各种不同型号的
iPhone和iPad

00:06:50.711 --> 00:06:52.579 align:middle
当iPhone用户来到

00:06:52.646 --> 00:06:53.881 align:middle
购买App后

00:06:54.114 --> 00:06:57.284 align:middle
应用分割可以确保
他们所得到的资源是必须的

00:06:57.351 --> 00:06:58.986 align:middle
而且是适合该
iPhone版本的

00:06:59.520 --> 00:07:01.321 align:middle
在此之前
用户会下载所有的

00:06:59.520 --> 00:07:01.321 align:middle
在此之前
用户会下载所有的

00:07:01.388 --> 00:07:03.257 align:middle
包括适合iPad的资源

00:07:03.924 --> 00:07:06.860 align:middle
因此 现在结合应用分割

00:07:07.160 --> 00:07:08.829 align:middle
和ODR之后

00:07:08.896 --> 00:07:10.330 align:middle
彼此双方都收益

00:07:10.397 --> 00:07:12.566 align:middle
它占用的空间更小

00:07:12.733 --> 00:07:15.536 align:middle
我们使App运行更快

00:07:15.669 --> 00:07:18.205 align:middle
App持续稳定性更好

00:07:18.272 --> 00:07:20.474 align:middle
在设备上占用的空间更小

00:07:21.909 --> 00:07:22.743 align:middle
好的

00:07:23.644 --> 00:07:24.478 align:middle
那么

00:07:25.145 --> 00:07:26.980 align:middle
一个ODR App是什么样的呢

00:07:27.047 --> 00:07:27.915 align:middle
它是如何构建的呢

00:07:28.182 --> 00:07:30.284 align:middle
它与如今的App很类似

00:07:30.617 --> 00:07:31.451 align:middle
但是

00:07:31.919 --> 00:07:35.923 align:middle
他能够将游戏里的等级
和资料梳理开

00:07:36.423 --> 00:07:37.891 align:middle
我们把这叫做资料包

00:07:38.659 --> 00:07:41.128 align:middle
剩余的App
仍是你的 .app

00:07:41.995 --> 00:07:46.366 align:middle
现在 运用Xcode
和简单的标签进行分组

00:07:46.433 --> 00:07:49.002 align:middle
例如 这些是我在游戏
Level 1中的所有资料

00:07:49.069 --> 00:07:50.103 align:middle
假设的说

00:07:50.437 --> 00:07:51.438 align:middle
这非常容易设置

00:07:53.440 --> 00:07:56.109 align:middle
你可以将它标记为简单的文件
或一整个文件夹

00:07:56.176 --> 00:07:58.612 align:middle
例如 这是Level 2的
整个文件夹

00:08:00.147 --> 00:08:02.082 align:middle
现在 你可以标记什么呢

00:08:03.250 --> 00:08:05.919 align:middle
几乎.app里的任何东西都可以

00:08:06.386 --> 00:08:07.221 align:middle
例如

00:08:07.654 --> 00:08:08.488 align:middle
图像

00:08:08.922 --> 00:08:09.756 align:middle
声音

00:08:10.357 --> 00:08:11.825 align:middle
数据和文字

00:08:12.059 --> 00:08:13.594 align:middle
很多有脚本的游戏

00:08:14.595 --> 00:08:17.030 align:middle
同样还有App内购买的内容

00:08:17.097 --> 00:08:19.900 align:middle
那么现在你可以
将程序内购买的物品

00:08:20.367 --> 00:08:22.636 align:middle
和通过ODR下载的
实际购买的内容

00:08:22.703 --> 00:08:24.338 align:middle
相结合起来

00:08:24.404 --> 00:08:26.473 align:middle
利用其它ODR API

00:08:26.540 --> 00:08:27.574 align:middle
实现管理

00:08:28.775 --> 00:08:30.911 align:middle
唯一无法获得的是可执行内容

00:08:30.978 --> 00:08:34.448 align:middle
即编译好的Swift
Objective-C、C、C++

00:08:34.581 --> 00:08:35.716 align:middle
这些会留在 .app里

00:08:37.083 --> 00:08:37.918 align:middle
好的

00:08:38.818 --> 00:08:39.653 align:middle
那么

00:08:40.187 --> 00:08:41.788 align:middle
这些内容将存储在哪里

00:08:42.389 --> 00:08:43.789 align:middle
好的 我提出其中一个位置

00:08:43.857 --> 00:08:45.158 align:middle
显然它是在App Store

00:08:46.226 --> 00:08:48.762 align:middle
我们存储在App Store
并且按需供应

00:08:49.596 --> 00:08:52.733 align:middle
但在开发过程中
Xcode代替了App Store

00:08:52.799 --> 00:08:55.569 align:middle
无论你是针对
设备还是模拟器进行开发

00:08:55.903 --> 00:08:58.572 align:middle
它存储在你的App中
并根据需求传输

00:09:00.040 --> 00:09:03.010 align:middle
现在 Xcode的另一款工具是
Xcode服务器

00:09:03.510 --> 00:09:05.445 align:middle
你可以把它设置在自己部门中

00:09:05.946 --> 00:09:09.750 align:middle
这样可以获取服务器上的
ODR和App

00:09:09.816 --> 00:09:11.351 align:middle
例如 按照你所安排的

00:09:11.418 --> 00:09:13.320 align:middle
Q/A工程组测试你的App

00:09:15.222 --> 00:09:18.992 align:middle
正如你所期望Test
Flight完全整合了ODR

00:09:20.027 --> 00:09:22.563 align:middle
最后 假如你要为公司部署一款App

00:09:22.930 --> 00:09:26.800 align:middle
实际上你可以在公司的
网络服务器上存储ODR内容

00:09:26.867 --> 00:09:28.569 align:middle
并设置安全登录

00:09:28.635 --> 00:09:31.071 align:middle
以确保不是所有人
都可以获取该内容

00:09:32.472 --> 00:09:34.174 align:middle
这ODR内容的存储位置了

00:09:35.843 --> 00:09:36.677 align:middle
好的

00:09:36.844 --> 00:09:38.245 align:middle
那么 该如何开始的呢

00:09:38.779 --> 00:09:40.614 align:middle
嗯 作为一个开发者
你要做的第一件事情是

00:09:40.681 --> 00:09:43.650 align:middle
看看你所有的App资料

00:09:43.817 --> 00:09:45.185 align:middle
并且识别它们

00:09:45.352 --> 00:09:46.720 align:middle
你需要对它们进行分类

00:09:47.821 --> 00:09:50.657 align:middle
再次重复 你可以
用简单的字符进行标记

00:09:51.024 --> 00:09:53.160 align:middle
这些是我游戏
Level 1的所有资料

00:09:53.794 --> 00:09:55.829 align:middle
这些是我游戏
Level 2的资料

00:09:55.929 --> 00:09:58.532 align:middle
而且你知道
等级间有一些共享的资料吗

00:09:59.233 --> 00:10:00.067 align:middle
它们就在那里

00:09:59.233 --> 00:10:00.067 align:middle
它们就在那里

00:10:00.133 --> 00:10:02.569 align:middle
你可用多重标签标记资料

00:10:02.669 --> 00:10:06.206 align:middle
以显示共享内容 防止重复

00:10:07.374 --> 00:10:10.444 align:middle
这部分是为准备好使用ODR的人
设计的首个部分

00:10:10.511 --> 00:10:12.145 align:middle
作为开发者 这是你的工作

00:10:12.246 --> 00:10:15.382 align:middle
现在Xcode起作用了
它将所有这些标签

00:10:15.749 --> 00:10:17.451 align:middle
和组放到资料包中

00:10:18.085 --> 00:10:20.754 align:middle
在这个案例中
我们用三个资料包做结尾

00:10:21.655 --> 00:10:23.257 align:middle
资料包1为Level 1

00:10:23.757 --> 00:10:25.359 align:middle
资料包2为Level 2

00:10:25.659 --> 00:10:27.861 align:middle
最后以介于资料包1和2之间

00:10:27.928 --> 00:10:30.130 align:middle
的资料包3作结尾

00:10:30.731 --> 00:10:32.266 align:middle
再一次
请避免重复

00:10:33.767 --> 00:10:36.136 align:middle
好了 Xcode起作用了

00:10:36.203 --> 00:10:37.771 align:middle
现在轮到开发者了

00:10:39.306 --> 00:10:40.974 align:middle
首先你要做的是

00:10:41.041 --> 00:10:42.509 align:middle
请求资料

00:10:42.609 --> 00:10:44.444 align:middle
我需要Level 1的所有东西

00:10:45.045 --> 00:10:46.914 align:middle
出来两个资料包

00:10:47.214 --> 00:10:49.449 align:middle
都属于Level 1

00:10:49.683 --> 00:10:52.819 align:middle
然后是介于Level 1
和Level 2之间的共享资料

00:10:53.320 --> 00:10:55.522 align:middle
因为已经接入共享资料包

00:10:55.923 --> 00:10:57.324 align:middle
在我们请求Level 2时

00:10:57.791 --> 00:10:58.792 align:middle
我们得到这些资料

00:10:59.259 --> 00:11:01.528 align:middle
而这些共享资料
也已经在我的设备上了

00:10:59.259 --> 00:11:01.528 align:middle
而这些共享资料
也已经在我的设备上了

00:11:02.629 --> 00:11:06.600 align:middle
以上是关于ODR概念以及

00:11:06.967 --> 00:11:09.069 align:middle
如何建立一个ODR请求的概述

00:11:09.136 --> 00:11:10.971 align:middle
现在 有请托尼·帕克上台

00:11:11.238 --> 00:11:13.807 align:middle
为我们展示使用API Xcode中
发生了什么

00:11:13.874 --> 00:11:14.708 align:middle
托尼

00:11:20.547 --> 00:11:21.381 align:middle
谢谢你 史蒂芬

00:11:21.915 --> 00:11:25.018 align:middle
我叫托尼·帕克
我是Apple Foundation组的经理

00:11:25.385 --> 00:11:28.689 align:middle
史蒂芬为大家介绍了
ODR系统如何工作的基本信息

00:11:29.022 --> 00:11:31.191 align:middle
现在我们将详细讲API

00:11:31.592 --> 00:11:34.027 align:middle
即在你的App 中
实际用来处理这些请求的API

00:11:35.362 --> 00:11:37.497 align:middle
关于API你必须知道这个

00:11:37.564 --> 00:11:41.535 align:middle
这是Foundation中的新类叫
NS Bundle Resource Request

00:11:43.070 --> 00:11:45.472 align:middle
这个类遵照命令设计模式

00:11:45.539 --> 00:11:48.609 align:middle
意思是你将用一组选择
建立一个对象

00:11:49.076 --> 00:11:51.778 align:middle
包括你喜欢用的标签

00:11:52.246 --> 00:11:54.181 align:middle
随后你告诉它开始它的请求

00:11:56.450 --> 00:11:58.452 align:middle
这样 你就可以按需创建对象了

00:11:58.719 --> 00:12:01.388 align:middle
因为系统会参照
高级选项计算标签

00:11:58.719 --> 00:12:01.388 align:middle
因为系统会参照
高级选项计算标签

00:12:02.089 --> 00:12:05.125 align:middle
所以 如果有不同部分
使用ODR App

00:12:05.325 --> 00:12:07.427 align:middle
且可能有重叠标签

00:12:07.761 --> 00:12:09.596 align:middle
你就不需要每次都创建管理类

00:12:09.663 --> 00:12:11.465 align:middle
跟踪你已经用过的那些

00:12:11.532 --> 00:12:13.133 align:middle
我们将为你处理这些问题

00:12:15.936 --> 00:12:18.705 align:middle
最重要的一点 即设计出发点是

00:12:19.006 --> 00:12:23.076 align:middle
请求与实际资料利用
不挂钩

00:12:23.777 --> 00:12:26.313 align:middle
意思是说
那些你已在App 中使用的

00:12:26.380 --> 00:12:28.682 align:middle
以及你已经非常熟悉的API

00:12:28.749 --> 00:12:31.185 align:middle
比如NS Bundle
URL For Resource

00:12:31.451 --> 00:12:33.887 align:middle
包含URL内容的NS Data数据

00:12:33.954 --> 00:12:35.923 align:middle
或UI Image
imageNamed

00:12:36.123 --> 00:12:38.425 align:middle
这些API将保持不变

00:12:38.792 --> 00:12:40.594 align:middle
你只需事先告诉系统

00:12:40.661 --> 00:12:42.262 align:middle
使用一个请求对象

00:12:42.462 --> 00:12:44.765 align:middle
告诉系统 这个对象里
的资料是你想显示的

00:12:47.701 --> 00:12:49.603 align:middle
这个对象组成一个
非常简单的状态机

00:12:49.670 --> 00:12:51.205 align:middle
从初始化开始

00:12:52.272 --> 00:12:53.740 align:middle
在预估资料需求时

00:12:53.807 --> 00:12:56.143 align:middle
我们跳转到请求状态

00:12:57.611 --> 00:12:59.813 align:middle
我们回到结束处理器回调

00:12:59.880 --> 00:13:03.350 align:middle
它将告诉我们
那些资料可以获得

00:12:59.880 --> 00:13:03.350 align:middle
它将告诉我们
那些资料可以获得

00:13:03.884 --> 00:13:06.887 align:middle
以及你可以继续使用
刚讨论的API

00:13:07.521 --> 00:13:08.922 align:middle
或告诉我们发生的错误

00:13:09.156 --> 00:13:11.124 align:middle
当然 在使用ODR时

00:13:11.191 --> 00:13:14.061 align:middle
会有一些错误
这些需要告诉用户

00:13:14.361 --> 00:13:16.430 align:middle
错误可能包括
我们需要下载内容

00:13:16.496 --> 00:13:18.198 align:middle
但没有适用的网络

00:13:18.565 --> 00:13:20.767 align:middle
或尽管已经做了清理

00:13:20.834 --> 00:13:23.170 align:middle
设备里仍没有足够的空间
储存这些内容

00:13:23.604 --> 00:13:25.906 align:middle
不管是什么情况
你都需要告诉用户

00:13:25.973 --> 00:13:27.875 align:middle
或许他们有办法解决这些问题

00:13:28.809 --> 00:13:30.644 align:middle
所以若有适用的资料

00:13:30.777 --> 00:13:32.980 align:middle
就像我说的请继续使用它们

00:13:33.480 --> 00:13:36.483 align:middle
同样重要的是当你用完这些资料

00:13:36.683 --> 00:13:37.818 align:middle
请告诉我们

00:13:37.885 --> 00:13:39.686 align:middle
你可以用这两种方法告诉我们

00:13:39.987 --> 00:13:42.990 align:middle
第一种
在这个类中调用明确的API

00:13:43.257 --> 00:13:45.225 align:middle
告诉我们你已经完成这个内容

00:13:46.026 --> 00:13:48.462 align:middle
第二种 允许种类解除分配

00:13:48.529 --> 00:13:50.030 align:middle
允许对象解除分配

00:13:50.430 --> 00:13:51.832 align:middle
在这种情况下

00:13:51.899 --> 00:13:54.201 align:middle
我们将为你结束请求

00:13:56.537 --> 00:13:58.138 align:middle
这是基本方法

00:13:58.605 --> 00:14:00.040 align:middle
首先 初始化程序

00:13:58.605 --> 00:14:00.040 align:middle
首先 初始化程序

00:14:00.274 --> 00:14:02.109 align:middle
你可看到这里有字符串

00:14:02.209 --> 00:14:04.478 align:middle
这就是正在请求
你所感兴趣的标签

00:14:05.512 --> 00:14:07.047 align:middle
开始请求的方法叫做

00:14:07.114 --> 00:14:11.151 align:middle
beginAccessingResources
WithCompletionHandler

00:14:11.218 --> 00:14:12.452 align:middle
你可看到有个结尾

00:14:12.519 --> 00:14:13.954 align:middle
里面有NSR Error证据

00:14:15.189 --> 00:14:16.356 align:middle
最后 这种方法

00:14:16.423 --> 00:14:17.691 align:middle
会告诉系统请求完成完成

00:14:17.891 --> 00:14:20.661 align:middle
明确
endAccessing Resources调用

00:14:22.596 --> 00:14:24.131 align:middle
接下来 我将展示

00:14:24.198 --> 00:14:25.899 align:middle
已经在运行中的API

00:14:34.341 --> 00:14:35.175 align:middle
好了

00:14:35.309 --> 00:14:38.846 align:middle
这是演示app 叫做iTravel

00:14:39.012 --> 00:14:41.882 align:middle
之所以叫这个名字

00:14:42.216 --> 00:14:44.618 align:middle
是因为它是一本旅行手册
提供所有你感兴趣的

00:14:44.685 --> 00:14:46.954 align:middle
以字母i开头的国家信息

00:14:47.621 --> 00:14:50.457 align:middle
你可以看到
今天用到的两个国家是

00:14:50.724 --> 00:14:52.459 align:middle
冰岛和意大利

00:14:52.993 --> 00:14:54.328 align:middle
现在 这个App是说明

00:14:54.394 --> 00:14:56.897 align:middle
On Demand Resources
用法的很好的例子

00:14:56.964 --> 00:14:57.998 align:middle
原因是...

00:14:58.065 --> 00:15:00.300 align:middle
用户购买这个app时

00:14:58.065 --> 00:15:00.300 align:middle
用户购买这个app时

00:15:00.534 --> 00:15:04.972 align:middle
或许对获取冰岛和意大利的
信息并不感兴趣

00:15:05.305 --> 00:15:07.274 align:middle
或至少不需要同时获得
两个信息

00:15:07.407 --> 00:15:09.543 align:middle
所以 我们可以通过

00:15:09.610 --> 00:15:11.678 align:middle
只下载所需内容

00:15:11.745 --> 00:15:13.480 align:middle
以减小安装和下载大小

00:15:14.081 --> 00:15:15.482 align:middle
在使用ODR之前

00:15:15.549 --> 00:15:18.085 align:middle
我想要简单的展示一下
如何使用它

00:15:18.452 --> 00:15:20.587 align:middle
首先访问冰岛

00:15:21.788 --> 00:15:24.725 align:middle
你可以看到我在这里拿到
兴趣点清单

00:15:25.225 --> 00:15:26.793 align:middle
我从中选择一个

00:15:27.227 --> 00:15:29.429 align:middle
里面可能有些优质的图片

00:15:29.496 --> 00:15:30.964 align:middle
或指南文本

00:15:31.265 --> 00:15:34.134 align:middle
兴趣点清单里的每一点
都有不少图片

00:15:34.535 --> 00:15:36.904 align:middle
你可以看到
这些增加了不少数据信息

00:15:39.573 --> 00:15:41.675 align:middle
而意大利 也是一样的

00:15:42.042 --> 00:15:44.011 align:middle
但是内容不同

00:15:46.813 --> 00:15:48.682 align:middle
我们来看看如何创建这个App

00:15:51.852 --> 00:15:53.620 align:middle
我们今天将花大量的时间
来讲一个类

00:15:53.687 --> 00:15:56.323 align:middle
就是
Album TableViewController

00:15:56.390 --> 00:15:58.992 align:middle
这是个视图控制器

00:15:59.059 --> 00:16:01.361 align:middle
控制这个兴趣点清单中的视图

00:15:59.059 --> 00:16:01.361 align:middle
控制这个兴趣点清单中的视图

00:16:02.062 --> 00:16:03.297 align:middle
让我来展示下它如何工作的

00:16:04.498 --> 00:16:06.166 align:middle
当我们继续这个视图

00:16:06.400 --> 00:16:09.570 align:middle
会有这个函数 叫做loadAlbum

00:16:09.636 --> 00:16:11.572 align:middle
接下来的问题是
我们想看那个相册

00:16:11.638 --> 00:16:13.540 align:middle
意大利或冰岛

00:16:14.842 --> 00:16:15.809 align:middle
设置标题

00:16:15.876 --> 00:16:18.512 align:middle
我们把这项辅助函数
叫做populateTable

00:16:19.146 --> 00:16:21.048 align:middle
现在 在populateTable
函数里

00:16:21.148 --> 00:16:24.351 align:middle
我们将使用
NSBundle´s URLForResource

00:16:24.551 --> 00:16:26.053 align:middle
寻找JSON文件

00:16:26.119 --> 00:16:29.823 align:middle
这个文件介绍所有兴趣点和清单
以显示题注

00:16:30.791 --> 00:16:33.594 align:middle
我们使用NSData的
contentsOfURL方法

00:16:33.660 --> 00:16:35.229 align:middle
从磁盘里读取JSON文件

00:16:35.629 --> 00:16:38.365 align:middle
我们使用NSJSONSerialization
对其进行解析

00:16:38.465 --> 00:16:40.467 align:middle
我们在这里
创建一些更详细标签文本

00:16:40.701 --> 00:16:42.669 align:middle
最后重载tableView

00:16:43.070 --> 00:16:45.105 align:middle
tableView里的数据源

00:16:45.172 --> 00:16:47.374 align:middle
使用UI Image.imageNamed

00:16:47.441 --> 00:16:49.476 align:middle
显示信息 获取图片

00:16:51.178 --> 00:16:52.746 align:middle
重点是

00:16:53.013 --> 00:16:55.148 align:middle
在这个App中使用ODR

00:16:55.449 --> 00:16:57.918 align:middle
植入Table中的功能无需变动

00:16:58.318 --> 00:16:59.152 align:middle
再说一次

00:16:59.219 --> 00:17:02.256 align:middle
现在你用来获取磁盘中文件内容

00:16:59.219 --> 00:17:02.256 align:middle
现在你用来获取磁盘中文件内容

00:17:02.456 --> 00:17:07.394 align:middle
或找出像NSBundles这种文件
所用的所有API保持不变

00:17:09.396 --> 00:17:10.364 align:middle
我们首先要做的是

00:17:10.430 --> 00:17:12.665 align:middle
在App中增加一些标签

00:17:12.999 --> 00:17:16.069 align:middle
做到这点
我将在这里创建检测点

00:17:16.803 --> 00:17:19.506 align:middle
你可以看到
我已经处理过我的App

00:17:19.573 --> 00:17:22.041 align:middle
里面有个叫Resources的组

00:17:22.409 --> 00:17:25.212 align:middle
以及包含部分内容的文件夹

00:17:25.345 --> 00:17:28.048 align:middle
这个包含所有冰岛的图片

00:17:28.715 --> 00:17:30.417 align:middle
这个包含所有意大利的图片

00:17:31.285 --> 00:17:33.754 align:middle
和我刚才讨论的这些JSON文件

00:17:35.489 --> 00:17:36.456 align:middle
接下来 我将接续

00:17:36.523 --> 00:17:40.661 align:middle
并为冰岛选择JSON文件
和文件夹

00:17:41.195 --> 00:17:43.764 align:middle
并查看检测点的右边

00:17:44.097 --> 00:17:47.201 align:middle
你可以看到这里有个新的叫
On Demand Resource标签

00:17:47.367 --> 00:17:49.269 align:middle
所以我所需做的是开始打字

00:17:50.304 --> 00:17:52.506 align:middle
内容将被标记为冰岛

00:17:53.106 --> 00:17:54.908 align:middle
用同样的方法
处理意大利的内容

00:17:56.443 --> 00:17:57.644 align:middle
内容 好了

00:17:59.580 --> 00:18:02.449 align:middle
接下来我们只需 以便
当然了

00:17:59.580 --> 00:18:02.449 align:middle
接下来我们只需 以便
当然了

00:18:02.516 --> 00:18:05.752 align:middle
正如Steve说过的
告诉Xcode如何将你的内容分开

00:18:06.086 --> 00:18:07.554 align:middle
现在 下一部分是

00:18:07.788 --> 00:18:09.289 align:middle
告诉运行中的系统

00:18:09.590 --> 00:18:11.091 align:middle
我们预计什么时间

00:18:11.158 --> 00:18:12.893 align:middle
需要这些内容备好可用

00:18:13.293 --> 00:18:15.262 align:middle
我们将在视图控制器中
进行操作

00:18:15.762 --> 00:18:18.899 align:middle
首先我要在我的类中
增加一个I var

00:18:18.966 --> 00:18:20.400 align:middle
以保存我们刚说的类

00:18:20.467 --> 00:18:22.803 align:middle
NSBundleResourceRequest

00:18:23.003 --> 00:18:25.105 align:middle
当视图控制器进行拆分时

00:18:25.172 --> 00:18:27.007 align:middle
我现在要做的是充分利用

00:18:27.441 --> 00:18:30.143 align:middle
我们很好地控制这个对象

00:18:30.210 --> 00:18:31.812 align:middle
这样 我们可以控制使用时间

00:18:32.079 --> 00:18:34.314 align:middle
当它完成拆分时
我们知道请求也完成了

00:18:34.381 --> 00:18:36.650 align:middle
我们允许系统对其解除分配

00:18:36.717 --> 00:18:39.353 align:middle
这将告诉系统
我们处理好内容了

00:18:41.221 --> 00:18:44.324 align:middle
下一步 在loadAlbum函数
调用populateTable前

00:18:44.558 --> 00:18:45.526 align:middle
我们将先...

00:18:45.826 --> 00:18:46.827 align:middle
创建请求

00:18:46.994 --> 00:18:49.263 align:middle
进入一组标签
在这个情况下

00:18:49.329 --> 00:18:51.865 align:middle
进入意大利
或冰岛中的一组标签

00:18:53.200 --> 00:18:54.034 align:middle
我们称之为

00:18:54.101 --> 00:18:56.937 align:middle
beginAccessingResources
WithCompletionHandler

00:18:57.004 --> 00:18:57.971 align:middle
结果出来后

00:18:58.038 --> 00:18:59.373 align:middle
这个结尾将被调用

00:19:00.140 --> 00:19:01.808 align:middle
或许会产生错误

00:19:02.142 --> 00:19:04.778 align:middle
在主线程中 这个完成处理程序

00:19:04.845 --> 00:19:06.113 align:middle
将在非主线程中被调用

00:19:06.480 --> 00:19:08.949 align:middle
我们首先检查
并确保错误是0

00:19:09.316 --> 00:19:10.918 align:middle
若不是0
那就是出现错误了

00:19:10.984 --> 00:19:12.252 align:middle
正如我们先前所讨论的

00:19:12.319 --> 00:19:15.689 align:middle
这需要告诉使用者
我将在辅助函数里进行操作

00:19:16.590 --> 00:19:20.360 align:middle
然后调用刚使用过的
populateTable函数

00:19:20.661 --> 00:19:22.029 align:middle
再一次
没有变动任何东西

00:19:22.729 --> 00:19:24.231 align:middle
继续 并再一次运行App

00:19:24.298 --> 00:19:25.299 align:middle
看看会是什么样的

00:19:30.070 --> 00:19:32.039 align:middle
现在 我访问冰岛

00:19:32.306 --> 00:19:34.708 align:middle
可以看到我的内容在这边

00:19:35.142 --> 00:19:36.810 align:middle
因为我们已经做了请求

00:19:36.877 --> 00:19:39.680 align:middle
我可以选择一些图片或兴趣点

00:19:40.047 --> 00:19:42.115 align:middle
所有的内容都准备就绪了

00:19:42.182 --> 00:19:44.384 align:middle
就好像从一开始它们就是
App的一部分一样

00:19:45.185 --> 00:19:48.088 align:middle
现在我们为你展示
Xcode新调试特征

00:19:48.155 --> 00:19:49.690 align:middle
若你以你认为的方式

00:19:49.990 --> 00:19:51.592 align:middle
使用这些请求对象

00:19:51.658 --> 00:19:52.960 align:middle
它将帮助你更好的进行理解

00:19:53.627 --> 00:19:55.095 align:middle
即新的调试计量器

00:19:55.762 --> 00:19:57.731 align:middle
我将把调试计量器视图
放在这里

00:19:57.798 --> 00:19:58.799 align:middle
选择磁盘

00:19:59.299 --> 00:20:01.835 align:middle
你可以看到
在中间我们有一个新部分

00:19:59.299 --> 00:20:01.835 align:middle
你可以看到
在中间我们有一个新部分

00:20:01.969 --> 00:20:03.537 align:middle
叫做
On Demand Resources

00:20:03.604 --> 00:20:05.873 align:middle
它列出你App中所有的标签

00:20:06.740 --> 00:20:07.975 align:middle
比如冰岛和意大利

00:20:08.108 --> 00:20:09.209 align:middle
他们的大小

00:20:09.409 --> 00:20:10.777 align:middle
和现在的状态

00:20:11.211 --> 00:20:13.680 align:middle
你看到冰岛的状态是在使用中

00:20:13.981 --> 00:20:15.115 align:middle
这就说得通了

00:20:15.182 --> 00:20:17.284 align:middle
因为我们在这里查看冰岛内容

00:20:17.651 --> 00:20:19.887 align:middle
在我看部分图片时
它保持使用中的状态

00:20:20.320 --> 00:20:22.556 align:middle
但若我回到主内容目录

00:20:22.789 --> 00:20:25.626 align:middle
它的状态由使用中变为已下载

00:20:25.926 --> 00:20:28.295 align:middle
因为请求对象已解除
系统知道我们

00:20:28.562 --> 00:20:31.465 align:middle
不再使用这些内容了

00:20:32.966 --> 00:20:35.702 align:middle
我们并未立即
从磁盘中删除信息

00:20:35.769 --> 00:20:37.771 align:middle
所以当你回到冰岛时
内容仍旧可用

00:20:38.005 --> 00:20:40.040 align:middle
它的状态也变成使用中

00:20:41.141 --> 00:20:43.076 align:middle
让我们看看访问意大利时
会出现什么

00:20:45.679 --> 00:20:47.414 align:middle
现在
你看到需要花一些时间

00:20:47.648 --> 00:20:48.982 align:middle
内容才会出来

00:20:49.449 --> 00:20:52.252 align:middle
原因是...

00:20:52.419 --> 00:20:56.190 align:middle
意大利标签远比冰岛的大

00:20:56.256 --> 00:20:57.691 align:middle
有130兆字节

00:20:58.392 --> 00:21:00.994 align:middle
这里需要做两件很重要的事

00:20:58.392 --> 00:21:00.994 align:middle
这里需要做两件很重要的事

00:21:01.228 --> 00:21:05.465 align:middle
首先需要减小标签内容大小

00:21:05.532 --> 00:21:07.401 align:middle
将其分成小的组块

00:21:07.701 --> 00:21:10.838 align:middle
随后我们会详细说明

00:21:11.305 --> 00:21:12.940 align:middle
现在
我想要告诉你

00:21:13.006 --> 00:21:16.410 align:middle
如何使用App中的进度报告

00:21:16.743 --> 00:21:17.578 align:middle
并配合使用

00:21:17.644 --> 00:21:20.013 align:middle
NS Bundle Resource Request

00:21:20.080 --> 00:21:23.383 align:middle
这样在你下载内容时
就可以告诉用户一些信息

00:21:23.450 --> 00:21:25.519 align:middle
以帮助他们理解接下来
会发生什么

00:21:27.254 --> 00:21:28.789 align:middle
让我们回到

00:21:29.456 --> 00:21:32.559 align:middle
AlbumTableViewController类

00:21:35.996 --> 00:21:37.764 align:middle
接下来要做的是利用

00:21:37.831 --> 00:21:40.701 align:middle
支持NS Progress的
NSBundleResourceRequest的优势

00:21:40.767 --> 00:21:41.869 align:middle
这是个基础类

00:21:41.935 --> 00:21:47.207 align:middle
你可在你的App中
用它来报告进程和构建进程

00:21:48.475 --> 00:21:50.844 align:middle
NS Progress支持键值观察

00:21:51.211 --> 00:21:55.282 align:middle
所以我们要做的是增加
视图控制器作为进度的观察点

00:21:55.649 --> 00:21:57.284 align:middle
并更新

00:21:57.651 --> 00:22:00.387 align:middle
改变屏幕上部分UI
一个UI进度视图

00:21:57.651 --> 00:22:00.387 align:middle
改变屏幕上部分UI
一个UI进度视图

00:22:00.454 --> 00:22:02.055 align:middle
并对一些详细标签文本
做出反应

00:22:03.724 --> 00:22:06.360 align:middle
这里 在创建请求后

00:22:06.827 --> 00:22:08.795 align:middle
调用addObserver

00:22:09.129 --> 00:22:10.464 align:middle
这类将是观察者

00:22:11.098 --> 00:22:14.301 align:middle
请求的进度属性
正是我们观察的对象

00:22:15.602 --> 00:22:18.338 align:middle
进度中的关键路径是
fractionCompleted

00:22:18.872 --> 00:22:20.607 align:middle
和往常一样 使用KVO时

00:22:20.841 --> 00:22:23.277 align:middle
指定唯一的内容指示器很重要

00:22:23.577 --> 00:22:25.212 align:middle
这个我已经在文件的某处
进行定义

00:22:25.979 --> 00:22:29.516 align:middle
我将继续并显示一个
UI progressView

00:22:29.583 --> 00:22:31.752 align:middle
这个进度视图已经
连接到我的故事板中

00:22:33.353 --> 00:22:36.757 align:middle
当收到回应
就可以移除Observer了

00:22:36.823 --> 00:22:40.727 align:middle
因为之后
我们不在对更新的进度感兴趣了

00:22:41.395 --> 00:22:45.132 align:middle
然后在主线程中
我们将继续显示...

00:22:45.199 --> 00:22:47.467 align:middle
不好意思
是继续隐藏UI 进程视图

00:22:47.534 --> 00:22:50.304 align:middle
因为我们不想要用户
盯着完整的进度指示器一直看

00:22:50.971 --> 00:22:54.208 align:middle
所以我们本身也是观察点

00:22:54.274 --> 00:22:55.309 align:middle
随后在第二部分

00:22:55.375 --> 00:22:58.345 align:middle
在数值变化时 采取一些行动

00:22:58.545 --> 00:23:00.480 align:middle
这里采取的是传统的KVO方法

00:22:58.545 --> 00:23:00.480 align:middle
这里采取的是传统的KVO方法

00:23:00.647 --> 00:23:02.649 align:middle
observeValueForKeyPath

00:23:02.716 --> 00:23:03.884 align:middle
首先需要检查

00:23:03.951 --> 00:23:07.087 align:middle
通过检查内容指示器
和关键路径

00:23:07.154 --> 00:23:09.556 align:middle
确保那就是我们感兴趣的
观察更新

00:23:10.057 --> 00:23:11.892 align:middle
在主线程中 再一次

00:23:11.959 --> 00:23:14.461 align:middle
因为更新将在非主线程中出现

00:23:14.528 --> 00:23:18.665 align:middle
我们将通过设置进度属性
更新UI进度视图

00:23:18.832 --> 00:23:23.370 align:middle
我们将通过使用它的
localizedDescription方法

00:23:23.437 --> 00:23:26.540 align:middle
充分利用自动局部描述的
NS Progress支持

00:23:28.842 --> 00:23:30.644 align:middle
让我们继续 并再次运行
看看它将如何工作

00:23:36.483 --> 00:23:38.485 align:middle
所以这次 当我访问意大利时

00:23:38.619 --> 00:23:41.522 align:middle
你可以看到在详细标签文本
底部已经更新

00:23:41.588 --> 00:23:45.359 align:middle
可以显示完成百分比
随后 一旦下载完成

00:23:45.425 --> 00:23:48.161 align:middle
UI进度视图将告诉用户

00:23:48.228 --> 00:23:49.263 align:middle
已经发生的变化

00:23:50.163 --> 00:23:52.566 align:middle
所以 再一次 我们并不着急
删掉这些内容

00:23:52.633 --> 00:23:54.568 align:middle
这样当我们再次返回
访问意大利时

00:23:54.835 --> 00:23:56.737 align:middle
你可以看到内容立马就显示了

00:23:57.171 --> 00:24:00.574 align:middle
因为这些内容已经存储在
On Demand Resources系统中

00:23:57.171 --> 00:24:00.574 align:middle
因为这些内容已经存储在
On Demand Resources系统中

00:24:02.009 --> 00:24:03.310 align:middle
现在回到幻灯片

00:24:11.251 --> 00:24:13.654 align:middle
关于展示中
进度报告部分的一些东西

00:24:14.121 --> 00:24:15.689 align:middle
所以 再一次 通过查看进度

00:24:15.756 --> 00:24:18.992 align:middle
你可以找到请求进度的信息

00:24:19.860 --> 00:24:23.197 align:middle
我们同样支持取消 暂停

00:24:23.263 --> 00:24:24.965 align:middle
重新开始请求
这些方法本身并不是请求

00:24:25.032 --> 00:24:27.401 align:middle
它们可在NSProgress中找到

00:24:29.536 --> 00:24:32.539 align:middle
现在 事实上在iOS 9
和 OS X 10.11中

00:24:32.606 --> 00:24:34.808 align:middle
Foundation中
NSProgress类

00:24:34.875 --> 00:24:36.643 align:middle
我们已经做了很多重大改进

00:24:37.077 --> 00:24:38.612 align:middle
想知道如何使用它们

00:24:38.812 --> 00:24:42.616 align:middle
如何大规模的将这类整合
到你的App

00:24:42.950 --> 00:24:43.917 align:middle
和其他地方

00:24:43.984 --> 00:24:46.687 align:middle
真的建议你
关注周五的演讲

00:24:46.753 --> 00:24:48.555 align:middle
《进度报告的最佳范例》

00:24:51.225 --> 00:24:53.360 align:middle
在内容还未准备就绪之前

00:24:53.627 --> 00:24:56.930 align:middle
beginAccessing方法
将继续运行并下载内容

00:24:57.364 --> 00:24:58.799 align:middle
然后 有时候你只想

00:24:58.866 --> 00:25:01.001 align:middle
使用磁盘中已经有的内容

00:24:58.866 --> 00:25:01.001 align:middle
使用磁盘中已经有的内容

00:25:01.068 --> 00:25:02.302 align:middle
不想再进行下载

00:25:02.669 --> 00:25:05.205 align:middle
你可以使用假定请求做到这点

00:25:05.906 --> 00:25:06.773 align:middle
方法如下

00:25:06.840 --> 00:25:10.010 align:middle
conditionallyBeginAccessing
ResourcesWithCompletionHandler

00:25:10.077 --> 00:25:10.911 align:middle
你可看到

00:25:11.178 --> 00:25:13.013 align:middle
这里的结尾有布尔参数

00:25:13.080 --> 00:25:14.781 align:middle
所以不管是是还是否

00:25:14.882 --> 00:25:17.150 align:middle
答案取决于内容可用还是不可用

00:25:18.018 --> 00:25:21.121 align:middle
所以根据状态机

00:25:21.355 --> 00:25:22.723 align:middle
我们从初始化开始

00:25:23.323 --> 00:25:25.325 align:middle
通过调用这个方法

00:25:25.392 --> 00:25:26.560 align:middle
进入假定请求状态

00:25:27.194 --> 00:25:29.663 align:middle
不管它是否可用
你都将得到回应

00:25:29.897 --> 00:25:32.165 align:middle
若可用 资料也将可用

00:25:32.232 --> 00:25:33.667 align:middle
就好像你已经调用了其他方法

00:25:33.734 --> 00:25:36.803 align:middle
所以 再一次 确认调用
endAccessingResources

00:25:36.870 --> 00:25:38.438 align:middle
或允许对象解除分配

00:25:38.872 --> 00:25:41.141 align:middle
若不可用
此时你可以做选择

00:25:41.208 --> 00:25:42.209 align:middle
你可以...

00:25:42.910 --> 00:25:43.744 align:middle
什么都不做

00:25:43.810 --> 00:25:46.847 align:middle
也可以调用
beginAccessingResources方法

00:25:46.914 --> 00:25:47.981 align:middle
进行下载

00:25:50.017 --> 00:25:54.955 align:middle
最后 我讲讲此类中
API两个优先权

00:25:55.122 --> 00:25:56.757 align:middle
第一个叫做加载优先权

00:25:57.090 --> 00:25:58.625 align:middle
这个是双重的

00:25:58.692 --> 00:26:02.162 align:middle
它为你的App中
未解决的请求排序

00:25:58.692 --> 00:26:02.162 align:middle
它为你的App中
未解决的请求排序

00:26:02.663 --> 00:26:04.064 align:middle
数值为从0到1

00:26:04.231 --> 00:26:06.867 align:middle
所以数值1指最高优先权

00:26:06.934 --> 00:26:08.602 align:middle
数值0指最低优先权

00:26:09.136 --> 00:26:10.804 align:middle
当我们处理这些数值时

00:26:10.904 --> 00:26:15.709 align:middle
它将提示系统哪个未解决的
请求应该优先处理

00:26:16.176 --> 00:26:19.112 align:middle
因为数值只在
你的app中进行比较

00:26:19.179 --> 00:26:21.515 align:middle
并未在系统中的App进行比较

00:26:21.615 --> 00:26:23.450 align:middle
你可利用这些数值

00:26:23.517 --> 00:26:26.053 align:middle
根据你的需要对请求进行排序

00:26:27.487 --> 00:26:29.423 align:middle
这里有个常量可以使用

00:26:29.489 --> 00:26:31.491 align:middle
它叫做紧急装载优先权

00:26:32.593 --> 00:26:34.761 align:middle
当用户只需等待下载完成
而无需做其他事时

00:26:34.828 --> 00:26:36.430 align:middle
就可以使用这个常量

00:26:36.697 --> 00:26:38.198 align:middle
随后我们会详细讲到这点

00:26:40.200 --> 00:26:42.636 align:middle
第二种优先权叫做保存优先权

00:26:43.136 --> 00:26:47.140 align:middle
这个方法指的是
在app中未使用的标签清除排序

00:26:47.207 --> 00:26:49.209 align:middle
这里并不需要特别的请求

00:26:49.276 --> 00:26:51.578 align:middle
这是它成为NSBundle
延伸功能的原因

00:26:51.879 --> 00:26:54.681 align:middle
由一个标签
或一组标签进行替代

00:26:55.082 --> 00:26:57.084 align:middle
数值范围从0到1

00:26:57.384 --> 00:26:59.586 align:middle
0数值表示最不需要保存

00:26:59.686 --> 00:27:01.388 align:middle
1数值表示最需要保存

00:26:59.686 --> 00:27:01.388 align:middle
1数值表示最需要保存

00:27:02.256 --> 00:27:05.125 align:middle
所以在碰到磁盘存储空间问题时

00:27:05.192 --> 00:27:07.461 align:middle
你可通过它告诉系统

00:27:07.861 --> 00:27:10.364 align:middle
哪些数值最需要保存

00:27:10.797 --> 00:27:13.634 align:middle
只在你自己的App中进行比较

00:27:13.700 --> 00:27:15.769 align:middle
而不是在系统的App中进行比较

00:27:17.104 --> 00:27:18.906 align:middle
以上就这些
有请史蒂芬上台

00:27:18.972 --> 00:27:21.341 align:middle
说说使用ODR的最佳范例

00:27:23.810 --> 00:27:24.645 align:middle
谢谢你 托尼

00:27:28.282 --> 00:27:31.485 align:middle
好的 现在我们对ODR
有了整体的了解

00:27:31.552 --> 00:27:33.820 align:middle
我们知道它是什么
并观看了如何使用它

00:27:34.254 --> 00:27:38.192 align:middle
现在来说说
我们如何建立最佳ODR app

00:27:38.825 --> 00:27:41.695 align:middle
现在开始对资料做标签之前

00:27:41.762 --> 00:27:44.798 align:middle
首先需要考虑你的app的反应

00:27:45.232 --> 00:27:48.368 align:middle
因为这将告诉你对资料做标签
需做到哪种程度

00:27:48.869 --> 00:27:51.605 align:middle
关于你可能如何使用ODR内容

00:27:51.672 --> 00:27:54.308 align:middle
这里我可以提供三种模式

00:27:55.142 --> 00:27:58.712 align:middle
第一种模式
这个就像托尼的iTravel app

00:27:59.046 --> 00:28:02.282 align:middle
我们无法预测用户将去哪里

00:27:59.046 --> 00:28:02.282 align:middle
我们无法预测用户将去哪里

00:28:02.716 --> 00:28:04.051 align:middle
这是随机访问

00:28:04.484 --> 00:28:05.986 align:middle
在随机访问app中

00:28:06.053 --> 00:28:09.590 align:middle
特别是资料比较大的时候

00:28:09.656 --> 00:28:12.759 align:middle
你想要的内容标记了很多资料

00:28:12.826 --> 00:28:14.328 align:middle
并逐步读取

00:28:14.394 --> 00:28:16.530 align:middle
所以一旦用户做出决定

00:28:16.830 --> 00:28:18.599 align:middle
他们立即就可以在UI中

00:28:18.665 --> 00:28:20.367 align:middle
看到那个决定的部分进度

00:28:21.435 --> 00:28:24.471 align:middle
第二种模式叫做有限预测

00:28:24.538 --> 00:28:27.875 align:middle
某种程度上来说
这就像开放式世界游戏

00:28:28.308 --> 00:28:32.012 align:middle
它可能是无穷种可能性

00:28:32.079 --> 00:28:35.082 align:middle
在具体时间点时
它只是有限的子集

00:28:35.148 --> 00:28:37.117 align:middle
再次 你要做的是

00:28:37.184 --> 00:28:40.454 align:middle
拥有许多标签
标记比少的内容

00:28:40.721 --> 00:28:42.222 align:middle
逐步读取

00:28:42.289 --> 00:28:45.359 align:middle
也需要准备好放弃那些

00:28:45.526 --> 00:28:48.262 align:middle
用户选择不看的内容

00:28:48.328 --> 00:28:52.399 align:middle
比如 就像游戏玩家
在世界范围移动

00:28:52.466 --> 00:28:54.468 align:middle
他们离开一些地方一样

00:28:54.535 --> 00:28:55.636 align:middle
你需停止使用索引资料

00:28:55.702 --> 00:28:58.672 align:middle
去掉
NSBundleResourceRequest对象

00:28:59.706 --> 00:29:02.843 align:middle
现在 第三种模式是
已经在我例子中使用的模式

00:28:59.706 --> 00:29:02.843 align:middle
现在 第三种模式是
已经在我例子中使用的模式

00:29:02.910 --> 00:29:04.111 align:middle
就是游戏中的等级

00:29:04.178 --> 00:29:06.280 align:middle
这是直线型进度式游戏

00:29:06.346 --> 00:29:08.081 align:middle
就像第一人称的射击游戏

00:29:08.448 --> 00:29:09.550 align:middle
在这个案例中

00:29:09.616 --> 00:29:11.752 align:middle
作为一名开发者

00:29:11.818 --> 00:29:15.522 align:middle
你最大的任务是
提早预估下一步需求

00:29:16.023 --> 00:29:17.591 align:middle
但是你非常肯定

00:29:17.658 --> 00:29:19.593 align:middle
所有的内容都是必要的

00:29:19.660 --> 00:29:21.595 align:middle
所以你将只开始加载那些

00:29:21.662 --> 00:29:26.567 align:middle
在一定合理时间内
可被加载的内容

00:29:26.633 --> 00:29:27.467 align:middle
好了

00:29:27.901 --> 00:29:29.169 align:middle
说到时间

00:29:29.236 --> 00:29:32.206 align:middle
这里有个插曲
讲到你如何使用ODR API

00:29:32.272 --> 00:29:34.041 align:middle
所以我们给自己一个时间线

00:29:34.107 --> 00:29:36.977 align:middle
即从app开始到退出

00:29:38.011 --> 00:29:40.180 align:middle
现在 设计合理的ODR App

00:29:40.247 --> 00:29:43.250 align:middle
应该可以很好的
提早预测需求资料

00:29:43.851 --> 00:29:45.285 align:middle
请记住 这是网络型app

00:29:45.352 --> 00:29:47.321 align:middle
它将必须从App Store

00:29:47.487 --> 00:29:49.456 align:middle
或我们刚检查过的其他地方下载

00:29:49.590 --> 00:29:50.691 align:middle
但这需要花些时间

00:29:51.291 --> 00:29:53.427 align:middle
因此 在需要使用资料的时候

00:29:53.560 --> 00:29:56.897 align:middle
且当调出
beginAccessing Resources

00:29:56.964 --> 00:29:58.532 align:middle
如果还未安装到设备上

00:29:58.899 --> 00:30:00.767 align:middle
那么会自动开始下载

00:29:58.899 --> 00:30:00.767 align:middle
那么会自动开始下载

00:30:01.969 --> 00:30:05.806 align:middle
当前 这是善用网络资源

00:30:05.873 --> 00:30:08.475 align:middle
和解决资料尚未准备就绪

00:30:08.542 --> 00:30:11.411 align:middle
就需要使用的最佳办法

00:30:12.012 --> 00:30:14.848 align:middle
而且 在这种情况下
你可以通过进度属性

00:30:14.982 --> 00:30:17.618 align:middle
和NS Bundle
Resource Request

00:30:17.684 --> 00:30:19.219 align:middle
加快托尼之前提到的进度UI

00:30:19.686 --> 00:30:22.689 align:middle
分享一下屏幕
同时让下载继续进行

00:30:23.056 --> 00:30:25.292 align:middle
这时候 已经完成下载了

00:30:25.592 --> 00:30:27.361 align:middle
资料已经准备就绪

00:30:27.427 --> 00:30:28.962 align:middle
你可以关闭下载界面

00:30:29.196 --> 00:30:31.064 align:middle
然后开始使用资料了

00:30:31.932 --> 00:30:33.767 align:middle
一旦资料使用完毕

00:30:33.834 --> 00:30:37.271 align:middle
你们绝对会想要调出
endAccessingResources

00:30:37.671 --> 00:30:41.275 align:middle
或者允许NS Bundle
Resource Request对象解除分配

00:30:41.441 --> 00:30:43.544 align:middle
以便让系统知道你已经使用完毕

00:30:44.011 --> 00:30:47.214 align:middle
另外 这不代表我们会关闭服务
并删除记录

00:30:47.281 --> 00:30:48.582 align:middle
我们只是在这里提醒大家而已

00:30:49.349 --> 00:30:52.119 align:middle
因此
这是需要清楚的基本时间线

00:30:52.186 --> 00:30:54.788 align:middle
并且你们还可以同时发出多个请求

00:30:55.389 --> 00:30:57.891 align:middle
只需要记得本部分的基本内容即可

00:30:58.659 --> 00:30:59.493 align:middle
好的

00:31:00.727 --> 00:31:01.562 align:middle
现在

00:31:01.628 --> 00:31:03.664 align:middle
我已经谈了ODR

00:31:03.730 --> 00:31:06.900 align:middle
如何通过改善其安装体验
而提高用户体验

00:31:07.768 --> 00:31:09.203 align:middle
因此 具体怎么完成呢？

00:31:09.269 --> 00:31:10.871 align:middle
我们需要大家的帮助

00:31:11.738 --> 00:31:12.840 align:middle
作为开发者

00:31:12.906 --> 00:31:14.975 align:middle
你们需要做的是考虑用户

00:31:15.042 --> 00:31:17.644 align:middle
在登录到app后所需要的资料

00:31:18.712 --> 00:31:21.248 align:middle
当你们了解是什么之后
比如游戏Level 1

00:31:21.415 --> 00:31:22.316 align:middle
已经准备就绪

00:31:22.683 --> 00:31:24.084 align:middle
然后你们需要设置资料标签

00:31:24.151 --> 00:31:28.555 align:middle
并放到Xcode的
初始安装标签UI

00:31:29.823 --> 00:31:31.959 align:middle
这会通知ODR系统去确认

00:31:32.025 --> 00:31:33.994 align:middle
所有资料的标签...

00:31:34.127 --> 00:31:35.295 align:middle
在app被...

00:31:36.129 --> 00:31:38.432 align:middle
完全安装好之前

00:31:38.498 --> 00:31:40.968 align:middle
可以被下载

00:31:41.034 --> 00:31:43.103 align:middle
这样 当显示完全安装好之后

00:31:43.170 --> 00:31:45.005 align:middle
用户点击标签后就准备就绪了

00:31:45.072 --> 00:31:46.306 align:middle
这时候准备开玩了

00:31:46.740 --> 00:31:49.776 align:middle
在App Store看到的
App的大小

00:31:50.077 --> 00:31:52.212 align:middle
是 .app大小

00:31:52.713 --> 00:31:56.450 align:middle
以及初始ODR内容的大小之和

00:31:56.683 --> 00:31:58.018 align:middle
因此 需要明白这点

00:31:58.085 --> 00:31:59.987 align:middle
此外 我们将在之后会谈谈这点

00:32:00.787 --> 00:32:03.457 align:middle
好的那么 现在我们可以谈谈

00:32:03.524 --> 00:32:05.292 align:middle
自动化安装app和ODR内容

00:32:05.359 --> 00:32:10.297 align:middle
但此时用户还未实际登录

00:32:10.430 --> 00:32:12.933 align:middle
因为你们也可以
自动设定这段时间

00:32:13.534 --> 00:32:16.503 align:middle
可以这么做
以确保游戏的Level 2

00:32:16.570 --> 00:32:19.439 align:middle
或者教程之类可以开始下载

00:32:19.506 --> 00:32:21.708 align:middle
也许某些用户想要看看教程

00:32:21.775 --> 00:32:22.809 align:middle
其他人不会想看

00:32:22.876 --> 00:32:26.446 align:middle
因此你应当确保app
即使没有教程

00:32:26.747 --> 00:32:28.182 align:middle
也能够实际运行教程

00:32:28.248 --> 00:32:29.516 align:middle
但是最好还是确保有教程

00:32:29.783 --> 00:32:30.884 align:middle
为了这么做

00:32:31.552 --> 00:32:34.788 align:middle
你们还可以使用Xcode
的资料标签UI

00:32:34.855 --> 00:32:38.592 align:middle
然后将标签放进
预取标签命令部分

00:32:38.992 --> 00:32:41.261 align:middle
在你放到该部分的命令顺序

00:32:41.328 --> 00:32:43.463 align:middle
是实际上下载这些标签的顺序

00:32:44.765 --> 00:32:45.599 align:middle
好的

00:32:46.867 --> 00:32:48.735 align:middle
现在谈谈缓存

00:32:48.802 --> 00:32:50.437 align:middle
我们之前提到缓存

00:32:50.504 --> 00:32:52.005 align:middle
而且还展示了系统是

00:32:52.406 --> 00:32:55.876 align:middle
如何为新等级腾出
Level 1的空间

00:32:56.710 --> 00:32:59.746 align:middle
首先 需要了解的是
我们会清理内容

00:32:59.813 --> 00:33:01.782 align:middle
但只在系统内存占用度
不高的情况进行

00:32:59.813 --> 00:33:01.782 align:middle
但只在系统内存占用度
不高的情况进行

00:33:02.583 --> 00:33:06.086 align:middle
另外 也只有ODR内容会被清理

00:33:07.020 --> 00:33:08.689 align:middle
当我们这么做的时候

00:33:08.856 --> 00:33:11.692 align:middle
这里有几个属性会发挥作用

00:33:11.758 --> 00:33:14.094 align:middle
通知我们是否要

00:33:14.494 --> 00:33:17.364 align:middle
删除哪个资料包

00:33:18.465 --> 00:33:19.499 align:middle
很明显

00:33:20.067 --> 00:33:22.336 align:middle
是删除上次使用的那个资料包

00:33:22.402 --> 00:33:23.303 align:middle
因此 如果...

00:33:23.670 --> 00:33:25.873 align:middle
玩游戏Level 1的时候是
上周周二

00:33:26.373 --> 00:33:30.244 align:middle
那么 很可能会在前一天
完成Level 1的时候就被删除

00:33:32.145 --> 00:33:35.215 align:middle
另外 正如托尼之提到的保留优先权

00:33:35.282 --> 00:33:37.518 align:middle
这指的是对标签设置
的优先级

00:33:37.985 --> 00:33:40.821 align:middle
因此 这是你自己的排序
我们也会加以考虑

00:33:42.589 --> 00:33:45.492 align:middle
最后 我们会考虑
app的运行状态

00:33:45.993 --> 00:33:48.662 align:middle
我们不会在资料包
正在使用的情况下

00:33:48.962 --> 00:33:51.131 align:middle
删除运行中的app的
任何资料包

00:33:53.934 --> 00:33:56.870 align:middle
现在有几种策略

00:33:57.137 --> 00:33:59.206 align:middle
用于保留ODR内容

00:33:59.907 --> 00:34:02.109 align:middle
其中之一是避免过度清理

00:33:59.907 --> 00:34:02.109 align:middle
其中之一是避免过度清理

00:34:02.543 --> 00:34:03.744 align:middle
什么意思呢？

00:34:03.810 --> 00:34:05.045 align:middle
我可以举个例子

00:34:05.379 --> 00:34:07.881 align:middle
比如说系统需要100 MB空间

00:34:08.681 --> 00:34:09.949 align:middle
那么系统在进行整机搜索

00:34:10.016 --> 00:34:11.618 align:middle
然而没有找到够大的空间

00:34:12.452 --> 00:34:14.955 align:middle
通过我们刚提及的属性

00:34:15.522 --> 00:34:17.224 align:middle
系统会定位到你的资料包

00:34:17.291 --> 00:34:19.659 align:middle
容量为512 MB

00:34:20.561 --> 00:34:22.429 align:middle
我需要清理资料包

00:34:22.496 --> 00:34:23.797 align:middle
以符合空间要求

00:34:24.031 --> 00:34:27.266 align:middle
因此 我们需要
过度清理412MB

00:34:27.768 --> 00:34:30.337 align:middle
所以你的资料包体积
最好是小一点

00:34:30.603 --> 00:34:33.040 align:middle
正如我刚提及的 这也有好处

00:34:33.106 --> 00:34:35.909 align:middle
因为想要快点下载好
而且享用内容

00:34:36.275 --> 00:34:38.078 align:middle
因此体积越小就越好

00:34:38.212 --> 00:34:40.781 align:middle
但是体积越小就越不容易被过度清理

00:34:42.748 --> 00:34:43.583 align:middle
好的

00:34:44.351 --> 00:34:46.553 align:middle
另一件你们可能想做的是

00:34:46.887 --> 00:34:49.790 align:middle
对任何事设置1.0的优先权

00:34:50.324 --> 00:34:51.925 align:middle
但这么做并无卵用

00:34:52.259 --> 00:34:55.195 align:middle
这么做只会让系统认为

00:34:55.262 --> 00:34:57.397 align:middle
更多的资料重要性是相等的

00:34:57.531 --> 00:35:00.300 align:middle
特别是当系统在对app
进行清理的情况下

00:34:57.531 --> 00:35:00.300 align:middle
特别是当系统在对app
进行清理的情况下

00:35:00.601 --> 00:35:03.437 align:middle
因此 需要谨慎使用优先权设置

00:35:06.306 --> 00:35:08.108 align:middle
最后请再次确认

00:35:08.175 --> 00:35:10.143 align:middle
因为当你做完标注我们会看

00:35:10.410 --> 00:35:14.581 align:middle
上次endAccessingResources
的使用日期

00:35:14.915 --> 00:35:18.051 align:middle
确认允许NS Bundle
Resource Request对象

00:35:18.185 --> 00:35:19.520 align:middle
尽快解除分配

00:35:19.820 --> 00:35:22.389 align:middle
这会让系统知道
你将如何使用该资料

00:35:22.456 --> 00:35:24.258 align:middle
这样系统会给出最佳决策

00:35:26.293 --> 00:35:28.195 align:middle
好的
现在 我想开始谈谈

00:35:28.262 --> 00:35:30.330 align:middle
性能方面的事情

00:35:31.498 --> 00:35:34.568 align:middle
其中之一是我们在
本次会议想做的事

00:35:34.635 --> 00:35:38.939 align:middle
是鼓励大家
提前在后台下载内容

00:35:40.040 --> 00:35:42.543 align:middle
但是我们不想要让大家

00:35:43.010 --> 00:35:46.313 align:middle
浪费更太多的系统资源

00:35:46.613 --> 00:35:48.081 align:middle
超过app所能容纳的资源

00:35:48.582 --> 00:35:51.785 align:middle
因此 我们平衡了
下载速度 资源

00:35:51.852 --> 00:35:53.086 align:middle
CPU和其他属性

00:35:53.153 --> 00:35:55.022 align:middle
这样我们只有在下载
和使用资料包的时候

00:35:55.088 --> 00:35:56.456 align:middle
才会消耗系统资源

00:35:57.224 --> 00:35:58.058 align:middle
这是预设情况

00:35:58.492 --> 00:36:01.762 align:middle
但如果有需要
或者想要自行进行管理

00:35:58.492 --> 00:36:01.762 align:middle
但如果有需要
或者想要自行进行管理

00:36:01.828 --> 00:36:03.797 align:middle
或者想要完全手动操作

00:36:03.864 --> 00:36:05.866 align:middle
那么你可以在这里设置紧急优先

00:36:06.400 --> 00:36:08.435 align:middle
系统会忽略平衡设置

00:36:08.502 --> 00:36:11.038 align:middle
我们将会以最快速度下载内容

00:36:11.638 --> 00:36:15.542 align:middle
正如托尼提到的
当你提供载入画面时

00:36:15.976 --> 00:36:17.177 align:middle
那时候就是设置的好时机

00:36:17.611 --> 00:36:20.948 align:middle
但实际上你的App
可能与CPU不兼容

00:36:21.014 --> 00:36:23.283 align:middle
与我们在系统这样操作情况一样

00:36:24.451 --> 00:36:25.586 align:middle
因此 这完全取决于你

00:36:27.821 --> 00:36:29.022 align:middle
而且

00:36:29.223 --> 00:36:31.191 align:middle
我们应该讨论性能测试

00:36:32.392 --> 00:36:35.362 align:middle
你需要为ODR的App做
现世测试

00:36:35.629 --> 00:36:38.165 align:middle
ODR App是一个
基于网络的App

00:36:38.832 --> 00:36:41.001 align:middle
因此当你使用USB将你的设备

00:36:41.068 --> 00:36:43.904 align:middle
连接到你的MacBook Pro

00:36:43.971 --> 00:36:44.972 align:middle
并运行Xcode

00:36:45.038 --> 00:36:47.975 align:middle
那不是真实的场景

00:36:48.041 --> 00:36:49.142 align:middle
真是太快了

00:36:49.910 --> 00:36:51.144 align:middle
所以你要做的是

00:36:51.445 --> 00:36:56.216 align:middle
使用TestFlight或Xcode
服务器来测试你的App

00:36:57.518 --> 00:37:01.989 align:middle
然后使用Developer Tools
Network Link Conditioner

00:36:57.518 --> 00:37:01.989 align:middle
然后使用Developer Tools
Network Link Conditioner

00:37:02.689 --> 00:37:05.259 align:middle
来测试各种网络条件

00:37:06.059 --> 00:37:08.362 align:middle
你的App在ODR内容下载时

00:37:08.529 --> 00:37:10.564 align:middle
可能会出问题

00:37:11.064 --> 00:37:12.999 align:middle
事实上
我建议你在任何网络App上

00:37:13.066 --> 00:37:14.868 align:middle
使用这个工具

00:37:14.935 --> 00:37:15.769 align:middle
真的很好用

00:37:15.836 --> 00:37:17.271 align:middle
如果之前你还没有使用过它

00:37:17.337 --> 00:37:19.439 align:middle
那我现在做个简短说明

00:37:20.140 --> 00:37:21.675 align:middle
当你把你的...

00:37:22.109 --> 00:37:23.243 align:middle
设备通过USB连接到

00:37:23.310 --> 00:37:25.279 align:middle
MacBook Pro上
运行Xcode时

00:37:25.546 --> 00:37:27.314 align:middle
然后设置设备时候会看到这个条目

00:37:27.381 --> 00:37:29.583 align:middle
一个开发者条目

00:37:29.883 --> 00:37:32.586 align:middle
你点击后会看到大量的

00:37:32.653 --> 00:37:38.825 align:middle
开发者设置
您可以使用日志等等

00:37:38.892 --> 00:37:41.762 align:middle
中间有Network
Link Conditioner

00:37:42.162 --> 00:37:43.530 align:middle
点击你看到的选项

00:37:43.897 --> 00:37:45.165 align:middle
您可以看到

00:37:45.232 --> 00:37:47.501 align:middle
你可以用来造成App断网时的

00:37:47.568 --> 00:37:51.839 align:middle
各种情况的... 各选择

00:37:52.239 --> 00:37:56.009 align:middle
要用它 启用Network
Link Conditioner

00:37:56.210 --> 00:37:59.012 align:middle
然后决定你想要创建
什么类型的情况

00:37:59.413 --> 00:38:02.015 align:middle
也许你想模仿100%的无网络状态

00:37:59.413 --> 00:38:02.015 align:middle
也许你想模仿100%的无网络状态

00:38:02.316 --> 00:38:03.851 align:middle
或非常缓慢的网络

00:38:04.384 --> 00:38:07.154 align:middle
或者高延时DNS查找

00:38:07.654 --> 00:38:10.591 align:middle
或者你只是想重创
非常糟糕的网络

00:38:11.258 --> 00:38:15.696 align:middle
这便是使用ODR App的最佳工具

00:38:17.364 --> 00:38:18.198 align:middle
好的

00:38:18.699 --> 00:38:20.200 align:middle
说到网络问题

00:38:20.267 --> 00:38:24.605 align:middle
你可能会遇到几个网络错误

00:38:25.005 --> 00:38:26.173 align:middle
其中一个

00:38:26.240 --> 00:38:27.741 align:middle
没有网络

00:38:27.975 --> 00:38:31.078 align:middle
如果你的App需要ODR内容
却没有网络

00:38:31.211 --> 00:38:33.714 align:middle
那么你需要准备好处理这种情况

00:38:35.048 --> 00:38:38.719 align:middle
您可能遇到的另一个问题
是资源不可用

00:38:38.785 --> 00:38:41.488 align:middle
这基本上意味着
我们认为ODR的内容

00:38:41.555 --> 00:38:43.557 align:middle
在一个特定的位置
然而不是那么回事儿

00:38:44.091 --> 00:38:47.227 align:middle
一般的原因 例如在公司内部

00:38:47.294 --> 00:38:50.130 align:middle
建立自己的服务器并有人管理

00:38:50.197 --> 00:38:52.366 align:middle
移动服务器文件等

00:38:52.533 --> 00:38:55.702 align:middle
但是还没准备好
让用户使用App

00:38:56.170 --> 00:38:58.172 align:middle
所以要随时准备应对错误发生

00:38:59.907 --> 00:39:02.442 align:middle
另一类错误可能会遇到

00:38:59.907 --> 00:39:02.442 align:middle
另一类错误可能会遇到

00:39:03.510 --> 00:39:05.012 align:middle
就是存储空间有关的问题

00:39:06.280 --> 00:39:07.814 align:middle
所以ODR在任何时候

00:39:07.881 --> 00:39:12.786 align:middle
将允许你有最大的2G的应用空间

00:39:13.453 --> 00:39:15.489 align:middle
这意味着你的App
正在运行的时候

00:39:15.689 --> 00:39:19.126 align:middle
你已经调用标签2G的

00:39:19.459 --> 00:39:22.396 align:middle
beginAccessingResources

00:39:22.696 --> 00:39:25.532 align:middle
用完后却没调用
endAccessingResources

00:39:25.599 --> 00:39:28.702 align:middle
你不允许NS Bundle
Resource Request

00:39:28.769 --> 00:39:30.304 align:middle
进行终止处理

00:39:30.604 --> 00:39:32.339 align:middle
所以占用2G空间

00:39:32.673 --> 00:39:34.241 align:middle
然后你又去启动另一个请求

00:39:34.441 --> 00:39:36.944 align:middle
你会再次得到一个请求错误

00:39:37.010 --> 00:39:37.845 align:middle
回叫反馈

00:39:38.312 --> 00:39:39.646 align:middle
所以要注意

00:39:41.348 --> 00:39:44.718 align:middle
当然我们可能在
本地存储在设备上

00:39:44.785 --> 00:39:46.753 align:middle
遇到空间不足的情况

00:39:46.820 --> 00:39:48.188 align:middle
你就会收到通知

00:39:48.822 --> 00:39:51.158 align:middle
这可能是因为你下载太多

00:39:51.225 --> 00:39:55.128 align:middle
或者你发出该下载请求太久

00:39:55.762 --> 00:39:57.497 align:middle
所以还是需要随时准备
处理这些问题

00:39:57.564 --> 00:39:59.333 align:middle
这时候你可以采取一些处理步骤

00:39:59.399 --> 00:40:00.234 align:middle
你可以停止任何

00:39:59.399 --> 00:40:00.234 align:middle
你可以停止任何

00:40:00.300 --> 00:40:03.504 align:middle
不再需要的ODR内容的
Accessing Resources

00:40:04.671 --> 00:40:06.840 align:middle
另外 你可以看看本地设备上
储存的是什么资料

00:40:06.907 --> 00:40:08.642 align:middle
也许是一些缓冲数据

00:40:08.709 --> 00:40:10.444 align:middle
或者一些已不在需要用到的文件

00:40:10.878 --> 00:40:12.946 align:middle
你可以清理一下并进行删除

00:40:15.949 --> 00:40:17.885 align:middle
那么 现在我们来谈谈蜂窝数据

00:40:18.852 --> 00:40:21.588 align:middle
再次说明ODR App
是一款网络型应用

00:40:22.189 --> 00:40:25.025 align:middle
因此需要使用到蜂窝数据开关

00:40:25.893 --> 00:40:28.028 align:middle
用于控制其他App的网络连接

00:40:28.262 --> 00:40:30.097 align:middle
因此 如果关闭开关

00:40:30.163 --> 00:40:32.165 align:middle
那么就不能获取到ODR文件

00:40:33.467 --> 00:40:36.737 align:middle
如果开启开关
并且你正在下载ODR内容

00:40:37.171 --> 00:40:39.773 align:middle
那么通过蜂窝数据下载的任何数据

00:40:39.940 --> 00:40:42.843 align:middle
将算是该App产生网络数据

00:40:43.577 --> 00:40:45.812 align:middle
因此 我们鼓励大家一定确保

00:40:45.879 --> 00:40:48.415 align:middle
什么是所需的 什么是不再需要的

00:40:49.016 --> 00:40:50.884 align:middle
我们不希望用户
产生高额的网络费用

00:40:53.153 --> 00:40:54.021 align:middle
最后

00:40:54.421 --> 00:40:56.123 align:middle
100MB的蜂窝下载限制

00:40:56.190 --> 00:40:58.292 align:middle
仍适用于ODR App

00:40:58.926 --> 00:41:01.395 align:middle
因此 要确认.app本身

00:40:58.926 --> 00:41:01.395 align:middle
因此 要确认.app本身

00:41:01.461 --> 00:41:02.930 align:middle
和初始ODR的数据

00:41:02.996 --> 00:41:05.666 align:middle
是否超过App Store的
App体积限制

00:41:06.033 --> 00:41:08.135 align:middle
如果超过100 MB

00:41:08.335 --> 00:41:10.704 align:middle
那么你的App不会
通过蜂窝数据下载

00:41:10.771 --> 00:41:12.506 align:middle
正如一般的App
超过100 MB的话

00:41:12.573 --> 00:41:14.174 align:middle
就不会通过蜂窝数据下载一样

00:41:15.209 --> 00:41:16.043 align:middle
因此

00:41:16.210 --> 00:41:18.645 align:middle
需要注意App的大小

00:41:20.914 --> 00:41:24.017 align:middle
最后 正如前面所说

00:41:24.084 --> 00:41:26.687 align:middle
你们还需要注意一些
重要的统计数据

00:41:27.888 --> 00:41:29.022 align:middle
首先

00:41:29.556 --> 00:41:32.025 align:middle
虽然App Store现在可以储存

00:41:32.492 --> 00:41:35.162 align:middle
超过20G的ODR App

00:41:35.429 --> 00:41:37.030 align:middle
但是对于.app而言...

00:41:37.965 --> 00:41:39.833 align:middle
只有最高2g的空间

00:41:39.900 --> 00:41:41.335 align:middle
那么 你的
.app本身如何呢？

00:41:41.401 --> 00:41:43.504 align:middle
请记得
当我们分解.app中的资料时

00:41:43.570 --> 00:41:45.472 align:middle
我们分解的资料包
那么.app本身呢？

00:41:45.572 --> 00:41:48.008 align:middle
.app最高可以有2G

00:41:48.275 --> 00:41:50.878 align:middle
剩下的ODR内容可以有20G

00:41:52.813 --> 00:41:58.018 align:middle
另外 初始ODR和预取ODR内容
最高也是2G

00:41:58.085 --> 00:42:00.387 align:middle
该内容是我们在
Xcode的UI中设置的

00:41:58.085 --> 00:42:00.387 align:middle
该内容是我们在
Xcode的UI中设置的

00:42:01.121 --> 00:42:04.758 align:middle
用于在App安装过程中
和后续过程中下载数据

00:42:04.992 --> 00:42:06.593 align:middle
你最高可以有2GB

00:42:06.827 --> 00:42:08.629 align:middle
合起来 2GB

00:42:10.531 --> 00:42:12.399 align:middle
正如我刚刚所说

00:42:12.466 --> 00:42:15.035 align:middle
只能在同一时间使用最高2G

00:42:16.837 --> 00:42:18.705 align:middle
最后 给定的资料包

00:42:19.039 --> 00:42:21.341 align:middle
最高可以有512MB

00:42:22.743 --> 00:42:25.379 align:middle
因此 如果使用一个标签
标记一堆资料

00:42:25.546 --> 00:42:29.716 align:middle
且提及超过512M
那么Xcode将发出警告

00:42:29.783 --> 00:42:33.320 align:middle
但是Xcode会允许你继续
开发App或者游戏

00:42:33.754 --> 00:42:36.623 align:middle
但是当你提交到
App Store之时

00:42:36.924 --> 00:42:39.560 align:middle
会收到提交失败的错误信息
并解释原因

00:42:41.395 --> 00:42:44.531 align:middle
好的 总结一下
On Demand Resources

00:42:44.598 --> 00:42:47.034 align:middle
是一款动态加载内容系统

00:42:47.835 --> 00:42:49.369 align:middle
服务器在App Store之中

00:42:50.137 --> 00:42:51.438 align:middle
这样可以允许app...

00:42:51.672 --> 00:42:55.242 align:middle
在安装期间自动和在有要求提出下
下载其内容

00:42:56.210 --> 00:42:58.445 align:middle
你可以对下载内容设置优先级

00:42:59.746 --> 00:43:01.181 align:middle
我们有了智能缓冲机制

00:42:59.746 --> 00:43:01.181 align:middle
我们有了智能缓冲机制

00:43:01.248 --> 00:43:06.553 align:middle
因此当我们等级提升后
会为后面的级别腾出空间

00:43:07.387 --> 00:43:09.489 align:middle
在App Store有
20G的空间供你使用

00:43:10.991 --> 00:43:14.461 align:middle
因此 如果想知道更多信息
我们有关于ODR一份新文件

00:43:15.128 --> 00:43:16.296 align:middle
还有简单的代码

00:43:17.030 --> 00:43:19.633 align:middle
以及开发者论坛可为你答疑解惑

00:43:20.367 --> 00:43:21.468 align:middle
如果你仍有疑问

00:43:21.535 --> 00:43:24.137 align:middle
你可以联系我们的
App Frameworks专员

00:43:24.972 --> 00:43:26.740 align:middle
如果你错过了

00:43:26.940 --> 00:43:30.611 align:middle
关于ODR大会等其他技术的大会

00:43:31.144 --> 00:43:35.249 align:middle
你可以到开发者网站去观看视频

00:43:35.883 --> 00:43:36.717 align:middle
接下来

00:43:37.050 --> 00:43:40.754 align:middle
会有一场托尼在星期五所说的
关于ODR进程

00:43:41.788 --> 00:43:45.726 align:middle
和实验的大会
时间是明天11点到1点30

00:43:45.993 --> 00:43:49.329 align:middle
托尼和我以及
ODR工程组将出席会议

00:43:49.396 --> 00:43:51.064 align:middle
回答你们的任何疑问

00:43:51.131 --> 00:43:52.900 align:middle
帮助你们开始使用ODR内容

00:43:53.800 --> 00:43:55.769 align:middle
并听取大家的建议

00:43:56.670 --> 00:43:57.504 align:middle
非常感谢
