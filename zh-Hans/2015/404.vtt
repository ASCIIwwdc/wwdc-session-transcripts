WEBVTT

00:00:20.754 --> 00:00:23.524 align:middle
Xcode的app切割

00:00:24.191 --> 00:00:26.460 align:middle
早上好 我是安德斯

00:00:26.793 --> 00:00:30.531 align:middle
欢迎你们来参加404会议
Xcode的app切割

00:00:32.533 --> 00:00:35.602 align:middle
APP切割在这个舞台上已经多次提及

00:00:35.769 --> 00:00:40.107 align:middle
但从你们昨天
提出的问题和问题数量看来

00:00:40.174 --> 00:00:41.842 align:middle
很多人深感兴趣并且仍有疑问

00:00:42.509 --> 00:00:45.379 align:middle
所以在这个会议上我们会讲的更详细些

00:00:45.946 --> 00:00:48.081 align:middle
尤其是关于

00:00:48.148 --> 00:00:52.319 align:middle
当今
APP切割如何影响APP传播途径

00:00:52.553 --> 00:00:54.788 align:middle
我们会看看其工作原理以及改善

00:00:56.123 --> 00:00:57.090 align:middle
我们会讨论

00:00:57.157 --> 00:01:01.161 align:middle
如何进行高效的APP切割

00:00:57.157 --> 00:01:01.161 align:middle
如何进行高效的APP切割

00:01:01.628 --> 00:01:03.697 align:middle
减少内存占用率

00:01:05.632 --> 00:01:06.667 align:middle
然后我们要讨论

00:01:06.733 --> 00:01:08.135 align:middle
这对你工作流程的意义

00:01:08.302 --> 00:01:11.772 align:middle
当你在开发和测试应用以及
提交到App Store等过程中

00:01:13.941 --> 00:01:15.442 align:middle
现在我们快速浏览一下

00:01:15.509 --> 00:01:17.044 align:middle
当前的APP是如何传播的

00:01:17.744 --> 00:01:20.314 align:middle
你会使用
Xcode开发iOS系统app

00:01:21.281 --> 00:01:23.951 align:middle
然后测试并提交应用商店

00:01:25.252 --> 00:01:26.186 align:middle
当你提交时

00:01:26.253 --> 00:01:30.157 align:middle
App会被标记上开发者证书

00:01:31.024 --> 00:01:35.229 align:middle
在经过检验后
App Store会重新证书标记

00:01:35.562 --> 00:01:37.531 align:middle
然后上架以供下载

00:01:40.234 --> 00:01:43.604 align:middle
然后有一台设备下载了你的App

00:01:43.670 --> 00:01:47.541 align:middle
这样设备就获得了你上传的的App

00:01:47.875 --> 00:01:49.409 align:middle
现在我们来看看里面的内容

00:01:50.644 --> 00:01:52.579 align:middle
首先 这是你的执行代码

00:01:53.180 --> 00:01:56.383 align:middle
这里有很多资源
几乎所有的东西都罗列在内

00:01:58.218 --> 00:02:01.221 align:middle
有些App代码很繁重 很多

00:01:58.218 --> 00:02:01.221 align:middle
有些App代码很繁重 很多

00:02:01.288 --> 00:02:02.923 align:middle
资源也比较少

00:02:03.423 --> 00:02:06.226 align:middle
有些则正好相反 媒体文件较多

00:02:06.293 --> 00:02:08.529 align:middle
大部分是资源

00:02:09.596 --> 00:02:11.598 align:middle
我们举一个例子看一看

00:02:14.067 --> 00:02:19.373 align:middle
现在代码基本上
有两种版本64位或32位

00:02:19.439 --> 00:02:21.508 align:middle
实际上 还可能是RMV7

00:02:21.675 --> 00:02:24.478 align:middle
也包括NRV64切片

00:02:24.745 --> 00:02:29.416 align:middle
为了在
Apple硬件上运作良好RMV7

00:02:31.485 --> 00:02:34.021 align:middle
当然 资源中如果有图像的话

00:02:34.087 --> 00:02:38.625 align:middle
你会使用
1X 2X 3X或Retina

00:02:38.859 --> 00:02:41.361 align:middle
以使图像在各类设备上运行良好

00:02:44.198 --> 00:02:46.300 align:middle
你也许会想对图像进行一部分区分

00:02:46.466 --> 00:02:48.468 align:middle
分为适用iPhone的

00:02:48.669 --> 00:02:50.003 align:middle
和适用iPad的

00:02:52.105 --> 00:02:56.543 align:middle
如果是
游戏app或者是3D图像型APP

00:02:56.910 --> 00:03:00.714 align:middle
那么1X和2X在处理文本压缩和

00:02:56.910 --> 00:03:00.714 align:middle
那么1X和2X在处理文本压缩和

00:03:00.781 --> 00:03:04.451 align:middle
文字模块方面并无太大意义

00:03:06.286 --> 00:03:09.957 align:middle
事实上 如果想利用
OpenGL AS和Metal语言

00:03:10.023 --> 00:03:12.759 align:middle
那么可能需要不同类型的资源纹理

00:03:12.960 --> 00:03:14.695 align:middle
而且还进行进一步的区分

00:03:14.761 --> 00:03:16.496 align:middle
优质和劣质文件

00:03:16.630 --> 00:03:20.300 align:middle
这样都能让设备在
不同内存大小上良好地运行

00:03:20.367 --> 00:03:24.438 align:middle
在任何设备上运行
取决于内存大小的图像清晰度

00:03:25.506 --> 00:03:26.907 align:middle
可能你还有声频资料

00:03:27.307 --> 00:03:29.710 align:middle
所以你还可能需要根据比特率进行区分

00:03:31.411 --> 00:03:35.482 align:middle
当然还有其他数据 像是游戏等级

00:03:35.782 --> 00:03:38.452 align:middle
又或者你的app需要认证文件

00:03:38.519 --> 00:03:40.554 align:middle
可能有些模板及其他一些信息

00:03:40.988 --> 00:03:45.259 align:middle
无法让设备进行区分
所有设备上都可能发生这种事

00:03:47.027 --> 00:03:49.596 align:middle
实际上
现在很多App都有所有类型的数据

00:03:49.930 --> 00:03:54.301 align:middle
所以你可能要费力进行归类

00:03:54.368 --> 00:03:57.137 align:middle
做好备注

00:03:57.304 --> 00:03:59.640 align:middle
这样相应资料才能安装在相应的设备上

00:04:01.008 --> 00:04:04.311 align:middle
这再好不过
这实际上就是APP切割的优势所在

00:04:05.145 --> 00:04:06.747 align:middle
如果你有一个iPad Mini

00:04:07.714 --> 00:04:11.018 align:middle
当它运行的时候 会运行RMV7切割

00:04:11.285 --> 00:04:13.654 align:middle
iPad等设备也是如此

00:04:14.688 --> 00:04:17.457 align:middle
另外APP切割所做的就是

00:04:17.524 --> 00:04:20.527 align:middle
在运行时决定加载资料

00:04:20.928 --> 00:04:22.296 align:middle
放到Store的资料

00:04:22.896 --> 00:04:25.666 align:middle
设备上的内容就是保存到设备上

00:04:26.033 --> 00:04:30.470 align:middle
始终保存在设备上
虽然不会在iPad1上下载

00:04:30.537 --> 00:04:34.942 align:middle
所以RM 64切割
无法在ipad Mini上使用

00:04:35.542 --> 00:04:38.345 align:middle
那么
为什么要全部上传到Store中呢？

00:04:40.247 --> 00:04:41.982 align:middle
在App Store上

00:04:42.416 --> 00:04:45.953 align:middle
我们将为ipad
Mini预构建一个定制版本

00:04:47.688 --> 00:04:50.657 align:middle
iPhone 6+也是如此

00:04:50.724 --> 00:04:53.927 align:middle
这时候 我们使用3X art
work RM 64等

00:04:54.428 --> 00:04:55.362 align:middle
此类的工具

00:04:55.796 --> 00:04:57.264 align:middle
值得注意的是

00:04:57.331 --> 00:05:02.903 align:middle
你仍会上传包括各种原图变体

00:04:57.331 --> 00:05:02.903 align:middle
你仍会上传包括各种原图变体

00:05:02.970 --> 00:05:05.439 align:middle
和其他资源的通用APP

00:05:05.772 --> 00:05:08.609 align:middle
于是在App Store里

00:05:08.675 --> 00:05:09.977 align:middle
切割就会发生

00:05:11.445 --> 00:05:14.147 align:middle
实际上 App Store的作用是

00:05:14.214 --> 00:05:18.752 align:middle
查看你的App能够支持的不同设备
即使不同设备特性

00:05:19.253 --> 00:05:21.788 align:middle
然后再查看App中的实际内容

00:05:21.889 --> 00:05:25.692 align:middle
以及你如何
使用1X 2X等工具进行标注

00:05:25.759 --> 00:05:30.163 align:middle
然后Store
会预制并分离被下载的IPA

00:05:30.230 --> 00:05:33.267 align:middle
我们来看一个已经看过的例子

00:05:33.500 --> 00:05:36.570 align:middle
这是个演示箱 曾在美国展示过

00:05:37.938 --> 00:05:39.673 align:middle
在这个例子中 我们有一个App

00:05:40.440 --> 00:05:42.309 align:middle
74兆字节的通用APP

00:05:42.743 --> 00:05:46.513 align:middle
适用于所有架构和设备

00:05:47.214 --> 00:05:50.717 align:middle
通过切割 我们得到16至29兆字节

00:05:51.084 --> 00:05:55.789 align:middle
平均在22兆字节的文件

00:05:56.156 --> 00:05:58.625 align:middle
我们在这款App上运行切割

00:05:58.892 --> 00:06:00.861 align:middle
实际上 其中产生了19种变量

00:05:58.892 --> 00:06:00.861 align:middle
实际上 其中产生了19种变量

00:06:00.928 --> 00:06:02.963 align:middle
包括不同的特性组合

00:06:03.330 --> 00:06:07.634 align:middle
这一些都在后台自动进行

00:06:07.701 --> 00:06:10.771 align:middle
而你只需对app内容进行标注即可

00:06:12.573 --> 00:06:14.408 align:middle
这是第一级保存 实在酷

00:06:14.675 --> 00:06:16.410 align:middle
但是 有改善的空间吗？

00:06:16.476 --> 00:06:18.245 align:middle
当然了 有

00:06:18.946 --> 00:06:23.517 align:middle
设备上有些资料是我们一直使用到的

00:06:23.584 --> 00:06:24.952 align:middle
首先 代码

00:06:25.352 --> 00:06:29.489 align:middle
那里可能会有一些原图比如故事板
当你启动你的应用程序

00:06:30.090 --> 00:06:32.693 align:middle
或者将原图添加到主菜单

00:06:32.759 --> 00:06:34.428 align:middle
让我们假设
你需要不断使用这些原图

00:06:35.729 --> 00:06:38.198 align:middle
然后还有其它这些东西

00:06:38.265 --> 00:06:41.502 align:middle
这个应用程序之后会需要用到
但现在不需要用到

00:06:41.568 --> 00:06:45.506 align:middle
你之前听过的一个典型例子
比如游戏的第19级

00:06:46.106 --> 00:06:49.676 align:middle
正在玩游戏第一级的用户
还不需要19级的资料

00:06:50.544 --> 00:06:51.945 align:middle
同样地 还有其它例子

00:06:52.012 --> 00:06:53.747 align:middle
如果App是文件类应用

00:06:53.814 --> 00:06:55.482 align:middle
那么媒体模板就会比较丰富

00:06:55.816 --> 00:06:58.585 align:middle
你可能会想把这些推向市场

00:06:58.785 --> 00:07:02.422 align:middle
为了提供丰富的体验
你可能要有很多的模板

00:06:58.785 --> 00:07:02.422 align:middle
为了提供丰富的体验
你可能要有很多的模板

00:07:02.589 --> 00:07:05.826 align:middle
但是它们可能会占用很多空间
你可能会根据需要进行下载

00:07:06.560 --> 00:07:09.496 align:middle
对于音频工具也是这样的或者此类的

00:07:11.265 --> 00:07:13.467 align:middle
很好的示范例子是

00:07:13.534 --> 00:07:16.069 align:middle
许多用户看过一次就不再想让文件

00:07:16.136 --> 00:07:17.371 align:middle
占用设备的空间

00:07:18.739 --> 00:07:22.009 align:middle
如果我们看看我们以前讨论过的

00:07:22.342 --> 00:07:24.478 align:middle
应用切割其实应用已经进行简化了

00:07:24.545 --> 00:07:26.246 align:middle
因而只剩下一个结构

00:07:26.313 --> 00:07:31.785 align:middle
以及一种资源类型的质量变体

00:07:33.820 --> 00:07:37.090 align:middle
下一等级划分 我们可以做的只有

00:07:37.157 --> 00:07:41.728 align:middle
在了解应用程序的特定区域后才能执行

00:07:41.862 --> 00:07:44.531 align:middle
就是基于给定的时间所需要的资料

00:07:44.731 --> 00:07:46.700 align:middle
因为这些是基于你的代码逻辑

00:07:47.434 --> 00:07:51.405 align:middle
因此在这个例子中我们有图像

00:07:51.705 --> 00:07:53.607 align:middle
Metal着色器诸如此类的

00:07:54.007 --> 00:07:56.043 align:middle
我们可以把这些分为共享的

00:07:56.310 --> 00:07:59.446 align:middle
以及归入到
应用程序本身时刻所必须的一类

00:07:59.880 --> 00:08:02.850 align:middle
我们可以按需选择

00:07:59.880 --> 00:08:02.850 align:middle
我们可以按需选择

00:08:03.951 --> 00:08:05.319 align:middle
通过划分

00:08:06.386 --> 00:08:09.156 align:middle
实际上你就可以减小

00:08:09.223 --> 00:08:12.259 align:middle
应用程序占用的基础空间
这样就可以保存更多文件

00:08:13.427 --> 00:08:17.264 align:middle
在这种特定的情况下
使用Xcode建立的

00:08:17.331 --> 00:08:20.634 align:middle
标记资源包就会被清除

00:08:20.801 --> 00:08:23.904 align:middle
保存到App Store中的IPA

00:08:24.972 --> 00:08:27.007 align:middle
你可以根据需要进行下载

00:08:27.608 --> 00:08:29.409 align:middle
你可以指定其中的一部分

00:08:29.476 --> 00:08:32.078 align:middle
作为初始下载 当用户下载展示的

00:08:32.145 --> 00:08:34.347 align:middle
应用程序并在进度条达到百分之百之后

00:08:34.982 --> 00:08:37.251 align:middle
应用程序就准备就绪了

00:08:37.351 --> 00:08:39.152 align:middle
App已经有了一些初始内容

00:08:40.453 --> 00:08:44.324 align:middle
你可以根据需要下载更多的内容

00:08:44.558 --> 00:08:48.195 align:middle
这已经不是存储在设备上应用程序包里

00:08:48.262 --> 00:08:51.698 align:middle
也不会备份到iCloud存储空间里

00:08:51.765 --> 00:08:55.335 align:middle
而是存储在系统内存中

00:08:55.936 --> 00:08:58.505 align:middle
系统可以进行高速缓存资源

00:08:58.572 --> 00:09:00.908 align:middle
并按需加载资源

00:08:58.572 --> 00:09:00.908 align:middle
并按需加载资源

00:09:02.242 --> 00:09:03.310 align:middle
因此在这种情况下

00:09:03.377 --> 00:09:06.613 align:middle
假如你在这个场景中
实际上我们会有更多的空间

00:09:06.680 --> 00:09:08.348 align:middle
而不仅只有三个等级的空间

00:09:08.415 --> 00:09:10.617 align:middle
我们可以有更多的等级空间

00:09:10.684 --> 00:09:12.419 align:middle
假如你不使用按需加载资源的话

00:09:12.553 --> 00:09:16.156 align:middle
当我们来到第四级系统会自动清理

00:09:16.223 --> 00:09:21.128 align:middle
最近使用过的资源包包括你的第一级资
源

00:09:21.695 --> 00:09:22.696 align:middle
对于第五级同样如此

00:09:24.164 --> 00:09:26.733 align:middle
如果用户有段时间没使用你的应用程序

00:09:26.867 --> 00:09:29.670 align:middle
以及其它需要下载需加载资源的App

00:09:30.037 --> 00:09:31.405 align:middle
则可进行空间回收

00:09:31.471 --> 00:09:32.873 align:middle
当应用程序再次被使用时

00:09:32.940 --> 00:09:34.141 align:middle
则再次自动下载

00:09:36.076 --> 00:09:38.979 align:middle
说说一些关于 按需加载资源的事

00:09:39.546 --> 00:09:43.116 align:middle
你通过
在Xcode中标记资源建立资源包

00:09:43.183 --> 00:09:47.421 align:middle
昨天你观看了一个简短演示

00:09:47.788 --> 00:09:51.425 align:middle
今天晚一点的时候
将会有一整个环节说明按需加载资源

00:09:53.594 --> 00:09:56.897 align:middle
资源包可以包含任何不可执行资源

00:09:57.664 --> 00:10:00.767 align:middle
应用切割在在资源类型下

00:09:57.664 --> 00:10:00.767 align:middle
应用切割在在资源类型下

00:10:00.834 --> 00:10:02.236 align:middle
资源目录起作用

00:10:02.302 --> 00:10:05.305 align:middle
通过按需加载资源
你可以下载任何的松散文件并标记它们

00:10:05.372 --> 00:10:07.941 align:middle
它们会成为资源包一部分
然后从App Store中下载

00:10:08.008 --> 00:10:09.676 align:middle
它们存储在App Store中

00:10:10.043 --> 00:10:12.579 align:middle
你把
它们一起提交到App Store

00:10:12.646 --> 00:10:16.416 align:middle
作为IPA的一部分
但是App Store会把它们分开

00:10:17.217 --> 00:10:18.318 align:middle
并单独存储

00:10:19.653 --> 00:10:22.856 align:middle
它们会根据代码在需要时被下载

00:10:23.257 --> 00:10:24.992 align:middle
它们作为必需品被回收

00:10:26.326 --> 00:10:29.229 align:middle
它们就像其它内容一样被切割

00:10:29.763 --> 00:10:32.366 align:middle
因此你可以把资源包放在这里

00:10:32.432 --> 00:10:36.436 align:middle
实际上 如果你在资源包里标记资源

00:10:36.503 --> 00:10:39.907 align:middle
Xcode会自动为你建立

00:10:41.208 --> 00:10:42.376 align:middle
在资源目录里面

00:10:45.078 --> 00:10:47.247 align:middle
我们来看下储存大小

00:10:47.314 --> 00:10:51.618 align:middle
对了 今天下午4：30分

00:10:51.685 --> 00:10:53.320 align:middle
在太平洋大厦会有一个会议

00:10:54.788 --> 00:10:58.192 align:middle
让我们看看 我们得到什么种类的储存
程序片切割后

00:10:58.525 --> 00:11:02.663 align:middle
我们得到的程序片平均为22兆字节

00:10:58.525 --> 00:11:02.663 align:middle
我们得到的程序片平均为22兆字节

00:11:03.397 --> 00:11:04.531 align:middle
在这种情况下

00:11:04.598 --> 00:11:09.670 align:middle
我们得根据核心app
下载5-11兆字节的内容

00:11:10.103 --> 00:11:13.173 align:middle
而资源本身则是11-18兆字节

00:11:13.240 --> 00:11:16.476 align:middle
关键是并非所有文件

00:11:16.543 --> 00:11:18.312 align:middle
同时存在在设备中

00:11:19.046 --> 00:11:21.748 align:middle
所以总量大约有8兆字节

00:11:21.815 --> 00:11:23.217 align:middle
这是一个非常精简的app

00:11:23.283 --> 00:11:27.387 align:middle
但你可以看到它是一个巨大的运用程序
尤其是它有大量媒体资源文件

00:11:27.888 --> 00:11:30.424 align:middle
更精简app的就会很有帮助

00:11:32.593 --> 00:11:36.496 align:middle
更小的APP更好的使用体验

00:11:36.930 --> 00:11:40.934 align:middle
有些设备有8GB的空间

00:11:41.001 --> 00:11:45.405 align:middle
我们会小心使用这些空间
没必要用的东西不会占用你的设备容量

00:11:46.940 --> 00:11:51.645 align:middle
通过app简化设备就可支持更多应用

00:11:52.713 --> 00:11:57.417 align:middle
更棒的是这同时也意味着
更短的下载用时 更少的电线传送

00:11:57.918 --> 00:12:01.822 align:middle
更不容易超过100MB的限制

00:11:57.918 --> 00:12:01.822 align:middle
更不容易超过100MB的限制

00:12:03.924 --> 00:12:04.892 align:middle
这使你下载的应用

00:12:05.993 --> 00:12:08.128 align:middle
这意味着你可以使用

00:12:08.428 --> 00:12:11.098 align:middle
更多类型的设备而不受太多限制

00:12:11.164 --> 00:12:14.434 align:middle
如果你一直很想使用那种

00:12:14.501 --> 00:12:17.337 align:middle
不但可以在大功率设备上运行地很好

00:12:17.938 --> 00:12:20.707 align:middle
而且也可以
在低能耗设备上使用的Metal

00:12:20.774 --> 00:12:24.178 align:middle
有更好的用户体验 那该怎么做呢

00:12:24.244 --> 00:12:26.480 align:middle
下面这个能使你克服其中一些限制

00:12:26.547 --> 00:12:28.015 align:middle
你可以现在就提交

00:12:28.081 --> 00:12:33.787 align:middle
提交到Store
和用户下载的体积都变小

00:12:36.056 --> 00:12:38.692 align:middle
这意味着你确实

00:12:38.759 --> 00:12:42.896 align:middle
可以长期利用回收的空间

00:12:42.963 --> 00:12:45.332 align:middle
处理之前因为容量问题

00:12:45.399 --> 00:12:46.733 align:middle
而不能安装的应用

00:12:46.800 --> 00:12:48.869 align:middle
这不是说你又得占据大量的容量

00:12:48.936 --> 00:12:51.805 align:middle
相反的 这意味着当你面临容量不够

00:12:51.872 --> 00:12:55.709 align:middle
而又想放
更多的东西进app时可以更自由

00:12:57.878 --> 00:13:02.549 align:middle
现在 我想请我的同事帕特里克·海宁

00:12:57.878 --> 00:13:02.549 align:middle
现在 我想请我的同事帕特里克·海宁

00:13:02.616 --> 00:13:04.484 align:middle
来告诉你们具体如何做到这一点

00:13:07.721 --> 00:13:08.555 align:middle
谢谢你 安德斯

00:13:11.758 --> 00:13:12.793 align:middle
我是帕特里克·海宁

00:13:12.860 --> 00:13:15.095 align:middle
我想谈论一些关于
资源切割的更多一些细节

00:13:16.697 --> 00:13:18.632 align:middle
它的工作原理是什么呢

00:13:20.601 --> 00:13:22.202 align:middle
好吧 非常高兴告诉大家

00:13:22.269 --> 00:13:24.505 align:middle
资源切割和App简化已经无缝

00:13:24.571 --> 00:13:27.641 align:middle
整合到Xcode的开发
输出和工作流之中了

00:13:27.708 --> 00:13:29.142 align:middle
也许你们已经很熟悉

00:13:29.209 --> 00:13:30.644 align:middle
如何开发应用

00:13:32.079 --> 00:13:35.916 align:middle
这一切的改善

00:13:35.983 --> 00:13:38.352 align:middle
可以让你真正
实现资源切割和App简化的关键在于

00:13:38.418 --> 00:13:44.024 align:middle
我们为产品开发和资源目录
设立工作流

00:13:44.391 --> 00:13:49.296 align:middle
并同时考虑了
各种不同设备和变量从而方便开发应用

00:13:51.231 --> 00:13:53.500 align:middle
那么你需要做的是什么呢

00:13:54.701 --> 00:13:59.506 align:middle
如果你已经习惯使用
iOS的app 亦或者

00:14:00.707 --> 00:14:04.945 align:middle
习惯开发iOS应用

00:14:05.012 --> 00:14:07.214 align:middle
那么你们
会使用1X 2X 3X原图

00:14:07.281 --> 00:14:11.285 align:middle
适应各类尺寸的屏幕

00:14:11.818 --> 00:14:13.687 align:middle
甚至可能早就在使用

00:14:13.754 --> 00:14:17.090 align:middle
iOS 7的资源目录了

00:14:18.892 --> 00:14:20.327 align:middle
这一些确实也是你必须要有的

00:14:20.894 --> 00:14:24.431 align:middle
什么是资源目录 它们有什么作用呢

00:14:25.265 --> 00:14:26.967 align:middle
资源目录就是根据

00:14:27.034 --> 00:14:29.169 align:middle
资源的相关设备特征

00:14:29.236 --> 00:14:31.405 align:middle
进行资源组织的功能

00:14:31.505 --> 00:14:33.507 align:middle
因此非常重要且具有针对性

00:14:35.008 --> 00:14:36.577 align:middle
这里需要重点强调一下

00:14:37.211 --> 00:14:39.146 align:middle
为了能利用应用简化功能

00:14:39.379 --> 00:14:42.816 align:middle
你的资源必须处于资源目录内才行

00:14:43.250 --> 00:14:45.185 align:middle
我们无法处理松散资源

00:14:45.886 --> 00:14:50.257 align:middle
这不能限制这项强大功能

00:14:50.324 --> 00:14:51.592 align:middle
以后我们会进行改善

00:14:51.959 --> 00:14:53.026 align:middle
需要重点说明

00:14:54.895 --> 00:14:56.597 align:middle
所以我刚刚提到了设备特征

00:14:56.897 --> 00:15:00.767 align:middle
因为在资源目录内

00:14:56.897 --> 00:15:00.767 align:middle
因为在资源目录内

00:15:00.834 --> 00:15:03.837 align:middle
资源可以用设备关键组特征进行优化

00:15:04.204 --> 00:15:06.306 align:middle
这包括你很熟悉的

00:15:06.373 --> 00:15:11.111 align:middle
屏幕分辨率
2X 3X和其他系列设备

00:15:11.478 --> 00:15:15.816 align:middle
不管它是ipad还是 iPhone

00:15:18.285 --> 00:15:23.457 align:middle
更新
Xcode 7的iOS 9系统后

00:15:23.790 --> 00:15:25.192 align:middle
我们在设备硬件特征的基础上

00:15:25.259 --> 00:15:26.727 align:middle
开发了一组设备特性

00:15:27.327 --> 00:15:30.998 align:middle
尤其是图片处理能力和内存级别

00:15:31.765 --> 00:15:34.201 align:middle
这确实引起了两个需求

00:15:34.268 --> 00:15:38.005 align:middle
第一 我们可使用的一系列设备

00:15:38.071 --> 00:15:39.540 align:middle
性能特点更多强大

00:15:39.606 --> 00:15:41.475 align:middle
从最低终端到最高终端设备各有不同

00:15:41.542 --> 00:15:45.579 align:middle
单一的资源并不适用于

00:15:45.779 --> 00:15:48.015 align:middle
所有类别的设备

00:15:48.315 --> 00:15:52.686 align:middle
对于最终的使用体验
会是怎样真的很难达成一致

00:15:53.153 --> 00:15:57.658 align:middle
这对高端和低端的内存级别都是一样的

00:15:57.858 --> 00:16:02.763 align:middle
新的设备特性使你能
给不同的功能制定相应的资源

00:15:57.858 --> 00:16:02.763 align:middle
新的设备特性使你能
给不同的功能制定相应的资源

00:16:04.831 --> 00:16:08.235 align:middle
资源目录里又有哪些内容呢

00:16:10.571 --> 00:16:13.373 align:middle
好吧 目前为止

00:16:13.440 --> 00:16:15.776 align:middle
在我们所推出的资源目录中
最热门的是image

00:16:16.977 --> 00:16:21.715 align:middle
这主要是你应用里的原图资源

00:16:22.282 --> 00:16:26.353 align:middle
特别是位图资源和载体类型

00:16:26.420 --> 00:16:30.490 align:middle
你的图片可以是
png jpg或者pdf的格式

00:16:30.557 --> 00:16:33.794 align:middle
这些会先压缩以节省空间

00:16:33.861 --> 00:16:36.964 align:middle
编译成最佳的传送格式

00:16:37.030 --> 00:16:42.569 align:middle
然后通过
UI工具包的API传送到你应用

00:16:46.373 --> 00:16:50.477 align:middle
iOS 9和Xcode7更新后有了

00:16:51.111 --> 00:16:53.080 align:middle
新的的数据类别

00:16:53.614 --> 00:16:54.882 align:middle
至少一个新的数据类别

00:16:55.549 --> 00:16:56.817 align:middle
那就是Name数据

00:16:57.751 --> 00:16:58.785 align:middle
这是用来做什么的呢

00:16:59.453 --> 00:17:03.390 align:middle
Name数据让你可以
随心所欲的储存文件内容

00:16:59.453 --> 00:17:03.390 align:middle
Name数据让你可以
随心所欲的储存文件内容

00:17:04.625 --> 00:17:06.660 align:middle
现在 可能你们会担心的事情是

00:17:06.727 --> 00:17:08.362 align:middle
我们只是根据内容

00:17:08.428 --> 00:17:10.830 align:middle
对资源目录进行简化

00:17:10.897 --> 00:17:14.601 align:middle
你们会问
如果我尝试简化非Image类的资源

00:17:14.667 --> 00:17:16.203 align:middle
这正是Name数据的作用所在

00:17:16.270 --> 00:17:20.440 align:middle
Name数据让你可以
在资源目录中随意放入文件

00:17:20.507 --> 00:17:23.310 align:middle
并根据硬件水平进行分类

00:17:23.377 --> 00:17:25.244 align:middle
正如我之前提到的

00:17:27.247 --> 00:17:30.584 align:middle
然后 在运行时
可以使用OS X系统UI工具包

00:17:30.651 --> 00:17:35.722 align:middle
新的NSDataAsset
类别在app内进行内容检索

00:17:37.224 --> 00:17:39.092 align:middle
侧边栏在这里

00:17:39.393 --> 00:17:42.796 align:middle
资源目录的特征

00:17:42.863 --> 00:17:46.800 align:middle
正如我描述的Name数据和其他特点

00:17:46.867 --> 00:17:48.368 align:middle
在OS X系统中也有

00:17:48.435 --> 00:17:50.637 align:middle
我们不会在OS X系统中

00:17:50.704 --> 00:17:53.807 align:middle
进行应用简化
但是在目录里储存资源制品格式可以

00:17:53.874 --> 00:17:55.876 align:middle
用于从所有目标上获取资源

00:17:55.943 --> 00:17:58.345 align:middle
包括OS X系统和Watch

00:17:58.412 --> 00:18:00.347 align:middle
所有这些功能都能起作用

00:17:58.412 --> 00:18:00.347 align:middle
所有这些功能都能起作用

00:18:00.414 --> 00:18:01.615 align:middle
API在所有平台均可使用

00:18:01.949 --> 00:18:04.084 align:middle
简化只适用于iOS系统

00:18:04.651 --> 00:18:05.619 align:middle
侧边栏结束

00:18:07.254 --> 00:18:10.791 align:middle
在Xcode 7 和iSO 9
系统我们引入了另一种新的数据类型

00:18:10.858 --> 00:18:14.761 align:middle
就是Sprite地图集

00:18:15.429 --> 00:18:21.802 align:middle
这意味资源目录
和SpriteKit已经实现整合

00:18:23.604 --> 00:18:26.373 align:middle
让你们可以使用一般的方式
可以让你分组图像资源

00:18:26.440 --> 00:18:28.408 align:middle
以一种普通的方式在资源目录内组织

00:18:28.475 --> 00:18:30.444 align:middle
并重命名为Sprite地图集

00:18:30.511 --> 00:18:32.412 align:middle
另外可以在创建时候

00:18:32.579 --> 00:18:36.884 align:middle
自动创建纹理地图集

00:18:36.950 --> 00:18:42.256 align:middle
从而在图像资源里
检索SK纹理地图集类型

00:18:42.890 --> 00:18:44.458 align:middle
一项关键功能是

00:18:44.758 --> 00:18:49.696 align:middle
如果你已经在iPhone
iPad上完成常规组织

00:18:50.063 --> 00:18:54.401 align:middle
那么它将自动创建

00:18:54.535 --> 00:18:57.971 align:middle
编译好的纹理地图集的简化版本

00:18:58.105 --> 00:19:01.675 align:middle
然后作为简化资源

00:18:58.105 --> 00:19:01.675 align:middle
然后作为简化资源

00:19:01.775 --> 00:19:05.979 align:middle
与AppStore上和我稍后会谈到
的其他工作流简化的版本一致

00:19:07.948 --> 00:19:11.118 align:middle
那么我们如何
从资源目录中进行app简化呢

00:19:12.553 --> 00:19:14.922 align:middle
好的 这实在很简单
也许大家已经猜到了

00:19:15.222 --> 00:19:18.225 align:middle
每个资源目录中的资源都有标记

00:19:18.525 --> 00:19:23.263 align:middle
用于描述资源相关特征
以及有用的特征

00:19:24.865 --> 00:19:28.268 align:middle
在创建之时当我们建立流程后

00:19:28.702 --> 00:19:31.004 align:middle
这些特征会在资源

00:19:31.071 --> 00:19:32.806 align:middle
和相关简化app变体之间建立路径

00:19:34.107 --> 00:19:37.678 align:middle
就是这么简单
我想要在这里重点说明一下

00:19:38.679 --> 00:19:41.081 align:middle
资源目录已经存在好一会儿了

00:19:41.148 --> 00:19:43.417 align:middle
它们可以让你能够在运行的时候

00:19:43.483 --> 00:19:45.986 align:middle
选择适合请求该资源的

00:19:46.353 --> 00:19:48.088 align:middle
设备的正确资源

00:19:48.155 --> 00:19:51.625 align:middle
在简化app变体路径方面

00:19:51.725 --> 00:19:55.195 align:middle
也是基于同样的算法
和一样的选择标准

00:19:55.529 --> 00:19:58.699 align:middle
如果你的
app今天在不同设备上工作正常

00:19:58.765 --> 00:20:01.435 align:middle
那么app简化也同样工作正常

00:19:58.765 --> 00:20:01.435 align:middle
那么app简化也同样工作正常

00:20:01.735 --> 00:20:04.238 align:middle
因为它们使用同一个原理

00:20:06.707 --> 00:20:11.478 align:middle
好了我之前提到单词组织

00:20:12.112 --> 00:20:13.780 align:middle
我想要再强调一下

00:20:14.114 --> 00:20:18.252 align:middle
有效对
资源目录进行归类绝对是关键所在

00:20:18.952 --> 00:20:19.820 align:middle
为什么呢？

00:20:19.987 --> 00:20:23.056 align:middle
因为对资源进行

00:20:23.323 --> 00:20:27.494 align:middle
大规模标注意味着
程序片变体中的冗余数据就越少

00:20:28.128 --> 00:20:32.699 align:middle
你不会
获取app变体产生的额外数据

00:20:32.866 --> 00:20:35.802 align:middle
而这些数据在目标设备上运行时

00:20:35.869 --> 00:20:38.105 align:middle
是不会使用到的

00:20:39.373 --> 00:20:43.377 align:middle
例如 即使应用之前可以正常工作

00:20:43.443 --> 00:20:48.248 align:middle
但是如果只是在一台设备上使用那么就
没有必要保留通用资源了

00:20:48.315 --> 00:20:53.120 align:middle
考虑一下比如你的iPad上的应用有
自己的UI弹出按钮

00:20:53.187 --> 00:20:54.755 align:middle
是在iPhone上的应用

00:20:54.821 --> 00:20:59.393 align:middle
却不会在你的iphone上显示出来

00:20:59.459 --> 00:21:02.863 align:middle
通用资源的话可以使用可以显示正常

00:20:59.459 --> 00:21:02.863 align:middle
通用资源的话可以使用可以显示正常

00:21:02.930 --> 00:21:07.034 align:middle
但是
现在我们可以重新访问并进行归类

00:21:07.100 --> 00:21:09.970 align:middle
这样就无需
传送到iPhone版本的应用上

00:21:10.470 --> 00:21:15.108 align:middle
因为在那里没法显示
好的

00:21:16.143 --> 00:21:17.644 align:middle
以上是基础的知识

00:21:17.711 --> 00:21:19.980 align:middle
关于该系统工作的原理

00:21:20.047 --> 00:21:23.784 align:middle
我们来举个例子
说说具体的工作流程

00:21:23.884 --> 00:21:25.085 align:middle
以及如何产生影响的

00:21:27.154 --> 00:21:28.622 align:middle
首先说说创建

00:21:28.689 --> 00:21:30.257 align:middle
你是如何创建资源目录的

00:21:30.891 --> 00:21:34.361 align:middle
创建资源目录内容的首要方法是

00:21:34.428 --> 00:21:36.496 align:middle
通过Xcode上的资源目录编辑器

00:21:38.131 --> 00:21:41.401 align:middle
在IDE上使用用户界面很简单

00:21:41.468 --> 00:21:43.570 align:middle
或许你对此很熟悉了

00:21:44.104 --> 00:21:48.408 align:middle
创建一个新资源

00:21:48.475 --> 00:21:50.811 align:middle
只需增加一个新项目

00:21:51.879 --> 00:21:53.647 align:middle
你可以看到这里有个值域

00:21:53.714 --> 00:21:56.717 align:middle
这里 你可以看到数据集
图像集 Sprite地图集

00:21:56.783 --> 00:21:59.353 align:middle
以及其他平台的其他数据类型

00:22:01.622 --> 00:22:03.490 align:middle
当你将这增加到项目中时

00:22:03.557 --> 00:22:06.093 align:middle
你可以看到在左边
有一个组织数组和范围

00:22:06.159 --> 00:22:08.695 align:middle
显示的是设备特征
你可根据这些特征进行分类

00:22:08.762 --> 00:22:14.201 align:middle
并显示你想要的资料丰富性

00:22:14.768 --> 00:22:18.238 align:middle
将资源放到合适的源中

00:22:18.639 --> 00:22:20.974 align:middle
然后离开 前往种类完成了

00:22:23.277 --> 00:22:25.212 align:middle
好极了 用起来很简单

00:22:26.046 --> 00:22:30.284 align:middle
倘若你的团队无法在资源
产品里使用Xcode将会怎么样

00:22:31.652 --> 00:22:33.754 align:middle
倘若这是个游戏工作室

00:22:33.820 --> 00:22:36.990 align:middle
在现有资源工具链和管道上投资巨大

00:22:37.057 --> 00:22:40.694 align:middle
但对于创造出合适原图的

00:22:40.827 --> 00:22:43.397 align:middle
内容工程师或设计者来说
现有的资源工具链和管道

00:22:43.463 --> 00:22:45.866 align:middle
并不适合使用Xcode这将会怎样

00:22:46.800 --> 00:22:50.337 align:middle
很高兴的告诉你们我们考虑到这种情况

00:22:50.671 --> 00:22:53.740 align:middle
我们仔细地设计了资源目录特征

00:22:53.807 --> 00:22:56.610 align:middle
与简化相配使之适用于这些情况

00:22:58.045 --> 00:23:00.314 align:middle
我们特别地将它设计成

00:22:58.045 --> 00:23:00.314 align:middle
我们特别地将它设计成

00:23:00.380 --> 00:23:04.151 align:middle
很容易从现有资源管道

00:23:04.218 --> 00:23:05.786 align:middle
导出图像集和数据集

00:23:06.787 --> 00:23:07.988 align:middle
如何做到这点呢

00:23:09.723 --> 00:23:13.193 align:middle
我们将通过
XC资源来源工件格式进行讲解

00:23:13.493 --> 00:23:17.698 align:middle
我很高兴的告诉大家
我们将进行文件编制和发行

00:23:18.098 --> 00:23:21.034 align:middle
使得外部工具链

00:23:21.101 --> 00:23:22.903 align:middle
可以很容易的执行这个格式

00:23:24.638 --> 00:23:28.575 align:middle
这算不上什么格式

00:23:28.642 --> 00:23:31.745 align:middle
因为它只是JSON标记上一个简单的
文件夹结构而且很容易配合使用

00:23:32.246 --> 00:23:33.814 align:middle
我想要强调的是

00:23:34.314 --> 00:23:39.853 align:middle
这并不是下面提到的这种格式
先创建 然后导入Xcode中

00:23:39.920 --> 00:23:42.055 align:middle
然后就变成了一个项目工件

00:23:42.456 --> 00:23:44.992 align:middle
这是源工件格式

00:23:45.058 --> 00:23:47.194 align:middle
在创建时

00:23:47.594 --> 00:23:49.396 align:middle
Xcode创建系统就开始用来

00:23:49.463 --> 00:23:51.532 align:middle
处理和产生最后执行成品

00:23:53.500 --> 00:23:56.470 align:middle
我们来看看它的细节信息

00:23:56.904 --> 00:24:02.009 align:middle
来看看先前说过的
例子AirPlay图像原图

00:23:56.904 --> 00:24:02.009 align:middle
来看看先前说过的
例子AirPlay图像原图

00:24:02.276 --> 00:24:03.944 align:middle
在磁盘中看起来是这样的

00:24:04.011 --> 00:24:05.145 align:middle
事实上 这就是格式

00:24:05.812 --> 00:24:06.780 align:middle
非常简单

00:24:06.980 --> 00:24:09.550 align:middle
它所包含的是一个文件夹命名约定

00:24:09.616 --> 00:24:10.984 align:middle
包含资源的名字

00:24:11.051 --> 00:24:13.654 align:middle
这是使用UI图像名称在代码中

00:24:13.720 --> 00:24:15.589 align:middle
重新得到的名字

00:24:16.490 --> 00:24:19.159 align:middle
随后文件夹里包含了单独原图源

00:24:19.593 --> 00:24:24.932 align:middle
我想指出的是
尽管在这个特别例子中

00:24:24.998 --> 00:24:28.435 align:middle
用了一个众所周知半标准文件命名约定

00:24:28.502 --> 00:24:30.771 align:middle
来显示比例系数和设备习语

00:24:30.938 --> 00:24:32.739 align:middle
但它并不需要

00:24:32.806 --> 00:24:34.675 align:middle
任何特别的文件命名约定

00:24:34.741 --> 00:24:36.944 align:middle
你可以使用任何工作流程

00:24:37.010 --> 00:24:38.679 align:middle
或工具链或任何你所喜欢的方法

00:24:39.346 --> 00:24:40.347 align:middle
为什么可以做到这样

00:24:40.547 --> 00:24:42.950 align:middle
因为在这个设计中

00:24:43.016 --> 00:24:45.452 align:middle
有重要的第三元素
即contents.JSON文件

00:24:46.920 --> 00:24:49.022 align:middle
contents.JSON文件

00:24:49.256 --> 00:24:52.593 align:middle
包含所有资源标记信息

00:24:52.659 --> 00:24:54.228 align:middle
并将信息连接在一起

00:24:54.294 --> 00:24:55.796 align:middle
并告诉系统

00:24:55.863 --> 00:24:59.533 align:middle
与特别资源有关的特性

00:25:00.200 --> 00:25:02.369 align:middle
来看看

00:25:02.903 --> 00:25:07.574 align:middle
先前在Xcode编辑器上显示的
AirPlay图标

00:25:07.641 --> 00:25:09.309 align:middle
现在看起来是这样子的

00:25:09.476 --> 00:25:11.378 align:middle
你可以看到 它非常的简单明了

00:25:12.045 --> 00:25:16.416 align:middle
这只是单独图像中的一个数组你可以看
到单独文件名称

00:25:16.483 --> 00:25:20.854 align:middle
然后是设备习语和比例系数标记信息

00:25:21.355 --> 00:25:24.691 align:middle
这些属性你看到的这些关键数值组

00:25:24.758 --> 00:25:26.693 align:middle
就是将被记录在

00:25:26.760 --> 00:25:28.295 align:middle
SES源工件格式中的东西

00:25:30.464 --> 00:25:34.968 align:middle
举个高一级的例子 名字数据

00:25:35.102 --> 00:25:38.705 align:middle
我们叫它数据集
不出所料 看起来很相似

00:25:38.772 --> 00:25:41.308 align:middle
再一次 里面有单独源的文件名

00:25:41.375 --> 00:25:44.411 align:middle
然后是通用型标识符

00:25:44.678 --> 00:25:47.614 align:middle
和存储器的属性

00:25:47.781 --> 00:25:48.815 align:middle
或显卡未来集类

00:25:50.284 --> 00:25:52.452 align:middle
你可看到 它真的很好配合使用

00:25:52.519 --> 00:25:54.454 align:middle
你可以看到它是如何操作的

00:25:54.521 --> 00:25:57.224 align:middle
如何命名文件名和属性

00:25:57.291 --> 00:26:00.227 align:middle
这也是为什么不管你在

00:25:57.291 --> 00:26:00.227 align:middle
这也是为什么不管你在

00:26:00.294 --> 00:26:03.463 align:middle
数据集和图像集加入什么名字没有关系

00:26:03.530 --> 00:26:05.999 align:middle
重要的是
contents.JSON是正确的

00:26:08.836 --> 00:26:10.637 align:middle
你可以用它来做什么呢

00:26:10.704 --> 00:26:12.439 align:middle
这是用来做什么的呢

00:26:13.140 --> 00:26:16.043 align:middle
我来举个例子

00:26:16.109 --> 00:26:18.679 align:middle
假设有用Xcode创建的图像集

00:26:19.046 --> 00:26:20.514 align:middle
我将展示的这个假设工作流程

00:26:20.581 --> 00:26:23.650 align:middle
是在PhotoShop中
使用PhotoShop CC生成器

00:26:26.587 --> 00:26:29.556 align:middle
假设你的设计者创建了漂亮的原图

00:26:29.623 --> 00:26:32.826 align:middle
他们决定今天iPad是蓝色的

00:26:32.893 --> 00:26:33.961 align:middle
iPhone是红色的

00:26:34.027 --> 00:26:35.362 align:middle
这只是我们工作的方法

00:26:35.829 --> 00:26:36.964 align:middle
设计者有时会这么做

00:26:39.366 --> 00:26:41.468 align:middle
他们有漂亮的主文件

00:26:42.069 --> 00:26:44.471 align:middle
并在这里陈列所有这些变体

00:26:44.538 --> 00:26:47.274 align:middle
事实上

00:26:47.341 --> 00:26:49.343 align:middle
他们用生成器工作流程
创建了主文件

00:26:49.409 --> 00:26:51.245 align:middle
打开图像资源生成

00:26:51.512 --> 00:26:53.981 align:middle
由合适的命名约定

00:26:54.047 --> 00:26:57.684 align:middle
构造他们的层级清单

00:26:57.951 --> 00:27:00.354 align:middle
默认层级直接导出到一个图像集

00:26:57.951 --> 00:27:00.354 align:middle
默认层级直接导出到一个图像集

00:27:00.988 --> 00:27:04.391 align:middle
有一个生成器的特别版本

00:27:04.958 --> 00:27:08.428 align:middle
他们小心地进行扩展

00:27:08.495 --> 00:27:12.699 align:middle
这是产生
contents.JSON假想事例

00:27:12.966 --> 00:27:15.269 align:middle
这就是将从
PhotoShop工作流程中输出的

00:27:15.569 --> 00:27:17.738 align:middle
对于以前使用过生成器的人来说

00:27:17.871 --> 00:27:20.707 align:middle
他们很熟悉照片布局了

00:27:20.774 --> 00:27:21.842 align:middle
这是资源文件夹

00:27:22.009 --> 00:27:24.745 align:middle
里面有生成的图像集

00:27:24.811 --> 00:27:29.716 align:middle
所有不同的原图实体
和contents.JSON

00:27:30.450 --> 00:27:33.921 align:middle
我们要做的仅是拖出图像集

00:27:33.987 --> 00:27:35.989 align:middle
并将图像集放到
XE资源文件夹下的文件夹中

00:27:36.056 --> 00:27:39.593 align:middle
之后就可以进入竞态

00:27:43.330 --> 00:27:47.534 align:middle
就这样简单说来就是
带Xcode项目的动态集成

00:27:49.469 --> 00:27:51.305 align:middle
唯一的要求是

00:27:51.371 --> 00:27:55.676 align:middle
从一个Xcode项目文件水平来说
你的项目必须有XE资源文件夹

00:27:55.742 --> 00:27:58.512 align:middle
这是唯一的要求

00:28:00.047 --> 00:28:01.982 align:middle
里面的所有内容

00:28:02.549 --> 00:28:06.019 align:middle
都必须有一个任意层级 任意结构

00:28:06.520 --> 00:28:09.022 align:middle
它必须符合图像集和数据集

00:28:09.089 --> 00:28:13.694 align:middle
你可以按照任意深度进行嵌套

00:28:14.261 --> 00:28:16.864 align:middle
你可以使用
受它支配的自己的文件系统组织

00:28:17.064 --> 00:28:19.166 align:middle
假设你正确授权图像集和数据集

00:28:19.366 --> 00:28:23.103 align:middle
在创建时Xcode将递归地下降层级

00:28:23.203 --> 00:28:28.408 align:middle
发现所有图像集 数据集
和传播地图集并自动进行创建

00:28:31.044 --> 00:28:34.581 align:middle
现在你知道怎么创建资源目录了

00:28:35.115 --> 00:28:37.451 align:middle
现在进入下一步 创建

00:28:39.253 --> 00:28:42.456 align:middle
或许最普通最重要的创建工作流程是

00:28:42.789 --> 00:28:45.259 align:middle
坐在座位上
在Tether设备的app上作

00:28:45.592 --> 00:28:49.630 align:middle
或者你在模拟器上操作

00:28:49.696 --> 00:28:51.765 align:middle
此种情况下如何简化应用呢

00:28:51.832 --> 00:28:53.534 align:middle
很高兴的告诉你

00:28:53.600 --> 00:28:56.637 align:middle
创建和运行工作流程

00:28:56.703 --> 00:29:00.541 align:middle
可自动地为现有有效运作目标简化资源

00:28:56.703 --> 00:29:00.541 align:middle
可自动地为现有有效运作目标简化资源

00:29:01.074 --> 00:29:02.109 align:middle
在Xcode中

00:29:02.910 --> 00:29:05.312 align:middle
意思是说 每次进行创建

00:29:05.712 --> 00:29:07.681 align:middle
事实上它仅会对

00:29:07.748 --> 00:29:10.617 align:middle
你正在使用的目标设备分析

00:29:10.684 --> 00:29:15.989 align:middle
产生并自动创建适当的执行资源目录

00:29:17.424 --> 00:29:21.461 align:middle
所有的模拟器和设备均支持这功能

00:29:22.930 --> 00:29:25.566 align:middle
这是利用应用简化

00:29:25.632 --> 00:29:28.335 align:middle
绝佳的范例

00:29:29.736 --> 00:29:31.171 align:middle
这个功能是

00:29:31.238 --> 00:29:33.674 align:middle
由已经在目标编辑器资源目录显示的

00:29:33.740 --> 00:29:37.978 align:middle
新创建设置激发或控制的

00:29:38.145 --> 00:29:40.447 align:middle
仅在有效资源下启用创建

00:29:41.982 --> 00:29:43.650 align:middle
这很方便

00:29:43.717 --> 00:29:46.386 align:middle
倘若 你试着解决

00:29:46.453 --> 00:29:48.255 align:middle
一个由应用简化引起的问题将会怎么样

00:29:48.322 --> 00:29:50.591 align:middle
倘若简化全面影响了
特定的目标设备情况会怎么样

00:29:50.657 --> 00:29:54.862 align:middle
为此 你可以不断拨动开关

00:29:57.631 --> 00:29:59.833 align:middle
此创建工作流程的其他优势是

00:29:59.900 --> 00:30:03.070 align:middle
极大的加快重复编译

00:29:59.900 --> 00:30:03.070 align:middle
极大的加快重复编译

00:30:03.136 --> 00:30:04.238 align:middle
或增量编译

00:30:04.304 --> 00:30:06.673 align:middle
在应用内容繁多的时候尤其适用

00:30:07.007 --> 00:30:12.346 align:middle
它只处理并
只与当下适合目标的源进行匹配

00:30:12.412 --> 00:30:16.250 align:middle
当它创建一个应用的
普通版本时

00:30:16.316 --> 00:30:19.520 align:middle
并不需要像以前一样每一个都需做完

00:30:20.888 --> 00:30:22.256 align:middle
另一个重要优势是

00:30:22.322 --> 00:30:25.626 align:middle
对于一个特别设备或一组设备

00:30:25.692 --> 00:30:28.862 align:middle
可以很容易测试

00:30:29.263 --> 00:30:30.697 align:middle
若你想要理解

00:30:30.764 --> 00:30:34.334 align:middle
目录变动对简化输出的影响

00:30:34.401 --> 00:30:37.004 align:middle
整体创建应用的大小或
用户体验的其他方面的影响

00:30:37.237 --> 00:30:40.407 align:middle
你可以迅速变动这些目录创建并运行

00:30:40.641 --> 00:30:44.811 align:middle
随后通过在其他设备
和Xcode中运行目标间进行转化

00:30:44.878 --> 00:30:49.550 align:middle
来检查其他设备
可以极其快速简单地测试这些变动

00:30:53.220 --> 00:30:56.590 align:middle
创建就讲到这里 接下来是什么呢

00:30:56.657 --> 00:30:58.325 align:middle
传播

00:30:58.392 --> 00:31:03.297 align:middle
这是简化应用的基本步骤

00:30:58.392 --> 00:31:03.297 align:middle
这是简化应用的基本步骤

00:31:05.699 --> 00:31:08.468 align:middle
现在 有很多方法

00:31:08.535 --> 00:31:10.337 align:middle
可用来传播你的iOS应用

00:31:11.171 --> 00:31:13.307 align:middle
使你能够传播你的iOS应用

00:31:13.373 --> 00:31:15.542 align:middle
最大且最有效的一个

00:31:15.609 --> 00:31:18.245 align:middle
当然是你的终端用户 顾客

00:31:18.312 --> 00:31:21.114 align:middle
通过AppStore
购买正在使用的用户这是最核心的

00:31:21.181 --> 00:31:25.719 align:middle
安德斯提到
这是你提供普通IPA的地方

00:31:26.320 --> 00:31:27.888 align:middle
商店做了这个工作

00:31:27.955 --> 00:31:30.023 align:middle
处理了所有简化变体

00:31:30.090 --> 00:31:32.226 align:middle
当用户购买app时

00:31:32.292 --> 00:31:35.662 align:middle
它将从商店里自动选择适合设备的变体

00:31:35.729 --> 00:31:38.065 align:middle
下载并进行安装完成了 完全自动的

00:31:38.265 --> 00:31:39.233 align:middle
不需要操心什么

00:31:39.733 --> 00:31:42.202 align:middle
在发布应用前

00:31:42.536 --> 00:31:47.875 align:middle
你或许也想为beta C
测试者创造完全相同的体验

00:31:48.242 --> 00:31:53.413 align:middle
也可通过TestFlight支持测
试传播我们将通过简化传播

00:31:56.016 --> 00:31:58.652 align:middle
然后 当然有ad hoc和企业传播

00:31:58.719 --> 00:32:01.788 align:middle
这是个常用方法
可用来在你的组织中传播应用

00:31:58.719 --> 00:32:01.788 align:middle
这是个常用方法
可用来在你的组织中传播应用

00:32:01.855 --> 00:32:04.725 align:middle
或在你的组中进行QA测试其他事情

00:32:05.692 --> 00:32:08.695 align:middle
这是传播极其重要的一种方法

00:32:08.762 --> 00:32:12.499 align:middle
我们也在其中创建了简化支持

00:32:12.566 --> 00:32:16.003 align:middle
最后 还有已经更新的Xcode服务

00:32:16.637 --> 00:32:19.006 align:middle
和Ecos服务器

00:32:19.072 --> 00:32:21.675 align:middle
用来支持传播简化应用

00:32:22.042 --> 00:32:23.510 align:middle
随后 我会讲到更多细节

00:32:24.545 --> 00:32:30.017 align:middle
上述方法的自动化程度非常高

00:32:30.083 --> 00:32:31.885 align:middle
你无需做太多事情

00:32:32.252 --> 00:32:35.589 align:middle
等下要我要讲的是

00:32:35.656 --> 00:32:37.491 align:middle
Ad hoc企业解决方案

00:32:37.558 --> 00:32:40.894 align:middle
这里 你需要自己托管传播流程

00:32:40.961 --> 00:32:44.998 align:middle
你可能需要理解
他们是如何放到一起如何运作的

00:32:45.432 --> 00:32:47.134 align:middle
我们现在就来说这个它们是如何运作的

00:32:48.836 --> 00:32:52.039 align:middle
Xcode中已增加的一个功能是

00:32:52.206 --> 00:32:54.875 align:middle
现在 对于特别设备

00:32:54.942 --> 00:32:56.343 align:middle
你可以从组织器中导出

00:32:56.610 --> 00:33:00.480 align:middle
若你将测试一个创建或要将创建切换到

00:32:56.610 --> 00:33:00.480 align:middle
若你将测试一个创建或要将创建切换到

00:33:00.547 --> 00:33:02.149 align:middle
制定设备 非常管用

00:33:02.216 --> 00:33:05.052 align:middle
你可立即创建一个IPA

00:33:05.118 --> 00:33:07.521 align:middle
用于直接指向到特定设备和为特定设备
提供的组织器

00:33:10.991 --> 00:33:15.162 align:middle
未来 我们将为你提供一种方法

00:33:15.229 --> 00:33:19.166 align:middle
可在所有的兼容设备上

00:33:19.233 --> 00:33:22.936 align:middle
导出所有简化变体

00:33:23.003 --> 00:33:25.839 align:middle
为应用的所有
可能支持设备提供完整的传播单元

00:33:25.906 --> 00:33:27.174 align:middle
这很重要

00:33:27.241 --> 00:33:30.711 align:middle
你或许不知道或能够为

00:33:30.777 --> 00:33:33.013 align:middle
所有的设备生成所有的简化变体

00:33:33.080 --> 00:33:35.549 align:middle
你想要获得全组信息

00:33:37.384 --> 00:33:40.854 align:middle
事实上 它将做的是

00:33:40.921 --> 00:33:43.824 align:middle
处理你所有的普通app创建存档

00:33:45.993 --> 00:33:49.596 align:middle
生成适合所有不同兼容设备的

00:33:49.663 --> 00:33:52.099 align:middle
所有简化变体
并将它们放入一组产品中

00:33:54.234 --> 00:33:57.271 align:middle
现在 你有很多应用

00:33:58.038 --> 00:34:03.544 align:middle
你或许会问自己 何才能为设备

00:33:58.038 --> 00:34:03.544 align:middle
你或许会问自己 何才能为设备

00:34:03.610 --> 00:34:06.446 align:middle
获取一个正确的应用 是个大问题

00:34:06.713 --> 00:34:09.716 align:middle
将app发送到企业和adhoc设备

00:34:09.783 --> 00:34:11.185 align:middle
最常用的方法是

00:34:11.251 --> 00:34:12.452 align:middle
空中安装

00:34:14.321 --> 00:34:16.723 align:middle
随后我会讲到这个
化配合使用并会讲到如何与简

00:34:16.790 --> 00:34:20.827 align:middle
第一步保存为ad hoc或企业传播

00:34:20.893 --> 00:34:25.899 align:middle
这很重要 包了传播显示选项

00:34:25.966 --> 00:34:28.768 align:middle
左下角的复选框

00:34:29.837 --> 00:34:30.904 align:middle
这是用来做什么

00:34:32.206 --> 00:34:34.007 align:middle
它的作用是

00:34:34.074 --> 00:34:37.678 align:middle
当Xcode在生成IPA的导出集时

00:34:37.744 --> 00:34:40.681 align:middle
它将为它所生成的每个app变体

00:34:40.746 --> 00:34:42.783 align:middle
生成一个含有URL的显示清单

00:34:42.850 --> 00:34:44.585 align:middle
它将通过app变体的支持产品类型

00:34:45.351 --> 00:34:50.924 align:middle
更重要的是 将编插入索引
由不同产品门类区分支持

00:34:51.592 --> 00:34:52.693 align:middle
取决于那app的门类

00:34:53.927 --> 00:34:55.161 align:middle
影响在于

00:34:55.395 --> 00:35:00.767 align:middle
当设备试图安装app时

00:34:55.395 --> 00:35:00.767 align:middle
当设备试图安装app时

00:35:00.834 --> 00:35:03.036 align:middle
使用空中显示PO清单

00:35:03.403 --> 00:35:06.139 align:middle
它将会过一遍清单为设备

00:35:06.373 --> 00:35:08.942 align:middle
产品类型找到合适的URL

00:35:09.276 --> 00:35:12.045 align:middle
并对其进行安装

00:35:12.346 --> 00:35:13.180 align:middle
这就是它的运作方式

00:35:13.247 --> 00:35:17.351 align:middle
概念上与简化应用商店
实际所发生的相类似

00:35:17.718 --> 00:35:20.420 align:middle
但所有的这些移动块

00:35:20.487 --> 00:35:25.125 align:middle
都是由你通过Xcode进行生成并在
Web服务器上进行托管

00:35:26.793 --> 00:35:28.962 align:middle
倘若更进一步将会怎么样

00:35:30.030 --> 00:35:33.367 align:middle
这就是
Xcode服务器持续集成服务所做的

00:35:36.637 --> 00:35:38.939 align:middle
Xcode服务器所做的是

00:35:39.006 --> 00:35:41.775 align:middle
为创建代管和传播简化app

00:35:41.842 --> 00:35:43.577 align:middle
包括代管按需资源包

00:35:43.644 --> 00:35:45.012 align:middle
将我刚描述的原理

00:35:45.245 --> 00:35:48.582 align:middle
变成完整解决方案

00:35:51.318 --> 00:35:52.853 align:middle
非常简单

00:35:53.187 --> 00:35:55.923 align:middle
Xcode服务器
你在Xcode中创建集成盒

00:35:55.989 --> 00:35:59.493 align:middle
与Xcode服务器展开配合使用

00:36:00.360 --> 00:36:03.497 align:middle
项目自动创建应用

00:36:03.564 --> 00:36:06.667 align:middle
生成变体生成显示P清单

00:36:07.134 --> 00:36:09.636 align:middle
甚至在你在Xcode服务网站上

00:36:09.803 --> 00:36:13.473 align:middle
选定设备和选择特别创建的地方

00:36:13.674 --> 00:36:16.410 align:middle
覆盖web服务你所需做的

00:36:16.610 --> 00:36:18.245 align:middle
只是点击安装按钮

00:36:18.445 --> 00:36:20.614 align:middle
以及我先前所描述的
对显示P清单进行定位

00:36:20.681 --> 00:36:22.482 align:middle
牵引合适变量的所有原理

00:36:22.549 --> 00:36:25.719 align:middle
它是自动进行的

00:36:26.453 --> 00:36:30.324 align:middle
将设备指向Web服务并运行很简单

00:36:30.557 --> 00:36:33.126 align:middle
我鼓励你来看一看这个 尤其是

00:36:33.193 --> 00:36:35.195 align:middle
感受一下所有的一切是如何运作的

00:36:35.863 --> 00:36:39.166 align:middle
我鼓励你看看

00:36:39.233 --> 00:36:43.337 align:middle
这个模式和你在进行托管可能用来创建
你自己的企业传播工作流程

00:36:43.403 --> 00:36:48.242 align:middle
或ad hoc
传播工作流程的模式是相同的

00:36:48.976 --> 00:36:51.044 align:middle
所有的这些你都可以自己创建

00:36:53.447 --> 00:36:56.850 align:middle
整合各功能的Xcode服务

00:36:56.917 --> 00:36:59.753 align:middle
是使用空中显示的简化app变体的

00:36:59.820 --> 00:37:02.623 align:middle
一种流线型的安装方法

00:36:59.820 --> 00:37:02.623 align:middle
一种流线型的安装方法

00:37:03.490 --> 00:37:07.127 align:middle
漂亮简单的解决方案  一站式

00:37:09.663 --> 00:37:12.099 align:middle
好了 我们刚讲的是

00:37:12.165 --> 00:37:14.868 align:middle
如何创建资源目录从而进行app划分

00:37:15.002 --> 00:37:16.703 align:middle
我们讲了

00:37:17.204 --> 00:37:18.939 align:middle
它如何与你的创建工作流程相结合

00:37:19.106 --> 00:37:21.375 align:middle
我们也讲了传播的不同方法

00:37:21.441 --> 00:37:23.010 align:middle
app简化如何与它们相互作用

00:37:23.911 --> 00:37:25.245 align:middle
现场交给安德斯

00:37:25.312 --> 00:37:27.114 align:middle
请安德斯为我们做总结

00:37:31.985 --> 00:37:32.819 align:middle
谢谢你  帕特里克

00:37:35.322 --> 00:37:37.491 align:middle
好了 在这部分 我们看了

00:37:37.558 --> 00:37:40.460 align:middle
app传播工作流程是如何运作的

00:37:41.862 --> 00:37:44.164 align:middle
以及如何改进app简化

00:37:46.099 --> 00:37:49.269 align:middle
你可以帮助它变得更加有效的方法

00:37:49.336 --> 00:37:55.409 align:middle
当你恰地标记资源和传播特征

00:37:56.510 --> 00:38:01.048 align:middle
对于你的工作流程来说
在测试及提交到App Store

00:37:56.510 --> 00:38:01.048 align:middle
对于你的工作流程来说
在测试及提交到App Store

00:38:01.815 --> 00:38:04.017 align:middle
这意味着什么在这里需要进行一些操作

00:38:04.518 --> 00:38:05.352 align:middle
你所应做的是

00:38:05.786 --> 00:38:08.522 align:middle
不断开发资源的定制版本

00:38:08.589 --> 00:38:11.358 align:middle
太好了 为你想开发出最好的app

00:38:11.425 --> 00:38:13.594 align:middle
并在所有的设备上运作良好

00:38:13.894 --> 00:38:15.095 align:middle
使用app简化

00:38:15.162 --> 00:38:17.898 align:middle
现在稍微放宽了上传大小限制

00:38:18.565 --> 00:38:22.135 align:middle
每个用户将只获得他们所需的

00:38:23.170 --> 00:38:25.506 align:middle
不断开发资源的定制版本

00:38:26.240 --> 00:38:29.643 align:middle
使用资源目录使你的资源系统化

00:38:29.710 --> 00:38:33.447 align:middle
正如帕特里克提到的 你可以
在其中放置数据和Sprite地图集

00:38:33.514 --> 00:38:37.384 align:middle
且这些可根据设备进行改变

00:38:39.386 --> 00:38:42.356 align:middle
同样地
使用Xcode测试你简化app变体

00:38:42.789 --> 00:38:44.491 align:middle
这个现在变得很重要

00:38:44.558 --> 00:38:45.993 align:middle
因为我们是

00:38:46.059 --> 00:38:47.628 align:middle
根据每个设备所需进行资源传播的

00:38:48.161 --> 00:38:51.231 align:middle
正如帕特里克所提到的
你可通过使用Xcode目标做到这个

00:38:51.298 --> 00:38:56.737 align:middle
使用Xcode
服务器创建多样的简化变体

00:38:56.803 --> 00:38:59.006 align:middle
并在真实的设备上进行测试

00:39:01.675 --> 00:39:06.480 align:middle
充分利用按需资源 资源进行标记

00:39:06.547 --> 00:39:08.849 align:middle
使它们成为按需加载

00:39:08.916 --> 00:39:11.118 align:middle
资源包的一部分

00:39:14.087 --> 00:39:18.692 align:middle
我将检索数个地方以获取更多信息

00:39:18.992 --> 00:39:21.094 align:middle
一是app简化指南

00:39:21.161 --> 00:39:23.630 align:middle
app传播指南中的章节

00:39:24.364 --> 00:39:27.434 align:middle
可在Apple的开发者网站上找到

00:39:27.601 --> 00:39:30.270 align:middle
另一个是资源目录格式文件

00:39:30.337 --> 00:39:32.673 align:middle
这个将
会放到Apple的开发者网站上

00:39:35.008 --> 00:39:36.543 align:middle
我们有相关联的会议

00:39:36.610 --> 00:39:37.845 align:middle
第一部分已经有了

00:39:37.911 --> 00:39:39.246 align:middle
你可以通过录像进行了解

00:39:39.913 --> 00:39:42.716 align:middle
另一点是
SpriteKit有什么新特性

00:39:42.783 --> 00:39:46.553 align:middle
这个在20分钟后

00:39:47.187 --> 00:39:51.358 align:middle
会详细讨论

00:39:51.592 --> 00:39:53.393 align:middle
它侧重于按需资源部分
今天4:30在太平洋大厦进行

00:39:53.460 --> 00:39:55.028 align:middle
我鼓励你们参加这会议

00:39:55.429 --> 00:40:00.067 align:middle
明天1:30在Mission会议上

00:39:55.429 --> 00:40:00.067 align:middle
明天1:30在Mission会议上

00:40:00.501 --> 00:40:02.836 align:middle
将详细讨论DemoBots

00:40:03.704 --> 00:40:04.938 align:middle
我们有许多实验室

00:40:05.005 --> 00:40:07.908 align:middle
欢迎来我们的实验室学习更多信息

00:40:07.975 --> 00:40:09.776 align:middle
继续观看WWDC的其他部分
