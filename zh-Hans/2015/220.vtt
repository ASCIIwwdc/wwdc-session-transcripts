WEBVTT

00:00:20.721 --> 00:00:24.324 align:middle
Core Data 新中的内容

00:00:31.465 --> 00:00:34.201 align:middle
下午好！
欢迎收看第 220 课

00:00:34.768 --> 00:00:38.172 align:middle
我叫瑞西 卫尔玛稍后
斯克特 佩瑞将跟我一道

00:00:38.572 --> 00:00:41.408 align:middle
为您展示今年
Core Data 中的新内容

00:00:43.177 --> 00:00:44.778 align:middle
不过 在我们进入正题之前

00:00:45.012 --> 00:00:47.381 align:middle
我想给大家讲一下什么是
Core Data

00:00:48.315 --> 00:00:52.819 align:middle
现在 你们中的很多已经开发了
这些很棒的有漂亮 UI 的 app

00:00:52.886 --> 00:00:55.322 align:middle
你们已经把它
与从外部数据源获取的

00:00:55.389 --> 00:00:57.858 align:middle
或者来自于提供给你们的

00:00:57.925 --> 00:00:59.226 align:middle
资源框架的数据结合起来

00:00:59.726 --> 00:01:02.029 align:middle
那么当你处理那些对象的时候

00:00:59.726 --> 00:01:02.029 align:middle
那么当你处理那些对象的时候

00:01:02.262 --> 00:01:06.767 align:middle
你将创建一个复杂的图形
并将所有的那些更改向UI传递

00:01:07.434 --> 00:01:09.837 align:middle
然后当你的用户
对 UI 做出更改的时候

00:01:09.903 --> 00:01:11.972 align:middle
您将把所有的那些改动
推送回到您的对象图

00:01:12.072 --> 00:01:16.076 align:middle
并推送回到您的数据源

00:01:16.143 --> 00:01:17.845 align:middle
那么 Core Data
让这个变得容易

00:01:18.679 --> 00:01:20.781 align:middle
Core Data
将为您管理对象图

00:01:21.682 --> 00:01:24.451 align:middle
简单告诉我们一点
关于您的 Cocoa 模型

00:01:24.685 --> 00:01:26.987 align:middle
以及对象模型编辑器的信息
告诉我们一点

00:01:27.054 --> 00:01:29.223 align:middle
关于您的对象和它们的属性的信息

00:01:29.590 --> 00:01:33.260 align:middle
以及它们的相互关系
而我们将负责剩下的工作

00:01:33.594 --> 00:01:37.631 align:middle
而且我们也将
在您选择的后台维持它

00:01:37.998 --> 00:01:41.368 align:middle
不管它是 SQLite
或是您自己设定的存储方式

00:01:42.469 --> 00:01:47.407 align:middle
于是 随着你不断导入对象
你的各种关系将发生改变

00:01:47.774 --> 00:01:49.943 align:middle
而Core Data
将为您维护这些关系

00:01:50.010 --> 00:01:52.446 align:middle
因此如果您在您的对象模型
设置任何通用删除规则

00:01:52.513 --> 00:01:55.082 align:middle
我们将删除一个对象

00:01:55.148 --> 00:01:57.317 align:middle
并将按照你的定义
根据规则统一删除

00:01:59.319 --> 00:02:03.423 align:middle
在你的对象图里
找到对象也是特别容易的

00:01:59.319 --> 00:02:03.423 align:middle
在你的对象图里
找到对象也是特别容易的

00:02:04.324 --> 00:02:06.493 align:middle
只须使用一个
NSFetchRequest

00:02:07.127 --> 00:02:08.662 align:middle
并赋给它一个 predicate

00:02:08.729 --> 00:02:10.430 align:middle
来找到你在寻找的对象

00:02:10.830 --> 00:02:12.399 align:middle
我们将为你扎到它们

00:02:13.734 --> 00:02:16.036 align:middle
批处理也很方便

00:02:16.770 --> 00:02:20.874 align:middle
这让你从读取请求得到的数据集里面

00:02:20.941 --> 00:02:23.777 align:middle
仅提取一小部分对象

00:02:24.278 --> 00:02:27.614 align:middle
让您在检查数据集的时候
需要处理的数据变少

00:02:27.681 --> 00:02:31.451 align:middle
此外
NSFetchRequest 的

00:02:31.618 --> 00:02:35.022 align:middle
另一个特性是关系的预读取

00:02:35.822 --> 00:02:39.593 align:middle
告诉我们一个需要读取的对象

00:02:39.660 --> 00:02:41.895 align:middle
我们会预读取所有与其相关的对象
所以当你遍历那一关系的时候

00:02:41.962 --> 00:02:44.865 align:middle
你将仍然在内存中进行

00:02:47.067 --> 00:02:50.070 align:middle
然后你只须把所有这些绑定到 UI

00:02:51.071 --> 00:02:54.041 align:middle
你把一个NSFetchResult
Controller

00:02:54.174 --> 00:02:56.376 align:middle
绑定到一个餐桌视图
就像我们这里所做的一样

00:02:56.944 --> 00:02:58.579 align:middle
而当我删除苹果酱时

00:02:59.012 --> 00:03:00.747 align:middle
我的 UI 会相应地更新

00:02:59.012 --> 00:03:00.747 align:middle
我的 UI 会相应地更新

00:03:01.882 --> 00:03:06.286 align:middle
然后当我插入更多对象时
我添加了香蕉面包

00:03:06.787 --> 00:03:08.689 align:middle
我的 UI 也会相应更新

00:03:09.356 --> 00:03:12.392 align:middle
这些都为你处理
所有的关键视图行为

00:03:12.693 --> 00:03:15.562 align:middle
以及更改通知 Core Data
都会为你进行处理

00:03:17.064 --> 00:03:18.866 align:middle
抱歉

00:03:19.833 --> 00:03:21.668 align:middle
不过可能有一种情况

00:03:22.069 --> 00:03:25.172 align:middle
您的用户正在主上下文操作一个对象

00:03:25.739 --> 00:03:30.410 align:middle
而在背景上下文
也在导入同样的新对象

00:03:30.477 --> 00:03:34.214 align:middle
而且可能正在更新目前用户

00:03:34.281 --> 00:03:35.449 align:middle
正在操作的对象

00:03:36.216 --> 00:03:38.652 align:middle
这就引入了“多写入者冲突”的概念

00:03:39.553 --> 00:03:42.289 align:middle
在 Core Data 中
这里它也为您进行了处理

00:03:42.990 --> 00:03:46.960 align:middle
我们为所有对象进行版本描述
并让您设定合并策略

00:03:47.728 --> 00:03:50.764 align:middle
如果您不舍得合并策略
我们将在您将其存入上下文时

00:03:50.831 --> 00:03:52.165 align:middle
默认出错

00:03:52.766 --> 00:03:55.202 align:middle
并提示您出现了冲突错误

00:03:55.769 --> 00:03:57.838 align:middle
让您以自己认为合适的方式
处理冲突

00:03:58.605 --> 00:04:01.241 align:middle
或者您可以从我们已提供的策略中

00:03:58.605 --> 00:04:01.241 align:middle
或者您可以从我们已提供的策略中

00:04:01.308 --> 00:04:02.543 align:middle
选择多个合并策略

00:04:02.776 --> 00:04:07.014 align:middle
不管它是在内存中
还是在持久存储中

00:04:07.080 --> 00:04:10.951 align:middle
不管是持久存储优于内存
还是相反

00:04:11.618 --> 00:04:14.087 align:middle
选择最适合您的
最适合您的特定情况的

00:04:15.455 --> 00:04:18.058 align:middle
一旦您选用了 Core Data
你会有几大好处

00:04:18.125 --> 00:04:20.560 align:middle
我要给特别大家讲两个

00:04:20.627 --> 00:04:22.963 align:middle
真正最大的好处

00:04:23.664 --> 00:04:27.401 align:middle
出色的内存可升级性以及
积极的延迟加载

00:04:28.135 --> 00:04:32.239 align:middle
那是什么意思呢？
就是说我们仅当您在内存中

00:04:32.472 --> 00:04:34.241 align:middle
需要那些对象的时候我们才加载它们

00:04:35.375 --> 00:04:38.745 align:middle
采用Core Data会导致
占用空间的大幅减小

00:04:39.513 --> 00:04:42.749 align:middle
您需要维护的代码
减少 50 到 70%

00:04:42.816 --> 00:04:44.685 align:middle
让您有更多的时间

00:04:44.751 --> 00:04:47.154 align:middle
开发您的 app 的新特性

00:04:48.088 --> 00:04:49.489 align:middle
然后您就可以加入

00:04:49.556 --> 00:04:51.491 align:middle
App Store中
已在使用Core Data的

00:04:51.558 --> 00:04:53.493 align:middle
40多万个 app 了

00:04:54.728 --> 00:04:56.463 align:middle
Core Data 的概述到此为止

00:04:57.431 --> 00:04:59.366 align:middle
现在让我们进入新内容

00:04:59.666 --> 00:05:01.535 align:middle
我们为您准备的所有新的 API

00:04:59.666 --> 00:05:01.535 align:middle
我们为您准备的所有新的 API

00:05:03.003 --> 00:05:05.706 align:middle
首先让我们从
NSManagedObject

00:05:06.440 --> 00:05:08.208 align:middle
和一个新的属性

00:05:08.275 --> 00:05:10.310 align:middle
hasPersistent
ChangedValues开始

00:05:12.045 --> 00:05:14.748 align:middle
以前您可能
已经用过hasChanges

00:05:14.982 --> 00:05:19.086 align:middle
这是一个相当基础的脏标志
如果你碰了这个对象

00:05:19.152 --> 00:05:20.821 align:middle
我们会将其
标志为脏的 dirty

00:05:20.888 --> 00:05:24.057 align:middle
但是通过
hasPersistentchangedValues

00:05:24.124 --> 00:05:27.928 align:middle
我们将确保对象的属性

00:05:27.995 --> 00:05:31.331 align:middle
与持久存储中的不同
确保您不会有任何误报

00:05:33.800 --> 00:05:37.171 align:middle
NSManagedObject
的新特性还包括

00:05:37.237 --> 00:05:39.406 align:middle
objectIDsFor
RelationshipNamed

00:05:39.940 --> 00:05:43.577 align:middle
这个非常适合用于大型关系

00:05:44.878 --> 00:05:47.714 align:middle
因为将不会在内存内
将整个关系实体化

00:05:47.781 --> 00:05:49.983 align:middle
而是会将已经归类的

00:05:50.050 --> 00:05:52.653 align:middle
一系列对象的ID返还给您

00:05:53.287 --> 00:05:56.390 align:middle
这让您能够以更小的规模
检查这些对象的ID

00:05:56.456 --> 00:05:58.225 align:middle
并且以处理您的更小的对象

00:05:58.992 --> 00:06:00.961 align:middle
让我快速地为您
展示一个代码示例

00:05:58.992 --> 00:06:00.961 align:middle
让我快速地为您
展示一个代码示例

00:06:02.763 --> 00:06:04.631 align:middle
这里是我的人物对象

00:06:04.698 --> 00:06:08.635 align:middle
而我请求它的关系对象
ID“family”

00:06:09.303 --> 00:06:11.872 align:middle
这会给我全部关系
然后我可以

00:06:11.939 --> 00:06:15.209 align:middle
去读取这些关系
每批 100 个

00:06:16.276 --> 00:06:18.979 align:middle
然后以每次100个的速度
遍历这些关系

00:06:19.046 --> 00:06:23.083 align:middle
这让我把向内存的输入
维持在相当小的水平

00:06:23.483 --> 00:06:24.852 align:middle
而且易于管理

00:06:26.486 --> 00:06:29.489 align:middle
让我们继续往下讲NSManaged
ObjectContext

00:06:30.057 --> 00:06:34.361 align:middle
和一个名为refresh
AllObjects的新方法

00:06:36.430 --> 00:06:39.666 align:middle
RefreshAllObjects
所做的事情和你料想的完全一样

00:06:39.733 --> 00:06:41.635 align:middle
它把您的上下文中的对象更新

00:06:42.302 --> 00:06:44.137 align:middle
但是保留未被保存的更改

00:06:44.204 --> 00:06:47.040 align:middle
而且与reset
on the context不同的是

00:06:47.107 --> 00:06:49.610 align:middle
您对对象的引用仍然有效

00:06:50.110 --> 00:06:52.713 align:middle
因此 您不必重取任何引用

00:06:52.779 --> 00:06:56.049 align:middle
而它最适合用于
打破可能已出现的循环引用

00:06:56.116 --> 00:06:59.086 align:middle
循环引用是当你
遍历一个双向关系时

00:06:59.152 --> 00:07:01.054 align:middle
你陷入循环中

00:06:59.152 --> 00:07:01.054 align:middle
你陷入循环中

00:07:02.923 --> 00:07:05.759 align:middle
此外NSManagedObjectContext的
新特性还包括：

00:07:06.159 --> 00:07:09.329 align:middle
对于那些在您的存储中
使用多个协调程序的朋友

00:07:10.364 --> 00:07:12.999 align:middle
MergeChangesFrom
RemoteContextSave

00:07:13.066 --> 00:07:16.904 align:middle
将从一个协调程序接收通知

00:07:16.970 --> 00:07:19.473 align:middle
并将其用于另一个
协调程序的上下文

00:07:20.007 --> 00:07:21.842 align:middle
这让您在您的上下文中
有最新的行数据

00:07:21.909 --> 00:07:25.279 align:middle
而我们将为您照看

00:07:25.345 --> 00:07:27.247 align:middle
所有必要的上下文

00:07:32.953 --> 00:07:35.322 align:middle
在 Core Data 中
偶尔你会遇到某个特别的例外

00:07:35.389 --> 00:07:37.357 align:middle
而那对于开发者

00:07:37.424 --> 00:07:38.692 align:middle
将是非常容易识别的

00:07:39.193 --> 00:07:41.061 align:middle
那就是无法加载某个错误

00:07:42.529 --> 00:07:44.831 align:middle
为什么Core Data
无法加载这个错误呢?

00:07:45.566 --> 00:07:48.468 align:middle
好了 正如我早些时候提到的
在延迟加载对象方面

00:07:48.535 --> 00:07:52.239 align:middle
Core Data 是非常积极的
您在内存中

00:07:52.306 --> 00:07:55.609 align:middle
将只有对象图中的一部分
而且当我们试图遍历一个关系时

00:07:55.676 --> 00:07:59.246 align:middle
我们将可以回到磁盘

00:07:59.646 --> 00:08:02.015 align:middle
并发现那个对象已经被删除了

00:07:59.646 --> 00:08:02.015 align:middle
并发现那个对象已经被删除了

00:08:03.483 --> 00:08:05.285 align:middle
什么是比遇到例外更好的事情？

00:08:05.485 --> 00:08:07.054 align:middle
有很多

00:08:07.154 --> 00:08:08.488 align:middle
我们已经在

00:08:08.555 --> 00:08:10.490 align:middle
NSManagedObjectContext
上面

00:08:10.557 --> 00:08:12.226 align:middle
推出了一个新的属性

00:08:12.292 --> 00:08:14.394 align:middle
它让你能够设置一些基础的

00:08:14.461 --> 00:08:16.563 align:middle
faultingDelegated
API

00:08:21.001 --> 00:08:21.935 align:middle
目前

00:08:22.002 --> 00:08:24.171 align:middle
shouldDelete
InaccessibleFaults

00:08:24.238 --> 00:08:25.506 align:middle
默认为 yes

00:08:25.806 --> 00:08:29.576 align:middle
如果我们遇到一个错误
我们将把它标记为deleted

00:08:30.077 --> 00:08:33.280 align:middle
而任何缺失的属性都将是null或0

00:08:33.847 --> 00:08:37.284 align:middle
这让您的app持续这一对象

00:08:37.717 --> 00:08:39.318 align:middle
并将其当作一个
已被删除的对象处理

00:08:40.120 --> 00:08:42.188 align:middle
您将不会再崩溃
但是您将可以继续下去

00:08:42.256 --> 00:08:47.361 align:middle
并且向用户展示
他们预期将会看到的东西

00:08:50.230 --> 00:08:51.098 align:middle
现在关于

00:08:51.164 --> 00:08:54.768 align:middle
NSPersistentStoreCoordinator

00:08:54.835 --> 00:08:56.970 align:middle
我们要介绍两个新的 API

00:08:58.372 --> 00:09:01.542 align:middle
我们推出了这两个新的API
是因为我们发现开发者

00:08:58.372 --> 00:09:01.542 align:middle
我们推出了这两个新的API
是因为我们发现开发者

00:09:01.642 --> 00:09:05.579 align:middle
在如何清理他们的
持久存储方面存在问题

00:09:06.413 --> 00:09:07.814 align:middle
你们中的一些人做过这样的事情

00:09:07.881 --> 00:09:10.717 align:middle
您已经经过或绕过
Core Data API 层

00:09:11.118 --> 00:09:12.986 align:middle
而直接操作你的数据库

00:09:13.887 --> 00:09:17.724 align:middle
不幸的是带来了意想不到的后果

00:09:18.492 --> 00:09:21.061 align:middle
您可能让坏卷描述符保持开放状态

00:09:21.762 --> 00:09:24.164 align:middle
所以我们为您提供了

00:09:24.698 --> 00:09:27.067 align:middle
destroyPersistentStoreAtURL

00:09:32.773 --> 00:09:34.808 align:middle
就像 addPersistent StoreAtURL
一样

00:09:34.875 --> 00:09:36.076 align:middle
你做出了同样的选择

00:09:36.343 --> 00:09:38.178 align:middle
而且你可以破坏那一持久存储区

00:09:38.712 --> 00:09:42.749 align:middle
而我们将遵守所有的锁定协议

00:09:42.816 --> 00:09:45.819 align:middle
并将所有相关文件清理出来
放到您已选择使用的

00:09:45.886 --> 00:09:46.887 align:middle
特定类型的存储区

00:09:47.688 --> 00:09:49.456 align:middle
以那种同样的方式

00:09:49.523 --> 00:09:52.793 align:middle
我们推出了
replacePersistentStoreAtURL

00:09:53.327 --> 00:09:56.897 align:middle
这和破坏的模式类似
而如果目标数据库并不存在

00:09:57.197 --> 00:10:00.133 align:middle
我们将只须把它复制到位即可

00:09:57.197 --> 00:10:00.133 align:middle
我们将只须把它复制到位即可

00:10:00.868 --> 00:10:04.872 align:middle
一个大家都曾遇到的问题是副本

00:10:06.039 --> 00:10:08.842 align:middle
一个带有副本的数据库是无用的

00:10:09.309 --> 00:10:10.677 align:middle
你已经写了大量的代码

00:10:10.911 --> 00:10:12.279 align:middle
来确保你没有副本

00:10:13.213 --> 00:10:15.516 align:middle
这里 Core Data
也可以帮你

00:10:16.517 --> 00:10:19.152 align:middle
首先让我们看下
为了发现副本

00:10:19.453 --> 00:10:20.654 align:middle
你们可能已用过的常见模式

00:10:21.154 --> 00:10:22.723 align:middle
即“寻找或创建”模式

00:10:23.924 --> 00:10:28.028 align:middle
在这里 如你所见
我建立了一个读取请求并且

00:10:28.095 --> 00:10:30.998 align:middle
我必须寻找一个特别的对象

00:10:31.064 --> 00:10:34.201 align:middle
看它是否存在
然后才能创建它

00:10:34.268 --> 00:10:36.436 align:middle
如果它确实存在 我就更新它

00:10:37.404 --> 00:10:41.108 align:middle
不过这种模式可能是相当有风险的
而且如果我有

00:10:41.475 --> 00:10:45.712 align:middle
来自于多个数据源的线程的话
它可能导致多个副本

00:10:46.480 --> 00:10:50.284 align:middle
而Core Data今年已为您
提供了保护

00:10:50.350 --> 00:10:53.320 align:middle
只须告诉我们在一个实体内的
哪些属性应是唯一的

00:10:53.587 --> 00:10:56.356 align:middle
我们就将确保该实体的所有实例

00:10:56.723 --> 00:11:00.227 align:middle
都保持那一唯一属性
不管它是电子邮件 零部件编号

00:10:56.723 --> 00:11:00.227 align:middle
都保持那一唯一属性
不管它是电子邮件 零部件编号

00:11:00.294 --> 00:11:02.863 align:middle
通用产品代码 等等
我们将确保它在

00:11:02.930 --> 00:11:04.431 align:middle
它在所有实例中都是唯一的

00:11:11.538 --> 00:11:16.009 align:middle
当唯一实例
唯一约束条件

00:11:16.410 --> 00:11:18.745 align:middle
被用于对象创建后的
未被修改的数值时

00:11:18.812 --> 00:11:21.315 align:middle
是最佳的

00:11:21.381 --> 00:11:24.418 align:middle
通常当你创建对象的时候
这些唯一约束条件

00:11:24.518 --> 00:11:27.087 align:middle
应被一次性设定
然后在对象存续期间永不更改

00:11:28.222 --> 00:11:31.625 align:middle
更改它们可能导致冲突

00:11:32.192 --> 00:11:35.362 align:middle
因为您的唯一属性可能会与

00:11:35.429 --> 00:11:37.197 align:middle
有同样的唯一属性的
另一个对象冲突

00:11:37.731 --> 00:11:40.367 align:middle
那时候您就可以使用我们之前

00:11:40.434 --> 00:11:42.669 align:middle
在合并策略中讲到的恢复方法

00:11:43.337 --> 00:11:44.371 align:middle
来解决那些问题

00:11:45.305 --> 00:11:49.276 align:middle
此外 任何从具有
唯一约束条件的父实体

00:11:49.343 --> 00:11:53.013 align:middle
继承的实体也将继续那些约束条件

00:11:53.714 --> 00:11:56.884 align:middle
在上面的例子中您可以看出
父实体有一个已被确认的

00:11:56.950 --> 00:11:59.119 align:middle
UUID约束条件
作为唯一约束条件

00:11:59.853 --> 00:12:03.857 align:middle
子实体已经添加了电子邮件

00:11:59.853 --> 00:12:03.857 align:middle
子实体已经添加了电子邮件

00:12:03.924 --> 00:12:05.559 align:middle
作为对其唯一约束条件的补充

00:12:07.895 --> 00:12:11.331 align:middle
现在我想为您快速展示一下

00:12:11.532 --> 00:12:13.600 align:middle
如何利用唯一约束条件

00:12:16.069 --> 00:12:19.373 align:middle
那么这里我们将使用食谱 app
我们前些年一直在为您展示

00:12:19.439 --> 00:12:23.043 align:middle
可以在开发者门户
将其下载

00:12:23.777 --> 00:12:26.680 align:middle
我们增加了一个新性能
即右下方的 import 导入

00:12:27.514 --> 00:12:30.117 align:middle
这让我可以导入任何我喜欢的

00:12:30.384 --> 00:12:31.852 align:middle
与苹果相关的食谱

00:12:33.420 --> 00:12:35.556 align:middle
这里我们回退
你看到我增加了

00:12:35.622 --> 00:12:39.660 align:middle
所有我喜欢的苹果食谱
然而我的 UI 并不是非常直观

00:12:39.726 --> 00:12:42.763 align:middle
用户在点击的时候

00:12:42.829 --> 00:12:44.831 align:middle
可能会怀疑哪里出错了

00:12:44.898 --> 00:12:47.301 align:middle
不幸的是他们已复制了他们的数据

00:12:50.470 --> 00:12:52.773 align:middle
这里我们可以有很大的改善

00:12:53.340 --> 00:12:55.876 align:middle
让我们回到 Xcode
并看一下我们的对象模型

00:12:56.777 --> 00:12:59.847 align:middle
而这里我们在设置我们的实体
我将选择一个食谱

00:13:02.382 --> 00:13:05.185 align:middle
而现在我这里有了一个新选择

00:13:05.252 --> 00:13:07.888 align:middle
就在右边
叫做 unique 唯一

00:13:08.655 --> 00:13:11.391 align:middle
这让我指定那些属性

00:13:11.458 --> 00:13:13.527 align:middle
对于这个特定实体
是唯一的

00:13:14.261 --> 00:13:17.364 align:middle
在此例中我们将有
源 ID 和永久性 ID

00:13:21.468 --> 00:13:24.371 align:middle
那么现在当我运行这个食谱app时

00:13:26.240 --> 00:13:28.108 align:middle
我们将看到我有一个原始清单

00:13:28.575 --> 00:13:32.479 align:middle
我可以把它导入
然后选择我的苹果食谱

00:13:32.980 --> 00:13:34.381 align:middle
但是我也缺乏耐心

00:13:34.448 --> 00:13:37.050 align:middle
没看到任何 UI
所以我不断点击

00:13:37.684 --> 00:13:41.688 align:middle
这次我们有了单一对象
代表它们全部

00:13:42.689 --> 00:13:45.826 align:middle
不必寻找或创建任何副本
任何代码

00:13:46.593 --> 00:13:49.730 align:middle
您的唯一约束条件确保了您的唯一性

00:13:57.671 --> 00:14:02.509 align:middle
然而有了所有那些副本并不是理想的

00:13:57.671 --> 00:14:02.509 align:middle
然而有了所有那些副本并不是理想的

00:14:03.377 --> 00:14:05.579 align:middle
删掉副本可能需要做大量工作

00:14:05.979 --> 00:14:07.781 align:middle
这时候就要
斯克特 佩瑞出场了

00:14:07.848 --> 00:14:09.616 align:middle
他将向我们展示
我们对此能做些什么

00:14:15.889 --> 00:14:16.723 align:middle
谢谢 瑞西！

00:14:18.058 --> 00:14:20.394 align:middle
那么假如您已经有了一个app

00:14:20.694 --> 00:14:22.496 align:middle
而且您已经有了所有这些
已被复制的数据

00:14:23.197 --> 00:14:25.199 align:middle
现在您必须把它们全部删除

00:14:25.866 --> 00:14:29.203 align:middle
今天您必须要做的是
将它们全部从内存中提取出来

00:14:29.670 --> 00:14:32.639 align:middle
抱歉 是从存储中...
一旦它们进入内存

00:14:32.706 --> 00:14:35.576 align:middle
你将它们标记以便删除
然后您必须将其

00:14:35.642 --> 00:14:37.811 align:middle
存储到持久性存储中
如果您有很多对象

00:14:37.878 --> 00:14:41.315 align:middle
您将不得不一次又一次地删除

00:14:41.682 --> 00:14:44.084 align:middle
以维持足够低的内存占用

00:14:44.151 --> 00:14:45.786 align:middle
让您的 app 维持活跃状态

00:14:47.020 --> 00:14:51.825 align:middle
若只是为了将它们删除
而将对象加载到内存中

00:14:51.892 --> 00:14:54.027 align:middle
似乎有点愚蠢

00:14:54.094 --> 00:14:56.630 align:middle
今年我们已推出了一种新的 API

00:14:56.697 --> 00:14:58.432 align:middle
它的形式是
NSBatchDeleteRequest

00:14:59.766 --> 00:15:01.668 align:middle
NSBatchDeleteRequest
的工作原理

00:14:59.766 --> 00:15:01.668 align:middle
NSBatchDeleteRequest
的工作原理

00:15:01.735 --> 00:15:03.437 align:middle
类似于
NSBatchUpdateRequest

00:15:03.670 --> 00:15:07.107 align:middle
在于它直接在持久性存储中发挥作用
而无须向内存中加载任何对象

00:15:08.308 --> 00:15:10.077 align:middle
你可以使用NSFetchRequest
的一个实例创建它

00:15:10.143 --> 00:15:14.181 align:middle
指定一个实体
一个或更多的存储

00:15:14.314 --> 00:15:19.353 align:middle
并使用predicate
来源或限制来分割数据

00:15:19.419 --> 00:15:22.322 align:middle
以您希望的任何方式

00:15:24.691 --> 00:15:26.627 align:middle
批删除请求会返回一个方框型

00:15:26.693 --> 00:15:28.729 align:middle
NSBatchDeletesResult

00:15:28.896 --> 00:15:30.731 align:middle
而你可以对请求进行配置

00:15:30.797 --> 00:15:33.534 align:middle
以便返回一个默认的成功或失败

00:15:34.067 --> 00:15:37.137 align:middle
被删除的对象的总数

00:15:37.204 --> 00:15:39.306 align:middle
或该方框中的对象的对象ID

00:15:41.608 --> 00:15:43.243 align:middle
这样的做法有几个限制

00:15:43.377 --> 00:15:45.145 align:middle
因为对象都没有被加载到内存中

00:15:45.579 --> 00:15:47.781 align:middle
更改并没有别反映到上下文中

00:15:47.848 --> 00:15:49.950 align:middle
而且您的验证规则都没有被运行

00:15:50.817 --> 00:15:54.054 align:middle
各种关系将被酌情删除或作废

00:15:54.121 --> 00:15:56.590 align:middle
但是那是你得到的所有保证

00:15:56.657 --> 00:15:58.292 align:middle
也有“无对象通知”

00:15:59.293 --> 00:16:02.062 align:middle
我们认为这对有大量副本的人们

00:15:59.293 --> 00:16:02.062 align:middle
我们认为这对有大量副本的人们

00:16:02.129 --> 00:16:03.797 align:middle
将确实是有帮助的

00:16:03.864 --> 00:16:05.599 align:middle
现在我想为大家展示它如何工作

00:16:10.037 --> 00:16:12.940 align:middle
那么我这里有同样的食谱 app

00:16:13.006 --> 00:16:14.374 align:middle
而且带有一份从我的经理那里
拷贝来的数据库

00:16:14.441 --> 00:16:18.579 align:middle
他说他的一个孩子拿到了它

00:16:18.645 --> 00:16:21.281 align:middle
并且添加了大量的食谱
比如数以千计

00:16:22.349 --> 00:16:24.451 align:middle
如果我们以旧的方法检查它

00:16:24.518 --> 00:16:28.856 align:middle
那么我们将只是用一个读取请求

00:16:28.922 --> 00:16:32.092 align:middle
读取我们想要删除的所有对象

00:16:32.726 --> 00:16:36.430 align:middle
然后对它们全部进行迭代
删除它们

00:16:36.530 --> 00:16:39.333 align:middle
然后以我们设置的
每批1000的规模

00:16:39.399 --> 00:16:41.368 align:middle
保存更改

00:16:41.869 --> 00:16:43.403 align:middle
如果您试着这么做

00:16:47.241 --> 00:16:51.211 align:middle
我们可以在这里的控制台看到
它会耗费一点时间

00:16:52.346 --> 00:16:53.380 align:middle
你可以看到我们在...

00:16:53.447 --> 00:16:54.781 align:middle
由于我们在进行
以成千上万计算的批处理

00:16:54.848 --> 00:16:58.218 align:middle
我们现在正在进行第一批
现在仍在进行中

00:17:00.320 --> 00:17:02.723 align:middle
这会耗费一点时间
我们将不会站在这里等着它

00:17:02.789 --> 00:17:07.327 align:middle
如果我们在一个合适的点闯入
我们可以强制停止app

00:17:09.229 --> 00:17:12.432 align:middle
并再次尝试使用批删除

00:17:15.969 --> 00:17:17.271 align:middle
让我们把这些删了

00:17:22.809 --> 00:17:25.546 align:middle
使用与我们之前使用的
同样的读取请求

00:17:25.612 --> 00:17:28.849 align:middle
建立一个重复删除请求
然后我们

00:17:28.916 --> 00:17:31.351 align:middle
将选择一个
计数器resultType

00:17:31.418 --> 00:17:33.220 align:middle
以便我能够看到
我们做了些什么

00:17:34.888 --> 00:17:35.923 align:middle
这里我们将执行它

00:17:35.989 --> 00:17:39.426 align:middle
它的代码少得多
而且只有一个执行请求

00:17:39.493 --> 00:17:41.461 align:middle
没有循环
没有与对象的互动

00:17:41.528 --> 00:17:43.063 align:middle
如果我们运行这段代码

00:17:47.801 --> 00:17:49.036 align:middle
...我们将回到这里

00:17:53.207 --> 00:17:56.677 align:middle
这里你可以看到
在查询语句中编辑器

00:17:56.743 --> 00:17:58.745 align:middle
建立了一个触发器
它删除了所有

00:17:58.812 --> 00:18:01.281 align:middle
需要被清理的关系
我们也就完成了这点工作

00:17:58.812 --> 00:18:01.281 align:middle
需要被清理的关系
我们也就完成了这点工作

00:18:03.517 --> 00:18:05.118 align:middle
回到下边简单地看一些食谱

00:18:05.185 --> 00:18:07.187 align:middle
那么现在我们就可以应用
这些唯一约束条件了

00:18:14.595 --> 00:18:16.597 align:middle
那就是
NSBatchDeleteRequest

00:18:18.131 --> 00:18:21.134 align:middle
接下来我想谈一下模型的版本控制
model versioning

00:18:22.135 --> 00:18:24.872 align:middle
当我们创建新版本的食谱app时

00:18:25.706 --> 00:18:27.541 align:middle
为了支持“导入”这一特性

00:18:27.608 --> 00:18:30.410 align:middle
我们不得不对食谱实体
添加两个属性

00:18:30.477 --> 00:18:33.647 align:middle
来源以及外部 ID
瑞西 早些时候给大家演示过了

00:18:34.348 --> 00:18:37.384 align:middle
在进行这个工作期间
我们打开了模型

00:18:37.451 --> 00:18:39.353 align:middle
添加了两个属性
然后构建并运行

00:18:39.419 --> 00:18:41.922 align:middle
我们立刻就遇到了错误

00:18:43.223 --> 00:18:44.858 align:middle
我突出显示了最重要的部分

00:18:45.392 --> 00:18:48.428 align:middle
我们遇到了一个迁移问题
因为版本已经发生了变化

00:18:48.495 --> 00:18:50.564 align:middle
但是我忘记加入
起初的源模型

00:18:50.631 --> 00:18:53.400 align:middle
因为我们就是在它基础上做出更改的

00:18:54.801 --> 00:18:57.004 align:middle
而为了创建新模型
而复制旧模型的模式

00:18:57.070 --> 00:18:58.472 align:middle
确实不方便

00:18:58.539 --> 00:18:59.673 align:middle
进行您的app的迭代

00:18:59.773 --> 00:19:02.776 align:middle
而如果您忘记将某个模型
部署到运行该版本的客户手中

00:18:59.773 --> 00:19:02.776 align:middle
而如果您忘记将某个模型
部署到运行该版本的客户手中

00:19:02.843 --> 00:19:04.578 align:middle
那确实是危险的

00:19:05.279 --> 00:19:09.416 align:middle
这似乎就是自动的轻量级迁移
为您发挥作用的时候了

00:19:10.350 --> 00:19:14.388 align:middle
现在我们的 iOS 9
和 OS X11

00:19:15.222 --> 00:19:16.490 align:middle
有模型缓存功能

00:19:17.524 --> 00:19:20.627 align:middle
不管你何时创建或迁移存储

00:19:20.694 --> 00:19:23.197 align:middle
或者仅是在新的 iOS 上

00:19:23.263 --> 00:19:26.667 align:middle
打开较旧的模型
用来创建它的受管理的对象模型

00:19:26.733 --> 00:19:30.871 align:middle
被缓存到存储内
并且当轻量级迁移任务

00:19:30.938 --> 00:19:32.773 align:middle
它们无法找到合适的源模型的时候

00:19:32.840 --> 00:19:36.610 align:middle
这可以作为一种最后一搏的尝试

00:19:45.185 --> 00:19:46.553 align:middle
有几个限制

00:19:46.620 --> 00:19:48.555 align:middle
这只适用于 SQLite 存储

00:19:48.789 --> 00:19:50.057 align:middle
而且对重量级迁移

00:19:50.123 --> 00:19:51.325 align:middle
不提供缓存版本

00:19:51.625 --> 00:19:54.094 align:middle
如果您在进行重量级迁移
那您就该让您的版本准备就绪

00:19:54.161 --> 00:19:58.198 align:middle
因为您需要知道您的迁移
是来自何方 去往何处

00:20:00.467 --> 00:20:03.403 align:middle
瑞西 稍早时谈到了
我们添加的 API

00:20:03.470 --> 00:20:05.405 align:middle
而我现在想谈的是一些变化

00:20:06.240 --> 00:20:08.742 align:middle
对于 iOS 9 和
iOS X 1010

00:20:08.809 --> 00:20:10.511 align:middle
Core Data采用了您已经在

00:20:10.577 --> 00:20:12.679 align:middle
Objective-C中看到的
所有语言特性

00:20:12.746 --> 00:20:14.147 align:middle
包括泛型和空值

00:20:14.548 --> 00:20:19.820 align:middle
我们也利用了一个调用的新属性
它让向下转换变得容易一些

00:20:20.454 --> 00:20:22.256 align:middle
您在其他讲座里面可能没有看到

00:20:22.322 --> 00:20:25.058 align:middle
但这对Core Data来说
确实是方便的

00:20:25.459 --> 00:20:28.128 align:middle
因为如果你正在
与一个对象类型ID互动

00:20:28.195 --> 00:20:31.465 align:middle
您可以将其向下转换
到甚至完全不适合的类型

00:20:31.932 --> 00:20:34.635 align:middle
你可以为某个类型设置属性

00:20:34.701 --> 00:20:37.538 align:middle
但是它只能被向下转换
到该种类型的子类型

00:20:39.072 --> 00:20:41.208 align:middle
这将会在编译器上为您的代码
增加很多安全性

00:20:41.775 --> 00:20:43.944 align:middle
因为当一个缓存似乎毫无意义时

00:20:44.011 --> 00:20:46.747 align:middle
它会限制发出警报

00:20:49.249 --> 00:20:51.919 align:middle
为了使用泛型
已生成的子类也已被更新

00:20:52.186 --> 00:20:54.521 align:middle
以便满足大量的关系
以及空值的需求

00:20:54.955 --> 00:20:56.423 align:middle
而且我们已经对子类的生成机制

00:20:56.490 --> 00:20:58.625 align:middle
做出了一些其他的更改

00:20:59.359 --> 00:21:04.364 align:middle
在 Xcode 6 中
您会有一个执行文件

00:20:59.359 --> 00:21:04.364 align:middle
在 Xcode 6 中
您会有一个执行文件

00:21:04.431 --> 00:21:07.201 align:middle
和一个头文件用于使用同时包含
Core Data声明

00:21:07.634 --> 00:21:11.905 align:middle
和放置您的所有代码的空位的
Objective-C

00:21:11.972 --> 00:21:14.908 align:middle
它被用过之后就被扔掉了

00:21:14.975 --> 00:21:17.511 align:middle
但是如果你更改了自己的版本

00:21:17.578 --> 00:21:19.279 align:middle
更新日期就会变得有些不方便

00:21:19.346 --> 00:21:21.882 align:middle
因此在 Xcode 7 中
我们增加了一个新的文件

00:21:23.584 --> 00:21:26.119 align:middle
这个文件是一个扩展或类别

00:21:26.186 --> 00:21:27.421 align:middle
取决于头文件中

00:21:27.487 --> 00:21:30.891 align:middle
包含所有你熟悉的声明的语言

00:21:32.926 --> 00:21:35.529 align:middle
那么现在 头文件
和执行文件是属于你自己的

00:21:35.596 --> 00:21:39.199 align:middle
不管你何时更新模型
你所需做的就是更新这个文件

00:21:48.942 --> 00:21:50.344 align:middle
关于变化就说那么多

00:21:50.878 --> 00:21:53.013 align:middle
我想谈一下我们弃用的东西

00:21:53.647 --> 00:21:56.250 align:middle
我们将在 iOs9 和
OS 1010 中

00:21:56.884 --> 00:21:59.019 align:middle
去掉confinementConcurrency

00:21:59.086 --> 00:22:01.421 align:middle
它已经被标为“弃用”
我们将在以后去掉它

00:21:59.086 --> 00:22:01.421 align:middle
它已经被标为“弃用”
我们将在以后去掉它

00:22:03.490 --> 00:22:06.593 align:middle
因为对于新的受管理的对象上下文

00:22:06.660 --> 00:22:10.063 align:middle
Confinement是默认行为
因此我们也已经将其弃用

00:22:10.797 --> 00:22:13.800 align:middle
因此未来您将使用
init concurrencyType

00:22:13.867 --> 00:22:15.269 align:middle
为您的上下文使用

00:22:15.335 --> 00:22:17.538 align:middle
专用队列或主队列

00:22:18.005 --> 00:22:18.906 align:middle
如果您已经

00:22:18.972 --> 00:22:23.043 align:middle
进行到了区块 API
这确实是一个不错的主义

00:22:23.110 --> 00:22:25.412 align:middle
封装操作大大简化了您对

00:22:25.479 --> 00:22:28.448 align:middle
自己的模型代码的推演而对Core
Data的并发性调试支持

00:22:28.515 --> 00:22:30.150 align:middle
也增强了很多

00:22:31.885 --> 00:22:35.255 align:middle
我强烈建议查看在线文稿

00:22:35.489 --> 00:22:38.292 align:middle
今年 Core Data
指南已被彻底更新

00:22:38.959 --> 00:22:41.028 align:middle
而 亞當·斯威夫特 也介绍了
区块 API

00:22:41.094 --> 00:22:42.863 align:middle
他在 WWDC 2011 中的

00:22:42.930 --> 00:22:44.264 align:middle
《Core Data on iOS
中的新内容》

00:22:44.331 --> 00:22:46.366 align:middle
讲得确实不错

00:22:47.301 --> 00:22:49.770 align:middle
最后我想谈一下性能

00:22:52.172 --> 00:22:55.709 align:middle
随着时间推移
我们开始为模型增加属性

00:22:56.810 --> 00:23:00.380 align:middle
由于这些年对我们的app不离不弃
您的用户携带的数据量在增大

00:22:56.810 --> 00:23:00.380 align:middle
由于这些年对我们的app不离不弃
您的用户携带的数据量在增大

00:23:00.447 --> 00:23:03.784 align:middle
而我们试图查询和显示数据的方式

00:23:03.851 --> 00:23:07.054 align:middle
也在变得更加有趣 更加先进

00:23:07.487 --> 00:23:09.923 align:middle
我们的 app 也在维持很快的速度

00:23:11.925 --> 00:23:14.962 align:middle
但是您怎样避免
突然出现性能问题呢？

00:23:15.963 --> 00:23:17.397 align:middle
在开发过程中
您处理的是

00:23:17.464 --> 00:23:19.266 align:middle
已知的可能较小的数据集

00:23:19.333 --> 00:23:20.534 align:middle
比您的客户将要处理的要小

00:23:20.734 --> 00:23:23.837 align:middle
而模拟器又比仅仅
维持设备运行所需快得多

00:23:24.638 --> 00:23:26.373 align:middle
尽管它对开发非常有帮助

00:23:27.107 --> 00:23:29.443 align:middle
用户将会使用带有生产数据的设备

00:23:30.744 --> 00:23:34.515 align:middle
幸运的是我们提供一些工具

00:23:35.682 --> 00:23:37.751 align:middle
让您发现能够表明性能问题的模式

00:23:37.818 --> 00:23:39.820 align:middle
因此在它们在您的客户手里
成为问题之前

00:23:39.887 --> 00:23:41.488 align:middle
您就可以解决它们

00:23:41.788 --> 00:23:44.858 align:middle
我想讲三个需要注意的事情

00:23:44.925 --> 00:23:47.160 align:middle
首先是关系错误

00:23:48.629 --> 00:23:50.564 align:middle
这是 Core Data 工具

00:23:51.598 --> 00:23:53.500 align:middle
我们刚刚运行了食谱 app

00:23:53.901 --> 00:23:58.539 align:middle
在缓存缺失的工具项目下
我们立刻看见

00:23:58.605 --> 00:24:02.409 align:middle
我们在三个想要显示的
对象上的缓存丢失了

00:23:58.605 --> 00:24:02.409 align:middle
我们在三个想要显示的
对象上的缓存丢失了

00:24:03.076 --> 00:24:06.513 align:middle
如果我们查看中间的那一列
我们会看到它们的食谱类型

00:24:07.981 --> 00:24:10.384 align:middle
而现在你还记得我们今年
开发这个食谱 app 时

00:24:10.450 --> 00:24:12.819 align:middle
我们对其进行了更新
以便让主列表视图

00:24:12.886 --> 00:24:14.721 align:middle
在显示食谱本身的同时
显示食谱的类型

00:24:14.788 --> 00:24:16.390 align:middle
但是我们从未更改读取请求

00:24:17.791 --> 00:24:19.660 align:middle
我们可以通过向我们用来查看

00:24:19.726 --> 00:24:21.161 align:middle
NSFetchResultsController
的

00:24:21.228 --> 00:24:22.429 align:middle
查询命令增加一个

00:24:22.496 --> 00:24:24.565 align:middle
relationshipKeypathsForPrefetching

00:24:24.631 --> 00:24:26.166 align:middle
来解决这个问题

00:24:27.100 --> 00:24:29.403 align:middle
现在 那些-那第一组

00:24:29.469 --> 00:24:31.872 align:middle
丢失的缓存将不再是个问题

00:24:32.172 --> 00:24:34.374 align:middle
如果我们回到同样的工具

00:24:34.441 --> 00:24:35.843 align:middle
并且在稍后时再看下app里面

00:24:35.909 --> 00:24:38.045 align:middle
我们可以看到
当我们查看一个食谱的详情时

00:24:38.111 --> 00:24:40.314 align:middle
我们也引发了几个

00:24:40.380 --> 00:24:41.682 align:middle
对数据库的查询

00:24:42.549 --> 00:24:47.254 align:middle
这是因为详情查询控制器
从列表获得模型对象

00:24:47.621 --> 00:24:50.123 align:middle
然后在详细视图里面我们显示

00:24:50.190 --> 00:24:51.792 align:middle
那个食谱中的所有原料

00:24:52.392 --> 00:24:53.727 align:middle
我们不能使用预读取操作

00:24:53.794 --> 00:24:55.796 align:middle
因为那样我们将预读取
列表视图中显示的

00:24:55.863 --> 00:24:57.865 align:middle
所有食谱的所有原料

00:24:57.931 --> 00:25:00.868 align:middle
在详细视图中
在控制器中

00:24:57.931 --> 00:25:00.868 align:middle
在详细视图中
在控制器中

00:25:01.168 --> 00:25:04.338 align:middle
我们必须执行另一个读取请求
以便让那些原料出现在内存中

00:25:04.671 --> 00:25:07.107 align:middle
现在我们已经将9个查询变成1个

00:25:07.174 --> 00:25:09.843 align:middle
而我们仍能在食谱上使用这一关系

00:25:09.910 --> 00:25:12.079 align:middle
对其遍历并且与它返回的数据集互动

00:25:12.145 --> 00:25:14.114 align:middle
因为数据是在多个对象间共享的

00:25:17.451 --> 00:25:20.721 align:middle
最后如果我们看一下
Core Data 工具视图中的

00:25:20.787 --> 00:25:23.824 align:middle
读取工具
我们可以看到

00:25:23.891 --> 00:25:27.895 align:middle
第一个读取请求花费的时间
超过了我们的预期

00:25:28.896 --> 00:25:31.164 align:middle
它读取了 85 个对象

00:25:31.598 --> 00:25:33.300 align:middle
当时我们只有 85 个对象

00:25:33.367 --> 00:25:35.903 align:middle
如果我们有3万个对象的话
就像我在的示范中演示的那样

00:25:35.969 --> 00:25:38.372 align:middle
这将确实是糟糕
app 甚至很可能不会启动

00:25:40.407 --> 00:25:44.278 align:middle
在 Mac Pro上
它花费了15 毫秒

00:25:45.212 --> 00:25:47.948 align:middle
那在 iOS 上会有大量的掉帧

00:25:48.348 --> 00:25:52.085 align:middle
那么为解决这个问题
我们能做的就是增加

00:25:52.152 --> 00:25:54.855 align:middle
我们向读取结果控制器
输入的读取请求的批的大小

00:25:54.922 --> 00:25:58.358 align:middle
以便让对象仅按显示的需要
从存储读取

00:25:59.359 --> 00:26:03.864 align:middle
我想展示的最后一项内容是...
sequence blocking

00:25:59.359 --> 00:26:03.864 align:middle
我想展示的最后一项内容是...
sequence blocking

00:26:05.132 --> 00:26:08.068 align:middle
如果您的读取确实复杂
且耗费大量时间

00:26:08.836 --> 00:26:11.939 align:middle
那么您可以通过在程序上
使用这个参数找到它们

00:26:12.005 --> 00:26:15.042 align:middle
而它会在您的读取请求
运行的同时

00:26:15.309 --> 00:26:20.180 align:middle
开始输出相关数据

00:26:20.280 --> 00:26:23.617 align:middle
这种情况下我们有一个查询
而它所花费的时间

00:26:23.684 --> 00:26:28.322 align:middle
大约是十分之一秒

00:26:28.388 --> 00:26:29.790 align:middle
返回了 85 行结果

00:26:30.290 --> 00:26:31.491 align:middle
那是相当慢的

00:26:31.558 --> 00:26:33.060 align:middle
我们将看一下如何做得更好

00:26:33.961 --> 00:26:35.762 align:middle
如果我们向控制台的更高处滚动

00:26:35.829 --> 00:26:37.998 align:middle
我们看到它输出了
我们正在使用的文件

00:26:38.432 --> 00:26:40.501 align:middle
我们可以使用
SQLite连接那个文件

00:26:40.567 --> 00:26:42.169 align:middle
以便弄清楚正在发生的情况

00:26:43.670 --> 00:26:44.838 align:middle
如果我们把查询粘贴进去

00:26:44.905 --> 00:26:46.874 align:middle
在 EXPLAIN QUERY
PLAN之后

00:26:46.940 --> 00:26:48.275 align:middle
SQlite将告诉我们
它将试图做些什么

00:26:48.342 --> 00:26:51.512 align:middle
以便用这个图表来回答我们的查询

00:26:52.813 --> 00:26:56.850 align:middle
这里有几个需要注意的事情

00:26:56.917 --> 00:26:59.319 align:middle
我们可以将其作为
衡量性能如何的度量指标

00:26:59.386 --> 00:27:03.323 align:middle
第一个是扫描表
扫描表就是说SQLite

00:26:59.386 --> 00:27:03.323 align:middle
第一个是扫描表
扫描表就是说SQLite

00:27:03.390 --> 00:27:07.427 align:middle
将触探每行内容 检查每行内容
以完成查询

00:27:08.095 --> 00:27:10.364 align:middle
而在食谱表里面
就像是稍早些时候一样

00:27:10.430 --> 00:27:12.599 align:middle
我们有 3 万行内容
而我们将进行两次检查

00:27:12.666 --> 00:27:14.134 align:middle
因此那将不会太快

00:27:14.201 --> 00:27:15.669 align:middle
我们将进行考查 让它变得更好

00:27:16.770 --> 00:27:19.806 align:middle
此外 我们还使用临时 B 树

00:27:20.374 --> 00:27:23.944 align:middle
在这一步 SQLite利用数据
创建其自身的内存架构

00:27:24.011 --> 00:27:28.348 align:middle
以便实现排序或快速搜索

00:27:30.317 --> 00:27:33.453 align:middle
现在使用临时 B-树
是因为这里的这个group by

00:27:33.720 --> 00:27:36.323 align:middle
如果我们更仔细地看一下

00:27:36.390 --> 00:27:38.825 align:middle
它是因为外部 ID 中的来源

00:27:39.893 --> 00:27:42.930 align:middle
通过使用复合索引
我们应能够让这个过程加快

00:27:43.430 --> 00:27:45.933 align:middle
在Core Data模型编辑器中
我们可以在这里的右侧

00:27:46.033 --> 00:27:47.568 align:middle
添加一个复合索引

00:27:50.137 --> 00:27:52.573 align:middle
现在如果我们退出 SQLite
重建我们的项目

00:27:52.739 --> 00:27:55.175 align:middle
执行迁移并且用SQLite连接
到新的数据库

00:27:55.242 --> 00:27:58.312 align:middle
我们会发现
我们正在使用索引

00:27:59.012 --> 00:28:02.583 align:middle
使用索引意味着搜索将会很快

00:27:59.012 --> 00:28:02.583 align:middle
使用索引意味着搜索将会很快

00:28:03.417 --> 00:28:06.753 align:middle
使用覆盖索引更快
这意味着那一步的结果

00:28:06.820 --> 00:28:09.423 align:middle
是按照下一步需要的
自然顺序排列的

00:28:09.990 --> 00:28:12.392 align:middle
因此我们已经
完全清除了临时 B 树

00:28:13.460 --> 00:28:15.829 align:middle
但我们仍有这个扫描表

00:28:17.130 --> 00:28:20.067 align:middle
在这种情况下
我们将匹配重复对象

00:28:20.133 --> 00:28:24.238 align:middle
这是我们在示范中使用的查询
目的是找到需要删除的对象

00:28:24.838 --> 00:28:27.641 align:middle
它必须扫描整个表格
它的速度是可以更快的

00:28:28.775 --> 00:28:31.745 align:middle
剩下的唯一要做的事是确保
我们不碰主线程

00:28:32.379 --> 00:28:34.581 align:middle
在此例中我们将使用
一个专用队列上下文

00:28:35.015 --> 00:28:38.785 align:middle
但是如果您打算创建某些复合数据

00:28:38.852 --> 00:28:40.854 align:middle
以便向用户展示

00:28:40.921 --> 00:28:42.823 align:middle
您可能希望使用这个同步读取请求

00:28:42.890 --> 00:28:45.058 align:middle
它将在主线程工作的时候
离开主线程

00:28:45.125 --> 00:28:46.960 align:middle
然后当得到结果的时候再返回

00:28:47.995 --> 00:28:50.397 align:middle
那么这些就是在您的 app 中
需要留意的三种主要模式

00:28:50.464 --> 00:28:52.099 align:middle
它们让您能够在性能问题

00:28:52.165 --> 00:28:55.235 align:middle
真正成为问题之前
解决它们

00:28:57.905 --> 00:29:00.174 align:middle
关于今年Core
Data中的新内容就讲到这里

00:28:57.905 --> 00:29:00.174 align:middle
关于今年Core
Data中的新内容就讲到这里

00:29:00.240 --> 00:29:02.075 align:middle
如果您发现任何问题
请将其提交

00:29:02.142 --> 00:29:04.478 align:middle
对立刻重新写出的示例app代码
有一个奖励

00:29:04.545 --> 00:29:06.880 align:middle
它的错误会最先得到修复

00:29:07.548 --> 00:29:09.149 align:middle
但是我们也有兴趣听到

00:29:09.216 --> 00:29:11.285 align:middle
你们希望在Core Data
中看到的东西

00:29:11.351 --> 00:29:13.787 align:middle
功能上的要求 改善方面的想法
而如我所言

00:29:13.854 --> 00:29:17.524 align:middle
今年的文稿指南已全部经过修改
因此如果您发现任何相关问题

00:29:17.591 --> 00:29:19.560 align:middle
我们也将乐于了解

00:29:20.794 --> 00:29:23.197 align:middle
如需更多信息
请访问开发者门户

00:29:23.864 --> 00:29:25.799 align:middle
我们的文稿以及示例代码

00:29:25.866 --> 00:29:28.802 align:middle
您可以在开发者论坛
或通过 DTS 获得支持

00:29:29.870 --> 00:29:30.971 align:middle
感谢您的莅临！
