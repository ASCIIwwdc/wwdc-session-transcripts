WEBVTT

00:00:19.753 --> 00:00:24.224 align:middle
构建基于文档的app

00:00:25.893 --> 00:00:26.727 align:middle
谢谢

00:00:29.963 --> 00:00:30.797 align:middle
下午好

00:00:31.131 --> 00:00:34.635 align:middle
我是迈克·赫斯一名来自iOS
Apps和框架团队的软件工程师

00:00:35.002 --> 00:00:36.737 align:middle
今天我和约翰尼斯·福特曼一起

00:00:36.837 --> 00:00:40.407 align:middle
在这里给大家讲讲怎样让
你的基于文档的app脱颖而出

00:00:41.708 --> 00:00:43.977 align:middle
今天我们给你们写了一些
示例代码会展示给你们

00:00:44.211 --> 00:00:48.682 align:middle
如何构建一个基于文档的
app的两个主要元件

00:00:50.384 --> 00:00:54.288 align:middle
首先我们要向你演示如何构建
一个很棒的“文档浏览器”

00:00:54.621 --> 00:00:57.491 align:middle
这样你的用户就可以很快
找到他们感兴趣的文档

00:00:57.558 --> 00:00:58.926 align:middle
需要处理的文档

00:01:00.360 --> 00:01:03.931 align:middle
其次我们要向你们演示如何
构建一个能够和文档正确进行交互

00:01:04.397 --> 00:01:09.670 align:middle
协调处理并发阅读程序和写入程序
比如iCloud驱动守护进程

00:01:09.736 --> 00:01:11.505 align:middle
这样一个很棒的文档编辑器

00:01:12.439 --> 00:01:14.374 align:middle
我们稍后会深入讲一下
iCloud驱动守护进程

00:01:14.741 --> 00:01:17.010 align:middle
首先我们来看看“文档浏览器”

00:01:18.912 --> 00:01:21.048 align:middle
那么什么是基于文档的app？

00:01:22.916 --> 00:01:26.620 align:middle
我们认为一个文档就是一个
单一的独立的实体

00:01:26.687 --> 00:01:30.657 align:middle
用户也把它理解为一个单一的实体

00:01:31.325 --> 00:01:34.394 align:middle
那么基于文档的app就是一个
能够管理这些文档列表、

00:01:34.461 --> 00:01:37.331 align:middle
把文档展示给用户以便用户对它们进行

00:01:37.397 --> 00:01:41.702 align:middle
查看 编辑 重命名的这样一个app

00:01:43.003 --> 00:01:45.472 align:middle
比如说Keynote
就可以对Keynote文档列表

00:01:45.539 --> 00:01:46.540 align:middle
进行管理

00:01:46.607 --> 00:01:51.378 align:middle
而Numbers这个应用程序就可以
管理Numbers电子表格文档列表

00:01:51.678 --> 00:01:55.415 align:middle
就连Garage Band也可以对
Garage Band歌曲文档进行管理

00:01:55.782 --> 00:01:59.520 align:middle
我们把这些都看作基于文档的app

00:02:01.255 --> 00:02:04.958 align:middle
现在我们就来深入讲一讲
我们如何构建我们的“文档浏览器”

00:02:06.493 --> 00:02:09.496 align:middle
一个很棒的“文档浏览器”
有四个主要元件

00:02:11.832 --> 00:02:14.101 align:middle
首先我们希望能够以对我们的用户

00:02:14.168 --> 00:02:16.737 align:middle
有意义的方式列出我们的
文档就像我们在这个

00:02:16.803 --> 00:02:20.240 align:middle
示例代码中这样根据文档名
对文档进行了分类

00:02:20.407 --> 00:02:23.644 align:middle
我们的用户就可以理解
我们的app的流程

00:02:25.546 --> 00:02:27.581 align:middle
其次我们认为你应该使用
缩略图这样文档可见性

00:02:27.648 --> 00:02:30.317 align:middle
可以很棒你的用户只需要一瞥

00:02:30.384 --> 00:02:34.354 align:middle
就可以快速找出他们感兴趣的文档

00:02:34.421 --> 00:02:36.023 align:middle
需要处理的文档

00:02:38.158 --> 00:02:41.161 align:middle
第三我们想要展示我们的
app中所有可用的文档

00:02:41.228 --> 00:02:44.565 align:middle
包括位于其它app的容器内的文档

00:02:44.631 --> 00:02:47.835 align:middle
比如示例中的这个文档它是位于

00:02:48.402 --> 00:02:51.605 align:middle
共享iCloud Drive容器上

00:02:53.207 --> 00:02:55.275 align:middle
第四，我们认为保存一个
最近访问的文档列表

00:02:55.342 --> 00:02:58.912 align:middle
是个不错的主意
这样用户就可以快速返回

00:02:59.513 --> 00:03:03.317 align:middle
他们当前正在处理的文档

00:02:59.513 --> 00:03:03.317 align:middle
他们当前正在处理的文档

00:03:05.953 --> 00:03:08.589 align:middle
现在我们看看怎样找出我们的

00:03:08.655 --> 00:03:10.324 align:middle
“文档浏览器”上的文档

00:03:12.826 --> 00:03:17.798 align:middle
一个笨办法可能是使用
NSFileManager尝试列出

00:03:17.865 --> 00:03:19.633 align:middle
你在云端的文档

00:03:19.933 --> 00:03:21.635 align:middle
但是这些结果是不完整的

00:03:23.537 --> 00:03:27.541 align:middle
比如说在iCloud有一个
文档的概念

00:03:27.975 --> 00:03:29.977 align:middle
文档位于那里 但是内容还没有实现

00:03:30.043 --> 00:03:32.679 align:middle
本地可见的文档就是说

00:03:32.746 --> 00:03:34.248 align:middle
还没有下载到磁盘上的文档

00:03:34.414 --> 00:03:37.551 align:middle
NSFileManager并不能
正确获得这些文档

00:03:38.819 --> 00:03:42.155 align:middle
此外如果你试图通过
NSFileManager来列出你的文档

00:03:42.589 --> 00:03:44.424 align:middle
那么外部文档就不会包括进来

00:03:44.658 --> 00:03:47.594 align:middle
那么你列出的也就不是你的app
可用的所有的文档

00:03:48.829 --> 00:03:49.997 align:middle
我们来快速看一下

00:03:51.098 --> 00:03:53.567 align:middle
假如说你用的是
NSFileManager API

00:03:55.936 --> 00:03:57.971 align:middle
如果你用的是NSFileManager
你可能会获得文档一

00:03:58.038 --> 00:04:00.174 align:middle
以及这里的文档二
它们都已经完整下载到了

00:03:58.038 --> 00:04:00.174 align:middle
以及这里的文档二
它们都已经完整下载到了

00:04:00.541 --> 00:04:03.477 align:middle
我们的app的容器的硬盘上

00:04:04.211 --> 00:04:06.613 align:middle
但是你遗漏了位于iCloud的

00:04:06.847 --> 00:04:08.982 align:middle
文档三这个文档

00:04:09.449 --> 00:04:13.620 align:middle
并且你也遗漏了位于另一个
app容器上的文档四

00:04:13.720 --> 00:04:17.824 align:middle
而我们的用户已经授予了你的
app访问那个文档的权限

00:04:18.291 --> 00:04:22.129 align:middle
因此当你列出你的文档时你肯定不会
想用NSFileManager API

00:04:23.697 --> 00:04:26.099 align:middle
你想用的肯定是
NSMetadataQuery

00:04:27.134 --> 00:04:30.070 align:middle
我们来看看
NSMetadataQuery的工作原理

00:04:31.638 --> 00:04:35.008 align:middle
NSMetadataQuery会
获得所有你的app可用的文档

00:04:35.609 --> 00:04:38.679 align:middle
包括位于iCloud的文档三

00:04:38.745 --> 00:04:42.149 align:middle
以及位于另一个app的容器
但是用户已经授权了我们的

00:04:42.216 --> 00:04:45.719 align:middle
app查看那个文档权限的文档四

00:04:46.520 --> 00:04:50.257 align:middle
重点要注意的是这里还有个文档五
同样位于另一个app的容器

00:04:50.457 --> 00:04:53.827 align:middle
但是用户并未授予我们的app
查看那个文档的权限

00:04:54.328 --> 00:04:57.664 align:middle
文档五并没有包括在
NSMetadataQuery结果中

00:04:57.731 --> 00:05:00.300 align:middle
因为如果我们把那个文档展示给用户

00:04:57.731 --> 00:05:00.300 align:middle
因为如果我们把那个文档展示给用户

00:05:00.367 --> 00:05:02.202 align:middle
那就构成了隐私泄漏

00:05:04.905 --> 00:05:06.840 align:middle
让我们用
NSMetadataQuery

00:05:06.907 --> 00:05:08.175 align:middle
找出我们位于云端的文档

00:05:10.210 --> 00:05:11.745 align:middle
那么流程是怎样的呢？

00:05:13.013 --> 00:05:15.883 align:middle
首先你要创建你的
NSMetadataQuery

00:05:17.384 --> 00:05:21.054 align:middle
然后NSMetadataQuery
就会经过一个初始收集阶段

00:05:21.188 --> 00:05:24.291 align:middle
列出所有当前对你的app可用的文档

00:05:26.360 --> 00:05:28.729 align:middle
初始收集阶段完成后

00:05:28.996 --> 00:05:31.965 align:middle
你会得到一条通知
然后你只需要在你的app的UI

00:05:32.032 --> 00:05:35.836 align:middle
主线程上把这些初始文档
显示出来就可以了

00:05:38.272 --> 00:05:40.874 align:middle
但是NSMetadataQuery
并不是到此就完事了

00:05:41.241 --> 00:05:45.112 align:middle
此外当云端状态发生变更时
你会收到更新通知

00:05:45.179 --> 00:05:48.315 align:middle
比如在这里
iCloud Drive守护程序

00:05:49.016 --> 00:05:52.119 align:middle
向我们的app的容器内下载了
一个新文档

00:05:52.186 --> 00:05:54.388 align:middle
我们就在我们的
NSMetadataQuery

00:05:54.454 --> 00:05:55.923 align:middle
上收到了关于这个文档的通知

00:05:58.125 --> 00:06:02.696 align:middle
然后你只需要计算变更动画

00:05:58.125 --> 00:06:02.696 align:middle
然后你只需要计算变更动画

00:06:02.763 --> 00:06:06.733 align:middle
比如在这里我们可能想要向
我们的CollectionView

00:06:07.100 --> 00:06:08.869 align:middle
插入一个
CollectionView单元

00:06:08.936 --> 00:06:12.773 align:middle
然后只需要把这个更新过的UI
显示在我们的主线程上

00:06:16.510 --> 00:06:18.412 align:middle
既然我们已经知道了
怎样找出我们的文档

00:06:18.478 --> 00:06:21.915 align:middle
我们再来看看怎样用文档缩略图

00:06:21.982 --> 00:06:23.584 align:middle
让我们的UI更棒

00:06:30.457 --> 00:06:35.796 align:middle
我们认为在你的UI显示缩略图
是一个不错的主意

00:06:36.430 --> 00:06:38.866 align:middle
因为它可以给你的用户提供视觉语境

00:06:39.766 --> 00:06:43.403 align:middle
这样你的用户只需要一瞥
就可以找到他们感兴趣的文档

00:06:43.470 --> 00:06:45.839 align:middle
需要处理的文档
因为他们有了不错的缩略图

00:06:45.939 --> 00:06:47.474 align:middle
他们就可以很快找到文档

00:06:48.775 --> 00:06:51.578 align:middle
iOS 9上有项新特性
会自动为你创建某些特定的

00:06:51.645 --> 00:06:54.581 align:middle
通用文档类型的缩略图

00:06:54.648 --> 00:06:57.551 align:middle
比如说大的图像文件举个例子

00:07:00.087 --> 00:07:02.923 align:middle
现在我们再来看看你加载你的缩略图

00:07:02.990 --> 00:07:06.627 align:middle
显示在你的app的UI的工作流程

00:07:07.861 --> 00:07:09.663 align:middle
这里要重点注意的是

00:07:09.730 --> 00:07:14.334 align:middle
加载缩略图涉及向内存中
加载数量可能很大的数据

00:07:14.968 --> 00:07:20.641 align:middle
可能会很慢因此加载你的缩略图数据时
你肯定不想阻塞你的主线程

00:07:21.708 --> 00:07:23.744 align:middle
首先让我们看一个工作
流程实例应该可以

00:07:24.311 --> 00:07:26.480 align:middle
这就是我们的示例代码app的
工作流程

00:07:27.948 --> 00:07:30.083 align:middle
首先在我们的示例代码中我们
有一个CollectionView

00:07:30.150 --> 00:07:33.687 align:middle
CollectionView让我们加载一个
CollectionView单元

00:07:34.755 --> 00:07:40.494 align:middle
我们要通过一个后台进程
安排读取缩略图

00:07:40.561 --> 00:07:42.763 align:middle
因为我们尚未缓存完毕缩略图

00:07:44.431 --> 00:07:47.668 align:middle
现在我们并不会等待完成读取缩略图

00:07:48.268 --> 00:07:51.205 align:middle
我们要立即返回一个带有占位图像的

00:07:51.271 --> 00:07:55.142 align:middle
CollectionView单元
这样用户就知道那里有图像

00:07:56.476 --> 00:08:00.080 align:middle
之后某个时间完成读取缩略图后

00:07:56.476 --> 00:08:00.080 align:middle
之后某个时间完成读取缩略图后

00:08:01.081 --> 00:08:03.383 align:middle
我们会通知我们的
CollectionView

00:08:03.450 --> 00:08:05.118 align:middle
需要重新加载那个单元

00:08:06.153 --> 00:08:10.224 align:middle
然后我们只要在我们的UI的
那个单元上显示我们的缩略图就可以了

00:08:12.793 --> 00:08:17.631 align:middle
好的 然我们已经知道了怎样找出
文档怎样用漂亮的缩略图

00:08:17.698 --> 00:08:20.934 align:middle
把它们显示出来
我们再来看看怎样管理最近列表

00:08:23.470 --> 00:08:25.772 align:middle
我们认为你可能想用最近列表

00:08:25.839 --> 00:08:29.610 align:middle
因为最近访问的文档通常就是用户

00:08:29.676 --> 00:08:32.578 align:middle
正在处理的文档

00:08:33.614 --> 00:08:37.384 align:middle
因此存储这些文档的这样
一个列表是个不错的主意

00:08:37.451 --> 00:08:39.486 align:middle
这样你的用户就可以快速返回文档中

00:08:41.989 --> 00:08:45.425 align:middle
同样地一个笨办法可能是
使用NSURLs来存储一个

00:08:45.492 --> 00:08:48.395 align:middle
最近访问的文档的最近列表

00:08:48.795 --> 00:08:51.431 align:middle
但是像之前NSFileManager
已经出现的那样

00:08:51.565 --> 00:08:53.534 align:middle
这样有很多缺陷

00:08:54.835 --> 00:08:56.203 align:middle
我们来快速看一下

00:08:57.471 --> 00:09:02.342 align:middle
假如说我们向最近访问的文档
存储一个NSURLs列表

00:08:57.471 --> 00:09:02.342 align:middle
假如说我们向最近访问的文档
存储一个NSURLs列表

00:09:02.910 --> 00:09:06.413 align:middle
但是在我们的app不运行时
iCloud Drive守护程序移动了文档

00:09:06.580 --> 00:09:09.616 align:middle
比如像这样移动到了一个新文件夹

00:09:11.185 --> 00:09:14.755 align:middle
现在NSURL就成了一个受损引用
没法解算我们的文档

00:09:14.988 --> 00:09:17.391 align:middle
在磁盘上更改后的位置

00:09:18.091 --> 00:09:22.162 align:middle
因此我们不能靠它来存储
我们的最近列表

00:09:24.231 --> 00:09:28.669 align:middle
存储最近列表的正确方法
是使用安全范围书签

00:09:30.170 --> 00:09:34.007 align:middle
这里如果我们向这个文档
存储了一个安全范围书签

00:09:34.575 --> 00:09:37.778 align:middle
而iCloud Drive
守护程序再次把这个文档

00:09:37.845 --> 00:09:42.783 align:middle
移动到了一个文件夹
那么书签就会自动更新

00:09:42.916 --> 00:09:46.954 align:middle
解算文档在磁盘上的新位置
因此当我们管理我们的最近列表时

00:09:47.020 --> 00:09:48.689 align:middle
我们应该使用安全范围书签

00:09:51.058 --> 00:09:53.594 align:middle
我想快速做个演示

00:09:54.161 --> 00:09:56.396 align:middle
看看我们如何管理我们的最近列表

00:09:56.496 --> 00:09:58.198 align:middle
如何加载缩略图

00:10:07.541 --> 00:10:09.610 align:middle
好的让我们在这里启动我们的示例代码

00:10:10.110 --> 00:10:12.379 align:middle
我们尚未向我们的app中加载缩略图

00:10:15.382 --> 00:10:19.219 align:middle
但是举例来说如果
我使用新的多任务处理

00:10:19.286 --> 00:10:22.322 align:middle
功能打开iCloud Drive
app 我们就可以看到

00:10:22.389 --> 00:10:24.258 align:middle
这些文档的缩略图已经在那里了

00:10:25.392 --> 00:10:29.029 align:middle
我们只需要加载它们
显示到我们的app的UI上即可

00:10:31.532 --> 00:10:33.734 align:middle
我们来看看它在代码中是什么样的

00:10:38.071 --> 00:10:42.276 align:middle
好的 首先我们来讲讲如何在代码中
管理我们的最近列表

00:10:46.313 --> 00:10:47.681 align:middle
这里有件重要的事情

00:10:49.650 --> 00:10:54.821 align:middle
当我们在这里保存对象时我们使用了

00:10:55.455 --> 00:10:59.793 align:middle
“标记带有选项数据”
的方法来进行标记

00:11:00.160 --> 00:11:04.398 align:middle
这里重要的是要传递
“适合标记文档”选项

00:11:04.665 --> 00:11:06.533 align:middle
这样我们就可以稍后进行解算

00:11:08.602 --> 00:11:10.470 align:middle
我们的app启动后我们使用书签

00:11:10.771 --> 00:11:15.742 align:middle
调用了“经由解算标记数据”
NSURL构造符方法

00:11:15.809 --> 00:11:19.313 align:middle
这是我们之前保存的
然后我们得到了一个URL

00:11:19.379 --> 00:11:22.416 align:middle
就是我们的文档在磁盘上的
更新后的位置

00:11:24.384 --> 00:11:27.721 align:middle
这里重要的是有了这个返回的URL

00:11:27.788 --> 00:11:30.791 align:middle
我们需要调用
“开始访问资源的安全范围”

00:11:31.191 --> 00:11:33.460 align:middle
防止这个文档是
另一个app的容器内的文档

00:11:33.527 --> 00:11:39.433 align:middle
否则我们就无法读取这个文档
因为...这个文档的读属性

00:11:39.666 --> 00:11:42.603 align:middle
因为这样就会让我们的沙盒

00:11:42.936 --> 00:11:44.705 align:middle
访问到这个文档

00:11:47.441 --> 00:11:51.311 align:middle
那么对于缩略图来说
我们已经为你在示例代码中

00:11:51.378 --> 00:11:55.949 align:middle
写好了这个很棒的缩略图缓存类

00:11:56.016 --> 00:11:59.720 align:middle
可以为我们的app缓存我们的缩略图

00:12:01.021 --> 00:12:03.423 align:middle
这会让我们如释重负

00:12:03.490 --> 00:12:06.727 align:middle
比如调度在后台进程中加载缩略图等等

00:12:06.793 --> 00:12:10.731 align:middle
然后通知我们的
CollectionView

00:12:10.797 --> 00:12:12.432 align:middle
我们需要重新加载单元

00:12:13.166 --> 00:12:14.902 align:middle
我们最后一个没有实现的

00:12:15.502 --> 00:12:17.171 align:middle
是这里的这个代码块

00:12:17.437 --> 00:12:20.641 align:middle
它会从磁盘上加载我们的缩略图

00:12:22.109 --> 00:12:24.711 align:middle
我们只需要在带有一个
缩略图字典键的URL上

00:12:24.778 --> 00:12:29.583 align:middle
调用“获取键的承诺项目资源值”
这个NSURL方法

00:12:30.350 --> 00:12:33.587 align:middle
然后我们就会得到一本缩略图字典

00:12:33.687 --> 00:12:37.357 align:middle
然后我们只需要从字典上抽出
UIImage然后把它返回到

00:12:37.958 --> 00:12:41.995 align:middle
我们的缩略图类这样我们就可以显示它

00:12:42.930 --> 00:12:46.900 align:middle
这里重要的是使用
“获取键的承诺项目资源值”

00:12:46.967 --> 00:12:49.336 align:middle
来代替“获取键的资源值”

00:12:49.837 --> 00:12:52.639 align:middle
因为文档可能还没有实现内容本地可用

00:12:53.040 --> 00:12:59.613 align:middle
这样即使尚未下载我们
也可以展示我们的缩略图

00:13:02.482 --> 00:13:05.485 align:middle
我们需要做的就是重新部署下

00:13:08.555 --> 00:13:10.591 align:middle
这样我们的app里就有了
一些很棒的缩略图

00:13:11.258 --> 00:13:14.761 align:middle
是在后台加载的这样当我们示例代码中

00:13:14.828 --> 00:13:17.865 align:middle
滚动时它们就不会阻塞我们的滚动

00:13:19.233 --> 00:13:20.400 align:middle
好的让我们回到幻灯片

00:13:27.541 --> 00:13:30.544 align:middle
关于构建一个“文档浏览器”
我们学到了什么？

00:13:32.179 --> 00:13:33.714 align:middle
首先我们学到了我们应该使用

00:13:33.780 --> 00:13:37.150 align:middle
NSMetadataQuery而
不是其它方法来找出我们的文档

00:13:37.217 --> 00:13:43.023 align:middle
这样我们就可以
找到所有我们的app可用的文档

00:13:44.458 --> 00:13:47.928 align:middle
其次我们学到了我们应该在
我们的app的UI展示缩略图

00:13:48.428 --> 00:13:50.631 align:middle
这样我们就可以构建一些很棒的UI

00:13:50.697 --> 00:13:53.600 align:middle
我们的用户也可以很快找到
他们正在处理的文档

00:13:54.535 --> 00:13:56.436 align:middle
最后我们学到了我们应该使用书签

00:13:56.503 --> 00:13:58.639 align:middle
而不是其它方法来存储我们的最近列表

00:13:58.705 --> 00:14:01.608 align:middle
这样用户就可以快速回到

00:13:58.705 --> 00:14:01.608 align:middle
这样用户就可以快速回到

00:14:01.675 --> 00:14:03.744 align:middle
他们正在处理的文档

00:14:04.378 --> 00:14:07.548 align:middle
那么我想请约翰尼斯·福特曼上台来

00:14:07.614 --> 00:14:09.716 align:middle
给你们讲讲如何构建文档编辑器

00:14:15.822 --> 00:14:16.657 align:middle
谢谢 迈克

00:14:17.991 --> 00:14:18.992 align:middle
迈克刚才向你们展示了

00:14:19.193 --> 00:14:22.563 align:middle
如何在你的应用程序内构建
一个漂亮的“文档浏览器”

00:14:23.130 --> 00:14:26.500 align:middle
当然这会让我们的app非常漂亮

00:14:26.633 --> 00:14:28.302 align:middle
但是同等重要的

00:14:28.368 --> 00:14:32.339 align:middle
甚至可能更重要的是你的应用程序中

00:14:32.406 --> 00:14:36.443 align:middle
你的用户可以加载编辑文档的那一部分

00:14:36.877 --> 00:14:40.113 align:middle
毕竟用户就是为了这个目的
而试图使用你的应用程序

00:14:41.281 --> 00:14:45.018 align:middle
在我们开始讲整个
加载写入变更文档之前

00:14:45.085 --> 00:14:48.889 align:middle
我们先来快速看看一个叫做

00:14:49.223 --> 00:14:51.658 align:middle
文件的协调性的概念

00:14:52.793 --> 00:14:54.761 align:middle
我在这里讲的是什么？

00:14:55.963 --> 00:15:01.635 align:middle
在我们新的现代
基于多任务处理的世界中

00:14:55.963 --> 00:15:01.635 align:middle
在我们新的现代
基于多任务处理的世界中

00:15:01.969 --> 00:15:06.540 align:middle
这个概念指的是多个
app访问显示同一文件

00:15:07.841 --> 00:15:11.211 align:middle
举个例子我们可以在iCloud
Drive app显示

00:15:11.578 --> 00:15:15.415 align:middle
你的文档容器内的全部
文件的概述的同时

00:15:16.083 --> 00:15:21.588 align:middle
让你的app运行并且
让用户编辑这个文档

00:15:22.856 --> 00:15:26.093 align:middle
或者还有一种更保守的方法

00:15:26.493 --> 00:15:30.464 align:middle
即使你的用户没有使用这个
两个在前多任务处理视图

00:15:30.531 --> 00:15:34.101 align:middle
也可能经常出现iCloud
Drive同步守护程序

00:15:34.601 --> 00:15:37.070 align:middle
可能想要访问这个文档进行云端同步

00:15:37.838 --> 00:15:44.044 align:middle
而同时你的用户正在编辑这个文档

00:15:44.111 --> 00:15:46.446 align:middle
实际上这是一种非常常见的情况

00:15:46.914 --> 00:15:49.650 align:middle
因为用户正在编辑这个文档

00:15:50.284 --> 00:15:52.586 align:middle
他们把这个文档保存到了磁盘

00:15:53.287 --> 00:15:56.190 align:middle
这个文档当然就发生了变化
因此iCloud Drive守护程序

00:15:56.523 --> 00:15:59.426 align:middle
就想确保它在云端也进行更新了

00:16:00.861 --> 00:16:05.866 align:middle
因此这是一种常见的情况

00:16:06.633 --> 00:16:10.137 align:middle
我们来看看你的用户正在磁盘上

00:16:10.204 --> 00:16:13.507 align:middle
编辑这个文档这一具体案例

00:16:14.341 --> 00:16:16.977 align:middle
当然你的app看起来正在运行中

00:16:17.578 --> 00:16:19.346 align:middle
用户正在进行编辑

00:16:19.913 --> 00:16:22.816 align:middle
同时你的应用程序正在

00:16:23.016 --> 00:16:29.056 align:middle
自动保存定期把这个文档写入磁盘

00:16:29.590 --> 00:16:31.859 align:middle
这样我们在某一时刻有一个写入操作

00:16:32.559 --> 00:16:35.762 align:middle
然后之后某个时刻我们又有用户编辑

00:16:36.196 --> 00:16:39.032 align:middle
变更文档的这样一个操作
然后我们又有一个写入操作

00:16:40.033 --> 00:16:43.136 align:middle
很好 我们假设在某个时刻
我们的用户充分利用了

00:16:43.637 --> 00:16:45.606 align:middle
这个多任务处理功能也就是说

00:16:45.672 --> 00:16:51.311 align:middle
当他们编辑这个文档时他们还同时

00:16:51.712 --> 00:16:53.413 align:middle
运行着另外一个应用程序

00:16:54.248 --> 00:16:57.684 align:middle
这个其它应用程序可能
之前对这个文档有一个引用

00:16:57.751 --> 00:17:01.555 align:middle
并不会立即进行状态恢复

00:16:57.751 --> 00:17:01.555 align:middle
并不会立即进行状态恢复

00:17:01.622 --> 00:17:05.559 align:middle
举例来说即试图从磁盘上读取这个文档

00:17:06.727 --> 00:17:11.031 align:middle
现在你可以看到这种情况很糟糕

00:17:11.598 --> 00:17:14.800 align:middle
因为当我们读取这个文档时同时还有

00:17:14.902 --> 00:17:16.737 align:middle
另外一个应用程序对它进行写入操作

00:17:17.738 --> 00:17:19.406 align:middle
这实际上就是我们的应用程序

00:17:19.873 --> 00:17:22.142 align:middle
我们得到的就是这个不一致的读取

00:17:22.542 --> 00:17:24.178 align:middle
当然这很不幸

00:17:24.778 --> 00:17:26.445 align:middle
我们正在写入这个文档但是同时

00:17:26.512 --> 00:17:28.382 align:middle
另一个应用程序又正在读取这个文档

00:17:29.049 --> 00:17:32.019 align:middle
数据仅仅写了一半到磁盘
另一半还没有写入

00:17:32.619 --> 00:17:35.189 align:middle
出现这种怪异的不一致的数据时

00:17:35.255 --> 00:17:37.090 align:middle
其它app可能就不知道应该怎么做

00:17:37.591 --> 00:17:38.759 align:middle
这种情况很糟糕

00:17:39.927 --> 00:17:43.830 align:middle
同样地即使我们设法挺了过去

00:17:44.264 --> 00:17:46.600 align:middle
我们第二次写入后别忘了

00:17:46.667 --> 00:17:49.436 align:middle
我们现在仍然正在第一个
应用程序中编辑这个文档

00:17:50.270 --> 00:17:54.842 align:middle
其它应用程序现在仍然
正在显示你的文档

00:17:55.809 --> 00:18:00.914 align:middle
其它应用程序现在正在
显示你的文档的旧版本

00:17:55.809 --> 00:18:00.914 align:middle
其它应用程序现在正在
显示你的文档的旧版本

00:18:00.981 --> 00:18:04.551 align:middle
我们就遇到了过时显示这样一个问题

00:18:05.953 --> 00:18:08.021 align:middle
当然出现这种情况很不幸

00:18:08.689 --> 00:18:11.758 align:middle
这里我们给你们准备了
两个方便的解决方法

00:18:12.693 --> 00:18:16.530 align:middle
首先我们有了这个文件的协调性的概念

00:18:17.631 --> 00:18:22.202 align:middle
文件的协调性是一种
分布式阅读程序/写入程序加锁机制

00:18:23.003 --> 00:18:26.740 align:middle
这就意味着
虽然任何时候多个阅读程序

00:18:26.807 --> 00:18:29.810 align:middle
都可以读取同一个文档
但是每次却只能有一个写入程序

00:18:30.344 --> 00:18:35.782 align:middle
这个写入程序会禁止
其它任何阅读程序进行读取

00:18:37.284 --> 00:18:39.620 align:middle
这就意味着如果我们的应用程序

00:18:39.686 --> 00:18:42.956 align:middle
就像使用UIDocument那样
使用正确的文件的协调性

00:18:43.423 --> 00:18:45.692 align:middle
这些机制就会生效

00:18:46.326 --> 00:18:51.532 align:middle
我们的读取操作就会被推迟到
我们的写入操作完成后

00:18:51.965 --> 00:18:54.601 align:middle
这样我们就能始终保持

00:18:55.202 --> 00:18:59.606 align:middle
这个文档一致的形象

00:19:00.307 --> 00:19:01.141 align:middle
非常棒

00:19:02.309 --> 00:19:05.245 align:middle
我向你们保证这里还有一个机制

00:19:05.546 --> 00:19:08.282 align:middle
这里的这个机制是
NSFilePresentation

00:19:09.249 --> 00:19:12.119 align:middle
NSFilePresentation
是一种分布式修改机制

00:19:12.920 --> 00:19:16.790 align:middle
这就意味着我们的文件的协调性会

00:19:17.157 --> 00:19:20.227 align:middle
自动告诉所有其它的文件提出器

00:19:20.294 --> 00:19:24.298 align:middle
你的文档已经登记过了已经写入了磁盘

00:19:24.865 --> 00:19:27.768 align:middle
文件提出器需要对自身进行更新

00:19:29.069 --> 00:19:32.005 align:middle
这样在我们的第二次写入后
我们就可以立即得到一个通知

00:19:32.072 --> 00:19:35.909 align:middle
我们就可以放心地更新我们的UI了

00:19:36.877 --> 00:19:43.884 align:middle
很好我们就是这样来确认我们的文档
总是保存一致的形象

00:19:44.418 --> 00:19:45.719 align:middle
但是文档是什么？

00:19:46.753 --> 00:19:49.456 align:middle
当然我们首先需要创建一些文档

00:19:49.523 --> 00:19:52.226 align:middle
这样才可以显示文档让用户编辑文档

00:19:52.726 --> 00:19:53.894 align:middle
我们来看看这个

00:19:54.795 --> 00:19:57.564 align:middle
我们创建这些文档的目的是什么？

00:19:57.865 --> 00:20:01.268 align:middle
让我们想象下
当我们实现我们的示例app时

00:19:57.865 --> 00:20:01.268 align:middle
让我们想象下
当我们实现我们的示例app时

00:20:01.335 --> 00:20:03.670 align:middle
我们在右上角有这样一个
小的“加号”按钮

00:20:04.071 --> 00:20:07.040 align:middle
这是个加号按钮用户点击下

00:20:07.107 --> 00:20:10.811 align:middle
我们可能会弹出一个
示例对话或是类似的东西

00:20:11.078 --> 00:20:14.014 align:middle
不过我们总会在某个时刻创建一个文档

00:20:14.581 --> 00:20:16.783 align:middle
在这里我们的主要目的是

00:20:17.084 --> 00:20:21.188 align:middle
给用户一个一致的显示

00:20:21.822 --> 00:20:23.857 align:middle
并且这个显示总是最新的

00:20:24.291 --> 00:20:28.228 align:middle
如果用户点击这个小加号按钮
那就没什么大用

00:20:28.629 --> 00:20:31.431 align:middle
我们现在并不会在我们的
“文档浏览器”内得到更新

00:20:31.498 --> 00:20:35.035 align:middle
用户就会困惑不解不知道发生了什么

00:20:35.102 --> 00:20:37.738 align:middle
用户可能会再点击几次这个加号按钮

00:20:37.804 --> 00:20:40.707 align:middle
现在我们有了五个不同的新文档
这可不太妙

00:20:40.941 --> 00:20:46.813 align:middle
如果不使用文件的协调性
我们最后就可能出现

00:20:47.447 --> 00:20:51.752 align:middle
现在这种情况当然了这是因为...

00:20:51.818 --> 00:20:54.254 align:middle
这就意味着我们在
磁盘上创建了一个文档

00:20:55.088 --> 00:20:57.724 align:middle
之后某个时刻iCloud
Drive守护程序注意到了

00:20:57.991 --> 00:21:01.895 align:middle
这个新文档然后通知我们的app

00:20:57.991 --> 00:21:01.895 align:middle
这个新文档然后通知我们的app

00:21:01.962 --> 00:21:06.233 align:middle
这个延迟可能在半秒左右

00:21:06.300 --> 00:21:08.669 align:middle
如果守护程序现在正忙
延迟时间可能会更长

00:21:09.503 --> 00:21:12.339 align:middle
我们正是想要避免这种延迟

00:21:13.006 --> 00:21:17.144 align:middle
如果你使用文件的协调性
那现在就很方便了

00:21:17.611 --> 00:21:19.613 align:middle
会直接替你完成

00:21:20.814 --> 00:21:25.853 align:middle
协同运行会与你用来
在你的浏览器中显示文档的

00:21:26.119 --> 00:21:28.522 align:middle
NSMetadataQuery一起

00:21:28.589 --> 00:21:34.628 align:middle
协力也就是在协调完成后

00:21:34.695 --> 00:21:37.598 align:middle
进行回路循环立即告诉

00:21:38.031 --> 00:21:40.300 align:middle
你正在运行的查询出现了

00:21:40.868 --> 00:21:43.036 align:middle
一个新的更新后的文档

00:21:44.338 --> 00:21:46.874 align:middle
这样我们就干掉了这个令人厌恶的延迟

00:21:48.308 --> 00:21:50.711 align:middle
当然这里还是要提醒你们一件事

00:21:51.311 --> 00:21:53.714 align:middle
因为我们是在磁盘上进行写入

00:21:54.214 --> 00:21:57.551 align:middle
无论我们往磁盘上写入什么都需要时间

00:21:58.619 --> 00:22:03.090 align:middle
当然了在主线程上执行任何需要

00:21:58.619 --> 00:22:03.090 align:middle
当然了在主线程上执行任何需要

00:22:03.156 --> 00:22:06.093 align:middle
时间的操作都很不幸

00:22:06.159 --> 00:22:09.363 align:middle
因为它会阻塞主线程
让你的应用程序在用户看来

00:22:09.429 --> 00:22:11.632 align:middle
就像成了一个结巴

00:22:15.936 --> 00:22:18.605 align:middle
当然了解决这个也很容易

00:22:19.173 --> 00:22:20.607 align:middle
我们要使用一个后台进程

00:22:20.674 --> 00:22:25.712 align:middle
来发送这一协同运行来确保

00:22:25.979 --> 00:22:31.518 align:middle
我们的操作不会阻塞主线程

00:22:32.352 --> 00:22:34.154 align:middle
幸运的是我们仍然...

00:22:34.221 --> 00:22:36.056 align:middle
因为我们仍然在用这个协同运行

00:22:36.623 --> 00:22:40.928 align:middle
我们就仍然可以在我们的UI
上得到立即更新的显示

00:22:40.994 --> 00:22:44.331 align:middle
这是因为我们的
NSMetadataQuery

00:22:44.798 --> 00:22:46.333 align:middle
仍然是直接更新的

00:22:47.234 --> 00:22:49.436 align:middle
你甚至都不需要把这个信息
弹回给主线程

00:22:49.503 --> 00:22:51.405 align:middle
这是因为我们是在直接更新

00:22:51.471 --> 00:22:53.040 align:middle
NSMetadataQuery

00:22:54.374 --> 00:22:59.046 align:middle
很好 另一个常用的
操作是删除某个文档

00:23:00.180 --> 00:23:03.317 align:middle
对于你的用户来说
这是再正常不过的事

00:23:03.383 --> 00:23:05.752 align:middle
这个文档他们不用了
他们想把这个文档删掉

00:23:06.119 --> 00:23:07.688 align:middle
这样就不会弄乱他们的工作区

00:23:08.255 --> 00:23:12.226 align:middle
删除文档背后的基本理念
仍然是一模一样的

00:23:12.926 --> 00:23:17.664 align:middle
我们会通过我们的后台线程
协调某个写入操作

00:23:17.998 --> 00:23:21.902 align:middle
在本次写入时执行删除操作然后通过
NSMetadataQuery

00:23:21.969 --> 00:23:27.040 align:middle
回送给主线程及时进行更新

00:23:29.042 --> 00:23:35.983 align:middle
很好 你就是这样通过你们的
后台进程对创建删除文档进行管理的

00:23:36.984 --> 00:23:42.256 align:middle
我们来看看你到底想用这些文档干什么

00:23:42.956 --> 00:23:45.726 align:middle
当然你想显示这些文档

00:23:46.493 --> 00:23:48.562 align:middle
也就是说你想读写这些文档

00:23:49.396 --> 00:23:52.666 align:middle
现在我们强烈推荐你使用

00:23:52.733 --> 00:23:55.502 align:middle
UIDocument来读写文档

00:23:56.036 --> 00:24:00.841 align:middle
UIDocument会实现
NSFileCoordination调用

00:23:56.036 --> 00:24:00.841 align:middle
UIDocument会实现
NSFileCoordination调用

00:24:01.008 --> 00:24:03.977 align:middle
这样可以确保你在任何时候
进行读写文档时

00:24:04.044 --> 00:24:06.046 align:middle
都是以一种协调的方式进行

00:24:07.314 --> 00:24:12.119 align:middle
此外它还会实现
NSFilePresentation

00:24:12.319 --> 00:24:13.987 align:middle
确保会立即通知这个文档发生了变更

00:24:14.054 --> 00:24:17.591 align:middle
可以在你的显示中立即更新了

00:24:19.026 --> 00:24:20.928 align:middle
我们来看看怎样读取一个文档

00:24:21.662 --> 00:24:25.332 align:middle
你创建一个UIDocument对象
然后在这个UIDocument实例中

00:24:25.399 --> 00:24:28.302 align:middle
简单调用这个“完成后打开”方法

00:24:29.203 --> 00:24:32.973 align:middle
这种方法会通过一个后台工作队列

00:24:33.674 --> 00:24:35.375 align:middle
取出一个协调读取

00:24:36.510 --> 00:24:40.147 align:middle
这样你的应用程序就可以保持
完美的性能和响应性

00:24:40.981 --> 00:24:44.818 align:middle
同时你的文档可以对自身进行读入

00:24:45.652 --> 00:24:49.523 align:middle
那么现在你需要做的

00:24:49.823 --> 00:24:52.292 align:middle
就是实现“通过内容载入”这个方法

00:24:53.293 --> 00:24:55.662 align:middle
这种方法会在协调读入中简单调用

00:24:55.829 --> 00:24:58.298 align:middle
因此就被这个协调读入给封装了

00:24:58.398 --> 00:25:01.602 align:middle
这就意味着在那里
读入任何你想要的东西

00:24:58.398 --> 00:25:01.602 align:middle
这就意味着在那里
读入任何你想要的东西

00:25:01.668 --> 00:25:05.305 align:middle
都是绝对安全的
请听清楚是来自那个文档

00:25:06.139 --> 00:25:09.843 align:middle
那么你需要做的就是取出内容

00:25:09.910 --> 00:25:13.814 align:middle
然后把它们填入你的文档数据

00:25:14.448 --> 00:25:17.885 align:middle
现在这里还有一种方法

00:25:18.118 --> 00:25:20.521 align:middle
你也可以选择实现这种方法

00:25:21.522 --> 00:25:25.893 align:middle
它会取出一个
NSURL而不是一大堆数据

00:25:26.727 --> 00:25:30.430 align:middle
你也可以把这个方法用于
举例来说流文档

00:25:30.497 --> 00:25:34.935 align:middle
有时候你可能更有理由这么做

00:25:35.502 --> 00:25:40.240 align:middle
这是因为举例来说磁盘上的文档格式
与你在内存中想要的格式完全不同

00:25:41.208 --> 00:25:44.778 align:middle
完成后我们只需要回送给主队列

00:25:44.845 --> 00:25:48.815 align:middle
然后调用你提供给我们的完成块

00:25:49.249 --> 00:25:53.620 align:middle
在那个完成块中你可以举例来说

00:25:53.687 --> 00:25:57.491 align:middle
为你的文档推送更新你的新界面

00:26:00.227 --> 00:26:03.397 align:middle
很好读入一个文档的原理就是这样的

00:26:03.897 --> 00:26:06.967 align:middle
不过别忘了麦克告诉过你们

00:26:07.034 --> 00:26:09.036 align:middle
这个概念叫做“约定”

00:26:09.770 --> 00:26:16.109 align:middle
一项“约定”指的是iCloud
Drive守护程序允诺给你的app

00:26:16.410 --> 00:26:20.681 align:middle
某个文档就在那里
但是还没有进行下载

00:26:21.949 --> 00:26:24.084 align:middle
这就意味着对这个文档进行读入

00:26:24.151 --> 00:26:26.320 align:middle
就可能会触发一次下载

00:26:27.688 --> 00:26:32.025 align:middle
当然了如果你像我们一样

00:26:32.092 --> 00:26:38.165 align:middle
生活在真实的世界中
很明显下载有时候会很慢

00:26:38.465 --> 00:26:41.768 align:middle
依据你的文档大小下载可能

00:26:42.269 --> 00:26:43.370 align:middle
需要一段时间

00:26:43.971 --> 00:26:49.409 align:middle
你的用户可能把这次下载
归咎于你的app出了问题

00:26:49.710 --> 00:26:51.879 align:middle
这很不公平这不是你的错

00:26:52.479 --> 00:26:56.917 align:middle
本次下载所处的网络连接很慢
需要一点时间

00:26:57.684 --> 00:27:02.723 align:middle
我们在iOS 9中为你准备了一项
新特性我们公开了一种通过

00:26:57.684 --> 00:27:02.723 align:middle
我们在iOS 9中为你准备了一项
新特性我们公开了一种通过

00:27:02.789 --> 00:27:05.759 align:middle
新的
NSProgressReporting协议

00:27:06.126 --> 00:27:09.663 align:middle
在UIDocuments上显示
进度的方法

00:27:10.697 --> 00:27:12.633 align:middle
实现这个非常简单

00:27:13.133 --> 00:27:18.639 align:middle
NSProgressReporting协议在你的
UIDocument实例上公开了一项

00:27:19.173 --> 00:27:24.878 align:middle
进度属性这项进度属性是我们填写的
显示给你我们的进度如何了

00:27:25.546 --> 00:27:29.116 align:middle
基本上这就是下载状态的
一项简单的百分比

00:27:30.350 --> 00:27:35.989 align:middle
我们现在通过一个状态变换
公开了这项NSProgress属性

00:27:36.390 --> 00:27:39.993 align:middle
这样你就可以把它显示为
你在你的文档状态上

00:27:40.894 --> 00:27:44.831 align:middle
监听到的状态变换通知

00:27:46.133 --> 00:27:50.304 align:middle
当状态发生变换时你就可以
看到带有下列内容的新标志

00:27:50.571 --> 00:27:53.040 align:middle
“你好我在这里公开了一条进度”

00:27:54.007 --> 00:27:55.809 align:middle
然后你只要显示这个进度就可以了

00:27:56.510 --> 00:28:00.314 align:middle
举例来说在一个
UIProgress视图上显示一个进度

00:27:56.510 --> 00:28:00.314 align:middle
举例来说在一个
UIProgress视图上显示一个进度

00:28:00.614 --> 00:28:02.449 align:middle
过去往往比较复杂

00:28:02.883 --> 00:28:05.018 align:middle
这是因为它公开了一项
你需要把值观测键入

00:28:05.085 --> 00:28:08.722 align:middle
这个进度视图的属性

00:28:09.389 --> 00:28:13.627 align:middle
当然我们也意识到了这一点
还是在iOS 9上

00:28:13.861 --> 00:28:17.097 align:middle
我们在UIProgress视图新公
开了一项观测进度属性

00:28:17.698 --> 00:28:23.237 align:middle
你就可以直接把NSProgress
弄到进度视图

00:28:23.770 --> 00:28:25.606 align:middle
你只需要把
NSProgress分配给

00:28:25.873 --> 00:28:28.375 align:middle
进度视图的“观测进度”属性

00:28:29.076 --> 00:28:31.879 align:middle
它就会自动更新它的计数

00:28:33.514 --> 00:28:35.048 align:middle
对你来说这非常方便

00:28:38.252 --> 00:28:43.123 align:middle
谢谢 那么你只需要监听
下次状态变换

00:28:43.223 --> 00:28:47.861 align:middle
监听这样的信号：
“你好我们把这个进度搞完了”

00:28:48.729 --> 00:28:53.433 align:middle
此时你可能想取消显示你的
UIProgress视图

00:28:53.834 --> 00:28:57.237 align:middle
准备显示新的文档控制器

00:28:58.872 --> 00:29:01.675 align:middle
很好 这就是读入文档

00:28:58.872 --> 00:29:01.675 align:middle
很好 这就是读入文档

00:29:01.875 --> 00:29:03.710 align:middle
当然我们还想写入文档

00:29:04.344 --> 00:29:08.048 align:middle
写入文档和读入文档是对称的

00:29:08.715 --> 00:29:12.085 align:middle
我们写入文档的方式
就是在一条后台进程上

00:29:12.152 --> 00:29:15.122 align:middle
取出一个协调文件的协调性

00:29:15.923 --> 00:29:19.526 align:middle
这个略微有点不同不是由你来启动它

00:29:19.993 --> 00:29:23.597 align:middle
而是由UIDocument
自动通知说现在非常适合

00:29:24.164 --> 00:29:27.835 align:middle
保存文档

00:29:28.135 --> 00:29:31.905 align:middle
比如说因为有一阵没有编辑进来

00:29:31.972 --> 00:29:36.543 align:middle
或者因为文档上次保存后
已经过去了一段时间

00:29:37.611 --> 00:29:40.647 align:middle
或者因为用户把你的
应用程序放到了后台

00:29:40.714 --> 00:29:43.450 align:middle
那么这个时候保存文档就非常合适

00:29:44.117 --> 00:29:47.688 align:middle
不过这种实现方式
和读入一个文档是非常

00:29:47.754 --> 00:29:51.091 align:middle
对称的我们只需要在
你的UIDocument实例上

00:29:51.158 --> 00:29:52.759 align:middle
调用“类型内容”

00:29:53.160 --> 00:29:56.830 align:middle
然后你把你从那里返回的
NSData实例填进去

00:29:57.865 --> 00:30:00.534 align:middle
非常好 这里还有一件事

00:29:57.865 --> 00:30:00.534 align:middle
非常好 这里还有一件事

00:30:00.834 --> 00:30:04.004 align:middle
此时写入一幅缩略图也非常方便

00:30:04.771 --> 00:30:08.375 align:middle
正如麦克告诉你们的
我们会为某些非常特定的文档

00:30:08.642 --> 00:30:12.980 align:middle
格式自动生成缩略图
不过有很大几率你正在构建的东西

00:30:13.046 --> 00:30:16.149 align:middle
和我们正在构建的东西并不完全一致

00:30:16.683 --> 00:30:21.421 align:middle
因此如果你没有使用我们的
非常通用的格式来

00:30:21.488 --> 00:30:25.526 align:middle
进行构建像图像或者简单文本

00:30:25.959 --> 00:30:28.896 align:middle
那么你就想自己写入缩略图

00:30:29.930 --> 00:30:32.466 align:middle
现在你这样实现的方式

00:30:32.533 --> 00:30:35.068 align:middle
我们称之为在
你的UIDocument上

00:30:35.135 --> 00:30:37.871 align:middle
“自行写入文件属性”方法

00:30:39.039 --> 00:30:42.676 align:middle
使用这种方法
你只需要当成你的属性字典的一部分

00:30:42.943 --> 00:30:45.078 align:middle
返回一个UIImage实例

00:30:46.280 --> 00:30:48.215 align:middle
在这个实例中我们会在写入你的文档

00:30:49.116 --> 00:30:53.520 align:middle
包含于同一协调写入上进行写入

00:30:54.188 --> 00:30:56.390 align:middle
这就意味着如果此时用户

00:30:56.456 --> 00:31:01.762 align:middle
在一个单独的窗格中打开了
“文档浏览器”

00:30:56.456 --> 00:31:01.762 align:middle
在一个单独的窗格中打开了
“文档浏览器”

00:31:02.196 --> 00:31:04.331 align:middle
他们就不会看到不一致的状态

00:31:05.098 --> 00:31:10.270 align:middle
很好 这里重点需要记住的是
这是在一条后台进程上调用的

00:31:10.971 --> 00:31:14.007 align:middle
这就意味着在任何情况下

00:31:14.074 --> 00:31:17.678 align:middle
你都不能用UIViews
来写入...来渲染你的缩略图

00:31:18.212 --> 00:31:21.148 align:middle
UIViews不属于线程安全
因此你需要确保你的缩略图

00:31:21.481 --> 00:31:23.717 align:middle
渲染是通过举例来说

00:31:24.218 --> 00:31:28.088 align:middle
Core Graphics
或者textKit

00:31:28.455 --> 00:31:33.060 align:middle
或者任何其它我们在我们的
平台上提供的线程安全渲染机制来进行

00:31:33.293 --> 00:31:38.532 align:middle
在iOS 8上访问一个文档的
唯一机制是通过一个副本来访问

00:31:39.299 --> 00:31:42.169 align:middle
原因在于一般来说应用程序

00:31:42.236 --> 00:31:45.005 align:middle
不能访问彼此的沙盒

00:31:45.372 --> 00:31:48.976 align:middle
因此如果我们有两个应用程序
沙盒那么从一个沙盒

00:31:49.343 --> 00:31:53.380 align:middle
移动到另一个沙盒的
唯一方式就是第一个应用程序

00:31:53.647 --> 00:31:58.151 align:middle
在另一个应用程序的
沙盒内生成一个副本

00:31:58.752 --> 00:32:04.525 align:middle
现在通过使用UIDocument
菜单视图控制器我们就可以松口气了

00:31:58.752 --> 00:32:04.525 align:middle
现在通过使用UIDocument
菜单视图控制器我们就可以松口气了

00:32:04.992 --> 00:32:10.297 align:middle
它允许你的应用程序
在另一个应用程序的容器内进行拉取

00:32:11.131 --> 00:32:15.536 align:middle
不过一般来说你不会
仅仅打开一个文档就算了

00:32:16.203 --> 00:32:19.306 align:middle
每次打开这个文档都会生成一个副本

00:32:20.340 --> 00:32:24.578 align:middle
当然 处理这些副本就非常方便了

00:32:24.711 --> 00:32:27.748 align:middle
因为你现在其它应用程序的
容器内有一个你的

00:32:28.081 --> 00:32:30.584 align:middle
文档的副本用户会对它进行修改

00:32:30.651 --> 00:32:33.220 align:middle
这样你就会得到这个文档的第二个版本

00:32:33.854 --> 00:32:36.590 align:middle
现在举例来说回到你的应用程序中

00:32:36.657 --> 00:32:39.459 align:middle
用户想打开这个文档

00:32:40.160 --> 00:32:42.763 align:middle
这样就会生成第三个副本

00:32:43.197 --> 00:32:46.700 align:middle
现在漂浮着的
你有文档的三个不同的版本

00:32:47.401 --> 00:32:50.504 align:middle
这很不幸因为用户会感到困惑不解

00:32:50.938 --> 00:32:52.873 align:middle
不知道哪个版本是最近的版本

00:32:54.308 --> 00:32:56.710 align:middle
这种情况可不太妙

00:32:57.945 --> 00:33:00.681 align:middle
现在在iOS 9中
我们有了这个漂亮的新机制

00:32:57.945 --> 00:33:00.681 align:middle
现在在iOS 9中
我们有了这个漂亮的新机制

00:33:00.747 --> 00:33:01.949 align:middle
叫做“就地打开”

00:33:03.150 --> 00:33:05.853 align:middle
这意味着通过使用文档交互控制器

00:33:05.986 --> 00:33:08.255 align:middle
你的应用程序可以授予另一个应用程序

00:33:08.856 --> 00:33:14.561 align:middle
访问一个文档的权限

00:33:15.896 --> 00:33:18.599 align:middle
文档还是一模一样的

00:33:18.665 --> 00:33:22.436 align:middle
这不是一个副本
而是对这个文档的一个副本

00:33:23.670 --> 00:33:27.975 align:middle
当然了这就意味着
另一个应用程序就可以进行编辑

00:33:28.308 --> 00:33:30.611 align:middle
然后通过展示文件这一魔法

00:33:30.677 --> 00:33:34.414 align:middle
直接反射到你的应用程序中

00:33:36.116 --> 00:33:38.552 align:middle
当然了这对用户来说就非常方便

00:33:39.119 --> 00:33:42.389 align:middle
这包括通过iCloud Drive
app以及通过Spotlight

00:33:42.689 --> 00:33:43.557 align:middle
打开的文件

00:33:44.491 --> 00:33:48.729 align:middle
这就意味着你的用户任何时候在
iCloud Drive app中

00:33:48.996 --> 00:33:55.068 align:middle
浏览他们的文档时我们就可以直接
就地打开那个文档

00:33:56.703 --> 00:33:59.139 align:middle
这个背后的机制
和“文档菜单视图控制器”

00:33:59.206 --> 00:34:01.909 align:middle
中使用的机制非常相似

00:33:59.206 --> 00:34:01.909 align:middle
中使用的机制非常相似

00:34:02.476 --> 00:34:05.012 align:middle
这就意味着如果你的应用程序
已经对此提供支持了

00:34:05.679 --> 00:34:08.315 align:middle
那么对你来说支持这种机制
就不费吹灰之力

00:34:09.315 --> 00:34:12.619 align:middle
即使你现在不支持
UIMenuViewController

00:34:12.686 --> 00:34:15.255 align:middle
采用这种机制也不费吹灰之力

00:34:15.322 --> 00:34:18.659 align:middle
因为这并不是多么神奇的东西

00:34:18.725 --> 00:34:20.226 align:middle
你获得一个URL后

00:34:20.494 --> 00:34:23.597 align:middle
就把它放入你稍后将要展示的
一个UIDocument实例中

00:34:24.697 --> 00:34:28.135 align:middle
我们现在来快速看看
你怎样可以对此提供支持

00:34:29.969 --> 00:34:31.271 align:middle
就像我之前说的非常简单

00:34:31.871 --> 00:34:33.907 align:middle
首先你要告诉我们你对此提供支持了

00:34:34.574 --> 00:34:36.143 align:middle
记住当我们试图找出我们是否要

00:34:36.210 --> 00:34:41.614 align:middle
就地打开这个文件时
你的app可能在那时并不会启动

00:34:42.149 --> 00:34:43.617 align:middle
因此你要事先告诉我们

00:34:44.284 --> 00:34:48.621 align:middle
你需要在你的Info.plist中
采用“LS支持就地打开文档”

00:34:48.688 --> 00:34:50.791 align:middle
这个键来告知我们

00:34:51.190 --> 00:34:53.159 align:middle
根据你用的是Objective-C
还是Swift不同

00:34:53.226 --> 00:34:55.295 align:middle
你只需要把它设置成
为“是”或者“真”即可

00:34:55.996 --> 00:35:02.336 align:middle
这样就可以告诉我们
你的应用程序可以处理这个了

00:34:55.996 --> 00:35:02.336 align:middle
这样就可以告诉我们
你的应用程序可以处理这个了

00:35:03.136 --> 00:35:05.873 align:middle
你还需要再写一点代码

00:35:06.540 --> 00:35:09.109 align:middle
是一种新的委托方法

00:35:10.177 --> 00:35:11.078 align:middle
那个看起来怎么样？

00:35:11.678 --> 00:35:15.015 align:middle
假如说你已经在这里打开了文档

00:35:15.649 --> 00:35:18.919 align:middle
这样假设很合理这是因为
你的app是基于文档的

00:35:19.353 --> 00:35:23.757 align:middle
因此你实现的方法
肯定就和我们在这里看到的非常类似

00:35:24.591 --> 00:35:28.262 align:middle
现在你的方法肯定
得到了一个NSURL

00:35:29.129 --> 00:35:32.332 align:middle
因为这个NSURL是
系统为你的app创建的

00:35:32.399 --> 00:35:35.602 align:middle
临时副本你就需要把这个副本复制到

00:35:36.670 --> 00:35:40.674 align:middle
你自己的容器然后打开这个复制文件

00:35:41.642 --> 00:35:46.313 align:middle
这一小块代码的作用就是这个

00:35:46.880 --> 00:35:49.449 align:middle
现在首先要做的
是在这里采用我们的新方法

00:35:50.250 --> 00:35:53.320 align:middle
这种新方法和旧方法非常相似

00:35:53.854 --> 00:35:56.423 align:middle
它只是取得了一本选项字典

00:35:57.157 --> 00:36:01.295 align:middle
对之前的方法的参数进行封装

00:35:57.157 --> 00:36:01.295 align:middle
对之前的方法的参数进行封装

00:36:01.929 --> 00:36:05.832 align:middle
重要的是其中的一个参数是
“就地打开”键

00:36:07.067 --> 00:36:11.672 align:middle
现在你要做的，
就是看看这个“就地打开”键

00:36:12.039 --> 00:36:13.607 align:middle
是否为真如果这个键为真

00:36:14.741 --> 00:36:18.445 align:middle
那么你的应用程序应该就可以
就地打开这个文件了

00:36:18.812 --> 00:36:20.848 align:middle
这就意味着它不应该生成副本

00:36:21.648 --> 00:36:24.585 align:middle
很简单你不应该再做
你之前不得不做的事了

00:36:26.119 --> 00:36:29.089 align:middle
现在你有了这个URL

00:36:29.523 --> 00:36:34.194 align:middle
你只需要照着之前的打开方式
打开它就可以了

00:36:36.196 --> 00:36:38.665 align:middle
支持就地打开就是这么简单

00:36:40.467 --> 00:36:43.003 align:middle
很好 我们来总结下今天学到的东西

00:36:43.904 --> 00:36:47.341 align:middle
我们已经看过了怎样让你的app
性能响应性很高

00:36:47.407 --> 00:36:53.247 align:middle
看过了使用NSMetadataQuery
来展示一组文档并且当云端

00:36:53.313 --> 00:36:58.118 align:middle
有变更发生时及时更新这些文档

00:36:58.218 --> 00:36:59.753 align:middle
这种方法有多么漂亮

00:37:00.587 --> 00:37:04.258 align:middle
我们还看到了怎样使用
书签来实现最近访问机制

00:37:04.892 --> 00:37:07.294 align:middle
这样你的用户就可以很快返回

00:37:07.427 --> 00:37:09.897 align:middle
他们之前的状态...
他们之前所处的文档

00:37:10.631 --> 00:37:12.733 align:middle
当然有些事情我们没有说

00:37:12.799 --> 00:37:14.468 align:middle
但是也非常合理

00:37:14.668 --> 00:37:17.204 align:middle
即你也可以使用书签来实现状态恢复

00:37:17.704 --> 00:37:21.742 align:middle
这样你的用户就可以直接返回
他们之前所处的状态

00:37:22.809 --> 00:37:26.180 align:middle
我们还看到了怎样使用缩略图
让你的应用程序非常美观

00:37:26.547 --> 00:37:30.350 align:middle
看到了怎样实现进度显示
确保你的用户

00:37:30.417 --> 00:37:33.253 align:middle
始终清楚在他们的
应用程序内发生了什么

00:37:34.121 --> 00:37:37.491 align:middle
最后我们也看到了实现
就地打开有多么容易

00:37:38.125 --> 00:37:41.461 align:middle
就地打开是个很棒的新机制
你的用户就可以直接在

00:37:41.762 --> 00:37:45.632 align:middle
你的应用程序内打开文档

00:37:46.166 --> 00:37:49.036 align:middle
而不用复制多份副本

00:37:50.470 --> 00:37:54.942 align:middle
我们今天发布的一个示例代码
对所有的这些概念

00:37:55.008 --> 00:37:57.144 align:middle
都做了一个漂亮的展示

00:37:57.744 --> 00:37:59.813 align:middle
这个示例代码实际上
就是麦克之前在演示中

00:37:59.880 --> 00:38:01.415 align:middle
向你们演示的那个

00:37:59.880 --> 00:38:01.415 align:middle
向你们演示的那个

00:38:01.915 --> 00:38:03.684 align:middle
它实现了所有的这些特征特性

00:38:04.151 --> 00:38:07.120 align:middle
即在一个“文档浏览器”中创建文档

00:38:08.155 --> 00:38:13.360 align:middle
展示文档生成这些文档的变更动画

00:38:13.827 --> 00:38:18.098 align:middle
当然还有写入缩略图当然还有就地打开

00:38:19.066 --> 00:38:22.703 align:middle
如果你需要获得技术支持
我们建议你去我们的论坛

00:38:23.737 --> 00:38:27.341 align:middle
你可以看到在这个链接下面
我们也有很棒的资料

00:38:28.242 --> 00:38:32.145 align:middle
如果你想了解关于使用
“UIDocument菜单视图控制器”

00:38:32.212 --> 00:38:33.447 align:middle
的更多信息

00:38:33.981 --> 00:38:39.386 align:middle
来实现拉取机制，
而不是就地打开工具的拉取机制

00:38:39.887 --> 00:38:45.359 align:middle
这样你的应用程序就可以
从另一个应用程序的容器内拉取文档

00:38:45.893 --> 00:38:50.197 align:middle
或者你对如何实现基于UIDocument
的应用程序略感兴趣

00:38:50.664 --> 00:38:53.267 align:middle
我们建议你观看我们去年的会议

00:38:54.101 --> 00:38:57.004 align:middle
即去年的会议234

00:38:57.604 --> 00:38:59.273 align:middle
当然你在网上也找得到

00:39:00.040 --> 00:39:01.608 align:middle
那么谢谢你抽出时间参会

00:39:01.875 --> 00:39:03.210 align:middle
祝你下午过得愉快
