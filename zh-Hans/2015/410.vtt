WEBVTT

00:00:19.820 --> 00:00:25.025 align:middle
Xcode中的持续集成和代码覆盖

00:00:33.600 --> 00:00:34.434 align:middle
早上好

00:00:35.402 --> 00:00:38.472 align:middle
欢迎参加“Xcode中的
持续集成和代码覆盖”

00:00:38.939 --> 00:00:41.842 align:middle
我的名字是马特·莫里亚蒂
我是Xcode团队的一名工程师

00:00:42.242 --> 00:00:44.978 align:middle
今天 能在这里给大家讲讲
我们在Xcode中推出的一些工具

00:00:45.045 --> 00:00:47.014 align:middle
我感到激动万分这些工具可以帮助你们

00:00:47.080 --> 00:00:49.850 align:middle
从测试中受益更多我们也希望
它们可以激励你写更多的测试

00:00:53.153 --> 00:00:54.922 align:middle
今天 我们先来讲讲

00:00:54.988 --> 00:00:56.256 align:middle
Xcode Server

00:00:56.590 --> 00:00:58.859 align:middle
Xcode Server是我们
捆绑到Xcode上的一项

00:00:58.959 --> 00:01:00.093 align:middle
持续集成产品

00:00:58.959 --> 00:01:00.093 align:middle
持续集成产品

00:01:01.595 --> 00:01:03.497 align:middle
然后我们再来讲讲
XcodeServer

00:01:03.564 --> 00:01:04.864 align:middle
和Xcode 7中有什么新料

00:01:05.165 --> 00:01:09.036 align:middle
并且重点关注下我们
今年引入的新的代码覆盖特性

00:01:10.804 --> 00:01:12.439 align:middle
会议的下半程我们会来讲一些

00:01:12.673 --> 00:01:14.975 align:middle
Xcode Server更多的
高级特性

00:01:15.242 --> 00:01:16.677 align:middle
这些特性可以允许你把它集成到

00:01:16.743 --> 00:01:18.812 align:middle
你的团队的独特的工作流程上

00:01:19.613 --> 00:01:20.714 align:middle
当然了 在会议整个过程中

00:01:20.781 --> 00:01:23.116 align:middle
我们都会通过演示向你们
展示这些东西是如何实现的

00:01:24.418 --> 00:01:25.285 align:middle
让我们开始吧

00:01:27.754 --> 00:01:30.157 align:middle
Xcode Server是我们
通过Xcode 5

00:01:30.224 --> 00:01:31.458 align:middle
引入Xcode的一项特性

00:01:31.825 --> 00:01:35.596 align:middle
它是关于对一个叫做
“持续集成”的进程提供支持的

00:01:36.830 --> 00:01:40.200 align:middle
持续集成的目的 是为了
提高你们团队的协作效率

00:01:40.634 --> 00:01:42.169 align:middle
让你们得以打造更好的软件

00:01:43.237 --> 00:01:44.171 align:middle
那么这意味着什么？

00:01:44.404 --> 00:01:47.708 align:middle
这意味着定期把你的全部代码取下来

00:01:48.008 --> 00:01:52.446 align:middle
然后进行构建、测试
让构建错误、测试失败等问题

00:01:52.679 --> 00:01:53.680 align:middle
尽快浮出水面

00:01:53.947 --> 00:01:55.516 align:middle
这样你就可以立即修复它们

00:01:58.218 --> 00:02:00.721 align:middle
你们实现持续集成的方式有很多

00:01:58.218 --> 00:02:00.721 align:middle
你们实现持续集成的方式有很多

00:02:00.921 --> 00:02:03.690 align:middle
但是我们认为Xcode
Server更加适合像你们一样的

00:02:03.757 --> 00:02:04.858 align:middle
app开发者原因有两个

00:02:06.360 --> 00:02:08.294 align:middle
第一个原因设置它很容易

00:02:08.662 --> 00:02:10.497 align:middle
因为与OS X Server
进行了集成

00:02:10.663 --> 00:02:13.133 align:middle
如果你已经在你的Mac上安装了
OS X Server和Xcode

00:02:13.200 --> 00:02:15.802 align:middle
那么你离让一个持续集成
服务器定期测试你的项目

00:02:16.003 --> 00:02:17.371 align:middle
就很近了

00:02:19.773 --> 00:02:23.343 align:middle
第二个原因Xcode
Server和Xcode有深度集成

00:02:23.544 --> 00:02:25.812 align:middle
我们深谙如何构建Xcode项目

00:02:26.180 --> 00:02:28.515 align:middle
深谙如何兼容设备等等此类的事情

00:02:28.682 --> 00:02:30.751 align:middle
这样我们就可以尽量少地问你们问题

00:02:30.817 --> 00:02:34.154 align:middle
就可以设置完毕定期检查你的代码

00:02:36.990 --> 00:02:39.726 align:middle
在我们展开讲之前
我想先讲几个我们在谈起

00:02:39.793 --> 00:02:42.129 align:middle
Xcode Server
时要提到的概念

00:02:42.829 --> 00:02:44.498 align:middle
第一个概念你可能已经熟悉了

00:02:44.865 --> 00:02:47.000 align:middle
哪怕你之前从没有
用过Xcode Server

00:02:47.501 --> 00:02:48.702 align:middle
这个概念就是Scheme

00:02:49.269 --> 00:02:52.139 align:middle
每次你在Xcode中运行
你的项目或者测试时

00:02:52.206 --> 00:02:53.707 align:middle
你运行的就是一个Scheme

00:02:53.774 --> 00:02:55.409 align:middle
一般来说会自动为你创建Scheme

00:02:55.475 --> 00:02:57.377 align:middle
不过你也可以创建你自己的
定制Scheme

00:02:57.444 --> 00:02:59.913 align:middle
它们基本上就构成了
构建你的项目的“食谱”

00:03:00.314 --> 00:03:03.550 align:middle
告诉你构建的目标是什么
运行的测试包是什么

00:03:03.750 --> 00:03:06.153 align:middle
传递给你执行的自变量
是什么 诸如此类的事情

00:03:07.120 --> 00:03:09.256 align:middle
当需要设置Bot时
对Xcode Server来说

00:03:09.323 --> 00:03:11.091 align:middle
Scheme就非常重要了

00:03:12.626 --> 00:03:17.231 align:middle
Bot是我们倾向于把它
当成你的团队的一员

00:03:18.398 --> 00:03:20.567 align:middle
它其实就是采取某种特定的方案构建好

00:03:20.868 --> 00:03:22.936 align:middle
然后根据你定义的日程表运行

00:03:23.203 --> 00:03:25.205 align:middle
并完全遵照你的说明执行某些操作

00:03:25.706 --> 00:03:27.274 align:middle
然后把结果汇报给你

00:03:29.910 --> 00:03:32.513 align:middle
每当我们按照日程表运行你的项目时

00:03:32.646 --> 00:03:34.181 align:middle
我们就称之为集成

00:03:34.248 --> 00:03:37.885 align:middle
它就好比是把你的团队
每个成员所做的变更集成到一起

00:03:38.151 --> 00:03:40.554 align:middle
然后看看结果如何

00:03:43.790 --> 00:03:45.092 align:middle
既然我们都已经达成共识了

00:03:45.158 --> 00:03:46.660 align:middle
那么就让我们来谈谈Xcode 7

00:03:46.727 --> 00:03:48.529 align:middle
和Xcode Server中
有什么新料

00:03:49.596 --> 00:03:52.933 align:middle
如果在Xcode 6之前你就用过
Xcode Server的话

00:03:53.233 --> 00:03:55.035 align:middle
你就知道每次你对
一个Bot进行编辑时

00:03:55.169 --> 00:03:58.438 align:middle
我们会让你重新走一遍
生成Bot的整个工作流程

00:03:58.505 --> 00:04:00.340 align:middle
不过提前填写好了很多值

00:03:58.505 --> 00:04:00.340 align:middle
不过提前填写好了很多值

00:04:01.041 --> 00:04:03.877 align:middle
如果你只是想做一些简单的变更
比如添加一个触发器

00:04:03.944 --> 00:04:06.046 align:middle
修改你的方案诸如此类的事情

00:04:06.113 --> 00:04:07.714 align:middle
那么这就有点单调乏味了

00:04:08.081 --> 00:04:09.750 align:middle
现在我们有了这个选项卡式的界面

00:04:09.816 --> 00:04:12.920 align:middle
你就可以进去完成你
想要的更改然后退出

00:04:19.026 --> 00:04:20.894 align:middle
看来大家都是选项卡式工作流程的粉丝

00:04:22.462 --> 00:04:24.998 align:middle
我们还对Xcode 7中的
源代码管理做了多项改进

00:04:25.599 --> 00:04:27.467 align:middle
而我们之前则是会试图自动处理

00:04:28.235 --> 00:04:32.673 align:middle
你的源代码管理并且向你隐藏了
细节不过我们现在让你看到了

00:04:32.739 --> 00:04:36.610 align:middle
更多 这样你就可以清晰地看到
你的Bot将要校验的储存库是哪个

00:04:37.244 --> 00:04:39.847 align:middle
并且你还可以选择不要校验某些储存库

00:04:40.180 --> 00:04:42.950 align:middle
对于你要校验的储存库来说
现在你可以看到并且选择

00:04:43.016 --> 00:04:45.986 align:middle
你要校验的分支是哪个而不是...

00:04:47.754 --> 00:04:48.589 align:middle
谢谢

00:04:51.191 --> 00:04:53.427 align:middle
而不是寄希望于Xcode
希望它自行正确搞明白

00:04:57.231 --> 00:04:59.666 align:middle
我们还改进了源代码管理的安全性

00:04:59.933 --> 00:05:02.870 align:middle
具体来说指的就是SSH指纹对比

00:04:59.933 --> 00:05:02.870 align:middle
具体来说指的就是SSH指纹对比

00:05:03.170 --> 00:05:05.005 align:middle
以及自签名证书

00:05:05.372 --> 00:05:09.710 align:middle
这两项都不会自动成为安全的输送方式

00:05:09.776 --> 00:05:12.379 align:middle
它们要求你信任你连接的服务器

00:05:12.713 --> 00:05:16.116 align:middle
这样如果服务器之后发生了变更

00:05:16.450 --> 00:05:20.387 align:middle
你就知道它们有了新的指纹它们
可能在冒充你以为你正在连接的服务器

00:05:20.787 --> 00:05:24.258 align:middle
之前Xcode会自动信任这些服务器

00:05:24.591 --> 00:05:26.994 align:middle
而不做任何验证

00:05:27.227 --> 00:05:29.897 align:middle
现在我们要求你明确
信任这些中的哪些服务器

00:05:30.163 --> 00:05:33.166 align:middle
然后我们会把指纹储存起来
这样如果之后它发生了变更

00:05:33.400 --> 00:05:35.502 align:middle
我们就不会从错误的服务器上进行校验

00:05:38.772 --> 00:05:41.742 align:middle
我们同样也更新了你在你的
集成中看到的多个报告

00:05:42.242 --> 00:05:44.511 align:middle
所以说测试报告也整理过了更紧凑了

00:05:45.646 --> 00:05:48.849 align:middle
现在在你的测试中
看出断言故障就更加容易了

00:05:52.553 --> 00:05:55.689 align:middle
日志视图的性能提升也得到了大幅提升

00:05:55.923 --> 00:05:58.859 align:middle
之前我们试图向你展示你的
全部日志的堆叠视图

00:05:59.259 --> 00:06:01.562 align:middle
但是当你视图展开某项日志时

00:05:59.259 --> 00:06:01.562 align:middle
但是当你视图展开某项日志时

00:06:01.628 --> 00:06:04.064 align:middle
这就出现了明显的性能代偿

00:06:04.131 --> 00:06:06.166 align:middle
现在我们一次只向你展示一条日志

00:06:06.233 --> 00:06:08.068 align:middle
你可以通过左上角的
弹出按钮来选择日志

00:06:08.168 --> 00:06:11.438 align:middle
现在查看大的日志文件也非常快了

00:06:20.280 --> 00:06:23.584 align:middle
提到持续集成让Xcode
Server脱颖而出的一件事情

00:06:23.650 --> 00:06:25.686 align:middle
是它知道Xcode项目会产生

00:06:25.953 --> 00:06:28.488 align:middle
什么类型的问题它还知道

00:06:28.555 --> 00:06:31.458 align:middle
构建错误是什么样的
知道测试失败是什么样的

00:06:31.725 --> 00:06:35.229 align:middle
它不会仅仅向你显示一些
原始的纯文本日志文件

00:06:35.462 --> 00:06:38.365 align:middle
让你自己仔细查看然后
找出发生了什么问题

00:06:39.399 --> 00:06:41.969 align:middle
说到此类问题我们做了很多巧妙的事情

00:06:42.035 --> 00:06:44.104 align:middle
就是为了让这些问题
浮出水面 对你有所裨益

00:06:45.639 --> 00:06:46.740 align:middle
当你运行集成时...

00:06:46.907 --> 00:06:48.509 align:middle
Xcode 6中同样也是如此...

00:06:48.642 --> 00:06:52.913 align:middle
我们会向你展示这个漂亮的报告
告诉你在你的构建中出了什么问题

00:06:53.914 --> 00:06:56.216 align:middle
因为我们会把这次集成
和之前的集成进行对比

00:06:56.283 --> 00:06:59.219 align:middle
我们就能让新问题浮现出来
这样我们就可以精确定位出

00:06:59.286 --> 00:07:02.856 align:middle
是哪次集成出了问题是哪次提交
把某个特定的问题带进来了

00:06:59.286 --> 00:07:02.856 align:middle
是哪次集成出了问题是哪次提交
把某个特定的问题带进来了

00:07:03.290 --> 00:07:08.795 align:middle
这样的话找到原因查出问题所在
修复问题就非常容易了

00:07:12.799 --> 00:07:15.335 align:middle
围绕“问题” 我们在Xcode 7
中还添加了一些新东西

00:07:15.636 --> 00:07:17.137 align:middle
假如说你现在看到发生了一个问题

00:07:17.371 --> 00:07:20.274 align:middle
你要么可以看到是不是
你的错 这样你好修复

00:07:20.407 --> 00:07:22.376 align:middle
它要么你可以看到问题的原因

00:07:22.442 --> 00:07:24.378 align:middle
比如我就知道那里错了我就可以

00:07:24.444 --> 00:07:26.380 align:middle
进去快速修复它把这个搞定

00:07:26.813 --> 00:07:28.849 align:middle
然后你可以认领问题
这样你的名字就放上去了

00:07:28.916 --> 00:07:30.617 align:middle
这样当你的团队中的每个人查看报告时

00:07:30.817 --> 00:07:32.853 align:middle
他们就可以看到这个这
样他们就知道自己不用

00:07:32.920 --> 00:07:34.688 align:middle
操心这个事了因为你已经在处理了

00:07:37.057 --> 00:07:38.926 align:middle
如果问题是间歇性的或者是你知道

00:07:38.992 --> 00:07:41.929 align:middle
已经修复了的问题你就可以

00:07:42.095 --> 00:07:43.230 align:middle
把它们“消音”一段时间

00:07:43.430 --> 00:07:44.932 align:middle
它们就会从报告中消失

00:07:46.400 --> 00:07:48.802 align:middle
这样的话你可以集中精神关注那些

00:07:48.869 --> 00:07:50.437 align:middle
确实需要你关注的事而不用和你知道

00:07:50.504 --> 00:07:52.873 align:middle
已经解决了的事情搅和到一起

00:07:58.278 --> 00:08:01.648 align:middle
不过关于Xcode Server
最棒的一点是我们能在多大程度上

00:07:58.278 --> 00:08:01.648 align:middle
不过关于Xcode Server
最棒的一点是我们能在多大程度上

00:08:01.715 --> 00:08:04.117 align:middle
和Xcode引入的
其它各项特性进行交互

00:08:04.351 --> 00:08:06.520 align:middle
因为我们在Xcode 7上
有一些很棒的新特性

00:08:06.787 --> 00:08:09.623 align:middle
我们也专门拿出时间
把这些特性集成到了

00:08:09.690 --> 00:08:10.858 align:middle
Xcode Server

00:08:11.358 --> 00:08:12.693 align:middle
我想看看其中的几项特性

00:08:14.895 --> 00:08:17.564 align:middle
用户界面测试是
Xcode 7上的新特性

00:08:19.032 --> 00:08:21.034 align:middle
我们专门对此进行了处理

00:08:21.101 --> 00:08:23.136 align:middle
确保了它能完美兼容
Xcode Server

00:08:23.871 --> 00:08:26.473 align:middle
当你运行Mac测试或者
iOS模拟器测试时

00:08:26.807 --> 00:08:28.308 align:middle
我们会在你的服务器后台

00:08:28.375 --> 00:08:29.610 align:middle
创建一个全屏会话

00:08:29.877 --> 00:08:31.144 align:middle
你的全部测试都是在那里

00:08:31.378 --> 00:08:33.013 align:middle
运行的这就意味着你无需担心启动

00:08:33.212 --> 00:08:36.817 align:middle
你的应用程序时 是否处于
适用于Xcode 2的正确环境中

00:08:37.017 --> 00:08:38.150 align:middle
我们会替你搞定它

00:08:38.519 --> 00:08:40.220 align:middle
如果你用的是真实的iOS设备

00:08:40.453 --> 00:08:42.422 align:middle
那么你就可以看到UI测试在设备上

00:08:42.489 --> 00:08:44.224 align:middle
逐句通过应用程序

00:08:50.864 --> 00:08:52.566 align:middle
用户界面测试是以一个高水平的标准

00:08:52.699 --> 00:08:54.801 align:middle
对你的应用程序进行测试的绝佳方式

00:08:54.868 --> 00:08:56.470 align:middle
测试的方式和你的用户看到的一致

00:08:56.537 --> 00:08:58.772 align:middle
并且会对所有的不同
层在一起的相互交互进行测试

00:08:59.006 --> 00:09:03.744 align:middle
如果你同时还有一个服务器
在各种设备上运行这些测试那就更棒了

00:08:59.006 --> 00:09:03.744 align:middle
如果你同时还有一个服务器
在各种设备上运行这些测试那就更棒了

00:09:05.345 --> 00:09:06.246 align:middle
对于一项方案来说

00:09:09.750 --> 00:09:12.519 align:middle
“点播资源”是iOS 9上
的一项新特性

00:09:12.786 --> 00:09:16.657 align:middle
通过避免在你的包中存储太多的资源

00:09:16.723 --> 00:09:18.158 align:middle
它就可以让你的apps包更小

00:09:18.392 --> 00:09:20.394 align:middle
如果你的app已经上
架了App Store

00:09:20.460 --> 00:09:22.095 align:middle
App Store就会替你充当主机

00:09:23.063 --> 00:09:25.132 align:middle
这样 当需要的时候
你的应用程序就可以下载

00:09:25.332 --> 00:09:28.035 align:middle
这些资源而当你不用的时候
就可以从磁盘上删除

00:09:29.703 --> 00:09:31.905 align:middle
那么当你在发布之前
需要做内部产品质量测试

00:09:31.972 --> 00:09:35.342 align:middle
需要测试你的应用程序的构建

00:09:35.709 --> 00:09:38.245 align:middle
并且你的app
已经上架App Store了

00:09:38.779 --> 00:09:40.280 align:middle
对于资源来说那时候会发生什么？

00:09:40.347 --> 00:09:42.382 align:middle
那时候 App Store就不会
再为这些资源充当主机了

00:09:42.449 --> 00:09:45.652 align:middle
你做的变更太快
App Store没法再充当主机了

00:09:46.820 --> 00:09:48.555 align:middle
但是如果你是从Xcode
Server上

00:09:48.622 --> 00:09:49.923 align:middle
获取的内部产品质量构建

00:09:49.990 --> 00:09:52.693 align:middle
并且你是让你的集成
为你生成了你安装到

00:09:53.293 --> 00:09:55.863 align:middle
你的设备上的IPAS
那么这就会自动为你进行处理

00:09:56.196 --> 00:09:59.099 align:middle
你不需要勾选选项框你什么也
不用做Xcode Server

00:09:59.166 --> 00:10:01.702 align:middle
会自行知道在你的
应用程序内有了点播资源

00:09:59.166 --> 00:10:01.702 align:middle
会自行知道在你的
应用程序内有了点播资源

00:10:01.768 --> 00:10:03.770 align:middle
它就会在自己的服务器上
为这些资源充当主机

00:10:03.837 --> 00:10:05.706 align:middle
如何找到这些资源

00:10:13.180 --> 00:10:15.582 align:middle
最后 我还想再讲讲
Xcode 7上的另外一项

00:10:15.649 --> 00:10:17.718 align:middle
新的特性这项特性
和Xcode Server

00:10:17.784 --> 00:10:19.453 align:middle
以及持续集成都配合的天衣无缝

00:10:19.653 --> 00:10:20.621 align:middle
这就是“代码覆盖”

00:10:23.557 --> 00:10:28.061 align:middle
“代码覆盖”就是一种对你的
测试的值进行度量的工具具体来说

00:10:28.262 --> 00:10:30.330 align:middle
当我们运行测试时
我们想知道实际运行的

00:10:30.631 --> 00:10:31.532 align:middle
代码是什么

00:10:32.466 --> 00:10:35.969 align:middle
因为你很容易就会出现你的
应用程序上有一大堆

00:10:36.036 --> 00:10:39.072 align:middle
测试套件你很难进行变更

00:10:39.139 --> 00:10:41.608 align:middle
你不注意的话就不会出现回归这种情况

00:10:42.609 --> 00:10:45.512 align:middle
但是你怎么知道你到底
需要多少项测试才算足够？

00:10:45.879 --> 00:10:48.715 align:middle
假如说我有一个应用程序
并且有二百项单元测试

00:10:49.116 --> 00:10:53.220 align:middle
但是这些测试却仅仅覆盖了
我的应用程序的20%？

00:10:53.921 --> 00:10:56.690 align:middle
要是这样的话
它们可不像我想的那样有用

00:10:57.024 --> 00:10:59.593 align:middle
因此代码覆盖为的就是
把这些信息呈现给你

00:10:59.793 --> 00:11:01.261 align:middle
这样你就可以做出明智的决策

00:10:59.793 --> 00:11:01.261 align:middle
这样你就可以做出明智的决策

00:11:01.895 --> 00:11:05.465 align:middle
它可以让你运行你的测试
并且正确度量运行的代码

00:11:05.766 --> 00:11:08.869 align:middle
是哪个更重要的是度量出完全
未经测试的代码是哪个

00:11:09.169 --> 00:11:11.738 align:middle
这个代码就是当你继续添加新的特性时

00:11:11.805 --> 00:11:14.875 align:middle
可能出现回归的代码而你之前
是不会从你的测试中知道的

00:11:17.177 --> 00:11:19.713 align:middle
因此我们认为对于那些
真的在意测试的团队来说

00:11:19.780 --> 00:11:20.848 align:middle
代码覆盖真的很重要

00:11:21.148 --> 00:11:23.917 align:middle
这也是我们把代码覆盖集成到
Xcode的原因

00:11:25.519 --> 00:11:27.154 align:middle
像其它很棒的Xcode特性一样

00:11:27.321 --> 00:11:29.923 align:middle
代码覆盖在构建时就和
LLVM有着紧密集成

00:11:30.724 --> 00:11:33.760 align:middle
因此当你在你的方案中收集
启用的代码覆盖时

00:11:33.894 --> 00:11:35.629 align:middle
编译器就会对你的代码进行指导

00:11:35.896 --> 00:11:38.599 align:middle
我们就可以计算每个表达的执行频率

00:11:39.166 --> 00:11:41.568 align:middle
然后我们就会在IDE中
把这个信息呈现给你

00:11:43.003 --> 00:11:44.671 align:middle
我们现在有两种方式可以实现这一点

00:11:45.405 --> 00:11:48.575 align:middle
第一种是当你进到你的
测试的报告导航器中

00:11:48.742 --> 00:11:51.445 align:middle
你之前在Xcode 6中
就可以这么做 不过现在在

00:11:51.512 --> 00:11:53.881 align:middle
Xcode 7中有了一个贴有
“覆盖”标签的新标签

00:11:55.415 --> 00:11:59.119 align:middle
如果你查看这个报告
你就可以根据目标 文件

00:11:59.186 --> 00:12:01.555 align:middle
以及方式进行查看
这样就可以知道你的应用程序

00:11:59.186 --> 00:12:01.555 align:middle
以及方式进行查看
这样就可以知道你的应用程序

00:12:01.622 --> 00:12:02.990 align:middle
的各个不同部分的覆盖情况

00:12:04.391 --> 00:12:07.361 align:middle
这样你就可以从一个较高的
层面来查看你的应用程序

00:12:07.594 --> 00:12:10.130 align:middle
然后向下挖掘下 看看
值得你注意的部分是哪个

00:12:11.932 --> 00:12:16.336 align:middle
如果我发现某种方法的覆盖率是75%

00:12:17.037 --> 00:12:18.038 align:middle
这也算是个好消息

00:12:18.105 --> 00:12:20.941 align:middle
但是我并没有获得
怎样才能进行修复的信息

00:12:21.008 --> 00:12:24.411 align:middle
我不知道我的代码的哪些
分支测试到了哪些分支没有测试到

00:12:25.679 --> 00:12:28.582 align:middle
当你悬停在这些方法或者文件上时

00:12:28.649 --> 00:12:31.752 align:middle
我就可以点击弹出的箭头
这些就会显示出源代码编辑器

00:12:31.919 --> 00:12:34.421 align:middle
我们就可以在那里通过
内联注释 高亮显示你的

00:12:34.488 --> 00:12:36.290 align:middle
应用程序中未被覆盖的部分

00:12:36.557 --> 00:12:38.625 align:middle
对于那些已被覆盖的
部分来说 我们则会告诉你

00:12:38.692 --> 00:12:40.160 align:middle
它们在测试中被执行的次数

00:12:48.001 --> 00:12:51.271 align:middle
代码覆盖在Xcode IDE中
本身就已经很棒了

00:12:51.605 --> 00:12:54.408 align:middle
不过我想当你把它放到Xcode
Server上时 它会更棒

00:12:54.641 --> 00:12:56.810 align:middle
你在那里有一个Bot在各种设备上

00:12:56.877 --> 00:12:58.212 align:middle
运行你的项目

00:13:00.214 --> 00:13:02.049 align:middle
集成和Bot的一个特别之处在于

00:13:02.115 --> 00:13:04.418 align:middle
你可以设置它们在一系列的设备上运行

00:13:04.484 --> 00:13:06.453 align:middle
而不是一次仅能运行在一台设备上

00:13:06.520 --> 00:13:08.021 align:middle
就像你在Xcode中所做的那样

00:13:08.956 --> 00:13:11.291 align:middle
当你这么做的时候
我们会集中向你展示你全部

00:13:11.358 --> 00:13:13.527 align:middle
设备的覆盖数据
并且我们以橙色高亮显示

00:13:13.594 --> 00:13:19.032 align:middle
在你的设备上有着不同的
覆盖的方法 目标 或者文件

00:13:19.333 --> 00:13:21.935 align:middle
这样你就可以看看这些不一样的地方

00:13:22.069 --> 00:13:25.172 align:middle
看看它是否属于bug
还是属于某种预期行为

00:13:26.073 --> 00:13:29.309 align:middle
你在不同的设备上有不同的代码覆盖

00:13:29.510 --> 00:13:32.112 align:middle
这相当普遍尤其是在用户界面代码中

00:13:32.312 --> 00:13:33.947 align:middle
你在不同的设备上可能有不同的代码

00:13:34.014 --> 00:13:35.983 align:middle
比如一台iPad和一部
iPhone就不同

00:13:38.452 --> 00:13:41.555 align:middle
Xcode Server还可以为你
提供的一件事情

00:13:41.722 --> 00:13:44.157 align:middle
是一份存储追踪你的项目的
存在期的档案

00:13:44.658 --> 00:13:46.994 align:middle
这样当你查看某个集成的代码覆盖时

00:13:47.060 --> 00:13:49.830 align:middle
我们就可以高亮显示变更发生的时间

00:13:50.030 --> 00:13:53.967 align:middle
这些变更在代码覆盖中的方法以及文件

00:13:54.201 --> 00:13:57.070 align:middle
这样你就可以精确定位到
某次具体的提交集合

00:13:59.840 --> 00:14:03.243 align:middle
档案还使得我们可以显示
趋势 之前在Xcode 6中

00:13:59.840 --> 00:14:03.243 align:middle
档案还使得我们可以显示
趋势 之前在Xcode 6中

00:14:03.310 --> 00:14:05.846 align:middle
我们有构建历史图表以及你的
Bot的测试历史图表

00:14:06.313 --> 00:14:09.183 align:middle
这样当你添加更多的测试的时候
你就可以看到图表发生变动

00:14:09.449 --> 00:14:11.818 align:middle
你就可以看到事情进展如何

00:14:12.252 --> 00:14:13.520 align:middle
你的Bot的稳定性如何

00:14:13.854 --> 00:14:15.822 align:middle
不过现在我们又有了一项
新的代码覆盖图

00:14:16.089 --> 00:14:19.193 align:middle
可以表明随着时间的变化
你的项目的整体覆盖趋势

00:14:20.294 --> 00:14:23.163 align:middle
这样的话 你就可以知道
举例来说是否有所提升

00:14:23.230 --> 00:14:25.199 align:middle
这样你就可以知道当你添加特性时

00:14:25.365 --> 00:14:27.100 align:middle
你是否需要给这些特性添加测试

00:14:27.467 --> 00:14:30.437 align:middle
或者你是否需要给
之前没有覆盖到的特性添加测试

00:14:31.071 --> 00:14:33.740 align:middle
或者也可能出现向下的趋势
这是因为你进展太快了

00:14:33.807 --> 00:14:35.542 align:middle
没有对你刚加的特性进行测试

00:14:35.776 --> 00:14:37.945 align:middle
这样 就可以帮助你做出明智的决策

00:14:38.078 --> 00:14:40.480 align:middle
决定下一步该怎么办
决定如何分配你的开发时间

00:14:44.318 --> 00:14:46.887 align:middle
当然了 如果你在你的工作区
使用大屏幕来显示你的

00:14:46.954 --> 00:14:50.123 align:middle
Bot的整体状况
那么在你的项目的测试数量

00:14:50.190 --> 00:14:53.961 align:middle
下面我们还会向你显示你的整体
覆盖百分比这样你就可以密切注视它

00:14:56.930 --> 00:14:57.764 align:middle
好的

00:14:57.831 --> 00:14:59.633 align:middle
现在我想请我的同事埃里克上来

00:14:59.700 --> 00:15:02.202 align:middle
请他给大家演示一些Xcode
以及Xcode Server上的

00:14:59.700 --> 00:15:02.202 align:middle
请他给大家演示一些Xcode
以及Xcode Server上的

00:15:02.269 --> 00:15:03.103 align:middle
代码覆盖特性

00:15:10.844 --> 00:15:11.712 align:middle
谢谢 马特

00:15:12.880 --> 00:15:15.482 align:middle
我要向你们演示一个
我们开发的供内部使用的

00:15:15.682 --> 00:15:17.684 align:middle
应用程序我们用它来跟踪大家互相

00:15:17.751 --> 00:15:18.819 align:middle
欠下的请喝咖啡的次数

00:15:19.219 --> 00:15:21.088 align:middle
去年你可能已经看过这个应用程序了

00:15:21.154 --> 00:15:22.890 align:middle
自那之后我们又做了一些改进

00:15:24.057 --> 00:15:26.960 align:middle
它的基本规则是
如果有人替你修复了一个bug

00:15:27.027 --> 00:15:29.363 align:middle
或者你欠了别人一个人情
那么你就需要请对方喝咖啡

00:15:29.563 --> 00:15:31.398 align:middle
我们专门有一个应用程序对此进行跟踪

00:15:32.199 --> 00:15:34.201 align:middle
和其它优秀的应用程序一样
我们也有单元测试

00:15:34.268 --> 00:15:36.036 align:middle
来确保当我们添加新的特性时

00:15:36.103 --> 00:15:38.138 align:middle
不会影响到已有的工作代码

00:15:39.973 --> 00:15:42.743 align:middle
对这些进行测试只算成功的一半

00:15:42.809 --> 00:15:45.746 align:middle
当对应用程序进行实际的全面测试时

00:15:45.946 --> 00:15:49.216 align:middle
我不知道我能坦然面对的
单元测试有多少个

00:15:49.283 --> 00:15:51.785 align:middle
我想看看覆盖情况看看情况如何

00:15:53.220 --> 00:15:55.088 align:middle
不过也许我们没有那么多的测试

00:15:55.355 --> 00:15:56.190 align:middle
让我们来看看

00:15:56.423 --> 00:15:58.859 align:middle
实际上 在我来这儿之前
我已经运行过了测试

00:15:59.860 --> 00:16:01.495 align:middle
我们可以直接在设备上看看测试结果

00:15:59.860 --> 00:16:01.495 align:middle
我们可以直接在设备上看看测试结果

00:16:01.562 --> 00:16:02.396 align:middle
我们只有七项测试

00:16:02.563 --> 00:16:04.164 align:middle
这可很不妙

00:16:05.032 --> 00:16:07.768 align:middle
不过这是一个小的应用程序

00:16:07.835 --> 00:16:09.903 align:middle
也许这已经足以覆盖所有的事情了

00:16:10.003 --> 00:16:11.839 align:middle
最起码这些测试都通过了所以开局不错

00:16:11.905 --> 00:16:12.873 align:middle
我们来看看覆盖情况

00:16:15.309 --> 00:16:16.710 align:middle
如果我们来看看这里的覆盖报告

00:16:16.777 --> 00:16:19.112 align:middle
我们就可以看到这个应用程序
被分解成了两个目标

00:16:19.179 --> 00:16:22.382 align:middle
我们有一个UI层面的应用程序即
coffeeboard.app

00:16:22.716 --> 00:16:24.451 align:middle
测试覆盖情况不太好

00:16:25.419 --> 00:16:28.188 align:middle
不过没关系 这是一个UI应用程序
我应该给它写一些UI测试

00:16:28.255 --> 00:16:30.791 align:middle
我更关心这个基础水平的框架

00:16:31.024 --> 00:16:32.926 align:middle
我们可以在这里看到
只有50%测试覆盖

00:16:32.993 --> 00:16:37.130 align:middle
这可不太妙因为如果我们努力的话
就可以实现100%覆盖

00:16:38.165 --> 00:16:42.369 align:middle
看起来真正落后的类是这个事务类

00:16:43.604 --> 00:16:45.339 align:middle
如果我们看看这个事务类

00:16:46.039 --> 00:16:47.508 align:middle
我们就可以看到这里有一堆的类

00:16:47.574 --> 00:16:49.476 align:middle
在我们的各项单元测试中
并没有被调用到

00:16:50.043 --> 00:16:52.145 align:middle
我们创建了一些事务
我们可以看到它们在

00:16:52.212 --> 00:16:53.714 align:middle
初始化程序中被调用了

00:16:54.414 --> 00:16:56.350 align:middle
但是我们并没有实际用它们来做什么事

00:16:56.817 --> 00:16:58.385 align:middle
我再来解释下我们的app

00:16:58.452 --> 00:16:59.720 align:middle
它有一项很棒的特性

00:17:00.220 --> 00:17:02.623 align:middle
使用了我们的一个专属算法

00:17:02.723 --> 00:17:05.526 align:middle
如果我欠马特两杯咖啡
而他又欠我一杯咖啡

00:17:05.893 --> 00:17:08.729 align:middle
那么我们就会把这两个数字合并
就成了我欠马特一杯咖啡

00:17:09.997 --> 00:17:11.397 align:middle
因为算法是秘密的我就想确保

00:17:11.464 --> 00:17:14.101 align:middle
这个算法经过了仔细测试因为数学

00:17:14.167 --> 00:17:16.970 align:middle
不是我的强项我就更得确保不出问题

00:17:17.938 --> 00:17:20.540 align:middle
我们来看看它的源文件

00:17:20.607 --> 00:17:22.776 align:middle
就像马特说过的那样
我要使用那个悬停后

00:17:23.010 --> 00:17:27.013 align:middle
显示出来的箭头
直接进到我的源码编辑器

00:17:28.147 --> 00:17:32.019 align:middle
这里我们可以看到一大堆
深色的高亮显示区域

00:17:32.319 --> 00:17:35.189 align:middle
在我的源码编辑器中
使用了默认的背景色的

00:17:35.255 --> 00:17:37.090 align:middle
代码在这里背景色是白色

00:17:37.391 --> 00:17:40.527 align:middle
就是已经在测试中覆盖了的代码
所以我并不太需要担心它们

00:17:40.694 --> 00:17:44.398 align:middle
我更关心的是那些
以灰色背景显示的代码

00:17:44.998 --> 00:17:47.768 align:middle
我可以确认它们未被覆盖到
因为在右边这里

00:17:48.135 --> 00:17:49.403 align:middle
我们可以看到一堆“零”

00:17:49.603 --> 00:17:53.740 align:middle
表明这个代码从未通过
我的任何单元测试

00:17:54.675 --> 00:17:55.509 align:middle
这可不好

00:17:56.810 --> 00:17:59.479 align:middle
现在让我们在这个单元
测试中导航下 然后再来看看这个

00:18:00.180 --> 00:18:01.949 align:middle
如果我到事务测试那里

00:18:03.684 --> 00:18:05.185 align:middle
我就可以发现我并没有任何测试

00:18:05.252 --> 00:18:06.820 align:middle
这就出问题了

00:18:07.120 --> 00:18:08.789 align:middle
让我们现在把它修复

00:18:09.156 --> 00:18:11.325 align:middle
我要在这里创建一个小的空白区

00:18:12.025 --> 00:18:13.293 align:middle
写一些Swift代码

00:18:14.461 --> 00:18:16.597 align:middle
当然了 我假设
你们都有神奇的宏命令

00:18:16.663 --> 00:18:18.165 align:middle
可以为你们添加各种单元测试

00:18:18.465 --> 00:18:20.033 align:middle
我们就是这样开发程序的不是吗？

00:18:26.440 --> 00:18:28.075 align:middle
我要在设备上运行下测试

00:18:28.141 --> 00:18:29.309 align:middle
这需要一点时间

00:18:29.376 --> 00:18:31.979 align:middle
就像马特说过的那样当你的代码运行时

00:18:32.045 --> 00:18:34.715 align:middle
我们会用LLVM对你的代码
进行指导 这样我们就可以

00:18:34.781 --> 00:18:36.216 align:middle
看到到底运行的是哪个表达式

00:18:36.783 --> 00:18:40.354 align:middle
趁着它在我的设备上运行
我要去看看方案

00:18:40.621 --> 00:18:43.190 align:middle
要记住既然它是LLVM的一项特性

00:18:43.257 --> 00:18:44.892 align:middle
那么它在Xcode上也是可选项

00:18:44.958 --> 00:18:47.594 align:middle
打开它的方式是进到方案编辑器

00:18:48.061 --> 00:18:49.329 align:middle
然后选择测试操作

00:18:49.763 --> 00:18:52.833 align:middle
然后确保“收集数据覆盖”
那个勾选框已经勾选了

00:18:53.901 --> 00:18:55.502 align:middle
这样就可以确保我得到覆盖数据

00:18:56.270 --> 00:18:57.838 align:middle
时间正好我的所有测试都成功了

00:18:58.205 --> 00:19:00.374 align:middle
太好了 只要我用神奇的
宏命令来构建 就总会成功

00:18:58.205 --> 00:19:00.374 align:middle
太好了 只要我用神奇的
宏命令来构建 就总会成功

00:19:01.542 --> 00:19:03.710 align:middle
如果我现在看看
测试报告 我可以看到

00:19:04.478 --> 00:19:05.779 align:middle
我有更多的单元测试

00:19:05.979 --> 00:19:07.214 align:middle
但这并不是故事的全部

00:19:07.281 --> 00:19:08.649 align:middle
我们再看一次覆盖报告

00:19:10.884 --> 00:19:12.519 align:middle
这里 我们能看到一张更漂亮的图片

00:19:12.786 --> 00:19:15.656 align:middle
如果我在上面放大下我们
就可以看到我现在覆盖了76%

00:19:15.856 --> 00:19:18.592 align:middle
虽然不是100%覆盖
但是已经比我们之前的情况好得多了

00:19:20.160 --> 00:19:22.896 align:middle
我要把事务类再次显露出来

00:19:22.963 --> 00:19:25.132 align:middle
这里我们可以看到
更多的这些类现在得到了覆盖

00:19:25.199 --> 00:19:27.701 align:middle
我现在测试的是合并代码
之前我一直很担心这些代码

00:19:28.001 --> 00:19:29.403 align:middle
害我损失了好多睡眠时间

00:19:30.370 --> 00:19:33.073 align:middle
这里有件有趣的事
如果我们返回源编辑器

00:19:34.374 --> 00:19:36.443 align:middle
然后看看等效方法

00:19:36.510 --> 00:19:38.745 align:middle
如果你之前注意的话
当时它只是被部分覆盖了

00:19:38.812 --> 00:19:41.181 align:middle
我们在这里就可以看到原因所在

00:19:41.682 --> 00:19:42.749 align:middle
我们看看这个等效方法

00:19:42.816 --> 00:19:46.420 align:middle
我们并没有把我们的事务类
同某个不是事务类的类进行对比

00:19:46.887 --> 00:19:50.257 align:middle
因此这个返回的假值永远不会
在任何我们的单元测试中被调用到

00:19:50.991 --> 00:19:53.260 align:middle
当你查看不同的分支时
能够看到这个覆盖情况

00:19:53.327 --> 00:19:55.529 align:middle
用处会很大
尤其是当你的代码中有很多

00:19:55.596 --> 00:19:58.332 align:middle
分支逻辑
你知道会出现边界情况

00:19:58.765 --> 00:20:02.135 align:middle
这样的话你就可以确保当你写你的
单元测试时每种边界情况都能覆盖到

00:19:58.765 --> 00:20:02.135 align:middle
这样的话你就可以确保当你写你的
单元测试时每种边界情况都能覆盖到

00:20:02.970 --> 00:20:04.972 align:middle
我们还可以看到
这个代码被覆盖了多次

00:20:05.038 --> 00:20:08.175 align:middle
因此你是否知道你的代码中
有这种多个实例到底同一路径

00:20:08.242 --> 00:20:10.844 align:middle
但是最终却并不相同的情况就非常重要

00:20:10.911 --> 00:20:12.346 align:middle
你需要全部覆盖它们

00:20:14.648 --> 00:20:16.850 align:middle
刚才我做的事情都非常单独枯燥

00:20:16.917 --> 00:20:19.553 align:middle
因此我希望有人能替我整天跑这些测试

00:20:19.620 --> 00:20:23.156 align:middle
我就不需要担心这个
不需要对它们进行对比

00:20:23.223 --> 00:20:25.526 align:middle
但是有人告诉我
预算表中没有雇佣一名

00:20:25.592 --> 00:20:26.760 align:middle
实习生来做这件事的钱

00:20:27.594 --> 00:20:29.263 align:middle
我们来看看Xcode Server

00:20:29.530 --> 00:20:31.965 align:middle
我已经为此设置了一个
Bot 跑在一个已经

00:20:32.032 --> 00:20:34.401 align:middle
有了这个提交的不同分支
我们来看看这个Bot

00:20:36.370 --> 00:20:38.172 align:middle
就像刚才马特在幻灯片中演示的那样

00:20:38.238 --> 00:20:41.508 align:middle
当Bot运行了二十四小时后

00:20:41.575 --> 00:20:44.044 align:middle
当它运行了一段时间后
我们就可以从更高层面

00:20:44.378 --> 00:20:46.046 align:middle
对我的项目进行一次总览

00:20:46.914 --> 00:20:48.882 align:middle
顶部这里 我们为你显示了
高阶统计数字

00:20:49.483 --> 00:20:53.387 align:middle
你可以看到任何时间
任一周、时、月、年

00:20:53.820 --> 00:20:55.656 align:middle
或者自从你的Bot
运行以来的统计数字

00:20:56.957 --> 00:20:58.158 align:middle
然后我们可以看到构建历史

00:20:58.225 --> 00:21:01.361 align:middle
在这里 我们会为你显示随着时间
变化的错误报警以及问题分析

00:20:58.225 --> 00:21:01.361 align:middle
在这里 我们会为你显示随着时间
变化的错误报警以及问题分析

00:21:01.528 --> 00:21:03.263 align:middle
在这个实例中我之前有一些报警

00:21:03.330 --> 00:21:04.498 align:middle
不过我已经修复了它们

00:21:04.898 --> 00:21:06.200 align:middle
所以现在我们显示没有问题

00:21:06.834 --> 00:21:09.136 align:middle
对于持续集成来说接下来的两个图表

00:21:09.203 --> 00:21:11.872 align:middle
可能是最重要的前提是假设
你的项目构建的很干净

00:21:11.939 --> 00:21:13.073 align:middle
没有报警或者错误

00:21:13.640 --> 00:21:14.708 align:middle
那就是你的测试

00:21:15.209 --> 00:21:17.411 align:middle
在这个例子中我们可以看到
我之前有几个测试失败

00:21:17.477 --> 00:21:18.946 align:middle
不过我还是在持续添加测试

00:21:19.580 --> 00:21:22.816 align:middle
这很棒 不过我们真正想看到
的是 顺利通过的测试数量

00:21:22.883 --> 00:21:27.688 align:middle
持续增长并且这些测试也让
代码覆盖持续增长

00:21:27.888 --> 00:21:29.923 align:middle
如果你的测试增加了
但是覆盖情况却没有增加

00:21:30.457 --> 00:21:32.492 align:middle
那么你实际增加的价值
就没有你想象的大

00:21:33.694 --> 00:21:35.996 align:middle
如果我看下上次集成的覆盖情况

00:21:36.063 --> 00:21:38.265 align:middle
这是我刚刚进行的提交你们没有看到

00:21:38.332 --> 00:21:39.433 align:middle
但是我保证我确实提交了

00:21:39.833 --> 00:21:41.902 align:middle
我们就可以直接进到覆盖报告

00:21:43.303 --> 00:21:45.339 align:middle
当我本地跑我的测试时这个看起来

00:21:45.405 --> 00:21:47.040 align:middle
就和我们在Xcode中看到的很像

00:21:47.708 --> 00:21:49.710 align:middle
和Xcode中的类似
我们也是按照目标

00:21:50.077 --> 00:21:51.712 align:middle
按照不同的类进行了划分

00:21:51.945 --> 00:21:53.514 align:middle
我可以展开那个事务类

00:21:54.348 --> 00:21:56.683 align:middle
看到相同的方法覆盖层次
也一模一样

00:21:57.384 --> 00:21:58.652 align:middle
不过有两个不同之处

00:21:58.785 --> 00:22:00.654 align:middle
在这个例子中
我就可以在报告中看到

00:21:58.785 --> 00:22:00.654 align:middle
在这个例子中
我就可以在报告中看到

00:22:00.721 --> 00:22:02.222 align:middle
随着时间推移发生的变化

00:22:02.289 --> 00:22:04.024 align:middle
这样我就不用再查看两份报告

00:22:04.091 --> 00:22:06.293 align:middle
看看覆盖是否有所增加了

00:22:06.360 --> 00:22:07.961 align:middle
尤其是在改动不大的情况下

00:22:08.028 --> 00:22:10.864 align:middle
我们就可以让它显示在这里了

00:22:11.431 --> 00:22:13.901 align:middle
现在 在CB
foundation.framework

00:22:13.967 --> 00:22:16.003 align:middle
我的覆盖率比之前提高了22%

00:22:16.870 --> 00:22:20.607 align:middle
尤其是事务类的覆盖率也增加了48%

00:22:22.042 --> 00:22:24.444 align:middle
下面这里我们用橙色高亮显示了一件

00:22:24.511 --> 00:22:26.813 align:middle
有趣的事即设备的差异之处

00:22:27.281 --> 00:22:30.017 align:middle
实际上
在Xcode Server报告内

00:22:30.083 --> 00:22:33.287 align:middle
我可以点击这个复选框
让设备的差异之处立即

00:22:33.787 --> 00:22:34.855 align:middle
显示出来

00:22:35.389 --> 00:22:37.724 align:middle
在这个例子中看起来
这个详细视图控制器

00:22:38.258 --> 00:22:40.093 align:middle
并没有在我的iPhone上显示出来

00:22:40.327 --> 00:22:42.062 align:middle
这实际上并不意外

00:22:42.129 --> 00:22:44.264 align:middle
在这个例子中 我们的
应用程序用的是分割视图

00:22:44.798 --> 00:22:46.733 align:middle
除非有人点一下
否则第二个视图控制器

00:22:46.800 --> 00:22:48.569 align:middle
并不会在iPhone上显示出来

00:22:48.669 --> 00:22:50.604 align:middle
我们的单元测试并没有执行那个代码

00:22:50.971 --> 00:22:53.507 align:middle
这并没有什么特别不寻常不过你要确保

00:22:53.574 --> 00:22:54.942 align:middle
如果出现此类事情

00:22:55.209 --> 00:22:56.410 align:middle
那么它们不会出乎你的意料

00:22:56.476 --> 00:22:58.745 align:middle
这也就是我们为什么让你们
可以在Xcode Server中

00:22:58.812 --> 00:23:01.114 align:middle
很容易看到不同种类的设备的
差异之处的原因所在

00:22:58.812 --> 00:23:01.114 align:middle
很容易看到不同种类的设备的
差异之处的原因所在

00:23:01.849 --> 00:23:04.418 align:middle
这样就可以很容易找出
本来应该被覆盖的代码

00:23:04.484 --> 00:23:05.652 align:middle
实际上没有覆盖到

00:23:07.120 --> 00:23:09.923 align:middle
这个就是显示了代码覆盖的持续集成

00:23:09.990 --> 00:23:11.558 align:middle
那么我要再请马特来给大家谈一些

00:23:11.625 --> 00:23:13.560 align:middle
Xcode Server
更多的高级特性

00:23:20.834 --> 00:23:21.668 align:middle
谢谢 埃里克

00:23:22.803 --> 00:23:24.872 align:middle
就像埃里克刚刚说过的
我要来给大家谈一些

00:23:24.938 --> 00:23:26.773 align:middle
Xcode Server
更多的高级特性

00:23:27.474 --> 00:23:30.911 align:middle
我知道你们很多开发者
都对扩展Xcode Server

00:23:31.211 --> 00:23:34.715 align:middle
把它和你们团队的工作
流程的一部分集成起来很感兴趣

00:23:35.048 --> 00:23:39.052 align:middle
我们知道你们并不能
仅仅靠Xcode Server

00:23:39.119 --> 00:23:41.889 align:middle
这个工具就能搞定一切
因此我们想给你们提供

00:23:41.955 --> 00:23:43.524 align:middle
让Xcode Server
和你们手上的所有

00:23:43.590 --> 00:23:45.225 align:middle
工具兼容完全拟合你们团队的方式

00:23:46.693 --> 00:23:49.429 align:middle
我们有两种方式今天我要
就如何把Xcode Server

00:23:49.963 --> 00:23:52.132 align:middle
集成到你使用的所有工具上谈一谈

00:23:52.699 --> 00:23:54.201 align:middle
首先是触发器

00:23:55.702 --> 00:23:58.071 align:middle
触发器是在Xcode 6中
引入的引入触发器的目的

00:23:58.939 --> 00:24:02.643 align:middle
是为了在你的Bot
以及你的集成的生命周期内

00:23:58.939 --> 00:24:02.643 align:middle
是为了在你的Bot
以及你的集成的生命周期内

00:24:02.776 --> 00:24:04.311 align:middle
把定制操作集成到上面

00:24:05.245 --> 00:24:07.381 align:middle
触发器可以是邮件通知
提供关于你的集成

00:24:07.447 --> 00:24:09.583 align:middle
集成运行情况出现了什么问题

00:24:09.650 --> 00:24:12.586 align:middle
提交者是谁等等此类事情的细节

00:24:12.653 --> 00:24:18.058 align:middle
以及配置信息或者
你也可以选择某种程序语言

00:24:18.725 --> 00:24:20.561 align:middle
把触发器写成任意脚本

00:24:21.962 --> 00:24:24.164 align:middle
我们默认使用Bash来跑这些脚本

00:24:24.231 --> 00:24:27.134 align:middle
因此你可以向你的触发器中
输入任何老的shell命令

00:24:27.201 --> 00:24:28.035 align:middle
照样可以生效

00:24:28.502 --> 00:24:30.771 align:middle
但是如果你照着写命令行工具那样

00:24:30.838 --> 00:24:33.607 align:middle
在你的脚本顶部包含了
一个hash bang

00:24:33.941 --> 00:24:36.410 align:middle
我们就会用它
你也可以使用任何你喜欢的解释器

00:24:36.944 --> 00:24:39.546 align:middle
如果你愿意的话 你甚至还可以
用Swift来写你的触发器

00:24:40.647 --> 00:24:41.882 align:middle
埃里克稍后会给你们演示下

00:24:44.284 --> 00:24:49.523 align:middle
触发器可以在你的集成运行
之前或者之后运行

00:24:49.890 --> 00:24:52.092 align:middle
每一段代码都能让你的Bot

00:24:52.159 --> 00:24:53.660 align:middle
做一些很酷的事

00:24:54.361 --> 00:24:56.330 align:middle
在你的源代码之后集成运行之前

00:24:56.530 --> 00:24:58.465 align:middle
运行的触发器会进行检验

00:24:58.532 --> 00:25:00.667 align:middle
这点很重要
因为这就意味着你可以访问

00:24:58.532 --> 00:25:00.667 align:middle
这点很重要
因为这就意味着你可以访问

00:25:00.734 --> 00:25:04.838 align:middle
你的项目 并且在构建之前
进行任何你想要的自动变更

00:25:06.573 --> 00:25:10.477 align:middle
集成之后运行的触发器
可以根据集成的结果进行控制

00:25:10.544 --> 00:25:14.281 align:middle
这样触发器就可以仅在
集成成功时或者仅在测试失败时运行

00:25:14.681 --> 00:25:17.518 align:middle
它们也可以访问很多
关于你的集成中发生了

00:25:17.718 --> 00:25:19.319 align:middle
什么事情的信息

00:25:21.288 --> 00:25:23.524 align:middle
我们提供访问这些信息的
一种方式是通过

00:25:23.590 --> 00:25:24.925 align:middle
环境变量来访问

00:25:25.959 --> 00:25:29.997 align:middle
这个仅仅是当你的脚本运行时
定义的某些变量的样本

00:25:30.264 --> 00:25:32.866 align:middle
任何值得你用的脚本语言
都能让你很容易地理解

00:25:32.933 --> 00:25:34.868 align:middle
这些环境变量让你可以把它们用起来

00:25:36.336 --> 00:25:38.071 align:middle
我们举个例子看看你能用它们做什么

00:25:38.305 --> 00:25:42.176 align:middle
去年我们演示了一个触发器
每当完成一项集成的时候

00:25:42.242 --> 00:25:44.511 align:middle
触发器就会在一个逾限聊天室
内贴出一条消息

00:25:44.811 --> 00:25:46.613 align:middle
我们是使用了Bot的名称集成的数量

00:25:46.680 --> 00:25:48.081 align:middle
以及结果来实现的

00:25:49.183 --> 00:25:51.552 align:middle
把它设置起来很容易很快

00:25:53.587 --> 00:25:56.657 align:middle
这里我想请你们注意两件事

00:25:56.723 --> 00:25:58.392 align:middle
因为它们看起来比较怪看起来不协调

00:25:59.026 --> 00:26:01.028 align:middle
对于运行的集成以及相应的Bot来说

00:25:59.026 --> 00:26:01.028 align:middle
对于运行的集成以及相应的Bot来说

00:26:01.094 --> 00:26:03.463 align:middle
我们有一个BotID和一个集成ID

00:26:03.830 --> 00:26:06.166 align:middle
如果我们只给你这些那就有点怪了

00:26:06.366 --> 00:26:07.901 align:middle
你用一个ID做不了什么事

00:26:07.968 --> 00:26:09.536 align:middle
这个ID是一个任意的字符串

00:26:10.204 --> 00:26:12.472 align:middle
那这个字符串有什么好处？
没有用户想看这个字符串

00:26:13.540 --> 00:26:16.009 align:middle
这个字符串本身做不了
什么事 但是当这个字符串

00:26:16.076 --> 00:26:18.345 align:middle
和Xcode Server API
结合起来后事情就非常有趣了

00:26:20.113 --> 00:26:22.482 align:middle
Xcode Server
API构成了

00:26:22.549 --> 00:26:24.685 align:middle
Xcode ID
和Xcode Server

00:26:24.751 --> 00:26:25.586 align:middle
通信的基础

00:26:25.886 --> 00:26:28.455 align:middle
你也可以控制这个API为你自己所用

00:26:28.622 --> 00:26:30.123 align:middle
用它来做一些很有趣的事

00:26:31.992 --> 00:26:34.761 align:middle
和大多数网络服务APIs一样
这个API构造时遵循的也是

00:26:34.862 --> 00:26:36.129 align:middle
开源的 相沿成习的标准

00:26:37.531 --> 00:26:41.668 align:middle
我们在服务器和客户端之间
使用HTTPS来进行来回的安全通信

00:26:41.869 --> 00:26:46.039 align:middle
通过那个加密渠道
我们使用基本认证来进行认证

00:26:49.009 --> 00:26:51.512 align:middle
我们的API遵循的是一个REST

00:26:51.578 --> 00:26:54.047 align:middle
模式像Bot和集成一样
与资源进行交互

00:26:54.248 --> 00:26:57.818 align:middle
使用标准的HTTP谓词
比如获取、发布、打补丁、

00:26:57.885 --> 00:27:02.990 align:middle
删除等等 在这些资源上执行操作

00:26:57.885 --> 00:27:02.990 align:middle
删除等等 在这些资源上执行操作

00:27:04.558 --> 00:27:07.561 align:middle
当然了 我们还使用了JSON
来对数据进行来回通信

00:27:07.794 --> 00:27:09.596 align:middle
JSON用起来很简单
解析起来也很简单

00:27:09.663 --> 00:27:11.298 align:middle
它是网络服务的通用语

00:27:11.498 --> 00:27:12.332 align:middle
大家都在用它

00:27:15.269 --> 00:27:18.405 align:middle
对你来说Xcode
Server这个雄心勃勃的扩展器

00:27:18.805 --> 00:27:22.109 align:middle
是个好消息因为这意味着无论你偏好
什么样的编程语言 什么样的环境

00:27:22.309 --> 00:27:25.145 align:middle
你肯定都能找到表达
HTTPS以及JSON的方法

00:27:25.212 --> 00:27:28.382 align:middle
也就意味着你能够让几乎所有的东西
同Xcode Server进行交谈

00:27:29.883 --> 00:27:33.120 align:middle
我们来看看我们都能怎样
使用这个API

00:27:34.721 --> 00:27:37.090 align:middle
我们能问我们的服务器的
最简单的问题是什么？

00:27:37.791 --> 00:27:40.661 align:middle
我们从这个问题开始
我的服务器上有什么Bot？

00:27:41.328 --> 00:27:42.362 align:middle
这个很简单

00:27:42.496 --> 00:27:44.665 align:middle
我们向Bot资源发一个get请求

00:27:45.432 --> 00:27:48.035 align:middle
如果你看看那里的URI
你就可以看到我们是通过端口

00:27:48.101 --> 00:27:52.773 align:middle
20,343进行通信的 我们所有的
API请求都有一个API前缀

00:27:53.407 --> 00:27:56.777 align:middle
这个并不重要但是当你们在
你们自己的服务器上

00:27:57.010 --> 00:27:59.880 align:middle
尝试这个API的时候
我希望你们记住这一点

00:28:01.582 --> 00:28:04.418 align:middle
当我们发送完那个请求后
我们就得到了一个JSON对象

00:28:04.484 --> 00:28:05.986 align:middle
告诉我们得到的结果的数量

00:28:06.220 --> 00:28:08.055 align:middle
给我们提供一个与结果自身相关的阵列

00:28:09.223 --> 00:28:13.427 align:middle
每个JSON对象都代表一个在我们的
服务器上设置 配置的Bot

00:28:14.061 --> 00:28:17.431 align:middle
和大多数Bot一样
Bot也有一个ID它们也有一个名字

00:28:17.564 --> 00:28:19.733 align:middle
和你在创建
它们时在Xcode中给的一样

00:28:20.100 --> 00:28:22.069 align:middle
它们也有各个配置参数
和你在设置Bot时

00:28:22.669 --> 00:28:24.471 align:middle
设置的配置参数一样

00:28:26.607 --> 00:28:28.775 align:middle
好的 那么我们还能做什么？
既然有了一个Bot

00:28:29.042 --> 00:28:31.211 align:middle
我们来看看这个Bot
运行了什么样的集成

00:28:32.646 --> 00:28:36.116 align:middle
现在我们可以访问那个
Bot的集成子资源了

00:28:39.086 --> 00:28:40.954 align:middle
这样做我们就可以得到一个和我们之前

00:28:41.221 --> 00:28:43.891 align:middle
看到的非常相似的结果
除了现在的结果...

00:28:44.091 --> 00:28:46.293 align:middle
代表集成而不是代表Bot

00:28:47.461 --> 00:28:50.130 align:middle
但是集成也同样属于资源
它们也有自己的ID

00:28:50.531 --> 00:28:53.700 align:middle
一件有趣的事是我们也保存了

00:28:53.967 --> 00:28:56.837 align:middle
集成上的Bot的快照这很重要

00:28:56.937 --> 00:28:58.839 align:middle
因为随着时间推移你的项目会发生变更

00:28:58.906 --> 00:29:01.141 align:middle
你可能采用新的
Xcode特性 类似这样的事

00:28:58.906 --> 00:29:01.141 align:middle
你可能采用新的
Xcode特性 类似这样的事

00:29:01.441 --> 00:29:03.644 align:middle
当你编辑的时候 机器人
程序的配置也可能发生变更

00:29:03.944 --> 00:29:05.812 align:middle
因此我们存储了一张集成的快照

00:29:05.879 --> 00:29:07.781 align:middle
这样当集成运行时
你就可以知道到底你的

00:29:07.981 --> 00:29:09.283 align:middle
Bot是怎样配置的

00:29:11.885 --> 00:29:15.322 align:middle
我们同样会跟踪你的集成的
构造过程的步骤

00:29:15.455 --> 00:29:17.224 align:middle
完成后你可以在那里看到一个结果

00:29:17.558 --> 00:29:20.460 align:middle
你还可以看到你的集成发生的
各种不同的问题的分类

00:29:20.727 --> 00:29:24.731 align:middle
之前的集成的变更的分类

00:29:26.800 --> 00:29:29.102 align:middle
这些都是之前我向
你们展示的get请求

00:29:29.203 --> 00:29:31.772 align:middle
非常适合收集信息

00:29:32.172 --> 00:29:35.209 align:middle
不过如果你在用API的话
你可能想用它做些事情

00:29:36.176 --> 00:29:38.812 align:middle
那么我们到底可以做什么事
来对我们的服务器产生影响呢？

00:29:39.246 --> 00:29:41.081 align:middle
我们可以手动触发一个集成

00:29:41.648 --> 00:29:44.418 align:middle
也许我们有某种不属于Xcode
Server内置调度

00:29:44.484 --> 00:29:46.486 align:middle
程序的自动化流程
我们就希望使用这个流程

00:29:46.553 --> 00:29:48.355 align:middle
来为某些Bot触发集成

00:29:50.057 --> 00:29:52.526 align:middle
这个实现起来也很容易
我们可以使用相同的URL

00:29:52.726 --> 00:29:55.295 align:middle
把我们的HTTP方法
改成一个post

00:29:57.831 --> 00:30:01.268 align:middle
这样的话我们就从“我想列出这个
Bot的集成”变成了

00:29:57.831 --> 00:30:01.268 align:middle
这样的话我们就从“我想列出这个
Bot的集成”变成了

00:30:01.335 --> 00:30:03.337 align:middle
“我想为这个bot
创建一个新的集成 ”

00:30:05.439 --> 00:30:06.540 align:middle
如果我们发出这个请求

00:30:07.074 --> 00:30:08.976 align:middle
我们就可以得到一个代表
一项集成的对象

00:30:09.042 --> 00:30:11.211 align:middle
和你们之前看到的很相似
不过这个对象轻了很多

00:30:11.512 --> 00:30:15.482 align:middle
在构造过程中集成上面
设置了许多项属性

00:30:15.782 --> 00:30:17.484 align:middle
不过这个集成会仅仅处于挂起状态

00:30:17.718 --> 00:30:20.521 align:middle
直到构造程序在队列中捡起它
开始实际运行它

00:30:22.890 --> 00:30:26.460 align:middle
在我们的API中
大部分的post终点都要求你

00:30:26.693 --> 00:30:27.995 align:middle
在主体中放置一些JSON

00:30:28.061 --> 00:30:31.265 align:middle
然后说明这是这个资源的属性

00:30:31.331 --> 00:30:34.568 align:middle
这是我正在创建的事物的属性

00:30:35.169 --> 00:30:37.004 align:middle
在这里集成属于某种特例

00:30:37.371 --> 00:30:41.108 align:middle
因为Bot在本质上已经成了那个样子

00:30:41.241 --> 00:30:43.777 align:middle
它们已经成了每个新的集成的模板

00:30:44.044 --> 00:30:46.647 align:middle
因此它们知道创建一个新的集成
它们需要知道的一切

00:30:47.781 --> 00:30:50.150 align:middle
或者说 它们最起码知道
一般情况下需要知道的一切

00:30:50.384 --> 00:30:52.619 align:middle
你也可以对你的集成有某种影响

00:30:52.686 --> 00:30:54.988 align:middle
举例来说如果你想要一个运行时非常

00:30:55.055 --> 00:30:56.390 align:middle
干净、没有残余物构造块效应

00:30:56.690 --> 00:30:58.859 align:middle
的集成那么你就可以通过向主体中

00:30:59.226 --> 00:31:02.296 align:middle
传递某些JSON 告诉主体这个
集成在运行之前应该先进行

00:30:59.226 --> 00:31:02.296 align:middle
传递某些JSON 告诉主体这个
集成在运行之前应该先进行

00:31:02.429 --> 00:31:04.631 align:middle
清理这种方式来实现

00:31:06.700 --> 00:31:09.303 align:middle
这里有一个例子是你能用
我们的API做什么事情的例子

00:31:09.436 --> 00:31:12.039 align:middle
现在我想把埃里克请回来
请他给你们做一个

00:31:12.105 --> 00:31:13.540 align:middle
Xcode某些高级特性的演示

00:31:20.814 --> 00:31:21.648 align:middle
再次感谢 马特

00:31:22.749 --> 00:31:24.751 align:middle
就像马特所说的我们要通过这个项目

00:31:24.818 --> 00:31:27.154 align:middle
向你们演示一些
Xcode Server的高级特性

00:31:27.988 --> 00:31:30.157 align:middle
和你们中的许多人一样

00:31:30.824 --> 00:31:33.260 align:middle
我们这个app也是内部开发的

00:31:33.327 --> 00:31:37.364 align:middle
不过我们也想把它分发出去我想要
非常容易地就能区分我的内部构建

00:31:37.698 --> 00:31:38.732 align:middle
以及我的外部构建

00:31:39.533 --> 00:31:42.169 align:middle
对此 最常见的一个策略是
如果我们看看我们的“资产目录”

00:31:42.236 --> 00:31:43.737 align:middle
我们就可以看到两张不同的图片

00:31:43.904 --> 00:31:46.240 align:middle
在第一个例子中
我们可以看到标准app图标

00:31:46.306 --> 00:31:48.408 align:middle
就是这个白色的咖啡杯

00:31:49.810 --> 00:31:51.712 align:middle
对于我们的内部构建来说

00:31:51.845 --> 00:31:55.249 align:middle
我们想要始终显示一个
黑色的咖啡杯图标

00:31:55.315 --> 00:31:56.450 align:middle
把它作为一个内部标记

00:31:56.917 --> 00:31:59.620 align:middle
这样的话 当我们在我们的
设备上运行内部构建时

00:32:00.354 --> 00:32:01.588 align:middle
我们就知道它们是内部构建

00:32:01.655 --> 00:32:04.758 align:middle
而不是我们可能上架App
Store或者通过我们的正常通道

00:32:04.825 --> 00:32:05.759 align:middle
分发出去的外部构建

00:32:06.627 --> 00:32:08.795 align:middle
这就非常有用
当我们发现一个bug时

00:32:09.429 --> 00:32:11.365 align:middle
我们就知道就希望只
有我们能看到这个bug

00:32:12.900 --> 00:32:15.602 align:middle
还有一种方式我们可以
用来区分我们的内部app

00:32:16.103 --> 00:32:17.938 align:middle
就是当我们运行内部构建时

00:32:18.472 --> 00:32:20.240 align:middle
我们通常都有一个设置包

00:32:20.307 --> 00:32:23.076 align:middle
在那个设置包中像很多应用程序一样

00:32:23.143 --> 00:32:25.379 align:middle
我们会定义一个版本
在这里就是版本2.0

00:32:25.445 --> 00:32:27.347 align:middle
因为我们刚刚做了一些很大的变更

00:32:28.048 --> 00:32:30.918 align:middle
2.0对于我们内部用户来说
已经足够完美了

00:32:30.984 --> 00:32:33.587 align:middle
不过向App Store提交时
我们不会提交这个版本

00:32:34.388 --> 00:32:37.391 align:middle
不过对于内部使用来说
我们可能还想要一些更多的细粒度信息

00:32:37.558 --> 00:32:40.427 align:middle
再进一步具体来说 我们想让
构建有某种唯一标识符

00:32:41.662 --> 00:32:44.131 align:middle
在这个例子中我想用
Xcode Server来区分

00:32:44.331 --> 00:32:48.735 align:middle
构建是来自在我的服务器上的哪个集成

00:32:49.703 --> 00:32:51.271 align:middle
我到Bot那里看看

00:32:52.739 --> 00:32:54.174 align:middle
这个Bot和我之前用的一样

00:32:54.241 --> 00:32:55.876 align:middle
我要编辑下这个工作流程

00:32:57.377 --> 00:32:59.646 align:middle
正如马特说的那样
现在这是完全非线性的

00:33:00.013 --> 00:33:02.516 align:middle
因为我对触发器最感兴趣
我就直接到那里了

00:33:04.117 --> 00:33:05.652 align:middle
让我们开始第一...

00:33:05.819 --> 00:33:07.688 align:middle
开始我们的第一步 变更图标

00:33:08.188 --> 00:33:10.424 align:middle
我要打开一个我已经写好的触发器脚本

00:33:10.891 --> 00:33:12.893 align:middle
在这个例子中
这是一个简单的批处理脚本

00:33:12.960 --> 00:33:14.795 align:middle
因为我们要做的都是简单的文件操作

00:33:15.028 --> 00:33:18.966 align:middle
我们要使用XES源目录环境变量

00:33:19.032 --> 00:33:22.603 align:middle
来找出那个app图标的路径

00:33:23.770 --> 00:33:25.506 align:middle
然后我们要把它删掉

00:33:26.139 --> 00:33:28.242 align:middle
然后我们要把我们的服务器版本取出来

00:33:28.308 --> 00:33:29.510 align:middle
把它移动到这个位置

00:33:30.143 --> 00:33:32.112 align:middle
那么这就会成为一个集成前触发器

00:33:32.279 --> 00:33:34.581 align:middle
因为我们想让它在我们的
源代码检查完毕

00:33:34.648 --> 00:33:37.150 align:middle
准备构建但是并没有真的
进行构建时运行

00:33:38.185 --> 00:33:41.121 align:middle
我要把它当成一个
运行脚本触发器来复制

00:33:42.656 --> 00:33:46.493 align:middle
现在对设置包进行设置就会有点棘手了

00:33:46.560 --> 00:33:48.929 align:middle
我可以使用一个批处理脚本
来设置 但是那就需要手动

00:33:48.996 --> 00:33:51.698 align:middle
编辑大量的批处理脚本
或者在一个批处理脚本中

00:33:51.765 --> 00:33:53.400 align:middle
放大量的plist代码会很痛苦

00:33:54.168 --> 00:33:57.070 align:middle
那么我要启用一个Swift触发器

00:33:57.738 --> 00:34:00.440 align:middle
在这个例子中和bash触发器类似

00:33:57.738 --> 00:34:00.440 align:middle
在这个例子中和bash触发器类似

00:34:00.507 --> 00:34:03.277 align:middle
我要给用户宾·斯威夫特
设置为使用hash bang

00:34:04.645 --> 00:34:07.814 align:middle
我还没有写完所以请等我一下

00:34:08.748 --> 00:34:11.051 align:middle
我要获取导入基础 我在那里就可以

00:34:11.485 --> 00:34:13.920 align:middle
获得我想从Swift获得的
其它额外的权限

00:34:14.721 --> 00:34:17.090 align:middle
导入基础后
我要使用NSProcess信息

00:34:17.157 --> 00:34:20.226 align:middle
来获得我在bash中其它脚本上
使用的

00:34:20.393 --> 00:34:22.362 align:middle
那些环境变量

00:34:22.462 --> 00:34:24.898 align:middle
在这个例子中就是XCS源目录

00:34:27.935 --> 00:34:30.504 align:middle
然后我要找到我所有的设置包

00:34:30.571 --> 00:34:32.873 align:middle
这里 有了Swift事情就更有趣了

00:34:32.940 --> 00:34:37.043 align:middle
我可以在Swift中
把plist当成一本字典载入

00:34:37.110 --> 00:34:40.380 align:middle
我并不需要亲自手动对plist文件
进行任何编辑

00:34:40.947 --> 00:34:44.083 align:middle
当我想往上面添加什么
东西时 这就非常有用

00:34:44.685 --> 00:34:47.521 align:middle
我只需要在swift中
创建一个新的字典常量

00:34:48.188 --> 00:34:50.456 align:middle
然后把它塞进我的字典中

00:34:51.558 --> 00:34:57.130 align:middle
这里我们把集成编号的
环境变量设置成这个构建编号标题

00:34:58.131 --> 00:35:01.001 align:middle
最后在完成脚本之前

00:34:58.131 --> 00:35:01.001 align:middle
最后在完成脚本之前

00:35:01.068 --> 00:35:02.803 align:middle
我要把它写出到磁盘

00:35:02.870 --> 00:35:07.307 align:middle
这样 当我们实际构建时
它就可以在我的设置包中被拾取到

00:35:08.542 --> 00:35:10.310 align:middle
为此 我只需要在下面
添加另一个触发器

00:35:11.512 --> 00:35:12.346 align:middle
好的

00:35:14.081 --> 00:35:15.382 align:middle
现在我有了两个触发器

00:35:17.317 --> 00:35:19.586 align:middle
现在 我就可以在这里推送
“现在开始集成”按钮

00:35:19.653 --> 00:35:21.488 align:middle
得到一个新的集成但是我想在服务器上

00:35:21.855 --> 00:35:24.992 align:middle
用一些马特提到的API来实现这个

00:35:26.460 --> 00:35:28.395 align:middle
我要再启用一个我拥有的应用程序

00:35:29.196 --> 00:35:32.833 align:middle
如果我们看这里
我们就能看到一个应用程序

00:35:32.900 --> 00:35:36.003 align:middle
它已经连接到了插入我的
电脑的一个串行设备上

00:35:37.070 --> 00:35:40.941 align:middle
它使用了示例代码的某些
输入/输出套件

00:35:41.008 --> 00:35:42.910 align:middle
那么我们就要来读取那个缓冲器

00:35:43.277 --> 00:35:46.613 align:middle
无论我们什么时候在那个缓冲器上看到
有内容我们就要运行这一代码块

00:35:47.281 --> 00:35:52.286 align:middle
我要打开一个NSURL会话我要调用
能够获得所有的Bot的API

00:35:52.886 --> 00:35:54.221 align:middle
这只不过是本地主机

00:35:54.288 --> 00:35:57.024 align:middle
马特之前提到过的端口API/Bot

00:35:57.191 --> 00:35:58.692 align:middle
就会成为get方法

00:35:59.560 --> 00:36:04.298 align:middle
我要调用它使用NS JSON序列化
API然后在各个Bot中

00:35:59.560 --> 00:36:04.298 align:middle
我要调用它使用NS JSON序列化
API然后在各个Bot中

00:36:04.565 --> 00:36:09.236 align:middle
进行读取 找出咖啡板Bot的ID

00:36:10.003 --> 00:36:11.205 align:middle
我想集成的就是那个Bot

00:36:12.539 --> 00:36:15.042 align:middle
有了那个ID 我就可以
像马特之前展示的那样

00:36:15.108 --> 00:36:16.543 align:middle
使用Bot/我的

00:36:16.844 --> 00:36:22.349 align:middle
通用唯一标识符/集成
创建一个新的URL

00:36:22.416 --> 00:36:24.651 align:middle
把那个请求切换成一个post请求

00:36:25.018 --> 00:36:26.620 align:middle
这样就会创建一个新集成

00:36:26.887 --> 00:36:29.556 align:middle
为此我们并不真的在意集成要做什么事

00:36:30.457 --> 00:36:31.992 align:middle
要触发这个

00:36:32.759 --> 00:36:35.162 align:middle
我设法绕过安全机制
取得了这个有趣的小按钮

00:36:35.863 --> 00:36:38.265 align:middle
我要把它插入我的Mac

00:36:41.101 --> 00:36:43.237 align:middle
然后我要运行这个应用程序

00:36:46.039 --> 00:36:47.107 align:middle
我们要再试试

00:36:53.046 --> 00:36:54.748 align:middle
在我运行之前确保它完全连接好了

00:36:55.349 --> 00:36:56.783 align:middle
不想操之过急 好的

00:36:58.051 --> 00:37:00.420 align:middle
很好 现在应用程序开始运行了
拾取了调制解调器

00:36:58.051 --> 00:37:00.420 align:middle
很好 现在应用程序开始运行了
拾取了调制解调器

00:37:00.854 --> 00:37:04.491 align:middle
我要在我的Bot这里放大下

00:37:04.558 --> 00:37:07.094 align:middle
然后等一会儿就是用这个按钮

00:37:08.629 --> 00:37:09.463 align:middle
创建一个新的集成

00:37:17.037 --> 00:37:19.072 align:middle
就是完全用我们的API中的这个按钮

00:37:19.239 --> 00:37:21.108 align:middle
我不想等待集成完毕
我要直接向你们展示

00:37:21.175 --> 00:37:24.378 align:middle
发生了什么 在这里我们可以看到集成

00:37:24.444 --> 00:37:27.881 align:middle
我可以把它安装到我之前
使用的本地设备上进行测试

00:37:29.283 --> 00:37:34.454 align:middle
安装 如果我打开QuickTime

00:37:35.756 --> 00:37:36.990 align:middle
你们就可以看到我看到的
东西...好的

00:37:42.396 --> 00:37:43.230 align:middle
这是我的设备

00:37:44.364 --> 00:37:46.433 align:middle
你可以看到我们在设备上有了内部图标

00:37:46.500 --> 00:37:47.968 align:middle
尽管我从来没有把它切换成本地

00:37:48.035 --> 00:37:50.470 align:middle
我们是从服务器上下载的
现在我们的app

00:37:51.271 --> 00:37:52.472 align:middle
我们知道 是一个内部构建

00:37:53.640 --> 00:37:56.376 align:middle
这些就是Xcode Server
上面的一些更多的高级特性

00:37:56.543 --> 00:38:00.147 align:middle
我要请马特再讲讲你们可以
在实验室的什么位置找到我们

00:37:56.543 --> 00:38:00.147 align:middle
我要请马特再讲讲你们可以
在实验室的什么位置找到我们

00:38:00.214 --> 00:38:01.348 align:middle
诸如此类的事情

00:38:02.382 --> 00:38:03.217 align:middle
马特？

00:38:09.523 --> 00:38:10.490 align:middle
好的 谢谢 埃里克

00:38:10.557 --> 00:38:11.692 align:middle
太棒了

00:38:11.959 --> 00:38:14.528 align:middle
我最喜欢按下大大的
红色按钮 进行集成了

00:38:17.531 --> 00:38:20.868 align:middle
这里还有一些更多的你们可以
在我们的API中使用的端点

00:38:20.934 --> 00:38:24.605 align:middle
或者最起码说对于你们这些
开发者来说是这样的

00:38:24.972 --> 00:38:29.676 align:middle
这些还有很多的端点
但是它们是被锁定的仅限内部使用

00:38:29.743 --> 00:38:34.982 align:middle
我们想要的是真正的安全确保当集成在
运行时不会和太多的东西混杂在一起

00:38:36.483 --> 00:38:38.585 align:middle
尤其与客户端服务器之间的交互

00:38:38.785 --> 00:38:40.988 align:middle
你可能会在更多的地方
而不仅仅是你的网络上

00:38:41.522 --> 00:38:42.656 align:middle
把你的服务器公开出去

00:38:43.590 --> 00:38:46.126 align:middle
不过当我们稍后上传了
这个开发视频以及幻灯片后

00:38:46.627 --> 00:38:51.598 align:middle
我建议你引用这个幻灯片
在你们自己的服务器上尝试这些端点

00:38:51.832 --> 00:38:52.999 align:middle
然后看看你们会得到什么

00:38:53.200 --> 00:38:54.902 align:middle
看看对于你们团队来说有什么有趣的事

00:38:57.404 --> 00:39:00.674 align:middle
今天我们看了我们在Xcode上对
Xcode Server所在的改进

00:38:57.404 --> 00:39:00.674 align:middle
今天我们看了我们在Xcode上对
Xcode Server所在的改进

00:39:00.741 --> 00:39:02.809 align:middle
无论是从质量方面来说

00:39:02.876 --> 00:39:06.013 align:middle
还是从采用添加到Xcode 7
中的新测试特性

00:39:06.079 --> 00:39:08.849 align:middle
来说 尤其是新的代码覆盖特性

00:39:09.149 --> 00:39:11.552 align:middle
用来度量你的应用程序
代码在你的测试中

00:39:11.618 --> 00:39:14.488 align:middle
实际被用到的情况真是再合适不过了

00:39:15.522 --> 00:39:17.324 align:middle
当然了我们也向你们演示了扩展

00:39:17.591 --> 00:39:20.928 align:middle
Xcode Server通过触发器
以及Xcode Server API把它

00:39:20.994 --> 00:39:23.430 align:middle
更好地与你们的
团队进行集成的两种方法

00:39:25.933 --> 00:39:27.634 align:middle
要获取更多信息我们有一个

00:39:27.701 --> 00:39:30.771 align:middle
开发者库有一个“持续集成指导”

00:39:31.271 --> 00:39:33.240 align:middle
当然了你也可以在开发者论坛上

00:39:33.307 --> 00:39:34.241 align:middle
贴出任何问题

00:39:36.310 --> 00:39:37.845 align:middle
有几场会议与此相关

00:39:38.111 --> 00:39:40.380 align:middle
它们都已经结束了

00:39:40.547 --> 00:39:42.049 align:middle
有些是刚刚结束的

00:39:42.716 --> 00:39:46.954 align:middle
昨天结束的是“Xcode中的UI
测试”不过我建议你们去看看视屏

00:39:47.020 --> 00:39:49.089 align:middle
今天我们也谈及了UI测试
但是我们并没有向你们演示

00:39:49.156 --> 00:39:50.390 align:middle
它在Server中是如何运作的

00:39:50.490 --> 00:39:53.527 align:middle
它的自动化程度很高
不过UI测试特性真的很棒

00:39:53.594 --> 00:39:54.661 align:middle
我建议你们去试试

00:39:55.429 --> 00:39:58.165 align:middle
如果关于如何使用Xcode
Server你想了解更多信息

00:39:58.232 --> 00:40:00.934 align:middle
那么去年我们在Xcode 6会议中
演示了如何从头开始

00:39:58.232 --> 00:40:00.934 align:middle
那么去年我们在Xcode 6会议中
演示了如何从头开始

00:40:01.001 --> 00:40:03.470 align:middle
设置你的服务器
如何在“持续集成”中

00:40:03.537 --> 00:40:07.207 align:middle
初始设置你的Bot

00:40:09.376 --> 00:40:12.079 align:middle
谢谢大家 祝你们在苹果全球开发者
大会剩余的时间内过得愉快
