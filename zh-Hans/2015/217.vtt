WEBVTT

00:00:20.988 --> 00:00:21.822 align:middle
早上好

00:00:22.155 --> 00:00:24.958 align:middle
采用新Trackpad特性

00:00:25.025 --> 00:00:26.493 align:middle
欢迎来到会议217：

00:00:26.560 --> 00:00:28.195 align:middle
“采用新Trackpad特性”

00:00:28.495 --> 00:00:30.764 align:middle
我叫罗利·雷德 我是一名
AppKit工程师

00:00:30.831 --> 00:00:33.700 align:middle
我是使用新的压力触控tra
ckpads方面的“大师”

00:00:34.735 --> 00:00:37.037 align:middle
我们接下来要讲的
就是这个

00:00:37.104 --> 00:00:38.739 align:middle
新的压力触控
trackpads

00:00:39.273 --> 00:00:42.309 align:middle
它们是很酷很酷的
技术

00:00:42.409 --> 00:00:44.845 align:middle
与我们之前的trackpads
不同之处在于

00:00:45.045 --> 00:00:48.182 align:middle
它没有可供你按压的
实体键

00:00:48.715 --> 00:00:51.218 align:middle
代替实体键的
是四个力传感器

00:00:51.485 --> 00:00:53.954 align:middle
这样我们就可以测量
用户对trackpad

00:00:54.021 --> 00:00:55.822 align:middle
施加了多大的力
然后我们会把它

00:00:55.889 --> 00:00:57.524 align:middle
和我们的Taptic引擎
结合起来

00:00:57.925 --> 00:00:58.759 align:middle
当我们确定用户
在trackpad

00:00:58.825 --> 00:01:01.361 align:middle
按压的力足够大
足以触发鼠标的时候

00:00:58.825 --> 00:01:01.361 align:middle
按压的力足够大
足以触发鼠标的时候

00:01:01.428 --> 00:01:02.829 align:middle
我们就会使用
Taptic引擎

00:01:02.896 --> 00:01:04.998 align:middle
把trackpad向侧面

00:01:05.331 --> 00:01:07.968 align:middle
稍微
拉一下

00:01:08.502 --> 00:01:10.304 align:middle
这样用户就会感觉

00:01:10.370 --> 00:01:12.673 align:middle
他们实际上已经按压到了
一个按钮

00:01:13.173 --> 00:01:15.108 align:middle
就是这样 trackpad
向侧面移动

00:01:15.342 --> 00:01:16.977 align:middle
但是你的大脑会让你以为

00:01:17.044 --> 00:01:18.579 align:middle
你实际上已经按压到了
一个按钮

00:01:18.879 --> 00:01:21.281 align:middle
这种感觉真的很棒
这样欺骗你的大脑

00:01:21.348 --> 00:01:23.150 align:middle
让你的大脑以为你已经

00:01:23.217 --> 00:01:24.685 align:middle
按压到了一个按钮
这真的很奇妙

00:01:24.751 --> 00:01:26.587 align:middle
我们楼下实验室有一些
trackpad

00:01:26.653 --> 00:01:28.155 align:middle
如果你还没有
体验过它

00:01:28.589 --> 00:01:29.756 align:middle
请下来试试

00:01:30.591 --> 00:01:33.460 align:middle
在那里顺便看看
Taptic引擎

00:01:34.061 --> 00:01:35.195 align:middle
真的很棒

00:01:35.395 --> 00:01:38.265 align:middle
概括一下
你施加了一点压力

00:01:38.332 --> 00:01:41.535 align:middle
我们给你算一次单击 但是当
你向trackpad施加

00:01:41.602 --> 00:01:45.305 align:middle
更大的力
我们也可以辨别出来

00:01:45.372 --> 00:01:46.373 align:middle
我们也可以感觉得到

00:01:46.440 --> 00:01:47.941 align:middle
我们称之为
Force click

00:01:48.008 --> 00:01:48.876 align:middle
我们也会给你一个
更加强烈的

00:01:48.942 --> 00:01:49.943 align:middle
触觉感受

00:01:50.878 --> 00:01:52.312 align:middle
那么有了
Force click

00:01:52.379 --> 00:01:53.647 align:middle
你就可以很多
好玩的事

00:01:53.847 --> 00:01:54.982 align:middle
事实上 让我给你演示一些

00:01:55.048 --> 00:01:57.451 align:middle
你现在就可以用Force
click做的好玩的事

00:02:03.423 --> 00:02:05.993 align:middle
像我这样
你可以看到我四处移动光标

00:02:06.126 --> 00:02:09.329 align:middle
你可以看到我对trackpad
施加的力

00:02:09.395 --> 00:02:12.799 align:middle
如果我再进一步 你就可以得
到Force click

00:02:12.999 --> 00:02:14.401 align:middle
那么
大家都听到了吧？

00:02:14.468 --> 00:02:15.502 align:middle
是我添加的 你知道

00:02:15.569 --> 00:02:16.837 align:middle
通常情况下 当你进行
Force click

00:02:16.904 --> 00:02:19.039 align:middle
的时候 你的电脑并不会
发出声音 我加了这个声音

00:02:19.106 --> 00:02:21.241 align:middle
是因为你们并不能实际
感受到这个触觉反馈 因为

00:02:21.308 --> 00:02:22.342 align:middle
你们在那里 而我在这里

00:02:22.910 --> 00:02:27.147 align:middle
这样 当我在演示中向tra
ckpad施加力的时候

00:02:27.214 --> 00:02:28.415 align:middle
你们就可以
观看了

00:02:29.149 --> 00:02:31.885 align:middle
你能做的一件事
就是在取景器中重命名文件

00:02:31.952 --> 00:02:33.620 align:middle
有时候
这有点棘手

00:02:33.687 --> 00:02:37.191 align:middle
你必须点击它
然后像这样

00:02:37.257 --> 00:02:39.293 align:middle
再来一次...
我又失败了

00:02:39.359 --> 00:02:40.294 align:middle
你的时间选择要正好

00:02:40.360 --> 00:02:41.695 align:middle
这样你才不会双击
打开它

00:02:42.196 --> 00:02:43.764 align:middle
但是有了
Force Touch

00:02:43.830 --> 00:02:45.699 align:middle
我就可以
Force click它

00:02:45.766 --> 00:02:48.302 align:middle
然后就立即
可以编辑文件名了

00:02:48.502 --> 00:02:49.336 align:middle
编辑文件名就非常容易了

00:02:49.403 --> 00:02:51.271 align:middle
但这只是你可以
用Force click

00:02:51.338 --> 00:02:52.606 align:middle
完成的事情中的
小小的一件

00:02:52.673 --> 00:02:54.608 align:middle
我要很快打开
TextEdit

00:02:55.242 --> 00:02:59.646 align:middle
我来捕获窗口

00:03:00.347 --> 00:03:02.049 align:middle
你也已经看过这个例子了

00:03:02.115 --> 00:03:03.417 align:middle
你可以
Force click

00:03:03.483 --> 00:03:05.686 align:middle
你就可以看到
“快速浏览”

00:03:05.752 --> 00:03:08.255 align:middle
非常奇妙
你可以坐在那儿 如果你

00:03:08.322 --> 00:03:12.492 align:middle
调整你施加的力的程度的话
你就可以“调戏”下动画

00:03:12.659 --> 00:03:15.495 align:middle
我们还有另外一项
功能特性

00:03:15.562 --> 00:03:18.065 align:middle
我刚才快速向你演示了
一些东西 这个你是知道的

00:03:18.131 --> 00:03:20.701 align:middle
通过改变力的大小
我可以改变速度

00:03:20.767 --> 00:03:23.470 align:middle
照片显示的速度

00:03:23.537 --> 00:03:27.341 align:middle
显示的指示器的量

00:03:27.407 --> 00:03:29.109 align:middle
你可以控制力的量

00:03:29.176 --> 00:03:31.612 align:middle
当然了
没有绘制区

00:03:31.678 --> 00:03:34.781 align:middle
你就没法绘制任何东西
压力演示也就没法完成

00:03:35.582 --> 00:03:38.452 align:middle
最后
不要像这样连接音响

00:03:38.519 --> 00:03:40.821 align:middle
而是要在
这个控制器上...

00:03:40.921 --> 00:03:42.256 align:middle
当你把照片
归零时

00:03:42.322 --> 00:03:43.957 align:middle
你会感受到
轻微的触觉反馈

00:03:44.258 --> 00:03:45.459 align:middle
就是在trackpad上

00:03:45.893 --> 00:03:47.694 align:middle
真的很奇妙

00:03:48.161 --> 00:03:49.429 align:middle
我们再回到幻灯片中

00:03:50.564 --> 00:03:51.765 align:middle
我们已经讲了很多东西

00:03:52.299 --> 00:03:53.433 align:middle
我们再来讲讲
API

00:03:53.500 --> 00:03:56.970 align:middle
就是那个应用程序用的API
就是我们在系统中使用的

00:03:57.037 --> 00:03:59.039 align:middle
各种API
这样你就可以在你的应用程序

00:03:59.106 --> 00:04:01.441 align:middle
中使用Force To
Touch trackpad

00:03:59.106 --> 00:04:01.441 align:middle
中使用Force To
Touch trackpad

00:04:01.508 --> 00:04:04.211 align:middle
添加
各种各样的

00:04:04.278 --> 00:04:05.112 align:middle
新的功能特性

00:04:06.947 --> 00:04:08.315 align:middle
我今天会教你如何成为

00:04:08.382 --> 00:04:09.783 align:middle
在OS X上使用Force
Touchtrackpad

00:04:09.850 --> 00:04:11.285 align:middle
的“大师”

00:04:11.351 --> 00:04:12.286 align:middle
要成为

00:04:12.352 --> 00:04:13.887 align:middle
Force Touch
trackpad方面的大师

00:04:13.954 --> 00:04:14.955 align:middle
尽管我们会让你在
一天内速成

00:04:15.022 --> 00:04:15.923 align:middle
你也得从小处着手

00:04:15.989 --> 00:04:17.089 align:middle
你得学习
所有的事情

00:04:17.156 --> 00:04:18.192 align:middle
你得学习一个“侍从”在使用

00:04:18.257 --> 00:04:19.358 align:middle
Force Touch
trackpad方面

00:04:19.426 --> 00:04:20.427 align:middle
全部的知识

00:04:20.494 --> 00:04:22.729 align:middle
这些都是与高级
API

00:04:23.030 --> 00:04:25.199 align:middle
以及内置工具相关
这些API和工具

00:04:25.265 --> 00:04:26.767 align:middle
有些是在我们的掌控下

00:04:27.301 --> 00:04:28.502 align:middle
然后我们会继续 我们需要
学习一名“骑士”在使用

00:04:28.569 --> 00:04:29.970 align:middle
Force Touch
trackpad方面

00:04:30.037 --> 00:04:31.538 align:middle
全部
的知识

00:04:31.905 --> 00:04:34.842 align:middle
这些都与压力流在
系统内的变化有关

00:04:34.908 --> 00:04:37.211 align:middle
事件流
我们会讲讲如何在你的

00:04:37.277 --> 00:04:39.646 align:middle
应用程序定制“弹性加载”
然后讲一讲进行

00:04:39.713 --> 00:04:41.081 align:middle
“对齐反馈”的方式

00:04:41.148 --> 00:04:43.417 align:middle
给用户提供
更多的触觉反馈

00:04:44.151 --> 00:04:47.087 align:middle
最后
我们会让你成为

00:04:47.154 --> 00:04:48.322 align:middle
Force Touch
trackpad

00:04:48.388 --> 00:04:49.223 align:middle
方面的“大师”

00:04:49.289 --> 00:04:50.390 align:middle
这与力的控制有关

00:04:50.524 --> 00:04:52.059 align:middle
对trackpad
进行配置

00:04:52.359 --> 00:04:54.795 align:middle
这样它可以在给定的情景中
给出适当的触觉反馈

00:04:54.862 --> 00:04:57.531 align:middle
以便你
进行控制

00:04:57.931 --> 00:05:00.234 align:middle
并且在适当时机
手动进行触觉反馈

00:04:57.931 --> 00:05:00.234 align:middle
并且在适当时机
手动进行触觉反馈

00:05:01.068 --> 00:05:02.703 align:middle
我们来看看吧

00:05:05.205 --> 00:05:08.408 align:middle
要成为一名“侍从” 我们要
说的是“表格行动作”

00:05:08.475 --> 00:05:10.010 align:middle
它是一项很棒 很奇妙的
新功能

00:05:10.077 --> 00:05:12.145 align:middle
你在克雷格在keynote
上进行的电子邮件应用程序

00:05:12.212 --> 00:05:13.380 align:middle
演示中
已经看到过了

00:05:13.814 --> 00:05:15.182 align:middle
我们来讲讲
弹性加载控制

00:05:15.249 --> 00:05:18.252 align:middle
内置的一些东西
还有加速器控制

00:05:18.619 --> 00:05:20.387 align:middle
我们会通过一些案例研究
来实现这一点

00:05:21.021 --> 00:05:24.124 align:middle
比如说 在邮件这里
如果你在邮件的某行上做

00:05:24.191 --> 00:05:27.194 align:middle
双指滑动这个动作
你会看到更多的

00:05:27.261 --> 00:05:28.762 align:middle
“表格行动作”
你就可以点击它们

00:05:28.896 --> 00:05:31.665 align:middle
或者你可以进行平滑的滑动
一个时间更长的滑动

00:05:31.732 --> 00:05:35.169 align:middle
实际上
它会激活默认动作

00:05:35.269 --> 00:05:37.171 align:middle
这是用户的完整手势
之一

00:05:37.538 --> 00:05:39.473 align:middle
这样向你的应用程序中

00:05:39.573 --> 00:05:41.141 align:middle
添加一些其它的功能
就

00:05:41.208 --> 00:05:42.075 align:middle
非常棒

00:05:42.142 --> 00:05:43.677 align:middle
我自己每天都在
邮件中用它

00:05:44.211 --> 00:05:45.913 align:middle
它用的API
非常简单

00:05:46.246 --> 00:05:47.347 align:middle
在你的tableView
授权中

00:05:47.414 --> 00:05:48.282 align:middle
只要实现

00:05:48.348 --> 00:05:49.183 align:middle
tableView ow

00:05:49.249 --> 00:05:50.250 align:middle
ActionsForRow
界限即可

00:05:50.317 --> 00:05:52.252 align:middle
我们会告诉你是什么界限
要么是前面的

00:05:52.319 --> 00:05:54.121 align:middle
要么是后面的
这样我们就可以为你处理为

00:05:54.188 --> 00:05:55.189 align:middle
从右到左 从左到右

00:05:56.523 --> 00:05:59.726 align:middle
然后你只要返回一个
“表格行动作”阵列

00:06:00.727 --> 00:06:04.998 align:middle
创建一个新NS表格行动作
你以一个类型 一个标题

00:06:05.065 --> 00:06:07.234 align:middle
以及一个处理程序
如果选中了一个项目

00:06:07.634 --> 00:06:11.104 align:middle
那么回调的就是这个处理程序
无论是点击选中

00:06:11.171 --> 00:06:13.207 align:middle
或者是完成了默认的
完整的滑动

00:06:13.574 --> 00:06:15.976 align:middle
那么它就会调用
处理程序

00:06:17.344 --> 00:06:20.080 align:middle
我们有这么几种类型：
“规则的”以及“破坏的”

00:06:20.881 --> 00:06:22.883 align:middle
蓝色高亮的
就是“规则的” 在你的

00:06:22.950 --> 00:06:25.552 align:middle
“表格行动作”大部分类型中
你都应该使用

00:06:25.619 --> 00:06:27.221 align:middle
“规则的”

00:06:27.855 --> 00:06:29.223 align:middle
红色的是
“破坏的”

00:06:29.957 --> 00:06:31.825 align:middle
不要因为它们的颜色
而做出选中

00:06:31.959 --> 00:06:33.360 align:middle
它不仅仅只是红色那么简单

00:06:35.128 --> 00:06:38.398 align:middle
破坏性的项目 因为它们
本质上就是破坏性的

00:06:38.465 --> 00:06:39.967 align:middle
事实上
我们也让用户更难完成一次

00:06:40.033 --> 00:06:41.635 align:middle
完整的滑动

00:06:41.768 --> 00:06:44.004 align:middle
他们必须在trackpad
上滑动较长的距离

00:06:44.271 --> 00:06:47.541 align:middle
这样才能触发
默认的

00:06:47.608 --> 00:06:48.442 align:middle
破坏性的动作

00:06:48.642 --> 00:06:51.345 align:middle
这样是为了防止他们
意外触发破坏性的动作

00:06:51.745 --> 00:06:54.181 align:middle
尽量在所有的事情上使用
“规则的”

00:06:54.248 --> 00:06:57.251 align:middle
把“破坏的”留给
破坏性的项目

00:06:57.317 --> 00:07:00.687 align:middle
不要尝试用红色
它的语义非常重要

00:06:57.317 --> 00:07:00.687 align:middle
不要尝试用红色
它的语义非常重要

00:07:00.754 --> 00:07:01.622 align:middle
你要注意这一点

00:07:03.223 --> 00:07:04.591 align:middle
这个API就是
这样

00:07:04.791 --> 00:07:05.626 align:middle
非常简单

00:07:05.792 --> 00:07:07.628 align:middle
这个适用于新的
Force Touch trackpad

00:07:07.694 --> 00:07:08.795 align:middle
也同样适用于我们的

00:07:08.862 --> 00:07:11.064 align:middle
老款trackpads
和Magic Mouse

00:07:11.265 --> 00:07:13.300 align:middle
这样你很容易就能把它们
加到你的应用程序中

00:07:13.600 --> 00:07:16.069 align:middle
你就可以开启新的
奇妙的可能

00:07:17.871 --> 00:07:19.740 align:middle
我们再来看看
取景器中的“弹性加载”

00:07:19.806 --> 00:07:23.677 align:middle
我这里有下载的一张
洛拉的图像

00:07:23.744 --> 00:07:25.746 align:middle
我想把她移动到
“我的文档”文件夹

00:07:25.812 --> 00:07:27.114 align:middle
我要通过
Force clicking

00:07:27.181 --> 00:07:28.348 align:middle
开始拖动它

00:07:28.415 --> 00:07:31.051 align:middle
回到我的历史
我甚至还要改成图标模式

00:07:31.118 --> 00:07:32.853 align:middle
这样我就能更加容易地
找到文档文件夹

00:07:33.020 --> 00:07:35.189 align:middle
最后 把它放进“我的文档”
文件夹

00:07:35.923 --> 00:07:38.025 align:middle
你之前可能已经知道了
弹性加载

00:07:38.392 --> 00:07:40.561 align:middle
你可以悬停在一个文件夹上
超时后

00:07:40.627 --> 00:07:43.330 align:middle
文件夹就会进行
弹性加载

00:07:43.664 --> 00:07:45.299 align:middle
我们向许多地方
和应用程序中添加了

00:07:45.365 --> 00:07:47.100 align:middle
弹性加载
以便把窗口置前

00:07:47.501 --> 00:07:49.436 align:middle
就像你刚才看到的
按钮是弹性加载的

00:07:49.670 --> 00:07:52.306 align:middle
你只要进行Force
click 就可以越过

00:07:52.372 --> 00:07:53.473 align:middle
悬停超时

00:07:53.540 --> 00:07:58.078 align:middle
这样用起来就更直观
更便利

00:07:59.346 --> 00:08:02.082 align:middle
要在这项工具栏按钮上

00:07:59.346 --> 00:08:02.082 align:middle
要在这项工具栏按钮上

00:08:02.149 --> 00:08:05.652 align:middle
实现弹性加载
取景器所做的

00:08:05.719 --> 00:08:08.255 align:middle
就是把NSButton的弹
性加载属性设置为“真”

00:08:09.189 --> 00:08:10.724 align:middle
他们就是在IB内校验了下
框

00:08:10.791 --> 00:08:11.692 align:middle
就这么简单

00:08:11.758 --> 00:08:13.894 align:middle
分段控制
你也可以这么做

00:08:13.961 --> 00:08:17.631 align:middle
当我把图标布局
从列表视图改为图标视图

00:08:18.031 --> 00:08:19.433 align:middle
那就是
NSSegmentedControl

00:08:19.499 --> 00:08:21.702 align:middle
再说一遍 它就是个
springLoaded属性

00:08:21.768 --> 00:08:23.937 align:middle
你可以在IB的一个勾选框
上进行设置

00:08:24.004 --> 00:08:27.140 align:middle
在你的按钮 分段控制上
打开弹性加载

00:08:27.407 --> 00:08:28.408 align:middle
就这么简单

00:08:28.642 --> 00:08:31.078 align:middle
你可以勾选使用
但是如果是

00:08:31.144 --> 00:08:33.080 align:middle
在导航中
那么拖放

00:08:33.145 --> 00:08:34.948 align:middle
就很有用
我建议你们去试试

00:08:35.015 --> 00:08:35.916 align:middle
打开它

00:08:37.384 --> 00:08:40.354 align:middle
这是施加力的另一个实例
这是QuickTime

00:08:40.419 --> 00:08:42.856 align:middle
我想让你们注意看这里的
这个快进按钮

00:08:44.057 --> 00:08:45.325 align:middle
我要使用
ForceTouchtrackpad

00:08:45.392 --> 00:08:46.660 align:middle
我要向那个按钮

00:08:46.727 --> 00:08:48.095 align:middle
施加不同的
压力

00:08:48.161 --> 00:08:50.497 align:middle
你可以看到 我可以达到5x
10x 30x

00:08:50.764 --> 00:08:51.598 align:middle
你也可以放慢速度

00:08:51.999 --> 00:08:53.734 align:middle
当你翻看你的
电影文件时

00:08:54.067 --> 00:08:55.969 align:middle
你可以控制前进的
速度

00:08:56.036 --> 00:08:58.138 align:middle
当你接近你要找的区域时
你就可以放慢速度

00:08:58.205 --> 00:09:00.040 align:middle
避免
跑过头

00:08:58.205 --> 00:09:00.040 align:middle
避免
跑过头

00:09:01.808 --> 00:09:03.410 align:middle
QuickTime能这样做
是因为

00:09:03.477 --> 00:09:04.845 align:middle
我们有了一种新的按钮类型

00:09:04.912 --> 00:09:08.815 align:middle
因此快进按钮就是带有自定义
图像的NSButtons

00:09:08.882 --> 00:09:11.518 align:middle
它们可以
把按钮的类型设为

00:09:11.652 --> 00:09:13.253 align:middle
Accelerator
Button或者

00:09:13.320 --> 00:09:14.855 align:middle
MultiLevel
AcceleratorButton

00:09:15.522 --> 00:09:17.057 align:middle
对Accelerator
Button来说

00:09:17.124 --> 00:09:18.592 align:middle
你可以在IB这里设置

00:09:20.594 --> 00:09:23.096 align:middle
当trackpad上的力
发生改变时

00:09:23.363 --> 00:09:25.432 align:middle
这个按钮就会持续
发送活动消息

00:09:25.532 --> 00:09:27.601 align:middle
因此当力发生改变时
你就会得到新的活动消息

00:09:27.734 --> 00:09:29.736 align:middle
如果力再次发生改变
你又会收到新的活动消息

00:09:30.270 --> 00:09:33.006 align:middle
当用户点击按钮达到
两次时

00:09:33.073 --> 00:09:35.609 align:middle
doubleValue的域
为1 这是因为

00:09:35.676 --> 00:09:38.679 align:middle
用户达到了
我们在trackpad上

00:09:38.745 --> 00:09:41.682 align:middle
接受的力的按压的最大值

00:09:42.850 --> 00:09:45.552 align:middle
你可以看到
压力在1到2之间变动

00:09:45.619 --> 00:09:48.288 align:middle
你可以
随意

00:09:48.355 --> 00:09:49.656 align:middle
对它
进行调整

00:09:49.723 --> 00:09:52.960 align:middle
QuickTime这个实例
中 它控制的是加速度

00:09:54.027 --> 00:09:55.729 align:middle
你最终得到的值
为零

00:09:55.796 --> 00:09:58.065 align:middle
当用户结束追踪按钮时
你会得到

00:09:58.131 --> 00:10:00.334 align:middle
一条值为零的
活动消息

00:09:58.131 --> 00:10:00.334 align:middle
一条值为零的
活动消息

00:10:00.634 --> 00:10:01.935 align:middle
当他们释放
鼠标按钮时

00:10:02.402 --> 00:10:04.471 align:middle
你会得到最后一条
域为零的活动消息

00:10:05.506 --> 00:10:07.441 align:middle
实际上 QuickTime
在这里使用的

00:10:07.508 --> 00:10:09.409 align:middle
就是MultiLevel
AcceleratorButton

00:10:09.977 --> 00:10:11.712 align:middle
你可以在IB这里
进行设置

00:10:12.312 --> 00:10:13.981 align:middle
MultiLevel
AcceleratorButton

00:10:14.047 --> 00:10:15.616 align:middle
是离散的

00:10:15.983 --> 00:10:19.753 align:middle
而AcceleratorB
utton是一个平滑域

00:10:19.820 --> 00:10:21.455 align:middle
一个介于一到二之间的
连续域

00:10:21.622 --> 00:10:24.291 align:middle
AcceleratorBu
tton是整数层

00:10:24.358 --> 00:10:25.959 align:middle
是一个离散整数层
你可以用

00:10:26.026 --> 00:10:28.295 align:middle
max
AcceleratorLevel

00:10:28.362 --> 00:10:29.329 align:middle
对它 进行设置

00:10:29.663 --> 00:10:33.166 align:middle
我们的域是介于一到五
因此你可以设置

00:10:33.233 --> 00:10:35.169 align:middle
在你的加速中
你想要的层数

00:10:35.936 --> 00:10:37.704 align:middle
默认是二

00:10:38.205 --> 00:10:39.806 align:middle
QuickTime把它设置
成了五

00:10:40.274 --> 00:10:42.242 align:middle
你又看到了
doubleValue

00:10:42.309 --> 00:10:45.212 align:middle
域为零到五
当你点击时为一

00:10:45.279 --> 00:10:46.713 align:middle
当用户上升
层级时

00:10:46.780 --> 00:10:48.982 align:middle
它会上升到
你设置的最大层级

00:10:49.349 --> 00:10:51.652 align:middle
当用户停止追踪时
你会得到零的最终

00:10:51.718 --> 00:10:53.287 align:middle
活动消息

00:10:53.387 --> 00:10:54.888 align:middle
QuickTime做的
就是这个

00:10:54.955 --> 00:10:55.889 align:middle
这里你可以看到

00:10:55.956 --> 00:10:57.658 align:middle
QuickTime是
如何映射你的各种速度为

00:10:57.724 --> 00:11:00.494 align:middle
一、二、三、四、五

00:10:57.724 --> 00:11:00.494 align:middle
一、二、三、四、五

00:11:00.561 --> 00:11:03.463 align:middle
比如说
三就是10x快进

00:11:05.666 --> 00:11:08.769 align:middle
加速器控制的另一个实例：
这是“地图”

00:11:09.436 --> 00:11:11.171 align:middle
“地图”上有这个
漂亮的缩放按钮

00:11:11.972 --> 00:11:13.473 align:middle
实际上

00:11:13.540 --> 00:11:16.143 align:middle
这些是当做NSSegmented
Controls

00:11:16.210 --> 00:11:17.044 align:middle
实现的

00:11:17.144 --> 00:11:18.212 align:middle
NSSegmentedControls

00:11:18.278 --> 00:11:19.179 align:middle
有一种新的追踪模式

00:11:19.246 --> 00:11:21.048 align:middle
即Momentary
Accelerator

00:11:21.114 --> 00:11:24.017 align:middle
它和加速器
NSButtonType

00:11:24.084 --> 00:11:26.653 align:middle
的工作方式一模一样

00:11:27.387 --> 00:11:29.156 align:middle
在IB中设置这个
同样也非常容易

00:11:30.190 --> 00:11:31.692 align:middle
但是当分段控制活动消息
发出后

00:11:31.758 --> 00:11:34.595 align:middle
你应该请求选定的分段的
doubleValue

00:11:34.761 --> 00:11:35.963 align:middle
而不是
请求

00:11:36.029 --> 00:11:37.231 align:middle
doubleValue

00:11:37.698 --> 00:11:40.334 align:middle
它和我们之前谈到的
域是一样的

00:11:40.400 --> 00:11:43.937 align:middle
当用户结束追踪时
它为一到二

00:11:44.004 --> 00:11:45.105 align:middle
并且最后活动消息值为零

00:11:46.440 --> 00:11:49.209 align:middle
分段控制
没有多层选项

00:11:49.443 --> 00:11:51.912 align:middle
它们仅仅支持
连续模式

00:11:55.048 --> 00:11:56.350 align:middle
这是一个照片的例子

00:11:57.184 --> 00:12:02.389 align:middle
通过施加力 调整力
浏览

00:11:57.184 --> 00:12:02.389 align:middle
通过施加力 调整力
浏览

00:12:03.090 --> 00:12:04.258 align:middle
“照片”中的照片

00:12:04.324 --> 00:12:07.027 align:middle
我可以控制照片移动的
速度

00:12:07.794 --> 00:12:10.898 align:middle
我们称之为
连续加速控制

00:12:11.598 --> 00:12:13.233 align:middle
如果你在NSButton

00:12:13.300 --> 00:12:14.568 align:middle
或者NSSegmented
Control上

00:12:14.635 --> 00:12:16.203 align:middle
有一项
加速控制设置

00:12:16.537 --> 00:12:18.272 align:middle
你可以在
NSControl节

00:12:18.338 --> 00:12:20.140 align:middle
把连续标志设置为“真”

00:12:20.340 --> 00:12:22.042 align:middle
或者在IB中勾选框

00:12:22.776 --> 00:12:26.380 align:middle
你就可以得到我们所说的
连续加速控制

00:12:27.181 --> 00:12:29.116 align:middle
连续加速控制
是不同的

00:12:29.183 --> 00:12:30.884 align:middle
因为你不太需要关心

00:12:30.951 --> 00:12:31.852 align:middle
它们的
doubleValues

00:12:31.919 --> 00:12:33.921 align:middle
当动作发生时
你只是想尽快移动到

00:12:33.987 --> 00:12:34.888 align:middle
下一个滑动上

00:12:34.955 --> 00:12:37.024 align:middle
doubleValue
无关紧要

00:12:37.090 --> 00:12:39.193 align:middle
它们会像心跳一样
回来

00:12:39.359 --> 00:12:41.662 align:middle
而力会改变
心跳的频率

00:12:42.029 --> 00:12:42.996 align:middle
这就是区别所在

00:12:43.263 --> 00:12:46.400 align:middle
要把问题讲清楚
让我们来对两者进行对比

00:12:46.967 --> 00:12:48.068 align:middle
在加速控制中

00:12:48.936 --> 00:12:51.638 align:middle
只要压力发生变化 我们
就可以获取到你的活动消息

00:12:51.705 --> 00:12:53.841 align:middle
因此
可能会有延迟

00:12:54.041 --> 00:12:56.043 align:middle
它们可能会互相靠近

00:12:56.243 --> 00:12:58.378 align:middle
这样你就改变了
你在电影中

00:12:58.445 --> 00:12:59.279 align:middle
的快进速度

00:13:00.280 --> 00:13:04.952 align:middle
如果是连续控制
对连续加速来说

00:13:05.018 --> 00:13:06.186 align:middle
它会参加到心跳中

00:13:06.253 --> 00:13:07.754 align:middle
然后你就可以
完成你的动作

00:13:07.921 --> 00:13:09.923 align:middle
如果用户施加了多次力
频率会很高

00:13:09.990 --> 00:13:12.559 align:middle
它们
可能会

00:13:12.626 --> 00:13:13.460 align:middle
紧密结合起来

00:13:13.527 --> 00:13:16.763 align:middle
像滑动照片
此时动画速度是连续的

00:13:16.830 --> 00:13:19.199 align:middle
它就非常适合
不过你何时应该呈现

00:13:19.266 --> 00:13:20.501 align:middle
下一张照片？

00:13:20.734 --> 00:13:22.436 align:middle
应该在
下次发出活动消息时呈现

00:13:22.703 --> 00:13:24.171 align:middle
它为用户提供了
许多控制

00:13:25.472 --> 00:13:27.274 align:middle
要成为一个“侍从”
你需要了解的就这些

00:13:27.341 --> 00:13:28.876 align:middle
恭喜
你们现在都成了使用

00:13:28.942 --> 00:13:30.711 align:middle
Force Touch
trackpads方面的“侍从”

00:13:30.777 --> 00:13:33.514 align:middle
我们讲了“表格行动作”
一个非常容易实现的API

00:13:33.580 --> 00:13:35.949 align:middle
弹性加载
NSButtons

00:13:36.016 --> 00:13:38.452 align:middle
加速器NS
Buttons 分段控制

00:13:38.585 --> 00:13:41.522 align:middle
打开它们很容易
我们的高层API

00:13:41.622 --> 00:13:45.092 align:middle
使用这些API
在这里真的物有所值

00:13:45.392 --> 00:13:47.327 align:middle
我们希望你们在你们的
应用程序内打开它们

00:13:48.428 --> 00:13:49.596 align:middle
我们接着来看看
怎样成为一名“骑士”

00:13:50.531 --> 00:13:51.665 align:middle
要成为一名“骑士”

00:13:51.732 --> 00:13:54.201 align:middle
那就需要理解力在系统内的
流动方式

00:13:54.701 --> 00:13:56.570 align:middle
我们来讲一下
力的事件流

00:13:57.437 --> 00:13:58.438 align:middle
然后我会讲一下

00:13:58.505 --> 00:14:01.074 align:middle
弹性加载
协议

00:13:58.505 --> 00:14:01.074 align:middle
弹性加载
协议

00:14:01.141 --> 00:14:04.778 align:middle
这样你就可以使用和
NSButton相同的API

00:14:04.978 --> 00:14:07.381 align:middle
在你的自定义应用程序内
提供弹性加载

00:14:08.015 --> 00:14:11.451 align:middle
我们最后会谈一些
对齐反馈API

00:14:11.518 --> 00:14:15.122 align:middle
可以帮助你进行对齐
指导以及类似的事情

00:14:16.390 --> 00:14:17.391 align:middle
我们再来谈谈
事件流

00:14:18.292 --> 00:14:20.427 align:middle
我们在OS X已经
有了很多事件

00:14:21.228 --> 00:14:23.096 align:middle
你向上和向下移动鼠标

00:14:23.163 --> 00:14:26.233 align:middle
你的放大 旋转
手势

00:14:26.500 --> 00:14:27.901 align:middle
现在我们再介绍一个：

00:14:28.001 --> 00:14:29.303 align:middle
NSEventType
Pressure

00:14:30.103 --> 00:14:32.506 align:middle
实际上 它是我们在10.1
0.3介绍

00:14:32.573 --> 00:14:33.941 align:middle
新MacBooks时
引入的

00:14:34.274 --> 00:14:37.711 align:middle
你也可以在那里
获得

00:14:38.712 --> 00:14:40.080 align:middle
它们是压力手势

00:14:41.114 --> 00:14:42.783 align:middle
当然了
和新的事件类型

00:14:42.850 --> 00:14:46.520 align:middle
我们有事件掩码：
NSEventMaskPressure

00:14:46.854 --> 00:14:49.056 align:middle
这意味着
在你的跟踪回路中

00:14:49.590 --> 00:14:51.158 align:middle
你可以向你的跟踪回路中
添加

00:14:51.225 --> 00:14:52.993 align:middle
事件掩码压力

00:14:53.694 --> 00:14:56.730 align:middle
当你追踪鼠标时
你也可以让

00:14:56.797 --> 00:14:58.432 align:middle
压力事件
起作用

00:14:59.166 --> 00:15:00.200 align:middle
使用真的很方便

00:14:59.166 --> 00:15:00.200 align:middle
使用真的很方便

00:15:01.702 --> 00:15:03.504 align:middle
如果你更喜欢
响应器这种方式 这样你可以

00:15:03.570 --> 00:15:06.640 align:middle
覆盖鼠标向上
鼠标拖动 鼠标向下

00:15:06.707 --> 00:15:08.642 align:middle
我们也还有一种新的
响应器方式

00:15:08.709 --> 00:15:10.043 align:middle
pressureChange
WithEvent

00:15:10.110 --> 00:15:11.011 align:middle
这样如果你喜欢的话

00:15:11.078 --> 00:15:11.979 align:middle
你就可以获取它们

00:15:14.348 --> 00:15:17.317 align:middle
我们再来挖掘下
压力手势的属性

00:15:17.651 --> 00:15:20.420 align:middle
这是一种手势
和鼠标事件序列不同

00:15:20.487 --> 00:15:23.190 align:middle
后者为鼠标上移 鼠标拖动
鼠标下移有个体类型

00:15:23.257 --> 00:15:26.593 align:middle
压力只有
单一类型

00:15:26.960 --> 00:15:29.897 align:middle
它有一个段
会经历开始 改变 结束

00:15:30.130 --> 00:15:32.065 align:middle
这样的一个循环
直到手势结束

00:15:33.534 --> 00:15:34.701 align:middle
我们也有一个阶段

00:15:34.835 --> 00:15:35.869 align:middle
阶段是指我们如何确定

00:15:35.936 --> 00:15:37.437 align:middle
Force click
是否发生了

00:15:37.804 --> 00:15:40.707 align:middle
当你用trackpad
进行鼠标下移

00:15:40.774 --> 00:15:43.343 align:middle
你会得到“开始”段

00:15:43.410 --> 00:15:46.346 align:middle
压力手势
它是阶段一

00:15:46.413 --> 00:15:48.882 align:middle
这是标准
点击层次

00:15:48.949 --> 00:15:50.484 align:middle
用户增加力度

00:15:50.551 --> 00:15:51.952 align:middle
在trackpad上达到了
Force click

00:15:52.019 --> 00:15:53.687 align:middle
层级
就变成了阶段二

00:15:53.754 --> 00:15:56.390 align:middle
这样你就知道用户实现了
Force click

00:15:56.790 --> 00:15:59.459 align:middle
你就可以立即完成你的For
ce click动作

00:15:59.526 --> 00:16:01.728 align:middle
比如说
重命名取景器

00:15:59.526 --> 00:16:01.728 align:middle
比如说
重命名取景器

00:16:02.763 --> 00:16:03.964 align:middle
这样当用户
从trackpad上

00:16:04.031 --> 00:16:05.332 align:middle
释放力的时候

00:16:05.799 --> 00:16:08.035 align:middle
当它到达点击层级时
就会返回阶段一

00:16:08.101 --> 00:16:10.504 align:middle
当手势结束时
最终到了阶段零

00:16:10.904 --> 00:16:15.275 align:middle
因为鼠标按下去后
就不再往下了

00:16:15.742 --> 00:16:19.913 align:middle
这样得到了阶段零
“结束”段的最后事件

00:16:21.849 --> 00:16:25.152 align:middle
现在 当然了
没有真正的压力值

00:16:25.219 --> 00:16:26.620 align:middle
就不会完成任何
压力手势

00:16:26.687 --> 00:16:28.322 align:middle
因此我们也有
压力属性

00:16:28.388 --> 00:16:29.723 align:middle
它的域为
零到一

00:16:30.858 --> 00:16:32.159 align:middle
注意这里

00:16:32.226 --> 00:16:34.328 align:middle
压力属性
就是当前阶段的

00:16:34.394 --> 00:16:35.395 align:middle
压力

00:16:35.462 --> 00:16:36.730 align:middle
正如你在这个图表中看到的

00:16:36.797 --> 00:16:39.499 align:middle
当你进入阶段一
压力开始上升

00:16:39.566 --> 00:16:43.003 align:middle
并且在你进入阶段二时
达到了1

00:16:43.070 --> 00:16:45.239 align:middle
当你越过阶段二
压力立即掉回了零

00:16:45.305 --> 00:16:47.574 align:middle
当你在阶段二增加压力时
压力又重新

00:16:47.975 --> 00:16:51.445 align:middle
开始
上升

00:16:51.512 --> 00:16:54.381 align:middle
压力属于
当前阶段

00:16:55.015 --> 00:16:55.849 align:middle
现在我展示的是

00:16:57.217 --> 00:16:59.953 align:middle
trackpad上的力
和用户在压力事件中的值

00:17:00.020 --> 00:17:03.357 align:middle
这两者
之间的

00:17:03.423 --> 00:17:05.459 align:middle
线性映射
但是

00:17:05.526 --> 00:17:06.527 align:middle
我不希望你们过度曲解

00:17:07.160 --> 00:17:10.263 align:middle
我们喜欢把trackpad
上的每次点击

00:17:10.329 --> 00:17:12.999 align:middle
都当成一次冒险
我们看到了很多

00:17:13.066 --> 00:17:15.769 align:middle
不同的变量
用户使用他们的拇指

00:17:15.836 --> 00:17:18.505 align:middle
他们偏好的
硬度设置

00:17:18.972 --> 00:17:20.874 align:middle
他们如何与trackpad
进行交互

00:17:20.941 --> 00:17:23.109 align:middle
因此我们忙着对这些曲线
进行动态变更

00:17:23.176 --> 00:17:25.145 align:middle
给用户
尽可能好的体验

00:17:25.512 --> 00:17:28.281 align:middle
我们把trackpad的输
入标准化为

00:17:28.682 --> 00:17:30.484 align:middle
零到一的
压力域

00:17:30.784 --> 00:17:32.452 align:middle
你在你的应用程序中
也应该用这个

00:17:35.055 --> 00:17:37.157 align:middle
你可能注意到了
之前我在演示时四处点击

00:17:37.224 --> 00:17:39.826 align:middle
仅仅在TextEdit
四处点击

00:17:40.394 --> 00:17:44.965 align:middle
我并不会看到
动画弹出

00:17:45.032 --> 00:17:46.834 align:middle
直到我离的足够近
施加的压力非常接近

00:17:46.900 --> 00:17:47.901 align:middle
Force click

00:17:48.936 --> 00:17:51.371 align:middle
当用户只是随意点击时
你不会希望有

00:17:51.438 --> 00:17:52.673 align:middle
一大堆的动画
出现

00:17:52.739 --> 00:17:54.174 align:middle
分散
用户的注意

00:17:54.341 --> 00:17:57.845 align:middle
当他们接近转移到
阶段二时

00:17:57.911 --> 00:17:59.012 align:middle
这个动画很有用

00:17:59.346 --> 00:18:00.981 align:middle
阶段的
转移属性

00:17:59.346 --> 00:18:00.981 align:middle
阶段的
转移属性

00:18:01.048 --> 00:18:02.015 align:middle
就是用来干这个的

00:18:02.149 --> 00:18:04.284 align:middle
你可以在这里看到
它的域为零到一

00:18:04.351 --> 00:18:07.154 align:middle
但是在零这里
停留了很长时间

00:18:07.221 --> 00:18:09.389 align:middle
直到你开始
接近下一阶段

00:18:09.456 --> 00:18:10.490 align:middle
这个例子中是阶段二

00:18:11.058 --> 00:18:13.927 align:middle
我想让你们接近阶段二
它会暴涨到一

00:18:13.994 --> 00:18:17.731 align:middle
你可以用这个域
控制你的动画

00:18:18.031 --> 00:18:19.600 align:middle
而如果你只是在界面内
随意点击

00:18:19.666 --> 00:18:21.168 align:middle
它就不会妨碍你

00:18:21.635 --> 00:18:23.604 align:middle
你可以得到这个动画
你一接近阶段二

00:18:23.670 --> 00:18:26.006 align:middle
你就可以弹出
结束动画

00:18:26.073 --> 00:18:29.510 align:middle
你可以看到
你一接近阶段二

00:18:29.576 --> 00:18:32.346 align:middle
阶段过渡值就掉回了零
在这个例子中

00:18:32.412 --> 00:18:34.982 align:middle
我们没有阶段三可以过渡
因此剩余的时间

00:18:35.048 --> 00:18:36.717 align:middle
它仍然停在零

00:18:38.085 --> 00:18:42.222 align:middle
我之前提到过
当压力手势存在

00:18:42.289 --> 00:18:45.392 align:middle
鼠标事件
也就同时继续

00:18:45.492 --> 00:18:47.761 align:middle
trackpad还是会
继续模仿鼠标

00:18:48.695 --> 00:18:51.632 align:middle
它也会发出
压力手势

00:18:51.698 --> 00:18:54.034 align:middle
我要看看
这些流是如何在系统中

00:18:54.101 --> 00:18:55.335 align:middle
同时并行

00:18:55.669 --> 00:18:56.770 align:middle
我们接着要讲的
就是这个

00:18:56.837 --> 00:19:00.841 align:middle
这是一个实例 用户向tra
ckpad施加力

00:18:56.837 --> 00:19:00.841 align:middle
这是一个实例 用户向tra
ckpad施加力

00:19:01.141 --> 00:19:02.242 align:middle
进行点击
慢慢接近

00:19:02.309 --> 00:19:03.710 align:middle
Force click
阈值

00:19:03.777 --> 00:19:05.245 align:middle
然后释放了
压力

00:19:05.312 --> 00:19:06.180 align:middle
这就是他们的输入

00:19:06.513 --> 00:19:08.949 align:middle
下面这里
我们要向你演示

00:19:09.016 --> 00:19:10.217 align:middle
进入你的应用程序的事件

00:19:11.051 --> 00:19:13.253 align:middle
一开始
用户施加的是轻微的压力

00:19:13.854 --> 00:19:15.789 align:middle
这些就是全部的鼠标移动

00:19:15.856 --> 00:19:18.058 align:middle
我们还没有到达
点击阈值

00:19:18.392 --> 00:19:20.394 align:middle
我们还没有开始
压力手势

00:19:20.494 --> 00:19:21.628 align:middle
这些只是鼠标移动

00:19:21.795 --> 00:19:23.597 align:middle
还没有
压力手势进来

00:19:24.698 --> 00:19:27.034 align:middle
你达到点击阈值
出现了鼠标下移

00:19:27.568 --> 00:19:31.138 align:middle
你也到了阶段一
得到压力开始事件

00:19:31.438 --> 00:19:33.674 align:middle
此时
压力值要变成零

00:19:34.274 --> 00:19:35.142 align:middle
我们不能保证

00:19:35.209 --> 00:19:38.178 align:middle
是压力开始事件先发生
还是

00:19:38.245 --> 00:19:41.114 align:middle
鼠标向下先发生
它们有时候会交换位置

00:19:41.882 --> 00:19:45.252 align:middle
处理这个最容易的方式
是寻找鼠标向下这个事件

00:19:45.319 --> 00:19:47.354 align:middle
如果你也要压力事件
那么在鼠标向下发生之后

00:19:47.421 --> 00:19:49.022 align:middle
继续寻找
压力事件

00:19:50.390 --> 00:19:53.026 align:middle
当用户开始向trackpa
d施加更多的力

00:19:53.093 --> 00:19:54.995 align:middle
你可以看到 当我们接近
Force click阈值时

00:19:55.062 --> 00:19:56.697 align:middle
压力
朝着一升上去了

00:19:57.197 --> 00:19:58.999 align:middle
如果光标移动
这些将作为鼠标拖动事件

00:19:59.066 --> 00:20:00.267 align:middle
体现出来

00:19:59.066 --> 00:20:00.267 align:middle
体现出来

00:20:00.334 --> 00:20:01.602 align:middle
你就有了鼠标拖动事件
以及

00:20:01.668 --> 00:20:03.570 align:middle
压力事件
我们仍然处于阶段一

00:20:04.037 --> 00:20:05.739 align:middle
我们达到了Force
click阈值

00:20:06.340 --> 00:20:08.575 align:middle
现在你在阶段二得到了
压力手势

00:20:08.642 --> 00:20:11.278 align:middle
压力值
一路掉回了零

00:20:12.079 --> 00:20:14.515 align:middle
用户继续向trackpad
施加更大的力

00:20:14.815 --> 00:20:17.117 align:middle
压力再次开始增加 当他们从
trackpad上释放

00:20:17.184 --> 00:20:18.986 align:middle
压力时
它就开始

00:20:19.052 --> 00:20:20.420 align:middle
朝着零回落

00:20:20.988 --> 00:20:23.190 align:middle
现在他们释放回到了Forc
e click阈值

00:20:23.257 --> 00:20:24.324 align:middle
压力为零

00:20:25.859 --> 00:20:27.427 align:middle
此时
我们仍然处于阶段二

00:20:28.295 --> 00:20:30.531 align:middle
用户再多释放
一点压力

00:20:30.664 --> 00:20:31.899 align:middle
我们也仍然处于阶段二

00:20:32.533 --> 00:20:34.601 align:middle
实际上 在这个图表上
我们夸张了一点

00:20:35.102 --> 00:20:37.638 align:middle
不过对于一个人来说
在trackpad上以一个

00:20:37.704 --> 00:20:39.706 align:middle
恒速保持压力
非常困难

00:20:39.773 --> 00:20:42.209 align:middle
如果他们恰好处于Force
click层级 他们就会

00:20:42.276 --> 00:20:44.444 align:middle
超越 然后略微下降
我们并不希望

00:20:44.511 --> 00:20:45.979 align:middle
触发 关闭Force
click

00:20:46.046 --> 00:20:47.181 align:middle
触发 关闭 触发 关闭

00:20:47.247 --> 00:20:48.615 align:middle
这不是用户
想做的

00:20:48.916 --> 00:20:52.319 align:middle
我们要求你往Force
click阈值下

00:20:52.386 --> 00:20:55.856 align:middle
多降一点
直到我们最终脱离阶段二

00:20:56.390 --> 00:20:58.992 align:middle
然后我们给你最终的
阶段一事件

00:20:59.493 --> 00:21:00.594 align:middle
在那个小的时间段内

00:20:59.493 --> 00:21:00.594 align:middle
在那个小的时间段内

00:21:00.661 --> 00:21:03.964 align:middle
事件的压力
将为零

00:21:04.298 --> 00:21:06.233 align:middle
很明显 你在Force
click阈值下方

00:21:06.300 --> 00:21:07.868 align:middle
压力将会
开始上升

00:21:09.403 --> 00:21:13.140 align:middle
既然你处于阶段一
用户继续释放

00:21:13.340 --> 00:21:16.276 align:middle
压力上升
再次开始回来

00:21:16.343 --> 00:21:18.412 align:middle
你注意到 它并不是
一路跳回阶段一

00:21:18.478 --> 00:21:20.047 align:middle
因为那是
间隙的一部分

00:21:20.647 --> 00:21:23.450 align:middle
要注意的一点是
这就是为什么你不应该

00:21:23.517 --> 00:21:25.519 align:middle
尝试合并阶段一
和阶段二 获得更大的

00:21:25.586 --> 00:21:27.487 align:middle
动态范围的
原因

00:21:27.554 --> 00:21:30.157 align:middle
但我们到了“大师”阶段时
我们会再

00:21:30.224 --> 00:21:32.326 align:middle
多谈谈

00:21:32.659 --> 00:21:33.894 align:middle
无论何时发生阶段二

00:21:33.961 --> 00:21:37.097 align:middle
我们也会自动提供触觉反馈
因此不要尝试把

00:21:37.164 --> 00:21:38.899 align:middle
压力
合并到两个阶段

00:21:39.233 --> 00:21:41.869 align:middle
要么看着阶段一 使用压力
要么看着阶段二 使用压力

00:21:41.969 --> 00:21:43.403 align:middle
如果你需要在后者
进行你的动画

00:21:43.470 --> 00:21:46.273 align:middle
或者
阶段过渡属性

00:21:48.942 --> 00:21:52.212 align:middle
我们达到了阶段一的
点击阈值点

00:21:52.279 --> 00:21:53.514 align:middle
因此你的压力现在回到了零

00:21:53.580 --> 00:21:55.415 align:middle
就像我们用
Force click阈值

00:21:55.482 --> 00:21:57.017 align:middle
做的那样
实际上 在我们

00:21:57.084 --> 00:21:58.685 align:middle
最终从阶段一释放之前

00:21:58.752 --> 00:22:03.490 align:middle
用户
必须释放更多的力

00:21:58.752 --> 00:22:03.490 align:middle
用户
必须释放更多的力

00:22:04.124 --> 00:22:06.693 align:middle
我们要施加一个力
结束时阶段为零

00:22:06.760 --> 00:22:08.495 align:middle
鼠标上移

00:22:08.896 --> 00:22:11.198 align:middle
还是这样
无法保证是鼠标上移先发生

00:22:11.265 --> 00:22:13.634 align:middle
还是
压力结束事件

00:22:14.101 --> 00:22:16.737 align:middle
先发生
处理这个最容易的方式是：

00:22:16.803 --> 00:22:19.439 align:middle
寻找鼠标上移
同时追踪压力

00:22:19.506 --> 00:22:21.108 align:middle
和鼠标运动
直到

00:22:21.175 --> 00:22:22.976 align:middle
发生了鼠标上移

00:22:23.243 --> 00:22:25.612 align:middle
忽略任何可能在压力事件
之前

00:22:25.679 --> 00:22:26.747 align:middle
之后发生的序列

00:22:27.247 --> 00:22:31.885 align:middle
这个适用于Mice
也同样适用于我们的

00:22:31.952 --> 00:22:33.220 align:middle
老款trackpads

00:22:33.287 --> 00:22:34.454 align:middle
以及新
ForceTouchtrackpads

00:22:35.055 --> 00:22:37.457 align:middle
最后 鼠标上移后
如果用户用非常非常轻微的

00:22:37.524 --> 00:22:39.927 align:middle
压力四处移动
这些鼠标移动

00:22:40.093 --> 00:22:42.396 align:middle
压力手势结束了
我们会再次开始循环

00:22:42.462 --> 00:22:44.131 align:middle
就像
我们一开始做的那样

00:22:45.966 --> 00:22:49.102 align:middle
如果压力会和这个鼠标下移
联系起来

00:22:49.169 --> 00:22:50.904 align:middle
了解鼠标下移

00:22:50.971 --> 00:22:53.407 align:middle
就
非常重要

00:22:53.607 --> 00:22:56.610 align:middle
是否来自一台
模仿鼠标的设备？

00:22:56.677 --> 00:22:58.712 align:middle
是否给出了
压力手势事件？

00:22:59.313 --> 00:23:01.815 align:middle
我们就是通过使用
鼠标下移事件上的

00:22:59.313 --> 00:23:01.815 align:middle
我们就是通过使用
鼠标下移事件上的

00:23:01.882 --> 00:23:04.017 align:middle
associatedEve
ntMask属性

00:23:04.484 --> 00:23:06.153 align:middle
来帮助你做这个

00:23:06.220 --> 00:23:08.222 align:middle
你在鼠标移动事件上
也可以看到这个

00:23:09.089 --> 00:23:09.990 align:middle
使用真的非常方便

00:23:10.991 --> 00:23:12.860 align:middle
你为associated
EventMask

00:23:12.926 --> 00:23:13.861 align:middle
请求鼠标下移事件

00:23:13.927 --> 00:23:16.363 align:middle
你发现它包括了
EventMaskPressure

00:23:16.430 --> 00:23:18.198 align:middle
如果你正在使用Cocoa

00:23:18.265 --> 00:23:20.200 align:middle
你就用
NSEventMaskPressure

00:23:20.267 --> 00:23:21.735 align:middle
把它结束了

00:23:21.802 --> 00:23:23.237 align:middle
因为你正在校验
位域

00:23:24.605 --> 00:23:27.040 align:middle
如果它确实包括EventM
askPressure

00:23:27.107 --> 00:23:29.376 align:middle
你知道压力事件
就要来了

00:23:29.443 --> 00:23:32.746 align:middle
你就可以把它设置好 这样
你就可以有不同的笔刷宽度

00:23:33.013 --> 00:23:34.014 align:middle
比如说在你绘画时

00:23:34.081 --> 00:23:34.915 align:middle
这很棒

00:23:35.415 --> 00:23:37.150 align:middle
如果它不包括
EventMaskPressure

00:23:37.618 --> 00:23:41.221 align:middle
那么它就来自一个鼠标
或者 比如说

00:23:41.288 --> 00:23:43.090 align:middle
一台老款trackpad
此时你想选择一个默认的

00:23:43.156 --> 00:23:45.192 align:middle
笔刷宽度

00:23:45.259 --> 00:23:47.961 align:middle
通常你在此时选择
最大的笔刷宽度

00:23:48.328 --> 00:23:51.532 align:middle
或者你想要选择
一半的笔刷宽度

00:23:51.732 --> 00:23:53.166 align:middle
你在整个鼠标拖动序列中

00:23:53.600 --> 00:23:55.969 align:middle
都
使用这个定值

00:23:57.738 --> 00:24:01.141 align:middle
这是新EventTypeP
ressure

00:23:57.738 --> 00:24:01.141 align:middle
这是新EventTypeP
ressure

00:24:02.543 --> 00:24:05.179 align:middle
它有很多新属性
有一个段

00:24:05.546 --> 00:24:07.681 align:middle
因为它是一个手势
当前阶段的压力

00:24:07.748 --> 00:24:10.751 align:middle
位于零到一
的域内

00:24:11.051 --> 00:24:12.653 align:middle
当然你有阶段
你很容易就可以看到

00:24:12.719 --> 00:24:14.288 align:middle
当用户达到
Force click

00:24:14.354 --> 00:24:15.556 align:middle
那些过渡动画的阶段过渡

00:24:15.622 --> 00:24:17.257 align:middle
相连
事件掩码

00:24:17.324 --> 00:24:20.194 align:middle
你知道 当你的鼠标事件
会有压力

00:24:20.260 --> 00:24:21.828 align:middle
与它们
相连时

00:24:22.196 --> 00:24:24.031 align:middle
当然
如果你使用了响应器方式

00:24:24.097 --> 00:24:25.332 align:middle
事件响应器方式

00:24:25.532 --> 00:24:26.834 align:middle
会引起
压力变化

00:24:28.335 --> 00:24:29.736 align:middle
我们再来讲讲
弹性加载

00:24:29.803 --> 00:24:31.905 align:middle
讲一讲NSButton是如
何实现弹性加载的

00:24:32.039 --> 00:24:34.641 align:middle
你可以在你的定制控制器中
使用完全相同的API

00:24:34.708 --> 00:24:36.543 align:middle
向你的应用程序添加
弹性加载

00:24:37.911 --> 00:24:38.779 align:middle
这是一个

00:24:38.846 --> 00:24:40.814 align:middle
NSSpringLoadingDestination
协议

00:24:40.881 --> 00:24:42.416 align:middle
如果你曾经实施过的话

00:24:42.482 --> 00:24:43.984 align:middle
它和
NSDraggingDestination

00:24:44.051 --> 00:24:45.018 align:middle
协议非常类似

00:24:46.787 --> 00:24:49.656 align:middle
在你的目标中
在你的目标视图中

00:24:49.723 --> 00:24:51.325 align:middle
你需要实现
springLoadingEntered

00:24:51.391 --> 00:24:52.559 align:middle
或springLoadingUpdated

00:24:53.260 --> 00:24:54.962 align:middle
这里给你一个实例
看看是如何实现的：

00:24:55.195 --> 00:24:56.330 align:middle
NSButton实现

00:24:56.396 --> 00:24:57.631 align:middle
springLoading
Entered

00:24:57.698 --> 00:24:59.099 align:middle
而不是
springLoadingUpdated

00:24:59.299 --> 00:25:01.368 align:middle
因为一个按钮要么是
激活的 要么是禁止的

00:24:59.299 --> 00:25:01.368 align:middle
因为一个按钮要么是
激活的 要么是禁止的

00:25:01.435 --> 00:25:02.769 align:middle
因此
你一按住按钮

00:25:03.070 --> 00:25:06.139 align:middle
它就会返回弹性加载选项
然后它就

00:25:06.206 --> 00:25:07.341 align:middle
在生命期内就不变了

00:25:07.407 --> 00:25:08.775 align:middle
拖曳
就发生在按钮中

00:25:09.476 --> 00:25:11.245 align:middle
NSSegmentedControl
另一方面

00:25:11.311 --> 00:25:12.846 align:middle
实现了
springLoadingUpdated

00:25:13.313 --> 00:25:15.983 align:middle
每个段都可能是激活的
或者禁止的 彼此独立

00:25:16.049 --> 00:25:17.651 align:middle
是一个视图

00:25:17.718 --> 00:25:19.620 align:middle
因此有了
springLoadingUpdated

00:25:20.153 --> 00:25:23.290 align:middle
分段控制就可以对拖曳
进行观察 精确找出拖曳

00:25:23.357 --> 00:25:24.491 align:middle
在控制器哪里

00:25:24.558 --> 00:25:26.393 align:middle
如何动态改变
弹性加载选项的

00:25:26.894 --> 00:25:28.729 align:middle
就像我提到过的 你需要...

00:25:29.062 --> 00:25:30.430 align:middle
如果你实现其中的
一个方式

00:25:31.164 --> 00:25:32.766 align:middle
你需要实现
弹性加载选项

00:25:33.333 --> 00:25:35.936 align:middle
如果你愿意
你可以两者都实现

00:25:36.003 --> 00:25:37.704 align:middle
你并不需要仅仅实现
其中一个 但是

00:25:37.771 --> 00:25:38.872 align:middle
你最起码要实现其中一个

00:25:39.540 --> 00:25:41.041 align:middle
对你的弹性加载选项来说
很明显

00:25:41.108 --> 00:25:43.577 align:middle
你返回弹性加载选项应该是
“激活的”还是“禁止的”

00:25:43.644 --> 00:25:45.379 align:middle
非常简单

00:25:45.746 --> 00:25:47.548 align:middle
我们还有其它一些
有趣的选项

00:25:47.614 --> 00:25:49.016 align:middle
持续激活

00:25:49.550 --> 00:25:52.452 align:middle
一般来说
弹性加载动作是离散的

00:25:52.519 --> 00:25:53.520 align:middle
弹性加载产生了

00:25:53.754 --> 00:25:56.857 align:middle
按钮发出了动作
结束了

00:25:57.157 --> 00:25:58.659 align:middle
还有一个持续版本
我们在下面的

00:25:58.725 --> 00:26:00.394 align:middle
幻灯片中 会

00:25:58.725 --> 00:26:00.394 align:middle
幻灯片中 会

00:26:00.460 --> 00:26:02.129 align:middle
讲到

00:26:02.763 --> 00:26:04.097 align:middle
我想再讲讲没有悬停的情况

00:26:05.499 --> 00:26:07.634 align:middle
就像我之前提到的
弹性加载可以通过

00:26:07.701 --> 00:26:09.303 align:middle
悬停或者
Force click激活

00:26:09.369 --> 00:26:11.071 align:middle
悬停非常适合

00:26:11.138 --> 00:26:12.506 align:middle
没有Force Touch
trackpads的

00:26:12.573 --> 00:26:13.574 align:middle
人群

00:26:14.675 --> 00:26:17.211 align:middle
举例来说
如果你想在一块很大的画布上

00:26:17.277 --> 00:26:18.579 align:middle
进行
Force click

00:26:18.946 --> 00:26:20.214 align:middle
用户把项目拖拽过画布

00:26:20.280 --> 00:26:22.983 align:middle
他们只是试图
拖到画布另一边

00:26:23.150 --> 00:26:24.751 align:middle
他们抬起手指
回来继续拖拽

00:26:24.818 --> 00:26:26.553 align:middle
或者抬起鼠标
继续拖拽

00:26:26.620 --> 00:26:27.788 align:middle
这个时间可能会很长

00:26:28.422 --> 00:26:30.490 align:middle
光标停住不动
而

00:26:30.557 --> 00:26:34.127 align:middle
弹性加载
一直处于激活状态

00:26:35.162 --> 00:26:37.097 align:middle
这就是一个
假的激活

00:26:37.164 --> 00:26:38.732 align:middle
这不是用户试图
做的

00:26:39.399 --> 00:26:41.134 align:middle
如果因为悬停 你收到了
大量假的激活

00:26:41.201 --> 00:26:43.203 align:middle
如果你遇到了这种情况
你可能想考虑下

00:26:43.837 --> 00:26:47.074 align:middle
无悬停
弹性加载选项

00:26:47.274 --> 00:26:48.742 align:middle
用户就可以用

00:26:48.809 --> 00:26:49.943 align:middle
Force Touch
trackpad进行

00:26:50.010 --> 00:26:52.379 align:middle
Force click
在你的视图的那个位置

00:26:52.513 --> 00:26:53.480 align:middle
得到弹性加载

00:26:54.314 --> 00:26:57.484 align:middle
你要保守地使用
使用之前务必三思

00:26:57.551 --> 00:26:59.086 align:middle
因为我们不想遗漏任何没有
Force Touch trackpad

00:26:59.152 --> 00:27:00.687 align:middle
的 用户

00:26:59.152 --> 00:27:00.687 align:middle
的 用户

00:27:01.054 --> 00:27:03.824 align:middle
但是如果你收到了
大量的假的激活

00:27:04.024 --> 00:27:05.626 align:middle
那么偶尔用一个这个选项
就很好

00:27:07.661 --> 00:27:08.629 align:middle
与springLoading
Entered

00:27:08.695 --> 00:27:10.130 align:middle
和“已更新”一起
我们当然还有

00:27:10.197 --> 00:27:11.164 align:middle
springLoadingExited...

00:27:11.231 --> 00:27:13.767 align:middle
当用户退出了你的视图
它就会告诉你

00:27:13.967 --> 00:27:15.502 align:middle
还有draggingEnded

00:27:15.569 --> 00:27:17.738 align:middle
弹性加载是
拖放操作的一部分

00:27:17.804 --> 00:27:21.742 align:middle
因此如果用户
拖过了你的视图

00:27:21.942 --> 00:27:24.645 align:middle
你的弹性加载
目的

00:27:24.845 --> 00:27:26.547 align:middle
你实现了
draggingEnded

00:27:26.880 --> 00:27:29.283 align:middle
当拖拽完成后
当用户释放了鼠标

00:27:29.349 --> 00:27:30.684 align:middle
取消了拖拽

00:27:31.385 --> 00:27:33.253 align:middle
你会拿回
draggingEnded

00:27:33.387 --> 00:27:37.057 align:middle
无论用户是在你的应用程序中
还是在另一个进程中

00:27:37.124 --> 00:27:39.059 align:middle
完成了拖拽
都不重要

00:27:39.493 --> 00:27:41.862 align:middle
任何实现了
draggingUpdated的人

00:27:41.929 --> 00:27:43.130 align:middle
都会得到他们的回调

00:27:45.432 --> 00:27:46.834 align:middle
因为这是拖拽的一部分

00:27:47.367 --> 00:27:48.836 align:middle
NSDraggingDestination

00:27:48.902 --> 00:27:52.973 align:middle
还有一个
draggingEnded函数

00:27:53.173 --> 00:27:54.741 align:middle
它和我们这里的函数
一模一样

00:27:54.975 --> 00:27:57.277 align:middle
如果你同时使用了
弹性加载目的

00:27:57.344 --> 00:27:59.546 align:middle
和NSDragging
Destination

00:27:59.947 --> 00:28:00.814 align:middle
那么你只需要

00:27:59.947 --> 00:28:00.814 align:middle
那么你只需要

00:28:00.881 --> 00:28:02.583 align:middle
实现一个
draggingEnded

00:28:02.649 --> 00:28:04.918 align:middle
它会应用于两者之上
因此如果你同时使用了

00:28:04.985 --> 00:28:07.287 align:middle
弹性加载目的
和拖拽目的

00:28:07.688 --> 00:28:09.556 align:middle
你就需要为弹性加载目的
和拖拽目的

00:28:09.623 --> 00:28:11.425 align:middle
完成
清除工作

00:28:13.093 --> 00:28:15.596 align:middle
现在我们来看看
弹性加载真正好玩的地方

00:28:15.996 --> 00:28:18.899 align:middle
因此 要求你实现
springLoadingActivated

00:28:18.966 --> 00:28:21.735 align:middle
我们就是在这里
告诉你的目的

00:28:21.802 --> 00:28:23.270 align:middle
用户进行了弹性加载

00:28:24.471 --> 00:28:26.273 align:middle
我们有一个布尔值
通常这个值为“是”

00:28:26.607 --> 00:28:29.109 align:middle
就像我提到的
弹性加载是一个离散动作

00:28:29.176 --> 00:28:32.045 align:middle
它发生了
NSButton刚刚发生了动作

00:28:32.913 --> 00:28:36.183 align:middle
大家都满意了

00:28:36.416 --> 00:28:39.486 align:middle
但是 如果
你有连续位组

00:28:39.553 --> 00:28:40.754 align:middle
那么只要用户
进行Force click

00:28:41.388 --> 00:28:43.123 align:middle
我们会发送一个
springLoadingActivated“是”

00:28:43.190 --> 00:28:45.492 align:middle
你可以启动一个计时器
你可以继续

00:28:45.692 --> 00:28:47.995 align:middle
往那个计时器添加你的
活动消息

00:28:48.061 --> 00:28:51.732 align:middle
当你从
Force click释放后 它会回复给你

00:28:51.999 --> 00:28:54.134 align:middle
一个springLoading
Activated“否”

00:28:54.201 --> 00:28:56.537 align:middle
你就知道你该关闭
你的计时器了

00:28:56.937 --> 00:28:58.472 align:middle
如果用户使用悬停

00:28:58.539 --> 00:29:00.474 align:middle
当悬停超时时 你会得到

00:28:58.539 --> 00:29:00.474 align:middle
当悬停超时时 你会得到

00:29:00.541 --> 00:29:02.042 align:middle
springLoadingActivated
“是”

00:29:02.109 --> 00:29:03.844 align:middle
当它们从控制器移出时
你就会得到

00:29:03.911 --> 00:29:05.379 align:middle
一个
“否”

00:29:06.513 --> 00:29:09.016 align:middle
要把这个和
正常的离散动作进行对比

00:29:09.149 --> 00:29:10.851 align:middle
通常是在释放
Force click时

00:29:10.918 --> 00:29:12.719 align:middle
来自Force click的
弹性加载

00:29:12.786 --> 00:29:14.154 align:middle
它们会一路进入
Force click

00:29:14.221 --> 00:29:15.522 align:middle
当它们释放Force click

00:29:15.589 --> 00:29:17.324 align:middle
如果你不是连续使用
你就会得到

00:29:17.391 --> 00:29:18.892 align:middle
一个springLoadingActivated
“是”

00:29:18.959 --> 00:29:22.095 align:middle
除非你在弹性加载时
需要连续发出你的活动消息

00:29:22.162 --> 00:29:23.297 align:middle
那么我们通常

00:29:23.363 --> 00:29:27.134 align:middle
会建议你
用它

00:29:28.902 --> 00:29:29.903 align:middle
最后 我们有

00:29:29.970 --> 00:29:31.305 align:middle
springLoading
HighlightChanged

00:29:31.638 --> 00:29:33.640 align:middle
我们希望给用户提供反馈
告诉它们当前的情况

00:29:33.707 --> 00:29:35.742 align:middle
我们有三种高亮形式：不高亮

00:29:35.976 --> 00:29:37.244 align:middle
标准高亮 增强高亮

00:29:38.679 --> 00:29:40.414 align:middle
当你得到一个

00:29:40.480 --> 00:29:42.216 align:middle
springLoading
HighlightChanged

00:29:42.282 --> 00:29:44.751 align:middle
消息 你需要告诉
draggingInfo那个

00:29:44.818 --> 00:29:46.520 align:middle
springLoading
Highlight是为了什么

00:29:46.587 --> 00:29:48.188 align:middle
设置需要展示的视图

00:29:48.255 --> 00:29:51.491 align:middle
然后你就可以更新
在正确的高亮显示

00:29:51.558 --> 00:29:52.860 align:middle
那里绘画

00:29:54.228 --> 00:29:56.697 align:middle
重要的是
不要试图推断

00:29:56.763 --> 00:29:59.466 align:middle
用户的
任何动作

00:29:59.900 --> 00:30:02.035 align:middle
这就是springLoadingActivated
的用途

00:29:59.900 --> 00:30:02.035 align:middle
这就是springLoadingActivated
的用途

00:30:04.238 --> 00:30:08.075 align:middle
就像当你从一个菜单中
选择一个项目时

00:30:08.141 --> 00:30:10.444 align:middle
我们会让那个菜单项目闪烁
让用户知道 确认他们已经

00:30:10.511 --> 00:30:13.413 align:middle
选择了那个项目
我们在弹性加载中

00:30:13.480 --> 00:30:14.882 align:middle
也做了类似的事

00:30:14.948 --> 00:30:17.317 align:middle
我们是通过改变高亮
实现的

00:30:17.684 --> 00:30:19.586 align:middle
因此你需要做的
就是用任何需要的

00:30:19.653 --> 00:30:21.722 align:middle
高亮方式绘画
然后你的应用程序的

00:30:22.089 --> 00:30:24.791 align:middle
风格就会和
系统的其它地方

00:30:24.858 --> 00:30:25.993 align:middle
保持一致

00:30:26.360 --> 00:30:27.995 align:middle
使用springLoadingActivated
来知道何时

00:30:28.061 --> 00:30:29.463 align:middle
发出
活动消息

00:30:30.898 --> 00:30:32.266 align:middle
这是弹性加载
目的

00:30:33.233 --> 00:30:34.835 align:middle
我们有对齐反馈 当你在
Interface Builder中

00:30:34.902 --> 00:30:37.004 align:middle
有两个项目在一起时
你可以看到这个

00:30:37.070 --> 00:30:39.273 align:middle
我们把它们对齐了
绘制了这个漂亮的对齐指导

00:30:40.107 --> 00:30:42.476 align:middle
我们有一些新的API
能帮助你实现这一点

00:30:42.643 --> 00:30:45.245 align:middle
绘图由你决定
但是我们的新API能帮助你

00:30:45.312 --> 00:30:46.313 align:middle
决定何时应该对齐

00:30:47.080 --> 00:30:50.551 align:middle
这里给你一个例子
我们来看看这个跟踪回路

00:30:50.617 --> 00:30:51.718 align:middle
一个典型的跟踪回路

00:30:51.785 --> 00:30:53.620 align:middle
我们放大下

00:30:53.687 --> 00:30:54.888 align:middle
你得到了你的鼠标下移事件

00:30:54.955 --> 00:30:57.758 align:middle
你找出你的事件掩码是什么
你想要追踪哪个事件

00:30:57.824 --> 00:31:01.662 align:middle
你请求下个事件
你移动你的项目

00:30:57.824 --> 00:31:01.662 align:middle
你请求下个事件
你移动你的项目

00:31:01.762 --> 00:31:04.097 align:middle
更新你的数据模型
设置你的需求显示

00:31:04.164 --> 00:31:06.700 align:middle
鼠标上移了吗？没有
你就继续这个循环

00:31:06.867 --> 00:31:10.270 align:middle
无论drawRect什么时候被调用
你就绘制

00:31:10.337 --> 00:31:12.573 align:middle
你把你的项目拖过屏幕
直到发生了鼠标上移

00:31:13.373 --> 00:31:14.208 align:middle
我们有一个

00:31:14.274 --> 00:31:16.410 align:middle
NSAlignmentFeedbackFilter
对象

00:31:16.476 --> 00:31:17.778 align:middle
能帮到你

00:31:18.946 --> 00:31:20.380 align:middle
你把鼠标上移
你做的第一件事

00:31:20.447 --> 00:31:21.915 align:middle
你从对齐反馈过滤器中

00:31:21.982 --> 00:31:23.851 align:middle
得到
输入事件掩码

00:31:24.952 --> 00:31:27.688 align:middle
对齐反馈过滤器需要知道
这个

00:31:27.754 --> 00:31:29.189 align:middle
当你调用
nextEventMatchingMask时

00:31:29.256 --> 00:31:31.425 align:middle
你只需要或者把它们 或者

00:31:31.491 --> 00:31:34.661 align:middle
把它们的并集 在Swift实例中
和你的事件掩码并运算

00:31:35.562 --> 00:31:38.866 align:middle
你一旦得到下个事件
你要做的第一件事

00:31:38.932 --> 00:31:41.201 align:middle
就是把事件送到
对齐反馈过滤器

00:31:41.268 --> 00:31:42.436 align:middle
它会立即返回

00:31:42.503 --> 00:31:44.104 align:middle
它只是更新一些
内部状态

00:31:44.938 --> 00:31:48.675 align:middle
你移动...不好意思 如果
你使用的是pan手势识别器

00:31:48.742 --> 00:31:51.011 align:middle
你也可以用pan手势识别器
来进行更新

00:31:51.078 --> 00:31:52.746 align:middle
它和跟踪回路工作方式
十分类似

00:31:52.980 --> 00:31:56.283 align:middle
一切都适用
除了这个消息差异

00:31:58.252 --> 00:31:59.953 align:middle
对齐反馈过滤器一旦
处理完输出 返回后

00:32:00.020 --> 00:32:03.524 align:middle
像你平常那样
你把项目移到你的数据模型

00:32:03.590 --> 00:32:06.093 align:middle
然后
你准备对齐

00:32:06.627 --> 00:32:09.296 align:middle
我们来挖掘一下准备对齐
你得使用对齐反馈过滤器

00:32:09.363 --> 00:32:11.632 align:middle
来帮助你
实现这一点

00:32:12.199 --> 00:32:14.668 align:middle
我们之前在数据模型中
有对象

00:32:14.735 --> 00:32:17.171 align:middle
我们得到了事件
我们决定用户移动到这里

00:32:17.271 --> 00:32:18.639 align:middle
如果我们不进行任何对齐

00:32:19.072 --> 00:32:20.741 align:middle
这里就是
默认位置

00:32:20.841 --> 00:32:22.476 align:middle
这是对象
结束的地方

00:32:23.243 --> 00:32:26.280 align:middle
我们想知道：是否应该
在这里对齐 是否应该

00:32:26.346 --> 00:32:29.082 align:middle
向下对齐这条线 或者我们
是否要同时对齐

00:32:29.149 --> 00:32:30.384 align:middle
弄到下面角落里

00:32:31.418 --> 00:32:34.188 align:middle
使用对齐反馈过滤器
对象来帮助你

00:32:34.254 --> 00:32:35.088 align:middle
决定这个

00:32:35.155 --> 00:32:36.223 align:middle
alignmentFeedback
Token

00:32:36.290 --> 00:32:37.724 align:middle
ForHorizontal
MovementInView

00:32:37.791 --> 00:32:40.394 align:middle
previousX
alignedX和defaultX

00:32:40.794 --> 00:32:43.030 align:middle
这些坐标都位于
窗口坐标空格上

00:32:43.096 --> 00:32:47.201 align:middle
因此无论你在视图内
的缩放层级是什么

00:32:47.267 --> 00:32:48.502 align:middle
它都工作的
很好

00:32:49.837 --> 00:32:51.972 align:middle
如果发生对齐
我们就会返回给你一个

00:32:52.039 --> 00:32:54.308 align:middle
对齐反馈
令牌

00:32:55.008 --> 00:32:56.577 align:middle
如果你没有得到
对齐反馈令牌

00:32:56.643 --> 00:32:57.644 align:middle
那就不要进行任何对齐

00:32:57.711 --> 00:32:59.079 align:middle
如果你得到了
对齐反馈令牌

00:32:59.413 --> 00:33:01.782 align:middle
在这个例子中 在你的
数据模型中改变X位置

00:32:59.413 --> 00:33:01.782 align:middle
在这个例子中 在你的
数据模型中改变X位置

00:33:02.015 --> 00:33:04.484 align:middle
改变为对齐位置
留住那个

00:33:04.551 --> 00:33:05.719 align:middle
对齐反馈令牌

00:33:06.653 --> 00:33:09.256 align:middle
然后你也可以校验
纵向运动

00:33:09.323 --> 00:33:11.525 align:middle
除了你要发送你的Y值
代替你的X

00:33:11.825 --> 00:33:14.394 align:middle
你还是可能得到 或者得不到
对齐反馈令牌

00:33:14.962 --> 00:33:17.064 align:middle
如果你得到两个
对齐反馈令牌 你就需要

00:33:17.130 --> 00:33:19.466 align:middle
在两个轴线中对齐
这样你的对象就会

00:33:19.533 --> 00:33:21.168 align:middle
到下面角落这里

00:33:22.903 --> 00:33:25.138 align:middle
有时候
这个并不经常发生

00:33:25.205 --> 00:33:28.141 align:middle
但是如果它同时在
X轴和Y轴对齐

00:33:28.709 --> 00:33:32.446 align:middle
你只想对齐到一个位置
它要么对齐

00:33:32.713 --> 00:33:35.749 align:middle
两个轴
要么哪个轴都不对齐

00:33:35.983 --> 00:33:39.186 align:middle
此时我们有运动的
对齐反馈令牌

00:33:39.253 --> 00:33:42.122 align:middle
你越过点
而不是一个个体X坐标

00:33:42.189 --> 00:33:44.758 align:middle
或者Y坐标
两者都可以

00:33:44.825 --> 00:33:49.263 align:middle
你可能得到 也可能得不到
对齐反馈令牌

00:33:49.930 --> 00:33:53.867 align:middle
你对拖拽的各种项目
进行迭代 这样它们

00:33:53.934 --> 00:33:56.203 align:middle
可以对齐
你拿回你的对齐反馈令牌

00:33:56.270 --> 00:33:59.139 align:middle
如果发生对齐
你就改变你的数据模型

00:33:59.673 --> 00:34:02.276 align:middle
现在你有了
一系列令牌

00:33:59.673 --> 00:34:02.276 align:middle
现在你有了
一系列令牌

00:34:02.776 --> 00:34:04.344 align:middle
你想要给使用新
Force Touch trackpad的

00:34:04.411 --> 00:34:06.313 align:middle
用户提供
触觉反馈

00:34:07.281 --> 00:34:09.583 align:middle
我们会使用对齐反馈过滤器
来帮助我们这样做

00:34:09.650 --> 00:34:11.418 align:middle
我们会让对齐反馈过滤器
在执行时间来

00:34:11.485 --> 00:34:13.152 align:middle
执行
反馈

00:34:13.620 --> 00:34:15.621 align:middle
现在执行时间
先使用默认值

00:34:15.688 --> 00:34:17.991 align:middle
我们稍后会
再讲一讲执行时间

00:34:18.824 --> 00:34:20.860 align:middle
然后你给阵列传递
一个反馈令牌

00:34:21.027 --> 00:34:23.330 align:middle
如果没有对齐 你甚至可以
传递一个空的阵列

00:34:23.597 --> 00:34:26.166 align:middle
对齐反馈过滤器
在这方面很健壮

00:34:26.233 --> 00:34:27.734 align:middle
它知道什么都不用做

00:34:28.502 --> 00:34:30.103 align:middle
然后你设置你的视图
为需要显示

00:34:30.469 --> 00:34:35.141 align:middle
无论什么时候要求
你就重新绘制 如果你

00:34:35.208 --> 00:34:37.244 align:middle
有令牌 你就知道你
何时在重新绘制

00:34:37.311 --> 00:34:41.215 align:middle
如果对你的UI合适的话
绘制对齐指导

00:34:41.581 --> 00:34:43.784 align:middle
然后反馈就会同步
和屏幕改变执行

00:34:43.851 --> 00:34:46.453 align:middle
用户就可以
有一个漂亮的

00:34:46.520 --> 00:34:49.188 align:middle
同步
看到对齐指导弹出

00:34:49.389 --> 00:34:50.524 align:middle
他们也同时从trackpad上
感受到

00:34:50.591 --> 00:34:53.193 align:middle
触觉
反馈

00:34:53.327 --> 00:34:56.864 align:middle
如果用户用的不是Force
Touch trackpad 对齐

00:34:56.929 --> 00:34:59.032 align:middle
反馈过滤器也知道
应该如何工作

00:34:59.333 --> 00:35:01.668 align:middle
所以你只需要假设是
Force Touch trackpad

00:34:59.333 --> 00:35:01.668 align:middle
所以你只需要假设是
Force Touch trackpad

00:35:01.735 --> 00:35:02.936 align:middle
你只需要写就可以了

00:35:03.003 --> 00:35:04.938 align:middle
如果不是
那就没问题

00:35:07.441 --> 00:35:09.009 align:middle
所以 实际上

00:35:09.142 --> 00:35:10.811 align:middle
就是使用对齐
反馈过滤器

00:35:11.011 --> 00:35:13.113 align:middle
它们非常简单的API
添加到你的应用程序

00:35:13.180 --> 00:35:15.716 align:middle
和现有的跟踪回路中
很容易

00:35:16.083 --> 00:35:17.551 align:middle
让整个app提供
一致的风格

00:35:17.784 --> 00:35:20.854 align:middle
比如 我们看看
光标的速度

00:35:21.088 --> 00:35:23.624 align:middle
因此如果用户移动的很快
我们就不对齐

00:35:23.690 --> 00:35:25.092 align:middle
因为我们不想在那个时候

00:35:25.158 --> 00:35:26.393 align:middle
进行
对齐

00:35:26.960 --> 00:35:28.562 align:middle
那不是
用户想要做的

00:35:28.996 --> 00:35:30.464 align:middle
我们来看修改值

00:35:30.831 --> 00:35:32.633 align:middle
这会给所有使用系统宽度
对齐反馈API

00:35:32.699 --> 00:35:35.302 align:middle
的应用程序
提供

00:35:35.369 --> 00:35:36.436 align:middle
一致的风格

00:35:36.970 --> 00:35:39.740 align:middle
你就可以用它
不仅仅是拖拽一个项目

00:35:40.107 --> 00:35:42.509 align:middle
如果你重新调整尺寸
比如说 或者自动调整

00:35:42.676 --> 00:35:44.778 align:middle
那就非常适合用
对齐反馈过滤器

00:35:45.179 --> 00:35:47.581 align:middle
它可以用在
很多不同的地方

00:35:49.149 --> 00:35:50.617 align:middle
要成为一名“骑士”
你需要了解的就这些

00:35:50.684 --> 00:35:51.518 align:middle
恭喜

00:35:51.585 --> 00:35:53.020 align:middle
你们现在都是使用

00:35:53.086 --> 00:35:54.488 align:middle
Force Touch trackpad
的“骑士”了

00:35:55.055 --> 00:35:56.990 align:middle
我们来继续成为
“大师”

00:35:57.491 --> 00:35:59.092 align:middle
都是关于
力的控制

00:35:59.560 --> 00:36:01.261 align:middle
是关于对trackpad
进行配置

00:35:59.560 --> 00:36:01.261 align:middle
是关于对trackpad
进行配置

00:36:01.328 --> 00:36:04.531 align:middle
这样它就能适用于
你的定制情景

00:36:04.731 --> 00:36:06.366 align:middle
手动提供
触觉反馈

00:36:09.770 --> 00:36:11.605 align:middle
我们再回到
绘图这个例子

00:36:12.773 --> 00:36:15.642 align:middle
你开始绘图 你按压Force
Touch trackpad

00:36:15.709 --> 00:36:17.110 align:middle
你得到了
Force click

00:36:17.177 --> 00:36:19.146 align:middle
但是它并不真的
适用于你的绘图

00:36:19.213 --> 00:36:20.814 align:middle
就像我之前提到的
你不希望尝试合并

00:36:20.881 --> 00:36:23.183 align:middle
阶段一的压力值
和阶段二的压力值

00:36:23.250 --> 00:36:25.586 align:middle
合并 甚至在释放时
也不行

00:36:25.652 --> 00:36:27.788 align:middle
这样
用户就会在绘图过程中

00:36:27.855 --> 00:36:29.656 align:middle
得到触觉反馈
这种经历

00:36:29.723 --> 00:36:31.325 align:middle
可不妙

00:36:31.992 --> 00:36:33.393 align:middle
因此我们想要对trackpad
进行配置

00:36:33.460 --> 00:36:37.965 align:middle
让它在这个例子中不提供一点Forc
e click动作

00:36:38.031 --> 00:36:40.400 align:middle
我们能用压力配置对象
做的 就是这个

00:36:40.467 --> 00:36:42.903 align:middle
我们先用一个
pressureBehavior开始

00:36:43.370 --> 00:36:45.706 align:middle
校验下头部文档
和资料

00:36:45.772 --> 00:36:49.042 align:middle
校验NSEvent.h
头部文档中对每个

00:36:49.109 --> 00:36:50.511 align:middle
都有
大量的描述

00:36:50.577 --> 00:36:51.845 align:middle
我不会每个都讲

00:36:51.945 --> 00:36:54.581 align:middle
默认的是DeepClick
这是系统

00:36:54.648 --> 00:36:55.549 align:middle
发生的

00:36:55.616 --> 00:36:57.518 align:middle
在这个例子中 我们想要
PrimaryGeneric

00:36:57.951 --> 00:37:00.454 align:middle
PrimaryGeneric是个阶
段一手势

00:36:57.951 --> 00:37:00.454 align:middle
PrimaryGeneric是个阶
段一手势

00:37:00.787 --> 00:37:03.323 align:middle
因此当用户在绘制时
他们就不会得到

00:37:03.390 --> 00:37:04.791 align:middle
Force click动作

00:37:04.858 --> 00:37:08.629 align:middle
给用户提供了在他们的
trackpad上输入力的

00:37:08.695 --> 00:37:11.532 align:middle
最大的动态范围
把它向你映射回去

00:37:11.598 --> 00:37:12.966 align:middle
映射到零到一的压力

00:37:13.267 --> 00:37:15.636 align:middle
最适合绘图
以及其它多个

00:37:15.702 --> 00:37:18.305 align:middle
情景
校验头部文档

00:37:18.372 --> 00:37:21.341 align:middle
看看其它行为描述
看看

00:37:21.408 --> 00:37:22.976 align:middle
哪个适合
你的情景

00:37:24.578 --> 00:37:25.913 align:middle
一旦你完成压力
配置后

00:37:25.979 --> 00:37:26.880 align:middle
你就可以调用设置

00:37:26.947 --> 00:37:29.516 align:middle
trackpad现在在新的配置中
配置好了

00:37:29.883 --> 00:37:32.553 align:middle
一切都很好
有了一些画布

00:37:33.220 --> 00:37:34.788 align:middle
在鼠标拖拽时 你可以

00:37:34.855 --> 00:37:37.791 align:middle
仅仅把trackpad设置成
一个不同的配置

00:37:37.958 --> 00:37:39.993 align:middle
在鼠标上移中 你对
鼠标的位置进行校验

00:37:40.060 --> 00:37:41.328 align:middle
如果这个特定的

00:37:41.395 --> 00:37:42.729 align:middle
鼠标位置
需要改变

00:37:43.530 --> 00:37:45.566 align:middle
创建一个压力配置
调用设置

00:37:45.632 --> 00:37:47.034 align:middle
trackpad就会
做出改变

00:37:47.901 --> 00:37:50.571 align:middle
你需要意识到
此时你在和用户竞赛

00:37:51.305 --> 00:37:55.676 align:middle
用户可能使用光标
翻过你的视图 立即进行

00:37:55.742 --> 00:37:57.311 align:middle
Force click 释放鼠标
而你甚至

00:37:57.377 --> 00:37:58.879 align:middle
还没有
下移鼠标

00:37:58.979 --> 00:38:01.949 align:middle
也许你被从虚拟内存中
置入分页

00:37:58.979 --> 00:38:01.949 align:middle
也许你被从虚拟内存中
置入分页

00:38:02.015 --> 00:38:03.684 align:middle
你的app失去响应了

00:38:04.318 --> 00:38:07.321 align:middle
你可以试着设置压力
此时的trackpad配置

00:38:07.387 --> 00:38:10.757 align:middle
但是用户已经
完成了他们的手势

00:38:11.024 --> 00:38:12.092 align:middle
手势不会生效

00:38:12.659 --> 00:38:16.029 align:middle
当你设置trackpad配置时
它会自动重置为

00:38:16.830 --> 00:38:19.266 align:middle
系统默认值
用户也会同时

00:38:19.333 --> 00:38:21.468 align:middle
结束手势
因此你不需要担心

00:38:21.535 --> 00:38:22.769 align:middle
对它复原

00:38:23.270 --> 00:38:26.440 align:middle
但是对多数情况来说
这不够理想 当你需要

00:38:26.507 --> 00:38:30.043 align:middle
根据鼠标位置 在最后一分钟
决定

00:38:30.110 --> 00:38:32.346 align:middle
配置应该是什么时
这很有用

00:38:33.013 --> 00:38:37.518 align:middle
而不是在NSView上设置
压力配置

00:38:38.352 --> 00:38:40.220 align:middle
提前创建一个
压力配置

00:38:40.420 --> 00:38:42.022 align:middle
在NSView上把它设置为
压力配置属性

00:38:42.089 --> 00:38:44.291 align:middle
系统就会在
鼠标下移发生之前

00:38:44.358 --> 00:38:46.326 align:middle
设置好
trackpad

00:38:46.393 --> 00:38:48.695 align:middle
事实上 系统可以给
trackpad配置为这种配置

00:38:48.762 --> 00:38:50.697 align:middle
即使你的app

00:38:50.764 --> 00:38:52.566 align:middle
失去了
响应

00:38:53.100 --> 00:38:56.370 align:middle
现在用户就可以继续
和你的应用程序交互了

00:38:56.436 --> 00:38:57.804 align:middle
你甚至还没有完成
鼠标下移

00:38:57.871 --> 00:38:59.039 align:middle
但是他们没有
感受到Force click

00:38:59.106 --> 00:39:01.842 align:middle
因为它位于
PrimaryGeneric行为

00:38:59.106 --> 00:39:01.842 align:middle
因为它位于
PrimaryGeneric行为

00:39:01.909 --> 00:39:04.011 align:middle
以及你从应用程序中
得到的事件

00:39:04.077 --> 00:39:06.547 align:middle
当你最终得到你的事件
此时从系统中

00:39:07.080 --> 00:39:08.415 align:middle
获得
如果

00:39:08.482 --> 00:39:12.019 align:middle
你失去了响应 不要在它们里面
进行Force click

00:39:12.085 --> 00:39:13.754 align:middle
它们不会到阶段二

00:39:13.820 --> 00:39:16.390 align:middle
我们再来讲讲
触觉反馈

00:39:18.192 --> 00:39:20.360 align:middle
触觉反馈应该
保守使用

00:39:20.727 --> 00:39:21.995 align:middle
它们是用于微妙的交互

00:39:22.062 --> 00:39:24.164 align:middle
我们想让trackpad感觉很奇妙
不是吗？

00:39:25.165 --> 00:39:26.633 align:middle
当用户想要
对齐某些东西时

00:39:26.700 --> 00:39:28.535 align:middle
它们会得到触觉反馈
感觉很棒

00:39:28.602 --> 00:39:30.671 align:middle
但是我们不是想在这里
按摩用户的指头

00:39:31.004 --> 00:39:33.040 align:middle
我们只是想进行
微妙的交互

00:39:33.874 --> 00:39:37.044 align:middle
事实上 如果用户
用回我们的老款

00:39:37.110 --> 00:39:38.846 align:middle
trackpads
我们希望他们根本

00:39:38.912 --> 00:39:41.281 align:middle
意识不到 虽然设备换了
但是却

00:39:41.348 --> 00:39:42.916 align:middle
基本
感觉不到

00:39:43.383 --> 00:39:47.521 align:middle
使用触觉反馈的
意义就在这里

00:39:47.754 --> 00:39:49.990 align:middle
正确使用的话
当用户试图做一些事情

00:39:50.057 --> 00:39:52.259 align:middle
的时候
给他们一点微妙的反馈

00:39:52.426 --> 00:39:53.827 align:middle
是的 就这样

00:39:53.894 --> 00:39:55.195 align:middle
它就应该
一直是这样

00:39:55.262 --> 00:39:56.129 align:middle
我都不知道

00:39:56.697 --> 00:39:57.598 align:middle
微妙的交互

00:39:58.065 --> 00:39:59.266 align:middle
你为defaultPerformer
请求了

00:39:59.333 --> 00:40:00.901 align:middle
NSHaptic
FeedbackManager

00:39:59.333 --> 00:40:00.901 align:middle
NSHaptic
FeedbackManager

00:40:00.968 --> 00:40:03.003 align:middle
始终请求
defaultPerformer

00:40:03.070 --> 00:40:05.839 align:middle
因为它可以根据输入
设备以及用户的偏好

00:40:06.240 --> 00:40:09.510 align:middle
进行改变

00:40:10.143 --> 00:40:12.079 align:middle
在某个特定的运行时间
你要求执行反馈模式

00:40:12.145 --> 00:40:14.481 align:middle
我们
有三个

00:40:14.848 --> 00:40:17.584 align:middle
模式：“通用”“对齐”
以及“LevelChange”

00:40:17.651 --> 00:40:19.386 align:middle
对齐可以用于
很多事情

00:40:19.887 --> 00:40:23.824 align:middle
即使你只是旋转一幅
照片进行水平对齐

00:40:23.891 --> 00:40:26.193 align:middle
打个比方 你也可以
为它使用对齐

00:40:26.560 --> 00:40:30.163 align:middle
“LevelChange”就是NS
Button在不同的多次方式中用的

00:40:30.230 --> 00:40:32.599 align:middle
当层级改变时
它会提供触觉反馈

00:40:33.300 --> 00:40:35.802 align:middle
如果那两项对你试图
做的事情描述的不够充分

00:40:35.869 --> 00:40:37.905 align:middle
那就使用
“通用”

00:40:39.072 --> 00:40:42.109 align:middle
你想让你的触觉反馈
与屏幕上进行的事物

00:40:42.176 --> 00:40:44.178 align:middle
同步执行
那么默认的

00:40:44.244 --> 00:40:45.746 align:middle
就是
DrawCompleted

00:40:45.812 --> 00:40:47.614 align:middle
如果你用Cocoa绘画
或者用核心动画

00:40:47.881 --> 00:40:50.851 align:middle
你就用DrawCompleted
执行时间

00:40:50.984 --> 00:40:53.987 align:middle
这个会自动把它们
为你同步起来

00:40:54.054 --> 00:40:57.024 align:middle
这样在事件进程中 绘画中
你就能确定你的触觉反馈

00:40:57.090 --> 00:40:59.826 align:middle
你就可以仅仅
关注绘画

00:41:00.294 --> 00:41:02.396 align:middle
如果你直接用Medal
或者OpenGL

00:41:02.663 --> 00:41:05.832 align:middle
那就可以用“现在”
当事情在屏幕上更新时

00:41:06.133 --> 00:41:09.269 align:middle
你需要确保你排列了它们
这样

00:41:09.336 --> 00:41:10.971 align:middle
它们可以同时
发生

00:41:12.139 --> 00:41:13.307 align:middle
就是这些

00:41:13.373 --> 00:41:14.508 align:middle
你们现在都是使用

00:41:14.575 --> 00:41:16.276 align:middle
Force Touch
trackpad的“大师”了

00:41:16.343 --> 00:41:18.312 align:middle
我迫不及待
想看看你们在你们的

00:41:18.378 --> 00:41:20.914 align:middle
应用程序中运用这些东西
我们讲了“表格行动作”

00:41:20.981 --> 00:41:24.318 align:middle
加速按钮 弹性加载
我们讲了力在

00:41:24.518 --> 00:41:26.520 align:middle
系统中的
流动

00:41:26.753 --> 00:41:29.723 align:middle
进行对齐反馈
最后是控制trackpad

00:41:29.790 --> 00:41:32.192 align:middle
为你的特定需求配置
trackpad

00:41:32.626 --> 00:41:34.228 align:middle
你能做的事情很多

00:41:35.796 --> 00:41:37.631 align:middle
刚才在我的
演示中的小app

00:41:37.698 --> 00:41:39.032 align:middle
叫做Force Touch
Catalog

00:41:39.099 --> 00:41:40.601 align:middle
你可以下载后
看一看

00:41:40.667 --> 00:41:43.237 align:middle
我们也有对齐指导
样例应用程序

00:41:43.303 --> 00:41:44.805 align:middle
把它们用起来
也确实有用

00:41:46.773 --> 00:41:49.109 align:middle
我建议你们看看
“WebKit和Safari中的

00:41:49.176 --> 00:41:50.811 align:middle
网站开发
有什么新料”

00:41:50.878 --> 00:41:54.615 align:middle
这样你就可以了解Safari
在网站环境中

00:41:54.681 --> 00:41:58.252 align:middle
是如何承担压力的

00:41:59.586 --> 00:42:02.723 align:middle
这之后我们会有个实验室

00:41:59.586 --> 00:42:02.723 align:middle
这之后我们会有个实验室

00:42:02.789 --> 00:42:04.825 align:middle
“Cocoa
和Force Touch 手势”

00:42:04.892 --> 00:42:06.226 align:middle
实验室 我当然也会到场

00:42:06.426 --> 00:42:08.862 align:middle
我十分乐意倾听
你们就如何在你们的

00:42:08.929 --> 00:42:11.965 align:middle
应用程序中使用Force
Touch的想法 你们甚至可以给我

00:42:12.032 --> 00:42:14.668 align:middle
展示下你们已经完成的东西
我会十分乐意观看

00:42:14.735 --> 00:42:15.602 align:middle
并且和你们讨论

00:42:15.669 --> 00:42:18.038 align:middle
会议结束后请到
实验室找我

00:42:18.739 --> 00:42:20.774 align:middle
非常感谢
祝你们剩余的时间过得愉快
