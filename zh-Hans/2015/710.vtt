WEBVTT

00:00:19.887 --> 00:00:24.992 align:middle
《CloudKitJS与网络服务》

00:00:34.301 --> 00:00:36.103 align:middle
大家下午好
我是克里斯

00:00:36.170 --> 00:00:38.272 align:middle
是苹果公司ICloud
网络服务部经理

00:00:39.072 --> 00:00:41.275 align:middle
今天我很荣幸能够
在此告诉你们

00:00:41.542 --> 00:00:45.012 align:middle
去年我们收到的关于
CloudKit的第一大特性需求

00:00:45.245 --> 00:00:46.313 align:middle
就是网络服务

00:00:53.554 --> 00:00:56.857 align:middle
那么本节讲座需要对
CloudKit话题有点熟悉

00:00:57.157 --> 00:00:59.826 align:middle
我将给你们简要概括
CloudKit的架构

00:01:00.060 --> 00:01:01.728 align:middle
但是如果你们想
更深入了解它

00:01:01.795 --> 00:01:03.163 align:middle
我们去年有一系列讲座

00:01:03.530 --> 00:01:05.399 align:middle
你们可以回去查看
那些讲座的具体内容

00:01:08.569 --> 00:01:09.670 align:middle
在CloudKit中

00:01:09.903 --> 00:01:12.072 align:middle
你们的所有数据
都储存在一个容器中

00:01:14.007 --> 00:01:16.577 align:middle
在这个容器中
我们有一个公用数据库

00:01:16.810 --> 00:01:18.111 align:middle
用于储存你们的app数据

00:01:19.012 --> 00:01:20.314 align:middle
另外还有一个专用数据库

00:01:20.414 --> 00:01:21.782 align:middle
用于储存你们的用户数据

00:01:23.784 --> 00:01:26.320 align:middle
在公用数据库中
你们有默认区

00:01:27.521 --> 00:01:28.455 align:middle
这里有记录

00:01:29.723 --> 00:01:30.991 align:middle
而在专用数据库内

00:01:31.124 --> 00:01:32.492 align:middle
你们同样有一个默认区

00:01:33.794 --> 00:01:35.696 align:middle
你们同样可以创建自定义区域

00:01:35.829 --> 00:01:37.197 align:middle
它们增加的同步语义

00:01:37.497 --> 00:01:39.233 align:middle
使你们能够回答关于
从某个时间点开始

00:01:39.299 --> 00:01:41.468 align:middle
发生了什么改变变化的问题

00:01:42.903 --> 00:01:45.239 align:middle
当然 你们可以在这两个
区域都建立记录

00:01:47.541 --> 00:01:48.976 align:middle
从API的角度

00:01:49.042 --> 00:01:50.644 align:middle
我们有CloudKit服务器

00:01:51.945 --> 00:01:54.281 align:middle
而在本地
我们有CloudKit框架

00:01:55.382 --> 00:01:57.551 align:middle
通过此框架
你们的App程序与服务器连接

00:01:59.486 --> 00:02:01.688 align:middle
我们今天将会介绍
CloudKit网络服务

00:01:59.486 --> 00:02:01.688 align:middle
我们今天将会介绍
CloudKit网络服务

00:02:02.689 --> 00:02:05.225 align:middle
我们已经使用这种服务
建立Notes Web app

00:02:06.293 --> 00:02:08.829 align:middle
今天你们可以用它来
建立你们的网络app

00:02:11.031 --> 00:02:13.233 align:middle
那么CloudKit网络服务
具体是什么呢?

00:02:15.202 --> 00:02:16.236 align:middle
这包括三方面内容

00:02:16.370 --> 00:02:19.106 align:middle
第一 这是一个连接到
CloudKit的JSON接口

00:02:19.873 --> 00:02:20.707 align:middle
第二

00:02:21.241 --> 00:02:23.777 align:middle
这是一个使用
Apple ID进行的网络登录

00:02:24.378 --> 00:02:25.379 align:middle
第三

00:02:25.946 --> 00:02:27.481 align:middle
它是个JavaScript库

00:02:28.715 --> 00:02:31.485 align:middle
让我们看一下
JSON API的特性

00:02:34.188 --> 00:02:37.291 align:middle
有了对公用和专用
数据库的完全访问权限

00:02:38.125 --> 00:02:39.359 align:middle
你们当然就可以创建

00:02:39.526 --> 00:02:42.029 align:middle
读取 更新
和删除记录

00:02:43.030 --> 00:02:44.898 align:middle
你们可以上传和下载资源

00:02:45.899 --> 00:02:47.167 align:middle
你们可以查询你们的数据

00:02:48.669 --> 00:02:51.305 align:middle
你们可以创建订阅
可以接收回调

00:02:51.605 --> 00:02:52.806 align:middle
当你们的数据发生变化时

00:02:54.641 --> 00:02:55.876 align:middle
可发现这些用户数据变化

00:02:55.943 --> 00:02:57.377 align:middle
你们可以发现用户的
真实姓名

00:02:58.846 --> 00:02:59.780 align:middle
你们可以进行同步

00:03:01.215 --> 00:03:02.749 align:middle
我们提供身份验证

00:03:04.318 --> 00:03:06.887 align:middle
因此这是一个很长的清单
事实上这意味着

00:03:07.254 --> 00:03:09.823 align:middle
我们在本地API和
JavaScript API 之间

00:03:10.123 --> 00:03:11.592 align:middle
存在特性上的对等关系

00:03:18.966 --> 00:03:21.134 align:middle
每件你能够在本地API上
做的事情

00:03:21.201 --> 00:03:22.870 align:middle
你都能够通过JSON API完成

00:03:23.437 --> 00:03:25.239 align:middle
我们已经做出付出极大努力

00:03:25.405 --> 00:03:27.741 align:middle
确保例如字段名称和参数等

00:03:27.808 --> 00:03:29.610 align:middle
在JavaScript中
有同样的名称

00:03:30.677 --> 00:03:33.914 align:middle
并且我们用JavaScript
Promises进行补全

00:03:34.381 --> 00:03:36.350 align:middle
这是效仿Blocks和Swift

00:03:36.817 --> 00:03:37.885 align:middle
最终你的代码

00:03:37.951 --> 00:03:40.454 align:middle
看起来在JavaScript
和Swift之间很类似

00:03:42.723 --> 00:03:43.924 align:middle
我知道你们观众中的很多人

00:03:43.991 --> 00:03:46.693 align:middle
或许已经有过对
CloudKit的应用

00:03:47.194 --> 00:03:48.762 align:middle
如果你们不了解
让我们迅速看一下

00:03:49.029 --> 00:03:51.565 align:middle
如何开始进行一个
新的CloudKit应用

00:03:53.333 --> 00:03:55.402 align:middle
你们应该做的第一件事
是建立一个容器

00:03:56.303 --> 00:03:58.906 align:middle
你们可以通过WWDR门户

00:03:59.439 --> 00:04:00.541 align:middle
或Xcode建立容器

00:03:59.439 --> 00:04:00.541 align:middle
或Xcode建立容器

00:04:01.508 --> 00:04:03.744 align:middle
一旦你们有了容器
就需要建立一个架构

00:04:04.711 --> 00:04:07.748 align:middle
你们可以通过iCloud控制面板

00:04:08.282 --> 00:04:10.050 align:middle
或者你们的本地app

00:04:10.117 --> 00:04:11.218 align:middle
按需要建立这个框架

00:04:12.519 --> 00:04:15.389 align:middle
那么这时你们的CloudKit应用
就开始启动并运行了

00:04:15.556 --> 00:04:17.124 align:middle
让我们开启网络接入

00:04:17.991 --> 00:04:19.593 align:middle
这有三个步骤

00:04:19.993 --> 00:04:22.963 align:middle
第一 你们需要生成
一个网络服务API令牌

00:04:23.797 --> 00:04:24.631 align:middle
第二

00:04:25.232 --> 00:04:27.801 align:middle
你们需要设置
你们的登录回调机制

00:04:28.468 --> 00:04:29.703 align:middle
第三

00:04:29.970 --> 00:04:32.206 align:middle
你们需要设定你们的域限制

00:04:34.074 --> 00:04:36.210 align:middle
让我们更进一步了解这三个步骤

00:04:37.277 --> 00:04:39.446 align:middle
这是CloudKit控制面板

00:04:40.214 --> 00:04:43.016 align:middle
如你们所见 我们增加了
一个被称为API令牌的新的窗格

00:04:43.483 --> 00:04:45.219 align:middle
我已经在这儿建立了
我的第一个令牌

00:04:50.390 --> 00:04:52.993 align:middle
在顶部是令牌的ID

00:04:53.327 --> 00:04:55.295 align:middle
这是当你们在进行网络服务调用时

00:04:55.362 --> 00:04:57.397 align:middle
传入的东西

00:04:58.432 --> 00:05:00.434 align:middle
在那下方我选择了
postMessage

00:04:58.432 --> 00:05:00.434 align:middle
在那下方我选择了
postMessage

00:05:00.501 --> 00:05:01.368 align:middle
作为我的登录回调

00:05:01.902 --> 00:05:04.204 align:middle
对于JavaScript应用
我会在用户登录时

00:05:04.271 --> 00:05:06.039 align:middle
取得一个JavaScript回调

00:05:06.773 --> 00:05:09.710 align:middle
或者我可以选择使用...

00:05:10.944 --> 00:05:11.979 align:middle
URL重定向

00:05:13.580 --> 00:05:15.682 align:middle
在这下方 我可以设置
允许通过网络服务

00:05:15.749 --> 00:05:18.652 align:middle
访问我的CloudKit...
数据的来源

00:05:19.286 --> 00:05:21.989 align:middle
我已经选择任何域
都可以访问我的数据

00:05:22.422 --> 00:05:25.425 align:middle
为了增加安全性
我完全可以限定为查看者域

00:05:26.960 --> 00:05:28.929 align:middle
那么现在我们启动了网络服务

00:05:29.563 --> 00:05:30.931 align:middle
我们让一些用户登录

00:05:33.634 --> 00:05:34.735 align:middle
因此
身份验证的...

00:05:35.302 --> 00:05:36.637 align:middle
处理是透明的

00:05:37.070 --> 00:05:37.938 align:middle
我的意思是说

00:05:38.005 --> 00:05:40.073 align:middle
当一个用户调用一个

00:05:40.140 --> 00:05:41.441 align:middle
需要身份验证的API时

00:05:41.775 --> 00:05:43.744 align:middle
我们会返回一个
特别形成的有效荷载

00:05:44.011 --> 00:05:45.279 align:middle
它带有一个你们可以发送给

00:05:45.345 --> 00:05:46.880 align:middle
你们的用户的URL重定向网址

00:05:48.215 --> 00:05:51.251 align:middle
然后他们与已经存在的
Apple ID进行验证

00:05:51.485 --> 00:05:55.022 align:middle
或者他们可以在登录环节
建立一个新的Apple ID

00:05:56.256 --> 00:05:57.925 align:middle
为了保护用户的隐私

00:05:58.192 --> 00:05:59.993 align:middle
我们不向你们的app
提供用户的姓名

00:06:00.060 --> 00:06:00.894 align:middle
或者登录密码

00:06:01.762 --> 00:06:04.531 align:middle
但我们提供一个
稳定且匿名的

00:06:04.665 --> 00:06:05.499 align:middle
用户标识符

00:06:07.701 --> 00:06:09.203 align:middle
让我们把所有这些事情连起来

00:06:09.303 --> 00:06:11.104 align:middle
并且让我们快速建立一个
示例app

00:06:14.608 --> 00:06:16.243 align:middle
那么我们将要建立
一个任务app

00:06:16.743 --> 00:06:17.811 align:middle
它把任务存储在...

00:06:18.846 --> 00:06:22.182 align:middle
com.example.tasks
容器内存储任务

00:06:23.450 --> 00:06:25.452 align:middle
它有一个记录类型：Tasks

00:06:25.719 --> 00:06:26.854 align:middle
记录有两个字段

00:06:27.087 --> 00:06:29.723 align:middle
分别是任务的名称...
和优先级

00:06:30.724 --> 00:06:32.025 align:middle
那么让我们建立第一个任务

00:06:34.328 --> 00:06:37.331 align:middle
那么我将做的是
调用记录修改API

00:06:38.632 --> 00:06:40.000 align:middle
并传入一个JSON实体

00:06:40.434 --> 00:06:42.603 align:middle
这个JSON实体表示
要创建一个新的任务

00:06:42.769 --> 00:06:44.738 align:middle
该任务有个唯一的标识符task-1

00:06:45.739 --> 00:06:47.875 align:middle
任务的值为"Buy Milk"

00:06:48.876 --> 00:06:50.377 align:middle
我们把它发送到服务器

00:06:52.012 --> 00:06:54.381 align:middle
我们没有一位已经过验证的用户

00:06:55.115 --> 00:06:55.949 align:middle
作为回应...

00:06:56.416 --> 00:06:58.819 align:middle
我们得到
一个URL重定向网址

00:06:58.886 --> 00:07:00.854 align:middle
我们可以把这个网址
发给用户进行验证

00:06:58.886 --> 00:07:00.854 align:middle
我们可以把这个网址
发给用户进行验证

00:07:01.622 --> 00:07:02.923 align:middle
让我们跟随这个网址

00:07:04.758 --> 00:07:06.260 align:middle
这儿是用户登录界面

00:07:07.060 --> 00:07:09.830 align:middle
你们应该注意到
它有app名称和app图标

00:07:10.264 --> 00:07:13.300 align:middle
能够在这儿建立
一个新的Apple ID

00:07:14.601 --> 00:07:17.037 align:middle
我们已经有一个Apple ID
我们让我们直接登录

00:07:18.872 --> 00:07:20.140 align:middle
用户登录后

00:07:20.407 --> 00:07:21.909 align:middle
通过您早些时候
规定的回调机制

00:07:22.109 --> 00:07:23.410 align:middle
你们的应用会被

00:07:23.477 --> 00:07:25.145 align:middle
返回一个会话ID

00:07:26.813 --> 00:07:29.349 align:middle
我们可以继续把这个会话ID

00:07:29.449 --> 00:07:30.284 align:middle
附加到URL上

00:07:30.584 --> 00:07:31.852 align:middle
并重新发送相同的请求

00:07:35.122 --> 00:07:35.956 align:middle
好多了

00:07:36.723 --> 00:07:39.493 align:middle
现在我们收到了创建成功的消息

00:07:39.760 --> 00:07:41.662 align:middle
你们可以看到记录名

00:07:42.162 --> 00:07:44.932 align:middle
改变标签...
各个字段都在

00:07:44.998 --> 00:07:46.567 align:middle
以及关于记录
更多的一些元数据

00:07:47.901 --> 00:07:49.403 align:middle
这涉及到大量的JSON解析

00:07:49.536 --> 00:07:51.505 align:middle
你们或许会担心错误处理...

00:07:52.105 --> 00:07:52.940 align:middle
和限速

00:07:53.240 --> 00:07:55.776 align:middle
我们希望让这个API
尽可能容易使用

00:07:56.476 --> 00:07:57.311 align:middle
因此

00:07:58.045 --> 00:08:00.214 align:middle
我们自豪向你们介绍
CloudKit JS

00:07:58.045 --> 00:08:00.214 align:middle
我们自豪向你们介绍
CloudKit JS

00:08:00.280 --> 00:08:03.217 align:middle
它是在JSON之上的封装器

00:08:03.684 --> 00:08:06.420 align:middle
谈到这方面我会邀请
欧那尔·维克斯塔德到台上

00:08:13.560 --> 00:08:14.394 align:middle
谢谢克里斯

00:08:14.895 --> 00:08:17.965 align:middle
我是欧那尔·维克斯塔德
iCloud部门的工程经理

00:08:18.098 --> 00:08:19.967 align:middle
我将向大家介绍
CloudKit JS

00:08:21.001 --> 00:08:23.270 align:middle
CloudKit JS让你们能够

00:08:23.504 --> 00:08:26.073 align:middle
从JavaScript
连接到CloudKit

00:08:27.140 --> 00:08:29.176 align:middle
它是一个小型
性能完备的库

00:08:29.943 --> 00:08:34.381 align:middle
它能够与你们已经在网络上
使用的任何框架或库兼容

00:08:35.816 --> 00:08:38.619 align:middle
注意这是一个低水平的
传输API

00:08:39.119 --> 00:08:42.456 align:middle
这意味着它不会真正成为
一个数据存储

00:08:42.722 --> 00:08:46.393 align:middle
它不允许在JSON API
上有很多抽象化

00:08:46.827 --> 00:08:48.662 align:middle
因此如果你们
已经使用一个数据存储

00:08:48.996 --> 00:08:52.533 align:middle
请继续使用这个数据存储

00:08:52.733 --> 00:08:54.601 align:middle
你们应能够直接把
CloudKit JS

00:08:54.668 --> 00:08:55.536 align:middle
插入这个数据存储

00:08:57.571 --> 00:09:00.641 align:middle
它同样支持轻易地
从CloudKit框架过渡

00:08:57.571 --> 00:09:00.641 align:middle
它同样支持轻易地
从CloudKit框架过渡

00:09:01.275 --> 00:09:03.143 align:middle
那么你们或许已经在
iOS或OS X上

00:09:03.210 --> 00:09:04.511 align:middle
使用CloudKit框架

00:09:04.845 --> 00:09:06.980 align:middle
术语 概念

00:09:07.314 --> 00:09:09.449 align:middle
方法名称和类的名称都相同

00:09:10.050 --> 00:09:12.286 align:middle
因此这是一个容易的过渡

00:09:13.353 --> 00:09:15.322 align:middle
即便如此
仍然有一些不同

00:09:15.756 --> 00:09:17.991 align:middle
毕竟这是网络是
JavaScript

00:09:18.592 --> 00:09:20.394 align:middle
因此会有一些不同

00:09:20.460 --> 00:09:23.096 align:middle
例如我们将把
JavaScript Promises

00:09:23.163 --> 00:09:24.164 align:middle
用于所有异步行为

00:09:24.665 --> 00:09:26.900 align:middle
我们稍后会查看相关示例

00:09:29.503 --> 00:09:30.437 align:middle
在浏览器...

00:09:31.972 --> 00:09:32.940 align:middle
支持方面

00:09:33.740 --> 00:09:35.809 align:middle
我们支持所有主要的浏览器

00:09:36.844 --> 00:09:39.012 align:middle
例如Safari
FireFox Chrome

00:09:39.479 --> 00:09:41.782 align:middle
IE和新的
Microsoft Edge

00:09:42.616 --> 00:09:46.153 align:middle
如果你们想代表用户进行
服务器到服务器连接

00:09:46.420 --> 00:09:50.090 align:middle
我们支持JavaScript环境

00:09:50.424 --> 00:09:52.025 align:middle
如Note JS

00:09:53.827 --> 00:09:56.997 align:middle
因此在我们开始了解更多的
API方面的内容前

00:09:57.264 --> 00:09:58.565 align:middle
让我给你们一个快速的演示

00:10:08.442 --> 00:10:10.944 align:middle
那么我们正在查看的是
CloudKit目录

00:10:11.011 --> 00:10:12.346 align:middle
示例代码项目

00:10:13.113 --> 00:10:15.582 align:middle
这既可以作为一个
可下载压缩文件

00:10:15.649 --> 00:10:17.451 align:middle
你们也可以在开发者站点上获得

00:10:17.951 --> 00:10:20.354 align:middle
我们在这儿将看到的是
托管版本

00:10:20.420 --> 00:10:21.588 align:middle
这个同样可以提供

00:10:21.889 --> 00:10:24.224 align:middle
那么它正在提供实时代码示例

00:10:24.291 --> 00:10:25.859 align:middle
你们可以
在任何浏览器内执行它们

00:10:26.627 --> 00:10:28.996 align:middle
你们可以在左侧看到一个
特性列表

00:10:29.062 --> 00:10:30.597 align:middle
我们正在看的是自述文件

00:10:30.998 --> 00:10:31.965 align:middle
它给向你们介绍一些

00:10:32.032 --> 00:10:34.535 align:middle
如何开始在CloudKit Js
上的工作的介绍

00:10:35.969 --> 00:10:38.572 align:middle
我们来到叫做"验证"
的第一步

00:10:39.072 --> 00:10:41.108 align:middle
你们会注意到每个部分
都在顶端有一个描述

00:10:41.175 --> 00:10:43.377 align:middle
这个示例告诉你们如何...

00:10:43.977 --> 00:10:44.845 align:middle
使用验证

00:10:45.279 --> 00:10:47.381 align:middle
在这下方你们有一个代码示例

00:10:47.848 --> 00:10:49.550 align:middle
这个代码片段专门校验...

00:10:50.017 --> 00:10:52.886 align:middle
用户的验证状态

00:10:53.253 --> 00:10:55.489 align:middle
如果用户没有登录

00:10:55.556 --> 00:10:57.457 align:middle
就会出现一个登录按钮

00:10:58.825 --> 00:11:01.562 align:middle
而你们可以在上面这里
实际运行这个代码

00:10:58.825 --> 00:11:01.562 align:middle
而你们可以在上面这里
实际运行这个代码

00:11:02.062 --> 00:11:03.931 align:middle
因此 如果我点击
这个"运行代码"按钮

00:11:04.264 --> 00:11:05.332 align:middle
它会执行这个代码

00:11:05.899 --> 00:11:08.001 align:middle
你们会看到它向下滚动一段

00:11:08.435 --> 00:11:11.271 align:middle
它告诉我们
此时我们是未经过验证的用户

00:11:11.738 --> 00:11:13.440 align:middle
我们看登录按钮

00:11:14.842 --> 00:11:16.844 align:middle
我可以继续点击登录按钮

00:11:19.379 --> 00:11:20.247 align:middle
我输入...

00:11:21.381 --> 00:11:22.583 align:middle
随便一个Apple ID

00:11:24.084 --> 00:11:24.918 align:middle
和密码

00:11:29.223 --> 00:11:30.824 align:middle
你们会注意到窗口关闭了

00:11:32.025 --> 00:11:34.962 align:middle
那就是苹果公司的托管验证页

00:11:35.329 --> 00:11:37.531 align:middle
这时你们完成了网络应用登录

00:11:37.598 --> 00:11:38.632 align:middle
这是示例app

00:11:39.032 --> 00:11:41.101 align:middle
你们看到我们有用户名

00:11:41.168 --> 00:11:42.503 align:middle
包括名和姓两部分

00:11:42.836 --> 00:11:45.439 align:middle
而且"退出"按钮
取代了"登录"按钮

00:11:45.973 --> 00:11:48.275 align:middle
这是CloudKit的
另一个特性

00:11:48.342 --> 00:11:49.643 align:middle
可发现性

00:11:50.143 --> 00:11:51.512 align:middle
如果用户选择进入

00:11:51.812 --> 00:11:55.516 align:middle
用户可以选择与开发者
分享他的姓名

00:11:55.816 --> 00:11:57.618 align:middle
以及能够在容器内被发现

00:11:57.684 --> 00:11:59.586 align:middle
以便其他用户找到他们

00:12:00.420 --> 00:12:02.356 align:middle
现在既然我们有了姓名

00:12:02.422 --> 00:12:05.726 align:middle
我们将用它们填充到...右上角

00:12:07.261 --> 00:12:09.596 align:middle
好 现在我们登录了

00:12:10.230 --> 00:12:12.666 align:middle
我们可以进行一些操作
我们到记录部分

00:12:14.101 --> 00:12:15.969 align:middle
这将向您演示
怎样在专用数据库内

00:12:16.036 --> 00:12:17.137 align:middle
保存到一条记录

00:12:18.305 --> 00:12:20.374 align:middle
那么我们在顶部看到有一些字段

00:12:20.841 --> 00:12:21.842 align:middle
我们有记录的名称

00:12:21.909 --> 00:12:23.844 align:middle
这个名称是记录的独特标识符

00:12:24.678 --> 00:12:27.114 align:middle
我们有一个区域名 这是默认区

00:12:27.181 --> 00:12:28.849 align:middle
它可以是你们建立的
任意自定义区域

00:12:29.583 --> 00:12:31.818 align:middle
你们有三个
在CloudKit架构中

00:12:31.885 --> 00:12:33.487 align:middle
确定的自定义字段名

00:12:34.321 --> 00:12:36.490 align:middle
在这个示例中
我们有一个名称字段

00:12:36.790 --> 00:12:37.624 align:middle
字符串值

00:12:37.925 --> 00:12:41.061 align:middle
我们有一个位置字段
地理位置值

00:12:41.528 --> 00:12:44.631 align:middle
然后我们有一个资源字段
它可以让您上传一个文件

00:12:45.566 --> 00:12:46.667 align:middle
那么我将继续往下进行

00:12:47.034 --> 00:12:47.868 align:middle
并选择一个文件

00:12:48.936 --> 00:12:51.138 align:middle
我选择这张绿地景观...

00:12:52.306 --> 00:12:53.140 align:middle
Jpeg图片

00:12:53.807 --> 00:12:55.375 align:middle
而且我将返回到顶部

00:12:55.442 --> 00:12:56.810 align:middle
给图片命名为...

00:12:57.644 --> 00:12:58.812 align:middle
"景观1"

00:12:58.879 --> 00:13:01.081 align:middle
这是记录名称
是一个独特的标识符

00:12:58.879 --> 00:13:01.081 align:middle
这是记录名称
是一个独特的标识符

00:13:01.715 --> 00:13:04.918 align:middle
我这里将更改图片名称
称其为"绿地"

00:13:06.386 --> 00:13:09.456 align:middle
那么在填完了这个字段后
我可以运行代码

00:13:09.990 --> 00:13:12.025 align:middle
它将把记录也保存到数据库

00:13:12.092 --> 00:13:13.861 align:middle
作为上传资源保存到资源存储器

00:13:14.595 --> 00:13:18.365 align:middle
你们可以看到完成之后
我们得到一个结果

00:13:18.999 --> 00:13:21.034 align:middle
而这实际上是服务器做出的应答

00:13:21.401 --> 00:13:22.903 align:middle
以我们在桌面这里表示的

00:13:22.970 --> 00:13:24.538 align:middle
JSON文件做出的应答

00:13:25.072 --> 00:13:26.740 align:middle
除了三个自定义区域

00:13:27.241 --> 00:13:30.344 align:middle
我们还有一些元数据字段
绿地

00:13:30.911 --> 00:13:33.280 align:middle
位置以及下载这些资源的链接

00:13:38.051 --> 00:13:39.753 align:middle
为向您展示它实际是
如何被存储的

00:13:39.820 --> 00:13:41.088 align:middle
我们可以去提取记录

00:13:41.655 --> 00:13:42.689 align:middle
我输入...

00:13:43.123 --> 00:13:43.957 align:middle
景观...

00:13:45.425 --> 00:13:46.260 align:middle
1

00:13:46.994 --> 00:13:47.928 align:middle
运行这个代码

00:13:48.362 --> 00:13:49.730 align:middle
我们再次得到了同样的记录

00:13:49.796 --> 00:13:51.865 align:middle
那就说明了
在CloudKit内

00:13:51.932 --> 00:13:54.401 align:middle
使用CloudKit
JS保存记录是多么简单

00:13:56.603 --> 00:14:00.307 align:middle
我们继续查看另一个特性
名为"查询"

00:13:56.603 --> 00:14:00.307 align:middle
我们继续查看另一个特性
名为"查询"

00:14:00.407 --> 00:14:04.578 align:middle
为此 我将首先让用户退出

00:14:07.080 --> 00:14:10.717 align:middle
通过查询 你们能够从数据库
得到数据子集

00:14:11.385 --> 00:14:12.819 align:middle
在这个代码示例中

00:14:12.886 --> 00:14:15.022 align:middle
我们给你们展示
怎样查询公用数据库

00:14:15.422 --> 00:14:18.659 align:middle
如果你们在架构上
合理设置了安全角色

00:14:18.859 --> 00:14:20.294 align:middle
你们实际上能够容易地

00:14:20.360 --> 00:14:22.029 align:middle
在公用数据库中查询数据

00:14:22.095 --> 00:14:23.363 align:middle
即我们在这里展示的东西

00:14:23.697 --> 00:14:24.798 align:middle
即使用户没有经过验证

00:14:25.232 --> 00:14:27.801 align:middle
我继续运行这个代码

00:14:28.068 --> 00:14:30.671 align:middle
这个示例的基本原理是使用

00:14:30.737 --> 00:14:33.974 align:middle
当前在Monscone中心
的位置

00:14:34.575 --> 00:14:35.843 align:middle
发送一个查询请求

00:14:35.909 --> 00:14:38.745 align:middle
并根据离我们现在
所在位置的远近

00:14:39.146 --> 00:14:40.247 align:middle
对结果进行排序

00:14:40.647 --> 00:14:41.648 align:middle
我现在...

00:14:42.649 --> 00:14:43.550 align:middle
运行这个代码

00:14:44.685 --> 00:14:45.953 align:middle
我得到两个返回的记录

00:14:46.420 --> 00:14:49.423 align:middle
第一个是冰岛
第二个是意大利

00:14:50.724 --> 00:14:52.826 align:middle
冰岛距离我们现在的位置
与意大利相比更近

00:14:52.960 --> 00:14:53.794 align:middle
结果是合理的

00:14:54.194 --> 00:14:55.529 align:middle
我将...

00:14:55.929 --> 00:14:58.098 align:middle
不会继续查看所有额外的特性

00:14:58.565 --> 00:15:00.100 align:middle
但我们非常鼓励你们
查看一下它

00:14:58.565 --> 00:15:00.100 align:middle
但我们非常鼓励你们
查看一下它

00:15:00.167 --> 00:15:03.504 align:middle
你们可以访问
developer@Apple.com/CloudKit

00:15:03.637 --> 00:15:05.639 align:middle
点击CloudKit
Catalog的链接

00:15:05.706 --> 00:15:07.574 align:middle
你们可以自己在任意浏览器上运行

00:15:20.687 --> 00:15:24.992 align:middle
CloudKit是我们苹果公司
很多新业务的基础

00:15:25.192 --> 00:15:27.995 align:middle
包括iCloud Drive
iCloud Photo Library

00:15:28.428 --> 00:15:32.232 align:middle
今年我们也已经为
iOS和OS X推出了...

00:15:32.699 --> 00:15:34.301 align:middle
一个备忘录应用

00:15:34.902 --> 00:15:37.371 align:middle
此应用也将出现在
iCloudKit平台

00:15:37.938 --> 00:15:40.307 align:middle
除了本地备忘录应用之外

00:15:40.774 --> 00:15:43.677 align:middle
我们在iCloud.com有一个
备忘录网络应用

00:15:44.178 --> 00:15:46.680 align:middle
这个备忘录应用是
在使用CloudKit JS

00:15:46.747 --> 00:15:49.383 align:middle
事实上
它使用的方式与你们

00:15:49.449 --> 00:15:52.152 align:middle
作为开发者目前可以
使用它的方式相同

00:15:52.653 --> 00:15:54.688 align:middle
这儿没有额外的"苹果魔法"

00:15:55.422 --> 00:15:59.059 align:middle
因此希望你们和我们一样
对CloudKit JS感到激动

00:15:59.359 --> 00:16:01.461 align:middle
在这儿看到很多新的可能

00:15:59.359 --> 00:16:01.461 align:middle
在这儿看到很多新的可能

00:16:01.695 --> 00:16:03.030 align:middle
并想了解怎样开始

00:16:04.464 --> 00:16:05.599 align:middle
那么让我们看这儿

00:16:08.602 --> 00:16:10.170 align:middle
首先 我们需要确保...

00:16:10.938 --> 00:16:13.006 align:middle
你们要在自己的网页上

00:16:13.707 --> 00:16:14.641 align:middle
嵌入一个脚本标签

00:16:14.708 --> 00:16:17.678 align:middle
你们通过将其指向CloudKit
JS的 非托管CD版本完成

00:16:18.612 --> 00:16:20.747 align:middle
这将让CloudKit JS
加入到网页中

00:16:21.648 --> 00:16:25.519 align:middle
其次
你们需要配置CloudKit实例

00:16:25.586 --> 00:16:27.521 align:middle
你们需要使CloudKit
命名空间可用

00:16:27.754 --> 00:16:30.390 align:middle
你们可以调用
CloudKit配置方法

00:16:30.958 --> 00:16:32.793 align:middle
并向它赋予一个
你们的应用

00:16:33.260 --> 00:16:34.661 align:middle
即将使用的容器标识符

00:16:35.128 --> 00:16:37.931 align:middle
你们的目标环境
生产环境或开发环境

00:16:38.665 --> 00:16:40.367 align:middle
然后你们指定API令牌
你们刚才看到

00:16:40.434 --> 00:16:43.403 align:middle
克里斯通过CloudKit
控制面板生成了API令牌

00:16:43.770 --> 00:16:44.605 align:middle
这就是需要的全部

00:16:44.671 --> 00:16:47.274 align:middle
此时你们已准备好
调用CloudKit API了

00:16:51.445 --> 00:16:52.279 align:middle
接下来

00:16:52.412 --> 00:16:54.882 align:middle
你们很可能希望
验证你们的用户

00:16:54.948 --> 00:16:56.617 align:middle
正如我们在示例app中
看到的一样

00:16:58.752 --> 00:17:01.321 align:middle
在iOS和OS X上
可以通过CloudKit直接操作

00:16:58.752 --> 00:17:01.321 align:middle
在iOS和OS X上
可以通过CloudKit直接操作

00:17:01.989 --> 00:17:04.858 align:middle
因为大多数用户已经登录
设备上的iCloud

00:17:04.925 --> 00:17:08.896 align:middle
你们只需要
在容器上调用取用户方法

00:17:09.463 --> 00:17:12.598 align:middle
你们得到一个用户记录

00:17:13.267 --> 00:17:16.069 align:middle
这个用户记录将
有一个稳定的标识符

00:17:16.803 --> 00:17:19.339 align:middle
那么这就是你们为了
通过本地设备上的CloudKit

00:17:19.406 --> 00:17:21.108 align:middle
验证用户
所需要做的全部工作

00:17:21.575 --> 00:17:24.243 align:middle
不使用显式登录
没有用户界面

00:17:24.310 --> 00:17:25.345 align:middle
这些都是无缝操作的

00:17:27.781 --> 00:17:30.551 align:middle
然而在网络上
操作会稍有不同

00:17:31.118 --> 00:17:33.353 align:middle
这些浏览器上不能直接登录

00:17:33.420 --> 00:17:35.589 align:middle
因此 你们必须为登录按钮
提供一个地址

00:17:36.356 --> 00:17:37.858 align:middle
如同我们在示例app上看到的

00:17:38.158 --> 00:17:39.860 align:middle
点击它会打开新窗口

00:17:40.227 --> 00:17:42.563 align:middle
这儿有一个苹果托管验证页

00:17:43.330 --> 00:17:45.832 align:middle
你们注意到在这个网页上

00:17:45.899 --> 00:17:49.203 align:middle
我们有应用的iCon
和应用的名称

00:17:49.469 --> 00:17:51.438 align:middle
这来自ITunes Connect

00:17:51.505 --> 00:17:53.507 align:middle
并发布于苹果公司App商店

00:17:54.074 --> 00:17:57.911 align:middle
用户输入他们的用户名和凭证

00:17:57.978 --> 00:17:59.646 align:middle
这显然将回到Apple网站

00:18:00.214 --> 00:18:02.282 align:middle
同样有一个分为两步的验证过程

00:18:02.349 --> 00:18:03.684 align:middle
如果账户是那么设置的话

00:18:05.485 --> 00:18:08.188 align:middle
这个过程完成后
窗口将关闭

00:18:08.355 --> 00:18:10.090 align:middle
它会发回一条POST信息

00:18:10.157 --> 00:18:13.560 align:middle
给已打开的窗口
这条信息将包括CloudKit会话

00:18:14.228 --> 00:18:16.897 align:middle
那么这时
你们的CloudKit JS

00:18:16.964 --> 00:18:18.398 align:middle
你们的网络应用将能够

00:18:18.465 --> 00:18:21.301 align:middle
开始对CloudKit
进行已验证的调用

00:18:24.838 --> 00:18:27.574 align:middle
为了在你们的页面上进行验证

00:18:28.509 --> 00:18:30.978 align:middle
你们首先必须为登录按钮
提供一个位置

00:18:31.678 --> 00:18:35.215 align:middle
进行设置给它一个
“apple-sign-in-button”ID

00:18:36.383 --> 00:18:39.386 align:middle
第二 你们必须调用
名为setUpAuth的方法

00:18:39.987 --> 00:18:42.322 align:middle
这将核对用户的验证状态

00:18:43.023 --> 00:18:44.791 align:middle
如果用户已经登录

00:18:45.392 --> 00:18:47.661 align:middle
一个user
info对象将会被返回

00:18:48.495 --> 00:18:50.531 align:middle
那就是你们需要寻找的全部信息

00:18:50.831 --> 00:18:53.634 align:middle
除了user info对象
它将会有一条记录名称

00:18:53.934 --> 00:18:55.836 align:middle
这是我们刚看到的

00:18:56.036 --> 00:18:57.070 align:middle
稳定标识符

00:18:57.504 --> 00:18:59.873 align:middle
现在
这个在网络上的稳定标识符

00:18:59.940 --> 00:19:02.075 align:middle
将与在iOS和OS X上的一样

00:18:59.940 --> 00:19:02.075 align:middle
将与在iOS和OS X上的一样

00:19:02.376 --> 00:19:04.778 align:middle
所以 你们有办法
在所有平台

00:19:05.078 --> 00:19:06.313 align:middle
引用相同的用户

00:19:09.449 --> 00:19:11.618 align:middle
除了核对验证状态外

00:19:12.319 --> 00:19:13.954 align:middle
你们需要处理用户

00:19:14.021 --> 00:19:15.656 align:middle
登录或退出时发生的事情

00:19:16.723 --> 00:19:20.127 align:middle
你们在容器上
调用whenUserSignsIn

00:19:20.627 --> 00:19:22.296 align:middle
你们得到一个promise

00:19:22.529 --> 00:19:25.299 align:middle
用户一旦登录会便会解决

00:19:27.568 --> 00:19:30.204 align:middle
用户退出登录时的情况也完全相同

00:19:32.840 --> 00:19:35.209 align:middle
除了CloudKit JS中的那些

00:19:35.275 --> 00:19:37.578 align:middle
关于验证的默认功能外

00:19:37.945 --> 00:19:40.380 align:middle
我们也提供切换以及

00:19:40.781 --> 00:19:42.616 align:middle
你们自定义处理验证的方式

00:19:43.183 --> 00:19:46.587 align:middle
下一个示例将向您展示
怎样在会话之间

00:19:46.653 --> 00:19:49.857 align:middle
保持验证状态
这样CloudKit就不会

00:19:50.190 --> 00:19:52.793 align:middle
在你们的域上写cookies

00:19:53.293 --> 00:19:55.495 align:middle
如果你们想让cookie被写下

00:19:55.796 --> 00:19:57.064 align:middle
以便存储AUTH会话

00:19:57.130 --> 00:19:58.398 align:middle
你们必须在配置阶段

00:19:58.799 --> 00:20:00.901 align:middle
将persist属性设置为true

00:19:58.799 --> 00:20:00.901 align:middle
将persist属性设置为true

00:20:02.202 --> 00:20:03.036 align:middle
现在

00:20:03.504 --> 00:20:05.439 align:middle
不用cookies
你们或许想

00:20:05.506 --> 00:20:07.040 align:middle
用其它方法存储会话

00:20:07.641 --> 00:20:09.476 align:middle
这个示例
将给你们展示配置中...

00:20:10.077 --> 00:20:11.645 align:middle
的几个手法

00:20:11.712 --> 00:20:14.548 align:middle
我们有一个putToken方法
和一个getToken方法

00:20:14.615 --> 00:20:19.853 align:middle
以便让putToken不管在何时
CloudKit JS从服务器收到任何令牌

00:20:20.187 --> 00:20:22.823 align:middle
和getToken不管在何时
CloudKit JS试图让令牌

00:20:22.890 --> 00:20:24.191 align:middle
与服务器对话时都能被调用

00:20:24.725 --> 00:20:27.761 align:middle
这个示例是您可能想把会话存储到

00:20:27.828 --> 00:20:30.731 align:middle
本地存储器或希望将其存储在

00:20:30.797 --> 00:20:32.199 align:middle
你们自己的服务器上

00:20:32.533 --> 00:20:34.034 align:middle
以便你们可以代表用户

00:20:34.101 --> 00:20:36.036 align:middle
进行服务器到服务器的调用

00:20:40.407 --> 00:20:42.809 align:middle
接下来我们将谈一下记录操作

00:20:44.711 --> 00:20:47.147 align:middle
正像早些时候克里斯
用JSON展示给你们的一样

00:20:47.881 --> 00:20:52.085 align:middle
CloudKit Js中的记录
基本像这样

00:20:52.653 --> 00:20:56.190 align:middle
我们有一个名称为
task-1的记录

00:20:56.790 --> 00:20:58.759 align:middle
它的recordType是
tasks

00:20:58.959 --> 00:21:02.229 align:middle
我们创建和修改了
一些元数据字段被

00:20:58.959 --> 00:21:02.229 align:middle
我们创建和修改了
一些元数据字段被

00:21:02.296 --> 00:21:05.566 align:middle
包括创建和修改记录的

00:21:05.632 --> 00:21:06.967 align:middle
用户数据以及时间戳

00:21:07.668 --> 00:21:11.004 align:middle
recordChangeTag
是该条记录的版本

00:21:11.672 --> 00:21:13.006 align:middle
目的为了解决冲

00:21:13.140 --> 00:21:14.675 align:middle
突然后下面出现的是

00:21:14.741 --> 00:21:16.577 align:middle
你们已经在框架中定义的

00:21:16.643 --> 00:21:18.078 align:middle
所有自定义字段

00:21:18.378 --> 00:21:21.448 align:middle
这个示例中
我们只有一个任务名

00:21:21.815 --> 00:21:23.951 align:middle
类型是字符串
值为"买牛奶"

00:21:27.721 --> 00:21:29.456 align:middle
显然你们可能想存储

00:21:29.523 --> 00:21:32.693 align:middle
字符串以外其它类型的字段

00:21:33.727 --> 00:21:36.363 align:middle
这会给你们一个

00:21:36.430 --> 00:21:38.932 align:middle
与iOS和OS X的比较

00:21:39.333 --> 00:21:41.468 align:middle
在CloudKit框架中
我们有一个字符串

00:21:41.535 --> 00:21:43.637 align:middle
但是在CloudKit JS中
我们只使用

00:21:43.704 --> 00:21:45.906 align:middle
JavaScript字符串
数字方面也一样

00:21:46.507 --> 00:21:49.543 align:middle
对于NS数据 我们使用基本
64位代码和二进制编码

00:21:50.711 --> 00:21:53.013 align:middle
对于NS数据
我们有JavaScript数字

00:21:53.080 --> 00:21:54.848 align:middle
使用UNIX时间
以毫秒为时间单位

00:21:56.316 --> 00:21:59.186 align:middle
对于更复杂的对象
如CL位置

00:21:59.253 --> 00:22:00.888 align:middle
我们有一个定位对象

00:21:59.253 --> 00:22:00.888 align:middle
我们有一个定位对象

00:22:01.522 --> 00:22:03.090 align:middle
和一个参考对象

00:22:03.156 --> 00:22:04.658 align:middle
和一个资源对象

00:22:05.259 --> 00:22:07.160 align:middle
请你们查看文稿

00:22:07.227 --> 00:22:09.296 align:middle
以了解每一个对象是如何定义的

00:22:12.933 --> 00:22:14.968 align:middle
在建立记录方面

00:22:15.536 --> 00:22:16.670 align:middle
你们可以继续

00:22:16.737 --> 00:22:18.071 align:middle
定义其中一个对象字面量

00:22:18.205 --> 00:22:21.408 align:middle
这个示例只是表明了
记录类型是tasks的情况

00:22:22.109 --> 00:22:23.810 align:middle
而且只有一个字段
即taskName

00:22:23.877 --> 00:22:26.480 align:middle
它的值为"买牛奶"

00:22:27.414 --> 00:22:29.816 align:middle
你们可以继续进行下去
在数据库对象上

00:22:30.384 --> 00:22:31.985 align:middle
调用saveRecord方法

00:22:33.287 --> 00:22:34.721 align:middle
不过你们注意到
在以上示例中

00:22:34.788 --> 00:22:36.657 align:middle
我们没有赋给它recordName

00:22:36.924 --> 00:22:39.126 align:middle
记录名是一个记录的
独特标识符

00:22:39.526 --> 00:22:41.428 align:middle
那么
在未指定情况下

00:22:41.495 --> 00:22:43.497 align:middle
服务器将径直
为我们生成一个记录名

00:22:44.198 --> 00:22:48.068 align:middle
我们也没有为这个特定字段
指定字符串类型

00:22:48.602 --> 00:22:51.371 align:middle
因此CloudKit JS会做一些
类型推断

00:22:51.705 --> 00:22:53.807 align:middle
它会弄清这个值是一个字符串

00:22:53.874 --> 00:22:56.376 align:middle
你们应该对我们的所有基本
类型都进行这种指定

00:23:01.715 --> 00:23:04.351 align:middle
接下来我们想谈谈查询

00:23:04.551 --> 00:23:07.454 align:middle
它在网络上通过
JavaScript API

00:23:07.521 --> 00:23:09.890 align:middle
的操作有一点不同

00:23:10.958 --> 00:23:13.260 align:middle
在Foundation框架中的
iOS和OS X上

00:23:13.327 --> 00:23:15.462 align:middle
我们有NSPredicate

00:23:16.263 --> 00:23:18.365 align:middle
NSPredicate...

00:23:19.132 --> 00:23:19.967 align:middle
很棒

00:23:20.033 --> 00:23:22.469 align:middle
但它对网络不是很自然

00:23:22.536 --> 00:23:23.537 align:middle
不是很符合...

00:23:23.837 --> 00:23:27.674 align:middle
我们将通过网络服务
展示的JSON API

00:23:28.475 --> 00:23:32.045 align:middle
我们这里有些东西看起来
与Java用于记录的字面量很像

00:23:32.112 --> 00:23:34.181 align:middle
你们只须定义一个这样的查询

00:23:34.248 --> 00:23:36.783 align:middle
这本例中我们表明
记录类型是tasks

00:23:37.651 --> 00:23:40.120 align:middle
我们在数据库上调用
performQuery

00:23:40.654 --> 00:23:43.357 align:middle
我们将取回类型为"tasks"的
任务的所有记录

00:23:45.492 --> 00:23:48.161 align:middle
现在你们可以做一
更复杂的操作

00:23:48.228 --> 00:23:50.864 align:middle
下一个示例中我们提供
一些performQuer y

00:23:51.398 --> 00:23:52.833 align:middle
方法的选择

00:23:53.333 --> 00:23:55.169 align:middle
我们表明这个硬键是任务名

00:23:55.235 --> 00:23:56.670 align:middle
我们将只是从每个记录

00:23:56.737 --> 00:23:58.038 align:middle
取回任务名字段

00:23:58.872 --> 00:24:00.741 align:middle
我们将把结果限额限制为十个

00:23:58.872 --> 00:24:00.741 align:middle
我们将把结果限额限制为十个

00:24:01.608 --> 00:24:03.977 align:middle
我们也将把所有记录限定为

00:24:04.044 --> 00:24:05.913 align:middle
在"allTask"这个自定义区内

00:24:09.516 --> 00:24:12.152 align:middle
查询同样允许你们

00:24:12.419 --> 00:24:13.854 align:middle
指定一个筛选条件

00:24:14.521 --> 00:24:16.557 align:middle
在接下来的这个示例中
我们将表明

00:24:17.224 --> 00:24:19.760 align:middle
希望查找任务的记录类型

00:24:19.826 --> 00:24:22.296 align:middle
但是我们只想取回
符合"优先条件1"的任务

00:24:23.230 --> 00:24:25.232 align:middle
我们将调用
performQuery方法

00:24:25.332 --> 00:24:27.401 align:middle
我们取回所有
符合"优先条件1"的任务

00:24:28.335 --> 00:24:31.138 align:middle
你们注意到我们在这儿
使用"等于"作为比较条件

00:24:31.705 --> 00:24:33.540 align:middle
并且我们有更多的比较条件

00:24:33.607 --> 00:24:36.176 align:middle
这取决于你们查询的字段类型

00:24:36.243 --> 00:24:37.444 align:middle
因此请查阅字段相关文稿

00:24:37.511 --> 00:24:39.479 align:middle
以便了解在什么地方
对每种类型进行定义

00:24:43.483 --> 00:24:46.353 align:middle
你们在早些时候已经看到
我们限制了结果集合

00:24:46.653 --> 00:24:50.324 align:middle
问题是你们怎样在结果上标注页码

00:24:51.558 --> 00:24:53.393 align:middle
这是一个相关的例子

00:24:53.527 --> 00:24:56.163 align:middle
结果的数量限制为10

00:24:56.797 --> 00:25:00.133 align:middle
当这个promise解决时
我们将取回前10个记录

00:24:56.797 --> 00:25:00.133 align:middle
当这个promise解决时
我们将取回前10个记录

00:25:00.834 --> 00:25:02.369 align:middle
但是在response
对象上

00:25:02.436 --> 00:25:03.971 align:middle
还有moreComing属性

00:25:04.271 --> 00:25:05.939 align:middle
这告诉我们除了我们刚取得的

00:25:06.006 --> 00:25:07.941 align:middle
10个记录之外还有更多记录

00:25:08.442 --> 00:25:11.712 align:middle
我们把response对象
传回给performQuery

00:25:11.979 --> 00:25:14.748 align:middle
CloudKit JS会为我们
完成所有工作

00:25:14.815 --> 00:25:17.951 align:middle
继续为我们
获取的下10条记录

00:25:18.652 --> 00:25:20.454 align:middle
本例中
我们展示如何能够

00:25:20.521 --> 00:25:22.389 align:middle
把这些promises
很好地连接起来

00:25:26.960 --> 00:25:28.962 align:middle
那么接下来是资源

00:25:29.129 --> 00:25:31.431 align:middle
与其他字段类型相比

00:25:31.498 --> 00:25:34.301 align:middle
资源在CloudKit的操作
有一些不同

00:25:35.269 --> 00:25:38.205 align:middle
资源没有和记录一起被存储

00:25:38.272 --> 00:25:41.408 align:middle
资源被存储在外面的
我们所谓的资源存储器中

00:25:41.775 --> 00:25:43.377 align:middle
记录只是简单引用了

00:25:43.443 --> 00:25:44.845 align:middle
资源和资源存储器

00:25:45.779 --> 00:25:48.982 align:middle
好消息是CloudKit JS
完美的为你们处理这些事务

00:25:49.883 --> 00:25:53.287 align:middle
这个例子中
我们有一个带有输入元素的网页

00:25:53.654 --> 00:25:55.622 align:middle
让用户在
CloudKit目录app中

00:25:55.689 --> 00:25:57.257 align:middle
选择一个这样的文件

00:25:58.258 --> 00:26:00.294 align:middle
那么当某个文件被选定时

00:25:58.258 --> 00:26:00.294 align:middle
那么当某个文件被选定时

00:26:00.360 --> 00:26:03.697 align:middle
handleFileSelect
函数将被调用

00:26:04.464 --> 00:26:06.800 align:middle
我们只需要为这个文件
找到一个参考

00:26:07.534 --> 00:26:09.069 align:middle
我们可以将其作为我们

00:26:09.136 --> 00:26:11.471 align:middle
即将保存的资源字段的值

00:26:12.005 --> 00:26:14.441 align:middle
因此在这里CloudKit JS
会为我们把资源

00:26:14.508 --> 00:26:17.878 align:middle
上传到资源存储器
然后在数据库中保存记录

00:26:18.245 --> 00:26:20.714 align:middle
同时在数据库内
创建对该资源的参考

00:26:26.086 --> 00:26:28.722 align:middle
下载资源更容易

00:26:28.789 --> 00:26:30.257 align:middle
当您请求一个带有资源的字段时

00:26:30.924 --> 00:26:33.627 align:middle
你们将取回一个下载URL

00:26:34.027 --> 00:26:37.598 align:middle
这个例子中
我们将获取一个用户记录

00:26:38.332 --> 00:26:42.202 align:middle
你们注意到这里的值
有一个downloadURL属性

00:26:42.503 --> 00:26:44.872 align:middle
你们可以继续获取相关信息

00:26:44.938 --> 00:26:46.473 align:middle
或把这个作为你们

00:26:46.607 --> 00:26:48.375 align:middle
图像等要素的一个来源

00:26:53.013 --> 00:26:54.848 align:middle
CloudKit的另一个重要特性

00:26:54.915 --> 00:26:56.783 align:middle
是订阅和推送通知

00:26:57.818 --> 00:26:59.419 align:middle
所有推送到Apple设备上
的通知

00:26:59.486 --> 00:27:03.557 align:middle
都通过Apple通知推送服务

00:26:59.486 --> 00:27:03.557 align:middle
都通过Apple通知推送服务

00:27:05.292 --> 00:27:07.060 align:middle
为了使推送顺利进行
传统上你们必须

00:27:07.127 --> 00:27:09.830 align:middle
设定你们自己的第三方服务器

00:27:09.897 --> 00:27:11.999 align:middle
你们必须有自己的服务器

00:27:12.232 --> 00:27:13.200 align:middle
带有你们自己的证书

00:27:13.267 --> 00:27:14.568 align:middle
有你们自己的服务器逻辑

00:27:14.935 --> 00:27:16.036 align:middle
你们必须通过那种方式

00:27:17.437 --> 00:27:18.572 align:middle
发出推送通知

00:27:19.606 --> 00:27:20.874 align:middle
然而使用CloudKit

00:27:20.941 --> 00:27:22.676 align:middle
不再需要这样了

00:27:22.743 --> 00:27:25.846 align:middle
你们可以设置CloudKit订阅

00:27:26.380 --> 00:27:28.315 align:middle
它们就像数据库中的触发器

00:27:28.916 --> 00:27:30.884 align:middle
它们会寻找数据中的变化

00:27:30.951 --> 00:27:33.353 align:middle
并且根据变化发生的时间
发出推送通知

00:27:34.288 --> 00:27:35.989 align:middle
现在
有了CloudKit JS

00:27:36.056 --> 00:27:37.591 align:middle
网络将成为另一个客户端

00:27:38.091 --> 00:27:39.493 align:middle
我们将能够通过网络收到

00:27:39.560 --> 00:27:42.863 align:middle
与使用iOS和OS X相同的推送

00:27:45.632 --> 00:27:48.769 align:middle
为了收到推送
你们必须设置订阅

00:27:49.336 --> 00:27:52.673 align:middle
这里的第一个例子
向你们展示一个区域订阅

00:27:53.307 --> 00:27:55.676 align:middle
我们将声明
subscriptionType是zone

00:27:55.909 --> 00:27:58.779 align:middle
subscriptionID是
changeTasks

00:27:59.112 --> 00:28:01.615 align:middle
我们为zoneID的赋值为
allTasks

00:27:59.112 --> 00:28:01.615 align:middle
我们为zoneID的赋值为
allTasks

00:28:02.549 --> 00:28:05.285 align:middle
我继续用数据库保存订阅

00:28:06.253 --> 00:28:08.121 align:middle
那么这将开始寻找变化

00:28:08.188 --> 00:28:11.325 align:middle
一旦allTasks自定义区内
发生任何变化

00:28:11.625 --> 00:28:12.926 align:middle
它会向连接到相同账户

00:28:12.993 --> 00:28:15.629 align:middle
的所有客户端推送信息

00:28:19.600 --> 00:28:23.136 align:middle
订阅同样允许你们把它们
建立在查询基础上

00:28:23.971 --> 00:28:27.441 align:middle
这里的下一个例子中
我们建立一个查询订阅

00:28:27.708 --> 00:28:30.544 align:middle
它将触发allTasks
自定义区内创建

00:28:30.777 --> 00:28:32.713 align:middle
更新或删除的任何信息

00:28:33.480 --> 00:28:36.083 align:middle
然后我们指定一个查询
这个特定查询

00:28:36.149 --> 00:28:37.484 align:middle
就像我们为记录取信息一样

00:28:37.885 --> 00:28:40.420 align:middle
任何时候一个优先权为1的任务

00:28:40.721 --> 00:28:42.823 align:middle
被创建 更新或删除时

00:28:43.323 --> 00:28:44.558 align:middle
将会有一个推送通知被发出

00:28:45.626 --> 00:28:47.060 align:middle
而那就是我们需要做的全部

00:28:49.830 --> 00:28:53.534 align:middle
那么在网站上
你们必须完成两件事

00:28:54.201 --> 00:28:57.171 align:middle
首先
们必须为通知注册

00:28:57.538 --> 00:28:59.907 align:middle
这会从服务器获得一个令牌

00:28:59.973 --> 00:29:02.042 align:middle
我们可以将其
用于Apple推送通知服务

00:28:59.973 --> 00:29:02.042 align:middle
我们可以将其
用于Apple推送通知服务

00:29:02.309 --> 00:29:03.644 align:middle
并且暂停

00:29:04.077 --> 00:29:06.613 align:middle
与Apple推送连接服务的连接

00:29:07.214 --> 00:29:08.048 align:middle
其次

00:29:08.582 --> 00:29:12.319 align:middle
你们需要调用
addNotificationListener

00:29:12.386 --> 00:29:14.888 align:middle
每当网页上收到通知的时候

00:29:14.955 --> 00:29:16.089 align:middle
它都会被调用

00:29:21.295 --> 00:29:25.299 align:middle
最后 让我讲一下一些使用
CloudKit JS的最佳实践

00:29:26.466 --> 00:29:27.868 align:middle
如我们刚才所见

00:29:28.068 --> 00:29:29.837 align:middle
你们应该动态链接到

00:29:29.903 --> 00:29:32.005 align:middle
CDN托管版本的
CloudKit JS

00:29:32.406 --> 00:29:34.842 align:middle
你们应该跟随我们
升级到最新版本

00:29:34.908 --> 00:29:36.510 align:middle
并修复安全漏洞

00:29:36.810 --> 00:29:40.180 align:middle
它同样确保这个资源

00:29:40.347 --> 00:29:42.816 align:middle
通过我们庞大而完善的
分发网络实现低延迟交付

00:29:43.150 --> 00:29:44.952 align:middle
而且它是完全免费的
这一点好极了

00:29:46.854 --> 00:29:49.056 align:middle
其次 你们应该考虑
在你们的网页上

00:29:49.122 --> 00:29:50.858 align:middle
异步加载CloudKit JS

00:29:51.158 --> 00:29:53.327 align:middle
对于任何你们可能在网页
加载的第三方库

00:29:53.393 --> 00:29:55.095 align:middle
这是一个好建议

00:29:55.696 --> 00:29:59.266 align:middle
它会避免任何网络阻塞
以及用户体验的冲击

00:30:01.802 --> 00:30:05.539 align:middle
最后 你们必须确保
对请求响应进行处理

00:30:05.973 --> 00:30:07.074 align:middle
所以CloudKit的

00:30:07.140 --> 00:30:08.642 align:middle
新自由限制设置

00:30:09.076 --> 00:30:10.077 align:middle
包括对请求的限制

00:30:10.143 --> 00:30:11.478 align:middle
确实是极为宽宏大量的

00:30:11.912 --> 00:30:14.548 align:middle
你们在检索时可能遇到网站阻塞

00:30:14.615 --> 00:30:15.716 align:middle
所以你们需要确定

00:30:15.782 --> 00:30:17.584 align:middle
你们的客户端
将提供适当的备份支持

00:30:18.085 --> 00:30:21.522 align:middle
它是否在有大量响应的同时
仍能正常检索请求

00:30:22.222 --> 00:30:25.592 align:middle
那么你们也可以研究它怎样
对单一请求进行批量操作

00:30:25.659 --> 00:30:28.428 align:middle
我们确实有一个
CloudKit JS批

00:30:28.795 --> 00:30:29.730 align:middle
处理API

00:30:30.597 --> 00:30:32.366 align:middle
如果你们真的对这个话题
感兴趣的话

00:30:32.432 --> 00:30:33.834 align:middle
你们确实应该参加

00:30:33.901 --> 00:30:35.769 align:middle
明天的CloudKit小窍门讲座

00:30:36.136 --> 00:30:39.306 align:middle
他们会谈到更多关于整个
CloudKit请求被限流的问题

00:30:39.373 --> 00:30:41.108 align:middle
而且不限于网络方面

00:30:42.242 --> 00:30:43.143 align:middle
就这么多

00:30:43.210 --> 00:30:44.645 align:middle
那就是CloudKit JS

00:30:44.711 --> 00:30:46.280 align:middle
我们非常期待看到你们

00:30:46.346 --> 00:30:47.414 align:middle
用它构建的东西

00:30:47.814 --> 00:30:50.150 align:middle
你们如有任何问题
敬请顺便访问各个实验室

00:30:50.551 --> 00:30:52.085 align:middle
现在
我将把舞台交给克里斯

00:31:02.863 --> 00:31:03.697 align:middle
感谢欧那尔

00:31:06.133 --> 00:31:07.000 align:middle
总而言之

00:31:09.069 --> 00:31:11.438 align:middle
CloudKit 网络服务
提供了一个完全

00:31:11.505 --> 00:31:14.074 align:middle
与你们在网络上的CloudKit
数据对等的接口

00:31:15.642 --> 00:31:18.011 align:middle
它们通常以容器为基础的

00:31:19.746 --> 00:31:21.114 align:middle
我们处理验证

00:31:21.348 --> 00:31:22.282 align:middle
元数据存储

00:31:22.482 --> 00:31:24.084 align:middle
以及资源上传和下载

00:31:25.619 --> 00:31:27.788 align:middle
你们处理托管
你们的静态资源

00:31:28.088 --> 00:31:30.057 align:middle
和你们的
JavaScript应用代码

00:31:31.558 --> 00:31:33.527 align:middle
最后我们为你们带来
CloudKit JS

00:31:33.594 --> 00:31:35.162 align:middle
以使这些变得尽可能的容易

00:31:37.631 --> 00:31:38.832 align:middle
你们可以在网上访问我们

00:31:38.899 --> 00:31:41.768 align:middle
地址是
developer.Apple.com/cloudKit

00:31:42.536 --> 00:31:44.571 align:middle
如果有任何问题
你们可以访问

00:31:44.638 --> 00:31:45.706 align:middle
苹果开发者论坛

00:31:46.039 --> 00:31:48.141 align:middle
或Apple开发者技术支持

00:31:48.909 --> 00:31:49.810 align:middle
如果仍然有问题

00:31:49.877 --> 00:31:50.811 align:middle
可以给我们发邮件

00:31:50.878 --> 00:31:53.080 align:middle
地址为<u>CloudKit@Apple .com</u>

00:31:55.649 --> 00:31:56.917 align:middle
有一些相关的讲座

00:31:56.984 --> 00:31:58.519 align:middle
你们可以在网上观看我们昨天的

00:31:58.585 --> 00:32:00.454 align:middle
《CloudKit中的新特性》讲座

00:31:58.585 --> 00:32:00.454 align:middle
《CloudKit中的新特性》讲座

00:32:00.521 --> 00:32:03.257 align:middle
明天有题为
《CloudKit小窍门》的讲座

00:32:03.624 --> 00:32:04.725 align:middle
我希望在那里见到你们

00:32:04.892 --> 00:32:05.826 align:middle
非常感谢你们
