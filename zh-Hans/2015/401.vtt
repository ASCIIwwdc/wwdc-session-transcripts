WEBVTT

00:00:19.820 --> 00:00:23.824 align:middle
Swift和Objective-C
互操作性

00:00:25.459 --> 00:00:27.961 align:middle
大家下午好 我是约旦·羅斯

00:00:33.867 --> 00:00:35.302 align:middle
哇 谢谢你们我还什么都没做

00:00:36.336 --> 00:00:37.237 align:middle
我是约旦·羅斯

00:00:37.304 --> 00:00:39.540 align:middle
过会儿道格·格雷戈尔也会加入我们

00:00:39.907 --> 00:00:44.745 align:middle
我们想要和你们分享一年来我们在
Swift和Objective-C语言的改进

00:00:45.012 --> 00:00:47.514 align:middle
特别是在互操作性方面的变化

00:00:48.182 --> 00:00:51.385 align:middle
因为Objective-C
和Swift的类库都相同

00:00:51.652 --> 00:00:53.020 align:middle
所以这很重要

00:00:53.820 --> 00:00:56.023 align:middle
在Xcode 7中我们更容易看到

00:00:56.089 --> 00:00:57.758 align:middle
这个映射是如何工作的

00:00:58.125 --> 00:00:59.860 align:middle
来到Objective-C的头文件

00:01:00.160 --> 00:01:02.496 align:middle
在顶部靠左的位置

00:01:02.696 --> 00:01:03.864 align:middle
选择显示关联项按钮

00:01:04.263 --> 00:01:06.300 align:middle
会跳出关联项菜单

00:01:06.366 --> 00:01:09.303 align:middle
其中一个是生成的接口

00:01:09.837 --> 00:01:12.873 align:middle
这会显示SWIFT的对于
这个头文件的映射

00:01:13.974 --> 00:01:16.009 align:middle
这和Xcode 6中用”调到定义

00:01:16.076 --> 00:01:19.446 align:middle
场景中的视图是完全一样的

00:01:19.780 --> 00:01:22.916 align:middle
但是现在你可以很容易的在对象中的
任意头文件中得到这个映射关系

00:01:24.952 --> 00:01:26.220 align:middle
今天我们将会讲到多种

00:01:26.286 --> 00:01:28.989 align:middle
在Swif
和Objective-C混编中

00:01:29.056 --> 00:01:32.359 align:middle
和在Objective-C中的
开发的新特性

00:01:32.960 --> 00:01:35.495 align:middle
我们将从一些Swif
和Objective-C混编

00:01:35.562 --> 00:01:36.997 align:middle
的基本特性开始重点

00:01:37.664 --> 00:01:40.667 align:middle
讨论新的错误处理特性和这种特性

00:01:40.734 --> 00:01:41.969 align:middle
跨语言工作原理

00:01:42.402 --> 00:01:43.403 align:middle
然后我们将会

00:01:43.470 --> 00:01:45.772 align:middle
讲在过去一年中关于
Objective-C的3个

00:01:45.839 --> 00:01:47.941 align:middle
主要改进包括“可空性注释”

00:01:48.041 --> 00:01:50.711 align:middle
“轻量通用类型”和“种类型”

00:01:52.212 --> 00:01:53.881 align:middle
我们从Swift端开始

00:01:54.548 --> 00:01:57.184 align:middle
我们会看到将
Objective-C APIs

00:01:57.251 --> 00:01:58.886 align:middle
嵌入Swift有多容易

00:01:59.653 --> 00:02:01.622 align:middle
但是问题来了

00:01:59.653 --> 00:02:01.622 align:middle
但是问题来了

00:02:01.989 --> 00:02:05.125 align:middle
什么时候把Swift暴露给
Objective-C代码

00:02:06.460 --> 00:02:08.495 align:middle
让我们复习一下规则

00:02:09.930 --> 00:02:12.499 align:middle
如果你有一个NSObject的子类

00:02:12.966 --> 00:02:16.670 align:middle
那么默认的它的方法和属性暴露
给Objective-C代码

00:02:17.271 --> 00:02:19.740 align:middle
在这个例子中我们有一个
我的控制器类是

00:02:19.806 --> 00:02:21.542 align:middle
UIViewController的
子类

00:02:21.608 --> 00:02:23.810 align:middle
那是NSObject的非直接子类

00:02:24.211 --> 00:02:28.115 align:middle
所以这个刷新方法将暴露给
Objective-C

00:02:29.750 --> 00:02:32.719 align:middle
然而如果你把这个方法标记为私有的

00:02:33.120 --> 00:02:35.689 align:middle
这意味着它仅在当前文件中可见

00:02:36.256 --> 00:02:39.159 align:middle
所以在这里默认情况下
Swift不会将这个方法暴露

00:02:39.226 --> 00:02:41.028 align:middle
给Objective-C

00:02:42.062 --> 00:02:44.431 align:middle
另外如果你仅仅使用

00:02:44.531 --> 00:02:48.902 align:middle
如果使用一些Swift专用的特性

00:02:49.436 --> 00:02:52.706 align:middle
就没有办法把这个方法
暴露给Objective-C

00:02:52.806 --> 00:02:54.208 align:middle
Swift甚至试都不会试

00:02:56.009 --> 00:03:00.113 align:middle
最后如果不是NSObject的子类

00:02:56.009 --> 00:03:00.113 align:middle
最后如果不是NSObject的子类

00:03:00.547 --> 00:03:03.483 align:middle
仅粗略的符合
Objective-C协议

00:03:04.051 --> 00:03:05.719 align:middle
那么你必须格外注意

00:03:05.786 --> 00:03:08.856 align:middle
你的方法必须完全的满足协议要求

00:03:09.256 --> 00:03:11.758 align:middle
在Xcode 7你会得到这样的告警

00:03:12.125 --> 00:03:16.029 align:middle
在这里 “页面视图开始加载”
不是objc

00:03:16.296 --> 00:03:18.465 align:middle
它不能满足

00:03:18.699 --> 00:03:20.834 align:middle
“UI web视图代理协议”的要求

00:03:22.870 --> 00:03:24.271 align:middle
这涵盖了默认值

00:03:24.771 --> 00:03:26.340 align:middle
你把这些默认行为

00:03:26.540 --> 00:03:27.841 align:middle
变成这样时会发生什么？

00:03:28.742 --> 00:03:31.278 align:middle
让我们回到具有刷新
方法的我的控制器版本

00:03:31.345 --> 00:03:34.615 align:middle
我想把它暴露给
Objective-C

00:03:35.415 --> 00:03:36.383 align:middle
但是它依赖于

00:03:36.450 --> 00:03:40.621 align:middle
我下一步想做什么依赖于我需要
用刷新方法做什么

00:03:41.288 --> 00:03:45.158 align:middle
所以如果我想要

00:03:45.225 --> 00:03:49.229 align:middle
用接口生成器或是核心数据属性

00:03:49.530 --> 00:03:51.331 align:middle
我们有专用属性

00:03:51.398 --> 00:03:53.734 align:middle
你所要做的就是添加这些属性

00:03:54.234 --> 00:03:56.970 align:middle
所以如果你使用现在
展示的IBAction属性

00:03:58.472 --> 00:04:02.743 align:middle
你只需要在i接口生成器中
将刷新方法设置为有效行为

00:03:58.472 --> 00:04:02.743 align:middle
你只需要在i接口生成器中
将刷新方法设置为有效行为

00:04:04.211 --> 00:04:06.547 align:middle
相似的如果你正在使用

00:04:06.747 --> 00:04:09.016 align:middle
全系统基础关键值属性

00:04:09.249 --> 00:04:10.450 align:middle
或者是Cocoa绑定属性

00:04:11.018 --> 00:04:13.787 align:middle
你只要添加动态调整器就可以了

00:04:14.254 --> 00:04:16.757 align:middle
这将告诉Swift
这个属性实施过程中

00:04:17.024 --> 00:04:18.659 align:middle
通过全系统关键值

00:04:18.892 --> 00:04:20.627 align:middle
可以在线调整

00:04:22.062 --> 00:04:24.865 align:middle
但是如果你想要将某个特殊方法

00:04:24.932 --> 00:04:26.733 align:middle
或是属性暴露给
Objective-C

00:04:27.000 --> 00:04:30.170 align:middle
你总是可以使用plain-old
at-objc调整器

00:04:30.971 --> 00:04:35.843 align:middle
或是objc 属性 对不起
这将会把方法或

00:04:36.009 --> 00:04:38.111 align:middle
objective暴露给
Objective-C

00:04:38.178 --> 00:04:39.947 align:middle
这不需要任何附加语义

00:04:41.448 --> 00:04:44.151 align:middle
这个objc属性在其它事情上也有用

00:04:44.418 --> 00:04:46.920 align:middle
在Objective-C中
这个objc属性会

00:04:46.987 --> 00:04:48.956 align:middle
为你指出一些不可见的事物

00:04:49.389 --> 00:04:51.792 align:middle
如果我想要非寻常返回类型

00:04:51.859 --> 00:04:54.061 align:middle
的跨版本刷新

00:04:54.494 --> 00:04:56.864 align:middle
那么我将会看到错误信息
“因为返结果类型不能在

00:04:56.930 --> 00:04:58.465 align:middle
Objective-C中体现

00:04:58.899 --> 00:05:01.768 align:middle
所以该方法无法在objc中标识”

00:04:58.899 --> 00:05:01.768 align:middle
所以该方法无法在objc中标识”

00:05:03.337 --> 00:05:06.673 align:middle
所有这些规则都包含在
“用cocoa使用Swift

00:05:06.740 --> 00:05:09.576 align:middle
and Objective-C”
手册这本手册中

00:05:09.643 --> 00:05:12.346 align:middle
可以访问
developer.apple.com/Swift在线查找

00:05:13.814 --> 00:05:16.550 align:middle
现在我们已经介绍了默认值

00:05:16.617 --> 00:05:19.019 align:middle
还介绍了如何重新定义这些默认值

00:05:19.453 --> 00:05:21.321 align:middle
以便让我们的代码更加符合ObjC

00:05:21.922 --> 00:05:23.524 align:middle
但是如果你碰到相反的问题呢？

00:05:24.992 --> 00:05:27.528 align:middle
让我们来看看这个类：计算器控制器

00:05:28.095 --> 00:05:30.597 align:middle
它有两个方法：“执行 操作”

00:05:31.231 --> 00:05:32.866 align:middle
其中一个有一种类型的封闭包

00:05:33.033 --> 00:05:34.735 align:middle
另外一种有不同种类的封闭包

00:05:35.636 --> 00:05:36.470 align:middle
好吧

00:05:36.570 --> 00:05:40.274 align:middle
Swift能够基于参数类型快速区分
这两个方法

00:05:41.074 --> 00:05:42.843 align:middle
但是Objective-C
不是这样工作的

00:05:42.910 --> 00:05:45.345 align:middle
在Objective-C中
不能通过类型

00:05:45.412 --> 00:05:47.247 align:middle
只能通过名称区分方法

00:05:48.649 --> 00:05:51.285 align:middle
在这里Swift知道这是个问题

00:05:51.351 --> 00:05:52.819 align:middle
它会给你发送错误信息

00:05:54.021 --> 00:05:57.257 align:middle
现在你总是可以使用ObjC
属性的选择器形式

00:05:57.324 --> 00:05:58.959 align:middle
来修正这个错误

00:05:59.526 --> 00:06:03.430 align:middle
所以如果我编写了这个代码
那么当我从Objective-C接入它时

00:05:59.526 --> 00:06:03.430 align:middle
所以如果我编写了这个代码
那么当我从Objective-C接入它时

00:06:03.697 --> 00:06:05.465 align:middle
我就将按钮方法

00:06:05.866 --> 00:06:08.001 align:middle
重命名为执行二进制操作

00:06:08.635 --> 00:06:11.538 align:middle
顶部的方法还是名为执行操作

00:06:13.273 --> 00:06:16.643 align:middle
在Xcode 7中为这类问题
我们添加了其它解决方案

00:06:16.877 --> 00:06:18.779 align:middle
即non-ObjC属性

00:06:19.179 --> 00:06:20.447 align:middle
就像你所想到的

00:06:20.614 --> 00:06:23.417 align:middle
这会使用一些非正常
暴露给Objective-C的东西

00:06:23.817 --> 00:06:26.620 align:middle
并且防止它被这样暴露

00:06:27.020 --> 00:06:29.790 align:middle
你可以将
non-ObjC赋予任何方法

00:06:30.224 --> 00:06:32.626 align:middle
属性子脚本或初始化器

00:06:34.862 --> 00:06:37.364 align:middle
那是数量非常庞大的
Objective-C和方法

00:06:37.698 --> 00:06:39.499 align:middle
但是低级语言怎么办？

00:06:40.667 --> 00:06:41.668 align:middle
来看看C语言

00:06:43.470 --> 00:06:45.472 align:middle
这里有些人不太高兴了

00:06:45.539 --> 00:06:47.407 align:middle
我们有一个函数指针的幻灯片

00:06:49.643 --> 00:06:52.746 align:middle
函数指针是C语言用户用来回调的

00:06:53.547 --> 00:06:55.883 align:middle
这意味着它们类似于闭包

00:06:56.416 --> 00:06:58.685 align:middle
但是它们不能携带任何附加状态

00:06:59.319 --> 00:07:00.454 align:middle
我说的是什么意思呢？

00:06:59.319 --> 00:07:00.454 align:middle
我说的是什么意思呢？

00:07:01.455 --> 00:07:03.056 align:middle
我用Swift试图

00:07:03.123 --> 00:07:05.526 align:middle
调用C函数开放函数

00:07:05.759 --> 00:07:07.361 align:middle
它有很多的参数

00:07:07.427 --> 00:07:08.695 align:middle
你不需要知道所有的参数

00:07:09.129 --> 00:07:10.297 align:middle
其中一个是回调参数

00:07:11.164 --> 00:07:16.670 align:middle
在这个回调中我做自调用

00:07:16.737 --> 00:07:22.309 align:middle
所以它必须储存在这个闭包
后面访问的某个部分

00:07:23.177 --> 00:07:25.479 align:middle
这是我们所谓的携带状态的闭包

00:07:25.946 --> 00:07:28.115 align:middle
当你试图使用这个闭包

00:07:28.382 --> 00:07:30.817 align:middle
用这个API你收到一个错误信息

00:07:32.319 --> 00:07:36.490 align:middle
现在在Swift1.2中
函数指针不是非常有用

00:07:36.957 --> 00:07:39.359 align:middle
在顶部显示的是C类型

00:07:39.560 --> 00:07:43.297 align:middle
它透明的进入Swift
C函数指针类型

00:07:43.630 --> 00:07:46.733 align:middle
你可以把它传过来
但是不能再做更多的东西了

00:07:47.768 --> 00:07:50.971 align:middle
Swift 2.0中我们只是增加了
标识为convention-C

00:07:51.104 --> 00:07:53.607 align:middle
标识为
convention-C的闭包

00:07:54.007 --> 00:07:55.609 align:middle
你能在Swift中创建传递它们

00:07:55.676 --> 00:07:57.678 align:middle
甚至是调用它们

00:07:58.111 --> 00:08:00.214 align:middle
这意味着你可以在Swift中

00:07:58.111 --> 00:08:00.214 align:middle
这意味着你可以在Swift中

00:08:00.514 --> 00:08:02.382 align:middle
访问全部的C APIs

00:08:02.482 --> 00:08:03.617 align:middle
以前你可不行

00:08:11.158 --> 00:08:14.494 align:middle
所以我们做了
两件小事以提升Swift

00:08:14.561 --> 00:08:17.464 align:middle
C和Objective-C
之间的桥接能力

00:08:18.465 --> 00:08:20.634 align:middle
但是今年我们还有非常重要的新特性

00:08:20.701 --> 00:08:22.202 align:middle
在语言桥接方面

00:08:22.269 --> 00:08:23.370 align:middle
具有非常巨大的影响

00:08:24.571 --> 00:08:26.673 align:middle
最重要的当然是错误处理

00:08:28.175 --> 00:08:29.443 align:middle
如果你还没听说过

00:08:29.510 --> 00:08:33.280 align:middle
错误处理模型我们准备了很多

00:08:33.347 --> 00:08:37.384 align:middle
关于Cocoa的NSError
样式和规则的课程

00:08:37.451 --> 00:08:39.152 align:middle
以及围绕这些话题的约定

00:08:39.753 --> 00:08:41.421 align:middle
并分享我们从建立这样一个新特性

00:08:41.688 --> 00:08:43.090 align:middle
中学到的知识

00:08:43.190 --> 00:08:45.259 align:middle
这个新特性用
“throws“关键字表示

00:08:46.093 --> 00:08:48.362 align:middle
这会覆盖今天上午课程的许多内容

00:08:48.428 --> 00:08:49.763 align:middle
“有什么新Swift”

00:08:50.130 --> 00:08:53.267 align:middle
如果你还没有使用它

00:08:53.500 --> 00:08:55.569 align:middle
我强烈的建议你以后试试

00:08:55.636 --> 00:08:58.605 align:middle
看看错误处理机制是如何工作的

00:09:00.140 --> 00:09:04.211 align:middle
但是我重点要讲的是它在两种语言

00:09:04.278 --> 00:09:05.879 align:middle
混编时的应用

00:09:06.513 --> 00:09:11.151 align:middle
你要明白这并不是仅仅从
Objective-C映射到Swift

00:09:11.585 --> 00:09:15.756 align:middle
这也是Swift类库
如何暴露给Objective-C

00:09:16.423 --> 00:09:18.292 align:middle
这是双向映射

00:09:20.060 --> 00:09:22.329 align:middle
让我们仔细看看这里的返回类型

00:09:23.063 --> 00:09:26.233 align:middle
在Objective-C中错误约定为

00:09:26.466 --> 00:09:30.838 align:middle
返回无效值视为发生错误

00:09:31.338 --> 00:09:33.774 align:middle
当填写“out error“参数时

00:09:33.841 --> 00:09:34.842 align:middle
会这样

00:09:36.043 --> 00:09:38.512 align:middle
然而在Swift中这完全
包含在错误处理模型中了

00:09:38.579 --> 00:09:41.648 align:middle
所以在Swift返回类型中你会看到

00:09:41.715 --> 00:09:45.018 align:middle
非选择性的对象类型

00:09:46.720 --> 00:09:50.591 align:middle
相似的在Objective-C
当没有事务被视为失败事务时

00:09:51.058 --> 00:09:53.293 align:middle
你将得到一个布尔返回值

00:09:53.527 --> 00:09:56.730 align:middle
同样的在Swift的错误处理中也有

00:09:56.997 --> 00:09:59.399 align:middle
你将得到一个void返回类型

00:10:01.134 --> 00:10:03.904 align:middle
现在在这些
Objective-C的例子中

00:10:03.971 --> 00:10:06.106 align:middle
既有多参数的

00:10:06.173 --> 00:10:07.941 align:middle
也有只有一个错误参数的

00:10:08.509 --> 00:10:11.044 align:middle
但是还有一些case中的
方法只有一个参数

00:10:11.245 --> 00:10:12.412 align:middle
你将得到像

00:10:12.846 --> 00:10:15.415 align:middle
“请检查资源可查到并返回错误”
这样的提示

00:10:16.216 --> 00:10:18.752 align:middle
在Swift中如你所见
既然我们已经知道

00:10:18.819 --> 00:10:20.387 align:middle
使用“throws”关键字

00:10:20.687 --> 00:10:22.055 align:middle
方法可以返回错误

00:10:22.322 --> 00:10:24.024 align:middle
我们将砍下最后三个单词

00:10:24.091 --> 00:10:25.459 align:middle
只为你!!!

00:10:27.761 --> 00:10:30.731 align:middle
现在所有的都会有的

00:10:30.797 --> 00:10:33.600 align:middle
当你使用
NSError-star-star类型

00:10:33.967 --> 00:10:35.802 align:middle
当你真正的使用NSError约定

00:10:35.869 --> 00:10:37.704 align:middle
的基本格式

00:10:38.105 --> 00:10:39.406 align:middle
其它情况下会发生什么？

00:10:39.973 --> 00:10:42.276 align:middle
我们只是让事情保持像这样

00:10:42.643 --> 00:10:45.546 align:middle
在Objective-C如果你有
NSError参数通常

00:10:45.612 --> 00:10:48.315 align:middle
它会以可选的NSError
参数出现在Swift中

00:10:48.615 --> 00:10:50.350 align:middle
你为正在使用的任何API

00:10:50.517 --> 00:10:52.085 align:middle
来恰当的处理它

00:10:53.153 --> 00:10:56.990 align:middle
记住NSError参数符合
Swift错误类型协议

00:10:57.291 --> 00:11:00.761 align:middle
所以你也可以用Swift自己的
处理机制使用NSError参数

00:10:57.291 --> 00:11:00.761 align:middle
所以你也可以用Swift自己的
处理机制使用NSError参数

00:11:02.696 --> 00:11:05.132 align:middle
这些都显示Swift已经准备好处理

00:11:05.499 --> 00:11:08.035 align:middle
所有来自Objective-C的报错

00:11:09.303 --> 00:11:12.072 align:middle
但是如果我从
Objective-C调用一个方法

00:11:12.840 --> 00:11:15.943 align:middle
并且它是一个Swift方法
产生的Swift错误呢

00:11:18.245 --> 00:11:19.680 align:middle
现在当然了我们需要这个

00:11:19.913 --> 00:11:21.315 align:middle
然我们看看它的原理

00:11:22.783 --> 00:11:24.952 align:middle
这里我有一个名为“请求错误”
的错误类型

00:11:25.419 --> 00:11:28.422 align:middle
它是一个用Swift的错误
系统定义的新类型

00:11:28.622 --> 00:11:31.625 align:middle
它符合错误类型协议在这个案例中

00:11:31.758 --> 00:11:35.529 align:middle
它是一个枚举只有一种可能性

00:11:36.864 --> 00:11:39.466 align:middle
在方法中使用这个错误很容易

00:11:40.100 --> 00:11:42.269 align:middle
我再定义一个“发送请求”方法

00:11:42.569 --> 00:11:44.304 align:middle
用“throws”关键字标识它表示

00:11:44.805 --> 00:11:48.408 align:middle
它可以失败然后当我触发失败条件时

00:11:48.475 --> 00:11:50.911 align:middle
实际调用了“throw”

00:11:52.679 --> 00:11:55.015 align:middle
现在我要在
Objective-C调用这个方法

00:11:55.249 --> 00:11:56.416 align:middle
它应该能行

00:11:56.850 --> 00:11:58.085 align:middle
怎么样

00:12:00.187 --> 00:12:02.055 align:middle
首先是方法的名字

00:12:02.122 --> 00:12:03.423 align:middle
发生了变化

00:12:03.757 --> 00:12:05.292 align:middle
不再只是“发送请求

00:12:05.526 --> 00:12:07.694 align:middle
现在是发送请求错误”了

00:12:08.428 --> 00:12:09.596 align:middle
就是你将使用的名称

00:12:09.663 --> 00:12:12.699 align:middle
前提是你的Objective-C
代码从“发送请求这个方法开始

00:12:13.333 --> 00:12:17.104 align:middle
另外在此基础上我们刚刚使用了

00:12:17.171 --> 00:12:19.840 align:middle
plain-old NSError
类型以及我们在Swift

00:12:19.907 --> 00:12:21.308 align:middle
中产生的错误

00:12:22.776 --> 00:12:26.813 align:middle
除此之外错误类型确实包括有用的信息

00:12:27.147 --> 00:12:30.117 align:middle
如果我们输出带着这个错误的域和代码

00:12:30.584 --> 00:12:33.754 align:middle
我们将会知道它原来是类型

00:12:33.820 --> 00:12:36.089 align:middle
以及我们以前看到的
enum类型的原始值

00:12:38.458 --> 00:12:40.460 align:middle
现在这里将会有一个
更加有趣的事情发生

00:12:41.028 --> 00:12:43.797 align:middle
我用ObjC 属性去标记
enum类型的数据

00:12:44.264 --> 00:12:46.934 align:middle
这是我们添加在
Xcode 6.3的一个功能

00:12:47.267 --> 00:12:50.003 align:middle
如果你在enum上用
ObjC 属性标记

00:12:50.504 --> 00:12:53.006 align:middle
然后它就会输出到你所产生的头文件上

00:12:53.607 --> 00:12:57.611 align:middle
这个头文件暴露了swift类的
Objective-C的一面

00:12:59.580 --> 00:13:01.882 align:middle
在Xcode...抱歉
在Xcode 7中

00:12:59.580 --> 00:13:01.882 align:middle
在Xcode...抱歉
在Xcode 7中

00:13:02.182 --> 00:13:04.218 align:middle
我们已经添加了一个更有趣的
小功能在这儿

00:13:04.651 --> 00:13:07.521 align:middle
这是一个包含错误类型协议的enum

00:13:08.121 --> 00:13:12.392 align:middle
因此我们也将会产生一个字符串常量
去表示错误域

00:13:14.695 --> 00:13:17.598 align:middle
现在所有比较的大的
错误都已经被你在swift中标定了

00:13:17.865 --> 00:13:19.900 align:middle
你可能想为自己的类去使用和运行这个

00:13:19.967 --> 00:13:23.136 align:middle
但是随后从 Cocoa

00:13:23.203 --> 00:13:25.839 align:middle
回到其余的SDKs

00:13:25.973 --> 00:13:27.140 align:middle
感到不足的错误

00:13:28.108 --> 00:13:30.444 align:middle
但是别担心我们将会全力帮助你的

00:13:31.345 --> 00:13:33.080 align:middle
因此如果你出席今天早些时候的演示

00:13:33.146 --> 00:13:35.082 align:middle
你可能已经见过这种

00:13:35.482 --> 00:13:38.185 align:middle
检查资源的可达性

00:13:38.418 --> 00:13:40.587 align:middle
并且捕捉不同错误情况的预检措施

00:13:41.154 --> 00:13:43.090 align:middle
现在错误的类型之一

00:13:43.156 --> 00:13:46.293 align:middle
已经被列为
“NSURLError文件不存在”

00:13:47.127 --> 00:13:49.096 align:middle
那是一个来自Cocoa的错误

00:13:49.696 --> 00:13:52.199 align:middle
为什么要使用快速符号去显示？

00:13:53.367 --> 00:13:56.136 align:middle
好了我们已经在整个SDKS中
使用了最常见的错误类型

00:13:56.203 --> 00:13:58.872 align:middle
这样可以让你利用

00:13:58.939 --> 00:14:00.941 align:middle
Swift自己的捕捉语法去使用它们

00:13:58.939 --> 00:14:00.941 align:middle
Swift自己的捕捉语法去使用它们

00:14:01.508 --> 00:14:03.544 align:middle
因此在这儿你可以使用各种各样的错误

00:14:03.911 --> 00:14:05.946 align:middle
你应当远离的通常的想法就是

00:14:06.380 --> 00:14:10.017 align:middle
当你在使用Objective-C中的时候
错误就应该会就像NSError

00:14:10.350 --> 00:14:13.187 align:middle
而当你在使用swift的时候
它们也就应该想swift的错误

00:14:13.253 --> 00:14:14.221 align:middle
事情应该只是工作

00:14:16.056 --> 00:14:18.559 align:middle
因此这只是在过去的一年中

00:14:18.659 --> 00:14:21.461 align:middle
我们在互操作性所做的一些改进

00:14:21.995 --> 00:14:24.965 align:middle
所以说到我们在Objective-C
方面所做到的改进

00:14:25.265 --> 00:14:26.533 align:middle
我想把它交给 道格

00:14:34.308 --> 00:14:35.142 align:middle
谢谢你 约旦

00:14:36.076 --> 00:14:37.678 align:middle
那么今天我们将会讨论

00:14:37.978 --> 00:14:40.848 align:middle
我们这一年添加在
Objective-C方面的三个特性

00:14:41.715 --> 00:14:42.583 align:middle
这些特性能够让你

00:14:42.649 --> 00:14:44.384 align:middle
更好的使用
Objective-C去编程

00:14:44.451 --> 00:14:46.053 align:middle
能够让Objective-C
APIs更加的优秀

00:14:46.119 --> 00:14:47.754 align:middle
让他们更好的映入到swift中

00:14:47.921 --> 00:14:50.724 align:middle
同时提高你在使用
Objective-C的静态类型的安全性

00:14:51.358 --> 00:14:52.759 align:middle
我们将要讨论的第一件事情就是

00:14:52.993 --> 00:14:55.028 align:middle
Objective-C的
nullability

00:14:55.929 --> 00:14:58.732 align:middle
来观察一段
Objective-C的代码

00:14:59.700 --> 00:15:00.601 align:middle
有很多的指针

00:14:59.700 --> 00:15:00.601 align:middle
有很多的指针

00:15:01.301 --> 00:15:02.736 align:middle
这里面哪一个可以是零？

00:15:04.304 --> 00:15:05.372 align:middle
代码不会告诉你

00:15:06.473 --> 00:15:07.941 align:middle
如果你继续去阅读文档

00:15:08.108 --> 00:15:10.711 align:middle
如果你今天幸运的话
它今天可能会告诉你

00:15:11.945 --> 00:15:13.380 align:middle
你应当去写一些测试

00:15:13.447 --> 00:15:16.683 align:middle
看看它可能的表现的
行为或者可能的猜测

00:15:16.750 --> 00:15:18.185 align:middle
但是那并不是一个好的方法

00:15:18.252 --> 00:15:19.786 align:middle
在这些地方可能会缺少一些信息

00:15:20.687 --> 00:15:22.322 align:middle
当我们去年推出swift的时候

00:15:22.656 --> 00:15:25.592 align:middle
在这些实质上意味着我们不知道的

00:15:26.260 --> 00:15:28.562 align:middle
默认打开的选项中

00:15:29.263 --> 00:15:30.797 align:middle
信息的缺乏表现的更加的明显

00:15:30.864 --> 00:15:32.332 align:middle
在swift的一面它可能是零

00:15:34.101 --> 00:15:35.469 align:middle
所以我们并没有感到太高兴

00:15:35.969 --> 00:15:39.173 align:middle
在发布Swift 1.0之后

00:15:39.373 --> 00:15:41.975 align:middle
我们在自己的核心框架内

00:15:42.042 --> 00:15:46.380 align:middle
编写了成千的指针

00:15:46.747 --> 00:15:48.482 align:middle
去告诉那些指针可能为零的编译器

00:15:48.916 --> 00:15:51.718 align:middle
经过编辑之后的接口变得更加的简洁

00:15:52.352 --> 00:15:54.888 align:middle
现在我们使用可选择的类型

00:15:54.988 --> 00:15:57.291 align:middle
零是你确实必须处理的一件事情

00:15:58.091 --> 00:15:59.526 align:middle
其它的一切都是不可选择的

00:16:01.228 --> 00:16:02.596 align:middle
这仍然不是那样的美好

00:16:02.663 --> 00:16:04.531 align:middle
因为这些知识被编译成编译器

00:16:04.598 --> 00:16:06.200 align:middle
这不是你所能完成的事情

00:16:07.034 --> 00:16:11.605 align:middle
所以对Xcode 6.3来说我们为
Objective-C引入了可空限定符

00:16:13.040 --> 00:16:15.209 align:middle
所以你可以把可空限定符

00:16:15.442 --> 00:16:17.477 align:middle
添加到C/Objective-C
的指针中

00:16:17.578 --> 00:16:19.446 align:middle
去描述是否可以接受零状态

00:16:20.514 --> 00:16:22.416 align:middle
当然你的应用程序

00:16:22.783 --> 00:16:24.418 align:middle
确实可以做更好的通讯

00:16:24.484 --> 00:16:25.586 align:middle
它接受零么？

00:16:25.652 --> 00:16:26.854 align:middle
这说的通么？

00:16:27.688 --> 00:16:29.890 align:middle
它能够帮助我们的工具

00:16:29.957 --> 00:16:32.259 align:middle
做出更好的静态检查去
捕捉运行时表现出来的bug

00:16:32.826 --> 00:16:35.429 align:middle
它能够在你的
Objective-C APIs中

00:16:35.662 --> 00:16:37.064 align:middle
让你的swift表现的更好

00:16:39.499 --> 00:16:41.602 align:middle
现在这儿有三个可空限定符

00:16:42.503 --> 00:16:45.205 align:middle
Nullable
这表明可能是空的指针

00:16:46.373 --> 00:16:48.342 align:middle
这个当然映射到一个Swift选项中

00:16:49.510 --> 00:16:50.477 align:middle
然后那儿有一个非零

00:16:50.811 --> 00:16:55.549 align:middle
这就表明零并不是一个有意义的值

00:16:57.317 --> 00:16:59.887 align:middle
现在对于一个非零指针来说

00:17:00.521 --> 00:17:02.055 align:middle
它可能最终在Objective-C
程序中最终变成0

00:17:02.122 --> 00:17:04.992 align:middle
可能它就是因为某些时候
我们在传递0的时候

00:17:05.058 --> 00:17:06.292 align:middle
零通过传递

00:17:07.160 --> 00:17:08.694 align:middle
而这个时候已经开始运行过了

00:17:08.996 --> 00:17:11.365 align:middle
编译器并不会因为非空的注释

00:17:11.531 --> 00:17:13.233 align:middle
改变它生成代码的方式

00:17:13.567 --> 00:17:16.136 align:middle
这就表明了应用程序作者的意图就是

00:17:16.203 --> 00:17:17.771 align:middle
零在这儿不合情理

00:17:19.573 --> 00:17:23.010 align:middle
我们也有三分之一的
null-unspecified限定符

00:17:23.877 --> 00:17:28.015 align:middle
这在无论是nullable还是
非零的情况下实际上都是正确的事情

00:17:28.549 --> 00:17:30.117 align:middle
如果我们对于指针一无所知

00:17:30.417 --> 00:17:32.786 align:middle
我们把这些映射到
那些你就可能会得到的

00:17:32.920 --> 00:17:34.855 align:middle
相同的默认打开的选项中

00:17:36.790 --> 00:17:38.492 align:middle
关于可空限定符
最重要的事情就是

00:17:38.559 --> 00:17:42.062 align:middle
我们已经在我们整个SDKs去推出了

00:17:43.363 --> 00:17:45.832 align:middle
好 所以不是
单纯的覆盖几个核心框架

00:17:45.899 --> 00:17:48.302 align:middle
我们已经覆盖了 SDKs的绝大部分

00:17:48.802 --> 00:17:51.738 align:middle
所以这给出了一个非常好的

00:17:51.905 --> 00:17:54.241 align:middle
在其他地方都有关系和
non-optionals

00:17:54.308 --> 00:17:56.210 align:middle
正确optionals的
swift经验

00:17:56.944 --> 00:17:59.213 align:middle
对于你的
Objective-C代码来说

00:17:59.279 --> 00:18:01.048 align:middle
这意味着你已经开始看到

00:17:59.279 --> 00:18:01.048 align:middle
这意味着你已经开始看到

00:18:01.114 --> 00:18:02.916 align:middle
已经被误用的APIs的新的警告

00:18:03.584 --> 00:18:09.323 align:middle
因此 比如你看到一个你已经把
零传送到你并不期望的路径的警告

00:18:09.389 --> 00:18:11.091 align:middle
这不是应用程序协议的一部分

00:18:12.125 --> 00:18:14.528 align:middle
现在可能传递过一个以前运行过的零

00:18:14.962 --> 00:18:16.330 align:middle
它可能会继续工作

00:18:16.830 --> 00:18:18.165 align:middle
但是你应当注意这些警告

00:18:18.232 --> 00:18:20.234 align:middle
因为这些应用程序的作者已经告诉过你

00:18:20.334 --> 00:18:22.636 align:middle
你不应当在这儿传递零这里必须要小心

00:18:22.703 --> 00:18:24.171 align:middle
因为它将来可能会改变

00:18:26.540 --> 00:18:29.877 align:middle
现在,比方说你想添加
可空限定符到你的头文件中去

00:18:30.210 --> 00:18:33.080 align:middle
这个开始的地方就是被编辑的区域

00:18:33.647 --> 00:18:36.483 align:middle
因此这些将会被“NS-assume
non-null begin”

00:18:36.550 --> 00:18:37.885 align:middle
所描述
NS-假设非空结束

00:18:38.519 --> 00:18:41.121 align:middle
包括你用的这些宏的头文件

00:18:42.122 --> 00:18:44.057 align:middle
这样做就是允许编译器

00:18:44.124 --> 00:18:46.860 align:middle
对未注明的指针

00:18:46.927 --> 00:18:48.529 align:middle
去采用默认的假设

00:18:49.263 --> 00:18:51.665 align:middle
所以如果你有一个单级指针

00:18:51.732 --> 00:18:54.468 align:middle
那么将会被假定为非空
因为我们发现

00:18:54.535 --> 00:18:57.738 align:middle
对于我们绝大多数的APIs来说
零并不是一个有意义的值

00:18:59.573 --> 00:19:01.475 align:middle
另一个有趣的特殊情况下就是

00:18:59.573 --> 00:19:01.475 align:middle
另一个有趣的特殊情况下就是

00:19:01.542 --> 00:19:03.177 align:middle
这里是一个
NSError-star-star

00:19:03.243 --> 00:19:06.213 align:middle
参数当你在对Objective-C
的错误进行处理的时候

00:19:06.446 --> 00:19:08.448 align:middle
这些可以在两个级别上被认为是空的

00:19:08.515 --> 00:19:11.285 align:middle
因为这是你和他们为空性工作的方式

00:19:12.719 --> 00:19:15.022 align:middle
现在默认是良好的
他们应该承担大部分的情况下

00:19:15.556 --> 00:19:18.292 align:middle
但是这就意味着
你必须去注释异常的情况

00:19:18.759 --> 00:19:22.029 align:middle
所以我们把这些超视图的
属性标记为nullable

00:19:22.429 --> 00:19:24.698 align:middle
当然不是每个视图都有一个超视图

00:19:24.831 --> 00:19:25.799 align:middle
零在这儿是有意义的

00:19:27.067 --> 00:19:29.536 align:middle
冲击测试的时间有个可空参数

00:19:30.170 --> 00:19:32.573 align:middle
你不需要通过一个事件去做冲击测试

00:19:32.873 --> 00:19:34.274 align:middle
当然结果是可空

00:19:34.641 --> 00:19:36.443 align:middle
因为零在这个地方是有意义的

00:19:36.510 --> 00:19:37.978 align:middle
这意味着我们没有击中任何东西

00:19:40.080 --> 00:19:42.716 align:middle
现在这就是null-unspecified
出现的地方

00:19:43.050 --> 00:19:44.318 align:middle
说你正在编辑一个头文件

00:19:45.419 --> 00:19:50.524 align:middle
你将会遇见一些
一直都存在的很奇怪的事情

00:19:50.891 --> 00:19:52.659 align:middle
你不知道它

00:19:53.193 --> 00:19:54.628 align:middle
它没有被记录下来

00:19:55.195 --> 00:19:57.798 align:middle
可能它正在做一些特别有趣的事情

00:19:57.865 --> 00:20:00.300 align:middle
这些事情传递着可能会或者不会工作

00:19:57.865 --> 00:20:00.300 align:middle
这些事情传递着可能会或者不会工作

00:20:00.367 --> 00:20:02.236 align:middle
它五年之前退役时才能回答的零

00:20:03.737 --> 00:20:05.372 align:middle
仍然有使用空未指明的很大空间

00:20:06.039 --> 00:20:07.641 align:middle
只是要把它标记成空未指明

00:20:07.841 --> 00:20:11.545 align:middle
这就意味着“我考虑过这个问题
但是我没有得出答案”

00:20:11.879 --> 00:20:15.949 align:middle
最好的事情就是在swift中
保持它默认未开的选择

00:20:17.451 --> 00:20:18.685 align:middle
保持它是空未指明的

00:20:18.919 --> 00:20:20.254 align:middle
你可以稍后再回来

00:20:20.487 --> 00:20:21.788 align:middle
所以当编辑的时候吗你确实像

00:20:22.055 --> 00:20:23.624 align:middle
更早的得到一些好的广度

00:20:23.857 --> 00:20:26.426 align:middle
去让你的 APIs 更好更快

00:20:28.662 --> 00:20:31.698 align:middle
现在 当你去到C

00:20:31.965 --> 00:20:33.734 align:middle
事情就会变得有点模糊

00:20:34.501 --> 00:20:36.837 align:middle
所以我们有了所有相同限定符

00:20:36.904 --> 00:20:38.639 align:middle
但是他们之前需要下划线

00:20:39.840 --> 00:20:42.843 align:middle
现在这些双下划线的关键字这些限定符

00:20:42.910 --> 00:20:45.179 align:middle
可以被用于任何地方任何指针

00:20:45.746 --> 00:20:50.551 align:middle
这个地方有个重要的规则就是

00:20:51.318 --> 00:20:54.188 align:middle
限定符适用于右指针

00:20:54.254 --> 00:20:56.857 align:middle
constor或者volatile
将会去应用那个指针

00:20:57.758 --> 00:21:00.827 align:middle
这对于这样的
参数外指针是nullable的

00:20:57.758 --> 00:21:00.827 align:middle
这对于这样的
参数外指针是nullable的

00:21:00.961 --> 00:21:02.796 align:middle
参数外指针值是nullable的

00:21:03.363 --> 00:21:05.999 align:middle
多级指针是非常重要的

00:21:06.767 --> 00:21:10.437 align:middle
因为只要参数num的值也是
零你就可以在这个参数中传递零

00:21:12.606 --> 00:21:15.876 align:middle
内部指针是空的因为当你传递数组时

00:21:15.943 --> 00:21:19.847 align:middle
所有的使用CF数组的值

00:21:19.913 --> 00:21:21.081 align:middle
都必须是非空的

00:21:25.118 --> 00:21:26.653 align:middle
这就是我们要讲的关于可空的东西

00:21:27.421 --> 00:21:29.389 align:middle
今年我们已经把它推送到
我们的 SDKs 中

00:21:29.456 --> 00:21:30.757 align:middle
所以你能够在

00:21:30.824 --> 00:21:32.960 align:middle
在Objective-C 和
Swift中获得更好的体验

00:21:33.260 --> 00:21:35.329 align:middle
我们强烈的推荐你使用它

00:21:35.395 --> 00:21:37.865 align:middle
去提高你自己的
Objective-C APIs

00:21:37.931 --> 00:21:40.067 align:middle
特别是为了一个更好的
Swift 体验

00:21:42.336 --> 00:21:44.271 align:middle
好了 让我们开始下一个特性

00:21:44.671 --> 00:21:45.506 align:middle
这是一个大的

00:21:47.608 --> 00:21:49.543 align:middle
对于Objective-C来说
是一个重量级的泛型

00:21:51.044 --> 00:21:52.479 align:middle
现在这个特性的原型

00:21:52.713 --> 00:21:54.581 align:middle
它其实是相当容易去激励的

00:21:55.015 --> 00:21:55.849 align:middle
集合

00:21:57.050 --> 00:21:59.686 align:middle
这里我们有
subviews的NSArray

00:22:01.555 --> 00:22:02.422 align:middle
数组中的是什么？

00:22:03.257 --> 00:22:04.625 align:middle
我们不说在数组中的东西

00:22:05.058 --> 00:22:07.561 align:middle
我们把这个拿入到 Swift中你说

00:22:07.761 --> 00:22:09.463 align:middle
嗯 这是任何对象的数组

00:22:09.563 --> 00:22:11.465 align:middle
它仍然没有告诉我任何事情

00:22:13.600 --> 00:22:15.269 align:middle
我已经投了很多 那就是他告诉我的

00:22:15.903 --> 00:22:19.873 align:middle
当然我们有这种常见的

00:22:19.940 --> 00:22:21.475 align:middle
请求类型的集合

00:22:22.242 --> 00:22:25.112 align:middle
因为人们总是说想说
我有一个数组的观点

00:22:25.479 --> 00:22:27.347 align:middle
我有一个从字符串关键字映射到

00:22:27.414 --> 00:22:29.583 align:middle
与图片相关的关键字的字典

00:22:30.551 --> 00:22:32.986 align:middle
这可能是过去十年当中

00:22:33.053 --> 00:22:34.988 align:middle
要求最高的
Objective-C特性

00:22:35.756 --> 00:22:37.691 align:middle
所以现在我们最终推出

00:22:38.125 --> 00:22:39.826 align:middle
重量级泛型的Objective-C

00:22:40.327 --> 00:22:42.663 align:middle
所以这是一个可以改善
你的APIs的表达性

00:22:42.729 --> 00:22:44.965 align:middle
的一个最通用的语言特性

00:22:45.799 --> 00:22:48.769 align:middle
这让集合的方式更容易去使用

00:22:48.836 --> 00:22:51.972 align:middle
现在我们有了所有静态安全集合类型

00:22:53.607 --> 00:22:54.474 align:middle
让我们看一看

00:22:55.542 --> 00:22:57.344 align:middle
所以这是我们的
subviews的属性

00:22:58.545 --> 00:23:00.581 align:middle
这是一组UI视图

00:22:58.545 --> 00:23:00.581 align:middle
这是一组UI视图

00:23:01.081 --> 00:23:04.885 align:middle
我们只是把UI-view-star
UIV指针放置在尖括号中

00:23:05.219 --> 00:23:07.454 align:middle
相同的语法你已经看到过了
哎哟 抱歉

00:23:15.262 --> 00:23:17.998 align:middle
相同的语法你
可能从swift和C++

00:23:18.065 --> 00:23:20.601 align:middle
或者C-Sharp等语言当中看到过

00:23:20.801 --> 00:23:21.969 align:middle
是的 我们完全清楚

00:23:22.035 --> 00:23:24.071 align:middle
尖角括号是引用协议限定符

00:23:24.271 --> 00:23:25.305 align:middle
别担心 我们知道这一点

00:23:28.709 --> 00:23:31.945 align:middle
所以这就向 Object-C 中
引入了更多的类型信息

00:23:32.346 --> 00:23:33.981 align:middle
当然这一点反映到Swift中

00:23:34.047 --> 00:23:36.049 align:middle
就有了更多优雅的类型信息

00:23:36.383 --> 00:23:38.485 align:middle
但我真正想谈谈
其对Objective-C的影响

00:23:38.585 --> 00:23:41.288 align:middle
因为这一功能对于
Objective-C来讲确实有用

00:23:41.755 --> 00:23:43.690 align:middle
现在我们来谈谈类型安全

00:23:46.059 --> 00:23:46.894 align:middle
下面是一个例子

00:23:47.361 --> 00:23:50.998 align:middle
所以我要取得任何一个
URL 或 NSURL 的路径组件

00:23:51.064 --> 00:23:53.166 align:middle
然后将其放入
进入一个阵列的 URLs 之中

00:23:54.034 --> 00:23:56.904 align:middle
如果我不知道这个应用编程接口
这种做法看起来就近乎是合理的

00:23:57.404 --> 00:23:59.773 align:middle
而且要等一段时间我才能
得到运行错误的信息

00:23:59.840 --> 00:24:02.109 align:middle
一个无法确认的选择器会指出不对

00:23:59.840 --> 00:24:02.109 align:middle
一个无法确认的选择器会指出不对

00:24:02.176 --> 00:24:04.645 align:middle
我在使用路径组件的方式上
犯了一个很大的错误

00:24:05.412 --> 00:24:07.147 align:middle
有了类型集合体并且 当然

00:24:07.214 --> 00:24:09.816 align:middle
我们在我们的整个软件开发包中
推出了很多类型集合体

00:24:10.384 --> 00:24:12.686 align:middle
现在你就会及时得到一个警告
在错误发生时

00:24:13.020 --> 00:24:14.288 align:middle
告诉你到底你做错了什么

00:24:16.490 --> 00:24:19.726 align:middle
还有许多其他情况比如说
我要建立一个 NS 字符串组成的

00:24:19.860 --> 00:24:24.498 align:middle
不可变阵列可我傻傻地又要
往那个阵列中加个东西

00:24:24.731 --> 00:24:26.667 align:middle
却没有先把它变成一个字符串

00:24:27.768 --> 00:24:29.770 align:middle
编译器将会告诉我不对

00:24:29.837 --> 00:24:31.338 align:middle
你不能把一个 NSNumber

00:24:31.405 --> 00:24:33.073 align:middle
放到这个 NS 可变字符串阵列中

00:24:33.340 --> 00:24:34.474 align:middle
这不合理

00:24:36.210 --> 00:24:38.579 align:middle
实际上编译器
对于此处与 Cocoa 集合体有关

00:24:39.079 --> 00:24:42.216 align:middle
的语义有着相当深入的了解

00:24:42.983 --> 00:24:46.320 align:middle
现在我们看看这里的例子
我们有一个视图阵列

00:24:46.954 --> 00:24:48.155 align:middle
我们还有一个应答阵列

00:24:48.222 --> 00:24:50.757 align:middle
我们将视图阵列中的元素
一个个分配到应答阵列中

00:24:51.758 --> 00:24:54.261 align:middle
没有问题 因为每个视图也是一个应答

00:24:54.328 --> 00:24:55.262 align:middle
看起来挺好

00:24:55.863 --> 00:24:56.697 align:middle
没有问题

00:24:58.265 --> 00:25:00.901 align:middle
让我们用一个可变的变式
来做同样的事情

00:24:58.265 --> 00:25:00.901 align:middle
让我们用一个可变的变式
来做同样的事情

00:25:02.336 --> 00:25:04.872 align:middle
所以我们用那个存储的可变
视图阵列将其元素分配给

00:25:05.706 --> 00:25:09.443 align:middle
存储的可变应答阵列

00:25:11.144 --> 00:25:11.979 align:middle
这里有个陷阱

00:25:12.679 --> 00:25:14.147 align:middle
这个陷阱是 当然 我可以对

00:25:14.214 --> 00:25:17.050 align:middle
我所存储的应答进行转换

00:25:17.518 --> 00:25:20.320 align:middle
在其中放一些不是视图的应答元素

00:25:21.822 --> 00:25:24.391 align:middle
这样对之后的某个过程
事情就会变得非常混乱

00:25:24.491 --> 00:25:26.159 align:middle
那个它正在查看的视图阵列

00:25:26.793 --> 00:25:28.562 align:middle
中有个一个视图控制器元素不是视图

00:25:29.930 --> 00:25:31.331 align:middle
编译器也了解这一点

00:25:31.532 --> 00:25:33.934 align:middle
它会在程序初始化时抱怨在这里

00:25:34.201 --> 00:25:37.137 align:middle
虽然用不可变阵列来完成这一任务

00:25:37.371 --> 00:25:40.774 align:middle
很安全因为他们不会

00:25:40.874 --> 00:25:43.210 align:middle
在你不注意时改变可用其变体可变阵列

00:25:43.310 --> 00:25:44.344 align:middle
来做这些就不安全

00:25:46.380 --> 00:25:49.016 align:middle
好你其实已经亲眼见过你需要的一切

00:25:49.316 --> 00:25:50.951 align:middle
使你能够在你的整个应用程序中

00:25:51.018 --> 00:25:53.120 align:middle
使用轻量泛型且类型化的集合体

00:25:53.520 --> 00:25:55.789 align:middle
但是现在来看看
我们怎样在Foundation 中

00:25:55.856 --> 00:25:57.257 align:middle
使用这一方法

00:25:58.458 --> 00:26:00.360 align:middle
来实际上创造类型化的集合体

00:25:58.458 --> 00:26:00.360 align:middle
来实际上创造类型化的集合体

00:26:00.460 --> 00:26:02.229 align:middle
因为这里的该功能是泛型的

00:26:02.829 --> 00:26:04.431 align:middle
类型化的集合体是其结果之一

00:26:04.731 --> 00:26:07.201 align:middle
所以在这里我们有 NSArray
因为你习惯于见到它

00:26:08.435 --> 00:26:11.305 align:middle
现在我们要
基于存储在 NSArray 中的

00:26:12.472 --> 00:26:13.907 align:middle
对象的类型将其参数化

00:26:14.641 --> 00:26:15.976 align:middle
这次我们又要使用尖角括号

00:26:16.043 --> 00:26:17.377 align:middle
这里我们只是引入一个名字

00:26:18.045 --> 00:26:19.847 align:middle
这一名称 我们可以在整个界面上使用

00:26:20.147 --> 00:26:23.417 align:middle
当然索引处是对象
返回的也会是对象类型

00:26:24.117 --> 00:26:26.320 align:middle
如果我们在这里添加其他的方法

00:26:27.054 --> 00:26:29.389 align:middle
当你用一些对象来将你的阵列初始化

00:26:29.456 --> 00:26:32.025 align:middle
那个 C 阵列就会包含对象

00:26:32.960 --> 00:26:34.194 align:middle
通过添加对象来使用阵列

00:26:34.261 --> 00:26:36.897 align:middle
你放入一个新的对象
你获得一个NSArray阵列的对象

00:26:36.964 --> 00:26:38.465 align:middle
所以它的组造非常非常顺利

00:26:39.633 --> 00:26:42.436 align:middle
当然这也适用于类别和扩展

00:26:43.470 --> 00:26:46.340 align:middle
在这里我们有一个NSDictionary
类别以密匙类型和对象类型

00:26:46.406 --> 00:26:49.176 align:middle
进行参数化而且我们还在这里

00:26:49.243 --> 00:26:52.079 align:middle
使用对象类型替代密匙类型
在这里接受一个密钥类型

00:26:52.379 --> 00:26:55.349 align:middle
返回一个可以为 null
的对象类型 因为这里

00:26:55.582 --> 00:26:58.085 align:middle
当然空值是有意义的
因而我们要使我们的应用程序接口中

00:26:58.151 --> 00:26:59.052 align:middle
包含这一信息

00:27:00.521 --> 00:27:04.124 align:middle
现在当然还有一些
现有的在 NSDictionary

00:27:04.191 --> 00:27:07.694 align:middle
和NSArray等等基础上定义的
类别也许你自己就会有一些

00:27:08.095 --> 00:27:09.930 align:middle
那些会和过去一样可以继续使用

00:27:10.330 --> 00:27:12.966 align:middle
他们不能以任何方式访问类型参数

00:27:13.834 --> 00:27:15.969 align:middle
但他们也根本不会改变行为

00:27:16.036 --> 00:27:17.671 align:middle
他们将会像过去一样继续发挥作用

00:27:19.273 --> 00:27:22.042 align:middle
这使我想到了向后兼容性

00:27:23.410 --> 00:27:26.013 align:middle
所以整个轻量泛型功能都基于

00:27:26.079 --> 00:27:27.281 align:middle
一个类型擦除模式之上

00:27:27.681 --> 00:27:29.383 align:middle
这意味着编译器拥有全部这些

00:27:29.449 --> 00:27:31.985 align:middle
丰富的静态类型信息但当编译器要

00:27:32.052 --> 00:27:34.121 align:middle
生成代码时它就会清除这些信息

00:27:34.988 --> 00:27:37.291 align:middle
这对 Objective-C 来讲
有很大的好处

00:27:37.624 --> 00:27:39.893 align:middle
我们不需要对
Objective-C 的运行

00:27:39.960 --> 00:27:43.297 align:middle
进行任何更改就可实现这一功能

00:27:43.931 --> 00:27:46.099 align:middle
这意味着我们可以在类型集合体中

00:27:46.166 --> 00:27:48.335 align:middle
推出泛型你可以在你的所有
应用程序中采用之

00:27:48.402 --> 00:27:52.172 align:middle
这不会影响你将你的应用
部署回各种现有的

00:27:52.239 --> 00:27:54.274 align:middle
操作系统上的能力

00:28:03.050 --> 00:28:04.852 align:middle
这些从那个描述中看起来不太明显

00:28:04.918 --> 00:28:06.653 align:middle
当然我们也不会

00:28:06.987 --> 00:28:08.822 align:middle
以任何方式改变程序共同生成

00:28:08.889 --> 00:28:11.124 align:middle
我们不会在Objective-C中
添加运行中的检查

00:28:11.191 --> 00:28:13.293 align:middle
这种做法在
Objective-C中没有意义

00:28:13.861 --> 00:28:16.163 align:middle
我们只是要保持
完全的二进制码兼容性

00:28:16.230 --> 00:28:19.132 align:middle
因此采用此功能用好那些警告
因为他们能帮助你

00:28:19.199 --> 00:28:20.601 align:middle
避免犯下可怕的错误

00:28:23.403 --> 00:28:27.975 align:middle
你可以非常 非常 非常缓慢地采用之

00:28:28.509 --> 00:28:30.677 align:middle
我觉得这是最好的说法

00:28:31.512 --> 00:28:33.280 align:middle
所以除了二进制代码的兼容性之外

00:28:33.347 --> 00:28:35.282 align:middle
我们还要提供源代码的兼容性

00:28:35.616 --> 00:28:38.018 align:middle
因为我们是通过我们的
软件开发包来推出这些功能的

00:28:38.085 --> 00:28:40.687 align:middle
我们不想让你不得不
更新你所有的源代码

00:28:40.754 --> 00:28:42.356 align:middle
以便在各处都使用这一功能

00:28:42.656 --> 00:28:44.091 align:middle
我们希望你逐步采用它

00:28:44.191 --> 00:28:45.726 align:middle
哪里你觉得合理你就在那里使用它

00:28:46.059 --> 00:28:48.662 align:middle
因此我们在该语言中
提供这些隐式转换

00:28:49.029 --> 00:28:52.266 align:middle
使你可以添加类型参数或将其去除

00:28:54.168 --> 00:28:56.136 align:middle
好吗？另外这样做
不会带来任何运行成本

00:28:56.537 --> 00:28:59.506 align:middle
但在你需要时 它可以让你
进入和离开泛型系统

00:28:59.806 --> 00:29:01.842 align:middle
因此你所有的新代码都可以
用泛型来编写

00:28:59.806 --> 00:29:01.842 align:middle
因此你所有的新代码都可以
用泛型来编写

00:29:01.942 --> 00:29:03.477 align:middle
而且如果你不想要去碰你旧的代码

00:29:03.577 --> 00:29:05.379 align:middle
那完全没有问题这不会改变

00:29:07.514 --> 00:29:10.817 align:middle
好吧 我们还要谈谈最后的一个功能
这一功能比较酷

00:29:12.819 --> 00:29:14.454 align:middle
是这种的类型

00:29:17.224 --> 00:29:19.693 align:middle
实际上来自于我们
在轻量泛型方面所作的工作

00:29:20.360 --> 00:29:22.262 align:middle
于是我们起步之处当然是

00:29:22.930 --> 00:29:25.599 align:middle
将不具类型的集合体用于子视图

00:29:26.200 --> 00:29:28.869 align:middle
也有这样的代码先去抓取一个视图

00:29:28.936 --> 00:29:30.337 align:middle
之后向其发送一些信息

00:29:31.171 --> 00:29:32.940 align:middle
此代码是好的今天仍能运行

00:29:34.541 --> 00:29:37.010 align:middle
我们进行下一步做了这些注释说 好吧

00:29:37.077 --> 00:29:41.515 align:middle
子视图包含用户界面视图
所以我们被警告了

00:29:44.051 --> 00:29:45.886 align:middle
编译器完全有正当理由

00:29:45.953 --> 00:29:46.987 align:middle
来发出这一警告

00:29:48.088 --> 00:29:51.859 align:middle
它现在知道
第一个子视图是个用户界面视图

00:29:52.893 --> 00:29:56.463 align:middle
它不可能知道
你知道那是一个用户界面按钮

00:29:56.763 --> 00:29:58.432 align:middle
且会实际上对这一选择器做出反应

00:29:59.499 --> 00:30:02.970 align:middle
因此虽然编译器是正确的

00:29:59.499 --> 00:30:02.970 align:middle
因此虽然编译器是正确的

00:30:03.270 --> 00:30:05.072 align:middle
可对所有这些代码

00:30:05.439 --> 00:30:07.040 align:middle
发出警告并不一定有什么用处

00:30:07.107 --> 00:30:09.676 align:middle
你会得到大量的警告
其中大部分都是良性的

00:30:09.743 --> 00:30:11.545 align:middle
你会需要在各处使用各种转换

00:30:12.613 --> 00:30:14.681 align:middle
这真的迫使我们考虑 ID

00:30:14.848 --> 00:30:17.384 align:middle
以及如何将它作为
一个应用程序接口合同

00:30:18.752 --> 00:30:20.521 align:middle
所以我们在这方面举个小的简单的示例

00:30:20.587 --> 00:30:23.257 align:middle
让我们来谈谈 NSApp
这是 Cocoa 中的那个全球变量

00:30:23.323 --> 00:30:25.993 align:middle
使你能够访问
你的NSApplication实例

00:30:26.927 --> 00:30:32.799 align:middle
现在这真正的意味是NSApp
是NSApplication的

00:30:32.966 --> 00:30:34.034 align:middle
一个子类别

00:30:34.168 --> 00:30:35.903 align:middle
但我们无法向类型系统解释这一点

00:30:36.803 --> 00:30:40.574 align:middle
使用 kindof 类型我们可以
在Objective-C中准确表达这一点

00:30:43.043 --> 00:30:44.011 align:middle
这意味着什么？

00:30:44.945 --> 00:30:47.247 align:middle
这意味着NSApp是某种应用程序

00:30:47.581 --> 00:30:51.852 align:middle
所以我们要赋予它
一些有限的行为 如ID

00:30:53.353 --> 00:30:56.723 align:middle
所以我有了一个NSApp当然我可以
将它转换成一个 NSObject

00:30:56.924 --> 00:30:59.960 align:middle
因为每个NSApplication
都是一个 NSObject

00:31:00.460 --> 00:31:02.729 align:middle
在这里重要的部分
也就是类似 ID 的行为

00:31:02.996 --> 00:31:05.666 align:middle
是将 NSApplication
隐式向下转换成

00:31:06.133 --> 00:31:08.001 align:middle
你的
MyApplication子类别

00:31:09.102 --> 00:31:09.937 align:middle
这样好

00:31:10.003 --> 00:31:13.040 align:middle
我们想要这种行为模式是因为
这就是NSApp一直的工作模式

00:31:13.707 --> 00:31:16.310 align:middle
现在我们不会允许的
是一些愚蠢的交叉转换

00:31:16.410 --> 00:31:19.446 align:middle
您试过在一个字符串中
使用 NSApp 吗？

00:31:19.513 --> 00:31:22.049 align:middle
这不是一个NSApplication
且永远也不会是

00:31:22.249 --> 00:31:23.650 align:middle
所以你可以在那里提出一个警告

00:31:25.185 --> 00:31:27.354 align:middle
当然与此同来的是一种想法

00:31:27.421 --> 00:31:30.824 align:middle
你可以与NSApp交换信息 并
得到NSApplication中的

00:31:31.091 --> 00:31:33.927 align:middle
所有方法其各种超类别和其各种子类别

00:31:35.796 --> 00:31:37.731 align:middle
现在使用kindof类型
我们实际上发现

00:31:37.965 --> 00:31:39.366 align:middle
这比 ID 更有用的多

00:31:39.700 --> 00:31:43.537 align:middle
因为它会在应用程序接口合同中
给你更多的类型信息

00:31:44.104 --> 00:31:46.707 align:middle
这一点对 Swift 和
Objective-C来讲都很好

00:31:47.074 --> 00:31:49.343 align:middle
所以在这里我们有这个
NSTableView 方法

00:31:49.409 --> 00:31:51.311 align:middle
有列行和
makeIfNecessary

00:31:51.612 --> 00:31:52.746 align:middle
它总是返回到 ID

00:31:52.813 --> 00:31:54.648 align:middle
因为这一隐含的向下转换类型的行为

00:31:54.715 --> 00:31:55.549 align:middle
是重要的

00:31:56.416 --> 00:31:59.386 align:middle
那么现在我们可以将其重
写成一个kindof NSView

00:31:59.553 --> 00:32:03.857 align:middle
所以返回某种NSView
而从 Swift 来讲

00:31:59.553 --> 00:32:03.857 align:middle
所以返回某种NSView
而从 Swift 来讲

00:32:04.191 --> 00:32:06.460 align:middle
现在我们要返回
一个选择性的 NSView

00:32:06.827 --> 00:32:09.196 align:middle
这对 Swift 来讲 是个正确的

00:32:09.963 --> 00:32:12.132 align:middle
应用程序接口且它可以在
Objective-C中完美地工作

00:32:12.399 --> 00:32:13.834 align:middle
让我们将其带回我们最初的

00:32:13.901 --> 00:32:15.068 align:middle
有关轻量泛型的例子

00:32:15.602 --> 00:32:20.874 align:middle
这里我们有我们的各种子视图称为
UIViews的一个NSArray

00:32:21.208 --> 00:32:25.345 align:middle
好吧现在我们可以说它是
一个NSArray的kindof UIViews

00:32:25.946 --> 00:32:28.182 align:middle
这样我们就在Object-C和
Swift中得到了一个更强大的

00:32:28.248 --> 00:32:29.349 align:middle
应用程序接口

00:32:30.217 --> 00:32:32.986 align:middle
获知这一属性是什么会容易很多

00:32:34.288 --> 00:32:37.391 align:middle
但你不会造成任何虚假
的警告 因为你依旧会有

00:32:37.457 --> 00:32:39.993 align:middle
从 ID 而来的好的隐式的
向下类型转换行为

00:32:42.296 --> 00:32:43.830 align:middle
希望这一点儿会让你提出一个问题

00:32:46.200 --> 00:32:48.535 align:middle
我真的该在应用编程
接口中使用 ID 吗？

00:32:50.037 --> 00:32:52.573 align:middle
多年以来我们实际上
一直在推出很多功能

00:32:52.639 --> 00:32:56.210 align:middle
在各种重要的情况下
比 ID 能够给出

00:32:56.276 --> 00:32:59.046 align:middle
更为具体的类型信息

00:33:00.047 --> 00:33:01.782 align:middle
且在我们推出Arc 的同一年

00:33:01.882 --> 00:33:03.383 align:middle
我们推出了 instance 类型

00:33:04.117 --> 00:33:06.386 align:middle
用于让你调用的方法
返回与 self 相同的

00:33:06.453 --> 00:33:08.322 align:middle
动态类型

00:33:09.990 --> 00:33:11.692 align:middle
今年我们正在推出类型集合体

00:33:11.758 --> 00:33:14.161 align:middle
这将消除 ID 的很多用途

00:33:14.595 --> 00:33:17.197 align:middle
从我们自己的应用编程接口我们
一直在推出这些功能

00:33:17.531 --> 00:33:20.234 align:middle
当然当你采用这一功能时
在你自己的应用编程接口上也是一样

00:33:21.101 --> 00:33:24.204 align:middle
我们现在从 kindof X
通过隐式向下转换

00:33:24.371 --> 00:33:26.073 align:middle
谈谈 X 的任何子类别

00:33:26.773 --> 00:33:29.176 align:middle
所以你可以保持你代码继续工作

00:33:29.576 --> 00:33:32.446 align:middle
起码所有那些实际上
起着作用又没表现怪异的代码

00:33:33.180 --> 00:33:34.815 align:middle
但是会有一个更好应用编程接口合同

00:33:35.415 --> 00:33:38.185 align:middle
而且各种协议已存在于
Objective-C中很长一段儿时间

00:33:38.252 --> 00:33:41.855 align:middle
而使用某个协议的 ID是明白地说

00:33:41.922 --> 00:33:43.357 align:middle
我不在乎一个类别的类型是什么

00:33:43.423 --> 00:33:44.992 align:middle
它只是必须要符合这一协定

00:33:46.627 --> 00:33:49.696 align:middle
所以有一个大类的用途适合于 ID

00:33:50.130 --> 00:33:51.231 align:middle
那是当你真正的意思

00:33:51.298 --> 00:33:53.867 align:middle
确实是一个任何类型的对象

00:33:54.234 --> 00:33:56.537 align:middle
那就没有任何静态类型
信息可以把这一点

00:33:56.603 --> 00:33:57.638 align:middle
表达得更好

00:33:58.605 --> 00:34:02.776 align:middle
这样这方面的一个典型的例子
是用户信息字典

00:33:58.605 --> 00:34:02.776 align:middle
这样这方面的一个典型的例子
是用户信息字典

00:34:03.143 --> 00:34:07.881 align:middle
你用字符串做密匙且
你用 ID 做值

00:34:08.681 --> 00:34:09.683 align:middle
这完全合理

00:34:09.750 --> 00:34:12.286 align:middle
因为对不同的密钥其值会有

00:34:12.351 --> 00:34:14.521 align:middle
不同的类型而这种类型你只能够

00:34:14.588 --> 00:34:15.589 align:middle
动态地确定

00:34:19.960 --> 00:34:20.793 align:middle
让我们总结一下

00:34:21.061 --> 00:34:24.864 align:middle
所以我们对Swift和
Objective-C都做了大的改进

00:34:25.032 --> 00:34:27.501 align:middle
这些语言是一起设计并一起进化

00:34:27.935 --> 00:34:29.636 align:middle
以使其可以完美地一起工作

00:34:30.404 --> 00:34:33.607 align:middle
而Xcode和其支持工具将会帮助你

00:34:34.007 --> 00:34:37.978 align:middle
在这两种语言之间游移
这是对你的工作流最好的方法

00:34:39.446 --> 00:34:42.081 align:middle
我们已经为Objective-C
推出了很多强大的功能

00:34:42.149 --> 00:34:44.083 align:middle
我们强烈建议你
使你的使用Objective-C的

00:34:44.150 --> 00:34:44.985 align:middle
情况现代化

00:34:45.518 --> 00:34:48.121 align:middle
这些新的语言功能
给你提供好得多的应用编程接口

00:34:48.188 --> 00:34:51.091 align:middle
你会在我们的应用编程接口和你自己
应用编程接口中看到这一点

00:34:51.158 --> 00:34:53.527 align:middle
这些新功能还会让你的程序
具有更好的类型安全性

00:34:53.594 --> 00:34:55.529 align:middle
让你能够尽早找出问题
而不用等他们在程序

00:34:55.596 --> 00:34:57.865 align:middle
运行时以可怕的无法
确认的选择器的形式表现出来

00:34:59.166 --> 00:35:01.535 align:middle
且使用这些功能可以
真的使你在 Swift 中的

00:34:59.166 --> 00:35:01.535 align:middle
且使用这些功能可以
真的使你在 Swift 中的

00:35:01.602 --> 00:35:03.437 align:middle
Objective-C接口变得优美

00:35:03.504 --> 00:35:06.673 align:middle
从而让你编程时
获得最好的 Swift 体验

00:35:08.175 --> 00:35:12.613 align:middle
如需更多的信息请联系我们的传道人

00:35:12.713 --> 00:35:15.048 align:middle
Stefan Lesser
查找相关文档

00:35:15.115 --> 00:35:16.783 align:middle
或者通过我们的网上论坛与我们联系

00:35:18.485 --> 00:35:19.653 align:middle
还有很多有关的课程讲授

00:35:19.720 --> 00:35:21.655 align:middle
Swift 和 Cocoa 中
有什么新的东西

00:35:21.855 --> 00:35:23.790 align:middle
这里有很多很棒的Swift课程

00:35:24.391 --> 00:35:25.225 align:middle
谢谢
