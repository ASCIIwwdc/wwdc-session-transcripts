WEBVTT

00:00:25.726 --> 00:00:29.129 align:middle
彼得·崔：大家好 下午好

00:00:29.196 --> 00:00:31.832 align:middle
欢迎参加《iOS高级手写输入》讲座

00:00:32.366 --> 00:00:33.300 align:middle
我是彼得

00:00:33.500 --> 00:00:35.636 align:middle
在Apple的iOS性能小组工作

00:00:36.303 --> 00:00:39.239 align:middle
今天和朋友UIKit小组的雅各布

00:00:39.540 --> 00:00:41.108 align:middle
准备给大家介绍更多有关

00:00:41.341 --> 00:00:43.510 align:middle
手写输入在iOS怎样运行

00:00:43.877 --> 00:00:48.582 align:middle
以及怎样用它让
自己的应用对手写输入更为灵敏

00:00:50.117 --> 00:00:51.418 align:middle
今天要讲的内容可是不少

00:00:51.919 --> 00:00:55.989 align:middle
正如前一个幻灯片
所讲要想让自己的应用

00:00:56.056 --> 00:00:57.391 align:middle
反应灵敏的话

00:00:57.524 --> 00:00:59.560 align:middle
减少延迟是关键

00:00:59.993 --> 00:01:02.896 align:middle
我们将介绍延迟是什么

00:00:59.993 --> 00:01:02.896 align:middle
我们将介绍延迟是什么

00:01:03.030 --> 00:01:04.697 align:middle
以及为什么要关注应用中的延迟

00:01:05.132 --> 00:01:06.900 align:middle
以及iOS中的一般性延迟问题

00:01:08.035 --> 00:01:10.337 align:middle
为了探讨延迟是来自哪里

00:01:10.571 --> 00:01:13.974 align:middle
我们将探讨并剖析iOS中

00:01:14.274 --> 00:01:16.109 align:middle
在手指下负责处理

00:01:16.176 --> 00:01:17.578 align:middle
手写输入和绘制像素图之间

00:01:17.911 --> 00:01:21.348 align:middle
对触控做出各种反应的主要内容

00:01:22.983 --> 00:01:25.018 align:middle
去年我们对iOS 9的系统

00:01:25.185 --> 00:01:26.720 align:middle
做了许多改进我们将向大家

00:01:26.787 --> 00:01:29.289 align:middle
介绍这些改进以及大家可以

00:01:29.356 --> 00:01:33.093 align:middle
用到的部分API 以便充分
利用我们所做的这些改进

00:01:34.161 --> 00:01:36.597 align:middle
最后 我们会告诉大家一些技巧

00:01:36.663 --> 00:01:40.100 align:middle
和最佳实践 以便发现 分析

00:01:40.167 --> 00:01:42.903 align:middle
和解决在应用中出现的性能瓶颈

00:01:44.805 --> 00:01:48.141 align:middle
为何要关注降低应用中的延迟问题呢？

00:01:49.343 --> 00:01:53.380 align:middle
iOS手写输入是
建立在直接操纵的理念上

00:01:53.780 --> 00:01:57.317 align:middle
也就是说用户实际上用手指

00:01:57.384 --> 00:02:01.021 align:middle
触碰物理对象 并在虚拟空间中做移动

00:01:57.384 --> 00:02:01.021 align:middle
触碰物理对象 并在虚拟空间中做移动

00:02:01.955 --> 00:02:06.059 align:middle
例如 如果用户想要把这个圆

00:02:06.260 --> 00:02:10.597 align:middle
从A点移动到B点那么预期的结果

00:02:10.864 --> 00:02:13.834 align:middle
就是圆感觉被粘在手指指尖

00:02:14.801 --> 00:02:16.036 align:middle
你会注意到在本例中

00:02:16.270 --> 00:02:19.473 align:middle
这个圆会准确灵敏地随着

00:02:19.773 --> 00:02:20.741 align:middle
用户手指移动

00:02:22.075 --> 00:02:24.545 align:middle
但是一旦降低延迟

00:02:24.811 --> 00:02:26.947 align:middle
也就是手指移动和圆的移动

00:02:27.314 --> 00:02:29.850 align:middle
二者间的滞后这种直接

00:02:29.917 --> 00:02:31.852 align:middle
操纵的感觉就会开始被打破

00:02:32.686 --> 00:02:36.690 align:middle
在本例中 你可以看到
圆在跟随手指而动而且并不像

00:02:36.757 --> 00:02:38.692 align:middle
是你是在手指周围移动圆

00:02:40.294 --> 00:02:41.695 align:middle
当用户手指移动

00:02:41.762 --> 00:02:43.430 align:middle
速度非常快时情况会越发严重

00:02:43.997 --> 00:02:47.801 align:middle
这样 手指与圆之间会形成相当距离

00:02:48.368 --> 00:02:51.471 align:middle
而且不再感觉手指与圆是处于粘合状态

00:02:51.572 --> 00:02:54.741 align:middle
圆此刻是在跟着手指移动

00:02:57.044 --> 00:03:01.415 align:middle
这类延迟会影响到iOS的各方面

00:02:57.044 --> 00:03:01.415 align:middle
这类延迟会影响到iOS的各方面

00:03:01.481 --> 00:03:03.951 align:middle
从按下按钮到移动对象

00:03:04.384 --> 00:03:06.820 align:middle
到滚动任何内容甚至是网页都不可避免

00:03:07.821 --> 00:03:10.157 align:middle
但是我们可以确定有两三个应用

00:03:10.224 --> 00:03:13.126 align:middle
可以显著增加延迟作用

00:03:14.161 --> 00:03:17.798 align:middle
一种应用类型是绘图应用

00:03:18.365 --> 00:03:21.335 align:middle
不仅是艺术家会被线条末端

00:03:21.401 --> 00:03:24.638 align:middle
和用户指尖的距离搞得心神不宁

00:03:26.240 --> 00:03:29.776 align:middle
艺术家通常要依赖应用

00:03:29.843 --> 00:03:33.413 align:middle
或用户界面的快速灵敏更新

00:03:33.480 --> 00:03:36.283 align:middle
以便及时调整物理行为

00:03:36.350 --> 00:03:38.018 align:middle
才能获得希望的结果

00:03:38.986 --> 00:03:41.788 align:middle
此外 游戏这类应用中的延迟

00:03:41.855 --> 00:03:43.857 align:middle
可能会让游戏很难继续

00:03:44.491 --> 00:03:47.160 align:middle
并会影响到应用的感知质量

00:03:48.595 --> 00:03:49.997 align:middle
这个延迟是从哪里来的呢？

00:03:50.330 --> 00:03:52.165 align:middle
是来源自许多不同地方

00:03:52.599 --> 00:03:56.737 align:middle
为了探讨哪里会产生延迟我们会聊聊

00:03:57.004 --> 00:03:59.473 align:middle
在处理触控和相应绘制

00:03:59.540 --> 00:04:02.709 align:middle
触控当中系统中的所有不同部分

00:03:59.540 --> 00:04:02.709 align:middle
触控当中系统中的所有不同部分

00:04:04.144 --> 00:04:05.612 align:middle
在讲座接下来的内容中

00:04:05.712 --> 00:04:08.515 align:middle
我们会用到很多这些管路图

00:04:08.815 --> 00:04:11.451 align:middle
我们要确保大家对其中的含义理解相同

00:04:12.319 --> 00:04:14.655 align:middle
在屏幕上 你会看到5个不同的盒子

00:04:15.022 --> 00:04:17.357 align:middle
每个盒子都代表显示器上

00:04:17.423 --> 00:04:19.660 align:middle
显示一帧内容所用的时间

00:04:20.560 --> 00:04:23.497 align:middle
我们的产品刷新屏幕是60赫兹

00:04:23.564 --> 00:04:24.831 align:middle
也就是每秒60次

00:04:25.332 --> 00:04:27.734 align:middle
那么每个盒子所代表的时间

00:04:27.801 --> 00:04:30.871 align:middle
大约为1/60秒

00:04:32.272 --> 00:04:36.810 align:middle
大家可能听到了每个盒子都代表显示帧

00:04:37.044 --> 00:04:39.246 align:middle
显示间隔或显示周期

00:04:39.580 --> 00:04:40.581 align:middle
这些都是一个意思

00:04:42.182 --> 00:04:46.486 align:middle
现在分割每个盒子的
垂直线代表显示刷新

00:04:46.720 --> 00:04:49.256 align:middle
这个时间点上显示器上的一帧

00:04:49.323 --> 00:04:51.792 align:middle
和接下来要显示的帧进行交换

00:04:52.559 --> 00:04:55.996 align:middle
我接下来会用显示刷新

00:04:56.163 --> 00:04:59.132 align:middle
或同步刷新来表示
这两个基本上也是相同内容

00:05:00.501 --> 00:05:02.302 align:middle
显示刷新在iOS中很重要

00:05:02.536 --> 00:05:05.038 align:middle
因为许多重要系统进程

00:05:05.572 --> 00:05:09.109 align:middle
都是由这个显示刷新来启动或触发

00:05:10.277 --> 00:05:12.946 align:middle
我们来具体看看
在管线中在发生了些什么

00:05:13.680 --> 00:05:15.949 align:middle
管线的第一阶段是
Multi-Touch

00:05:16.583 --> 00:05:20.888 align:middle
在这一个进程中硬件将扫描

00:05:20.954 --> 00:05:22.923 align:middle
显示器表面寻找触控

00:05:23.824 --> 00:05:26.126 align:middle
在我们的多数产品中这部分用时

00:05:26.193 --> 00:05:29.997 align:middle
会小于整个显示帧
但在我们的部分产品中

00:05:30.063 --> 00:05:32.533 align:middle
这会占用整个显示帧

00:05:32.933 --> 00:05:36.170 align:middle
为了更直观我们
用绿盒子来填充整个盒子

00:05:37.571 --> 00:05:42.309 align:middle
Multi-Touch一旦完成
扫描显示器

00:05:42.976 --> 00:05:46.580 align:middle
会过滤掉屏幕上

00:05:46.647 --> 00:05:48.582 align:middle
所出现的任何噪音

00:05:49.283 --> 00:05:53.120 align:middle
UI应用的UITouch
的回调将在靠近下一个

00:05:53.187 --> 00:05:57.691 align:middle
触控帧开始时被调用
通常是在显示刷新开始后

00:05:58.825 --> 00:06:01.528 align:middle
这个点出现在应用应

00:05:58.825 --> 00:06:01.528 align:middle
这个点出现在应用应

00:06:01.595 --> 00:06:04.531 align:middle
该对手写输入做出反应时在绘图应用中

00:06:04.932 --> 00:06:07.601 align:middle
也许是标定点并连接这些点

00:06:08.268 --> 00:06:11.271 align:middle
你也许想做平滑处理令线条更流畅

00:06:12.072 --> 00:06:14.141 align:middle
在不是绘图应用的应用中

00:06:14.474 --> 00:06:16.844 align:middle
这里需要通过按下按钮或按键

00:06:16.910 --> 00:06:19.713 align:middle
来做出反应也许是生成视图

00:06:20.280 --> 00:06:22.349 align:middle
视图控制器 并向用户呈现

00:06:23.350 --> 00:06:25.986 align:middle
这里所花费的时间是个变量

00:06:26.053 --> 00:06:27.221 align:middle
但可以占据一个显示帧

00:06:27.454 --> 00:06:29.456 align:middle
那么我再来填充整个盒子

00:06:30.858 --> 00:06:35.762 align:middle
一旦应用完成与触碰
事件做出反应并相应更新状态

00:06:36.330 --> 00:06:39.800 align:middle
在下一个显示刷新时 Core
Animation 就会启动

00:06:40.200 --> 00:06:43.837 align:middle
开始将视图和图层

00:06:44.471 --> 00:06:47.441 align:middle
翻译成GPU指令这可以被GPU渲染

00:06:48.208 --> 00:06:52.946 align:middle
你会注意到GPU不必等到
下一个显示刷新开始的时候

00:06:53.013 --> 00:06:54.882 align:middle
它在Core Animation

00:06:54.948 --> 00:06:59.219 align:middle
给出它需要渲染帧的
指令时候就会立即开始

00:07:00.020 --> 00:07:03.290 align:middle
同样 这些阶段的时间根据应用中的

00:07:03.824 --> 00:07:07.261 align:middle
视图复杂程度不同也是变量

00:07:08.395 --> 00:07:11.031 align:middle
最后一旦GPU完成渲染帧

00:07:11.398 --> 00:07:13.500 align:middle
这个帧就会在下一个显示刷新

00:07:13.867 --> 00:07:16.703 align:middle
开始时排队在显示器上显示

00:07:18.705 --> 00:07:23.143 align:middle
大家都明白在显示器上感知触控

00:07:23.377 --> 00:07:27.848 align:middle
直至画图需要占用若干帧数
本例中 需要占用4帧

00:07:28.582 --> 00:07:29.516 align:middle
因此不是即刻完成

00:07:30.851 --> 00:07:32.452 align:middle
此外 这是管线

00:07:32.686 --> 00:07:36.356 align:middle
在应用处理之前正发生的触控时

00:07:36.423 --> 00:07:38.825 align:middle
其他的触控也会发生

00:07:39.426 --> 00:07:42.829 align:middle
这就是在管线不同的点经过的进程

00:07:44.298 --> 00:07:46.667 align:middle
我们来谈谈
作为开发人员该怎样控制

00:07:47.134 --> 00:07:50.437 align:middle
并没有API可以改变
Multi-Touch的行为

00:07:50.504 --> 00:07:52.005 align:middle
或显示器硬件图层

00:07:52.272 --> 00:07:54.174 align:middle
这是系统做出的处理

00:07:55.075 --> 00:08:00.013 align:middle
根据应用中的视图复杂程度
你对Core Animation

00:07:55.075 --> 00:08:00.013 align:middle
根据应用中的视图复杂程度
你对Core Animation

00:08:00.347 --> 00:08:03.050 align:middle
渲染服务器和GP进行间接控制

00:08:03.684 --> 00:08:06.620 align:middle
但是你可以对应用几乎完全控制

00:08:07.054 --> 00:08:08.055 align:middle
我们就从这里开始

00:08:10.357 --> 00:08:12.226 align:middle
我刚说过在这个点上

00:08:12.292 --> 00:08:16.263 align:middle
要根据手写输入更新应用的状态

00:08:16.897 --> 00:08:19.566 align:middle
例如 在绘图应用中可以标定点

00:08:19.900 --> 00:08:22.436 align:middle
并彼此连接或是根据按下按钮创建视图

00:08:22.836 --> 00:08:25.873 align:middle
这里也许是发布OpenGL
或Metal指令的位置

00:08:26.940 --> 00:08:28.609 align:middle
这里所花费的时间量是个变量

00:08:28.876 --> 00:08:32.346 align:middle
可以进行优化减少所用时间

00:08:32.412 --> 00:08:33.881 align:middle
我们鼓励大家这么做

00:08:34.581 --> 00:08:37.751 align:middle
但是当我们优化应用时你会注意到这点

00:08:38.085 --> 00:08:42.389 align:middle
Core Animation
并不会进入填充UIKit

00:08:42.756 --> 00:08:44.124 align:middle
或应用所留下的空间

00:08:45.259 --> 00:08:50.697 align:middle
这是因为之前在iOS
如何更新视图所导致

00:08:51.565 --> 00:08:53.433 align:middle
当你在iOS上更新视图状态时

00:08:53.767 --> 00:08:56.570 align:middle
如果用UIMethods更新
A CATransaction

00:08:57.237 --> 00:08:59.907 align:middle
视图属性的话可以显性提交

00:09:00.274 --> 00:09:03.010 align:middle
或UIKit将隐性为你生成一个

00:09:03.577 --> 00:09:07.347 align:middle
我们用红点来表示
CATransaction提交

00:09:08.749 --> 00:09:12.819 align:middle
现在Core Animation
没有填入时间

00:09:13.187 --> 00:09:14.988 align:middle
是因为应用允许在一个

00:09:15.189 --> 00:09:18.325 align:middle
显示帧中多次升级状态

00:09:18.659 --> 00:09:20.994 align:middle
在本例中用第二个点表示

00:09:21.962 --> 00:09:24.965 align:middle
现在 为减少冗余任务量

00:09:25.032 --> 00:09:26.733 align:middle
或永远不会在显示器上出现的任务

00:09:27.167 --> 00:09:31.338 align:middle
Core Animation
分批处理所有更新

00:09:31.405 --> 00:09:33.740 align:middle
并在显示刷新中进行一次渲染

00:09:34.074 --> 00:09:37.010 align:middle
那么我们将渲染这些

00:09:37.077 --> 00:09:39.580 align:middle
Core Animation事务的
综合状态

00:09:41.782 --> 00:09:45.652 align:middle
一旦Core Animation
在显示刷新时

00:09:46.320 --> 00:09:51.058 align:middle
快照视图它将会开始把
所有你为之生成的逻辑视图

00:09:51.592 --> 00:09:54.361 align:middle
和图层翻译成GPU指令
以便由GPU进行渲染

00:09:54.928 --> 00:09:58.332 align:middle
我刚说过
一接到Core Animation

00:09:58.398 --> 00:10:00.801 align:middle
的必要指令GPU就会立刻启动

00:09:58.398 --> 00:10:00.801 align:middle
的必要指令GPU就会立刻启动

00:10:01.168 --> 00:10:04.738 align:middle
因此 如果优化
Core Animation

00:10:04.805 --> 00:10:08.609 align:middle
或GPU的用时数量
GPU就会填充所留下的空间

00:10:10.043 --> 00:10:15.115 align:middle
Xcode的视图调试器是理解
视图层次复杂度的很好方法

00:10:15.382 --> 00:10:20.420 align:middle
也是找到可以取出的视图的
很好方法从而可以优化应用

00:10:21.955 --> 00:10:26.159 align:middle
不过我们认识到
对视图的需求非常复杂

00:10:26.326 --> 00:10:29.196 align:middle
在一个显示帧中很难完全体现

00:10:30.297 --> 00:10:33.500 align:middle
那么iOS管线可以灵活处理这点

00:10:34.434 --> 00:10:37.171 align:middle
如果应用需要花
费额外的时间渲染视图

00:10:37.237 --> 00:10:39.540 align:middle
我们可以把Core
Animation

00:10:39.606 --> 00:10:41.241 align:middle
和GPU任务分到两个显示帧

00:10:41.775 --> 00:10:43.977 align:middle
当然 这增加了额外的延迟帧数

00:10:44.178 --> 00:10:47.414 align:middle
但是还可以在应用的各处获得

00:10:47.748 --> 00:10:50.517 align:middle
每秒60帧的流畅动画视图还更为复杂

00:10:51.852 --> 00:10:56.590 align:middle
并无手动触发选择快慢模式

00:10:56.890 --> 00:11:00.260 align:middle
这又是视情况而定而且是系统任意选定

00:10:56.890 --> 00:11:00.260 align:middle
这又是视情况而定而且是系统任意选定

00:11:00.661 --> 00:11:05.065 align:middle
所以重要的是我们理解
什么内容可以触发进入更快模式

00:11:05.332 --> 00:11:07.401 align:middle
什么内容可以触发进入更慢模式

00:11:09.436 --> 00:11:12.439 align:middle
更快模式叫做双缓冲

00:11:12.639 --> 00:11:16.810 align:middle
这么叫是因为有两个缓冲
一个是为了引入GPU

00:11:17.010 --> 00:11:19.346 align:middle
一个是为了LCD向用户显示

00:11:20.280 --> 00:11:22.983 align:middle
在显示刷新中大家回忆一下

00:11:23.050 --> 00:11:26.086 align:middle
Core Animation
为自己和GPU抓取缓冲

00:11:26.153 --> 00:11:28.755 align:middle
并开始输出该帧的GPU指令

00:11:29.489 --> 00:11:32.693 align:middle
一旦GPU获得指令GPU就开始渲染

00:11:33.093 --> 00:11:36.230 align:middle
如果渲染在下一个显示刷新

00:11:36.330 --> 00:11:40.200 align:middle
发生前结束我们就把这个帧放入队列

00:11:40.434 --> 00:11:41.702 align:middle
在下一个显示刷新中显示

00:11:42.336 --> 00:11:43.904 align:middle
一旦到达显示刷新

00:11:44.371 --> 00:11:46.406 align:middle
这个帧就会进入屏幕

00:11:46.673 --> 00:11:48.876 align:middle
我们开始处理下一个帧

00:11:49.877 --> 00:11:52.813 align:middle
同样 GPU将做渲染
再把这一帧放入队列

00:11:52.880 --> 00:11:54.481 align:middle
为下一个显示刷新进行显示

00:11:54.982 --> 00:11:56.416 align:middle
一旦开始显示刷新

00:11:56.650 --> 00:11:59.586 align:middle
这两个帧将交换位置

00:11:59.853 --> 00:12:03.090 align:middle
我们会回收绿色缓冲继续这一进程

00:11:59.853 --> 00:12:03.090 align:middle
我们会回收绿色缓冲继续这一进程

00:12:03.257 --> 00:12:06.393 align:middle
只要应用有需要渲染的视图即可

00:12:07.661 --> 00:12:08.795 align:middle
现在都没问题

00:12:09.029 --> 00:12:11.365 align:middle
我们已经在一个显示帧完成Core

00:12:11.431 --> 00:12:12.933 align:middle
Core Animation
和GPU任务

00:12:12.999 --> 00:12:14.067 align:middle
性能很好

00:12:15.202 --> 00:12:17.738 align:middle
可是如果无法做到所有这些 会怎样？

00:12:18.338 --> 00:12:19.606 align:middle
如果无法在一帧中完成呢？

00:12:20.174 --> 00:12:22.176 align:middle
那我们就进入了三重缓冲模式

00:12:22.943 --> 00:12:25.712 align:middle
同样Core Animation
会输出GPU指令

00:12:25.779 --> 00:12:28.882 align:middle
GPU随后会渲染不过在本例中

00:12:29.216 --> 00:12:33.921 align:middle
在开始显示刷新时
GPU并没有完成绿色帧的渲染

00:12:34.655 --> 00:12:36.823 align:middle
在本例中 因为我们还无法展示

00:12:37.224 --> 00:12:40.494 align:middle
为了额外的帧蓝色
帧延伸到屏幕上的情景

00:12:41.929 --> 00:12:44.331 align:middle
Core Animation现在
需要分配第三个缓冲

00:12:44.398 --> 00:12:46.200 align:middle
开始处理下一个帧通过生成

00:12:46.600 --> 00:12:48.869 align:middle
第三个缓冲来实现这一点

00:12:49.536 --> 00:12:52.039 align:middle
Core Animation将
开始为之输出GPU指令

00:12:52.105 --> 00:12:54.875 align:middle
同时GPU完成前一帧的渲染

00:12:55.876 --> 00:12:58.712 align:middle
然后前一帧将进入队列

00:12:58.879 --> 00:13:00.280 align:middle
在下一个显示刷新中显示

00:12:58.879 --> 00:13:00.280 align:middle
在下一个显示刷新中显示

00:13:01.315 --> 00:13:02.482 align:middle
这一进程随后

00:13:02.883 --> 00:13:06.954 align:middle
和Core Animation
渲染服务器输出GPU指令一起重复

00:13:07.154 --> 00:13:08.622 align:middle
GPU会对它们进行渲染

00:13:09.122 --> 00:13:12.492 align:middle
思路就是我们交换缓冲回收缓冲

00:13:12.793 --> 00:13:14.127 align:middle
然后进程重复进行

00:13:17.197 --> 00:13:20.901 align:middle
大家可能会想 所有这些幻灯片都
在说Core Animation

00:13:21.101 --> 00:13:23.303 align:middle
我如果不用Core
Animation会怎样？

00:13:23.370 --> 00:13:24.938 align:middle
如果我要优化应用

00:13:25.339 --> 00:13:27.241 align:middle
使用 Metal or
OpenGL 会怎样？

00:13:28.041 --> 00:13:31.678 align:middle
大家可能会想与其让管线变成这样

00:13:31.845 --> 00:13:35.449 align:middle
让显示的帧变成4帧延迟

00:13:35.782 --> 00:13:37.951 align:middle
不如改作3帧延迟

00:13:39.620 --> 00:13:40.954 align:middle
不过这里不行

00:13:42.489 --> 00:13:45.792 align:middle
在iOS 8
如果用Metal或OpenGL

00:13:46.093 --> 00:13:48.862 align:middle
Core Animation仍会
作为仲裁器 确保你对...

00:13:48.929 --> 00:13:52.299 align:middle
Core Animation
内容在屏幕上所做的

00:13:52.633 --> 00:13:54.935 align:middle
任何更新 都与这些图层上的GPU

00:13:55.402 --> 00:13:58.539 align:middle
OpenGL和Metal
更新保持同步

00:13:59.540 --> 00:14:01.608 align:middle
在使用iOS 8的 OpenGL

00:13:59.540 --> 00:14:01.608 align:middle
在使用iOS 8的 OpenGL

00:14:01.842 --> 00:14:05.245 align:middle
或Metal时你仍有4帧延迟

00:14:06.947 --> 00:14:11.685 align:middle
那么我们谈到过iOS管线非常灵活

00:14:11.852 --> 00:14:13.520 align:middle
可以处理更为复杂的视图

00:14:13.787 --> 00:14:16.590 align:middle
可以实现每秒60帧动画

00:14:16.657 --> 00:14:18.759 align:middle
但是在5帧延迟中会怎样

00:14:19.092 --> 00:14:23.664 align:middle
怎样优化应用通过优化绘图

00:14:23.897 --> 00:14:25.832 align:middle
把延迟降为4帧

00:14:26.767 --> 00:14:30.003 align:middle
但是 在本例中没有办法

00:14:30.103 --> 00:14:32.840 align:middle
可以实现更快 因为
Core Animation

00:14:32.906 --> 00:14:34.541 align:middle
需要等到显示刷新开始

00:14:34.942 --> 00:14:37.511 align:middle
生成GPU指令才行

00:14:39.713 --> 00:14:42.449 align:middle
在iOS 9中
我们去除了这种依赖性

00:14:43.483 --> 00:14:46.386 align:middle
现在可以在应用完成应用状态升级后

00:14:46.453 --> 00:14:48.889 align:middle
立刻启动 Core
Animation 任务

00:14:49.857 --> 00:14:53.927 align:middle
为了充分利用这些功能
我们在iOS系统中引入了

00:14:53.994 --> 00:14:55.863 align:middle
一些新的API和新技巧

00:14:56.196 --> 00:14:57.664 align:middle
为了更多介绍这方面内容

00:14:57.731 --> 00:14:59.399 align:middle
有请雅各布

00:15:00.934 --> 00:15:01.935 align:middle
雅克布·肖：谢谢 彼得

00:15:03.337 --> 00:15:04.171 align:middle
我将向大家

00:15:04.371 --> 00:15:06.740 align:middle
介绍我们在iOS 9中新增的内容

00:15:07.341 --> 00:15:10.344 align:middle
以及怎样用它们实现app的更低延迟

00:15:12.179 --> 00:15:13.780 align:middle
今天我来讲三个问题

00:15:14.448 --> 00:15:17.551 align:middle
第一 低延迟
支持Core Animation

00:15:18.519 --> 00:15:21.121 align:middle
然后是用户触控接合的新系统

00:15:22.155 --> 00:15:24.925 align:middle
最后是个很酷的系统
可以在UIKit构建

00:15:25.092 --> 00:15:26.393 align:middle
触控预测

00:15:27.928 --> 00:15:30.731 align:middle
我们现在先从Core
Animation低延迟开始

00:15:32.733 --> 00:15:34.735 align:middle
彼得讲过在iOS 8中

00:15:35.102 --> 00:15:39.373 align:middle
即便是最优化的app
延迟的降低程度也是非常有限的

00:15:40.541 --> 00:15:43.410 align:middle
通过使用iOS 9的低延迟
Core Animation

00:15:43.877 --> 00:15:47.014 align:middle
可以把app的帧和Core
Animation的帧相结合

00:15:47.414 --> 00:15:48.849 align:middle
这会实现更低的延迟

00:15:49.716 --> 00:15:51.018 align:middle
这种功能的最好一点在于

00:15:51.218 --> 00:15:52.519 align:middle
它是自动发生的

00:15:52.786 --> 00:15:54.321 align:middle
你不必在app上做任何改变

00:15:54.588 --> 00:15:56.190 align:middle
除了优化你的性能表现之外

00:15:57.724 --> 00:15:59.493 align:middle
不过 还需要牢记一点

00:15:59.726 --> 00:16:02.629 align:middle
当app中的动画激活时

00:15:59.726 --> 00:16:02.629 align:middle
当app中的动画激活时

00:16:02.930 --> 00:16:04.665 align:middle
低延迟模式是自动关闭的

00:16:05.866 --> 00:16:09.069 align:middle
这包括CA动画和UIKit动画

00:16:09.736 --> 00:16:11.939 align:middle
因此 如果需要
app中 延迟是绝对最低水平

00:16:12.406 --> 00:16:14.374 align:middle
在显示器上触控激活时一定确保要

00:16:14.675 --> 00:16:16.643 align:middle
关闭这些动画功能

00:16:22.816 --> 00:16:26.320 align:middle
现在 系统还可以与Metal
OpenGL内容配合使用

00:16:26.954 --> 00:16:29.656 align:middle
因此正如之前在iOS 8中所见

00:16:30.157 --> 00:16:33.627 align:middle
我们必须等额外的
帧以便让GPU内容得以显示

00:16:34.595 --> 00:16:36.330 align:middle
但是有了新的低延迟模式

00:16:36.663 --> 00:16:39.233 align:middle
我们可以在紧邻的下一帧

00:16:39.299 --> 00:16:40.367 align:middle
尽快显示这些内容

00:16:41.335 --> 00:16:42.803 align:middle
这些都是自动完成

00:16:42.870 --> 00:16:45.706 align:middle
使用CAeagllayer
或CAMetalLayer即可

00:16:47.140 --> 00:16:49.243 align:middle
不过 如果有想和
OpenGL或Metal内容

00:16:49.309 --> 00:16:51.512 align:middle
一起显示的Core
Animation 内容的话

00:16:51.578 --> 00:16:54.181 align:middle
在app中还需要记住一点

00:16:55.349 --> 00:16:58.585 align:middle
这样 GPU内容 会尽快拉到

00:16:58.652 --> 00:17:01.355 align:middle
显示器上但是 core
Animation内容

00:16:58.652 --> 00:17:01.355 align:middle
显示器上但是 core
Animation内容

00:17:01.822 --> 00:17:03.824 align:middle
则需要更长时间才能过去

00:17:05.092 --> 00:17:08.127 align:middle
如果是这种情况那么默认状态

00:17:08.362 --> 00:17:11.098 align:middle
不会确保GPU内容
会到达Core Animation

00:17:11.164 --> 00:17:12.432 align:middle
内容的同一帧

00:17:13.267 --> 00:17:15.903 align:middle
如果你希望二者同步的话
这就会出现问题

00:17:16.369 --> 00:17:18.638 align:middle
例如如果你希望把UIKit内容绘制

00:17:18.704 --> 00:17:22.009 align:middle
在OpenGL视图
上面就会出现这样的情况

00:17:23.477 --> 00:17:25.945 align:middle
这种情况下 你希望同步更新

00:17:26.313 --> 00:17:28.582 align:middle
类似这样这里有个属性

00:17:28.649 --> 00:17:29.616 align:middle
可实现这一功能

00:17:29.683 --> 00:17:32.085 align:middle
叫做Presents
With Transaction

00:17:32.152 --> 00:17:34.955 align:middle
是在CAeagllayer
和CAMetalLayer上面

00:17:35.322 --> 00:17:37.524 align:middle
当设置这个为False时这是默认值

00:17:38.025 --> 00:17:41.461 align:middle
那就可以尽快获得显示的GPU内容

00:17:42.229 --> 00:17:43.530 align:middle
但是当设置为True的时候

00:17:44.031 --> 00:17:45.999 align:middle
我们可以将GPU内容

00:17:46.166 --> 00:17:48.836 align:middle
和Core Animation内容
同步 因此它们会同时

00:17:48.902 --> 00:17:50.737 align:middle
出现在显示器上

00:17:52.372 --> 00:17:55.242 align:middle
好 接下来 我们谈谈触控接合

00:17:56.176 --> 00:17:56.977 align:middle
在这之前

00:17:57.177 --> 00:17:59.813 align:middle
我先介绍一下 iPad Air 2

00:18:01.014 --> 00:18:02.950 align:middle
去年 我们推出iPad Air 2

00:18:03.650 --> 00:18:05.919 align:middle
显示屏更新速率为60赫兹

00:18:06.186 --> 00:18:09.189 align:middle
也就是说显示器每秒更新60次

00:18:09.523 --> 00:18:10.891 align:middle
和其他的iOS设备一样

00:18:11.725 --> 00:18:14.394 align:middle
它有个很酷的功能可以影响触控

00:18:14.461 --> 00:18:17.231 align:middle
和触控延迟我今天
很兴奋能向大家介绍这点

00:18:18.198 --> 00:18:21.502 align:middle
这样它可实现
120赫兹触控扫描更新速率

00:18:25.272 --> 00:18:25.939 align:middle
太酷了

00:18:27.541 --> 00:18:31.578 align:middle
这意味着扫描触控的
速率是其他iOS设备的两倍

00:18:31.945 --> 00:18:34.281 align:middle
这非常棒因为你可以获得

00:18:34.515 --> 00:18:37.384 align:middle
用户手指和显示器互动时的更多信息

00:18:38.919 --> 00:18:41.922 align:middle
我们来看这会在实践中怎样影响app

00:18:42.923 --> 00:18:46.326 align:middle
使用60赫兹的触
控扫描速率在用户手指

00:18:46.393 --> 00:18:48.795 align:middle
在显示器上移动时我们会定期采样

00:18:48.862 --> 00:18:52.099 align:middle
手指的位置
并把这个信息提供给app

00:18:53.400 --> 00:18:56.036 align:middle
使用120赫兹扫描速率时
也会发生同样的事情

00:18:56.370 --> 00:18:59.840 align:middle
但是因为是两倍的速率
你会获得两倍的样本

00:19:00.741 --> 00:19:03.410 align:middle
这会让你掌握用户行为的更多信息

00:19:09.316 --> 00:19:12.186 align:middle
现在 一旦获得这些样本
我们就会把它们转给app

00:19:13.086 --> 00:19:16.323 align:middle
通过这些 你会了解
用户想要用触控做些什么

00:19:16.790 --> 00:19:19.726 align:middle
例如 在绘图app中你可能会把这些

00:19:20.060 --> 00:19:22.362 align:middle
连接起来 显示出用户想要实现的绘图

00:19:23.330 --> 00:19:26.800 align:middle
120赫兹的信息会提供更多信息量

00:19:26.967 --> 00:19:29.770 align:middle
以便会绘图有着更好的表示

00:19:31.538 --> 00:19:34.608 align:middle
现在我们看到了使用120赫兹的
触控扫描速率所带来的好处

00:19:35.142 --> 00:19:39.446 align:middle
我们先来看它会怎样
影响触控对显示管线的作用

00:19:40.981 --> 00:19:43.951 align:middle
这是60赫兹的
触控扫描速率管线我们之前见过

00:19:44.718 --> 00:19:47.621 align:middle
我们主要来看
管线的Multi-Touch阶段

00:19:49.022 --> 00:19:52.726 align:middle
在60赫兹水平上 我们
每帧会获得一个新触控样本

00:19:53.794 --> 00:19:56.897 align:middle
在120赫兹水平上
我们每次会获得两个样本

00:19:57.764 --> 00:20:00.901 align:middle
不过 要注意显示帧依然相同

00:19:57.764 --> 00:20:00.901 align:middle
不过 要注意显示帧依然相同

00:20:01.235 --> 00:20:03.804 align:middle
因为显示器本身的更新速率相同

00:20:05.606 --> 00:20:08.475 align:middle
现在我们可以用这些新的触控样本

00:20:09.243 --> 00:20:11.445 align:middle
并将其转至app而且
app可以用它来更新绘图

00:20:11.612 --> 00:20:13.647 align:middle
而绘图会把在
Core Animation

00:20:13.714 --> 00:20:15.082 align:middle
和显示器显示的内容做更新

00:20:16.049 --> 00:20:17.551 align:middle
但是你会注意到如果我们这么做

00:20:17.918 --> 00:20:21.088 align:middle
app的更新次数实际是显示器更新的
两倍 这会导致app在做

00:20:21.321 --> 00:20:22.856 align:middle
无用功

00:20:24.024 --> 00:20:27.327 align:middle
我们介绍了触控接合系统
来或者两方面的最好效果

00:20:27.995 --> 00:20:31.865 align:middle
这样可以从120赫兹
触控扫描速率中获得更多信息

00:20:32.533 --> 00:20:35.802 align:middle
但是不会在app中取消太多无用功

00:20:36.837 --> 00:20:39.673 align:middle
我们来看管线如何与接合一起改变

00:20:40.941 --> 00:20:43.410 align:middle
现在我们只能向app

00:20:43.877 --> 00:20:45.179 align:middle
每个显示帧交付一个触控

00:20:45.746 --> 00:20:48.115 align:middle
当首个触控出现时我们会把它交付给你

00:20:49.483 --> 00:20:51.852 align:middle
然后是下一帧我们会交付这一帧

00:20:51.919 --> 00:20:54.821 align:middle
的触控 同时还有上次我们发送触控

00:20:54.888 --> 00:20:57.357 align:middle
到app上时所出现的任何中间触控

00:20:58.725 --> 00:21:03.197 align:middle
每次用户要显示更多
触控时这些都会重复一遍

00:20:58.725 --> 00:21:03.197 align:middle
每次用户要显示更多
触控时这些都会重复一遍

00:21:03.697 --> 00:21:05.866 align:middle
我们提供当前的触控和任何接合触控

00:21:06.533 --> 00:21:08.468 align:middle
只要触控激活这些就会继续

00:21:10.103 --> 00:21:13.207 align:middle
现在 API使用这些
接合触控就非常简单

00:21:13.273 --> 00:21:16.376 align:middle
这是UIEvent上的新方法叫做
Coalesce Touches

00:21:16.443 --> 00:21:17.244 align:middle
For Touch

00:21:17.978 --> 00:21:20.280 align:middle
把这个方法转至正在看的触控

00:21:20.781 --> 00:21:23.417 align:middle
在上次我们交付 触控到app上之后

00:21:23.483 --> 00:21:26.520 align:middle
会返回一组所有的接合触控

00:21:28.422 --> 00:21:30.591 align:middle
为更好了解这个API该怎样使用

00:21:30.657 --> 00:21:33.160 align:middle
我们来看看触控处理
一般在iOS上怎样运作

00:21:35.028 --> 00:21:36.797 align:middle
当用户首先触控显示屏时

00:21:37.264 --> 00:21:39.466 align:middle
我们会调用app上的
Touches Began

00:21:40.133 --> 00:21:42.636 align:middle
他们的手指移动时我们
将调用Touches Moved

00:21:43.003 --> 00:21:44.905 align:middle
当手指从显示屏拿开时

00:21:44.972 --> 00:21:46.840 align:middle
我们会调用
Touches Ended

00:21:48.008 --> 00:21:50.077 align:middle
现在 我们谈论这些触控回调时

00:21:50.377 --> 00:21:52.980 align:middle
另一个非常重要的回调
是Touches Canceled

00:21:54.014 --> 00:21:56.917 align:middle
当通往app的触控流中
断时 就会调用它

00:21:57.518 --> 00:21:59.520 align:middle
例如 如果用户从底部滑动

00:21:59.586 --> 00:22:01.188 align:middle
来激活Control Center

00:21:59.586 --> 00:22:01.188 align:middle
来激活Control Center

00:22:02.055 --> 00:22:04.525 align:middle
在这种情况下 当接收到
系统手势 app将

00:22:04.591 --> 00:22:06.627 align:middle
获得部分初始触控回调

00:22:07.160 --> 00:22:09.296 align:middle
我们将获得
Touches Canceled

00:22:10.764 --> 00:22:13.800 align:middle
用这种方法来清理之前的触控

00:22:13.867 --> 00:22:16.570 align:middle
回调所开始的任何内容

00:22:17.037 --> 00:22:18.605 align:middle
以及回退所做的任何改变都很重要

00:22:19.239 --> 00:22:23.177 align:middle
例如 在绘图app中你可能想
清除用户所画的线条

00:22:24.945 --> 00:22:27.014 align:middle
现在我们了解了
这些触控回调是怎么起作用

00:22:27.281 --> 00:22:29.383 align:middle
我们来看它们怎样和接合触控互动

00:22:30.484 --> 00:22:34.121 align:middle
我们交付给所有回调的触控
我们称之为主触控

00:22:34.588 --> 00:22:39.193 align:middle
这部分在120赫兹扫描速率
和60赫兹设备上都完全相同

00:22:41.495 --> 00:22:42.696 align:middle
但是 有了Coalesce

00:22:42.763 --> 00:22:44.865 align:middle
Touches For Touch
方法

00:22:45.098 --> 00:22:47.267 align:middle
你可以通过这些接合触控了解更多信息

00:22:48.202 --> 00:22:52.773 align:middle
接合触控互动不仅
有着中间触控的相关信息

00:22:53.240 --> 00:22:56.176 align:middle
它们还会提供主触控本身的副本

00:22:57.244 --> 00:22:59.680 align:middle
这其中最棒的一点是你可以进行选择

00:23:00.080 --> 00:23:01.782 align:middle
你可以来看主触控

00:23:02.049 --> 00:23:03.851 align:middle
如果不需要app的更高触控扫描速率

00:23:04.284 --> 00:23:06.453 align:middle
所增加的信息量

00:23:07.054 --> 00:23:08.622 align:middle
或者如果如果想要这些信息

00:23:08.989 --> 00:23:12.593 align:middle
可以来看接合触控
而且你不必担心主触控

00:23:17.598 --> 00:23:20.601 align:middle
现在 我们再来看触控序列

00:23:20.667 --> 00:23:23.837 align:middle
看它如何与主触控和接合触控相配合

00:23:25.105 --> 00:23:26.573 align:middle
随着用户手指的下滑

00:23:26.974 --> 00:23:31.178 align:middle
我们会给app一个
主触控并将其副本作为接合触控

00:23:32.279 --> 00:23:33.380 align:middle
随着手指的移动

00:23:33.447 --> 00:23:35.015 align:middle
我们会交付新的主触控

00:23:35.315 --> 00:23:37.217 align:middle
和各自的一组接合触控

00:23:37.985 --> 00:23:39.520 align:middle
最后 随着手指离开

00:23:39.720 --> 00:23:41.054 align:middle
我们将提供最后的主触控

00:23:41.455 --> 00:23:42.956 align:middle
和任何其余的接合触控

00:23:44.458 --> 00:23:48.829 align:middle
这里我希望只展示
每个主触控的一两个接合触控

00:23:49.263 --> 00:23:52.065 align:middle
需要注意的是app可以收到
不同的数量这点很重要

00:23:52.966 --> 00:23:55.202 align:middle
如果app花费长时间处理一个触控

00:23:55.602 --> 00:23:59.806 align:middle
然后我们给你些时间跟进并等着
跟进之后发送新的触控

00:24:01.008 --> 00:24:01.942 align:middle
如果出现这样的情况

00:24:02.109 --> 00:24:05.879 align:middle
那么未交付给你的
触控稍后会作为接合触控发送给你

00:24:06.413 --> 00:24:08.515 align:middle
因此 确保你的代码对
所收到的接合触控

00:24:08.682 --> 00:24:10.551 align:middle
数量 不存在任何依赖性

00:24:12.519 --> 00:24:14.922 align:middle
现在 在这些接合 触控的行为方式

00:24:15.155 --> 00:24:17.658 align:middle
和主触控的行为方式之间存在一些区别

00:24:18.425 --> 00:24:20.727 align:middle
其中之一与之前的位置有关

00:24:21.762 --> 00:24:23.463 align:middle
之前的位置可以通过Previous

00:24:23.530 --> 00:24:27.067 align:middle
Location In View
from UITouch方法来获得

00:24:28.635 --> 00:24:32.105 align:middle
对主触控而言
这可以为app提供该触控

00:24:32.172 --> 00:24:33.707 align:middle
在交付时的最后位置

00:24:34.441 --> 00:24:36.677 align:middle
对接合触控而言其行为也非常相似

00:24:37.110 --> 00:24:38.212 align:middle
它可以提供针对app的

00:24:38.312 --> 00:24:39.746 align:middle
最后接合触控的位置

00:24:41.715 --> 00:24:43.650 align:middle
这就是需要只关注主触控

00:24:43.717 --> 00:24:46.420 align:middle
或只关注接合触控很重要的原因之一

00:24:47.287 --> 00:24:50.624 align:middle
这样 你就不会对
之前的位置产生任何混淆

00:24:51.058 --> 00:24:52.926 align:middle
因此不要过界非常重要

00:24:58.932 --> 00:25:01.668 align:middle
在主触控和接合触控之间还有一个区别

00:24:58.932 --> 00:25:01.668 align:middle
在主触控和接合触控之间还有一个区别

00:25:01.969 --> 00:25:04.238 align:middle
就是UITouch对象本身如何行为

00:25:05.572 --> 00:25:08.742 align:middle
和主触控一起 每次触控交付

00:25:08.809 --> 00:25:10.844 align:middle
给app时 UITouch
实例就会再次使用

00:25:12.179 --> 00:25:14.581 align:middle
这样做很有用因为如果用户

00:25:14.715 --> 00:25:18.552 align:middle
立刻在显示器上使用多个手指的话
这可以让你区别不同的触控

00:25:20.654 --> 00:25:22.856 align:middle
对接合触控而言这会有所不同

00:25:23.724 --> 00:25:26.393 align:middle
每次 向app交付接合触控时

00:25:26.793 --> 00:25:28.462 align:middle
我们交付一个新的具有新属性的

00:25:29.496 --> 00:25:30.631 align:middle
UITouch实例

00:25:31.498 --> 00:25:33.166 align:middle
所以你可以把这些当作是快照

00:25:33.333 --> 00:25:35.903 align:middle
而不是主触控的共享身份

00:25:37.471 --> 00:25:39.540 align:middle
现在 你理解了触控接合是如何工作的

00:25:39.606 --> 00:25:42.576 align:middle
让我们研究一下某些代码
如何使用接合触控

00:25:43.510 --> 00:25:45.245 align:middle
这就是在app中可能用到的部分代码

00:25:45.512 --> 00:25:49.449 align:middle
可以用于绘图在移动的
触控中可以用这类内容

00:25:50.450 --> 00:25:52.819 align:middle
这里我们会重复我们已有的触控

00:25:53.420 --> 00:25:55.789 align:middle
我们在抓取每个触控对应的代码行

00:25:57.024 --> 00:26:00.527 align:middle
然后 我们把最后的触控
作为新样本加入该行的末尾

00:25:57.024 --> 00:26:00.527 align:middle
然后 我们把最后的触控
作为新样本加入该行的末尾

00:26:02.095 --> 00:26:06.099 align:middle
为了增加触控的接合支持
我们只需要加上这一小部分代码

00:26:07.034 --> 00:26:09.903 align:middle
这里我们为给定的主触控

00:26:09.970 --> 00:26:11.071 align:middle
重复所有的接合触控

00:26:12.005 --> 00:26:15.909 align:middle
对于各个接合触控
我们把它加为该行的样本

00:26:16.710 --> 00:26:19.046 align:middle
注意 我们只添加样本接合触控

00:26:19.346 --> 00:26:20.247 align:middle
而不是主触控

00:26:21.181 --> 00:26:22.382 align:middle
这就是触控接合

00:26:27.454 --> 00:26:29.356 align:middle
现在我想谈谈触控预测

00:26:30.023 --> 00:26:33.527 align:middle
这是我们刚加入
UIKit中的很酷的系统

00:26:33.594 --> 00:26:35.996 align:middle
用它可以实现app中的更低延迟

00:26:36.964 --> 00:26:42.169 align:middle
正如我们交付的app新触控
也会让你了解到未来

00:26:42.436 --> 00:26:45.506 align:middle
我们可以预测到用户
触控在稍后会做些什么

00:26:46.874 --> 00:26:50.410 align:middle
这里的API和接合触控的API
工作效果很相似

00:26:50.811 --> 00:26:54.014 align:middle
这是UIEvent上的新方法叫做
Predicted Touches

00:26:54.081 --> 00:26:54.882 align:middle
For Touch

00:26:55.649 --> 00:26:58.018 align:middle
同样 经过主触控进入这个方法

00:26:58.352 --> 00:27:00.287 align:middle
然后返回一组预测触控

00:26:58.352 --> 00:27:00.287 align:middle
然后返回一组预测触控

00:27:01.855 --> 00:27:04.925 align:middle
可以使用这些预测触控来更新绘图

00:27:05.025 --> 00:27:07.160 align:middle
或者是你用用户触控所做的其他任务

00:27:07.861 --> 00:27:09.029 align:middle
来获取更低的延迟

00:27:10.564 --> 00:27:13.834 align:middle
之前我们看到主触控和
接合触控是如何相关联

00:27:14.668 --> 00:27:16.803 align:middle
而且预测触控的运行方法也非常相似

00:27:17.704 --> 00:27:20.474 align:middle
它们是与主触控相关的另一组触控

00:27:21.542 --> 00:27:24.178 align:middle
而且和接合触控一样作为快照发挥作用

00:27:25.712 --> 00:27:27.948 align:middle
现在 和接合触控相比预测触控

00:27:28.015 --> 00:27:31.084 align:middle
有一点不同那就是
在发生新触控时的表现

00:27:31.885 --> 00:27:34.988 align:middle
当你获得新的主触控时
你会获得一组新的

00:27:35.889 --> 00:27:39.726 align:middle
预测触控 然后你只想
使用新的预测触控

00:27:40.227 --> 00:27:42.529 align:middle
任何之前的预测触控都不再有用

00:27:42.796 --> 00:27:46.400 align:middle
因为我们现在掌握了
当时用户实际在哪里触控

00:27:46.733 --> 00:27:49.436 align:middle
因此 你一般想扔掉那些旧的预测触控

00:27:51.071 --> 00:27:53.373 align:middle
现在视图中之前的位置
对预测触控进行类似的处理

00:27:53.440 --> 00:27:55.642 align:middle
它对其他触控类型也是如此对待

00:27:56.476 --> 00:27:57.911 align:middle
它指出之前的预测触控

00:27:57.978 --> 00:28:00.147 align:middle
所在的位置或者是针对第一个

00:27:57.978 --> 00:28:00.147 align:middle
所在的位置或者是针对第一个

00:28:00.514 --> 00:28:04.618 align:middle
预测触控它指出
交付给app的最后位置

00:28:06.220 --> 00:28:09.690 align:middle
因此你可能会奇怪我们怎么会获得
这些预测触控 其实相当简单

00:28:10.390 --> 00:28:12.526 align:middle
我们在每个iOS设备中
都加上了时间机器

00:28:14.528 --> 00:28:15.562 align:middle
其实不是这样的

00:28:16.163 --> 00:28:19.132 align:middle
我们实际上是来看交付给app的

00:28:19.233 --> 00:28:23.871 align:middle
触控 并使用一套高度精密的
算法来确定用户手指此刻

00:28:23.937 --> 00:28:27.374 align:middle
即将会做些什么

00:28:28.175 --> 00:28:30.811 align:middle
当我们获得新的触控
样本时我们会更新预测

00:28:30.944 --> 00:28:32.913 align:middle
并把新的预测触控交付给app

00:28:34.248 --> 00:28:37.851 align:middle
现在每个预测触控
都是完整的UITouch

00:28:38.185 --> 00:28:39.820 align:middle
对象 而且都填写了所有的属性

00:28:40.053 --> 00:28:41.622 align:middle
例如位置和时间标记

00:28:43.457 --> 00:28:47.394 align:middle
现在我们来看 预测触控对我们
在看的管线会有什么影响

00:28:49.062 --> 00:28:54.635 align:middle
这是我们之前看到的主触控和
接合触控我们可以轻松加入预测触控

00:28:56.103 --> 00:28:58.238 align:middle
每一帧 正如app获得主触控

00:28:58.338 --> 00:29:00.307 align:middle
你也可以获得一组预测触控

00:28:58.338 --> 00:29:00.307 align:middle
你也可以获得一组预测触控

00:29:01.441 --> 00:29:04.111 align:middle
如果你获得主触控和接合触控

00:29:04.311 --> 00:29:07.848 align:middle
那么预测触控是可以获得的更多信息

00:29:08.916 --> 00:29:11.351 align:middle
在新触控交付时会重复这一进程

00:29:12.352 --> 00:29:16.490 align:middle
要注意的是接合触控的
和预测触控是独立的

00:29:16.757 --> 00:29:18.192 align:middle
你可以用其中一个而不用另一个

00:29:18.659 --> 00:29:21.195 align:middle
60赫兹和120赫兹
触控扫描速率设备

00:29:21.361 --> 00:29:23.697 align:middle
均可支持预测触控

00:29:25.499 --> 00:29:27.701 align:middle
我们先来看怎么把触控预测

00:29:28.001 --> 00:29:30.370 align:middle
加入我们刚才看的代码之中

00:29:32.005 --> 00:29:34.208 align:middle
只需要加上这一小部分代码

00:29:35.008 --> 00:29:38.145 align:middle
我们要做的是首先删除我们加入

00:29:38.212 --> 00:29:39.980 align:middle
代码行中的之前的任何预测触控

00:29:40.514 --> 00:29:44.284 align:middle
这很重要 因为我们现在
有了这些触控的实际位置

00:29:50.390 --> 00:29:53.327 align:middle
然后 我们会重复运行已有的预测触控

00:29:54.228 --> 00:29:58.699 align:middle
对于每个预测触控
我们把它加为代码行的样本

00:29:59.633 --> 00:30:01.568 align:middle
但是注意 我们这里加入预测样本

00:29:59.633 --> 00:30:01.568 align:middle
但是注意 我们这里加入预测样本

00:30:01.668 --> 00:30:05.272 align:middle
调用的方法不同于调用常规样本的方法

00:30:05.706 --> 00:30:10.444 align:middle
这样我们可以将样本标记为
下次运行该代码时需要将之删除

00:30:11.945 --> 00:30:13.847 align:middle
这就是触控接合和触控预测

00:30:14.915 --> 00:30:16.717 align:middle
大家现在看到了所有这些技巧

00:30:16.783 --> 00:30:18.919 align:middle
我们来看看把它们
结合起来会是什么效果

00:30:20.988 --> 00:30:23.524 align:middle
在iOS 8中 有个优化的app

00:30:24.057 --> 00:30:25.792 align:middle
这就是你可以获取的触控延迟视图

00:30:26.593 --> 00:30:28.395 align:middle
在触控首次出现和显示器

00:30:28.462 --> 00:30:30.163 align:middle
更新触控信息之间

00:30:30.797 --> 00:30:33.433 align:middle
我们测量延迟的时间

00:30:34.234 --> 00:30:35.836 align:middle
因此 你可以看到在iOS 8中

00:30:36.170 --> 00:30:37.538 align:middle
我们会有4帧延迟

00:30:39.072 --> 00:30:42.576 align:middle
通过使用低延迟Core
Animation和iOS 9

00:30:42.776 --> 00:30:44.611 align:middle
我们可以从中删除一帧延迟

00:30:45.746 --> 00:30:48.115 align:middle
通过使用触控接合并在高触控

00:30:48.215 --> 00:30:50.150 align:middle
扫描速率设备上运行

00:30:50.751 --> 00:30:55.956 align:middle
你不仅可以获得用户触控的
更多信息量还可以从一开始

00:30:56.190 --> 00:30:56.990 align:middle
就删除半帧延迟

00:30:58.926 --> 00:30:59.626 align:middle
但是不仅如此！

00:31:02.296 --> 00:31:03.864 align:middle
通过使用触控预测你可以获得

00:31:04.264 --> 00:31:08.635 align:middle
未来用户触控将往何处去的
大约一帧延迟

00:31:09.203 --> 00:31:12.105 align:middle
这会让你为用户提供有效延迟

00:31:12.739 --> 00:31:14.942 align:middle
也可以减少一帧以上延迟

00:31:15.609 --> 00:31:18.979 align:middle
那么算在一起
在 iOS 9 你可以为用户降低

00:31:19.046 --> 00:31:21.048 align:middle
约1.5帧延迟这要比iOS 8

00:31:21.281 --> 00:31:24.051 align:middle
中的4帧延迟提高很多

00:31:31.592 --> 00:31:32.893 align:middle
那么我们觉得这的确了不得

00:31:32.993 --> 00:31:35.095 align:middle
我很希望大家在app中运用这些技术

00:31:35.162 --> 00:31:38.298 align:middle
为用户提供更低的延迟体验

00:31:39.233 --> 00:31:41.134 align:middle
现在我想把讲台交回给彼得

00:31:41.435 --> 00:31:42.703 align:middle
请他来讲讲怎样调试app

00:31:48.542 --> 00:31:49.710 align:middle
彼得·崔：谢谢 雅各布

00:31:50.444 --> 00:31:53.313 align:middle
现在我们了解了一些
iOS 9中的最新低延迟模式

00:31:53.480 --> 00:31:56.717 align:middle
我们还将介绍一些如何利用

00:31:57.150 --> 00:31:59.520 align:middle
这些来调试应用这样就可以满足

00:31:59.753 --> 00:32:05.325 align:middle
时间的一个显示帧的要求
还可以把帧快速地显示出来

00:31:59.753 --> 00:32:05.325 align:middle
时间的一个显示帧的要求
还可以把帧快速地显示出来

00:32:06.260 --> 00:32:11.064 align:middle
首先 要确保应用在完成最少量的任务

00:32:11.131 --> 00:32:14.768 align:middle
则要将应用需要完成的任务量最小化

00:32:15.536 --> 00:32:18.839 align:middle
通过雅各布刚介绍的接合触控API

00:32:19.373 --> 00:32:22.543 align:middle
你可以享用到iPad Air 2

00:32:22.643 --> 00:32:24.811 align:middle
高保真手写输入的好处同时确保

00:32:24.878 --> 00:32:28.448 align:middle
完成的任务量将在屏幕上显示的图像

00:32:29.483 --> 00:32:32.119 align:middle
此外 要记住用户只会关心

00:32:32.186 --> 00:32:35.355 align:middle
在设备显示器上可以看到的内容

00:32:35.956 --> 00:32:38.125 align:middle
应用可以跟踪屏幕

00:32:38.659 --> 00:32:41.962 align:middle
以外的环境状态

00:32:42.462 --> 00:32:46.333 align:middle
但是 最终 你需要确保
渲染工作要仅限于

00:32:46.667 --> 00:32:49.269 align:middle
那些最终要在屏幕上

00:32:49.469 --> 00:32:52.406 align:middle
生成显示图像的必要工作

00:32:54.875 --> 00:32:57.344 align:middle
如果准备构建应用

00:32:57.511 --> 00:33:01.248 align:middle
计算应用在CPU上

00:32:57.511 --> 00:33:01.248 align:middle
计算应用在CPU上

00:33:01.582 --> 00:33:04.117 align:middle
所花费时间 Time
Profiler是个不错的办法

00:33:04.618 --> 00:33:07.321 align:middle
Time Profiler将通过

00:33:07.387 --> 00:33:10.724 align:middle
在固定间隔取样
显示应用在CPU中所用的时间

00:33:11.358 --> 00:33:14.228 align:middle
在本例中在
Time Profiler

00:33:14.294 --> 00:33:17.397 align:middle
我选用的是16毫秒间隔

00:33:17.531 --> 00:33:19.700 align:middle
这基本和一个显示帧相对应

00:33:20.634 --> 00:33:23.604 align:middle
你可以看出本例中的应用

00:33:23.804 --> 00:33:27.407 align:middle
只用了其中一小块时间

00:33:28.041 --> 00:33:29.710 align:middle
在本例中 是3毫秒

00:33:30.644 --> 00:33:33.080 align:middle
如果是要测量并简要介绍

00:33:33.146 --> 00:33:36.183 align:middle
在CPU方面的表现这也没问题

00:33:36.750 --> 00:33:37.885 align:middle
那么GPU会怎样呢？

00:33:39.586 --> 00:33:41.922 align:middle
在Xcode调试会话中GPU

00:33:41.989 --> 00:33:46.927 align:middle
报告中的每秒
传输帧数工具会为应用的GPU

00:33:47.027 --> 00:33:48.829 align:middle
表现给出高层视图

00:33:49.496 --> 00:33:53.267 align:middle
在本例中 你可以看到
这个应用是60帧每秒

00:33:53.800 --> 00:33:57.337 align:middle
这是相对较低的GPU帧时

00:33:57.638 --> 00:33:59.806 align:middle
在本例中仅为3.8毫秒

00:34:00.774 --> 00:34:06.313 align:middle
不过要记住这是关于
应用运行的高层概视图

00:34:06.780 --> 00:34:09.049 align:middle
其中并未提供也许会导致

00:34:09.116 --> 00:34:13.020 align:middle
掉帧的单独帧的详细信息

00:34:14.188 --> 00:34:16.123 align:middle
如果需要此类精度

00:34:16.723 --> 00:34:20.360 align:middle
可以使用新的GPU驱动工具

00:34:20.726 --> 00:34:22.462 align:middle
我们今年在Xcode中就有包括

00:34:23.597 --> 00:34:26.699 align:middle
GPU驱动工具可以
在你使用应用的同时

00:34:27.067 --> 00:34:30.204 align:middle
显示GPU激活的准确时间

00:34:30.838 --> 00:34:33.473 align:middle
在本例中 你可以看到我的应用中

00:34:33.540 --> 00:34:37.844 align:middle
在顶点和片段着色器所用时间相对较少

00:34:38.145 --> 00:34:41.014 align:middle
实际上 这只是在显示器上

00:34:41.348 --> 00:34:43.650 align:middle
显示一帧内容所用时间的一小部分

00:34:45.118 --> 00:34:48.422 align:middle
注意这里只有两种颜色

00:34:48.989 --> 00:34:53.360 align:middle
这两种颜色代表着使用
双缓冲方案的两个缓冲器

00:34:54.428 --> 00:34:58.031 align:middle
如果应用在
Core Animation

00:34:58.098 --> 00:35:01.368 align:middle
和GPU中花费更多时间你会在这里

00:34:58.098 --> 00:35:01.368 align:middle
和GPU中花费更多时间你会在这里

00:35:01.635 --> 00:35:04.905 align:middle
看到三种颜色代表系统里
正在进行的三重缓冲

00:35:06.840 --> 00:35:09.776 align:middle
我们谈了很多降低延迟的内容

00:35:09.977 --> 00:35:13.213 align:middle
并让应用灵敏度更高不过最终

00:35:13.480 --> 00:35:16.884 align:middle
实现出色的iOS 体验是用户

00:35:16.950 --> 00:35:18.986 align:middle
自然和本能的体验

00:35:19.319 --> 00:35:23.457 align:middle
而让应用感觉更生动则是
实现这一目标的另一种不错的方法

00:35:24.491 --> 00:35:29.796 align:middle
去年 我们对系统的
每个部件都进行了认真的思考

00:35:29.863 --> 00:35:31.932 align:middle
想方设法使其比以前更快更好

00:35:32.699 --> 00:35:35.135 align:middle
在这一过程中我们改进了API

00:35:35.235 --> 00:35:37.638 align:middle
为大家提供更多控制和信息

00:35:37.738 --> 00:35:39.106 align:middle
来了解系统的运行状况

00:35:39.907 --> 00:35:43.277 align:middle
有了OpenGL Metal
和 Core Animation

00:35:43.377 --> 00:35:46.246 align:middle
的最新低延迟模式
你可以在向用户显示帧

00:35:46.380 --> 00:35:49.950 align:middle
以及如何与屏幕上的其他内容

00:35:50.017 --> 00:35:51.919 align:middle
同步的时候 实现更多控制

00:35:52.786 --> 00:35:56.323 align:middle
利用触控接合你可以利用

00:35:56.390 --> 00:35:58.792 align:middle
所有硬件及其所有出色的功能 向用户

00:35:59.126 --> 00:36:00.327 align:middle
提供出色体验

00:35:59.126 --> 00:36:00.327 align:middle
提供出色体验

00:36:00.627 --> 00:36:05.632 align:middle
使用触控预测我们可以让你
少许窥探未来预测触控即将往何处去

00:36:06.800 --> 00:36:10.270 align:middle
最后我们构建
并生成部分不错的工具

00:36:10.337 --> 00:36:15.042 align:middle
以便你了解应用的性能表现
这样你可以对之进行改进

00:36:15.242 --> 00:36:17.544 align:middle
以便向用户提供更好的体验

00:36:18.979 --> 00:36:21.782 align:middle
在Apple 我们致力于
让我们的产品

00:36:21.849 --> 00:36:24.685 align:middle
使用体验比以往更出色

00:36:24.751 --> 00:36:27.287 align:middle
我们认为通过降低
延迟是实现这一点的不错方法

00:36:27.621 --> 00:36:29.489 align:middle
我们愿意邀请各位朝这方面努力

00:36:29.556 --> 00:36:31.525 align:middle
大家在
developer.apple.com

00:36:31.592 --> 00:36:36.997 align:middle
可以了解到我们今天探讨的技术
工具和API等更多详情

00:36:37.364 --> 00:36:39.733 align:middle
我们还想邀请大家参加开发者

00:36:40.000 --> 00:36:43.537 align:middle
论坛中的开发者

00:36:43.971 --> 00:36:46.106 align:middle
技术对话

00:36:47.708 --> 00:36:50.577 align:middle
我们今天介绍了许多不同的新技术

00:36:50.944 --> 00:36:53.614 align:middle
今年和往年有过许多

00:36:53.680 --> 00:36:57.784 align:middle
与这一讲座相关话题的出色讨论

00:36:58.452 --> 00:37:03.257 align:middle
例如 如果你非常感兴趣简要
介绍应用的GPU性能

00:36:58.452 --> 00:37:03.257 align:middle
例如 如果你非常感兴趣简要
介绍应用的GPU性能

00:37:03.690 --> 00:37:07.261 align:middle
如果非常非常想着手尝试

00:37:07.327 --> 00:37:10.764 align:middle
新的GPU工具我将向大家推荐

00:37:10.831 --> 00:37:13.166 align:middle
《Metal性能优化技术》讲座

00:37:13.433 --> 00:37:16.503 align:middle
这是今天早些时候的一场讲座

00:37:17.137 --> 00:37:20.274 align:middle
其中介绍了一整套不同的技术

00:37:20.340 --> 00:37:23.844 align:middle
可以用来优化GPU运行
而不只是说使用Metal

00:37:25.179 --> 00:37:29.216 align:middle
此外如果Time Profiler
常出问题 可以试试去听

00:37:29.283 --> 00:37:32.986 align:middle
《深度剖析》讲座
这是昨天的一场讲座

00:37:33.487 --> 00:37:36.456 align:middle
其中深度剖析了该怎样
使用Time Profiler

00:37:36.523 --> 00:37:38.892 align:middle
并了解你的应用完成任务的情况

00:37:39.826 --> 00:37:41.862 align:middle
最后 如果大家的确感兴趣

00:37:41.929 --> 00:37:45.165 align:middle
在Core Animation和
管线的GPU阶段究竟在做些什么

00:37:45.232 --> 00:37:46.600 align:middle
这部分内容我们今天讲过

00:37:46.834 --> 00:37:48.802 align:middle
我将向大家推荐去年WWDC的

00:37:48.869 --> 00:37:51.371 align:middle
《高级图形和动画》讲座

00:37:52.606 --> 00:37:55.442 align:middle
所有这些讲座和许许多多其他讲座

00:37:55.509 --> 00:37:58.612 align:middle
都可以在开发人员门户网站找到
developer.apple.com

00:37:58.679 --> 00:38:02.282 align:middle
希望大家今天收获很多
在本周的全部环节中

00:37:58.679 --> 00:38:02.282 align:middle
希望大家今天收获很多
在本周的全部环节中

00:38:02.349 --> 00:38:05.719 align:middle
我希望大家喜欢WWDC的内容

00:38:05.786 --> 00:38:06.520 align:middle
谢谢
