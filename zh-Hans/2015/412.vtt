WEBVTT

00:00:19.786 --> 00:00:25.292 align:middle
深入分析

00:00:27.861 --> 00:00:28.695 align:middle
谢谢

00:00:31.565 --> 00:00:33.367 align:middle
谢谢 我是查德·伍尔夫

00:00:33.634 --> 00:00:34.735 align:middle
我是克里斯·马克尔

00:00:35.035 --> 00:00:37.271 align:middle
我们是苹果的性能工具工程师

00:00:37.704 --> 00:00:39.506 align:middle
这是会议412

00:00:39.573 --> 00:00:41.208 align:middle
我们会深入谈一下“分析”

00:00:42.910 --> 00:00:46.380 align:middle
也就是谈一下Instruments
中的时间分析器以及如何用它

00:00:46.446 --> 00:00:49.149 align:middle
来优化你的应用程序

00:00:50.317 --> 00:00:52.886 align:middle
当你想要找出你的应用程序
把大部分时间都花在哪里了

00:00:52.953 --> 00:00:56.089 align:middle
的时候你就可以求助于时间分析器

00:00:56.290 --> 00:00:57.124 align:middle
举个例子

00:00:58.425 --> 00:01:00.027 align:middle
当你试图查明应用程序在

00:00:58.425 --> 00:01:00.027 align:middle
当你试图查明应用程序在

00:01:00.093 --> 00:01:02.629 align:middle
运行时间内做了什么事时
时间分析器就会非常有用

00:01:02.696 --> 00:01:04.364 align:middle
你想看到具体调用情况

00:01:05.999 --> 00:01:08.202 align:middle
我们的会议会这样分成若干部分

00:01:08.268 --> 00:01:11.138 align:middle
我们将会谈谈为什么我们
想要举办一场专门针对

00:01:11.205 --> 00:01:13.707 align:middle
时间分析器的会议的动机

00:01:15.042 --> 00:01:18.245 align:middle
不过会议会以向你们演示
展示它的工作原理的细节

00:01:18.345 --> 00:01:22.349 align:middle
你的应用程序在源代码级别

00:01:22.416 --> 00:01:25.886 align:middle
以下的工作原理为中心

00:01:27.487 --> 00:01:30.090 align:middle
最后我们会就你们如何
自行使用时间分析器

00:01:30.224 --> 00:01:31.225 align:middle
给你们一些小窍门

00:01:31.291 --> 00:01:34.161 align:middle
首先快速谈谈我们的动机这次会议是受

00:01:34.228 --> 00:01:36.129 align:middle
“Instruments 7”的
直接启发

00:01:36.697 --> 00:01:38.899 align:middle
“Instruments 7”的
目的是展示新的外观新的感觉

00:01:38.966 --> 00:01:41.368 align:middle
它意味着新的工艺图
并且还意味着我们想让这种

00:01:41.435 --> 00:01:46.573 align:middle
新感觉更具响应性想让
这种新感觉更流畅

00:01:46.740 --> 00:01:50.143 align:middle
我们会从在各个方面对
我们的UI进行优化

00:01:51.445 --> 00:01:53.213 align:middle
我们还想尝试新的图形风格

00:01:53.280 --> 00:01:55.916 align:middle
我们过去就想尝试新的图形风格

00:01:55.983 --> 00:02:00.554 align:middle
但是我们现有的图形代码的性能不足

00:01:55.983 --> 00:02:00.554 align:middle
但是我们现有的图形代码的性能不足

00:02:02.022 --> 00:02:04.258 align:middle
我们知道我们不得不
把注意力放在渲染上面

00:02:04.758 --> 00:02:07.961 align:middle
因为它是应用中的一块硬骨头

00:02:08.027 --> 00:02:10.964 align:middle
Instruments必须处理
成百上千

00:02:11.031 --> 00:02:14.268 align:middle
有时候甚至是数以百万的数据点
Instruments必须把这些

00:02:14.868 --> 00:02:18.505 align:middle
处理成一个非常容易理解的表达

00:02:18.805 --> 00:02:21.175 align:middle
那里的算法复杂性
毫无疑问就很高了

00:02:22.676 --> 00:02:25.779 align:middle
对于我们来说 这就意味着
我们必须对我们的应用程序中

00:02:25.846 --> 00:02:29.750 align:middle
特别重要的一部分进行重写也就是对
位于app顶部的轨迹视图进行重写

00:02:31.118 --> 00:02:35.322 align:middle
整个冬季 克里斯和我拿出了
新的轨迹视图的设计

00:02:35.956 --> 00:02:38.458 align:middle
开始根据一系列的原型进行构建

00:02:38.959 --> 00:02:41.361 align:middle
我们并没有在Instruments中
直接生成原型

00:02:41.428 --> 00:02:43.830 align:middle
而是为了简单起见 把它拆分
到了一个单独的应用程序中

00:02:44.665 --> 00:02:47.935 align:middle
这就是我们最近的一个原型的样子

00:02:49.403 --> 00:02:51.839 align:middle
当我们生成原型时
我们做了一件事 我们设置了

00:02:51.905 --> 00:02:53.207 align:middle
一项“性能预算”

00:02:53.874 --> 00:02:55.309 align:middle
当我们分层堆放功能特性的

00:02:55.375 --> 00:02:58.378 align:middle
时候 我们会依据这项
“预算” 不断地对

00:02:58.445 --> 00:03:00.948 align:middle
我们的代码的性能进行评估

00:02:58.445 --> 00:03:00.948 align:middle
我们的代码的性能进行评估

00:03:01.815 --> 00:03:04.818 align:middle
当我们超出了“预算”时
我们就会借助于时间分析器

00:03:04.885 --> 00:03:08.255 align:middle
看看到底是我们的
应用程序的哪一部分出了问题

00:03:09.523 --> 00:03:12.993 align:middle
有时候很容易就可以修复
而有时候则不然

00:03:13.727 --> 00:03:14.928 align:middle
因为我们生成的是原型

00:03:15.195 --> 00:03:17.197 align:middle
所以即使我们需要进行一些
大的结构改变才能把

00:03:17.264 --> 00:03:20.100 align:middle
性能拉回正道这也是相当容易的

00:03:21.602 --> 00:03:24.338 align:middle
当我们把它集成回
Instruments时

00:03:24.638 --> 00:03:26.106 align:middle
我们会再次借助于时间分析器

00:03:26.206 --> 00:03:28.876 align:middle
找出我们的集成点中的“热点”

00:03:29.009 --> 00:03:32.546 align:middle
这样经过几次迭代后我们最终
得到了Instruments 7

00:03:32.613 --> 00:03:34.281 align:middle
这个版本实现了我们的性能目标

00:03:35.315 --> 00:03:38.051 align:middle
时间分析器帮助我们
“熬过”了这个冬天

00:03:38.118 --> 00:03:40.921 align:middle
为此我们兴奋不已
因此当苹果全球开发者大会

00:03:40.988 --> 00:03:45.325 align:middle
来临时 我们想开一次会议
谈谈时间分析器

00:03:45.659 --> 00:03:47.528 align:middle
谈谈它善于解决哪些问题

00:03:48.629 --> 00:03:52.900 align:middle
我们想要和你们分享
我们写轨迹视图时的经验

00:03:54.001 --> 00:03:58.505 align:middle
我们今年所做的就是在iOS上
创建了一个演示应用程序

00:03:59.173 --> 00:04:02.643 align:middle
它和轨迹视图的第一个原型看起来很像

00:03:59.173 --> 00:04:02.643 align:middle
它和轨迹视图的第一个原型看起来很像

00:04:03.544 --> 00:04:06.613 align:middle
我们也给自己设定了性能目标

00:04:06.680 --> 00:04:10.317 align:middle
我们想要绘制十万个数据点

00:04:11.084 --> 00:04:15.222 align:middle
我们想要平移和缩放的帧速
为完美的每秒钟六十帧

00:04:15.989 --> 00:04:18.825 align:middle
我们还想让它支持
第一代iPad mini

00:04:19.493 --> 00:04:22.062 align:middle
我们选择第一代iPad mini
的原因是...

00:04:22.696 --> 00:04:24.464 align:middle
你知道我说的是什么...

00:04:24.531 --> 00:04:27.734 align:middle
如果它能支持第一代iPad
mini 那么它在其它的平台上

00:04:27.801 --> 00:04:30.737 align:middle
尤其是后面的平台上
也就没问题

00:04:30.804 --> 00:04:32.439 align:middle
克里斯会向你们展示这个应用程序

00:04:32.706 --> 00:04:36.777 align:middle
他会对它进行时间剖析
他会向你们展示把这些东西

00:04:36.844 --> 00:04:39.580 align:middle
组合到一起时我们发现了什么东西

00:04:41.081 --> 00:04:45.285 align:middle
谢谢 查德 这里我有
Xcode的原型应用程序

00:04:45.586 --> 00:04:48.055 align:middle
我想点出几样东西

00:04:48.121 --> 00:04:51.191 align:middle
当我们初步实现时
我们发现 我们根本就处理

00:04:51.258 --> 00:04:52.826 align:middle
不了不到十万个的数据点

00:04:53.160 --> 00:04:55.963 align:middle
一开始 我们先从一万个数据点开始

00:04:56.396 --> 00:04:59.733 align:middle
还有一点也很重要
你应该在你的发版构建上进行

00:04:59.800 --> 00:05:02.569 align:middle
时间剖析因为你肯定想在你进行

00:04:59.800 --> 00:05:02.569 align:middle
时间剖析因为你肯定想在你进行

00:05:02.636 --> 00:05:05.906 align:middle
剖析时 把编译器的优化利用起来

00:05:06.540 --> 00:05:09.510 align:middle
我要开始剖析应用程序了

00:05:09.710 --> 00:05:12.813 align:middle
我要从产品菜单中选择“剖析”

00:05:13.580 --> 00:05:16.483 align:middle
这样就会构建应用程序
把它安装到iPad上

00:05:16.817 --> 00:05:18.952 align:middle
并且显示出
Instrument模板用户

00:05:19.586 --> 00:05:22.089 align:middle
这里 时间分析器已经为我们选择好了

00:05:22.656 --> 00:05:24.057 align:middle
我要点击“选择”

00:05:24.491 --> 00:05:27.227 align:middle
这里 你可以在我们的轨迹
视图中看到Instruments

00:05:27.461 --> 00:05:29.296 align:middle
我们过一会儿再回来看这个

00:05:29.363 --> 00:05:31.265 align:middle
现在我要开始录制了

00:05:31.732 --> 00:05:35.169 align:middle
点击“录制”按钮
我们向你展示了app

00:05:35.235 --> 00:05:39.239 align:middle
我想要强调下 你们在这里
看到的 这个并不是模拟器

00:05:39.306 --> 00:05:43.010 align:middle
这是QuickTime对app上已有的
东西进行的镜像

00:05:43.810 --> 00:05:48.515 align:middle
这是我们的图表我要开始滚动

00:05:49.183 --> 00:05:52.686 align:middle
滚动没有什么不好
我要通过收聚进行缩小

00:05:53.220 --> 00:05:56.390 align:middle
刚开始还不错不过之后就开始卡了

00:05:56.924 --> 00:05:58.025 align:middle
这可不太妙

00:05:58.792 --> 00:06:02.196 align:middle
最后我要用我的手指进行

00:05:58.792 --> 00:06:02.196 align:middle
最后我要用我的手指进行

00:06:02.262 --> 00:06:04.064 align:middle
前后滚动我正在移动我的手指

00:06:04.131 --> 00:06:07.668 align:middle
但是显示器并没有更新太卡了

00:06:08.202 --> 00:06:10.504 align:middle
性能表现太糟糕了

00:06:11.238 --> 00:06:12.873 align:middle
我们来看看发生了什么

00:06:13.140 --> 00:06:15.642 align:middle
让我们回到Xcode中
回到Instruments中

00:06:15.809 --> 00:06:16.777 align:middle
我们把分析器停下来

00:06:16.910 --> 00:06:19.313 align:middle
快速让你们看看新的轨迹视图

00:06:19.713 --> 00:06:21.682 align:middle
这里我们看到了CPU使用情况

00:06:22.082 --> 00:06:24.384 align:middle
它指的是在某个特定的时间单位内

00:06:24.585 --> 00:06:26.320 align:middle
平均的CPU使用情况

00:06:26.620 --> 00:06:28.722 align:middle
这里的时间单位取决于
你当前的缩放程度

00:06:29.122 --> 00:06:31.458 align:middle
当我使用我的app时
你可以看到不同的部分

00:06:31.925 --> 00:06:33.360 align:middle
那里消耗的时间是不同的

00:06:33.427 --> 00:06:37.798 align:middle
这是滚动 这是缩小这是
缩小时进行前后滚动

00:06:38.265 --> 00:06:41.401 align:middle
关于轨迹视图 还有一点
很棒 就是我可以使用这个

00:06:41.468 --> 00:06:47.207 align:middle
缩小手势来放大我感兴趣的某段数据

00:06:47.774 --> 00:06:50.878 align:middle
如果你用的不是Trackpad
那么你可以按住选项键

00:06:50.978 --> 00:06:54.481 align:middle
上下滚动来进行放大和缩小

00:06:55.115 --> 00:06:57.718 align:middle
我想看看这段特定的数据

00:06:57.885 --> 00:06:59.720 align:middle
就是这里的这个活动

00:07:00.020 --> 00:07:01.388 align:middle
刚才我在这里进行了滚动

00:07:01.455 --> 00:07:05.592 align:middle
为此我要使用一个过滤器
只需单击并拖动

00:07:06.260 --> 00:07:11.265 align:middle
就可以把那些特定的样例给选中
这样我就可以专注于

00:07:11.331 --> 00:07:12.566 align:middle
那个特定的数据

00:07:13.567 --> 00:07:16.370 align:middle
我要在下面这里创建更多的空白

00:07:17.070 --> 00:07:19.339 align:middle
下面这里是我们的详细视图

00:07:19.940 --> 00:07:22.676 align:middle
它可以向我们显示
我们在某个特定的函数

00:07:22.743 --> 00:07:27.481 align:middle
或者方法内拥有的时间分析器的
样本百分比的数量

00:07:27.748 --> 00:07:28.815 align:middle
这样我们就有了符号名

00:07:28.882 --> 00:07:31.852 align:middle
这是我们的百分比这是我们的符号

00:07:32.386 --> 00:07:37.124 align:middle
当你进行时间剖析时你通常所做的
第一件事是把这个扩展开来

00:07:37.591 --> 00:07:42.563 align:middle
然后查看某种...
在这里对数字进行对比

00:07:42.629 --> 00:07:45.098 align:middle
这里是具体的方法函数

00:07:45.432 --> 00:07:48.035 align:middle
看看突出来的是什么类型的情况

00:07:48.402 --> 00:07:50.504 align:middle
你知道的那些值得你进行
调查的情况会显示出来

00:07:50.871 --> 00:07:53.740 align:middle
还有一个选项 如果我们
认真看看检查器窗格

00:07:54.174 --> 00:07:58.612 align:middle
点击扩展开的细节 我们就能
看到最厚重的堆栈踪迹

00:07:59.146 --> 00:08:00.247 align:middle
这是针对主线程的

00:07:59.146 --> 00:08:00.247 align:middle
这是针对主线程的

00:08:00.681 --> 00:08:03.984 align:middle
当我进行时间剖析希望提高性能时

00:08:04.051 --> 00:08:08.255 align:middle
我就会关注这里因为
这里是最物有所值的

00:08:08.822 --> 00:08:10.290 align:middle
我们来看看发生了什么

00:08:10.457 --> 00:08:14.428 align:middle
主线程调用了应用程序的
主线程 进行循环

00:08:14.828 --> 00:08:18.298 align:middle
核心动画开始工作了

00:08:21.268 --> 00:08:27.574 align:middle
没有什么异常情况发生

00:08:28.075 --> 00:08:31.245 align:middle
实际上这就是剖析时常见的事

00:08:31.345 --> 00:08:33.780 align:middle
你想看看应用程序最常干的事情是什么

00:08:34.214 --> 00:08:36.850 align:middle
但是看起来它并没有做什么特别的事情

00:08:36.917 --> 00:08:38.485 align:middle
那里什么也没有

00:08:38.552 --> 00:08:41.655 align:middle
没有要求在这里计算第四十个斐
波纳契数也没有做什么其它异常的事

00:08:42.456 --> 00:08:45.425 align:middle
但是 你知道的看看这个调用栈

00:08:45.492 --> 00:08:48.829 align:middle
看看这个堆栈踪迹
我知道了我的应用程序做了什么事

00:08:48.896 --> 00:08:52.032 align:middle
这是一个简单的原型
app它的作用就是

00:08:52.099 --> 00:08:54.434 align:middle
构建一个路径并且绘制一个路径

00:08:55.369 --> 00:08:58.972 align:middle
实际上 我能够看到这里有一个
调用一个CG环境路径

00:08:59.239 --> 00:09:02.409 align:middle
它没有被我的代码根据堆栈踪迹调用到

00:08:59.239 --> 00:09:02.409 align:middle
它没有被我的代码根据堆栈踪迹调用到

00:09:02.743 --> 00:09:05.078 align:middle
就在这里占据了很大一块时间

00:09:05.145 --> 00:09:07.047 align:middle
我要点击下那个看看它

00:09:07.881 --> 00:09:09.850 align:middle
如果我们看看我们的调用树

00:09:10.417 --> 00:09:12.219 align:middle
我就可以看到一些有趣的事

00:09:12.286 --> 00:09:14.855 align:middle
我们可以看到根据这个调用树

00:09:14.922 --> 00:09:16.690 align:middle
这个绘制路径会被这个

00:09:16.757 --> 00:09:19.092 align:middle
绘制分层法在UI试图上调用

00:09:19.626 --> 00:09:24.264 align:middle
它还会为图形视图调用我们的
drawRect

00:09:24.765 --> 00:09:26.767 align:middle
这占据了大量的时间

00:09:26.834 --> 00:09:29.536 align:middle
这就是app所做的其中一件事

00:09:29.937 --> 00:09:34.374 align:middle
如果我看看这里的那个时间
环境绘制路径占据了

00:09:34.541 --> 00:09:38.812 align:middle
你知道 样本的55%但是这个
drawRect占据的却非常少

00:09:39.379 --> 00:09:42.549 align:middle
这就很有趣了
如果我在drawRect方法上

00:09:42.616 --> 00:09:45.052 align:middle
右击下我就可以看到源代码

00:09:45.686 --> 00:09:47.821 align:middle
我知道了如果你看看底部那里

00:09:47.955 --> 00:09:51.592 align:middle
我就可以从drawRect方法上
调用绘制路径

00:09:52.059 --> 00:09:55.128 align:middle
但是在哪个样例中都显示不出来

00:09:55.429 --> 00:09:58.432 align:middle
只是在添加路径

00:09:58.699 --> 00:10:01.635 align:middle
这可不太寻常

00:09:58.699 --> 00:10:01.635 align:middle
这可不太寻常

00:10:01.702 --> 00:10:04.738 align:middle
因为我的预期是我的
drawRect方法

00:10:04.805 --> 00:10:05.906 align:middle
运行需要一段时间

00:10:06.540 --> 00:10:08.275 align:middle
它只是我的app完成的一半

00:10:08.709 --> 00:10:10.644 align:middle
看这个我注意到

00:10:11.078 --> 00:10:12.579 align:middle
drawRect返回了一个空白

00:10:12.846 --> 00:10:16.350 align:middle
最后调用的方法是环境绘制路径

00:10:16.950 --> 00:10:20.521 align:middle
这可能就是所谓的“尾部调用消除”

00:10:21.388 --> 00:10:25.259 align:middle
查德会给大家讲讲什么是
“尾部调用消除”

00:10:25.325 --> 00:10:27.227 align:middle
以及如何对它进行验证

00:10:30.464 --> 00:10:34.168 align:middle
好的 要解释刚才克里斯看到的情况

00:10:34.234 --> 00:10:39.173 align:middle
我们就需要理解时间分析器是怎样
知道在你的应用程序内调用什么的

00:10:40.040 --> 00:10:42.743 align:middle
这个的技术含量就比较高了
我会一步一步向你们讲解

00:10:44.411 --> 00:10:48.148 align:middle
左边是drawRect的代码
右边则和你想象的堆栈

00:10:48.215 --> 00:10:54.588 align:middle
在UIKit调用drawRect
之前为那个线程找到的一样

00:10:56.290 --> 00:10:57.858 align:middle
当向drawRect进行调用时

00:10:58.025 --> 00:11:01.261 align:middle
和大多数函数 方法所做的事情一样

00:10:58.025 --> 00:11:01.261 align:middle
和大多数函数 方法所做的事情一样

00:11:01.328 --> 00:11:02.863 align:middle
它会建立自己的调用帧

00:11:03.864 --> 00:11:07.768 align:middle
它会首先推送链路寄存器以及堆栈上的

00:11:07.868 --> 00:11:11.705 align:middle
帧指针的上一个值的返回地址

00:11:12.039 --> 00:11:16.376 align:middle
现在drawRect知道了怎样返回
它的调用程序怎样恢复帧指针

00:11:18.078 --> 00:11:21.515 align:middle
下一件发生的事是我们
得到帧指针设置成新的基础

00:11:23.317 --> 00:11:26.320 align:middle
然后drawRect会给它的
局部变量

00:11:26.386 --> 00:11:28.455 align:middle
编译程序的暂存空间腾出空间

00:11:28.522 --> 00:11:30.357 align:middle
现在我们有了一个
drawRect的帧

00:11:31.325 --> 00:11:34.494 align:middle
现在代码开始运行了
我们到绘制路径那里

00:11:35.796 --> 00:11:39.166 align:middle
绘制路径做的事也相同
它把自己的帧推送到了堆栈上

00:11:40.400 --> 00:11:43.437 align:middle
时间分析器的工作方式
就是在内核中使用一项服务

00:11:43.737 --> 00:11:47.207 align:middle
以每秒1000x的速度对
CPU所做的事进行采样

00:11:48.408 --> 00:11:50.511 align:middle
在这个例子中如果我们采一次样

00:11:50.911 --> 00:11:53.280 align:middle
我们就可以看到 我们是在
环境绘制路径中运行的

00:11:54.381 --> 00:11:58.252 align:middle
然后内核会看下帧指针寄存器

00:11:58.318 --> 00:12:01.488 align:middle
看看函数帧的基础在哪里

00:11:58.318 --> 00:12:01.488 align:middle
看看函数帧的基础在哪里

00:12:01.822 --> 00:12:03.657 align:middle
然后找到调用它的程序的返回地址

00:12:04.291 --> 00:12:08.362 align:middle
现在我们可以看到那个
drawRect是在绘制路径中调用

00:12:09.263 --> 00:12:11.098 align:middle
如果我们想看看drawRect中

00:12:11.632 --> 00:12:14.268 align:middle
调用了什么我们就可以使用我们推送到

00:12:15.035 --> 00:12:17.004 align:middle
堆栈上的帧指针来找到
drawRect的基础

00:12:17.237 --> 00:12:20.507 align:middle
然后继续返回堆栈直到我们到达底部

00:12:21.108 --> 00:12:22.242 align:middle
这就是一次回溯

00:12:22.876 --> 00:12:25.212 align:middle
如果我们有足够的回溯
并且把它们放到

00:12:25.279 --> 00:12:29.183 align:middle
调用树视图你就可以搞清楚在你的
应用程序内发生了什么

00:12:30.083 --> 00:12:32.152 align:middle
我想指出一点堆栈上的帧指针

00:12:32.319 --> 00:12:34.021 align:middle
是绝对必须的

00:12:34.421 --> 00:12:37.424 align:middle
如果你编译代码时
关闭了fomit-frame-pointer

00:12:37.524 --> 00:12:41.428 align:middle
想要进行和我们这里一样的时间剖析

00:12:42.996 --> 00:12:44.531 align:middle
让我们看看这个优化实例

00:12:44.598 --> 00:12:46.967 align:middle
启用编辑器优化后drawRect

00:12:47.034 --> 00:12:48.402 align:middle
就是进行编译的

00:12:49.303 --> 00:12:51.271 align:middle
同样地我们有一个drawRect帧

00:12:51.738 --> 00:12:53.273 align:middle
我们要准备调用绘制路径了

00:12:54.074 --> 00:12:57.578 align:middle
你可以注意到 当绘制路径
返回drawRect时就完成了

00:12:57.744 --> 00:12:58.779 align:middle
什么也不需要做

00:12:59.279 --> 00:13:00.214 align:middle
它就会返回回来

00:12:59.279 --> 00:13:00.214 align:middle
它就会返回回来

00:13:00.280 --> 00:13:03.050 align:middle
它返回时会弹出堆栈结构

00:13:03.483 --> 00:13:06.086 align:middle
恢复帧指针的上一个值

00:13:06.520 --> 00:13:07.788 align:middle
然后回到调用程序

00:13:09.022 --> 00:13:11.191 align:middle
编译器看到这个后会想

00:13:11.458 --> 00:13:17.397 align:middle
为什么绘制路径需要用到
drawRect的堆栈结构的东西？

00:13:18.398 --> 00:13:20.834 align:middle
明明不需要的
此外返回它的调用程序时

00:13:20.901 --> 00:13:23.270 align:middle
为什么要返回drawRect？

00:13:23.871 --> 00:13:27.374 align:middle
那么它就会把代码重新整理成这样

00:13:27.674 --> 00:13:30.811 align:middle
它会弹出堆栈结构恢复帧指针

00:13:30.878 --> 00:13:34.248 align:middle
然后直接向绘制路径进行回调

00:13:34.414 --> 00:13:36.149 align:middle
这就意味着我们无需再跳回调用程序了

00:13:36.984 --> 00:13:39.686 align:middle
解释这个要比让你们直接看到更困难

00:13:39.753 --> 00:13:42.422 align:middle
让我们想象一下 当运行
这个代码时它会是什么样的

00:13:43.524 --> 00:13:46.059 align:middle
我们会弹出堆栈结构去掉局部变量

00:13:47.060 --> 00:13:49.329 align:middle
我们会把帧指针恢复成初始值

00:13:49.463 --> 00:13:50.864 align:middle
链路寄存器的值

00:13:51.665 --> 00:13:54.668 align:middle
然后我们跳回绘制路径代码的开头

00:13:55.536 --> 00:13:58.739 align:middle
绘制路径会使用它在
链路寄存器中找到的值

00:13:59.306 --> 00:14:02.843 align:middle
帧指针中找到的值把它
自己的帧推送回堆栈

00:13:59.306 --> 00:14:02.843 align:middle
帧指针中找到的值把它
自己的帧推送回堆栈

00:14:03.610 --> 00:14:07.080 align:middle
从绘制路径的透视图中它会直接在

00:14:07.147 --> 00:14:09.149 align:middle
UIKit的环境中
从绘制层上得到调用

00:14:09.950 --> 00:14:11.685 align:middle
此时如果我们进行一次时间采样

00:14:12.119 --> 00:14:13.754 align:middle
我们就可以看到同样的情况

00:14:15.022 --> 00:14:16.890 align:middle
即使发生的不是实际的调用序列

00:14:16.957 --> 00:14:19.092 align:middle
时间分析器看到的就是这样

00:14:19.660 --> 00:14:22.963 align:middle
我们在我们的调用树上
最后看到的就是这个

00:14:23.564 --> 00:14:25.966 align:middle
这就叫“尾部调用消除”
在高度优化的代码上

00:14:26.033 --> 00:14:29.203 align:middle
很常见也有一些好处

00:14:30.804 --> 00:14:31.972 align:middle
它能够节省堆栈内存

00:14:32.806 --> 00:14:35.242 align:middle
节省堆栈内存时
它会让缓存保持“热度”

00:14:35.309 --> 00:14:38.045 align:middle
然后重新利用内存缓存和数据

00:14:39.179 --> 00:14:42.749 align:middle
它对递归代码有着深刻影响

00:14:42.816 --> 00:14:45.919 align:middle
尤其是尾部调用递归代码
在那里 一个函数或者方法

00:14:45.986 --> 00:14:48.355 align:middle
会最后调用自身然后返回回来

00:14:49.223 --> 00:14:52.893 align:middle
无需推送这些帧一个递归函数内的

00:14:53.093 --> 00:14:56.463 align:middle
尾部调用消除
就可以让性能和迭代版本

00:14:56.530 --> 00:15:00.200 align:middle
一样好所以堆栈就不会增长

00:14:56.530 --> 00:15:00.200 align:middle
一样好所以堆栈就不会增长

00:15:00.267 --> 00:15:01.735 align:middle
并且性能也很优秀

00:15:02.536 --> 00:15:06.406 align:middle
这个优化也能兼容高度递归代码

00:15:07.140 --> 00:15:09.109 align:middle
如果为了剖析你想把它关掉

00:15:09.176 --> 00:15:11.111 align:middle
显示一个更清晰的堆栈踪迹

00:15:12.145 --> 00:15:15.315 align:middle
你就可以到项目的构建设置中把它关掉

00:15:15.782 --> 00:15:17.684 align:middle
并且把编辑器标志

00:15:17.751 --> 00:15:20.787 align:middle
从CFLAGS设置成
FNO-optimize-sibling-calls

00:15:20.854 --> 00:15:22.122 align:middle
关掉优化

00:15:22.422 --> 00:15:24.625 align:middle
不幸的是性能同时也会受到影响

00:15:25.092 --> 00:15:27.394 align:middle
但是这样你可以在时间分析器
中得到更好一个的结果

00:15:28.562 --> 00:15:31.131 align:middle
如果你选择忍受它
你想要知道是否发生了

00:15:31.298 --> 00:15:34.768 align:middle
尾部调用消除那么你该怎么做？

00:15:34.835 --> 00:15:38.405 align:middle
你可以看看反汇编调用最后调用的情况

00:15:39.473 --> 00:15:41.942 align:middle
如果是个普通的调用
那么它会使用指令的

00:15:42.009 --> 00:15:44.711 align:middle
一个分支和家族链接
那里是第一个实例

00:15:45.746 --> 00:15:47.614 align:middle
那就意味着它会跳到新函数

00:15:47.681 --> 00:15:50.117 align:middle
并且在链路寄存器内保存返回的值

00:15:51.318 --> 00:15:54.021 align:middle
如果是一个尾部调用
并且我们需要直接跳到

00:15:54.087 --> 00:15:59.893 align:middle
直接跳到新函数内 那么
它就是一个直接的分支指令没有BL

00:16:00.561 --> 00:16:04.665 align:middle
那就是一个指令和链路的调用指令

00:16:04.731 --> 00:16:06.600 align:middle
分支就是一个转移指令

00:16:06.733 --> 00:16:09.102 align:middle
如果你看看它你会发现很眼熟

00:16:10.137 --> 00:16:14.741 align:middle
现在就由克里斯来决定了
他可以禁用优化 重新编译

00:16:14.808 --> 00:16:17.444 align:middle
或者他也可以继续由你决定

00:16:18.412 --> 00:16:20.747 align:middle
我要看看反汇编

00:16:20.814 --> 00:16:24.885 align:middle
在Instruments详细视图的
右上角那里

00:16:24.952 --> 00:16:28.055 align:middle
有一个按钮
查看反汇编 如果我点击下

00:16:28.622 --> 00:16:30.858 align:middle
我就可以看到那个方法的反汇编

00:16:31.091 --> 00:16:35.395 align:middle
我们就可以确认添加路径
环境调用是一个分支和链路

00:16:35.929 --> 00:16:39.166 align:middle
环境调用绘制路径是一个简单的分支

00:16:39.600 --> 00:16:42.669 align:middle
我确信这是一个尾部调用消除的例子

00:16:43.036 --> 00:16:48.442 align:middle
我在调用树上看到的55%的
调用都不属于我的drawRect

00:16:48.509 --> 00:16:51.345 align:middle
它们本来应该属于
我的drawRect

00:16:51.845 --> 00:16:53.447 align:middle
这是个好消息

00:16:53.514 --> 00:16:57.951 align:middle
现在我知道了drawRect就是
我的最重的堆栈结构

00:16:58.018 --> 00:16:59.052 align:middle
我的最重的堆栈踪迹

00:16:59.453 --> 00:17:02.456 align:middle
消耗了我55%到60%的时间

00:16:59.453 --> 00:17:02.456 align:middle
消耗了我55%到60%的时间

00:17:02.723 --> 00:17:04.724 align:middle
很好 我知道应该优化哪里了

00:17:04.892 --> 00:17:07.594 align:middle
我要优化drawRect开始吧

00:17:08.395 --> 00:17:09.930 align:middle
我们来看看这个drawRect

00:17:11.231 --> 00:17:14.867 align:middle
看看这个drawRect 如果
有张桌子的话我早就掀了

00:17:15.702 --> 00:17:17.971 align:middle
优化的地方不多

00:17:18.172 --> 00:17:20.440 align:middle
很难想出一个能用的更简单的

00:17:20.674 --> 00:17:22.075 align:middle
但是又能用的drawRect

00:17:22.175 --> 00:17:28.015 align:middle
我们有四个函数调用 环境
你知道的 CG调用

00:17:28.515 --> 00:17:30.584 align:middle
这个drawRect
没有起到多少作用

00:17:31.251 --> 00:17:33.720 align:middle
那么这个实际上就是进行剖析时

00:17:33.787 --> 00:17:35.389 align:middle
一个很常见的事

00:17:36.657 --> 00:17:41.762 align:middle
你看了下自己的“热点”和代码

00:17:42.062 --> 00:17:45.799 align:middle
发现你没有多少能直接在
代码中进行修改

00:17:45.999 --> 00:17:47.334 align:middle
提高你的性能的地方

00:17:48.068 --> 00:17:50.404 align:middle
你知道 这个节点你该做什么？

00:17:51.305 --> 00:17:55.776 align:middle
你知道 除了掀桌子
晚上在枕头上嚎啕大哭之外

00:17:57.277 --> 00:18:01.715 align:middle
我们所做的事 就是仔细检查
开始查看核心图像文档以及其它绘图

00:17:57.277 --> 00:18:01.715 align:middle
我们所做的事 就是仔细检查
开始查看核心图像文档以及其它绘图

00:18:01.782 --> 00:18:03.517 align:middle
你知道 Cocoa绘图资料

00:18:04.184 --> 00:18:07.087 align:middle
我们无意中发现了这里的
这个特殊的属性

00:18:07.921 --> 00:18:09.823 align:middle
这是
drawsAsynchrously

00:18:10.123 --> 00:18:12.926 align:middle
你瞧！这是一个
“让我的代码更快”按钮

00:18:13.060 --> 00:18:17.064 align:middle
是一位苹果工程师创建的

00:18:19.066 --> 00:18:20.334 align:middle
非常棒

00:18:20.734 --> 00:18:23.103 align:middle
在那个上面 你可以看到

00:18:23.170 --> 00:18:25.272 align:middle
我从资料中复制出来粘贴都了那里

00:18:25.606 --> 00:18:27.541 align:middle
它说了几件有趣的事

00:18:27.608 --> 00:18:31.645 align:middle
首先它说 它可能提高性能
也可能不会提高性能

00:18:31.712 --> 00:18:32.846 align:middle
你应该衡量得失

00:18:33.614 --> 00:18:35.749 align:middle
你懂得 好了 爸爸

00:18:36.216 --> 00:18:37.117 align:middle
我们开始度量吧

00:18:37.317 --> 00:18:39.887 align:middle
我们看看这个能否提高性能

00:18:40.420 --> 00:18:43.156 align:middle
这次 要启动Instruments
我要给Instruments进行

00:18:43.223 --> 00:18:45.325 align:middle
运行command-I

00:18:45.726 --> 00:18:46.760 align:middle
它会做同样的事情

00:18:47.361 --> 00:18:50.531 align:middle
它会构建应用程序安装到设备上

00:18:51.198 --> 00:18:52.299 align:middle
显示出模板选择器

00:18:53.267 --> 00:18:54.368 align:middle
需要一点时间

00:18:55.802 --> 00:18:56.637 align:middle
还需要一点时间

00:18:57.771 --> 00:18:58.705 align:middle
还得再需要一点时间

00:18:59.173 --> 00:19:04.311 align:middle
好了 我还想使用另外一种
快捷方式 如果你看看下面的选择按钮

00:18:59.173 --> 00:19:04.311 align:middle
好了 我还想使用另外一种
快捷方式 如果你看看下面的选择按钮

00:19:04.945 --> 00:19:07.548 align:middle
如果我按住选择按钮
它就变成了“剖析”

00:19:07.981 --> 00:19:09.850 align:middle
这就意味着着
当我点击这个按钮时

00:19:10.150 --> 00:19:11.852 align:middle
应用程序就会开始录制

00:19:12.186 --> 00:19:13.787 align:middle
会替我省一两步

00:19:14.021 --> 00:19:15.055 align:middle
我现在点了

00:19:15.822 --> 00:19:18.625 align:middle
现在时间分析器出来了

00:19:19.092 --> 00:19:20.160 align:middle
会对app进行度量

00:19:20.627 --> 00:19:22.496 align:middle
我要快速进行一些前后滚动

00:19:22.563 --> 00:19:24.698 align:middle
捕捉一些数据

00:19:25.499 --> 00:19:26.333 align:middle
我想够了

00:19:26.400 --> 00:19:28.302 align:middle
让我们把录制停下来

00:19:28.769 --> 00:19:33.040 align:middle
我要进行过滤获得具体滚动数据

00:19:33.707 --> 00:19:35.843 align:middle
如果我们到下面这里看看细节视图

00:19:36.310 --> 00:19:37.711 align:middle
很有希望

00:19:37.945 --> 00:19:40.714 align:middle
实际上上你们可以看到这里有多个线程

00:19:40.881 --> 00:19:42.216 align:middle
线程正在发挥作用

00:19:42.683 --> 00:19:43.750 align:middle
这很好

00:19:43.851 --> 00:19:45.652 align:middle
如果我们继续如果我按住选项

00:19:45.986 --> 00:19:48.055 align:middle
点击提示三角符号
我就可以看到这个线程在

00:19:48.622 --> 00:19:52.092 align:middle
调用什么这是一些群调用

00:19:52.159 --> 00:19:53.493 align:middle
一些CG调用 很好

00:19:53.560 --> 00:19:54.628 align:middle
这就是绘制代码

00:19:55.195 --> 00:19:57.097 align:middle
我们继续一个接一个检查下

00:19:58.265 --> 00:19:59.266 align:middle
按住这个选项键

00:19:59.900 --> 00:20:02.202 align:middle
群调用 CG调用

00:19:59.900 --> 00:20:02.202 align:middle
群调用 CG调用

00:20:02.503 --> 00:20:04.738 align:middle
很好 这个看起来很有希望

00:20:05.239 --> 00:20:09.142 align:middle
我是多线程
理论上我的app应该更快了

00:20:10.043 --> 00:20:13.914 align:middle
但是 多线程并不一定意味着更快

00:20:13.981 --> 00:20:17.217 align:middle
我们应该确认它真的在帮我们做事

00:20:17.751 --> 00:20:21.755 align:middle
有一种方法可以确认 我碰巧
知道这台设备有两个CPU

00:20:22.122 --> 00:20:24.157 align:middle
如果CPU以最大性能

00:20:24.224 --> 00:20:28.662 align:middle
并行运行 那么我应该会看到
在我图表上面这里

00:20:29.096 --> 00:20:30.497 align:middle
看到200%的CPU使用情况

00:20:31.131 --> 00:20:33.634 align:middle
但是我看不到有超过100%的情况

00:20:33.700 --> 00:20:36.270 align:middle
那么这就是某种警告信号了
它并不一定意味着两个

00:20:36.537 --> 00:20:38.639 align:middle
CPU没有同时工作

00:20:39.039 --> 00:20:40.541 align:middle
它只是意味着我应该进一步检查下

00:20:41.074 --> 00:20:42.276 align:middle
那么我们怎样进一步检查？

00:20:42.609 --> 00:20:44.678 align:middle
Instruments就有我们称
之为“策略”的东西

00:20:44.745 --> 00:20:47.314 align:middle
它指的是对数据进行划分的
不同方法为的是查看数据

00:20:47.481 --> 00:20:48.415 align:middle
这里有三个

00:20:48.849 --> 00:20:51.451 align:middle
第一个是Instrument策略
即默认值

00:20:51.652 --> 00:20:52.553 align:middle
我们在这里看的就是

00:20:53.387 --> 00:20:55.289 align:middle
第二个是CPU策略

00:20:55.656 --> 00:20:58.926 align:middle
它显示的是每个CPU或者CPU
的数据 相关数据

00:20:59.826 --> 00:21:01.662 align:middle
最后一个是线程策略

00:20:59.826 --> 00:21:01.662 align:middle
最后一个是线程策略

00:21:01.962 --> 00:21:04.531 align:middle
它给你显示了每个线程
处理的细节情况

00:21:05.399 --> 00:21:07.467 align:middle
我们来看看CPU策略

00:21:08.569 --> 00:21:10.971 align:middle
我们可以看到我们拥有的每个CPU

00:21:11.038 --> 00:21:12.606 align:middle
我们可以看到它们做了多少功

00:21:12.673 --> 00:21:14.808 align:middle
在底部我们可以看到组合使用情况

00:21:15.242 --> 00:21:21.982 align:middle
这里有一件很棒的事可以做
当我放大的足够大

00:21:22.049 --> 00:21:24.251 align:middle
图表向我显示的细节就会发生变更

00:21:25.018 --> 00:21:27.387 align:middle
它就会显示那个CPU是
否处于活跃状态

00:21:27.721 --> 00:21:29.957 align:middle
而不再显示平均使用情况

00:21:30.023 --> 00:21:32.793 align:middle
它就会显示活跃或者不活跃
而不再显示平均使用情况

00:21:33.393 --> 00:21:37.130 align:middle
现在每个CPU都显示了一个
在线状态或者离线状态是否处于工作中

00:21:37.831 --> 00:21:41.535 align:middle
这里你可以注意到
CPU从来没有一起工作中

00:21:41.602 --> 00:21:44.438 align:middle
这里没有并行性

00:21:44.771 --> 00:21:48.642 align:middle
你懂得 这可不好

00:21:49.276 --> 00:21:53.146 align:middle
如果我们还想试试伤口撒盐
我们可以看看线程策略

00:21:54.181 --> 00:21:56.416 align:middle
它可以向我们显示每个图标

00:21:56.817 --> 00:22:00.120 align:middle
每个图标代表了时间分析器
采集的一个样本

00:21:56.817 --> 00:22:00.120 align:middle
每个图标代表了时间分析器
采集的一个样本

00:22:00.187 --> 00:22:02.222 align:middle
你可以点击 看看调用堆栈

00:22:02.623 --> 00:22:05.359 align:middle
这里的这个是位于一个后台线程上

00:22:05.726 --> 00:22:08.161 align:middle
你可以看到核心图形调用这是主线程

00:22:08.228 --> 00:22:14.668 align:middle
你可以看到主线程...
我们在主线程上进行的工作

00:22:15.202 --> 00:22:17.204 align:middle
你可以看到 如果我放大到合适的程度

00:22:17.804 --> 00:22:18.972 align:middle
应该就是这里了我滚动下

00:22:19.339 --> 00:22:24.611 align:middle
你可以看到两个线程并没有
真的同时工作过

00:22:24.811 --> 00:22:27.314 align:middle
它是从一个线程跳到另一个线程

00:22:28.682 --> 00:22:34.354 align:middle
因此drawsAsynchronously
并没有真的为我们做什么事

00:22:34.421 --> 00:22:36.890 align:middle
从理论上来说它可能会拖慢我们

00:22:37.391 --> 00:22:42.429 align:middle
我们不仅进行了绘制而且还进行了管理

00:22:42.663 --> 00:22:45.065 align:middle
你懂得 核心图形系统
对它工作的线程进行了管理

00:22:45.132 --> 00:22:48.769 align:middle
类似这种的事情 并没有什么实质作用

00:22:49.903 --> 00:22:51.738 align:middle
我会把它关掉

00:22:53.006 --> 00:22:56.176 align:middle
我会再掀一张桌子

00:22:56.543 --> 00:22:59.780 align:middle
不很清晰神奇按钮没多大作用

00:23:00.547 --> 00:23:01.682 align:middle
我们现在该怎么做？

00:23:02.382 --> 00:23:05.485 align:middle
同样这也是时间剖析中
一个很常见的情况

00:23:06.320 --> 00:23:08.755 align:middle
你尝试了很多事但是大部分都不起作用

00:23:09.489 --> 00:23:11.625 align:middle
我们往回退一步

00:23:11.892 --> 00:23:12.726 align:middle
app会怎么做？

00:23:13.060 --> 00:23:15.128 align:middle
它构建了一条路径
然后描绘了一条路径

00:23:15.963 --> 00:23:17.364 align:middle
我们已经看过绘制路径代码了

00:23:17.431 --> 00:23:19.633 align:middle
我们来考虑下构建路径代码

00:23:19.933 --> 00:23:23.470 align:middle
就在这里

00:23:25.105 --> 00:23:29.109 align:middle
我们想做的事就是调查下
我们构建的实际路径

00:23:29.643 --> 00:23:32.613 align:middle
这个代码的作用就是循环数据元素

00:23:32.880 --> 00:23:35.949 align:middle
创建一条路径然后为每个
数据元素向那个路径中一行

00:23:36.250 --> 00:23:39.319 align:middle
我们想知道我们向那个路径中
添加了多少行

00:23:39.386 --> 00:23:42.122 align:middle
时间分析器就可以告诉我们这个信息

00:23:42.422 --> 00:23:44.291 align:middle
它不能告诉你某个特定的方法

00:23:44.558 --> 00:23:47.528 align:middle
函数被调用了多久被调用了多少次

00:23:48.228 --> 00:23:49.897 align:middle
它不知道一个被调用了仅仅

00:23:49.963 --> 00:23:52.266 align:middle
几次的慢函数同一个被调用了
很多次的快函数之间

00:23:52.332 --> 00:23:53.934 align:middle
有什么区别

00:23:54.535 --> 00:23:56.970 align:middle
在这个例子中 我们要借助于
NSLog 我们就可以实现

00:23:57.404 --> 00:24:01.341 align:middle
一个情况 即我们每次添加
一个路径 我们就放大计数器一次

00:23:57.404 --> 00:24:01.341 align:middle
一个情况 即我们每次添加
一个路径 我们就放大计数器一次

00:24:01.642 --> 00:24:05.312 align:middle
然后当我们循环结束时
我们就把它录入

00:24:05.679 --> 00:24:07.881 align:middle
重点要指出的是NSLog并不是一个

00:24:08.415 --> 00:24:10.617 align:middle
很快的函数

00:24:11.151 --> 00:24:13.387 align:middle
在高性能代码中你不会想让它出现的

00:24:13.520 --> 00:24:16.056 align:middle
除了收集诊断信息或者进行调试以外

00:24:16.123 --> 00:24:18.825 align:middle
你可能不会想用它做任何其它事情

00:24:19.393 --> 00:24:21.762 align:middle
当你用完后把它从代码中删掉

00:24:21.995 --> 00:24:23.897 align:middle
在这个例子中 我们仅仅添加
注释 这样你可以看到

00:24:24.665 --> 00:24:29.636 align:middle
我们发现 我们在例子中的
这个点这里添加了十万行

00:24:30.204 --> 00:24:32.506 align:middle
这是没有必要的

00:24:32.573 --> 00:24:36.076 align:middle
事实上 这台设备上无论如何
也显示不了十万行

00:24:37.110 --> 00:24:39.079 align:middle
尤其是当你缩的足够小所有的数据

00:24:39.146 --> 00:24:41.682 align:middle
就都需要适合一百个屏幕点

00:24:42.015 --> 00:24:44.251 align:middle
没理由在那里绘制十万行

00:24:44.318 --> 00:24:47.754 align:middle
我们绘制一百行就可以了

00:24:47.955 --> 00:24:48.956 align:middle
这样工作就少了很多

00:24:49.923 --> 00:24:54.127 align:middle
我们继续 创建一个执行来实现它

00:24:54.728 --> 00:24:58.065 align:middle
如果是多个数据元素
数据点位于一个单一的

00:24:58.165 --> 00:25:01.368 align:middle
屏幕点那么它就会找出最大值

00:24:58.165 --> 00:25:01.368 align:middle
屏幕点那么它就会找出最大值

00:25:01.435 --> 00:25:02.669 align:middle
绘制一条单一的行

00:25:03.136 --> 00:25:07.341 align:middle
如果我们使用一百个屏幕点
我们就会创建一百个屏幕行

00:25:08.408 --> 00:25:11.378 align:middle
我们来切换到那个执行

00:25:12.312 --> 00:25:14.481 align:middle
我们对它的感觉很好

00:25:14.581 --> 00:25:18.352 align:middle
我们把元素数量的上限改成了十万

00:25:18.418 --> 00:25:20.621 align:middle
而不是一万

00:25:21.488 --> 00:25:23.790 align:middle
我们看看这对我们是否有帮助

00:25:25.559 --> 00:25:29.630 align:middle
我要使用command-I来启动
Instruments

00:25:30.030 --> 00:25:31.899 align:middle
因为Instruments已经打开了
它就会把它弄到

00:25:31.965 --> 00:25:35.369 align:middle
前台立即开始录制

00:25:37.004 --> 00:25:38.872 align:middle
好了 一个新的录制

00:25:39.540 --> 00:25:43.243 align:middle
我们来滚动下滚动看起来没问题

00:25:44.478 --> 00:25:45.846 align:middle
我再缩小下

00:25:46.747 --> 00:25:49.216 align:middle
缩放性能也有了非常大的提高

00:25:49.383 --> 00:25:52.085 align:middle
需要的时间更多
因为我要缩小的数据更多了

00:25:52.853 --> 00:25:54.054 align:middle
看起来真的很好

00:25:54.888 --> 00:25:56.623 align:middle
我要进行前后滑动

00:25:56.690 --> 00:25:59.226 align:middle
现在它能很好地追踪我的手指了

00:25:59.726 --> 00:26:02.696 align:middle
它能跟得上我的手指真棒

00:25:59.726 --> 00:26:02.696 align:middle
它能跟得上我的手指真棒

00:26:04.031 --> 00:26:05.799 align:middle
万岁！都搞定了！

00:26:07.601 --> 00:26:09.536 align:middle
还差一点

00:26:11.038 --> 00:26:12.506 align:middle
当我们前后滚动时

00:26:12.573 --> 00:26:15.108 align:middle
如果我们看一下我们使用的
CPU的实际数量

00:26:15.709 --> 00:26:18.345 align:middle
我们就可以看到 你懂得
有时候会降到60%

00:26:18.412 --> 00:26:20.180 align:middle
通常是七十到八十秒

00:26:21.048 --> 00:26:23.951 align:middle
从技术上说
我们实现了我们的性能目标

00:26:24.551 --> 00:26:27.454 align:middle
我们要做的
我们接下来要对这个app

00:26:27.721 --> 00:26:28.655 align:middle
原型做什么？

00:26:28.722 --> 00:26:30.591 align:middle
我们添加了一些附加特性

00:26:31.191 --> 00:26:36.263 align:middle
我们知道我们需要比这里更多的净空

00:26:36.997 --> 00:26:42.169 align:middle
我们怎样能让它更快？
我们怎样能让这个app更好？

00:26:42.236 --> 00:26:44.338 align:middle
我们怎样实现性能目标？

00:26:45.405 --> 00:26:46.940 align:middle
我们专注下这个

00:26:47.441 --> 00:26:48.675 align:middle
我们来过滤下那个数据

00:26:50.143 --> 00:26:52.579 align:middle
我要给我自己一点空间

00:26:53.180 --> 00:26:55.282 align:middle
在这个例子中我要按住选项键

00:26:56.250 --> 00:26:57.985 align:middle
点击“主要”把它展开

00:26:58.085 --> 00:27:02.222 align:middle
我就可以到这里看到这里的这个方法

00:26:58.085 --> 00:27:02.222 align:middle
我就可以到这里看到这里的这个方法

00:27:02.890 --> 00:27:06.460 align:middle
你懂得 现在绘制路径就足够快了

00:27:06.527 --> 00:27:11.198 align:middle
反而是构建路径成了瓶颈

00:27:12.266 --> 00:27:14.701 align:middle
我想关注下这个方法

00:27:15.035 --> 00:27:16.436 align:middle
我要点击下“聚焦”按钮

00:27:16.803 --> 00:27:21.708 align:middle
它会把方法中的所有事情移动到一边

00:27:21.775 --> 00:27:26.480 align:middle
把这个方法中

00:27:27.080 --> 00:27:29.082 align:middle
我们的百分比标准化

00:27:29.149 --> 00:27:33.587 align:middle
这个方法把55%的时间用在了
获取下个元素上

00:27:34.221 --> 00:27:38.892 align:middle
把10到11%的时间用在了
objc msgSend上

00:27:39.560 --> 00:27:42.930 align:middle
关于objc msgSend
我知道的是

00:27:42.996 --> 00:27:45.299 align:middle
它是一个超快的方法

00:27:45.365 --> 00:27:46.733 align:middle
它是经过极致优化的

00:27:47.134 --> 00:27:51.438 align:middle
但是如果我能把那个10%
拿回来 我还是想要

00:27:52.539 --> 00:27:58.445 align:middle
如果我们看看我们代码里面
我们就可以看到它已经

00:27:58.512 --> 00:27:59.646 align:middle
很干净了

00:27:59.713 --> 00:28:03.383 align:middle
我们大部分的时间都花在了
获取下个元素上

00:27:59.713 --> 00:28:03.383 align:middle
我们大部分的时间都花在了
获取下个元素上

00:28:04.084 --> 00:28:06.787 align:middle
这里的这个百分比 要比
树状视图中的略微高一点

00:28:07.120 --> 00:28:09.690 align:middle
因为它包括了
objc msgSend的时间

00:28:10.090 --> 00:28:14.795 align:middle
如果我把它去掉
这个迭代程序就更快了

00:28:15.128 --> 00:28:19.366 align:middle
希望我就可以实现我想要的性能提升

00:28:19.600 --> 00:28:23.103 align:middle
请查德给我们讲讲如何实现这一点

00:28:26.106 --> 00:28:29.042 align:middle
我们来谈谈objc msgSend

00:28:30.410 --> 00:28:35.148 align:middle
无论你何时使用方括号符号

00:28:35.349 --> 00:28:37.951 align:middle
无论你何时使用点符号
来访问一个对象的属性

00:28:38.552 --> 00:28:41.822 align:middle
编辑器就会把它隐式插入

00:28:43.156 --> 00:28:46.026 align:middle
它的目的是查找选择器的实现方法

00:28:46.093 --> 00:28:48.662 align:middle
然后调用那个方法

00:28:49.029 --> 00:28:51.598 align:middle
我们如何在Objective-C中
进行动态分派

00:28:51.665 --> 00:28:52.799 align:middle
要讲的东西还很多

00:28:54.101 --> 00:28:59.139 align:middle
Objc msgSend非常快
也不会推送堆栈结构

00:28:59.773 --> 00:29:02.376 align:middle
当你看你的时间剖析时

00:28:59.773 --> 00:29:02.376 align:middle
当你看你的时间剖析时

00:29:02.576 --> 00:29:04.311 align:middle
通常来说你不会看到它的效果

00:29:05.412 --> 00:29:08.549 align:middle
你能看到它的时机
就是在一个完美的例子中

00:29:08.615 --> 00:29:11.451 align:middle
就像我们在我们的
迭代程序中看到的那样

00:29:11.518 --> 00:29:15.088 align:middle
我们要做的就是迭代超过十万个点

00:29:15.155 --> 00:29:19.359 align:middle
用一个小的方法主体
称之为“获得下一个方法”

00:29:19.426 --> 00:29:21.428 align:middle
只需增加一对值返回一个结构即可

00:29:22.529 --> 00:29:26.200 align:middle
那么接下来要发生的
就是Objective-C消息发送

00:29:26.266 --> 00:29:30.070 align:middle
开销时间会积累到一个可测量的程度

00:29:31.405 --> 00:29:34.074 align:middle
是否有方法可以避开开销呢？

00:29:35.442 --> 00:29:37.544 align:middle
不一定

00:29:38.212 --> 00:29:41.181 align:middle
Objective-C从设计上
就是一种动态语言

00:29:41.481 --> 00:29:43.851 align:middle
要访问对象和类的方法你就必须

00:29:44.117 --> 00:29:47.454 align:middle
进行objc msgSend调用

00:29:48.255 --> 00:29:52.025 align:middle
每次它都会这样做
因为你可以在运行时间

00:29:52.092 --> 00:29:53.694 align:middle
转换方法执行

00:29:54.161 --> 00:29:57.631 align:middle
Objective-C内没有
编译时间

00:29:57.698 --> 00:29:59.600 align:middle
比如说我想调用这个特殊的方法主体

00:30:00.534 --> 00:30:04.505 align:middle
这里唯一的异常是 如果
你进行所谓的“方法缓存”

00:30:04.905 --> 00:30:07.307 align:middle
你可以自己查找方法执行

00:30:07.774 --> 00:30:09.543 align:middle
然后通过函数指针调用它

00:30:10.244 --> 00:30:12.846 align:middle
一般来说我不推荐你们这么做

00:30:13.347 --> 00:30:15.282 align:middle
你可以想象的到它很脆弱

00:30:15.782 --> 00:30:20.687 align:middle
一般来说 根据我的经验它没有给过
我期望的性能你得想想我们起初

00:30:21.255 --> 00:30:23.757 align:middle
到这里的目的是什么

00:30:24.124 --> 00:30:28.028 align:middle
我们到这里的原因获得下个
元素方法有一个小的方法主体

00:30:28.729 --> 00:30:31.565 align:middle
即使你通过函数指针调用它
你也必须对自变量

00:30:31.632 --> 00:30:34.234 align:middle
进行整理把帧推送到堆栈上

00:30:34.301 --> 00:30:35.936 align:middle
并且在你完成后把它们弹出来

00:30:36.803 --> 00:30:38.839 align:middle
你们在上一组幻灯片中看到的正是这个

00:30:38.906 --> 00:30:42.142 align:middle
开销可能会很大增加后会再返回

00:30:43.177 --> 00:30:47.781 align:middle
我想要指出的是方法缓存并不像

00:30:47.848 --> 00:30:49.449 align:middle
直接插入那样快在这个例子中

00:30:49.516 --> 00:30:53.120 align:middle
我们真正想实现的是
直接插入那个小的方法主体

00:30:54.488 --> 00:30:56.390 align:middle
我们在Objective-C中
该怎样实现？

00:30:56.790 --> 00:30:59.059 align:middle
你还有其它选项

00:30:59.159 --> 00:31:01.461 align:middle
首先 你本来应该用 C

00:30:59.159 --> 00:31:01.461 align:middle
首先 你本来应该用 C

00:31:02.396 --> 00:31:04.398 align:middle
你本来应该用结构而不是一个

00:31:04.464 --> 00:31:08.001 align:middle
迭代程序举例来说 你可以向这个
方法中传递一个C线

00:31:08.702 --> 00:31:13.640 align:middle
如果你想要那个OO特点
你可以使用C++

00:31:14.274 --> 00:31:16.210 align:middle
你在Objective-C中使用
C++的方法

00:31:16.276 --> 00:31:18.679 align:middle
是把文件从a .m
重命名为a .mm

00:31:18.879 --> 00:31:20.714 align:middle
然后你就可以使用C++语法

00:31:21.448 --> 00:31:23.183 align:middle
因为通常Arc是默认打开的

00:31:23.350 --> 00:31:27.487 align:middle
然后你取出Objective-C
对象把它们放进

00:31:27.955 --> 00:31:32.025 align:middle
STL容器内把它们放到
你的类和结构的实体变量中

00:31:33.126 --> 00:31:37.231 align:middle
这很方便
你也可以得到C++的性能好处

00:31:37.297 --> 00:31:39.766 align:middle
我在Instruments中大量用它
以便在轨迹视图

00:31:39.833 --> 00:31:45.272 align:middle
以及Instruments
其它关键的地方尽可能地快

00:31:46.039 --> 00:31:50.110 align:middle
根据我的亲身经验
这个有一个主要的下降趋势

00:31:50.677 --> 00:31:53.313 align:middle
你需要提前知道
你的代码的哪一部分会

00:31:53.614 --> 00:31:56.783 align:middle
从C++中受益
哪一部分代码会从

00:31:57.317 --> 00:31:59.820 align:middle
Objective-C中受益

00:32:00.487 --> 00:32:02.956 align:middle
有时候像我们在演示示例中那样

00:32:03.156 --> 00:32:05.826 align:middle
你可能在那里犯错误
并且直到进行剖析才意识到

00:32:06.193 --> 00:32:07.594 align:middle
我们是用Objective-C
写了我们的

00:32:07.661 --> 00:32:11.832 align:middle
Objective-C没有意识到
它在我们的时间剖析中有多慢

00:32:12.900 --> 00:32:17.538 align:middle
除了我刚刚提到的这些
你还有其它更好的选项吗？

00:32:19.006 --> 00:32:23.210 align:middle
当然了 你知道的已经有了

00:32:26.580 --> 00:32:29.183 align:middle
Swift非常完美因为不像
Objective-C

00:32:29.249 --> 00:32:31.652 align:middle
Swift只有在注释为动态时
它才是动态的

00:32:32.386 --> 00:32:35.989 align:middle
如果你确保性能关键类是内部的

00:32:36.056 --> 00:32:39.760 align:middle
并且使用整体模块优化

00:32:39.860 --> 00:32:43.130 align:middle
编译器或者整体工具链
就可以确定何时只有

00:32:43.430 --> 00:32:45.199 align:middle
一个方法执行

00:32:45.432 --> 00:32:49.369 align:middle
并且把它内联到调用点
让你的性能有明显的提升

00:32:49.436 --> 00:32:52.940 align:middle
尤其是对迭代程序这个例子

00:32:53.607 --> 00:32:56.944 align:middle
因为我们是在生成原型
在Swift的视图控制器中

00:32:57.010 --> 00:32:59.413 align:middle
重写迭代程序就非常容易了

00:32:59.947 --> 00:33:01.181 align:middle
克里斯之前干过这个

00:32:59.947 --> 00:33:01.181 align:middle
克里斯之前干过这个

00:33:02.850 --> 00:33:09.623 align:middle
我有一个Swift执行已经就绪了

00:33:10.057 --> 00:33:14.862 align:middle
这是Objective-C执行的
一个简易的接口

00:33:14.928 --> 00:33:17.164 align:middle
采用了他们在今天上午的
会议上提出的关于...

00:33:18.665 --> 00:33:22.269 align:middle
...优化Swift代码的几点建议

00:33:22.636 --> 00:33:24.805 align:middle
具体来说就是打开整体模块优化

00:33:25.506 --> 00:33:28.342 align:middle
让我们来剖析下这个
Command-I

00:33:29.042 --> 00:33:29.877 align:middle
它会开始构建

00:33:30.711 --> 00:33:33.480 align:middle
安装到设备上

00:33:34.081 --> 00:33:36.350 align:middle
它会开始进行剖析

00:33:39.052 --> 00:33:42.823 align:middle
好的 我要把应用程序提前
这样你们就能看到

00:33:44.124 --> 00:33:45.292 align:middle
这是滚动

00:33:45.926 --> 00:33:47.060 align:middle
看起来不错

00:33:48.295 --> 00:33:49.162 align:middle
缩小

00:33:49.696 --> 00:33:51.298 align:middle
好了

00:33:51.932 --> 00:33:52.766 align:middle
缩小

00:33:53.033 --> 00:33:54.201 align:middle
非常棒 非常快

00:33:54.368 --> 00:33:55.936 align:middle
要缩小很多数据

00:33:57.671 --> 00:34:02.075 align:middle
现在 如果我前后移动
它移动的就非常快了

00:33:57.671 --> 00:34:02.075 align:middle
现在 如果我前后移动
它移动的就非常快了

00:34:03.911 --> 00:34:04.745 align:middle
太棒了

00:34:06.647 --> 00:34:09.349 align:middle
谢谢 实际上我们可以到这里

00:34:09.416 --> 00:34:11.385 align:middle
看看CPU使用情况

00:34:11.818 --> 00:34:15.022 align:middle
你懂得我们取得的优化超过了

00:34:15.088 --> 00:34:19.193 align:middle
我们的预期去掉
objc msgSend

00:34:19.259 --> 00:34:23.797 align:middle
我们本来预期会
有5到6%的提升 这个有点低

00:34:25.132 --> 00:34:28.402 align:middle
如果我关掉这个提示三角符号
你就可以看到

00:34:28.902 --> 00:34:31.572 align:middle
它们两个以此运行 你可以
看到之前的运行更低...

00:34:31.972 --> 00:34:37.010 align:middle
当前的运行很明显更低

00:34:37.643 --> 00:34:39.580 align:middle
事实上如果我到这儿

00:34:39.646 --> 00:34:44.150 align:middle
查找我的构建路径方法
现在我就必须进行搜索

00:34:44.384 --> 00:34:45.652 align:middle
这就是你进行搜索的方法

00:34:46.954 --> 00:34:50.424 align:middle
如果我点击command-F
这个对话就会显示出来

00:34:50.991 --> 00:34:53.827 align:middle
我可以输入构建路径

00:34:54.995 --> 00:34:58.899 align:middle
它会在这里给我显示我的方法

00:34:59.967 --> 00:35:03.670 align:middle
如果我们看看这个 你就可以
在这里看到我的Swift代码

00:34:59.967 --> 00:35:03.670 align:middle
如果我们看看这个 你就可以
在这里看到我的Swift代码

00:35:04.204 --> 00:35:07.674 align:middle
我的获得下一个调用就在这里

00:35:08.175 --> 00:35:09.810 align:middle
没有在任何样例中显示出来

00:35:14.214 --> 00:35:15.749 align:middle
你懂得没有样例包括了这个

00:35:16.116 --> 00:35:19.186 align:middle
为什么？因为Swift能够把它内联

00:35:19.820 --> 00:35:22.322 align:middle
鞭子意味着这里没有函数开销

00:35:22.389 --> 00:35:24.191 align:middle
没有方法调用开销等等

00:35:24.258 --> 00:35:28.595 align:middle
因为迭代程序的代码
和其余的代码是内联的

00:35:28.662 --> 00:35:32.132 align:middle
它就有了进一步优化
这就解释了出现比我们预期的

00:35:32.199 --> 00:35:34.034 align:middle
更高的性能的原因

00:35:34.668 --> 00:35:37.638 align:middle
它是忽略了动态调度

00:35:39.006 --> 00:35:42.042 align:middle
查德 你还有什么想对大家说的么？

00:35:43.744 --> 00:35:44.878 align:middle
当然了 我们还剩五分钟！

00:35:47.581 --> 00:35:50.751 align:middle
当你自行探索Instruments时
这里有一些小窍门

00:35:51.385 --> 00:35:55.722 align:middle
首先要指出的是在录制设置下面

00:35:56.190 --> 00:35:57.624 align:middle
叫做“录制等待线程”

00:35:58.058 --> 00:35:59.293 align:middle
我提到过我们使用样例

00:35:59.359 --> 00:36:01.528 align:middle
活跃CPU的服务和内核

00:35:59.359 --> 00:36:01.528 align:middle
活跃CPU的服务和内核

00:36:01.795 --> 00:36:04.097 align:middle
但是如果你有空闲的线程
被一个加锁阻塞或者等待

00:36:04.164 --> 00:36:07.134 align:middle
输入/输出
你就可以勾选这个复选框

00:36:07.467 --> 00:36:09.736 align:middle
服务就同样也会对空闲线程进行采样

00:36:10.370 --> 00:36:12.172 align:middle
如果你有代码和加锁争夺支配权

00:36:12.239 --> 00:36:14.741 align:middle
那么当你激活录制等待线程时

00:36:15.142 --> 00:36:17.711 align:middle
你会看到热区显示出来

00:36:18.946 --> 00:36:20.781 align:middle
我还发现了另外一件有趣的事

00:36:21.448 --> 00:36:25.886 align:middle
在“显示设置”中调用树那里

00:36:26.386 --> 00:36:27.454 align:middle
调用树被反转了过来

00:36:28.689 --> 00:36:31.658 align:middle
打个比喻就是它把调用树颠倒了过来

00:36:31.992 --> 00:36:36.096 align:middle
在树的底部节点看到的就不是叶子

00:36:36.196 --> 00:36:37.831 align:middle
那就是没有被调用到任何地方的函数

00:36:38.098 --> 00:36:38.966 align:middle
它们显示到了顶部

00:36:39.299 --> 00:36:42.302 align:middle
如果某个实用功能同时
被五六个地方调用了

00:36:42.636 --> 00:36:46.607 align:middle
你把调用树反转过来
看看到底是谁在调用

00:36:46.807 --> 00:36:48.375 align:middle
那个特定的函数

00:36:48.909 --> 00:36:51.211 align:middle
它给你提供了调用树上的
数据的一个不同的视角

00:36:51.979 --> 00:36:53.847 align:middle
当你在调用树上右键点击一个节点

00:36:54.548 --> 00:36:58.852 align:middle
你就可以看到环境菜单
这也是那里的一件有趣的事

00:36:59.086 --> 00:37:03.123 align:middle
我经常做的一件事就是给调用者记账

00:36:59.086 --> 00:37:03.123 align:middle
我经常做的一件事就是给调用者记账

00:37:03.423 --> 00:37:06.426 align:middle
那么你就可以给调用者的方法
记一笔欠函数的账

00:37:07.027 --> 00:37:10.130 align:middle
你可以给调用者记一笔欠
整个框架库的账

00:37:11.064 --> 00:37:14.635 align:middle
那里还有一个选项可以修剪子树

00:37:14.701 --> 00:37:16.904 align:middle
如果你当时不想处理某个具体的问题

00:37:16.970 --> 00:37:20.641 align:middle
你可以把它从数据上
修剪掉然后专注于你想专注的事情

00:37:22.543 --> 00:37:23.777 align:middle
我们从中学到了什么？

00:37:25.679 --> 00:37:29.583 align:middle
就是通过这个我要提醒你们的第一件事

00:37:29.917 --> 00:37:32.352 align:middle
就是提前合并性能目标

00:37:33.387 --> 00:37:35.455 align:middle
如果你像我们一样
进行了一个大的性能重写

00:37:35.522 --> 00:37:38.859 align:middle
你要首先设好预算然后对它进行监视

00:37:38.926 --> 00:37:41.428 align:middle
因为一旦你开始在它的顶部
分层放置大量的代码

00:37:41.495 --> 00:37:42.963 align:middle
要改变就很难了

00:37:44.431 --> 00:37:45.499 align:middle
其次 要经常进行度量

00:37:45.832 --> 00:37:48.535 align:middle
在我们的整个演示中我们用时间
分析器进行了时间剖析

00:37:48.602 --> 00:37:52.105 align:middle
我们用那个数据来找出“热区”

00:37:52.172 --> 00:37:56.076 align:middle
然后把它返回最后我们就
得到了一个运行良好的应用程序

00:37:56.610 --> 00:38:00.681 align:middle
如果你还是不明白 可能
你可能很幸运 直接点吧

00:37:56.610 --> 00:38:00.681 align:middle
如果你还是不明白 可能
你可能很幸运 直接点吧

00:38:01.081 --> 00:38:03.483 align:middle
我会从一个测量开始
然后把它当成领头羊来追随

00:38:05.152 --> 00:38:06.720 align:middle
第三 这个对我来说很重要

00:38:07.187 --> 00:38:09.022 align:middle
我鼓励你们深入挖掘下去

00:38:09.790 --> 00:38:11.558 align:middle
你第一眼看到的某些性能问题可能

00:38:11.625 --> 00:38:13.827 align:middle
看上去是无解的

00:38:14.294 --> 00:38:16.763 align:middle
你说别人的的代码中就出现过这种问题

00:38:16.830 --> 00:38:18.365 align:middle
或者是运行时间的副效应

00:38:19.166 --> 00:38:22.135 align:middle
我们给出你时间分析器
运行时间的详细资料的

00:38:22.202 --> 00:38:24.938 align:middle
原因给出你反汇编视图的样子

00:38:25.506 --> 00:38:29.176 align:middle
就是想向你们展示那是一个
细节丰富的一个完整的世界

00:38:29.443 --> 00:38:34.414 align:middle
用它你就可以像我们
今天一样解决性能问题

00:38:34.982 --> 00:38:38.619 align:middle
我鼓励你们带着创造性去
进一步挖掘

00:38:38.852 --> 00:38:40.854 align:middle
看看像这样的会议

00:38:40.988 --> 00:38:44.525 align:middle
我知道你们能够修复
问题 实现你们想要的性能目标

00:38:46.960 --> 00:38:48.896 align:middle
只要你今天开始干就行

00:38:49.263 --> 00:38:52.599 align:middle
史蒂芬·莱塞是我们的
开发工具福音传道者

00:38:52.666 --> 00:38:54.868 align:middle
如果你有问题的话就可以联系他

00:38:55.769 --> 00:39:00.641 align:middle
与我们相关的会议是
“能量调试问题”

00:38:55.769 --> 00:39:00.641 align:middle
与我们相关的会议是
“能量调试问题”

00:39:00.941 --> 00:39:03.644 align:middle
证明了如果你在CPU上的代码
是有效的 CPU耗能就会更低

00:39:03.810 --> 00:39:05.846 align:middle
那次会议是周三举行的

00:39:06.380 --> 00:39:09.917 align:middle
明天还会有一个关于iOS
以及Watch OS的会议

00:39:10.284 --> 00:39:13.287 align:middle
好消息是 时间分析器
也能用于watch上的app

00:39:13.353 --> 00:39:14.188 align:middle
这是一项大福利

00:39:14.821 --> 00:39:16.423 align:middle
祝你们在会议剩余的时间内过得愉快
