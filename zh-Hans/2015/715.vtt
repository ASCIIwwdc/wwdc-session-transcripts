WEBVTT

00:00:20.254 --> 00:00:24.958 align:middle
CloudKit技术讲座

00:00:30.030 --> 00:00:31.932 align:middle
<br/>
大家下午好 欢迎参加

00:00:31.999 --> 00:00:33.834 align:middle
CloudKit技术讲座

00:00:34.668 --> 00:00:36.570 align:middle
我是尼哈 沙尔曼

00:00:36.637 --> 00:00:38.172 align:middle
是CloudKit团队的工程师

00:00:39.072 --> 00:00:41.942 align:middle
我知道 你们一些人可能
对我们的平台十分陌生

00:00:42.242 --> 00:00:45.179 align:middle
而且是首次遇到
CloudKit框架

00:00:46.013 --> 00:00:48.715 align:middle
而其他一些人可能已经开发
一些APP并且在应用商店中上架

00:00:48.782 --> 00:00:51.051 align:middle
在本讲座 我们将介绍
一些对所有人都适用的技术

00:00:51.451 --> 00:00:52.286 align:middle
现在让我们开始

00:00:54.621 --> 00:00:55.822 align:middle
什么是CloudKit？

00:00:56.390 --> 00:00:58.892 align:middle
去年我们推出了CloudKit

00:00:58.959 --> 00:01:00.961 align:middle
<br/>
这是一种全新的方法

00:00:58.959 --> 00:01:00.961 align:middle
<br/>
这是一种全新的方法

00:01:01.028 --> 00:01:03.997 align:middle
让你能够与Apple的
iCloud数据库服务器对话

00:01:05.032 --> 00:01:05.966 align:middle
利用此功能

00:01:06.033 --> 00:01:08.635 align:middle
我们为你
提供一系列的内置技术

00:01:09.303 --> 00:01:10.504 align:middle
例如大文件存储等

00:01:12.272 --> 00:01:14.208 align:middle
我们提供隐私保护标识符

00:01:14.274 --> 00:01:16.443 align:middle
让你能够有效地管理

00:01:16.777 --> 00:01:19.012 align:middle
任何拥有iCloud帐户
的用户

00:01:21.215 --> 00:01:22.749 align:middle
首先也是最重要的

00:01:22.816 --> 00:01:25.853 align:middle
这是一个公开的开发者API

00:01:25.919 --> 00:01:28.689 align:middle
因为我们想希望你
利用这个平台的强大功能

00:01:28.755 --> 00:01:31.692 align:middle
为你的用户开发有用的APP

00:01:33.527 --> 00:01:35.329 align:middle
最后但并非不重要的事情是

00:01:35.395 --> 00:01:36.864 align:middle
<br/>
Apple大力投资

00:01:36.930 --> 00:01:37.764 align:middle
开发这项技术

00:01:38.131 --> 00:01:40.033 align:middle
仅在去年
当我们首次发布此项技术时

00:01:40.667 --> 00:01:41.502 align:middle
我们就去推出

00:01:41.568 --> 00:01:42.636 align:middle
一系列重要的客户端

00:01:42.703 --> 00:01:44.137 align:middle
包括iCloud drive

00:01:44.204 --> 00:01:46.173 align:middle
和iCloud
photo library

00:01:46.240 --> 00:01:48.041 align:middle
今年我们增加了一些新客户端

00:01:48.108 --> 00:01:50.711 align:middle
例如 Notes APP
News APP

00:01:51.311 --> 00:01:54.448 align:middle
和WWDC APP 本周
你们很多人使用过这些APP

00:01:54.748 --> 00:01:56.283 align:middle
而且你们的手机上还有这些APP

00:01:58.185 --> 00:01:59.753 align:middle
如果你不熟悉这些应用

00:02:00.220 --> 00:02:01.588 align:middle
我请你回顾一下

00:02:01.989 --> 00:02:03.423 align:middle
去年的开发大会上的

00:02:03.490 --> 00:02:04.825 align:middle
CloudKit讲座

00:02:04.892 --> 00:02:06.793 align:middle
和Advanced
CloudKit讲座

00:02:06.860 --> 00:02:09.263 align:middle
这些讲座详细地
介绍了新API

00:02:09.329 --> 00:02:11.164 align:middle
我强烈建议你去看看

00:02:12.466 --> 00:02:13.901 align:middle
我们来先讲重要的事情

00:02:13.967 --> 00:02:16.170 align:middle
你们很多人一直在使用

00:02:16.236 --> 00:02:18.872 align:middle
令人称道的Swift 2新功能

00:02:19.273 --> 00:02:22.342 align:middle
我很高兴宣布
对于iOS 9操作系统

00:02:22.409 --> 00:02:25.445 align:middle
在Swift中使用CloudKit
将会更加容易

00:02:26.480 --> 00:02:28.582 align:middle
让我们来通过一些例子

00:02:28.649 --> 00:02:29.583 align:middle
来深入了解

00:02:30.250 --> 00:02:34.288 align:middle
直到现在 当你在CK记录中
设置和获取值时 你还必须

00:02:34.354 --> 00:02:37.324 align:middle
使用陈旧的键值对象设置语法
使用对像语法设置键值

00:02:37.391 --> 00:02:40.327 align:middle
这些工作将由
CloudKit API来完成

00:02:40.394 --> 00:02:44.097 align:middle
但是在iOS 9中
在处理CK记录时

00:02:44.164 --> 00:02:46.567 align:middle
你可以使用更为熟悉和

00:02:46.767 --> 00:02:48.101 align:middle
现代的字典订阅语法

00:02:49.903 --> 00:02:52.739 align:middle
除此之外 我们还利用
库标识符和轻量级泛型

00:02:52.906 --> 00:02:56.410 align:middle
让你在Swift中编写的
CloudKit代码

00:02:56.610 --> 00:02:58.478 align:middle
和Objective-C代码

00:02:58.679 --> 00:02:59.746 align:middle
更不容易发生类型错误

00:03:00.414 --> 00:03:05.118 align:middle
以前你可能需要为记录设置
一组任意类型的对象

00:03:05.552 --> 00:03:09.056 align:middle
来确保安全和正确的
CKRecords运算

00:03:09.723 --> 00:03:13.994 align:middle
现在利用iOS 9中的最新工具

00:03:14.061 --> 00:03:16.663 align:middle
当你做这些工作时 编译器
会发出提醒 让你及早发现错误

00:03:16.964 --> 00:03:18.398 align:middle
编写更可靠的代码

00:03:21.001 --> 00:03:23.170 align:middle
对此 请我简要回顾

00:03:23.604 --> 00:03:25.305 align:middle
CloudKit存储架构

00:03:27.241 --> 00:03:31.144 align:middle
CloudKit的最顶层
称为CloudKit容器

00:03:32.613 --> 00:03:35.749 align:middle
它分为两个数据库

00:03:36.283 --> 00:03:37.284 align:middle
一个公用数据库

00:03:37.751 --> 00:03:40.587 align:middle
它是你的所有用户共享的

00:03:41.288 --> 00:03:43.123 align:middle
庞大APP数据

00:03:44.858 --> 00:03:46.326 align:middle
另一个私人数据库

00:03:46.393 --> 00:03:48.228 align:middle
仅供用户的iCloud帐户使用

00:03:48.929 --> 00:03:50.430 align:middle
这个数据库包含

00:03:50.497 --> 00:03:53.200 align:middle
特定iCloud帐户
跨越所有用户设备

00:03:53.267 --> 00:03:54.368 align:middle
所共享的数据

00:03:55.769 --> 00:03:59.373 align:middle
在每个数据库内
我们还有一个分层离

00:03:59.573 --> 00:04:01.041 align:middle
用于存储记录

00:03:59.573 --> 00:04:01.041 align:middle
用于存储记录

00:04:01.508 --> 00:04:03.110 align:middle
它们称为记录区

00:04:05.112 --> 00:04:07.948 align:middle
CloudKit使用这些数据库

00:04:08.015 --> 00:04:09.983 align:middle
为你存储在其中的记录
提供更多的功能

00:04:10.884 --> 00:04:13.687 align:middle
公用数据库有一个
称为默认区域的存储区域

00:04:13.754 --> 00:04:15.088 align:middle
用于存储所有记录

00:04:17.190 --> 00:04:20.226 align:middle
私有数据库也有一个默认区域

00:04:20.627 --> 00:04:23.163 align:middle
利用这一特性
你能够创建

00:04:23.230 --> 00:04:25.332 align:middle
多个自定义区域

00:04:25.732 --> 00:04:29.203 align:middle
这些区域可以为你的记录
提供更多的功能

00:04:31.438 --> 00:04:33.674 align:middle
让我来介绍

00:04:33.740 --> 00:04:35.943 align:middle
我们将在今天的讲座中
所要探讨的内容

00:04:37.611 --> 00:04:39.713 align:middle
你可能还记得 在去年
我们讨论了schema

00:04:39.847 --> 00:04:42.816 align:middle
我们介绍了一个APP的
示例schema

00:04:42.883 --> 00:04:44.685 align:middle
这个APP通过云端
将内容提供给各方

00:04:45.519 --> 00:04:48.388 align:middle
这里有一个简单的schema
其中有一个party记录类型

00:04:48.455 --> 00:04:50.924 align:middle
和clown记录类型
这两个类型的记录

00:04:51.758 --> 00:04:54.761 align:middle
存储在公用数据库之中
让我们来运行这个示例APP

00:04:55.729 --> 00:04:57.798 align:middle
并且为它开发更多的功能

00:04:58.298 --> 00:05:00.734 align:middle
我们将这个示例APP
称为clown central

00:04:58.298 --> 00:05:00.734 align:middle
我们将这个示例APP
称为clown central

00:05:00.801 --> 00:05:01.702 align:middle
因为它是关于小丑的

00:05:03.604 --> 00:05:05.239 align:middle
我们将使用一个示例来介绍

00:05:05.305 --> 00:05:07.040 align:middle
当你使用CloudKit
进行开发时

00:05:07.207 --> 00:05:09.009 align:middle
可以运用的经验和技巧

00:05:10.344 --> 00:05:12.279 align:middle
我们的APP有一个
简单的UI

00:05:12.346 --> 00:05:14.181 align:middle
在这个UI中

00:05:14.248 --> 00:05:16.884 align:middle
我们显示派对列表
在这个讲座中

00:05:16.950 --> 00:05:18.318 align:middle
我们将会介绍一系列的功能

00:05:20.120 --> 00:05:20.954 align:middle
现在

00:05:21.021 --> 00:05:24.224 align:middle
通过示例
我将会讨论四个主要方面的内容

00:05:25.692 --> 00:05:27.594 align:middle
第一个方面是错误处理

00:05:28.762 --> 00:05:29.863 align:middle
去年 我们曾经讲到过

00:05:29.930 --> 00:05:32.165 align:middle
CloudKit APP

00:05:32.232 --> 00:05:33.667 align:middle
是否处理错误

00:05:34.234 --> 00:05:36.770 align:middle
不仅关系到APP的好坏

00:05:37.137 --> 00:05:38.906 align:middle
甚至还决定APP是否

00:05:39.106 --> 00:05:40.440 align:middle
正常运行或者完全崩溃

00:05:41.041 --> 00:05:41.909 align:middle
的确是这样的

00:05:42.576 --> 00:05:45.546 align:middle
当你使用API时

00:05:45.612 --> 00:05:48.649 align:middle
你会遇到一组特殊的错误代码
我会讲解这些代码

00:05:49.116 --> 00:05:50.684 align:middle
并为你提供一些
一般性指导原则

00:05:50.884 --> 00:05:51.818 align:middle
告诉你如处理错误

00:05:53.387 --> 00:05:54.221 align:middle
对此

00:05:54.288 --> 00:05:56.356 align:middle
我们将会介绍
一系列的技术

00:05:56.423 --> 00:05:57.724 align:middle
你需要记住这些技术

00:05:57.791 --> 00:05:59.359 align:middle
当你维护本地缓存

00:05:59.660 --> 00:06:00.727 align:middle
进行CloudKit开发工作时
可以使用这些技术

00:05:59.660 --> 00:06:00.727 align:middle
进行CloudKit开发工作时
可以使用这些技术

00:06:02.029 --> 00:06:04.097 align:middle
然后我们将会讨论
如何设置订阅

00:06:04.164 --> 00:06:06.934 align:middle
以不断地更新缓存

00:06:07.634 --> 00:06:10.037 align:middle
最后我将介绍一系列的

00:06:10.103 --> 00:06:12.739 align:middle
通用性能技术你应该记住它们

00:06:12.806 --> 00:06:15.175 align:middle
并用于你的APP开发

00:06:16.944 --> 00:06:18.579 align:middle
因此我们将会讲解许多内容

00:06:18.645 --> 00:06:21.281 align:middle
现在让我们讲解错误处理

00:06:26.587 --> 00:06:29.623 align:middle
我首先要讨论的事项
是关于帐户的

00:06:30.824 --> 00:06:32.993 align:middle
CloudKit并不需要

00:06:33.060 --> 00:06:35.128 align:middle
你具有一个iCloud帐户

00:06:35.462 --> 00:06:38.932 align:middle
我们允许匿名只读
访问公用数据库

00:06:40.033 --> 00:06:41.935 align:middle
比如说 为了便于演示

00:06:42.002 --> 00:06:44.805 align:middle
clown central APP
将需要一个iCloud账户

00:06:46.206 --> 00:06:47.708 align:middle
我们将讨论一系列的功能

00:06:47.774 --> 00:06:50.844 align:middle
这些功能使用私有数据库

00:06:50.911 --> 00:06:52.779 align:middle
根据定义 将需要
一个通过身份验证的帐户

00:06:54.515 --> 00:06:56.049 align:middle
默认情况下 数据库写访问

00:06:56.116 --> 00:06:58.085 align:middle
需要一个帐户

00:07:00.554 --> 00:07:03.190 align:middle
需要注意的是
检查当前用户的

00:07:03.457 --> 00:07:05.959 align:middle
帐户状态的方法是
使用CK容器内可用的

00:07:06.026 --> 00:07:09.229 align:middle
完成处理API进行检查

00:07:11.832 --> 00:07:15.035 align:middle
在进行CloudKit开发时
由于身份验证而造成的错误

00:07:15.102 --> 00:07:16.403 align:middle
将会导致失败

00:07:16.470 --> 00:07:20.107 align:middle
并返回CKError
身份未验证错误代码

00:07:21.475 --> 00:07:23.744 align:middle
处理这种错误的一般性做法是

00:07:23.810 --> 00:07:25.045 align:middle
重新检查帐户状态

00:07:26.947 --> 00:07:29.249 align:middle
例如 缺少iCloud帐户

00:07:30.083 --> 00:07:31.518 align:middle
当你检查账户状态时

00:07:31.718 --> 00:07:34.488 align:middle
你会收到“无帐户”
CKAccount状态

00:07:36.356 --> 00:07:37.491 align:middle
在以前

00:07:37.558 --> 00:07:39.126 align:middle
你没有办法知道

00:07:39.393 --> 00:07:41.895 align:middle
因为帐户缺失而失败的请求

00:07:42.062 --> 00:07:43.297 align:middle
是否会继续

00:07:44.231 --> 00:07:45.532 align:middle
正因为如此

00:07:45.599 --> 00:07:47.668 align:middle
在iOS 9和
OS X El Capitan中

00:07:47.935 --> 00:07:50.470 align:middle
我们添加了CKAccount
变更通知

00:07:51.138 --> 00:07:54.975 align:middle
当用户帐户发生变更时

00:07:55.042 --> 00:07:57.144 align:middle
例如无登录或退出

00:07:57.444 --> 00:07:59.213 align:middle
或者iCloud
drive功能开关

00:07:59.279 --> 00:08:00.581 align:middle
被开启或关闭
将会发送此通知

00:07:59.279 --> 00:08:00.581 align:middle
被开启或关闭
将会发送此通知

00:08:02.850 --> 00:08:06.086 align:middle
为此 我想介绍一些
最佳实践方法

00:08:06.153 --> 00:08:08.322 align:middle
以处理APP中的账户缺失错误

00:08:10.290 --> 00:08:11.658 align:middle
一种看上去不错的方法是

00:08:11.725 --> 00:08:13.126 align:middle
<br/>
当遇到这种情况时

00:08:13.193 --> 00:08:14.928 align:middle
抛出一个警告

00:08:15.395 --> 00:08:17.264 align:middle
告诉用户他们没有登录iCloud

00:08:17.331 --> 00:08:18.832 align:middle
<br/>
因此不能继续

00:08:19.800 --> 00:08:21.535 align:middle
但是这对用户来说没有帮助作用

00:08:21.602 --> 00:08:23.470 align:middle
因为他们可能会忽略警告

00:08:24.004 --> 00:08:25.839 align:middle
重新尝试操作

00:08:25.906 --> 00:08:28.509 align:middle
从而会继续看到警告

00:08:29.576 --> 00:08:31.879 align:middle
我们建议的方法是

00:08:32.679 --> 00:08:35.048 align:middle
巧妙地设置你的UI

00:08:35.115 --> 00:08:38.684 align:middle
禁用需要帐户的功能

00:08:39.620 --> 00:08:41.822 align:middle
为此
你可以使用

00:08:41.889 --> 00:08:43.457 align:middle
CKAccount变更通知

00:08:43.590 --> 00:08:45.125 align:middle
当你收到此通知时

00:08:45.192 --> 00:08:46.126 align:middle
<br/>
应重新检查用户状态

00:08:46.193 --> 00:08:47.561 align:middle
查看帐户是否可用

00:08:47.628 --> 00:08:49.229 align:middle
如果可用 则重新启用UI

00:08:52.165 --> 00:08:53.600 align:middle
帐户缺失仅仅是

00:08:53.667 --> 00:08:59.039 align:middle
操作临时发生故障的
的原因之一

00:09:01.041 --> 00:09:03.177 align:middle
但是它可能在未来的
某个时间点发生

00:09:04.511 --> 00:09:06.980 align:middle
例如 在较差的
网络条件下

00:09:07.114 --> 00:09:09.883 align:middle
你可能遇到这种错误
CKError网络故障

00:09:11.318 --> 00:09:13.620 align:middle
或者CloudKit服务器忙时
也会发生这种错误

00:09:13.687 --> 00:09:14.988 align:middle
你可能会看到以下错误之一：

00:09:15.055 --> 00:09:16.323 align:middle
CKError服务不可用

00:09:16.990 --> 00:09:18.225 align:middle
或CKError区域忙

00:09:19.326 --> 00:09:21.995 align:middle
遇到这种错误时

00:09:22.629 --> 00:09:24.831 align:middle
你应该在稍后重试操作

00:09:26.099 --> 00:09:28.202 align:middle
但是你可能会想

00:09:28.435 --> 00:09:29.736 align:middle
我应该在何时重试这些操作？

00:09:30.537 --> 00:09:32.906 align:middle
你不需要猜想这个时间值

00:09:34.842 --> 00:09:37.144 align:middle
发生这些错误时
在我们发送给你的用户信息字典中

00:09:37.211 --> 00:09:40.314 align:middle
在“CKError retry
after key.”键值中

00:09:40.380 --> 00:09:41.949 align:middle
<br/>
有一个专用的值

00:09:42.983 --> 00:09:46.186 align:middle
这个值就是
在重新尝试操作之前

00:09:46.253 --> 00:09:48.522 align:middle
需要等待的时间 单位为秒

00:09:51.458 --> 00:09:53.460 align:middle
现在让我们来看一个
类似的例子

00:09:54.061 --> 00:09:57.130 align:middle
在这个例中 我们的APP
有一个bug

00:09:57.197 --> 00:09:58.599 align:middle
可能导致APP

00:09:58.866 --> 00:10:02.336 align:middle
在极短的时间内
向服务器发送大量更新

00:09:58.866 --> 00:10:02.336 align:middle
在极短的时间内
向服务器发送大量更新

00:10:03.270 --> 00:10:06.373 align:middle
如果这个APP始终这样做

00:10:06.440 --> 00:10:08.342 align:middle
而且许多用户触发这个bug

00:10:08.642 --> 00:10:10.410 align:middle
将会导致
iCloud服务器崩溃

00:10:11.078 --> 00:10:12.412 align:middle
为了避免这种问题

00:10:12.713 --> 00:10:13.780 align:middle
我们需要使用一个

00:10:13.847 --> 00:10:16.650 align:middle
名为CKErrorRequest
RateLimited的

00:10:16.717 --> 00:10:17.684 align:middle
专用错误代码

00:10:19.019 --> 00:10:20.721 align:middle
CloudKit利用这种方法

00:10:20.787 --> 00:10:22.222 align:middle
避免APP bug造成

00:10:22.289 --> 00:10:24.157 align:middle
iCloud服务器崩溃

00:10:26.159 --> 00:10:29.263 align:middle
如果请求数量达到限值

00:10:29.329 --> 00:10:31.365 align:middle
在一定的时间期限内

00:10:31.565 --> 00:10:33.467 align:middle
将不发送请求给服务器

00:10:34.168 --> 00:10:35.936 align:middle
那么这个时间期限是多少呢？

00:10:36.737 --> 00:10:39.339 align:middle
系统通过“CKErrorretry
afterkey”

00:10:39.406 --> 00:10:40.307 align:middle
来告知这个时间期限

00:10:42.476 --> 00:10:44.111 align:middle
因此 当你遇到这种错误时

00:10:44.711 --> 00:10:47.114 align:middle
请在用户错误信息字典中
查找这个键值

00:10:47.481 --> 00:10:50.050 align:middle
请等待一定时间
然后重试你的请求

00:10:51.985 --> 00:10:54.154 align:middle
现在我想介绍
你可能会遇到的

00:10:54.221 --> 00:10:55.989 align:middle
另一种不同类别的错误

00:10:56.857 --> 00:10:58.959 align:middle
这类错误是由于
schema设计方式造成的

00:10:59.026 --> 00:10:59.860 align:middle
具体地说

00:10:59.927 --> 00:11:02.129 align:middle
如果你的schema
允许多个用户更新

00:10:59.927 --> 00:11:02.129 align:middle
如果你的schema
允许多个用户更新

00:11:04.231 --> 00:11:06.700 align:middle
Cloud数据库中的同一条记录
就可能发生这类错误

00:11:07.734 --> 00:11:10.370 align:middle
假设我们想要为APP
增加一项功能

00:11:10.671 --> 00:11:12.005 align:middle
从而允许用户

00:11:12.472 --> 00:11:13.974 align:middle
将他们自己添加到派对之中

00:11:16.009 --> 00:11:16.910 align:middle
但是不幸的是

00:11:16.977 --> 00:11:18.879 align:middle
在设计此APP的schema之前

00:11:18.946 --> 00:11:21.548 align:middle
我们并没有参加去年的
关于高级CloudKit的讲座

00:11:23.083 --> 00:11:24.618 align:middle
这是我们设计的schema

00:11:25.853 --> 00:11:27.621 align:middle
对于派对记录本身

00:11:27.688 --> 00:11:28.755 align:middle
我们决定存储

00:11:28.822 --> 00:11:31.425 align:middle
一个引用数组
它指向想要

00:11:31.491 --> 00:11:32.726 align:middle
参加派对的人员记录

00:11:36.563 --> 00:11:38.699 align:middle
现在你可以看到
每当我想要添加一个参加者

00:11:38.765 --> 00:11:40.701 align:middle
到一个特定的派对时

00:11:41.001 --> 00:11:43.570 align:middle
我们都会修改同一个派对记录

00:11:45.105 --> 00:11:47.641 align:middle
让我们通过一个例子来了解
当两个不同的用户

00:11:47.975 --> 00:11:51.345 align:middle
想要将他们添加到派对时
将会发生什么

00:11:53.280 --> 00:11:55.949 align:middle
由于WWDC bash晚会
即将开始

00:11:56.216 --> 00:11:58.018 align:middle
因此让我们将这个记录

00:11:58.085 --> 00:11:59.253 align:middle
保存到CloudKit

00:12:00.621 --> 00:12:03.390 align:middle
在我们了解
当两个用户下载此记录时

00:12:03.457 --> 00:12:05.192 align:middle
将会发生什么之前

00:12:05.425 --> 00:12:06.260 align:middle
我想介绍一下

00:12:06.326 --> 00:12:09.062 align:middle
记录变更标记(record
change tags)是什么

00:12:10.097 --> 00:12:14.201 align:middle
你可以认为它们是一个字符串

00:12:14.268 --> 00:12:15.736 align:middle
<br/>
服务器使用它

00:12:16.170 --> 00:12:18.172 align:middle
来标识特定的记录版本

00:12:18.672 --> 00:12:21.642 align:middle
保存在服务器上的记录版本

00:12:21.708 --> 00:12:24.745 align:middle
通过变更标记A表示

00:12:26.013 --> 00:12:29.383 align:middle
它是CKRecords的只读属性

00:12:29.516 --> 00:12:32.553 align:middle
但是只有已经保存的记录
才会有这个标记

00:12:34.054 --> 00:12:36.657 align:middle
假设两个用户John
和Alice都下载

00:12:36.723 --> 00:12:38.959 align:middle
这个特定的记录版本

00:12:39.560 --> 00:12:42.262 align:middle
你可以看到
他们接收相同的变更标记A

00:12:43.664 --> 00:12:46.867 align:middle
现在 John首先将他自己
作为参加者添加到派对

00:12:47.601 --> 00:12:50.304 align:middle
然后尝试将他的记录
添加到服务器

00:12:51.438 --> 00:12:54.074 align:middle
现在这条记录被保存
我们将John的变更标记

00:12:54.141 --> 00:12:57.010 align:middle
也就是A 发送到服务器

00:12:57.678 --> 00:12:59.746 align:middle
服务器发现变更标记匹配

00:13:00.614 --> 00:13:02.182 align:middle
因此接受John的更改

00:13:03.383 --> 00:13:06.520 align:middle
由于服务器记录版本已发生变化

00:13:06.787 --> 00:13:09.523 align:middle
服务器将生成新的变更标记
在本例中 此标记为B

00:13:10.023 --> 00:13:12.693 align:middle
并通过记录保存响应消息
将它发回给John

00:13:15.262 --> 00:13:17.865 align:middle
现在Alice上线了
她决定参加派对

00:13:19.433 --> 00:13:22.135 align:middle
她尝试相同的操作
将她自己添加到数组中

00:13:22.269 --> 00:13:23.904 align:middle
并尝试保存她的记录版本

00:13:24.805 --> 00:13:25.939 align:middle
这时你会看到

00:13:26.006 --> 00:13:28.242 align:middle
她发送旧的变更标记A

00:13:29.142 --> 00:13:30.477 align:middle
服务器将会提醒

00:13:30.577 --> 00:13:33.447 align:middle
她正在尝试修改
已经不存在的

00:13:33.514 --> 00:13:34.681 align:middle
服务器记录版本

00:13:35.115 --> 00:13:36.750 align:middle
她遇到了冲突

00:13:38.318 --> 00:13:39.920 align:middle
在她的设备上

00:13:39.987 --> 00:13:40.854 align:middle
CloudKit

00:13:40.921 --> 00:13:44.124 align:middle
通过“CKerror:server
record changed”

00:13:44.191 --> 00:13:47.060 align:middle
专用代码向她告知这种冲突

00:13:48.729 --> 00:13:51.532 align:middle
其背后的机制并不神秘

00:13:51.598 --> 00:13:53.200 align:middle
我们不必想办法

00:13:53.267 --> 00:13:55.202 align:middle
来解决这种冲突

00:13:55.669 --> 00:13:57.070 align:middle
你自己就可以解决

00:13:57.571 --> 00:13:59.973 align:middle
因此我们会为你提供

00:14:00.307 --> 00:14:01.775 align:middle
尽可能多的有用信息

00:14:01.842 --> 00:14:04.578 align:middle
让你能够自己解决冲突

00:14:05.879 --> 00:14:07.781 align:middle
当更新请求被拒绝时
我们为你提供的最早

00:14:07.848 --> 00:14:09.683 align:middle
也是最重要的信息是

00:14:09.750 --> 00:14:13.353 align:middle
服务器中的记录版本信息

00:14:14.688 --> 00:14:16.089 align:middle
在哪里可以找到这些信息呢？

00:14:16.156 --> 00:14:18.859 align:middle
同样地 你可以
在用户错误字典中找到它

00:14:19.126 --> 00:14:21.361 align:middle
在本例中其值是
CKRecordchanged

00:14:21.428 --> 00:14:23.297 align:middle
errorServer
RecordKey键值

00:14:23.363 --> 00:14:24.965 align:middle
在本例中 当我们将它

00:14:25.032 --> 00:14:27.234 align:middle
用户错误信息字典中提取出来时

00:14:27.434 --> 00:14:29.736 align:middle
我们会发现
服务器中的记录

00:14:29.970 --> 00:14:33.340 align:middle
已经记录John将会参加派对
而且会发新的变更标记B

00:14:35.342 --> 00:14:37.044 align:middle
现在 除了服务器记录之外

00:14:37.444 --> 00:14:40.147 align:middle
我们还会为你返回
更多的信息

00:14:42.349 --> 00:14:46.019 align:middle
这些包括在Alice对记录
进行任何修改之前的

00:14:46.086 --> 00:14:49.423 align:middle
原始记录键值

00:14:50.824 --> 00:14:54.428 align:middle
以及客户端记录键值
此键值包含

00:14:54.494 --> 00:14:56.296 align:middle
Alice尝试保存到服务器的记录

00:14:59.733 --> 00:15:01.869 align:middle
现在 我想强调的是

00:14:59.733 --> 00:15:01.869 align:middle
现在 我想强调的是

00:15:01.935 --> 00:15:05.439 align:middle
在大多数情况下
在解决冲突时

00:15:05.506 --> 00:15:07.441 align:middle
最重要的事情
也是你需要做的事情是

00:15:07.908 --> 00:15:10.511 align:middle
在发生错误之前
及早保存你所做的修改

00:15:10.577 --> 00:15:12.913 align:middle
而不是等待错误响消息

00:15:13.480 --> 00:15:16.650 align:middle
向你返回
服务器记录

00:15:18.185 --> 00:15:20.320 align:middle
在本例中 你获取服务器记录

00:15:20.954 --> 00:15:23.624 align:middle
我们将对想要保存的
这条记录进行相同的修改

00:15:23.690 --> 00:15:26.760 align:middle
也就是把Alice作为参加者

00:15:26.827 --> 00:15:29.329 align:middle
添加到派对 包括她和John

00:15:29.696 --> 00:15:31.265 align:middle
<br/>
并将这个记录版本

00:15:31.331 --> 00:15:32.299 align:middle
保存到服务器

00:15:34.401 --> 00:15:37.404 align:middle
你会发现
服务器中的变更标记为B

00:15:38.138 --> 00:15:40.641 align:middle
当我们保存记录时
这些变更标记将匹配

00:15:40.707 --> 00:15:42.042 align:middle
服务器将接受保存操作

00:15:45.612 --> 00:15:47.214 align:middle
在这里 我们应该知道

00:15:47.281 --> 00:15:50.217 align:middle
如果我们为这项功能
设计更好的schema,

00:15:50.417 --> 00:15:52.419 align:middle
我们可以避免这类错误

00:15:53.620 --> 00:15:55.722 align:middle
稍后我将会讨论schema

00:15:58.425 --> 00:16:00.160 align:middle
你会发现 在尝试修改相同记录时

00:15:58.425 --> 00:16:00.160 align:middle
你会发现 在尝试修改相同记录时

00:16:00.227 --> 00:16:03.463 align:middle
每次不同的用户都要进行这种修改

00:16:03.530 --> 00:16:05.632 align:middle
这并不是最好的方法

00:16:09.670 --> 00:16:11.271 align:middle
让我们来了解一种新的schema

00:16:11.538 --> 00:16:13.540 align:middle
让我们来看
CloudKit操作

00:16:14.975 --> 00:16:17.978 align:middle
我想为APP添加一个新功能

00:16:18.045 --> 00:16:20.681 align:middle
以允许用户存储派对照片

00:16:22.015 --> 00:16:24.985 align:middle
这次 我们需要
在派对与照片之间

00:16:25.052 --> 00:16:26.186 align:middle
建立一对多的关系

00:16:26.587 --> 00:16:28.055 align:middle
照片将拥有
它们自己的记录类型

00:16:28.856 --> 00:16:31.692 align:middle
但是我们不想将它们
存储到照片记录

00:16:31.992 --> 00:16:33.126 align:middle
我们应该怎么做呢？

00:16:33.193 --> 00:16:37.564 align:middle
我们可以通过反向引用
照片所属的派对

00:16:37.631 --> 00:16:39.666 align:middle
来保存照片记录

00:16:41.935 --> 00:16:42.870 align:middle
你可以看到

00:16:42.936 --> 00:16:45.405 align:middle
当我们保存照片记录时

00:16:45.939 --> 00:16:49.042 align:middle
不需要更改
照片所属的派对记录

00:16:53.313 --> 00:16:55.349 align:middle
让我们来了解
如何保存这些记录

00:16:58.185 --> 00:16:59.820 align:middle
在我们的APP中

00:16:59.887 --> 00:17:00.954 align:middle
<br/>
我们使用便利性API

00:16:59.887 --> 00:17:00.954 align:middle
<br/>
我们使用便利性API

00:17:01.021 --> 00:17:03.023 align:middle
利用完成处理操作保存记录

00:17:03.090 --> 00:17:05.125 align:middle
每次保存一个照片记录

00:17:06.660 --> 00:17:07.594 align:middle
但是

00:17:07.661 --> 00:17:10.731 align:middle
用户可能一次存储多张照片

00:17:10.797 --> 00:17:12.398 align:middle
对于这种情况

00:17:12.465 --> 00:17:14.701 align:middle
目前我们
使用便利性API

00:17:14.835 --> 00:17:17.304 align:middle
通过不间断循环
来保存多条记录

00:17:18.204 --> 00:17:21.141 align:middle
让我们来看这些操作的

00:17:21.375 --> 00:17:22.542 align:middle
背后机制

00:17:24.912 --> 00:17:28.015 align:middle
APP多次调用便利性API

00:17:28.080 --> 00:17:29.516 align:middle
来保存多张照片

00:17:30.450 --> 00:17:33.320 align:middle
在系统中
必须通过一组默认值

00:17:33.487 --> 00:17:36.690 align:middle
将它们封装在CK操作中

00:17:39.026 --> 00:17:43.030 align:middle
当我们尝试将记录
保存到服务器时

00:17:43.163 --> 00:17:45.165 align:middle
这些操作中的每个操作
至少发出一次网络请求

00:17:46.099 --> 00:17:48.502 align:middle
我们不希望所有这些请求
导致服务器崩溃

00:17:48.569 --> 00:17:52.072 align:middle
但是我们造成了系统瓶颈

00:17:52.139 --> 00:17:55.375 align:middle
系统一次发送多个请求

00:17:57.711 --> 00:17:59.079 align:middle
以保存这些记录

00:18:00.113 --> 00:18:02.516 align:middle
现在 除了这个瓶颈之外

00:18:02.583 --> 00:18:05.285 align:middle
还需要考虑另外一件事情

00:18:07.654 --> 00:18:11.558 align:middle
这些操作中的每个操作
都请求一次保存一条记录

00:18:11.625 --> 00:18:13.493 align:middle
在本例中

00:18:13.861 --> 00:18:15.996 align:middle
将会产生大量的网络请求

00:18:16.063 --> 00:18:18.232 align:middle
从CloudKit APP开发人员
的角度来看

00:18:19.233 --> 00:18:20.801 align:middle
这显然不是一个好主意

00:18:22.202 --> 00:18:24.905 align:middle
我们希望通过一次网络请求

00:18:25.172 --> 00:18:28.275 align:middle
批处理这些记录更新操作
或者 至少应该

00:18:28.342 --> 00:18:29.743 align:middle
使用最少的网络请求来处理它们

00:18:30.010 --> 00:18:30.944 align:middle
我们应该怎么做呢？

00:18:31.979 --> 00:18:36.383 align:middle
我们使用与便利性API

00:18:36.450 --> 00:18:37.618 align:middle
相对应的
CK操作

00:18:38.886 --> 00:18:41.889 align:middle
几乎每个一次处理一个项目的

00:18:41.955 --> 00:18:45.058 align:middle
便利性API都有对应的CK操作

00:18:45.192 --> 00:18:46.793 align:middle
这些CK操作能够批处理记录更新

00:18:47.427 --> 00:18:50.831 align:middle
在本例中 我们想要使用
CKModifyRecords操作

00:18:51.198 --> 00:18:53.634 align:middle
将多个记录作为一个数组
提供给记录保存资产

00:18:54.735 --> 00:18:57.237 align:middle
以一次保存多个记录

00:18:58.505 --> 00:19:01.008 align:middle
让我们来看此操作的背后原理

00:18:58.505 --> 00:19:01.008 align:middle
让我们来看此操作的背后原理

00:19:01.508 --> 00:19:04.144 align:middle
现在我们可以将组合所有记录

00:19:04.211 --> 00:19:05.846 align:middle
通过一次操作来保存它们

00:19:08.448 --> 00:19:09.550 align:middle
此操作进入系统队列

00:19:09.616 --> 00:19:11.952 align:middle
系统能够使用最少的请求数量

00:19:12.019 --> 00:19:14.821 align:middle
保存这些记录到服务器

00:19:14.888 --> 00:19:17.858 align:middle
我们就消除了瓶颈

00:19:19.393 --> 00:19:24.164 align:middle
同时 我们最大限度地

00:19:24.231 --> 00:19:25.165 align:middle
减少了请求数量

00:19:26.500 --> 00:19:30.370 align:middle
我希望你们所有人
在你的APP中

00:19:30.437 --> 00:19:32.840 align:middle
使用便利性API时
使用这项技术

00:19:33.640 --> 00:19:36.443 align:middle
如果你考虑将它用于

00:19:36.510 --> 00:19:39.680 align:middle
在多个位置或同一个类型的循环中
处理同一种类型的请求

00:19:40.514 --> 00:19:43.083 align:middle
应考虑使用
CKOperation API

00:19:43.150 --> 00:19:44.852 align:middle
以批处理这些请求

00:19:45.719 --> 00:19:47.487 align:middle
这将会减少请求数量

00:19:47.554 --> 00:19:50.490 align:middle
同时提高系统的效率

00:19:52.759 --> 00:19:55.195 align:middle
好的
现在我们来讨论批处理

00:19:57.197 --> 00:19:58.765 align:middle
这是我们需要考虑的

00:19:58.899 --> 00:19:59.833 align:middle
另外一件事情

00:20:02.970 --> 00:20:05.772 align:middle
服务器限制
一次可以设置

00:20:05.839 --> 00:20:07.908 align:middle
的批处理数量

00:20:10.177 --> 00:20:12.012 align:middle
这些限制包括

00:20:12.079 --> 00:20:14.181 align:middle
每个请求中的项目数量

00:20:15.916 --> 00:20:18.318 align:middle
和请求总数量

00:20:18.519 --> 00:20:19.987 align:middle
请求总数量是

00:20:20.053 --> 00:20:22.356 align:middle
在隶属于该请求的记录中

00:20:22.422 --> 00:20:25.025 align:middle
设置的键值数据之和

00:20:26.360 --> 00:20:28.495 align:middle
必须注意的一点是

00:20:28.562 --> 00:20:30.030 align:middle
<br/>
通过CKAsset API

00:20:30.097 --> 00:20:32.466 align:middle
作为批量存储的组成部分
存储的数据量

00:20:32.533 --> 00:20:35.636 align:middle
并不会计入

00:20:35.702 --> 00:20:37.638 align:middle
这个键值数据

00:20:40.307 --> 00:20:43.510 align:middle
但是 如果你的请求
想要绕过任何此类限制

00:20:44.778 --> 00:20:45.879 align:middle
你将会收到一个名为

00:20:45.946 --> 00:20:48.115 align:middle
CKErrorLimit
Exceeded的专用错误代码

00:20:49.316 --> 00:20:51.685 align:middle
对于这种错误的处理方法

00:20:51.752 --> 00:20:54.621 align:middle
我们通常建议开发人员将
将项目对半拆拆分

00:20:54.688 --> 00:20:58.825 align:middle
成为批处理 进行两次操作
而不是一次操作

00:21:00.093 --> 00:21:02.129 align:middle
如果再次遇到相同的错误

00:21:02.196 --> 00:21:04.298 align:middle
则应该进行同样的拆分

00:21:06.366 --> 00:21:09.169 align:middle
如果仅有批处理中的部分项目
发生错误 应该怎么办呢？

00:21:10.871 --> 00:21:15.008 align:middle
由于批处理包括很多项目

00:21:15.075 --> 00:21:18.445 align:middle
但是只会返回一个错误
但是我们仍然希望向你

00:21:18.512 --> 00:21:20.247 align:middle
告知其中每一项错误

00:21:20.981 --> 00:21:21.915 align:middle
为此

00:21:21.982 --> 00:21:23.584 align:middle
我们使用一个名为

00:21:24.651 --> 00:21:26.553 align:middle
CKError partial
failure的专用错误代码

00:21:28.155 --> 00:21:30.324 align:middle
这是一个顶层错误代码

00:21:30.657 --> 00:21:32.459 align:middle
你并不希望直接处理它

00:21:33.827 --> 00:21:34.661 align:middle
但是与前面一样

00:21:35.262 --> 00:21:37.030 align:middle
在用户错误字典中

00:21:37.097 --> 00:21:40.000 align:middle
如果你按项目ID键值查找
CKPartial错误键值

00:21:40.701 --> 00:21:41.702 align:middle
我们将会提供

00:21:41.768 --> 00:21:44.238 align:middle
与你的批处理错误相应对应的

00:21:44.304 --> 00:21:45.706 align:middle
项目ID字典

00:21:47.274 --> 00:21:51.078 align:middle
例如 在本例中
有一个项目ID

00:21:51.144 --> 00:21:52.846 align:middle
发生CKRecord无效参数错误

00:21:53.213 --> 00:21:54.781 align:middle
另外 批处理中的其他项目

00:21:54.848 --> 00:21:56.416 align:middle
可能发生错误
也可能没有错误

00:21:56.750 --> 00:21:59.987 align:middle
你需要打开这个字典
在字典中进行查看

00:22:00.053 --> 00:22:01.488 align:middle
单独处理该错误

00:22:03.757 --> 00:22:06.293 align:middle
如果考虑自定义区域中的原子更新
(atomic update)

00:22:06.360 --> 00:22:09.530 align:middle
情况会略微发生变化

00:22:11.665 --> 00:22:14.101 align:middle
需要注意的是 自定义区域

00:22:14.168 --> 00:22:17.704 align:middle
具有CKModify
记录操作功能

00:22:17.771 --> 00:22:19.039 align:middle
能够发送原子更新

00:22:19.106 --> 00:22:22.276 align:middle
在这种情况下 服务器将整个
批处理作为一个操作予以接受

00:22:22.342 --> 00:22:24.444 align:middle
或者拒绝整个批处理

00:22:25.812 --> 00:22:28.448 align:middle
如果批处理中的一个项目

00:22:28.515 --> 00:22:31.051 align:middle
发生CKError无效参数错误
（与本例相同）

00:22:31.118 --> 00:22:33.654 align:middle
其余项目ID
将包含错误信息

00:22:34.021 --> 00:22:36.890 align:middle
和CKRecords批处理
请求失败专用错误代码

00:22:38.091 --> 00:22:39.793 align:middle
在处理原子更新时

00:22:39.860 --> 00:22:41.828 align:middle
必须检索字典内容

00:22:42.329 --> 00:22:43.764 align:middle
处理未包含在

00:22:43.830 --> 00:22:45.599 align:middle
批处理请求失败中的所有错误

00:22:47.734 --> 00:22:51.705 align:middle
关于如何通过优化方式
将我们的照片记录存储到

00:22:51.772 --> 00:22:53.273 align:middle
Cloud服务器
我们就讲到这里

00:22:53.674 --> 00:22:55.876 align:middle
下面我们来讨论另外一半

00:22:55.943 --> 00:22:57.544 align:middle
<br/>
即如何下载

00:22:57.611 --> 00:23:00.113 align:middle
我们使用
CloudKit查询来进行下载

00:22:57.611 --> 00:23:00.113 align:middle
我们使用
CloudKit查询来进行下载

00:23:01.481 --> 00:23:03.150 align:middle
现在
利用我们设计的schema

00:23:03.217 --> 00:23:06.053 align:middle
下载特定派对的照片变得十分简单

00:23:06.119 --> 00:23:08.889 align:middle
在这种schema中

00:23:08.956 --> 00:23:11.758 align:middle
照片记录引用它们所属的派对

00:23:12.759 --> 00:23:15.562 align:middle
我们只需要创建一个CK查询

00:23:15.863 --> 00:23:17.497 align:middle
这个尝试匹配将这个引用

00:23:17.698 --> 00:23:19.132 align:middle
与已知派对记录ID进行匹配

00:23:22.035 --> 00:23:25.072 align:middle
现在 如果我们发出查询
以下载一个派对的照片

00:23:25.772 --> 00:23:27.741 align:middle
一些派对可能有大量的照片

00:23:28.041 --> 00:23:29.877 align:middle
我们是否需要全部下载它们呢？

00:23:31.111 --> 00:23:35.115 align:middle
让我们来看如何
使用CKQuery操作

00:23:35.182 --> 00:23:37.017 align:middle
发出特定派对照片

00:23:37.351 --> 00:23:38.952 align:middle
优化下载查询

00:23:42.589 --> 00:23:44.391 align:middle
首先需要解决的问题是：

00:23:44.691 --> 00:23:47.661 align:middle
我们并不知道有多少张照片
隶属于一个特定的派对

00:23:47.928 --> 00:23:49.296 align:middle
我们应该下载多少张照片呢？

00:23:50.163 --> 00:23:52.132 align:middle
下载全部照片并没有意义

00:23:53.267 --> 00:23:55.469 align:middle
对于我们的UI来说

00:23:55.536 --> 00:23:57.304 align:middle
应该回答这个问题

00:23:58.238 --> 00:24:00.274 align:middle
如果你看一下
我们这里的示例UI

00:23:58.238 --> 00:24:00.274 align:middle
如果你看一下
我们这里的示例UI

00:24:00.541 --> 00:24:03.443 align:middle
你可以看到 当我们调出
一个特定的派对时

00:24:03.677 --> 00:24:06.380 align:middle
我们看到20张照片

00:24:07.648 --> 00:24:09.449 align:middle
正确的做法是

00:24:09.516 --> 00:24:11.718 align:middle
当我们首次发出查询时

00:24:12.052 --> 00:24:14.221 align:middle
查询应仅返回20张照片给我们

00:24:15.189 --> 00:24:18.358 align:middle
我们可以使用
CKQuery操作的结果限值属性

00:24:18.525 --> 00:24:19.726 align:middle
来做到这一点

00:24:21.295 --> 00:24:25.098 align:middle
当你不知道总共会
返回多少个项目时

00:24:26.300 --> 00:24:28.368 align:middle
这个属性能够帮助你

00:24:28.435 --> 00:24:31.738 align:middle
管理特定批处理中
的项目数量

00:24:33.774 --> 00:24:35.676 align:middle
因此 这个属性也可以用于

00:24:35.742 --> 00:24:37.544 align:middle
CKFetch记录变更操作

00:24:38.045 --> 00:24:39.980 align:middle
此操作可能会返回大量的变更

00:24:40.047 --> 00:24:42.516 align:middle
而你并不知道自定义区域

00:24:43.851 --> 00:24:46.086 align:middle
和CKFetch通知变更操作
会返回多少个变更

00:24:46.153 --> 00:24:47.588 align:middle
其原因与前面一样

00:24:50.357 --> 00:24:52.526 align:middle
好的
现在我们只想下载20个记录

00:24:52.993 --> 00:24:53.894 align:middle
这样更简单一些

00:24:54.494 --> 00:24:55.996 align:middle
但是 我们可以做得更好吗吗？

00:24:56.763 --> 00:24:58.465 align:middle
让我们来看我们的下载

00:24:59.266 --> 00:25:02.069 align:middle
我们再次来让UI
为我们回答这个问题

00:24:59.266 --> 00:25:02.069 align:middle
我们再次来让UI
为我们回答这个问题

00:25:02.236 --> 00:25:04.605 align:middle
当我们查看一个特定派对时

00:25:04.671 --> 00:25:07.774 align:middle
我们看到的是
特定派对的经过裁剪和

00:25:07.841 --> 00:25:09.810 align:middle
缩小的缩略图

00:25:12.613 --> 00:25:14.882 align:middle
但是我们存储在照片记录上

00:25:15.115 --> 00:25:17.985 align:middle
而且默认情况下将会完全下载的

00:25:18.051 --> 00:25:22.256 align:middle
可能是我们使用iOS设备

00:25:23.457 --> 00:25:25.459 align:middle
高画质相机拍摄的

00:25:25.526 --> 00:25:26.593 align:middle
照片的高分辨率版本

00:25:27.794 --> 00:25:30.898 align:middle
如果我们能够将该信息添加到

00:25:30.964 --> 00:25:33.667 align:middle
我们的照片记录

00:25:34.635 --> 00:25:37.738 align:middle
让我们能够调出部分记录
将会很有帮助作用

00:25:38.605 --> 00:25:40.107 align:middle
但是 我们如何
调出部分记录呢吗？

00:25:41.008 --> 00:25:42.476 align:middle
我们通过对CKQuery操作

00:25:42.543 --> 00:25:45.179 align:middle
使用desiredKeys属性
来完成此任务

00:25:46.313 --> 00:25:47.814 align:middle
在本例中

00:25:47.881 --> 00:25:50.684 align:middle
desiredKeys属性
接收一个键值属性数组

00:25:50.751 --> 00:25:52.953 align:middle
这些键值是符合查询条件的

00:25:53.020 --> 00:25:53.854 align:middle
所有记录的键值

00:25:55.122 --> 00:25:57.291 align:middle
因此 如果我们将它设置为
thumbnail

00:25:57.357 --> 00:26:00.327 align:middle
你可以看到 当查询返回时

00:25:57.357 --> 00:26:00.327 align:middle
你可以看到 当查询返回时

00:26:00.394 --> 00:26:02.896 align:middle
载入的数据量大幅减少了

00:26:06.066 --> 00:26:08.936 align:middle
这也可以用于
CKFetchRecords操作

00:26:09.536 --> 00:26:13.440 align:middle
在这种操作 你可能已经提前
知道你想要获取记录的ID

00:26:14.007 --> 00:26:15.042 align:middle
但是你的UI

00:26:15.108 --> 00:26:17.277 align:middle
或者因其他原因
你只想要

00:26:17.678 --> 00:26:19.246 align:middle
下载部分记录

00:26:21.882 --> 00:26:24.251 align:middle
另外 也可以用于CKFetch
记录变更操作

00:26:24.384 --> 00:26:27.387 align:middle
默认情况下 此操作下载
任何已经变更的记录的

00:26:27.788 --> 00:26:29.356 align:middle
全部记录内容

00:26:31.925 --> 00:26:35.028 align:middle
现在 如果我们只想显示
20张照片 当我们首次向用户

00:26:35.095 --> 00:26:38.165 align:middle
显示这些照片时

00:26:38.232 --> 00:26:39.800 align:middle
照片应该以特定的顺序显示

00:26:40.400 --> 00:26:43.203 align:middle
假设我们想要按照

00:26:43.270 --> 00:26:45.439 align:middle
照片在iCloud上的存储顺序

00:26:45.506 --> 00:26:48.075 align:middle
显示这些照片

00:26:50.711 --> 00:26:54.615 align:middle
我们可以对CKQuery
设置sortDescriptor

00:26:54.681 --> 00:26:56.984 align:middle
并使用这些描述符
初始化CKQuery操作

00:26:58.752 --> 00:27:01.822 align:middle
你可以看到 在这里
我们将sortDescriptor

00:26:58.752 --> 00:27:01.822 align:middle
你可以看到 在这里
我们将sortDescriptor

00:27:01.889 --> 00:27:04.958 align:middle
设置为创建日期键值
这是一个系统字段

00:27:05.092 --> 00:27:07.961 align:middle
保存在服务器上的所有
CKRecord都有这个字段

00:27:09.930 --> 00:27:11.098 align:middle
我们将它设置为降序

00:27:14.735 --> 00:27:17.638 align:middle
在这里 需要注意的是
由于它是一个系统字段

00:27:17.905 --> 00:27:21.108 align:middle
因此你需要可以在服务器上
使用此字段进行排序

00:27:21.642 --> 00:27:24.745 align:middle
你可以通过iCloud
Dashboard进行此设置

00:27:25.612 --> 00:27:26.580 align:middle
应该在保存记录之前

00:27:26.647 --> 00:27:29.416 align:middle
进行此项设置

00:27:29.917 --> 00:27:34.855 align:middle
否则 在设置之前
保存的记录

00:27:34.922 --> 00:27:36.123 align:middle
将不会有此项索引值

00:27:38.292 --> 00:27:41.128 align:middle
我们想要获取所有记录中的
小部分记录

00:27:41.195 --> 00:27:43.897 align:middle
你可能会想

00:27:43.964 --> 00:27:45.532 align:middle
如何向用户显示其余记录？

00:27:45.799 --> 00:27:48.435 align:middle
假设用户开始向下滚动

00:27:48.502 --> 00:27:49.770 align:middle
想要查看下一批照片

00:27:52.206 --> 00:27:55.209 align:middle
在这种情况下
我们如何实现分页显示？

00:27:55.676 --> 00:27:58.679 align:middle
我们通过分析查询处理语句
返回的结果

00:27:58.745 --> 00:27:59.980 align:middle
来处理这个问题

00:28:01.315 --> 00:28:04.918 align:middle
当查询完成时

00:28:04.985 --> 00:28:06.954 align:middle
我们不仅获得
查询返回的所有结果

00:28:07.254 --> 00:28:09.056 align:middle
还获得一个
CKQueryCursor

00:28:10.591 --> 00:28:14.027 align:middle
这是一个不透明的标记符

00:28:14.094 --> 00:28:18.198 align:middle
显示你在整个查询结果中
所处的位置

00:28:18.932 --> 00:28:20.968 align:middle
因此你应该存储

00:28:21.034 --> 00:28:23.437 align:middle
首次查询操作返回给你的
QueryCursor

00:28:25.005 --> 00:28:26.907 align:middle
当你想要

00:28:26.974 --> 00:28:28.509 align:middle
获取下一批结果时

00:28:28.942 --> 00:28:32.479 align:middle
你可以始使用先前存储的
Cursor初始值

00:28:32.546 --> 00:28:34.648 align:middle
传递这个值 来初始化

00:28:34.948 --> 00:28:37.217 align:middle
另一个CKQuery操作

00:28:39.753 --> 00:28:43.323 align:middle
当我们通过这种方式
优化CKQuery操作时

00:28:43.390 --> 00:28:47.160 align:middle
应确保对新查询操作
设置相同的必要键值

00:28:47.227 --> 00:28:49.963 align:middle
和结果返回数量限值

00:28:50.964 --> 00:28:54.268 align:middle
这将优化下一批照片
查询结果

00:28:57.271 --> 00:28:59.706 align:middle
关于下载记录就是这些

00:29:01.074 --> 00:29:02.910 align:middle
现在我想要切换主题

00:29:02.976 --> 00:29:06.914 align:middle
介绍一些在使用CloudKit时

00:29:07.014 --> 00:29:10.250 align:middle
维护本地缓存方面的技术

00:29:10.317 --> 00:29:12.719 align:middle
让我们首先来讨论一项新功能

00:29:15.189 --> 00:29:17.257 align:middle
假设我们希望
用户能够为派对添加一些

00:29:17.324 --> 00:29:20.427 align:middle
简短的个人评论

00:29:22.462 --> 00:29:24.331 align:middle
假设这些评论是个人化的

00:29:24.932 --> 00:29:27.167 align:middle
我们想要将它存储到
用户的私人数据库之中

00:29:30.604 --> 00:29:33.540 align:middle
我们不想要在用户每次查看
或修改这些评论时

00:29:33.607 --> 00:29:35.709 align:middle
获取这些评论

00:29:36.443 --> 00:29:37.945 align:middle
我们希望提供

00:29:38.011 --> 00:29:39.780 align:middle
提供某种离线访问功能

00:29:42.249 --> 00:29:45.953 align:middle
你可以看到 在这种情况下

00:29:46.386 --> 00:29:50.057 align:middle
我们需要的是
在特定的设备用户上

00:29:50.123 --> 00:29:51.592 align:middle
提供少量的数据

00:29:52.926 --> 00:29:55.963 align:middle
在这情况下使用CloudKit时

00:29:56.630 --> 00:29:58.298 align:middle
维护本地缓存是不错的做法

00:30:00.434 --> 00:30:03.270 align:middle
让我们先来看
如何从私人数据库

00:30:03.337 --> 00:30:04.404 align:middle
下载内容

00:30:05.572 --> 00:30:09.343 align:middle
前面讲过 我们能够将记录
存储到私人数据库中的

00:30:09.409 --> 00:30:11.879 align:middle
自定义区域
此区域为我们提供一些附加功能

00:30:13.080 --> 00:30:14.848 align:middle
让我们来进行这些操作

00:30:15.382 --> 00:30:18.685 align:middle
我们在私人数据库中
创建一个新区域

00:30:19.920 --> 00:30:21.788 align:middle
其名称为NotesZone

00:30:22.089 --> 00:30:24.324 align:middle
我们可以通过两种方法
获取此区域中的数据

00:30:26.126 --> 00:30:28.862 align:middle
与前面一样 我们可以
使用CKQuery操作

00:30:29.162 --> 00:30:31.131 align:middle
并对它进行优化
方法与前面一样

00:30:32.533 --> 00:30:36.570 align:middle
我们还可以通过
CKRecordsFetch操作

00:30:36.670 --> 00:30:41.175 align:middle
使用delta下载 让我们仅获取

00:30:41.241 --> 00:30:42.543 align:middle
区域中仅发生变更的记录

00:30:43.076 --> 00:30:48.215 align:middle
我们说过 此操作只适于

00:30:48.282 --> 00:30:50.050 align:middle
具有获取变更功能的区域

00:30:50.551 --> 00:30:52.152 align:middle
目前 私人数据库中的
所有自定义区域

00:30:52.219 --> 00:30:54.421 align:middle
都具有此功能

00:30:55.923 --> 00:30:57.191 align:middle
如果你想要更详细地

00:30:57.257 --> 00:30:59.993 align:middle
了解delta下载的工作原理

00:31:00.060 --> 00:31:01.128 align:middle
我建议你

00:31:01.195 --> 00:31:02.896 align:middle
回顾去年的
高级CloudKit讲座

00:31:03.230 --> 00:31:06.600 align:middle
这个讲座详细地介绍
这种操作是如何工作的

00:31:09.369 --> 00:31:10.737 align:middle
假设我们想要使用这项功能

00:31:11.238 --> 00:31:12.773 align:middle
我们开始获取变更记录

00:31:13.140 --> 00:31:16.677 align:middle
我们将APP对象存储在

00:31:16.743 --> 00:31:18.478 align:middle
一个本地数据库之中
它可能是核心数据

00:31:18.679 --> 00:31:20.247 align:middle
或你选择的其它数据库

00:31:21.815 --> 00:31:24.284 align:middle
在这个位置
我们编码APP对象

00:31:25.953 --> 00:31:28.222 align:middle
这里有一个party对象

00:31:28.422 --> 00:31:31.959 align:middle
我们为它添加了
一个notes键值

00:31:32.092 --> 00:31:34.094 align:middle
对应于用户为这个派对
添加的评论

00:31:34.895 --> 00:31:39.199 align:middle
我们将APP编码到
本地存储

00:31:39.266 --> 00:31:42.169 align:middle
当处理相应的CKRecords时

00:31:42.669 --> 00:31:44.738 align:middle
我们想要将记录
存储在Cloud之中

00:31:46.907 --> 00:31:50.611 align:middle
我们可能考虑
编码整个CKRecord

00:31:51.879 --> 00:31:55.782 align:middle
因此我们缓存这些记录
和我们的APP对象

00:31:56.183 --> 00:31:57.651 align:middle
让我们来看会发生什么

00:31:58.051 --> 00:32:00.721 align:middle
你可以看到
CKRecord还具有为其设置的

00:31:58.051 --> 00:32:00.721 align:middle
你可以看到
CKRecord还具有为其设置的

00:32:00.787 --> 00:32:02.356 align:middle
所有APP对象键值

00:32:02.689 --> 00:32:04.358 align:middle
当然 在我们编码时

00:32:04.424 --> 00:32:06.527 align:middle
我们会复制所有的APP键值

00:32:07.928 --> 00:32:09.897 align:middle
当我们编码APP对象之后

00:32:09.963 --> 00:32:11.565 align:middle
以及当我们编码
CKRecord时

00:32:12.266 --> 00:32:13.734 align:middle
这就是我们想要的

00:32:16.003 --> 00:32:18.138 align:middle
你看到 CKRecord对象中的
橙色字段

00:32:18.205 --> 00:32:19.673 align:middle
属于CKRecord

00:32:19.973 --> 00:32:22.409 align:middle
服务器通过这些字段

00:32:22.476 --> 00:32:26.780 align:middle
来识别记录的特定版本

00:32:27.014 --> 00:32:28.549 align:middle
它们称为系统字段

00:32:29.850 --> 00:32:32.119 align:middle
在本例中 你真正的想要是的

00:32:32.186 --> 00:32:35.189 align:middle
记录的系统字段的编码方法

00:32:36.089 --> 00:32:39.126 align:middle
你可以使用编码系统字段和

00:32:39.193 --> 00:32:41.328 align:middle
编码器API对
CKRecord进行编码

00:32:42.896 --> 00:32:45.465 align:middle
你需要使用这些代码

00:32:45.532 --> 00:32:46.867 align:middle
对这些系统字段进行编码

00:32:47.134 --> 00:32:50.337 align:middle
我们强烈建议你使用这种方法

00:32:50.404 --> 00:32:52.773 align:middle
如果遇到这样的情况
你需要回顾以往的讲座

00:32:55.008 --> 00:32:58.412 align:middle
现在让我们来看当我们开始
编码系统字段时将会发生什么

00:32:59.680 --> 00:33:02.583 align:middle
我们想要高效地存储

00:32:59.680 --> 00:33:02.583 align:middle
我们想要高效地存储

00:33:02.649 --> 00:33:05.385 align:middle
CKRecord的重要信息和
相应的party对象

00:33:08.121 --> 00:33:11.091 align:middle
现在 让我们来看
尝试修改一个party对象时

00:33:11.291 --> 00:33:13.160 align:middle
将会发生什么

00:33:13.560 --> 00:33:16.196 align:middle
我们已经使用前面所述的方法
存储这个对象的系统字段

00:33:18.432 --> 00:33:22.669 align:middle
为此 我们使用CKRecord的
编码器初始化函数

00:33:27.140 --> 00:33:28.575 align:middle
你可以看到 当我们调用它时

00:33:29.443 --> 00:33:34.648 align:middle
我们获得先前存储的
所有系统字段

00:33:34.715 --> 00:33:37.317 align:middle
为了简洁起见 我仅显示
记录ID和我们已经看到的

00:33:37.651 --> 00:33:38.585 align:middle
变更标记

00:33:40.420 --> 00:33:44.324 align:middle
对于这个CKRecord
你完全可以设置

00:33:44.391 --> 00:33:48.762 align:middle
此记录发生变更的键值

00:33:49.162 --> 00:33:50.831 align:middle
比如说 我们想要变更派对名称

00:33:51.698 --> 00:33:54.935 align:middle
将派对名称更改为
WWDC bash

00:33:55.169 --> 00:33:57.171 align:middle
我们为这个键值设置为新的值

00:33:57.538 --> 00:33:59.006 align:middle
并在服务器上保存新记录

00:34:01.875 --> 00:34:05.612 align:middle
必须指出的是
当存储记录的变更值时

00:34:05.679 --> 00:34:07.848 align:middle
你不必设置记录的

00:34:08.047 --> 00:34:10.117 align:middle
所有键值

00:34:12.553 --> 00:34:15.155 align:middle
我们正式地维护和存储

00:34:15.222 --> 00:34:19.525 align:middle
本地缓存 让我们来看
如何从自定义区域

00:34:19.592 --> 00:34:22.862 align:middle
获取变更值
以使缓存保持为最新

00:34:24.197 --> 00:34:27.100 align:middle
与前面一样 我们使用

00:34:27.167 --> 00:34:29.469 align:middle
CKFetchRecord
Changes操作

00:34:29.536 --> 00:34:31.205 align:middle
来完成这个任务

00:34:31.271 --> 00:34:33.206 align:middle
此操作提供区域中
所有已经发生变更的记录

00:34:33.774 --> 00:34:36.944 align:middle
真正的问题是
应该在何时使用此操作？

00:34:37.578 --> 00:34:40.514 align:middle
因为 单独使用此操作
并不会告诉我们

00:34:40.647 --> 00:34:42.482 align:middle
存储区域在何时已经发生变更

00:34:43.016 --> 00:34:44.384 align:middle
为此 我们需要

00:34:44.451 --> 00:34:47.387 align:middle
通过CKSubscription
API来使用通知

00:34:49.690 --> 00:34:52.525 align:middle
更具体地说
由于区域中的变更

00:34:52.592 --> 00:34:56.429 align:middle
并不是你想通知给用户的变更

00:34:56.864 --> 00:34:59.566 align:middle
因此在这里我们应该
使用静默通知

00:35:01.735 --> 00:35:06.406 align:middle
在下一节中 我将介绍

00:35:06.473 --> 00:35:09.343 align:middle
始何启用并运行订阅

00:35:09.409 --> 00:35:11.645 align:middle
尤其是当你想要
使用静默订阅时

00:35:12.446 --> 00:35:14.448 align:middle
让我们简要回顾

00:35:15.148 --> 00:35:16.350 align:middle
什么是订阅?

00:35:17.484 --> 00:35:19.286 align:middle
订阅内容是根据

00:35:19.353 --> 00:35:21.555 align:middle
用户存储在服务器上的
定期内容查询请求而提供的

00:35:23.490 --> 00:35:26.026 align:middle
你或你的APP通过这种方法

00:35:26.159 --> 00:35:29.463 align:middle
接收相关内容变更远程通知

00:35:30.497 --> 00:35:33.200 align:middle
有两种类型的订阅
它们的不同之处在于

00:35:33.267 --> 00:35:36.570 align:middle
你如何定义哪些变更
是你需要关注的

00:35:38.639 --> 00:35:41.275 align:middle
第一种是查询订阅

00:35:41.708 --> 00:35:43.210 align:middle
允许你存储
一个预设条件

00:35:44.011 --> 00:35:46.413 align:middle
如果变更符合预设条件时

00:35:46.613 --> 00:35:47.681 align:middle
就是你所需要的变更

00:35:48.982 --> 00:35:51.285 align:middle
第二种是区域订阅
在这种方法中

00:35:51.351 --> 00:35:53.253 align:middle
区域中的每次记录修改

00:35:53.320 --> 00:35:55.622 align:middle
都被计为一个相关变更

00:35:58.358 --> 00:36:01.428 align:middle
因此 很明显 在本例中
我们需要静默通知

00:35:58.358 --> 00:36:01.428 align:middle
因此 很明显 在本例中
我们需要静默通知

00:36:02.529 --> 00:36:05.699 align:middle
当我们的区域发生变更时
将会发送此通知

00:36:07.501 --> 00:36:10.737 align:middle
但是 我们首先需要了解
当你处理各种CloudKit订阅时

00:36:11.071 --> 00:36:13.340 align:middle
所需要的常规设置

00:36:14.675 --> 00:36:16.977 align:middle
对这个设置 我想强调的是

00:36:17.144 --> 00:36:22.149 align:middle
如果远程通知
并非来自于CloudKit.

00:36:22.216 --> 00:36:24.084 align:middle
你仍然需要

00:36:24.251 --> 00:36:26.386 align:middle
设置远程通知

00:36:27.554 --> 00:36:28.722 align:middle
让我来阐明其含义

00:36:29.256 --> 00:36:31.892 align:middle
首先 你仍然需要
在开发者门户中

00:36:31.959 --> 00:36:34.595 align:middle
为这个APP ID
开启APS功能

00:36:35.262 --> 00:36:38.165 align:middle
当你开启CloudKit功能时

00:36:38.232 --> 00:36:39.566 align:middle
将会自动为你开启此功能

00:36:41.368 --> 00:36:44.771 align:middle
第二 在测试你的APP
而且预计会收到远程通知时

00:36:44.838 --> 00:36:47.641 align:middle
你需要在你的APP中
将APS环境键值

00:36:47.708 --> 00:36:49.276 align:middle
设置到P列表之中
以用于开发工作

00:36:51.778 --> 00:36:52.880 align:middle
第三 你仍然需要

00:36:52.946 --> 00:36:55.782 align:middle
通过UI应用API
进行注册

00:36:56.650 --> 00:36:58.886 align:middle
如果你计划在你的App中
显示用户通知

00:36:58.952 --> 00:37:02.890 align:middle
至少 你需要调用
远程通知注册

00:36:58.952 --> 00:37:02.890 align:middle
至少 你需要调用
远程通知注册

00:37:03.023 --> 00:37:05.692 align:middle
并且提醒用户

00:37:05.759 --> 00:37:08.328 align:middle
注册用户通知设置

00:37:11.198 --> 00:37:14.134 align:middle
由于我们需要静默通知

00:37:14.501 --> 00:37:16.103 align:middle
而且会通过
CloudKit服务器

00:37:16.170 --> 00:37:19.273 align:middle
向我们发送通知
我们应该如何告诉服务器

00:37:19.973 --> 00:37:21.642 align:middle
此通知应该是静默通知呢？

00:37:22.743 --> 00:37:26.346 align:middle
我们通过与CK订阅相对应的

00:37:26.413 --> 00:37:28.815 align:middle
CKNotification信息
来完成这个任务

00:37:28.882 --> 00:37:30.150 align:middle
我们将它作为入口点

00:37:30.417 --> 00:37:32.819 align:middle
告诉CloudKit服务器
应该发送哪种类型的

00:37:32.886 --> 00:37:36.156 align:middle
推送内容和以哪种优先级
进行发送

00:37:36.523 --> 00:37:37.724 align:middle
让我们来说说优先级

00:37:39.960 --> 00:37:44.431 align:middle
如前所述 我们配置
CKNotification信息

00:37:44.531 --> 00:37:45.933 align:middle
以告诉CloudKit服务器

00:37:46.166 --> 00:37:48.635 align:middle
这是一个静默通知

00:37:48.702 --> 00:37:49.837 align:middle
它需要以低优先级发送

00:37:51.772 --> 00:37:53.574 align:middle
如果你为
CKNotification

00:37:53.640 --> 00:37:55.108 align:middle
信息设置这些键值

00:37:55.175 --> 00:37:57.411 align:middle
服务器将为你发送
高优先级推送内容

00:37:57.811 --> 00:38:02.149 align:middle
无论它是提醒正文
徽标或声音名称

00:37:57.811 --> 00:38:02.149 align:middle
无论它是提醒正文
徽标或声音名称

00:38:03.584 --> 00:38:06.320 align:middle
我们将它们称为订阅
使用的UI键值

00:38:06.420 --> 00:38:07.754 align:middle
如果你发送其中任何一项

00:38:08.188 --> 00:38:10.657 align:middle
服务器将发送
高优先级推送内容

00:38:10.724 --> 00:38:12.159 align:middle
这意味着 需要立即发送

00:38:14.027 --> 00:38:17.664 align:middle
所有其他推送内容
将会以中优先级发送

00:38:17.731 --> 00:38:19.032 align:middle
并计入静默通知数量

00:38:21.435 --> 00:38:23.904 align:middle
让我们来看你需要

00:38:23.971 --> 00:38:26.206 align:middle
什么样的静默通知设置

00:38:29.309 --> 00:38:30.711 align:middle
首先 你需要为你的APP

00:38:30.777 --> 00:38:33.614 align:middle
开启远程通知后台模式

00:38:34.281 --> 00:38:36.884 align:middle
你可以通过
Xcode中的功能窗格来启用它

00:38:37.951 --> 00:38:39.653 align:middle
你应该记得选中该选项

00:38:42.055 --> 00:38:43.690 align:middle
第二 你应该确保

00:38:43.757 --> 00:38:45.692 align:middle
你实现的APP

00:38:45.759 --> 00:38:47.361 align:middle
接收远程通知

00:38:47.694 --> 00:38:49.596 align:middle
获取应用委派的API

00:38:49.663 --> 00:38:51.031 align:middle
完成处理通知

00:38:52.699 --> 00:38:55.636 align:middle
将会在后台调用其他版本

00:38:55.702 --> 00:38:58.405 align:middle
在计划使用静默通知时

00:38:58.472 --> 00:38:59.973 align:middle
请确保已经实现这个版本

00:39:03.210 --> 00:39:06.313 align:middle
第三 我们需要再一次
告诉CloudKit服务器

00:39:06.380 --> 00:39:08.248 align:middle
通知是静默推送通知

00:39:08.715 --> 00:39:11.118 align:middle
我们如何配置CK
Notification信息呢？

00:39:12.953 --> 00:39:14.388 align:middle
首先也是最重要的

00:39:14.454 --> 00:39:15.289 align:middle
你应该将

00:39:15.355 --> 00:39:17.224 align:middle
shouldSendContent
Availablent属性

00:39:17.291 --> 00:39:18.458 align:middle
设置为true.

00:39:18.792 --> 00:39:21.094 align:middle
这个属性告诉
CloudKit服务器

00:39:21.161 --> 00:39:22.629 align:middle
在你的推送内容中
应该包含

00:39:22.696 --> 00:39:23.564 align:middle
可用内容键值

00:39:26.066 --> 00:39:29.703 align:middle
其次 你应该为C
Notification信息

00:39:29.770 --> 00:39:32.806 align:middle
设置我们前面所述的UI键值

00:39:33.507 --> 00:39:35.309 align:middle
目前并不支持
同时设置这些属性和

00:39:35.375 --> 00:39:38.278 align:middle
shouldSendContent
Available属性

00:39:38.345 --> 00:39:40.714 align:middle
这将会导致服务器错误

00:39:44.318 --> 00:39:46.553 align:middle
现在 让我们探讨
静默推送内容送达

00:39:46.620 --> 00:39:49.189 align:middle
我们已经配置
与推送相关的所有设置

00:39:49.556 --> 00:39:51.959 align:middle
我们将于何时获得推送内容呢？

00:39:52.292 --> 00:39:55.529 align:middle
由于这些通知的目的
并不是为了提醒用户

00:39:55.596 --> 00:39:58.765 align:middle
因此系统将会在适当的时机

00:39:58.832 --> 00:40:00.334 align:middle
发送这些通知

00:39:58.832 --> 00:40:00.334 align:middle
发送这些通知

00:40:00.834 --> 00:40:03.737 align:middle
在决定何时发送这些通知时

00:40:03.804 --> 00:40:04.905 align:middle
系统将会考虑各种因素

00:40:07.875 --> 00:40:10.544 align:middle
通常来说 推送是尽力而为的

00:40:11.645 --> 00:40:14.348 align:middle
也就是说 推送可能会被合并

00:40:14.648 --> 00:40:17.284 align:middle
甚至被丢弃
具体视设备状况而定

00:40:17.951 --> 00:40:21.355 align:middle
例如 如果在需要接收紧急通知时

00:40:21.421 --> 00:40:24.658 align:middle
设备处于飞行模式
当设备退出飞行模式时

00:40:24.725 --> 00:40:27.494 align:middle
Apple推送通知服务器
仅会向设备发送

00:40:27.561 --> 00:40:29.796 align:middle
确实需要接收的
最后一条推送通知

00:40:31.832 --> 00:40:34.067 align:middle
现在 我们有办法
来解决这个问题

00:40:34.134 --> 00:40:36.470 align:middle
因为我们可以
使用CloudKit通知

00:40:37.471 --> 00:40:38.772 align:middle
具体来说

00:40:39.273 --> 00:40:42.576 align:middle
CloudKit服务器
存储需要发送到你的设备的

00:40:42.643 --> 00:40:44.645 align:middle
所有通知

00:40:44.745 --> 00:40:46.847 align:middle
我们将它称为通知集合

00:40:48.382 --> 00:40:50.851 align:middle
因此当你接收静默通知时

00:40:51.084 --> 00:40:53.720 align:middle
应该确保从这个通知集合中

00:40:53.787 --> 00:40:55.222 align:middle
获取变更通知

00:40:55.322 --> 00:40:56.523 align:middle
你可以通过CK

00:40:56.590 --> 00:40:59.493 align:middle
FetchNotification
Changes操作来完成

00:41:01.528 --> 00:41:04.565 align:middle
因此 当我们获取静默通知时
我们检查

00:41:04.665 --> 00:41:06.400 align:middle
是否有任何丢失的通知

00:41:07.134 --> 00:41:09.036 align:middle
而且我们知道
我们的区域已经发生变更

00:41:09.102 --> 00:41:11.572 align:middle
这也是我们获得通知的原因

00:41:12.339 --> 00:41:13.574 align:middle
在这种情况下 我们使用

00:41:13.640 --> 00:41:15.876 align:middle
CKFetchRecord
Changes操作

00:41:15.943 --> 00:41:17.578 align:middle
来查看我们的区域内
发生了哪些变更

00:41:20.314 --> 00:41:22.382 align:middle
和前面讨论的一样

00:41:22.449 --> 00:41:24.918 align:middle
我们并不知道区域内
发生了多少变更

00:41:25.919 --> 00:41:28.055 align:middle
因此这可能一个
长时间运行的操作

00:41:28.388 --> 00:41:31.191 align:middle
如果操作需要较长的时间来完成

00:41:31.692 --> 00:41:32.759 align:middle
我建议你考虑使用

00:41:32.826 --> 00:41:35.429 align:middle
针对UI应用的后台任务API

00:41:37.264 --> 00:41:39.399 align:middle
这将允许你分配更多的时间

00:41:39.466 --> 00:41:41.735 align:middle
给你的操作 直到操作完成

00:41:44.137 --> 00:41:46.340 align:middle
现在 在我们开始讨论通知之前
我需要告诉你们

00:41:46.940 --> 00:41:50.544 align:middle
在iOS 8中 我们引入了
一个全新的通知类别

00:41:50.811 --> 00:41:53.413 align:middle
称为交互式通知

00:41:53.647 --> 00:41:57.684 align:middle
它允许用户在信息条

00:41:57.784 --> 00:41:59.620 align:middle
提醒界面或通知中心
处理推送通知

00:42:01.455 --> 00:42:03.724 align:middle
利用CloudKit 你可以
将大量的请求

00:42:03.790 --> 00:42:06.193 align:middle
配置为交互式通知

00:42:06.727 --> 00:42:09.229 align:middle
我很高兴地告诉你们
在iOS 9中你只需要很少的设置

00:42:09.296 --> 00:42:10.964 align:middle
就可以完成此操作

00:42:11.431 --> 00:42:14.001 align:middle
同样地如果CK
Notification信息

00:42:14.067 --> 00:42:15.302 align:middle
设置新的类型属性

00:42:15.369 --> 00:42:17.237 align:middle
当注册用户通知设置时

00:42:18.672 --> 00:42:21.441 align:middle
这个属性将对应于

00:42:21.942 --> 00:42:23.343 align:middle
你使用UIMutable

00:42:23.410 --> 00:42:26.580 align:middle
Notification
Categories注册的标识符

00:42:27.481 --> 00:42:28.949 align:middle
只需要进行这些设置

00:42:29.016 --> 00:42:31.685 align:middle
就可以通过
CloudKit运行交互式通知

00:42:39.193 --> 00:42:40.027 align:middle
<br/>
谢谢

00:42:40.594 --> 00:42:43.463 align:middle
结合这些功能 我想介绍一些

00:42:43.530 --> 00:42:46.099 align:middle
你应该掌握的一些常用性能技术

00:42:46.200 --> 00:42:49.102 align:middle
在使用CloudKit
开发APP时

00:42:49.303 --> 00:42:50.571 align:middle
你应该使用这些技术

00:42:52.339 --> 00:42:55.209 align:middle
CloudKit是高度异步API

00:42:56.977 --> 00:43:00.380 align:middle
大多操作在网络上进行
你经常会遇到

00:42:56.977 --> 00:43:00.380 align:middle
大多操作在网络上进行
你经常会遇到

00:43:00.447 --> 00:43:03.750 align:middle
许多具有依赖关系的任务

00:43:04.318 --> 00:43:07.221 align:middle
而且你需要保持
特定的任务完成顺序

00:43:09.756 --> 00:43:15.062 align:middle
当针对这些任务实施任务管理时

00:43:15.362 --> 00:43:18.732 align:middle
需要实现一些目标

00:43:18.799 --> 00:43:20.400 align:middle
你们需要记住一些重要的目标

00:43:22.069 --> 00:43:23.971 align:middle
首先 很明显

00:43:24.271 --> 00:43:27.474 align:middle
无论你使用什么样的技术
你都需要

00:43:27.541 --> 00:43:29.643 align:middle
为每个CloudKit任务

00:43:29.710 --> 00:43:31.712 align:middle
实施良好的错误处理方法

00:43:33.447 --> 00:43:35.916 align:middle
其次 由于这些操作
是异步操作

00:43:35.983 --> 00:43:38.485 align:middle
你应该确保
在任何情况下

00:43:38.552 --> 00:43:39.853 align:middle
避免阻止主线程

00:43:40.287 --> 00:43:41.822 align:middle
和降低它们的UI性能

00:43:44.358 --> 00:43:47.528 align:middle
最后但非不重要的是
作为开发人员

00:43:47.928 --> 00:43:51.164 align:middle
你应该确保你的任务管理方案
能够保持良好的代码可维护性

00:43:51.231 --> 00:43:54.301 align:middle
当你为APP添加新功能时
代码应该便于分析

00:43:54.368 --> 00:43:56.970 align:middle
调试和扩展

00:43:59.006 --> 00:44:01.308 align:middle
让我们来看一些方法

00:43:59.006 --> 00:44:01.308 align:middle
让我们来看一些方法

00:44:01.675 --> 00:44:03.110 align:middle
并且了解一些技巧和缺点

00:44:05.913 --> 00:44:09.249 align:middle
第一点是不要嵌套
便利性API调用

00:44:11.051 --> 00:44:14.154 align:middle
让我们来看一个简单的例子

00:44:14.288 --> 00:44:17.090 align:middle
在前面所述的schema中
如果我们想要修改

00:44:17.191 --> 00:44:20.294 align:middle
一个派对参加者记录
请不要在实际中编程中

00:44:20.360 --> 00:44:21.461 align:middle
使用这个schema

00:44:21.795 --> 00:44:24.264 align:middle
但是 当你使用便利性API时

00:44:24.331 --> 00:44:27.034 align:middle
如果你想要修改派对参加者记录
你就必须这样做

00:44:27.401 --> 00:44:29.837 align:middle
你首先需要使用ID获取记录

00:44:29.903 --> 00:44:31.038 align:middle
然后尝试获取

00:44:31.104 --> 00:44:33.173 align:middle
参加者想要参加的派对的记录

00:44:33.841 --> 00:44:36.844 align:middle
然后从参加者数组中

00:44:36.910 --> 00:44:41.448 align:middle
找到参加者记录ID
然后对参加者记录进行修改

00:44:41.515 --> 00:44:44.251 align:middle
然后尝试保存记录

00:44:45.285 --> 00:44:48.155 align:middle
当需要修改一条具有很多
依存关系的字段的记录时

00:44:48.555 --> 00:44:50.090 align:middle
你必须执行这些操作

00:44:50.290 --> 00:44:52.359 align:middle
你会看到一大堆

00:44:54.895 --> 00:44:58.565 align:middle
杂乱无章的代码

00:44:58.632 --> 00:45:02.236 align:middle
你不知道在哪里处理哪些错误

00:44:58.632 --> 00:45:02.236 align:middle
你不知道在哪里处理哪些错误

00:45:02.669 --> 00:45:05.105 align:middle
以及如何最合理地
重试这些操作

00:45:06.106 --> 00:45:07.708 align:middle
除此之外 还需要

00:45:07.774 --> 00:45:10.177 align:middle
考虑另外一件事情

00:45:11.378 --> 00:45:14.014 align:middle
假设用户的某些APP操作

00:45:14.081 --> 00:45:16.283 align:middle
导致我们需要进行这些操作

00:45:17.351 --> 00:45:20.387 align:middle
如果一个用户后续操作

00:45:20.454 --> 00:45:22.923 align:middle
而导致不再需要这些任务

00:45:23.223 --> 00:45:25.626 align:middle
由于这些任务已经进入队列

00:45:25.692 --> 00:45:26.693 align:middle
你将无法取消这些任务

00:45:27.661 --> 00:45:30.163 align:middle
如果它们的运行时间很长
当它们运行时

00:45:30.230 --> 00:45:32.666 align:middle
你将无法进行其它操作
你必须等待它们完成

00:45:34.468 --> 00:45:36.570 align:middle
当你管理相关依赖的任务时
尤其是在你需要

00:45:36.670 --> 00:45:39.540 align:middle
对批量记录进行相同的修改时

00:45:40.374 --> 00:45:43.510 align:middle
我们建议你不要使用这种方法

00:45:45.679 --> 00:45:47.881 align:middle
另一种方法是
消除API的异步性质

00:45:47.948 --> 00:45:50.717 align:middle
这可以使用信号灯

00:45:50.784 --> 00:45:52.786 align:middle
并且等待信号灯来实现

00:45:54.521 --> 00:45:57.224 align:middle
在一些情况下
这也会变得十分复杂

00:45:57.925 --> 00:46:00.527 align:middle
你不应该尝试这样做

00:45:57.925 --> 00:46:00.527 align:middle
你不应该尝试这样做

00:46:00.827 --> 00:46:04.998 align:middle
如果你这样做 你应该知道

00:46:05.766 --> 00:46:08.769 align:middle
尤其是在你的长时间
等待操作完成时

00:46:08.836 --> 00:46:10.838 align:middle
你很容易遇到

00:46:10.904 --> 00:46:12.606 align:middle
循环式的依赖关系

00:46:12.673 --> 00:46:14.174 align:middle
而导致APP陷入死循环

00:46:15.609 --> 00:46:19.213 align:middle
或者 如果你想对主线程
使用这种方法

00:46:19.847 --> 00:46:23.116 align:middle
在网络上等待被处理的操作

00:46:23.183 --> 00:46:25.352 align:middle
将会导致UI停止响应

00:46:25.419 --> 00:46:26.820 align:middle
从而严重影响用户体验

00:46:28.956 --> 00:46:30.057 align:middle
因此我们不建议这样做

00:46:33.927 --> 00:46:36.396 align:middle
我们建议你查看

00:46:36.463 --> 00:46:40.334 align:middle
NSOperation 提供的
依赖关系管理API

00:46:41.902 --> 00:46:43.570 align:middle
就是这个API

00:46:44.071 --> 00:46:46.840 align:middle
NSOperation
让你能够轻松添加

00:46:46.907 --> 00:46:49.343 align:middle
和消除其他NSOperations
之间的依赖关系

00:46:50.544 --> 00:46:52.246 align:middle
让我们来看如何使用

00:46:52.312 --> 00:46:53.547 align:middle
CKOperations
实现这一点

00:46:53.614 --> 00:46:56.450 align:middle
CKOperations是
NSOperations的子类

00:46:58.185 --> 00:47:01.154 align:middle
如果有两个互相依赖的
获取记录操作

00:46:58.185 --> 00:47:01.154 align:middle
如果有两个互相依赖的
获取记录操作

00:47:01.722 --> 00:47:05.125 align:middle
而且第二个操作应该
在第一个操作完成之后开始

00:47:05.192 --> 00:47:09.062 align:middle
你只需设置这两个操作

00:47:09.596 --> 00:47:13.267 align:middle
将第一个获取操作设置为
第二操作的先决条件

00:47:13.333 --> 00:47:14.935 align:middle
然后将这两个操作送入队列

00:47:15.936 --> 00:47:19.806 align:middle
这将保证
在第一个获取操作完成之前

00:47:20.140 --> 00:47:21.542 align:middle
第二个获取操作不会启动

00:47:22.543 --> 00:47:25.512 align:middle
你会看到
这提供一个符合逻辑的方法

00:47:25.579 --> 00:47:27.915 align:middle
让你能够发现特定操作的错误

00:47:28.248 --> 00:47:30.384 align:middle
并且能够方便地

00:47:30.450 --> 00:47:32.252 align:middle
管理它们的依赖关系

00:47:34.721 --> 00:47:37.357 align:middle
现在 当我们从性能的角度

00:47:37.424 --> 00:47:39.459 align:middle
考虑NSOperations时

00:47:40.928 --> 00:47:43.997 align:middle
我希望你们思考

00:47:44.064 --> 00:47:45.365 align:middle
另外一个不同之处

00:47:47.134 --> 00:47:49.336 align:middle
并非所有NSOperations
都是同等的

00:47:49.903 --> 00:47:52.606 align:middle
有些NSOperations
可能是因为用户在APP中的

00:47:52.673 --> 00:47:54.241 align:middle
显式操作而产生的

00:47:54.308 --> 00:47:56.543 align:middle
其他一些
NSOperations示操作

00:47:56.743 --> 00:47:58.312 align:middle
则可能是一些
低优先级的后台任务

00:47:59.379 --> 00:48:02.182 align:middle
为了向系统告知

00:47:59.379 --> 00:48:02.182 align:middle
为了向系统告知

00:48:02.249 --> 00:48:04.351 align:middle
这些NSOperations
的相对重要性

00:48:04.518 --> 00:48:07.154 align:middle
在iOS 8中
我们为NSOperations.

00:48:07.221 --> 00:48:09.656 align:middle
引入了服务质量属性

00:48:11.325 --> 00:48:14.862 align:middle
你可以用这个属性
指定NSOperation封装的

00:48:14.928 --> 00:48:17.598 align:middle
作业的性质和重要性

00:48:19.032 --> 00:48:21.201 align:middle
可以将这个属性

00:48:21.268 --> 00:48:24.605 align:middle
设置为不同的服务质量级别
我建议你们

00:48:24.671 --> 00:48:26.874 align:middle
查看相关文档
来了解各个服务质量等级

00:48:26.940 --> 00:48:28.675 align:middle
以及它们的重要性

00:48:29.476 --> 00:48:32.012 align:middle
在这里 需要记住的一点是

00:48:32.079 --> 00:48:35.148 align:middle
这个服务质量值
直接影响NSOperation的

00:48:35.215 --> 00:48:38.952 align:middle
资源分配优先级

00:48:39.353 --> 00:48:43.156 align:middle
例如CPU时间、
磁盘资源和网络资源

00:48:45.092 --> 00:48:47.794 align:middle
现在结合去年推出的CloudKit

00:48:47.861 --> 00:48:50.163 align:middle
<br/>
我们想要为你提供类似的方法

00:48:50.230 --> 00:48:53.267 align:middle
让你能够将低优先级
CKOperations

00:48:53.467 --> 00:48:55.202 align:middle
优化成为自主性网络行为

00:48:56.570 --> 00:48:57.538 align:middle
我的意思是

00:48:57.604 --> 00:49:01.341 align:middle
优化非用户发起的任务

00:48:57.604 --> 00:49:01.341 align:middle
优化非用户发起的任务

00:49:01.775 --> 00:49:04.344 align:middle
预取用户内容
就像我们在前面

00:49:04.411 --> 00:49:07.247 align:middle
使用CKRecords
获取记录变更操作

00:49:07.314 --> 00:49:09.383 align:middle
来响应静默通知所作的那样

00:49:10.317 --> 00:49:13.153 align:middle
你需要将这些任务
优化成为自主性行为

00:49:13.220 --> 00:49:16.356 align:middle
使系统在合适的时机

00:49:16.924 --> 00:49:18.625 align:middle
执行这些网络请求

00:49:19.760 --> 00:49:22.362 align:middle
在决定何时执行这些请求时

00:49:22.596 --> 00:49:25.432 align:middle
系统会考虑很多因素

00:49:26.133 --> 00:49:27.534 align:middle
例如蜂窝网络连通性等

00:49:27.935 --> 00:49:31.872 align:middle
系统可能会等待网络
连通性改善之后

00:49:31.939 --> 00:49:34.775 align:middle
再发送这些请求

00:49:35.375 --> 00:49:36.777 align:middle
另外还会考虑电量等

00:49:37.277 --> 00:49:38.812 align:middle
如果用户设备电量过低

00:49:39.046 --> 00:49:41.882 align:middle
或者设备未在充电
系统将会等待

00:49:41.949 --> 00:49:45.252 align:middle
电量增加之后
再发送这些请求

00:49:46.153 --> 00:49:47.154 align:middle
我们通过使用

00:49:47.221 --> 00:49:48.522 align:middle
CKOperations的

00:49:48.589 --> 00:49:51.491 align:middle
userBackground
Session属性来实现这一点

00:49:53.126 --> 00:49:55.529 align:middle
在iOS 9中

00:49:55.596 --> 00:49:57.364 align:middle
我们可以

00:49:57.564 --> 00:50:00.868 align:middle
极大地简化和统一这些功能

00:49:57.564 --> 00:50:00.868 align:middle
极大地简化和统一这些功能

00:50:00.934 --> 00:50:02.536 align:middle
这两个概念

00:50:02.603 --> 00:50:06.340 align:middle
我们通过服务质量来
推测你的网络行为

00:50:06.940 --> 00:50:09.877 align:middle
同时应用特定服务等级参数

00:50:09.943 --> 00:50:12.646 align:middle
向系统发送的所有其他设置

00:50:13.647 --> 00:50:15.048 align:middle
这就是我们使用的方法

00:50:16.283 --> 00:50:18.519 align:middle
我们不建议用户
使用后台会话属性

00:50:19.119 --> 00:50:22.155 align:middle
而建议你为所有
CKOperation操作

00:50:22.322 --> 00:50:24.091 align:middle
设置服务级别

00:50:25.792 --> 00:50:27.761 align:middle
现在 对于网络行为

00:50:28.061 --> 00:50:29.997 align:middle
可以设置将服务级别设置为

00:50:30.063 --> 00:50:32.165 align:middle
UserInteractive

00:50:32.232 --> 00:50:33.634 align:middle
或UserInitiated

00:50:33.700 --> 00:50:35.736 align:middle
来优化这些自主性行为

00:50:38.705 --> 00:50:41.074 align:middle
对于自主性行为

00:50:41.141 --> 00:50:43.777 align:middle
你可以设置utility值

00:50:44.811 --> 00:50:45.879 align:middle
在这种情况下

00:50:45.946 --> 00:50:49.449 align:middle
系统将推测
是否根据发送请求的APP

00:50:49.516 --> 00:50:53.954 align:middle
在前台或在后台运行
来优化自主性行为

00:50:54.755 --> 00:50:57.391 align:middle
从而始终会产生
自主性网络行为

00:50:59.259 --> 00:51:01.862 align:middle
请记住中
如果你在iOS 9

00:50:59.259 --> 00:51:01.862 align:middle
请记住中
如果你在iOS 9

00:51:01.929 --> 00:51:05.432 align:middle
和OS X El Capitan
或后续版本中开发APP

00:51:06.466 --> 00:51:08.669 align:middle
默认情况下
所有新CKOperations

00:51:08.735 --> 00:51:10.971 align:middle
将具有后台服务质量级别

00:51:11.839 --> 00:51:15.175 align:middle
你应该确保
审查所有CKOperations,

00:51:16.176 --> 00:51:17.477 align:middle
查看它们所代表的

00:51:17.544 --> 00:51:18.745 align:middle
作业的重要性

00:51:19.079 --> 00:51:20.480 align:middle
应该保持良好的系统性能

00:51:20.714 --> 00:51:22.983 align:middle
为这些操作合适的QS值

00:51:24.818 --> 00:51:26.820 align:middle
NSOperation是
功能强大的API

00:51:26.887 --> 00:51:28.789 align:middle
你可以使用它实现很多功能

00:51:29.556 --> 00:51:32.759 align:middle
如果你想了解更多信息
我强烈建议你们

00:51:32.826 --> 00:51:36.163 align:middle
参加明天上午在Presidio举行
的高级NSOperation讲座

00:51:37.831 --> 00:51:38.866 align:middle
作为总结

00:51:40.701 --> 00:51:42.002 align:middle
我想重新强调

00:51:42.069 --> 00:51:45.005 align:middle
CloudKit代码中的
错误处理方法很重要

00:51:45.339 --> 00:51:47.574 align:middle
它与功能一样重要

00:51:48.108 --> 00:51:50.043 align:middle
我希望你们反复检查你的代码

00:51:50.110 --> 00:51:52.379 align:middle
查看你的所有操作

00:51:52.446 --> 00:51:54.581 align:middle
弄清楚你遇到哪些类型的错误

00:51:54.648 --> 00:51:56.483 align:middle
以及你是否遵守了
今在我们所讲述的

00:51:56.550 --> 00:51:58.719 align:middle
关于错误处理的
一般性指导原则

00:52:00.521 --> 00:52:03.023 align:middle
第二 应该批处理你的请求

00:52:03.290 --> 00:52:07.394 align:middle
当你发现你的APP
使用便利性API,

00:52:07.461 --> 00:52:09.663 align:middle
一次处理一个项目

00:52:10.163 --> 00:52:11.798 align:middle
而且在多个位置
进行这样的处理时

00:52:11.865 --> 00:52:15.135 align:middle
你应该考虑使用该API的
CKOperation版本

00:52:15.502 --> 00:52:16.703 align:middle
并且批处理这些请求

00:52:17.237 --> 00:52:19.173 align:middle
你不仅会全面提升

00:52:19.540 --> 00:52:22.509 align:middle
系统的操作执行效率

00:52:22.910 --> 00:52:25.512 align:middle
而且会减少网络请求数量

00:52:28.048 --> 00:52:29.416 align:middle
应考虑优化schema

00:52:29.616 --> 00:52:31.285 align:middle
我们看到两种情况

00:52:31.351 --> 00:52:33.654 align:middle
需要我们优化schema...

00:52:35.556 --> 00:52:38.325 align:middle
让我们能够获得优化的好处

00:52:38.492 --> 00:52:41.295 align:middle
例如 当我们为照片记录

00:52:41.361 --> 00:52:42.896 align:middle
添加缩略键值时

00:52:43.096 --> 00:52:45.465 align:middle
<br/>
我们可以仅下载需要的数据

00:52:45.532 --> 00:52:48.168 align:middle
从而能够优化下载性能

00:52:48.902 --> 00:52:51.972 align:middle
在另一种情况下
当我们避免

00:52:52.039 --> 00:52:54.474 align:middle
某些派对照片被修改时

00:52:54.541 --> 00:52:56.977 align:middle
<br/>
当我们为派对存储照片时

00:52:57.044 --> 00:52:58.478 align:middle
可以避免发生
整个类别的错误

00:52:59.112 --> 00:53:01.281 align:middle
因此 在设计功能时

00:52:59.112 --> 00:53:01.281 align:middle
因此 在设计功能时

00:53:02.349 --> 00:53:03.684 align:middle
请认真思考你的schema

00:53:05.252 --> 00:53:06.687 align:middle
最后并非不重要的是

00:53:06.753 --> 00:53:08.522 align:middle
应该配置你的
CKOperations

00:53:08.589 --> 00:53:11.124 align:middle
它们是功能非常强大的API

00:53:11.191 --> 00:53:14.061 align:middle
它们提供大量的优化特性
让你能够优化

00:53:14.228 --> 00:53:16.864 align:middle
发送至CloudKit服务器的

00:53:16.930 --> 00:53:17.931 align:middle
网络请求

00:53:20.234 --> 00:53:22.736 align:middle
要想获取更多信息
请访问我们的文档地址是

00:53:22.803 --> 00:53:25.706 align:middle
developer.Apple.com/CloudKit.

00:53:26.240 --> 00:53:28.775 align:middle
关于其他所有问题和解答

00:53:28.842 --> 00:53:31.879 align:middle
可以咨询技术支持部门
论坛和CK支持网站

00:53:32.279 --> 00:53:33.113 align:middle
对于一般性咨询

00:53:33.180 --> 00:53:35.582 align:middle
请发送邮件至
CloudKit@Apple.com

00:53:36.850 --> 00:53:38.919 align:middle
这周我们举行了
一些很不错的讲座

00:53:38.986 --> 00:53:41.221 align:middle
我希望你们回去后
观看这些讲座视频

00:53:41.522 --> 00:53:44.091 align:middle
了解Web服务新功能

00:53:44.558 --> 00:53:46.159 align:middle
和CloudKit其他新功能

00:53:46.960 --> 00:53:48.061 align:middle
明天上午9点

00:53:48.128 --> 00:53:50.163 align:middle
我们还会在
Frameworks lab D

00:53:50.230 --> 00:53:51.498 align:middle
举行另外一场讲座

00:53:52.299 --> 00:53:54.301 align:middle
请准备好你们的问题
我们将乐意为你解答

00:53:54.768 --> 00:53:55.602 align:middle
谢谢
