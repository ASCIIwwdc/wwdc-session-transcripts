WEBVTT

00:00:32.466 --> 00:00:33.567 align:middle
伍迪·李德斯东：
大家好

00:00:34.301 --> 00:00:38.305 align:middle
今天早些时候我对斯特凡说
我希望有人能来

00:00:38.906 --> 00:00:40.841 align:middle
太不可思议你把这里都包了

00:00:40.908 --> 00:00:41.975 align:middle
感谢你能出来

00:00:42.042 --> 00:00:44.011 align:middle
我是伍迪
很高兴给大家讲讲

00:00:44.077 --> 00:00:46.413 align:middle
用Swift改进现有的App

00:00:47.748 --> 00:00:48.715 align:middle
大家能不能举一下手

00:00:48.782 --> 00:00:51.585 align:middle
多少人实际上
在用Swift 进行编码？

00:00:53.520 --> 00:00:54.354 align:middle
好的<c.blue> </c>很好

00:00:54.488 --> 00:00:55.756 align:middle
那你们大家就 都来对了

00:00:56.423 --> 00:00:57.724 align:middle
无论你是否用了都是如此

00:00:57.791 --> 00:00:59.860 align:middle
希望在讲座后你可以用Swift

00:01:00.327 --> 00:01:02.229 align:middle
打理现有的
Objective-C项目

00:01:03.630 --> 00:01:08.368 align:middle
要知道 去年我也
我也在这屋里 坐在后面的角落

00:01:08.635 --> 00:01:11.305 align:middle
是个听众的身份还带着笔记本

00:01:11.371 --> 00:01:14.007 align:middle
想试着实践一下

00:01:14.074 --> 00:01:16.677 align:middle
我在之前讲座学到的新技术

00:01:17.044 --> 00:01:19.546 align:middle
同时还在回复着工作邮件
虽然我之前说过不会回复的

00:01:20.080 --> 00:01:23.183 align:middle
同时把一半的心思放在发言人身上

00:01:23.250 --> 00:01:25.319 align:middle
我相信在座的大部分现在也是这样

00:01:25.919 --> 00:01:30.757 align:middle
然后 角色换位 我从台下听众

00:01:30.824 --> 00:01:31.859 align:middle
走到了台前

00:01:31.925 --> 00:01:33.894 align:middle
我从加拿大新斯科舍省哈利法克斯

00:01:33.961 --> 00:01:37.397 align:middle
来到了加利福尼亚

00:01:37.831 --> 00:01:41.235 align:middle
如今来这里帮助大家学习使用

00:01:41.301 --> 00:01:43.570 align:middle
Swift和Objective-C
的部分技术

00:01:46.773 --> 00:01:47.774 align:middle
我就不必上前去翻动了

00:01:47.908 --> 00:01:49.209 align:middle
这里有遥控

00:01:53.380 --> 00:01:56.617 align:middle
我想来做的是

00:01:56.850 --> 00:02:01.088 align:middle
介绍部分技术内容让大家可以
把Swift加到现有项目

00:01:56.850 --> 00:02:01.088 align:middle
介绍部分技术内容让大家可以
把Swift加到现有项目

00:02:01.154 --> 00:02:02.289 align:middle
让项目变得更好

00:02:02.523 --> 00:02:04.825 align:middle
本次讲座我就会用来

00:02:04.892 --> 00:02:06.426 align:middle
介绍这样的内容

00:02:06.894 --> 00:02:10.264 align:middle
我去过Infinite
Loop园区到了停车场

00:02:10.330 --> 00:02:12.999 align:middle
来到下面一层的地下迷宫

00:02:13.333 --> 00:02:16.136 align:middle
经过守卫工业设计入口的三头犬

00:02:16.203 --> 00:02:18.005 align:middle
在尽头 是我们

00:02:18.071 --> 00:02:19.473 align:middle
保存软件的保险库

00:02:19.540 --> 00:02:21.308 align:middle
我打开软件保险库

00:02:21.375 --> 00:02:25.078 align:middle
取出app<c.blue> </c>The
Elements 这可能在两三年内

00:02:25.145 --> 00:02:26.547 align:middle
都没在WWDC见到了

00:02:26.713 --> 00:02:28.849 align:middle
现在我就将向
大家介绍它是怎么回事

00:02:30.784 --> 00:02:32.486 align:middle
好的 这就是
The Elements

00:02:32.686 --> 00:02:34.488 align:middle
有谁还记得以前见过?

00:02:34.588 --> 00:02:36.423 align:middle
啊? 有人见过 有人没有

00:02:36.623 --> 00:02:37.658 align:middle
有人当真喜欢它

00:02:37.758 --> 00:02:38.592 align:middle
我就是

00:02:40.127 --> 00:02:43.230 align:middle
这是个标准的
基于UIKit的表视图app

00:02:43.830 --> 00:02:45.465 align:middle
我们有一束单元格 针对

00:02:45.699 --> 00:02:47.768 align:middle
针对原子表中的每个元素

00:02:47.935 --> 00:02:49.303 align:middle
我们还有这个小的详细视图

00:02:49.369 --> 00:02:50.704 align:middle
其中会有更多的信息

00:02:50.771 --> 00:02:52.439 align:middle
如果点击一个单元格

00:02:53.106 --> 00:02:58.278 align:middle
我们有这个导航控制器
推动演示显示部分相关细节

00:02:59.680 --> 00:03:00.747 align:middle
非常棒

00:02:59.680 --> 00:03:00.747 align:middle
非常棒

00:03:08.755 --> 00:03:09.590 align:middle
<c.blue> </c>我相信可能

00:03:09.656 --> 00:03:11.992 align:middle
很多人都会这么做

00:03:12.059 --> 00:03:13.827 align:middle
在不同的应用中移动

00:03:13.927 --> 00:03:15.462 align:middle
并且回来再来看有一阵子

00:03:15.529 --> 00:03:17.431 align:middle
没用的app 或是有一阵子
没编程的app

00:03:17.497 --> 00:03:19.466 align:middle
然后有人让你增添新的功能

00:03:19.533 --> 00:03:21.568 align:middle
或是支持
新的操作系统 新的SDK

00:03:22.069 --> 00:03:23.737 align:middle
这就是我们马上要做的事情

00:03:23.804 --> 00:03:27.007 align:middle
我们会对Objective-C
app准备用Swift来实现现代化

00:03:28.876 --> 00:03:31.979 align:middle
意思是说：如果有现有应用

00:03:32.546 --> 00:03:34.014 align:middle
你必须要为它编写新代码

00:03:34.147 --> 00:03:36.517 align:middle
而现有的应用是
Objective-C app

00:03:36.850 --> 00:03:40.988 align:middle
考虑利用Swift功能
使用Swift来编写新代码

00:03:41.388 --> 00:03:42.556 align:middle
与此同时

00:03:43.423 --> 00:03:46.560 align:middle
把原始的Objective-C代码
留在Objective-C

00:03:46.793 --> 00:03:47.661 align:middle
这也很好的

00:03:48.495 --> 00:03:52.633 align:middle
在本讲座中 我们先从

00:03:52.866 --> 00:03:55.502 align:middle
对应用的翻新讲起为用户界面

00:03:55.569 --> 00:03:57.304 align:middle
带来更为现代的外观

00:03:57.538 --> 00:03:59.373 align:middle
我们马上要做的是使用Swift

00:03:59.606 --> 00:04:02.643 align:middle
之后 我们还要来看看代码

00:03:59.606 --> 00:04:02.643 align:middle
之后 我们还要来看看代码

00:04:02.709 --> 00:04:06.146 align:middle
Swift的结构及其函数
比如映射

00:04:06.213 --> 00:04:08.582 align:middle
找到为应用增添新功能的办法

00:04:12.186 --> 00:04:15.789 align:middle
这个应用有大小tile框架

00:04:15.923 --> 00:04:17.558 align:middle
小tile框架是表视图

00:04:17.658 --> 00:04:18.992 align:middle
大tile框架是详细视图

00:04:19.625 --> 00:04:22.095 align:middle
这些tile框架包括背景

00:04:22.229 --> 00:04:24.798 align:middle
外加在背景上渲染的文本

00:04:25.566 --> 00:04:27.301 align:middle
因为这个app是个老版本app

00:04:27.768 --> 00:04:30.504 align:middle
背景最初是用
Photoshop做的渲染

00:04:30.637 --> 00:04:32.573 align:middle
然后嵌入到应用之中

00:04:33.207 --> 00:04:35.342 align:middle
因为背景中的不同颜色取决于

00:04:35.475 --> 00:04:40.080 align:middle
原子状态固体 液体 合成气体

00:04:40.614 --> 00:04:43.650 align:middle
是仅为最初的iPhone做的渲染

00:04:43.717 --> 00:04:45.552 align:middle
其中并不包括Retina艺术设计

00:04:45.652 --> 00:04:47.754 align:middle
也就是说当我们拿到这个老版本app

00:04:47.821 --> 00:04:49.523 align:middle
在新版本硬件上运行时
我们必须做扩展

00:04:50.224 --> 00:04:54.828 align:middle
当我们扩展这个老版本艺术设计时

00:04:55.162 --> 00:04:57.364 align:middle
我们最后是得到的是圆角失真效果
就是锯齿

00:04:57.497 --> 00:05:00.033 align:middle
因为没有足够的像素数据

00:04:57.497 --> 00:05:00.033 align:middle
因为没有足够的像素数据

00:05:00.133 --> 00:05:01.568 align:middle
来光滑地表现这些角

00:05:01.835 --> 00:05:04.605 align:middle
所以我们在
本次讲座中就会解决这个问题

00:05:06.440 --> 00:05:09.343 align:middle
还有一个问题就是 当你看自己的

00:05:10.077 --> 00:05:11.645 align:middle
中学纪念册时

00:05:12.045 --> 00:05:14.314 align:middle
也许是80年代或90年代

00:05:14.381 --> 00:05:16.016 align:middle
对吗？

00:05:16.083 --> 00:05:17.351 align:middle
你看到了自己的照片

00:05:17.584 --> 00:05:19.820 align:middle
你在这里穿着马甲

00:05:19.887 --> 00:05:22.656 align:middle
还绣着小猫手里拿着键盘

00:05:22.723 --> 00:05:24.057 align:middle
因为当时这样很酷

00:05:24.191 --> 00:05:25.826 align:middle
背景还是激光效果

00:05:25.893 --> 00:05:26.894 align:middle
因为这当初也很酷

00:05:26.960 --> 00:05:27.828 align:middle
现在你再来看着它

00:05:27.895 --> 00:05:30.230 align:middle
心里会想着
当时我脑子里在想什么呢？

00:05:34.968 --> 00:05:36.670 align:middle
有时 我们看着以前的app心里会想

00:05:37.004 --> 00:05:38.438 align:middle
当时我们脑子里是想什么呢？

00:05:38.505 --> 00:05:40.541 align:middle
还有闪亮 光泽 反射效果

00:05:41.275 --> 00:05:43.277 align:middle
我们这就来调整

00:05:43.510 --> 00:05:45.345 align:middle
时尚潮流改变了
风格不一样了

00:05:45.412 --> 00:05:46.613 align:middle
有一种办法是从

00:05:46.747 --> 00:05:50.918 align:middle
背景上把光泽效果删除下去

00:05:52.653 --> 00:05:55.088 align:middle
我们得到了非常时尚的
渲染矩形轮廓

00:05:55.622 --> 00:05:57.991 align:middle
看似在小tile框架上效果不错

00:05:58.058 --> 00:05:59.893 align:middle
就像是在app的大tile框架一样

00:05:59.960 --> 00:06:02.162 align:middle
现在我们可以在
Photoshop渲染新 背景

00:05:59.960 --> 00:06:02.162 align:middle
现在我们可以在
Photoshop渲染新 背景

00:06:02.262 --> 00:06:03.530 align:middle
并把它们嵌入应用中

00:06:03.830 --> 00:06:05.365 align:middle
不过要清楚这个应用我们

00:06:06.233 --> 00:06:07.467 align:middle
不会经常使用

00:06:07.534 --> 00:06:10.938 align:middle
要知道  我们再讲到

00:06:11.305 --> 00:06:14.775 align:middle
可能到了WWDC2020
Elements 我希望确保

00:06:14.875 --> 00:06:17.177 align:middle
当时它看上去还不错
不是简单的过去的硬件

00:06:17.244 --> 00:06:19.646 align:middle
和现在的硬件 而是
潜在的未来硬件

00:06:19.947 --> 00:06:24.051 align:middle
那我继续选择
放入一些自定义绘图代码

00:06:24.117 --> 00:06:26.787 align:middle
绘制圆角矩形背景因为它是个圆角矩形

00:06:26.954 --> 00:06:29.523 align:middle
我准备在Swift中实现 但是

00:06:29.590 --> 00:06:31.325 align:middle
我会从 Objective-C调用

00:06:33.760 --> 00:06:36.296 align:middle
为实现这一点 我用到的是
Mix和Match技术

00:06:36.964 --> 00:06:39.032 align:middle
我们在去年和今年有许多讲座

00:06:39.132 --> 00:06:42.236 align:middle
都是介绍Swift
和Objective-C的互操作性

00:06:42.536 --> 00:06:44.938 align:middle
对其中的机制都有很好的介绍

00:06:45.239 --> 00:06:47.341 align:middle
现在我想来为大家进行综述

00:06:47.407 --> 00:06:49.076 align:middle
来看技术怎样发挥作用

00:06:49.209 --> 00:06:51.712 align:middle
然后深入介绍一个
演示 大家可以直观地了解

00:06:54.147 --> 00:06:56.750 align:middle
一般而言 当我们考虑到
Objective-C中的类时

00:06:56.817 --> 00:06:59.019 align:middle
会有个头文件和一个执行文件

00:06:59.086 --> 00:07:01.522 align:middle
两部分共同构成类定义

00:06:59.086 --> 00:07:01.522 align:middle
两部分共同构成类定义

00:07:02.122 --> 00:07:03.824 align:middle
但是可能我们会有部分

00:07:04.157 --> 00:07:06.193 align:middle
分类中执行的方法

00:07:06.393 --> 00:07:07.694 align:middle
这相当好

00:07:07.961 --> 00:07:10.597 align:middle
然后我们的类定义是基类

00:07:10.998 --> 00:07:12.499 align:middle
加上分类

00:07:12.599 --> 00:07:13.534 align:middle
并不是说

00:07:13.600 --> 00:07:14.902 align:middle
不可以有多个分类

00:07:15.169 --> 00:07:17.137 align:middle
实际上 我们可以
用UI表视图做些什么

00:07:17.204 --> 00:07:19.206 align:middle
如果来看
Objective-C中的头文件

00:07:19.273 --> 00:07:22.009 align:middle
会看到在UI表视图有很多分类

00:07:23.010 --> 00:07:27.047 align:middle
同样 也不是说这些分类之一

00:07:27.114 --> 00:07:28.549 align:middle
不可以在Swift中执行

00:07:29.049 --> 00:07:31.785 align:middle
其中 术语会改变可是概念还是一样

00:07:31.885 --> 00:07:35.322 align:middle
我们只是称其为Objective-
C的Swift扩展

00:07:35.455 --> 00:07:36.456 align:middle
在本例中是基类

00:07:36.723 --> 00:07:37.691 align:middle
并不是说

00:07:37.758 --> 00:07:41.595 align:middle
不可以用多个
Objective-C分类

00:07:41.662 --> 00:07:46.900 align:middle
与多个Swift扩展
相混合 其中所有的内容构成类

00:07:48.302 --> 00:07:50.904 align:middle
我们在Objective-C中
编写部分函数

00:07:51.305 --> 00:07:53.540 align:middle
这会让你在Swift中
编写更新的函数

00:07:54.541 --> 00:07:58.045 align:middle
为了让互操作性技术可以实现我们用到

00:07:58.212 --> 00:08:00.347 align:middle
一组桥接头文件不是一组桥接头文件

00:07:58.212 --> 00:08:00.347 align:middle
一组桥接头文件不是一组桥接头文件

00:08:00.414 --> 00:08:02.149 align:middle
我们是用桥接头文件和一个生成头文件

00:08:03.650 --> 00:08:06.787 align:middle
现在桥接头文件在Xcode中编成

00:08:06.854 --> 00:08:10.390 align:middle
首次向现有Objective-C
项目中引入Swift

00:08:10.924 --> 00:08:12.326 align:middle
然后进行维护

00:08:12.392 --> 00:08:14.294 align:middle
基本上要进入其中
加上部分输入语句

00:08:14.361 --> 00:08:18.298 align:middle
这样就可以针对性
从Objective-C

00:08:18.532 --> 00:08:20.133 align:middle
面向Swift
使用选择数据类型

00:08:21.201 --> 00:08:24.137 align:middle
然后在倒数上
Swift编译器编成生成的头文件

00:08:24.204 --> 00:08:27.541 align:middle
可以将之输入到
Objective-C执行文件

00:08:27.741 --> 00:08:30.177 align:middle
来面对Swift
在本例中是针对

00:08:30.344 --> 00:08:33.046 align:middle
Objective-C的扩展
和其他数据类型

00:08:33.447 --> 00:08:34.881 align:middle
现在我们有了两个头文件

00:08:34.948 --> 00:08:36.350 align:middle
你会在演示中看到它们

00:08:38.085 --> 00:08:39.453 align:middle
马上就好

00:08:50.197 --> 00:08:51.431 align:middle
好的<c.blue> </c>在项目中

00:08:51.598 --> 00:08:53.834 align:middle
这个类名为原子元素tile视图

00:08:54.868 --> 00:08:56.837 align:middle
这就是实际在绘制背景的

00:08:57.504 --> 00:08:58.639 align:middle
其中有个方法

00:08:58.972 --> 00:09:00.541 align:middle
这其实不仅是绘制背景

00:08:58.972 --> 00:09:00.541 align:middle
这其实不仅是绘制背景

00:09:00.607 --> 00:09:02.576 align:middle
它为大小tile框架绘制了背景

00:09:02.643 --> 00:09:03.911 align:middle
和背景上的所有的文本

00:09:04.545 --> 00:09:07.047 align:middle
我准备介绍新的绘图代码

00:09:07.114 --> 00:09:09.283 align:middle
但我将用Swift来实现因此
我会继续制作新的Swift文件

00:09:09.349 --> 00:09:11.151 align:middle
这是Xcode
中的command-N

00:09:11.418 --> 00:09:15.956 align:middle
我们会选择Swift文件来创建

00:09:16.223 --> 00:09:18.292 align:middle
因为是这是首次将Swift加入

00:09:18.392 --> 00:09:19.826 align:middle
这个项目我可以选择

00:09:19.927 --> 00:09:21.061 align:middle
现在就生成接桥头文件

00:09:21.361 --> 00:09:24.064 align:middle
我想创建一个按下Return

00:09:27.334 --> 00:09:30.804 align:middle
现在我有两个文件
其中包括Objective-C的

00:09:31.405 --> 00:09:32.706 align:middle
基类 外加Swift文件

00:09:33.006 --> 00:09:34.808 align:middle
我还有接桥头文件

00:09:35.209 --> 00:09:37.144 align:middle
还可以把这个再加宽一些 就这样

00:09:39.046 --> 00:09:41.548 align:middle
你可能注意到
Swift文件的文件名

00:09:41.815 --> 00:09:44.284 align:middle
和Objective-C中
的完全一样

00:09:44.384 --> 00:09:46.320 align:middle
并不是有这样的要求
而是为了方便起见

00:09:46.587 --> 00:09:48.555 align:middle
因为这表示在Xcode

00:09:48.622 --> 00:09:51.458 align:middle
可以用快捷方式 control
command-up arrow

00:09:51.525 --> 00:09:55.162 align:middle
并循环Swift和
Objective-C头文件并执行

00:09:55.562 --> 00:09:57.631 align:middle
在这三个之间快速往复即可

00:09:59.733 --> 00:10:02.102 align:middle
现在我选定在桥接头文件

00:09:59.733 --> 00:10:02.102 align:middle
现在我选定在桥接头文件

00:10:02.402 --> 00:10:04.505 align:middle
把在Objective-C中
声明的数据类型

00:10:04.571 --> 00:10:07.007 align:middle
暴露Swift通过输入头文件来实现

00:10:07.641 --> 00:10:11.745 align:middle
因为我想将原子元素tile视图
扩展到Swift

00:10:11.812 --> 00:10:15.115 align:middle
或使用Swift
将之输入给接桥头文件

00:10:16.683 --> 00:10:20.654 align:middle
此刻我只需要的是我已经强调过的
原子元素tile视图

00:10:20.721 --> 00:10:22.856 align:middle
但是在演讲的稍后部分
我还需要其他几个

00:10:22.923 --> 00:10:24.658 align:middle
我先来继续现在把它们全都输入

00:10:26.527 --> 00:10:28.228 align:middle
我们在来看Swift文件

00:10:29.029 --> 00:10:33.200 align:middle
我会编写原子元素tile视图的扩展

00:10:40.941 --> 00:10:44.178 align:middle
现在类原子元素
tile视图 调用这个新函数

00:10:44.478 --> 00:10:45.646 align:middle
叫绘制原始背景

00:10:45.879 --> 00:10:49.183 align:middle
大家可以看到 我还用到了
新的Xcode 7标记

00:10:49.316 --> 00:10:51.351 align:middle
给出文档注释文档注释

00:10:51.485 --> 00:10:53.687 align:middle
在本例中 是绘制原子
元素背景tile框架

00:10:54.488 --> 00:10:55.956 align:middle
我来继续 把实际

00:10:56.089 --> 00:10:57.257 align:middle
进行绘制的代码加进去

00:11:02.763 --> 00:11:04.064 align:middle
这就是Swift的部分

00:11:04.131 --> 00:11:06.967 align:middle
但现在我想从Objective-C
中调用Swift函数

00:11:07.401 --> 00:11:09.903 align:middle
这样反而是装载预渲染图像

00:11:09.970 --> 00:11:12.973 align:middle
我会用这种方法来绘制

00:11:14.107 --> 00:11:16.376 align:middle
然后切换到原子元素tile视图m

00:11:16.877 --> 00:11:19.847 align:middle
需要确保
它可以看到我加入Swift中的

00:11:20.180 --> 00:11:22.583 align:middle
代码 因此我继续并输入生成的头文件

00:11:24.251 --> 00:11:26.286 align:middle
生成的头文件和
产品使用完全相同的名称

00:11:26.486 --> 00:11:31.959 align:middle
因此元素
再加上连字符 Swift.h

00:11:34.528 --> 00:11:37.364 align:middle
现在 在这种方法中我通常会装载

00:11:37.464 --> 00:11:39.633 align:middle
预渲染背景
我会加注释

00:11:41.568 --> 00:11:45.506 align:middle
并反而调用“self draw”
大家可以看到

00:11:45.572 --> 00:11:47.241 align:middle
Swift的方法作为原生方法

00:11:47.307 --> 00:11:49.743 align:middle
和这里的所有内容一起显示

00:11:49.810 --> 00:11:51.778 align:middle
你甚至可以看到注释显示为
draw

00:11:51.845 --> 00:11:55.082 align:middle
an atomicelements
background tile

00:11:55.148 --> 00:11:57.818 align:middle
我来传递交出这个元素

00:12:03.490 --> 00:12:05.025 align:middle
把它传递交给外包矩形

00:12:05.092 --> 00:12:06.693 align:middle
它会绘制圆角矩形

00:12:09.563 --> 00:12:10.631 align:middle
运行app

00:12:15.002 --> 00:12:18.639 align:middle
就这样运用Swift代码
和Objective-C

00:12:18.705 --> 00:12:20.541 align:middle
获得部分圆角矩形 谢谢

00:12:26.613 --> 00:12:28.515 align:middle
这就是在观众里
安排自己的朋友的好处

00:12:38.192 --> 00:12:40.561 align:middle
大部分内容 都是和我的预期相符

00:12:40.627 --> 00:12:41.495 align:middle
是圆角矩形

00:12:41.662 --> 00:12:43.564 align:middle
但是圆角矩形本身 它们并不

00:12:43.630 --> 00:12:44.831 align:middle
和我想要的方式相符

00:12:45.098 --> 00:12:48.535 align:middle
实际上 如果放大 大家可以看到

00:12:48.602 --> 00:12:50.904 align:middle
里边是圆角但外边不是圆角

00:12:51.138 --> 00:12:52.306 align:middle
这不是我的本意

00:12:52.472 --> 00:12:54.775 align:middle
我是希望是纯圆角纯粹的圆角

00:12:54.842 --> 00:12:55.976 align:middle
在里边和外边都是

00:12:56.777 --> 00:12:59.980 align:middle
我们来仔细看看为什么会是这样

00:13:00.047 --> 00:13:03.083 align:middle
我们来看Swift结构

00:13:03.951 --> 00:13:05.619 align:middle
Swift会怎么让它

00:13:05.752 --> 00:13:07.154 align:middle
更简单并与结构配合更自然

00:13:07.354 --> 00:13:11.091 align:middle
例如在Core Graphics
框架中我们有许多

00:13:11.625 --> 00:13:12.726 align:middle
基本结构

00:13:12.793 --> 00:13:16.163 align:middle
我们有CGrects
CGpoints CGsize等等

00:13:17.764 --> 00:13:22.302 align:middle
绘制的时候我有外包矩形是个
CGrect我绘制了贝兹曲线路径

00:13:22.669 --> 00:13:24.171 align:middle
现在贝兹曲线路径是屏幕上的

00:13:24.238 --> 00:13:27.474 align:middle
灰色边框绘制贝兹曲线路径

00:13:29.710 --> 00:13:31.879 align:middle
接下来 把它被放在外包矩形内部

00:13:31.945 --> 00:13:33.313 align:middle
你就会看到这里是外包矩形

00:13:34.181 --> 00:13:36.583 align:middle
贝兹曲线路径
你看到的不是这样本身并非是你所见

00:13:36.650 --> 00:13:38.986 align:middle
直到对之应用线条才会进行渲染

00:13:39.052 --> 00:13:41.321 align:middle
比如画线大家会看到

00:13:41.388 --> 00:13:42.990 align:middle
对贝兹曲线路径的渲染效果

00:13:43.790 --> 00:13:46.026 align:middle
我们来绘制贝兹曲线路径

00:13:47.027 --> 00:13:48.195 align:middle
在加上画线

00:13:48.595 --> 00:13:51.765 align:middle
例如 画线为
10个单位宽 10点宽

00:13:52.399 --> 00:13:53.901 align:middle
但是会超过外包矩形的

00:13:53.967 --> 00:13:54.835 align:middle
边界

00:13:56.970 --> 00:13:58.272 align:middle
这会导致剪切

00:13:58.772 --> 00:14:00.908 align:middle
圆角矩形实际上是在外边

00:13:58.772 --> 00:14:00.908 align:middle
圆角矩形实际上是在外边

00:14:00.974 --> 00:14:03.877 align:middle
但是在外包矩形上
发生的剪切防止它到达那里

00:14:05.078 --> 00:14:08.048 align:middle
我知道 在座的朋友
有人会觉得

00:14:08.115 --> 00:14:09.716 align:middle
如果剪切存在问题 那就关闭剪切

00:14:10.184 --> 00:14:11.451 align:middle
问题就解决了

00:14:11.518 --> 00:14:12.452 align:middle
就可以继续了

00:14:14.188 --> 00:14:16.490 align:middle
当然可以 我觉得

00:14:16.557 --> 00:14:20.260 align:middle
在Xcode中
Swift问题可以这么解决

00:14:20.727 --> 00:14:23.463 align:middle
只要重新安排
Swift的感叹号位置

00:14:23.530 --> 00:14:25.232 align:middle
直至开始编译为止

00:14:27.134 --> 00:14:30.070 align:middle
可以这么做 只是我不会
称之为最佳实践

00:14:30.871 --> 00:14:33.507 align:middle
当出现剪切问题时

00:14:35.275 --> 00:14:36.710 align:middle
这是性能表现的问题

00:14:36.777 --> 00:14:38.912 align:middle
通过所调用的每个API

00:14:39.046 --> 00:14:42.916 align:middle
通过发起的每个任务
通过进行的每个动作

00:14:42.983 --> 00:14:44.585 align:middle
通过你的每一次呼吸

00:14:44.885 --> 00:14:47.921 align:middle
你需要考虑对
功能和性能的影响

00:14:48.288 --> 00:14:52.359 align:middle
不断计算两个矩形的
交叉部分并对之进行剪切

00:14:52.426 --> 00:14:53.393 align:middle
这不是很有效的方法

00:14:53.861 --> 00:14:57.564 align:middle
在一开始就把矩形设置为
正确大小则更为有效

00:14:59.266 --> 00:15:00.200 align:middle
我们就要这么做

00:14:59.266 --> 00:15:00.200 align:middle
我们就要这么做

00:15:00.400 --> 00:15:02.202 align:middle
准备嵌入贝兹曲线路径

00:15:02.402 --> 00:15:03.670 align:middle
这样就不会自行剪切

00:15:04.238 --> 00:15:07.307 align:middle
为此 我们会用到一些方法

00:15:07.741 --> 00:15:11.345 align:middle
我是说CGrect上的方法

00:15:11.411 --> 00:15:13.313 align:middle
当它在Swift中使用的时候

00:15:14.214 --> 00:15:16.183 align:middle
考虑一下这些原始类型怎样正常使用

00:15:16.316 --> 00:15:18.685 align:middle
我们有CGrects
CGpoint等等

00:15:19.119 --> 00:15:21.388 align:middle
我说过它们可能会在这里

00:15:21.855 --> 00:15:25.859 align:middle
那么单独来看
你获得了可适用的整套全局通用函数

00:15:25.926 --> 00:15:29.263 align:middle
例如CGrectZero
CGrectMake

00:15:29.329 --> 00:15:32.132 align:middle
或GetWidth
或是部分实际函数

00:15:32.199 --> 00:15:33.634 align:middle
例如获得联合或交点

00:15:34.001 --> 00:15:35.869 align:middle
这是二者之间的认知区分

00:15:35.936 --> 00:15:37.771 align:middle
我们了解是这个类型 然后我们需要

00:15:37.871 --> 00:15:40.374 align:middle
了解是这些方法 不好意思

00:15:40.440 --> 00:15:41.875 align:middle
是作用的函数

00:15:43.076 --> 00:15:45.612 align:middle
我们用Swift
工作时我们实际上改变的是

00:15:45.679 --> 00:15:49.650 align:middle
CGrect和CGpoint
及CGsize进入Swift的方法

00:15:50.517 --> 00:15:52.920 align:middle
我们基本会用封装用所有这些

00:15:53.453 --> 00:15:56.356 align:middle
这些全局 正式来讲是
作用于框架的全局函数

00:15:56.423 --> 00:15:59.193 align:middle
并在结构中搭建它以便使之完成代码

00:16:00.561 --> 00:16:05.299 align:middle
更为简单
还可以更出色预测到API是什么

00:16:06.166 --> 00:16:09.770 align:middle
因为你可以处理点结构

00:16:09.837 --> 00:16:13.140 align:middle
然后为所有方法和属性
获得它所具备的代码完成

00:16:14.074 --> 00:16:16.109 align:middle
然是如果我们把名称就保留成这样

00:16:16.476 --> 00:16:17.878 align:middle
这还不是原生的感觉

00:16:18.445 --> 00:16:21.415 align:middle
名称实际上都做了重新映射

00:16:22.115 --> 00:16:25.953 align:middle
让人觉得
这是数据类型的 第一类型方法

00:16:26.420 --> 00:16:30.858 align:middle
这样做的好处在于
处理Swift中的结构的方法

00:16:31.325 --> 00:16:35.195 align:middle
调用函数或调用方法

00:16:35.262 --> 00:16:38.732 align:middle
或访问其属性这与类的处理方法

00:16:39.199 --> 00:16:42.336 align:middle
与枚举的处理方法完全相同

00:16:43.103 --> 00:16:45.339 align:middle
都是相同的一致风格

00:16:45.672 --> 00:16:48.275 align:middle
我们还要在所有不同数据类型中

00:16:48.408 --> 00:16:49.776 align:middle
使用同样的初始化器

00:16:49.943 --> 00:16:51.912 align:middle
我们有着更好的代码完成

00:16:51.979 --> 00:16:56.850 align:middle
总之
在Swift中运用这些类型更为自然

00:16:56.917 --> 00:17:02.055 align:middle
因为
它们作为第一类型数据类型和方法配合

00:16:56.917 --> 00:17:02.055 align:middle
因为
它们作为第一类型数据类型和方法配合

00:17:03.557 --> 00:17:06.126 align:middle
好的我们还要做一件事情

00:17:06.193 --> 00:17:08.929 align:middle
在下面的演示中我不了解大家会怎样但
是当我用图形代码时

00:17:08.996 --> 00:17:10.998 align:middle
特别是部分Core
Graphics代码时

00:17:11.164 --> 00:17:16.637 align:middle
我使用的一个方法是渲染代码

00:17:16.703 --> 00:17:19.106 align:middle
然后会运行接着来构建并复制到

00:17:19.173 --> 00:17:21.407 align:middle
模拟器然后我导航到

00:17:21.474 --> 00:17:23.644 align:middle
模拟器中代码真正被激活被使用的位置

00:17:23.844 --> 00:17:25.746 align:middle
我还会进行检测 如果不喜欢

00:17:25.811 --> 00:17:27.748 align:middle
就会返回调整代码并运行全部内容

00:17:27.814 --> 00:17:29.917 align:middle
这是个循环

00:17:29.983 --> 00:17:32.152 align:middle
来回走一遍会非常耗时

00:17:32.252 --> 00:17:34.488 align:middle
来看如果把直线宽度

00:17:34.555 --> 00:17:37.357 align:middle
从3改到4 或是关闭光栅化 或是

00:17:37.424 --> 00:17:39.626 align:middle
进行某种设置更改试着让它运转会怎样

00:17:41.995 --> 00:17:43.330 align:middle
还有更好的方法

00:17:43.897 --> 00:17:45.432 align:middle
不需要这么来回反复

00:17:45.832 --> 00:17:48.302 align:middle
也不必经常注释出

00:17:48.368 --> 00:17:50.337 align:middle
部分代码只为尝试效果如何

00:17:50.404 --> 00:17:51.505 align:middle
如果真想试验 可以

00:17:51.572 --> 00:17:54.842 align:middle
拿一些代码试试看看效果怎样

00:17:55.042 --> 00:17:56.543 align:middle
体育场就是为这个准备的

00:17:56.877 --> 00:17:58.745 align:middle
通过体育场循环修改成

00:17:58.812 --> 00:17:59.713 align:middle
这个样子

00:18:00.214 --> 00:18:03.283 align:middle
只要调整代码你就会立刻看到改变
如果不喜欢可以立 刻修改

00:18:03.684 --> 00:18:06.186 align:middle
这些都不会复制到模拟器中 导航并

00:18:06.553 --> 00:18:09.323 align:middle
现在通过体育场
解决圆角来看看是什么样子

00:18:09.590 --> 00:18:11.258 align:middle
矩形的问题并使用CGrect

00:18:11.525 --> 00:18:15.295 align:middle
的部分方法
从中得到更好的CGrect

00:18:15.395 --> 00:18:16.697 align:middle
我来给大家看看

00:18:23.670 --> 00:18:26.406 align:middle
绘图代码在原子元素tile视图

00:18:26.473 --> 00:18:27.574 align:middle
<c.blue>.</c>点Swift就在这里

00:18:27.708 --> 00:18:29.209 align:middle
这是我在之前演示中

00:18:29.276 --> 00:18:30.577 align:middle
复制的函数

00:18:30.911 --> 00:18:32.346 align:middle
我就是想要处理这个

00:18:32.412 --> 00:18:33.514 align:middle
所以把它复制到体育场

00:18:33.847 --> 00:18:37.518 align:middle
复制好了点击command-N
生成新的iOS体育场

00:18:46.860 --> 00:18:47.928 align:middle
粘贴进去

00:18:48.395 --> 00:18:49.730 align:middle
现在就有了绘图函数

00:18:51.698 --> 00:18:53.500 align:middle
开发人员并非身处孤岛

00:18:53.700 --> 00:18:56.036 align:middle
没有任何绘图函数是完全隔绝

00:18:56.336 --> 00:18:58.639 align:middle
绘图函数需要在有上下文来绘制

00:18:58.872 --> 00:19:00.674 align:middle
也就是绘图上下文或是图形上下文

00:18:58.872 --> 00:19:00.674 align:middle
也就是绘图上下文或是图形上下文

00:19:00.941 --> 00:19:03.210 align:middle
获得图形上下文的最便捷方式

00:19:03.277 --> 00:19:04.578 align:middle
是在UIView生成子类

00:19:04.645 --> 00:19:06.046 align:middle
这就是我准备做的

00:19:06.113 --> 00:19:09.516 align:middle
我先来声明UIView的子类 这里

00:19:11.919 --> 00:19:16.023 align:middle
它所做的就是调用绘图函数

00:19:17.224 --> 00:19:19.393 align:middle
然后我会实例化这个类

00:19:23.096 --> 00:19:26.533 align:middle
然后我会采用绘图函数

00:19:26.700 --> 00:19:28.869 align:middle
绘制的图像
并直接加入这里的故事板

00:19:30.971 --> 00:19:32.472 align:middle
放大些 这样都能看清

00:19:34.341 --> 00:19:35.742 align:middle
接着可以进行尝试

00:19:35.809 --> 00:19:37.044 align:middle
你可以指出自己该做什么

00:19:37.110 --> 00:19:38.812 align:middle
让它按照自己的意图来进行绘制

00:19:39.012 --> 00:19:41.114 align:middle
例如 我想看看是否看似

00:19:41.181 --> 00:19:42.683 align:middle
它只有120点

00:19:43.884 --> 00:19:44.785 align:middle
这就是结果

00:19:46.286 --> 00:19:49.690 align:middle
也许我想看看如果直线宽度
不是6而是60圆角半径

00:19:50.457 --> 00:19:55.596 align:middle
为356会怎样

00:19:55.662 --> 00:19:56.663 align:middle
就是这样

00:19:57.531 --> 00:19:59.032 align:middle
大家可以一直做尝试

00:19:59.099 --> 00:20:00.734 align:middle
一旦代码运行方式符合要求

00:19:59.099 --> 00:20:00.734 align:middle
一旦代码运行方式符合要求

00:20:00.968 --> 00:20:01.969 align:middle
就可以复制并

00:20:02.035 --> 00:20:03.470 align:middle
粘贴到它来自的实际文件中

00:20:04.571 --> 00:20:08.509 align:middle
在本例中我希望获得直线宽度比例

00:20:08.609 --> 00:20:10.611 align:middle
那么如果是表视图中的小tile视图

00:20:11.011 --> 00:20:13.113 align:middle
就会是细边如果是大些的视图

00:20:13.180 --> 00:20:14.548 align:middle
相应的就是宽一些的边

00:20:14.715 --> 00:20:18.819 align:middle
因此我会
让它关联到背景矩形的宽度上

00:20:19.520 --> 00:20:24.091 align:middle
那么背景矩形宽度在本例中会除以36

00:20:25.292 --> 00:20:27.094 align:middle
对圆角半径 我也会做同样处理

00:20:27.861 --> 00:20:30.864 align:middle
Background
rectangle.width除以

00:20:31.198 --> 00:20:32.766 align:middle
小一点的值 比如16

00:20:34.668 --> 00:20:37.037 align:middle
现在来看我希望它看的内容

00:20:37.104 --> 00:20:38.272 align:middle
但我仍然还有剪切的问题

00:20:38.338 --> 00:20:40.874 align:middle
我还是不能看到画线或者是

00:20:40.941 --> 00:20:42.876 align:middle
圆角矩形的全部内容

00:20:43.610 --> 00:20:45.913 align:middle
为此 在背景矩形

00:20:46.780 --> 00:20:50.684 align:middle
我会通过嵌入使用矩形方法

00:20:50.884 --> 00:20:52.953 align:middle
并且嵌入到直线宽度的一半

00:20:54.321 --> 00:20:57.057 align:middle
这里的直线宽度除以2

00:20:57.491 --> 00:21:00.594 align:middle
然后 同样直线宽度除以2

00:20:57.491 --> 00:21:00.594 align:middle
然后 同样直线宽度除以2

00:21:03.597 --> 00:21:05.866 align:middle
我有个完美的圆角矩形

00:21:05.933 --> 00:21:07.734 align:middle
和我最初设想完全相同

00:21:08.101 --> 00:21:13.640 align:middle
我把这个代码从这里复制到扩展

00:21:13.907 --> 00:21:15.409 align:middle
代替这个文档 不对

00:21:15.475 --> 00:21:16.376 align:middle
代替这里的方法

00:21:17.477 --> 00:21:19.346 align:middle
用command-R再次运行app

00:21:22.516 --> 00:21:25.352 align:middle
正如我所愿圆角矩形

00:21:25.886 --> 00:21:26.854 align:middle
好的 很好

00:21:34.461 --> 00:21:37.998 align:middle
这很有WWDC的感觉如果你想鼓掌
那就随时可以鼓掌

00:21:38.532 --> 00:21:40.434 align:middle
没有人会阻止这一点

00:21:41.602 --> 00:21:42.603 align:middle
没问题
好的 谢谢大家

00:21:45.072 --> 00:21:46.373 align:middle
app看似没问题

00:21:46.440 --> 00:21:47.541 align:middle
我也实现了圆角矩形

00:21:47.608 --> 00:21:48.742 align:middle
非常好 就是我想要的

00:21:48.976 --> 00:21:49.943 align:middle
接下来 我想做的是

00:21:50.010 --> 00:21:52.679 align:middle
让这个app看上去像是当前的app

00:21:54.047 --> 00:21:58.619 align:middle
我不了解大家会怎样但是在参加WWD
C大会之后你是否曾跑到客户那里

00:21:58.685 --> 00:22:01.054 align:middle
说 现在iOS的新版本出来了

00:21:58.685 --> 00:22:01.054 align:middle
说 现在iOS的新版本出来了

00:22:01.121 --> 00:22:02.723 align:middle
比如说iOS 9出来了

00:22:02.789 --> 00:22:05.259 align:middle
我觉得 应该不再支持iOS 8

00:22:05.626 --> 00:22:09.496 align:middle
我们应该只支持新的操作系统

00:22:11.899 --> 00:22:13.100 align:middle
很好<c.blue> </c>你们这么干过吗？

00:22:15.636 --> 00:22:16.937 align:middle
好 那你再去找下一个客户好了

00:22:17.971 --> 00:22:22.376 align:middle
因为大家都希望你支持这些旧版本

00:22:22.676 --> 00:22:27.181 align:middle
iOS 7 8现在可能9
对大部分人而言会在秋天能用上

00:22:27.614 --> 00:22:32.319 align:middle
为实现这一点 我们在Swift
2.0推出了新的可用性功能

00:22:32.386 --> 00:22:34.321 align:middle
只要是用Swift 2.0编写代码

00:22:34.388 --> 00:22:38.292 align:middle
我们有很好的办法来看所用的SDK

00:22:38.358 --> 00:22:40.994 align:middle
无论你是否真会用这种功能与否

00:22:42.529 --> 00:22:44.097 align:middle
去年在WWDC

00:22:44.264 --> 00:22:48.035 align:middle
我们推出了一些新的
视图控制器显示API

00:22:48.735 --> 00:22:50.671 align:middle
可以在iPhone上弹出显示

00:22:51.138 --> 00:22:54.341 align:middle
我想用元素app
做的是当我在支持它的任何设备上

00:22:54.408 --> 00:22:58.111 align:middle
例如在iOS 8或者更新

00:22:58.412 --> 00:22:59.980 align:middle
版本的设备上我想用弹出显示

00:23:00.280 --> 00:23:01.748 align:middle
但是当我在iOS 7上

00:23:01.815 --> 00:23:05.452 align:middle
我想继续使用导航推送显示样式

00:23:06.353 --> 00:23:08.222 align:middle
好 怎么做呢？

00:23:09.556 --> 00:23:14.561 align:middle
这是检测是否支持API的经典办法

00:23:14.895 --> 00:23:17.798 align:middle
无论是什么类型我们都要
检测它是否对选择器有反应

00:23:17.865 --> 00:23:19.800 align:middle
如果有反应我们就用这款选择器

00:23:19.900 --> 00:23:21.568 align:middle
如果没有我们就做其他的事情

00:23:23.837 --> 00:23:27.174 align:middle
在Swift 到Swift 2.0
我们都是这么做的

00:23:27.741 --> 00:23:32.980 align:middle
我们有这个井号标签指定想要的SDK

00:23:33.046 --> 00:23:35.482 align:middle
在本例中是iOS 8.3如果是这样

00:23:35.782 --> 00:23:38.819 align:middle
我们会用到弹出框
如果不是我们用其他方法

00:23:39.419 --> 00:23:42.155 align:middle
这种样式的好处在于你并没有等待

00:23:42.222 --> 00:23:44.358 align:middle
运行时间来看是否实际工作正常

00:23:44.424 --> 00:23:46.593 align:middle
在编译时间编译器会告知你

00:23:47.060 --> 00:23:49.229 align:middle
没问题 这可行或不可行

00:23:49.296 --> 00:23:50.497 align:middle
根据你的部署目标而定

00:23:50.597 --> 00:23:52.432 align:middle
如果我在iOS 7部署

00:23:52.999 --> 00:23:54.735 align:middle
它会告知无法进行弹出

00:23:55.135 --> 00:23:57.171 align:middle
但是因为我进行了妥善保护

00:23:57.538 --> 00:23:59.573 align:middle
提供了另外的路径就可以编译

00:24:02.576 --> 00:24:06.180 align:middle
在本例中 如果我没有进行保护
如果我没有说这里是检测

00:24:07.047 --> 00:24:10.951 align:middle
我想要做编译 准备部署到iOS 7

00:24:12.252 --> 00:24:15.022 align:middle
它就会说 弹出显示
控制器不可用

00:24:15.189 --> 00:24:16.423 align:middle
只能在8或者更新版本才行

00:24:17.157 --> 00:24:18.425 align:middle
然后会给我一些修复

00:24:18.492 --> 00:24:19.927 align:middle
但是我不会用更多的幻灯片

00:24:19.993 --> 00:24:21.094 align:middle
而是直接给大家看代码

00:24:22.095 --> 00:24:22.930 align:middle
好<c.blue> </c>首先

00:24:22.996 --> 00:24:24.731 align:middle
在第二个视图控制器显示的代码

00:24:24.798 --> 00:24:27.668 align:middle
保存在elements
viewcontroller.m.

00:24:28.435 --> 00:24:33.674 align:middle
表视图附件的执行
但是点击了索引路径的行

00:24:34.875 --> 00:24:36.443 align:middle
因为我想使用可用性检测

00:24:36.510 --> 00:24:39.012 align:middle
我只能在Swift上执行

00:24:39.079 --> 00:24:40.747 align:middle
执行而不是Objective-C
我现在就来添加注释

00:24:41.915 --> 00:24:43.884 align:middle
然后我会生成一个类扩展

00:24:43.951 --> 00:24:46.854 align:middle
更像20分钟左右前的
那个最初演示的样子

00:24:47.221 --> 00:24:52.759 align:middle
这样我可以扩展元素视图控制器
并在Swift中执行部分功能

00:24:53.660 --> 00:24:56.163 align:middle
我点击command-N
生成新文件 是Swift文件

00:24:57.965 --> 00:25:00.267 align:middle
是元素视图控制器.Swift

00:24:57.965 --> 00:25:00.267 align:middle
是元素视图控制器.Swift

00:25:01.134 --> 00:25:03.637 align:middle
然后我会在上面编写扩展

00:25:05.606 --> 00:25:08.575 align:middle
扩展 元素视图控制器

00:25:09.977 --> 00:25:15.215 align:middle
其中 我会用 等效的Swift函数

00:25:15.382 --> 00:25:16.984 align:middle
因此这基本上是我在Swift中

00:25:17.084 --> 00:25:18.085 align:middle
已有的相同代码

00:25:18.185 --> 00:25:19.620 align:middle
这里并没有新鲜内容

00:25:19.686 --> 00:25:21.522 align:middle
就是在Swift上执行的相同内容

00:25:21.588 --> 00:25:23.423 align:middle
但是这可以让我进行可用性检测

00:25:25.325 --> 00:25:29.830 align:middle
这个特殊应用是针对 iOS 7.1

00:25:30.731 --> 00:25:35.369 align:middle
我想在其中用这个新的弹出显示
控制器技术

00:25:37.271 --> 00:25:38.805 align:middle
那么就在这一行做注释

00:25:40.140 --> 00:25:43.110 align:middle
并加入代码试着直接调用弹出显示

00:25:47.714 --> 00:25:48.815 align:middle
我有些错误

00:25:49.082 --> 00:25:51.018 align:middle
一个错误是抱怨我没有

00:25:51.084 --> 00:25:54.488 align:middle
真正满足弹出框所需的委托协议

00:25:55.189 --> 00:25:59.226 align:middle
在旁边可以用Swift扩展

00:25:59.293 --> 00:26:02.696 align:middle
并用它来为额外的协议添加一致性

00:25:59.293 --> 00:26:02.696 align:middle
并用它来为额外的协议添加一致性

00:26:02.763 --> 00:26:06.867 align:middle
所以我将添加UI弹出显示控制器委托

00:26:08.368 --> 00:26:11.271 align:middle
这就会消除这个错误但我仍然还有问题

00:26:11.939 --> 00:26:15.809 align:middle
就是要用iOS
7.1中不存在的API

00:26:16.276 --> 00:26:17.644 align:middle
而我却偏偏需要这样

00:26:17.945 --> 00:26:19.179 align:middle
嗯 是在演示中需要如此

00:26:19.847 --> 00:26:21.982 align:middle
我有两种解决办法

00:26:23.917 --> 00:26:25.886 align:middle
现在就给大家简单介绍一下

00:26:28.155 --> 00:26:30.624 align:middle
如果我是在运
在本例中是iOS 8.3

00:26:31.058 --> 00:26:32.426 align:middle
继续 并作为弹出显示

00:26:32.593 --> 00:26:34.261 align:middle
否则 就用导航控制器

00:26:35.963 --> 00:26:40.000 align:middle
现在 如果我运行它 并点击

00:26:42.102 --> 00:26:43.170 align:middle
我们来看这里

00:26:45.038 --> 00:26:46.039 align:middle
我们得到一个弹出框

00:26:46.907 --> 00:26:49.910 align:middle
已经15年了
我们仍在WWDC上见到Carbon

00:26:52.813 --> 00:26:53.647 align:middle
好

00:27:04.758 --> 00:27:06.460 align:middle
若要了解可用性检测的更多详情

00:27:06.827 --> 00:27:09.096 align:middle
可去看周四的讲座《Swift实践》

00:27:09.363 --> 00:27:10.731 align:middle
其中会有大篇幅的相关介绍

00:27:14.067 --> 00:27:15.903 align:middle
接下来 之前的演示是关于

00:27:15.969 --> 00:27:18.939 align:middle
应用外观的改进和现代化处理

00:27:19.006 --> 00:27:21.575 align:middle
要知道 我们改变绘图来取消光泽

00:27:21.642 --> 00:27:23.210 align:middle
我们现在还有弹出框等等 不胜枚举

00:27:23.644 --> 00:27:25.412 align:middle
但是让我们实际增添部分功能

00:27:25.546 --> 00:27:28.515 align:middle
我们要执行智能搜索

00:27:28.882 --> 00:27:30.184 align:middle
为此 我们会来看看

00:27:30.250 --> 00:27:31.652 align:middle
Swift的过滤方法

00:27:31.718 --> 00:27:34.821 align:middle
在所有的集合中都有包括集合和数组

00:27:35.756 --> 00:27:39.393 align:middle
过滤可以用于驱动智能搜索函数
其中只有满足搜索

00:27:39.459 --> 00:27:42.930 align:middle
字符串的原子元素会在表视图中显示

00:27:44.665 --> 00:27:48.335 align:middle
标准设置是这个样子
我们有TableView

00:27:48.402 --> 00:27:51.605 align:middle
TableView
加上视图控制器作为数据源

00:27:52.072 --> 00:27:53.941 align:middle
视图控制器有内容数组

00:27:56.243 --> 00:27:59.413 align:middle
我在搜索域输入一些东西时

00:27:59.847 --> 00:28:01.682 align:middle
就会有个委托方式在视图控制器上叫做

00:27:59.847 --> 00:28:01.682 align:middle
就会有个委托方式在视图控制器上叫做

00:28:01.748 --> 00:28:04.218 align:middle
searchbar:
textDidChange.

00:28:06.153 --> 00:28:07.888 align:middle
我找出传递的字符串

00:28:07.955 --> 00:28:09.022 align:middle
那只是一个参数

00:28:09.089 --> 00:28:10.657 align:middle
我过滤内容数组

00:28:10.924 --> 00:28:13.927 align:middle
并告知TableView用过滤后的

00:28:15.562 --> 00:28:17.231 align:middle
内容数组进行更新

00:28:17.297 --> 00:28:19.766 align:middle
Searchbar:
textDidChange

00:28:19.833 --> 00:28:21.401 align:middle
基本是这样

00:28:22.269 --> 00:28:24.037 align:middle
实际上 就是这个样子

00:28:24.104 --> 00:28:25.472 align:middle
因为这就是我用的代码

00:28:25.906 --> 00:28:27.040 align:middle
现在我要大家注意

00:28:27.574 --> 00:28:29.910 align:middle
标亮的部分是个闭包

00:28:30.477 --> 00:28:32.713 align:middle
我正在运行过滤器 在过滤器中

00:28:33.013 --> 00:28:35.382 align:middle
会应用数组中的每一项

00:28:35.816 --> 00:28:38.585 align:middle
数组中的项我有占位控件

00:28:38.986 --> 00:28:41.622 align:middle
是$0我得到了它的名称
接着询问它是否有前缀

00:28:41.688 --> 00:28:42.789 align:middle
无论搜索字符串是什么

00:28:45.792 --> 00:28:48.729 align:middle
都会这样运行 顶部是最初的数组

00:28:49.129 --> 00:28:51.198 align:middle
我有一个封闭的过滤器

00:28:51.832 --> 00:28:52.933 align:middle
会循环

00:28:52.999 --> 00:28:54.601 align:middle
每次都会传递元素

00:28:54.668 --> 00:28:57.538 align:middle
如果名称前有字母在本例中是N

00:28:57.871 --> 00:28:59.773 align:middle
它被传递给返回过滤数组

00:29:01.008 --> 00:29:02.376 align:middle
如果没有字母 那就不是

00:29:02.943 --> 00:29:04.011 align:middle
我给大家看看代码

00:29:04.411 --> 00:29:06.280 align:middle
但是为加快速度我已经运行过

00:29:06.947 --> 00:29:08.248 align:middle
把搜索条放在上面

00:29:08.982 --> 00:29:09.950 align:middle
但我还没搭建好

00:29:10.017 --> 00:29:11.418 align:middle
那么如果我试着在里面做点什么

00:29:12.386 --> 00:29:14.621 align:middle
都不会奏效 因为我没有加入委托方式

00:29:16.623 --> 00:29:18.625 align:middle
委托方式是这个

00:29:23.030 --> 00:29:24.665 align:middle
也就是说 如果搜索文本为空
就在这里

00:29:24.731 --> 00:29:27.234 align:middle
显示所有原子元素

00:29:28.235 --> 00:29:30.537 align:middle
如果不是空我想做个过滤器

00:29:30.604 --> 00:29:32.005 align:middle
这部分需要完成

00:29:32.072 --> 00:29:32.940 align:middle
我们现在就动手

00:29:38.278 --> 00:29:39.746 align:middle
我准备一个过滤器

00:29:40.013 --> 00:29:41.648 align:middle
如果这是大家第一次见到闭包

00:29:42.015 --> 00:29:43.684 align:middle
不错 欢迎闭包

00:29:43.884 --> 00:29:44.952 align:middle
我来给大家多讲几句

00:29:45.018 --> 00:29:46.787 align:middle
如果不是的话就当是复习了

00:29:47.354 --> 00:29:50.023 align:middle
当Xcode显示这种蓝色符号化背景

00:29:50.090 --> 00:29:52.226 align:middle
还都是单项可以双击

00:29:52.292 --> 00:29:54.528 align:middle
会展开需要填入空白部分

00:29:54.795 --> 00:29:57.531 align:middle
我会用这个闭包双击 会展开

00:29:59.499 --> 00:30:03.637 align:middle
我知道
有原子元素数组数据类型叫原子元素

00:29:59.499 --> 00:30:03.637 align:middle
我知道
有原子元素数组数据类型叫原子元素

00:30:04.137 --> 00:30:07.341 align:middle
如果传递的参数是一个原子元素

00:30:07.975 --> 00:30:10.077 align:middle
我会明确在闭包中

00:30:10.611 --> 00:30:13.213 align:middle
所传递的参数是原子元素

00:30:13.280 --> 00:30:17.551 align:middle
我会给它一个本地名称
这样原子元素有了自己的本地名称

00:30:17.618 --> 00:30:20.053 align:middle
而数据类型是原子元素

00:30:21.255 --> 00:30:23.824 align:middle
在闭包中 我需要检查是否要将它

00:30:23.891 --> 00:30:26.760 align:middle
包括在过滤结果中

00:30:27.127 --> 00:30:29.763 align:middle
因为我承诺给出Boolean返回值

00:30:30.964 --> 00:30:35.736 align:middle
我来看返回值是否是原子元素

00:30:38.438 --> 00:30:43.110 align:middle
名称
有前缀 再看搜索条传递的搜索文本

00:30:48.148 --> 00:30:50.150 align:middle
像这样 现在 当我运行的时候

00:30:55.489 --> 00:30:59.092 align:middle
我们会搜索所有以字母N开始的内容

00:30:59.493 --> 00:31:02.029 align:middle
就这样
我们用Swift过滤器过滤了

00:30:59.493 --> 00:31:02.029 align:middle
就这样
我们用Swift过滤器过滤了

00:31:03.330 --> 00:31:04.831 align:middle
但是有两方面内容需要给大家展示

00:31:04.898 --> 00:31:07.701 align:middle
其一 有两种方法可以来看闭包

00:31:07.768 --> 00:31:09.436 align:middle
这里是个扩展句法

00:31:11.872 --> 00:31:13.373 align:middle
这里还有精简句法

00:31:13.607 --> 00:31:15.108 align:middle
我来给大家看看精简句法

00:31:16.476 --> 00:31:19.146 align:middle
Swift有非常强大的类型推断系统

00:31:19.213 --> 00:31:21.648 align:middle
我们可根据上下文和所使用的数据类型

00:31:21.715 --> 00:31:23.050 align:middle
推断出很多内容

00:31:23.617 --> 00:31:26.653 align:middle
例如 如果在闭包有个单独行

00:31:26.720 --> 00:31:29.289 align:middle
假设它将返回一个值

00:31:29.356 --> 00:31:30.557 align:middle
那我不必放入返回值

00:31:30.858 --> 00:31:35.262 align:middle
实际上 如果前缀
返回了Boolean类型

00:31:35.329 --> 00:31:37.564 align:middle
Swift可推断这个闭包的返回类型

00:31:37.631 --> 00:31:40.167 align:middle
就是Boolean 所以我不需要

00:31:40.534 --> 00:31:42.970 align:middle
把它放在这里也就是说我也不必

00:31:43.036 --> 00:31:45.305 align:middle
把它放在那里因为原子元素

00:31:45.806 --> 00:31:49.643 align:middle
我就不必明确 原子元素需要传递
就可以不要这部分

00:31:50.177 --> 00:31:53.247 align:middle
因为我没有任何参数 我不必区分代码

00:31:53.313 --> 00:31:54.681 align:middle
和参数 那么我不需要关键词

00:31:55.549 --> 00:31:58.085 align:middle
也就是说 可以不要这部分

00:31:59.219 --> 00:32:02.456 align:middle
节省空间
最后我得到的是这样的东西

00:31:59.219 --> 00:32:02.456 align:middle
节省空间
最后我得到的是这样的东西

00:32:05.225 --> 00:32:07.528 align:middle
因为最后的

00:32:07.594 --> 00:32:11.231 align:middle
过滤方法参数是闭包本身

00:32:12.199 --> 00:32:14.902 align:middle
我们可以把它变成结尾闭包
并且可以删掉括号

00:32:15.669 --> 00:32:17.871 align:middle
我们得到的是这个样子

00:32:18.472 --> 00:32:19.706 align:middle
现在唯一的问题是

00:32:19.773 --> 00:32:22.109 align:middle
没有符号声明调用了原子元素

00:32:22.609 --> 00:32:23.577 align:middle
因为我删掉了

00:32:24.278 --> 00:32:28.315 align:middle
但是我可以每次传递给过滤闭包一个项

00:32:28.382 --> 00:32:32.152 align:middle
而且可以这样参考那个参数

00:32:32.853 --> 00:32:35.255 align:middle
这是完全一样的代码
如果大家怀念Perl代码

00:32:35.722 --> 00:32:37.191 align:middle
这里就是

00:32:44.498 --> 00:32:46.066 align:middle
现在可以检测一下

00:32:46.133 --> 00:32:48.302 align:middle
我们放入字母N 不错

00:32:48.902 --> 00:32:51.538 align:middle
现在有了这些元素不过
它们不是在正确的方向分类

00:32:51.805 --> 00:32:52.840 align:middle
实际上 它们就没有分类

00:32:53.140 --> 00:32:55.375 align:middle
我们快速继续加入分类

00:32:55.809 --> 00:32:58.345 align:middle
我会把它加在现有闭包的结尾

00:32:58.412 --> 00:33:01.682 align:middle
.sort在本例中

00:32:58.412 --> 00:33:01.682 align:middle
.sort在本例中

00:33:01.748 --> 00:33:05.118 align:middle
我双击这个蓝色的符号 让它展开

00:33:05.185 --> 00:33:07.154 align:middle
还有很多方式可以比较字符串

00:33:07.287 --> 00:33:10.490 align:middle
比如大小写和区分比较本地化比较等等

00:33:10.824 --> 00:33:13.794 align:middle
但是因为我知道某种程度上 我得到

00:33:14.261 --> 00:33:17.497 align:middle
一个原子元素
接着又得到一个原子元素

00:33:17.564 --> 00:33:21.902 align:middle
我只需要明确哪个在前 哪个在后

00:33:22.202 --> 00:33:24.404 align:middle
或是否一个在另一个之前 我可以自己

00:33:24.538 --> 00:33:28.041 align:middle
编写闭包首先识别
我会有两个原子元素传递过来

00:33:28.709 --> 00:33:31.812 align:middle
拿到第一个来查看名称

00:33:31.879 --> 00:33:32.913 align:middle
然后是第二个

00:33:32.980 --> 00:33:33.947 align:middle
也要查看名称

00:33:36.416 --> 00:33:38.452 align:middle
其本身不会做比较

00:33:39.019 --> 00:33:41.288 align:middle
但是在Swift中我们过载了

00:33:41.355 --> 00:33:44.057 align:middle
许多标准运算符例如大于和小于

00:33:44.124 --> 00:33:47.261 align:middle
那么它们会在你可能不希望它们处理的
类型上发挥作用 比如字符串

00:33:50.097 --> 00:33:51.498 align:middle
这是字符串比较

00:33:52.999 --> 00:33:54.201 align:middle
我再次运行

00:33:57.437 --> 00:34:01.408 align:middle
搜索字母N 现在分类妥当了

00:33:57.437 --> 00:34:01.408 align:middle
搜索字母N 现在分类妥当了

00:34:01.475 --> 00:34:03.644 align:middle
过滤和分类都在一行

00:34:04.011 --> 00:34:04.978 align:middle
我再检查一遍

00:34:05.045 --> 00:34:06.380 align:middle
我们搜索S

00:34:06.713 --> 00:34:08.047 align:middle
我有一些非常重要的元素

00:34:08.681 --> 00:34:10.016 align:middle
比如Swiftonium

00:34:11.318 --> 00:34:12.386 align:middle
非常重要

00:34:13.587 --> 00:34:16.489 align:middle
好的<c.blue> </c>我们回来

00:34:17.623 --> 00:34:20.561 align:middle
在这部分我们通过

00:34:20.627 --> 00:34:23.362 align:middle
Swift的过滤方法执行过滤表视图

00:34:25.599 --> 00:34:30.036 align:middle
然后用分类进行分类
看到过载操作符是小于或是大于

00:34:31.271 --> 00:34:33.907 align:middle
下面的功能
也是我想加入app中的最后一个功能

00:34:34.107 --> 00:34:37.476 align:middle
是可以选择多个行 再做累计以便得到

00:34:37.811 --> 00:34:40.112 align:middle
所选元素的原子量

00:34:40.347 --> 00:34:41.348 align:middle
是这样的

00:34:41.715 --> 00:34:44.117 align:middle
我们先从表视图开始

00:34:44.818 --> 00:34:47.286 align:middle
顶部的导航条说选择二或更多项

00:34:48.222 --> 00:34:52.626 align:middle
你选择二或更多项
接着顶部的导航条确定其原子量总数

00:34:54.795 --> 00:34:57.097 align:middle
为实现这一点我从内容数组开始

00:34:57.164 --> 00:34:58.899 align:middle
这就是我有的全部原子元素

00:34:58.966 --> 00:35:00.767 align:middle
那些是在表视图中显示的全部

00:34:58.966 --> 00:35:00.767 align:middle
那些是在表视图中显示的全部

00:35:01.001 --> 00:35:05.405 align:middle
但是我只想要 选中的原子元素

00:35:06.273 --> 00:35:08.942 align:middle
为此 我不能前往表视图

00:35:09.009 --> 00:35:12.646 align:middle
让询问视图所选项的数组

00:35:12.946 --> 00:35:16.750 align:middle
我只能通过所选项的索引路径来找

00:35:19.052 --> 00:35:22.189 align:middle
表视图会给我所选项的索引路径数组

00:35:22.389 --> 00:35:24.458 align:middle
我可以询问索引路径 还获得这一行

00:35:24.525 --> 00:35:27.261 align:middle
我可以将这与支持数组内容相关联

00:35:27.661 --> 00:35:30.597 align:middle
从这里 生成所选元素

00:35:31.265 --> 00:35:32.366 align:middle
基本上 就是这个

00:35:32.999 --> 00:35:34.067 align:middle
我们生成新数组

00:35:34.334 --> 00:35:36.003 align:middle
循环索引路径

00:35:36.236 --> 00:35:37.571 align:middle
返回内容

00:35:37.771 --> 00:35:42.910 align:middle
为当前的索引路径的行
找出对应的原子元素

00:35:43.443 --> 00:35:45.746 align:middle
如果你们习惯于这样编码

00:35:46.713 --> 00:35:48.549 align:middle
在Swift中也可以同样

00:35:49.316 --> 00:35:50.150 align:middle
这是映射函数

00:35:51.051 --> 00:35:53.287 align:middle
重要的内容 还是用橙色表示

00:35:53.587 --> 00:35:55.155 align:middle
周围所有的额外基础架构

00:35:55.222 --> 00:35:56.490 align:middle
都已经删除

00:35:58.859 --> 00:36:02.729 align:middle
接下来 一旦我有所有所选项的数组

00:35:58.859 --> 00:36:02.729 align:middle
接下来 一旦我有所有所选项的数组

00:36:03.697 --> 00:36:05.666 align:middle
我就想加上原子量

00:36:06.166 --> 00:36:09.770 align:middle
为此 我会传统地使用一个外循环

00:36:09.837 --> 00:36:12.039 align:middle
那里 我把其变量设置为零

00:36:12.105 --> 00:36:16.043 align:middle
接着重复所选对象并加上

00:36:16.109 --> 00:36:18.645 align:middle
在本例中是D原子量

00:36:18.812 --> 00:36:21.148 align:middle
如果习惯用for-in循环做这类事

00:36:21.381 --> 00:36:22.916 align:middle
可以在Swift中也同样如此

00:36:23.150 --> 00:36:26.153 align:middle
通过化简函数 我们将初始值设为零

00:36:26.220 --> 00:36:29.356 align:middle
接下来
我们加上采用初始值的闭包也就是零值

00:36:29.756 --> 00:36:32.960 align:middle
再把它附在传递来的下一项后面做累加

00:36:33.994 --> 00:36:36.563 align:middle
我给大家看看代码 不过我会把所做的

00:36:37.030 --> 00:36:37.965 align:middle
全部内容用一行代码

00:36:38.165 --> 00:36:39.800 align:middle
进行综述像这样

00:36:40.834 --> 00:36:42.503 align:middle
有个图形设计师看过演示后

00:36:42.569 --> 00:36:44.538 align:middle
曾经问过我
能不能把这些放在一行中？

00:36:45.539 --> 00:36:46.907 align:middle
不 不可以

00:36:46.974 --> 00:36:47.975 align:middle
我觉得 你们看不到

00:36:48.442 --> 00:36:53.013 align:middle
我们转到演示电脑上

00:37:02.823 --> 00:37:05.425 align:middle
现在就是所有内容的函数

00:37:05.626 --> 00:37:08.862 align:middle
首先要确保选中的是两个以上的项

00:37:09.196 --> 00:37:11.532 align:middle
这样大家可以看到

00:37:11.632 --> 00:37:15.836 align:middle
只要选中的项大于或
等于2就要继续执行这个代码

00:37:17.171 --> 00:37:20.507 align:middle
然后我会用映射
这样可以获得通过表视图

00:37:20.574 --> 00:37:21.875 align:middle
而不是索引路径所选定的对象

00:37:22.743 --> 00:37:25.078 align:middle
接着用化简函数进行累加

00:37:25.846 --> 00:37:28.682 align:middle
最后
通过数字格式器传递固定在标题部分

00:37:29.149 --> 00:37:31.618 align:middle
如果想在一行内看到同样内容
就是这样

00:37:34.288 --> 00:37:35.622 align:middle
在我运行程序时

00:37:39.726 --> 00:37:41.261 align:middle
就会做累加并把结果放在顶部

00:37:42.062 --> 00:37:47.034 align:middle
这样显示映射和化简会使与支持表视图
的项一起配合会更容易些

00:37:56.176 --> 00:37:59.446 align:middle
好 总之

00:38:00.314 --> 00:38:03.450 align:middle
我希望大家发现使用Swift
会有很多好处

00:38:03.517 --> 00:38:06.053 align:middle
甚至可以和现有的
Objective-C项目配合使用

00:38:06.119 --> 00:38:08.922 align:middle
这并不难 而且还有诸多好处

00:38:09.489 --> 00:38:11.225 align:middle
大家不必把任何现有代码都扔掉

00:38:11.291 --> 00:38:15.996 align:middle
而且会习惯使用这些现代的强大技术
例如化简和映射

00:38:16.063 --> 00:38:17.631 align:middle
和这些功能强大的结构等等

00:38:18.532 --> 00:38:20.267 align:middle
若想了解更多详情可以来实验室找我们

00:38:20.334 --> 00:38:22.669 align:middle
查看文档资料访问开发人员论坛

00:38:23.003 --> 00:38:24.238 align:middle
给斯特凡发邮件

00:38:24.304 --> 00:38:25.205 align:middle
他喜欢收邮件

00:38:25.272 --> 00:38:27.274 align:middle
你可以告诉他大会开的非常好
就行了

00:38:27.741 --> 00:38:29.810 align:middle
这么说 我会非常感谢你
希望大家喜欢这次大会
