WEBVTT

00:00:19.319 --> 00:00:23.957 align:middle
高级调试和地址消毒剂

00:00:27.794 --> 00:00:28.629 align:middle
早上好

00:00:29.296 --> 00:00:32.064 align:middle
欢迎来参加《高级调试和
地址消毒剂》讲座

00:00:32.566 --> 00:00:34.501 align:middle
我是麦克...
大家怎么样呢？

00:00:35.035 --> 00:00:36.503 align:middle
好吗？准备好啦？

00:00:36.870 --> 00:00:37.704 align:middle
激动吗？

00:00:38.105 --> 00:00:39.039 align:middle
好 现在就开始

00:00:42.309 --> 00:00:45.412 align:middle
那我先来介绍
Xcode中加入的新功能

00:00:45.479 --> 00:00:47.414 align:middle
还有一些大家

00:00:47.481 --> 00:00:49.283 align:middle
可能不知道的
新旧技巧和诀窍

00:00:50.184 --> 00:00:51.552 align:middle
先来说说视图调试器

00:00:51.785 --> 00:00:53.820 align:middle
来看怎样才能
获得更多洞察力

00:00:53.887 --> 00:00:55.722 align:middle
关于你的app UI及其用户...

00:00:57.391 --> 00:01:00.127 align:middle
界面元素 以及它们
在运行时间如何表现

00:00:57.391 --> 00:01:00.127 align:middle
界面元素 以及它们
在运行时间如何表现

00:01:00.727 --> 00:01:02.996 align:middle
我们会调试
AutoLayout Constraint问题

00:01:03.063 --> 00:01:05.364 align:middle
至少对我而言
我需要一些帮助

00:01:05.432 --> 00:01:07.868 align:middle
理解AutoLayout在
运行时间做些什么

00:01:08.969 --> 00:01:10.838 align:middle
接下来 我们将详细分析用

00:01:10.904 --> 00:01:12.606 align:middle
Advanced Breakpoints
调试代码

00:01:13.106 --> 00:01:16.276 align:middle
我想给大家看看
如何设置自定义操作和条件

00:01:16.577 --> 00:01:18.245 align:middle
快速分析例外情况

00:01:18.478 --> 00:01:19.947 align:middle
在一定条件下打印值

00:01:20.180 --> 00:01:22.916 align:middle
而不会因NSLogs和
打印把代码搞乱

00:01:23.917 --> 00:01:26.987 align:middle
之后 我的同事安娜
会来介绍

00:01:27.054 --> 00:01:29.356 align:middle
最新最兴奋的调试功能
这就是我们新加入

00:01:29.423 --> 00:01:32.559 align:middle
Xcodes调试工具箱的
Address Sanitizer

00:01:33.460 --> 00:01:35.395 align:middle
她会详细介绍
其工作方式

00:01:35.462 --> 00:01:36.997 align:middle
可以捕捉到哪些问题

00:01:37.064 --> 00:01:40.634 align:middle
以及今天就用它
来整理代码

00:01:41.134 --> 00:01:44.037 align:middle
为了这两个话题
我觉得先用

00:01:44.304 --> 00:01:46.773 align:middle
演示设备
给大家看看

00:01:55.849 --> 00:01:58.785 align:middle
这里是个应用
名为Jogr

00:02:00.087 --> 00:02:03.490 align:middle
这个健身应用
可以为跑步计时

00:02:03.557 --> 00:02:07.127 align:middle
记录跑步路线
沿途会为照片加标签

00:02:07.828 --> 00:02:10.497 align:middle
几年来我们都用Jogr
来做示范app

00:02:10.564 --> 00:02:13.800 align:middle
今年我们添加了
一些使用Swift的新功能

00:02:14.101 --> 00:02:17.437 align:middle
并转换了Objective-C
的若干类

00:02:17.671 --> 00:02:19.206 align:middle
这是个非常混合的应用

00:02:19.940 --> 00:02:22.643 align:middle
在故事板中也用了尺寸类

00:02:22.709 --> 00:02:24.378 align:middle
并完全采用了AutoLayout

00:02:25.379 --> 00:02:27.915 align:middle
因为今年我们改变并增加了
所有这些新代码

00:02:28.215 --> 00:02:30.117 align:middle
可想而知其中会有程序错误

00:02:30.384 --> 00:02:31.552 align:middle
来找找看

00:02:32.452 --> 00:02:35.889 align:middle
先来点击这里的计时器

00:02:36.523 --> 00:02:40.127 align:middle
第一个非常明显的问题是

00:02:40.194 --> 00:02:43.630 align:middle
计时器周围的圆环
不是很整齐

00:02:44.131 --> 00:02:48.101 align:middle
在我提供的最初设计中
并不是这样

00:02:49.036 --> 00:02:50.904 align:middle
这可能是Jogr是在iPhone5

00:02:50.971 --> 00:02:53.740 align:middle
的屏幕上运行有关的

00:02:54.474 --> 00:02:56.410 align:middle
而当初是在
iPhone 6上开发的

00:02:56.510 --> 00:02:58.145 align:middle
可能是我没有完全测试

00:02:58.212 --> 00:03:01.315 align:middle
来看布局是否在小号的
屏幕上也适用

00:02:58.212 --> 00:03:01.315 align:middle
来看布局是否在小号的
屏幕上也适用

00:03:01.648 --> 00:03:05.352 align:middle
为了想了解
到底出了什么问题

00:03:05.686 --> 00:03:08.522 align:middle
我在下面的Debug条上

00:03:08.589 --> 00:03:12.192 align:middle
点击了DebugView
Hierarchy按钮

00:03:12.993 --> 00:03:16.196 align:middle
现在 获得了所有
视图的快照

00:03:16.263 --> 00:03:19.399 align:middle
并在Xcode中装载了
关于视图

00:03:19.466 --> 00:03:21.702 align:middle
会如何互动的运行时间信息

00:03:23.203 --> 00:03:26.406 align:middle
我点击并拖动画布

00:03:26.773 --> 00:03:29.409 align:middle
你会看到我可以
怎样扭动场景

00:03:29.476 --> 00:03:31.545 align:middle
显示所有的不同视图
以及它们如何在

00:03:31.612 --> 00:03:32.646 align:middle
彼此上方分层

00:03:32.713 --> 00:03:35.382 align:middle
我甚至还点击具体视图来选择

00:03:36.083 --> 00:03:39.219 align:middle
我们可以在对象检测器中看到

00:03:39.286 --> 00:03:40.487 align:middle
所有细节

00:03:41.688 --> 00:03:43.557 align:middle
现在有许多内容在继续

00:03:43.891 --> 00:03:47.294 align:middle
有导航条和背景所有这些

00:03:47.361 --> 00:03:49.463 align:middle
可我只想关注大家在意的一点

00:03:49.530 --> 00:03:52.299 align:middle
也就是我放在中心的内容部分

00:03:53.400 --> 00:03:56.970 align:middle
只要双击视图就可以做到

00:03:57.337 --> 00:04:00.641 align:middle
万一你忘记了
我给大家看看怎么失焦

00:03:57.337 --> 00:04:00.641 align:middle
万一你忘记了
我给大家看看怎么失焦

00:04:00.707 --> 00:04:02.409 align:middle
就是在画布上双击即可

00:04:03.110 --> 00:04:06.446 align:middle
这里可以继续只关注这一点

00:04:07.648 --> 00:04:11.451 align:middle
你会注意到在这里
在Debug Navigator

00:04:11.618 --> 00:04:13.654 align:middle
UI堆栈视图上的

00:04:15.222 --> 00:04:18.225 align:middle
所有层次都已经省略

00:04:18.291 --> 00:04:20.928 align:middle
因为我们最近
在关注UI堆栈视图

00:04:24.765 --> 00:04:30.237 align:middle
如果我点击修剪后的图像

00:04:30.804 --> 00:04:34.041 align:middle
我可以用这里的尺寸检测器

00:04:34.141 --> 00:04:39.112 align:middle
检测平衡和约束条件

00:04:39.780 --> 00:04:43.183 align:middle
尺寸检测器不仅是显示x y

00:04:43.250 --> 00:04:47.120 align:middle
和这个的矩形坐标
还显示了

00:04:47.187 --> 00:04:49.423 align:middle
影响视图运行时间的约束

00:04:49.957 --> 00:04:53.560 align:middle
约束并非是现在在发挥作用

00:04:53.627 --> 00:04:56.930 align:middle
它影响了大小 边界
或是x y

00:04:57.331 --> 00:04:58.999 align:middle
在这里用灰色显示

00:04:59.833 --> 00:05:01.869 align:middle
那么这就有点奇怪

00:04:59.833 --> 00:05:01.869 align:middle
那么这就有点奇怪

00:05:02.135 --> 00:05:05.706 align:middle
我看到高度约束是249点

00:05:05.806 --> 00:05:07.941 align:middle
这实际是这个
图像内容的实际尺寸

00:05:08.041 --> 00:05:09.843 align:middle
在运行时间
却没有真正运行

00:05:10.177 --> 00:05:11.345 align:middle
如果我来看约束

00:05:11.411 --> 00:05:15.649 align:middle
表示父视图应该和
图像同等大小

00:05:15.916 --> 00:05:17.184 align:middle
我们看到它在运行

00:05:17.618 --> 00:05:20.020 align:middle
看似是有其他部分在约束

00:05:20.087 --> 00:05:21.455 align:middle
父视图的大小

00:05:22.122 --> 00:05:25.092 align:middle
我们来看视图层次

00:05:25.192 --> 00:05:26.660 align:middle
了解一下父视图发生了些什么

00:05:29.429 --> 00:05:32.399 align:middle
这里
我们看到与其他视图

00:05:33.300 --> 00:05:38.272 align:middle
是四分之三
或.75的关系

00:05:38.539 --> 00:05:40.274 align:middle
我知道另一个视图

00:05:40.340 --> 00:05:42.643 align:middle
包括下面的起始按钮

00:05:43.443 --> 00:05:45.479 align:middle
在调试导航器上
我们还看到

00:05:45.546 --> 00:05:46.980 align:middle
所有的同样约束

00:05:47.247 --> 00:05:49.716 align:middle
可以像这样 打开

00:05:51.652 --> 00:05:54.388 align:middle
我们看到
约束按钮的视图上

00:05:54.621 --> 00:05:56.456 align:middle
有着相同的
四分之三约束

00:05:56.890 --> 00:05:58.725 align:middle
所有这些
看上去都很正常

00:05:58.792 --> 00:06:01.328 align:middle
上下关系
都是有条理的

00:05:58.792 --> 00:06:01.328 align:middle
上下关系
都是有条理的

00:06:01.395 --> 00:06:02.930 align:middle
顶部高于底部

00:06:02.996 --> 00:06:06.300 align:middle
底部和父视图底部相连
没别的了

00:06:06.500 --> 00:06:09.803 align:middle
为什么我们
不能把视图层次再提高一层

00:06:11.839 --> 00:06:16.577 align:middle
我们可以看出 这里有些奇怪

00:06:17.277 --> 00:06:19.947 align:middle
我们有个中心 y-约束

00:06:20.013 --> 00:06:23.217 align:middle
它想把整个堆栈视图中心

00:06:23.283 --> 00:06:25.352 align:middle
垂直于容器中

00:06:25.419 --> 00:06:28.722 align:middle
但是我们把这个自身顶部

00:06:28.789 --> 00:06:31.692 align:middle
与父视图顶部相连
在50点

00:06:32.192 --> 00:06:33.961 align:middle
这也有些奇怪

00:06:36.530 --> 00:06:38.699 align:middle
我觉得50点的
约束不应该在这里

00:06:39.066 --> 00:06:40.367 align:middle
我觉得在我开始

00:06:40.434 --> 00:06:42.903 align:middle
打开视图到尺寸类时
它可能就已经加上了

00:06:42.970 --> 00:06:45.639 align:middle
我告知IB
加入所有丢掉的约束

00:06:46.073 --> 00:06:47.941 align:middle
之后我设置了垂直中心对齐

00:06:48.008 --> 00:06:49.910 align:middle
我可能是忘记删除了

00:06:49.977 --> 00:06:53.580 align:middle
我们在故事板上做修改

00:06:55.182 --> 00:06:56.517 align:middle
来看是不是问题所在

00:06:57.518 --> 00:07:01.388 align:middle
我可以选择堆栈视图
就在这里

00:06:57.518 --> 00:07:01.388 align:middle
我可以选择堆栈视图
就在这里

00:07:01.455 --> 00:07:03.090 align:middle
这是50点约束

00:07:03.156 --> 00:07:04.258 align:middle
我会删掉它

00:07:04.992 --> 00:07:06.059 align:middle
重新运行

00:07:09.396 --> 00:07:10.230 align:middle
不错！

00:07:10.297 --> 00:07:13.300 align:middle
现在圆形没问题了

00:07:13.433 --> 00:07:16.370 align:middle
没有缺失
视图也完全可以修改

00:07:17.571 --> 00:07:20.407 align:middle
我们再来运行计时器

00:07:22.876 --> 00:07:24.811 align:middle
好的看似有异常

00:07:25.846 --> 00:07:28.448 align:middle
我会打开
Debug Navigator

00:07:28.515 --> 00:07:31.852 align:middle
查看异常的线程

00:07:32.452 --> 00:07:34.488 align:middle
但是看似不是很有用

00:07:34.988 --> 00:07:37.124 align:middle
应该是主函数出了问题

00:07:37.658 --> 00:07:41.628 align:middle
如果从控制台来看

00:07:41.695 --> 00:07:45.732 align:middle
可以看到
是抛出了部分异常

00:07:46.033 --> 00:07:48.302 align:middle
但是现在对我来说帮助不大

00:07:48.368 --> 00:07:51.271 align:middle
因为我想停止程序

00:07:51.338 --> 00:07:52.172 align:middle
在抛出异常的时刻

00:07:52.239 --> 00:07:53.941 align:middle
对它进行调试

00:07:55.075 --> 00:07:59.079 align:middle
为此 我可以进入
Breakpoint Navigator

00:07:59.680 --> 00:08:04.451 align:middle
点击下面的加号
添加异常断点

00:07:59.680 --> 00:08:04.451 align:middle
点击下面的加号
添加异常断点

00:08:05.052 --> 00:08:06.820 align:middle
我接下来要配置这个断点

00:08:06.887 --> 00:08:09.289 align:middle
来停止Objective-C异常

00:08:12.993 --> 00:08:13.827 align:middle
像这样

00:08:14.361 --> 00:08:17.164 align:middle
我们从新运行应用

00:08:19.333 --> 00:08:21.869 align:middle
希望我们在问题发生时

00:08:22.503 --> 00:08:25.105 align:middle
能准确找到问题

00:08:26.306 --> 00:08:28.075 align:middle
非常好 但是...

00:08:29.076 --> 00:08:32.379 align:middle
如果我去看控制台
却什么都看不到

00:08:32.513 --> 00:08:36.416 align:middle
没有信息描述
异常是什么

00:08:37.116 --> 00:08:38.552 align:middle
这里有个技巧

00:08:38.619 --> 00:08:40.953 align:middle
是我从LLVM团队的
朋友那里学来的

00:08:41.355 --> 00:08:42.422 align:middle
导航进入

00:08:42.556 --> 00:08:44.758 align:middle
Ob-C Exception
Throw函数

00:08:44.825 --> 00:08:46.460 align:middle
在Ob-C的运行时间中

00:08:46.527 --> 00:08:49.563 align:middle
打印函数的首个参数

00:08:49.997 --> 00:08:52.366 align:middle
实际上是异常对象本身

00:08:52.799 --> 00:08:55.135 align:middle
我说 打印对象

00:08:55.903 --> 00:08:56.737 align:middle
arg1

00:08:57.271 --> 00:09:01.275 align:middle
这就是 异常信息本身

00:08:57.271 --> 00:09:01.275 align:middle
这就是 异常信息本身

00:09:02.109 --> 00:09:03.844 align:middle
因此我会调整异常断点

00:09:03.911 --> 00:09:08.315 align:middle
为所出现的异常
始终这么做

00:09:08.382 --> 00:09:09.716 align:middle
这样会很有帮助

00:09:10.317 --> 00:09:12.653 align:middle
我可以在这里添加一个操作

00:09:13.320 --> 00:09:16.456 align:middle
输入的内容和
输入控制台的完全一样

00:09:17.157 --> 00:09:19.660 align:middle
打印对象 arg1

00:09:21.161 --> 00:09:24.464 align:middle
现在
如果我再次运行应用

00:09:27.334 --> 00:09:28.402 align:middle
运行计时器

00:09:29.469 --> 00:09:31.738 align:middle
现在我仍然停在

00:09:31.805 --> 00:09:35.642 align:middle
异常被抛出的准确时刻

00:09:36.210 --> 00:09:40.214 align:middle
我实际上在控制台
有异常信息本身

00:09:41.181 --> 00:09:43.884 align:middle
现在
当我看着异常

00:09:44.184 --> 00:09:46.753 align:middle
被抛出的代码行

00:09:47.020 --> 00:09:49.656 align:middle
可以看到我构建的范围

00:09:50.591 --> 00:09:54.795 align:middle
范围超出了边界
估计是用了

00:09:54.962 --> 00:09:57.798 align:middle
索引1开头
而不是索引0

00:09:57.865 --> 00:09:59.766 align:middle
并且在设定字体属性时

00:09:59.833 --> 00:10:01.835 align:middle
执行了
字符串的全长

00:09:59.833 --> 00:10:01.835 align:middle
执行了
字符串的全长

00:10:02.569 --> 00:10:05.272 align:middle
我们重新运行

00:10:06.840 --> 00:10:09.176 align:middle
再看看效果

00:10:09.543 --> 00:10:13.847 align:middle
看似计时器
现在工作正常

00:10:14.882 --> 00:10:18.418 align:middle
我们成功发现了
两处程序错误

00:10:18.519 --> 00:10:20.187 align:middle
我再看第三个

00:10:21.088 --> 00:10:24.691 align:middle
现在来看
来这里之前

00:10:24.791 --> 00:10:28.362 align:middle
我今天早上跑步的路线

00:10:29.296 --> 00:10:31.999 align:middle
看似没问题

00:10:33.367 --> 00:10:36.537 align:middle
但如果我们返回

00:10:36.670 --> 00:10:39.940 align:middle
则有些不对劲
我不是从莫斯科尼出发

00:10:40.007 --> 00:10:41.408 align:middle
跑到码头大街

00:10:41.475 --> 00:10:44.678 align:middle
然后跳到了水里
这是在太蠢了

00:10:44.811 --> 00:10:47.581 align:middle
我们再试一遍

00:10:48.815 --> 00:10:50.684 align:middle
这里出现了异常

00:10:50.751 --> 00:10:56.456 align:middle
我不知道
看似是数据模型出现了问题

00:10:56.757 --> 00:10:59.560 align:middle
所以我想找出
放在地图上的各点

00:11:00.360 --> 00:11:02.529 align:middle
出现覆盖时

00:11:02.863 --> 00:11:04.398 align:middle
我们在做什么

00:11:06.567 --> 00:11:10.771 align:middle
现在进入类
是这里

00:11:10.904 --> 00:11:14.575 align:middle
使路线出现了覆盖

00:11:15.175 --> 00:11:18.011 align:middle
我们在这里
用了一束数据点

00:11:18.512 --> 00:11:20.514 align:middle
从字典里拿出

00:11:20.747 --> 00:11:23.083 align:middle
生成并构造了代表我的...

00:11:24.618 --> 00:11:28.288 align:middle
跑步路线的多段线

00:11:29.489 --> 00:11:32.593 align:middle
我会设置一个断点

00:11:32.693 --> 00:11:34.761 align:middle
来看获得的数据值是什么

00:11:35.896 --> 00:11:39.166 align:middle
我会打开
Debug Console

00:11:39.533 --> 00:11:44.304 align:middle
来看变量视图
在下面 可以看到

00:11:44.571 --> 00:11:45.906 align:middle
我所感兴趣的点

00:11:46.440 --> 00:11:47.875 align:middle
它有着这些值

00:11:47.941 --> 00:11:50.844 align:middle
我会向前推进

00:11:51.245 --> 00:11:54.681 align:middle
这很有趣
但是有些麻烦

00:11:54.748 --> 00:11:56.650 align:middle
这些值看似相似

00:11:56.850 --> 00:11:59.219 align:middle
我在这里的处理
会让进程快些

00:11:59.286 --> 00:12:01.021 align:middle
来看所有这些值

00:11:59.286 --> 00:12:01.021 align:middle
来看所有这些值

00:12:01.088 --> 00:12:02.556 align:middle
我会编辑这个断点

00:12:03.156 --> 00:12:06.527 align:middle
打印出Struct点

00:12:07.861 --> 00:12:12.366 align:middle
实际上在变量视图上
我检测过这里

00:12:12.566 --> 00:12:14.868 align:middle
然后我会说
评价过操作后

00:12:15.202 --> 00:12:16.503 align:middle
自动继续

00:12:16.570 --> 00:12:18.672 align:middle
其实
这不是条件

00:12:18.739 --> 00:12:20.574 align:middle
是个操作
就这样

00:12:22.009 --> 00:12:24.912 align:middle
我们继续运行

00:12:25.746 --> 00:12:30.884 align:middle
我们可以看到
所有的点都看似一样

00:12:31.385 --> 00:12:34.087 align:middle
但是还会在
不知什么地方

00:12:34.154 --> 00:12:35.489 align:middle
会出现瞬移

00:12:36.223 --> 00:12:39.693 align:middle
但是所有的值看似合理

00:12:40.093 --> 00:12:42.396 align:middle
我不太确定问题是什么

00:12:42.462 --> 00:12:45.866 align:middle
也许从别人那里...

00:12:47.267 --> 00:12:49.469 align:middle
能得到更多帮助

00:12:51.338 --> 00:12:53.373 align:middle
我们回到幻灯片

00:13:00.514 --> 00:13:02.015 align:middle
总结一下看到的内容

00:13:02.449 --> 00:13:05.085 align:middle
首先在Jogr的计时器视图

00:13:05.152 --> 00:13:07.020 align:middle
深入了解
约束问题

00:13:07.254 --> 00:13:10.357 align:middle
我想给大家看看
怎样双击视图

00:13:10.424 --> 00:13:11.725 align:middle
关注具体部件

00:13:12.092 --> 00:13:14.294 align:middle
我们检测部分约束

00:13:14.361 --> 00:13:17.464 align:middle
发现当我们在其他屏幕
尺寸上运行时

00:13:17.531 --> 00:13:19.233 align:middle
需要将之删除

00:13:20.200 --> 00:13:23.203 align:middle
然后 我们在运行
计时器时 出现异常

00:13:23.370 --> 00:13:25.339 align:middle
并使用异常断点 来停在

00:13:25.405 --> 00:13:27.007 align:middle
出现异常的准确时刻

00:13:27.107 --> 00:13:28.709 align:middle
并打印异常信息

00:13:29.343 --> 00:13:32.679 align:middle
最后 我们可以
添加打印并继续添加了

00:13:32.980 --> 00:13:35.449 align:middle
日志的断点
所有这些都不会因NSLogs

00:13:35.516 --> 00:13:37.251 align:middle
或打印语句搞乱代码

00:13:37.918 --> 00:13:40.320 align:middle
现在来解决下一个谜题
为什么今天早上的

00:13:40.387 --> 00:13:43.290 align:middle
跑步会有那么
奇怪的结果

00:13:43.557 --> 00:13:45.192 align:middle
有请安娜

00:13:53.267 --> 00:13:54.101 align:middle
谢谢 麦克

00:13:54.334 --> 00:13:57.204 align:middle
大家好 那么回到
麦克刚刚在演示中

00:13:57.271 --> 00:13:59.239 align:middle
给大家看的那条路线

00:14:00.107 --> 00:14:02.943 align:middle
在测试演示app时
大家会看到

00:14:03.010 --> 00:14:05.479 align:middle
所有的路线
而且包括正确路线

00:14:06.280 --> 00:14:08.515 align:middle
我们非常希望麦克刚刚没有

00:14:08.582 --> 00:14:11.718 align:middle
找出正确的跑步路线
因为这样的话

00:14:11.785 --> 00:14:14.755 align:middle
我们的讲座
就没什么可说的了

00:14:15.956 --> 00:14:19.293 align:middle
这种不可预见的行为通常是
内存出错而导致

00:14:19.393 --> 00:14:21.028 align:middle
例如 分配给一个对象的内存

00:14:21.094 --> 00:14:23.964 align:middle
可能被其他对象所重写

00:14:24.765 --> 00:14:27.367 align:middle
或者也许由于某些计算错误

00:14:27.434 --> 00:14:29.236 align:middle
你用了并不属于你的内存

00:14:30.871 --> 00:14:34.541 align:middle
相信大家之前也遇过类似情况

00:14:34.842 --> 00:14:37.244 align:middle
代码中出现随机异常

00:14:37.611 --> 00:14:40.581 align:middle
也许在测试app的
某个侧面时

00:14:40.647 --> 00:14:42.115 align:middle
每次会出现这个问题

00:14:42.182 --> 00:14:45.085 align:middle
或者只是当你周五晚上

00:14:45.219 --> 00:14:47.254 align:middle
准备回家时出现这个问题！

00:14:49.389 --> 00:14:50.724 align:middle
最糟糕的用例场景

00:14:50.791 --> 00:14:53.927 align:middle
是用户看到这些
不稳定性或随机异常

00:14:53.994 --> 00:14:55.762 align:middle
而你却无法把它们重现眼前

00:14:57.364 --> 00:15:00.400 align:middle
内存出错是出了名的很难

00:14:57.364 --> 00:15:00.400 align:middle
内存出错是出了名的很难

00:15:00.467 --> 00:15:03.337 align:middle
一致性复现 那么也就很难

00:15:03.403 --> 00:15:05.906 align:middle
发现这一异常的根本原因

00:15:06.974 --> 00:15:07.875 align:middle
那该怎么办呢？

00:15:08.642 --> 00:15:11.512 align:middle
最好的办法就是尽量减少
面对内存出错的情况

00:15:11.845 --> 00:15:14.615 align:middle
要避免内存操控

00:15:15.249 --> 00:15:18.085 align:middle
例如使用Swift这类
语言勾选并

00:15:18.151 --> 00:15:21.555 align:middle
自动参考计数
这才会长久

00:15:22.723 --> 00:15:26.293 align:middle
即便内存出错
在技术上仍然可能

00:15:26.360 --> 00:15:29.129 align:middle
由于编码而产生这类问题
则较为不可能

00:15:30.264 --> 00:15:34.334 align:middle
另一方面
如果代码会直接操控内存

00:15:34.401 --> 00:15:37.104 align:middle
通过调用动态分配[unintell
igible]运算

00:15:37.171 --> 00:15:41.842 align:middle
或者代码可以
与C和C++ API可以互操作

00:15:42.309 --> 00:15:45.579 align:middle
你所在的风险组
会非常需要帮助

00:15:47.814 --> 00:15:51.685 align:middle
Address Sanitizer
是基于C语言的LLVM工具

00:15:51.752 --> 00:15:55.622 align:middle
这与Guard Malloc
起到相同的作用

00:15:55.689 --> 00:15:58.792 align:middle
因为它可以在运行时间
发现内存错误

00:15:58.859 --> 00:16:02.362 align:middle
并且较其他工具
有更多好处

00:15:58.859 --> 00:16:02.362 align:middle
并且较其他工具
有更多好处

00:16:03.063 --> 00:16:05.365 align:middle
它的运行时间
开销会少的很多

00:16:05.599 --> 00:16:09.203 align:middle
还会产生
综合详细的诊断分析

00:16:09.269 --> 00:16:11.972 align:middle
可以直接
整合到Xcode UI

00:16:12.372 --> 00:16:15.742 align:middle
还有一点很重要
只有这种工具

00:16:15.809 --> 00:16:17.477 align:middle
可以在iOS设备上运行

00:16:18.312 --> 00:16:22.282 align:middle
这些是Address Sanitizer
可以捕捉到的常见错误清单

00:16:23.050 --> 00:16:29.089 align:middle
例如 它可以很好地
捕捉到缓冲区溢出

00:16:29.756 --> 00:16:31.859 align:middle
这是个很常见的错误

00:16:32.426 --> 00:16:35.562 align:middle
因为与安全性攻击的关联
而臭名昭著

00:16:36.997 --> 00:16:38.765 align:middle
正如大家所见
它发现了部分工具

00:16:38.832 --> 00:16:41.034 align:middle
通过 Valgrind 和
Guard Malloc

00:16:41.101 --> 00:16:42.135 align:middle
发现的错误

00:16:42.202 --> 00:16:44.738 align:middle
但是它也发现了
新种类的程序错误

00:16:44.972 --> 00:16:47.174 align:middle
是其他工具没有注意的

00:16:48.408 --> 00:16:49.776 align:middle
我们回到演示

00:16:49.843 --> 00:16:52.646 align:middle
来看怎样才能
把这些用于项目中

00:17:03.190 --> 00:17:06.260 align:middle
我接着麦克讲到的内容继续

00:17:06.326 --> 00:17:08.962 align:middle
来看我们看看是否
Address Sanitizer

00:17:09.029 --> 00:17:10.696 align:middle
可以帮我们找出路线问题

00:17:11.431 --> 00:17:13.634 align:middle
为了启动
Address Sanitizer

00:17:13.934 --> 00:17:15.469 align:middle
进入Edit Scheme

00:17:18.438 --> 00:17:20.207 align:middle
进入Diagnostics选项卡

00:17:21.108 --> 00:17:23.242 align:middle
勾选 Enable
Address Sanitizer

00:17:23.644 --> 00:17:25.945 align:middle
与其他内存管理工具不同

00:17:26.012 --> 00:17:28.248 align:middle
Address Sanitizer
需要重新编译

00:17:28.315 --> 00:17:32.219 align:middle
选中复选框后
Xcode就会知道

00:17:32.286 --> 00:17:35.355 align:middle
要打开 Address
Sanitizer 重建应用

00:17:35.656 --> 00:17:37.457 align:middle
它会启动特殊模式

00:17:37.524 --> 00:17:39.326 align:middle
允许Address
Sanitizer

00:17:39.393 --> 00:17:41.728 align:middle
在运行时间更多地
干预进程

00:17:43.263 --> 00:17:46.400 align:middle
我们继续重建
并重新运行app

00:17:48.001 --> 00:17:50.470 align:middle
来看像刚才的路线会怎样

00:17:51.905 --> 00:17:54.741 align:middle
现在Address Sanitizer
发现了问题

00:17:54.975 --> 00:17:57.444 align:middle
它的诊断直接整合到了

00:17:57.511 --> 00:17:59.713 align:middle
Xcode Debugger UI

00:17:59.980 --> 00:18:03.317 align:middle
这与出现异常时
情况非常相似

00:17:59.980 --> 00:18:03.317 align:middle
这与出现异常时
情况非常相似

00:18:03.650 --> 00:18:05.786 align:middle
但是与使用Sec的
情况不同

00:18:05.853 --> 00:18:07.988 align:middle
这次可以对情况有更好的诊断

00:18:08.555 --> 00:18:12.426 align:middle
这里它告诉我们
查出堆缓冲区溢出

00:18:13.360 --> 00:18:15.162 align:middle
还可以看到堆栈轨迹

00:18:15.262 --> 00:18:17.998 align:middle
在这里出现了内存错误

00:18:19.800 --> 00:18:22.703 align:middle
如大家所见 我们称之为
Poly Line With Points

00:18:22.769 --> 00:18:24.071 align:middle
和Map Kit的常用方法

00:18:24.137 --> 00:18:28.242 align:middle
我们在缓冲区做测试
通过缓冲区的长度

00:18:28.308 --> 00:18:30.611 align:middle
来进行
计算点的数量

00:18:30.677 --> 00:18:33.947 align:middle
再用每个点的大小
来相除

00:18:34.414 --> 00:18:36.250 align:middle
看上去可以

00:18:36.316 --> 00:18:39.987 align:middle
随着应用在 Address
Sanitizer 中执行

00:18:40.053 --> 00:18:42.055 align:middle
它会收集过程中

00:18:42.122 --> 00:18:44.725 align:middle
堆对象的重要信息

00:18:44.825 --> 00:18:47.027 align:middle
例如 分配
堆分配

00:18:47.094 --> 00:18:48.395 align:middle
和取消分配事件

00:18:48.962 --> 00:18:53.267 align:middle
当发现内存出错
它会使用启发法

00:18:53.333 --> 00:18:56.837 align:middle
来关联错误地址
到有效的堆对象

00:18:57.404 --> 00:19:00.307 align:middle
在内存项下信息都呈现在这里

00:18:57.404 --> 00:19:00.307 align:middle
在内存项下信息都呈现在这里

00:19:00.841 --> 00:19:03.877 align:middle
这里它告诉我们
错误地址是在

00:19:03.944 --> 00:19:08.148 align:middle
在2240字节堆区域后的
一个字节

00:19:08.615 --> 00:19:12.553 align:middle
还告诉我们堆区域
所分配的位置

00:19:13.554 --> 00:19:15.756 align:middle
即使这不是激活线程

00:19:15.923 --> 00:19:21.395 align:middle
而是在分配事件发生时
进程执行的历史快照

00:19:21.461 --> 00:19:22.930 align:middle
我们可以把流

00:19:23.764 --> 00:19:25.432 align:middle
视作激活线程

00:19:26.600 --> 00:19:30.504 align:middle
它会把我们带到
内存分配的点的位置

00:19:31.338 --> 00:19:34.274 align:middle
好的
我们来看缓冲区的大小

00:19:34.341 --> 00:19:38.478 align:middle
是用每个点的大小
乘以点的数量得出

00:19:39.446 --> 00:19:42.749 align:middle
我们使用
MK Map Point

00:19:43.450 --> 00:19:45.352 align:middle
作为点的代表

00:19:45.419 --> 00:19:46.854 align:middle
这是带双精度的Struct

00:19:48.055 --> 00:19:49.423 align:middle
那么问题是什么？

00:19:50.090 --> 00:19:52.326 align:middle
我们回到Use站点

00:19:53.861 --> 00:19:57.497 align:middle
你传递到这里的类型是不同的

00:19:58.131 --> 00:20:01.368 align:middle
我们传递了MK Map Point星级

00:19:58.131 --> 00:20:01.368 align:middle
我们传递了MK Map Point星级

00:20:02.402 --> 00:20:06.139 align:middle
但是我们知道
刚分配了Struct的缓冲区

00:20:06.206 --> 00:20:07.641 align:middle
而不是指针的缓冲区

00:20:08.642 --> 00:20:12.279 align:middle
因为每个
指针的大小小于

00:20:12.346 --> 00:20:14.414 align:middle
结构体的大小
包括两个双精度

00:20:15.015 --> 00:20:17.918 align:middle
这里获得的计数
要大于缓冲区

00:20:17.985 --> 00:20:20.020 align:middle
包括的元素数量

00:20:20.654 --> 00:20:22.890 align:middle
这就会解释
为什么在地图上

00:20:22.956 --> 00:20:25.058 align:middle
我们会有那些额外的点

00:20:26.627 --> 00:20:29.196 align:middle
为解决问题
我们需要删掉星级

00:20:29.263 --> 00:20:30.731 align:middle
如大家所见

00:20:30.797 --> 00:20:33.667 align:middle
这是个人们非常容易犯的错误

00:20:33.800 --> 00:20:38.071 align:middle
只看代码是非常难发现的

00:20:39.039 --> 00:20:42.309 align:middle
在本例中
这个信息已经

00:20:42.376 --> 00:20:44.578 align:middle
足以诊断和解决问题

00:20:45.112 --> 00:20:50.517 align:middle
不过 如果觉得
想更多地看看这个报告

00:20:50.584 --> 00:20:53.053 align:middle
可以前往Memory View

00:20:53.120 --> 00:20:54.955 align:middle
来看哪个内存是有效的

00:20:55.122 --> 00:20:57.057 align:middle
哪个内存是被视为无效

00:20:57.124 --> 00:20:59.326 align:middle
从Address Sanitizer
的视角来看

00:20:59.660 --> 00:21:03.297 align:middle
前往Memory View
可以点击这个地址

00:20:59.660 --> 00:21:03.297 align:middle
前往Memory View
可以点击这个地址

00:21:03.864 --> 00:21:07.801 align:middle
这里可以看到所有变灰的内容
都是无效内存

00:21:08.068 --> 00:21:12.873 align:middle
所有黑色内存都被视为有效

00:21:14.441 --> 00:21:17.644 align:middle
我们返回并重新运行app

00:21:17.711 --> 00:21:20.547 align:middle
来看删掉星号
是否可以解决问题

00:21:23.317 --> 00:21:25.252 align:middle
我来继续返回Route视图

00:21:27.487 --> 00:21:31.592 align:middle
啊 这就是麦克
今天早上的跑步路线

00:21:31.859 --> 00:21:33.427 align:middle
还有早上
Bash之后的部分

00:21:33.994 --> 00:21:35.095 align:middle
我很受感动

00:21:35.429 --> 00:21:36.930 align:middle
我们返回
打开幻灯片

00:21:37.831 --> 00:21:40.701 align:middle
大家已经看到
打开Address Sanitizer很容易

00:21:40.767 --> 00:21:44.271 align:middle
进入Scheme Editor
打开Diagnostics选项卡

00:21:44.638 --> 00:21:47.441 align:middle
勾选Enable
Address Sanitizer复选框

00:21:47.941 --> 00:21:50.210 align:middle
接着可以构建
并运行自己的项目

00:21:52.513 --> 00:21:55.082 align:middle
同样
正如大家在演示app所见

00:21:55.148 --> 00:21:58.118 align:middle
使用Address Sanitizer的
开销几乎很难注意到

00:21:58.619 --> 00:22:01.788 align:middle
较低的运行时间开销
允许你使用Address Sanitizer

00:21:58.619 --> 00:22:01.788 align:middle
较低的运行时间开销
允许你使用Address Sanitizer

00:22:02.122 --> 00:22:06.126 align:middle
不仅是在调试
部分内存出错问题的时候

00:22:06.360 --> 00:22:09.463 align:middle
而且是在进行UI驱动的测试

00:22:09.530 --> 00:22:12.533 align:middle
这里要手动测试
app的不同方面

00:22:13.500 --> 00:22:15.769 align:middle
再进一步 我们推荐

00:22:15.836 --> 00:22:18.572 align:middle
在连续整合过程中
使用Address Sanitizer

00:22:19.273 --> 00:22:21.708 align:middle
因为这是运行时间
程序错误发现工具

00:22:21.775 --> 00:22:25.045 align:middle
它仅会捕捉已执行
代码中的程序错误

00:22:25.712 --> 00:22:27.748 align:middle
那么应该提供尽可能多的覆盖

00:22:27.814 --> 00:22:29.449 align:middle
以实现最好结果

00:22:30.651 --> 00:22:36.723 align:middle
在Xcode或Xcode Server
的任务中启动

00:22:36.790 --> 00:22:40.227 align:middle
Address Sanitizer
进入Edit Scheme选择Task

00:22:40.460 --> 00:22:42.829 align:middle
然后再次进入
Diagnostics选项卡

00:22:42.896 --> 00:22:45.699 align:middle
勾选Enable
Address Sanitizer复选框

00:22:45.766 --> 00:22:46.767 align:middle
构建并测试你的app

00:22:47.501 --> 00:22:49.236 align:middle
还可以用命令行启动

00:22:49.303 --> 00:22:52.039 align:middle
通过向Xcode Build
传递额外的参数

00:22:54.808 --> 00:22:56.476 align:middle
我们建议在Debug构建

00:22:56.543 --> 00:22:58.378 align:middle
使用Address
Sanitizer

00:22:58.445 --> 00:22:59.680 align:middle
并将编译器优化关闭

00:23:00.414 --> 00:23:03.917 align:middle
但是它也得到
Fast优化水平的支持

00:23:05.052 --> 00:23:07.521 align:middle
是与01编辑器旗标相对应

00:23:08.488 --> 00:23:10.157 align:middle
需要牢记一点

00:23:10.224 --> 00:23:13.260 align:middle
当在这两个优化水平之间
进行决定时

00:23:14.361 --> 00:23:17.030 align:middle
如果有任何编译优化
是启动状态

00:23:17.164 --> 00:23:20.467 align:middle
调试体验就不会十分流畅

00:23:23.036 --> 00:23:26.607 align:middle
现在我们进入
讲座的最激动环节

00:23:26.740 --> 00:23:28.075 align:middle
我会告诉大家一个

00:23:28.141 --> 00:23:30.410 align:middle
驱动这个工具的很酷的技术

00:23:32.646 --> 00:23:36.049 align:middle
传统而言Xcode
使用clang编译器来

00:23:36.116 --> 00:23:40.053 align:middle
编译源代码
可以生成可执行的二进制代码

00:23:41.221 --> 00:23:43.223 align:middle
为使用
Address Sanitizer

00:23:43.290 --> 00:23:45.359 align:middle
Xcode将特殊的旗标
传递给clang

00:23:45.592 --> 00:23:47.294 align:middle
它会生成工具二进制代码

00:23:47.361 --> 00:23:48.996 align:middle
其中包括
更多的内存检测

00:23:50.130 --> 00:23:55.569 align:middle
在运行时间 这个二进制代码
与asan运行时间dylib连接

00:23:55.636 --> 00:23:57.437 align:middle
其中包括更多检测

00:23:57.504 --> 00:24:00.174 align:middle
而且dylib是工具所要求的

00:23:57.504 --> 00:24:00.174 align:middle
而且dylib是工具所要求的

00:24:02.042 --> 00:24:03.877 align:middle
但是这些内存检测
如何发挥作用？

00:24:04.278 --> 00:24:07.381 align:middle
Address Sanitizer
检测进程中的所有位置

00:24:07.447 --> 00:24:09.416 align:middle
如果这是进程内存

00:24:11.218 --> 00:24:14.154 align:middle
Address Sanitizer会成为
所谓的影子内存

00:24:14.521 --> 00:24:17.424 align:middle
可以跟踪真实内存中的
每个字节

00:24:18.492 --> 00:24:22.896 align:middle
它有着字节是否为可访问
地址的相关信息

00:24:24.131 --> 00:24:26.700 align:middle
无效内存的字节就是红区

00:24:26.767 --> 00:24:28.702 align:middle
或者说内存中毒

00:24:30.737 --> 00:24:33.140 align:middle
当使用Address Sanitizer
编译程序时

00:24:33.207 --> 00:24:35.242 align:middle
它会影响每个内存访问

00:24:35.409 --> 00:24:37.010 align:middle
并在前缀加上检测

00:24:37.811 --> 00:24:38.946 align:middle
如果内存中毒

00:24:39.012 --> 00:24:41.215 align:middle
Address Sanitizer
就会跟踪程序

00:24:41.582 --> 00:24:43.750 align:middle
并生成诊断报告

00:24:44.151 --> 00:24:46.053 align:middle
否则 它会允许你继续

00:24:47.721 --> 00:24:49.122 align:middle
我们再来仔细看看

00:24:49.256 --> 00:24:50.524 align:middle
假设p为指针

00:24:50.958 --> 00:24:55.395 align:middle
然后IsPoisoned函数会
检测影子内存中的相关字节

00:24:56.129 --> 00:24:57.764 align:middle
在本例中 内存是有效的

00:24:57.831 --> 00:25:01.435 align:middle
因此程序可以编写那个
内存位置

00:24:57.831 --> 00:25:01.435 align:middle
因此程序可以编写那个
内存位置

00:25:04.738 --> 00:25:06.940 align:middle
不过 如果它并未指向有效内存

00:25:07.207 --> 00:25:08.509 align:middle
条件将会为真

00:25:09.142 --> 00:25:11.612 align:middle
程序将卡在无效内存

00:25:11.845 --> 00:25:14.448 align:middle
就是访问可能要发生的地方

00:25:15.249 --> 00:25:18.051 align:middle
这就是Address
Sanitizer生成报告的方法

00:25:18.118 --> 00:25:20.087 align:middle
并将这个问题报告给用户

00:25:21.922 --> 00:25:25.158 align:middle
查找影子内存需要非常快才行

00:25:26.260 --> 00:25:28.729 align:middle
为实现这点
我们保留了查找表

00:25:28.795 --> 00:25:33.700 align:middle
在影子内存中每8个字节
就会有1个字节被跟踪

00:25:35.002 --> 00:25:36.970 align:middle
这是个很大的查找表

00:25:37.037 --> 00:25:38.939 align:middle
我们并未真正分配 而是在

00:25:39.239 --> 00:25:42.910 align:middle
进程启动的时候保存
在需要的时候使用

00:25:44.344 --> 00:25:46.113 align:middle
这样我们就可以查找地址

00:25:46.180 --> 00:25:50.717 align:middle
通过将原始指针的值除以8

00:25:50.784 --> 00:25:52.653 align:middle
再添加常数补偿

00:25:52.719 --> 00:25:55.822 align:middle
就是在内存影子的
位置上添加

00:25:56.390 --> 00:25:58.859 align:middle
即便计算地址的字节为非零

00:25:59.126 --> 00:26:00.527 align:middle
我们知道内存中毒了

00:25:59.126 --> 00:26:00.527 align:middle
我们知道内存中毒了

00:26:03.130 --> 00:26:05.165 align:middle
现在 我们聊聊堆的内容

00:26:06.099 --> 00:26:08.802 align:middle
捕获溢出和
堆中的其他程序错误

00:26:09.369 --> 00:26:12.206 align:middle
Address Sanitizer会提供
自定义分配器

00:26:12.272 --> 00:26:15.209 align:middle
以替代默认的Malloc执行

00:26:16.710 --> 00:26:19.713 align:middle
默认分配器
可以用不同方式组织对象

00:26:20.347 --> 00:26:23.984 align:middle
例如
它可以逐个排布对象

00:26:24.718 --> 00:26:27.921 align:middle
这对于优化内存消耗十分有利

00:26:28.655 --> 00:26:30.691 align:middle
但是这对捕捉程序错误不太好

00:26:30.757 --> 00:26:33.260 align:middle
因为一个对象的溢出会落到

00:26:33.327 --> 00:26:34.661 align:middle
另一个对象上

00:26:34.728 --> 00:26:38.232 align:middle
因此无法与有效的内存访问区别开来

00:26:39.900 --> 00:26:42.402 align:middle
为解决这个问题
ASan的分配器

00:26:42.469 --> 00:26:45.239 align:middle
会让对象彼此间距更大

00:26:46.006 --> 00:26:48.742 align:middle
这些对象之间未用的内存

00:26:49.176 --> 00:26:51.011 align:middle
在影子部分会标记为中毒

00:26:53.280 --> 00:26:54.848 align:middle
当对象被取消分配

00:26:54.915 --> 00:26:57.050 align:middle
我们将对象在影子部分
标记为中毒

00:26:59.319 --> 00:27:03.790 align:middle
总之 自定Malloc执行
在有效的分配周围

00:26:59.319 --> 00:27:03.790 align:middle
总之 自定Malloc执行
在有效的分配周围

00:27:03.857 --> 00:27:06.560 align:middle
插入中毒的红区

00:27:06.860 --> 00:27:09.263 align:middle
以捕捉堆下溢和溢出

00:27:10.464 --> 00:27:12.666 align:middle
这会延迟用户释放的内存

00:27:12.799 --> 00:27:16.236 align:middle
使得Address
Sanitizer更有效地捕捉

00:27:16.303 --> 00:27:18.238 align:middle
用户释放的和双重释放的错误

00:27:19.306 --> 00:27:23.343 align:middle
它还会为分配和解除分配
搜集Sect痕迹

00:27:23.544 --> 00:27:26.713 align:middle
允许它提供这些综合详细的诊断

00:27:27.014 --> 00:27:28.415 align:middle
这些我们在演示中都见过

00:27:28.615 --> 00:27:30.217 align:middle
能立即明白问题在何处

00:27:30.584 --> 00:27:32.186 align:middle
和花费大量时间去调试

00:27:32.452 --> 00:27:34.788 align:middle
再找出具体发生了什么

00:27:35.689 --> 00:27:37.191 align:middle
这二者是完全不同的效果

00:27:38.759 --> 00:27:41.562 align:middle
现在 我们来谈谈堆栈

00:27:43.630 --> 00:27:45.699 align:middle
与之相似 对于堆内存而言

00:27:45.766 --> 00:27:47.801 align:middle
红区是放在独立的
堆栈变量之间

00:27:48.902 --> 00:27:52.206 align:middle
假设我们有个数组和整数
作为本地变量

00:27:52.739 --> 00:27:55.509 align:middle
那么在Address Sanitizer
编译时

00:27:56.009 --> 00:27:59.346 align:middle
这些变量之间
会插入额外的红区

00:27:59.413 --> 00:28:03.483 align:middle
这样我们可以发现
堆栈变量的任何溢出

00:27:59.413 --> 00:28:03.483 align:middle
这样我们可以发现
堆栈变量的任何溢出

00:28:05.085 --> 00:28:07.287 align:middle
在运行时间进入函数时

00:28:07.354 --> 00:28:09.790 align:middle
堆栈红区会中毒在运行时间

00:28:09.857 --> 00:28:13.026 align:middle
退出函数时它们会解毒

00:28:16.697 --> 00:28:19.600 align:middle
处理全局变量也非常相似

00:28:19.666 --> 00:28:24.204 align:middle
在编译期间
检测全局变量

00:28:24.671 --> 00:28:27.241 align:middle
额外的红区会插入它们四周

00:28:29.376 --> 00:28:32.246 align:middle
现在堆栈和全局编译器检测

00:28:32.312 --> 00:28:34.848 align:middle
是Address Sanitizer
非常有用的功能

00:28:35.249 --> 00:28:37.784 align:middle
这会允许它发现其他工具

00:28:37.851 --> 00:28:39.453 align:middle
无法捕获的程序错误

00:28:41.588 --> 00:28:44.925 align:middle
Address Sanitizer
还能找到其他类型的独特程序错误

00:28:45.158 --> 00:28:49.530 align:middle
在座的Avid C++开发
人员会对此特别感兴趣

00:28:50.864 --> 00:28:53.066 align:middle
我们有个C++容器矢量

00:28:53.667 --> 00:28:55.969 align:middle
即便所有的内存
都给了v.begin

00:28:56.036 --> 00:28:58.472 align:middle
v.begin加容量
都已经分配

00:28:59.173 --> 00:29:02.476 align:middle
访问内存过去
v.end是个错误

00:28:59.173 --> 00:29:02.476 align:middle
访问内存过去
v.end是个错误

00:29:03.944 --> 00:29:06.947 align:middle
检测Leap C++
向Address Sanitizer

00:29:07.014 --> 00:29:10.017 align:middle
提供更多信息
这样就会像这里一样

00:29:10.384 --> 00:29:11.251 align:middle
发现错误

00:29:16.089 --> 00:29:20.160 align:middle
正如我们所见
我们谈到的所有检测

00:29:20.227 --> 00:29:21.995 align:middle
都需要编译器检测

00:29:22.062 --> 00:29:25.032 align:middle
但是
我们知道部分错误会出现在

00:29:25.799 --> 00:29:29.469 align:middle
即便代码没有
重新编译的时候也会触发

00:29:29.636 --> 00:29:31.738 align:middle
例如我们调用
内存拷贝函数的时候

00:29:32.973 --> 00:29:37.411 align:middle
Address Sanitizer
会使用一个技术名为BYOD函数

00:29:37.978 --> 00:29:40.647 align:middle
插补用运行时间的自身版本

00:29:41.081 --> 00:29:43.450 align:middle
来替代数十种标准库函数

00:29:44.218 --> 00:29:46.019 align:middle
因为这是一个运行技术

00:29:46.119 --> 00:29:47.855 align:middle
这些检测甚至会触发

00:29:47.921 --> 00:29:49.823 align:middle
未经重新编译的代码

00:29:50.991 --> 00:29:54.061 align:middle
这里是个内存拷贝包裹示例

00:29:54.228 --> 00:29:58.899 align:middle
正如你所预期
在转发原始内存拷贝执行前

00:29:59.166 --> 00:30:03.270 align:middle
首先会检查源和目的地
缓冲区是否有效

00:29:59.166 --> 00:30:03.270 align:middle
首先会检查源和目的地
缓冲区是否有效

00:30:06.673 --> 00:30:10.077 align:middle
所有这些额外检查意味着
会有运行时间开销

00:30:10.143 --> 00:30:11.478 align:middle
而且你可能会考虑这是什么

00:30:13.180 --> 00:30:16.483 align:middle
这些细节很大程度上
取决于各自的程序

00:30:16.550 --> 00:30:20.354 align:middle
Address Sanitizer
通常会导致CPU减速2倍左右

00:30:20.954 --> 00:30:24.758 align:middle
但是我们看到在一些边缘情况下
曾高达5倍

00:30:25.592 --> 00:30:28.095 align:middle
而内存开销从2倍到3倍

00:30:29.429 --> 00:30:30.797 align:middle
需要注意的一点是

00:30:30.864 --> 00:30:32.966 align:middle
这些开销要比

00:30:33.033 --> 00:30:36.703 align:middle
可以找到相似问题的
其他工具要小很多

00:30:37.971 --> 00:30:40.741 align:middle
通过运行时间技术
编译编译器检测

00:30:40.807 --> 00:30:43.410 align:middle
是令Address Sanitizer
更为有效和

00:30:43.477 --> 00:30:46.880 align:middle
可扩展的关键所在

00:30:47.781 --> 00:30:52.152 align:middle
例如 我们在Address Sanitizer
运行并测试Safari

00:30:53.053 --> 00:30:53.921 align:middle
这是个大app

00:30:56.657 --> 00:30:59.793 align:middle
这是Xcode 7
新增的Address Sanitizer

00:31:01.862 --> 00:31:02.729 align:middle
谢谢

00:31:09.603 --> 00:31:12.272 align:middle
我们调整一下关注点
来仔细看看

00:31:12.339 --> 00:31:16.310 align:middle
我们平台上可用的
其他内存管理工具

00:31:16.376 --> 00:31:18.912 align:middle
它们可以做什么
你何时应该使用

00:31:20.214 --> 00:31:22.082 align:middle
那我们先从
Guard Malloc开始

00:31:22.149 --> 00:31:25.052 align:middle
像Address Sanitizer一样
它也可以发现同样问题

00:31:25.252 --> 00:31:27.221 align:middle
使用Guard Malloc的
主要优势是

00:31:27.287 --> 00:31:29.523 align:middle
它不需要进行重新编译

00:31:30.624 --> 00:31:32.960 align:middle
另一方面
它还有其他局限性

00:31:33.627 --> 00:31:35.896 align:middle
Guard Malloc不能在
iOS设备上运行

00:31:36.063 --> 00:31:38.165 align:middle
而且不能发现
Address Sanitizer

00:31:38.232 --> 00:31:39.666 align:middle
发现的所有问题

00:31:40.267 --> 00:31:42.903 align:middle
例如 因为它使用保护页面

00:31:43.604 --> 00:31:47.107 align:middle
它将无法捕捉到
所有的单字节缓冲区溢出

00:31:47.207 --> 00:31:49.243 align:middle
这是个常见错误

00:31:50.410 --> 00:31:54.081 align:middle
再选择两者间该使用哪个时
要考虑其他的权衡因素

00:31:55.282 --> 00:31:57.751 align:middle
可供大家考虑的
还有NSZombie

00:31:58.285 --> 00:32:01.755 align:middle
它善于捕捉Objective-C
对象过度释放

00:31:58.285 --> 00:32:01.755 align:middle
它善于捕捉Objective-C
对象过度释放

00:32:02.623 --> 00:32:05.526 align:middle
可以通过发送信息时
困住的僵尸对象

00:32:05.926 --> 00:32:09.329 align:middle
替代取消分配对象
以发挥作用

00:32:10.330 --> 00:32:12.432 align:middle
这个基本功能
可以从Xcode中的

00:32:12.666 --> 00:32:15.469 align:middle
相同Diagnostics选项卡
来启动

00:32:15.802 --> 00:32:18.739 align:middle
但是 如果希望
获得该功能的全部效用

00:32:18.805 --> 00:32:20.774 align:middle
还是要使用
Zombies Instrument

00:32:22.376 --> 00:32:27.114 align:middle
Malloc Scribble会帮助
调查未初始化的内存问题

00:32:27.481 --> 00:32:29.716 align:middle
它可以通过预设常数
填入分配和

00:32:29.983 --> 00:32:34.087 align:middle
取消分配的内存
更能预见这些错误的出现

00:32:35.556 --> 00:32:37.624 align:middle
最后
泄露Instrument会帮助你

00:32:37.691 --> 00:32:41.562 align:middle
发现保留周期
以及导致更高内存

00:32:41.628 --> 00:32:43.096 align:middle
消耗的放弃内存

00:32:45.999 --> 00:32:47.968 align:middle
总之
我们见识了三种不同的技术

00:32:48.035 --> 00:32:51.805 align:middle
可以帮助我们
更深入地理解程序

00:32:52.306 --> 00:32:54.842 align:middle
首先 使用View
Debugger来发现

00:32:54.908 --> 00:32:57.277 align:middle
并解决布局的约束问题

00:32:58.245 --> 00:33:00.080 align:middle
第二 设置断点操作

00:32:58.245 --> 00:33:00.080 align:middle
第二 设置断点操作

00:33:00.147 --> 00:33:03.917 align:middle
以便自动评估和
打印任何LLVD表达式

00:33:04.351 --> 00:33:05.786 align:middle
并使用异常断点

00:33:05.853 --> 00:33:10.390 align:middle
让程序调试恰好停在
异常出现的位置

00:33:11.024 --> 00:33:12.359 align:middle
最后 第三

00:33:12.793 --> 00:33:15.863 align:middle
使用Address Sanitizer
整理应用

00:33:16.230 --> 00:33:18.932 align:middle
清除那些难以捉摸的
内存出错问题

00:33:20.467 --> 00:33:23.170 align:middle
关于今天谈到的问题
还有其他的资源

00:33:23.237 --> 00:33:24.771 align:middle
帮助大家了解更多内容

00:33:25.739 --> 00:33:28.275 align:middle
本周早些时候
有几次讲座介绍了

00:33:28.342 --> 00:33:31.345 align:middle
LLDB连续整合和测试问题

00:33:31.645 --> 00:33:34.214 align:middle
大会结束后
大家就可以立即观看

00:33:34.681 --> 00:33:36.750 align:middle
非常感谢
祝大家今天过得愉快
