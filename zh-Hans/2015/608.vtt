WEBVTT

00:00:20.087 --> 00:00:25.926 align:middle
GameplayKit介绍

00:00:32.064 --> 00:00:33.767 align:middle
大家好 欢迎光临

00:00:35.169 --> 00:00:37.871 align:middle
我的名字叫布鲁诺·萨默
是Apple公司游戏技术工程师

00:00:38.172 --> 00:00:39.573 align:middle
今天我非常高兴

00:00:39.840 --> 00:00:43.210 align:middle
能为您介绍GameplayKit

00:00:43.944 --> 00:00:46.880 align:middle
Apple公司第一个
专用的游戏开发框架

00:00:48.916 --> 00:00:52.486 align:middle
我们有多种解决方案
可以处理制作游戏的视觉部分

00:00:52.786 --> 00:00:55.722 align:middle
在像SpriteKit SceneKit
和Metal的平台工具上

00:00:56.590 --> 00:00:59.426 align:middle
在游戏开发难题中
游戏设置是另一个非常重要的部分

00:01:01.028 --> 00:01:03.764 align:middle
事实证明 游戏设置方面存在难题

00:01:04.131 --> 00:01:07.301 align:middle
像AI 寻路算法和自主运动这些工具

00:01:08.969 --> 00:01:11.705 align:middle
我们坚信不应当故步自封

00:01:12.573 --> 00:01:16.009 align:middle
应当鼓励开发人员设计出更优秀的游戏

00:01:17.678 --> 00:01:21.014 align:middle
我们希望你们能够
更加专注为生活带来好点子

00:01:21.548 --> 00:01:24.117 align:middle
我们将挑起重担在后端实现

00:01:26.486 --> 00:01:29.389 align:middle
所以开始制作GameplayKit时
我们的使命非常清晰

00:01:30.123 --> 00:01:33.760 align:middle
我们想要设计一个具有游戏设置
且简单功能强大的API解决方案

00:01:34.494 --> 00:01:39.933 align:middle
现在这就像普通的设计模式和架构
因此我们开始先讲讲游戏语言

00:01:41.134 --> 00:01:45.973 align:middle
另外还有一些标准的游戏算法
适用于多种多样的游戏类型

00:01:47.441 --> 00:01:50.644 align:middle
并且对我们很重要的是
这隔断图形和引擎的联系

00:01:50.744 --> 00:01:54.081 align:middle
因此虽然GameplayKit
与很多我讲到的那些视觉框架分隔

00:01:54.681 --> 00:01:55.782 align:middle
它和其它框架运作得很好

00:01:56.049 --> 00:01:59.653 align:middle
它和SpriteKit SceneKit Metal
及更多的软件也运作得很好

00:02:03.056 --> 00:02:06.693 align:middle
所以此时我们有GameplayKit
和七个GameplayKit的重要特性

00:02:07.261 --> 00:02:11.298 align:middle
并且这些组件可以说说是非常好
可用于构建你的游戏对象和游戏逻辑

00:02:12.499 --> 00:02:17.137 align:middle
状态机描述了我们游戏中的状态化
和游戏对象的各种状态变化

00:02:18.438 --> 00:02:23.510 align:middle
主体是自主运动的实体
由现实行为和目标控制

00:02:24.745 --> 00:02:28.682 align:middle
路径找寻解决了导航图形生成
和我们如何移动实体的问题

00:02:29.082 --> 00:02:30.984 align:middle
在游戏世界的可通行区域中

00:02:31.919 --> 00:02:33.520 align:middle
我们也有一个极好的
MinMax AI解决方案

00:02:33.587 --> 00:02:36.823 align:middle
它是非常好的解决方法
让反对计算机控制者看到了希望

00:02:38.392 --> 00:02:42.362 align:middle
有许多游戏质量随机源
和随机分布可以任意使用

00:02:42.863 --> 00:02:45.032 align:middle
最后我们有一个规则系统
也是个很好的途径

00:02:45.098 --> 00:02:47.301 align:middle
对模拟谨慎和模糊逻辑很有用

00:02:49.303 --> 00:02:53.607 align:middle
今天还涉及到很多
让我们继续看看接着讲实体和组件

00:02:55.843 --> 00:02:57.845 align:middle
我想要提几个继承的经典问题

00:02:58.846 --> 00:03:01.215 align:middle
从普通游戏对象中得到的

00:02:58.846 --> 00:03:01.215 align:middle
从普通游戏对象中得到的

00:03:01.648 --> 00:03:05.919 align:middle
此时我们有一个塔防游戏
带有简单的弹塔和弓箭手类

00:03:07.254 --> 00:03:08.922 align:middle
这有一些共享的功能

00:03:09.723 --> 00:03:13.293 align:middle
我们有射击 有移动
还有被攻击的目标

00:03:14.561 --> 00:03:15.629 align:middle
让我们以射击为例

00:03:15.963 --> 00:03:18.398 align:middle
我们想让塔和弓箭手都能够射击

00:03:18.866 --> 00:03:20.200 align:middle
那么我们在哪放置射击功能呢

00:03:21.668 --> 00:03:25.272 align:middle
一种选择可能是在塔和弓箭手类之间
简单地复制并粘帖它

00:03:25.906 --> 00:03:28.542 align:middle
但现在在我的分享功能代码中有两个点

00:03:28.609 --> 00:03:30.544 align:middle
并且如果我想要更新这个功能

00:03:30.811 --> 00:03:32.412 align:middle
现在我也需要更新那两个点

00:03:32.513 --> 00:03:35.883 align:middle
如果我只是更新一个
那么会导致一些很奇怪的行为

00:03:37.284 --> 00:03:40.287 align:middle
所以在我所描述的这种继承模型中

00:03:40.687 --> 00:03:43.590 align:middle
我们的唯一正确的选择就是
在树状图中把分享功能往更高的层级放

00:03:43.657 --> 00:03:44.691 align:middle
此时我们有个射击功能

00:03:44.758 --> 00:03:48.095 align:middle
可以将它置于游戏对象类
或某些基于普通的类

00:03:49.296 --> 00:03:50.464 align:middle
现在这种方法的问题是

00:03:50.631 --> 00:03:53.634 align:middle
当我们在游戏中获得
越来越多的共享功能

00:03:53.867 --> 00:03:56.270 align:middle
我们不得不将它移到越来越高的层次

00:03:56.703 --> 00:03:59.106 align:middle
并且我们的基础游戏对象
变得根本不基础了

00:03:59.706 --> 00:04:04.378 align:middle
他们变得很大 难以理解
并且很难维护 协作

00:03:59.706 --> 00:04:04.378 align:middle
他们变得很大 难以理解
并且很难维护 协作

00:04:05.846 --> 00:04:09.349 align:middle
让我们看下怎么样
用实体和组件解决这个问题

00:04:10.651 --> 00:04:13.921 align:middle
你看我们仍然有三个对象
弹 塔 弓箭手

00:04:14.655 --> 00:04:18.158 align:middle
但现在取而代之的是有了功能
在继承意义上

00:04:18.358 --> 00:04:21.394 align:middle
成为移动者 成为射手
成为被击中者

00:04:22.095 --> 00:04:24.498 align:middle
它们反而有这些对象
我们称之为组件

00:04:24.565 --> 00:04:27.000 align:middle
里面包含游戏逻辑的个别元素

00:04:27.334 --> 00:04:29.770 align:middle
所以此时我们有移动组件
可以解决移动问题

00:04:29.937 --> 00:04:31.672 align:middle
有射击组件可以解决射击问题

00:04:32.105 --> 00:04:34.274 align:middle
还有目标组件
这表示可命中目标

00:04:36.944 --> 00:04:40.280 align:middle
所以我们获得这些很好的小黑盒
具有特定功能松散结构的盒子

00:04:40.347 --> 00:04:43.150 align:middle
而不是与层次紧密结合的结构

00:04:46.486 --> 00:04:48.655 align:middle
所以我们现在看见的实体
和组件是的很好方法

00:04:48.722 --> 00:04:50.023 align:middle
可用于组织我们的游戏逻辑

00:04:51.325 --> 00:04:52.759 align:middle
举个例说他们很容易维护

00:04:52.826 --> 00:04:56.196 align:middle
因为他们是极好的黑盒子
具有压缩功能

00:04:56.330 --> 00:04:57.364 align:middle
他们倾向于更简单

00:04:59.533 --> 00:05:01.969 align:middle
我们也可以让实体
和组件进行良好的协作

00:04:59.533 --> 00:05:01.969 align:middle
我们也可以让实体
和组件进行良好的协作

00:05:02.135 --> 00:05:04.204 align:middle
现在我可以让一个开发人员
在一个组件上操作

00:05:04.471 --> 00:05:06.573 align:middle
另一个开发人员
在另一个组件上操作

00:05:06.840 --> 00:05:10.344 align:middle
并且他们不一定需要知道
这些组件间的具体细节

00:05:12.279 --> 00:05:14.281 align:middle
我可以随着复杂性的高低
得到很好的缩放比例

00:05:14.348 --> 00:05:18.685 align:middle
我的意思是 在那个类和继承模型中
我的层级越来越宽 越高

00:05:18.752 --> 00:05:20.153 align:middle
随着我的游戏变得越复杂

00:05:20.554 --> 00:05:22.823 align:middle
有了实体和组件
它只是在宽度中变得更宽

00:05:23.490 --> 00:05:25.292 align:middle
而不再有其他变化

00:05:25.659 --> 00:05:26.827 align:middle
真的是个好工具

00:05:27.828 --> 00:05:29.396 align:middle
无论何时想在游戏中制作个新实体

00:05:29.463 --> 00:05:31.198 align:middle
我只要简单地看下可用的组件

00:05:31.598 --> 00:05:34.168 align:middle
选择合适的或执行新的组件

00:05:35.669 --> 00:05:38.972 align:middle
有了实体和组件
我们可以轻易获取动态行为

00:05:39.673 --> 00:05:41.141 align:middle
让我们回想塔防例子

00:05:41.208 --> 00:05:45.412 align:middle
我想要实现施放魔咒使弓箭手固定不动
这样他们不再移动

00:05:46.346 --> 00:05:49.917 align:middle
一种典型的方法可能是
暂时删除它的移动组件

00:05:50.384 --> 00:05:52.019 align:middle
间接地告诉游戏剩下的部分

00:05:52.386 --> 00:05:53.520 align:middle
停止移动

00:05:53.620 --> 00:05:57.991 align:middle
并且在这里还有其他的优势
即不需要知道魔咒的细节

00:05:59.826 --> 00:06:01.295 align:middle
那么让我们继续往下
看一下类

00:05:59.826 --> 00:06:01.295 align:middle
那么让我们继续往下
看一下类

00:06:02.129 --> 00:06:03.430 align:middle
此时我们有GKEntity

00:06:03.797 --> 00:06:04.898 align:middle
这是基于实体的类

00:06:04.965 --> 00:06:07.334 align:middle
这是个简单的组件集合

00:06:07.868 --> 00:06:10.871 align:middle
随着实体功能改变

00:06:11.171 --> 00:06:13.407 align:middle
它可以动态增加和删除组件

00:06:14.241 --> 00:06:17.144 align:middle
同时也让我通过独特类的类型
访问现有的组件

00:06:18.378 --> 00:06:22.549 align:middle
当我在GKEntity上调用更新时
自身拥有的组件将自动更新

00:06:23.584 --> 00:06:27.888 align:middle
所以回想之前的例子 弹 塔 弓箭手
都随着GKEntities而更新

00:06:31.592 --> 00:06:33.160 align:middle
现在讲GKComponent类

00:06:33.227 --> 00:06:37.598 align:middle
现在当你要在游戏中添加功能时
你可以把这编入子集

00:06:37.664 --> 00:06:39.066 align:middle
并且有多种方法可以实现

00:06:39.967 --> 00:06:43.270 align:middle
你的组件属性成为那些组件的状态信息

00:06:43.904 --> 00:06:46.707 align:middle
所以你可以想象
射击组件此时很可能有一个伤害属性

00:06:46.940 --> 00:06:49.042 align:middle
描述了炮弹能造成多大的伤害

00:06:50.477 --> 00:06:53.046 align:middle
你也可以执行自定义选择器
进行功能扩展

00:06:53.547 --> 00:06:55.782 align:middle
也可以告诉游戏的剩余部分
如何与组件进行通讯

00:06:56.783 --> 00:06:59.987 align:middle
同样举个例子 移动组件此时可能
有能移动到某位置的功能

00:07:00.187 --> 00:07:02.956 align:middle
你可以调用输入或调用游戏控制器代码

00:07:04.191 --> 00:07:07.327 align:middle
正如我之前所提到的
组件是通过它实体更新实现自动更新

00:07:07.394 --> 00:07:11.465 align:middle
并且你可以随意地在
updateWithDeltaTime中执行时间逻辑

00:07:14.968 --> 00:07:19.840 align:middle
因此你需要更好地控制命令
或控制组件的更新

00:07:20.240 --> 00:07:22.543 align:middle
为此我们提供
GKComponentSystem

00:07:23.143 --> 00:07:25.612 align:middle
这是不同实体的组件集合

00:07:25.879 --> 00:07:29.149 align:middle
但他们都是同类的类型

00:07:29.616 --> 00:07:32.653 align:middle
并且在当更新命令对游戏内部
起到重要作用的情况下调用

00:07:33.086 --> 00:07:35.322 align:middle
在更新移动代码后
我可能想要更新AI

00:07:35.389 --> 00:07:39.359 align:middle
因为我想让我的AI
处理最新的位置信息

00:07:40.928 --> 00:07:45.599 align:middle
需要留意的是放置在组件系统中的组件
不会随着实体更新而更新

00:07:45.832 --> 00:07:48.235 align:middle
而取决于在正确的时间
调用组件系统更新

00:07:48.402 --> 00:07:50.571 align:middle
以便更新所有的实体

00:07:51.538 --> 00:07:53.106 align:middle
所以再一次回想我们的例子

00:07:53.407 --> 00:07:57.811 align:middle
我们可能有一个移动系统
能够移动游戏中的组件

00:07:58.312 --> 00:08:01.448 align:middle
并且我可以用来
同步多种实体间的移动

00:07:58.312 --> 00:08:01.448 align:middle
并且我可以用来
同步多种实体间的移动

00:08:04.651 --> 00:08:08.455 align:middle
最后我有一个代码例子 看看如何使用
GameplayKit的实体和组件

00:08:09.156 --> 00:08:11.091 align:middle
你看下此处的上方
我将制作我的弓箭手实体

00:08:11.725 --> 00:08:14.428 align:middle
然后我将制作三个组件
构成一个弓箭手移动组件

00:08:14.761 --> 00:08:17.531 align:middle
射击组件和目标组件

00:08:17.831 --> 00:08:19.233 align:middle
并且给我的弓箭手增加这些组件

00:08:20.534 --> 00:08:23.971 align:middle
然后我将制作谈到的移动系统
进入移动组件的类

00:08:24.037 --> 00:08:26.673 align:middle
指示这个组件系统只处理移动组件

00:08:28.008 --> 00:08:30.310 align:middle
然后我将增加弓箭手的移动组件
到移动系统

00:08:30.544 --> 00:08:34.280 align:middle
然后继续进行
弓箭手和移动系统准备就绪可以使用了

00:08:38.284 --> 00:08:39.586 align:middle
所以接下来是实体和组件

00:08:39.886 --> 00:08:41.655 align:middle
因此让我们转移到状态机

00:08:43.789 --> 00:08:45.092 align:middle
此时我将讲解其它例子

00:08:45.325 --> 00:08:47.895 align:middle
让我们想象一些游戏
游戏中玩家被鬼魂追捕

00:08:48.395 --> 00:08:52.099 align:middle
有时他获得力量加成
然后追赶并击败鬼魂

00:08:53.500 --> 00:08:57.037 align:middle
这有一个状态机的例子
说明如何控制鬼魂的

00:08:58.071 --> 00:09:00.841 align:middle
此时你看 我们有四个鬼魂状态

00:08:58.071 --> 00:09:00.841 align:middle
此时你看 我们有四个鬼魂状态

00:09:01.241 --> 00:09:02.976 align:middle
当鬼魂追逐玩家时可以逃跑

00:09:03.777 --> 00:09:05.445 align:middle
当玩家追逐鬼魂时可以被追赶

00:09:06.079 --> 00:09:08.582 align:middle
当鬼魂被抓住且被打败时可以被击败

00:09:09.249 --> 00:09:13.220 align:middle
并且在击败后和复活前
有时候可以复位

00:09:14.621 --> 00:09:17.457 align:middle
现在重要的事情是
请注意只有一部分状态转换是有效的

00:09:18.292 --> 00:09:20.661 align:middle
你可以看到 我在追赶和逃跑之间转换

00:09:20.794 --> 00:09:22.729 align:middle
根据我刚才描述的这是合理的

00:09:22.963 --> 00:09:26.366 align:middle
有时候是鬼在追赶玩家
有时候是玩家在追赶鬼

00:09:27.534 --> 00:09:29.469 align:middle
当然只有在逃跑的时候会打败鬼

00:09:29.536 --> 00:09:33.640 align:middle
这是玩家可以真正打败鬼的唯一时刻
当获得力量后就可以追赶鬼

00:09:34.675 --> 00:09:37.044 align:middle
然后复活再被打败
这是同样的道理

00:09:37.344 --> 00:09:39.246 align:middle
在我们重生之后
我们就开始追赶鬼

00:09:39.313 --> 00:09:40.247 align:middle
这是我们的初始状态

00:09:40.314 --> 00:09:43.250 align:middle
当鬼重生之后
它们就变回追赶玩家

00:09:46.053 --> 00:09:48.522 align:middle
因此为什么说状态机
对游戏开发是如此重要

00:09:49.323 --> 00:09:52.359 align:middle
对于很多游戏来说
这是游戏设置元素的重要部分

00:09:53.160 --> 00:09:55.462 align:middle
许多常见的游戏设置
元素都充满了状态

00:09:55.529 --> 00:09:58.966 align:middle
例如动画制作AI UI 等级

00:10:00.434 --> 00:10:02.202 align:middle
想要在游戏中赋予让人物类角色以生命

00:10:02.269 --> 00:10:04.471 align:middle
毫无疑问地
开发者必须对状态机非常熟悉

00:10:04.905 --> 00:10:06.273 align:middle
我们通常有个IdleAnimation

00:10:06.340 --> 00:10:08.709 align:middle
和MoveAnimation
及AttackAnimation

00:10:08.775 --> 00:10:10.344 align:middle
并在它们之间进行合理切换

00:10:12.379 --> 00:10:15.148 align:middle
因此由于这种模式
在我们的代码中是很普遍的

00:10:15.816 --> 00:10:16.650 align:middle
我们会执行多次

00:10:16.950 --> 00:10:22.022 align:middle
与部分样板文件一样
采用个开关语句或者树状结构

00:10:23.557 --> 00:10:25.626 align:middle
是否有一些常见的方法

00:10:25.692 --> 00:10:28.662 align:middle
用于删除样板文件
添加一些可维护性

00:10:29.062 --> 00:10:32.566 align:middle
让我们可以在整个游戏中
从使用状态和状态机得益呢

00:10:33.700 --> 00:10:35.702 align:middle
这就是我们在
GameplayKit里做的

00:10:35.769 --> 00:10:36.870 align:middle
让我们来看看类

00:10:38.305 --> 00:10:39.773 align:middle
这里我们有
GKStateMachine

00:10:39.840 --> 00:10:42.009 align:middle
这是你的总体目标限定状态机

00:10:42.075 --> 00:10:45.946 align:middle
我的意思是说
任何给定的状态均只有一个状态

00:10:46.647 --> 00:10:49.049 align:middle
它拥有所有的状态

00:10:50.250 --> 00:10:54.521 align:middle
你可以调用状态机里的
enterState进行状态转换

00:10:54.988 --> 00:10:59.560 align:middle
具体发生了什么呢
如果转换是有效的 它会检查改变

00:11:00.260 --> 00:11:02.663 align:middle
它调用许多状态目标的回调函数

00:11:02.729 --> 00:11:05.999 align:middle
退出状态 进入状态等

00:11:06.200 --> 00:11:08.368 align:middle
并更新状态机里的现有状态

00:11:09.303 --> 00:11:11.939 align:middle
在那个鬼的例子中
我们可能有个GhostStateMachine

00:11:12.005 --> 00:11:14.208 align:middle
它将依次有四个状态

00:11:17.578 --> 00:11:19.379 align:middle
这里我们有
GKState抽象类

00:11:20.514 --> 00:11:23.617 align:middle
然后调用回调函数
执行状态基础逻辑

00:11:23.684 --> 00:11:25.786 align:middle
当你键入状态的时候
我们给你一个进入回调函数

00:11:26.019 --> 00:11:27.921 align:middle
当你离开状态时
我们给你个退出回调函数

00:11:28.121 --> 00:11:30.691 align:middle
当状态机里是现有状态的时候
我们给你一个更新回调函数

00:11:30.891 --> 00:11:34.428 align:middle
正如我之前所提
它们会在何时的时间自动被状态机调用

00:11:35.762 --> 00:11:38.165 align:middle
你可以选择性地重写
isValidNextState功能

00:11:38.232 --> 00:11:41.735 align:middle
从而控制状态图边缘
就是那些我说的有效转换

00:11:42.436 --> 00:11:44.471 align:middle
现在通过默认值
所有这些边缘都是有效的

00:11:44.538 --> 00:11:49.776 align:middle
但毫无疑问的是你想要调用
状态的内部动态决定哪个转换是有效的

00:11:51.144 --> 00:11:54.281 align:middle
我们讨论的四个鬼状态
追赶 被打败 逃跑 重生

00:11:54.581 --> 00:11:56.250 align:middle
全部会随着GKState被执行

00:11:58.886 --> 00:12:00.888 align:middle
因此我想要在这里通过一个例子
结束这个问题

00:11:58.886 --> 00:12:00.888 align:middle
因此我想要在这里通过一个例子
结束这个问题

00:12:01.321 --> 00:12:04.024 align:middle
让我们执行刚刚讨论的
GhostStateMachine

00:12:04.191 --> 00:12:06.326 align:middle
一开始我要说说我的四个状态

00:12:06.660 --> 00:12:09.062 align:middle
追赶 逃跑 被打败以及重生

00:12:10.430 --> 00:12:12.966 align:middle
然后我将使我的状态机
经历这四种状态

00:12:13.033 --> 00:12:15.269 align:middle
这四种状态是状态机里有的状态

00:12:16.637 --> 00:12:19.740 align:middle
然后我将继续并在例子中
进入追赶的初始状态

00:12:20.040 --> 00:12:22.342 align:middle
我们开始这个状态机
它已为我们的游戏做好了准备

00:12:22.409 --> 00:12:24.444 align:middle
并且鬼将做我们希望它做的

00:12:28.048 --> 00:12:28.982 align:middle
这就是状态机

00:12:29.983 --> 00:12:32.319 align:middle
让我们转向主体 目标和行为

00:12:33.987 --> 00:12:35.789 align:middle
在我们开始之前先说一些概念

00:12:37.591 --> 00:12:39.626 align:middle
我们说的主体 目标和行为

00:12:39.893 --> 00:12:41.962 align:middle
都是真正的自主移动实体

00:12:42.563 --> 00:12:45.432 align:middle
由现实的行为和目标所控制

00:12:45.799 --> 00:12:50.170 align:middle
它们受制于许多客观约束
如掩码 加速度和惯性

00:12:51.805 --> 00:12:57.044 align:middle
控制这些主体的行为反过来
组成一定的目标并附上适当的权重

00:12:57.277 --> 00:13:00.647 align:middle
从而在游戏中
完成一些有意义的自主运动

00:12:57.277 --> 00:13:00.647 align:middle
从而在游戏中
完成一些有意义的自主运动

00:13:03.984 --> 00:13:06.253 align:middle
因此为什么主体
在游戏发展中如此重要

00:13:06.720 --> 00:13:10.657 align:middle
我想许多游戏
都是以现实情况为出发点

00:13:11.225 --> 00:13:13.026 align:middle
当我们的游戏实体呈直线运动

00:13:13.293 --> 00:13:18.031 align:middle
然后再转弯后撞上环境障碍物
这样看起来就不是很真实

00:13:19.132 --> 00:13:20.934 align:middle
现实世界的运动有诸如惯性

00:13:21.335 --> 00:13:22.636 align:middle
质量和加速度这类的因素

00:13:23.136 --> 00:13:25.973 align:middle
这样它就可以准确地
避开附近的障碍物和其它实体

00:13:27.274 --> 00:13:30.344 align:middle
当实体知道如何从点A到点B
它们通常跟随一条路径

00:13:30.410 --> 00:13:32.746 align:middle
并且路径通常是笔直的而非曲折的

00:13:36.283 --> 00:13:38.619 align:middle
以上就是对主体系统的简单概述

00:13:38.986 --> 00:13:41.722 align:middle
我们有主体类
由一个行为控制

00:13:42.055 --> 00:13:44.892 align:middle
也有一个指派
让你可以回应 主体中的变化

00:13:46.193 --> 00:13:51.198 align:middle
这些行为反过来组成一定的权重目标
从而实现有意义的功能

00:13:51.999 --> 00:13:57.104 align:middle
你可以设置许多目标
如寻找 拦截 避免障碍物及跟随路径

00:14:00.374 --> 00:14:01.842 align:middle
让我们继续看看类

00:14:02.609 --> 00:14:05.245 align:middle
GKAgent
是一个简单的自主质点

00:14:05.679 --> 00:14:07.080 align:middle
也是个
GKComponent

00:14:07.247 --> 00:14:09.416 align:middle
和实体 组件系统配合得非常出色

00:14:10.184 --> 00:14:13.854 align:middle
当你在GKAgent上调用更新
它将应用当前行为

00:14:13.987 --> 00:14:17.624 align:middle
具体的是查看组成行为的目标

00:14:18.592 --> 00:14:25.465 align:middle
然后计算权重及所有必须的加速变化
从而达成目标

00:14:26.834 --> 00:14:28.602 align:middle
然后运用加速中的变化

00:14:29.169 --> 00:14:31.972 align:middle
改变主体速度和旋转位置

00:14:33.440 --> 00:14:36.043 align:middle
正如我说的 现在GKAgent受制
于许多客观约束

00:14:36.109 --> 00:14:39.646 align:middle
例如质量 反弹半径
最大速度和最大加速度

00:14:40.514 --> 00:14:44.484 align:middle
很重要的是请注意
这些单元式无标度且只适用于游戏世界

00:14:45.252 --> 00:14:49.056 align:middle
因此你可以想象以公里为单位的游戏
相对于英尺为单位的游戏

00:14:49.656 --> 00:14:51.124 align:middle
二者将有非常大的差异

00:14:51.825 --> 00:14:54.161 align:middle
因此要确保游戏世界选择合适的数值

00:14:56.797 --> 00:14:58.398 align:middle
这里我们有GKBehavior类

00:14:58.465 --> 00:15:01.068 align:middle
它是一个像字典一样的简单目标容器

00:14:58.465 --> 00:15:01.068 align:middle
它是一个像字典一样的简单目标容器

00:15:01.768 --> 00:15:05.606 align:middle
它让你随着游戏
动态修改行为

00:15:06.039 --> 00:15:09.910 align:middle
你可以添加新的行为
添加新的目标

00:15:10.310 --> 00:15:13.447 align:middle
移动已有目标
改变已有目标的重量

00:15:14.381 --> 00:15:16.383 align:middle
正如我之前提过的
在主体设置了一个行为

00:15:16.483 --> 00:15:17.484 align:middle
主体将很好地执行

00:15:17.584 --> 00:15:21.688 align:middle
下次你更新主体时
它将正确遵循该行为

00:15:23.156 --> 00:15:26.326 align:middle
举几个关于行为例子
可能你想执行群集行为

00:15:26.693 --> 00:15:28.662 align:middle
以模仿现实世界中鸟类的群集

00:15:29.296 --> 00:15:32.065 align:middle
我们可以通过合适权重
将一个凝聚目标 一个分离目标

00:15:32.366 --> 00:15:33.834 align:middle
和一个匹配目标结合在一起

00:15:35.502 --> 00:15:38.872 align:middle
或者我可能正在做一个赛车游戏
我想要做一个竞赛行为控制赛车

00:15:39.606 --> 00:15:41.475 align:middle
这就像结合跟随路径那样简单

00:15:41.542 --> 00:15:43.410 align:middle
我想要我的赛车跟随赛道

00:15:44.011 --> 00:15:45.379 align:middle
避开其他主体目标

00:15:45.612 --> 00:15:48.382 align:middle
我想要我的赛车避免和其他赛车相撞

00:15:51.218 --> 00:15:53.453 align:middle
这代码样本看起来像室行为代码的样子

00:15:54.221 --> 00:15:55.822 align:middle
看上面 我将创建寻找行为

00:15:55.889 --> 00:15:58.058 align:middle
我想在我的环境里找一些敌方的主体

00:15:59.426 --> 00:16:02.162 align:middle
我将创建一个回避目标
用来避开附近的障碍

00:15:59.426 --> 00:16:02.162 align:middle
我将创建一个回避目标
用来避开附近的障碍

00:16:02.763 --> 00:16:07.100 align:middle
然后我将创建一个targetSpeed目标
我想要我的主体加速并达到目标速度

00:16:08.502 --> 00:16:12.840 align:middle
然后用一套合适的权重
让我的行为通过这三个目标

00:16:13.307 --> 00:16:15.209 align:middle
你可以看到我把回避目标权重加到5

00:16:15.275 --> 00:16:18.111 align:middle
因为我真的不想让我的主体
撞到附近的障碍

00:16:19.479 --> 00:16:20.547 align:middle
然后我将创建我的主体

00:16:20.881 --> 00:16:22.950 align:middle
初始化 设置行为

00:16:23.450 --> 00:16:24.418 align:middle
主体已经准备好了

00:16:24.484 --> 00:16:28.288 align:middle
下次我更新主体时
它将完全按照我的要求来做

00:16:31.325 --> 00:16:32.860 align:middle
现在来讲讲主体指派

00:16:33.694 --> 00:16:36.730 align:middle
在你需要使用基础指派模仿

00:16:36.830 --> 00:16:39.266 align:middle
同步你的外观
事物如图形 动画 物理时

00:16:39.600 --> 00:16:41.602 align:middle
GKAgentDelegate
就很有用了

00:16:42.503 --> 00:16:44.137 align:middle
我们提供两个回调函数对其进行操作

00:16:44.338 --> 00:16:47.741 align:middle
在主体更新前
调用agentWillUpdate

00:16:48.408 --> 00:16:50.878 align:middle
在设备更新后
调用agentDidUpdate

00:16:52.012 --> 00:16:54.815 align:middle
在你的游戏中
这或许就像是SpriteKit节点

00:16:55.215 --> 00:16:57.584 align:middle
或SceneKit节点 或渲染组件

00:16:59.987 --> 00:17:02.756 align:middle
我们来看看SpriteKit游戏中
这个指派看起来像什么

00:16:59.987 --> 00:17:02.756 align:middle
我们来看看SpriteKit游戏中
这个指派看起来像什么

00:17:03.457 --> 00:17:06.292 align:middle
你可以看到这里有个自定义图形节点
MyAgentSpriteNode

00:17:06.627 --> 00:17:09.796 align:middle
我将继续操作
并执行我刚说过的两个回调函数

00:17:10.864 --> 00:17:13.901 align:middle
在agentWillUpdate中
我将在循环里设置主体的位置

00:17:13.967 --> 00:17:15.801 align:middle
它们的节点位置一样

00:17:15.969 --> 00:17:18.672 align:middle
我想让基础主体模仿和我的外观相匹配

00:17:19.906 --> 00:17:21.108 align:middle
然后我将做一些更新

00:17:21.508 --> 00:17:23.743 align:middle
然后在agentDidUpdate中
做的事情刚好相反

00:17:23.810 --> 00:17:25.878 align:middle
我将在循环中设置节点位置

00:17:26.213 --> 00:17:30.384 align:middle
它的位置和循环中主体的位置一样
外观将和基本主体模拟相匹配

00:17:33.520 --> 00:17:34.821 align:middle
我将简要的为你展示一下

00:17:35.455 --> 00:17:38.492 align:middle
主体运动的样子
和你可以自行处理的一些目标

00:17:49.203 --> 00:17:53.307 align:middle
有个简单的SpriteKit情景
我们用一个圆圈里的三角形来代表主体

00:17:53.674 --> 00:17:55.209 align:middle
他们按照三角形的指向调整方向

00:17:56.176 --> 00:17:57.377 align:middle
这里我有一个座位目标

00:17:57.978 --> 00:18:00.714 align:middle
中间的主体会试图寻找鼠标的位置

00:17:57.978 --> 00:18:00.714 align:middle
中间的主体会试图寻找鼠标的位置

00:18:01.782 --> 00:18:03.784 align:middle
可以看到
移动看起来很流畅自然

00:18:03.884 --> 00:18:08.021 align:middle
因为它是受真实物理约束
比如质量 加速度和惯性

00:18:14.061 --> 00:18:15.963 align:middle
这里有个相反的事例 逃跑目标

00:18:16.063 --> 00:18:19.032 align:middle
主体试图
逃离鼠标的位置

00:18:25.706 --> 00:18:27.140 align:middle
这是漫步行为的事例

00:18:27.708 --> 00:18:31.678 align:middle
我的主体正在环境里任意移动
任意左转 右转

00:18:40.020 --> 00:18:41.922 align:middle
这是一个障碍回避目标事例

00:18:42.122 --> 00:18:44.191 align:middle
我的主体又在试图
寻找鼠标的位置

00:18:44.258 --> 00:18:46.693 align:middle
但我在情景里
增加了一些循环障碍物

00:18:47.060 --> 00:18:48.729 align:middle
主体的目标之一是回避障碍

00:18:49.062 --> 00:18:53.500 align:middle
所以在他试图寻找鼠标位置时
同时也在避免和障碍物相撞

00:19:02.843 --> 00:19:04.278 align:middle
这是一个分离目标事例

00:19:04.344 --> 00:19:07.080 align:middle
我有三个主体正在试图寻找鼠标位置

00:19:07.347 --> 00:19:09.016 align:middle
但他们同时有一个分离目标

00:19:09.283 --> 00:19:11.752 align:middle
他们之间试图保持最小距离

00:19:12.586 --> 00:19:17.257 align:middle
这对游戏中编队飞行或各组保持在一起
真的很有用

00:19:22.529 --> 00:19:24.131 align:middle
这里有个对齐目标事例

00:19:24.565 --> 00:19:27.534 align:middle
右边的主体试图
与左边主体的标签相对齐

00:19:29.369 --> 00:19:32.539 align:middle
这对于在游戏中同步单位
真的很有用

00:19:40.914 --> 00:19:42.449 align:middle
这里有一个群集目标事例

00:19:43.584 --> 00:19:46.486 align:middle
领导主体是在场景里漫步的红色

00:19:47.521 --> 00:19:50.224 align:middle
但是在一个群集行为里
同样还有一组蓝色主体

00:19:50.290 --> 00:19:52.826 align:middle
它们结合了一个凝聚目标
一个分离目标 和一个阵营目标

00:19:53.026 --> 00:19:55.996 align:middle
形成了一个集体
同时试图追逐领导实体

00:19:57.397 --> 00:20:00.133 align:middle
分离目标 维护他们之间的最小距离

00:19:57.397 --> 00:20:00.133 align:middle
分离目标 维护他们之间的最小距离

00:20:00.334 --> 00:20:03.470 align:middle
凝聚目标让它们
以结合块的形式待在一起

00:20:03.804 --> 00:20:07.074 align:middle
而对齐目标想让它们达到一个均等状态

00:20:11.178 --> 00:20:14.147 align:middle
最后是一个跟随路径的事例

00:20:14.615 --> 00:20:17.451 align:middle
我的主体正试图跟随简单的多线路径

00:20:18.652 --> 00:20:21.555 align:middle
请注意它并不会突然转弯

00:20:22.256 --> 00:20:25.859 align:middle
他正处于我们说过的真实物理约束下
比如质量和加速度

00:20:26.360 --> 00:20:30.898 align:middle
所以尽管基本路径是固定的
但是主体会被迫以曲线的跟随目标

00:20:37.804 --> 00:20:39.673 align:middle
以上就是主体 目标 和行为

00:20:49.516 --> 00:20:50.817 align:middle
我们现在继续来说说搜索路径

00:20:53.187 --> 00:20:55.656 align:middle
我很确定
在游戏开发中我们对此都很熟悉

00:20:56.256 --> 00:20:59.259 align:middle
在我的游戏世界里
有一些实体想从A点移到B点

00:20:59.593 --> 00:21:00.761 align:middle
但路径中有一个障碍

00:20:59.593 --> 00:21:00.761 align:middle
但路径中有一个障碍

00:21:01.995 --> 00:21:05.999 align:middle
我不想这些实体穿过障碍
我不想她碰到障碍

00:21:06.600 --> 00:21:09.870 align:middle
我想让她像人类一样
准确地找到路径 绕过障碍

00:21:11.171 --> 00:21:13.740 align:middle
我正在寻找的是这些东西

00:21:13.874 --> 00:21:19.213 align:middle
我想让她找到障碍周围
最短的路线 越过障碍 继续前往目标

00:21:21.215 --> 00:21:24.318 align:middle
我们调用游戏设置搜索路径

00:21:25.686 --> 00:21:27.221 align:middle
开始之前 说一些概念

00:21:28.288 --> 00:21:30.457 align:middle
导航图上的路径搜索操作

00:21:31.225 --> 00:21:35.863 align:middle
导航图是一个节点集合
体现的是游戏世界里可通行的区域

00:21:36.096 --> 00:21:38.432 align:middle
允许实体呆着以及移动的地方

00:21:39.700 --> 00:21:44.771 align:middle
这些节点依次连接在一起
体现在可通行区域是如何移动的

00:21:45.639 --> 00:21:48.475 align:middle
这些连接可以是单向的
也可以是双向的

00:21:49.610 --> 00:21:53.780 align:middle
在连接图中
任何两个节点之间总是存在最佳路径

00:21:54.314 --> 00:21:56.850 align:middle
这是在路径搜索中
我们通常会找到的路径

00:21:58.986 --> 00:22:00.521 align:middle
我们继续来看看类

00:21:58.986 --> 00:22:00.521 align:middle
我们继续来看看类

00:22:01.989 --> 00:22:04.858 align:middle
我们有GKGraph
这是抽象图基础类

00:22:05.192 --> 00:22:09.663 align:middle
它仅是图节点的容器
图节点是游戏世界里可通行区域的描述

00:22:10.797 --> 00:22:15.068 align:middle
在游戏世界有变动时
它有个功能可用来增加以及移除节点

00:22:15.769 --> 00:22:20.674 align:middle
它也可以让我将新节点连接到图上
与我希望的现有的节点做恰当的连接

00:22:22.075 --> 00:22:25.112 align:middle
当然我们也可以让
你在节点和一个图之间寻找路径

00:22:26.113 --> 00:22:28.015 align:middle
我们提供两个专门化

00:22:28.482 --> 00:22:31.952 align:middle
一个是GKGraph和网格配合使用
一个是GKGraph和障碍配合使用

00:22:32.252 --> 00:22:33.720 align:middle
我们现在来看下这两个东西

00:22:36.156 --> 00:22:37.291 align:middle
GKGridGraph

00:22:37.357 --> 00:22:39.893 align:middle
这是GK图
2D网格专用的

00:22:40.227 --> 00:22:43.830 align:middle
它所做的是自动创建所有节点
用来代表格框

00:22:44.565 --> 00:22:46.667 align:middle
既定的初始位置
网格 宽度网格以及高度网格

00:22:47.835 --> 00:22:51.004 align:middle
它将在网格节点间
自动创建基本连接

00:22:51.371 --> 00:22:53.073 align:middle
同样在在对角线之间
随意创建基本连接

00:22:53.640 --> 00:22:56.977 align:middle
它也有很简单的功能
在你的游戏中

00:22:57.044 --> 00:23:00.514 align:middle
网格空间变得不可通行时
可对其进行增加以及移除

00:22:57.044 --> 00:23:00.514 align:middle
网格空间变得不可通行时
可对其进行增加以及移除

00:23:03.016 --> 00:23:05.118 align:middle
接下来我们讲
GKObstacleGraph

00:23:05.185 --> 00:23:09.423 align:middle
这是GK图
游戏世界中 障碍周围路径搜索专用

00:23:09.690 --> 00:23:12.192 align:middle
障碍可以是任意的多边形

00:23:13.560 --> 00:23:18.699 align:middle
我们提供一些在游戏世界变化时
不断地增加以及移除障碍的功能

00:23:19.233 --> 00:23:21.602 align:middle
它也可以让你不断地
将新节点连接到图上

00:23:21.668 --> 00:23:27.641 align:middle
对于为一个单位寻找路径而在图中插入
一个开始以及结束节点来说很有用

00:23:28.976 --> 00:23:30.811 align:middle
我们通过一个缓冲区半径实现

00:23:30.878 --> 00:23:32.913 align:middle
这是障碍周围的安全地带

00:23:33.146 --> 00:23:34.648 align:middle
这里我的实体是进不去的

00:23:34.815 --> 00:23:36.583 align:middle
它通常是由游戏来决定大小

00:23:36.850 --> 00:23:40.220 align:middle
与我想要做导航的实体边界框半径有关

00:23:41.388 --> 00:23:44.291 align:middle
我们来说说
这些障碍图是如何被创建的

00:23:45.058 --> 00:23:47.661 align:middle
这里是一个简单的情景
有两个方形障碍

00:23:48.395 --> 00:23:52.032 align:middle
左下角的一个实体
想要到达右下角的桥上

00:23:52.766 --> 00:23:55.302 align:middle
我的实体受一些边界框半径约束

00:23:56.503 --> 00:24:00.307 align:middle
我们将它当做缓冲区半径
人为增大障碍

00:23:56.503 --> 00:24:00.307 align:middle
我们将它当做缓冲区半径
人为增大障碍

00:24:01.642 --> 00:24:06.513 align:middle
高级选项下
障碍图将在网格节点间创建合适的连接

00:24:07.447 --> 00:24:11.818 align:middle
它将不会创建违反障碍空间性的连接

00:24:12.219 --> 00:24:14.922 align:middle
从这里可以看到
我们找到了最短的路径了

00:24:15.122 --> 00:24:16.990 align:middle
它将不会和障碍相撞

00:24:22.663 --> 00:24:25.065 align:middle
这是最后示例的代码

00:24:25.232 --> 00:24:26.500 align:middle
但这个示例中只有一个障碍

00:24:26.900 --> 00:24:30.671 align:middle
在顶端我将创建一个
只有四个点的简单多边形障碍

00:24:31.972 --> 00:24:35.843 align:middle
我将创建障碍图进入障碍
以及一些缓冲区半径

00:24:37.377 --> 00:24:38.879 align:middle
然后我将创建一个开始和结束节点

00:24:39.179 --> 00:24:42.182 align:middle
一个是现在我的英雄所在地
另一个是她想去的地方

00:24:43.750 --> 00:24:48.488 align:middle
我不断地将这些节点
连接到我的障碍图上

00:24:48.722 --> 00:24:53.427 align:middle
它将做的是将这些节点插到图中
并再一次自动创建合理的连接

00:24:53.760 --> 00:24:57.097 align:middle
但它并不创建那些
会违反障碍空间性的节点

00:24:58.832 --> 00:25:01.335 align:middle
最后我为开始和结束节点寻找一个路径

00:24:58.832 --> 00:25:01.335 align:middle
最后我为开始和结束节点寻找一个路径

00:25:01.435 --> 00:25:03.704 align:middle
我取回一个简单的
图节点NSArray

00:25:03.770 --> 00:25:06.974 align:middle
我可以用它来激活角色

00:25:10.744 --> 00:25:13.547 align:middle
GKGraphNode
是图节点类的先进节点

00:25:13.914 --> 00:25:15.916 align:middle
毫无疑问
你会想对其进行划分子类

00:25:15.983 --> 00:25:21.388 align:middle
在你执行高级或非空间操作
或在需要精确控制路径搜索时

00:25:22.890 --> 00:25:24.491 align:middle
将非常好用

00:25:25.259 --> 00:25:27.628 align:middle
你可以设想一个拥有各种
版图类型的战略游戏

00:25:27.694 --> 00:25:29.096 align:middle
或许你想要一个森林版图类型

00:25:29.563 --> 00:25:31.732 align:middle
可以向其他版图类型一样做双倍挪动

00:25:32.099 --> 00:25:34.234 align:middle
我需要考虑路径搜索

00:25:34.301 --> 00:25:36.870 align:middle
我不想它返回可见的最短路径

00:25:37.137 --> 00:25:39.306 align:middle
我只想它在森林周围进行导航

00:25:39.706 --> 00:25:42.943 align:middle
因为事实上
在我的游戏世界里这是最短的路径

00:25:44.344 --> 00:25:47.281 align:middle
在你想手动创建自己的图时
GKGraphNode同样也很有用

00:25:47.381 --> 00:25:50.484 align:middle
你通过手动管理节点间的连接
手动创建自己的图

00:25:50.918 --> 00:25:54.021 align:middle
对于一些像抽象或非空间图的东西
这真的是好东西

00:25:54.454 --> 00:25:59.593 align:middle
或许你想要你的游戏有个端口
想要单位让这些端口为路径搜索负责

00:26:00.127 --> 00:26:02.729 align:middle
尽管这些端口在空间上并不相连

00:26:04.331 --> 00:26:07.835 align:middle
Grid/GraphNode和使用
障碍节点的GraphNode2D

00:26:07.901 --> 00:26:09.970 align:middle
正如你所看到的都很合适

00:26:13.273 --> 00:26:14.808 align:middle
对于这个特性
我真的很兴奋

00:26:14.875 --> 00:26:16.810 align:middle
我们和SpriteKit组
配合做了一些工作

00:26:16.877 --> 00:26:19.346 align:middle
可让你从现有的
SpriteKit Scenes中

00:26:19.413 --> 00:26:21.281 align:middle
很容易地创建这些障碍图

00:26:21.782 --> 00:26:26.153 align:middle
你可以为这些类似节点边界
节点实体和节点材质的东西创建障碍图

00:26:27.221 --> 00:26:28.922 align:middle
这个意思是说只要极少的代码

00:26:28.989 --> 00:26:32.192 align:middle
你就可以获得一个现有的SpriteKit场景
创建一个障碍图

00:26:32.559 --> 00:26:34.394 align:middle
并动地在其周围路径搜索

00:26:35.996 --> 00:26:37.931 align:middle
现在我们为你稍微展示一下

00:26:38.699 --> 00:26:40.567 align:middle
我们用SpriteKit来搜索路径

00:26:52.246 --> 00:26:54.314 align:middle
这里有一个我们讲过的塔防游戏

00:26:54.548 --> 00:26:56.416 align:middle
我们将它作为
SpriteKit场景来执行

00:26:57.684 --> 00:27:00.787 align:middle
我在左边创建实体
它们想移到右边的桥上

00:26:57.684 --> 00:27:00.787 align:middle
我在左边创建实体
它们想移到右边的桥上

00:27:01.522 --> 00:27:02.823 align:middle
因为这是个塔防游戏

00:27:02.890 --> 00:27:07.794 align:middle
我将在右边放置一些塔
而这占用了它们现在的路径

00:27:07.928 --> 00:27:08.896 align:middle
我们继续 放置一个

00:27:10.264 --> 00:27:12.432 align:middle
你将看到它们在它的周围
正确地搜索路径

00:27:12.499 --> 00:27:14.668 align:middle
那是因为我们正在用刚讲过的
SpriteKit集成

00:27:14.735 --> 00:27:17.271 align:middle
自动地从节点创建一个障碍

00:27:17.971 --> 00:27:19.873 align:middle
更基本的
GKObstacleGraph

00:27:20.040 --> 00:27:20.941 align:middle
以及更新我们的路径

00:27:21.508 --> 00:27:23.677 align:middle
我们转向调试程序
迅速的将塔移开

00:27:24.444 --> 00:27:27.247 align:middle
你可以看到从开始
和结束节点间的简单路径

00:27:28.015 --> 00:27:29.583 align:middle
当我在这里插入一个障碍时

00:27:30.184 --> 00:27:32.719 align:middle
我们重新计算了基本的
GKObstacleGraph

00:27:33.020 --> 00:27:35.722 align:middle
这就允许我们的实体
在障碍周围找一条新路径

00:27:36.790 --> 00:27:38.091 align:middle
我们继续增加一些东西

00:27:41.662 --> 00:27:45.666 align:middle
因为有那个SpriteKit集成
每次我们增加或移除障碍时

00:27:46.133 --> 00:27:48.902 align:middle
基本GKObstacleGraph
总能进行更新

00:27:53.607 --> 00:27:55.609 align:middle
以上就是使用
SpriteKit的路径搜索

00:28:04.852 --> 00:28:06.920 align:middle
现在有请我的同事萝丝·德克斯特

00:28:07.087 --> 00:28:09.223 align:middle
为我们讲讲MinMax AI

00:28:09.690 --> 00:28:10.524 align:middle
萝丝

00:28:16.430 --> 00:28:17.264 align:middle
谢谢你 布鲁诺

00:28:19.967 --> 00:28:24.771 align:middle
布鲁诺刚讲的很多特性
可以用来创建AI

00:28:25.739 --> 00:28:28.509 align:middle
但它们更多的是在你的游戏中
给于实体生命

00:28:29.376 --> 00:28:34.181 align:middle
许多游戏也需要同等的AI对手
用人类玩家同样的规则来玩整个游戏

00:28:34.248 --> 00:28:38.352 align:middle
这对于有些游戏来说是很关键的
如象棋 西洋棋 一字棋等等

00:28:39.086 --> 00:28:40.821 align:middle
所以我们想为你提供解决方案

00:28:42.122 --> 00:28:45.225 align:middle
我们选择实现经典
AI解决方案MinMax

00:28:45.292 --> 00:28:47.194 align:middle
将它当做GameplayKit
关键部分

00:28:47.294 --> 00:28:50.130 align:middle
MinMax会查看
所有适合玩家的移动

00:28:50.397 --> 00:28:55.936 align:middle
然后它根据每个移动及每个移动
能产生的所有排列建立一个决策图标

00:28:56.837 --> 00:29:00.374 align:middle
当你请求一个移动
它就搜索决策图标最大化潜在收获

00:28:56.837 --> 00:29:00.374 align:middle
当你请求一个移动
它就搜索决策图标最大化潜在收获

00:29:00.641 --> 00:29:04.878 align:middle
同时最小化潜在损失

00:29:05.379 --> 00:29:06.847 align:middle
在这个一字棋事例中

00:29:07.281 --> 00:29:12.219 align:middle
AI为X玩家选择了右边的一步
因为是在最好的情况下 结果是胜利

00:29:12.486 --> 00:29:14.454 align:middle
在最差的情况下 结果是平局

00:29:14.821 --> 00:29:17.224 align:middle
其他两个布则会导致失败

00:29:19.960 --> 00:29:23.497 align:middle
MinMax AI给你
控制对手的能力

00:29:23.730 --> 00:29:27.601 align:middle
当人类玩家陷入困局时
它也可以为人类玩家提供建议

00:29:27.868 --> 00:29:31.071 align:middle
这对于游戏来说非常好
甚至都不需要其他的AI请求

00:29:32.272 --> 00:29:33.774 align:middle
它尤其适合以转弯类的游戏

00:29:33.841 --> 00:29:38.846 align:middle
但也同样适合对于需要玩家
操作的不连续移动的游戏

00:29:40.180 --> 00:29:46.787 align:middle
但你也可以通过改变对未来的预测程度
调整AI的难度

00:29:47.421 --> 00:29:48.889 align:middle
事先预测10步

00:29:48.956 --> 00:29:52.359 align:middle
当然要比事先
只预测2 3步要来的更有效

00:29:52.993 --> 00:29:57.531 align:middle
此外你可以随意指挥它
任意挑选最不适宜的一步

00:29:57.598 --> 00:29:59.266 align:middle
给它一些类似人类的错误

00:30:00.834 --> 00:30:02.369 align:middle
我们来看看它如何整合到游戏之中

00:30:03.337 --> 00:30:06.807 align:middle
MinMax非常棒的地方是
你不需要知道游戏的任何细节

00:30:06.907 --> 00:30:10.511 align:middle
你不需要告诉它你的规则
它也不需要知道该如何执行

00:30:11.078 --> 00:30:12.312 align:middle
所有的这些都是抽象的

00:30:12.446 --> 00:30:15.349 align:middle
你所需做的只是提供游戏中的玩家清单

00:30:15.883 --> 00:30:17.117 align:middle
他们可能会走的步

00:30:17.718 --> 00:30:21.922 align:middle
每个玩家的分数
用来显示他们目前位置的相对强弱

00:30:23.257 --> 00:30:27.661 align:middle
当你向AI请求一步
它会考虑所有这些数据 创建决策图标

00:30:27.794 --> 00:30:30.030 align:middle
返回一个最佳策略供你使用

00:30:33.667 --> 00:30:34.568 align:middle
我们来看看类

00:30:34.835 --> 00:30:38.572 align:middle
有三个所需的关键协议
以便与MinMax AI配合使用

00:30:38.805 --> 00:30:40.507 align:middle
第一个是GKGameModel

00:30:40.841 --> 00:30:42.876 align:middle
指的是对目前游戏状态进行抽象

00:30:44.811 --> 00:30:51.685 align:middle
比如你在创建一个象棋游戏
执行该类的较佳的是板类

00:30:51.952 --> 00:30:55.822 align:middle
因为它追踪板上所有的位置
以及目前在玩的所有块

00:30:56.557 --> 00:30:57.858 align:middle
正如我在前面的幻灯片提到的

00:30:58.158 --> 00:31:01.962 align:middle
所需做的是提供游戏中活跃的玩家清单

00:30:58.158 --> 00:31:01.962 align:middle
所需做的是提供游戏中活跃的玩家清单

00:31:02.229 --> 00:31:05.265 align:middle
目前的玩家
每个玩家的分数

00:31:05.499 --> 00:31:08.468 align:middle
然后是每个玩家可能会下的每一步

00:31:09.503 --> 00:31:11.538 align:middle
同样也需要一个应用这些步的方法

00:31:11.972 --> 00:31:14.374 align:middle
AI用这个方法创建出决策图标

00:31:14.441 --> 00:31:17.644 align:middle
在它已经被AI选中后
你也可以用它来应用每一步

00:31:18.178 --> 00:31:21.215 align:middle
当采用该步后
它将改变目前游戏状态

00:31:21.448 --> 00:31:23.784 align:middle
可能改变玩家目前的行动

00:31:24.218 --> 00:31:25.786 align:middle
每个玩家的分数

00:31:25.919 --> 00:31:26.954 align:middle
以及适合他们的下一步

00:31:28.455 --> 00:31:30.591 align:middle
接下来的协议是
GKGameModelUpdate

00:31:30.657 --> 00:31:32.526 align:middle
这是游戏里的动作抽象

00:31:33.260 --> 00:31:37.364 align:middle
它应该有你为游戏模型
应用每一步的全部数据

00:31:38.031 --> 00:31:41.201 align:middle
正如我们所说的
MinMax用它创建决策图标

00:31:41.268 --> 00:31:44.137 align:middle
在它被选中后
你可以用它来做出下一步行动

00:31:45.272 --> 00:31:47.374 align:middle
最后是
GKGameModelPlayer

00:31:47.608 --> 00:31:49.443 align:middle
是游戏玩家抽象

00:31:49.910 --> 00:31:53.180 align:middle
AI用它来区分不同玩家的行动

00:31:56.316 --> 00:31:59.720 align:middle
现在来说说AI
它属于GKMinMaxStrategist类

00:32:00.120 --> 00:32:01.955 align:middle
在GKGameModel上运作

00:32:02.155 --> 00:32:04.558 align:middle
在你创建
MinMaxStrategist示例后

00:32:04.625 --> 00:32:06.527 align:middle
你将把它连接到
gameModel属性中

00:32:07.995 --> 00:32:12.799 align:middle
当你从AI请求下一步时
maxLookAheadDepth就是能进行预测

00:32:13.734 --> 00:32:17.871 align:middle
正如我们前面提到的
较高的数字比较低的数字更有效

00:32:18.338 --> 00:32:19.806 align:middle
开始使用之前
这是你所需要做的

00:32:20.107 --> 00:32:23.744 align:middle
当你调用bestMoveForPlayer时
AI将创建它的决策图标

00:32:24.244 --> 00:32:28.549 align:middle
按照从优到劣的顺序列出所有适合的步
然后返回最优的步

00:32:29.249 --> 00:32:31.118 align:middle
这可能会出现在这些情况中

00:32:31.185 --> 00:32:33.153 align:middle
你有不止一个有利的步
需要由AI作出决定

00:32:33.587 --> 00:32:37.624 align:middle
以及这些情况中
你可以直接指挥AI随机打破连接

00:32:38.692 --> 00:32:41.662 align:middle
若你想调用randomMoveForPlayer
它就会出现

00:32:42.095 --> 00:32:44.031 align:middle
你有10个适合玩家的移动

00:32:44.765 --> 00:32:48.335 align:middle
但你只想从3个最佳移动中
随机挑选出一个

00:32:48.669 --> 00:32:52.573 align:middle
它将按照你的要求操作
从3个最佳中随机挑选出一个

00:32:53.140 --> 00:32:54.875 align:middle
而选出的这个可能是次优的

00:32:54.942 --> 00:32:58.145 align:middle
如果你想要让AI看起来
更人性化 会犯错误

00:32:58.212 --> 00:32:59.646 align:middle
这或许就是最令人满意的结果了

00:33:01.215 --> 00:33:03.984 align:middle
bestMoveForPlayer
和randomMoveForPlayer

00:33:04.051 --> 00:33:05.319 align:middle
都返回GKGameModelUpdate

00:33:05.385 --> 00:33:09.823 align:middle
你可以将GKGameModelUpdate
应用到GKGameModel以创建一个移动

00:33:11.725 --> 00:33:13.193 align:middle
这是个简单的代码样本

00:33:13.594 --> 00:33:15.796 align:middle
我正在创建象棋游戏模型

00:33:16.129 --> 00:33:17.397 align:middle
不幸的是

00:33:17.764 --> 00:33:21.702 align:middle
审查你将如何执行游戏模型细节
不在这个会话范围里

00:33:21.768 --> 00:33:23.670 align:middle
但我们有很棒的样本代码

00:33:23.971 --> 00:33:26.573 align:middle
你可以用来展示将如何做这些事

00:33:27.241 --> 00:33:28.442 align:middle
我们创建象棋模型

00:33:28.842 --> 00:33:31.912 align:middle
然后创建MinMax AI

00:33:32.112 --> 00:33:35.382 align:middle
通过在gameModel属性上
设置游戏模型将它联系起来

00:33:36.450 --> 00:33:38.452 align:middle
我们为
LookAheadDepth选择6

00:33:38.752 --> 00:33:41.488 align:middle
当你创建决策图标时
你将提前看到6个转弯

00:33:42.222 --> 00:33:43.123 align:middle
这就是我们所需做的

00:33:43.657 --> 00:33:46.560 align:middle
我们调用当前活跃玩家的
bestMoveForPlayer

00:33:46.660 --> 00:33:50.130 align:middle
它将利用所给信息
为玩家找出最优移动

00:33:50.797 --> 00:33:53.367 align:middle
你可以在游戏中应用那个移动
用它来创建移动

00:33:56.036 --> 00:33:57.137 align:middle
我们来看一个简单的演示

00:34:12.652 --> 00:34:15.856 align:middle
有一个只有两个玩家的简单游戏
黑色和白色

00:34:15.922 --> 00:34:19.860 align:middle
它们在棋盘上尽可能的收集
和它们同颜色的块

00:34:20.494 --> 00:34:26.199 align:middle
当它们在棋盘上放置块时

00:34:26.300 --> 00:34:28.936 align:middle
它们将反转两块之间的属于对手的块
使之变成属于己方颜色

00:34:30.304 --> 00:34:33.407 align:middle
我们有两个AI控制的玩家

00:34:33.706 --> 00:34:35.943 align:middle
黑色玩家可提前预测5个移动

00:34:36.009 --> 00:34:38.579 align:middle
而白色玩家
只能提前预测3个移动

00:34:38.946 --> 00:34:43.583 align:middle
在游戏过程中使得黑色玩家
可以很容易的打败白色玩家

00:34:44.650 --> 00:34:47.855 align:middle
这里你可以看到
有双方玩家的分数

00:34:47.955 --> 00:34:49.156 align:middle
这个很简单

00:34:49.422 --> 00:34:53.627 align:middle
我们来看一下玩家在棋盘上拥有的块
减去对手在棋盘上的块

00:34:54.061 --> 00:34:58.565 align:middle
再通权重码进行调整
就得到分数了

00:34:59.066 --> 00:35:01.301 align:middle
这里你可以看到
黑色玩家很容易就打败了白色玩家

00:34:59.066 --> 00:35:01.301 align:middle
这里你可以看到
黑色玩家很容易就打败了白色玩家

00:35:01.668 --> 00:35:06.073 align:middle
我们来详细看下分数

00:35:07.007 --> 00:35:08.108 align:middle
看这里

00:35:09.376 --> 00:35:11.879 align:middle
在中间的块
他们的权重是1

00:35:12.112 --> 00:35:14.414 align:middle
棋盘边缘位置
权重略高

00:35:14.481 --> 00:35:16.216 align:middle
在角落的权重就更高了

00:35:16.483 --> 00:35:19.052 align:middle
因为对于玩家来说
这些位置更有利

00:35:19.286 --> 00:35:24.658 align:middle
我们通过改变这些位置如何影响分数
来指挥AI选择这些地方

00:35:26.660 --> 00:35:29.196 align:middle
我来互换一下这些人的预测

00:35:29.263 --> 00:35:31.632 align:middle
白色将会预测4步
取代先前的预测3步

00:35:32.332 --> 00:35:38.138 align:middle
尽管只是小变动
这也会让AI更有效率

00:35:38.205 --> 00:35:40.507 align:middle
事实上
游戏中白色AI略占上风

00:35:41.108 --> 00:35:44.745 align:middle
但是黑色AI将牺牲短期利益
换取长期胜利

00:35:45.112 --> 00:35:47.314 align:middle
这样最后就可以战胜白色

00:35:53.620 --> 00:35:54.821 align:middle
以上就是MinMax AI

00:36:03.197 --> 00:36:05.098 align:middle
现在让我们来讨论随机源

00:36:06.133 --> 00:36:07.935 align:middle
起初这个话题可能看起来不必要

00:36:08.001 --> 00:36:10.771 align:middle
因为我们已经有了随机函数
为什么我们不能仅仅使用它就好呢

00:36:11.572 --> 00:36:12.973 align:middle
好的 随机函数给我们随机序号

00:36:13.040 --> 00:36:15.209 align:middle
但是游戏有独特的随机序号需求

00:36:15.275 --> 00:36:18.178 align:middle
随机函数可能无法给我们想要的一切

00:36:19.279 --> 00:36:22.716 align:middle
首先每个系统中由随机函数生成的序号
可能是不相同的

00:36:22.783 --> 00:36:26.320 align:middle
不能保证不同的计算机平台产生的
结果是相同的

00:36:27.154 --> 00:36:28.956 align:middle
这对网络游戏来说
会是一个大问题

00:36:29.022 --> 00:36:33.560 align:middle
因为我们不能依靠任何一方
以相同顺序生成的数据集合

00:36:33.627 --> 00:36:35.028 align:middle
否则为了使两方是数据同步

00:36:35.295 --> 00:36:36.463 align:middle
我们不得不浪费关键带宽

00:36:37.231 --> 00:36:39.166 align:middle
因此我们需要平台独立性和确定性

00:36:40.200 --> 00:36:43.170 align:middle
无论我们什么调用随机函数
都取自单一来源

00:36:43.704 --> 00:36:46.473 align:middle
如果我对AI代码中的随机函数
有一串请求

00:36:46.840 --> 00:36:48.842 align:middle
然后我在我的物理代码中添加一项请求

00:36:49.209 --> 00:36:54.281 align:middle
物理代码中的这个请求就会影响
在我的AI代码中生成的数字

00:36:54.448 --> 00:36:55.616 align:middle
这可能会导致意外行为

00:36:55.916 --> 00:36:58.485 align:middle
我们真正想做的事情是
可以把这两个系统分开

00:36:58.819 --> 00:37:03.657 align:middle
这样两个系统分别生成的数字
就不会互相影响

00:36:58.819 --> 00:37:03.657 align:middle
这样两个系统分别生成的数字
就不会互相影响

00:37:04.424 --> 00:37:08.295 align:middle
我们不仅想要控制生成的数字范围

00:37:08.529 --> 00:37:11.131 align:middle
而且还要控制这些数字
在该范围内是如何分布的

00:37:11.331 --> 00:37:12.766 align:middle
这就是随机源的由来

00:37:14.401 --> 00:37:17.504 align:middle
我们为你提供一系列
具有确定性的游戏优质随机源

00:37:17.938 --> 00:37:20.874 align:middle
因此当你有同样的种子时
你就可以获取相同顺序号

00:37:20.941 --> 00:37:22.009 align:middle
无论你在什么平台上

00:37:22.576 --> 00:37:25.179 align:middle
它们是可序列化的
因此它们可以为你保存游戏数据

00:37:25.412 --> 00:37:27.314 align:middle
这对阻止欺骗程序是非常实用的

00:37:28.448 --> 00:37:30.450 align:middle
人们用行业标准算法执行

00:37:30.517 --> 00:37:34.221 align:middle
众所周知这些行业标准算法
具有可靠性和卓越的随机性

00:37:35.255 --> 00:37:38.058 align:middle
此外我们为你提供一套随机分布杠杆

00:37:38.492 --> 00:37:43.497 align:middle
这使你可以在给定的范围内
控制序号的分布

00:37:43.864 --> 00:37:47.134 align:middle
我们有一个真随机
它的每个值都有同等的发生可能

00:37:47.601 --> 00:37:53.307 align:middle
高斯通过平均值
分布中它的值以钟形曲线分布

00:37:53.807 --> 00:37:56.577 align:middle
而非边缘值以及反聚类
或恰当的随机分布

00:37:56.810 --> 00:37:58.512 align:middle
这样有助于消除运行的数据

00:37:59.146 --> 00:38:01.014 align:middle
最后我们有NSArray排列

00:37:59.146 --> 00:38:01.014 align:middle
最后我们有NSArray排列

00:38:01.348 --> 00:38:04.184 align:middle
对洗牌这类事情是超级实用的

00:38:05.285 --> 00:38:06.153 align:middle
让我们来看看类

00:38:06.753 --> 00:38:09.556 align:middle
GKRandomSource
是随机源的基础类

00:38:09.823 --> 00:38:13.360 align:middle
采用NSSecureCoding
和NSCopying以便被安全地序列化

00:38:15.095 --> 00:38:17.631 align:middle
同样的种子保证了确定性

00:38:17.798 --> 00:38:18.932 align:middle
无论你在哪个平台上

00:38:18.999 --> 00:38:22.302 align:middle
因此如果你想要同样的顺序号
你可以依靠它生成

00:38:23.036 --> 00:38:27.274 align:middle
如果没有种子
可以从安全的系统源获取一个

00:38:28.108 --> 00:38:30.143 align:middle
我们继续说说共享随机

00:38:30.210 --> 00:38:32.546 align:middle
它是系统隐含的
共享随机源

00:38:32.913 --> 00:38:36.183 align:middle
它不具有确定性
但是很多例子说明它值得拥有

00:38:36.483 --> 00:38:40.554 align:middle
例如你在洗牌的时候
你希望每个结果都是唯一的

00:38:42.322 --> 00:38:45.392 align:middle
让我们看看
我们为你提供的AI随机源运算法

00:38:45.692 --> 00:38:46.560 align:middle
我们有ARC4

00:38:46.960 --> 00:38:51.398 align:middle
它低消耗并具有卓越的随机性
并且它即将成为你的Goldielocks随机源

00:38:51.798 --> 00:38:55.169 align:middle
我们有线性
意味它比ARC4更低消耗

00:38:55.435 --> 00:39:00.274 align:middle
但它的随机性并不那么好
你可能会更频繁地看见重复的顺序号

00:38:55.435 --> 00:39:00.274 align:middle
但它的随机性并不那么好
你可能会更频繁地看见重复的顺序号

00:39:00.774 --> 00:39:04.211 align:middle
最后我们有马特赛特旋转演算法
高质量但占用大量内存

00:39:04.845 --> 00:39:06.580 align:middle
可以发现没有一个适合密码系统

00:39:06.647 --> 00:39:09.583 align:middle
但Apple提供其它单独的
API来满足这些需求

00:39:11.919 --> 00:39:13.320 align:middle
现在我们开始讨论随机分布

00:39:13.387 --> 00:39:17.891 align:middle
在基础类中GKRandomDistribution
执行一个纯粹的随机分布

00:39:18.192 --> 00:39:23.163 align:middle
意味着每个在最低值和最高值之间的值
都有同等的发生可能性

00:39:23.897 --> 00:39:25.866 align:middle
你可以通过操纵nextInt

00:39:26.200 --> 00:39:28.068 align:middle
nextUniform
及rextBool来获取数值

00:39:29.102 --> 00:39:34.675 align:middle
我们也提供一套骰子默认构造函数
用于创建6面 20面和自定义骰子

00:39:37.544 --> 00:39:39.279 align:middle
然后我们有
GKGaussianDistribution

00:39:39.346 --> 00:39:42.950 align:middle
来执行钟形曲线高斯分布

00:39:44.218 --> 00:39:49.590 align:middle
这些值偏向于均值
而距离均值较远的值是不太可能发生

00:39:49.656 --> 00:39:51.525 align:middle
这就是在样板分布里所发生的一切情况

00:39:52.226 --> 00:39:55.662 align:middle
我们已经生成了一个由1到5之间
数字组成的15位顺序号

00:39:55.896 --> 00:39:59.933 align:middle
我们可以看到均值3发生的可能性
远远大于其他任意数

00:40:01.602 --> 00:40:04.304 align:middle
事实上和其它任何数字一样
它发生两次以上

00:40:04.371 --> 00:40:06.039 align:middle
边缘数1和5

00:40:06.306 --> 00:40:07.641 align:middle
每个只发生一次

00:40:08.375 --> 00:40:11.378 align:middle
可以发现在一个
标准高斯分布中它是无限的

00:40:11.745 --> 00:40:13.680 align:middle
但它不被随机源需要

00:40:13.847 --> 00:40:18.085 align:middle
因此我们操纵每个均值
三个标准差之外的每个值

00:40:20.687 --> 00:40:21.688 align:middle
接下来我们看看

00:40:21.788 --> 00:40:25.826 align:middle
在GKShuffledDistribution类中
执行反聚类分布

00:40:26.260 --> 00:40:31.265 align:middle
这是随机分布
有助于减少或消除运行的数字

00:40:31.498 --> 00:40:32.633 align:middle
但它随着时间是随机的

00:40:33.267 --> 00:40:35.636 align:middle
你运用
uniformDistance来控制这些

00:40:36.103 --> 00:40:40.007 align:middle
在0.0
所有数字都有同等的发生概率

00:40:40.274 --> 00:40:44.778 align:middle
这是无法从一个随机分布中
真随机源中区分的

00:40:45.646 --> 00:40:47.281 align:middle
在1.0
所有值都是不同的

00:40:47.347 --> 00:40:50.884 align:middle
在你开始看到任何重复值之前
它会遍及范围内的每个值

00:40:51.952 --> 00:40:53.954 align:middle
这就是在我们的分布中的情况

00:40:54.021 --> 00:40:56.757 align:middle
再重复一下 我们生成了
由1-5之间的数字组成的15为数值

00:40:57.124 --> 00:41:02.296 align:middle
在我们开始发现任何重复值之前
我们会命中每一个数值

00:40:57.124 --> 00:41:02.296 align:middle
在我们开始发现任何重复值之前
我们会命中每一个数值

00:41:03.330 --> 00:41:06.500 align:middle
实际上每个数值都生成了三次

00:41:09.069 --> 00:41:10.470 align:middle
让我们来看一个简单的代码例子

00:41:11.905 --> 00:41:14.708 align:middle
我们可以很容易地创建一个
6面骰子随机源

00:41:14.775 --> 00:41:18.245 align:middle
你仅需运用默认构建函数
GKRandomDistribution然后摇动骰子

00:41:18.712 --> 00:41:22.449 align:middle
如同调用nextInt一样简单

00:41:24.418 --> 00:41:26.587 align:middle
类似的
创建一个20面骰子也很容易

00:41:30.290 --> 00:41:33.393 align:middle
创建自定义骰子也同样简单

00:41:33.493 --> 00:41:35.095 align:middle
我们正创建一个256面骰子

00:41:35.162 --> 00:41:37.664 align:middle
如果你试着在现实世界中掷这样的骰子
情况将完全不一样

00:41:39.900 --> 00:41:44.238 align:middle
前面的三个例子
都运用真随机分布执行

00:41:44.304 --> 00:41:46.573 align:middle
但你可以使用我们提供给你的任何分布

00:41:46.974 --> 00:41:49.877 align:middle
我们正使用高斯分布

00:41:50.110 --> 00:41:52.246 align:middle
创建了一个20面骰子
因此它的均值大约是11

00:41:52.613 --> 00:41:55.115 align:middle
因此当你转骰子的时候
你最有可能得到一个约值

00:41:57.251 --> 00:42:01.588 align:middle
在这里我们创建一个20面骰子
使用洗牌分布

00:41:57.251 --> 00:42:01.588 align:middle
在这里我们创建一个20面骰子
使用洗牌分布

00:42:02.689 --> 00:42:07.995 align:middle
在默认情况下
统一的洗牌分布距离是1.0

00:42:08.228 --> 00:42:09.363 align:middle
因此当我们转动的时候

00:42:09.696 --> 00:42:13.200 align:middle
在我们看见任何重复值之前
我们将击中范围内的每个值

00:42:13.400 --> 00:42:15.135 align:middle
我们第一次转的时候可能得到了5

00:42:15.569 --> 00:42:18.705 align:middle
然后我们知道下一次我们转动它的时候
我们一定不会再转到5

00:42:18.939 --> 00:42:21.575 align:middle
直到我们转出范围内的其他所有值

00:42:23.710 --> 00:42:26.413 align:middle
最后我们有数组洗牌

00:42:27.047 --> 00:42:30.484 align:middle
我们运用早前在GKRandomSource
提到过的共享随机源

00:42:30.551 --> 00:42:32.586 align:middle
它让我们获得系统隐含的随机源

00:42:32.953 --> 00:42:34.788 align:middle
它不具有确定性

00:42:35.222 --> 00:42:37.858 align:middle
但在这个情况下是有利的

00:42:38.192 --> 00:42:41.461 align:middle
我们希望每一个卡铲都是唯一的

00:42:42.296 --> 00:42:45.899 align:middle
你可以看到让随机源
成为你游戏的一部分是很容易的

00:42:46.333 --> 00:42:48.402 align:middle
仅仅是几行代码就可以实现

00:42:49.369 --> 00:42:50.437 align:middle
这就是随机源

00:42:51.705 --> 00:42:54.908 align:middle
现在我想邀请桥什·伯格斯
和我们谈谈规则系统

00:43:01.615 --> 00:43:02.482 align:middle
谢谢 罗斯

00:43:07.054 --> 00:43:08.121 align:middle
你们好 我是桥什

00:43:08.755 --> 00:43:13.961 align:middle
我一直和布鲁诺和诺斯并肩工作
进行GameplayKit收尾工作

00:43:15.863 --> 00:43:18.398 align:middle
我在这里讲讲这些系统中的
一个规则系统

00:43:19.666 --> 00:43:23.871 align:middle
在我开始降解规则系统之前
我想要说说游戏总有的一些常见要素

00:43:24.938 --> 00:43:26.707 align:middle
游戏往往由三个元素组成

00:43:27.641 --> 00:43:32.713 align:middle
这像是名词之类的东西
位置 速度 生命值

00:43:33.413 --> 00:43:34.448 align:middle
已经穿上身的装备

00:43:36.049 --> 00:43:38.018 align:middle
第二是类似动词的东西

00:43:38.819 --> 00:43:42.923 align:middle
这些玩家可执行的动作
例如跑 跳

00:43:43.757 --> 00:43:47.127 align:middle
使用一件物品
或者如果你在一辆车上 加速

00:43:48.662 --> 00:43:50.564 align:middle
最后是规则

00:43:51.632 --> 00:43:55.736 align:middle
规则是极其重要的
因为要界定名词和动词是如何相互作用

00:43:57.171 --> 00:44:00.641 align:middle
规则给你的游戏添加了质感
绝好的游戏有绝好的规则

00:43:57.171 --> 00:44:00.641 align:middle
规则给你的游戏添加了质感
绝好的游戏有绝好的规则

00:44:02.276 --> 00:44:03.510 align:middle
让我们来看一个例子规则

00:44:07.047 --> 00:44:08.048 align:middle
在这里我们有一项规则

00:44:08.215 --> 00:44:11.685 align:middle
司机可以用来决定什么时候刹车
什么时候加速

00:44:13.353 --> 00:44:14.988 align:middle
运用距离的输入属性

00:44:15.689 --> 00:44:17.558 align:middle
玩家要么将减速 要么将加速

00:44:18.926 --> 00:44:20.160 align:middle
在这个例子中我们可以看到

00:44:20.394 --> 00:44:22.896 align:middle
如果距离小于5 他们将刹车

00:44:23.096 --> 00:44:24.665 align:middle
当大于或等于的时候 他们将加速

00:44:26.667 --> 00:44:29.102 align:middle
这个逻辑很不错
但这里有一个不易察觉的问题

00:44:30.037 --> 00:44:33.774 align:middle
在距离为5左右
我们的动作非常不稳定

00:44:34.174 --> 00:44:38.779 align:middle
因为汽车将在刹车
和加速之间不断徘徊

00:44:41.215 --> 00:44:42.983 align:middle
这将使我们的动作非常不稳定

00:44:43.317 --> 00:44:46.653 align:middle
因此想要更多自然的动作
我们需要一些更加真实的东西

00:44:50.757 --> 00:44:52.292 align:middle
运用一个更加模糊的解决方法

00:44:53.327 --> 00:44:58.232 align:middle
我们输出的情况而不是立即执行动作

00:44:58.765 --> 00:45:01.268 align:middle
我们在这里输出了两种情况 近和远

00:44:58.765 --> 00:45:01.268 align:middle
我们在这里输出了两种情况 近和远

00:45:01.635 --> 00:45:02.703 align:middle
两者都是基于距离的

00:45:03.570 --> 00:45:05.539 align:middle
重要的事情是

00:45:07.374 --> 00:45:09.676 align:middle
现在你既可以是远也可以是近

00:45:10.210 --> 00:45:11.745 align:middle
与其执行一个或另外一个

00:45:12.212 --> 00:45:14.982 align:middle
这让我们把两者融合在一起
获得更加自然的动作

00:45:15.716 --> 00:45:20.454 align:middle
这对之前的例子尤为重要
现在当距离在5左右

00:45:21.054 --> 00:45:23.924 align:middle
我们可以更加自然地加速

00:45:28.529 --> 00:45:30.063 align:middle
这就是规则系统的动机作用

00:45:30.931 --> 00:45:32.432 align:middle
事实是可以划分等级的

00:45:32.633 --> 00:45:35.469 align:middle
这允许我们用模糊的逻辑
执行更加复杂的演算

00:45:37.437 --> 00:45:39.206 align:middle
模糊逻辑处理近似值

00:45:41.608 --> 00:45:44.444 align:middle
它也允许我们把
我们做什么和我们如何做分开

00:45:45.479 --> 00:45:47.014 align:middle
而不是马上执行动作

00:45:47.080 --> 00:45:51.585 align:middle
我们只是说明关于世界的情况
然后基于这些情况采取推迟操作

00:45:52.853 --> 00:45:54.254 align:middle
让我们来看看这些类的其中之一

00:45:56.557 --> 00:45:57.691 align:middle
这里我们有GKRule

00:45:59.126 --> 00:46:02.129 align:middle
GKRule包含
一个布尔预测和一个动作

00:45:59.126 --> 00:46:02.129 align:middle
GKRule包含
一个布尔预测和一个动作

00:46:03.830 --> 00:46:09.770 align:middle
预测与事实和系统状态相匹配
如果预测为真 将触发动作

00:46:10.871 --> 00:46:15.442 align:middle
动作则如断言事实那样简单
也可以如复杂块一样复杂

00:46:17.211 --> 00:46:19.413 align:middle
重要的是现在可以运用

00:46:21.081 --> 00:46:23.750 align:middle
NSPredicate序列化方法
进行序列化

00:46:28.288 --> 00:46:31.925 align:middle
重要的事情是记住
规则系统提供近似值答案

00:46:32.626 --> 00:46:34.761 align:middle
回答类似前面的车有多远这样的问题

00:46:35.762 --> 00:46:37.297 align:middle
在第一个例子中

00:46:37.764 --> 00:46:40.534 align:middle
我们可以相当自信认为
我们还很远

00:46:41.368 --> 00:46:43.403 align:middle
在其他两个例子中
事情有点模糊

00:46:44.071 --> 00:46:47.541 align:middle
我们在做出答案后
真实情况是介于两者之间的

00:46:50.110 --> 00:46:52.679 align:middle
让我们来看看管理这些规则的系统

00:46:56.083 --> 00:46:58.252 align:middle
这里我们有其它类
GKRuleSystem

00:46:59.786 --> 00:47:02.356 align:middle
它是规则和事实的有序集合

00:46:59.786 --> 00:47:02.356 align:middle
它是规则和事实的有序集合

00:47:03.924 --> 00:47:07.594 align:middle
如要陈述世界事实
只需要进行调用即可

00:47:08.462 --> 00:47:09.897 align:middle
这将在序列中运行规则

00:47:10.464 --> 00:47:14.134 align:middle
这些规则将使用一个状态字典作为输入

00:47:14.468 --> 00:47:16.770 align:middle
然后基于此插入事实

00:47:17.804 --> 00:47:19.640 align:middle
事实将输入到事实序列

00:47:20.807 --> 00:47:23.310 align:middle
重要的是要了解陈述事实后

00:47:24.311 --> 00:47:27.514 align:middle
评价将返回到开端
然后继续评价

00:47:28.582 --> 00:47:30.350 align:middle
这是因为当你明确一个事实的时候

00:47:30.717 --> 00:47:32.352 align:middle
它可能会影响其它规则的运行

00:47:34.788 --> 00:47:39.927 align:middle
这可以确保当评价结束的时候
你可以有最简明和精确的游戏视图

00:47:41.662 --> 00:47:42.696 align:middle
如要重新开始

00:47:42.763 --> 00:47:45.632 align:middle
比如在一个更新循环末尾或计时器上

00:47:46.033 --> 00:47:46.934 align:middle
只需调用重置

00:47:47.434 --> 00:47:50.704 align:middle
这样你就可以重复评价

00:47:54.241 --> 00:47:55.409 align:middle
让我们看一个代码例子

00:47:56.910 --> 00:47:59.546 align:middle
在开始的时候
我们初始化规则系统

00:48:00.347 --> 00:48:04.451 align:middle
然后我们获取状态
并明确基于此的两个事实

00:48:06.653 --> 00:48:09.423 align:middle
稍后在游戏代码中

00:48:09.823 --> 00:48:13.160 align:middle
我们抓取这两种等级并求出两者之和

00:48:13.660 --> 00:48:15.929 align:middle
来获取关于我们可以加速多少
的模糊近似值

00:48:16.430 --> 00:48:17.664 align:middle
然后填入游戏代码中

00:48:22.135 --> 00:48:24.071 align:middle
看看我们正在做的一个小例子

00:48:43.557 --> 00:48:46.627 align:middle
我们在高速公路上开车

00:48:48.061 --> 00:48:51.865 align:middle
汽车在十字路口使用一套规则
而在高速公路上使用一套不同的规则

00:48:53.166 --> 00:48:56.803 align:middle
高速公路上使用的规则是基于
与前方车辆的距离

00:48:56.870 --> 00:48:58.872 align:middle
决定它们要加速多少或减速多少

00:48:59.973 --> 00:49:01.375 align:middle
它们明确世界的两个事实

00:48:59.973 --> 00:49:01.375 align:middle
它们明确世界的两个事实

00:49:01.975 --> 00:49:04.611 align:middle
分别是距离和相对速度

00:49:05.979 --> 00:49:10.150 align:middle
车辆在十字路口使用另一套规则
明确谁有通行权的事实

00:49:13.120 --> 00:49:15.422 align:middle
现在综合在一起的话

00:49:16.223 --> 00:49:20.561 align:middle
我们获得非常复杂的仿真世界

00:49:21.728 --> 00:49:23.263 align:middle
这就是规则系统的力量

00:49:37.778 --> 00:49:40.147 align:middle
所以在我运用规则系统
作一些最佳实践之前

00:49:40.914 --> 00:49:43.550 align:middle
很重要的是请记住
GKRuleSystem是孤立的

00:49:44.284 --> 00:49:46.787 align:middle
你必须使用状态字典
作为游戏世界的快照

00:49:48.322 --> 00:49:52.392 align:middle
你同样必须要运用许多简单规则
并明确许多关于游戏世界的事实

00:49:52.693 --> 00:49:54.561 align:middle
作为对抗大型复杂规则以及少数事实

00:49:56.463 --> 00:49:58.532 align:middle
同样重要的是
请注意事实是一些近似值

00:49:58.599 --> 00:50:00.701 align:middle
如何使用它们取决于你

00:49:58.599 --> 00:50:00.701 align:middle
如何使用它们取决于你

00:50:01.635 --> 00:50:03.504 align:middle
事实的等级是系统的置信度

00:50:04.004 --> 00:50:07.908 align:middle
这允许我们使用模糊逻辑
来完成更复杂的推理

00:50:11.411 --> 00:50:14.147 align:middle
那样 我想把这交回给我的同事布鲁诺

00:50:20.487 --> 00:50:21.321 align:middle
谢谢 乔什

00:50:24.057 --> 00:50:25.425 align:middle
这就是GameplayKit

00:50:25.826 --> 00:50:28.629 align:middle
今天我们讲了
GameplayKit里的七个主要系统

00:50:29.162 --> 00:50:32.232 align:middle
实体和组件是构建
游戏逻辑的好方法

00:50:33.066 --> 00:50:37.471 align:middle
状态机处理游戏中的状态性
及我们的目标经历的各种各样状态变化

00:50:39.139 --> 00:50:44.077 align:middle
主体即自主移动的实体
由真实行为和目标控制

00:50:45.379 --> 00:50:49.383 align:middle
路径搜索 处理导航图的生成
以及找到我们游戏世界中的路径

00:50:50.751 --> 00:50:52.719 align:middle
我们也讨论了MinMax AI解决方法

00:50:53.020 --> 00:50:55.255 align:middle
它让计算机控制的对手
表现出生命力

00:50:56.256 --> 00:51:01.061 align:middle
同样可以提供给你许多
随机源和分布

00:50:56.256 --> 00:51:01.061 align:middle
同样可以提供给你许多
随机源和分布

00:51:01.862 --> 00:51:06.834 align:middle
最后我们讨论了规则系统
是用于描述谨慎和模糊逻辑的绝好方法

00:51:08.302 --> 00:51:10.370 align:middle
我们很期待发布GameplayKit

00:51:10.437 --> 00:51:12.406 align:middle
我们迫不及待地想看到你们会如何使用

00:51:15.943 --> 00:51:17.444 align:middle
一些很好的代码例子本周发布了

00:51:17.511 --> 00:51:20.247 align:middle
如果你想了解更多东西
你一定要看看

00:51:20.714 --> 00:51:24.818 align:middle
Demobot是一个SpriteKit游戏
涵盖了GameplayKit各种API

00:51:25.152 --> 00:51:28.055 align:middle
FourInARow是
实操MinMax AI的绝佳示例

00:51:28.255 --> 00:51:32.025 align:middle
AgentsCatalog表现
主体行为和目标的好例子

00:51:32.226 --> 00:51:34.228 align:middle
因此如果你想学习
一定要看看

00:51:36.630 --> 00:51:40.100 align:middle
同样还有一些环节
如果你想要了解更多相关技术

00:51:40.167 --> 00:51:43.604 align:middle
例如SpriteKit ReplayKit
Game Center SceneKit

00:51:44.104 --> 00:51:46.173 align:middle
今天午饭之后
有一个DemoBots的深入研究

00:51:46.240 --> 00:51:47.508 align:middle
就是我说到的那个例子

00:51:47.708 --> 00:51:50.844 align:middle
如果你想了解更多关于
GameplayKit或SpriteKit的资料

00:51:51.111 --> 00:51:51.945 align:middle
就一定要来看看

00:51:53.947 --> 00:51:56.884 align:middle
我们有实验室
欢迎来游戏控制器实验室

00:51:57.184 --> 00:51:59.686 align:middle
今天午饭之后同样
有个关于GameplayKit实验

00:51:59.753 --> 00:52:03.924 align:middle
大家可以来会面成员 发问
讨论任何关于代码的问题

00:51:59.753 --> 00:52:03.924 align:middle
大家可以来会面成员 发问
讨论任何关于代码的问题

00:52:05.926 --> 00:52:09.162 align:middle
如果你需要更多信息
请登录伟大的开发者网站

00:52:09.897 --> 00:52:13.834 align:middle
有任何一般询问
联系我们的游戏技术专员艾伦·沙菲尔

00:52:15.569 --> 00:52:17.871 align:middle
谢谢
会议中间请休息片刻
