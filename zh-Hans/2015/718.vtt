WEBVTT

00:00:20.120 --> 00:00:24.825 align:middle
用GCD构建具有响应性的高效app

00:00:27.528 --> 00:00:28.362 align:middle
早上好

00:00:30.898 --> 00:00:33.834 align:middle
欢迎来到本次讲座 题目为
用GCD构建具有响应性的高效app

00:00:34.301 --> 00:00:37.504 align:middle
我们非常高兴看到这么多的人有兴趣

00:00:37.571 --> 00:00:40.541 align:middle
学习如何利用
多线程优化技术来帮助你们的

00:00:40.874 --> 00:00:43.443 align:middle
应用程序适应我们所有的平台

00:00:43.577 --> 00:00:47.548 align:middle
我是Anthony我将和我的队友
Daniel一起呈现这段演讲

00:00:48.315 --> 00:00:50.851 align:middle
多线程优化技术或者叫GCD是
与OS X Snow

00:00:50.918 --> 00:00:53.587 align:middle
Leopard
操作系统一起引入的一种技术

00:00:54.021 --> 00:00:56.523 align:middle
当时我们的最新版的Mac

00:00:56.590 --> 00:00:59.459 align:middle
还是使用Core II
Duo的MacBook Pro

00:00:59.593 --> 00:01:02.596 align:middle
当时GCD的卖点之一是

00:00:59.593 --> 00:01:02.596 align:middle
当时GCD的卖点之一是

00:01:02.663 --> 00:01:05.065 align:middle
它让你可以使用双核

00:01:05.132 --> 00:01:07.534 align:middle
同时运行应用程序的不同部分

00:01:07.601 --> 00:01:10.070 align:middle
并使线程变得非常非常容易

00:01:10.370 --> 00:01:13.841 align:middle
我们认为GCD的使用真的
经受住了时间的考验

00:01:14.708 --> 00:01:19.046 align:middle
今天我们最先进
的Mac Pro有多得多的内核

00:01:19.613 --> 00:01:22.382 align:middle
而GCD仍然是利用这些所有计算资源

00:01:22.449 --> 00:01:23.617 align:middle
的好方法

00:01:24.585 --> 00:01:27.988 align:middle
但正如GCD有助于利用所有高端

00:01:28.055 --> 00:01:30.891 align:middle
资源一样 它还可以帮助你的应用程序

00:01:30.991 --> 00:01:32.593 align:middle
适应较小的环境

00:01:34.494 --> 00:01:37.598 align:middle
比如最近发布的新MacBook是

00:01:37.664 --> 00:01:39.099 align:middle
第一个无窗格的设计

00:01:39.333 --> 00:01:42.769 align:middle
虽然就机型体积而言

00:01:44.304 --> 00:01:47.274 align:middle
这是一个优势 但如何管理热性能而言

00:01:47.341 --> 00:01:49.476 align:middle
它也带来一些独特的挑战

00:01:49.943 --> 00:01:53.113 align:middle
稍后我会谈到
你们的app如何利用GCD

00:01:53.180 --> 00:01:55.148 align:middle
从而在这种环境下更有效地运行

00:01:56.817 --> 00:01:59.520 align:middle
我们iOS 9也有了 新多任务功能

00:01:59.953 --> 00:02:02.923 align:middle
这是第一次你们的
应用程序必须肩并肩地

00:01:59.953 --> 00:02:02.923 align:middle
这是第一次你们的
应用程序必须肩并肩地

00:02:02.990 --> 00:02:06.827 align:middle
这种说法毫不夸张与其他
应用程序一起在系统中运行

00:02:06.894 --> 00:02:09.930 align:middle
GCD可以告诉系统你正在做什么

00:02:09.997 --> 00:02:12.599 align:middle
并能够更好地在你的应用程序和其他

00:02:12.666 --> 00:02:15.035 align:middle
出现在屏幕上应用程序之间分配资源

00:02:16.837 --> 00:02:21.642 align:middle
有了Watch OS系统
即便我们最小的平台都能识别你的代码

00:02:22.643 --> 00:02:26.280 align:middle
GCD可以帮助
系统知道你应该运行哪些部分

00:02:26.346 --> 00:02:28.849 align:middle
的代码才能让你在这么大的设备上

00:02:28.916 --> 00:02:34.154 align:middle
构建起具有响应性能的应用程序

00:02:39.359 --> 00:02:41.361 align:middle
所以我要先简要概述
我们今天将要讨论的内容

00:02:42.029 --> 00:02:45.199 align:middle
我首先会介绍所谓的服务质量类别

00:02:45.632 --> 00:02:49.503 align:middle
我们与iOS 8和OS X
Yosemite发布的一款API

00:02:50.838 --> 00:02:53.207 align:middle
Daniel来讲解它针对GCD使用

00:02:53.273 --> 00:02:54.641 align:middle
一些设计模式以及

00:02:54.708 --> 00:02:56.577 align:middle
如何整合QLS与这些模式

00:02:57.678 --> 00:03:00.280 align:middle
然后我会详细讲解线程 队列

00:02:57.678 --> 00:03:00.280 align:middle
然后我会详细讲解线程 队列

00:03:00.347 --> 00:03:03.217 align:middle
并运行可以使GCD更便于使用的循环

00:03:03.717 --> 00:03:06.620 align:middle
最后我们会就如何理解使用GCD时

00:03:06.687 --> 00:03:09.089 align:middle
的崩溃报告得出一个简短的结论

00:03:12.192 --> 00:03:13.827 align:middle
但首先需要一点背景

00:03:14.661 --> 00:03:16.964 align:middle
你们构建起非常棒的app

00:03:17.030 --> 00:03:20.200 align:middle
然后开始执行这款app
用户触碰它的图标

00:03:20.267 --> 00:03:21.835 align:middle
从finder中进行下载

00:03:22.102 --> 00:03:24.304 align:middle
我们将开始执行主函数中的代码

00:03:24.571 --> 00:03:26.306 align:middle
那么你们将得到每个app用以开始的

00:03:26.373 --> 00:03:27.708 align:middle
最初的主线程

00:03:28.342 --> 00:03:32.212 align:middle
你们调用应用程序UI函数
或者NS应用程序函数

00:03:32.279 --> 00:03:34.281 align:middle
接着会弹出一个线程上的运行循环

00:03:34.348 --> 00:03:35.816 align:middle
和框架代码

00:03:37.284 --> 00:03:39.887 align:middle
然后线程会停在那里等待事件

00:03:40.320 --> 00:03:41.889 align:middle
在某一时刻会有事件发生

00:03:42.389 --> 00:03:44.124 align:middle
也许你会得到一个调出的委派模式

00:03:44.191 --> 00:03:45.993 align:middle
到你的应用程序委托UI

00:03:46.660 --> 00:03:48.362 align:middle
这时你的代码开始运行

00:03:48.428 --> 00:03:51.198 align:middle
需要完成某项任务
比方说从数据库读取信息

00:03:52.132 --> 00:03:54.535 align:middle
你发出指令访问磁盘上的该文件

00:03:55.669 --> 00:03:57.070 align:middle
就会返回相应数据

00:03:58.372 --> 00:03:59.973 align:middle
你会更新用户界面

00:04:02.776 --> 00:04:05.612 align:middle
最后返回控制到框架

00:04:05.679 --> 00:04:07.514 align:middle
并继续等待线程上的事件

00:04:08.348 --> 00:04:10.117 align:middle
这些进展都很顺利 只是

00:04:10.184 --> 00:04:12.186 align:middle
从数据库读取信息需要一点儿时间

00:04:13.754 --> 00:04:18.791 align:middle
在OS X系统
此时你可能会看到一个旋转的等待光标

00:04:18.858 --> 00:04:21.661 align:middle
iOS系统里
app会暂停甚至被终止运行

00:04:22.429 --> 00:04:25.799 align:middle
这种用户体验不仅糟糕而且未得到响应

00:04:28.068 --> 00:04:30.037 align:middle
出现这种情况GCD就可以参与进来

00:04:30.103 --> 00:04:31.972 align:middle
帮助提高运行效率

00:04:32.039 --> 00:04:33.774 align:middle
你会得到调出的委派模式

00:04:33.841 --> 00:04:38.478 align:middle
但是不要立即开始进行操作
而要创建一个GCD队列

00:04:39.947 --> 00:04:42.583 align:middle
使用异步分派把任务移动到尾接

00:04:43.650 --> 00:04:47.387 align:middle
你的代码与主线程异步执行

00:04:48.989 --> 00:04:50.190 align:middle
等你们得到了数据

00:04:50.257 --> 00:04:53.861 align:middle
就可以异步分派回主线程更新用户界面

00:04:54.795 --> 00:04:58.498 align:middle
这样做的优势在于
当你的任务在GCD队列运行时

00:04:59.233 --> 00:05:01.368 align:middle
主线程可以继续等待事件

00:04:59.233 --> 00:05:01.368 align:middle
主线程可以继续等待事件

00:05:01.435 --> 00:05:02.503 align:middle
它始终保持响应状态

00:05:02.569 --> 00:05:04.605 align:middle
用户可以获得持续的良好体验

00:05:05.339 --> 00:05:06.573 align:middle
大家都感到满意

00:05:08.308 --> 00:05:09.376 align:middle
我希望这是一个

00:05:09.443 --> 00:05:10.711 align:middle
大家都熟悉的模式

00:05:10.777 --> 00:05:12.212 align:middle
我们不会详细谈论

00:05:12.279 --> 00:05:13.514 align:middle
如何做到这一点

00:05:14.014 --> 00:05:16.517 align:middle
如果你们不熟悉
我强烈建议各位在今天的

00:05:16.583 --> 00:05:19.853 align:middle
演讲之后去一趟去普西迪
听一听那里的讲话

00:05:19.920 --> 00:05:21.922 align:middle
里面将详细讲述这种模式

00:05:23.757 --> 00:05:25.792 align:middle
有一点你们之前可能没有想过

00:05:25.859 --> 00:05:29.263 align:middle
我们现在有两个线程两个都要执行代码

00:05:29.329 --> 00:05:31.265 align:middle
主线程要处理新事件

00:05:31.331 --> 00:05:32.466 align:middle
GCD队列要

00:05:32.533 --> 00:05:34.568 align:middle
执行你派遣的任务

00:05:35.235 --> 00:05:37.371 align:middle
也许这两个任务都在一个核心设备上

00:05:38.038 --> 00:05:40.374 align:middle
在这种情况下我们要执行哪个线程呢

00:05:45.145 --> 00:05:47.881 align:middle
这里服务质量类别
就要发挥作用了

00:05:49.049 --> 00:05:53.086 align:middle
这是一个在iOS 8和10
Yosemite系统中的新的API

00:05:53.153 --> 00:05:54.555 align:middle
于去年发布

00:05:55.455 --> 00:05:58.959 align:middle
我们有四个服务质量类别：
用户交互模式

00:05:59.026 --> 00:06:01.628 align:middle
用户发起模式效用和背景

00:05:59.026 --> 00:06:01.628 align:middle
用户发起模式效用和背景

00:06:02.796 --> 00:06:05.766 align:middle
通过这些方法你可以
告诉系统你们正在进行哪种任务

00:06:06.433 --> 00:06:10.404 align:middle
它也使系统能够提供各种资源控制

00:06:10.704 --> 00:06:12.706 align:middle
以最有效地执行你的代码

00:06:14.341 --> 00:06:16.376 align:middle
说到资源控制什么是资源控制

00:06:16.944 --> 00:06:20.214 align:middle
我们的系统支持CPU调度优先级

00:06:20.414 --> 00:06:22.382 align:middle
我们要运行哪些线程以什么顺序运行

00:06:23.217 --> 00:06:26.086 align:middle
说到I / O优先级
当系统中有多个I / O时

00:06:26.153 --> 00:06:27.321 align:middle
应该以什么顺序执行呢

00:06:28.088 --> 00:06:30.657 align:middle
计时器聚合技术是一个省电的功能

00:06:31.325 --> 00:06:33.760 align:middle
无论我们按照吞吐量还是以效率

00:06:33.827 --> 00:06:35.429 align:middle
导向模式运行CPU

00:06:35.495 --> 00:06:37.364 align:middle
我们想要获得最佳的性能还是想要

00:06:37.431 --> 00:06:39.867 align:middle
以最节能的方式执行的代码

00:06:41.268 --> 00:06:45.305 align:middle
在理想情况下为每个平台或设备优化

00:06:45.372 --> 00:06:48.308 align:middle
这些配置值或设备运行的代码

00:06:49.243 --> 00:06:51.178 align:middle
但显然这种做法很快会难以为继

00:06:51.445 --> 00:06:54.448 align:middle
许多配置值很难调整 而代码

00:06:54.515 --> 00:06:56.283 align:middle
运行的平台数量众多

00:06:58.185 --> 00:07:00.254 align:middle
服务质量类别被设计成

00:06:58.185 --> 00:07:00.254 align:middle
服务质量类别被设计成

00:07:00.320 --> 00:07:03.156 align:middle
一个抽象参数你们可以使用

00:07:03.223 --> 00:07:06.727 align:middle
这个参数描述任务的目的和类别

00:07:07.194 --> 00:07:08.495 align:middle
不要试图调整所有

00:07:08.562 --> 00:07:11.665 align:middle
具体的配置值
你们要明白自己所做的都

00:07:11.732 --> 00:07:13.433 align:middle
“由将要执行工作的用户启动”

00:07:13.667 --> 00:07:15.602 align:middle
而系统将自动为平台和设备

00:07:15.669 --> 00:07:17.571 align:middle
选择正确的配置值

00:07:20.641 --> 00:07:22.776 align:middle
我前面提到过我们有四个服务质量类别

00:07:23.043 --> 00:07:25.479 align:middle
接下来我要对它们进行简要介绍
它们分别有什么用途

00:07:26.079 --> 00:07:27.548 align:middle
第一个是用户交互模式

00:07:28.081 --> 00:07:29.583 align:middle
这是主线程

00:07:30.250 --> 00:07:33.353 align:middle
假设有一个iOS应用程序用户的手指

00:07:33.420 --> 00:07:34.688 align:middle
正在屏幕上拖动

00:07:35.088 --> 00:07:37.891 align:middle
主线程需要响应以便在

00:07:37.958 --> 00:07:39.693 align:middle
用户手指拖动时交付

00:07:39.760 --> 00:07:40.727 align:middle
下一帧动画

00:07:41.695 --> 00:07:45.799 align:middle
主要用户交互代码是保持动画

00:07:45.866 --> 00:07:49.236 align:middle
以每秒60帧的
速度平稳运行的专门代码

00:07:52.206 --> 00:07:55.342 align:middle
所以你们需要问自己
这项工作是否积极参与

00:07:55.409 --> 00:07:56.376 align:middle
到更新UI之中

00:07:56.443 --> 00:07:59.179 align:middle
在决定是否需要进行用户交互式设计时
这一点一定要加以考虑

00:08:00.113 --> 00:08:04.384 align:middle
这不是在加载可能成为滚动视图的内容

00:08:04.985 --> 00:08:07.921 align:middle
这就是在画新的动画

00:08:08.589 --> 00:08:11.792 align:middle
我们所说的用户发起模式
是指加载由用户

00:08:11.859 --> 00:08:13.861 align:middle
完成的动作结果

00:08:14.328 --> 00:08:15.662 align:middle
比如当我翻动滚动视图

00:08:15.729 --> 00:08:18.532 align:middle
为下一个单元加载数据时

00:08:19.166 --> 00:08:23.270 align:middle
或我在使用照片或邮件
应用程序并点击电子邮件或照片

00:08:23.604 --> 00:08:26.173 align:middle
加载全尺寸照片或电子邮件时

00:08:26.673 --> 00:08:29.243 align:middle
这些行为就是我们
所说的用户发起的动作

00:08:30.744 --> 00:08:33.145 align:middle
问题是要继续进行用户交互

00:08:33.212 --> 00:08:34.715 align:middle
是否需要这项工作

00:08:35.414 --> 00:08:36.717 align:middle
对其中任何一个都没有帮助

00:08:36.783 --> 00:08:38.852 align:middle
作为用户发起而不是用户拦截

00:08:39.385 --> 00:08:41.755 align:middle
如果用户不能通过你们的应用程序继续

00:08:41.822 --> 00:08:44.591 align:middle
取得有意义的进展
就应该选择用户发起模式

00:08:46.226 --> 00:08:49.329 align:middle
效用是指用户本来可能已经开始进行

00:08:49.596 --> 00:08:51.098 align:middle
或已经自动启动任务

00:08:51.164 --> 00:08:54.101 align:middle
这些任务长时间运行但是并不阻碍用户

00:08:54.168 --> 00:08:55.702 align:middle
继续使用你们的应用程序

00:08:57.171 --> 00:08:59.072 align:middle
你们要问问自己用户是否了解

00:08:59.139 --> 00:09:00.407 align:middle
这项工作的进展

00:08:59.139 --> 00:09:00.407 align:middle
这项工作的进展

00:09:00.841 --> 00:09:03.911 align:middle
如果一个杂志app正在下载新刊物

00:09:04.344 --> 00:09:07.881 align:middle
那么用户可以继续使这个app
下载任务可以同时进行彼此互不干扰

00:09:07.948 --> 00:09:10.517 align:middle
他们可以阅读往期刊物或随意浏览

00:09:10.584 --> 00:09:12.152 align:middle
你们可以设计一个进度条

00:09:12.419 --> 00:09:13.987 align:middle
帮助用户了解进展情况

00:09:14.521 --> 00:09:16.757 align:middle
效用是一个很好的类别

00:09:18.892 --> 00:09:21.395 align:middle
最后其余的一切都可以归为背景

00:09:21.528 --> 00:09:23.163 align:middle
用户不会主动关注的一切

00:09:23.230 --> 00:09:25.432 align:middle
任何类型的维护任务 清理工作

00:09:26.767 --> 00:09:29.770 align:middle
数据库清空都属于背景

00:09:31.638 --> 00:09:32.739 align:middle
根本问题是

00:09:32.806 --> 00:09:34.408 align:middle
用户有没有意识到这项工作

00:09:35.309 --> 00:09:37.177 align:middle
背景工作很有趣 因为你要

00:09:37.244 --> 00:09:38.645 align:middle
考虑何时处理背景

00:09:39.379 --> 00:09:41.281 align:middle
我强烈建议你们去看一看

00:09:42.282 --> 00:09:44.651 align:middle
去年关于编写节能代码的那部分演讲

00:09:44.718 --> 00:09:47.421 align:middle
该演讲讨论了如何有效地做好背景工作

00:09:47.521 --> 00:09:49.556 align:middle
如何判断你们
的应用程序背景是否表现出色

00:09:56.663 --> 00:09:58.165 align:middle
所以我提到了我们的新MacBook

00:09:59.299 --> 00:10:01.768 align:middle
就像我说的这是第一款无风扇的Mac

00:09:59.299 --> 00:10:01.768 align:middle
就像我说的这是第一款无风扇的Mac

00:10:02.336 --> 00:10:05.205 align:middle
在之前有风扇的Macbook里

00:10:05.672 --> 00:10:08.842 align:middle
机器处理的工作越来越多 产生的热量

00:10:08.909 --> 00:10:11.712 align:middle
也越来越多 那么我们可以加快

00:10:11.778 --> 00:10:14.781 align:middle
风扇转速来帮助热量更快消散

00:10:15.682 --> 00:10:18.185 align:middle
新版MacBook非常节能令人惊讶

00:10:18.252 --> 00:10:22.456 align:middle
我们不需要风扇散热在大多数情况下

00:10:23.423 --> 00:10:26.827 align:middle
但全速运转该机器仍然会

00:10:26.894 --> 00:10:29.329 align:middle
产生一些热量我们需要驱散

00:10:30.264 --> 00:10:32.432 align:middle
但是我们驱散热量的能力是有限的

00:10:33.367 --> 00:10:37.738 align:middle
我们有其他技术确保我们能让

00:10:37.804 --> 00:10:40.007 align:middle
机器保持适当的温度适合使用者使用

00:10:40.841 --> 00:10:44.144 align:middle
假设你有一款正在使用的app
然后你已经完成工作

00:10:44.211 --> 00:10:46.013 align:middle
按服务类的四项质量指标而言

00:10:46.847 --> 00:10:50.117 align:middle
你正很努力的开动机器用了很多的能量

00:10:50.184 --> 00:10:52.853 align:middle
而我们需要帮忙控制控制热量的多少

00:10:52.920 --> 00:10:55.189 align:middle
这样能让机器在合理的温度中工作

00:10:56.423 --> 00:10:58.926 align:middle
好了我们能做的是我们能
开始挤出我们的工作量

00:10:58.992 --> 00:11:00.394 align:middle
我们将要做的是

00:10:58.992 --> 00:11:00.394 align:middle
我们将要做的是

00:11:00.460 --> 00:11:02.663 align:middle
比较不重要的服务质量标准

00:11:03.397 --> 00:11:06.600 align:middle
这就允许我们管理
这个系统能量的使用

00:11:07.901 --> 00:11:10.337 align:middle
保持机器
响应及时确保了

00:11:10.404 --> 00:11:13.841 align:middle
没有无反应情况 让使用者看到

00:11:14.675 --> 00:11:16.043 align:middle
这个方式很重要

00:11:16.109 --> 00:11:17.811 align:middle
因为你让你的工作正确分类了

00:11:17.878 --> 00:11:19.646 align:middle
在运行一个像这样的机器时

00:11:22.015 --> 00:11:24.852 align:middle
我还提到iOS
以及新的多元任务的特点

00:11:25.552 --> 00:11:28.355 align:middle
你可以想象在古老的
世界里我们可能会有你的app

00:11:28.422 --> 00:11:31.758 align:middle
的主要思路而且可能
它还有另外的分派线程

00:11:31.825 --> 00:11:35.162 align:middle
在使用但是现在
我提出了另外一款app

00:11:38.198 --> 00:11:40.067 align:middle
那款app也将会有一个主要思路

00:11:41.235 --> 00:11:43.570 align:middle
然后我也有Picture in
Picture

00:11:43.637 --> 00:11:45.205 align:middle
那款也有一个思路解码视频

00:11:46.039 --> 00:11:48.976 align:middle
好了但是我也只是拥有两个CPUs

00:11:49.910 --> 00:11:52.346 align:middle
所以如果我不得不使用其中之一
来解码视频

00:11:52.412 --> 00:11:54.181 align:middle
对于下一个我该做些什么呢

00:11:54.281 --> 00:11:55.616 align:middle
这是另外一个领域对于质量

00:11:55.682 --> 00:11:57.351 align:middle
服务标准来说能真正帮你解决问题

00:11:57.851 --> 00:12:01.655 align:middle
表明了操作系统的服务质量标准的

00:11:57.851 --> 00:12:01.655 align:middle
表明了操作系统的服务质量标准的

00:12:01.722 --> 00:12:03.957 align:middle
每一个线程我们都可以准确决定

00:12:04.024 --> 00:12:06.226 align:middle
在哪里安排那些可用的资源

00:12:07.928 --> 00:12:10.130 align:middle
通过那些我会转交东西给Daniel

00:12:10.197 --> 00:12:14.301 align:middle
他会检查特定的设计模式
以及对那些类型如何应用服务质量标准

00:12:21.275 --> 00:12:22.943 align:middle
早上好 谢谢 Anthony

00:12:23.010 --> 00:12:24.945 align:middle
本章我们会看几个

00:12:25.012 --> 00:12:29.616 align:middle
关于GCD设计和QOS是如何应用的
具体的例子

00:12:30.617 --> 00:12:34.154 align:middle
首先我们从最基本的开始 先看GCD

00:12:34.221 --> 00:12:38.325 align:middle
和QoS 在每个独立模块的层次上

00:12:38.392 --> 00:12:41.862 align:middle
是怎样被细分的
例如QoS 从提交线程到

00:12:42.462 --> 00:12:44.364 align:middle
异步运行模块

00:12:44.431 --> 00:12:47.668 align:middle
有一个整体功能模块

00:12:47.734 --> 00:12:49.036 align:middle
和一个异步分派模块

00:12:49.102 --> 00:12:50.838 align:middle
以及相关的自动传播QoS模块

00:12:51.505 --> 00:12:54.575 align:middle
那么这个系统是怎样为你

00:12:54.641 --> 00:12:56.143 align:middle
自动切换一些优先级别的呢？

00:12:56.210 --> 00:13:00.247 align:middle
没有时间深入地讨论具体的API命令

00:12:56.210 --> 00:13:00.247 align:middle
没有时间深入地讨论具体的API命令

00:13:00.781 --> 00:13:05.452 align:middle
如果你想了解更多的细节 我建议你

00:13:05.519 --> 00:13:07.454 align:middle
看看去年的演讲内容
"功率 性能

00:13:07.521 --> 00:13:09.389 align:middle
和诊断: GCD和XPC的新内容"

00:13:09.456 --> 00:13:13.293 align:middle
那么你就能在开发者的网站看到

00:13:13.360 --> 00:13:17.231 align:middle
我们在如何使用API的
问题上已经讲了很多具体内容

00:13:17.297 --> 00:13:18.665 align:middle
这是去年的新课程

00:13:20.334 --> 00:13:23.136 align:middle
第一个例子是
Anthony很早就有了的

00:13:23.203 --> 00:13:26.139 align:middle
在主线程的提示下执行了一些异步工作

00:13:26.206 --> 00:13:31.211 align:middle
在GCD上做了些I/O

00:13:32.546 --> 00:13:37.251 align:middle
这个例子怎样适应于QoS？

00:13:37.317 --> 00:13:38.986 align:middle
什么是可以被应用在这里的

00:13:39.052 --> 00:13:40.587 align:middle
适当质量的服务等级呢？

00:13:41.088 --> 00:13:44.525 align:middle
当然在左手边我们有主线程

00:13:44.591 --> 00:13:47.461 align:middle
Anthony说过是UI呈现的地方

00:13:47.528 --> 00:13:48.862 align:middle
这里是事件处理的地方

00:13:49.396 --> 00:13:51.865 align:middle
合适的调用服务命令是用户互动命令

00:13:52.566 --> 00:13:54.101 align:middle
这些都是无条件获得的

00:13:54.201 --> 00:13:57.571 align:middle
应用程序的主线程就在这种质量
的服务等级下服务等级下出现

00:13:58.872 --> 00:14:00.474 align:middle
在屏幕右手边

00:13:58.872 --> 00:14:00.474 align:middle
在屏幕右手边

00:14:00.541 --> 00:14:03.243 align:middle
是没有出现在主线程的异步工作

00:14:03.777 --> 00:14:07.014 align:middle
很明显我们不应该启动用户互动

00:14:07.147 --> 00:14:09.049 align:middle
这里我们不是在做UI呈现

00:14:09.183 --> 00:14:12.419 align:middle
而是在说正盯住文件图标

00:14:12.486 --> 00:14:16.723 align:middle
正在等待他的文件打开的用户

00:14:16.924 --> 00:14:18.792 align:middle
用户已经在使用此app前就被绊住了

00:14:18.892 --> 00:14:21.795 align:middle
他仍然能和用户界面互相影响
但是并不能做所有他想做的事情

00:14:21.862 --> 00:14:24.631 align:middle
比如编辑文件或者查看文件

00:14:24.798 --> 00:14:27.901 align:middle
用户初始化是服务的最佳质量

00:14:30.270 --> 00:14:33.173 align:middle
如何通过GCDAPI达到这个目标

00:14:34.141 --> 00:14:37.644 align:middle
其实你不需要做任何事情

00:14:37.978 --> 00:14:39.546 align:middle
它就会自动实现

00:14:39.613 --> 00:14:41.582 align:middle
但重要的是理解为什么会这样

00:14:41.648 --> 00:14:43.050 align:middle
让我们详细来看一下

00:14:44.785 --> 00:14:47.387 align:middle
所有程序都起源于初步调动async

00:14:47.454 --> 00:14:50.357 align:middle
它能从主线程消除异步工作

00:14:50.757 --> 00:14:53.594 align:middle
正如我在前一个幻灯片里讲的那样

00:14:53.660 --> 00:14:55.963 align:middle
async异步分派会从你提交块执行

00:14:56.029 --> 00:14:59.566 align:middle
服务线程队列

00:14:59.633 --> 00:15:02.736 align:middle
自动传播服务质量

00:14:59.633 --> 00:15:02.736 align:middle
自动传播服务质量

00:15:04.838 --> 00:15:07.174 align:middle
在这个例子中有一个特殊的规则适用于

00:15:07.241 --> 00:15:12.713 align:middle
我们自动转译的
用户交互用户发起的服务质量

00:15:13.280 --> 00:15:15.883 align:middle
这样做我们就避免了过度传播

00:15:15.949 --> 00:15:18.151 align:middle
应该受到限制的服务质量

00:15:18.218 --> 00:15:20.153 align:middle
到主要的线程和呈现的用户界面

00:15:20.654 --> 00:15:22.356 align:middle
我们可以好好利用此法

00:15:22.422 --> 00:15:24.258 align:middle
因为这正是我们想要的

00:15:24.358 --> 00:15:26.360 align:middle
通常情况下

00:15:26.527 --> 00:15:30.030 align:middle
在用户发起的服务质量队列上

00:15:30.464 --> 00:15:33.967 align:middle
都是通过自动传播来运行

00:15:34.735 --> 00:15:38.472 align:middle
当你用自动传播也试着进行的结果

00:15:38.539 --> 00:15:40.607 align:middle
回到主线程去更新

00:15:40.674 --> 00:15:42.009 align:middle
用户界面

00:15:42.075 --> 00:15:47.281 align:middle
因为用户主线程是服务用户交互的质量

00:15:47.581 --> 00:15:48.649 align:middle
所优先考虑的

00:15:48.715 --> 00:15:51.451 align:middle
如果你去一个线程 它不会降低

00:15:51.518 --> 00:15:52.786 align:middle
那些主线程上指定的

00:15:52.853 --> 00:15:54.254 align:middle
服务质量

00:15:54.855 --> 00:15:56.890 align:middle
这里我们将忽略传播的价值

00:15:57.324 --> 00:16:01.328 align:middle
来在用户交互
服务质量底部运行用户界面修改块

00:15:57.324 --> 00:16:01.328 align:middle
来在用户交互
服务质量底部运行用户界面修改块

00:16:01.395 --> 00:16:02.863 align:middle
运行用户界面修改块

00:16:05.566 --> 00:16:09.369 align:middle
我们调用QoS传播属性推断QoS

00:16:09.503 --> 00:16:14.208 align:middle
这是块被提交
至一个队列时被捕获的QoS

00:16:14.274 --> 00:16:15.576 align:middle
和特殊规则

00:16:15.642 --> 00:16:17.211 align:middle
我们转译用户交互至用户初始化

00:16:17.311 --> 00:16:19.079 align:middle
正如上文提到的

00:16:20.414 --> 00:16:22.716 align:middle
如果目的地提交之处

00:16:22.783 --> 00:16:24.751 align:middle
没有自己的指定的服务质量

00:16:24.818 --> 00:16:27.154 align:middle
在分配自己的
高质量的服务主线程的情况下

00:16:28.288 --> 00:16:34.127 align:middle
也不降低QoS
就将用到这种传播的服务质量

00:16:37.097 --> 00:16:42.569 align:middle
下一个例子是不能自动开启任务的情况

00:16:42.636 --> 00:16:45.038 align:middle
长期运行的任务
比如说在一个异步调用的长期

00:16:45.105 --> 00:16:48.408 align:middle
的运算中 关闭主线程

00:16:48.475 --> 00:16:53.080 align:middle
用户界面就不能更新
它正在处理主线程的当前队列

00:16:53.146 --> 00:16:58.919 align:middle
可能会更新UI 通过一个异步

00:16:58.986 --> 00:17:00.454 align:middle
返回块的进程

00:16:58.986 --> 00:17:00.454 align:middle
返回块的进程

00:17:00.554 --> 00:17:02.589 align:middle
这个块包含了更新一些用户界面元素

00:17:05.826 --> 00:17:08.662 align:middle
那么什么才是合适的服务质量类呢？

00:17:08.729 --> 00:17:11.865 align:middle
在你左手边是用户互动

00:17:11.932 --> 00:17:14.902 align:middle
右手边是之前描述过的Anthony

00:17:14.968 --> 00:17:16.970 align:middle
这就是适合质量服务

00:17:17.037 --> 00:17:18.939 align:middle
程序运行的情景

00:17:19.339 --> 00:17:20.741 align:middle
它是长期运行的

00:17:20.807 --> 00:17:22.442 align:middle
用户可以继续使用用户界面

00:17:22.509 --> 00:17:24.310 align:middle
不用等待就会得到想要的画面

00:17:24.377 --> 00:17:27.981 align:middle
他也可以看一些进程 以某种方式发起

00:17:28.048 --> 00:17:31.685 align:middle
的进程
但是这并不会影响到之前的界面

00:17:34.421 --> 00:17:38.192 align:middle
我们怎么用GCD API实现它呢？

00:17:38.258 --> 00:17:40.394 align:middle
最简单的解决方法是关注

00:17:40.460 --> 00:17:42.529 align:middle
任务的产生和发起

00:17:43.063 --> 00:17:44.998 align:middle
这是异步调用的开始

00:17:45.599 --> 00:17:48.202 align:middle
我们以标记我们提交

00:17:48.669 --> 00:17:50.537 align:middle
的带有合适的质量服务类的块

00:17:50.604 --> 00:17:54.041 align:middle
通过调用块生成质量服务类的接口

00:17:54.441 --> 00:17:57.377 align:middle
我们传入想执行的块或者

00:17:57.477 --> 00:17:58.579 align:middle
我们想要的质量服务类

00:17:58.679 --> 00:18:00.714 align:middle
应用程序就有了

00:17:58.679 --> 00:18:00.714 align:middle
应用程序就有了

00:18:00.781 --> 00:18:02.616 align:middle
这就是生成的异步调用的

00:18:02.683 --> 00:18:06.753 align:middle
块对象 当它被执行的时候

00:18:06.820 --> 00:18:08.589 align:middle
会在质量服务类的应用程序里运行

00:18:09.223 --> 00:18:12.693 align:middle
通过查找最初

00:18:12.759 --> 00:18:14.995 align:middle
质量服务类变化的点

00:18:15.062 --> 00:18:17.998 align:middle
就会自动传递给下一步执行

00:18:18.065 --> 00:18:21.268 align:middle
如果那个块发生变化 就会利用

00:18:21.335 --> 00:18:22.870 align:middle
自动执行这个特性

00:18:22.936 --> 00:18:25.339 align:middle
因此产生的

00:18:25.405 --> 00:18:27.474 align:middle
任何异步线程将会自动运行

00:18:27.541 --> 00:18:29.676 align:middle
相对应的质量服务类

00:18:29.743 --> 00:18:32.613 align:middle
并继续作为应用程序
这期间你不需要做任何事

00:18:34.848 --> 00:18:39.419 align:middle
在前面的幻灯片上我们可以看到这个

00:18:39.486 --> 00:18:42.356 align:middle
质量服务块被创建
通过显示的给块对象添加质量

00:18:42.422 --> 00:18:45.726 align:middle
服务属性的方式来实现
你只需要提供合适的调用时间

00:18:45.792 --> 00:18:50.531 align:middle
当任务产生不同的类的时候

00:18:51.398 --> 00:18:54.334 align:middle
另一个质量服务应用在块对象中的案例

00:18:54.668 --> 00:18:58.639 align:middle
当你需要捕获你提供块的

00:18:58.705 --> 00:19:00.774 align:middle
质量服务类时

00:18:58.705 --> 00:19:00.774 align:middle
质量服务类时

00:19:00.841 --> 00:19:05.112 align:middle
就是说在一个回调块的方案中
你正在写一个接口

00:19:05.312 --> 00:19:07.981 align:middle
别人提供给你一个回调块 你想

00:19:08.048 --> 00:19:11.318 align:middle
在另一个队列或者线程中保存并提交它

00:19:11.385 --> 00:19:13.287 align:middle
但是你很想让它

00:19:13.353 --> 00:19:16.023 align:middle
像异步调用

00:19:16.089 --> 00:19:18.058 align:middle
质量服务程序那样被执行

00:19:18.125 --> 00:19:21.895 align:middle
你可以去分派现有指定模块

00:19:21.962 --> 00:19:24.064 align:middle
由创立分配模块标识并通过

00:19:24.131 --> 00:19:27.434 align:middle
它会捕捉到现有的QOS和执行状态

00:19:27.501 --> 00:19:30.504 align:middle
在提交模块后把它保存到快速模块中

00:19:30.571 --> 00:19:33.507 align:middle
它会按分配值在一个队列上运行

00:19:37.144 --> 00:19:40.280 align:middle
看看另外一个我们的应用程序案例

00:19:40.347 --> 00:19:41.982 align:middle
它执行了一个UI操作

00:19:42.049 --> 00:19:42.983 align:middle
在操作测试性能时

00:19:43.050 --> 00:19:45.285 align:middle
它通告显示处于维护状态中

00:19:45.352 --> 00:19:47.254 align:middle
并即将执行清除状态

00:19:47.321 --> 00:19:49.489 align:middle
还说里面有一个数据库
有太多的松散区

00:19:49.556 --> 00:19:53.560 align:middle
不得不进行一些压缩程序和清除任务

00:19:53.927 --> 00:19:59.099 align:middle
还有一个GCD应用的典型例子

00:20:01.235 --> 00:20:04.037 align:middle
在执行异步分配运行的地方

00:20:04.104 --> 00:20:07.641 align:middle
后台列队上的维护任务

00:20:07.708 --> 00:20:09.676 align:middle
当然是在左手边的

00:20:10.077 --> 00:20:13.714 align:middle
作为用户会重新启动用户界面

00:20:14.081 --> 00:20:16.850 align:middle
在这里相应的服务质量等级

00:20:17.150 --> 00:20:19.086 align:middle
将用于服务背景质量上

00:20:19.820 --> 00:20:22.189 align:middle
目前鉴于幻灯片的标题

00:20:22.322 --> 00:20:23.724 align:middle
这只是一个维护操作

00:20:23.790 --> 00:20:25.392 align:middle
与用户做了些什么不相关系

00:20:25.459 --> 00:20:27.995 align:middle
你通告出此时你正在进行的状态

00:20:28.595 --> 00:20:31.298 align:middle
用户此时并未察觉发生了什么

00:20:31.431 --> 00:20:33.967 align:middle
你要做的工作是关于APP的工作

00:20:34.034 --> 00:20:35.435 align:middle
基于此处自已利益上的工作

00:20:36.637 --> 00:20:39.540 align:middle
我们怎样才能取得服务后台的运行质量

00:20:39.940 --> 00:20:43.343 align:middle
我们能做的一件事
就是早点看到API模块的应用

00:20:43.410 --> 00:20:47.748 align:middle
让初始异步此队列成为

00:20:47.848 --> 00:20:49.316 align:middle
后台服务的质量

00:20:49.616 --> 00:20:52.186 align:middle
也许这件事在APP中是比较多样性的

00:20:52.252 --> 00:20:53.820 align:middle
以此而成清除工作的类型

00:20:53.887 --> 00:20:55.255 align:middle
同时你也有多样的方法

00:20:55.656 --> 00:20:58.992 align:middle
可以在这个模式下的数据库上进行操作

00:20:59.059 --> 00:21:02.329 align:middle
这要用一个适当并特别的队列

00:20:59.059 --> 00:21:02.329 align:middle
这要用一个适当并特别的队列

00:21:02.396 --> 00:21:05.165 align:middle
精确地完成此任务 你才可能创立起

00:21:05.232 --> 00:21:07.734 align:middle
有指定服务质量的队列

00:21:07.801 --> 00:21:10.771 align:middle
你可以用QOS等级分派队列属性

00:21:11.171 --> 00:21:13.674 align:middle
通过如范例中后台

00:21:13.740 --> 00:21:16.376 align:middle
所生成属性通过并分配到创立队列上

00:21:16.810 --> 00:21:19.546 align:middle
创立一个如范例中清除队列

00:21:20.547 --> 00:21:23.217 align:middle
通过服务等级质量被指定到队列上

00:21:23.617 --> 00:21:26.787 align:middle
得到了异步分派的自动传播

00:21:27.254 --> 00:21:31.859 align:middle
用户再次从主流程启动

00:21:31.992 --> 00:21:34.161 align:middle
我们实际上忽略了传播的价值

00:21:34.228 --> 00:21:36.763 align:middle
因为你正在提交
一个自身拥用指定服务等级质量的队列

00:21:36.830 --> 00:21:39.499 align:middle
并说可以用此队列来替代

00:21:40.000 --> 00:21:43.170 align:middle
所以你提交的模块将在后台运行

00:21:43.370 --> 00:21:44.638 align:middle
代替已经如果有的

00:21:44.705 --> 00:21:46.673 align:middle
自动系统

00:21:47.641 --> 00:21:50.210 align:middle
对于这样的情况

00:21:50.277 --> 00:21:55.015 align:middle
某处有一个与执行流程无关的维护任务

00:21:55.315 --> 00:21:59.953 align:middle
考虑调度程序块分离
的标记是否有用是合适的

00:22:00.420 --> 00:22:04.424 align:middle
这是一种告诉操纵系统

00:22:04.491 --> 00:22:06.193 align:middle
你正对这个程序块所做的事情

00:22:06.260 --> 00:22:08.028 align:middle
与执行流程无关的方式

00:22:08.095 --> 00:22:11.598 align:middle
而且它尤其不参与QoS的传播

00:22:11.665 --> 00:22:16.069 align:middle
也不捕捉事物 如活动ID

00:22:16.136 --> 00:22:20.741 align:middle
如果你正在去年我们会上介绍过的
活动追踪特性中使用它

00:22:22.142 --> 00:22:25.179 align:middle
和其它一些执行上下文的性质

00:22:27.714 --> 00:22:30.384 align:middle
当然即使你有工作

00:22:30.450 --> 00:22:32.619 align:middle
它总是应该在QoS背景里

00:22:32.686 --> 00:22:34.621 align:middle
那是些清理性的工作 是可例外的

00:22:34.688 --> 00:22:38.825 align:middle
如一些退出特性 用户退出他的账户

00:22:38.892 --> 00:22:41.995 align:middle
你应该删除数据库

00:22:42.062 --> 00:22:44.431 align:middle
及用户的私人数据

00:22:44.498 --> 00:22:47.134 align:middle
那是一些用户希望能看到它完成的事情

00:22:47.201 --> 00:22:48.902 align:middle
这不该是后台任务

00:22:49.069 --> 00:22:54.541 align:middle
你有必要在后台属性中重写

00:22:54.608 --> 00:22:56.944 align:middle
或退出你这里已经设置过的

00:22:57.010 --> 00:22:58.545 align:middle
这个队列或这个运行

00:22:58.979 --> 00:23:01.582 align:middle
如果这里你仅用自动传播特性

00:22:58.979 --> 00:23:01.582 align:middle
如果这里你仅用自动传播特性

00:23:01.648 --> 00:23:04.718 align:middle
像以前一样除了这里 我们应该忽略

00:23:04.785 --> 00:23:06.587 align:middle
用户初始的QoS

00:23:06.820 --> 00:23:09.590 align:middle
当然这是可用的合适的QoS

00:23:09.656 --> 00:23:10.824 align:middle
这是我们真正期望的

00:23:10.891 --> 00:23:12.926 align:middle
用户正在等待这个退出结束

00:23:13.327 --> 00:23:14.461 align:middle
如何达成呢？

00:23:14.528 --> 00:23:19.333 align:middle
利用调度程序块执行QoS分类标志

00:23:19.399 --> 00:23:22.102 align:middle
程序块创建和你想执行的程序块

00:23:22.169 --> 00:23:23.737 align:middle
那是在告诉系统

00:23:23.804 --> 00:23:26.773 align:middle
你真的希望程序块中的数值

00:23:26.840 --> 00:23:27.908 align:middle
与队列中的相反

00:23:27.975 --> 00:23:30.911 align:middle
这样你可以重写队列的数值显示

00:23:32.212 --> 00:23:36.917 align:middle
如果你这样做程序块将在本例中

00:23:36.984 --> 00:23:39.386 align:middle
用户初始的QoS分类中执行

00:23:41.088 --> 00:23:42.022 align:middle
但是 当然 在图中

00:23:42.089 --> 00:23:44.057 align:middle
你可以看到现在的情况：

00:23:44.124 --> 00:23:47.027 align:middle
你有个别潜在含两个程序块的队列

00:23:47.094 --> 00:23:49.830 align:middle
两程序块是同时的且有不同的优先级别

00:23:50.264 --> 00:23:53.467 align:middle
这就是异步优先级反转翻转

00:23:53.534 --> 00:23:56.136 align:middle
一个高级QoS程序块
可能被提交给一个串行队列

00:23:56.203 --> 00:23:58.539 align:middle
但是队列中已有工作

00:23:58.605 --> 00:24:00.207 align:middle
或在更低级的QoS中运行

00:23:58.605 --> 00:24:00.207 align:middle
或在更低级的QoS中运行

00:24:00.274 --> 00:24:01.975 align:middle
你有优先权翻转

00:24:03.177 --> 00:24:05.646 align:middle
GCD会帮助你如果你通过提升

00:24:05.712 --> 00:24:08.882 align:middle
串行队列中的工作来使用串行队列

00:24:08.949 --> 00:24:12.252 align:middle
运行或是入队
直到你达到高级别的QoS程序块

00:24:12.986 --> 00:24:17.224 align:middle
这是后台QoS覆盖出现问题

00:24:17.624 --> 00:24:23.163 align:middle
并非重写块调用自身的问题
或者如果将任务非同步传输下去

00:24:23.230 --> 00:24:28.268 align:middle
程序块将以原始QoS状态传输

00:24:28.468 --> 00:24:32.539 align:middle
但程序块将以更高优先级
执行从而消除块的反转执行

00:24:34.408 --> 00:24:38.612 align:middle
概括说QoS队列排序大多适合那些

00:24:38.679 --> 00:24:41.615 align:middle
在应用程序中排序是唯一用途的场景

00:24:41.682 --> 00:24:44.818 align:middle
或者输入的指令
不需要考虑登录优先级的重要性

00:24:44.885 --> 00:24:48.555 align:middle
而需要考虑的是指令用途的优先级

00:24:48.622 --> 00:24:50.824 align:middle
QoS队列排序还可用于

00:24:50.891 --> 00:24:54.895 align:middle
为这种类型的工作
负载所开发的独立的程序块API

00:24:54.962 --> 00:24:56.964 align:middle
当这种负载处于维护或后台模式时

00:24:59.333 --> 00:25:03.504 align:middle
在队列中使用QoS会使我们忽略

00:24:59.333 --> 00:25:03.504 align:middle
在队列中使用QoS会使我们忽略

00:25:03.570 --> 00:25:06.773 align:middle
异步block(块)中的QoS除非

00:25:06.840 --> 00:25:08.742 align:middle
我们在程序中使用强制执行标记

00:25:12.412 --> 00:25:16.483 align:middle
最后是利用串行队列
实现lock(锁)的功能

00:25:16.550 --> 00:25:18.886 align:middle
这在GCD当中是很常见的用法

00:25:18.952 --> 00:25:22.055 align:middle
在程序当中你有一些共享的数据结构

00:25:22.122 --> 00:25:25.125 align:middle
而你想要锁定对这些数据结构的访问

00:25:25.192 --> 00:25:29.930 align:middle
你可以通过
在数据结构中创建一个带有调用队列

00:25:30.030 --> 00:25:34.601 align:middle
标记的串行队列的方法来使用GCD

00:25:35.068 --> 00:25:39.339 align:middle
然后用同步调用来执行关键的区段块

00:25:39.406 --> 00:25:43.410 align:middle
在队列中只有这个block（块）
有访问数据结构的权限

00:25:46.079 --> 00:25:50.083 align:middle
QoS在这个过程中是如何运行的呢
注明”同步调用”函数很重要

00:25:50.150 --> 00:25:54.388 align:middle
当调用”同步调用”函数的线程

00:25:54.454 --> 00:25:57.624 align:middle
被锁定时执行块

00:25:57.691 --> 00:26:00.727 align:middle
返回block（块）的同时释放线程

00:25:57.691 --> 00:26:00.727 align:middle
返回block（块）的同时释放线程

00:26:01.228 --> 00:26:03.764 align:middle
这种情况下我们不需要任何额外的线程

00:26:03.830 --> 00:26:07.835 align:middle
我们只需要执行调用同步调用的线程

00:26:07.901 --> 00:26:10.971 align:middle
然后在所调用线程的QoS中执行块

00:26:11.038 --> 00:26:12.773 align:middle
此处指用户交互进程

00:26:13.440 --> 00:26:15.075 align:middle
当你可以使用同步

00:26:15.142 --> 00:26:16.243 align:middle
因为有其他的线程或队列

00:26:16.310 --> 00:26:18.378 align:middle
也在访问此数据结构

00:26:18.445 --> 00:26:22.382 align:middle
或许当执行一个QoS线程时
在队列内调用”同步调用”函数

00:26:22.449 --> 00:26:25.285 align:middle
从而可以独占访问

00:26:25.352 --> 00:26:26.553 align:middle
数据结构

00:26:26.620 --> 00:26:28.856 align:middle
如果随后返回线程 同样的事情将出现

00:26:28.922 --> 00:26:32.960 align:middle
他将停止等待线程以获取独占访问权限

00:26:33.026 --> 00:26:36.163 align:middle
然后在调用QoS的线程中

00:26:36.230 --> 00:26:37.397 align:middle
执行自身

00:26:37.464 --> 00:26:40.300 align:middle
QoS线程中的块

00:26:41.435 --> 00:26:47.374 align:middle
我们就又会碰到
如果这个独占访问以别的顺序获得

00:26:47.441 --> 00:26:50.377 align:middle
优先权翻转的问题

00:26:50.444 --> 00:26:52.880 align:middle
如果实用程序效用先进入锁死

00:26:52.946 --> 00:26:55.616 align:middle
主线程就必须等待效用线程

00:26:56.450 --> 00:26:58.719 align:middle
这当然是我们不期望的

00:26:59.086 --> 00:27:00.654 align:middle
所以QoS继承

00:26:59.086 --> 00:27:00.654 align:middle
所以QoS继承

00:27:01.188 --> 00:27:04.691 align:middle
异步优先级翻转会帮助你去解决

00:27:04.758 --> 00:27:08.328 align:middle
一个高级的优先级服务线程正在等待
较低级别的进程工作

00:27:08.395 --> 00:27:12.533 align:middle
我们可以通过为等待期间

00:27:13.166 --> 00:27:15.135 align:middle
提高等待工作的QoS来解决

00:27:15.202 --> 00:27:18.639 align:middle
如果你用串行队列和同步调用

00:27:18.705 --> 00:27:20.274 align:middle
或调用程序块等待API

00:27:20.908 --> 00:27:22.910 align:middle
如果你用多线程互斥锁

00:27:23.110 --> 00:27:26.413 align:middle
或任何建立在其上的API
如NSLock也可实现

00:27:28.015 --> 00:27:31.818 align:middle
值得注意的是
有些API在这里是不可用的

00:27:31.885 --> 00:27:35.255 align:middle
调度信号量不承认认同所有权概念

00:27:35.322 --> 00:27:37.157 align:middle
所以系统无法决定

00:27:37.224 --> 00:27:38.759 align:middle
谁最终将向信号量发信号

00:27:38.825 --> 00:27:42.829 align:middle
那种情况下
没有任何优先权翻转的解决方案

00:27:42.896 --> 00:27:44.631 align:middle
如果你有优先级翻转

00:27:44.698 --> 00:27:50.003 align:middle
你在某调度信号
等待中发现高级优先级等待者

00:27:50.070 --> 00:27:53.774 align:middle
低级别优先级工作者正在执行某些工作

00:27:53.841 --> 00:27:57.377 align:middle
你可能必须转变成调度程序块等待

00:27:57.444 --> 00:28:00.814 align:middle
在我们能够进行提升的外显实体处等待

00:27:57.444 --> 00:28:00.814 align:middle
在我们能够进行提升的外显实体处等待

00:28:01.915 --> 00:28:06.286 align:middle
下面请Anthony
讲一下队列线程和运行循环

00:28:12.826 --> 00:28:13.861 align:middle
谢谢 Daniel

00:28:14.695 --> 00:28:17.564 align:middle
希望这激起了你们对服务质量的兴趣

00:28:17.664 --> 00:28:19.967 align:middle
并愿回头看看这些应用

00:28:20.033 --> 00:28:22.035 align:middle
及思考一下如何应用服务质量

00:28:22.569 --> 00:28:26.974 align:middle
现在我们讲一下队列、线程及运行循环

00:28:27.975 --> 00:28:32.179 align:middle
希望能使GCD的
更广泛被应用变得更简单

00:28:32.246 --> 00:28:34.915 align:middle
并为你调试应用程序提供一些背景

00:28:36.917 --> 00:28:40.220 align:middle
提醒我们自己我们的应用程序与

00:28:40.287 --> 00:28:41.788 align:middle
我们的主线程相关

00:28:41.855 --> 00:28:44.057 align:middle
GCD线程池

00:28:44.124 --> 00:28:47.427 align:middle
服务于GCD队列中的所有程序块

00:28:47.694 --> 00:28:49.663 align:middle
在应用程序中也有某些队列

00:28:50.931 --> 00:28:54.034 align:middle
想象一下你在主线程上执行代码

00:28:54.101 --> 00:28:56.537 align:middle
你异步调度到某队列

00:28:58.872 --> 00:29:02.209 align:middle
一程序块
且我们会为此程序块启动一个线程

00:28:58.872 --> 00:29:02.209 align:middle
一程序块
且我们会为此程序块启动一个线程

00:29:02.910 --> 00:29:04.411 align:middle
开始执行你的代码

00:29:04.478 --> 00:29:07.681 align:middle
在Delay之后我们将同时
执行Object和Selector

00:29:08.382 --> 00:29:10.250 align:middle
且这将在当前线程的运行循环上

00:29:10.317 --> 00:29:11.752 align:middle
加入定时源

00:29:12.586 --> 00:29:14.855 align:middle
现在让我们想一下一秒后会发生什么？

00:29:16.657 --> 00:29:18.825 align:middle
结果是：当程序块完成时

00:29:18.892 --> 00:29:20.894 align:middle
线程可能会消失

00:29:20.961 --> 00:29:23.830 align:middle
这些是我们临时线程池里的线程

00:29:23.897 --> 00:29:25.999 align:middle
他们没有任何可确保的有效期

00:29:26.066 --> 00:29:27.668 align:middle
我们可能会破坏这个线程

00:29:28.335 --> 00:29:30.571 align:middle
当然即使线程保留了下来

00:29:31.038 --> 00:29:32.973 align:middle
也没人在实际地运行那个运行循环

00:29:33.307 --> 00:29:35.242 align:middle
那个计时器将永远不会被触发

00:29:36.043 --> 00:29:38.745 align:middle
这是一个有趣的互动

00:29:38.812 --> 00:29:43.550 align:middle
当你混合基于运行
循环与调度队列的API时发生的

00:29:45.819 --> 00:29:48.522 align:middle
简单的总结一下运行循环与

00:29:48.589 --> 00:29:52.559 align:middle
串行队列的区别：运行循环束缚于

00:29:52.626 --> 00:29:53.927 align:middle
某一特定线程

00:29:54.761 --> 00:29:58.031 align:middle
一般看到API通过委托方式被回调

00:29:59.199 --> 00:30:01.835 align:middle
他们拥有在整个运行循环源中的

00:29:59.199 --> 00:30:01.835 align:middle
他们拥有在整个运行循环源中的

00:30:01.902 --> 00:30:03.737 align:middle
每次迭代后出现的自动释放池

00:30:04.471 --> 00:30:06.640 align:middle
且运行循环可以被重新进入使用

00:30:06.707 --> 00:30:09.943 align:middle
通过调出运行循环
以使运行循环自旋也是可能的

00:30:10.944 --> 00:30:13.380 align:middle
另一方面串行队列

00:30:13.447 --> 00:30:16.149 align:middle
或调度队列可利用

00:30:16.950 --> 00:30:19.987 align:middle
来自Grand Central
Dispatch线程池的临时线程

00:30:20.053 --> 00:30:22.556 align:middle
它们一般将程序块作为它们的回调

00:30:22.990 --> 00:30:25.459 align:middle
或应用它们的API
一般将程序块作为它们的回调

00:30:26.660 --> 00:30:29.129 align:middle
仅在一线程完全空闲时

00:30:29.196 --> 00:30:30.964 align:middle
串行队列的自动释放池才会出现

00:30:31.732 --> 00:30:34.835 align:middle
如果你的应用在持续忙碌中
自动释放池将绝不会出现

00:30:35.602 --> 00:30:38.939 align:middle
所以当你用调度时 不依赖于

00:30:39.006 --> 00:30:40.807 align:middle
免费的自动释放池是很重要的

00:30:41.208 --> 00:30:43.243 align:middle
如果你要自动释放大量的项目

00:30:43.310 --> 00:30:45.412 align:middle
你需确保你的自动释放池是合适的

00:30:46.180 --> 00:30:50.117 align:middle
最后串行队列不是一个重入锁

00:30:50.684 --> 00:30:52.119 align:middle
或递归锁结构

00:30:53.053 --> 00:30:55.756 align:middle
你需要确保当你设计你应用的队列时

00:30:55.956 --> 00:30:57.157 align:middle
不要使自己陷入需重入地

00:30:57.224 --> 00:30:58.325 align:middle
使用它们的情况

00:30:59.326 --> 00:31:01.895 align:middle
这些规则被捆绑在一起 其意义在于

00:30:59.326 --> 00:31:01.895 align:middle
这些规则被捆绑在一起 其意义在于

00:31:01.962 --> 00:31:05.165 align:middle
主线程的运行循环也作为主队列被公开

00:31:05.632 --> 00:31:09.203 align:middle
相对于主线程
在这些领域间来回跳转

00:31:09.269 --> 00:31:10.604 align:middle
是非常容易的

00:31:12.439 --> 00:31:14.274 align:middle
所以如果你回到计时器那个例子

00:31:14.341 --> 00:31:16.210 align:middle
我们是有点在比较不同的API

00:31:16.310 --> 00:31:17.945 align:middle
说到运行循环 我们有

00:31:18.011 --> 00:31:21.215 align:middle
NSObjects—在Delay后
运行Selector和Object

00:31:21.281 --> 00:31:23.917 align:middle
或NSTimer—安排TimerW
ithTimeInterval

00:31:23.984 --> 00:31:26.420 align:middle
可在当前运行循环上安装计时器

00:31:26.753 --> 00:31:29.556 align:middle
在调度领域我们有
dispatchafter和

00:31:29.623 --> 00:31:32.860 align:middle
dispatch sources
用其设置计时器

00:31:32.926 --> 00:31:35.929 align:middle
这样就创建一个通过队列上加入程序块

00:31:35.996 --> 00:31:37.965 align:middle
就可激活的计时器

00:31:40.501 --> 00:31:44.972 align:middle
我提到过GDC利用临时线程

00:31:45.739 --> 00:31:48.041 align:middle
现在让我说明一下它是如何运作的

00:31:48.442 --> 00:31:51.879 align:middle
想象一下我正在做大量的异步调度

00:31:53.347 --> 00:31:55.749 align:middle
我将那些放入全局队列

00:31:57.918 --> 00:32:00.587 align:middle
系统正从线程池中取出一个线程

00:31:57.918 --> 00:32:00.587 align:middle
系统正从线程池中取出一个线程

00:32:00.654 --> 00:32:02.022 align:middle
并将它分配给第一个程序块

00:32:02.322 --> 00:32:03.624 align:middle
使其按自己的方式运行

00:32:04.091 --> 00:32:05.826 align:middle
取出另一个线程给第二个程序块

00:32:05.893 --> 00:32:07.361 align:middle
并使其按自己的方式运行

00:32:07.895 --> 00:32:09.563 align:middle
这样我们就有一个两核设备

00:32:09.997 --> 00:32:12.266 align:middle
这些线程在同时运行

00:32:12.366 --> 00:32:13.534 align:middle
我们先停在这里

00:32:13.600 --> 00:32:17.137 align:middle
理想情况下每核有一个线程

00:32:17.771 --> 00:32:20.274 align:middle
当第一个程序块结束执行时

00:32:20.340 --> 00:32:23.443 align:middle
我们将取出线程
分配给下一个以此类推

00:32:24.478 --> 00:32:25.879 align:middle
这样运作非常好

00:32:25.946 --> 00:32:29.716 align:middle
直到我们程序中的某个需要访问

00:32:29.783 --> 00:32:30.984 align:middle
现在还不可获得的资源

00:32:32.352 --> 00:32:33.687 align:middle
我们把这叫做等待

00:32:33.754 --> 00:32:37.024 align:middle
线程将等待并暂缓执行

00:32:37.090 --> 00:32:40.427 align:middle
当它需要像是I/O或锁定资源时

00:32:41.195 --> 00:32:43.664 align:middle
你或许听说过这个被称作阻塞

00:32:43.764 --> 00:32:45.098 align:middle
但今天我们叫它等待

00:32:45.165 --> 00:32:49.403 align:middle
所以在接下来的五分钟
如果谈论程序块阻塞你会觉得非常困惑

00:32:49.469 --> 00:32:52.472 align:middle
但在许多其它的情况下 你会听到它被
称作阻塞

00:32:54.007 --> 00:32:56.643 align:middle
从GCD的角度看这里非常有趣的是

00:32:56.710 --> 00:33:02.583 align:middle
我们想要设备上
每核的程序块或是线程都在主动地执行

00:32:56.710 --> 00:33:02.583 align:middle
我们想要设备上
每核的程序块或是线程都在主动地执行

00:33:03.083 --> 00:33:06.420 align:middle
所以当一线程等待时
我们将提出线程池中的另一个线程

00:33:06.486 --> 00:33:08.822 align:middle
直到受到限制

00:33:09.623 --> 00:33:11.758 align:middle
这样就有每核都有一个线程在运行

00:33:13.727 --> 00:33:15.829 align:middle
来想象一下我们有四个这样的程序块

00:33:15.896 --> 00:33:18.365 align:middle
正在两个不同的线程上执行前两个

00:33:19.233 --> 00:33:22.402 align:middle
前一个说：嘿 我需要执行I/O

00:33:22.970 --> 00:33:24.872 align:middle
我们说：好我们将发布I/O到磁盘上

00:33:25.272 --> 00:33:29.910 align:middle
但之后我们必须等待I/O回归返回

00:33:30.177 --> 00:33:31.778 align:middle
然后才可提出另一个线程

00:33:31.845 --> 00:33:35.816 align:middle
执行下一个程序块等等 当线程等待时

00:33:35.883 --> 00:33:39.119 align:middle
当仍有工作需要被做时
找另一线程来执行队列上的下一程序块

00:33:40.487 --> 00:33:44.191 align:middle
这里的问题是：
如果仅有四个程序块时运行没有问题

00:33:44.258 --> 00:33:48.161 align:middle
如果我有许多程序块且它们都想等待

00:33:48.562 --> 00:33:50.330 align:middle
我们就会遇到线程激增

00:33:51.965 --> 00:33:54.001 align:middle
当然这就会有点低效

00:33:54.067 --> 00:33:56.637 align:middle
有大量的线程都在占用资源

00:33:57.337 --> 00:33:59.106 align:middle
如果它们同时停止等待

00:33:59.173 --> 00:34:00.507 align:middle
就会有大量的资源冲突

00:33:59.173 --> 00:34:00.507 align:middle
就会有大量的资源冲突

00:34:01.708 --> 00:34:03.977 align:middle
所以这对性能来说是非常不好的

00:34:04.745 --> 00:34:05.979 align:middle
同时它也有一点危险性

00:34:06.046 --> 00:34:08.514 align:middle
因为这对可提出的程序数量有所限制

00:34:08.581 --> 00:34:11.851 align:middle
当我们耗尽极限时对于新的工作

00:34:11.918 --> 00:34:13.219 align:middle
我们该怎么办？

00:34:13.754 --> 00:34:15.222 align:middle
这就导致了死锁

00:34:16.623 --> 00:34:22.262 align:middle
我想举一个死锁的例子 是在
我们的一个内部应用程序里碰到的

00:34:22.862 --> 00:34:25.799 align:middle
这个例子有点复杂但
我希望我能一步步给你解释 因为

00:34:26.400 --> 00:34:28.034 align:middle
此例很好的说明 应用程序不同部分间

00:34:28.101 --> 00:34:30.670 align:middle
是如何以一种意料外的方式互动的

00:34:33.172 --> 00:34:37.244 align:middle
我们有主线程
并且主线程有大量的工作需要去做

00:34:37.811 --> 00:34:41.014 align:middle
它会异步调度大批程序块

00:34:41.081 --> 00:34:42.416 align:middle
到某一并发队列

00:34:42.815 --> 00:34:45.518 align:middle
我们为这些程序块提出线程

00:34:45.719 --> 00:34:47.353 align:middle
这些程序块立即转向

00:34:47.420 --> 00:34:49.422 align:middle
同步调度回主线程

00:34:50.357 --> 00:34:52.059 align:middle
这时我们已经提出了

00:34:52.125 --> 00:34:53.393 align:middle
我们需要的所有线程

00:34:53.493 --> 00:34:55.429 align:middle
在这里的这个简单例子中 是四个

00:34:55.963 --> 00:34:57.264 align:middle
我们达到了线程限制

00:34:57.865 --> 00:35:00.734 align:middle
我们将不能
再为线程池提出任何更多的线程

00:34:57.865 --> 00:35:00.734 align:middle
我们将不能
再为线程池提出任何更多的线程

00:35:03.403 --> 00:35:07.074 align:middle
那么 好的
我们需要主线程再次变成可使用的

00:35:07.140 --> 00:35:09.076 align:middle
以使那些程序块可以获取它

00:35:09.243 --> 00:35:11.345 align:middle
继续运行 至完成

00:35:11.745 --> 00:35:13.247 align:middle
现在它使我们重新回到限制下

00:35:14.648 --> 00:35:17.117 align:middle
仅在某些情况下
这可能发生但是让我们试想一下

00:35:17.818 --> 00:35:21.688 align:middle
主线程进入异步调度成为某一串行信号

00:35:22.589 --> 00:35:24.024 align:middle
到目前为止一切顺利

00:35:24.091 --> 00:35:25.792 align:middle
那个程序块仍不会开始执行

00:35:26.126 --> 00:35:28.195 align:middle
因为没有可利用的额外的主线程

00:35:28.262 --> 00:35:29.663 align:middle
来执行那个程序块

00:35:29.730 --> 00:35:32.933 align:middle
它会呆在那里 等待着某一线程返回

00:35:32.999 --> 00:35:34.334 align:middle
然后我们可将其再度利用

00:35:35.903 --> 00:35:38.405 align:middle
但是之后我们的主线程决定同步调度

00:35:38.472 --> 00:35:39.940 align:middle
成相同的串行队列

00:35:41.208 --> 00:35:43.410 align:middle
问题是对于串行队列

00:35:43.477 --> 00:35:44.511 align:middle
没有可用的线程

00:35:44.745 --> 00:35:48.615 align:middle
主调用将永远阻塞

00:35:48.682 --> 00:35:50.584 align:middle
这就是经典的死锁情况

00:35:51.251 --> 00:35:53.020 align:middle
我们的主线程正在等待资源

00:35:53.687 --> 00:35:55.923 align:middle
在此案例中是我们线程池中的一个线程

00:35:55.989 --> 00:35:58.392 align:middle
所有来自线程池中的线程都在等待资源

00:35:58.458 --> 00:36:01.328 align:middle
主线程都在互相等待 但没有一个会

00:35:58.458 --> 00:36:01.328 align:middle
主线程都在互相等待 但没有一个会

00:36:01.395 --> 00:36:04.164 align:middle
放弃那个资源 所以导致了死锁

00:36:05.132 --> 00:36:07.601 align:middle
这似乎非常匪夷所思不自然

00:36:07.801 --> 00:36:12.906 align:middle
但是当你的应用程序有许多不同的部分
不同的模块同时运行的框架时

00:36:13.307 --> 00:36:15.108 align:middle
死锁会比你想象中更容易碰到

00:36:15.909 --> 00:36:18.078 align:middle
并且实际情况中会更复杂

00:36:19.313 --> 00:36:21.014 align:middle
所以当你在用GCD时

00:36:21.081 --> 00:36:22.416 align:middle
这是你需要时刻铭记的

00:36:22.482 --> 00:36:24.818 align:middle
以保证你可以避免这种情况

00:36:25.085 --> 00:36:26.019 align:middle
这很容易做到

00:36:26.086 --> 00:36:29.122 align:middle
下面我会讲一些可适当避免这个问题的

00:36:29.189 --> 00:36:30.657 align:middle
设计应用程序的方法

00:36:32.626 --> 00:36:34.294 align:middle
首先是一些基础的东西

00:36:34.361 --> 00:36:35.262 align:middle
在任何可能的情况下

00:36:35.329 --> 00:36:37.231 align:middle
尽可能利用异步API

00:36:37.297 --> 00:36:38.665 align:middle
尤其是对于I/O

00:36:39.299 --> 00:36:42.503 align:middle
如果你这样做你可以避免程序块等待

00:36:43.136 --> 00:36:45.272 align:middle
这样你就不用提出更多的线程

00:36:45.339 --> 00:36:46.540 align:middle
更高效

00:36:48.008 --> 00:36:50.577 align:middle
对这类的情况 你也可以用串行队列

00:36:50.644 --> 00:36:53.647 align:middle
如果调度所有此类工作到串行队列上

00:36:53.714 --> 00:36:56.283 align:middle
我们就不会遇到线程激增

00:36:56.350 --> 00:36:58.285 align:middle
我们每次将仅执行一个程序块

00:36:59.086 --> 00:37:01.955 align:middle
我并不是在告诉你们
串行化你们全部的应用程序

00:36:59.086 --> 00:37:01.955 align:middle
我并不是在告诉你们
串行化你们全部的应用程序

00:37:02.623 --> 00:37:05.459 align:middle
但是当你建立你的应用程序

00:37:05.526 --> 00:37:09.329 align:middle
并创建不同的队列
在你的应用程序中处理不同的模块时

00:37:09.763 --> 00:37:11.932 align:middle
除非你知道对特别的模块你需要

00:37:11.999 --> 00:37:13.967 align:middle
平行运行某些东西

00:37:14.034 --> 00:37:16.303 align:middle
取而代之地为达到你的性能目标

00:37:16.370 --> 00:37:18.539 align:middle
请考虑从串行队列开始

00:37:19.239 --> 00:37:25.012 align:middle
在串行队列上同时运行你应用程序中
的各部分从中你可获得很多性能

00:37:25.078 --> 00:37:29.283 align:middle
之后你可以给出你应用程序的轮廓

00:37:29.349 --> 00:37:32.286 align:middle
看什么地方需要额外的平行运行的性能

00:37:32.352 --> 00:37:34.821 align:middle
并对这些地方进行特别设计

00:37:34.888 --> 00:37:37.658 align:middle
以避免线程激增

00:37:38.859 --> 00:37:41.461 align:middle
当然你也可以用有并发限制的

00:37:41.528 --> 00:37:42.963 align:middle
NSOperation队列

00:37:45.332 --> 00:37:47.634 align:middle
最后不要产生无限的工作

00:37:47.701 --> 00:37:51.705 align:middle
如果你可以按照
你需要的程序块数量来约束你的工作

00:37:51.772 --> 00:37:52.906 align:middle
就会避免线程激增

00:37:54.441 --> 00:37:57.077 align:middle
让我们来看看更具体的

00:37:57.477 --> 00:37:58.779 align:middle
在这是出现问题的实例代码

00:38:00.047 --> 00:38:03.317 align:middle
第一个是我们混合异步和同步

00:38:04.651 --> 00:38:09.423 align:middle
如果我只是对某队列进行同步调度
会非常的快

00:38:09.489 --> 00:38:11.291 align:middle
大体上是得到锁

00:38:11.892 --> 00:38:14.761 align:middle
如果我进行异步调度也会非常的快

00:38:14.828 --> 00:38:16.230 align:middle
大体上是原子入队

00:38:17.030 --> 00:38:19.700 align:middle
如果我有一个队列且仅用两个中的某个

00:38:19.766 --> 00:38:23.504 align:middle
其性能与这些基本体是非常相近的

00:38:24.771 --> 00:38:29.243 align:middle
如果我将这些混合异步到某队列
并做同步调度

00:38:29.610 --> 00:38:32.379 align:middle
同步调度就必须等待一线程被建立

00:38:32.446 --> 00:38:35.315 align:middle
并执行那个程序块
然后程序块才会被完成

00:38:36.049 --> 00:38:38.385 align:middle
现在我们多了创建线程的时间

00:38:38.452 --> 00:38:40.420 align:middle
但其实本来仅一个锁就足够了

00:38:41.121 --> 00:38:43.357 align:middle
混合这些基本体当然是安全的

00:38:43.824 --> 00:38:46.960 align:middle
但是当你设计应用程序的时候
想一下是否你真的需要这么做

00:38:47.561 --> 00:38:50.264 align:middle
在主线程中混合它们的时候
需要特别的小心

00:38:53.967 --> 00:38:58.972 align:middle
现在下一个问题是我们尝试一次调度许
多程序块到某一并发队列

00:39:00.007 --> 00:39:05.112 align:middle
如果你这么做
在我们的这个情况中你只需

00:39:05.179 --> 00:39:06.880 align:middle
避开主线程尝试继续执行

00:39:07.347 --> 00:39:09.616 align:middle
但是试想一下
在你异步的地方做一些相似的事情

00:39:09.683 --> 00:39:10.784 align:middle
之后做一个同步屏障

00:39:11.485 --> 00:39:16.456 align:middle
任何一个都是危险的
因为它将引起线程激增和死锁

00:39:17.324 --> 00:39:19.893 align:middle
但是我们有一个基本体叫做调度使用

00:39:19.960 --> 00:39:23.864 align:middle
这两段代码对你来说基本上是一模一样

00:39:23.931 --> 00:39:25.732 align:middle
从语义上来看

00:39:26.300 --> 00:39:28.502 align:middle
通过转换为调度应用 你通过GCD

00:39:28.569 --> 00:39:32.039 align:middle
来管理并行性和避免线程激增

00:39:36.143 --> 00:39:38.011 align:middle
当然你也可以用调度信号量

00:39:38.312 --> 00:39:41.348 align:middle
你们中的许多对用信号量作锁非常熟悉

00:39:42.115 --> 00:39:44.918 align:middle
取而代之的是这里
我们将信号量用做计数信号量

00:39:45.452 --> 00:39:47.788 align:middle
我们从对它进行初始化着手

00:39:47.855 --> 00:39:50.224 align:middle
通过使用我们想执行的并发任务数

00:39:50.290 --> 00:39:51.992 align:middle
比如说我们想要运行四个

00:39:53.360 --> 00:39:57.464 align:middle
每次我们的程序块完成
它会向信号量发出信号

00:39:58.165 --> 00:40:01.268 align:middle
每次我们提交 我们需要等待信号量

00:39:58.165 --> 00:40:01.268 align:middle
每次我们提交 我们需要等待信号量

00:40:02.269 --> 00:40:05.906 align:middle
结果是：提交线程将进行四次提交

00:40:05.973 --> 00:40:08.542 align:middle
之后阻塞那个信号量 直到

00:40:08.609 --> 00:40:10.978 align:middle
它们中的一个
可以完成并发信号给信号量

00:40:11.445 --> 00:40:13.313 align:middle
这个模式非常好 如果你的应用程序中

00:40:13.380 --> 00:40:15.115 align:middle
你可能在多个地点提交

00:40:15.182 --> 00:40:17.951 align:middle
某些东西像是调度应用是不合适的

00:40:23.090 --> 00:40:26.393 align:middle
希望这些帮助你们对线程激增有了解

00:40:26.460 --> 00:40:28.128 align:middle
并知道如何去避免它

00:40:28.195 --> 00:40:30.430 align:middle
我还想简短地谈一下崩溃报告

00:40:31.965 --> 00:40:33.800 align:middle
不幸的是
某些时候你们中的大多数都必须

00:40:33.867 --> 00:40:35.402 align:middle
处理一份崩溃报告

00:40:35.469 --> 00:40:37.004 align:middle
这里有许多信息

00:40:37.437 --> 00:40:40.607 align:middle
如果你在用GCD就更是这样

00:40:44.144 --> 00:40:46.513 align:middle
随着你有更多的线程
就会有更多的东西需要被剖析

00:40:46.580 --> 00:40:47.881 align:middle
及理解到底是怎么回事

00:40:49.783 --> 00:40:51.585 align:middle
所以我想介绍给你们一对堆栈

00:40:51.652 --> 00:40:53.720 align:middle
它们可以帮助你了解应用程序中

00:40:54.855 --> 00:40:57.090 align:middle
不同线程的作用

00:40:57.591 --> 00:40:59.092 align:middle
第一个是管理线程

00:41:00.360 --> 00:41:02.095 align:middle
你几乎在所有使用GCD的应用程序中

00:41:02.162 --> 00:41:04.798 align:middle
都可以看到管理线程

00:41:04.865 --> 00:41:06.767 align:middle
它负责帮助进程调度来源

00:41:07.167 --> 00:41:10.070 align:middle
你会注意到调度管理线程是根框架

00:41:10.737 --> 00:41:12.105 align:middle
一般来说你可以忽略它

00:41:13.674 --> 00:41:15.375 align:middle
我们有空闲的GCD线程

00:41:16.009 --> 00:41:17.811 align:middle
这些是线程池里空闲的线程

00:41:17.878 --> 00:41:20.614 align:middle
在堆栈的底部
你可以看到开始工作队列线程

00:41:20.681 --> 00:41:22.583 align:middle
有迹象指出它是一个GCD线程

00:41:22.683 --> 00:41:25.252 align:middle
工作队列当前返回指出它正在处在空闲

00:41:27.955 --> 00:41:30.057 align:middle
另一方面一个活跃的GCD线程仍将从

00:41:30.123 --> 00:41:32.960 align:middle
开始工作队列线程开始
但你会看到一些

00:41:33.026 --> 00:41:36.396 align:middle
调度客服端调用和
调度调用程序块及释放类的东西

00:41:36.763 --> 00:41:37.931 align:middle
跟随着你的代码

00:41:38.198 --> 00:41:41.735 align:middle
你也会看到当你创建队列时
曾输入的调度队列名称

00:41:41.802 --> 00:41:43.971 align:middle
给出描述性队列名称是非常重要的

00:41:46.740 --> 00:41:49.309 align:middle
当主线程空闲时 你会看到其列席在

00:41:49.376 --> 00:41:53.814 align:middle
虚拟信息陷阱
CF运行循环端口及CF运行循环运行

00:41:54.548 --> 00:41:57.751 align:middle
你也会看到com.apple主线程

00:41:59.486 --> 00:42:02.055 align:middle
另一方面如果你的主线程是活跃的

00:41:59.486 --> 00:42:02.055 align:middle
另一方面如果你的主线程是活跃的

00:42:02.122 --> 00:42:05.259 align:middle
由于主队列GCD队列
你可能会看到CF运行循环

00:42:05.325 --> 00:42:09.730 align:middle
正在服务主调度队列—如果它是活跃的

00:42:10.664 --> 00:42:13.467 align:middle
并且在这种情况下有我们
正调出的NSBlock操作

00:42:14.701 --> 00:42:17.171 align:middle
当你不能依赖于事物不会改变

00:42:17.237 --> 00:42:19.907 align:middle
今天有些内部的细节我也会谈及

00:42:19.973 --> 00:42:23.110 align:middle
为了能给你一个崩溃报告的指南

00:42:23.710 --> 00:42:25.612 align:middle
希望能提供给你一些有用的信息

00:42:27.548 --> 00:42:31.318 align:middle
至此总结一下 记住一个有效的

00:42:31.385 --> 00:42:34.588 align:middle
有响应的应用程序必须接受不同的环境

00:42:34.655 --> 00:42:36.823 align:middle
不管是Watch还是Mac Pro

00:42:36.890 --> 00:42:40.527 align:middle
这些不同的平台有各种各样的可用资源

00:42:40.594 --> 00:42:43.163 align:middle
GCD是可以帮助你
合理管理它们的一种非常好的方式

00:42:44.331 --> 00:42:47.334 align:middle
QoS分类允许操作系统

00:42:47.401 --> 00:42:49.870 align:middle
以最有效的方式安排你的资源

00:42:51.505 --> 00:42:54.007 align:middle
所以你应该回家想想如何将QoS分类

00:42:54.074 --> 00:42:55.876 align:middle
整合进你的应用程序

00:42:55.943 --> 00:42:57.544 align:middle
及既存的GCD使用中

00:42:59.479 --> 00:43:02.149 align:middle
最后想一下应用程序是如何使用GCD

00:42:59.479 --> 00:43:02.149 align:middle
最后想一下应用程序是如何使用GCD

00:43:02.216 --> 00:43:03.317 align:middle
并尝试避免线程激增

00:43:04.818 --> 00:43:05.886 align:middle
更多的信息 请查看

00:43:05.953 --> 00:43:10.691 align:middle
Mac和iOS应用程序并发程序指导
或能源效率指导

00:43:10.757 --> 00:43:13.360 align:middle
iOS应用程序的那个是这周刚出的

00:43:13.560 --> 00:43:19.266 align:middle
看看吧 它很棒
有开发者论坛和我们的宣传员Paul

00:43:20.200 --> 00:43:21.668 align:middle
几个相关的场次：

00:43:21.768 --> 00:43:26.473 align:middle
《获得整日电池寿命》给出了更多关于

00:43:26.540 --> 00:43:27.741 align:middle
我提到的能源话题的信息

00:43:28.642 --> 00:43:31.778 align:middle
《为多任务iOS9优化你的app》

00:43:32.913 --> 00:43:36.850 align:middle
《高级的NSOperations》
和在这之后的

00:43:37.184 --> 00:43:39.052 align:middle
《iOS及Watch OS性能》

00:43:39.119 --> 00:43:44.725 align:middle
如果那些你没有看过
我强烈的建议你去看一下 谢谢
