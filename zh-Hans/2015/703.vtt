WEBVTT

00:00:20.554 --> 00:00:23.757 align:middle
隐私安全和App

00:00:31.765 --> 00:00:35.569 align:middle
大家好 我是姬蒂·斯金纳
今天下午我将要和傑森·諾瓦克

00:00:36.136 --> 00:00:39.373 align:middle
一起谈论一下
关于你们app中隐私安全的问题

00:00:40.374 --> 00:00:43.510 align:middle
我们都是苹果产品
安全及隐私团队中的成员

00:00:44.545 --> 00:00:47.581 align:middle
这意味着我们需要
和苹果公司里所有的团队打交道

00:00:47.981 --> 00:00:50.684 align:middle
来在我们的app
和服务中实现隐私安全

00:00:51.885 --> 00:00:53.854 align:middle
在工作中和我联系最紧密的团队包括

00:00:54.388 --> 00:00:58.358 align:middle
Apple Pay,Siri,Proactive
Assistant,Health

00:00:59.359 --> 00:01:01.528 align:middle
以及我们最新发布的操作系统
watch OS

00:00:59.359 --> 00:01:01.528 align:middle
以及我们最新发布的操作系统
watch OS

00:01:02.729 --> 00:01:08.335 align:middle
首先我想讲一点关于隐私安全的
意义以及我们是如何看待它的

00:01:10.404 --> 00:01:14.508 align:middle
在苹果我们把隐私
视作人的一项基本权利

00:01:15.475 --> 00:01:18.111 align:middle
这也是我们每天工作的首要原则

00:01:18.178 --> 00:01:23.584 align:middle
当我们在设计app
服务以及发行新版本

00:01:23.650 --> 00:01:26.720 align:middle
也就是IOS, OSX, watch OS的时候
我们会牢记这一点

00:01:28.188 --> 00:01:30.257 align:middle
用户希望当他们使用我们的产品时

00:01:30.324 --> 00:01:33.861 align:middle
他们的隐私得到尊重而对所有的开发者

00:01:33.927 --> 00:01:36.230 align:middle
在座的每一个人来说
这是我们的共同责任

00:01:37.564 --> 00:01:38.932 align:middle
所以当你们在开发app时

00:01:39.032 --> 00:01:44.805 align:middle
要留心对用户隐私的保护
并将其在你们的app中实现

00:01:46.740 --> 00:01:50.244 align:middle
在苹果我们不仅致力于做出伟大的产品

00:01:50.611 --> 00:01:54.715 align:middle
也致力于做出伟大的工具

00:01:55.482 --> 00:01:58.552 align:middle
面向开发团队为你们提供更多的便利

00:01:58.619 --> 00:02:02.923 align:middle
让你们尊重用户隐私并在
你们的app和服务中实现隐私安全

00:01:58.619 --> 00:02:02.923 align:middle
让你们尊重用户隐私并在
你们的app和服务中实现隐私安全

00:02:04.591 --> 00:02:09.530 align:middle
到目前为止我们所有的成功
都依赖于我们和用户之间的良好关系

00:02:10.864 --> 00:02:14.168 align:middle
而信任是维系这段关系的关键

00:02:15.636 --> 00:02:18.939 align:middle
我们都看过一些 关于违背隐私安全

00:02:19.740 --> 00:02:23.977 align:middle
泄露用户信息的新闻
在座的各位都不想看到这种事情发生

00:02:24.044 --> 00:02:26.246 align:middle
不希望苹果成为下一个此类新闻的焦点

00:02:28.782 --> 00:02:31.018 align:middle
我们提供了这样一个平台

00:02:31.084 --> 00:02:33.120 align:middle
让用户为新的体验感到兴奋

00:02:33.187 --> 00:02:35.756 align:middle
兴奋于下载新的app

00:02:36.957 --> 00:02:41.261 align:middle
这些使得我们的app
生态系统得以运转

00:02:41.461 --> 00:02:46.567 align:middle
并且繁荣而用户对
你们的信赖是其中重要的一环

00:02:47.634 --> 00:02:49.703 align:middle
所以我们要值得让用户信赖

00:02:52.906 --> 00:02:56.677 align:middle
如今用户因信任而提供了许多敏感数据

00:02:58.011 --> 00:03:00.414 align:middle
我们要成为优秀的数据管家

00:02:58.011 --> 00:03:00.414 align:middle
我们要成为优秀的数据管家

00:03:01.348 --> 00:03:05.319 align:middle
隐私安全的构建是个好的入手点

00:03:06.820 --> 00:03:09.823 align:middle
现在所有的数据都需要一份保存策略

00:03:10.791 --> 00:03:12.993 align:middle
你们对此有什么好的想法吗？

00:03:13.493 --> 00:03:16.563 align:middle
我们可以从如何使用这些数据入手

00:03:17.764 --> 00:03:20.934 align:middle
对于一些你们再也用不到的数据

00:03:21.401 --> 00:03:23.337 align:middle
不会再用它们来为用户提供服务

00:03:24.238 --> 00:03:25.706 align:middle
那就应该把它们删掉

00:03:27.708 --> 00:03:30.711 align:middle
对于你存储的所有数据而言

00:03:30.777 --> 00:03:34.715 align:middle
你存储的数据越多
你对攻击者就越具有吸引力

00:03:35.282 --> 00:03:36.650 align:middle
就越有价值

00:03:37.951 --> 00:03:40.654 align:middle
所以要做到只保存你们需要的数据

00:03:42.523 --> 00:03:45.759 align:middle
我认为我们收集到的
所有数据都具有风险

00:03:46.927 --> 00:03:51.398 align:middle
所以你需要在为用户提供的价值

00:03:52.065 --> 00:03:56.003 align:middle
和收集与存储数据本身存
在的风险之间做出权衡

00:03:57.938 --> 00:04:03.010 align:middle
现在你可以通过把数据减到
最少的技术来降低这种风险

00:03:57.938 --> 00:04:03.010 align:middle
现在你可以通过把数据减到
最少的技术来降低这种风险

00:04:04.645 --> 00:04:08.782 align:middle
为了学习这类技术以及具体应用的事例

00:04:08.849 --> 00:04:15.556 align:middle
你们可以找找去年的WWDC演讲

00:04:15.656 --> 00:04:17.724 align:middle
看一下IOS和OS X中的
用户隐私安全部分

00:04:19.726 --> 00:04:22.796 align:middle
如数据聚合 分辨率降低

00:04:23.297 --> 00:04:27.601 align:middle
这些都是减轻持有数据的风险的方法

00:04:29.002 --> 00:04:30.504 align:middle
但具体你应该选择哪种方法呢？

00:04:32.105 --> 00:04:35.776 align:middle
为了回答这个问题
我们可以从数据的用途入手

00:04:36.043 --> 00:04:37.344 align:middle
你将用这些数据来做些什么？

00:04:37.945 --> 00:04:39.980 align:middle
你想解决一些什么问题？

00:04:40.781 --> 00:04:42.816 align:middle
它们可以辅助做出什么决策？

00:04:44.251 --> 00:04:48.322 align:middle
如果你回答不出以上问题
你就什么都想不出来

00:04:48.789 --> 00:04:52.326 align:middle
那么保存这些数据对你一点用都没有

00:04:53.193 --> 00:04:57.097 align:middle
那可以使用列表中的
最后一项技术数据最小化

00:04:57.531 --> 00:04:59.967 align:middle
你根本就不需要收集和传输这些数据

00:05:02.269 --> 00:05:05.873 align:middle
如果你觉得可以用这些数据来做些什么

00:05:06.707 --> 00:05:10.010 align:middle
那么在转出过程中
所有数据都应该得到保护

00:05:11.378 --> 00:05:14.147 align:middle
一会儿傑森将要讲讲关于
app传输安全的问题

00:05:14.481 --> 00:05:17.584 align:middle
这是我们在IOS 9中
采用的一个新方法

00:05:18.018 --> 00:05:21.588 align:middle
来改进服务过程中的安全传输

00:05:23.023 --> 00:05:26.527 align:middle
为了降低风险
尽可能地避免在设备中输出数据

00:05:26.593 --> 00:05:29.363 align:middle
尤其是对于敏感的数据类别

00:05:29.696 --> 00:05:31.565 align:middle
更要慎之又慎

00:05:32.099 --> 00:05:34.001 align:middle
这包括一些像健康情况的数据

00:05:35.269 --> 00:05:37.704 align:middle
举个例子在
cycling Workout中

00:05:38.372 --> 00:05:42.442 align:middle
我们可以得到一些
诸如用户的心率和运动距离的数据

00:05:42.709 --> 00:05:45.512 align:middle
而用户的身高 体重和校正数据

00:05:46.146 --> 00:05:49.650 align:middle
都可能在配对设备中获取

00:05:50.250 --> 00:05:52.719 align:middle
可以计算出在运动过程中
卡路里消耗的情况

00:05:53.787 --> 00:05:56.423 align:middle
这些数据都不会反馈到
服务器中处理分析

00:05:58.692 --> 00:06:02.262 align:middle
现在我们不仅需要
在传输过程中保护数据

00:05:58.692 --> 00:06:02.262 align:middle
现在我们不仅需要
在传输过程中保护数据

00:06:02.462 --> 00:06:03.830 align:middle
在存储过程中也是一样

00:06:05.332 --> 00:06:08.535 align:middle
首先考虑一下是否需要存储这些数据？

00:06:10.137 --> 00:06:11.305 align:middle
是否只是需要短期保存？

00:06:11.572 --> 00:06:13.574 align:middle
能不能只在内存中存储呢？

00:06:14.174 --> 00:06:15.776 align:middle
或者说它需要被写进盘里吗？

00:06:17.077 --> 00:06:19.980 align:middle
IOS和watch OS
平台受益于数据保护

00:06:20.380 --> 00:06:22.282 align:middle
我将一会儿再谈论这个

00:06:23.817 --> 00:06:25.385 align:middle
如果你在服务端存储数据

00:06:25.485 --> 00:06:27.688 align:middle
要保证在空闲时段能对数据加密

00:06:28.455 --> 00:06:30.891 align:middle
使用CloudKit我们就
能很容易得实现这一点

00:06:32.392 --> 00:06:35.729 align:middle
思考一下在你的数据传输
和存储时应该用什么样的标识符呢

00:06:36.163 --> 00:06:40.734 align:middle
一会儿傑森将会深入介绍一下
如何选择合适的标识符的问题

00:06:43.170 --> 00:06:45.906 align:middle
现在你需要让用户明白

00:06:45.973 --> 00:06:48.809 align:middle
你将用你的这些数据
这些来源于用户的数据做些什么

00:06:48.876 --> 00:06:51.378 align:middle
你将如何使用它们
如果你将要和第三方分享数据

00:06:51.445 --> 00:06:53.180 align:middle
这些都需要保持透明

00:06:53.647 --> 00:06:55.883 align:middle
要确保用户可以理解你在做什么

00:06:56.917 --> 00:06:58.952 align:middle
避免用户产生任何的恐慌

00:07:01.121 --> 00:07:03.757 align:middle
这里有一种好的解决方式

00:07:04.224 --> 00:07:07.828 align:middle
让用户明白他们的数据
是如何被收集和存储的

00:07:08.262 --> 00:07:10.264 align:middle
那就是给用户检查他们数据的权利

00:07:11.798 --> 00:07:14.501 align:middle
而且在你收集数据的时候

00:07:14.568 --> 00:07:18.539 align:middle
或者说当你提供给用户选择权时

00:07:18.605 --> 00:07:20.641 align:middle
你希望通过透露一些信息

00:07:21.108 --> 00:07:22.409 align:middle
来帮助用户做出更好的选择

00:07:23.143 --> 00:07:25.012 align:middle
你可以通过采用目的字符串等解决方案

00:07:25.612 --> 00:07:29.016 align:middle
当用户在考虑他们是否要给你们
提供照片等信息的权限的同时

00:07:30.250 --> 00:07:32.052 align:middle
你也希望用户能掌握主控权

00:07:32.886 --> 00:07:35.255 align:middle
要给他们更改决定的权利

00:07:35.422 --> 00:07:39.259 align:middle
如果稍后他们的决定变得和先前不同

00:07:39.860 --> 00:07:44.798 align:middle
那时要给他们一个机会
对你已经存储的信息进行重置甚至删除

00:07:47.935 --> 00:07:50.904 align:middle
现在我要谈一些关于我们的平台

00:07:50.971 --> 00:07:52.840 align:middle
在提高用户隐私安全
方面做出的一些更新

00:07:54.908 --> 00:07:58.478 align:middle
我想讲一下在IOS,OS X
平台中发生的一些改变

00:07:59.279 --> 00:08:02.149 align:middle
还有一些在watch OS
平台中的基础的东西

00:07:59.279 --> 00:08:02.149 align:middle
还有一些在watch OS
平台中的基础的东西

00:08:03.750 --> 00:08:06.587 align:middle
首先说到IOS平台的发展
我们可以追溯到去年

00:08:07.521 --> 00:08:11.225 align:middle
在去年我们开始配置加密的MAC地址

00:08:11.558 --> 00:08:13.460 align:middle
来应对几种特定的wifi扫描方式

00:08:14.661 --> 00:08:17.331 align:middle
在ios 9平台里
我们增加了扫描方式的数目

00:08:17.598 --> 00:08:19.766 align:middle
对其MAC地址进行加密

00:08:20.601 --> 00:08:24.271 align:middle
值得注意的是
如果你的功能是基于外设的

00:08:24.338 --> 00:08:28.175 align:middle
一定要先在IOS 9中
对MAC地址做测试确认

00:08:28.942 --> 00:08:32.513 align:middle
因为在正式使用之前
你不能保证MAC地址的可用性

00:08:34.948 --> 00:08:38.519 align:middle
简单来说我们认为想在手机上

00:08:38.919 --> 00:08:42.322 align:middle
安什么软件是由用户决定的

00:08:43.890 --> 00:08:46.693 align:middle
用户可以用他们的手机做许多事

00:08:47.628 --> 00:08:50.564 align:middle
他们也有各种各样的理由
来安装自己喜欢的app

00:08:51.398 --> 00:08:54.334 align:middle
健康养生 金融理财
居家生活等 不胜枚举

00:08:55.569 --> 00:08:58.305 align:middle
就目前来说用户安装了哪些app

00:08:58.705 --> 00:09:01.875 align:middle
以及那些app从用户身上获取了些
什么信息已经变成了非常敏感的事

00:08:58.705 --> 00:09:01.875 align:middle
以及那些app从用户身上获取了些
什么信息已经变成了非常敏感的事

00:09:03.143 --> 00:09:06.079 align:middle
所以要尝试着检测出
用户安装了什么app

00:09:06.680 --> 00:09:10.717 align:middle
通过直接进行识别
或者收集相关信息来辅助判断

00:09:10.951 --> 00:09:13.620 align:middle
来找出一些违反IOS的
安全模型的内容

00:09:15.656 --> 00:09:19.860 align:middle
最终IOS安全系统会对确定
出来的app进行建模分析

00:09:20.928 --> 00:09:23.530 align:middle
它们仅在自己的沙箱中存活

00:09:23.697 --> 00:09:25.599 align:middle
这可以保护它们不被
其他的app和进程侵害

00:09:27.100 --> 00:09:30.771 align:middle
尝试确定用户在手机上安装了什么app

00:09:31.638 --> 00:09:33.807 align:middle
是IOS安全模型的一项颠覆性成果

00:09:36.310 --> 00:09:40.414 align:middle
现在与之相伴的是
canOpenURL今年也在改变

00:09:43.050 --> 00:09:45.652 align:middle
canOpenURL存在的意义

00:09:45.886 --> 00:09:49.990 align:middle
是为了确认一个app
能否打开指定的URL资源

00:09:51.158 --> 00:09:54.428 align:middle
这可以为一些功能提供支持

00:09:54.828 --> 00:09:57.664 align:middle
比如当手机里安装一个新的app时

00:09:58.432 --> 00:10:00.234 align:middle
它会提示用户可以实现
一些什么新的操作

00:09:58.432 --> 00:10:00.234 align:middle
它会提示用户可以实现
一些什么新的操作

00:10:02.269 --> 00:10:07.741 align:middle
有两个新方向你们可以了解一下

00:10:08.442 --> 00:10:09.610 align:middle
菜单和通用链接

00:10:09.910 --> 00:10:11.979 align:middle
他们支持一些和URL方案相同的功能

00:10:12.045 --> 00:10:13.680 align:middle
我希望你们可以多关注一下那些方面

00:10:14.481 --> 00:10:17.985 align:middle
但是如果你想继续使用URL方案

00:10:18.051 --> 00:10:21.021 align:middle
在IOS 9里开发你的app
并且想要调用URL方案

00:10:21.288 --> 00:10:24.758 align:middle
你需要知道的是你得先在app中的
Info.plist文件中声明它们

00:10:25.359 --> 00:10:28.762 align:middle
这里有个新增索引键叫
LSApplicationQueriesSchemes

00:10:29.363 --> 00:10:32.266 align:middle
在这里你需要把canOpenURL

00:10:32.499 --> 00:10:35.435 align:middle
添加进方案列表

00:10:37.871 --> 00:10:40.707 align:middle
现在你不用改变对
canOpenURL的调用方式

00:10:41.074 --> 00:10:43.043 align:middle
当前API也不会发生改变

00:10:43.810 --> 00:10:46.346 align:middle
但是一旦你调用了
canOpenURL

00:10:46.713 --> 00:10:49.049 align:middle
它就会检查你app中的
Info.plist文件

00:10:49.683 --> 00:10:54.087 align:middle
看看你所调用的方案是否已经被声明

00:10:55.489 --> 00:10:58.859 align:middle
所以说你需要先对其进行声明

00:10:59.026 --> 00:11:05.232 align:middle
当你在那个方案中调用
canOpenURL时

00:10:59.026 --> 00:11:05.232 align:middle
当你在那个方案中调用
canOpenURL时

00:11:05.699 --> 00:11:08.302 align:middle
如果安装的app支持这个方案
那么返回值为真

00:11:09.303 --> 00:11:13.540 align:middle
如果并没有安装任何app
那么返回值为无

00:11:16.210 --> 00:11:18.745 align:middle
所以如果你没有声明URL方案
会发生些什么呢

00:11:19.346 --> 00:11:22.149 align:middle
不管这里是否有一个支持它的app

00:11:22.349 --> 00:11:25.085 align:middle
你收到的返回值始终为无

00:11:28.255 --> 00:11:32.559 align:middle
所以对于那些在IOS 9
之前版本被链接

00:11:33.460 --> 00:11:35.362 align:middle
以及在IOS 9中运行的app来说

00:11:35.462 --> 00:11:39.566 align:middle
只给它们50个独立的URL方案

00:11:41.101 --> 00:11:43.403 align:middle
一旦你连续调用到第51个方案的时候

00:11:43.937 --> 00:11:45.506 align:middle
你将会收到的返回值为无

00:11:46.673 --> 00:11:49.576 align:middle
即使当用户重启手机的时候

00:11:49.643 --> 00:11:51.979 align:middle
这50个URL方案也不会被重启

00:11:54.381 --> 00:11:58.252 align:middle
我之前提到的今年新出的
一种可替代方案是通用链接

00:11:58.886 --> 00:12:03.023 align:middle
通用链接的厉害之处就在于
如果用户已安装某个app

00:11:58.886 --> 00:12:03.023 align:middle
通用链接的厉害之处就在于
如果用户已安装某个app

00:12:03.190 --> 00:12:04.258 align:middle
链接将会开启

00:12:05.025 --> 00:12:06.960 align:middle
同时也会发送一个反馈信息

00:12:07.294 --> 00:12:11.098 align:middle
如果没有安装这个app
链接将只会在app的网页端开启

00:12:12.366 --> 00:12:15.335 align:middle
Sysctl命令今年
也发生了一些变化

00:12:16.270 --> 00:12:20.340 align:middle
Sysctl是一种低水平的API

00:12:20.607 --> 00:12:22.242 align:middle
用以询问和设置系统信息

00:12:24.044 --> 00:12:28.115 align:middle
它涉及的初衷就是允许具
有合适权限的进程来浏览信息

00:12:29.750 --> 00:12:34.588 align:middle
但正如我之前所说

00:12:35.088 --> 00:12:38.759 align:middle
IOS中的app并没有浏览
其他app的信息的权限

00:12:39.860 --> 00:12:43.130 align:middle
所以IOS沙箱今年发生了一个变化

00:12:44.598 --> 00:12:51.271 align:middle
那就是它再也不能通过调用kern.proc
kern.procargs

00:12:51.772 --> 00:12:56.243 align:middle
和kern.procargs2来看到

00:12:56.543 --> 00:12:58.779 align:middle
来自其他任何进程的数据

00:13:00.814 --> 00:13:04.484 align:middle
今年在IOS和OS X这两个平台上

00:13:06.053 --> 00:13:09.323 align:middle
我们即将引入内容过滤
方面的新的延伸点

00:13:11.124 --> 00:13:14.194 align:middle
你的分程序表将能适
用于Safari

00:13:15.028 --> 00:13:18.532 align:middle
以及所有使用
SafariViewController的app

00:13:20.501 --> 00:13:23.070 align:middle
你应该去测试一下
非常受欢迎的扩展功能

00:13:23.136 --> 00:13:24.938 align:middle
来了解它将为你的应用或网页

00:13:25.205 --> 00:13:27.741 align:middle
带来怎样的影响

00:13:30.277 --> 00:13:33.380 align:middle
你应该时刻做好心理准备
你的页面中的某一部分

00:13:33.447 --> 00:13:35.883 align:middle
会在加载和处理它时遇到些问题

00:13:38.852 --> 00:13:43.423 align:middle
接下来要说的是在OS X平台上
我们正在尝试改变cookie策略

00:13:45.125 --> 00:13:48.028 align:middle
自从产生了可以在所有应用和进程中

00:13:48.095 --> 00:13:50.297 align:middle
分享cookie的
Yosemite系统之后

00:13:51.064 --> 00:13:53.901 align:middle
Cookie如今已变成了本地所有

00:13:54.701 --> 00:13:57.371 align:middle
它们对于单一进程来说是
属于本地的并且不可共享

00:13:58.172 --> 00:14:02.409 align:middle
注意如果你已经在
App Store中运行过你的应用

00:13:58.172 --> 00:14:02.409 align:middle
注意如果你已经在
App Store中运行过你的应用

00:14:03.076 --> 00:14:04.478 align:middle
那对你来说就不会发生任何改变

00:14:05.312 --> 00:14:06.547 align:middle
因为你已经在这种状态中了

00:14:08.081 --> 00:14:11.485 align:middle
如果你使用了Web Clips
或者Dashboard小工具

00:14:11.785 --> 00:14:14.521 align:middle
请注意要在OS X
EI Capitan中进行测试

00:14:17.991 --> 00:14:20.494 align:middle
现在我要讲一些关于
我们最新平台的内容

00:14:21.962 --> 00:14:27.401 align:middle
在这些年里我们看着IOS
和OS X系统一步步得发展成熟

00:14:28.368 --> 00:14:30.437 align:middle
正是这些经历让我们从一开始就确信

00:14:31.071 --> 00:14:35.375 align:middle
对于在新平台中建设好隐私和安全问题

00:14:36.109 --> 00:14:38.679 align:middle
我们已经有不错的基础了

00:14:40.380 --> 00:14:42.249 align:middle
我们的优势包括一些已有的技术

00:14:42.482 --> 00:14:45.352 align:middle
比如数据保护和我们的即时预警技术

00:14:46.320 --> 00:14:49.223 align:middle
我们认为这些装置是紧密相关的

00:14:50.524 --> 00:14:53.627 align:middle
对于用户来说只需要与这
两个装置中的其一建立联系就行

00:14:54.428 --> 00:14:57.130 align:middle
这也是为什么许多设置可以通用的原因

00:14:58.465 --> 00:15:01.034 align:middle
这同时也包括

00:14:58.465 --> 00:15:01.034 align:middle
这同时也包括

00:15:02.002 --> 00:15:03.770 align:middle
你在本地WatchKit app
中的隐私设置

00:15:03.837 --> 00:15:07.107 align:middle
所以不管用户是和你的
IOS中的app进行交互

00:15:07.608 --> 00:15:12.212 align:middle
还是和Glance
或者其他第三方进行交互

00:15:13.213 --> 00:15:15.816 align:middle
在隐私安全方面的设置都是相同的

00:15:17.050 --> 00:15:21.088 align:middle
我们相信如果用户对于
开发者是无条件信任的

00:15:22.089 --> 00:15:23.457 align:middle
他们就不会产生这样一些异议

00:15:23.524 --> 00:15:26.627 align:middle
比如想“能不能给他们权限
来访问我Glance中的照片呢？”

00:15:26.960 --> 00:15:28.662 align:middle
用户有着很单一的信任方式

00:15:29.162 --> 00:15:33.433 align:middle
他们因信任而允许你访问数据
并且对数据提供保护或者相反

00:15:36.270 --> 00:15:39.473 align:middle
所以我们认为

00:15:39.940 --> 00:15:43.977 align:middle
从一开始就把关注点放在
做好隐私保护工作是非常重要的

00:15:44.711 --> 00:15:50.250 align:middle
因为你的Glance可能成为
用户与你的app交互最多的一个地方

00:15:53.020 --> 00:15:57.057 align:middle
并且，在watchOS 2平台上
把钥匙串系统引进到Watch中

00:15:59.426 --> 00:16:03.397 align:middle
接下来将由Jason负责主讲他将
涉及更多关于如何选择标识符的问题

00:15:59.426 --> 00:16:03.397 align:middle
接下来将由Jason负责主讲他将
涉及更多关于如何选择标识符的问题

00:16:10.604 --> 00:16:13.173 align:middle
感谢姬蒂 现在我将讲一下

00:16:13.340 --> 00:16:15.843 align:middle
关于在IOS和watchOS中的
标识符的问题

00:16:16.176 --> 00:16:18.145 align:middle
这是我们在之前的演讲中

00:16:18.212 --> 00:16:19.546 align:middle
就谈到过的一个问题

00:16:19.613 --> 00:16:22.616 align:middle
你们可以回顾一下去年的WWDC演讲

00:16:22.683 --> 00:16:24.284 align:middle
来进行一下更加深入的了解

00:16:25.018 --> 00:16:27.654 align:middle
但是我认为
在讲watchOS中的标识符之前

00:16:27.721 --> 00:16:31.692 align:middle
回顾一下之前在IOS系统中
学过的一些知识也是非常必要的

00:16:33.126 --> 00:16:34.494 align:middle
标识符是具有很大作用的

00:16:34.928 --> 00:16:36.830 align:middle
它们的厉害之处就在于

00:16:36.897 --> 00:16:39.666 align:middle
如果你使用一些用户
相关的内容来鉴别他们

00:16:39.900 --> 00:16:43.871 align:middle
比如用户的姓名 电话号码
邮箱等 可以从中披露出许多信息

00:16:45.072 --> 00:16:47.341 align:middle
你可以建立更注重隐私安全的标识符

00:16:47.474 --> 00:16:53.547 align:middle
通过生成随机数来实现或者如果要求
随机数的结构规整你可以使用UUID

00:16:54.515 --> 00:16:57.918 align:middle
当一个随机数或者UUID
不能够鉴别用户

00:16:58.118 --> 00:16:59.653 align:middle
那就取决于你记录了什么信息

00:17:00.220 --> 00:17:01.922 align:middle
你以怎样的频率来切换标识符

00:17:01.989 --> 00:17:03.690 align:middle
以及用户掌控着些什么

00:17:03.857 --> 00:17:06.326 align:middle
超过规定时间标识符就会解除匿名

00:17:06.660 --> 00:17:08.962 align:middle
由于你记录着许多种不同的信息

00:17:09.329 --> 00:17:12.499 align:middle
那些信息可能识别具体用户
比如app动态

00:17:13.032 --> 00:17:16.537 align:middle
搜索词条 消息或者位置信息

00:17:16.603 --> 00:17:19.106 align:middle
这些都取决于你的app的行为

00:17:20.040 --> 00:17:22.542 align:middle
那就意味着所有标识符都携带有风险

00:17:23.042 --> 00:17:25.145 align:middle
即使标识符本身是可以匿名的

00:17:25.412 --> 00:17:27.047 align:middle
如果你持有的数据不能匿名

00:17:27.614 --> 00:17:30.050 align:middle
一旦其中一个数据违反了这一规则

00:17:30.117 --> 00:17:31.718 align:middle
你将担起危害用户隐私安全的后果

00:17:32.486 --> 00:17:34.087 align:middle
紧接着就是名誉受损

00:17:34.421 --> 00:17:35.822 align:middle
你会失去用户的信任

00:17:36.490 --> 00:17:38.725 align:middle
当我提及数据泄露你可能会想到黑客

00:17:38.792 --> 00:17:40.727 align:middle
或者其他不法势力

00:17:41.228 --> 00:17:45.032 align:middle
但那其实就像从把一个
未设密的笔记本从车的后备箱偷出来

00:17:45.199 --> 00:17:47.367 align:middle
或者备份文件从卡车上掉下来那么简单

00:17:48.702 --> 00:17:51.572 align:middle
正因为标识符的力量是如此强大

00:17:51.638 --> 00:17:53.807 align:middle
苹果花费了大量的时间
来研究标识符该如何运作

00:17:54.007 --> 00:17:55.209 align:middle
以及筛选一些最优方案

00:17:56.577 --> 00:17:59.146 align:middle
所以首先在你使用标识符之前

00:17:59.246 --> 00:18:01.215 align:middle
问一下你自己 你真的需要吗?

00:17:59.246 --> 00:18:01.215 align:middle
问一下你自己 你真的需要吗?

00:18:01.715 --> 00:18:03.884 align:middle
你是否用以下方式收集数据呢？

00:18:04.251 --> 00:18:07.287 align:middle
通过一个存储到服务器端的
数据库或者字典值

00:18:07.354 --> 00:18:11.525 align:middle
由客户端向服务器发送信息

00:18:11.992 --> 00:18:14.995 align:middle
而你只需记录服务器的增量数据？

00:18:16.663 --> 00:18:18.899 align:middle
如果你确定了自己真的需要使用标识符

00:18:19.233 --> 00:18:20.801 align:middle
考虑一下你想用它来标识什么

00:18:21.001 --> 00:18:22.870 align:middle
你需要使用多长时间

00:18:23.637 --> 00:18:25.739 align:middle
你只是想识别一个会话

00:18:25.806 --> 00:18:28.742 align:middle
通过简单得在app中
发送标识符来为不同进程取得关联？

00:18:29.309 --> 00:18:30.244 align:middle
你是否在尝试...

00:18:30.310 --> 00:18:33.080 align:middle
以及能不能在每次开启和
关闭app的时候都切换标识符呢？

00:18:33.947 --> 00:18:35.716 align:middle
你是否只着眼于暂时性的活动

00:18:35.916 --> 00:18:39.820 align:middle
每隔5,10或者15分钟
都会切换标识符？

00:18:40.854 --> 00:18:43.991 align:middle
我们知道切换标识符因其
可以降低数据相关性

00:18:44.057 --> 00:18:47.160 align:middle
而能起到隐私保护的作用

00:18:47.561 --> 00:18:49.563 align:middle
我们一会儿将要通过
一个例子来说明具体情况

00:18:50.864 --> 00:18:52.533 align:middle
如果你要标识一个用户

00:18:53.400 --> 00:18:56.003 align:middle
你要怎样同用户解释

00:18:56.170 --> 00:18:58.472 align:middle
为何拒绝他们安装一些
同样需要标识用户的应用呢？

00:18:59.206 --> 00:19:02.142 align:middle
你使他们通过你的服务建立了账户吗？

00:18:59.206 --> 00:19:02.142 align:middle
你使他们通过你的服务建立了账户吗？

00:19:02.242 --> 00:19:03.710 align:middle
你是否要求他们登录？

00:19:04.211 --> 00:19:06.680 align:middle
你能在UI界面中用语言描述清楚

00:19:06.747 --> 00:19:09.149 align:middle
你之所以这样做
是为了让他们获得更好的用户体验吗？

00:19:09.883 --> 00:19:13.353 align:middle
当你想清楚如何向用户
解释这些之后你真的考虑好

00:19:13.620 --> 00:19:19.560 align:middle
在收集数据的同时要承担的
用户标识方面的风险了吗？

00:19:21.495 --> 00:19:24.164 align:middle
最后如果你想收集

00:19:24.331 --> 00:19:28.769 align:middle
关于手机上app安装的信息在避免
触及用户的其他信息或者会话的情况下

00:19:29.369 --> 00:19:31.338 align:middle
你是否设计出了合适的度量方法

00:19:31.405 --> 00:19:34.074 align:middle
来统计计算用户在
设备上的一些操作实例

00:19:34.141 --> 00:19:36.910 align:middle
比如用户在第二个手机上
卸载或下载一个app

00:19:36.977 --> 00:19:40.714 align:middle
或者备份数据以及进行设备间存储呢？

00:19:41.114 --> 00:19:45.419 align:middle
在那些过程中关于用户的隐私保护方面

00:19:45.485 --> 00:19:49.957 align:middle
标识符的重置和不变是否能在你的
度量体系中有合理的解释？

00:19:52.593 --> 00:19:55.062 align:middle
最后你该考虑一下关于
标识符范围的问题

00:19:55.629 --> 00:19:56.930 align:middle
通过一个固定不变的标识符

00:19:56.997 --> 00:20:01.869 align:middle
利用它属性上的特征来
跟踪用户的一切行为是非常容易的

00:19:56.997 --> 00:20:01.869 align:middle
利用它属性上的特征来
跟踪用户的一切行为是非常容易的

00:20:02.503 --> 00:20:04.738 align:middle
但用户的隐私安全也被极大降低了

00:20:05.072 --> 00:20:09.510 align:middle
许多数据是通过单一标识符被收集的
当环境发生变化

00:20:09.576 --> 00:20:11.778 align:middle
内容发生变化时标识符却不会发生变化

00:20:12.880 --> 00:20:16.783 align:middle
而且用户也不希望用同一个
标识被跟踪所有的内容

00:20:17.284 --> 00:20:18.919 align:middle
审视标识符的作用域

00:20:18.986 --> 00:20:23.290 align:middle
你将会得到针对不同目的
针对和不同数据关联的

00:20:23.357 --> 00:20:25.192 align:middle
针对不同存活期的不同标识符

00:20:26.894 --> 00:20:28.762 align:middle
现在我要举一个例子

00:20:28.929 --> 00:20:32.933 align:middle
描述一种可以增加你
隐私安全的特殊的标识符

00:20:32.999 --> 00:20:34.601 align:middle
它把可能面临的风险降到最低

00:20:35.002 --> 00:20:37.905 align:middle
设计出用同一标识符搜索
所有信息的服务是非常简单的

00:20:37.971 --> 00:20:40.707 align:middle
可一旦发生了数据泄露

00:20:41.141 --> 00:20:43.110 align:middle
即使标识符是匿名的

00:20:43.777 --> 00:20:45.779 align:middle
也能通过已有信息来识别出用户

00:20:46.079 --> 00:20:48.482 align:middle
因为除了别的东西之外
用户还会搜索与自己相关的内容

00:20:48.849 --> 00:20:51.852 align:middle
这种情况将会造成用户对我们丧失信任

00:20:52.920 --> 00:20:55.556 align:middle
比如在这个例子中标识符是匿名的

00:20:55.622 --> 00:20:58.926 align:middle
它是123.但是我们可以
从中看出许多事实

00:20:59.359 --> 00:21:02.229 align:middle
用户123正在考虑订婚

00:20:59.359 --> 00:21:02.229 align:middle
用户123正在考虑订婚

00:21:02.596 --> 00:21:04.031 align:middle
可能在过去的周六

00:21:04.531 --> 00:21:06.867 align:middle
他们可能并不是来自圣弗朗西斯科

00:21:06.934 --> 00:21:08.735 align:middle
因为他们在寻找来自
圣弗朗西斯科的航班

00:21:09.069 --> 00:21:10.237 align:middle
他们可能要去WWDC

00:21:10.404 --> 00:21:14.041 align:middle
他们可能是
John Appleseed

00:21:14.241 --> 00:21:16.143 align:middle
他们可能对
John Appleseed很感兴趣

00:21:16.210 --> 00:21:19.012 align:middle
我们并不能确定但一旦知道了更多信息

00:21:19.079 --> 00:21:21.215 align:middle
我们能清晰得判断出真相

00:21:21.648 --> 00:21:25.819 align:middle
另一方面如果你的搜索服务
使用了可切换标识符

00:21:26.119 --> 00:21:27.487 align:middle
即使数据泄露了

00:21:27.721 --> 00:21:30.424 align:middle
对用户隐私安全的损害也被最小化

00:21:30.824 --> 00:21:32.392 align:middle
因为标识符在不断改变

00:21:32.860 --> 00:21:35.829 align:middle
在这个例子中
如果标识符每15分钟变换一次

00:21:36.296 --> 00:21:40.167 align:middle
我们就不能确定用户
123和用户456或者用户789

00:21:40.901 --> 00:21:42.069 align:middle
其实是同一个人

00:21:45.138 --> 00:21:47.474 align:middle
所以我要谈论一下固定标识符

00:21:48.041 --> 00:21:51.144 align:middle
由于他们能对用户提供长期跟踪

00:21:51.211 --> 00:21:53.080 align:middle
危害了用户隐私安全

00:21:53.714 --> 00:21:56.817 align:middle
所以它们在IOS和
watchOS中不再被设计使用

00:21:58.619 --> 00:22:00.721 align:middle
苹果想为用户提供惊喜和愉悦的体验

00:21:58.619 --> 00:22:00.721 align:middle
苹果想为用户提供惊喜和愉悦的体验

00:22:00.921 --> 00:22:03.557 align:middle
但如果不经过用户的同意而追踪他们
用户不会感到开心

00:22:04.024 --> 00:22:05.859 align:middle
这并不符合用户的心理预期

00:22:05.993 --> 00:22:08.629 align:middle
如果他们在同一标识符下
被一个app追踪

00:22:09.229 --> 00:22:11.565 align:middle
即使当他们卸载了
app并进行重新配置

00:22:11.632 --> 00:22:13.267 align:middle
或者采用其它更具破坏力的操作行为

00:22:13.734 --> 00:22:14.835 align:middle
比如擦除手机记录

00:22:16.570 --> 00:22:19.306 align:middle
但最终因为固定标识符是永久不变的

00:22:19.806 --> 00:22:21.341 align:middle
用户并不能对此进行改变

00:22:21.942 --> 00:22:23.277 align:middle
就像姬蒂之前说过的

00:22:23.343 --> 00:22:26.580 align:middle
我们认为让用户拥有更多的控制权
对隐私安全是非常重要的

00:22:29.016 --> 00:22:31.985 align:middle
为了在开发者对标识数据的需求

00:22:32.519 --> 00:22:34.354 align:middle
同保护用户隐私之间做权衡

00:22:34.788 --> 00:22:37.658 align:middle
我们在IOS平台建立了
一系列有目的作用域的标识符

00:22:37.891 --> 00:22:39.993 align:middle
让开发者可以收集他们需要的数据

00:22:40.294 --> 00:22:42.496 align:middle
投入进分析和智能广告环境中

00:22:42.696 --> 00:22:46.600 align:middle
同时用户也可以通过控制标识符的重置

00:22:46.900 --> 00:22:49.703 align:middle
来打破他们当前的行为记录

00:22:50.037 --> 00:22:51.338 align:middle
和被收集的历史数据

00:22:51.839 --> 00:22:53.307 align:middle
之间的关联

00:22:54.341 --> 00:22:55.876 align:middle
在app层级上

00:22:56.076 --> 00:22:59.079 align:middle
在用户从某个给定
team ID卸载了所有app之后

00:22:59.513 --> 00:23:03.083 align:middle
我们可以通过重置vendor
标识符和IDFV来实现

00:22:59.513 --> 00:23:03.083 align:middle
我们可以通过重置vendor
标识符和IDFV来实现

00:23:04.284 --> 00:23:08.722 align:middle
在广告环境中我们给用户
重置广告标识符的权利

00:23:09.156 --> 00:23:11.925 align:middle
可以通过依次选择“Settings”
“Privacy”和“Advertising”

00:23:11.992 --> 00:23:14.995 align:middle
再点击
“Reset Advertisement Identifier”

00:23:15.062 --> 00:23:18.632 align:middle
来重置广告标识符
因此用户可以轻易重置手机中的标识符

00:23:18.899 --> 00:23:23.904 align:middle
不用擦除任何数据就可以打破
和被收集的历史数据之间的联系

00:23:25.739 --> 00:23:27.140 align:middle
在watchOS 1中

00:23:28.108 --> 00:23:30.177 align:middle
vendor ID和广告ID

00:23:30.477 --> 00:23:35.182 align:middle
在iPhone中是作为
WatchKit运行的扩展而存在的

00:23:35.782 --> 00:23:36.950 align:middle
在watchOS 2中

00:23:37.217 --> 00:23:41.121 align:middle
你需要从iPhone中
把vendor ID和广告ID

00:23:41.555 --> 00:23:42.956 align:middle
同步到Watch上使用

00:23:43.323 --> 00:23:47.094 align:middle
你需要维持vendor ID
和广告ID的同步更新

00:23:49.162 --> 00:23:50.797 align:middle
所以现在我将要回顾一些最佳方法

00:23:51.798 --> 00:23:53.400 align:middle
确定你需要一个标识符

00:23:53.934 --> 00:23:56.570 align:middle
你可以只发送一个值
然后在服务器端记录增量吗？

00:23:57.137 --> 00:24:00.307 align:middle
通过标识符来收集信息带来责任的同时

00:23:57.137 --> 00:24:00.307 align:middle
通过标识符来收集信息带来责任的同时

00:24:00.374 --> 00:24:01.308 align:middle
也带来了风险

00:24:01.875 --> 00:24:03.777 align:middle
如果你可以仅在增量数据中收集值

00:24:03.844 --> 00:24:06.113 align:middle
那么就增加了用户隐私安全

00:24:06.446 --> 00:24:08.081 align:middle
也为你自己的数据收集降低了风险

00:24:09.316 --> 00:24:11.485 align:middle
使用合适的标识符作用范围

00:24:11.985 --> 00:24:14.955 align:middle
确定当你真的需要
标识一个会话一个用户

00:24:15.322 --> 00:24:19.193 align:middle
或者一个设备就根据你app的目的
来选择标识符作用范围

00:24:20.961 --> 00:24:22.996 align:middle
iOS 和 watchOS
提供了一些标识符

00:24:23.063 --> 00:24:25.532 align:middle
所以可以直接使用它们
不用新建你自己的标识符

00:24:26.333 --> 00:24:28.035 align:middle
试着建立一个永久标识符

00:24:28.535 --> 00:24:31.405 align:middle
它的值不因手机重置
或者其他毁灭性的操作

00:24:31.471 --> 00:24:32.439 align:middle
比如移除你的app

00:24:32.739 --> 00:24:35.409 align:middle
而改变这既不利于保护
用户隐私也不利于你的app运行

00:24:35.809 --> 00:24:39.513 align:middle
如果你在使用私有API
来建立一个永久标识符

00:24:39.746 --> 00:24:41.615 align:middle
你已违反了APP Store的条例

00:24:41.748 --> 00:24:43.116 align:middle
这将带来许多不良后果

00:24:44.551 --> 00:24:47.821 align:middle
最后要遵循设计标识符的基本原则

00:24:47.888 --> 00:24:51.825 align:middle
其中你该遵循的最重要的原则之一就是

00:24:52.192 --> 00:24:55.128 align:middle
在你调用广告标识符之前

00:24:55.195 --> 00:24:57.865 align:middle
检查一下Limit
Ad Tracking的值

00:24:57.931 --> 00:25:00.067 align:middle
同时要时刻跟踪广告标识符的当前值

00:24:57.931 --> 00:25:00.067 align:middle
同时要时刻跟踪广告标识符的当前值

00:25:00.834 --> 00:25:04.338 align:middle
用户可以在任意时间
重置广告标识符的值

00:25:04.771 --> 00:25:10.611 align:middle
此外授权广告跟踪的操作
也造成了广告标识符的重置

00:25:11.245 --> 00:25:16.617 align:middle
正因为这个你需要保证自己知晓当前值
并且不要把它存在cache里

00:25:17.684 --> 00:25:19.419 align:middle
最后我们谈一点报告相关的问题

00:25:19.953 --> 00:25:22.389 align:middle
我们知道在座许多都有
给合作伙伴提供报告的义务

00:25:22.623 --> 00:25:24.525 align:middle
但是我们认为在给第三方提供报告时

00:25:24.591 --> 00:25:27.261 align:middle
维护用户隐私是非常重要的

00:25:27.961 --> 00:25:30.063 align:middle
我们考虑了许多如何做
和用户有关的报告的问题

00:25:30.130 --> 00:25:33.800 align:middle
你们也能看到我们把许多机器学习的
部分嵌入到了App Analytics中

00:25:34.935 --> 00:25:38.272 align:middle
在提供报告的过程中
主要有三种重要的思想

00:25:38.805 --> 00:25:40.908 align:middle
和用户相关的报告所处的视野

00:25:41.074 --> 00:25:42.176 align:middle
报告的聚合

00:25:42.543 --> 00:25:43.377 align:middle
以及设定一个阈值

00:25:44.178 --> 00:25:45.812 align:middle
我所说的报告的视野是什么意思呢？

00:25:46.513 --> 00:25:49.850 align:middle
对于合作伙伴来说比起想了解

00:25:50.417 --> 00:25:52.853 align:middle
是哪些人在频繁得使用你的app

00:25:52.920 --> 00:25:56.690 align:middle
以及提供所有关于app
用量的数据来让他们计算

00:25:57.157 --> 00:26:00.694 align:middle
他们更想在确定计算方式定义的基础上

00:25:57.157 --> 00:26:00.694 align:middle
他们更想在确定计算方式定义的基础上

00:26:01.161 --> 00:26:03.897 align:middle
让我们基于数据进行计算

00:26:04.398 --> 00:26:07.401 align:middle
提供计算结果而不是递过去原始数据

00:26:08.569 --> 00:26:11.705 align:middle
保护用户隐私的下一步是做聚合

00:26:12.072 --> 00:26:14.975 align:middle
比起说出哪些用户是重度用户

00:26:15.042 --> 00:26:17.177 align:middle
不如说出你有多少个重度用户

00:26:17.244 --> 00:26:18.912 align:middle
他们在整个群体中占多大比例

00:26:19.646 --> 00:26:22.182 align:middle
最后报告中需要设定阈值

00:26:22.749 --> 00:26:25.052 align:middle
如果你要在报告中写你有一个重度用户

00:26:25.319 --> 00:26:27.087 align:middle
而你的app只有一个用户

00:26:27.287 --> 00:26:29.389 align:middle
如果你以对待群体用户的
方式来提供用户信息

00:26:29.456 --> 00:26:31.491 align:middle
比如提供邮政编码

00:26:32.059 --> 00:26:34.027 align:middle
那你就暴露了你的用户

00:26:34.194 --> 00:26:36.029 align:middle
在你提供用户信息之前要设置一个阈值

00:26:36.597 --> 00:26:40.400 align:middle
确定你不会暴露用户隐私
应该让他们以群体的形式出现

00:26:42.669 --> 00:26:46.507 align:middle
我将会讲一些关于如何
提示用户数据的最优方法

00:26:46.573 --> 00:26:51.178 align:middle
先讲在Watch平台的给大家提提神
再延伸到IOS和OS X中

00:26:51.512 --> 00:26:53.413 align:middle
当你想要接触到数据类的时候

00:26:53.847 --> 00:26:56.316 align:middle
操作系统不会直接提供给你数据

00:26:56.717 --> 00:26:59.386 align:middle
直到用户选择了是否能

00:26:59.853 --> 00:27:01.622 align:middle
让你的app获取接收数据的权限才行

00:26:59.853 --> 00:27:01.622 align:middle
让你的app获取接收数据的权限才行

00:27:03.323 --> 00:27:06.293 align:middle
所以用户可以知道
app用这些数据做些什么

00:27:06.360 --> 00:27:09.329 align:middle
因此你对数据的收集和使用
对用户来说就变成了透明的过程

00:27:09.663 --> 00:27:11.498 align:middle
因此我们在提示中提供了这样一个空间

00:27:11.565 --> 00:27:12.966 align:middle
你可以在这里向用户解释说明

00:27:13.667 --> 00:27:14.902 align:middle
这就叫做目的字符串

00:27:15.202 --> 00:27:17.538 align:middle
你可以针对多种受保护的数据类

00:27:17.604 --> 00:27:20.274 align:middle
把他们设置进你的app
和Info.plist中

00:27:20.340 --> 00:27:23.443 align:middle
我们认为如果用户理解
为什么你们想获得数据访问权限

00:27:23.710 --> 00:27:26.146 align:middle
他们就更有可能做出正确的选择

00:27:28.916 --> 00:27:32.553 align:middle
就像姬蒂之前说过的那样
提防着有限的“不动产”的可用性

00:27:33.120 --> 00:27:35.589 align:middle
让我们的意图变得透明增加用户控制

00:27:36.023 --> 00:27:38.926 align:middle
我们考虑过Watch上的app
如何获取用户数据的问题

00:27:39.860 --> 00:27:42.829 align:middle
首先就像在IOS和OS X中那样

00:27:43.597 --> 00:27:46.300 align:middle
watchOS上的app
并不能直接获取用户数据

00:27:46.600 --> 00:27:48.001 align:middle
直到获得用户的允许

00:27:49.536 --> 00:27:52.706 align:middle
然而和IOS和OS X
不同的是在watchOS上

00:27:52.773 --> 00:27:56.376 align:middle
用户不能选择接受
或拒绝设备本身发出的即时提示

00:27:57.244 --> 00:27:59.012 align:middle
或者说那些是指向iPhone的

00:27:59.379 --> 00:28:03.350 align:middle
正如姬蒂所说我们可以把
iPhone和与其配对的Watch

00:27:59.379 --> 00:28:03.350 align:middle
正如姬蒂所说我们可以把
iPhone和与其配对的Watch

00:28:03.750 --> 00:28:07.020 align:middle
视作紧密相连的用户
在其中一个平台上做出的

00:28:07.087 --> 00:28:09.590 align:middle
关于隐私处理的决策将会
影响到另一个设备

00:28:10.190 --> 00:28:11.959 align:middle
在watch中限定“不动产”

00:28:12.092 --> 00:28:14.962 align:middle
我们认为比起在
iPhone上面做要更有意义

00:28:15.729 --> 00:28:18.632 align:middle
在iPhone端用户在更大的
屏幕上看到提示信息

00:28:18.932 --> 00:28:20.234 align:middle
其中包括目的字符串

00:28:20.300 --> 00:28:24.771 align:middle
它可以清楚得说明为何你的iPhone app
和Watch app想要获得访问数据的权限

00:28:25.706 --> 00:28:27.908 align:middle
不像在IOS端你可以选择是或者否

00:28:28.342 --> 00:28:30.244 align:middle
你可以选择提示或者解散

00:28:30.377 --> 00:28:33.347 align:middle
当你做提示设置时
用户不能在watch中做出选择

00:28:33.614 --> 00:28:35.782 align:middle
因此会停留在一种未设置的状态

00:28:36.517 --> 00:28:39.520 align:middle
在这种未设置的状态
你将会稍后进行提示

00:28:40.654 --> 00:28:43.123 align:middle
举一个未设置状态的例子吧

00:28:43.557 --> 00:28:46.293 align:middle
用户可以带着Watch
去跑步而不是Phone

00:28:46.894 --> 00:28:48.595 align:middle
所以把你的app安装在Watch上

00:28:48.962 --> 00:28:49.963 align:middle
你的app将会提示

00:28:50.464 --> 00:28:51.665 align:middle
这种提示将会被消除

00:28:52.032 --> 00:28:53.867 align:middle
而你的应用将会

00:28:54.101 --> 00:28:55.802 align:middle
在没有数据访问权限的
情况下继续运行

00:28:56.336 --> 00:29:00.374 align:middle
但是在下一个时间节点
你的app将会再次提示

00:28:56.336 --> 00:29:00.374 align:middle
但是在下一个时间节点
你的app将会再次提示

00:29:02.376 --> 00:29:06.547 align:middle
现在如姬蒂之前说的
这些设置包括你的隐私设置

00:29:07.080 --> 00:29:09.316 align:middle
都是在Watch和iPhone上共享的

00:29:10.117 --> 00:29:12.419 align:middle
我们认为用户和你的
应用之间有单一的联系

00:29:12.786 --> 00:29:14.621 align:middle
与iPhone之间有单一的联系

00:29:14.688 --> 00:29:16.256 align:middle
与Watch之间有单一的联系

00:29:16.323 --> 00:29:18.325 align:middle
因此我们可以把
这些单一的联系组合起来

00:29:18.392 --> 00:29:21.328 align:middle
变成一种在iPhone
在watch在你的app中的设置

00:29:22.229 --> 00:29:24.698 align:middle
而这存在于我们平台里的其他地方

00:29:24.898 --> 00:29:27.935 align:middle
在IOS端如果用户对你的
app做出了关于隐私处理的决定

00:29:28.302 --> 00:29:30.637 align:middle
使得你的app的所有
进程都有获取那些数据的权限

00:29:31.171 --> 00:29:32.673 align:middle
如果你在app中提示了地理位置

00:29:33.173 --> 00:29:36.844 align:middle
你的扩展应用也可以使用它

00:29:36.910 --> 00:29:40.480 align:middle
如果用户是在app
扩展中首次进行提示

00:29:40.814 --> 00:29:42.950 align:middle
那么整个app
也将获得访问数据的权限

00:29:44.384 --> 00:29:48.689 align:middle
在Watch平台上用户做出的决定

00:29:48.989 --> 00:29:52.659 align:middle
对所有的watch中的app
对原有app以及你的Glance

00:29:53.126 --> 00:29:54.728 align:middle
还有你的Complication
来说都是有效的

00:29:55.229 --> 00:29:57.631 align:middle
当用户给你app的一部分提供许可

00:29:57.698 --> 00:29:59.900 align:middle
就相当于对你app的所有
部分都给予了许可

00:30:01.635 --> 00:30:05.772 align:middle
现在你知道在IOS,OS X和watchOS中
我们对什么数据有访问权限了

00:30:05.839 --> 00:30:07.975 align:middle
以及我们该如何提示它们

00:30:08.041 --> 00:30:11.345 align:middle
我们认为一旦用户在这些
平台上提供了数据访问权限

00:30:12.579 --> 00:30:14.648 align:middle
考虑如何保护它们是非常重要的

00:30:15.015 --> 00:30:17.484 align:middle
这里有一些你应该利用
和清楚的一些新的安全功能

00:30:17.985 --> 00:30:20.521 align:middle
第一个就是App传输安全

00:30:20.988 --> 00:30:23.056 align:middle
为了在默认情况下保证用户交流的安全

00:30:23.457 --> 00:30:25.392 align:middle
我们引入了App传输安全体系

00:30:25.759 --> 00:30:28.295 align:middle
在IOS 9和OS X
EI Capitan平台应用

00:30:28.896 --> 00:30:32.299 align:middle
在默认情况下你们在更高
层级的API中的交流

00:30:32.366 --> 00:30:35.669 align:middle
会需要用TLS 1.2版的
加密方式来实现保密性

00:30:36.170 --> 00:30:40.741 align:middle
如果你尝试进行的连接违反了这些要求

00:30:41.175 --> 00:30:42.276 align:middle
将会出现报错

00:30:43.877 --> 00:30:46.547 align:middle
如果你的app需要
向非安全域发送请求

00:30:46.780 --> 00:30:49.750 align:middle
你必须在你app中的
Info.plist中指定这个区域

00:30:50.384 --> 00:30:52.486 align:middle
如果想了解一下细节

00:30:52.553 --> 00:30:57.491 align:middle
可以关注一下明天上午9点的
NSURL会话与网络方面的演讲

00:30:57.558 --> 00:30:59.426 align:middle
或者关注今天下午的安全性演讲

00:31:01.728 --> 00:31:04.031 align:middle
如果你真的想在APP
传输安全体系中声明一个特例

00:31:04.097 --> 00:31:07.134 align:middle
你需要在你app中的
Info.plist中声明然后随意

00:31:07.201 --> 00:31:09.236 align:middle
设置一个或更多的这种密钥

00:31:12.773 --> 00:31:15.142 align:middle
现在我要谈论一下奖励卡的问题

00:31:15.943 --> 00:31:19.713 align:middle
在IOS 9系统奖励卡可以
出现在联系人列表中

00:31:20.047 --> 00:31:22.616 align:middle
我们知道有些奖励卡使用了
用户的电话号码

00:31:22.683 --> 00:31:25.052 align:middle
邮箱地址或者其他
个人指向性明显的数据

00:31:25.419 --> 00:31:27.221 align:middle
来作为奖励卡的标识符

00:31:27.821 --> 00:31:32.226 align:middle
所以为了在奖励卡以及联系
人列表的传输中保护用户的隐私

00:31:33.060 --> 00:31:35.963 align:middle
我们给开发者提供了一种简单的方式

00:31:36.230 --> 00:31:38.332 align:middle
在遍历联系人列表时加密数据

00:31:39.333 --> 00:31:42.135 align:middle
你所要做的就是修改你的
pass.json

00:31:42.202 --> 00:31:45.806 align:middle
用这个新的nfc字典

00:31:46.340 --> 00:31:49.109 align:middle
你可以指定信息标识符和你的公钥

00:31:49.576 --> 00:31:53.313 align:middle
从这开始当在非
接触支付中用到奖励卡时

00:31:53.614 --> 00:31:56.817 align:middle
IOS会谨慎得为你加密信息

00:31:58.352 --> 00:32:01.622 align:middle
随着IOS9中App搜索App历史
记录和App链接的应用

00:31:58.352 --> 00:32:01.622 align:middle
随着IOS9中App搜索App历史
记录和App链接的应用

00:32:01.722 --> 00:32:05.292 align:middle
这意味着你可以存储一些和你的app
有关以及在你app之外的信息

00:32:05.726 --> 00:32:07.861 align:middle
因此你需要做一个好管家

00:32:07.928 --> 00:32:11.598 align:middle
为用户保护好数据
这不仅包括位于你app里的数据

00:32:12.032 --> 00:32:14.168 align:middle
还包括在你app之外存储的数据

00:32:15.736 --> 00:32:18.672 align:middle
在星期三上午11点会有
一个很不错的演讲介绍这方面

00:32:18.739 --> 00:32:21.308 align:middle
到时候可以去听一下
他们讲的要比我更深入些

00:32:21.375 --> 00:32:23.744 align:middle
我将简单得讲一下
app的两种数据索引方式

00:32:23.977 --> 00:32:26.413 align:middle
以及它们在隐私保护方面所起到的作用

00:32:28.015 --> 00:32:29.816 align:middle
第一个是
NSUserActivity

00:32:29.883 --> 00:32:32.886 align:middle
它是一个为了支持
Handoff而被引入IOS8平台中的API

00:32:33.420 --> 00:32:36.657 align:middle
在IOS 9中我们对其进行了扩展

00:32:36.757 --> 00:32:39.326 align:middle
所以你可以使用
NSUserActivity在你的app中

00:32:39.393 --> 00:32:41.295 align:middle
建立索引视图让用户可以
回到那个地方搜索

00:32:41.662 --> 00:32:43.564 align:middle
比如在你的食谱app中

00:32:43.897 --> 00:32:47.301 align:middle
当用户看到一个干酪浇肉汁
土豆条的食谱时

00:32:47.367 --> 00:32:49.903 align:middle
你可以在视图中建立一个
NSUserActivity并将其索引

00:32:49.970 --> 00:32:53.373 align:middle
然后用户再次在手机里
搜索干酪浇肉汁土豆条的时候

00:32:53.640 --> 00:32:54.942 align:middle
显示出来的结果就包括

00:32:55.008 --> 00:32:56.677 align:middle
他们曾经看到过的这个链接

00:32:57.511 --> 00:33:01.515 align:middle
在未来它可以帮助我们解放双手
而不需要其他机器

00:32:57.511 --> 00:33:01.515 align:middle
在未来它可以帮助我们解放双手
而不需要其他机器

00:33:03.817 --> 00:33:06.386 align:middle
我们从最开始就思考
如何让搜索变得更注重保护隐私

00:33:07.588 --> 00:33:11.191 align:middle
我们之前所做的包括
把默认设置为非索引数据

00:33:12.159 --> 00:33:12.993 align:middle
这是非常正确的

00:33:13.060 --> 00:33:16.330 align:middle
在默认情况下NSUserActivity
将继续为Handoff提供支持

00:33:16.396 --> 00:33:18.232 align:middle
如果你想制作可搜索的视图

00:33:18.665 --> 00:33:21.802 align:middle
你必须得把eligibleForSearch
属性设置为真

00:33:22.469 --> 00:33:25.038 align:middle
如果你想把那个
视图变成公开索引...

00:33:25.105 --> 00:33:26.507 align:middle
那个我们一会儿将要提到...

00:33:27.241 --> 00:33:31.345 align:middle
你需要做的也是把
eligibleForPublicIndexing

00:33:31.411 --> 00:33:32.246 align:middle
值设置为真

00:33:33.413 --> 00:33:34.982 align:middle
此外还有一个你需要设置的值

00:33:35.048 --> 00:33:38.018 align:middle
如果你想把数据变成可变址的
需要用到expirationDate

00:33:38.085 --> 00:33:39.620 align:middle
正如姬蒂之前提到的那样

00:33:40.153 --> 00:33:42.556 align:middle
保护用户数据是保护
用户隐私的重要组成部分

00:33:42.623 --> 00:33:45.459 align:middle
这可以通过删除数据与用户
之间的关联来完成

00:33:49.663 --> 00:33:52.900 align:middle
现在我将要谈一点关于
NSUserActivity和公开索引的问题

00:33:53.567 --> 00:33:56.270 align:middle
NSUserActivity
是一种很好用的简单方式

00:33:56.336 --> 00:33:57.671 align:middle
它让你的app变得可以搜索

00:33:58.205 --> 00:34:01.742 align:middle
我们提高索引方面的隐私安全
就是通过在默认情况下不进行索引

00:33:58.205 --> 00:34:01.742 align:middle
我们提高索引方面的隐私安全
就是通过在默认情况下不进行索引

00:34:01.808 --> 00:34:06.647 align:middle
让开发者来决定是否要在
特定视图中添加索引

00:34:08.681 --> 00:34:12.719 align:middle
但是我们知道许多开发者想要添加一些

00:34:13.053 --> 00:34:15.289 align:middle
在所有设备中都能搜索到的公开内容

00:34:16.389 --> 00:34:19.126 align:middle
为了实现这一点
我们想出了这样一种方法

00:34:19.193 --> 00:34:22.161 align:middle
就是在保护用户安全的同时
为附加数据提供索引

00:34:23.597 --> 00:34:26.500 align:middle
当你创建了一个可搜索视图

00:34:26.934 --> 00:34:28.969 align:middle
把它标记为公共索引

00:34:29.335 --> 00:34:31.605 align:middle
如果它只包含可公开内容的话

00:34:32.505 --> 00:34:35.876 align:middle
然后当用户搜索这一视图并且使用它时

00:34:36.143 --> 00:34:38.011 align:middle
这一视图的散表
就被发送到Apple中

00:34:39.580 --> 00:34:41.181 align:middle
在经过多重设备之后

00:34:41.581 --> 00:34:44.217 align:middle
创建视图的散表并发到Apple里

00:34:45.252 --> 00:34:47.588 align:middle
最后当超过阈值时

00:34:48.889 --> 00:34:51.225 align:middle
真实视图将会被发送到Apple里

00:34:51.958 --> 00:34:57.063 align:middle
正是因为这个原因偶然被标记为公开的
视图并不会无意间被发送出去

00:34:59.032 --> 00:35:00.300 align:middle
这就是NSUserActivity

00:34:59.032 --> 00:35:00.300 align:middle
这就是NSUserActivity

00:35:00.367 --> 00:35:02.870 align:middle
现在我要讲一点关于
CoreSpotlight的内容

00:35:03.036 --> 00:35:05.973 align:middle
CoreSpotlight是
IOS 9中新增的一种API

00:35:06.039 --> 00:35:08.308 align:middle
它使得你的app中的用户内容可搜索

00:35:08.609 --> 00:35:10.978 align:middle
比如邮箱 联系人 日历等

00:35:11.411 --> 00:35:12.980 align:middle
这些是派生数据

00:35:13.313 --> 00:35:16.884 align:middle
你需要像保护你app中的
基础数据那样保护它们

00:35:17.651 --> 00:35:20.187 align:middle
首先是要加入数据保护类

00:35:20.587 --> 00:35:22.389 align:middle
就像你对app中的数据所做的那样

00:35:23.690 --> 00:35:27.060 align:middle
接下来要用索引中的派生数据

00:35:27.127 --> 00:35:28.795 align:middle
来实现数据管理

00:35:29.229 --> 00:35:31.865 align:middle
你可以存储--首先你
应该存储相关的用户数据

00:35:32.232 --> 00:35:35.602 align:middle
比如有没有人需要
看草稿或者删除文档？

00:35:37.738 --> 00:35:39.773 align:middle
当用户在你的app中更新文档的时候

00:35:39.840 --> 00:35:42.176 align:middle
你应该在索引中更新
这些文档的拷贝文件

00:35:43.010 --> 00:35:44.811 align:middle
在用户在你的app中
删除文档的时候

00:35:44.912 --> 00:35:46.747 align:middle
你应该在索引中也删除文档

00:35:46.813 --> 00:35:49.183 align:middle
由于用户有多种在app中
删除文档的方式

00:35:49.249 --> 00:35:51.018 align:middle
像是删除所有类型的文件

00:35:51.251 --> 00:35:53.987 align:middle
或者一个我们把它的
多种条目变得易于删除的文件夹

00:35:54.054 --> 00:35:57.324 align:middle
直接删除或者先搜索再删除

00:35:58.425 --> 00:36:03.030 align:middle
这是一个简要的概述
介绍了IOS 9中新的隐私保护特性

00:35:58.425 --> 00:36:03.030 align:middle
这是一个简要的概述
介绍了IOS 9中新的隐私保护特性

00:36:03.163 --> 00:36:05.199 align:middle
接下来再由姬蒂介绍

00:36:05.265 --> 00:36:08.368 align:middle
一些你们如果没有用过
可以去尝试一下的已有技术

00:36:15.442 --> 00:36:16.276 align:middle
感谢傑森

00:36:16.977 --> 00:36:19.413 align:middle
我想强调几个已有的技术

00:36:19.479 --> 00:36:22.282 align:middle
它们让保护用户信息变得容易

00:36:22.616 --> 00:36:24.451 align:middle
你不需要自己去写一些

00:36:24.952 --> 00:36:26.486 align:middle
基本的东西

00:36:28.989 --> 00:36:31.425 align:middle
Touch Id是用来保护你的
app的一种很好的方式

00:36:31.491 --> 00:36:33.393 align:middle
它也能保护你app中的数据

00:36:34.228 --> 00:36:38.165 align:middle
你可以使用app中的
Apple Pay来实现它

00:36:38.265 --> 00:36:40.367 align:middle
而不需要创建或者接收

00:36:40.434 --> 00:36:43.337 align:middle
用户的一些基本信息以及信用卡信息

00:36:44.505 --> 00:36:46.073 align:middle
现在我要深入得讲一下

00:36:46.340 --> 00:36:48.742 align:middle
隐私策略和数据保护方面的内容

00:36:49.610 --> 00:36:53.514 align:middle
在研究保护你的用户信息的技术之外

00:36:54.047 --> 00:36:56.583 align:middle
向用户解释你对他们的数据做了什么

00:36:56.650 --> 00:36:59.920 align:middle
也是非常重要的
如果你想和第三方分享数据的话

00:37:01.154 --> 00:37:04.958 align:middle
我们实际上需要对几种固定
类型的应用实施隐私保护策略

00:37:05.526 --> 00:37:07.628 align:middle
其中包括和
HealthKit相连接的app

00:37:08.228 --> 00:37:11.331 align:middle
我们把引入隐私策略变得非常容易

00:37:12.165 --> 00:37:14.535 align:middle
在iTunes连接中你只需要输入URL

00:37:14.835 --> 00:37:18.205 align:middle
它就会在你所有的
App Store中显示

00:37:18.305 --> 00:37:20.908 align:middle
它给用户一个在做购买决策之前

00:37:21.308 --> 00:37:23.010 align:middle
阅读隐私策略的机会

00:37:23.544 --> 00:37:27.014 align:middle
你可以使用IOS中的创建数据保护类

00:37:27.181 --> 00:37:30.551 align:middle
来为你的数据进行加密
其密钥源于用户的登录密码

00:37:31.585 --> 00:37:33.520 align:middle
这种加密技术有着惊人的力量

00:37:34.121 --> 00:37:38.091 align:middle
你可以轻松得利用它的优势
不需要自己写任何加密码

00:37:39.893 --> 00:37:42.596 align:middle
现在 每个IOS设备

00:37:43.397 --> 00:37:48.001 align:middle
都通过密钥层级管理来实施数据保护

00:37:49.002 --> 00:37:50.704 align:middle
它建立在硬件加密的基础上

00:37:50.871 --> 00:37:53.841 align:middle
应用于所有的IOS
和watchOS设备

00:37:54.942 --> 00:37:57.744 align:middle
数据保护是由每个基础文件来控制的

00:37:58.245 --> 00:38:00.113 align:middle
每个文件都被赋予一个类

00:37:58.245 --> 00:38:00.113 align:middle
每个文件都被赋予一个类

00:38:01.348 --> 00:38:06.119 align:middle
这些类是否被解锁
决定了访问权限是否开启

00:38:07.888 --> 00:38:11.291 align:middle
这里有四种数据类我将依次进行介绍

00:38:11.892 --> 00:38:13.994 align:middle
但是你最要清楚的一点是

00:38:14.061 --> 00:38:17.998 align:middle
Ns文件保护直到出现
第一个认证时才完成

00:38:18.632 --> 00:38:19.967 align:middle
在IOS 7中

00:38:20.667 --> 00:38:24.404 align:middle
所有的第三方app
数据都默认成这种数据类

00:38:25.305 --> 00:38:29.243 align:middle
如今你的app
在启动之前是不能运行的

00:38:29.309 --> 00:38:31.411 align:middle
直到用户输入他们的密码

00:38:32.179 --> 00:38:35.115 align:middle
所以至少你的数据会
经过以上过程的保护

00:38:36.183 --> 00:38:39.353 align:middle
我们知道有些开发者
并没有使用任何数据保护措施

00:38:39.753 --> 00:38:42.789 align:middle
因为那样做是没有任何理由
也没有任何价值的

00:38:45.792 --> 00:38:48.862 align:middle
所以我要迅速得介绍一下
这种模式中的几种不同的数据类

00:38:48.962 --> 00:38:50.831 align:middle
正如你所见在没有任何保护的情况下

00:38:51.265 --> 00:38:53.333 align:middle
即使用户输入了密码或者没有输入

00:38:53.800 --> 00:38:56.904 align:middle
数据都是没被上锁的数据很容易被获取

00:38:57.871 --> 00:39:01.775 align:middle
最后直到出现第一个认证
之前它们被保护的

00:38:57.871 --> 00:39:01.775 align:middle
最后直到出现第一个认证
之前它们被保护的

00:39:02.209 --> 00:39:05.512 align:middle
这就是你的默认类

00:39:06.580 --> 00:39:09.149 align:middle
现在这在启动中是不可访问的

00:39:09.616 --> 00:39:11.785 align:middle
但是一旦用户输入密码

00:39:12.085 --> 00:39:16.089 align:middle
所有数据都变得可用
即使设备加锁了数据依旧可用

00:39:18.025 --> 00:39:20.227 align:middle
下一个数据就会一直
被保护只到开放为止

00:39:20.594 --> 00:39:25.699 align:middle
这种设计面向的对象是
对设备上锁敏感的数据

00:39:26.466 --> 00:39:30.003 align:middle
所以这里有两种操作类型读和写

00:39:30.771 --> 00:39:34.074 align:middle
一旦设备启动了就关闭了数据访问权限

00:39:34.441 --> 00:39:35.809 align:middle
用户输入了密码后

00:39:36.243 --> 00:39:38.212 align:middle
你可以同时读写

00:39:38.846 --> 00:39:40.047 align:middle
当设备再次上锁

00:39:40.681 --> 00:39:43.817 align:middle
你不能读数据但你依旧可以写数据

00:39:45.219 --> 00:39:46.987 align:middle
最后我们完成了保护工作

00:39:47.287 --> 00:39:49.590 align:middle
现在对于所有的敏感数据

00:39:49.890 --> 00:39:52.392 align:middle
包括健康数据金融信息

00:39:53.627 --> 00:39:56.930 align:middle
在设备启动之后它们变得不可用

00:39:57.931 --> 00:40:01.235 align:middle
当用户输入了密码数据就变得可用

00:39:57.931 --> 00:40:01.235 align:middle
当用户输入了密码数据就变得可用

00:40:02.202 --> 00:40:05.038 align:middle
当设备上锁数据就不能用了

00:40:06.907 --> 00:40:08.842 align:middle
这将带来一个很大的工作量

00:40:09.109 --> 00:40:11.912 align:middle
来思考你要应用哪种数据保护类

00:40:12.980 --> 00:40:15.782 align:middle
最后确认你已测试过数据保护是可用的

00:40:16.149 --> 00:40:19.620 align:middle
你可以通过这些内容来核查
Settings, Touch ID和Passcode

00:40:19.820 --> 00:40:22.689 align:middle
向下滑动看看你是否启动了数据保护

00:40:24.424 --> 00:40:27.127 align:middle
我们今天讲了许多东西

00:40:27.528 --> 00:40:32.533 align:middle
你需要在IOS
和OS X上测试你的app

00:40:32.833 --> 00:40:34.935 align:middle
你希望理解这些改变所带来的影响

00:40:35.202 --> 00:40:38.872 align:middle
来保证你依旧可以
为用户提供优秀的体验

00:40:39.806 --> 00:40:40.974 align:middle
有目的地提示

00:40:42.276 --> 00:40:45.179 align:middle
确保让数据最小化 保持更新

00:40:46.180 --> 00:40:49.216 align:middle
从一些我们今天讲过的
平台中的技术中获益

00:40:50.184 --> 00:40:54.288 align:middle
最后用户隐私安全是我们共同的责任

00:40:55.189 --> 00:40:58.625 align:middle
我们必须携起手来

00:40:59.193 --> 00:41:02.996 align:middle
我们应该保护用户的隐私权

00:40:59.193 --> 00:41:02.996 align:middle
我们应该保护用户的隐私权

00:41:04.031 --> 00:41:05.165 align:middle
谢谢大家
