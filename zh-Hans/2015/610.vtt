WEBVTT

00:00:20.053 --> 00:00:22.856 align:middle
Metal性能优化技术

00:00:31.532 --> 00:00:32.466 align:middle
早上好

00:00:32.533 --> 00:00:36.170 align:middle
欢迎来到Metal性能优化技术

00:00:36.537 --> 00:00:39.439 align:middle
我是菲利普·班尼特
来自GPU软件性能团队

00:00:39.940 --> 00:00:42.009 align:middle
我们的特别嘉宾

00:00:42.075 --> 00:00:46.847 align:middle
来自GPU软件开发者
技术团队的塞尔哈特·特钦

00:00:46.914 --> 00:00:50.050 align:middle
将为我们展示一个非常棒的新工具

00:00:50.117 --> 00:00:53.053 align:middle
对你的Metal app进行配置
我相信你会喜欢这个工具的

00:00:54.988 --> 00:00:58.625 align:middle
到目前为止WWDC上的Metal

00:00:59.193 --> 00:01:03.130 align:middle
在Metal Part 1
新特性介绍会上

00:00:59.193 --> 00:01:03.130 align:middle
在Metal Part 1
新特性介绍会上

00:01:03.564 --> 00:01:08.368 align:middle
讨论了iOS 9和OS X El
Capitan上Metal的新特性

00:01:10.270 --> 00:01:11.805 align:middle
在Metal Part 2
新特性介绍会上

00:01:11.905 --> 00:01:13.874 align:middle
我们会介绍两个新架构

00:01:13.941 --> 00:01:16.510 align:middle
MetalKit
和Metal性能着色器

00:01:16.877 --> 00:01:19.313 align:middle
让我们更容易开发Metal app

00:01:20.514 --> 00:01:22.482 align:middle
在最后部分

00:01:22.549 --> 00:01:28.322 align:middle
我们将回顾有什么
工具适合调试和分析Metalapp

00:01:28.755 --> 00:01:31.458 align:middle
我们也将探讨
一些关于从Metal app中

00:01:31.525 --> 00:01:33.727 align:middle
获得最佳性能的最优方法

00:01:35.662 --> 00:01:37.164 align:middle
我们来看看工具

00:01:37.364 --> 00:01:38.866 align:middle
Metal调试和分析工具

00:01:38.999 --> 00:01:42.903 align:middle
若你已经在
iOS上做Metal app开发

00:01:42.970 --> 00:01:45.772 align:middle
你应该对Xcode

00:01:45.839 --> 00:01:47.574 align:middle
以及配套Metal工具很熟悉了

00:01:50.978 --> 00:01:52.713 align:middle
现在 我们将快速看一下

00:01:52.779 --> 00:01:54.047 align:middle
框架调试程序

00:01:55.682 --> 00:01:59.253 align:middle
这里是Metal app
中一个单帧捕获

00:02:00.254 --> 00:02:03.790 align:middle
左边是一个框架导航器

00:02:04.291 --> 00:02:07.060 align:middle
显示所有存在于框架内的

00:02:07.528 --> 00:02:08.862 align:middle
状态和Draw调用

00:02:08.929 --> 00:02:14.001 align:middle
渲染编码器命令缓冲器分组

00:02:14.067 --> 00:02:16.370 align:middle
如果你正在使用调试标签

00:02:16.436 --> 00:02:19.907 align:middle
那么调试标签也会对它们进行分组

00:02:21.408 --> 00:02:24.011 align:middle
是渲染attachment视图

00:02:24.077 --> 00:02:26.947 align:middle
显示除任何
深度和网板attachment外

00:02:27.214 --> 00:02:31.618 align:middle
与现有渲染pass有关的所有
color attachment

00:02:32.186 --> 00:02:35.756 align:middle
它显示当前Draw调用的框架高亮区

00:02:36.056 --> 00:02:38.725 align:middle
这让你可以很便利地操纵你的框架

00:02:40.093 --> 00:02:43.463 align:middle
接下来是资源检查器

00:02:43.931 --> 00:02:46.834 align:middle
你可以检查app所用的所有资源

00:02:48.402 --> 00:02:53.040 align:middle
从缓冲器到
纹理到渲染attachment

00:02:53.106 --> 00:02:55.609 align:middle
你可以查看所有不同的格式

00:02:55.676 --> 00:02:59.379 align:middle
分开位图水平 立方形地图

00:02:59.446 --> 00:03:01.982 align:middle
TD阵列 这些特征它都有

00:02:59.446 --> 00:03:01.982 align:middle
TD阵列 这些特征它都有

00:03:04.151 --> 00:03:05.853 align:middle
我们有状态检查器

00:03:06.053 --> 00:03:10.390 align:middle
它可以检查app上
所有Metal对象的属性

00:03:11.825 --> 00:03:15.028 align:middle
继续 我们有GPU报告

00:03:15.095 --> 00:03:17.965 align:middle
用于测量现有框架上的每一帧

00:03:18.699 --> 00:03:21.768 align:middle
并对CPU和GPU进行计时

00:03:22.002 --> 00:03:25.639 align:middle
此外 它也在框架中显示

00:03:25.706 --> 00:03:28.942 align:middle
消耗最大的渲染和计算编码器

00:03:29.510 --> 00:03:32.746 align:middle
以帮助你缩小消耗最大的着色器

00:03:32.813 --> 00:03:34.615 align:middle
和Draw调用的范围

00:03:36.683 --> 00:03:40.754 align:middle
最后 我们有着色器分析器和编辑器

00:03:41.221 --> 00:03:42.789 align:middle
这个工具很棒

00:03:43.156 --> 00:03:46.026 align:middle
可用来调试和分析着色器

00:03:46.326 --> 00:03:49.429 align:middle
因为它可让你在联机中

00:03:49.496 --> 00:03:52.799 align:middle
微调着色器并对他们重新编译

00:03:52.866 --> 00:03:54.835 align:middle
这样你就无需对app重新编译了

00:03:56.270 --> 00:03:58.205 align:middle
你或许已经知道了

00:03:58.272 --> 00:04:00.507 align:middle
所有这些很棒的工具

00:03:58.272 --> 00:04:00.507 align:middle
所有这些很棒的工具

00:04:00.574 --> 00:04:03.677 align:middle
都可用来在OS X El
Capitan试Metal app

00:04:05.712 --> 00:04:09.249 align:middle
工具能够很好协助Xcode的使用

00:04:09.316 --> 00:04:14.188 align:middle
它可以让你
在整个系统中分析app性能

00:04:14.788 --> 00:04:15.923 align:middle
现在 你也可以使用

00:04:15.989 --> 00:04:18.425 align:middle
类似Metal系统寻踪工具的方法

00:04:19.760 --> 00:04:22.896 align:middle
分析Metal的性能

00:04:23.397 --> 00:04:25.966 align:middle
这是iOS 9的一个最新工具

00:04:26.466 --> 00:04:28.569 align:middle
它可让你在CPU和GPU中

00:04:28.635 --> 00:04:30.270 align:middle
分析Metal app

00:04:30.737 --> 00:04:31.839 align:middle
我们来看一下

00:04:33.207 --> 00:04:37.377 align:middle
我们从分析应用中
的Metal API使用开始

00:04:38.679 --> 00:04:42.082 align:middle
然后是驱动程序 再到GPU

00:04:42.149 --> 00:04:44.985 align:middle
在GPU你可以看到单独处理阶段

00:04:45.052 --> 00:04:47.588 align:middle
verse X片段 随机计算

00:04:48.355 --> 00:04:50.290 align:middle
然后到真实的显示器硬件

00:04:52.059 --> 00:04:54.094 align:middle
现在 塞尔哈特·特钦将为我们演示

00:04:54.161 --> 00:04:55.095 align:middle
这个很棒的新工具

00:04:55.162 --> 00:04:58.031 align:middle
有请他上台

00:05:03.737 --> 00:05:05.572 align:middle
谢谢你 菲利普 大家好

00:05:06.607 --> 00:05:09.076 align:middle
今天我想为大家
展示一个非常酷的东西

00:05:09.142 --> 00:05:12.212 align:middle
Metal系统寻踪

00:05:12.446 --> 00:05:15.616 align:middle
Metal系统寻踪是
最新的Metal开发工具

00:05:16.650 --> 00:05:19.286 align:middle
Metal系统寻踪是
Metal iOS app上

00:05:19.353 --> 00:05:22.823 align:middle
一款性能分析和追踪工具

00:05:23.290 --> 00:05:25.092 align:middle
是整套工具的一部分

00:05:26.059 --> 00:05:30.063 align:middle
它让你可以随时
掌握应用的全系统概述

00:05:30.864 --> 00:05:35.569 align:middle
在显卡上 它也可让你获得细分到

00:05:35.636 --> 00:05:37.337 align:middle
微秒的细节信息

00:05:37.404 --> 00:05:39.239 align:middle
我必须强调一下 它很重要

00:05:40.407 --> 00:05:43.377 align:middle
它是首次出现在我们的平台上的

00:05:43.443 --> 00:05:46.847 align:middle
幸亏有了
Xcode 7 和 iOS 9

00:05:47.481 --> 00:05:50.684 align:middle
言归正传 我们继续 来尝试一下

00:05:52.352 --> 00:05:55.222 align:middle
我将启动工具

00:05:55.556 --> 00:05:57.491 align:middle
我们在模板选择器上

00:05:58.425 --> 00:06:01.495 align:middle
你可以看到这里有个新的模板标志

00:05:58.425 --> 00:06:01.495 align:middle
你可以看到这里有个新的模板标志

00:06:01.562 --> 00:06:03.230 align:middle
Metal系统寻踪Metal标志

00:06:03.297 --> 00:06:04.565 align:middle
我将进行选择

00:06:06.433 --> 00:06:08.669 align:middle
对工具很熟悉的人

00:06:08.735 --> 00:06:14.041 align:middle
知道我刚用它当中的四个工具
创建了一个新文件

00:06:14.942 --> 00:06:16.977 align:middle
在时间轴的左手边
可以看到这个文件

00:06:18.045 --> 00:06:20.747 align:middle
我们来快速浏览一下这些工具

00:06:20.814 --> 00:06:22.516 align:middle
和在时间轴中显示的数据

00:06:22.983 --> 00:06:26.553 align:middle
我们继续在
iPad中选择Metal app

00:06:26.620 --> 00:06:28.622 align:middle
作为目标app和开始记录

00:06:33.493 --> 00:06:34.661 align:middle
好了

00:06:34.728 --> 00:06:37.998 align:middle
现在Metal
系统寻踪是一款工具内的记录工具

00:06:38.065 --> 00:06:39.833 align:middle
这个
工具叫Windowed Mode

00:06:39.900 --> 00:06:42.970 align:middle
本质上说 它捕捉轨道
形成环形缓冲区

00:06:43.036 --> 00:06:45.439 align:middle
这可让你随时进行记录

00:06:46.173 --> 00:06:51.311 align:middle
重要的是
在你发现需要调查的问题时

00:06:51.378 --> 00:06:52.579 align:middle
可以停止记录

00:06:53.280 --> 00:06:54.281 align:middle
这时候

00:06:54.348 --> 00:06:58.685 align:middle
工具将收集所有
已经收集的追踪数据处理一会儿

00:06:58.752 --> 00:07:01.088 align:middle
以一个时间轴作为结束
时间轴看起来像这样

00:06:58.752 --> 00:07:01.088 align:middle
以一个时间轴作为结束
时间轴看起来像这样

00:07:02.222 --> 00:07:03.991 align:middle
这里有很多东西正在运作

00:07:04.057 --> 00:07:05.792 align:middle
放大一下 可以看得更清楚些

00:07:06.860 --> 00:07:09.162 align:middle
控制选择键 选择一个时间轴里

00:07:09.830 --> 00:07:11.465 align:middle
我想要放大的

00:07:11.532 --> 00:07:13.467 align:middle
感兴趣的区域

00:07:14.501 --> 00:07:17.538 align:middle
我可以通过追踪器手势操纵时间轴

00:07:17.871 --> 00:07:22.442 align:middle
两个手指滑动到滚动和收缩
以进行缩放

00:07:23.010 --> 00:07:24.912 align:middle
你可以看到 在我进一步放大时

00:07:25.445 --> 00:07:27.080 align:middle
我可以在时间轴里看到更多的细节

00:07:30.184 --> 00:07:32.085 align:middle
所以 在这里 我们看什么呢？

00:07:33.086 --> 00:07:35.055 align:middle
基本上 我们看到是

00:07:35.455 --> 00:07:40.160 align:middle
Metal应用图形处理过程中

00:07:40.761 --> 00:07:43.030 align:middle
所有图层集合中

00:07:44.932 --> 00:07:48.569 align:middle
图形深层信息

00:07:48.635 --> 00:07:51.605 align:middle
时间轴里不同的颜色

00:07:51.672 --> 00:07:53.941 align:middle
代表每个框架不同的工作量

00:07:55.042 --> 00:07:57.711 align:middle
磁道本身相当的灵敏

00:07:58.612 --> 00:08:02.583 align:middle
这里的每个盒子代表
每个轨道的相关开始时间

00:07:58.612 --> 00:08:02.583 align:middle
这里的每个盒子代表
每个轨道的相关开始时间

00:08:02.649 --> 00:08:04.284 align:middle
结束时间和所用时间

00:08:06.420 --> 00:08:09.156 align:middle
从头开始 然后往下一直处理

00:08:09.223 --> 00:08:12.960 align:middle
我们使用Metal框架的应用

00:08:13.861 --> 00:08:18.732 align:middle
接下来 我们有显卡驱动
它处理你的命令缓冲器

00:08:19.132 --> 00:08:21.635 align:middle
如果你有任何
着色器编辑活动中等框架

00:08:21.702 --> 00:08:23.570 align:middle
它同样也会在轨道中体现

00:08:25.439 --> 00:08:28.075 align:middle
这由GPU硬件轨道进行跟踪

00:08:28.542 --> 00:08:30.410 align:middle
显示的是在GPU中

00:08:30.477 --> 00:08:33.179 align:middle
执行渲染和计算指令

00:08:33.714 --> 00:08:37.049 align:middle
最后 我们有显示面轨道

00:08:37.116 --> 00:08:40.587 align:middle
基本上 这就是在设备上显示的框架

00:08:41.755 --> 00:08:42.589 align:middle
好了

00:08:43.490 --> 00:08:47.528 align:middle
在这里你可以
看到的其他东西是这些标签

00:08:48.962 --> 00:08:52.833 align:middle
这边的这两个标签阴影buffer
G buffer和lighting

00:08:53.467 --> 00:08:55.469 align:middle
是我用编码器标签的属性

00:08:55.536 --> 00:09:00.474 align:middle
分配到Metal代码中的编辑器里的

00:08:55.536 --> 00:09:00.474 align:middle
分配到Metal代码中的编辑器里的

00:09:01.742 --> 00:09:06.580 align:middle
这些标签带着与它们相关的工作负荷

00:09:06.647 --> 00:09:08.448 align:middle
沿着传递路径传送

00:09:08.782 --> 00:09:10.217 align:middle
这使得Metal系统寻踪中

00:09:10.284 --> 00:09:12.052 align:middle
追踪场景渲染pass

00:09:12.119 --> 00:09:13.086 align:middle
非常简单

00:09:13.153 --> 00:09:15.122 align:middle
我强烈建议你充分地使用它

00:09:15.923 --> 00:09:19.193 align:middle
有些东西太小 无法安装标签

00:09:20.060 --> 00:09:23.931 align:middle
你可以将鼠标悬停在尺子上就可以看到

00:09:23.997 --> 00:09:28.435 align:middle
一个工具提示
同时显示标签和持续时间

00:09:30.070 --> 00:09:36.176 align:middle
基本上 这里的轨道顺序映射

00:09:36.343 --> 00:09:39.146 align:middle
Metal指令沿着显卡

00:09:39.213 --> 00:09:41.748 align:middle
传递路径运作的顺序

00:09:42.316 --> 00:09:47.588 align:middle
让我们继续
跟随命令缓冲器 沿着管道向下

00:09:49.790 --> 00:09:53.861 align:middle
在轨道顶端
我可以看到我的应用使用的是

00:09:53.927 --> 00:09:56.396 align:middle
Metal命令缓冲器和编码器

00:09:56.964 --> 00:10:00.234 align:middle
尤其是这里 我看到的是命令缓冲器

00:09:56.964 --> 00:10:00.234 align:middle
尤其是这里 我看到的是命令缓冲器

00:10:00.300 --> 00:10:02.970 align:middle
和渲染计算编码器的

00:10:03.036 --> 00:10:04.338 align:middle
创建时间和提交时间

00:10:05.372 --> 00:10:07.741 align:middle
顶端有命令缓冲器

00:10:08.308 --> 00:10:14.248 align:middle
底部有相关的编码器 这个编码器是

00:10:14.314 --> 00:10:17.618 align:middle
由命令缓冲器直接嵌入其中而创建

00:10:18.352 --> 00:10:24.057 align:middle
现在 注意这个箭头
箭头在进入下个轨道

00:10:24.124 --> 00:10:27.361 align:middle
命令缓冲器的提交时间上

00:10:28.228 --> 00:10:31.064 align:middle
在Metal系统寻踪中

00:10:31.131 --> 00:10:32.299 align:middle
这些箭头代表

00:10:32.399 --> 00:10:34.234 align:middle
不同水平传递路径间的依赖性

00:10:34.434 --> 00:10:37.404 align:middle
例如 当提交了命令缓冲器

00:10:37.871 --> 00:10:40.874 align:middle
它的下一站是图形显示器驱动

00:10:40.941 --> 00:10:44.545 align:middle
如果将其可以放大
就会看到更多信息

00:10:45.879 --> 00:10:47.981 align:middle
看看我们获取到到了多少信息

00:10:48.448 --> 00:10:51.385 align:middle
它真的真的很快 CPU仍在处理

00:10:51.451 --> 00:10:52.853 align:middle
几乎没有占用多少内存

00:10:54.121 --> 00:10:57.724 align:middle
同样的 一旦编码器处理完毕

00:10:57.791 --> 00:11:00.994 align:middle
我就可以跟随这些箭头了

00:10:57.791 --> 00:11:00.994 align:middle
我就可以跟随这些箭头了

00:11:01.161 --> 00:11:03.997 align:middle
这些编码器将被提交到GPU轨道

00:11:05.065 --> 00:11:07.401 align:middle
用同样的方式跟随箭头

00:11:08.435 --> 00:11:12.539 align:middle
可以看到GPU正在处理我的编码器

00:11:13.540 --> 00:11:17.110 align:middle
这个GPU轨道被分成三个不同线路

00:11:17.177 --> 00:11:18.478 align:middle
一个是vertex处理

00:11:18.545 --> 00:11:20.814 align:middle
一个是碎片 一个是计算

00:11:22.015 --> 00:11:26.453 align:middle
比如说 我可以看到阴影缓冲途径的

00:11:26.520 --> 00:11:28.088 align:middle
阴影缓冲渲染代码

00:11:28.856 --> 00:11:31.158 align:middle
它正在仔细查
看它的vertex处理阶段

00:11:31.225 --> 00:11:34.161 align:middle
然后移到碎片阶段 这个阶段刚好

00:11:34.228 --> 00:11:36.330 align:middle
和G buffer
和lighting 阶段重叠

00:11:36.396 --> 00:11:37.798 align:middle
这些东西很好

00:11:38.832 --> 00:11:45.072 align:middle
这里有个简要的信息
vertex碎片不只是

00:11:45.672 --> 00:11:51.211 align:middle
计算着色器处理时间
同样也计算处理成本

00:11:51.278 --> 00:11:53.780 align:middle
比如说 我们正在iOS上运行

00:11:53.847 --> 00:11:56.216 align:middle
它是一个图块类延缓体系结构

00:11:56.617 --> 00:11:59.453 align:middle
所以vertex处理成本也将

00:11:59.520 --> 00:12:04.391 align:middle
包含图块成本 这些需要记住

00:11:59.520 --> 00:12:04.391 align:middle
包含图块成本 这些需要记住

00:12:05.826 --> 00:12:09.796 align:middle
最后 一旦框架完成渲染

00:12:10.664 --> 00:12:14.434 align:middle
表面也将在显示器中结束

00:12:14.735 --> 00:12:16.637 align:middle
这点显示在在底部的轨道中

00:12:19.106 --> 00:12:23.477 align:middle
基本上 它显示框架进入显示器的时间

00:12:23.544 --> 00:12:24.878 align:middle
以及在里面呆了多长时间

00:12:25.612 --> 00:12:28.582 align:middle
在它下面 有同步轨道

00:12:29.283 --> 00:12:31.685 align:middle
显示的是被与个别同步事件

00:12:31.752 --> 00:12:36.190 align:middle
相应的峰值分开的同步间隔

00:12:39.459 --> 00:12:42.930 align:middle
最后 在顶部有细节视图

00:12:43.897 --> 00:12:44.932 align:middle
细节视图和你在

00:12:44.998 --> 00:12:46.800 align:middle
其他工具看到的类似

00:12:46.867 --> 00:12:49.269 align:middle
它在选择的工具使用基础上

00:12:49.336 --> 00:12:50.938 align:middle
提供环境细节

00:12:51.505 --> 00:12:52.372 align:middle
比如说现在

00:12:52.439 --> 00:12:55.042 align:middle
我选择了Metal应用工具

00:12:55.108 --> 00:12:59.413 align:middle
就可以扩大这个 看看所有的框架

00:12:59.479 --> 00:13:01.481 align:middle
所有的命令缓冲器

00:12:59.479 --> 00:13:01.481 align:middle
所有的命令缓冲器

00:13:01.548 --> 00:13:02.683 align:middle
和与有关层级的编码器

00:13:03.550 --> 00:13:07.754 align:middle
如果你想看精确定时
这个轨道就很有用

00:13:07.821 --> 00:13:09.156 align:middle
若我转到编码器清单

00:13:09.590 --> 00:13:11.158 align:middle
精确创建提交时间

00:13:11.225 --> 00:13:13.227 align:middle
或进程的起始位置

00:13:13.293 --> 00:13:14.428 align:middle
非常有用

00:13:15.996 --> 00:13:20.868 align:middle
酷！这里的时间轴

00:13:20.934 --> 00:13:24.605 align:middle
对应这图形管道

00:13:25.405 --> 00:13:27.407 align:middle
这是一个非常强大的工具

00:13:27.608 --> 00:13:31.445 align:middle
iOS 9和Metal中是首次出现

00:13:32.779 --> 00:13:35.983 align:middle
所以要怎么用 才能解决你的问题呢？

00:13:36.049 --> 00:13:38.352 align:middle
或有问题的app是什么样的？

00:13:38.886 --> 00:13:40.587 align:middle
继续 我将打开一个不同的轨道

00:13:40.654 --> 00:13:42.055 align:middle
为你进行展示

00:13:42.222 --> 00:13:44.591 align:middle
等下菲利普将为你

00:13:44.658 --> 00:13:48.662 align:middle
详细讲解Metal性能

00:13:49.329 --> 00:13:52.833 align:middle
以及如何使用它解决你的问题

00:13:53.901 --> 00:13:55.903 align:middle
我将简要讲讲工具的

00:13:55.969 --> 00:13:59.373 align:middle
工作流程和一些小窍门

00:14:00.707 --> 00:14:03.610 align:middle
首要的是你需要关心

00:14:03.677 --> 00:14:05.712 align:middle
你的CPU和GPU并行

00:14:06.847 --> 00:14:09.516 align:middle
你可以看到 我打开的标有

00:14:09.583 --> 00:14:11.552 align:middle
Problem Run标签的轨道

00:14:12.286 --> 00:14:15.856 align:middle
比我们上一个轨道要稀疏

00:14:16.290 --> 00:14:18.959 align:middle
因为我们有不少同步点 在这些点里

00:14:20.527 --> 00:14:22.462 align:middle
事实上 CPU正在等待GPU

00:14:22.529 --> 00:14:24.498 align:middle
你需要确保将它消除掉

00:14:26.233 --> 00:14:32.406 align:middle
同样的 需要寻找另一个有用的东西

00:14:32.472 --> 00:14:33.807 align:middle
就是你在时间轴里看到的模式

00:14:34.341 --> 00:14:37.845 align:middle
这些框架都是同一场景的一部分

00:14:37.911 --> 00:14:39.713 align:middle
所以它们的时间局部性很高

00:14:40.480 --> 00:14:42.783 align:middle
任何你看到的分歧
都可能指向一个问题

00:14:42.850 --> 00:14:44.651 align:middle
你应该进行调查

00:14:45.185 --> 00:14:48.655 align:middle
另一个重要的东西是显示面轨道

00:14:50.090 --> 00:14:53.961 align:middle
理论上 若帧速率目标是60帧每秒

00:14:56.096 --> 00:14:59.867 align:middle
这些面将在显示上停留

00:15:00.601 --> 00:15:02.569 align:middle
一个单一的VSync间隔

00:15:05.405 --> 00:15:07.407 align:middle
所以我们可以看到每VSync间隔

00:15:07.474 --> 00:15:08.876 align:middle
显示面就会被交换

00:15:08.942 --> 00:15:11.411 align:middle
比如这个特别的框架
停留了三个间隔

00:15:11.478 --> 00:15:13.380 align:middle
所以我们以20 fps进行运行

00:15:16.683 --> 00:15:21.154 align:middle
另一个非常有用的
东西是着色器编辑轨道

00:15:21.455 --> 00:15:24.258 align:middle
不管着色器编辑器
何时在轨道里开始生效

00:15:24.324 --> 00:15:26.226 align:middle
它都直接为你显示相关信息

00:15:26.627 --> 00:15:28.762 align:middle
需要特别避免的一件事是

00:15:29.530 --> 00:15:33.800 align:middle
将工作提交到着色器编辑器中等框架

00:15:33.867 --> 00:15:35.569 align:middle
因为它将浪费你的CPU周期

00:15:35.636 --> 00:15:38.005 align:middle
这个周期你原本
可以用在其他的事情上的

00:15:38.071 --> 00:15:40.807 align:middle
菲利普等下会详细说到这点

00:15:41.742 --> 00:15:46.413 align:middle
最后 你应该尽早并经常进行分析

00:15:47.814 --> 00:15:51.752 align:middle
像这样的工作流程将帮你解决问题

00:15:51.818 --> 00:15:54.354 align:middle
而且可让解决问题变得简单

00:15:54.421 --> 00:15:58.559 align:middle
Xcode通过为创建产品
提供一个配置文件启动选项

00:15:58.625 --> 00:16:00.093 align:middle
对你有所帮助

00:15:58.625 --> 00:16:00.093 align:middle
对你有所帮助

00:16:00.160 --> 00:16:02.796 align:middle
它将自动创建一个已安装

00:16:02.863 --> 00:16:05.265 align:middle
在设备上的app的发布版本

00:16:05.332 --> 00:16:09.002 align:middle
启动一个按照你选择模板运行的工具

00:16:10.404 --> 00:16:14.107 align:middle
好了 这是Metal系统寻踪

00:16:15.108 --> 00:16:19.346 align:middle
适合所有支持Metal的iOS设备

00:16:20.614 --> 00:16:24.051 align:middle
你可以试一下
我们期待你的反馈和建议

00:16:24.685 --> 00:16:27.621 align:middle
现在有请菲利普上台

00:16:28.121 --> 00:16:32.826 align:middle
他将为我们展示
一些主要的Metal性能

00:16:33.260 --> 00:16:36.396 align:middle
以及如何使用工具对他们进行鉴别
谢谢

00:16:43.704 --> 00:16:46.039 align:middle
谢谢你 塞尔哈特 你的信息量很大

00:16:47.107 --> 00:16:52.212 align:middle
我们会讲到前面提到的Metal性能

00:16:53.981 --> 00:16:56.750 align:middle
一些最优方法 我们也将看看

00:16:56.817 --> 00:16:58.652 align:middle
如何使用这些工具进行诊断

00:16:58.719 --> 00:17:00.954 align:middle
并遵循最优方法

00:16:58.719 --> 00:17:00.954 align:middle
并遵循最优方法

00:17:01.388 --> 00:17:04.858 align:middle
让我来介绍一下我们的app样本

00:17:05.526 --> 00:17:07.828 align:middle
更确切地说
是app样本的一个系统轨道

00:17:08.127 --> 00:17:12.733 align:middle
我们马上可以看到一些性能问题

00:17:13.165 --> 00:17:17.371 align:middle
首先 CPU和GPU之间没有并行

00:17:18.005 --> 00:17:21.441 align:middle
那是非常强大的设备

00:17:21.541 --> 00:17:24.578 align:middle
实现最大性能的唯一方式

00:17:24.944 --> 00:17:29.049 align:middle
是立即运行它们
然而 它们似乎正在等待什么

00:17:30.617 --> 00:17:33.220 align:middle
你可以看到 CPU中处理框架之间

00:17:33.287 --> 00:17:35.589 align:middle
有大量的延迟

00:17:36.089 --> 00:17:37.691 align:middle
有一个异常的22毫秒

00:17:37.758 --> 00:17:40.060 align:middle
这里不能有任何拖延 发生什么了？

00:17:41.128 --> 00:17:45.632 align:middle
来看一下CPU实际活跃周期

00:17:46.300 --> 00:17:48.535 align:middle
它超过了框架截止期限

00:17:48.602 --> 00:17:50.504 align:middle
我们希望每秒有60帧

00:17:50.571 --> 00:17:54.741 align:middle
所以所有的东西必须在16毫秒内解决
我们已经超出时间 失效了

00:17:55.609 --> 00:17:58.512 align:middle
GPU方面看起来也不乐观

00:17:58.579 --> 00:18:02.549 align:middle
这是个漫长的拖延与CPU上的相称

00:17:58.579 --> 00:18:02.549 align:middle
这是个漫长的拖延与CPU上的相称

00:18:02.616 --> 00:18:05.652 align:middle
因为CPU花费了
大量的时间却没做成任何事

00:18:05.719 --> 00:18:09.489 align:middle
也无法为下个框架排队等候

00:18:09.923 --> 00:18:16.163 align:middle
此外
活跃的GPU周期超过框架截止期限

00:18:16.663 --> 00:18:19.032 align:middle
我们努力达到每秒60帧

00:18:19.099 --> 00:18:21.168 align:middle
但是事实每秒只有20帧

00:18:22.703 --> 00:18:25.005 align:middle
我们可以做些什么呢？

00:18:25.772 --> 00:18:28.375 align:middle
让我们看看基础的东西

00:18:28.542 --> 00:18:34.715 align:middle
首先检查一下
Metal设计和性能主要原则

00:18:35.782 --> 00:18:40.754 align:middle
在前面的状态中
它正在创建耗费资源的对象

00:18:44.591 --> 00:18:48.929 align:middle
现在 在传统app上
特别是在内容加载过程中将发生的

00:18:48.996 --> 00:18:53.367 align:middle
app编译所有来自源的着色器

00:18:53.433 --> 00:18:57.404 align:middle
着色器可能有数个 甚至上百个

00:18:57.471 --> 00:18:59.940 align:middle
这是个相当耗时的操作

00:19:01.241 --> 00:19:04.244 align:middle
现在共享编译才进行到一半

00:19:04.912 --> 00:19:07.948 align:middle
因为着色器需要全部编译到

00:19:08.015 --> 00:19:13.754 align:middle
与各种使用状态相结合的

00:19:13.820 --> 00:19:15.556 align:middle
GPU管道状态中

00:19:16.356 --> 00:19:18.926 align:middle
所以一些app可能

00:19:19.760 --> 00:19:22.663 align:middle
试图进行预热

00:19:23.430 --> 00:19:26.867 align:middle
通常情况下 当着色器和状态第一次

00:19:26.934 --> 00:19:30.838 align:middle
在Draw call中使用时
就会出现设备编辑

00:19:31.438 --> 00:19:35.108 align:middle
这是个坏消息 想象一下
你有一个竞赛游戏 突然间

00:19:35.175 --> 00:19:37.911 align:middle
你转了个弯 添加了很多新对象

00:19:37.978 --> 00:19:39.046 align:middle
帧速率也下降了

00:19:39.112 --> 00:19:40.047 align:middle
这真是的很糟糕

00:19:40.514 --> 00:19:43.083 align:middle
预热所做的就是

00:19:43.150 --> 00:19:47.688 align:middle
你释放大量

00:19:47.754 --> 00:19:50.958 align:middle
带显示状态和
不同着色器组合的W Draw调用

00:19:51.525 --> 00:19:57.497 align:middle
这样让驱动程序可以进行编辑
相关GPU管道状态

00:19:57.564 --> 00:19:59.533 align:middle
所以当使用

00:20:00.300 --> 00:20:02.569 align:middle
组合状态和着色器时

00:20:02.636 --> 00:20:05.772 align:middle
所有的一切都准备好了
帧速率也不会下降了

00:20:06.874 --> 00:20:08.509 align:middle
在实际的渲染循环中

00:20:08.575 --> 00:20:11.512 align:middle
它们是典型的状态设置

00:20:12.112 --> 00:20:13.914 align:middle
当你开始考虑做一些事情时

00:20:13.981 --> 00:20:16.016 align:middle
或许你将做些Draw调用

00:20:17.451 --> 00:20:23.223 align:middle
所以Metal路径就是事先移除
资源消耗多的对象

00:20:23.957 --> 00:20:26.894 align:middle
着色器可以在脱机状态下
从源代码进行编辑

00:20:27.728 --> 00:20:30.397 align:middle
它免去了不少的工作量

00:20:31.632 --> 00:20:34.935 align:middle
我们提前移到状态定义

00:20:35.002 --> 00:20:37.704 align:middle
你定义你的状态

00:20:38.438 --> 00:20:40.274 align:middle
GPU管道状态被编译成

00:20:40.340 --> 00:20:42.376 align:middle
这些状态对象

00:20:43.210 --> 00:20:46.513 align:middle
所以当你开始Draw调用时

00:20:46.580 --> 00:20:48.715 align:middle
就没有所谓的设备编辑

00:20:48.849 --> 00:20:51.585 align:middle
所以也就不在需要警告了

00:20:51.652 --> 00:20:52.886 align:middle
它已经成为历史了

00:20:53.754 --> 00:20:56.823 align:middle
它们已经
为Draw调用备好渲染循环了

00:20:56.890 --> 00:20:58.692 align:middle
许多Draw调用

00:21:00.027 --> 00:21:01.595 align:middle
基本上

00:21:02.462 --> 00:21:05.899 align:middle
Metal通过以下方式加速状态定义

00:21:06.333 --> 00:21:10.571 align:middle
分离Draw命令
里消耗多的状态确认和编辑

00:21:11.038 --> 00:21:13.473 align:middle
从而允许你将其推出渲染循环

00:21:13.540 --> 00:21:16.009 align:middle
并为真实的Draw调用

00:21:16.076 --> 00:21:17.744 align:middle
保持渲染循环

00:21:19.880 --> 00:21:22.282 align:middle
现在 这些资源消耗型状态

00:21:22.349 --> 00:21:25.886 align:middle
被打包到不可变状态对象中

00:21:26.353 --> 00:21:30.557 align:middle
目的是一旦创建 就可以被重复使用

00:21:31.725 --> 00:21:33.927 align:middle
现在 回到app样本

00:21:35.929 --> 00:21:39.600 align:middle
你可以看到中等
框架上有些渲染器编辑正在发生

00:21:39.800 --> 00:21:41.768 align:middle
这里我们大约浪费了一毫秒

00:21:42.636 --> 00:21:44.972 align:middle
根本没用

00:21:46.740 --> 00:21:50.577 align:middle
倘若看一下Xcode的框架调试器

00:21:51.078 --> 00:21:53.046 align:middle
看看在单个框架上发生的所有这些

00:21:53.113 --> 00:21:55.549 align:middle
看看所有的这些对象

00:21:55.616 --> 00:21:56.817 align:middle
都不是我们想要的

00:21:56.884 --> 00:21:59.620 align:middle
你应该看的是这些

00:21:59.686 --> 00:22:02.122 align:middle
创建框架命令缓冲器

00:21:59.686 --> 00:22:02.122 align:middle
创建框架命令缓冲器

00:22:02.689 --> 00:22:04.825 align:middle
获取drawable以及纹理

00:22:05.325 --> 00:22:07.528 align:middle
剩下的东西 就都是多余的了

00:22:08.762 --> 00:22:12.466 align:middle
我们来说说这些消耗大的对象

00:22:12.533 --> 00:22:13.800 align:middle
以及应该何时创建它们

00:22:13.867 --> 00:22:16.303 align:middle
我们从着色器库开始

00:22:17.304 --> 00:22:21.341 align:middle
这些是你的编译着色器库

00:22:22.376 --> 00:22:26.046 align:middle
现在 你真正要做的是
在离线状态下 对它们进行编译

00:22:27.047 --> 00:22:31.585 align:middle
你可以使用Xcode

00:22:31.785 --> 00:22:33.921 align:middle
项目上任何Metal源文件

00:22:34.087 --> 00:22:35.722 align:middle
都将被入默认库

00:22:36.623 --> 00:22:42.529 align:middle
你的app或许
有它自己的自定义目录管道

00:22:42.796 --> 00:22:45.132 align:middle
你或许并不是必需使用这个方法

00:22:45.666 --> 00:22:48.836 align:middle
因此 我们提供了命令行工具

00:22:48.902 --> 00:22:51.738 align:middle
它可以被合并到你的管道中

00:22:53.707 --> 00:22:55.742 align:middle
如果在运行时间里

00:22:55.809 --> 00:22:58.946 align:middle
你免不了要从源里编辑着色器

00:22:59.913 --> 00:23:02.783 align:middle
最好是进行异步创建

00:22:59.913 --> 00:23:02.783 align:middle
最好是进行异步创建

00:23:03.984 --> 00:23:07.621 align:middle
所以当你创建库 同时

00:23:07.688 --> 00:23:10.057 align:middle
你的app确切的说是调用线程

00:23:10.123 --> 00:23:12.826 align:middle
可以继续做其他事情

00:23:12.926 --> 00:23:16.930 align:middle
一旦着色器库创建完成

00:23:16.997 --> 00:23:19.166 align:middle
你的app也会得到相关信息

00:23:22.436 --> 00:23:25.606 align:middle
需在你的app创建的首个对象

00:23:25.672 --> 00:23:27.541 align:middle
是设备和命令队列

00:23:28.842 --> 00:23:32.145 align:middle
这些代表着你将使用的GPU

00:23:32.212 --> 00:23:36.250 align:middle
以及安排好的命令缓冲器的顺序

00:23:37.851 --> 00:23:40.053 align:middle
现在 正如我们所说的 你想要

00:23:40.120 --> 00:23:42.289 align:middle
在app初始化过程中 创建这些

00:23:42.356 --> 00:23:44.758 align:middle
因为创建它们消耗太大

00:23:44.825 --> 00:23:48.795 align:middle
你想让它们
可以在app的使用周期里被重复使用

00:23:49.596 --> 00:23:52.933 align:middle
而且当然
你想为每个使用的GPU都创建一个

00:23:54.568 --> 00:23:57.171 align:middle
接下来是很有趣的东西 渲染

00:23:57.237 --> 00:23:58.839 align:middle
和计算管道状态

00:24:00.007 --> 00:24:03.944 align:middle
它们压缩了
所有的可编程GPU管道状态

00:24:04.344 --> 00:24:09.116 align:middle
因此它准备了所有的
描述符vertex格式器脚本

00:24:09.850 --> 00:24:11.618 align:middle
渲染缓冲器格式

00:24:11.685 --> 00:24:14.087 align:middle
并把它们编译成真实的原管道状态

00:24:15.322 --> 00:24:17.424 align:middle
现在 因为这是个消耗多的操作

00:24:17.491 --> 00:24:21.962 align:middle
你应该在你加载内容时
创建这些管道对象

00:24:22.462 --> 00:24:24.998 align:middle
而且它们应该可以被不断循环使用

00:24:26.533 --> 00:24:28.101 align:middle
现在 因为有了这些库

00:24:28.168 --> 00:24:30.204 align:middle
你也可以用这些方法

00:24:30.270 --> 00:24:31.772 align:middle
对它们进行异步创建

00:24:32.072 --> 00:24:33.440 align:middle
一旦创建完毕

00:24:33.507 --> 00:24:35.542 align:middle
完成处理器将通知你的app

00:24:38.512 --> 00:24:42.616 align:middle
需要提到一点 除非你真的需要它们

00:24:42.983 --> 00:24:44.952 align:middle
要不然就不要获取反射数据了

00:24:45.018 --> 00:24:47.254 align:middle
因为这是个消耗很大的操作

00:24:48.989 --> 00:24:53.093 align:middle
接下来是深度网板和取样器状态

00:24:53.660 --> 00:24:56.763 align:middle
这些是GPU管道状态固定功能

00:24:57.497 --> 00:24:59.099 align:middle
在你加载内容时

00:24:59.166 --> 00:25:02.936 align:middle
你应该和其他管道状态一起
对其进行创建

00:24:59.166 --> 00:25:02.936 align:middle
你应该和其他管道状态一起
对其进行创建

00:25:03.770 --> 00:25:09.643 align:middle
现在 你或许已经结束了许多深度网板

00:25:09.710 --> 00:25:11.879 align:middle
和样品器状态 但你无需担忧

00:25:11.945 --> 00:25:15.682 align:middle
因为Metal实现将在内部

00:25:15.749 --> 00:25:19.219 align:middle
散列状态 并创建大量副本

00:25:19.286 --> 00:25:20.454 align:middle
所以 你无需担忧

00:25:22.089 --> 00:25:26.026 align:middle
接下来
我们有了GPU消耗的真实数据了

00:25:26.093 --> 00:25:29.763 align:middle
你获得了纹理和缓冲器

00:25:30.497 --> 00:25:33.233 align:middle
再一次 你应该在加载内容时

00:25:33.934 --> 00:25:37.771 align:middle
对其进行创建 并尽可能的重复使用

00:25:37.871 --> 00:25:42.109 align:middle
因为这是一项与配置

00:25:42.176 --> 00:25:44.011 align:middle
和释放资源有关的消耗

00:25:45.045 --> 00:25:48.815 align:middle
乃至动态资源 你或许无法

00:25:48.882 --> 00:25:51.785 align:middle
提前将它们完全初始化
但是你至少应该

00:25:51.852 --> 00:25:54.955 align:middle
创建优先存储

00:25:55.155 --> 00:25:57.691 align:middle
我们很快就会讲到这部分的详细信息

00:25:58.892 --> 00:26:00.928 align:middle
现在简要说一下

00:25:58.892 --> 00:26:00.928 align:middle
现在简要说一下

00:26:01.762 --> 00:26:07.401 align:middle
所以 对于消耗大的状态
显然应该提前创建

00:26:08.001 --> 00:26:09.903 align:middle
它们是着色器库

00:26:09.970 --> 00:26:11.972 align:middle
可在离线的时候进行创建

00:26:13.006 --> 00:26:15.909 align:middle
设备和命令序列 在你初始化

00:26:16.176 --> 00:26:18.245 align:middle
app的时候进行创建

00:26:18.779 --> 00:26:21.315 align:middle
渲染和计算管道状态

00:26:22.015 --> 00:26:23.917 align:middle
在你加载内容的时候进行创建

00:26:24.284 --> 00:26:26.753 align:middle
固定功能管道状态

00:26:26.820 --> 00:26:28.722 align:middle
深度网板和取样器状态

00:26:29.990 --> 00:26:32.059 align:middle
也是在你加载内容时进行创建

00:26:32.125 --> 00:26:33.760 align:middle
最后是app使用的纹理和缓冲器

00:26:34.728 --> 00:26:40.033 align:middle
我们继续 在app示例中遵循

00:26:40.701 --> 00:26:42.536 align:middle
这些最优方法
或许你还记得它是这样的

00:26:42.736 --> 00:26:46.507 align:middle
曾有些着色器编辑
每帧都会出现中间帧情况

00:26:47.608 --> 00:26:49.309 align:middle
现在 我们什么都没有了

00:26:49.376 --> 00:26:52.713 align:middle
已经节约了大概CPU时间的一毫秒

00:26:53.180 --> 00:26:55.082 align:middle
开端不错不过我们要看下

00:26:55.148 --> 00:26:56.517 align:middle
能否很快的做得更好

00:26:57.084 --> 00:27:02.022 align:middle
预先创建消耗多的状态和对象

00:26:57.084 --> 00:27:02.022 align:middle
预先创建消耗多的状态和对象

00:27:02.089 --> 00:27:05.125 align:middle
并使它们可以被重复使用

00:27:05.392 --> 00:27:10.097 align:middle
特别是 在脱机状态下
编辑你的着色器源

00:27:10.230 --> 00:27:13.033 align:middle
你想将渲染循环保持在它原本的样子

00:27:13.100 --> 00:27:14.168 align:middle
这是Draw调用

00:27:14.701 --> 00:27:16.069 align:middle
摆脱了所有的对象创建

00:27:18.238 --> 00:27:23.210 align:middle
对于那些你无法全部预先创建的资源
该怎么办？

00:27:23.744 --> 00:27:26.246 align:middle
我们正在谈论这些动态资源

00:27:26.813 --> 00:27:30.918 align:middle
所以我们该对它们做什么？
我们该如何有效地创建并管理它们呢？

00:27:32.286 --> 00:27:34.488 align:middle
现在 通过动态资源

00:27:34.821 --> 00:27:38.525 align:middle
我们来谈谈那些一经创建

00:27:38.926 --> 00:27:43.630 align:middle
就可能被CPU修改很多次的资源

00:27:44.064 --> 00:27:48.569 align:middle
一个好的例子是缓冲器着色器常量

00:27:50.704 --> 00:27:55.776 align:middle
以及一些东西
比如在CPU中产生的粒子系统

00:27:55.843 --> 00:27:58.912 align:middle
所拥有的任何动态
vertex和指示缓冲器

00:27:59.813 --> 00:28:02.216 align:middle
除动态纹理外

00:27:59.813 --> 00:28:02.216 align:middle
除动态纹理外

00:28:02.282 --> 00:28:04.384 align:middle
或许你的app有一些纹理

00:28:04.451 --> 00:28:06.420 align:middle
它在框架间的CPU上进行修改

00:28:07.654 --> 00:28:09.156 align:middle
理想的状态是 如果可以

00:28:09.223 --> 00:28:12.793 align:middle
你会选择将这些资源放在某处

00:28:12.860 --> 00:28:15.495 align:middle
以方便CPU和GPU有效地使用

00:28:16.463 --> 00:28:18.232 align:middle
当你创建资源时

00:28:18.498 --> 00:28:21.602 align:middle
你可以通过使用
共享储存模式选项进行操作

00:28:22.202 --> 00:28:25.239 align:middle
这在存储器里创建资源

00:28:25.305 --> 00:28:27.307 align:middle
资源由CPU和GPU共享

00:28:27.841 --> 00:28:31.278 align:middle
事实上
这是iOS上的默认储存模式

00:28:31.345 --> 00:28:35.916 align:middle
iOS设备已经统一存储器架构

00:28:35.983 --> 00:28:39.586 align:middle
所以相同的存储器
可在CPU和GPU之间进行共享

00:28:40.988 --> 00:28:44.992 align:middle
现在 关于这些共享资源的事情是

00:28:45.058 --> 00:28:48.061 align:middle
CPU完全无法同步使用

00:28:48.495 --> 00:28:53.100 align:middle
它可以通过指示器自由地修改数据

00:28:53.934 --> 00:28:59.173 align:middle
事实上 对于GPU正在使用的数据

00:28:59.239 --> 00:29:01.408 align:middle
对CPU而言是毁灭性的的数据

00:28:59.239 --> 00:29:01.408 align:middle
对CPU而言是毁灭性的的数据

00:29:01.475 --> 00:29:03.443 align:middle
CPU很容易就可以对其进行干涉

00:29:03.777 --> 00:29:05.112 align:middle
我们想要避免这种情况

00:29:05.612 --> 00:29:07.247 align:middle
但我们应该怎么做？

00:29:09.249 --> 00:29:13.120 align:middle
一个简单的做法是
为资源配备一个单一缓冲器

00:29:14.054 --> 00:29:16.857 align:middle
在资源里 我们有一个常量缓冲器

00:29:16.924 --> 00:29:21.261 align:middle
这个缓冲器在CPU里进行更新
并随后被GPU所消耗

00:29:22.496 --> 00:29:24.131 align:middle
现在 倘若CPU想要

00:29:24.198 --> 00:29:27.968 align:middle
修改常量缓冲器里的任何数据

00:29:28.702 --> 00:29:31.371 align:middle
它就必须等到GPU完成后 才能开始

00:29:31.438 --> 00:29:34.141 align:middle
唯一方法是

00:29:34.208 --> 00:29:38.412 align:middle
它是否在等待命令缓冲器
在命令缓冲器里

00:29:39.112 --> 00:29:41.481 align:middle
资源是调用于完成GPU进程

00:29:41.882 --> 00:29:45.452 align:middle
在这个示例中
我们使用等待至完成

00:29:46.086 --> 00:29:49.756 align:middle
所以我们空等着
等于CPU也在空等着

00:29:49.823 --> 00:29:51.725 align:middle
直到GPU完成处理

00:29:52.192 --> 00:29:54.695 align:middle
CPU才能继续并修改缓冲器

00:29:54.761 --> 00:29:57.164 align:middle
而缓冲器将在下个框架中被GPU消耗

00:29:58.198 --> 00:30:00.067 align:middle
这真的很不好

00:29:58.198 --> 00:30:00.067 align:middle
这真的很不好

00:30:00.133 --> 00:30:04.304 align:middle
因为不仅CPU储存了
GPU也储存了

00:30:04.671 --> 00:30:07.441 align:middle
因为CPU没有时间为
下个框架操作排队等候

00:30:09.309 --> 00:30:13.714 align:middle
这是在app示例中所发生的

00:30:14.615 --> 00:30:20.454 align:middle
CPU在空等
等待GPU完成每个框架

00:30:20.521 --> 00:30:24.124 align:middle
你引入了大量的存储周期

00:30:24.191 --> 00:30:27.194 align:middle
是的 CPU和GPU之间并没有并行

00:30:28.161 --> 00:30:30.831 align:middle
显然 你需要更好的方法

00:30:31.732 --> 00:30:35.836 align:middle
你或许会
冒险为每个框架创建新缓冲器

00:30:35.903 --> 00:30:36.837 align:middle
因为你需要他们

00:30:37.704 --> 00:30:40.874 align:middle
但是正如我们前面所提到的

00:30:40.941 --> 00:30:42.176 align:middle
这并不是一个好办法

00:30:42.242 --> 00:30:44.545 align:middle
因为创建缓冲器

00:30:44.611 --> 00:30:46.079 align:middle
需要经常消耗

00:30:46.847 --> 00:30:50.150 align:middle
如果你有很多大的缓冲器
他们会积累

00:30:50.217 --> 00:30:52.152 align:middle
你不会真的想这么做的

00:30:53.086 --> 00:30:57.691 align:middle
你应该做的是 使用一个缓冲器组合

00:30:58.258 --> 00:31:00.427 align:middle
这里我们有三重缓冲组合

00:30:58.258 --> 00:31:00.427 align:middle
这里我们有三重缓冲组合

00:31:01.061 --> 00:31:05.199 align:middle
里面有三个缓冲器
这些缓冲器是在CPU更新

00:31:05.265 --> 00:31:06.800 align:middle
然后被GPU消耗掉的

00:31:07.434 --> 00:31:08.302 align:middle
为什么是三个？

00:31:08.869 --> 00:31:11.972 align:middle
我尤其要建议你限制

00:31:12.039 --> 00:31:15.275 align:middle
命令缓冲器数量 最多三个

00:31:15.676 --> 00:31:20.414 align:middle
实际上 每个命令缓冲器有一个缓冲器

00:31:21.381 --> 00:31:24.017 align:middle
通过利用一个信号

00:31:24.084 --> 00:31:27.788 align:middle
阻止CPU超过GPU太多

00:31:28.388 --> 00:31:32.993 align:middle
我们可以确保在
CPU上更新缓冲器仍是安全的

00:31:33.660 --> 00:31:36.530 align:middle
返回读取第一个缓冲器时

00:31:36.597 --> 00:31:39.066 align:middle
当GPU在处理过程中

00:31:40.901 --> 00:31:43.504 align:middle
与其拿一堆恼人的样本代码

00:31:43.570 --> 00:31:47.007 align:middle
我将示范的很棒的例子

00:31:47.508 --> 00:31:49.910 align:middle
是Metal Uniform
Streaming示例

00:31:49.977 --> 00:31:52.246 align:middle
它将展示如何做到这点

00:31:53.413 --> 00:31:56.016 align:middle
若你感兴趣 我建议你随后检验一下它

00:31:57.317 --> 00:31:59.853 align:middle
回到app示例 你应该还记得

00:31:59.920 --> 00:32:02.356 align:middle
在CPU上 每个框架之间

00:31:59.920 --> 00:32:02.356 align:middle
在CPU上 每个框架之间

00:32:02.890 --> 00:32:06.059 align:middle
有这些被削弱性能的权重

00:32:07.294 --> 00:32:12.633 align:middle
在使用一个缓冲组合更新动态数据后

00:32:13.500 --> 00:32:17.171 align:middle
我们设法极大地减少

00:32:17.237 --> 00:32:20.140 align:middle
CPU处理和GPU处理之间的差距

00:32:20.674 --> 00:32:23.043 align:middle
我们还有些同步性问题

00:32:23.110 --> 00:32:25.245 align:middle
但我们将只简要地看一下

00:32:26.547 --> 00:32:28.582 align:middle
我们已经取得很大的进步

00:32:29.716 --> 00:32:32.252 align:middle
总之 你想要缓冲

00:32:32.319 --> 00:32:34.288 align:middle
动态共享资源

00:32:34.555 --> 00:32:38.091 align:middle
因为它是在
框架之间更新这些的最有效的方式

00:32:38.892 --> 00:32:44.865 align:middle
你通过使用我
提到过的缓冲器和组确保安全

00:32:47.467 --> 00:32:50.337 align:middle
现在 我将讲一些东西

00:32:50.871 --> 00:32:52.573 align:middle
确切地说 实际上是一件

00:32:52.639 --> 00:32:55.042 align:middle
我不想提前做的事情

00:32:55.843 --> 00:32:59.279 align:middle
那关系到你何时
获得你的appDrawable服务

00:33:01.048 --> 00:33:04.618 align:middle
Drawable
外观是领域里app的窗口

00:33:04.685 --> 00:33:08.455 align:middle
它是你的app
渲染它的可视内容进去的东西

00:33:08.755 --> 00:33:13.193 align:middle
这要么是在显示器上直接显示

00:33:13.360 --> 00:33:15.796 align:middle
要么是组成管道的一部分

00:33:16.797 --> 00:33:21.735 align:middle
从Core Animation
Metal图层检索Drawable

00:33:22.402 --> 00:33:26.306 align:middle
但这些Drawable数量有限
因为事实上 它们相当的大

00:33:26.907 --> 00:33:29.643 align:middle
而我们既不想大量保存它们

00:33:29.710 --> 00:33:33.180 align:middle
也不像在我们需要的时候
对它们进行配置

00:33:33.981 --> 00:33:37.351 align:middle
所以这些Drawable非常有限

00:33:37.551 --> 00:33:40.587 align:middle
而一旦它们在硬件中显示了

00:33:40.654 --> 00:33:42.756 align:middle
在显示间隔

00:33:42.823 --> 00:33:44.525 align:middle
预先drawable 被放弃了

00:33:45.659 --> 00:33:49.530 align:middle
如果你集成实际的显示硬件

00:33:50.230 --> 00:33:53.367 align:middle
显示管道的每个阶段可能在任何点

00:33:53.867 --> 00:33:57.704 align:middle
为一个GPU
为Core Animation

00:33:57.771 --> 00:33:59.773 align:middle
在你的app里抓取Drawable

00:34:01.742 --> 00:34:05.212 align:middle
你的app通过
调用下个Drawable方法

00:34:05.279 --> 00:34:07.114 align:middle
抓取了一个Drawable外观

00:34:07.881 --> 00:34:12.152 align:middle
当调用Current Render
Pass Descriptor时

00:34:12.219 --> 00:34:14.454 align:middle
可以执行MetalKit

00:34:16.089 --> 00:34:20.761 align:middle
一旦Drawable适用
方法将只能返回

00:34:21.495 --> 00:34:24.665 align:middle
若那时恰巧有个适用的可取值

00:34:24.731 --> 00:34:26.099 align:middle
它将立即返回

00:34:26.166 --> 00:34:29.902 align:middle
很好 你可以使用框架 继续做

00:34:29.969 --> 00:34:32.773 align:middle
然而 若没有适用的app

00:34:32.840 --> 00:34:35.342 align:middle
确切地说为它调用 它将被封锁直至

00:34:35.442 --> 00:34:39.880 align:middle
至少下个显示
间隔正在等待一个Drawable

00:34:39.947 --> 00:34:41.181 align:middle
可能会很久

00:34:41.248 --> 00:34:42.549 align:middle
60帧每秒

00:34:42.616 --> 00:34:44.618 align:middle
我们在说16毫秒

00:34:45.652 --> 00:34:47.387 align:middle
真是一个坏消息

00:34:48.522 --> 00:34:52.626 align:middle
所以这就是样本app所做的事情？

00:34:52.693 --> 00:34:56.964 align:middle
这就是执行中巨大差距的解释？

00:34:58.098 --> 00:34:59.633 align:middle
我们来看看Xcode是怎么说的

00:35:00.567 --> 00:35:02.269 align:middle
我们转到框架导航器

00:35:02.870 --> 00:35:06.273 align:middle
看看这里的框架导航器

00:35:06.340 --> 00:35:08.909 align:middle
Xcode与阴影缓冲编码器

00:35:08.976 --> 00:35:10.911 align:middle
之间似乎存在问题

00:35:12.646 --> 00:35:13.847 align:middle
这里有个小警告

00:35:14.982 --> 00:35:16.383 align:middle
详细看一下

00:35:17.417 --> 00:35:20.187 align:middle
事实上 我们确实比实际需要的早

00:35:20.254 --> 00:35:22.623 align:middle
调用了下个Drawable方法

00:35:23.257 --> 00:35:25.592 align:middle
下个代码提供了一些非常明智的建议

00:35:25.659 --> 00:35:28.562 align:middle
应该在真正需要这个Drawable
的时候 再调用它

00:35:29.663 --> 00:35:32.566 align:middle
所以这个是如何与样本app相适应？

00:35:34.168 --> 00:35:37.638 align:middle
这里 在样本app中
我们有数个pass

00:35:38.071 --> 00:35:44.211 align:middle
在阴影pass前的
每个框架开始时获得Drawable

00:35:44.278 --> 00:35:48.115 align:middle
这实在太早了
因为直到最后的pass

00:35:48.182 --> 00:35:49.850 align:middle
我们才将一切拖离屏幕

00:35:50.384 --> 00:35:56.123 align:middle
直到我们渲染UI pass时
我们才需要一个Drawable

00:35:56.690 --> 00:35:59.560 align:middle
所以获取下个
Drawable的最佳位置是

00:35:59.626 --> 00:36:02.095 align:middle
自然地刚好早于UI pass

00:35:59.626 --> 00:36:02.095 align:middle
自然地刚好早于UI pass

00:36:04.665 --> 00:36:09.603 align:middle
我们继续 做出改变
随后将调用移到

00:36:09.670 --> 00:36:11.405 align:middle
下个Drawable

00:36:12.172 --> 00:36:14.741 align:middle
来看看问题是否被解决了

00:36:15.209 --> 00:36:18.245 align:middle
你已经看到了 是的 它做到了

00:36:18.445 --> 00:36:22.950 align:middle
我们移动第二个同步点

00:36:23.417 --> 00:36:28.956 align:middle
现在在框架上的处理和在CPU上的处
理之间再无任何拖延了

00:36:29.590 --> 00:36:30.924 align:middle
这是个巨大的改进

00:36:33.594 --> 00:36:36.430 align:middle
建议很简单 仅在你真的需要

00:36:36.496 --> 00:36:38.131 align:middle
Drawable的时候 再获取它

00:36:38.866 --> 00:36:41.835 align:middle
这是在真的使用渲染pass之前

00:36:42.836 --> 00:36:47.674 align:middle
这将确保你隐藏任何长延时

00:36:47.741 --> 00:36:51.879 align:middle
这些延时在没有适用的
Drawable时就会出现

00:36:52.012 --> 00:36:55.816 align:middle
你的app可以继续做有用的工作

00:36:55.883 --> 00:36:58.118 align:middle
知道真的
需要一个Drawable时

00:36:58.252 --> 00:36:59.520 align:middle
就会出现一个适用的

00:37:01.989 --> 00:37:05.392 align:middle
从这点来说
目前为止 我们做得非常好

00:37:06.326 --> 00:37:07.728 align:middle
但是仍有改进的空间

00:37:08.462 --> 00:37:12.232 align:middle
所以 为什么我们不看看GPU的效能

00:37:12.799 --> 00:37:15.402 align:middle
而不是降到非常低的水平？

00:37:15.536 --> 00:37:19.439 align:middle
试图最优化着色器或改变纹理格式

00:37:19.506 --> 00:37:20.774 align:middle
诸如此类的

00:37:20.841 --> 00:37:22.809 align:middle
为什么不看我是否可以提供一般的建议

00:37:23.911 --> 00:37:26.313 align:middle
就是这么巧 这就是了
这涉及到我们如何使用

00:37:26.380 --> 00:37:29.416 align:middle
Render
Command Encoders

00:37:31.118 --> 00:37:35.822 align:middle
Render Command
Encoders是用来

00:37:35.956 --> 00:37:40.294 align:middle
为单个渲染
pass创建Draw命令的

00:37:40.861 --> 00:37:45.365 align:middle
一个单一渲染pass在颜色获得
attachment的一个不动集

00:37:45.432 --> 00:37:49.269 align:middle
以及深度和网板
attachment上其作用

00:37:49.336 --> 00:37:53.006 align:middle
一旦开始pass
就不能变动attachment了

00:37:53.073 --> 00:37:56.677 align:middle
你可以改变作用在它们上面的行动

00:37:56.743 --> 00:37:59.513 align:middle
比如深度网板状态

00:37:59.580 --> 00:38:02.816 align:middle
颜色蒙版和调配

00:37:59.580 --> 00:38:02.816 align:middle
颜色蒙版和调配

00:38:02.883 --> 00:38:05.018 align:middle
这个值得记住

00:38:06.954 --> 00:38:10.157 align:middle
现在 在iOS设备GPU上

00:38:10.224 --> 00:38:16.363 align:middle
尤其重要的渲染编码器使用方式

00:38:16.430 --> 00:38:19.066 align:middle
取决于它们的结构方式

00:38:19.533 --> 00:38:22.503 align:middle
它们是基于图块的延迟渲染器

00:38:23.270 --> 00:38:26.006 align:middle
每个Render
Command Encoder

00:38:26.507 --> 00:38:28.775 align:middle
可产生2个GPU pass

00:38:29.676 --> 00:38:34.481 align:middle
首先
你有vertex阶段 它在编码器中

00:38:34.548 --> 00:38:41.154 align:middle
变换所有的几何体 然后执行剪贴

00:38:41.221 --> 00:38:47.761 align:middle
着色 然后将所有的几何体装到

00:38:47.828 --> 00:38:49.396 align:middle
屏幕空间图块里

00:38:50.464 --> 00:38:54.434 align:middle
紧接着是碎片阶段 它通过决定

00:38:54.501 --> 00:38:57.938 align:middle
哪些对象是可见的

00:38:58.005 --> 00:39:01.942 align:middle
来处理所有的对象图块

00:38:58.005 --> 00:39:01.942 align:middle
来处理所有的对象图块

00:39:02.009 --> 00:39:05.779 align:middle
然后只有可见像素才能被处理

00:39:07.014 --> 00:39:10.017 align:middle
所有的碎片处理发生在

00:39:10.083 --> 00:39:12.419 align:middle
快速芯片图块缓冲器上

00:39:13.754 --> 00:39:16.590 align:middle
现在 在渲染结束时

00:39:16.657 --> 00:39:19.393 align:middle
你只需存储颜色缓冲器

00:39:19.459 --> 00:39:21.361 align:middle
你只是放弃了深度缓冲

00:39:21.895 --> 00:39:26.266 align:middle
甚至有时你有多个
color attachment

00:39:26.333 --> 00:39:28.168 align:middle
你也只需存储其中一个

00:39:28.535 --> 00:39:33.774 align:middle
不在每个pass存储图块数据

00:39:33.841 --> 00:39:35.742 align:middle
你就节省了不少带宽

00:39:35.809 --> 00:39:38.745 align:middle
你避免了写出整个框架缓冲器

00:39:38.812 --> 00:39:40.714 align:middle
这对于性能来说很重要

00:39:40.781 --> 00:39:44.651 align:middle
因为它不必加载每个贴图的数据

00:39:47.421 --> 00:39:50.591 align:middle
所以Xcode告诉了我们什么？

00:39:50.691 --> 00:39:53.660 align:middle
它能否为我们提供 -确切地说

00:39:55.863 --> 00:40:01.101 align:middle
我提到每个编码器相当于

00:39:55.863 --> 00:40:01.101 align:middle
我提到每个编码器相当于

00:40:01.168 --> 00:40:04.471 align:middle
一个vertex pass
和一个碎片pass

00:40:05.272 --> 00:40:08.408 align:middle
这甚至在MT编码器中也适用

00:40:08.475 --> 00:40:10.143 align:middle
这个是相当重要的

00:40:10.777 --> 00:40:13.580 align:middle
这里 事实上
我们有两个G buffer编码器

00:40:14.181 --> 00:40:17.284 align:middle
而第一个似乎没绘制任何东西

00:40:17.351 --> 00:40:19.253 align:middle
我猜这是误操作造成的

00:40:19.987 --> 00:40:23.290 align:middle
事实上 它对性能还是有影响的

00:40:24.758 --> 00:40:26.627 align:middle
但是看下app的系统轨道
就可以知道

00:40:27.961 --> 00:40:33.267 align:middle
由于空编码器
在GPU中消耗了2.8毫秒

00:40:34.001 --> 00:40:39.139 align:middle
由此推测它刚为
我们所有的attachment

00:40:39.206 --> 00:40:41.742 align:middle
三个颜色和两个深度

00:40:41.975 --> 00:40:44.278 align:middle
和网板写出了清晰的颜色

00:40:46.346 --> 00:40:50.551 align:middle
这个特殊框架GPU处理时间

00:40:50.617 --> 00:40:52.886 align:middle
总计是22毫秒

00:40:54.555 --> 00:40:56.957 align:middle
现在 如果我们移除MT编码器

00:40:57.024 --> 00:41:00.327 align:middle
这可以很容易就做到
因为MT编码器本就不该

00:40:57.024 --> 00:41:00.327 align:middle
这可以很容易就做到
因为MT编码器本就不该

00:41:01.261 --> 00:41:05.332 align:middle
在第一个位置时间就降到了19
非常好

00:41:05.399 --> 00:41:06.800 align:middle
只需做极少的事情 就达成目标

00:41:07.167 --> 00:41:09.469 align:middle
所以小心这些MT编码器

00:41:09.536 --> 00:41:11.839 align:middle
若你不打算在pass进行任何绘制

00:41:11.905 --> 00:41:14.241 align:middle
就别启动编码

00:41:17.644 --> 00:41:19.646 align:middle
我们来详细看一下

00:41:19.746 --> 00:41:22.783 align:middle
来看看样本app上的渲染pass

00:41:22.850 --> 00:41:24.284 align:middle
并看看我们都有些什么

00:41:25.485 --> 00:41:27.387 align:middle
所以我们有一个阴影pass

00:41:27.454 --> 00:41:30.090 align:middle
它转化成了一个深度缓冲器

00:41:30.991 --> 00:41:32.426 align:middle
有一个G buffer pass

00:41:32.492 --> 00:41:34.661 align:middle
它转化成3个
color attachment

00:41:34.728 --> 00:41:36.763 align:middle
一个深度和网板attachment

00:41:37.464 --> 00:41:40.167 align:middle
有这三个lighting pass

00:41:40.234 --> 00:41:45.138 align:middle
它用来自G buffer pass
的渲染attachment数据

00:41:45.272 --> 00:41:48.342 align:middle
要么通过纹理单位进行取样

00:41:48.408 --> 00:41:51.311 align:middle
要么加载到框架缓冲器内容

00:41:52.546 --> 00:41:57.117 align:middle
当lighting pass
使用这个数据时

00:41:57.618 --> 00:42:00.087 align:middle
它们完成lighting和输出

00:41:57.618 --> 00:42:00.087 align:middle
它们完成lighting和输出

00:42:00.153 --> 00:42:02.789 align:middle
使之成一个单一积聚对象

00:42:02.856 --> 00:42:04.157 align:middle
这个对象被多次使用

00:42:04.858 --> 00:42:07.394 align:middle
最后你有一个用户界面pass

00:42:07.461 --> 00:42:10.531 align:middle
在这个pass上
用户界面元素在屏幕上

00:42:11.098 --> 00:42:12.466 align:middle
被画出并被展示出来

00:42:13.967 --> 00:42:18.071 align:middle
所以 这是否是编码器最有效的设置？

00:42:18.872 --> 00:42:22.576 align:middle
再一次
我们调用Xcode框架调试器

00:42:22.643 --> 00:42:24.178 align:middle
看看它是否还有什么问题

00:42:25.312 --> 00:42:26.813 align:middle
再一次 是的 它做到了

00:42:26.880 --> 00:42:29.616 align:middle
它和sunlight编码器不协调

00:42:30.450 --> 00:42:31.852 align:middle
我们来详细看一下

00:42:32.486 --> 00:42:35.522 align:middle
使用命令编码器并没有什么效率

00:42:36.857 --> 00:42:38.926 align:middle
使用Xcode就足够了
它可以告诉我们

00:42:38.992 --> 00:42:41.862 align:middle
事实上 我们应该联合哪一些

00:42:43.564 --> 00:42:47.668 align:middle
我们继续 来合并一些pass

00:42:48.168 --> 00:42:51.371 align:middle
与其合并两个 不如合并三个

00:42:51.438 --> 00:42:54.141 align:middle
他们都在同一个上起作用
color attachment

00:42:54.908 --> 00:42:56.710 align:middle
我们继续 进行合并

00:42:56.910 --> 00:42:58.612 align:middle
这里 我们有6个pass

00:42:59.246 --> 00:43:01.682 align:middle
现在他们将把它们合并成4个

00:42:59.246 --> 00:43:01.682 align:middle
现在他们将把它们合并成4个

00:43:02.950 --> 00:43:06.954 align:middle
所以对于性能
GPU方面会有什么影响呢？

00:43:07.888 --> 00:43:11.425 align:middle
我们转到GPU 系统轨道

00:43:12.459 --> 00:43:16.864 align:middle
这里可以看到 我们从21毫秒

00:43:16.930 --> 00:43:20.934 align:middle
6个pass降低到18 而且不需要

00:43:21.001 --> 00:43:23.770 align:middle
写出所有的加载
存储所有的attachment数据

00:43:24.505 --> 00:43:25.839 align:middle
真是好极了

00:43:27.241 --> 00:43:29.042 align:middle
但是 是否能在进一步呢？

00:43:30.143 --> 00:43:31.845 align:middle
让我们回到app

00:43:32.746 --> 00:43:39.686 align:middle
我们有4个pass它是否真的可以

00:43:39.753 --> 00:43:44.658 align:middle
合并G buffer和
lighting pass免去存储

00:43:44.725 --> 00:43:49.062 align:middle
5个attachment
并将所有的一切都保存在芯片上？

00:43:50.063 --> 00:43:52.599 align:middle
是的 它真的可以

00:43:52.666 --> 00:43:56.570 align:middle
我们可以通过巧妙的
使用可编程调配做到这点

00:43:57.638 --> 00:43:59.373 align:middle
这里 我不会讲太多细节

00:43:59.439 --> 00:44:04.144 align:middle
我们所做的是
将两个编码器合并成一个

00:43:59.439 --> 00:44:04.144 align:middle
我们所做的是
将两个编码器合并成一个

00:44:04.711 --> 00:44:07.381 align:middle
现在 三个渲染编码器被留下来

00:44:08.048 --> 00:44:12.386 align:middle
我们必须加载并存储
极少的attachment数据

00:44:12.452 --> 00:44:13.921 align:middle
从带宽方面来说

00:44:13.987 --> 00:44:15.455 align:middle
这是个巨大的胜利

00:44:16.690 --> 00:44:18.659 align:middle
来看看有什么影响

00:44:19.993 --> 00:44:21.161 align:middle
事实上 并不多

00:44:21.428 --> 00:44:23.497 align:middle
这简直是出乎意料

00:44:23.564 --> 00:44:26.200 align:middle
我们只减掉了大约1毫秒

00:44:26.667 --> 00:44:28.101 align:middle
不是很好

00:44:28.168 --> 00:44:29.603 align:middle
我原本希望可以减掉更多的

00:44:30.971 --> 00:44:33.740 align:middle
再一次 Xcode能否挽救我们？

00:44:34.675 --> 00:44:36.944 align:middle
我们转向Xcode框架调试器

00:44:38.245 --> 00:44:41.615 align:middle
来详细看下为G buffer编码器

00:44:42.015 --> 00:44:43.817 align:middle
加载和存储带宽

00:44:45.886 --> 00:44:50.490 align:middle
它显示的是 事实上我们仍然加载
和存储了大量的数据

00:44:51.491 --> 00:44:53.694 align:middle
原因很简单

00:44:54.127 --> 00:44:57.564 align:middle
看起来似乎是
我们并未为每个attachment

00:44:58.031 --> 00:45:00.701 align:middle
正确设置加载和存储行动

00:44:58.031 --> 00:45:00.701 align:middle
正确设置加载和存储行动

00:45:01.535 --> 00:45:05.706 align:middle
我们只想存储第一个
color attachment

00:45:06.106 --> 00:45:08.909 align:middle
除了深度
和网板attachment外

00:45:08.976 --> 00:45:11.745 align:middle
其他的都要放弃 我们当然也不想加载

00:45:12.546 --> 00:45:14.982 align:middle
这些放弃掉的
color attachment

00:45:16.416 --> 00:45:21.221 align:middle
所以 若我做了个简单的变动 让加载

00:45:21.288 --> 00:45:24.124 align:middle
和存储行动变得更合适

00:45:24.825 --> 00:45:28.128 align:middle
加载带宽就被减到0

00:45:28.195 --> 00:45:31.832 align:middle
我们也大量减少

00:45:31.899 --> 00:45:33.734 align:middle
存储attachment数据的数量

00:45:35.302 --> 00:45:38.472 align:middle
所以现在有什么影响呢？

00:45:39.273 --> 00:45:41.875 align:middle
先前 GPU上

00:45:42.242 --> 00:45:44.912 align:middle
三个pass就花了17毫秒

00:45:45.812 --> 00:45:48.582 align:middle
现在 它减到14毫秒

00:45:48.649 --> 00:45:49.550 align:middle
更接近一些了

00:45:51.718 --> 00:45:55.489 align:middle
简而言之 不要浪费你的渲染编码器

00:45:55.589 --> 00:45:58.158 align:middle
想在它们上面
尽可能的多做些有用的工作

00:45:59.059 --> 00:46:01.695 align:middle
那就不想画任何东西的时候

00:45:59.059 --> 00:46:01.695 align:middle
那就不想画任何东西的时候

00:46:01.762 --> 00:46:03.330 align:middle
就别启动编码

00:46:05.265 --> 00:46:10.437 align:middle
如果你可以在Xcode的帮助下

00:46:10.504 --> 00:46:13.073 align:middle
合并渲染到同一
attachment上的编码器

00:46:13.140 --> 00:46:15.008 align:middle
这将让你获益良多

00:46:17.110 --> 00:46:20.380 align:middle
在GPU方面 我们做得相当好

00:46:20.480 --> 00:46:24.151 align:middle
事实上
我们是在我们的框架预算之内

00:46:25.485 --> 00:46:28.488 align:middle
但我们是否能在CPU上做些什么呢？

00:46:29.690 --> 00:46:32.693 align:middle
如果你记得 我想事实上我们仍然

00:46:32.759 --> 00:46:34.394 align:middle
有点超出我们的框架预算

00:46:35.863 --> 00:46:37.331 align:middle
多线程怎么样？

00:46:37.397 --> 00:46:39.099 align:middle
多线程会如何帮助我们？

00:46:40.234 --> 00:46:43.303 align:middle
在多线程方面
Metal允许我做些什么？

00:46:44.505 --> 00:46:48.575 align:middle
很幸运
Metal在考虑了多线程的基础上

00:46:49.510 --> 00:46:53.480 align:middle
设计出来的
它有一个非常有效的线程安全

00:46:53.547 --> 00:46:57.284 align:middle
和一些多线程渲染工具的可扩展方法

00:46:58.085 --> 00:47:03.090 align:middle
它允许你在不同的线程上
同时对多重命令缓冲器进行编码

00:46:58.085 --> 00:47:03.090 align:middle
它允许你在不同的线程上
同时对多重命令缓冲器进行编码

00:47:03.891 --> 00:47:04.958 align:middle
你的app控制了

00:47:05.025 --> 00:47:07.895 align:middle
正在执行编码的命令

00:47:09.396 --> 00:47:12.199 align:middle
我们来看一下可能的情境

00:47:12.266 --> 00:47:14.034 align:middle
在这个情境里
我们可能尝试一些多线程

00:47:14.968 --> 00:47:17.271 align:middle
开始之前 我想要强调

00:47:17.337 --> 00:47:20.374 align:middle
在你开始对你的渲染进

00:47:20.440 --> 00:47:21.742 align:middle
行多线程处理之前

00:47:21.808 --> 00:47:24.178 align:middle
你应该积极寻找

00:47:24.244 --> 00:47:26.680 align:middle
达到最佳单线程性能的可能

00:47:27.214 --> 00:47:30.017 align:middle
在你开始进行多线程处理之前

00:47:30.083 --> 00:47:32.119 align:middle
确保资源足够

00:47:34.288 --> 00:47:38.358 align:middle
好了 这里有个示例
里面有两个渲染pass

00:47:39.326 --> 00:47:45.933 align:middle
事实上CPU对
这两个pass进行编码时间太长

00:47:45.999 --> 00:47:51.638 align:middle
导致我们错过了框架截止期限

00:47:53.006 --> 00:47:54.741 align:middle
所以 如何改进呢？

00:47:55.375 --> 00:47:57.878 align:middle
我们可以继续

00:47:58.278 --> 00:48:00.113 align:middle
对两个pass采用并行编辑

00:47:58.278 --> 00:48:00.113 align:middle
对两个pass采用并行编辑

00:48:00.881 --> 00:48:06.186 align:middle
不仅是设法减少每帧的CPU时间

00:48:07.287 --> 00:48:10.991 align:middle
副作用是 第一个渲染pass会

00:48:11.058 --> 00:48:13.493 align:middle
更快地被提交到GPU中

00:48:16.997 --> 00:48:19.700 align:middle
在Metal对象方面
这个看起来是怎么样的？

00:48:20.934 --> 00:48:22.369 align:middle
如何一起使用呢？

00:48:22.836 --> 00:48:26.240 align:middle
照例从
命令队列中的Metal设备开始

00:48:28.175 --> 00:48:29.576 align:middle
现在这个示例

00:48:29.643 --> 00:48:30.844 align:middle
我们将有三个线程

00:48:31.912 --> 00:48:34.414 align:middle
每个线程需要一个命令缓冲器

00:48:36.416 --> 00:48:41.755 align:middle
这两个线程每个都有一个Render
Command Encoder

00:48:41.822 --> 00:48:44.291 align:middle
在单独的pass上起作用

00:48:45.325 --> 00:48:50.430 align:middle
第三个线程上 我们可能有

00:48:51.131 --> 00:48:52.432 align:middle
持续执行的多重编码器

00:48:53.033 --> 00:48:55.035 align:middle
为多线程展示方法

00:48:55.102 --> 00:48:57.371 align:middle
可以是非常灵活的

00:48:58.305 --> 00:49:00.641 align:middle
一旦编码完成了

00:48:58.305 --> 00:49:00.641 align:middle
一旦编码完成了

00:49:00.707 --> 00:49:03.410 align:middle
命令缓冲器就会被提交到命令队列中

00:49:04.978 --> 00:49:07.181 align:middle
所以 你会怎么设置呢？

00:49:08.549 --> 00:49:09.783 align:middle
非常简单

00:49:10.651 --> 00:49:15.189 align:middle
你为每个线程创建一个命令缓冲器
然后继续

00:49:15.255 --> 00:49:18.926 align:middle
像往常一样初始化渲染pass

00:49:19.593 --> 00:49:23.130 align:middle
现在 重要的一点是命令

00:49:23.197 --> 00:49:26.934 align:middle
在命令里
命令缓冲器将被提交到GPU中

00:49:27.835 --> 00:49:29.937 align:middle
有可能这对你很重要

00:49:30.270 --> 00:49:33.874 align:middle
所以你通过调用命令缓冲器里的

00:49:34.308 --> 00:49:37.277 align:middle
Enqueue方法执行它

00:49:37.344 --> 00:49:40.814 align:middle
它在命令队列里保存了位置

00:49:41.148 --> 00:49:43.584 align:middle
所以当缓冲器运作时

00:49:43.984 --> 00:49:47.154 align:middle
它们将按照排列的顺序被执行

00:49:47.754 --> 00:49:49.890 align:middle
这点很重要 需要记住

00:49:50.490 --> 00:49:55.095 align:middle
因为随后为每个线程创建渲染编码器

00:49:55.762 --> 00:50:00.067 align:middle
然后继续
在分开的线程中对绘制进行编码

00:49:55.762 --> 00:50:00.067 align:middle
然后继续
在分开的线程中对绘制进行编码

00:50:00.133 --> 00:50:02.102 align:middle
然后提交命令缓冲器

00:50:02.736 --> 00:50:04.471 align:middle
真的很简单

00:50:06.840 --> 00:50:08.742 align:middle
其他可能从多线程中

00:50:08.842 --> 00:50:11.245 align:middle
获益的情境怎么样？

00:50:13.080 --> 00:50:15.249 align:middle
这里 我们有两个pass

00:50:15.782 --> 00:50:18.018 align:middle
其中一个比另一个明显长很多

00:50:18.819 --> 00:50:20.621 align:middle
可以将它分离吗？

00:50:20.888 --> 00:50:22.189 align:middle
是的 可以

00:50:22.523 --> 00:50:25.692 align:middle
我们将它分成两个单独的pass

00:50:26.059 --> 00:50:27.261 align:middle
这里 我们有三个线程

00:50:27.895 --> 00:50:29.830 align:middle
一个在第一个渲染pass上起作用

00:50:29.897 --> 00:50:33.400 align:middle
另两个则在第二组块上起作用

00:50:34.234 --> 00:50:37.037 align:middle
再一次 通过使用多线程

00:50:37.104 --> 00:50:39.740 align:middle
我们没有超过框架截止期限

00:50:40.407 --> 00:50:42.776 align:middle
我们在CPU上节省了一些时间

00:50:42.843 --> 00:50:45.245 align:middle
可以用来做我们喜欢的事

00:50:45.779 --> 00:50:48.115 align:middle
无需更多的Metal工作

00:50:49.650 --> 00:50:52.953 align:middle
我们怎么确切地说这看起来像什么？

00:50:54.521 --> 00:50:58.358 align:middle
再一次 我们有设备和命令队列

00:50:59.526 --> 00:51:02.296 align:middle
在这个示例中 我们将用到三个线程

00:50:59.526 --> 00:51:02.296 align:middle
在这个示例中 我们将用到三个线程

00:51:03.864 --> 00:51:06.733 align:middle
但是我们只想用一个命令缓冲器

00:51:09.069 --> 00:51:13.273 align:middle
有Render Command
Encoder的特别格式

00:51:13.340 --> 00:51:16.076 align:middle
Parallel Render
Command Encoder

00:51:16.176 --> 00:51:21.448 align:middle
现在 这允许你越过多重线程

00:51:21.815 --> 00:51:26.053 align:middle
为单个编码器分离工作
在iOS上使用这个尤其重要

00:51:26.453 --> 00:51:30.457 align:middle
因为它确保线程的工作量

00:51:30.524 --> 00:51:34.194 align:middle
随后在GPU中
被合并成一个单个pass

00:51:34.261 --> 00:51:38.699 align:middle
所以pass之间并无加载和存储

00:51:38.832 --> 00:51:41.335 align:middle
如果你将在多重线程里拆分

00:51:41.401 --> 00:51:43.971 align:middle
一个单个pass
使用这个就很重要了

00:51:45.506 --> 00:51:47.941 align:middle
从Parallel Render
Command Encoder里

00:51:48.008 --> 00:51:52.012 align:middle
我们创建了三个从属命令编码器

00:51:53.213 --> 00:51:56.783 align:middle
现在每个都将编码成命令缓冲器

00:51:57.184 --> 00:52:01.054 align:middle
因为我们正在多重线程化

00:51:57.184 --> 00:52:01.054 align:middle
因为我们正在多重线程化

00:52:01.522 --> 00:52:03.190 align:middle
编码可能在不同的时间里被完成

00:52:03.257 --> 00:52:05.692 align:middle
无需特别的命令

00:52:06.860 --> 00:52:09.530 align:middle
然后命令缓冲器提交到队列

00:52:10.597 --> 00:52:12.666 align:middle
现在 它完全可行

00:52:12.733 --> 00:52:15.135 align:middle
你甚至可以有并行

00:52:15.202 --> 00:52:18.105 align:middle
Parallel Render
Command Encoders

00:52:18.539 --> 00:52:22.776 align:middle
多线程可能性并非无止境

00:52:22.843 --> 00:52:23.710 align:middle
但是非常的灵活

00:52:24.444 --> 00:52:26.780 align:middle
你也可以有我们刚看到的

00:52:26.847 --> 00:52:28.882 align:middle
你可以有第四个线程

00:52:28.949 --> 00:52:32.085 align:middle
连续地执行编码器

00:52:34.188 --> 00:52:36.557 align:middle
所以我们如何设置？

00:52:38.325 --> 00:52:42.729 align:middle
每Parallel Render
Command Encoder

00:52:42.796 --> 00:52:43.897 align:middle
创建一个命令缓冲器开始

00:52:44.431 --> 00:52:46.233 align:middle
不管有多少个使用中的线程

00:52:46.300 --> 00:52:47.701 align:middle
你只需要一个命令缓冲器

00:52:49.436 --> 00:52:54.141 align:middle
然后 和往常一样
继续初始化渲染pass

00:52:55.209 --> 00:52:58.979 align:middle
然后创建真实的并行编码器

00:52:59.613 --> 00:53:01.014 align:middle
现在 这里是重要的显存位宽

00:52:59.613 --> 00:53:01.014 align:middle
现在 这里是重要的显存位宽

00:53:02.516 --> 00:53:05.452 align:middle
在我们创建附属编码器时

00:53:06.019 --> 00:53:09.790 align:middle
创建编码器的命令决定

00:53:09.857 --> 00:53:12.659 align:middle
编码器提交到GPU的顺序

00:53:12.726 --> 00:53:15.462 align:middle
在你为多线程编码分离工作量时

00:53:15.529 --> 00:53:18.432 align:middle
就需要考虑到这点

00:53:20.434 --> 00:53:24.605 align:middle
然后我们继续 编码绘图 分离线程

00:53:25.205 --> 00:53:28.709 align:middle
然后为每个附属编码器完成编码

00:53:29.977 --> 00:53:31.712 align:middle
现在 第二个重要的点是

00:53:31.778 --> 00:53:35.883 align:middle
所有的附属编码器必须在我们结束

00:53:35.949 --> 00:53:39.253 align:middle
并行编码器编码之前完成编码

00:53:40.220 --> 00:53:41.922 align:middle
如何执行 取决于你

00:53:42.923 --> 00:53:46.059 align:middle
最后 命令缓冲器致力于队列

00:53:48.295 --> 00:53:52.633 align:middle
所以 我们继续
我们决定对我们的app多线程化

00:53:53.600 --> 00:53:54.601 align:middle
看看都有什么

00:53:56.103 --> 00:54:00.641 align:middle
先前 我们有连续编码或pass

00:53:56.103 --> 00:54:00.641 align:middle
先前 我们有连续编码或pass

00:54:01.842 --> 00:54:07.114 align:middle
这个用了CPU时间的25毫秒

00:54:08.248 --> 00:54:15.022 align:middle
现在 我们找到一种方法
即在一个线程里编码阴影pass

00:54:15.856 --> 00:54:20.661 align:middle
在其他线程上编码G buffer
pass和UI pass

00:54:21.662 --> 00:54:24.264 align:middle
现在时间减到少15毫秒

00:54:25.299 --> 00:54:27.835 align:middle
这是一个改进

00:54:27.901 --> 00:54:32.105 align:middle
我们同样也在CPU上节省了一些时间

00:54:34.174 --> 00:54:36.810 align:middle
直到多线程化进行

00:54:36.877 --> 00:54:40.380 align:middle
如果你发现你仍在CPU范围内

00:54:40.581 --> 00:54:42.616 align:middle
而且你已经做了所有你能做的调查

00:54:42.683 --> 00:54:46.220 align:middle
确定app上没有愚蠢的事正在进行

00:54:46.854 --> 00:54:49.289 align:middle
那你就可以从多线程化里获益了

00:54:50.023 --> 00:54:51.825 align:middle
你可以在多线程上

00:54:51.892 --> 00:54:54.061 align:middle
同时编码渲染pass

00:54:54.761 --> 00:54:57.831 align:middle
但是你决定在多线程里分离

00:54:58.298 --> 00:54:59.499 align:middle
一个单个pass

00:54:59.967 --> 00:55:03.403 align:middle
想用Parallel Render
Command Encoder来做

00:54:59.967 --> 00:55:03.403 align:middle
想用Parallel Render
Command Encoder来做

00:55:06.673 --> 00:55:09.409 align:middle
现在 我从这部分学到了什么？

00:55:10.944 --> 00:55:13.313 align:middle
我们介绍了Metal系统寻踪工具

00:55:13.380 --> 00:55:14.681 align:middle
它真的很棒

00:55:14.748 --> 00:55:17.818 align:middle
它为你的app Metal
性能提供了新理解

00:55:18.619 --> 00:55:21.688 align:middle
你想要和Xecode一起配合使用

00:55:21.822 --> 00:55:23.290 align:middle
进行早期分析 并经常进行分析

00:55:25.592 --> 00:55:27.461 align:middle
正如我们看到的 你也应该试着

00:55:27.528 --> 00:55:29.830 align:middle
遵循陈述过的最优方法

00:55:30.631 --> 00:55:34.234 align:middle
所以你想提前创建消耗多的状态

00:55:34.301 --> 00:55:35.836 align:middle
并尽可能重复使用状态

00:55:36.970 --> 00:55:39.940 align:middle
我们想要缓冲动态资源

00:55:40.440 --> 00:55:44.077 align:middle
所以我们可以在框架之间进行有效修改

00:55:44.144 --> 00:55:45.212 align:middle
而不会引起任何拖延

00:55:46.747 --> 00:55:50.083 align:middle
我们想要确保我们在适当的时候

00:55:50.150 --> 00:55:52.352 align:middle
在正确的点上获得Drawable

00:55:52.719 --> 00:55:54.621 align:middle
通常在最后的可能时刻

00:55:56.089 --> 00:55:58.592 align:middle
我们想确保我们有效使用

00:55:58.659 --> 00:56:00.761 align:middle
Render
Command Encoders

00:55:58.659 --> 00:56:00.761 align:middle
Render
Command Encoders

00:56:00.827 --> 00:56:03.163 align:middle
我们没有任何空的编码器

00:56:03.230 --> 00:56:06.800 align:middle
我们把为相同
attachment所写的

00:56:06.867 --> 00:56:08.535 align:middle
任何编码器都合并成一个

00:56:10.103 --> 00:56:14.141 align:middle
然后
倘若发现我们还在CPU范围内

00:56:14.208 --> 00:56:18.679 align:middle
正如在这里案例中看到了
我们可以考虑由Metal提供

00:56:18.946 --> 00:56:20.380 align:middle
用来将渲染多线程化的方法

00:56:22.049 --> 00:56:23.150 align:middle
所以 我是怎么做的？

00:56:25.853 --> 00:56:27.788 align:middle
现在 看我们的app

00:56:28.322 --> 00:56:30.791 align:middle
我们没有任何执行期着色器编辑

00:56:31.692 --> 00:56:36.597 align:middle
GPU工作量在框架截止期限内

00:56:36.663 --> 00:56:37.531 align:middle
很好

00:56:38.198 --> 00:56:40.267 align:middle
本来就是CPU的工作量

00:56:41.368 --> 00:56:45.372 align:middle
在CPU上框架之间的处理没有差距

00:56:48.442 --> 00:56:51.578 align:middle
我们甚至可以决定进行多线程

00:56:52.179 --> 00:56:54.848 align:middle
我们节省了不少时间
可以用来做其他事情

00:56:56.550 --> 00:56:58.952 align:middle
我们设法达到我们的对象

00:56:59.019 --> 00:57:01.021 align:middle
在这个示例中 它是60帧每秒

00:56:59.019 --> 00:57:01.021 align:middle
在这个示例中 它是60帧每秒

00:57:01.088 --> 00:57:02.089 align:middle
做得好！

00:57:05.225 --> 00:57:08.562 align:middle
现在 演讲结束了 如果你需要

00:57:08.629 --> 00:57:11.298 align:middle
这部分提到的更多信息

00:57:11.365 --> 00:57:14.535 align:middle
你可以访问我们的开发者门户网站

00:57:14.902 --> 00:57:18.005 align:middle
你可以在开发者论坛注册

00:57:18.906 --> 00:57:22.543 align:middle
任何详细的问题或一般询问

00:57:22.609 --> 00:57:26.079 align:middle
你可以将它们发送给艾伦 卡夫

00:57:26.146 --> 00:57:27.881 align:middle
他是我们的图像和游戏技术专员

00:57:29.483 --> 00:57:32.319 align:middle
感谢你们来参加这个演讲

00:57:32.386 --> 00:57:34.788 align:middle
希望你不会觉得无聊

00:57:34.855 --> 00:57:37.891 align:middle
请享受WWDC剩下的部分

00:57:38.292 --> 00:57:39.293 align:middle
谢谢
