WEBVTT

00:00:28.428 --> 00:00:29.930 align:middle
JAKE BEHRENS: 早上好

00:00:30.764 --> 00:00:32.866 align:middle
欢迎来到
"WatchKit 提示和技巧"

00:00:32.933 --> 00:00:34.268 align:middle
我叫Jake Behrens，

00:00:34.334 --> 00:00:36.937 align:middle
我是苹果watchOS框架的讲师

00:00:38.038 --> 00:00:40.407 align:middle
今天，我们将讨论
如何利用的不同的方法

00:00:40.474 --> 00:00:44.378 align:middle
去优化你在
watchOS上安装的应用

00:00:44.444 --> 00:00:45.746 align:middle
在 watchOS 1中

00:00:46.780 --> 00:00:49.116 align:middle
将会有很多我们需要讨论的东西

00:00:49.349 --> 00:00:52.653 align:middle
同样这个也适用于watchOS 2

00:00:53.020 --> 00:00:55.155 align:middle
在讨论的过程中 我将会指出这些

00:00:58.025 --> 00:01:00.794 align:middle
如今 随着之前苹果手表的发布之后

00:00:58.025 --> 00:01:00.794 align:middle
如今 随着之前苹果手表的发布之后

00:01:01.328 --> 00:01:03.230 align:middle
在写第一个手表app的过程中

00:01:03.297 --> 00:01:06.767 align:middle
我们有了和很多个
开发者一起工作的经历

00:01:07.568 --> 00:01:10.537 align:middle
在这个过程中我们学到了很多

00:01:11.071 --> 00:01:13.740 align:middle
而今天我们也将会和你们分享很多关于

00:01:15.075 --> 00:01:17.411 align:middle
类似于怎样优化你的网络

00:01:17.945 --> 00:01:22.249 align:middle
或者怎样减少你的
下载时间等很有用的知识

00:01:23.851 --> 00:01:25.953 align:middle
所以 首先让我们从数据和交流开始吧

00:01:26.753 --> 00:01:28.355 align:middle
正如我前面所提到

00:01:28.655 --> 00:01:33.293 align:middle
从你的web服务器上或者安装的苹果
应用程序中 获取信息是至关重要的

00:01:33.627 --> 00:01:35.395 align:middle
以至于你必须将一部分内容

00:01:35.729 --> 00:01:38.999 align:middle
去实际的显示给用户

00:01:41.201 --> 00:01:44.171 align:middle
现在，想象一下
你的用户正在车站等候

00:01:44.738 --> 00:01:47.975 align:middle
他们抬高了自己的手腕
他们正在和你的应用程序进行交互

00:01:48.375 --> 00:01:50.544 align:middle
突然你启动了一个网络请求

00:01:50.611 --> 00:01:53.113 align:middle
然后公共汽车从拐角处开过来了

00:01:53.514 --> 00:01:55.916 align:middle
因为他们得到了自己
想要的东西所以用户们放下了胳膊

00:01:56.183 --> 00:02:00.287 align:middle
然后他们匆忙地朝着
公共汽车赶去上车然后坐下来

00:01:56.183 --> 00:02:00.287 align:middle
然后他们匆忙地朝着
公共汽车赶去上车然后坐下来

00:02:01.021 --> 00:02:03.357 align:middle
好了你要做的事情
就是确保下一次提高手腕

00:02:03.423 --> 00:02:05.893 align:middle
他们重新回到你的应用程序中的时候

00:02:06.193 --> 00:02:08.294 align:middle
数据仍然在那儿等着他们

00:02:08.895 --> 00:02:11.164 align:middle
而不是你必须重新读取它

00:02:11.932 --> 00:02:13.734 align:middle
所以 你怎样才能有
效的完成这个过程呢？

00:02:14.368 --> 00:02:17.638 align:middle
好 第一部分就是你需要一个网络请求

00:02:18.038 --> 00:02:20.007 align:middle
这是你如何获得信息的过程

00:02:21.708 --> 00:02:26.914 align:middle
下一步你需要做的就是
询问系统是谁请求了

00:02:26.980 --> 00:02:28.182 align:middle
后台的任务中断处理

00:02:28.549 --> 00:02:33.086 align:middle
这种方法是向系统提出要求
说“嘿 我需要一些时间

00:02:33.554 --> 00:02:36.490 align:middle
因为我可能需要完成某个进程
一旦你开始

00:02:36.557 --> 00:02:38.358 align:middle
暂停我的 WatchKit
扩展程序时”

00:02:40.794 --> 00:02:44.164 align:middle
更进一步 如果你碰上后台任务声明

00:02:44.431 --> 00:02:46.166 align:middle
你会需要将其保持在打开的状态上

00:02:46.366 --> 00:02:49.236 align:middle
以便你的网络请求能够得以完成

00:02:51.205 --> 00:02:52.773 align:middle
那我们怎样去完成这些呢？

00:02:53.173 --> 00:02:54.508 align:middle
现在我们要一起走过整个过程

00:02:55.609 --> 00:03:00.480 align:middle
第一件事你需要做的
是设置好你的网络请求

00:02:55.609 --> 00:03:00.480 align:middle
第一件事你需要做的
是设置好你的网络请求

00:03:00.881 --> 00:03:04.351 align:middle
为此我们将使用
默认 NSURLSession

00:03:05.219 --> 00:03:09.423 align:middle
现在注意 我不会
使用后台 NSURLSession

00:03:09.790 --> 00:03:11.024 align:middle
因为在哪种情况下

00:03:11.091 --> 00:03:13.227 align:middle
如果我们的 WatchKit
扩展程序被暂停了

00:03:13.293 --> 00:03:14.862 align:middle
其完成就会取决

00:03:14.962 --> 00:03:16.730 align:middle
于我们总的 iPhone 应用程序

00:03:16.797 --> 00:03:19.032 align:middle
如果我们要把我们能做的一切

00:03:19.299 --> 00:03:21.301 align:middle
都在 WatchKit
扩展程序中完成

00:03:22.803 --> 00:03:26.273 align:middle
所以 接下来我们要索求
那个后台任务的声明

00:03:26.640 --> 00:03:27.774 align:middle
我们怎样做到这一步？

00:03:29.443 --> 00:03:31.678 align:middle
做到这一步我们需要使用

00:03:33.113 --> 00:03:35.449 align:middle
“合理执行到期活动”

00:03:35.883 --> 00:03:38.318 align:middle
这一NSProcessInfo
上的方法。

00:03:39.486 --> 00:03:42.990 align:middle
这一方法会向系统索求
一个后台任务声明

00:03:43.056 --> 00:03:45.926 align:middle
并说“嘿 我可能仍需做件事情

00:03:45.993 --> 00:03:48.228 align:middle
一旦你要暂停 WatchKit
扩展程序”

00:03:49.329 --> 00:03:53.634 align:middle
做法是 你向系统
传递一个调试字符串

00:03:53.700 --> 00:03:55.302 align:middle
这里字符串是 networkReq

00:03:55.669 --> 00:03:57.771 align:middle
然后系统就会执行那个程序块

00:03:58.505 --> 00:04:02.242 align:middle
现在 该程序块就会立即被调用

00:03:58.505 --> 00:04:02.242 align:middle
现在 该程序块就会立即被调用

00:04:02.342 --> 00:04:05.145 align:middle
当系统调用
“合理执行到期活动 ”时

00:04:05.879 --> 00:04:08.048 align:middle
现在 有些事情要牢记于心

00:04:08.115 --> 00:04:09.650 align:middle
这些事情实在重要

00:04:10.117 --> 00:04:13.854 align:middle
第一件事情是该程序块的执行

00:04:13.921 --> 00:04:15.389 align:middle
将会在一个异步队列上安排

00:04:16.223 --> 00:04:19.392 align:middle
所以你的主队列依然
会被释放出来用户将能与其界面

00:04:19.459 --> 00:04:21.495 align:middle
进行互动这不会有任何问题

00:04:21.762 --> 00:04:25.032 align:middle
用户不会感觉到有任何不同

00:04:25.999 --> 00:04:30.737 align:middle
如果 “已到期” 变量设置为
“假”那就意味着

00:04:30.804 --> 00:04:32.906 align:middle
我们的时间还没用完

00:04:33.173 --> 00:04:36.410 align:middle
也就是 系统已经给了我们
一个后台任务声明

00:04:37.511 --> 00:04:39.713 align:middle
然而 如果失效了

00:04:40.013 --> 00:04:44.151 align:middle
那么久意味着系统不能给
我们提供一个后台任务中断

00:04:44.785 --> 00:04:47.054 align:middle
这意味着系统不能正常的运行

00:04:48.088 --> 00:04:52.192 align:middle
然而 如果说我们
已经有了一个后台任务中断

00:04:52.459 --> 00:04:55.262 align:middle
这就意味着系统可能已经
觉得我们完全没有时间了

00:04:55.429 --> 00:04:59.700 align:middle
所以便在把失效设定为正确之后

00:04:59.766 --> 00:05:01.468 align:middle
再执行这个模块

00:04:59.766 --> 00:05:01.468 align:middle
再执行这个模块

00:05:02.002 --> 00:05:04.071 align:middle
将会给你一段时间

00:05:04.371 --> 00:05:08.242 align:middle
来确保你已经删除了
你所拥有的任何状态

00:05:08.542 --> 00:05:11.445 align:middle
或者在WatchKit
扩展完全终止之前

00:05:11.512 --> 00:05:13.046 align:middle
你需要做一些事情

00:05:14.448 --> 00:05:19.820 align:middle
正如我所说的那样最关键的事情就是
这个模块需要用异步序列的方式去执行

00:05:21.355 --> 00:05:24.424 align:middle
第二个很重要的就是一旦这个

00:05:24.791 --> 00:05:27.661 align:middle
模块执行完毕

00:05:28.128 --> 00:05:30.197 align:middle
然后你的时间消失

00:05:30.397 --> 00:05:32.599 align:middle
它放弃了后台的任务中断

00:05:33.233 --> 00:05:36.703 align:middle
因此我们要做的就是确保

00:05:36.770 --> 00:05:39.673 align:middle
我们有足够的时间
去完成我们的网络请求

00:05:40.340 --> 00:05:41.808 align:middle
可能需要两秒

00:05:42.042 --> 00:05:43.510 align:middle
可能需要十秒

00:05:43.911 --> 00:05:44.878 align:middle
可能花更多时间

00:05:47.481 --> 00:05:50.284 align:start position:10%
我们将会利用称为调度信号量的东西

00:05:51.151 --> 00:05:55.422 align:middle
调度信号量是中央调度
（GCD)的一部分

00:05:55.923 --> 00:06:00.527 align:middle
这本质上允许我们
用一种异步队列的方式

00:05:55.923 --> 00:06:00.527 align:middle
这本质上允许我们
用一种异步队列的方式

00:06:00.594 --> 00:06:02.296 align:middle
去暂停执行

00:06:03.830 --> 00:06:06.834 align:middle
所以称之为“调度信号量等待”

00:06:07.301 --> 00:06:09.369 align:middle
与此同时 它将会暂停执行

00:06:10.137 --> 00:06:13.507 align:middle
但是 在你需要再一次重新启动的时候

00:06:13.640 --> 00:06:15.976 align:middle
你可以请求“调度信号量信号”

00:06:16.977 --> 00:06:19.413 align:middle
现在 请注意我已经经过了一段时间

00:06:19.713 --> 00:06:21.682 align:middle
这本质上是一个超时

00:06:22.282 --> 00:06:24.251 align:middle
在这儿我已经把它设置到30秒了

00:06:24.318 --> 00:06:25.519 align:middle
当然也可以是其他数字

00:06:25.586 --> 00:06:29.489 align:middle
然而我想确定的是
你知道一旦它到达30秒

00:06:29.923 --> 00:06:33.093 align:middle
我应当获得我的数据或者报失

00:06:36.630 --> 00:06:38.665 align:start position:10%
所以这可能有点抽象

00:06:38.999 --> 00:06:41.602 align:middle
而且是有一点点先进的概念

00:06:41.802 --> 00:06:44.371 align:middle
所以让我们看看实际中真正需要的代码

00:06:51.478 --> 00:06:55.816 align:middle
好的 因此我这里有一个为
watchOS 1建立的

00:06:55.883 --> 00:06:57.584 align:middle
WatchKit 扩充

00:06:58.452 --> 00:07:01.955 align:middle
我面前是一个子集工作界面控制器

00:06:58.452 --> 00:07:01.955 align:middle
我面前是一个子集工作界面控制器

00:07:02.990 --> 00:07:06.260 align:middle
您可以看到我做的
第一件事是创建一种属性

00:07:06.326 --> 00:07:08.529 align:middle
用于执行会话数据任务

00:07:08.996 --> 00:07:11.331 align:middle
我们将要用这个数据任务来

00:07:11.765 --> 00:07:14.835 align:middle
从我们的网络服务中提取信息

00:07:17.104 --> 00:07:18.972 align:middle
接下来将激活

00:07:19.606 --> 00:07:23.510 align:middle
并实现您随时随地可以网络编码

00:07:23.710 --> 00:07:25.812 align:middle
就这个例子来说 简而言之

00:07:26.046 --> 00:07:27.514 align:middle
我正在做的就是即将激活

00:07:28.682 --> 00:07:31.318 align:middle
首先我会检查数据任务的状态

00:07:31.485 --> 00:07:33.520 align:middle
我还会看一下它是否已在运行

00:07:34.221 --> 00:07:37.858 align:middle
因为如果用户抬起手腕 开始了互动

00:07:37.925 --> 00:07:40.994 align:middle
开启了网络请求 放低了手腕

00:07:41.195 --> 00:07:44.798 align:middle
启动了后台时间 接着又抬起手腕

00:07:44.865 --> 00:07:49.102 align:middle
但是该请求还没有完成
那么我不想再次启动网络请求

00:07:49.469 --> 00:07:51.772 align:middle
我只会在当前没有网络请求运行时

00:07:51.839 --> 00:07:53.440 align:middle
再次启动网络请求

00:07:56.677 --> 00:07:59.146 align:middle
因此接下来我将创建一个网址

00:07:59.313 --> 00:08:01.748 align:middle
仅指向我的网络服务

00:07:59.313 --> 00:08:01.748 align:middle
仅指向我的网络服务

00:08:01.815 --> 00:08:04.918 align:middle
这里它指向了应用商店的元数据

00:08:06.119 --> 00:08:09.690 align:middle
一旦我有了这个网址我就开始创建信号

00:08:10.023 --> 00:08:11.992 align:middle
称为“发送信号创建”

00:08:13.994 --> 00:08:17.998 align:middle
接下来我将使用一种方法 我称之为

00:08:18.065 --> 00:08:19.533 align:middle
“请求确认信号”

00:08:19.600 --> 00:08:21.702 align:middle
来传送这个新创建的信号

00:08:23.103 --> 00:08:26.306 align:middle
因此 如果我们审视使用
这种方法时正在发生的情形

00:08:26.440 --> 00:08:30.277 align:middle
这其实就是我们所说的
“理性执行到期的活动”

00:08:30.711 --> 00:08:34.248 align:middle
我们正在调试字符串传送
如果到期设设定为假

00:08:34.313 --> 00:08:37.417 align:middle
那就意味着我们获得了一些后台时间

00:08:37.818 --> 00:08:40.087 align:middle
而我正在通过我的逾时进行传送

00:08:40.386 --> 00:08:42.188 align:middle
我称之为“发送信号等待”

00:08:42.923 --> 00:08:47.494 align:middle
记住 这将会导致异步队列暂停执行

00:08:48.095 --> 00:08:51.665 align:middle
没问题 用户依然可以与应用进行互动

00:08:51.732 --> 00:08:53.300 align:middle
假如WatchKit
扩充进入了后台

00:08:53.367 --> 00:08:55.369 align:middle
它就保持在那里

00:08:55.669 --> 00:08:58.539 align:middle
确保了我们有足够的时间

00:08:58.772 --> 00:09:00.140 align:middle
完成我们的网络请求

00:08:58.772 --> 00:09:00.140 align:middle
完成我们的网络请求

00:09:01.675 --> 00:09:04.545 align:middle
那么 如果到期设定为“真”，

00:09:04.778 --> 00:09:07.648 align:middle
这意味着我们或者没有接收到背景任务

00:09:07.714 --> 00:09:09.349 align:middle
执行或者我们可能接受到了

00:09:09.516 --> 00:09:12.886 align:middle
但是现在系统又再次调用它
说你已经超时

00:09:13.253 --> 00:09:15.189 align:start position:10%
那么 我们将调用一个方法

00:09:15.255 --> 00:09:18.158 align:middle
是我创建的称作“用信号释放执行”

00:09:18.258 --> 00:09:20.194 align:middle
再一次传那个信号

00:09:21.195 --> 00:09:25.065 align:middle
所有这些方法实际上就叫“发送信号”

00:09:25.632 --> 00:09:28.502 align:start position:10%
这允许执行恢复 而且它允许完成

00:09:28.569 --> 00:09:33.907 align:middle
阻止 它也对调用非常关键

00:09:33.974 --> 00:09:38.545 align:middle
因为如果我们停止
执行的时间太长 系统会认为

00:09:38.612 --> 00:09:41.682 align:middle
我们的进程已经暂停 这样不好

00:09:41.815 --> 00:09:45.185 align:middle
因为最后它直接停止了进程

00:09:45.485 --> 00:09:49.022 align:middle
所以，我们没有任何
机会保存状态或做任何清理

00:09:49.323 --> 00:09:51.425 align:middle
我们直接就被停止了

00:09:53.427 --> 00:09:55.863 align:middle
好 那么让我们回到“意愿激活”

00:09:56.597 --> 00:09:58.632 align:middle
所以我们被要求执行任务

00:09:58.699 --> 00:10:01.935 align:middle
接下来要做的事情就是我们要使用

00:09:58.699 --> 00:10:01.935 align:middle
接下来要做的事情就是我们要使用

00:10:02.002 --> 00:10:04.137 align:middle
我们的URL来创建数据任务

00:10:04.905 --> 00:10:07.407 align:middle
现在 注意到我没有传送它

00:10:07.474 --> 00:10:10.844 align:middle
不管我有没有背景任务执行

00:10:11.712 --> 00:10:13.981 align:middle
背景任务执行技术

00:10:14.147 --> 00:10:16.884 align:middle
是一个获得额外时间的方法 对吧？

00:10:17.117 --> 00:10:21.288 align:middle
我的意思是它不能确保
但是我们希望能用此得到更好的体验

00:10:21.722 --> 00:10:24.424 align:middle
所以我就创建我们网络要求

00:10:24.491 --> 00:10:28.762 align:middle
因为可能用户
正在这时用app互动交流

00:10:29.196 --> 00:10:33.901 align:start position:10%
网络要求已经开始并且
在很短的时间应答一切都很顺利

00:10:35.435 --> 00:10:39.740 align:middle
你在此还看到有一个
用于数据任务的便利完成处理程序

00:10:40.240 --> 00:10:42.142 align:middle
所以当要求结束时

00:10:42.409 --> 00:10:45.379 align:middle
我将调用“用信号释放执行”

00:10:45.612 --> 00:10:47.347 align:middle
再次传递那一信号

00:10:47.748 --> 00:10:51.185 align:middle
所以我们允许对异步队列执行恢复

00:10:51.251 --> 00:10:54.221 align:middle
这允许阻止完成

00:10:54.288 --> 00:10:57.057 align:middle
然后 WatchKit
扩展可以完全挂起。

00:10:57.891 --> 00:11:01.428 align:middle
这会确保系统不会认为操作进程已挂起

00:10:57.891 --> 00:11:01.428 align:middle
这会确保系统不会认为操作进程已挂起

00:11:02.996 --> 00:11:06.033 align:middle
这样 一旦创建数据任务

00:11:06.600 --> 00:11:11.271 align:middle
我们就可以调用恢复来启动
这样它可以去网路

00:11:11.338 --> 00:11:15.309 align:middle
获取信息 我们处理其余工作

00:11:19.780 --> 00:11:20.614 align:middle
现在

00:11:22.149 --> 00:11:25.853 align:middle
你对这项技术有了一些了解

00:11:25.919 --> 00:11:28.222 align:middle
可以使用它尝试并行使

00:11:28.288 --> 00:11:32.826 align:middle
WatchKit
extension内的联网权利

00:11:33.393 --> 00:11:37.197 align:middle
这是非常不错的体验
因为进入到watchOS2

00:11:37.698 --> 00:11:40.634 align:middle
你就会有很多可以利用的东西

00:11:40.767 --> 00:11:42.569 align:middle
我们将对此稍作介绍

00:11:42.936 --> 00:11:45.739 align:middle
但你如果已经联网到

00:11:45.873 --> 00:11:47.608 align:middle
WatchKit
extension

00:11:47.674 --> 00:11:51.044 align:middle
这将会使你做好准备一切都已经就绪

00:11:51.411 --> 00:11:56.083 align:middle
我看到过许多例子在使用打开父代程序

00:11:56.350 --> 00:11:59.653 align:middle
使内置的
iPhone app 完成联网

00:11:59.920 --> 00:12:01.722 align:middle
这会中断桥接

00:11:59.920 --> 00:12:01.722 align:middle
这会中断桥接

00:12:05.826 --> 00:12:10.264 align:middle
现在 在某些情况下
我们的网络服务不提供数据

00:12:10.564 --> 00:12:13.734 align:middle
数据实际已经在内置的
iPhone app内

00:12:14.301 --> 00:12:15.502 align:middle
如需要得到数据

00:12:15.836 --> 00:12:20.007 align:middle
我们实际需要越过
watchOS 1中的进程

00:12:20.073 --> 00:12:22.009 align:middle
从WatchKit
extension

00:12:22.075 --> 00:12:23.577 align:middle
进入到内置的iPhone app

00:12:24.578 --> 00:12:27.748 align:middle
我们可以使用打开父代程序来完成

00:12:27.814 --> 00:12:30.951 align:middle
这是基于WK界面控制器的方法

00:12:31.185 --> 00:12:34.021 align:middle
可以让我们发送信息词典

00:12:34.321 --> 00:12:37.391 align:middle
到iPhone app
并在后台启动它

00:12:37.691 --> 00:12:40.961 align:middle
让它进行一些处理并发送响应

00:12:42.429 --> 00:12:44.398 align:middle
在UI程序委托上

00:12:44.665 --> 00:12:47.835 align:middle
我们选择‘处理WatchKit
extension请求响应’

00:12:48.502 --> 00:12:51.004 align:middle
这将会进入信息词典

00:12:51.572 --> 00:12:55.008 align:middle
进行一些处理并发送响应

00:12:56.276 --> 00:12:59.012 align:middle
在使用中还需要考虑一些问题

00:13:00.047 --> 00:13:03.584 align:middle
第一如果在‘处理WatchKit
extension请求’中

00:13:03.650 --> 00:13:07.120 align:middle
有任何异步操作 你应确保创建了

00:13:07.454 --> 00:13:10.457 align:middle
一个后台任务

00:13:11.191 --> 00:13:14.328 align:middle
你想在进入该方法后立刻完成

00:13:14.394 --> 00:13:17.631 align:middle
原因是如果你离开并决定

00:13:17.698 --> 00:13:20.234 align:middle
完成一些异步操作
那么不管它是多么琐碎

00:13:20.567 --> 00:13:22.703 align:middle
系统会说‘好

00:13:22.769 --> 00:13:24.972 align:middle
我想我们实际并不想做什么

00:13:25.038 --> 00:13:28.242 align:middle
那么我就要去暂停
iPhone app了’

00:13:28.709 --> 00:13:31.512 align:middle
然后 你将失去机会发送响应

00:13:33.180 --> 00:13:36.250 align:middle
另一件事是在你将发送响应时

00:13:36.884 --> 00:13:38.752 align:middle
如果使用定制对象

00:13:39.052 --> 00:13:41.255 align:middle
则应把它们变成NSData

00:13:42.089 --> 00:13:45.359 align:middle
如果使用定制的二元格式

00:13:45.425 --> 00:13:47.761 align:middle
则可以在WatchKit
extension打开

00:13:47.928 --> 00:13:50.731 align:middle
这样更可取因为一个重要的方面

00:13:50.797 --> 00:13:55.202 align:middle
就是使数据尽可能变小这样传输才最快

00:13:58.272 --> 00:14:03.110 align:middle
现在 对于设备对设备的交流
我们已有很多了解

00:13:58.272 --> 00:14:03.110 align:middle
现在 对于设备对设备的交流
我们已有很多了解

00:14:04.278 --> 00:14:08.215 align:middle
现在，在watchOS 2中
‘打开父代程序’标为不可用

00:14:08.649 --> 00:14:10.918 align:middle
这是因为不再有这个必要

00:14:11.151 --> 00:14:12.286 align:middle
也不再需要

00:14:12.853 --> 00:14:15.522 align:middle
因为现在我们有了
WatchConnectivity

00:14:15.589 --> 00:14:16.490 align:middle
framework

00:14:16.924 --> 00:14:20.594 align:middle
这对我们有很大帮助

00:14:21.061 --> 00:14:25.132 align:middle
我们不仅可以在iPhone
app之间发送信息

00:14:25.499 --> 00:14:27.034 align:middle
而且还可以输送文件

00:14:27.334 --> 00:14:29.903 align:middle
你还可以 也应当利用

00:14:30.170 --> 00:14:34.341 align:middle
应用程序上下文

00:14:34.875 --> 00:14:37.678 align:middle
这样就可以用最新信息

00:14:38.011 --> 00:14:40.080 align:middle
更新该上下文

00:14:40.914 --> 00:14:44.151 align:middle
同时使你可以获得网络上
Watch app内的信息

00:14:44.518 --> 00:14:47.487 align:middle
也许这是提供的最新功能

00:14:48.021 --> 00:14:52.526 align:middle
然后 你会说‘iPhone app
以后会需要这样所以我想终止它’

00:14:53.060 --> 00:14:54.494 align:middle
它将会被转移

00:14:54.928 --> 00:14:56.797 align:middle
但是iPhone app并未被启动

00:14:56.864 --> 00:14:59.766 align:middle
因为它现在实际并不需要处理任何事情

00:15:00.267 --> 00:15:02.636 align:middle
所以在这种情况下 它只是等待

00:15:02.803 --> 00:15:04.905 align:middle
下一次iPhone app的启动

00:15:05.305 --> 00:15:10.110 align:middle
这是在设备之间完成交流的高效方式

00:15:11.512 --> 00:15:13.113 align:middle
这里 有一个精彩的演讲题目为

00:15:13.180 --> 00:15:15.516 align:middle
“Watch
Connectivity 介绍”

00:15:15.582 --> 00:15:18.252 align:middle
你应当进行了解
如果还没这样做的话

00:15:20.821 --> 00:15:24.558 align:middle
现在 一旦我们获得了数据
就需要进行管理

00:15:24.825 --> 00:15:28.428 align:middle
和维护 然而我们需要
把它存放在硬盘中

00:15:29.563 --> 00:15:30.864 align:middle
在watchOS 1中

00:15:30.998 --> 00:15:34.134 align:middle
使用应用程序组是
做这项工作的一个非常好的方法

00:15:34.501 --> 00:15:36.904 align:middle
你可以使用共享的应用组集合

00:15:37.104 --> 00:15:40.574 align:middle
储存一些模型数据或一些共享资产

00:15:40.707 --> 00:15:42.176 align:middle
内置iPhone app

00:15:42.242 --> 00:15:44.278 align:middle
和WatchKit
extension

00:15:44.511 --> 00:15:46.613 align:middle
可以指向并找到它们

00:15:49.216 --> 00:15:53.053 align:middle
现在 你也可以使用共享的
NSUserdefaults

00:15:53.587 --> 00:15:57.191 align:middle
但应当用于较小的状态数据

00:15:57.324 --> 00:15:59.560 align:middle
比如 Boolean
configuration

00:15:59.626 --> 00:16:01.662 align:middle
或类似数据它并不适用于模型数据

00:15:59.626 --> 00:16:01.662 align:middle
或类似数据它并不适用于模型数据

00:16:01.862 --> 00:16:04.398 align:middle
模型数据一般比较大

00:16:04.598 --> 00:16:09.603 align:middle
应以平面文件保存

00:16:09.670 --> 00:16:13.574 align:middle
在你的共享集合或数据存储中

00:16:15.976 --> 00:16:19.680 align:middle
通常 针对watchOS 1
或watchOS 2

00:16:19.913 --> 00:16:23.183 align:middle
你应考虑简化模型

00:16:24.351 --> 00:16:26.920 align:middle
Apple Watch上的体验与

00:16:26.987 --> 00:16:28.422 align:middle
iPhone是非常不同的

00:16:28.856 --> 00:16:34.261 align:middle
所以你想确保得到信息是你所需要的

00:16:35.329 --> 00:16:38.165 align:middle
这方面的一个例子是WWDC app

00:16:38.732 --> 00:16:41.468 align:middle
多年以来 在WWDC app之中

00:16:41.735 --> 00:16:43.971 align:middle
我们不再把实体增添到

00:16:44.037 --> 00:16:45.272 align:middle
Core Data模型中

00:16:46.340 --> 00:16:50.277 align:middle
当我们去进行Apple
Watch的体验时

00:16:51.044 --> 00:16:52.446 align:middle
我们看看它然后说

00:16:52.913 --> 00:16:55.616 align:middle
我们实际上不需要
Watch上的这一切

00:16:56.183 --> 00:16:59.253 align:middle
我们对此进行了讨论
并且最终认识到

00:16:59.319 --> 00:17:02.556 align:middle
我们所需要的是数据的简化版

00:16:59.319 --> 00:17:02.556 align:middle
我们所需要的是数据的简化版

00:17:03.524 --> 00:17:06.226 align:middle
我们仅仅需要这些演讲的简单列表

00:17:06.326 --> 00:17:09.863 align:middle
包括演讲 实验以及收藏

00:17:10.964 --> 00:17:15.035 align:middle
我们需要做的是
创建一个操作在任何时间

00:17:15.102 --> 00:17:16.936 align:middle
内置iPhone app的
数据可以变化

00:17:17.304 --> 00:17:20.874 align:middle
它可以输出一套简化的JSON文件

00:17:20.941 --> 00:17:22.675 align:middle
到共享组集合

00:17:23.010 --> 00:17:25.412 align:middle
WatchKit
extension可以读取

00:17:25.479 --> 00:17:26.547 align:middle
并予以展示

00:17:27.681 --> 00:17:28.749 align:middle
这是非常棒的体验

00:17:31.385 --> 00:17:35.956 align:middle
设备对应设备交流的最后一种方式是

00:17:36.256 --> 00:17:37.591 align:middle
使用Handoff

00:17:38.358 --> 00:17:41.361 align:middle
Handoff是一种
非常的方式可以让用户

00:17:41.428 --> 00:17:44.865 align:middle
从Apple Watch到
iPhone上继续一项活动

00:17:46.099 --> 00:17:48.969 align:middle
这方面的一个例子是如果你使用

00:17:49.036 --> 00:17:51.839 align:middle
Apple Watch上的
WWDC app

00:17:52.573 --> 00:17:55.943 align:middle
你会注意到iPhone的锁屏上

00:17:56.043 --> 00:17:57.578 align:middle
在要查看的特定区域的左下角

00:17:58.111 --> 00:18:02.649 align:middle
有WWDC app的图标

00:17:58.111 --> 00:18:02.649 align:middle
有WWDC app的图标

00:18:03.650 --> 00:18:06.320 align:middle
现在 如果你从左下角向上滑动

00:18:06.653 --> 00:18:08.989 align:middle
就会进入iPhone上
WWDC app

00:18:09.256 --> 00:18:11.692 align:middle
你想要的位置

00:18:12.860 --> 00:18:14.795 align:middle
这对于用户来说非常有用

00:18:16.997 --> 00:18:19.166 align:middle
使用Handoff非常简单

00:18:20.534 --> 00:18:22.569 align:middle
你可以使用WK界面管理器

00:18:22.836 --> 00:18:24.972 align:middle
更新用户活动

00:18:25.539 --> 00:18:30.344 align:middle
你还可以向用户发送一个NS数据词典

00:18:30.711 --> 00:18:32.980 align:middle
记住该词典应

00:18:33.046 --> 00:18:35.282 align:middle
包括你需要的一切

00:18:35.616 --> 00:18:38.685 align:middle
这样iPhone app
才能使用户到达

00:18:38.752 --> 00:18:40.053 align:middle
他们想去的位置

00:18:40.287 --> 00:18:43.357 align:middle
因此 无论你需要的数据多么琐碎

00:18:43.690 --> 00:18:46.159 align:middle
都需要输入到词典中

00:18:48.729 --> 00:18:53.066 align:middle
这样 系统会自动为你工作

00:18:53.433 --> 00:18:58.405 align:middle
其中之一是自动使用户活动

00:18:58.639 --> 00:18:59.973 align:middle
在一段时间后失效

00:19:00.574 --> 00:19:02.843 align:middle
所以你什么都不用做

00:19:02.910 --> 00:19:06.513 align:middle
给用户足够的时间拿出电话

00:19:06.680 --> 00:19:07.915 align:middle
去他们想去的地方

00:19:08.382 --> 00:19:11.418 align:middle
如果你再次调用‘更新用户活动’

00:19:11.652 --> 00:19:14.021 align:middle
即是目前的活动

00:19:14.588 --> 00:19:16.957 align:middle
如果他们切换到另一应用

00:19:17.157 --> 00:19:19.092 align:middle
而该应用调用‘更新用户活动’

00:19:19.193 --> 00:19:20.794 align:middle
即是目前的活动

00:19:22.362 --> 00:19:25.532 align:middle
现在 如果你
已经调用了‘更新用户活动’

00:19:25.766 --> 00:19:28.769 align:middle
但是当时用户正在与你的应用进行交互

00:19:29.136 --> 00:19:31.939 align:middle
他们轻敲一个按钮
确实可以使背景发生转换

00:19:32.673 --> 00:19:36.476 align:middle
你实际上可自己手动使用户活动无效

00:19:37.878 --> 00:19:41.548 align:middle
如果没有出现这种情况你什么都不用做

00:19:44.117 --> 00:19:45.552 align:middle
因此数据足够

00:19:46.753 --> 00:19:51.525 align:middle
我希望watchOS 1对你有用

00:19:51.625 --> 00:19:53.760 align:middle
尤其是 一旦你开始使用

00:19:54.127 --> 00:19:56.797 align:middle
WatchConnectivity
framework

00:19:56.864 --> 00:19:59.900 align:middle
它即会帮你
向watchOS 2过渡

00:20:01.068 --> 00:20:03.237 align:middle
现在让我们来谈谈界面组件

00:20:04.037 --> 00:20:06.607 align:middle
在你创造这个世界创建这些数据时

00:20:06.940 --> 00:20:11.345 align:middle
你最不希望给用户的体验

00:20:11.612 --> 00:20:13.480 align:middle
是加载指示条

00:20:13.547 --> 00:20:15.983 align:middle
你所做所有这些是为了一个控制器

00:20:16.416 --> 00:20:18.952 align:middle
每一件东西用户可能都会想要或需要

00:20:20.787 --> 00:20:24.625 align:middle
让我们看看如何能够优化这种体验

00:20:25.058 --> 00:20:26.660 align:middle
我们如何能够加载更快？

00:20:28.729 --> 00:20:30.230 align:middle
其中一种方法是我们可以...

00:20:30.397 --> 00:20:34.902 align:middle
通过优选加载方法和时间来实现

00:20:35.402 --> 00:20:37.237 align:middle
所以你这里可以看到
watchOS 1的

00:20:37.371 --> 00:20:38.605 align:middle
Weather app

00:20:39.039 --> 00:20:42.009 align:middle
而且我们有这个漂亮的大信息环

00:20:42.643 --> 00:20:45.946 align:start position:10%
对吗？我们想立刻把它呈现给用户

00:20:48.248 --> 00:20:50.484 align:middle
但是我们还有个10日预报

00:20:50.984 --> 00:20:53.987 align:middle
这个10日预报包括另外一些图像

00:20:54.288 --> 00:20:58.458 align:middle
表格行 数据 而我们也
不一定想要用户

00:20:58.525 --> 00:21:01.728 align:middle
等我们加载所有这些东西

00:20:58.525 --> 00:21:01.728 align:middle
等我们加载所有这些东西

00:21:02.963 --> 00:21:04.464 align:middle
因此我们采用一种技术使得我们在

00:21:04.531 --> 00:21:06.433 align:middle
‘异步分派’内加载10日预报时

00:21:06.733 --> 00:21:10.204 align:middle
call within将激活

00:21:11.705 --> 00:21:14.441 align:middle
现在，这样做可以使得
will activate完成

00:21:14.575 --> 00:21:16.009 align:middle
而一旦我们有了这个图像

00:21:16.243 --> 00:21:18.145 align:middle
则最先显示它

00:21:18.412 --> 00:21:21.081 align:middle
因此我们将其呈现在
will activate即可完成

00:21:21.248 --> 00:21:25.519 align:middle
之后即立刻加载10日预报

00:21:26.119 --> 00:21:28.689 align:middle
而用户实际并未看出有什么不同

00:21:28.956 --> 00:21:32.960 align:middle
当我们向下滚动至10日预报
则它已经在那里了

00:21:33.594 --> 00:21:38.065 align:middle
但是我们已经能够
给大家所有数据立即加载

00:21:38.131 --> 00:21:39.867 align:middle
并且更快的印象了

00:21:41.902 --> 00:21:45.305 align:middle
其他你能够做的就是
少直接加载几个表格单元格

00:21:46.039 --> 00:21:50.010 align:middle
对吗？如果你确实
有带图表和数据的单元格

00:21:50.177 --> 00:21:54.515 align:middle
那么你可能只要四五个这样的单元格

00:21:54.581 --> 00:21:56.750 align:middle
直接显示给用户即可

00:21:56.817 --> 00:21:59.620 align:middle
这些加载之后

00:22:00.020 --> 00:22:01.421 align:middle
你可能希望能够在别处加载

00:22:01.822 --> 00:22:03.290 align:middle
因此看一下

00:22:05.692 --> 00:22:09.196 align:middle
同时 只要更新
实际发生变更的信息即可

00:22:09.463 --> 00:22:11.899 align:middle
我见过许多数据只做了一点小小变更

00:22:11.965 --> 00:22:15.002 align:middle
就全部重新加载的例子

00:22:15.636 --> 00:22:16.670 align:middle
无需如此

00:22:16.970 --> 00:22:21.141 align:middle
只要更新这个屏面实际
需要更新的内容就可以了

00:22:23.277 --> 00:22:26.513 align:middle
现在 我们一旦进入界面
Builder你就能看到

00:22:26.580 --> 00:22:29.283 align:middle
我已经在为控制器创建我的布局了

00:22:30.017 --> 00:22:32.519 align:middle
而我将用到许多不同的群组

00:22:32.586 --> 00:22:34.488 align:middle
我将隐藏和显示许多不同的群组

00:22:34.755 --> 00:22:37.591 align:middle
因为根据某些数据或启发

00:22:37.658 --> 00:22:40.827 align:middle
我只打算一次显示一个
也可能一次两个

00:22:42.362 --> 00:22:45.232 align:middle
但是实际上我已经将所有这些东西

00:22:45.299 --> 00:22:50.437 align:middle
放在我的控制器里了也就是说
系统将会把这些全部实例化

00:22:50.938 --> 00:22:55.442 align:middle
因为我们实际上并不知道你什么
时候会决定隐藏或显示其内容

00:22:55.776 --> 00:22:59.313 align:middle
因此在某些情形下你可以对其稍作优化

00:22:59.479 --> 00:23:02.049 align:middle
方法是将这些分到一些单独的控制器中

00:22:59.479 --> 00:23:02.049 align:middle
方法是将这些分到一些单独的控制器中

00:23:02.683 --> 00:23:05.485 align:middle
如果必要时你能够加载其中某个

00:23:05.552 --> 00:23:07.087 align:middle
你确实会需要的控制器

00:23:07.421 --> 00:23:08.922 align:middle
那么就最好了

00:23:12.259 --> 00:23:14.828 align:middle
现在 穿过我们的界面组件

00:23:15.362 --> 00:23:18.799 align:middle
其中你可能常用的是图像

00:23:19.600 --> 00:23:23.537 align:middle
而图像应该大小合适 来自你的服务器

00:23:23.704 --> 00:23:25.172 align:middle
或所包括的iPhone app

00:23:25.906 --> 00:23:30.010 align:middle
我看到过许多这样的例子图像较大

00:23:30.077 --> 00:23:33.413 align:middle
甚至比42毫米的watch还大

00:23:33.780 --> 00:23:36.917 align:middle
而该图像其实只是
随处被重复使用和重新缩放

00:23:37.618 --> 00:23:40.187 align:middle
我这里的意思是
对于缩放 还有其他性能上的含义

00:23:40.254 --> 00:23:43.857 align:middle
而图像不会像它看起来那么好

00:23:43.924 --> 00:23:48.195 align:middle
因为你没有给它你恰好需要的尺寸

00:23:48.729 --> 00:23:51.899 align:middle
所以要给出正确尺寸的asset

00:23:52.232 --> 00:23:56.937 align:middle
在watchOS 2中
这可能对视频很关键

00:23:59.106 --> 00:24:01.909 align:middle
你也可以优化你的图像

00:23:59.106 --> 00:24:01.909 align:middle
你也可以优化你的图像

00:24:02.242 --> 00:24:06.046 align:middle
方法是采用‘设定图像数据’
而不只是‘设定图像’

00:24:07.114 --> 00:24:09.716 align:middle
此时‘设定图像’

00:24:09.783 --> 00:24:12.886 align:middle
只是要采用我们所用的默认压缩

00:24:13.654 --> 00:24:15.155 align:middle
通过‘设定图像数据’

00:24:15.222 --> 00:24:20.294 align:middle
你可以得到PNG压缩或JPG压缩

00:24:20.694 --> 00:24:23.630 align:middle
之后转成NS数据blob

00:24:24.131 --> 00:24:26.099 align:middle
以传送至Watch

00:24:26.300 --> 00:24:29.770 align:middle
从而你可以确保其大小符合你的需要

00:24:32.172 --> 00:24:35.242 align:middle
同时 我确信你听人们说过这样的话

00:24:35.309 --> 00:24:37.311 align:middle
你应该用asset catalog

00:24:37.978 --> 00:24:42.316 align:middle
asset catalog不仅是
整理其中内容的好方法

00:24:42.783 --> 00:24:45.319 align:middle
而且还能够为你做很多别的事情

00:24:45.385 --> 00:24:50.624 align:middle
你可以设定该
asset用于哪些具体设备

00:24:51.325 --> 00:24:56.129 align:middle
你可以设定并轻松看到
‘是的 我有了2x asset

00:24:56.530 --> 00:25:00.467 align:middle
38毫米版本和42毫米版本’

00:24:56.530 --> 00:25:00.467 align:middle
38毫米版本和42毫米版本’

00:25:02.102 --> 00:25:06.006 align:middle
目前 许多开发者问我...

00:25:06.173 --> 00:25:07.975 align:middle
这些插槽每一个
都什么时候用以及用在哪

00:25:08.041 --> 00:25:09.710 align:middle
那么让我们一起来看看。

00:25:10.777 --> 00:25:13.480 align:middle
首先是2x asset

00:25:13.947 --> 00:25:18.418 align:middle
这个用于你想要在两台设备

00:25:18.552 --> 00:25:20.721 align:middle
以相同尺寸采用的图像

00:25:21.088 --> 00:25:25.292 align:middle
所以 如果是这样
你可以将它插入2x插槽即可

00:25:25.359 --> 00:25:27.094 align:middle
其他地方用法相同

00:25:28.729 --> 00:25:33.267 align:middle
你还可以针对38毫米
提供具体的asset

00:25:34.334 --> 00:25:38.338 align:middle
现在 这可能就是
你要插入2x插槽的图像

00:25:38.739 --> 00:25:39.573 align:middle
没问题

00:25:41.074 --> 00:25:44.444 align:middle
然后你可以给出
一个具体的asset

00:25:44.511 --> 00:25:49.082 align:middle
针对可能大一些的
42毫米版本会有所不同

00:25:49.950 --> 00:25:52.986 align:middle
现在 如果你既有38毫米

00:25:53.053 --> 00:25:57.057 align:middle
也有42毫米 没问题
也用2xasset

00:25:57.124 --> 00:26:00.961 align:middle
因为我们要回退到该asset

00:25:57.124 --> 00:26:00.961 align:middle
因为我们要回退到该asset

00:26:01.361 --> 00:26:06.300 align:middle
所以 如果我们用
38毫米版本或42毫米版本

00:26:06.600 --> 00:26:08.802 align:middle
我们要回退到2x asset

00:26:09.636 --> 00:26:12.606 align:middle
这样 你的代码库将永不过时

00:26:15.375 --> 00:26:19.379 align:middle
另一项我们发现对WWDC app
确实有用的技术

00:26:19.847 --> 00:26:21.315 align:middle
正在采用PDFs

00:26:22.950 --> 00:26:26.720 align:middle
通过采用PDFs 你可以从各工具中

00:26:26.954 --> 00:26:29.122 align:middle
去除整批free work

00:26:30.190 --> 00:26:32.426 align:middle
首先 你可以设定缩放因子

00:26:33.760 --> 00:26:37.497 align:middle
你还可以设定图像生成的类型

00:26:37.698 --> 00:26:40.767 align:middle
作为模板图像所以如果你要给图像着色

00:26:40.934 --> 00:26:43.637 align:middle
那么去看看PDF的α值

00:26:44.905 --> 00:26:48.709 align:middle
如果你仍然想要你特别放入
你的asset中的这些颜色

00:26:48.775 --> 00:26:51.144 align:middle
你也可以设定为原图

00:26:52.312 --> 00:26:57.851 align:middle
这里所有事情就是当系统为你打包时

00:26:57.918 --> 00:27:01.421 align:middle
当你前去创建它时
我们要剪切这个PDF

00:26:57.918 --> 00:27:01.421 align:middle
当你前去创建它时
我们要剪切这个PDF

00:27:01.488 --> 00:27:06.193 align:middle
所有尺寸及比例按你的需要
用于你支持的设备

00:27:07.027 --> 00:27:08.962 align:middle
免费的资源很多

00:27:10.264 --> 00:27:13.534 align:middle
另一件很酷的事情
是你可以把PDF文件

00:27:13.600 --> 00:27:16.036 align:middle
与位图进行混合和匹配

00:27:16.470 --> 00:27:20.674 align:middle
你可以把这两种格式的文件
组合进一个PDF备用脚本

00:27:21.475 --> 00:27:26.046 align:middle
这样就可以分别得到38毫米

00:27:26.113 --> 00:27:27.681 align:middle
和42毫米版本的位图了

00:27:31.084 --> 00:27:35.689 align:middle
说完图片 我们来说说动画图像

00:27:36.223 --> 00:27:41.461 align:middle
在watchOS 1里 我们提供了
一个你可以大加利用的动画图像序列

00:27:41.895 --> 00:27:44.164 align:middle
在watchOS2里也可以这样做

00:27:44.898 --> 00:27:48.001 align:middle
但是不要忘了如果你的屏幕上

00:27:48.068 --> 00:27:50.571 align:middle
同时有多个动画图像 嗯

00:27:50.637 --> 00:27:53.440 align:middle
你就需要做更多处理和渲染

00:27:55.809 --> 00:27:59.346 align:middle
你需要注意的另外一点是你要尽量控制

00:27:59.613 --> 00:28:05.052 align:middle
自己减少每部动画的帧数

00:27:59.613 --> 00:28:05.052 align:middle
自己减少每部动画的帧数

00:28:05.819 --> 00:28:09.189 align:middle
我见过很多的这样的案例
一段只有两秒的动画

00:28:09.256 --> 00:28:10.691 align:middle
里面足足有300帧

00:28:11.291 --> 00:28:12.659 align:middle
似乎有点儿过分了

00:28:13.427 --> 00:28:16.363 align:middle
如果帧数减少了 但是仍然

00:28:16.430 --> 00:28:18.732 align:middle
可以得到你真正想要的效果

00:28:18.799 --> 00:28:20.300 align:middle
你会感到惊喜的

00:28:21.969 --> 00:28:26.673 align:middle
另一项你可以对这些动画图像
进行的操作是逆向播放

00:28:27.274 --> 00:28:29.643 align:middle
你不必另行创建一个全新的图像集

00:28:30.077 --> 00:28:32.412 align:middle
你只需选取一个已有的动画文件

00:28:32.579 --> 00:28:35.215 align:middle
将时间设置为负值

00:28:35.949 --> 00:28:39.887 align:middle
这项操作叫做“用图片启动动画”

00:28:40.287 --> 00:28:42.422 align:middle
你来设定一个负时间值

00:28:43.423 --> 00:28:46.560 align:middle
请注意我的时间范围是正向的

00:28:47.094 --> 00:28:50.430 align:middle
跨度是从0到15

00:28:50.497 --> 00:28:51.765 align:middle
这里我没做改变

00:28:52.466 --> 00:28:53.500 align:middle
只更改了持续时间

00:28:55.502 --> 00:29:01.775 align:middle
现在如果你喜欢动画在watchOS
2环境里 你可以大展拳脚了

00:28:55.502 --> 00:29:01.775 align:middle
现在如果你喜欢动画在watchOS
2环境里 你可以大展拳脚了

00:29:02.709 --> 00:29:06.280 align:middle
在watchOS 2里 我们引入了
一个动画应用程序界面API

00:29:06.346 --> 00:29:07.848 align:middle
它是WatchKit的一个部分

00:29:08.048 --> 00:29:11.385 align:middle
让你可以在你的Watch
app里制作出流畅的

00:29:11.451 --> 00:29:12.819 align:middle
效果强大的动画作品

00:29:13.921 --> 00:29:16.857 align:middle
它与UIView的动画工作原理近似

00:29:17.191 --> 00:29:20.460 align:middle
你可以自行设定时间长度 还一个模块

00:29:20.527 --> 00:29:22.829 align:middle
可以在这个区域重置一些属性

00:29:22.896 --> 00:29:24.631 align:middle
这些最终都将合成在你的动画作品里

00:29:25.732 --> 00:29:30.204 align:middle
你可以设置动画的高度 宽度 通道

00:29:30.571 --> 00:29:32.639 align:middle
内容嵌入以及其他属性

00:29:32.806 --> 00:29:36.743 align:middle
到目前为止 我已经见到了人们用这个
程序制作的一些相当了不起的作品

00:29:36.810 --> 00:29:39.680 align:middle
而且只用到了间隔组和移动项

00:29:39.847 --> 00:29:41.014 align:middle
相当了不起

00:29:42.316 --> 00:29:47.588 align:middle
在“WatchKit布局
和动画技术”中 还有很多有用的工具

00:29:48.789 --> 00:29:53.927 align:middle
关于图像处理 我建议大家

00:29:53.994 --> 00:29:57.397 align:middle
关注今天的讲座中"Apple
Watch设计建议与技巧"这一部分

00:29:57.564 --> 00:30:02.636 align:middle
它将会从设计者心态的
角度涉及很多的相关技巧

00:29:57.564 --> 00:30:02.636 align:middle
它将会从设计者心态的
角度涉及很多的相关技巧

00:30:02.703 --> 00:30:04.605 align:middle
还会谈及大量

00:30:04.671 --> 00:30:06.273 align:middle
你可以做和应该了解的操作

00:30:06.640 --> 00:30:07.574 align:middle
所以 一定要关注

00:30:09.209 --> 00:30:14.348 align:middle
配置的最后一块是
文本输入控制器的使用

00:30:15.649 --> 00:30:18.719 align:middle
现在 很多开发人员问我怎样才能

00:30:18.785 --> 00:30:23.457 align:middle
使用户直接从我的UI进入?听写UI

00:30:25.592 --> 00:30:27.828 align:middle
他们不希望自己的用户要经过

00:30:27.895 --> 00:30:30.864 align:middle
中间筛屏幕 并不停地敲击麦克风

00:30:30.931 --> 00:30:33.433 align:middle
这样做相当 相当直接

00:30:34.301 --> 00:30:39.940 align:middle
你只要在调用“目前的文本输入器
与建议”时 把建议设定为零

00:30:40.541 --> 00:30:43.777 align:middle
然后把“允许输入模式”设定为普通

00:30:44.611 --> 00:30:47.447 align:middle
这样就可以把用户从你的app直接

00:30:47.514 --> 00:30:51.018 align:middle
转入听写UI然后再返回你的app

00:30:51.451 --> 00:30:52.653 align:middle
极其简单

00:30:56.857 --> 00:30:59.026 align:middle
现在我们要谈谈通知机制

00:30:59.459 --> 00:31:02.896 align:middle
消息通知是Apple Watch上
一项意义重大的体验

00:30:59.459 --> 00:31:02.896 align:middle
消息通知是Apple Watch上
一项意义重大的体验

00:31:02.963 --> 00:31:05.732 align:middle
Apple Watch能够如此
操作简便 表现惊人

00:31:05.799 --> 00:31:07.935 align:middle
很大程度上归功于此

00:31:10.003 --> 00:31:14.408 align:middle
让我们看一个远程
通知的有效载荷的例子

00:31:14.775 --> 00:31:17.110 align:middle
让我们浏览一些你应该清楚的

00:31:17.177 --> 00:31:20.047 align:middle
为了让用户的手腕得到最好

00:31:20.113 --> 00:31:22.583 align:middle
最高效的体验而使用的技术

00:31:23.984 --> 00:31:29.089 align:middle
首先要注意的是
你应该正在使用报警键的字典值

00:31:29.890 --> 00:31:32.426 align:middle
这让你可以不仅提供一段正文

00:31:32.726 --> 00:31:34.661 align:middle
还可以设定一个标题

00:31:35.629 --> 00:31:38.999 align:middle
而且这个标题可以被用在
short-look通知里

00:31:39.633 --> 00:31:43.437 align:middle
所以当用户在Apple
Watch上收到通知时

00:31:43.504 --> 00:31:47.374 align:middle
他们首先看到的就是你的app的又大

00:31:47.441 --> 00:31:51.812 align:middle
又漂亮的图标 然后要看到的
是在屏幕底部的你的app的名字

00:31:52.412 --> 00:31:55.315 align:middle
如果你在有效负荷里提供了一个标题

00:31:55.382 --> 00:31:58.986 align:middle
图标和app名称之间看到那个标题

00:31:59.620 --> 00:32:03.557 align:middle
这样可以使通知的内容大为丰富

00:31:59.620 --> 00:32:03.557 align:middle
这样可以使通知的内容大为丰富

00:32:03.924 --> 00:32:07.694 align:middle
非常了不起 因为那么多的用户

00:32:07.761 --> 00:32:10.397 align:middle
要看他们的手腕他们会看到那条通知

00:32:10.464 --> 00:32:13.467 align:middle
并根据其信息决定他们是要继续看

00:32:13.534 --> 00:32:15.502 align:middle
long-look 通知

00:32:15.903 --> 00:32:19.439 align:middle
还是把它先放下
过一段时间再到通知中心查看

00:32:20.240 --> 00:32:22.009 align:middle
所以要好好利用它

00:32:23.844 --> 00:32:26.180 align:middle
另一个要运用的功能
是categary(类别)

00:32:26.780 --> 00:32:29.349 align:middle
Categories（类别）
让你可以指定

00:32:29.516 --> 00:32:33.587 align:middle
使用记事板中的具体哪一种控制器

00:32:33.921 --> 00:32:36.089 align:middle
来发送某种类型的信息

00:32:36.823 --> 00:32:40.027 align:middle
所以如果你点击通知类别对象

00:32:40.460 --> 00:32:42.462 align:middle
你可以在这里看到 你可以给它设置

00:32:42.529 --> 00:32:48.168 align:middle
与在有效负荷中相同的名称
所以你可以给每条通知设置

00:32:48.502 --> 00:32:51.271 align:middle
文本颜色和标题颜色

00:32:51.505 --> 00:32:55.542 align:middle
所以你就有很多办法

00:32:55.609 --> 00:32:57.578 align:middle
可以给通知设置多种属性

00:32:57.878 --> 00:32:59.980 align:middle
给用户更好的体验

00:33:02.249 --> 00:33:06.153 align:middle
现在是最后一步
如果你想让客户收到通知

00:33:06.386 --> 00:33:10.123 align:middle
听到通知提示音并收到触觉反馈

00:33:10.591 --> 00:33:13.894 align:middle
你需要设置音量值为默认值

00:33:15.028 --> 00:33:16.330 align:middle
这样可以确保

00:33:16.597 --> 00:33:19.533 align:middle
他们收到提示音和反馈

00:33:21.134 --> 00:33:26.473 align:middle
现在 我非常高兴地告诉大家你也
可以用UI本地通知来实现这些效果

00:33:26.907 --> 00:33:29.810 align:middle
所以 这些设置不仅可以用在远程通知

00:33:32.913 --> 00:33:36.517 align:middle
现在 共有两个通知的概念

00:33:37.217 --> 00:33:39.620 align:middle
第一个是动态通知

00:33:39.786 --> 00:33:42.189 align:start position:10%
你可能在有效负荷中收到一些信息

00:33:42.422 --> 00:33:44.858 align:middle
你需要处理这些信息
你需要得到一种资产

00:33:44.925 --> 00:33:47.528 align:middle
你需要进行一些操作 然后你要上传

00:33:47.828 --> 00:33:50.998 align:start position:10%
更多丰富的内容到你的动态信息中

00:33:51.431 --> 00:33:53.467 align:middle
还有一种静态信息

00:33:53.800 --> 00:33:57.070 align:middle
很多人问过我哪里会用到这种信息

00:33:57.804 --> 00:34:03.043 align:middle
静态信息总是由通知中心发出

00:33:57.804 --> 00:34:03.043 align:middle
静态信息总是由通知中心发出

00:34:03.610 --> 00:34:08.849 align:middle
所以如果用户点击通知中心发出的信息

00:34:08.916 --> 00:34:11.552 align:middle
他们一定会看到静态界面

00:34:11.985 --> 00:34:15.222 align:middle
所以你要确保这同时是一个很好的体验

00:34:16.389 --> 00:34:19.659 align:middle
使用静态通知的另一种情况

00:34:20.027 --> 00:34:23.897 align:middle
是你的动态通知下载时间过长

00:34:24.364 --> 00:34:27.868 align:middle
你可能正在处理一些数据从网络检索

00:34:27.935 --> 00:34:30.670 align:middle
一些资产 而且需要很长时间

00:34:31.004 --> 00:34:33.306 align:middle
那么我们就要称之为损耗

00:34:33.607 --> 00:34:38.545 align:middle
并以静态信息的方式
立即为客户提供一些有价值的信息

00:34:41.547 --> 00:34:44.217 align:middle
现在我们终于可以聊一聊
Glances

00:34:45.918 --> 00:34:49.822 align:middle
有了Glances就可以为客户提供

00:34:49.889 --> 00:34:52.993 align:middle
有价值的及时信息

00:34:54.761 --> 00:34:58.365 align:middle
你可能见过这样的情况在隔了一会儿

00:34:58.432 --> 00:35:01.468 align:middle
查看Glances时试图显示

00:34:58.432 --> 00:35:01.468 align:middle
查看Glances时试图显示

00:35:01.535 --> 00:35:03.637 align:middle
内容有了更新

00:35:03.704 --> 00:35:07.574 align:middle
你在页面底部看到
这个更新了的最近的标题字符串

00:35:07.875 --> 00:35:11.211 align:middle
在页面上端右部看到
这个旋转的进度指示器

00:35:12.279 --> 00:35:15.115 align:middle
但是也许你看见它的时候正在下载信息

00:35:17.217 --> 00:35:18.352 align:middle
所以 让我们再看一遍

00:35:18.986 --> 00:35:21.555 align:middle
你正在下载内容一切进展顺利

00:35:21.622 --> 00:35:24.791 align:middle
然后 哦 内容去哪儿了 嘣

00:35:24.858 --> 00:35:26.827 align:middle
更新完全停止了

00:35:28.028 --> 00:35:29.196 align:middle
为什么会发生这种情况?

00:35:29.930 --> 00:35:33.534 align:start position:10%
这种情况能够发生
是因为在你的Glance控制器中

00:35:33.600 --> 00:35:35.669 align:middle
对于“将要激活”要采取
稍有不同的处理方式

00:35:36.537 --> 00:35:41.909 align:middle
那么会发生的情况是当“将要激活”
完成的时候这个系统提供的快照

00:35:42.176 --> 00:35:44.077 align:middle
就会从UI上移除

00:35:44.778 --> 00:35:49.049 align:middle
所以与你在Watch app里
的做法稍有不同

00:35:49.383 --> 00:35:53.487 align:middle
你在这里要确保的是
你要在“将要激活”完成之前

00:35:53.620 --> 00:35:54.621 align:middle
选择完全安装

00:35:54.988 --> 00:35:56.857 align:middle
你要得到你需要的所有信息

00:35:57.024 --> 00:36:00.527 align:middle
这样设置 就会完全安装UI

00:35:57.024 --> 00:36:00.527 align:middle
这样设置 就会完全安装UI

00:36:00.594 --> 00:36:03.564 align:middle
在我们移除那个快照的时候
UI已经安装好了

00:36:03.830 --> 00:36:07.367 align:middle
整个镜像消失没有中间状态

00:36:07.634 --> 00:36:10.904 align:middle
在你的记事本中
可能有你会看到的占位符文本

00:36:10.971 --> 00:36:13.273 align:middle
或者作用近似的文件

00:36:13.774 --> 00:36:15.943 align:middle
这些并不能提供真正好的体验

00:36:17.511 --> 00:36:21.281 align:middle
另一件你应该做的事
是慎重对待重新加载内容

00:36:21.682 --> 00:36:24.985 align:middle
用户在Glances中切换屏幕时

00:36:25.853 --> 00:36:28.388 align:middle
"将要激活" 会出现在你的页面上

00:36:28.455 --> 00:36:31.058 align:middle
所以 如果它出现在你的页面上

00:36:31.124 --> 00:36:34.194 align:middle
而且在 "将要激活"中
你正在下载一大堆东西

00:36:34.261 --> 00:36:37.064 align:middle
进行文件处理 进行网络请求

00:36:37.598 --> 00:36:40.734 align:middle
恐怕你的效率会大打折扣

00:36:40.868 --> 00:36:43.971 align:middle
所以重新装载时一定要慎重

00:36:44.137 --> 00:36:47.074 align:middle
根据其他情形而不仅仅是 哦

00:36:47.140 --> 00:36:48.442 align:middle
他们看了我的内容

00:36:50.077 --> 00:36:52.646 align:middle
另外 与Watch app一样

00:36:52.713 --> 00:36:54.781 align:middle
要限制比较设计的数量

00:36:55.148 --> 00:36:59.353 align:middle
因为和之前一样我们将需要
在最前面实例化那些对象

00:37:02.189 --> 00:37:05.726 align:middle
最后 如果你要在
Glances中显示时间或日期

00:37:06.059 --> 00:37:10.063 align:middle
你应该使用WK界面的时间标签

00:37:10.130 --> 00:37:11.965 align:middle
或者绝对时间或日期

00:37:12.900 --> 00:37:14.868 align:middle
如果你要这这里找到一个例子

00:37:15.002 --> 00:37:18.038 align:middle
本次讲座在35分钟前开始

00:37:18.572 --> 00:37:23.410 align:middle
那么 如果现在是
下午1:00让人有点糊涂了

00:37:23.644 --> 00:37:24.912 align:middle
我看到讲座在不断进行

00:37:24.978 --> 00:37:27.214 align:middle
我知道 但是它是在35分钟前开始的

00:37:27.281 --> 00:37:29.883 align:middle
让我有种下意识地反应像是 等等

00:37:30.150 --> 00:37:31.652 align:middle
现在究竟是什么时间

00:37:32.486 --> 00:37:36.290 align:middle
这种情况下比较好的做法是
给出一个绝对时间

00:37:36.857 --> 00:37:38.625 align:middle
讲座在10:00开始

00:37:38.959 --> 00:37:41.728 align:middle
这就已经给了我可视性

00:37:41.795 --> 00:37:45.098 align:middle
"哦，既然现在是
1:00 或 3:00"

00:37:45.399 --> 00:37:46.466 align:middle
我并没有糊涂

00:37:46.700 --> 00:37:48.869 align:middle
内容在载入中 进展顺利

00:37:50.938 --> 00:37:53.974 align:middle
我们已经谈到了很多东西

00:37:54.741 --> 00:37:56.176 align:middle
首先 我们谈到过优化

00:37:56.243 --> 00:37:59.479 align:middle
watchOS 1
应用程序的网络的方法

00:37:59.546 --> 00:38:02.349 align:middle
这样要转换为watchOS 2

00:37:59.546 --> 00:38:02.349 align:middle
这样要转换为watchOS 2

00:38:02.416 --> 00:38:04.451 align:middle
就更容易了 而且这很有可能

00:38:04.751 --> 00:38:08.222 align:middle
对你的应用程序有帮助

00:38:09.723 --> 00:38:12.392 align:middle
然后 我们谈到过改善

00:38:12.459 --> 00:38:17.564 align:middle
性能布局的方法 以缩短
下载时间 提高运行效率

00:38:18.866 --> 00:38:21.134 align:middle
然后 我们又谈到了如何确保

00:38:21.201 --> 00:38:23.370 align:middle
你的Glances的内容可视

00:38:23.704 --> 00:38:26.840 align:middle
这样就不会让用户看到
面前的镜像一片空白

00:38:28.876 --> 00:38:33.380 align:middle
最后在watchOS 2 还有许多
需要核查的东西

00:38:33.747 --> 00:38:37.518 align:middle
除了在WatchKit中对
watchOS 2的更新

00:38:37.584 --> 00:38:39.119 align:middle
我们还有ClockKit

00:38:39.186 --> 00:38:42.155 align:middle
来为时钟表面进行复杂设计

00:38:42.389 --> 00:38:43.223 align:middle
我们还有

00:38:43.290 --> 00:38:45.125 align:middle
WatchConnectivity
框架

00:38:45.192 --> 00:38:48.095 align:middle
来进行所有设备到设备的交流

00:38:48.161 --> 00:38:50.731 align:middle
你还可以利用WatchKit

00:38:50.797 --> 00:38:52.566 align:middle
本身的延伸NSURL

00:38:54.735 --> 00:38:58.038 align:middle
如果你想了解更多的信息
可以查看我们的文档

00:38:58.172 --> 00:38:59.373 align:middle
我们有代码样本

00:38:59.573 --> 00:39:03.010 align:middle
如果你有技术问题 可以让论坛咨询

00:38:59.573 --> 00:39:03.010 align:middle
如果你有技术问题 可以让论坛咨询

00:39:03.243 --> 00:39:06.346 align:middle
你会得到与开发人员技术支持部
提供的相似的一对一的帮助

00:39:07.114 --> 00:39:09.216 align:middle
最后 如果你有任何问题

00:39:09.283 --> 00:39:11.552 align:middle
请随时与我联系这是我的email

00:39:13.020 --> 00:39:17.724 align:middle
今天我们还有一场关于Apple
Watch 的精彩演讲

00:39:17.791 --> 00:39:20.060 align:middle
题目是 "Apple Watch
设计建议与技巧"

00:39:20.460 --> 00:39:23.897 align:start position:10%
演讲会涉及许多很棒的信息

00:39:24.097 --> 00:39:26.667 align:middle
帮助你开发了不起的
Watch app

00:39:26.733 --> 00:39:28.702 align:middle
我们还进行了一场
名为 "Designing

00:39:28.769 --> 00:39:30.504 align:middle
for Apple
Watch" 的演讲

00:39:30.571 --> 00:39:32.606 align:middle
一场名为"Introduction
to WatchKit

00:39:32.673 --> 00:39:34.441 align:middle
for watchOS 2"
的演讲 还有其它演讲

00:39:34.508 --> 00:39:36.143 align:middle
总之 非常感谢
