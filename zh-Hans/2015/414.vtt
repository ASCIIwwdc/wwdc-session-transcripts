WEBVTT

00:00:21.255 --> 00:00:23.891 align:middle
在Swift中 如何使用
数值类型来打造更好的app

00:00:24.191 --> 00:00:26.193 align:middle
大家好 我是道格·格雷戈尔

00:00:26.260 --> 00:00:28.362 align:middle
今天我和我的同事比尔·达德利

00:00:28.595 --> 00:00:32.366 align:middle
我们会讲讲在Swift中 如何使用
数值类型来打造更好的app

00:00:36.203 --> 00:00:38.172 align:middle
首先我们来谈谈

00:00:38.238 --> 00:00:39.540 align:middle
引用语义

00:00:40.474 --> 00:00:44.645 align:middle
然后我们会深入探讨下不变性
把它作为引用语义提出的某些问题的

00:00:44.711 --> 00:00:46.380 align:middle
解决方案

00:00:48.048 --> 00:00:50.184 align:middle
深入探讨数值语义、数值类型

00:00:50.517 --> 00:00:53.153 align:middle
尤其是它在Swift的工作原理
数值类型在实践中的应用

00:00:53.887 --> 00:00:56.056 align:middle
然后探讨引用类型和数值类型

00:00:56.123 --> 00:01:00.127 align:middle
在Swift中的混合

00:00:56.123 --> 00:01:00.127 align:middle
在Swift中的混合

00:01:01.061 --> 00:01:01.895 align:middle
让我们开始吧

00:01:04.031 --> 00:01:05.065 align:middle
引用语义

00:01:05.666 --> 00:01:10.470 align:middle
引用语义在
Swift中就是用来定义一个类

00:01:11.405 --> 00:01:13.207 align:middle
这是一个很简单的温度组别

00:01:13.807 --> 00:01:16.643 align:middle
我们以摄氏度来存储我们的温度数值

00:01:16.710 --> 00:01:19.713 align:middle
想得到这个不错的计算华氏温度属性

00:01:20.180 --> 00:01:22.583 align:middle
这样我们可以始终以正确的单位得到它

00:01:23.650 --> 00:01:25.686 align:middle
温度的简单、抽象版本

00:01:26.320 --> 00:01:28.055 align:middle
让我们试着把它用到一些简单的代码上

00:01:28.755 --> 00:01:31.892 align:middle
我们创建一个家庭
实例再创建一个温度实例

00:01:32.226 --> 00:01:35.495 align:middle
把我们的恒温器设置成
温和的七十五华氏摄氏度

00:01:36.897 --> 00:01:39.399 align:middle
现在我们来决定...
晚餐时间快到了

00:01:39.466 --> 00:01:40.901 align:middle
我想烤一些鲑鱼肉

00:01:40.968 --> 00:01:44.304 align:middle
因此我把烤箱的温度设置成425度
然后点击“烤制”

00:01:44.872 --> 00:01:45.873 align:middle
走开一点

00:01:48.242 --> 00:01:50.410 align:middle
为什么这里这么烫？出了什么事？

00:01:51.812 --> 00:01:55.282 align:middle
你知道发生了什么事
我们实现的就是非有意的共享

00:01:55.449 --> 00:01:56.850 align:middle
想想对象图表

00:01:57.951 --> 00:01:58.986 align:middle
我们有自己的房子

00:01:59.052 --> 00:02:01.088 align:middle
里面有一个恒温器和烤箱

00:01:59.052 --> 00:02:01.088 align:middle
里面有一个恒温器和烤箱

00:02:01.154 --> 00:02:03.690 align:middle
我们还有这个温度指向的温度对象

00:02:04.525 --> 00:02:06.260 align:middle
当我们设置我们的恒温器时

00:02:06.326 --> 00:02:08.794 align:middle
我们把它作为温度连接到相同的对象

00:02:09.162 --> 00:02:12.466 align:middle
事情看起来不错直到我们进行转变

00:02:12.799 --> 00:02:15.736 align:middle
现在这个非有意的或者意想不到的分享

00:02:16.336 --> 00:02:18.172 align:middle
让我们把我们的恒温器设置成了

00:02:18.238 --> 00:02:20.207 align:middle
四百二十五华氏摄氏度

00:02:21.508 --> 00:02:23.110 align:middle
此时已经玩完了

00:02:23.177 --> 00:02:26.547 align:middle
但是为了度量起见
让我们把我们的恒温器连接到烤箱

00:02:26.613 --> 00:02:27.714 align:middle
因为我们已经搞砸了

00:02:30.317 --> 00:02:31.585 align:middle
那么我们做错了什么呢？

00:02:32.085 --> 00:02:34.955 align:middle
在这个有引用语义的世界里

00:02:35.656 --> 00:02:38.659 align:middle
你想要阻止分享 你就要进行复制

00:02:40.060 --> 00:02:42.162 align:middle
知道了吗？让我们来这样试试

00:02:44.031 --> 00:02:45.299 align:middle
好的 把温度设置成七十五

00:02:45.365 --> 00:02:47.501 align:middle
华氏摄氏度

00:02:47.801 --> 00:02:52.005 align:middle
当我设置我的恒温器的温度时
我就会生成一个副本

00:02:52.139 --> 00:02:53.841 align:middle
我就得了一个全新的对象

00:02:53.907 --> 00:02:56.376 align:middle
我的恒温器的温度指向的也就是它

00:02:56.710 --> 00:02:58.612 align:middle
当我改变我的温度变量的温度时

00:02:58.679 --> 00:03:01.515 align:middle
并不会对它产生影响 很好

00:02:58.679 --> 00:03:01.515 align:middle
并不会对它产生影响 很好

00:03:02.149 --> 00:03:04.084 align:middle
现在我来设置烤箱的温度

00:03:04.151 --> 00:03:05.586 align:middle
我又生成了一个副本

00:03:06.486 --> 00:03:09.723 align:middle
现在从技术上来讲
我并不需要最后的这个副本

00:03:10.224 --> 00:03:15.796 align:middle
在堆上浪费时间分配内存
创建这个另外的副本效率很低

00:03:16.296 --> 00:03:18.932 align:middle
但是这样更安全
因为上次我错过了一个副本

00:03:18.999 --> 00:03:20.200 align:middle
结果把我烤熟了！

00:03:22.169 --> 00:03:24.204 align:middle
给点力吧 这是周五的会议
让我喘口气吧

00:03:30.677 --> 00:03:32.613 align:middle
我们把这个称之为“保护性拷贝”

00:03:33.847 --> 00:03:36.216 align:middle
我们进行拷贝并不是因为

00:03:36.283 --> 00:03:38.585 align:middle
我们知道我们需要它 而是因为偶尔

00:03:38.652 --> 00:03:41.922 align:middle
或者过一段时间后需要用它

00:03:41.989 --> 00:03:43.390 align:middle
调试这些问题是相当困难的

00:03:43.857 --> 00:03:44.825 align:middle
无论我们什么时候

00:03:45.092 --> 00:03:49.897 align:middle
把一个温度指定到我们的烤箱某处
忘记进行点拷贝太容易了

00:03:50.230 --> 00:03:53.333 align:middle
我要在我自己的烤箱中烤一烤这个行为

00:03:55.869 --> 00:03:58.672 align:middle
好 我完了 我完了 对不起 对不起

00:03:59.473 --> 00:04:01.441 align:middle
通常来说我需要给恒温器做同样的事

00:03:59.473 --> 00:04:01.441 align:middle
通常来说我需要给恒温器做同样的事

00:04:01.508 --> 00:04:02.876 align:middle
不是吗？

00:04:02.943 --> 00:04:05.012 align:middle
有了一大堆样本
我们正在进行复制粘贴

00:04:05.078 --> 00:04:07.181 align:middle
你迟早会来敲我的门问我借

00:04:07.247 --> 00:04:09.116 align:middle
一项语言特征

00:04:09.750 --> 00:04:15.722 align:middle
我们先来谈复制
Cocoa和Objective-C

00:04:16.656 --> 00:04:19.892 align:middle
在Cocoa
有一个NSCopying协议的概念

00:04:20.327 --> 00:04:22.863 align:middle
它对复制的意义进行了编码

00:04:23.497 --> 00:04:26.366 align:middle
你有很多的数据类型
这NSstring NSArray

00:04:26.433 --> 00:04:29.002 align:middle
NSURLRequest
etcetera

00:04:29.069 --> 00:04:31.905 align:middle
这些都遵从NSCopying
因为你需要安全地对它们

00:04:31.972 --> 00:04:33.240 align:middle
进行复制

00:04:35.075 --> 00:04:36.977 align:middle
我们的系统中需要大量的复制

00:04:37.044 --> 00:04:40.647 align:middle
因此你有足够的理由看到
大量的“保护性拷贝”

00:04:40.714 --> 00:04:45.552 align:middle
NSDictionary会对你放到
字典中的键进行保护性拷贝 为什么？

00:04:46.353 --> 00:04:49.957 align:middle
若要递给NSDictionary
一个键 进行插入

00:04:50.324 --> 00:04:54.194 align:middle
然后又做了变更改变了它的hash值

00:04:54.428 --> 00:04:56.296 align:middle
打断
NSDictionary内部变度

00:04:56.363 --> 00:04:58.465 align:middle
然后埋怨我们让你出了bug

00:04:58.866 --> 00:05:00.133 align:middle
这可不是我们想要的

00:04:58.866 --> 00:05:00.133 align:middle
这可不是我们想要的

00:05:00.200 --> 00:05:03.504 align:middle
想要的是在
NSDictionary保护性拷贝

00:05:03.570 --> 00:05:07.207 align:middle
在这个系统中 这是正确的答案
但是不幸的是

00:05:08.275 --> 00:05:10.544 align:middle
进行这些额外的复制会让我们损失性能

00:05:11.745 --> 00:05:14.281 align:middle
我们会把
这些都弄到Objective-C

00:05:14.348 --> 00:05:17.150 align:middle
带有复制属性的语言层面

00:05:17.451 --> 00:05:20.220 align:middle
来对每个单一的赋值进行保护性拷贝

00:05:20.287 --> 00:05:23.123 align:middle
以此来避免这些问题 这确实有用

00:05:23.190 --> 00:05:25.092 align:middle
这个保护性拷贝确实有用

00:05:25.192 --> 00:05:26.560 align:middle
不过还不够好

00:05:26.860 --> 00:05:28.228 align:middle
你仍然会有一堆的bug

00:05:29.029 --> 00:05:32.065 align:middle
因此这些引用语义有问题

00:05:32.132 --> 00:05:33.100 align:middle
出现了变异

00:05:34.368 --> 00:05:36.703 align:middle
也许这里的问题不在于引用语义

00:05:36.937 --> 00:05:38.172 align:middle
而在于变异本身

00:05:38.505 --> 00:05:43.277 align:middle
也许应该移动到带有
引用语义的不可变数据结构

00:05:44.011 --> 00:05:46.914 align:middle
如果你和函数式语言社区某个人谈一谈

00:05:46.980 --> 00:05:48.682 align:middle
他们会说 是的

00:05:48.749 --> 00:05:50.250 align:middle
几十年前我们就开始这么做了

00:05:51.251 --> 00:05:52.920 align:middle
它确实可以提高那里的情况

00:05:53.320 --> 00:05:58.258 align:middle
因此如果没有副效用
你就不会出现非有意的副效用

00:05:58.892 --> 00:06:01.662 align:middle
不可变引用语义是一种在系统中工作的

00:05:58.892 --> 00:06:01.662 align:middle
不可变引用语义是一种在系统中工作的

00:06:01.828 --> 00:06:02.763 align:middle
一致的方法

00:06:02.930 --> 00:06:08.435 align:middle
它没有那些我们在我们的
温度小示例中出现的意外后果

00:06:09.303 --> 00:06:13.307 align:middle
问题在于不变性也有不足

00:06:13.740 --> 00:06:15.843 align:middle
它可能导致不佳的界面

00:06:16.310 --> 00:06:19.246 align:middle
语言工作的方式就是 它的一部分

00:06:19.613 --> 00:06:22.449 align:middle
我们生活在一个我们可以
让事情产生变异的世界中

00:06:22.516 --> 00:06:25.319 align:middle
这也是它的一部分 我们想到状态

00:06:25.385 --> 00:06:27.588 align:middle
变异的状态 因此单纯在一个

00:06:27.654 --> 00:06:29.923 align:middle
不可变的世界中进行思考
有时候对我们来说

00:06:29.990 --> 00:06:30.924 align:middle
是比较怪的

00:06:31.825 --> 00:06:33.694 align:middle
有效映射到机器模型

00:06:33.760 --> 00:06:35.028 align:middle
也是问题

00:06:35.829 --> 00:06:37.698 align:middle
最后你还是不得不着手处理机器码

00:06:37.764 --> 00:06:40.434 align:middle
在一个有状态寄存器、状态缓存、

00:06:40.501 --> 00:06:41.368 align:middle
状态内存、

00:06:41.435 --> 00:06:43.337 align:middle
状态存储的CPU上运行

00:06:44.371 --> 00:06:49.810 align:middle
把一个不可变算法映射到那个层级效率
并不总是那么容易

00:06:50.477 --> 00:06:52.112 align:middle
我们来讲一讲其中的几点

00:06:52.179 --> 00:06:54.414 align:middle
我们把我们的这个温度类拿出来

00:06:54.615 --> 00:06:56.583 align:middle
通过让它成为不可变的增加它的安全性

00:06:57.417 --> 00:07:03.257 align:middle
我们把摄氏度存储属性从一个
var变成一个let 你不能再改了

00:06:57.417 --> 00:07:03.257 align:middle
我们把摄氏度存储属性从一个
var变成一个let 你不能再改了

00:07:03.924 --> 00:07:07.094 align:middle
然后华氏温标计算器属性的
设值函数没有了

00:07:07.160 --> 00:07:08.228 align:middle
因此无论你做什么

00:07:08.295 --> 00:07:09.630 align:middle
你都不能再改变温度状态

00:07:09.963 --> 00:07:11.832 align:middle
为了方便起见
我们添加一些初始化程序

00:07:13.367 --> 00:07:15.702 align:middle
好的 我们来谈谈不优美的...

00:07:16.637 --> 00:07:18.071 align:middle
不优美的不可变界面

00:07:18.472 --> 00:07:22.509 align:middle
要是我说我把我的烤箱温度调整

00:07:22.576 --> 00:07:25.279 align:middle
十华氏温度 这是一个简单的操作

00:07:26.280 --> 00:07:28.415 align:middle
加号就是十度 可以了 好了

00:07:29.416 --> 00:07:32.152 align:middle
如果我们把变化去掉
我们又该怎么做？

00:07:32.219 --> 00:07:35.022 align:middle
我们就必须抓住烤箱的温度对象

00:07:35.689 --> 00:07:39.326 align:middle
创造另外一个有新值的温度对象

00:07:40.627 --> 00:07:43.430 align:middle
对吧？这就有点不太好看了代码更多

00:07:43.497 --> 00:07:47.167 align:middle
也浪费时间在堆上分配另一个对象

00:07:47.935 --> 00:07:50.737 align:middle
我们并没有在这里拥抱不变性

00:07:50.804 --> 00:07:54.341 align:middle
因为我们是做了一个使
烤箱本身发生变化的赋值

00:07:55.209 --> 00:07:57.177 align:middle
如果我们在这里自始至终

00:07:57.244 --> 00:07:59.580 align:middle
拥抱不可变引用的概念

00:08:00.113 --> 00:08:02.449 align:middle
我们就可以创建一个新的温度
放到一个新的烤箱中

00:08:02.516 --> 00:08:03.550 align:middle
然后放到一个新家中

00:08:05.719 --> 00:08:12.593 align:middle
不美观！
让我们再搞点理论知识做一些数学题

00:08:13.293 --> 00:08:18.899 align:middle
埃拉托色尼选筛法是
一种计算质数的古老的算法

00:08:19.433 --> 00:08:22.035 align:middle
它使用了变异 非常适合在地上用棍子

00:08:22.102 --> 00:08:24.271 align:middle
画出事情

00:08:24.771 --> 00:08:29.176 align:middle
这是Swift中变异版本的执行

00:08:29.510 --> 00:08:31.378 align:middle
我们来演示下
以便你明白它背后的想法

00:08:31.979 --> 00:08:33.547 align:middle
你首先要做的是：创建一个阵列

00:08:34.681 --> 00:08:36.616 align:middle
注意var 因为我们要改变这个阵列

00:08:37.049 --> 00:08:40.953 align:middle
注意这个阵列来源于两个、三个质数

00:08:41.020 --> 00:08:42.623 align:middle
是从你计算的数字中求出来的

00:08:42.688 --> 00:08:43.524 align:middle
我们这里是二十

00:08:44.825 --> 00:08:47.728 align:middle
现在每次通过外层循环

00:08:47.794 --> 00:08:50.330 align:middle
我们就会选择阵列中的下一个数字

00:08:50.998 --> 00:08:52.533 align:middle
那个数字是一个质数P

00:08:53.800 --> 00:08:58.005 align:middle
内循环要做的就是走过P的所有倍数

00:08:58.272 --> 00:09:03.043 align:middle
把它们设为零将它们从阵列中抹除

00:08:58.272 --> 00:09:03.043 align:middle
把它们设为零将它们从阵列中抹除

00:09:04.178 --> 00:09:05.212 align:middle
如果是一个质数的倍数

00:09:05.279 --> 00:09:06.446 align:middle
那么你就不是质数

00:09:07.514 --> 00:09:08.448 align:middle
再回到外层循环

00:09:08.515 --> 00:09:11.018 align:middle
我们获取下一个数字 这是一个质数

00:09:11.285 --> 00:09:13.687 align:middle
我们从阵列中把它所有的倍数抹除

00:09:13.754 --> 00:09:15.489 align:middle
这是一个非常简单的算法

00:09:15.556 --> 00:09:16.623 align:middle
想想地上的棍子

00:09:16.690 --> 00:09:18.225 align:middle
你就是在把事情划掉

00:09:19.893 --> 00:09:22.296 align:middle
一旦我们迭代

00:09:23.263 --> 00:09:24.398 align:middle
完毕我们就到这里

00:09:24.464 --> 00:09:27.034 align:middle
进行最后一个简单的操作 也就是说

00:09:27.100 --> 00:09:28.936 align:middle
阵列中所有我们未归零的东西

00:09:29.002 --> 00:09:30.170 align:middle
就是我们的结果的一部分

00:09:30.237 --> 00:09:31.572 align:middle
我们用一个过滤器来处理它

00:09:32.906 --> 00:09:35.843 align:middle
算法非常简单 完全基于变异的

00:09:37.444 --> 00:09:38.946 align:middle
但不是不能在没有变异的

00:09:39.046 --> 00:09:40.347 align:middle
世界里表达它

00:09:40.647 --> 00:09:42.182 align:middle
你当然可以的

00:09:42.983 --> 00:09:44.718 align:middle
为此 我们要使用Haskell

00:09:44.785 --> 00:09:46.587 align:middle
因为它是一个单纯的函数式语言

00:09:48.121 --> 00:09:50.724 align:middle
是的 我知道大家都爱它 好的

00:09:51.525 --> 00:09:53.627 align:middle
这是Haskell的公式化

00:09:53.927 --> 00:09:55.996 align:middle
如果你读过Haskell 它很美

00:09:56.797 --> 00:09:58.532 align:middle
它是函数式的 它一点也不会发生变异

00:09:59.199 --> 00:10:01.034 align:middle
这是个类似执行
它对Swift做了变动

00:09:59.199 --> 00:10:01.034 align:middle
这是个类似执行
它对Swift做了变动

00:10:01.101 --> 00:10:03.604 align:middle
因此也能是函数式的
如果你想让它懒一点

00:10:03.670 --> 00:10:05.606 align:middle
对于读者来说这是一个练习

00:10:05.672 --> 00:10:06.807 align:middle
没有那么难

00:10:07.541 --> 00:10:09.710 align:middle
我们来演示下这个算法的工作原理

00:10:09.776 --> 00:10:11.512 align:middle
因为非常相似

00:10:13.180 --> 00:10:16.783 align:middle
我们的阵列就从二开始 直到二十

00:10:18.519 --> 00:10:21.522 align:middle
在这个简单的例子中 如果没有数字

00:10:21.588 --> 00:10:22.556 align:middle
那里没有质数

00:10:22.623 --> 00:10:24.725 align:middle
那是第一个“If语句”这是小事情

00:10:25.926 --> 00:10:28.662 align:middle
你要做的就是
我们把第一个数字取出来

00:10:28.762 --> 00:10:30.197 align:middle
它就始终是质数

00:10:30.898 --> 00:10:32.799 align:middle
把它和其余的数字分割开来

00:10:33.200 --> 00:10:34.801 align:middle
Haskell通过模式匹配实现它

00:10:34.868 --> 00:10:35.802 align:middle
我们在这里可以分层

00:10:36.770 --> 00:10:39.673 align:middle
我们把那个质数拿出来
在这个阵列其余的元素这里

00:10:39.907 --> 00:10:44.311 align:middle
运行一个过滤器操作

00:10:45.179 --> 00:10:46.446 align:middle
仅仅复制那些不是

00:10:46.513 --> 00:10:48.582 align:middle
那个质数的倍数的东西

00:10:49.950 --> 00:10:51.351 align:middle
现在我们递归 再来一次

00:10:52.119 --> 00:10:54.121 align:middle
把“三”拆分 这是我们的新质数

00:10:54.521 --> 00:10:55.689 align:middle
然后运行这个过滤器

00:10:56.890 --> 00:11:00.494 align:middle
把所有三的倍数消除等等

00:10:56.890 --> 00:11:00.494 align:middle
把所有三的倍数消除等等

00:11:00.994 --> 00:11:02.362 align:middle
这里发生的

00:11:02.529 --> 00:11:05.933 align:middle
就是你以构建这个左斜
实际质数来结束

00:11:05.999 --> 00:11:08.669 align:middle
这样它们就都会连接在一起

00:11:10.504 --> 00:11:11.638 align:middle
理念是相似的

00:11:11.705 --> 00:11:12.940 align:middle
非常相似

00:11:13.974 --> 00:11:16.176 align:middle
但是算法不同

00:11:16.243 --> 00:11:20.080 align:middle
因为它的性能特征不同

00:11:21.248 --> 00:11:23.417 align:middle
这个结果来源于
梅莉莎·欧内尔发表的

00:11:23.483 --> 00:11:26.486 align:middle
一篇绝妙的论文 她称之为
“真实的埃拉托色尼筛选法”

00:11:27.154 --> 00:11:29.356 align:middle
她向Haskell社区展示了
他们挚爱的筛选法

00:11:29.423 --> 00:11:32.092 align:middle
并不是真实的筛选法

00:11:32.593 --> 00:11:35.629 align:middle
因为它并不会作为真实的筛选法来运行

00:11:36.363 --> 00:11:41.235 align:middle
她仔细查看了Haskell
中非常复杂的执行

00:11:41.568 --> 00:11:43.937 align:middle
那又回朔到了性能特征

00:11:44.137 --> 00:11:45.739 align:middle
读一下那篇论文 看一看 非常酷

00:11:46.173 --> 00:11:48.475 align:middle
我想让你们尝试下
为什么会出现这种情况

00:11:48.675 --> 00:11:50.644 align:middle
看看这个Haskell列表推导

00:11:50.944 --> 00:11:52.980 align:middle
或者下面等价的Swift过滤器

00:11:55.048 --> 00:11:59.152 align:middle
在这个不变版本中
这个操作会遍历阵列中的

00:11:59.219 --> 00:12:02.055 align:middle
每个单一元素

00:11:59.219 --> 00:12:02.055 align:middle
每个单一元素

00:12:02.122 --> 00:12:04.491 align:middle
然后执行一个除运算
看看下一步中

00:12:04.558 --> 00:12:06.727 align:middle
它是否还应该在那里
看看它是否是P的倍数

00:12:07.661 --> 00:12:11.565 align:middle
在原始的变异算法中
我们只会遍历质数的

00:12:11.632 --> 00:12:14.868 align:middle
倍数以及那些...当然了

00:12:14.935 --> 00:12:17.804 align:middle
随着你得到越来越大的数字
就会变得越来越稀疏

00:12:18.272 --> 00:12:20.874 align:middle
你访问的元素更少 此外

00:12:20.941 --> 00:12:23.410 align:middle
你只需要在到达下个元素进行一次加法

00:12:24.645 --> 00:12:26.413 align:middle
这样你每个元素所做的工作就更少了

00:12:26.713 --> 00:12:27.614 align:middle
这是有关系的

00:12:28.382 --> 00:12:30.517 align:middle
不变版本不像变异版本的效率那样高

00:12:30.584 --> 00:12:32.986 align:middle
后者无需做很多的功

00:12:35.122 --> 00:12:36.690 align:middle
我们再回到Cocoa

00:12:36.823 --> 00:12:41.028 align:middle
你看到了在Cocoa中使用不变性
Cocoa Touch框架

00:12:41.428 --> 00:12:44.431 align:middle
它们有很多
日期 Ui图片 NSNumber等

00:12:44.665 --> 00:12:45.899 align:middle
它们是不可变类型

00:12:46.099 --> 00:12:48.602 align:middle
有了这些不可变类型
安全性就可以得到提高

00:12:48.836 --> 00:12:50.103 align:middle
这是件好事因为你就无需

00:12:50.170 --> 00:12:51.038 align:middle
担心复制了

00:12:51.371 --> 00:12:54.575 align:middle
你无需担心
你的共享会产生非有意的副效用

00:12:55.542 --> 00:12:58.111 align:middle
但是当你用它工作时你也会看到缺点

00:12:58.645 --> 00:13:00.814 align:middle
在Objective-C
中给自己一个小任务

00:12:58.645 --> 00:13:00.814 align:middle
在Objective-C
中给自己一个小任务

00:13:01.215 --> 00:13:04.952 align:middle
我想从我的主目录开始
通过添加逐次路径元件

00:13:05.018 --> 00:13:07.621 align:middle
获得某些目录的方式 来创建一个

00:13:07.921 --> 00:13:08.956 align:middle
NSURL

00:13:09.823 --> 00:13:11.325 align:middle
我想在引用语义世界中 无需变异

00:13:11.391 --> 00:13:12.659 align:middle
就可以实现这一点

00:13:13.060 --> 00:13:14.761 align:middle
因此我创建了一个NSURL

00:13:15.262 --> 00:13:17.764 align:middle
每次通过循环时 我就通过附加下一个

00:13:17.831 --> 00:13:19.566 align:middle
路径元件 来创建一个新的URL

00:13:20.567 --> 00:13:22.002 align:middle
这个算法并不是非常好 真的

00:13:22.703 --> 00:13:25.572 align:middle
每通过一次我就创建一个NSURL
另一个对象

00:13:25.639 --> 00:13:31.612 align:middle
旧的对象就会消失
然后NSURL就会在每次通过

00:13:31.678 --> 00:13:33.914 align:middle
循环时 复制所有的
串式数据

00:13:34.448 --> 00:13:36.750 align:middle
那里的效率不是很高

00:13:37.084 --> 00:13:39.152 align:middle
道格 你按错了

00:13:39.219 --> 00:13:41.555 align:middle
你应该把所有的这些元件
收集到一个NSArray

00:13:41.622 --> 00:13:45.359 align:middle
然后使用带路径元件的
文件URL

00:13:46.627 --> 00:13:49.530 align:middle
就这样吧 不过要记住
我们是在这里拥抱不变性

00:13:50.564 --> 00:13:53.267 align:middle
这样当我创建我的阵列时
我会创建一个带有特定

00:13:53.634 --> 00:13:55.169 align:middle
对象的NSArray 好的

00:13:55.235 --> 00:13:56.103 align:middle
这是主目录

00:13:56.503 --> 00:13:59.072 align:middle
每次通过时
我创建一个新的阵列

00:13:59.640 --> 00:14:00.874 align:middle
多加一个对象

00:13:59.640 --> 00:14:00.874 align:middle
多加一个对象

00:14:01.341 --> 00:14:02.442 align:middle
我仍然是二次的

00:14:03.010 --> 00:14:04.311 align:middle
我仍然是在复制元素

00:14:04.378 --> 00:14:05.412 align:middle
我复制的不是串式数据

00:14:05.479 --> 00:14:06.380 align:middle
这样好一点

00:14:06.680 --> 00:14:07.881 align:middle
我仍然是在复制元素

00:14:09.283 --> 00:14:11.652 align:middle
这就是为什么我们不在
Cocoa世界中完全拥抱

00:14:11.718 --> 00:14:13.654 align:middle
不变性的原因 因为这样说不通

00:14:13.720 --> 00:14:15.856 align:middle
而如果你在更加本地化的

00:14:16.089 --> 00:14:18.592 align:middle
地方使用易变性 就说得通了

00:14:19.092 --> 00:14:22.329 align:middle
把你所有的元件收集到
一个NSMutable阵列

00:14:22.930 --> 00:14:26.066 align:middle
然后使用带路径元件的
文件URL返回到那个

00:14:26.533 --> 00:14:28.035 align:middle
不可变NSURL

00:14:29.670 --> 00:14:31.772 align:middle
因此不变性是件好事

00:14:31.839 --> 00:14:34.608 align:middle
它让引用语义世界的推论更加容易了

00:14:35.309 --> 00:14:38.011 align:middle
但是你又不能完全选择不变性

00:14:38.312 --> 00:14:39.479 align:middle
否则你会疯掉

00:14:41.748 --> 00:14:43.250 align:middle
这样我们就到了数值语义

00:14:44.218 --> 00:14:46.086 align:middle
对于数值语义
我们想采用一个不同的方法

00:14:46.553 --> 00:14:47.454 align:middle
我们喜欢变异

00:14:47.888 --> 00:14:51.458 align:middle
它很有价值
如果正确使用的话用起来很容易

00:14:52.159 --> 00:14:55.495 align:middle
问题在于正如我们看到的在于共享

00:14:57.264 --> 00:14:59.833 align:middle
你已经知道了数值语义的工作原理
无论你是在

00:14:59.900 --> 00:15:02.903 align:middle
Objective-C中还是在
Swift中你都应该始终用它

00:14:59.900 --> 00:15:02.903 align:middle
Objective-C中还是在
Swift中你都应该始终用它

00:15:03.770 --> 00:15:05.973 align:middle
道理很简单：如果你有两个变量

00:15:06.507 --> 00:15:09.042 align:middle
从逻辑上来讲
这些变量中的数值是不同的

00:15:10.777 --> 00:15:13.914 align:middle
我有一个整数A
我把它复制到一个整数B

00:15:14.147 --> 00:15:16.450 align:middle
当然了它们是等价的 它是一个副本

00:15:17.851 --> 00:15:19.219 align:middle
我来改变B

00:15:19.620 --> 00:15:22.789 align:middle
如果我告诉你A也会变 你会说我疯了

00:15:24.124 --> 00:15:25.025 align:middle
这些是整数

00:15:25.092 --> 00:15:26.093 align:middle
它们在我们用过的

00:15:26.159 --> 00:15:27.528 align:middle
每种语言中都有数值语义

00:15:29.630 --> 00:15:31.164 align:middle
到CGPoint中举例来说

00:15:33.300 --> 00:15:36.503 align:middle
从A复制到B改变B 对A不会产生

00:15:36.570 --> 00:15:37.971 align:middle
任何影响

00:15:38.939 --> 00:15:40.073 align:middle
你已经习惯这一点了

00:15:40.307 --> 00:15:42.543 align:middle
如果CGPoint的行为不是这样

00:15:42.609 --> 00:15:44.378 align:middle
你肯定会大吃一惊

00:15:46.813 --> 00:15:50.217 align:middle
数值语义的理念就是
把我们已经知道并且理解为

00:15:50.284 --> 00:15:53.554 align:middle
最基本类型的事物
像数字以及包含数字的

00:15:53.620 --> 00:15:57.124 align:middle
小的结构
把它向外扩展

00:15:57.991 --> 00:16:00.460 align:middle
让它能够兼容更多、更丰富的类型

00:15:57.991 --> 00:16:00.460 align:middle
让它能够兼容更多、更丰富的类型

00:16:00.527 --> 00:16:02.829 align:middle
在Swift中字符串属于数值类型

00:16:03.530 --> 00:16:07.134 align:middle
你创建了A从B复制到A
然后对B做出某种改变

00:16:07.201 --> 00:16:09.503 align:middle
这不会对A产生任何影响

00:16:10.771 --> 00:16:11.839 align:middle
因为它是一个数值类型

00:16:12.239 --> 00:16:13.740 align:middle
A和B是不同的变量

00:16:13.841 --> 00:16:15.309 align:middle
因此从逻辑上来说
它们是不同的

00:16:18.412 --> 00:16:22.249 align:middle
知道了吗？那么为什么阵列表现的
方式也是一模一样呢

00:16:23.650 --> 00:16:26.153 align:middle
创建A复制到B 然后改变B

00:16:26.220 --> 00:16:27.120 align:middle
对A没有影响

00:16:27.187 --> 00:16:29.890 align:middle
它们是完全不同的值

00:16:31.992 --> 00:16:33.827 align:middle
最后一点是字典 当然了

00:16:33.894 --> 00:16:34.862 align:middle
它就是一个集合

00:16:35.395 --> 00:16:37.030 align:middle
你把数值语义放进去
然后向你返回的

00:16:37.731 --> 00:16:38.899 align:middle
也是数值语义

00:16:39.600 --> 00:16:43.303 align:middle
这里很棒的一点是
数值类型的构成非常漂亮

00:16:43.670 --> 00:16:46.773 align:middle
因此你就可以在数值语义的
世界中非常容易地构建

00:16:46.840 --> 00:16:48.408 align:middle
非常丰富的抽象物

00:16:49.109 --> 00:16:52.412 align:middle
在Swift中所有的
基本类型整数、两倍数、

00:16:52.479 --> 00:16:55.616 align:middle
字符串、字符等等
它们都是数值类型

00:16:55.682 --> 00:16:57.251 align:middle
它们都有这个基本行为

00:16:57.317 --> 00:16:59.052 align:middle
从逻辑上说 这两个变量它们是不同的

00:16:59.820 --> 00:17:01.989 align:middle
我们在它们顶部构建的全部集合...

00:16:59.820 --> 00:17:01.989 align:middle
我们在它们顶部构建的全部集合...

00:17:02.055 --> 00:17:03.423 align:middle
阵列、集合、字典...

00:17:03.924 --> 00:17:06.260 align:middle
当给予它们数值类型时
它们都是数值类型

00:17:07.861 --> 00:17:09.296 align:middle
你用来构建自己的类的语言抽象

00:17:09.363 --> 00:17:12.566 align:middle
这里的类包括元组、结构和枚举

00:17:12.900 --> 00:17:15.801 align:middle
当你把数值类型放进去时
你得到的仍然是数值类型

00:17:16.170 --> 00:17:19.506 align:middle
再说一遍 在数值语义世界中构建

00:17:20.307 --> 00:17:21.808 align:middle
丰富的抽象物十分容易

00:17:22.843 --> 00:17:25.746 align:middle
数值类型上还有重要的一点

00:17:26.280 --> 00:17:30.017 align:middle
就是你有一个两个值等价两个数值类型

00:17:30.083 --> 00:17:32.519 align:middle
变量等价的概念

00:17:32.619 --> 00:17:33.954 align:middle
它们保持同样的值

00:17:34.821 --> 00:17:37.925 align:middle
重要的是
那个恒等式并不重要

00:17:38.959 --> 00:17:40.160 align:middle
因为可有任何数字的复制

00:17:40.227 --> 00:17:42.629 align:middle
重要的是存储在那里的实际值

00:17:43.330 --> 00:17:44.831 align:middle
你怎样拿到那个值并不重要

00:17:45.232 --> 00:17:47.534 align:middle
我给你们讲几件非常愚蠢的事

00:17:48.368 --> 00:17:50.437 align:middle
我们这里有A把它设置成五还有B

00:17:50.504 --> 00:17:51.805 align:middle
我们把B设置成二加三

00:17:52.639 --> 00:17:54.274 align:middle
当然了 A和B是等价的

00:17:55.375 --> 00:17:56.310 align:middle
你一直是这么用的

00:17:56.376 --> 00:17:58.912 align:middle
如果整数不是这么用的
你就理解不了了

00:17:59.513 --> 00:18:01.715 align:middle
因此把那个概念扩展一点

00:17:59.513 --> 00:18:01.715 align:middle
因此把那个概念扩展一点

00:18:02.282 --> 00:18:04.117 align:middle
当然了
对CGPoints来说也是如此

00:18:04.184 --> 00:18:05.953 align:middle
如果不是这种方式的话 你也理解不了

00:18:07.154 --> 00:18:09.790 align:middle
为什么字符串的行为
方式不是一模一样呢？

00:18:10.290 --> 00:18:13.527 align:middle
我怎样得到“你好 苹果全球
开发者大会”这个串不重要

00:18:14.561 --> 00:18:18.432 align:middle
字符串是数值
相同运算符需要把它表示出来

00:18:19.199 --> 00:18:21.668 align:middle
你可能会让它非常疯狂非常愚蠢

00:18:21.735 --> 00:18:24.605 align:middle
这里我要进行一些排序操作

00:18:25.072 --> 00:18:26.540 align:middle
归根结底我有整数的两个阵列

00:18:26.607 --> 00:18:28.809 align:middle
整数有同样的值

00:18:29.209 --> 00:18:30.611 align:middle
因此这些东西是等价的

00:18:31.578 --> 00:18:35.349 align:middle
当构建一个数值类型 非常重要的点是

00:18:35.949 --> 00:18:37.684 align:middle
要遵从“相等”协议

00:18:37.751 --> 00:18:41.088 align:middle
因为那里的每个数值类型都是相等

00:18:41.722 --> 00:18:44.258 align:middle
这就意味着它有等于操作符

00:18:44.324 --> 00:18:46.527 align:middle
来进行对比 但是操作符的运作方式

00:18:46.593 --> 00:18:48.195 align:middle
必须合乎情理

00:18:48.262 --> 00:18:50.998 align:middle
它需要是反身的、对称的、及物的

00:18:51.632 --> 00:18:53.066 align:middle
为什么这些属性很重要？

00:18:53.467 --> 00:18:55.702 align:middle
除非你拿到你的代码 否则你不理解

00:18:56.670 --> 00:18:58.605 align:middle
如果我从A复制到B

00:18:59.072 --> 00:19:01.642 align:middle
那么我期待A等于B B等于A

00:18:59.072 --> 00:19:01.642 align:middle
那么我期待A等于B B等于A

00:19:01.909 --> 00:19:03.043 align:middle
当然了 为什么不相等呢？

00:19:03.510 --> 00:19:06.113 align:middle
如果我之后又从B复制到C
那么C、B、A

00:19:06.180 --> 00:19:08.849 align:middle
它们都是等价的 我有哪个数字不重要
因为唯一重要的是值

00:19:08.916 --> 00:19:11.218 align:middle
而不是恒等式

00:19:12.686 --> 00:19:15.389 align:middle
幸运的是 实现这些非常容易

00:19:16.290 --> 00:19:18.492 align:middle
让我说就是拿出CGPoints

00:19:18.926 --> 00:19:21.662 align:middle
用“相等”协议扩展实现相同运算符

00:19:21.828 --> 00:19:24.131 align:middle
当你在其它数值类型上构成数值类型时

00:19:24.231 --> 00:19:27.067 align:middle
一般来说你只需要使用

00:19:27.534 --> 00:19:29.069 align:middle
下面的所有数值类型的

00:19:29.136 --> 00:19:30.037 align:middle
等号操作

00:19:32.272 --> 00:19:34.541 align:middle
好的
让我们把它弄回我们的温度类型

00:19:35.242 --> 00:19:36.677 align:middle
我们现在生成一个结构

00:19:37.010 --> 00:19:40.380 align:middle
我们要把摄氏度切换回一个var
我们就可以改变它

00:19:41.181 --> 00:19:42.482 align:middle
它现在就有了数值语义

00:19:42.549 --> 00:19:44.284 align:middle
很明显 我们给了它相同运算符

00:19:44.852 --> 00:19:47.654 align:middle
我们来把它用到我们之前的例子中
很好

00:19:47.721 --> 00:19:49.823 align:middle
创建家庭 创建温度 把温度设为华氏

00:19:49.890 --> 00:19:52.659 align:middle
七十五度 哇！

00:19:52.759 --> 00:19:54.661 align:middle
编译器停在这里了 发生什么了？

00:19:55.729 --> 00:19:59.233 align:middle
我们试着改变温度的一个属性

00:19:59.466 --> 00:20:00.767 align:middle
这项属性的描述是“let”

00:19:59.466 --> 00:20:00.767 align:middle
这项属性的描述是“let”

00:20:01.168 --> 00:20:02.336 align:middle
它是一个常量 不能更改

00:20:03.070 --> 00:20:04.238 align:middle
我们来满足编译器

00:20:04.605 --> 00:20:06.106 align:middle
把它改成var 现在可以改变它了

00:20:06.640 --> 00:20:08.342 align:middle
一切都进展顺利

00:20:09.610 --> 00:20:12.846 align:middle
为什么呢？家庭指向了烤箱内的恒温器

00:20:13.113 --> 00:20:16.016 align:middle
恒温器和烤箱都有了各自的温度数值

00:20:16.083 --> 00:20:17.284 align:middle
实例

00:20:17.351 --> 00:20:19.419 align:middle
它们是完全不同的不会共享

00:20:20.087 --> 00:20:21.622 align:middle
它们在结构中碰巧也是内联的

00:20:21.688 --> 00:20:23.657 align:middle
你的内存使用情况以及性能都更好了

00:20:24.858 --> 00:20:28.061 align:middle
这很棒 数值语义让我们的生活更容易

00:20:28.662 --> 00:20:31.331 align:middle
有了我们的例子让我们继续

00:20:31.431 --> 00:20:33.467 align:middle
把所有的事情都变得有数值语义

00:20:34.968 --> 00:20:37.304 align:middle
房子的结构里面有一个恒温器结构

00:20:37.371 --> 00:20:39.907 align:middle
一个烤箱结构 整个世界都是数值语义

00:20:40.140 --> 00:20:45.245 align:middle
我们需要对我们的代码做的
变更就是 现在家庭是可变化的了

00:20:45.546 --> 00:20:48.081 align:middle
因为我们改变了家庭的恒温器的温度

00:20:48.482 --> 00:20:51.652 align:middle
对 那是家庭、恒温器的
一个变异温度的一个变异

00:20:55.722 --> 00:20:57.324 align:middle
好的 现在就到了一个非常重要的地方

00:20:57.591 --> 00:21:00.827 align:middle
因为Swift的不变性工作模型
数值语义在Swift中

00:20:57.591 --> 00:21:00.827 align:middle
因为Swift的不变性工作模型
数值语义在Swift中

00:21:01.228 --> 00:21:04.364 align:middle
运行的天衣无缝

00:21:04.998 --> 00:21:08.535 align:middle
如果在Swift中有一个“let”
那么它就是数值类型

00:21:08.735 --> 00:21:12.472 align:middle
这意味着当某个东西损坏了
你的进程的内存时

00:21:12.539 --> 00:21:14.575 align:middle
这个值不会很快发生改变

00:21:16.643 --> 00:21:18.645 align:middle
这是一个健壮的语句

00:21:19.213 --> 00:21:21.748 align:middle
它意味着
推论出“let”的事情非常容易

00:21:22.349 --> 00:21:24.218 align:middle
不过我们仍然允许有变异

00:21:24.384 --> 00:21:27.387 align:middle
你可使用var 说这个变量是能变的

00:21:27.888 --> 00:21:30.023 align:middle
对于我们的算法来说 这就非常有用

00:21:31.325 --> 00:21:33.293 align:middle
注意这个变更是非常本地的

00:21:33.460 --> 00:21:35.329 align:middle
我可以变更这个变量但是除非我告诉它

00:21:35.395 --> 00:21:38.432 align:middle
除非我在其它地方做出改变
否则它是不会影响到

00:21:38.632 --> 00:21:41.235 align:middle
我的项目中的其它地方的

00:21:41.802 --> 00:21:44.905 align:middle
这样就有了这个非常漂亮的受控易变性

00:21:46.440 --> 00:21:47.774 align:middle
其它地方有了可靠的保证

00:21:49.009 --> 00:21:51.778 align:middle
这里有趣的一件事是
当你使用数值类型、把它们

00:21:51.979 --> 00:21:54.414 align:middle
传递到线程边界时
你就可以避免这些类型

00:21:54.481 --> 00:21:56.683 align:middle
出现竞态条件

00:21:57.150 --> 00:21:58.018 align:middle
我创建数字

00:21:58.085 --> 00:21:59.753 align:middle
把它们传递给某些会异步处理

00:21:59.820 --> 00:22:01.588 align:middle
事情的进程

00:21:59.820 --> 00:22:01.588 align:middle
事情的进程

00:22:02.155 --> 00:22:04.157 align:middle
我本地改变数字 然后再来一次

00:22:04.591 --> 00:22:08.662 align:middle
有了一个引用语义阵列
这是一个竞态条件

00:22:09.062 --> 00:22:10.364 align:middle
有时候 它会把你吹炸

00:22:10.631 --> 00:22:13.233 align:middle
有了数值语义 你每次都能得到复件

00:22:13.800 --> 00:22:14.902 align:middle
每次都能得到逻辑复件

00:22:16.069 --> 00:22:17.738 align:middle
因此 就没有竞态条件

00:22:18.372 --> 00:22:20.040 align:middle
它们不会同时到达相同的阵列

00:22:21.141 --> 00:22:23.911 align:middle
好的
这个听起来像一个性能问题 不是吗？

00:22:24.244 --> 00:22:27.681 align:middle
每次我们通过一个参数传递数字时
我们就会进行一次拷贝

00:22:28.916 --> 00:22:32.853 align:middle
好的 关于数值语义另外重要的一点是

00:22:32.920 --> 00:22:34.388 align:middle
复制很“廉价”

00:22:34.888 --> 00:22:37.457 align:middle
这里的“廉价”
我的意思是时间常数“廉价”

00:22:39.226 --> 00:22:40.827 align:middle
我们从基础开始构建这个app

00:22:40.894 --> 00:22:42.496 align:middle
当你有基本类型时

00:22:42.563 --> 00:22:45.866 align:middle
那些低层次的东西
整数、两倍数、浮点数等等

00:22:46.099 --> 00:22:48.168 align:middle
复制它们很“廉价”

00:22:48.235 --> 00:22:49.670 align:middle
你复制的只是几个字节

00:22:49.837 --> 00:22:51.638 align:middle
除非是在处理器中进行复制的

00:22:52.973 --> 00:22:57.177 align:middle
你就可以用两倍数、整数等等构建结构

00:22:57.244 --> 00:22:59.680 align:middle
就像CG点是由两个
CG浮点数构建的一样

00:23:00.180 --> 00:23:02.449 align:middle
任何这种结构 枚举或者元组

00:23:02.516 --> 00:23:06.186 align:middle
它们的字段数量是固定的
在那里复制每个东西

00:23:06.253 --> 00:23:08.021 align:middle
都是时间常数的

00:23:08.088 --> 00:23:10.324 align:middle
因此复制整个东西也是时间常数的

00:23:11.992 --> 00:23:13.293 align:middle
好的

00:23:13.360 --> 00:23:14.695 align:middle
对于定长的东西来说 这很棒

00:23:14.761 --> 00:23:17.331 align:middle
那么对于可扩展的东西来说
字符串、阵列、字典

00:23:17.397 --> 00:23:18.532 align:middle
又是怎样呢？

00:23:19.099 --> 00:23:21.802 align:middle
我们在Swift中处理这些东西的
方式是“写入时复制”

00:23:22.836 --> 00:23:24.471 align:middle
这样就可以让复制很“廉价”

00:23:24.671 --> 00:23:27.174 align:middle
就是一些固定数量的引用计数
操作来对“写入时复制”

00:23:27.241 --> 00:23:29.676 align:middle
值进行复制

00:23:30.010 --> 00:23:32.679 align:middle
当你进行改变时 你有了一个var

00:23:32.746 --> 00:23:35.115 align:middle
然后你就可以变更它
我们也就制作一份副本

00:23:35.182 --> 00:23:36.049 align:middle
并且在其上工作

00:23:36.850 --> 00:23:39.319 align:middle
因此你就是背后分享

00:23:40.654 --> 00:23:42.589 align:middle
但并不是逻辑分享

00:23:42.656 --> 00:23:44.992 align:middle
从逻辑上来说 这些仍然是不同的值

00:23:45.225 --> 00:23:47.160 align:middle
这样你的数值语义的性能特征

00:23:47.427 --> 00:23:50.664 align:middle
就很棒 编程模型也很棒

00:23:51.565 --> 00:23:53.600 align:middle
我们非常喜欢数值语义编程模型

00:23:54.268 --> 00:23:57.171 align:middle
从逻辑上说 不同的变量始终是不同的

00:23:58.505 --> 00:24:01.775 align:middle
你想让它是本地控制时 就有变异概念

00:23:58.505 --> 00:24:01.775 align:middle
你想让它是本地控制时 就有变异概念

00:24:01.842 --> 00:24:04.044 align:middle
一个有效的变异

00:24:05.412 --> 00:24:07.147 align:middle
但是你还有这些严格的“let”保证

00:24:07.214 --> 00:24:08.715 align:middle
意味着它不会在其它地方改变

00:24:09.750 --> 00:24:11.952 align:middle
复件很“廉价”我们就可以一起工作

00:24:13.187 --> 00:24:15.656 align:middle
好的 我想交给我的同事

00:24:15.722 --> 00:24:18.659 align:middle
比尔·达德利
他会谈谈数值类型和实践

00:24:26.500 --> 00:24:28.468 align:middle
谢谢 道格 大家好

00:24:28.535 --> 00:24:31.939 align:middle
刚才道格已经给我们讲了
数值类型的工作原理

00:24:32.072 --> 00:24:34.541 align:middle
它们如何与引用语义进行对比

00:24:34.641 --> 00:24:38.879 align:middle
我们来谈谈使用数值类型
构建一个真实的实例

00:24:40.280 --> 00:24:42.583 align:middle
我们要做的
就是把一个实例组织在一起

00:24:42.649 --> 00:24:44.885 align:middle
然后我们通过几个不同的值、
一个圈和一个多边形

00:24:44.952 --> 00:24:48.322 align:middle
构建一个简单的图表

00:24:49.857 --> 00:24:51.859 align:middle
让我们从圆开始吧

00:24:51.925 --> 00:24:54.228 align:middle
这是圆心 这是半径

00:24:54.294 --> 00:24:55.996 align:middle
都是取自标准库的几个

00:24:56.063 --> 00:24:57.231 align:middle
数值类型

00:24:57.865 --> 00:25:00.701 align:middle
当然了
我们想要实现相同运算符

00:24:57.865 --> 00:25:00.701 align:middle
当然了
我们想要实现相同运算符

00:25:00.767 --> 00:25:02.035 align:middle
equals相等操作符

00:25:02.102 --> 00:25:04.438 align:middle
我们只需要对比这些类型就可以实现

00:25:04.505 --> 00:25:06.974 align:middle
同样地
因为它们是内置于标准库的

00:25:07.040 --> 00:25:09.676 align:middle
我们只需要把它们用起来就行
这是因为我们用的是取自库的

00:25:09.743 --> 00:25:11.812 align:middle
简单类型来构建

00:25:13.380 --> 00:25:15.015 align:middle
下一个是多边形

00:25:15.082 --> 00:25:17.050 align:middle
它有一个角落阵列

00:25:17.117 --> 00:25:19.753 align:middle
每个角落都是一个
另一个CG点同样地

00:25:19.820 --> 00:25:21.255 align:middle
这些CG点也是数值类型

00:25:21.321 --> 00:25:23.357 align:middle
因此我们的阵列也是一个数值类型

00:25:23.423 --> 00:25:25.659 align:middle
我们的比较也很直接

00:25:25.726 --> 00:25:27.594 align:middle
只要在那使用equals相等操作符

00:25:27.661 --> 00:25:29.963 align:middle
确保我们实现了“相等”操作符即可

00:25:32.499 --> 00:25:36.603 align:middle
现在我们要做的
就是把这些类型放入我们的图表

00:25:36.670 --> 00:25:39.173 align:middle
把多边形和圆都放进去

00:25:40.374 --> 00:25:42.743 align:middle
制作一个圆的阵列也很直接

00:25:43.510 --> 00:25:47.548 align:middle
制作一个多边形的阵列 同样也很直接

00:25:47.614 --> 00:25:49.483 align:middle
因此我们可以制作任何类型的阵列

00:25:49.550 --> 00:25:53.620 align:middle
我们要做的 就是制作一个
两者都包含的阵列

00:25:54.021 --> 00:25:59.927 align:middle
在Swift中这样做的机制是
使用一项协议

00:26:00.093 --> 00:26:02.296 align:middle
我们会创建一个叫做
Drawable的协议

00:26:02.429 --> 00:26:05.365 align:middle
我们的子类型都会实施

00:26:05.432 --> 00:26:07.434 align:middle
那个协议 然后我们把它们放到

00:26:07.501 --> 00:26:09.303 align:middle
我们的图表中的一个阵列中

00:26:10.804 --> 00:26:14.441 align:middle
“Swift中面向协议编程”
这场会议中有很多信息

00:26:14.575 --> 00:26:18.011 align:middle
今天3:30会再次召开

00:26:18.078 --> 00:26:19.046 align:middle
若你还没有看过的话

00:26:19.112 --> 00:26:21.915 align:middle
我强烈建议你们去看看

00:26:21.982 --> 00:26:23.550 align:middle
或者看看视频

00:26:26.153 --> 00:26:27.754 align:middle
这是我们的Drawable协议

00:26:27.821 --> 00:26:31.158 align:middle
很直接 也很简单
上面有一种方法即“绘制”

00:26:32.559 --> 00:26:34.528 align:middle
当然了 我们想在我们的
两种类型上实施它

00:26:34.595 --> 00:26:36.763 align:middle
我们会创建一个多边形扩展

00:26:36.830 --> 00:26:39.099 align:middle
实施那个绘制方法 然后它会调用

00:26:39.166 --> 00:26:41.201 align:middle
Core Graphics
绘制多边形

00:26:42.970 --> 00:26:44.671 align:middle
圆也是 同样的情况

00:26:45.038 --> 00:26:47.608 align:middle
那么我们要做的
就是调用Core Graphics

00:26:47.674 --> 00:26:49.610 align:middle
构建圆的表示

00:26:54.381 --> 00:26:55.549 align:middle
现在再回到我们的图表

00:26:55.616 --> 00:26:58.051 align:middle
得到了这个可绘制的被调项目阵列

00:26:58.886 --> 00:27:00.854 align:middle
我们需要创建一个方法 添加项目

00:26:58.886 --> 00:27:00.854 align:middle
我们需要创建一个方法 添加项目

00:27:00.921 --> 00:27:03.690 align:middle
它被标记为了“变异的”
因为那会改变它自身

00:27:05.192 --> 00:27:08.028 align:middle
我们要实现这个绘制方式
来对那个项目列表进行

00:27:08.095 --> 00:27:10.230 align:middle
简单迭代并且调用列表上的

00:27:10.297 --> 00:27:12.332 align:middle
每个项目的绘制方式

00:27:13.166 --> 00:27:15.269 align:middle
我们来以图解的方式 看看它

00:27:15.836 --> 00:27:18.805 align:middle
我们创建一个图表称之为doc

00:27:19.773 --> 00:27:22.142 align:middle
我们创建一个多边形
然后把它添加到阵列上

00:27:23.410 --> 00:27:26.613 align:middle
我们再创建一个圆也把它添加到阵列上

00:27:26.680 --> 00:27:29.016 align:middle
现在我们的阵列内有了两项可绘制物

00:27:29.449 --> 00:27:30.951 align:middle
注意它们的类型是不同的

00:27:33.620 --> 00:27:37.658 align:middle
当我们再创建
一个文档并且说doc2等于doc

00:27:37.724 --> 00:27:40.394 align:middle
得到了一个逻辑上不同的、全新的实例

00:27:40.460 --> 00:27:43.297 align:middle
从逻辑上说它和第一个实例是分开的

00:27:46.867 --> 00:27:50.070 align:middle
我现在可以返回doc2进行更改
当我进行更改时

00:27:50.137 --> 00:27:52.706 align:middle
当然了它对doc没有影响

00:27:52.773 --> 00:27:54.975 align:middle
我把那个圆改成一个多边形

00:27:55.742 --> 00:27:58.545 align:middle
阵列有数值语义即使集合是

00:27:58.612 --> 00:28:01.181 align:middle
即使是不纯一的

00:27:58.612 --> 00:28:01.181 align:middle
即使是不纯一的

00:28:01.248 --> 00:28:05.919 align:middle
那么它的内部就有了多边形
那个阵列内的圆

00:28:05.986 --> 00:28:07.154 align:middle
也是一个值

00:28:10.090 --> 00:28:15.863 align:middle
当然了 我们想把我们的
图表的结构做成“相等”的

00:28:15.929 --> 00:28:17.431 align:middle
因此我们把协议实现

00:28:17.497 --> 00:28:19.433 align:middle
我们看到的
这是一个非常直接的

00:28:19.499 --> 00:28:20.834 align:middle
实现

00:28:21.168 --> 00:28:23.337 align:middle
但 如果我们那样做编辑器就会说

00:28:23.403 --> 00:28:27.007 align:middle
“等等方程式两边的两个值
我没有equals相等操作符”

00:28:27.074 --> 00:28:30.110 align:middle
对于在该方程式的两边这两个值

00:28:30.177 --> 00:28:32.980 align:middle
再说一次 我推荐你们去看
面向协议的编程

00:28:33.046 --> 00:28:36.450 align:middle
我们在那里讲了它的所有的原理细节

00:28:36.517 --> 00:28:39.553 align:middle
我们本次会议专注的是数值语义

00:28:41.755 --> 00:28:45.459 align:middle
可绘制物有个叫做“绘制”的单一方法

00:28:45.526 --> 00:28:48.428 align:middle
图表也有一个叫做“绘制”的方法

00:28:48.495 --> 00:28:51.999 align:middle
把我们的图表变成一个可绘制物

00:28:52.232 --> 00:28:54.601 align:middle
我们只需要把那个声明加到它上面

00:28:54.668 --> 00:28:58.605 align:middle
现在我们的图表像鸭子一样
嘎嘎叫 那它就是一只鸭子了

00:29:01.041 --> 00:29:02.743 align:middle
那么接下来的就非常有趣了

00:29:02.809 --> 00:29:08.882 align:middle
我可以创建一个新的图表
并把它添加到我现有的图表

00:29:09.950 --> 00:29:12.186 align:middle
那里有了三种不同的类型

00:29:12.252 --> 00:29:15.322 align:middle
不过它们都包含在那个阵列中

00:29:16.023 --> 00:29:17.791 align:middle
它是图表的一个新的实例

00:29:19.092 --> 00:29:21.195 align:middle
但是我还可以再进一步

00:29:21.261 --> 00:29:23.263 align:middle
把那个文档加到阵列中

00:29:23.630 --> 00:29:25.532 align:middle
如果这些是引用语义

00:29:26.400 --> 00:29:27.334 align:middle
我们来看看绘制方法

00:29:27.401 --> 00:29:29.169 align:middle
如果这个是引用语义

00:29:29.369 --> 00:29:30.737 align:middle
它就会无限递归

00:29:31.338 --> 00:29:35.809 align:middle
因为当我在我的图表上调用
“绘制”时 它就会遍历

00:29:35.876 --> 00:29:37.911 align:middle
项目列表
并且在列表上找到它自己

00:29:37.978 --> 00:29:40.814 align:middle
然后就会再次调用“绘制”
出现无限递归

00:29:41.148 --> 00:29:43.717 align:middle
不过我们用到是值

00:29:43.784 --> 00:29:48.422 align:middle
因为它是一个值
添加到我的图表的

00:29:48.488 --> 00:29:49.790 align:middle
一个完全分开的、不同的实例

00:29:49.857 --> 00:29:53.493 align:middle
而不是doc

00:29:54.328 --> 00:29:56.163 align:middle
因此不会出现无限递归

00:29:56.230 --> 00:29:59.600 align:middle
我刚刚绘制了两个多边形以及两个圆

00:30:02.870 --> 00:30:05.072 align:middle
既然已经讲过了 纯粹由数值类型构建

00:30:05.138 --> 00:30:06.974 align:middle
一个对象树

00:30:07.040 --> 00:30:10.077 align:middle
我们来讲怎样混淆数值类型和引用类型

00:30:10.911 --> 00:30:12.212 align:middle
在Objective-C中

00:30:12.279 --> 00:30:15.516 align:middle
你已经习惯了始终把原始
数据类型放到你的引用类型中

00:30:15.582 --> 00:30:18.352 align:middle
在Objective-C
中就是这样构建东西的

00:30:19.286 --> 00:30:22.422 align:middle
但是另一方面
这会产生一些有趣的问题

00:30:22.489 --> 00:30:24.024 align:middle
我们必须仔细考虑这些问题

00:30:25.225 --> 00:30:27.928 align:middle
如果我们构建一个数值类型
我们就想要确保

00:30:27.995 --> 00:30:31.365 align:middle
那个数值类型
维持自身的数值语义

00:30:31.431 --> 00:30:34.067 align:middle
哪怕它里面有一个引用

00:30:34.368 --> 00:30:35.769 align:middle
如果我们要那么做

00:30:35.836 --> 00:30:37.304 align:middle
我们就必须仔细考虑那个问题

00:30:37.371 --> 00:30:39.373 align:middle
我们该怎样处理这个事实：

00:30:39.439 --> 00:30:43.944 align:middle
它里面有一个引用 两个不同的值可能

00:30:44.011 --> 00:30:45.379 align:middle
指向了同一件事？

00:30:45.579 --> 00:30:47.347 align:middle
我们就必须解决那个问题

00:30:47.414 --> 00:30:48.348 align:middle
我们要仔细考虑的

00:30:48.415 --> 00:30:50.717 align:middle
另一件事是：
它会对等式产生什么样的影响？

00:30:52.019 --> 00:30:53.720 align:middle
让我们从一个带有不可变类的

00:30:53.787 --> 00:30:56.857 align:middle
简单例子开始 UIImage

00:30:57.391 --> 00:31:01.328 align:middle
创建一个要成为 可绘制物的图片结构

00:30:57.391 --> 00:31:01.328 align:middle
创建一个要成为 可绘制物的图片结构

00:31:01.395 --> 00:31:03.330 align:middle
它对UIImage有一个引用

00:31:05.132 --> 00:31:06.366 align:middle
我们用旧金山的这幅美丽的

00:31:06.433 --> 00:31:08.869 align:middle
照片来创建一个实例

00:31:10.204 --> 00:31:13.540 align:middle
如果我们再创建一个“图片2”现在

00:31:13.607 --> 00:31:16.710 align:middle
“图片”和“图片2”
就都指向了同一个对象

00:31:17.211 --> 00:31:18.779 align:middle
如果你看这个
你会想比尔骗我们了

00:31:18.846 --> 00:31:20.747 align:middle
这肯定会出问题 就像那个

00:31:20.814 --> 00:31:21.949 align:middle
温度一样

00:31:22.449 --> 00:31:25.652 align:middle
但是
这不是因为UIImage是不可变的

00:31:25.719 --> 00:31:29.756 align:middle
因此我们不用担心“图片2”
会改变位于它下方的

00:31:29.823 --> 00:31:30.724 align:middle
“图片”

00:31:30.791 --> 00:31:33.594 align:middle
不要担心第一个图片会猝不及防受到

00:31:33.660 --> 00:31:34.494 align:middle
改变的影响

00:31:35.729 --> 00:31:38.732 align:middle
我们想要确保我们实现这个等式

00:31:39.600 --> 00:31:41.735 align:middle
你可能会看到这个然后想“没问题”

00:31:41.802 --> 00:31:43.437 align:middle
我要使用三元组相等操作符

00:31:43.504 --> 00:31:46.306 align:middle
它会对比引用看看

00:31:46.373 --> 00:31:47.808 align:middle
那些引用是否相同

00:31:48.342 --> 00:31:51.778 align:middle
对于这个例子来说
当然没问题 不过我们还必须

00:31:51.845 --> 00:31:52.913 align:middle
认真考虑下 当我们使用

00:31:52.980 --> 00:31:57.751 align:middle
同样的底层位图创建两个UI图片时
会发生什么？

00:31:58.519 --> 00:32:02.523 align:middle
我们想让它们也相等、同等
在这个例子中

00:31:58.519 --> 00:32:02.523 align:middle
我们想让它们也相等、同等
在这个例子中

00:32:02.589 --> 00:32:04.958 align:middle
因为我们是在对比引用
它们就不会相等

00:32:05.025 --> 00:32:06.527 align:middle
因此 说这两个图片

00:32:06.593 --> 00:32:08.762 align:middle
不相同 就错了

00:32:09.229 --> 00:32:12.566 align:middle
想要使用我们从UIImage上的
NSObject继承“是等效方法”

00:32:12.900 --> 00:32:16.336 align:middle
来进行对比

00:32:16.403 --> 00:32:19.339 align:middle
这样
不管是否在相同的对象上

00:32:19.540 --> 00:32:25.145 align:middle
我们都可以确信引用类型
获得正确的回复

00:32:25.212 --> 00:32:27.681 align:middle
我们来谈谈如何使用可变的对象

00:32:28.215 --> 00:32:30.450 align:middle
在这里有一个BezierPath

00:32:31.351 --> 00:32:32.953 align:middle
它也会实现“可绘制物”

00:32:33.520 --> 00:32:35.155 align:middle
但是整个实现是由这个可变的

00:32:35.222 --> 00:32:38.525 align:middle
引用类型
UIBezierPath构成的

00:32:39.693 --> 00:32:42.696 align:middle
在这个读取实例中
当我们进行“Is Empty”时

00:32:42.763 --> 00:32:43.664 align:middle
一起都正常

00:32:43.730 --> 00:32:45.832 align:middle
没有进行任何改变
因为不会和任何其它的

00:32:45.899 --> 00:32:48.402 align:middle
实例混杂到一起

00:32:49.069 --> 00:32:52.272 align:middle
但是下面的这个
我们有这个“向点添加线”方法

00:32:52.472 --> 00:32:55.175 align:middle
如果我们有两个
BezierPaths指向这个方法

00:32:55.309 --> 00:32:56.610 align:middle
它就会造成问题

00:32:57.444 --> 00:33:00.714 align:middle
我们在那里
并没有“改变中”这个关键字

00:32:57.444 --> 00:33:00.714 align:middle
我们在那里
并没有“改变中”这个关键字

00:33:01.415 --> 00:33:04.585 align:middle
那是一个符号 表明我们知道
我们正在进行改变

00:33:04.651 --> 00:33:06.687 align:middle
“向点添加线”在那里
但是编译器并没有对着

00:33:06.753 --> 00:33:09.389 align:middle
大喊大叫 告诉我们这一点
这是因为路径是一种引用类型

00:33:09.823 --> 00:33:11.558 align:middle
我们很快会再看看它

00:33:12.659 --> 00:33:16.697 align:middle
如果有两个BezierPath实例
并且都通过这个改变

00:33:16.763 --> 00:33:18.799 align:middle
指向了
同一个UIBezierPath实例

00:33:18.866 --> 00:33:22.269 align:middle
如果我做出改变 那么

00:33:22.336 --> 00:33:23.971 align:middle
它就会让另一个实例措手不及

00:33:24.037 --> 00:33:25.606 align:middle
这种情况可不妙

00:33:25.672 --> 00:33:27.774 align:middle
我们就没法维持数值语义

00:33:28.041 --> 00:33:29.710 align:middle
我们需要修复它

00:33:30.677 --> 00:33:33.514 align:middle
我们修复的方式是使用“写入时复制”

00:33:33.881 --> 00:33:37.384 align:middle
我们需要确保
在我们写入那个路径之前

00:33:37.451 --> 00:33:39.186 align:middle
已经制作了它的一个副本

00:33:40.988 --> 00:33:42.789 align:middle
因此
要向我们的BezierPath中

00:33:42.856 --> 00:33:44.892 align:middle
引入一些新事物

00:33:44.958 --> 00:33:49.196 align:middle
首先我们想要让我们的
路径实例是私有的

00:33:49.496 --> 00:33:52.900 align:middle
其次想要实现这个读取计算路径属性

00:33:52.966 --> 00:33:56.370 align:middle
并从那里返回我们的私有实例变量

00:33:57.971 --> 00:33:59.339 align:middle
我们也想为写入计算属性

00:33:59.406 --> 00:34:02.776 align:middle
创建一个路径路径标记为“改变中”

00:33:59.406 --> 00:34:02.776 align:middle
创建一个路径路径标记为“改变中”

00:34:03.110 --> 00:34:04.845 align:middle
那么它就会 事实上改变状态

00:34:04.912 --> 00:34:07.714 align:middle
我们把它标记为“改变中”
把路径设为与我们现有路径的

00:34:07.781 --> 00:34:10.751 align:middle
新副本等同

00:34:11.284 --> 00:34:15.121 align:middle
现在我们有了一个读取副本
我们还可以获得一个写入副本

00:34:16.590 --> 00:34:18.824 align:middle
那么我们改变我们的实现
来反映这一点

00:34:18.891 --> 00:34:21.695 align:middle
在“Is Empty”方法中
我们会调用我们的读取副本

00:34:22.029 --> 00:34:23.764 align:middle
在下面的改变方法那里

00:34:23.830 --> 00:34:25.465 align:middle
我们会调用写入路径

00:34:25.732 --> 00:34:28.402 align:middle
关于这个 很棒的一点是
编译器会对我们大喊大叫

00:34:28.467 --> 00:34:29.969 align:middle
说：“写入属性路径标记为了

00:34:30.370 --> 00:34:33.473 align:middle
改变中 这个方法没有

00:34:33.806 --> 00:34:36.009 align:middle
标记为改变中 ”

00:34:36.076 --> 00:34:39.012 align:middle
我们就从编译器得到了帮助
在我们搞错时

00:34:39.079 --> 00:34:41.081 align:middle
帮助我们弄明白

00:34:43.984 --> 00:34:46.553 align:middle
在一个图表中浏览下它 浏览下路径

00:34:46.987 --> 00:34:49.556 align:middle
我通过说
“Path To”又创建了一个

00:34:49.989 --> 00:34:51.091 align:middle
当然 我可以读取它

00:34:51.158 --> 00:34:54.360 align:middle
没问题 当我对它写入时

00:34:54.995 --> 00:34:58.966 align:middle
建了另一个BezierPath实例

00:34:59.566 --> 00:35:02.736 align:middle
路径二还是不明白已经发生了一次变异

00:34:59.566 --> 00:35:02.736 align:middle
路径二还是不明白已经发生了一次变异

00:35:03.103 --> 00:35:09.009 align:middle
因此我不会在路径二后面
引入一些意料之外的变异

00:35:10.777 --> 00:35:14.681 align:middle
现在我们来谈谈如何在
实践中使用这些东西

00:35:15.649 --> 00:35:19.286 align:middle
这里我们有我们的
多边形类型 我们要通过

00:35:19.353 --> 00:35:21.455 align:middle
添加一个会返回给我们
对那个多边形进行描述的

00:35:21.522 --> 00:35:24.291 align:middle
BezierPath
的方法对它进行扩展

00:35:24.825 --> 00:35:27.327 align:middle
我们创建BezierPath
通过点进行迭代

00:35:27.394 --> 00:35:29.763 align:middle
向这些点中添加线二

00:35:30.797 --> 00:35:33.100 align:middle
现在缺点就是那个
“添加线到点”方法

00:35:33.166 --> 00:35:36.069 align:middle
会复制每次调用

00:35:36.637 --> 00:35:39.439 align:middle
因此它的表现可能不那么好

00:35:40.974 --> 00:35:43.577 align:middle
因此我们应该创建一个
UIBezierPath实例

00:35:43.644 --> 00:35:48.982 align:middle
然后就地改变那个可变的引用类型

00:35:49.316 --> 00:35:52.753 align:middle
当我们弄完后
用那个BezierPath创建一个

00:35:52.819 --> 00:35:55.155 align:middle
数值类型新的实例
且返回那个BezierPath

00:35:55.222 --> 00:35:57.124 align:middle
这样生成
UIBezierPath副本

00:35:57.191 --> 00:36:00.460 align:middle
或者生成个UIBezierPath
实例而不是生成多个副本、实例

00:35:57.191 --> 00:36:00.460 align:middle
或者生成个UIBezierPath
实例而不是生成多个副本、实例

00:36:01.962 --> 00:36:04.665 align:middle
在Swift中 有一个很棒的特性

00:36:04.731 --> 00:36:07.367 align:middle
可以通过它知道对象是否被惟一地引用

00:36:07.434 --> 00:36:09.102 align:middle
这样我们就可以利用它

00:36:09.169 --> 00:36:11.572 align:middle
这个结构和
BezierPath中看到的类似

00:36:12.206 --> 00:36:15.609 align:middle
我们可以利用我们有这个
惟一引用属性这一事实

00:36:15.676 --> 00:36:17.644 align:middle
我们就可以肯定

00:36:17.711 --> 00:36:18.946 align:middle
有些东西是被惟一引用的

00:36:19.012 --> 00:36:20.714 align:middle
如果我们知道那个引用类型是惟一引用

00:36:20.981 --> 00:36:23.851 align:middle
我们就可以避免制作副本

00:36:25.252 --> 00:36:27.487 align:middle
标准库会自始至终使用那个特性

00:36:27.554 --> 00:36:30.490 align:middle
使用那个特性
也可以进行很多很棒的性能优化

00:36:32.292 --> 00:36:34.561 align:middle
这样酒吧数值类型以及引用类型混合了

00:36:34.628 --> 00:36:37.497 align:middle
尽管事实是通过使用“写入时复制”

00:36:37.865 --> 00:36:44.071 align:middle
你在可变类型上有这些引用
你也想要确保你可以维持数值语义

00:36:46.206 --> 00:36:48.976 align:middle
现在我想看一个非常酷的特性
我们现在能做的

00:36:49.042 --> 00:36:52.312 align:middle
就是把一个模型类型当做一个
值来实现

00:36:53.080 --> 00:36:54.715 align:middle
然后实现一个撤销栈

00:36:55.382 --> 00:36:59.052 align:middle
那么我要创建一个图表
以及一个图表阵列

00:36:59.319 --> 00:37:04.892 align:middle
有了各个变异 我会把我的
doc添加到我的图表阵列中

00:36:59.319 --> 00:37:04.892 align:middle
有了各个变异 我会把我的
doc添加到我的图表阵列中

00:37:05.259 --> 00:37:06.760 align:middle
那么我创建并附加它

00:37:07.461 --> 00:37:10.697 align:middle
我添加了一个多边形
并且把它附加到了撤销栈

00:37:11.632 --> 00:37:14.334 align:middle
我创建了一个圈
并且把它附加到了撤销栈

00:37:14.902 --> 00:37:21.008 align:middle
现在在我的撤销栈里
我有三个不同的图表实例

00:37:21.074 --> 00:37:23.677 align:middle
它们没有引用同一件事情

00:37:23.744 --> 00:37:26.146 align:middle
这些是三个不同的值

00:37:26.580 --> 00:37:29.583 align:middle
因此可用它来实现一些很酷的特性

00:37:29.716 --> 00:37:33.754 align:middle
假设这个位于一个app内
我有一个“历史”按钮

00:37:34.054 --> 00:37:37.124 align:middle
我点击这个“历史”按钮
我得到了返回到

00:37:37.191 --> 00:37:40.527 align:middle
我的撤销栈的
我的图表的全部状态列表

00:37:41.094 --> 00:37:43.463 align:middle
我就可以允许用户点击其它东西

00:37:43.630 --> 00:37:45.566 align:middle
并且及时返回

00:37:45.699 --> 00:37:50.137 align:middle
我就不用在某个阵列中保存
如何撤销添加那个属性

00:37:50.204 --> 00:37:51.638 align:middle
或者撤销添加其它东西

00:37:51.705 --> 00:37:53.640 align:middle
它会直接返回上一个实例

00:37:53.707 --> 00:37:55.609 align:middle
也就是刚刚绘制的那个实例

00:37:56.944 --> 00:38:00.247 align:middle
这是一项超级强大的特性 事实上

00:37:56.944 --> 00:38:00.247 align:middle
这是一项超级强大的特性 事实上

00:38:00.314 --> 00:38:03.183 align:middle
Photoshop大量使用这一特性
以便实现他们的各个

00:38:03.250 --> 00:38:04.785 align:middle
与历史相关的东西

00:38:05.018 --> 00:38:07.154 align:middle
当在Photoshop打开一幅图片

00:38:07.221 --> 00:38:09.223 align:middle
幕后发生了什么？

00:38:09.323 --> 00:38:11.525 align:middle
Photoshop会对
那个照片分层、切块

00:38:11.592 --> 00:38:14.895 align:middle
不论照片有多大切分成一堆小的图块

00:38:15.128 --> 00:38:18.565 align:middle
每个这种图块都是数值 含图块的文档

00:38:18.632 --> 00:38:21.702 align:middle
同样也是一个数值

00:38:22.102 --> 00:38:24.605 align:middle
如果我进行改变比如说把这个人的衬衫

00:38:24.671 --> 00:38:29.610 align:middle
从紫色变成绿色
在那个图表的两个实例中唯一

00:38:29.676 --> 00:38:33.180 align:middle
被复制的
就是包含了这个人的衬衫的

00:38:33.247 --> 00:38:35.382 align:middle
图块

00:38:35.616 --> 00:38:38.318 align:middle
这样即使我有两个不同的文档

00:38:38.385 --> 00:38:42.523 align:middle
旧状态和新状态 我唯一需要当成那个

00:38:42.589 --> 00:38:44.525 align:middle
结果来使用的新数据

00:38:44.591 --> 00:38:47.828 align:middle
就是包含了这个人的衬衫的图块

00:38:50.097 --> 00:38:52.966 align:middle
小结一下 我们讲了数值类型

00:38:53.033 --> 00:38:55.802 align:middle
讲了它给你们的
应用程序带来的很棒的特性

00:38:55.869 --> 00:38:58.772 align:middle
把它和引用类型做了对比
向你们演示了数值类似

00:38:58.972 --> 00:39:00.374 align:middle
是如何修复某些问题的

00:38:58.972 --> 00:39:00.374 align:middle
是如何修复某些问题的

00:39:00.908 --> 00:39:03.410 align:middle
期间我们演示了一个实例
让你们看了一些你们可以

00:39:03.477 --> 00:39:05.746 align:middle
通过使用数值类型
添加到你们的应用程序上的

00:39:05.812 --> 00:39:07.281 align:middle
很酷的特性

00:39:07.347 --> 00:39:10.517 align:middle
我迫不及待想看到这些东西
在你们的app中是如何发挥作用的

00:39:11.051 --> 00:39:13.620 align:middle
有一些相关的会议 你可以观看视频

00:39:13.687 --> 00:39:15.389 align:middle
或者如果你有时间的话 今天3:30

00:39:15.455 --> 00:39:17.257 align:middle
有关于面向协议编程的会议

00:39:18.392 --> 00:39:21.428 align:middle
如果需要更多信息
你总可以给斯蒂芬发邮件

00:39:21.495 --> 00:39:25.132 align:middle
或者访问我们的论坛资料中也有一些

00:39:25.199 --> 00:39:26.300 align:middle
很棒的信息

00:39:27.067 --> 00:39:29.536 align:middle
谢谢 祝你们在苹果全球
开发者大会的剩余部分愉快
