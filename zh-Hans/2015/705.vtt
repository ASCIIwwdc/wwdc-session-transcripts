WEBVTT

00:00:36.937 --> 00:00:39.473 align:middle
Core Motion中有什么新料

00:00:41.408 --> 00:00:43.143 align:middle
下午好 欢迎大家

00:00:44.144 --> 00:00:47.447 align:middle
我的名字是阿尼尔·卡南加
今天我要讲一讲

00:00:47.514 --> 00:00:49.183 align:middle
Core Motion中有什么新料

00:00:49.616 --> 00:00:51.552 align:middle
我们能讲的事情比较多

00:00:51.618 --> 00:00:53.987 align:middle
不过今天我们主要讲几个关键点

00:00:56.056 --> 00:00:59.693 align:middle
我们会首先谈一谈
Apple Watch

00:00:59.760 --> 00:01:02.596 align:middle
这是我们的一个新的平台
我们会谈谈怎样把你的

00:00:59.760 --> 00:01:02.596 align:middle
这是我们的一个新的平台
我们会谈谈怎样把你的

00:01:02.663 --> 00:01:05.399 align:middle
Core Motion apps
弄到Apple Watch上

00:01:05.999 --> 00:01:07.935 align:middle
我们也对计步器做了一些

00:01:08.001 --> 00:01:10.571 align:middle
新的变更
其中包括一些新的APIs

00:01:12.039 --> 00:01:17.711 align:middle
我们还会谈一谈高度表
在Phone 6上引入的一个传感器

00:01:18.645 --> 00:01:21.982 align:middle
然后加布里埃尔就会通过一个
以一个非常有趣的方式

00:01:22.049 --> 00:01:25.185 align:middle
使用了Core Motion的
应用程序来给我们做一个演示

00:01:25.519 --> 00:01:26.954 align:middle
我之前已经看过了 非常棒

00:01:27.821 --> 00:01:29.289 align:middle
让我们开始吧

00:01:29.656 --> 00:01:31.592 align:middle
这并不是一个介绍性的会议

00:01:32.025 --> 00:01:35.295 align:middle
不过我们会涵盖非常多的
Core Motion概念

00:01:35.362 --> 00:01:36.363 align:middle
你也可以跟得上

00:01:36.430 --> 00:01:39.800 align:middle
即使你不是十分熟悉Motion

00:01:40.167 --> 00:01:44.905 align:middle
不过对于那些来到会场的人来说
我们在会议结束后会立即有一个实验室

00:01:45.239 --> 00:01:47.140 align:middle
请带着你的问题来实验室

00:01:47.207 --> 00:01:48.976 align:middle
我们有工程师以及科学家在场

00:01:49.743 --> 00:01:52.045 align:middle
但是如果你没有问题 那就要恭喜你了

00:01:52.713 --> 00:01:54.781 align:middle
不过还是要请你过来

00:01:54.848 --> 00:02:00.053 align:middle
告诉我们在你的apps中是怎样使用
Core Motion 乐意聆听

00:01:54.848 --> 00:02:00.053 align:middle
告诉我们在你的apps中是怎样使用
Core Motion 乐意聆听

00:02:00.487 --> 00:02:04.291 align:middle
在Apple developer
上确实也有一些之前的会议

00:02:04.358 --> 00:02:08.061 align:middle
在那些会议中深入探讨了动作感应、

00:02:08.127 --> 00:02:09.763 align:middle
动作活动性以及计步器

00:02:09.830 --> 00:02:11.198 align:middle
所以请你去看看那些会议

00:02:11.265 --> 00:02:12.799 align:middle
让我们开始吧

00:02:13.700 --> 00:02:18.639 align:middle
一段时间以来
动作感应已经在iOS上取得很大进展

00:02:18.705 --> 00:02:24.711 align:middle
先来看个有关它的工作原理的简短概述

00:02:24.778 --> 00:02:27.614 align:middle
这是一个传统的动作感应的结构

00:02:27.681 --> 00:02:30.684 align:middle
你把一些传感器连接到主处理器

00:02:31.118 --> 00:02:32.619 align:middle
就可以很明显地看到它们的缺点

00:02:32.686 --> 00:02:34.922 align:middle
无论你在什么时候想要访问传感器数据

00:02:34.988 --> 00:02:37.291 align:middle
你都必须让主处理器处于活动状态

00:02:37.824 --> 00:02:39.893 align:middle
这会严重制约你可以编写的

00:02:39.960 --> 00:02:42.029 align:middle
应用程序的种类

00:02:42.763 --> 00:02:44.598 align:middle
所以我们认为 我们能够做得更好

00:02:44.932 --> 00:02:49.436 align:middle
从iPhone 5S开始
我们就引入了一颗协处理器

00:02:49.503 --> 00:02:51.605 align:middle
我们称之为M7

00:02:51.772 --> 00:02:54.641 align:middle
是一颗微型处理器 它唯一的工作就是

00:02:54.842 --> 00:02:56.577 align:middle
对动作数据进行处理

00:02:56.643 --> 00:02:59.980 align:middle
这颗处理器可以全天候运行

00:03:00.080 --> 00:03:02.382 align:middle
且只有在真正必须时才会唤醒主处理器

00:03:03.183 --> 00:03:06.286 align:middle
对于用户的电池寿命来说这是好事

00:03:06.820 --> 00:03:10.724 align:middle
我们在iPhone 6上又引入了
M8处理器以及一个新的

00:03:10.791 --> 00:03:13.727 align:middle
传感器即“高度表”

00:03:13.794 --> 00:03:17.731 align:middle
现在在iOS上
动作感应看起来就是这样的

00:03:18.732 --> 00:03:20.234 align:middle
那么它对你来说有什么用呢？

00:03:20.467 --> 00:03:22.269 align:middle
如果你让传感器

00:03:22.636 --> 00:03:28.108 align:middle
实时访问你获得的数据
实时访问原始传感器数据

00:03:28.175 --> 00:03:31.512 align:middle
以及在传感器上构建的功能特性

00:03:31.812 --> 00:03:35.048 align:middle
如能够给你提供设备的高度的设备动作

00:03:35.115 --> 00:03:37.784 align:middle
比如计步器再比如动作活动性

00:03:38.051 --> 00:03:42.523 align:middle
若是在有高度计平台上 还可访问原始

00:03:42.589 --> 00:03:47.628 align:middle
压力、高度变化以及阶梯步级这些数据

00:03:48.795 --> 00:03:51.365 align:middle
这就是来自传感器的实时数据

00:03:51.431 --> 00:03:53.600 align:middle
但是动作协处理器能让你做的

00:03:53.667 --> 00:03:55.402 align:middle
远远不止这些 没错

00:03:55.469 --> 00:03:56.770 align:middle
远远不止这些

00:03:56.837 --> 00:03:59.806 align:middle
你还可以每周七天、每天
二十四小时访问动作活动性

00:04:00.073 --> 00:04:02.309 align:middle
访问计步器 在有高度计的平台上

00:04:02.376 --> 00:04:06.213 align:middle
你还可以每周七天、每天
二十四小时访问阶梯步级

00:04:06.280 --> 00:04:11.318 align:middle
现在在iOS上 你能用动作感应
做的事情就是这些

00:04:12.920 --> 00:04:16.523 align:middle
那么在Apple Watch上
动作感应看起来是什么样呢？

00:04:17.057 --> 00:04:20.293 align:middle
Apple Watch上
面同样也有一颗协处理器

00:04:20.827 --> 00:04:22.062 align:middle
它上面还有一个加速计

00:04:22.729 --> 00:04:27.634 align:middle
这就意味着你同样可以
每周七天、每天二十四小时

00:04:28.302 --> 00:04:31.238 align:middle
访问动作活动性以及计步器
访问除了这两种数据之外

00:04:31.305 --> 00:04:32.940 align:middle
你获得的实时传感器数据

00:04:33.340 --> 00:04:35.776 align:middle
如果你在想 哎呀！
这个看起来这么眼熟

00:04:36.043 --> 00:04:37.744 align:middle
那么Apple Watch上的动作

00:04:37.811 --> 00:04:40.747 align:middle
你看起来也眼熟 你看的没错

00:04:41.448 --> 00:04:46.153 align:middle
iOS上的Core Motion
APIs在watchOS上也有了

00:04:47.187 --> 00:04:51.191 align:middle
不仅是动作Core Motion
API iOS和watchOS部分

00:04:51.258 --> 00:04:53.660 align:middle
Core Motion APIs
都表现得一样

00:04:53.727 --> 00:04:56.363 align:middle
我们就是在两个OSs上沿用了

00:04:56.430 --> 00:04:58.065 align:middle
这个特性

00:04:59.199 --> 00:05:02.703 align:middle
不过Watch基本上就是一个
完全不同的平台了

00:04:59.199 --> 00:05:02.703 align:middle
不过Watch基本上就是一个
完全不同的平台了

00:05:03.270 --> 00:05:05.506 align:middle
因此当为Watch构建应用程序时

00:05:05.572 --> 00:05:09.209 align:middle
我们需要知道
一些事情从头到尾给你们讲讲

00:05:09.877 --> 00:05:11.945 align:middle
我们先来讲一下动作活动性

00:05:12.446 --> 00:05:15.816 align:middle
动作活动性
可以给我们提供上下文信息

00:05:15.883 --> 00:05:17.417 align:middle
告诉我们用户正在做什么

00:05:17.484 --> 00:05:19.019 align:middle
可知用户是否正在走路

00:05:19.086 --> 00:05:21.255 align:middle
是否正在跑步
是否潜水 是否正在骑车等

00:05:21.421 --> 00:05:25.259 align:middle
你能够获得的等级非常依赖于平台

00:05:25.325 --> 00:05:26.894 align:middle
非常依赖于它的使用方式

00:05:27.361 --> 00:05:31.632 align:middle
这里简单对你能够在watchOS上
得到的状态进行一个总结

00:05:32.032 --> 00:05:33.667 align:middle
你可以注意到 你可以访问

00:05:33.734 --> 00:05:36.803 align:middle
走路、跑步、骑车以及静止状态

00:05:37.471 --> 00:05:40.507 align:middle
这就是Apple Watch
上的动作活动性

00:05:42.376 --> 00:05:46.914 align:middle
开发者早就想要访问传感器本身

00:05:47.414 --> 00:05:49.950 align:middle
提供通过这个熟悉的
CMAccelerometer

00:05:50.017 --> 00:05:52.753 align:middle
API来访问加速计

00:05:53.887 --> 00:05:55.856 align:middle
那些东西都在加速计上

00:05:56.190 --> 00:05:58.458 align:middle
不过因为它是一个不同的平台

00:05:58.525 --> 00:06:00.627 align:middle
我们还是需要记住一些

00:05:58.525 --> 00:06:00.627 align:middle
我们还是需要记住一些

00:06:00.694 --> 00:06:02.229 align:middle
应该考虑的事

00:06:02.629 --> 00:06:06.166 align:middle
第一点你的app获得的处理时间

00:06:06.233 --> 00:06:07.668 align:middle
可能是有限的

00:06:08.268 --> 00:06:10.904 align:middle
Watch上并没有真正后台处理方式

00:06:10.971 --> 00:06:13.106 align:middle
因此当你的app显示在屏幕上时

00:06:13.173 --> 00:06:14.741 align:middle
你的app就在高速运行了

00:06:16.410 --> 00:06:19.313 align:middle
屏幕可能会因为多种原因关闭

00:06:19.379 --> 00:06:20.414 align:middle
屏幕可能会超时

00:06:21.014 --> 00:06:23.183 align:middle
不过Apple Watch
的屏幕是设计成了

00:06:23.250 --> 00:06:25.419 align:middle
只有当你在看它的时候屏幕才会开启

00:06:25.485 --> 00:06:28.021 align:middle
因此如果你不想看屏幕了

00:06:28.188 --> 00:06:30.757 align:middle
那么屏幕关闭、
屏幕关闭后你的app得不到

00:06:30.824 --> 00:06:34.127 align:middle
处理时间的可能性就非常大

00:06:34.294 --> 00:06:36.463 align:middle
考虑到这些情况

00:06:36.530 --> 00:06:38.732 align:middle
我想要谈一些

00:06:38.799 --> 00:06:40.133 align:middle
最佳实践

00:06:40.334 --> 00:06:45.472 align:middle
首先要把你的app设计成
只有当app在屏幕上显示时

00:06:45.539 --> 00:06:46.807 align:middle
你的app才会期望数据

00:06:47.074 --> 00:06:48.809 align:middle
我知道说起来容易做起来难

00:06:48.876 --> 00:06:50.377 align:middle
不过还是要记住这一点

00:06:51.512 --> 00:06:55.549 align:middle
其次当你访问一个流的时候
访问一个传感器数据流时

00:06:55.983 --> 00:07:00.053 align:middle
你需要确保当你的任务被挂起时

00:06:55.983 --> 00:07:00.053 align:middle
你需要确保当你的任务被挂起时

00:07:00.487 --> 00:07:04.024 align:middle
也可以以一种优雅的方式处理你的任务

00:07:04.091 --> 00:07:06.627 align:middle
幸运的是
可以通过NSProcessInfo

00:07:06.693 --> 00:07:08.262 align:middle
来实现这一点

00:07:08.762 --> 00:07:11.431 align:middle
如果你使用这个API
performExpiring

00:07:11.532 --> 00:07:14.835 align:middle
ActivityWithReason
你就可以在这个API中

00:07:14.902 --> 00:07:16.970 align:middle
把你的传感器数据当成一个块来处理

00:07:17.437 --> 00:07:20.674 align:middle
它就会通知你的块通知你你的任务

00:07:20.741 --> 00:07:23.477 align:middle
就要被挂起了
这样你就可以采取适当行动

00:07:24.344 --> 00:07:28.182 align:middle
那是CMAccelerometer
API

00:07:29.049 --> 00:07:32.052 align:middle
不过你们中有人想要的不仅仅是这些

00:07:32.119 --> 00:07:35.055 align:middle
事实上你想要长期访问

00:07:35.122 --> 00:07:36.990 align:middle
传感器数据

00:07:37.457 --> 00:07:39.092 align:middle
今天我很高兴地告诉大家

00:07:39.826 --> 00:07:41.695 align:middle
有史以来第一次 我们开始提供访问

00:07:41.762 --> 00:07:45.999 align:middle
历史传感器数据 历史加速计数据

00:07:47.100 --> 00:07:49.436 align:middle
那么你现在可以拿它做什么？

00:07:49.770 --> 00:07:53.807 align:middle
它允许你访问很长一段时间内的数据

00:07:54.074 --> 00:07:55.242 align:middle
相当长一段时间

00:07:55.976 --> 00:07:57.845 align:middle
你也可以访问这个数据

00:07:58.045 --> 00:07:59.880 align:middle
即使你的app不是处于运行状态

00:08:01.348 --> 00:08:06.653 align:middle
这样的话 你就可以在这个长长的

00:08:06.720 --> 00:08:09.289 align:middle
传感器数据流上运行你自己的定制算法

00:08:09.723 --> 00:08:11.124 align:middle
这很酷 我们也期待你们用它

00:08:11.191 --> 00:08:12.593 align:middle
来开发出很酷的apps

00:08:13.093 --> 00:08:14.428 align:middle
那么你应该怎么用它呢？

00:08:14.795 --> 00:08:17.764 align:middle
我们有一个新的API叫做
CMSensorRecorder

00:08:18.332 --> 00:08:22.803 align:middle
这个API允许
初始化历史传感器数据录制

00:08:23.070 --> 00:08:29.109 align:middle
记住这点此API和其他的APIs
一个很重要的不同之处

00:08:29.176 --> 00:08:31.845 align:middle
比如计步器以及动作活动性

00:08:32.246 --> 00:08:35.015 align:middle
其他的APIs
并不需要你初始化任何录制

00:08:35.749 --> 00:08:38.919 align:middle
对SensorRecorder说
你确实需要对它进行初始化

00:08:39.419 --> 00:08:42.523 align:middle
数据录制的频率是五十赫兹

00:08:42.823 --> 00:08:45.626 align:middle
你最多可以录制三天的数据

00:08:46.994 --> 00:08:50.931 align:middle
这就是SensorRecorder
的使用方式

00:08:51.565 --> 00:08:54.601 align:middle
提到执行 我们应该这样做

00:08:54.735 --> 00:08:58.272 align:middle
你首先要通过初始化
recordAccelerometerDataFor

00:08:58.338 --> 00:09:01.742 align:middle
录制数据 然后要提供一个

00:08:58.338 --> 00:09:01.742 align:middle
录制数据 然后要提供一个

00:09:02.075 --> 00:09:03.510 align:middle
持续时间

00:09:04.211 --> 00:09:07.314 align:middle
一旦你完成这一步
设备可能就会进入睡眠状态

00:09:07.681 --> 00:09:09.283 align:middle
你的app可能会被挂起

00:09:09.483 --> 00:09:10.651 align:middle
没关系

00:09:10.717 --> 00:09:14.388 align:middle
之后 用户可能会回来
并且启动你的app

00:09:15.389 --> 00:09:18.792 align:middle
当用户启动你的app时
你就可以决定是否查询传感器数据

00:09:19.826 --> 00:09:23.597 align:middle
通过查询
accelerometerDataFrom

00:09:23.664 --> 00:09:25.799 align:middle
当然你还需要指定一个时间段

00:09:27.801 --> 00:09:30.137 align:middle
然后指定的时间段的加速计的数据

00:09:30.504 --> 00:09:32.739 align:middle
就会返回回来

00:09:32.806 --> 00:09:35.242 align:middle
很明显 这个时间段可以是

00:09:35.742 --> 00:09:37.744 align:middle
你录制数据的时间的一个子集

00:09:38.645 --> 00:09:42.249 align:middle
好的 数据会被作为一个

00:09:42.316 --> 00:09:45.185 align:middle
CMAccelerometerData
对象序列返回回来

00:09:46.987 --> 00:09:49.556 align:middle
回想一下 我们提到过的

00:09:49.623 --> 00:09:52.159 align:middle
关于优雅地处理任务挂起的内容

00:09:52.226 --> 00:09:54.294 align:middle
你在这里也会遇到同样的问题

00:09:54.828 --> 00:09:57.798 align:middle
因此 当你处理这个很大的

00:09:57.865 --> 00:09:59.399 align:middle
历史数据流的时候

00:09:59.867 --> 00:10:03.403 align:middle
你就需要访问我们的老朋友
NSProcessInfo

00:09:59.867 --> 00:10:03.403 align:middle
你就需要访问我们的老朋友
NSProcessInfo

00:10:04.271 --> 00:10:09.142 align:middle
当你的任务就要被挂起时它会通知给你

00:10:11.144 --> 00:10:12.946 align:middle
如果你看一下加速计数据对象

00:10:13.013 --> 00:10:16.683 align:middle
它里面不仅包括了你熟悉的加速度部分

00:10:17.117 --> 00:10:20.988 align:middle
而且还包括了一个startDate
你就可以把这个它当做一个定位器

00:10:21.455 --> 00:10:24.525 align:middle
你可以从这个点
开始确保下次你的app启动时

00:10:25.225 --> 00:10:26.760 align:middle
向前进行查询

00:10:27.528 --> 00:10:30.264 align:middle
这就是SensorRecorder
的工作原理

00:10:30.998 --> 00:10:34.701 align:middle
这个很棒 不过正如你看到的
那里有一项需要考虑的事

00:10:35.169 --> 00:10:36.870 align:middle
不是 是两项功率与性能

00:10:37.404 --> 00:10:39.873 align:middle
SensorRecorder
是一个强大的API

00:10:39.940 --> 00:10:42.743 align:middle
但是能力越大 危险性也就越大

00:10:42.809 --> 00:10:46.980 align:middle
这里的危险性就在于
你可能没有足够的时间

00:10:47.047 --> 00:10:49.283 align:middle
来处理传感器数据的大量的字符串

00:10:49.850 --> 00:10:52.486 align:middle
因此我再介绍几个最佳做法

00:10:53.020 --> 00:10:57.224 align:middle
首先是 仅仅录制 查询你的app

00:10:57.758 --> 00:11:00.928 align:middle
需要用到的最短持续时间内的数据

00:10:57.758 --> 00:11:00.928 align:middle
需要用到的最短持续时间内的数据

00:11:00.994 --> 00:11:04.097 align:middle
如果app是一款锻炼身体
你大概就不需要十二个小时的数据

00:11:04.164 --> 00:11:06.934 align:middle
你大概需要几个小时的数据就够了

00:11:07.000 --> 00:11:09.570 align:middle
你查询的数据量越少

00:11:09.636 --> 00:11:11.605 align:middle
你的app就越能容易地获取、处理

00:11:12.940 --> 00:11:15.976 align:middle
此外你也应该知道
传感器数据传输率的要求

00:11:16.410 --> 00:11:18.579 align:middle
数据是以五十赫兹的频率提供给你的

00:11:19.012 --> 00:11:21.882 align:middle
但是除非你想要从那些数据中
抽取出特性、需要更高的

00:11:22.082 --> 00:11:25.919 align:middle
传感器数据传输率
那么你最好丢弃一些数据

00:11:26.253 --> 00:11:28.222 align:middle
处理较少的数据

00:11:28.288 --> 00:11:30.824 align:middle
只要采用几项最佳做法
你应该就没问题了

00:11:32.659 --> 00:11:35.896 align:middle
Apple Watch上Core
Motion的情况就是这些

00:11:36.396 --> 00:11:39.600 align:middle
你已经看过了
我们有很多看起来眼熟的APIs

00:11:39.900 --> 00:11:43.237 align:middle
我们也可以访问历史传感器数据

00:11:43.770 --> 00:11:45.105 align:middle
这个很棒 你们应该可以用它

00:11:45.172 --> 00:11:46.940 align:middle
来开发出很酷的应用程序

00:11:47.407 --> 00:11:49.476 align:middle
提到编写Watch应用程序

00:11:49.543 --> 00:11:51.612 align:middle
我们今天上午确实举办了一个会议

00:11:51.979 --> 00:11:53.313 align:middle
现在就可以看到会议视频了

00:11:55.182 --> 00:11:58.218 align:middle
会议剩余的时间里
我想重点关注iOS 我先来讲讲

00:11:58.285 --> 00:11:59.953 align:middle
计步器上有什么新情况

00:12:01.221 --> 00:12:04.191 align:middle
这就是你属性的计步器

00:12:04.424 --> 00:12:05.859 align:middle
步数、距离

00:12:06.627 --> 00:12:07.594 align:middle
我们来快速回顾下

00:12:08.095 --> 00:12:10.063 align:middle
计步器的设计理念

00:12:10.130 --> 00:12:13.600 align:middle
是持续给你
提供身体各个部位的行为表现

00:12:13.667 --> 00:12:16.170 align:middle
无论是放在你的手中
还是放到你的口袋里

00:12:16.270 --> 00:12:18.672 align:middle
计步器的性能应该是一致的

00:12:19.139 --> 00:12:22.509 align:middle
即使速度不同
计步器的性能也应该是一致的

00:12:23.443 --> 00:12:25.946 align:middle
计步器的一个很棒的特性是

00:12:26.013 --> 00:12:27.915 align:middle
它会适应用户

00:12:28.182 --> 00:12:31.485 align:middle
因此使用计步器的用户人数越多
那么通过自身的校正

00:12:31.552 --> 00:12:33.654 align:middle
它就能更好地理解用户

00:12:35.155 --> 00:12:38.559 align:middle
在iOS 9上我们对计步器
做了一个很大的改进

00:12:38.625 --> 00:12:42.462 align:middle
让它尽可能地合并了GPS

00:12:43.730 --> 00:12:44.932 align:middle
我们为什么要这么做？

00:12:45.465 --> 00:12:47.734 align:middle
原因在于你的app可能

00:12:47.835 --> 00:12:50.070 align:middle
已经订阅了用户的位置

00:12:50.137 --> 00:12:52.506 align:middle
你可能想要在用户进行跑步的时候

00:12:52.573 --> 00:12:53.473 align:middle
绘制用户的运动轨迹

00:12:54.208 --> 00:12:56.877 align:middle
当你这么做的时候计步器检测到

00:12:56.944 --> 00:12:58.512 align:middle
GPS数据可以用了

00:12:58.879 --> 00:13:00.981 align:middle
通过使用GPS数据
就可以让轨迹绘制的更精确

00:12:58.879 --> 00:13:00.981 align:middle
通过使用GPS数据
就可以让轨迹绘制的更精确

00:13:02.850 --> 00:13:05.285 align:middle
为什么这一点如此关键呢？

00:13:05.586 --> 00:13:09.656 align:middle
看看这个
这是我的一位同事在旧金山跑的一次步

00:13:09.990 --> 00:13:11.491 align:middle
旧金山是一座“城市峡谷”

00:13:11.558 --> 00:13:15.295 align:middle
有很高的建筑物对任何GPS来说

00:13:15.362 --> 00:13:16.730 align:middle
环境都富有挑战性

00:13:17.397 --> 00:13:18.932 align:middle
如果你看看这里的这一段

00:13:19.600 --> 00:13:22.369 align:middle
GPS在这里看起来非常靠谱

00:13:22.603 --> 00:13:27.274 align:middle
如果你依赖于GPS
我们就可以对距离进行很好的估测

00:13:28.041 --> 00:13:28.909 align:middle
很好

00:13:29.843 --> 00:13:31.478 align:middle
但是如果你再看这里不同的段

00:13:31.545 --> 00:13:34.915 align:middle
你就会发现在用户的轨迹中用户在闲逛

00:13:35.382 --> 00:13:38.118 align:middle
一路上有好几个酒吧 所以...

00:13:38.185 --> 00:13:42.289 align:middle
但是这可能
并不是这位用户真实的跑步轨迹

00:13:42.890 --> 00:13:44.324 align:middle
所以说

00:13:44.725 --> 00:13:47.561 align:middle
计步器非常聪明 它知道在这里

00:13:47.995 --> 00:13:50.531 align:middle
它就不应该继续依赖GPS了

00:13:50.931 --> 00:13:53.400 align:middle
它应该继续借助于自身的基于步幅的

00:13:53.467 --> 00:13:54.468 align:middle
距离估计

00:13:54.768 --> 00:13:59.173 align:middle
如果你使用了计步器
那么你得到的最终结果

00:13:59.306 --> 00:14:02.910 align:middle
就非常一致
这也就是为什么你应该使用

00:13:59.306 --> 00:14:02.910 align:middle
就非常一致
这也就是为什么你应该使用

00:14:03.911 --> 00:14:05.479 align:middle
计步器的步数和距离的原因

00:14:08.949 --> 00:14:13.420 align:middle
今年我们对计步器的API
做了一个很大的改进

00:14:14.321 --> 00:14:15.255 align:middle
在我们开始之前

00:14:15.322 --> 00:14:17.991 align:middle
我们先来回顾一个
你们已经知道的特性 这是层数计数

00:14:18.559 --> 00:14:21.128 align:middle
层数计数有
floorsAscended

00:14:21.195 --> 00:14:23.063 align:middle
还有floorsDescended

00:14:23.664 --> 00:14:25.599 align:middle
因为这是计步器的一部分

00:14:25.999 --> 00:14:28.335 align:middle
这就是一个徒步功能 你必须实际迈步

00:14:28.402 --> 00:14:29.736 align:middle
才能把它用起来

00:14:30.237 --> 00:14:33.674 align:middle
也就是说 你需要在这里

00:14:33.907 --> 00:14:36.376 align:middle
赢取授予的层数

00:14:37.744 --> 00:14:40.314 align:middle
让我们更深入地看看
它到底是如何工作的

00:14:41.481 --> 00:14:42.749 align:middle
它有几项要求

00:14:43.383 --> 00:14:46.353 align:middle
首先是 最低提升速率要求

00:14:47.221 --> 00:14:49.590 align:middle
还有一个步数要求

00:14:50.090 --> 00:14:54.394 align:middle
它们对我们意味着
假如说 如果你进行了一次远足

00:14:54.461 --> 00:14:55.562 align:middle
并且你走的很慢

00:14:55.629 --> 00:14:58.465 align:middle
那么最终你积累的高度就会很多

00:14:59.733 --> 00:15:03.537 align:middle
但是你很有可能达不到提升速率要求

00:14:59.733 --> 00:15:03.537 align:middle
但是你很有可能达不到提升速率要求

00:15:03.604 --> 00:15:04.938 align:middle
我们就不会授予你层数

00:15:05.873 --> 00:15:08.942 align:middle
但是如果你是在旧金山散步
有一些非常陡峭的丘陵

00:15:09.009 --> 00:15:12.746 align:middle
那么你就有可能达到一些层数

00:15:14.147 --> 00:15:16.350 align:middle
因为步速要求 如果你使用了电梯

00:15:17.251 --> 00:15:20.354 align:middle
或者自动扶梯

00:15:20.821 --> 00:15:22.689 align:middle
你就不大可能会被授予层数

00:15:22.789 --> 00:15:25.626 align:middle
这就是iOS上层数计数的工作原理

00:15:28.095 --> 00:15:29.396 align:middle
现在轮到新的API了

00:15:30.264 --> 00:15:32.299 align:middle
这是“步幅”

00:15:33.133 --> 00:15:36.370 align:middle
长期以来
开发者就要求我们提供“步幅”

00:15:36.803 --> 00:15:38.172 align:middle
我们很高兴现在能提供了

00:15:39.039 --> 00:15:42.676 align:middle
当我们提起“步幅”
我们指的是currentPace

00:15:43.210 --> 00:15:45.279 align:middle
这实际上是瞬时步幅

00:15:45.345 --> 00:15:48.148 align:middle
而不是在跑步一开始就估算出来的步幅

00:15:48.882 --> 00:15:52.619 align:middle
“步幅”是以时间单位内
通过的距离来表示的

00:15:53.387 --> 00:15:57.724 align:middle
如果你想问为什么这样表示
而不是时间单位内的速度

00:15:57.824 --> 00:15:59.660 align:middle
你知道 因为对于跑步者来说

00:16:00.194 --> 00:16:03.330 align:middle
步幅通常
可以被类推为走完一个已知的距离

00:16:03.397 --> 00:16:04.932 align:middle
需要的实际时间

00:16:06.200 --> 00:16:08.435 align:middle
在网站上关注了
Apple Watch的更新情况

00:16:08.502 --> 00:16:11.038 align:middle
那么这个步幅
你看起来就可能很眼熟

00:16:12.072 --> 00:16:13.807 align:middle
这就让我有点 妒忌了

00:16:17.211 --> 00:16:18.645 align:middle
计步器既有实时数据

00:16:18.712 --> 00:16:21.648 align:middle
又有历史数据
但是“步幅”是只有你在进行

00:16:21.715 --> 00:16:23.283 align:middle
实时查询时才有的

00:16:23.951 --> 00:16:25.419 align:middle
别忘了这一点

00:16:25.886 --> 00:16:27.821 align:middle
我们为什么要提供“步幅”？

00:16:27.888 --> 00:16:31.425 align:middle
毕竟我们已经在计步器上
提供了距离和一个时间概念

00:16:31.491 --> 00:16:35.596 align:middle
因此我们可以很容易地计算出步幅

00:16:36.363 --> 00:16:38.999 align:middle
这样得出的步幅健壮性更高

00:16:39.800 --> 00:16:42.069 align:middle
假如说你想要有所区别

00:16:42.135 --> 00:16:45.172 align:middle
想从那些距离组块中估算出步幅

00:16:45.806 --> 00:16:49.977 align:middle
也会向步幅中引入一个可接受的抖动量

00:16:50.777 --> 00:16:54.481 align:middle
计步器就可以对此进行处理

00:16:54.548 --> 00:16:57.117 align:middle
确保步幅的估算是平滑的

00:16:59.453 --> 00:17:02.289 align:middle
此外你还可以通过回顾历史组块

00:16:59.453 --> 00:17:02.289 align:middle
此外你还可以通过回顾历史组块

00:17:02.356 --> 00:17:05.726 align:middle
然后算出步幅的平均数这一方法

00:17:05.791 --> 00:17:07.560 align:middle
尝试获得平滑的步幅

00:17:07.627 --> 00:17:11.665 align:middle
不过你这样做的代价就是
如果用户步幅发生了改变

00:17:11.732 --> 00:17:14.701 align:middle
你就无法很快做出响应

00:17:15.169 --> 00:17:18.805 align:middle
通过CMPedometer得出步幅
能够对变更很快做出响应

00:17:18.872 --> 00:17:20.574 align:middle
响应性也很高

00:17:21.508 --> 00:17:24.411 align:middle
因此平滑性和响应性就
你应该通过CMPedometer

00:17:25.012 --> 00:17:26.413 align:middle
使用步幅的理由所在

00:17:27.481 --> 00:17:28.849 align:middle
这是步幅

00:17:28.916 --> 00:17:33.754 align:middle
步幅有个“近亲”叫做“步调”

00:17:34.488 --> 00:17:37.124 align:middle
我们现在在计步器上有了步调

00:17:37.858 --> 00:17:39.426 align:middle
那么什么是“步调”？

00:17:39.493 --> 00:17:43.130 align:middle
步调指的是你的步行速率
或者换其他话来说

00:17:43.197 --> 00:17:46.300 align:middle
就是你的脚接触地面的频率

00:17:46.800 --> 00:17:49.636 align:middle
对于跑步者来说步调非常重要

00:17:49.736 --> 00:17:51.538 align:middle
现在你就能直接通过计步器

00:17:51.605 --> 00:17:53.974 align:middle
在你的apps内提供步调了

00:17:56.076 --> 00:17:56.944 align:middle
是的！

00:17:57.010 --> 00:18:01.315 align:middle
我们对计步器做的变更就这些

00:17:57.010 --> 00:18:01.315 align:middle
我们对计步器做的变更就这些

00:18:01.381 --> 00:18:05.586 align:middle
这里快速看看各个平台内的特性

00:18:05.652 --> 00:18:08.422 align:middle
注意看
Apple Watch上也可以用

00:18:08.488 --> 00:18:09.590 align:middle
计步器了

00:18:10.991 --> 00:18:13.093 align:middle
我们接着来谈谈压力感应

00:18:13.861 --> 00:18:17.531 align:middle
通过高度表传感器可以获得压力数据

00:18:18.198 --> 00:18:21.602 align:middle
这是CMAltimeter API
的一个组成部分

00:18:21.869 --> 00:18:23.437 align:middle
它给你提供了两样东西

00:18:23.504 --> 00:18:25.873 align:middle
第一样是原始压力数据
这就是传感器自身获得的压力

00:18:25.939 --> 00:18:29.076 align:middle
然后进行过滤后的数据

00:18:29.309 --> 00:18:31.778 align:middle
第二样就是相对高度

00:18:32.246 --> 00:18:34.047 align:middle
我们来深入谈谈高度

00:18:35.315 --> 00:18:37.351 align:middle
当我们说到“相对”我们指的是相对

00:18:37.417 --> 00:18:39.253 align:middle
提供的第一个样本而言的

00:18:40.254 --> 00:18:42.923 align:middle
这就意味着 你从高度表上获得的

00:18:43.156 --> 00:18:47.528 align:middle
第一个样本的相对高度为零

00:18:47.995 --> 00:18:51.231 align:middle
后续的样本都会以此为基线

00:18:53.567 --> 00:18:56.069 align:middle
那么要使用高度表
我们需要知道些什么呢？

00:18:56.603 --> 00:19:02.910 align:middle
对于层级的变更来说
高度表再合适不过了

00:18:56.603 --> 00:19:02.910 align:middle
对于层级的变更来说
高度表再合适不过了

00:19:02.976 --> 00:19:05.245 align:middle
而对于人体层级的变更来说
高度表就差强人意了

00:19:05.679 --> 00:19:07.648 align:middle
因此也许你不应该使用高度表来感知

00:19:07.714 --> 00:19:09.449 align:middle
用户是否抬起了他们的胳膊

00:19:09.516 --> 00:19:11.185 align:middle
差错会让你失望的

00:19:12.286 --> 00:19:14.555 align:middle
对于传感器来说
这些情况都非常具有挑战性

00:19:14.621 --> 00:19:15.989 align:middle
这一点不要忘了

00:19:16.990 --> 00:19:18.792 align:middle
其中一项是环境

00:19:19.526 --> 00:19:22.529 align:middle
即使位置不变
环境也可能随着时间推移发生改变

00:19:22.596 --> 00:19:25.232 align:middle
这样就会让你误以为高度发生了变化

00:19:25.899 --> 00:19:28.702 align:middle
举例来说 旧金山最近的冷锋

00:19:28.769 --> 00:19:31.038 align:middle
就可以让压力发生很大的变化

00:19:31.138 --> 00:19:33.073 align:middle
足以让我们以为
你的高度发生了变化

00:19:33.140 --> 00:19:35.142 align:middle
比如说变化了十五米

00:19:35.642 --> 00:19:37.578 align:middle
建议你不要长时间使用

00:19:37.644 --> 00:19:39.680 align:middle
传感器

00:19:41.415 --> 00:19:44.818 align:middle
你的设备所处的外套也可以影响到压力

00:19:44.885 --> 00:19:48.822 align:middle
如果你给你的
手机使用了刚性密封防水外套

00:19:49.189 --> 00:19:50.924 align:middle
那么你就指望不上压力传感器了

00:19:53.060 --> 00:19:56.196 align:middle
说到API的使用
对你来说它应该很眼熟

00:19:56.263 --> 00:19:59.433 align:middle
API可以给你提供压力和高度

00:20:00.000 --> 00:20:03.337 align:middle
你访问这个传感器的速度能有多快呢？

00:20:04.071 --> 00:20:07.574 align:middle
当你第一次进行请求时
第一个样本需要大约

00:20:08.242 --> 00:20:09.910 align:middle
二点六秒可以得出来

00:20:10.177 --> 00:20:13.914 align:middle
之后的每次样本以步调的形式出现
用时一点三秒

00:20:14.214 --> 00:20:16.984 align:middle
你从高度表上获取数据的速度就这么快

00:20:18.752 --> 00:20:25.425 align:middle
总结一下
Core Motion已经出现在了

00:20:25.492 --> 00:20:27.194 align:middle
多个平台上

00:20:27.261 --> 00:20:29.329 align:middle
iPads上有了
iPhones有了

00:20:29.630 --> 00:20:31.265 align:middle
Apple Watch上也有了

00:20:31.331 --> 00:20:33.200 align:middle
在Apple Watch
上提供不只那些

00:20:33.267 --> 00:20:37.571 align:middle
看起来眼熟的APIs
我们还提供历史传感器数据

00:20:38.205 --> 00:20:41.275 align:middle
计步器自身也有了一大堆很酷的更新

00:20:41.341 --> 00:20:46.480 align:middle
它的精确度更高了
并且有了两个新的APIs

00:20:46.547 --> 00:20:48.215 align:middle
即步幅和步调

00:20:48.282 --> 00:20:51.385 align:middle
计步器现在是个多面手了
对于你的健身apps来说

00:20:51.451 --> 00:20:53.120 align:middle
这是个好消息

00:20:54.221 --> 00:20:56.657 align:middle
从传统意义上说
Core Motion已经被用于

00:20:57.024 --> 00:20:59.359 align:middle
游戏、手势以及健身

00:20:59.426 --> 00:21:02.296 align:middle
对于Core Motion来说
可用的应用程序有很多

00:20:59.426 --> 00:21:02.296 align:middle
对于Core Motion来说
可用的应用程序有很多

00:21:02.696 --> 00:21:08.068 align:middle
Core Motion也可以被用来
曾强其它的apps的智能

00:21:08.402 --> 00:21:12.105 align:middle
我要把加布里埃尔请上来
请他给你们解释下这个概念

00:21:21.381 --> 00:21:22.449 align:middle
大家好

00:21:23.350 --> 00:21:25.085 align:middle
能到这里我感到十分激动

00:21:25.819 --> 00:21:29.089 align:middle
作为一名开发者
我之前从未参加过苹果全球开发者大会

00:21:29.890 --> 00:21:32.726 align:middle
但是无论我在哪里工作
我总是在六月份的第一周内

00:21:32.993 --> 00:21:37.364 align:middle
在家里用电脑观看全部会议视频

00:21:38.432 --> 00:21:39.933 align:middle
我了解到了很多信息

00:21:40.000 --> 00:21:42.336 align:middle
但是其中让我头疼的是

00:21:42.503 --> 00:21:43.871 align:middle
信息量太大了

00:21:44.805 --> 00:21:48.609 align:middle
即使在一个会议视频中
要吸收的东西也太多了

00:21:48.876 --> 00:21:51.311 align:middle
当你看完后
你可能把过去的一小时内

00:21:51.378 --> 00:21:53.180 align:middle
学到的东西全都忘光

00:21:54.481 --> 00:21:57.317 align:middle
我在这里要做的
就是把阿尼尔刚刚向你们

00:21:57.384 --> 00:21:59.019 align:middle
提到的事情拿出来

00:21:59.553 --> 00:22:01.788 align:middle
看看你们到底想在你们的
应用程序中把它们用起来

00:21:59.553 --> 00:22:01.788 align:middle
看看你们到底想在你们的
应用程序中把它们用起来

00:22:01.855 --> 00:22:04.591 align:middle
希望能让你记住这些东西

00:22:06.293 --> 00:22:10.464 align:middle
Core Motion非常棒
因为它不仅能够用于

00:22:10.531 --> 00:22:12.866 align:middle
健身语境或者游戏语境

00:22:13.433 --> 00:22:16.603 align:middle
今天我要向你们展示的
是不管你的app属于

00:22:16.970 --> 00:22:18.906 align:middle
什么类别 你都可以把它用起来

00:22:20.507 --> 00:22:22.409 align:middle
Core Motion
能怎样为你效劳呢？

00:22:24.077 --> 00:22:27.748 align:middle
Core Motion
允许你检测用户正在做的事情

00:22:29.049 --> 00:22:31.385 align:middle
你可以知道用户是否正坐在他们的车里

00:22:31.652 --> 00:22:34.321 align:middle
是否在跑步是否在骑自行车

00:22:35.022 --> 00:22:37.724 align:middle
就像我们之前看到的
你可以知道他们的步幅变动

00:22:37.791 --> 00:22:39.159 align:middle
我们可以帮你让它更加平滑

00:22:40.127 --> 00:22:42.196 align:middle
借助这些变动

00:22:42.529 --> 00:22:46.400 align:middle
我们无需给用户发送提示
请他们告诉我们

00:22:46.466 --> 00:22:48.202 align:middle
就可以知道他们所处的语境

00:22:48.569 --> 00:22:52.706 align:middle
这样用户的体验就更加神奇了
我们的apps也就更智能了

00:22:54.074 --> 00:22:56.510 align:middle
其次 我们还能让用户参与进来

00:22:57.311 --> 00:23:01.081 align:middle
因为每隔几秒钟就有更新
我们就可以知道用户的步幅

00:22:57.311 --> 00:23:01.081 align:middle
因为每隔几秒钟就有更新
我们就可以知道用户的步幅

00:23:01.148 --> 00:23:02.449 align:middle
发生了怎样的变动

00:23:02.516 --> 00:23:04.718 align:middle
我们可以知道
他们高度的发生了怎样的变动

00:23:04.785 --> 00:23:08.589 align:middle
相应地我们可以快速更新
我们的app UI

00:23:10.424 --> 00:23:12.359 align:middle
最后我们还可以“反射返回”

00:23:13.460 --> 00:23:15.362 align:middle
我知道“反射返回”听起来很蹩脚

00:23:15.829 --> 00:23:18.432 align:middle
但是对于Core Motion来说
很棒的一点就在于

00:23:18.498 --> 00:23:21.034 align:middle
通过始终保持它的运行
我们可以让你的app看起来好像

00:23:21.101 --> 00:23:24.238 align:middle
一天二十四小时、
一周七天都在努力工作

00:23:24.304 --> 00:23:26.206 align:middle
实际上工作的是协处理器

00:23:27.541 --> 00:23:29.710 align:middle
我们可以看到过去一周内
你的活动性更新情况

00:23:29.776 --> 00:23:32.012 align:middle
你的计步器更新情况

00:23:32.246 --> 00:23:33.447 align:middle
这一点很赞

00:23:35.449 --> 00:23:38.752 align:middle
我记住了这三点
因此我决定来编写一款

00:23:38.819 --> 00:23:40.120 align:middle
音乐播放器

00:23:40.921 --> 00:23:43.857 align:middle
不是想与Apple
Music或者类似产品进行竞争

00:23:44.291 --> 00:23:47.661 align:middle
Core Motion怎样可以
让我的app的体验

00:23:47.728 --> 00:23:50.264 align:middle
更加迷人、更有魔力

00:23:52.399 --> 00:23:55.969 align:middle
很多音乐应用程序都有
这个播放列表的概念

00:23:56.270 --> 00:23:58.639 align:middle
我想听到不同的音乐当我在我的车里时

00:23:58.705 --> 00:24:02.242 align:middle
我想听到广播而如果我是在学习或者

00:23:58.705 --> 00:24:02.242 align:middle
我想听到广播而如果我是在学习或者

00:24:02.309 --> 00:24:04.344 align:middle
正在努力工作
可能就想要听一些古典音乐

00:24:04.411 --> 00:24:06.446 align:middle
锻炼身体时
也有不同的app播放列表

00:24:07.381 --> 00:24:10.083 align:middle
通过检测某个用户正在做什么

00:24:10.417 --> 00:24:13.987 align:middle
我的音乐应用程序就可以
相应地改变我的播放列表

00:24:14.121 --> 00:24:15.989 align:middle
而无需让用户进行选择

00:24:16.890 --> 00:24:20.694 align:middle
类似地我们知道了步幅的变化
我们就可以说

00:24:20.761 --> 00:24:24.198 align:middle
嘿！你正在进行慢跑
可能是因为你刚才跑到太快

00:24:24.264 --> 00:24:26.900 align:middle
并且爬了一座非常高的山
我们就可以给你放一首

00:24:26.967 --> 00:24:29.736 align:middle
让人兴奋的歌曲 让你有一种成就感

00:24:29.803 --> 00:24:32.239 align:middle
或者可以试着与你的步调相匹配

00:24:33.674 --> 00:24:35.342 align:middle
下面就到了“反射”部分

00:24:35.876 --> 00:24:37.077 align:middle
关于“反射”两点很棒

00:24:37.144 --> 00:24:39.246 align:middle
尤其是在我的音乐应用程序

00:24:39.313 --> 00:24:40.514 align:middle
这个语境下

00:24:41.882 --> 00:24:45.619 align:middle
第一件事我可以看看数据
了解用户当前正在做的事情

00:24:45.819 --> 00:24:47.554 align:middle
嘿 你已经有一段时间不跑了

00:24:47.888 --> 00:24:50.691 align:middle
可能你很快就要跑
也可能你想使用我们的

00:24:50.757 --> 00:24:52.626 align:middle
应用程序来跑步

00:24:52.826 --> 00:24:54.261 align:middle
并且听一下你的播放列表

00:24:55.128 --> 00:24:57.064 align:middle
一天结束时 我们想要刺激我们的用户

00:24:57.164 --> 00:24:58.332 align:middle
回到我们的app中来

00:24:59.867 --> 00:25:02.469 align:middle
我想用户可能想要知道他们昨天

00:24:59.867 --> 00:25:02.469 align:middle
我想用户可能想要知道他们昨天

00:25:03.637 --> 00:25:07.808 align:middle
在车里听的播放列表是什么
如果我们能实现的话 那就太棒了

00:25:08.242 --> 00:25:13.080 align:middle
通过查看活动性信息
然后把它与我的播放列表信息进行匹配

00:25:13.447 --> 00:25:15.115 align:middle
我就可以把那个信息提供给用户

00:25:16.617 --> 00:25:18.986 align:middle
记住了这三件事

00:25:19.419 --> 00:25:22.456 align:middle
我们来看看我的应用程序
实际是什么样子的

00:25:25.459 --> 00:25:27.761 align:middle
当用户打开app时
我们仅仅想把一个基本的

00:25:27.828 --> 00:25:29.563 align:middle
播放列表展示给他们

00:25:29.997 --> 00:25:32.966 align:middle
对我来说
我现在是站着不动 对吧？

00:25:33.333 --> 00:25:35.402 align:middle
我们来一些低强度的音乐

00:25:35.502 --> 00:25:36.470 align:middle
不要太剧烈

00:25:37.571 --> 00:25:39.573 align:middle
当我们检测到用户正在加速

00:25:40.073 --> 00:25:42.009 align:middle
可能是他们开始进行锻炼了

00:25:42.276 --> 00:25:44.011 align:middle
我们要对播放列表进行变更

00:25:44.378 --> 00:25:47.014 align:middle
给他们一些更加欢快的音乐

00:25:48.348 --> 00:25:50.651 align:middle
就是在这里
app开始与用户接洽起来了

00:25:50.717 --> 00:25:53.520 align:middle
我们看看发生了什么变动
也许是步调发生了变动

00:25:53.887 --> 00:25:57.891 align:middle
也许是高度发生了变动
我们就可以接洽并且跟随

00:25:57.958 --> 00:26:01.061 align:middle
这些变动 这样当用户加速时
我们就可以给他们

00:25:57.958 --> 00:26:01.061 align:middle
这些变动 这样当用户加速时
我们就可以给他们

00:26:01.195 --> 00:26:02.663 align:middle
一个强度更高的播放列表

00:26:04.932 --> 00:26:07.201 align:middle
然后我们就想要切换环境了

00:26:07.267 --> 00:26:10.003 align:middle
当用户开车时
我就想在他们早晨上班路上

00:26:10.070 --> 00:26:14.308 align:middle
把他们的podcast
或者他们经常听的任何节目

00:26:14.374 --> 00:26:15.576 align:middle
提供给他们

00:26:17.644 --> 00:26:21.081 align:middle
这是“检测”部分
以及“接洽”部分

00:26:21.582 --> 00:26:23.483 align:middle
接下来是“反射”部分

00:26:24.651 --> 00:26:27.855 align:middle
我想把这个信息分成几个有趣的部分

00:26:27.921 --> 00:26:30.524 align:middle
这样用户就可以向后滚动
看看他们的“历史”

00:26:30.824 --> 00:26:33.594 align:middle
我可能想把这个与用户在不同时刻听的

00:26:33.660 --> 00:26:36.063 align:middle
播放列表连接起来

00:26:38.298 --> 00:26:41.702 align:middle
既然我们已经知道了
app会是什么样子的

00:26:42.202 --> 00:26:44.872 align:middle
我们再来看看动作活动性的实际应用

00:26:45.272 --> 00:26:48.642 align:middle
看看要实现这些功能
我们需要什么样的APIs

00:26:51.445 --> 00:26:53.080 align:middle
首先我们有“检测”部分

00:26:53.146 --> 00:26:56.149 align:middle
这个部分是我们希望能够一直运行的

00:26:56.683 --> 00:26:59.753 align:middle
我们想知道用户是否正在开车

00:26:59.820 --> 00:27:02.823 align:middle
用户是否正在走路
用户走路的速度有多快

00:26:59.820 --> 00:27:02.823 align:middle
用户是否正在走路
用户走路的速度有多快

00:27:03.323 --> 00:27:04.825 align:middle
那么以此我们需要什么？

00:27:05.959 --> 00:27:08.295 align:middle
活动性更新情况以及计步器更新情况

00:27:08.729 --> 00:27:12.299 align:middle
我们想要监控这些情况 让它们更平滑

00:27:12.666 --> 00:27:16.737 align:middle
看看哪个信息可以使得我们判定语境

00:27:18.405 --> 00:27:20.307 align:middle
其次我们有那个“接洽”部分

00:27:21.241 --> 00:27:24.144 align:middle
如果用户正在走路或者跑步对于我来说

00:27:24.478 --> 00:27:26.580 align:middle
我想知道他们的速度有多快

00:27:26.847 --> 00:27:31.118 align:middle
看看步调 我就可以知道他们是否

00:27:31.185 --> 00:27:35.222 align:middle
爬了一座高大的丘陵
这样我就可以给他们播放一首

00:27:35.289 --> 00:27:36.690 align:middle
欢快的歌来庆祝他们的成就

00:27:36.957 --> 00:27:39.526 align:middle
为此 我需要计步器更新情况

00:27:39.593 --> 00:27:42.229 align:middle
这些情况里面包括步幅、步调的变更

00:27:42.663 --> 00:27:44.131 align:middle
以及高度更新情况

00:27:45.933 --> 00:27:47.968 align:middle
然后我们还有“反射”部分

00:27:48.602 --> 00:27:50.704 align:middle
就像我之前说过
Core Motion很棒的是

00:27:50.771 --> 00:27:53.407 align:middle
它们可以一天二十四小时、
一周七天都为我努力工作

00:27:53.974 --> 00:27:57.377 align:middle
因此我就可以进行回顾
获取那些历史活动性查询

00:27:57.678 --> 00:28:02.249 align:middle
以及计步器查询
然后把这个信息分成几个有趣的部分

00:27:57.678 --> 00:28:02.249 align:middle
以及计步器查询
然后把这个信息分成几个有趣的部分

00:28:05.819 --> 00:28:09.690 align:middle
既然我已经仔细看了
我的app长什么样

00:28:09.756 --> 00:28:12.993 align:middle
看了“检测”、“接洽”
以及“反射”部分

00:28:13.060 --> 00:28:16.363 align:middle
也知道了我需要使用Core
Motion哪一部分的APIs

00:28:16.730 --> 00:28:18.932 align:middle
我要向你们展示下
我到底是如何编码的

00:28:18.999 --> 00:28:21.401 align:middle
最起码要让你们看看我的
应用程序的数据模型

00:28:23.504 --> 00:28:25.372 align:middle
我要打开Xcode

00:28:26.006 --> 00:28:28.308 align:middle
但是在我走到这边的电脑之前

00:28:28.709 --> 00:28:31.645 align:middle
先提醒你们一下
屏幕上会出现大量的文本

00:28:32.212 --> 00:28:33.780 align:middle
别被吓跑了

00:28:34.081 --> 00:28:37.050 align:middle
示例代码现在已经放到网上了

00:28:37.184 --> 00:28:39.620 align:middle
现在请勿打开

00:28:42.122 --> 00:28:43.223 align:middle
请仅仅关注

00:28:43.290 --> 00:28:45.626 align:middle
我为你们高亮显示的部分

00:28:46.093 --> 00:28:48.262 align:middle
我之前已经说过了那里会有大量的文本

00:28:48.495 --> 00:28:52.299 align:middle
如果仅看那几个东西然后会议结束后

00:28:52.366 --> 00:28:54.401 align:middle
回去看看示例代码

00:28:54.701 --> 00:28:57.504 align:middle
你就能记住我重点讲的东西
而不是想要

00:28:57.571 --> 00:28:59.039 align:middle
一次做太多的事

00:29:00.274 --> 00:29:02.242 align:middle
我已经说过了 文本会很多提醒过了

00:29:02.976 --> 00:29:05.078 align:middle
就像我说过的
屏幕上有大量的文本

00:29:05.379 --> 00:29:08.015 align:middle
我只想让你们记住三个部分

00:29:09.616 --> 00:29:11.952 align:middle
就是“检测”、“接洽”与“反射”

00:29:12.019 --> 00:29:13.520 align:middle
记住了这些事情那么我要仔细看看

00:29:13.587 --> 00:29:16.890 align:middle
我的应用程序的数据模型中的这些东西

00:29:17.324 --> 00:29:21.261 align:middle
这个就是“数据模型”部分

00:29:21.328 --> 00:29:23.197 align:middle
剩下的部分供你以后自己探索

00:29:23.564 --> 00:29:26.400 align:middle
我要做的第一件事是“检测”

00:29:26.533 --> 00:29:29.436 align:middle
这就要求获得活动性更新情况
以及计步器更新情况

00:29:29.503 --> 00:29:31.238 align:middle
我们来看看这些活动性更新情况

00:29:36.009 --> 00:29:37.144 align:middle
很好 文本很多 是吧？

00:29:38.579 --> 00:29:40.914 align:middle
我要做的第一件事
就是校验下看看这个硬件上

00:29:40.981 --> 00:29:43.717 align:middle
能否使用活动性

00:29:44.551 --> 00:29:47.454 align:middle
就像阿尼尔之前提到的
活动性并不总是可用

00:29:47.521 --> 00:29:51.725 align:middle
因此在我们查询任何更新情况之前
我们需要进行这些校验

00:29:53.794 --> 00:29:55.062 align:middle
我们要做的第二件事是 使用

00:29:55.128 --> 00:29:58.165 align:middle
startActivitiesUpdateToQueue

00:29:58.232 --> 00:29:59.733 align:middle
API

00:30:00.033 --> 00:30:03.770 align:middle
对于我而言
我只是进行了一个简单的NS操作查询

00:30:04.838 --> 00:30:06.840 align:middle
然后我要对数据进行处理

00:30:09.209 --> 00:30:12.312 align:middle
动作活动性就频繁显示出来了

00:30:12.880 --> 00:30:15.415 align:middle
你可以自己决定
怎样对数据进行平滑操作

00:30:15.949 --> 00:30:18.986 align:middle
对于我而言当某个用户跑步时

00:30:19.253 --> 00:30:22.155 align:middle
他们可能会遇到红灯停下
处于半静止的状态

00:30:22.523 --> 00:30:24.992 align:middle
我不想从跑步时的播放列表
转移到非常舒缓的播放列表

00:30:25.058 --> 00:30:26.493 align:middle
然后这样 来来回回

00:30:26.560 --> 00:30:27.761 align:middle
往往复复

00:30:28.295 --> 00:30:32.499 align:middle
所以我想做的是自己指定
应用程序的平滑操作至于你的应用程序

00:30:32.566 --> 00:30:34.701 align:middle
最适合什么样的平滑操作
我就交给你来决定了

00:30:36.837 --> 00:30:38.839 align:middle
让我们再来看看
计步器的更新情况

00:30:44.344 --> 00:30:47.848 align:middle
PedometerUpdates
API看起来也非常眼熟 你看到的

00:30:48.415 --> 00:30:51.752 align:middle
我也要校验下 看看计步是否可用

00:30:52.486 --> 00:30:54.955 align:middle
即使我们假定
活动性可能是可以用的

00:30:55.022 --> 00:30:57.491 align:middle
那也并不意味着计步也同样可用

00:30:58.959 --> 00:31:02.362 align:middle
假定计步真的可用 那么我要
startPedometerUpdates

00:30:58.959 --> 00:31:02.362 align:middle
假定计步真的可用 那么我要
startPedometerUpdates

00:31:02.729 --> 00:31:05.766 align:middle
这个API可以允许我们提供一个日期

00:31:06.366 --> 00:31:08.635 align:middle
如果你所处的是一个更日记化的语境
你可能就想

00:31:08.702 --> 00:31:10.704 align:middle
在你的日期一开始 启动这些更新

00:31:10.804 --> 00:31:11.738 align:middle
就我而言

00:31:11.805 --> 00:31:14.808 align:middle
我想在我的应用程序的
生命周期内看到这些更新

00:31:14.942 --> 00:31:16.677 align:middle
因此我现在就要启动这些更新

00:31:19.980 --> 00:31:22.749 align:middle
有一件非常重要的事情我需要指出

00:31:24.318 --> 00:31:25.485 align:middle
我们可能会收到一个错误

00:31:27.821 --> 00:31:33.193 align:middle
关于Core Motion很棒的是

00:31:33.794 --> 00:31:38.098 align:middle
它们会做出这样的事：喂！是否想让此
app使用为你弹出的活动数据？

00:31:39.700 --> 00:31:42.169 align:middle
但是用户可能会第一次
打开你的应用程序

00:31:42.236 --> 00:31:46.473 align:middle
然后允许你访问活动数据
但是他们可以随时回到

00:31:46.940 --> 00:31:49.142 align:middle
“偏好”中把授权删除

00:31:49.743 --> 00:31:52.679 align:middle
在那种情况下
当你试图接受更新情况时

00:31:52.746 --> 00:31:54.548 align:middle
我们就会抛出一个授权错误

00:31:54.848 --> 00:31:57.084 align:middle
那么你就需要平滑地处理这些问题

00:31:57.150 --> 00:32:01.321 align:middle
提示用户进到应用程序设置中

00:31:57.150 --> 00:32:01.321 align:middle
提示用户进到应用程序设置中

00:32:01.522 --> 00:32:04.758 align:middle
再次对你的应用程序进行授权

00:32:06.860 --> 00:32:10.097 align:middle
我在这里不去设置中了
但是我会弹出一个简单的UI

00:32:10.163 --> 00:32:11.798 align:middle
提醒视图 提示要去设置

00:32:13.367 --> 00:32:14.835 align:middle
这就是“检测”部分

00:32:15.202 --> 00:32:18.472 align:middle
接下来我要做的就是“接洽”部分

00:32:20.140 --> 00:32:23.477 align:middle
就我而言 当我看到活动性更新时

00:32:23.877 --> 00:32:27.247 align:middle
我还想启动、终止高度表的更新

00:32:27.981 --> 00:32:29.349 align:middle
我要在这里这样做

00:32:31.118 --> 00:32:34.421 align:middle
我进行了平滑处理
看看用户什么时候在跑步或者在步行

00:32:34.488 --> 00:32:36.890 align:middle
在那个例子中
我对高度的更新情况很感兴趣

00:32:41.595 --> 00:32:43.363 align:middle
很好现在你可以在这里看到一个主题了

00:32:44.031 --> 00:32:45.299 align:middle
我要做的第一件事

00:32:45.365 --> 00:32:47.434 align:middle
就是校验下 看看高度更新是否可用

00:32:48.569 --> 00:32:50.003 align:middle
假定它是可用的 我会

00:32:50.070 --> 00:32:52.940 align:middle
startRelativeAltitude
UpdatesToQueue

00:32:54.675 --> 00:32:56.310 align:middle
我创建了一个队列

00:32:57.010 --> 00:32:58.846 align:middle
然后我要对数据进行相应的处理

00:32:59.546 --> 00:33:01.648 align:middle
我再校验一次 看看是否有错误

00:32:59.546 --> 00:33:01.648 align:middle
我再校验一次 看看是否有错误

00:33:01.982 --> 00:33:04.384 align:middle
如果没有错误
那么我要在我的应用程序中把那个数据

00:33:04.818 --> 00:33:08.455 align:middle
当成最优服务来处理
至于你的数据该如何进行

00:33:08.755 --> 00:33:10.824 align:middle
最优服务处理 那由你决定

00:33:14.061 --> 00:33:16.430 align:middle
接下来我要做的就是
因为我对持续的高度更新

00:33:16.496 --> 00:33:20.834 align:middle
不感兴趣 因此要确保当我不是处于

00:33:21.068 --> 00:33:22.636 align:middle
跑步或者走路时把它停掉

00:33:29.376 --> 00:33:33.580 align:middle
很好 在这里这个API非常直接

00:33:33.647 --> 00:33:35.082 align:middle
我校验下可用性

00:33:35.282 --> 00:33:38.485 align:middle
我来
stopRelativeAltitudeUpdates

00:33:40.754 --> 00:33:42.623 align:middle
现在我知道了
当我说我们想要与用户进行

00:33:42.689 --> 00:33:44.525 align:middle
“接洽”时我们也会同时看到

00:33:44.591 --> 00:33:46.193 align:middle
计步器的更新情况

00:33:46.860 --> 00:33:49.796 align:middle
你可能记得
在我的应用程序的生活周期内

00:33:49.863 --> 00:33:52.966 align:middle
我已经看到了计步器的更新情况 因此

00:33:53.033 --> 00:33:54.501 align:middle
我无需再次启动、停止它们

00:33:54.801 --> 00:33:57.871 align:middle
我可以把这些融合到高度更新中来用

00:33:57.971 --> 00:34:01.141 align:middle
给我提供我的应用程序需要的东西

00:33:57.971 --> 00:34:01.141 align:middle
给我提供我的应用程序需要的东西

00:34:01.208 --> 00:34:03.043 align:middle
也就是通过音乐来激励用户

00:34:04.811 --> 00:34:06.547 align:middle
这就是“反射”部分

00:34:12.252 --> 00:34:15.755 align:middle
那么在这里
我要看看活动性的更新情况

00:34:15.822 --> 00:34:18.792 align:middle
以便我以有趣的部分的形式
提供这些东西

00:34:18.859 --> 00:34:20.159 align:middle
就像我之前给你们看的那样

00:34:27.234 --> 00:34:30.404 align:middle
很好 我希望你们看的 第一件事

00:34:30.771 --> 00:34:33.172 align:middle
就是我们可以查询日期后的
所有的活动性的更新情况

00:34:33.507 --> 00:34:36.243 align:middle
就我而言
我想看看过去一周的情况

00:34:36.643 --> 00:34:38.779 align:middle
即使我们不看
那一周的应用程序的使用情况

00:34:38.978 --> 00:34:41.315 align:middle
我们也可以获取所有的数据

00:34:41.380 --> 00:34:42.850 align:middle
然后把它们放到一起

00:34:46.719 --> 00:34:49.523 align:middle
就我而言
我对那个数据进行下处理

00:34:49.590 --> 00:34:51.225 align:middle
让它们为我以有趣的部分的形式显示

00:34:51.291 --> 00:34:53.560 align:middle
我等不及想看看你们自己

00:34:53.627 --> 00:34:54.828 align:middle
会怎么做了

00:34:55.495 --> 00:34:57.464 align:middle
又出现了 我知道唱片损坏了 对吧？

00:34:57.931 --> 00:35:00.033 align:middle
我要对这个错误进行相应的处理

00:34:57.931 --> 00:35:00.033 align:middle
我要对这个错误进行相应的处理

00:35:01.468 --> 00:35:04.104 align:middle
就我而言
一旦我找到有趣的步行片段

00:35:04.371 --> 00:35:07.908 align:middle
我就会给出全部的额外的

00:35:07.975 --> 00:35:09.910 align:middle
历史计步器信息

00:35:09.977 --> 00:35:12.479 align:middle
那么我在这里要做的
我要为某个给定的活动性片段

00:35:15.015 --> 00:35:20.621 align:middle
请求计步器的更新情况

00:35:26.527 --> 00:35:29.796 align:middle
第一件事就是
queryPedometerDataFromDate

00:35:29.863 --> 00:35:32.132 align:middle
我提供了一个开始日期
还提供了一个结束日期

00:35:32.199 --> 00:35:35.669 align:middle
就我而言
我已经把数据放到程序段中了

00:35:35.736 --> 00:35:38.539 align:middle
那么我来看看这些段的开始和结束部分

00:35:40.073 --> 00:35:42.176 align:middle
这里我要指出的第二件事是

00:35:43.810 --> 00:35:46.346 align:middle
如果我想要进行任何UI变更

00:35:46.413 --> 00:35:49.149 align:middle
那么我就需要把这些变更发送到主队列

00:35:49.550 --> 00:35:51.051 align:middle
如果你在你自己的应用程序内

00:35:51.118 --> 00:35:53.086 align:middle
不这么做 那么你就会遇到问题

00:35:55.189 --> 00:35:56.590 align:middle
所以请这么做吧

00:35:57.257 --> 00:36:01.895 align:middle
我要向你们展示的就是这些
想你的应用程序添加活动

00:35:57.257 --> 00:36:01.895 align:middle
我要向你们展示的就是这些
想你的应用程序添加活动

00:36:02.196 --> 00:36:04.298 align:middle
总共花了我十分钟左右 因此

00:36:04.698 --> 00:36:07.601 align:middle
当你回去后
给你的应用程序做同样的事

00:36:07.668 --> 00:36:09.303 align:middle
就是这么容易

00:36:10.170 --> 00:36:13.540 align:middle
现在我真的想让你们看看这个app
但是我不会在这里

00:36:13.607 --> 00:36:15.108 align:middle
跑一圈或者开车

00:36:15.442 --> 00:36:18.645 align:middle
我要向你们看看
过去今天内我的历史数据

00:36:18.912 --> 00:36:21.515 align:middle
让你们看看“反射”部分
是怎样以有趣的图段的形式

00:36:21.582 --> 00:36:22.783 align:middle
来组织数据的

00:36:28.455 --> 00:36:30.157 align:middle
但愿这是一台iPhone

00:36:33.660 --> 00:36:36.964 align:middle
太好了！这是我的音乐活动应用程序

00:36:37.731 --> 00:36:39.666 align:middle
你可以看到
我的活动强度不大

00:36:39.733 --> 00:36:41.835 align:middle
因此 我现在处于低强度模式

00:36:43.704 --> 00:36:45.672 align:middle
现在我再来看看我的历史记录情况

00:36:46.874 --> 00:36:49.409 align:middle
我要从昨天早上开始

00:36:49.877 --> 00:36:51.211 align:middle
让你们看看我一天的情况

00:36:51.278 --> 00:36:53.580 align:middle
我昨天所做的
就是围绕莫斯康走路

00:36:55.148 --> 00:36:58.252 align:middle
昨天我醒来后
我决定快速骑行一段时间

00:36:58.852 --> 00:37:02.656 align:middle
我所做的就是...
app已经搞定了

00:36:58.852 --> 00:37:02.656 align:middle
我所做的就是...
app已经搞定了

00:37:02.723 --> 00:37:04.791 align:middle
替我把这些放进了一个有趣的图段

00:37:06.159 --> 00:37:10.564 align:middle
然后我朝着公交车走去
意识到有点晚了

00:37:10.631 --> 00:37:14.301 align:middle
于是就开始跑 最终上了公交车

00:37:15.169 --> 00:37:19.439 align:middle
你可以在这里看到
我在这里的就是步行的图段

00:37:19.506 --> 00:37:22.709 align:middle
有英里信息
有步幅信息

00:37:23.076 --> 00:37:25.946 align:middle
层级上升与下降
这些都替我放进了

00:37:26.013 --> 00:37:27.381 align:middle
那些有趣的组块中

00:37:28.215 --> 00:37:30.918 align:middle
如果我是在某个单元上
实际开发一款音乐应用程序

00:37:31.251 --> 00:37:34.555 align:middle
那么我可能会把
当时我听的播放列表

00:37:34.621 --> 00:37:36.456 align:middle
放到那个图块上

00:37:37.958 --> 00:37:41.028 align:middle
有一件事我要指出 话说今天

00:37:41.695 --> 00:37:43.564 align:middle
当我在莫斯康附近 走路的时候

00:37:43.964 --> 00:37:46.700 align:middle
我没有出现任何层级的上升与下降

00:37:47.134 --> 00:37:48.235 align:middle
这是因为我今天比较懒

00:37:48.302 --> 00:37:49.870 align:middle
到处都乘坐了自动扶梯

00:37:50.904 --> 00:37:53.040 align:middle
我希望你们也注意到了这一点

00:37:55.175 --> 00:37:57.211 align:middle
这就是我的
基础的音乐应用程序

00:37:57.945 --> 00:37:59.079 align:middle
我来总结下

00:38:03.217 --> 00:38:05.786 align:middle
我希望你们喜欢这个演示

00:38:06.086 --> 00:38:08.322 align:middle
我尽量把重点放在少数几个事情上

00:38:08.689 --> 00:38:11.325 align:middle
这样你就可以记住
并且用到你的应用程序上记住

00:38:11.992 --> 00:38:15.362 align:middle
这里有“检测”片段 使用活动来检测

00:38:15.429 --> 00:38:17.431 align:middle
某个用户正在做的事情

00:38:17.497 --> 00:38:19.366 align:middle
而不是让用户告诉你
他们正在做什么事情

00:38:20.067 --> 00:38:25.172 align:middle
通过活动性、计步器、高度表
推送更新与用户进行“接洽”

00:38:26.206 --> 00:38:28.475 align:middle
以及“反射回去”

00:38:28.642 --> 00:38:33.247 align:middle
把那些历史查询智慧地运用起来

00:38:34.181 --> 00:38:36.350 align:middle
如果你有更多的问题

00:38:36.817 --> 00:38:38.185 align:middle
请到“开发者论坛”看一看

00:38:38.452 --> 00:38:40.888 align:middle
请务必看看音乐活动

00:38:40.954 --> 00:38:42.723 align:middle
它应该就在开发者入口处

00:38:43.156 --> 00:38:46.126 align:middle
如果是一般的咨询
请联系我们的福音传道者

00:38:47.961 --> 00:38:49.863 align:middle
此外还有一些会议与本次会议相关

00:38:49.963 --> 00:38:51.498 align:middle
它们也值得你去看看

00:38:52.299 --> 00:38:53.967 align:middle
如果你参加了苹果全球开发者大会

00:38:54.334 --> 00:38:56.970 align:middle
你可能已经看过或者
还没有看过HealthKit演示、

00:38:57.037 --> 00:38:58.705 align:middle
Cocoa Touch演示

00:38:59.106 --> 00:39:01.475 align:middle
如果你错过了这些演示或者你现在在家

00:38:59.106 --> 00:39:01.475 align:middle
如果你错过了这些演示或者你现在在家

00:39:01.542 --> 00:39:03.177 align:middle
那么请去网上看看这些视频

00:39:03.610 --> 00:39:05.045 align:middle
同样 我也希望你们去看看

00:39:05.112 --> 00:39:07.447 align:middle
Core Location的演示

00:39:08.982 --> 00:39:12.452 align:middle
如果你能够真正把活动数据、健康数据

00:39:12.653 --> 00:39:16.523 align:middle
位置数据组合起来
那么你就可以创建一些绝妙的语境

00:39:16.590 --> 00:39:18.559 align:middle
来让你的应用程序更上一层楼

00:39:19.026 --> 00:39:21.862 align:middle
我迫不及待想看看你们会在
App Store上何应用程序

00:39:31.738 --> 00:39:33.106 align:middle
谢谢 太谢谢了
