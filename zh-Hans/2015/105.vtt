WEBVTT

00:00:19.553 --> 00:00:23.156 align:middle
介绍watchOS 2的
WatchKit

00:00:23.223 --> 00:00:24.525 align:middle
乔希·谢弗: 好的 上午好

00:00:25.025 --> 00:00:27.694 align:middle
感谢大家今天来到这里学习

00:00:27.761 --> 00:00:30.097 align:middle
有关watchkit和
watchOS 2的新知识

00:00:30.464 --> 00:00:32.698 align:middle
今天上午要讲的东西有很多

00:00:33.433 --> 00:00:36.503 align:middle
当然
最重要的部分是WatchKit

00:00:36.770 --> 00:00:38.238 align:middle
以及WatchKit相关最新信息

00:00:38.805 --> 00:00:43.277 align:middle
WatchKit
作为watchOS系统平台的一部分

00:00:43.677 --> 00:00:45.579 align:middle
存在一系列其他框架

00:00:45.879 --> 00:00:47.414 align:middle
其中很多是各位已经熟悉的

00:00:47.481 --> 00:00:48.882 align:middle
用于开发iOS应用的框架

00:00:49.349 --> 00:00:52.085 align:middle
此外还有一些用于专属watchOS

00:00:52.486 --> 00:00:55.322 align:middle
用于提供特性的新内容
都属于Apple Watch所独有

00:00:55.589 --> 00:00:57.724 align:middle
今天我们将讨论这些新信息

00:00:57.791 --> 00:01:02.663 align:middle
以及一些各位已经熟悉的
涉及watchOS专属的新内容

00:00:57.791 --> 00:01:02.663 align:middle
以及一些各位已经熟悉的
涉及watchOS专属的新内容

00:01:06.166 --> 00:01:07.734 align:middle
也就是watchOS 2

00:01:09.102 --> 00:01:11.271 align:middle
首先让我们简单谈谈系统结构

00:01:12.840 --> 00:01:16.510 align:middle
各位已经熟悉用于WatchOS 1
的Watch系统应用

00:01:17.144 --> 00:01:17.978 align:middle
其运行方式是

00:01:18.278 --> 00:01:21.582 align:middle
需要在iPhone和Apple
Watch上同时有用户界面

00:01:22.049 --> 00:01:24.418 align:middle
你推出了一款iPhone app

00:01:24.918 --> 00:01:26.420 align:middle
这款iPhone app中有

00:01:26.720 --> 00:01:29.756 align:middle
适合Apple Watch
作为Watch app的一部分

00:01:31.558 --> 00:01:33.861 align:middle
用户界面
分镜故事板

00:01:34.161 --> 00:01:36.430 align:middle
在Apple Watch中存在
并安装在这里

00:01:36.830 --> 00:01:38.332 align:middle
但app拓展在手机上运行

00:01:38.966 --> 00:01:41.101 align:middle
watchOS 2的一大进展就是

00:01:41.301 --> 00:01:45.272 align:middle
app拓展并运行
在Apple Watch

00:01:47.841 --> 00:01:50.544 align:middle
这给各位的用户带来了一些便利

00:01:51.011 --> 00:01:56.083 align:middle
首先 当然是用户界面
和运行的后台代码处于同一设备

00:01:56.383 --> 00:01:58.986 align:middle
可使交互等待时间更短

00:01:59.286 --> 00:02:01.822 align:middle
从而使应用反应速度更灵敏

00:01:59.286 --> 00:02:01.822 align:middle
从而使应用反应速度更灵敏

00:02:03.123 --> 00:02:05.692 align:middle
显然 这一改善带来了很好的效果

00:02:06.093 --> 00:02:08.362 align:middle
比如在手机不在身边时
仍然可以运行应用

00:02:09.530 --> 00:02:11.665 align:middle
为了确保这一效果高效运行

00:02:11.999 --> 00:02:16.937 align:middle
各位应该现在花时间了解清楚
如何将应用程序逻辑移动到程序拓展中

00:02:18.071 --> 00:02:19.273 align:middle
如果在watchOS 1中

00:02:19.373 --> 00:02:24.378 align:middle
你耗费大量时间用于打开父应用程序
在iPhone app中运行代码

00:02:24.778 --> 00:02:27.981 align:middle
你想要重构该逻辑并移动到拓展中

00:02:29.483 --> 00:02:31.251 align:middle
app拓展获得的代码越多

00:02:31.652 --> 00:02:35.556 align:middle
在iPhone不在身边的情况下
就可以提供越多的单机功能

00:02:36.623 --> 00:02:38.959 align:middle
当然 有关单机功能
另一个重要的部分是

00:02:39.326 --> 00:02:43.163 align:middle
Apple Watch可以通过
Wi-Fi访问网络

00:02:43.730 --> 00:02:47.301 align:middle
以便你的app可以从HTTP服务器
获得数据

00:02:47.434 --> 00:02:49.436 align:middle
即使在iPhone不在身边时
也能访问网络

00:02:49.670 --> 00:02:52.906 align:middle
如果你习惯在iOSapp中
使用NSURL Session

00:02:53.307 --> 00:02:54.975 align:middle
那么你已经知道如何操作了

00:02:55.275 --> 00:02:56.410 align:middle
稍后我们会讨论这个问题

00:02:57.144 --> 00:02:58.712 align:middle
但首先我们来谈谈

00:02:59.012 --> 00:03:00.514 align:middle
WatchKit框架下的新特性

00:02:59.012 --> 00:03:00.514 align:middle
WatchKit框架下的新特性

00:03:00.981 --> 00:03:04.751 align:middle
除了将代码运行移动到Apple
Watch这一巨大进展

00:03:05.052 --> 00:03:07.387 align:middle
我们也为WatchKit
加入了一系列新的性能

00:03:07.855 --> 00:03:10.591 align:middle
以便各位在watchOS 2
开发更酷的应用程序

00:03:11.658 --> 00:03:13.160 align:middle
为了给大家一些有关新性能的概述

00:03:13.427 --> 00:03:15.629 align:middle
这里的列表举出了我们即将谈到的性能

00:03:15.929 --> 00:03:18.498 align:middle
我们拥有数码表冠 设计和动画

00:03:18.732 --> 00:03:21.301 align:middle
因此现在我们来介绍这些优秀的性能

00:03:21.668 --> 00:03:23.504 align:middle
首先我们来看数码表冠

00:03:24.071 --> 00:03:27.641 align:middle
这是属于Apple Watch的
独特交互机制

00:03:28.408 --> 00:03:31.311 align:middle
一系列新的简单的控制

00:03:31.645 --> 00:03:35.048 align:middle
方便您将数码表冠
应用于工作界面选取器

00:03:36.250 --> 00:03:42.422 align:middle
选择器控件是通过
数码表冠滚动单元列表

00:03:42.756 --> 00:03:43.590 align:middle
并选择其中一项

00:03:44.191 --> 00:03:45.993 align:middle
数码表冠有三种类型

00:03:46.560 --> 00:03:47.528 align:middle
现在详细介绍每一类

00:03:47.628 --> 00:03:50.230 align:middle
我们现在看到的是第一类列表类型

00:03:50.864 --> 00:03:53.934 align:middle
如果你了解表盘上的配置合并

00:03:54.268 --> 00:03:55.469 align:middle
那你已经了解其基本运行了

00:03:55.936 --> 00:03:56.803 align:middle
这是一个项目列表

00:03:57.638 --> 00:04:00.374 align:middle
可以在周围列出可选的焦点框

00:03:57.638 --> 00:04:00.374 align:middle
可以在周围列出可选的焦点框

00:04:00.908 --> 00:04:04.912 align:middle
并在顶端给出有关已选项目
更多的细节信息介绍

00:04:05.145 --> 00:04:08.582 align:middle
以防列出的项目本身
代表的含义并不明确

00:04:10.083 --> 00:04:12.986 align:middle
用户可以选择显示或隐藏更多细节信息
针对任意一项用户交互单元

00:04:13.387 --> 00:04:16.023 align:middle
如果屏幕中同时列出多个选择器

00:04:16.190 --> 00:04:18.257 align:middle
用户可能需要显示焦点框

00:04:18.458 --> 00:04:22.129 align:middle
以便清晰告知用户
一旦按下表冠将要进行何种操作

00:04:23.330 --> 00:04:27.868 align:middle
第二种模式是堆叠式

00:04:28.936 --> 00:04:32.539 align:middle
堆叠式提供一系列图像

00:04:32.673 --> 00:04:34.608 align:middle
使用户可以滚动并选取其中之一

00:04:34.942 --> 00:04:39.112 align:middle
这一模式可以进行自动转换
其他项目自动淡出

00:04:39.646 --> 00:04:43.784 align:middle
如果你想给用户提供一系列选择
并生动地呈现出来

00:04:44.017 --> 00:04:46.854 align:middle
你可以选择这一模式
它的视觉效果很好

00:04:47.788 --> 00:04:49.923 align:middle
第三种模式是图像序列

00:04:50.891 --> 00:04:54.661 align:middle
图像序列模式提供一个可以滚动的列表

00:04:54.928 --> 00:04:56.730 align:middle
其中是相互没有过渡效果的图像

00:04:57.197 --> 00:05:00.868 align:middle
如果经过一个程序到另一个的转换后看
起来十分自然

00:04:57.197 --> 00:05:00.868 align:middle
如果经过一个程序到另一个的转换后看
起来十分自然

00:05:01.168 --> 00:05:05.506 align:middle
那么你可以选择这个十分适合此类情况
更适合使用这种图像的模式

00:05:07.140 --> 00:05:09.076 align:middle
我们可以看到右上角这里

00:05:09.443 --> 00:05:11.044 align:middle
这里设有一个滚动指示

00:05:11.678 --> 00:05:15.782 align:middle
这是一个三种模式都适用的
可选用户交互元素

00:05:16.717 --> 00:05:19.820 align:middle
这个滚动指示器使用的情况是

00:05:19.953 --> 00:05:23.724 align:middle
用户不能准确看到列表内容
或列表内容数量的情况

00:05:24.291 --> 00:05:26.760 align:middle
例如 用户在应用中选择一天中的时刻

00:05:27.594 --> 00:05:28.896 align:middle
选择一天中的一个小时

00:05:29.463 --> 00:05:31.598 align:middle
这时可能不需要滚动指示

00:05:31.865 --> 00:05:36.170 align:middle
因为用户明确知道一天有多少小时
并且在列表中有明显显示

00:05:36.970 --> 00:05:41.208 align:middle
加入选择的内容是其他多少不能像选择
表情符号那样清楚显示的

00:05:41.508 --> 00:05:42.709 align:middle
那么适合选择滚动指示

00:05:42.776 --> 00:05:45.979 align:middle
以便用户了解所面临的选项
以及一共有多少个选择

00:05:48.182 --> 00:05:49.983 align:middle
除了这三种模式

00:05:50.217 --> 00:05:53.287 align:middle
选择器控件事实上还有另一个性能

00:05:53.487 --> 00:05:56.857 align:middle
在运行中可以带来更多的灵活性
实现更便捷的用户交互

00:05:57.324 --> 00:05:59.293 align:middle
也就是协调化图像

00:05:59.860 --> 00:06:01.528 align:middle
这一特性的最大优点在于

00:05:59.860 --> 00:06:01.528 align:middle
这一特性的最大优点在于

00:06:01.595 --> 00:06:05.132 align:middle
可以用于创建动态的图像
在其他交互元素中

00:06:05.199 --> 00:06:08.535 align:middle
例如群组背景 或其他交互图像

00:06:08.836 --> 00:06:12.072 align:middle
你可以将它们设置为
与选择性控件相协调

00:06:12.639 --> 00:06:17.911 align:middle
当用户进行整理时
我们会调整动态图像的框架的偏移量

00:06:18.078 --> 00:06:20.881 align:middle
从而与列表项目中相关的偏移量相对应

00:06:21.348 --> 00:06:23.984 align:middle
从而方便您建立用户交互
看起来就像这样

00:06:24.685 --> 00:06:29.323 align:middle
当用户浏览 进行选择时
有一个协调话图像填充环形

00:06:30.157 --> 00:06:32.025 align:middle
不同模式的相互结合使用

00:06:32.092 --> 00:06:36.129 align:middle
并通过数码表冠操控
可以方便你开发一个有趣 独特的模式

00:06:37.698 --> 00:06:40.100 align:middle
接下来让我们谈谈动画技术和设计

00:06:40.968 --> 00:06:41.869 align:middle
正如各位所知

00:06:41.935 --> 00:06:44.037 align:middle
应该在storyboards上
在watchOS上建立用户交互

00:06:44.104 --> 00:06:45.506 align:middle
并且基于Xcode

00:06:47.541 --> 00:06:50.978 align:middle
Xcode中你有各种选择可用于设置

00:06:51.044 --> 00:06:53.080 align:middle
storyboard中
不同的交互元素

00:06:53.814 --> 00:06:57.451 align:middle
现在watchOS 1中推出了很多
此类选择可以以编程的方式进行改变

00:06:57.551 --> 00:06:59.853 align:middle
但是有一些选择
只能在storyboard中运行

00:07:00.320 --> 00:07:02.723 align:middle
在watchOS
2中我们不断推出新性能 进行提高

00:07:02.823 --> 00:07:04.558 align:middle
从而为这些项目提供设置

00:07:04.625 --> 00:07:08.362 align:middle
改变这些项目之前在设计过程中
只能在Xcode中设置的状态

00:07:09.096 --> 00:07:11.732 align:middle
这一性能可以极大改善
程序运行时的效果

00:07:11.798 --> 00:07:13.300 align:middle
改变之前只能静态呈现的状态

00:07:14.334 --> 00:07:19.206 align:middle
此外我们还添加了新的动画API界面

00:07:19.473 --> 00:07:24.344 align:middle
其持续时间可以通过一个讯息块
并可以将你设置的改动加入到交互元素

00:07:24.811 --> 00:07:27.080 align:middle
在该模块中
做的任何改动都会随之被动态化

00:07:27.381 --> 00:07:30.751 align:middle
如果您熟悉用户界面套件动态API
那么对这一特性就十分熟悉

00:07:31.451 --> 00:07:36.757 align:middle
这一特性有助于用动画开发
一系列很酷 运行流畅的交互

00:07:37.457 --> 00:07:39.159 align:middle
另外要介绍许多WatchKit方面

00:07:39.226 --> 00:07:42.763 align:middle
比如有关设计的整个过程和动画技术

00:07:43.030 --> 00:07:44.331 align:middle
所以您可以对此进行了解

00:07:45.065 --> 00:07:46.767 align:middle
有一些不能显示的很清楚的部分

00:07:46.834 --> 00:07:49.336 align:middle
和使用这些API时一些很酷的手法

00:07:49.703 --> 00:07:51.038 align:middle
可以带来很好的效果

00:07:51.338 --> 00:07:53.907 align:middle
因此如果你进行更多了解
会发现它们也是很出色的部分

00:07:55.342 --> 00:07:57.010 align:middle
下面 让我们介绍Taptic引擎

00:07:57.611 --> 00:08:00.647 align:middle
这是Apple Watch
又一项独特的性能

00:07:57.611 --> 00:08:00.647 align:middle
这是Apple Watch
又一项独特的性能

00:08:00.848 --> 00:08:05.752 align:middle
使信息传达到用户
而不用用户真的在屏幕中读取出来

00:08:06.053 --> 00:08:06.920 align:middle
这个功能真的很棒

00:08:07.154 --> 00:08:08.989 align:middle
Taptic引擎的
一个很棒的特点就是

00:08:09.056 --> 00:08:13.794 align:middle
可以通过用户触觉掌握用户感受和声音

00:08:14.094 --> 00:08:17.030 align:middle
以及在app环境下的意义

00:08:17.631 --> 00:08:23.637 align:middle
我们推出一个简洁的API
方便您在工作交互设备上使用触觉技术

00:08:23.837 --> 00:08:25.973 align:middle
有不同的模式可供选择

00:08:26.473 --> 00:08:29.343 align:middle
我所提到的每一个模式

00:08:29.409 --> 00:08:31.945 align:middle
都有预期使用环境
您的用户会了解这一模式

00:08:32.145 --> 00:08:35.883 align:middle
因为这一性能的目的就是传递信息
而不用真的读取屏幕

00:08:36.316 --> 00:08:38.485 align:middle
你会需要确保不断使用这一功能

00:08:38.784 --> 00:08:42.089 align:middle
这些模式的命名就是为了帮助你
了解他们所使用的情况

00:08:42.489 --> 00:08:46.026 align:middle
我们在说明文件中准备了相关文件

00:08:46.226 --> 00:08:49.429 align:middle
深度介绍每一个模式在设计Apple
Watch中有的预期使用环境

00:08:49.863 --> 00:08:52.499 align:middle
所以如果你想在开发应用中
使用触觉技术并持续使用

00:08:52.833 --> 00:08:54.401 align:middle
请继续了解此功能

00:08:54.468 --> 00:08:58.205 align:middle
最终达到用户可以直接了解程序运行
而不用读取屏幕

00:09:01.074 --> 00:09:05.479 align:middle
此外还有一些其他硬件
我们想要在WatchKit中应用

00:09:05.979 --> 00:09:07.481 align:middle
第一 是麦克风

00:09:08.382 --> 00:09:10.284 align:middle
我们在watchOS 2中
采用新的API

00:09:10.551 --> 00:09:12.286 align:middle
从而方便您采用录音表

00:09:12.753 --> 00:09:18.325 align:middle
录制记录音频
在用户进行处理之前回放

00:09:18.692 --> 00:09:21.528 align:middle
最后通过按下右上角的按键
对音频进行最终处理

00:09:23.197 --> 00:09:28.569 align:middle
因此右上角的按键
可以根据您的应用来命名

00:09:28.936 --> 00:09:31.839 align:middle
在此环境下我将它命名为“发送”
因为我预设它会发送一条消息

00:09:32.206 --> 00:09:35.275 align:middle
但你也可以将它命名为“保存”
如果你开发的是语音备忘录一类应用

00:09:36.710 --> 00:09:40.514 align:middle
它操作十分简单
先录制成文件 用户点击确认键时

00:09:40.747 --> 00:09:41.949 align:middle
你会收到一个文件 以便处理

00:09:42.216 --> 00:09:45.185 align:middle
任何的方式对于你的应用都是合适的

00:09:46.520 --> 00:09:50.023 align:middle
当然 除了麦克风
我们也想要开发扬声器的功能

00:09:50.724 --> 00:09:55.128 align:middle
我们通过为您的应用提供
回放视频音频内容

00:09:55.863 --> 00:09:58.632 align:middle
有三种API
用不同的方式实现这一操作

00:09:59.299 --> 00:10:03.270 align:middle
第一种是新的交互对象
叫做工作交互影片

00:09:59.299 --> 00:10:03.270 align:middle
第一种是新的交互对象
叫做工作交互影片

00:10:03.971 --> 00:10:06.807 align:middle
这一元素提供标准的外观

00:10:07.207 --> 00:10:11.044 align:middle
方便视频文件播放以及重放

00:10:11.712 --> 00:10:13.514 align:middle
在屏幕上这个案例中我准备了两个视频

00:10:13.847 --> 00:10:15.048 align:middle
假设现有一个海报形象

00:10:15.415 --> 00:10:17.451 align:middle
全球资源定位器可以定位你的内容

00:10:17.784 --> 00:10:19.186 align:middle
WatchKit操作为你重放

00:10:19.653 --> 00:10:23.190 align:middle
如果你已经将内容输入到手表中
这个全球资源定位器可以是本地文件

00:10:23.390 --> 00:10:26.627 align:middle
如果不是本地文件
则使用远程HTTP URL

00:10:27.094 --> 00:10:28.862 align:middle
如果提供一个远程资源

00:10:29.129 --> 00:10:33.967 align:middle
WatchKit可以下载 显示进程
并在下载完成后立即播放

00:10:34.468 --> 00:10:36.904 align:middle
如果是本地文件
可以很快进行重放

00:10:38.272 --> 00:10:39.907 align:middle
当用户点击播放键

00:10:40.140 --> 00:10:45.746 align:middle
则可以看到优质的全屏播放的视频
以及全屏视频回放

00:10:46.079 --> 00:10:50.951 align:middle
回放控制将在简要浏览全部内容后
立即淡出

00:10:53.787 --> 00:10:57.558 align:middle
此外 如果你想要用其他方式回放
而不采用标准界面

00:10:57.758 --> 00:11:01.962 align:middle
也有一个API可
直接从其他界面呈现控制器

00:10:57.758 --> 00:11:01.962 align:middle
也有一个API可
直接从其他界面呈现控制器

00:11:04.598 --> 00:11:07.234 align:middle
这些API可以播放视频音频内容

00:11:07.568 --> 00:11:10.037 align:middle
且十分适用于回放小型文件

00:11:10.404 --> 00:11:12.773 align:middle
Apple Watch
被设计为简短的互动

00:11:13.140 --> 00:11:17.077 align:middle
7所以在这里播放的
最好是不太长的东西

00:11:17.277 --> 00:11:19.379 align:middle
你也许不想以这种方式

00:11:19.713 --> 00:11:21.815 align:middle
在Apple Watch上
播放两个小时的电影

00:11:21.915 --> 00:11:26.854 align:middle
有时你想播放的音频类型
内容很长

00:11:27.287 --> 00:11:30.023 align:middle
如果你正在编写类似播客的app

00:11:30.257 --> 00:11:32.192 align:middle
你也许想要下载一些播客

00:11:32.392 --> 00:11:35.195 align:middle
然后运行一下
在你的蓝牙耳机上听一听

00:11:35.696 --> 00:11:40.100 align:middle
我们有另外一个API
对于播放这类较长形式的音频确实不错

00:11:40.834 --> 00:11:44.371 align:middle
如果你熟悉AV基础的API
你就知道如何使用这些

00:11:44.438 --> 00:11:45.606 align:middle
因为它们非常相似

00:11:46.473 --> 00:11:51.111 align:middle
你也许从iOS了解到这与以AV为基
础的API之间唯一的不同是

00:11:51.278 --> 00:11:58.185 align:middle
为了使应用程序获得真正的高性能
和更大的电池使用

00:11:58.585 --> 00:12:03.123 align:middle
它不要求你的应用程序
为了播放那个音频而持续在后台运转

00:11:58.585 --> 00:12:03.123 align:middle
它不要求你的应用程序
为了播放那个音频而持续在后台运转

00:12:03.524 --> 00:12:05.926 align:middle
该文件可以被切换到系统来播放

00:12:05.993 --> 00:12:08.228 align:middle
即使你的应用程序被悬置没有运行

00:12:08.829 --> 00:12:11.565 align:middle
如果用户在外奔跑时查看表盘

00:12:12.866 --> 00:12:14.668 align:middle
它们可以提供正在播放的信息

00:12:14.868 --> 00:12:17.604 align:middle
并且控制来自你应用程序的音频播放

00:12:17.738 --> 00:12:19.173 align:middle
即使你的应用程序没有在运行

00:12:22.409 --> 00:12:27.447 align:middle
我想在这里快速地谈一下
还有几个其他与硬件无关的API

00:12:28.182 --> 00:12:29.750 align:middle
第一个是提醒

00:12:30.284 --> 00:12:34.221 align:middle
我再重复一次Apple Watch
是为简短的互动而设计的

00:12:34.655 --> 00:12:38.525 align:middle
因此你也许真的要小心
不要过度使用这种API

00:12:38.592 --> 00:12:43.530 align:middle
因为它确实将额外的步骤引入了
你的应用程序中的一些工作流程中

00:12:44.097 --> 00:12:48.135 align:middle
有时候你只需要在获得回答前
问用户一个问题即可

00:12:48.468 --> 00:12:50.470 align:middle
对于那些情况
我们有提醒API

00:12:50.537 --> 00:12:53.607 align:middle
向你提供这种类UI
的统一外观

00:12:54.441 --> 00:12:55.909 align:middle
你提供一个标题 一个描写

00:12:56.243 --> 00:12:59.513 align:middle
块中应该采取的按钮列表和动作

00:13:00.180 --> 00:13:01.081 align:middle
它们只是被显示出来

00:13:01.148 --> 00:13:03.417 align:middle
当用户点击它们中的一个时
你就会获得回调

00:13:03.750 --> 00:13:07.454 align:middle
在这种情况下
我包含了一个破坏按钮

00:13:07.521 --> 00:13:09.990 align:middle
明确说明当我点击这里的删除
破坏的事情就会发生

00:13:13.193 --> 00:13:15.896 align:middle
我们有个非常不错的
开放系统URL API

00:13:16.096 --> 00:13:17.798 align:middle
它允许做许多新的事情

00:13:18.198 --> 00:13:20.601 align:middle
开放系统URL可以采用另外的URL

00:13:20.767 --> 00:13:26.940 align:middle
并发送给用户一个小型应用程序
使其发送信息给app中已有的接受者

00:13:28.275 --> 00:13:30.777 align:middle
更酷的是你可以传递来自
始于Apple Watch的

00:13:30.978 --> 00:13:34.882 align:middle
电话呼叫应用程序
tel URL

00:13:35.649 --> 00:13:36.483 align:middle
当那个发生的时候

00:13:36.550 --> 00:13:38.852 align:middle
通话中的UI就会出现在你的app中

00:13:39.186 --> 00:13:41.688 align:middle
用户可以打电话
他们只要一挂机

00:13:41.922 --> 00:13:45.225 align:middle
他们立刻就能回到他们开始打电话时
离开的app界面

00:13:48.962 --> 00:13:51.798 align:middle
我们还对票据进行集成-票据工具箱

00:13:52.432 --> 00:13:56.103 align:middle
实际上
票据工具箱是手表操作系统的一部分

00:13:56.803 --> 00:14:01.141 align:middle
这样你就能够访问
在iPhone上可能具有的票据

00:13:56.803 --> 00:14:01.141 align:middle
这样你就能够访问
在iPhone上可能具有的票据

00:14:01.275 --> 00:14:03.677 align:middle
票据库与iPhone
Apple Watch是同步的

00:14:03.744 --> 00:14:04.678 align:middle
这样你能同时获得

00:14:05.345 --> 00:14:07.681 align:middle
更不错的是
WatchiKit有个API

00:14:07.748 --> 00:14:09.750 align:middle
允许你添加票据到票据库中

00:14:10.117 --> 00:14:13.720 align:middle
你以这样的方式将PK票据
交给WatchKit API

00:14:14.188 --> 00:14:17.691 align:middle
用户能够滚动它
来查看那个票据中有什么

00:14:17.925 --> 00:14:20.928 align:middle
一直到最后有个添加按钮
将它添加到库中

00:14:21.695 --> 00:14:22.529 align:middle
当他们点击那个时

00:14:22.596 --> 00:14:23.997 align:middle
它就会被添加到
Apple Watch库中

00:14:24.064 --> 00:14:27.935 align:middle
但是也在iPhone
及其它通过云端服务同步的设备中

00:14:28.802 --> 00:14:32.773 align:middle
因此从输入一直到后来票据的使用

00:14:32.840 --> 00:14:35.676 align:middle
所有的端到端的票据情况
都在Apple Watch上

00:14:38.846 --> 00:14:42.082 align:middle
这就是WatchKit的新性能
那里还有许多新奇的东西

00:14:42.783 --> 00:14:47.154 align:middle
正如我所说过的WatchKit只是
整个的手表操作系统STK的一部分

00:14:47.621 --> 00:14:49.056 align:middle
还有其他的框架

00:14:49.156 --> 00:14:54.161 align:middle
一些是新的
一些是已有的并添加了新功能

00:14:54.962 --> 00:14:57.231 align:middle
我现在就要谈谈其他的几个

00:14:57.464 --> 00:15:00.067 align:middle
先说两个对WatchOS
很特别的特性

00:14:57.464 --> 00:15:00.067 align:middle
先说两个对WatchOS
很特别的特性

00:15:00.934 --> 00:15:02.970 align:middle
第一个是Clock Kit

00:15:05.339 --> 00:15:08.742 align:middle
Clock Kit是不需要构建信息

00:15:08.809 --> 00:15:12.579 align:middle
直接在表盘上显示的框架

00:15:12.846 --> 00:15:16.116 align:middle
它可以迅速地将你的数据
放在用户的面前

00:15:19.052 --> 00:15:20.821 align:middle
信息有几种模式

00:15:21.121 --> 00:15:22.789 align:middle
但Clock Kit支持所有的模式

00:15:22.990 --> 00:15:26.393 align:middle
让我们来仔细查看表盘
来看看它是什么样子的

00:15:27.194 --> 00:15:29.496 align:middle
这里是我们的实用表盘

00:15:29.563 --> 00:15:32.432 align:middle
现在表盘上能看到
有三种不同的信息特性

00:15:32.833 --> 00:15:37.871 align:middle
你可以看到有不同的尺寸
和形状的信息特性

00:15:38.172 --> 00:15:44.411 align:middle
为了显示信息 Clock Kit
以恰当的方式格式化数据

00:15:45.078 --> 00:15:47.214 align:middle
例如 如果我们看彩色的表盘

00:15:47.481 --> 00:15:49.650 align:middle
这个有着更宽尺寸的信息特性

00:15:49.716 --> 00:15:53.620 align:middle
且更高些可显示两行的文本或图像

00:15:54.588 --> 00:15:56.657 align:middle
最后 在数字模块表盘上

00:15:56.723 --> 00:16:00.160 align:middle
我们将最大的信息放在正中央
其他的放在边缘上

00:15:56.723 --> 00:16:00.160 align:middle
我们将最大的信息放在正中央
其他的放在边缘上

00:16:00.527 --> 00:16:03.163 align:middle
Clock Kit提供了
一些非常好的API

00:16:03.297 --> 00:16:07.768 align:middle
让你以多种不同模板来格式化你的数据
并满足不同的外观需求

00:16:08.101 --> 00:16:14.708 align:middle
使它能针对不同大小的信息进行调节
来显示合适的数据数量

00:16:16.743 --> 00:16:18.745 align:middle
现在有关信息的另一个重要特性是

00:16:18.979 --> 00:16:20.714 align:middle
它们正好在你的表盘上

00:16:21.081 --> 00:16:23.884 align:middle
这就意味着每次用户举起手腕看表

00:16:24.051 --> 00:16:26.687 align:middle
他们想要立即看到最新的数据

00:16:27.421 --> 00:16:32.459 align:middle
如果每次都要用户举起手腕询问代码
来提供要显示的当前数值

00:16:32.793 --> 00:16:33.861 align:middle
我们就已经失败了

00:16:34.361 --> 00:16:38.699 align:middle
在用户举起他们的手腕之前
信息需要立即在那儿

00:16:39.166 --> 00:16:40.400 align:middle
为了实现这个目标

00:16:40.667 --> 00:16:44.471 align:middle
你以时间轴的形式向ClockKit
提供应用程序数据

00:16:45.272 --> 00:16:48.242 align:middle
在这种情况下
我以这里的信息和时间轴的形式

00:16:48.642 --> 00:16:50.577 align:middle
向WWDC提供应用程序数据

00:16:51.178 --> 00:16:52.713 align:middle
如果是上午10:00

00:16:53.113 --> 00:16:54.314 align:middle
它将显示的早晨的主题

00:16:54.581 --> 00:16:57.217 align:middle
表明当前正在召开会议

00:16:58.685 --> 00:17:01.922 align:middle
随着一天的流逝
现在到2:00

00:16:58.685 --> 00:17:01.922 align:middle
随着一天的流逝
现在到2:00

00:17:02.155 --> 00:17:03.290 align:middle
因为它已经有了数据

00:17:03.423 --> 00:17:06.492 align:middle
所以ClockKit选择
那个时间点合适的事情

00:17:06.760 --> 00:17:08.595 align:middle
它会移动到国情咨询平台

00:17:09.162 --> 00:17:11.598 align:middle
移动到4:00
苹果设计奖励

00:17:12.398 --> 00:17:15.435 align:middle
这种格式的了不起的地方是

00:17:15.502 --> 00:17:20.674 align:middle
你整天都可获得自动的行为
不需要代码一直在运行

00:17:21.074 --> 00:17:25.311 align:middle
但是你可以参与时空之旅
而不需要你费任何事

00:17:25.811 --> 00:17:30.217 align:middle
如果用户将数字表冠向后移动
想看看这一天的早些时候都发生了什么

00:17:30.651 --> 00:17:34.988 align:middle
Clock Kit就会转换到显示
那一时刻的合适的数据段

00:17:35.789 --> 00:17:42.229 align:middle
这很容易为信息添加支持
也很有效地将数据放在用户面前

00:17:43.830 --> 00:17:44.965 align:middle
这就是Clock Kit

00:17:45.032 --> 00:17:49.403 align:middle
有一个全程的讲座
将会对此详细地进行说明及相关API

00:17:49.636 --> 00:17:52.739 align:middle
和不同的模板
甚至你起始要做的一切东西

00:17:53.040 --> 00:17:55.409 align:middle
离开时请领取
一本名叫用Clock Kit的书

00:17:57.811 --> 00:17:59.613 align:middle
下来我想说的是连网

00:18:01.114 --> 00:18:03.483 align:middle
在Apple Watch和
IPhone上

00:18:03.550 --> 00:18:07.087 align:middle
有代码运行连网是很重要的内容

00:18:09.089 --> 00:18:12.125 align:middle
有两种连网也许你想要在app中使用

00:18:12.459 --> 00:18:16.363 align:middle
第一个
你也许要有较宽的因特网

00:18:17.764 --> 00:18:23.904 align:middle
当你处于独立模式或手表和手机在相同
的地方使用NSURL对话API时

00:18:23.971 --> 00:18:26.340 align:middle
你可以使用这种连网方式

00:18:27.608 --> 00:18:32.613 align:middle
它会根据用户使用手机的方式

00:18:33.013 --> 00:18:37.384 align:middle
包括手机检测并连接Wi-Fi的方式
以最佳的方式连接到网络

00:18:40.287 --> 00:18:42.556 align:middle
有个全程的讲座都
将讨论NSURL连网

00:18:42.823 --> 00:18:45.292 align:middle
NSURL连网将会单独讲解

00:18:46.426 --> 00:18:51.598 align:middle
点击因特网上的任何服务器
都可以下载数据

00:18:51.865 --> 00:18:55.035 align:middle
如果你曾使用过iOS
它们是相同的API

00:18:55.536 --> 00:18:58.672 align:middle
且还具有相同的特性设置
包括后台下载

00:19:00.807 --> 00:19:06.079 align:middle
有时你想在Apple Watch和
iPhone上运行代码

00:19:06.313 --> 00:19:08.649 align:middle
你想让它们分享数据并且彼此对话

00:19:09.583 --> 00:19:13.654 align:middle
我们为WatchOS和iOS提供了
崭新的框架

00:19:13.720 --> 00:19:14.888 align:middle
叫做手表连通性

00:19:15.189 --> 00:19:16.623 align:middle
它允许你来做那样的事情

00:19:16.823 --> 00:19:20.360 align:middle
你的iPhone可以连通正在
iPhone上运行的代码

00:19:20.527 --> 00:19:23.330 align:middle
同时你的手表可以连通正在
手表上运行的代码

00:19:26.400 --> 00:19:32.105 align:middle
比如当你想要从因特网上下载数据

00:19:33.040 --> 00:19:37.044 align:middle
构建一个天气应用程序
去下载当前的天气信息

00:19:37.744 --> 00:19:39.746 align:middle
我们可以说
你的用户拿起他们的iPhone

00:19:39.980 --> 00:19:40.981 align:middle
并且启动了该应用程序

00:19:41.148 --> 00:19:45.118 align:middle
你来到因特网获取最新的天气
并将它显示在他们的iPhone上

00:19:45.786 --> 00:19:47.354 align:middle
如果你没有做其它的任何事

00:19:47.521 --> 00:19:49.790 align:middle
你构建手表应用程序
来做相同的事情

00:19:50.157 --> 00:19:52.192 align:middle
下次他们看到手表上的应用程序

00:19:52.359 --> 00:19:55.429 align:middle
来到网络上下载最新的数据
并将它显示在那儿

00:19:56.430 --> 00:19:59.233 align:middle
但是那不是我们能做的最好的做法
我们肯定可以做得更好

00:19:59.433 --> 00:20:03.370 align:middle
因为我们有刚从iPhone获得的数
据 它现在在用户的口袋中

00:19:59.433 --> 00:20:03.370 align:middle
因为我们有刚从iPhone获得的数
据 它现在在用户的口袋中

00:20:04.238 --> 00:20:10.611 align:middle
如果我们能充分利用已经下载的数据
并在我们设备中的多次使用

00:20:10.677 --> 00:20:12.145 align:middle
那就太好了

00:20:13.113 --> 00:20:15.148 align:middle
为达到这个目的
可以做类似这样的事情

00:20:15.649 --> 00:20:17.484 align:middle
用户将数据下载
在他们的iPhone上

00:20:17.551 --> 00:20:20.921 align:middle
你将它转移并保存在手表上

00:20:21.088 --> 00:20:24.224 align:middle
因此如果用户看到手表上的应用程序

00:20:24.458 --> 00:20:28.495 align:middle
数据已经在那儿且不需要再次下载

00:20:29.196 --> 00:20:32.533 align:middle
当然 你仍然可以下载最近的更新版本

00:20:32.666 --> 00:20:36.403 align:middle
如果你知道天气数据是
每小时更新一次

00:20:36.603 --> 00:20:39.039 align:middle
你可能已经获得了最新的数据
那就不需要这样做了

00:20:39.406 --> 00:20:43.744 align:middle
你现在就有更新的东西
可以立即显示

00:20:44.978 --> 00:20:47.714 align:middle
手表连通性就提供了这个功能

00:20:48.282 --> 00:20:51.185 align:middle
有两个提供后台下载的API

00:20:51.385 --> 00:20:52.853 align:middle
第一个叫做应用程序语境

00:20:53.086 --> 00:20:58.091 align:middle
你将它做的一切都
移交到一个数据字典中

00:20:58.358 --> 00:21:02.196 align:middle
你希望每当再次运行在另一侧的应用程
序时 都可以获得该数据

00:20:58.358 --> 00:21:02.196 align:middle
你希望每当再次运行在另一侧的应用程
序时 都可以获得该数据

00:21:02.596 --> 00:21:04.998 align:middle
它总是获得最新的数据版本

00:21:05.199 --> 00:21:07.234 align:middle
所以你只是设置为无论如何都是当前的

00:21:07.434 --> 00:21:10.304 align:middle
下次你的应用程序运行的时候
就可以在那里得到

00:21:11.071 --> 00:21:16.777 align:middle
在幕后 手表连通性在能量
和性能最佳的时机传输数据

00:21:18.212 --> 00:21:22.282 align:middle
还有个文件传输API
如果你有较大的数据

00:21:22.549 --> 00:21:26.720 align:middle
你可以将更多的数据从的iPhone
传输到你的手表 反之亦然

00:21:27.154 --> 00:21:31.358 align:middle
同样的 它会在后台
能量和性能的最佳时机完成

00:21:32.860 --> 00:21:37.130 align:middle
还有时你还需要在两侧
互动消息传递

00:21:37.764 --> 00:21:41.401 align:middle
如果你的手表应用程序将要在
你的iPhone上启动一些操作

00:21:41.635 --> 00:21:43.170 align:middle
你也许想要发送一个消息过去

00:21:43.670 --> 00:21:46.540 align:middle
在这个例子中
我在手表上有个去按钮

00:21:46.874 --> 00:21:49.443 align:middle
当我点击它的时候
我想给iPhone发送一个消息

00:21:50.577 --> 00:21:55.315 align:middle
下来要发生的就是
若应用程序已在iPhone后台运行

00:21:55.549 --> 00:21:56.717 align:middle
消息就会被转发

00:21:56.783 --> 00:22:01.555 align:middle
这样你就可以做类似开始一个会话
或在iPhone上进行一些活动

00:21:56.783 --> 00:22:01.555 align:middle
这样你就可以做类似开始一个会话
或在iPhone上进行一些活动

00:22:02.623 --> 00:22:05.859 align:middle
现在我提到这些API在两侧都存在
它们是双向的

00:22:06.193 --> 00:22:08.128 align:middle
应用程序语境可以到达两个方向

00:22:08.562 --> 00:22:11.498 align:middle
文件传输API
可以在两个方向传输文件

00:22:11.999 --> 00:22:14.368 align:middle
一个不同之处是在发送消息API

00:22:14.801 --> 00:22:16.837 align:middle
当从手表到iPhone发送消息时

00:22:16.904 --> 00:22:20.340 align:middle
可以唤醒iPhone后台的应用程序
进行一些活动

00:22:20.841 --> 00:22:23.577 align:middle
但是当从iPhone到手表的时候

00:22:23.744 --> 00:22:25.512 align:middle
它就不会唤醒后台的手表

00:22:25.579 --> 00:22:29.650 align:middle
你的app在手表上运行的目的
就是为了接受来自iPhone的消息

00:22:31.952 --> 00:22:34.755 align:middle
在这些API中还有很多细节需要注意

00:22:34.821 --> 00:22:38.025 align:middle
还有一个完整的讲座讲的是这些东西
这个讲座的名字是介绍手表的连接性

00:22:38.091 --> 00:22:39.393 align:middle
所以你需要看一下

00:22:39.593 --> 00:22:45.199 align:middle
并学习一下如何将后端从只能在一个
设备上运行

00:22:45.766 --> 00:22:48.902 align:middle
变成同时在iPhone
和Apple Watch运行

00:22:51.805 --> 00:22:54.474 align:middle
所以这些就是那三个新的构架

00:22:54.808 --> 00:22:57.344 align:middle
对于WatchOS来讲
是全新并且独有的

00:22:57.878 --> 00:23:00.480 align:middle
现存的IOS上有很多框架

00:22:57.878 --> 00:23:00.480 align:middle
现存的IOS上有很多框架

00:23:00.714 --> 00:23:02.783 align:middle
你已经熟悉了在你的app中使用它们

00:23:03.150 --> 00:23:07.921 align:middle
我们在Apple Watch上添加
了一些新功能或者说加强了独有的功能

00:23:08.555 --> 00:23:10.457 align:middle
我现在想要概述一下这些功能

00:23:11.091 --> 00:23:13.026 align:middle
第一个是Core Motion

00:23:13.760 --> 00:23:20.133 align:middle
正如你所知 Core Motion
可以让你访问IOS设备的运动传感器

00:23:20.634 --> 00:23:22.369 align:middle
WatchOS中同样存在

00:23:22.436 --> 00:23:24.171 align:middle
可以让你能够访问加速度计

00:23:24.972 --> 00:23:26.907 align:middle
和在IOS上一样
在WatchOS上

00:23:26.974 --> 00:23:30.611 align:middle
Core Motion
给你程序运行的实时数据

00:23:31.411 --> 00:23:35.315 align:middle
但对于Apple Watch来讲
这是新的而且很赞的是

00:23:35.649 --> 00:23:42.189 align:middle
它可以在程序中记录运动数据
即使它不是以一个较低的刷新速率运行

00:23:42.456 --> 00:23:46.627 align:middle
然后将加速度计的数据批量发送给你
在下次你的应用程序运行的时候

00:23:47.561 --> 00:23:50.531 align:middle
这在你的APP没有运行的时候

00:23:50.831 --> 00:23:52.466 align:middle
是一种很酷地检测运动数据的方法

00:23:53.467 --> 00:23:56.403 align:middle
关于这有一个完整的讲座
叫做Core Motion的新功能

00:23:56.603 --> 00:23:57.871 align:middle
所以你一定要去看一下

00:23:59.173 --> 00:24:02.009 align:middle
另外Core Location
是WatchOS的一部分

00:23:59.173 --> 00:24:02.009 align:middle
另外Core Location
是WatchOS的一部分

00:24:02.376 --> 00:24:06.180 align:middle
这是寻找用户新位置的很棒的方法

00:24:06.613 --> 00:24:10.317 align:middle
现在iOS 9和watchOS
2有个新的API

00:24:10.584 --> 00:24:15.355 align:middle
就可以非常简单地实现一些很赞的事情

00:24:17.157 --> 00:24:20.194 align:middle
现在另一件需要注意的是

00:24:20.527 --> 00:24:23.630 align:middle
WatchOS上
CoreLocation的位置信息

00:24:23.697 --> 00:24:26.633 align:middle
可以授权在iPhone上
运行的IOS APP

00:24:26.800 --> 00:24:29.336 align:middle
和Apple Watch上的
WatchOS APP之间共享

00:24:29.937 --> 00:24:32.472 align:middle
众所周知 当你使用
Core Location的时候

00:24:32.539 --> 00:24:37.144 align:middle
在app进行定位之前
要请求用户进行位置授权

00:24:37.578 --> 00:24:39.246 align:middle
在Apple Watch上也是这样

00:24:39.880 --> 00:24:44.418 align:middle
当用户允许了iPhone
或者Watch上的授权

00:24:44.484 --> 00:24:46.453 align:middle
它会同时提供给
IPhone和Watch

00:24:46.753 --> 00:24:48.455 align:middle
所以他们不需要对这个问题回答两次

00:24:48.789 --> 00:24:51.758 align:middle
有一个办法可以管理
用户的这种授权

00:24:54.127 --> 00:24:55.796 align:middle
有一完整的讲座介绍了
Core Location

00:24:55.863 --> 00:24:57.331 align:middle
叫做Core Location
的新功能

00:24:57.397 --> 00:24:58.765 align:middle
很多东西都能在那里找到

00:25:00.567 --> 00:25:01.869 align:middle
接下来是HealthKit

00:25:02.336 --> 00:25:04.705 align:middle
HealthKit也是
WatchOS的一部分

00:25:04.771 --> 00:25:08.509 align:middle
和你在IOS中使用的
是相同的API设置和相同的构架

00:25:09.376 --> 00:25:12.246 align:middle
在WatchOS上使用
HealthKit的最大优点是

00:25:12.579 --> 00:25:16.817 align:middle
有非常多的健康数据被记录在了手表上

00:25:17.084 --> 00:25:20.854 align:middle
你现在可以访问更多最新的实时数据

00:25:20.921 --> 00:25:22.422 align:middle
因为这都在手表其本身上

00:25:22.823 --> 00:25:25.526 align:middle
你现在可以在产生那些数据的设备上
进行查看

00:25:26.760 --> 00:25:30.430 align:middle
例如你可以看到实时的心率信息

00:25:30.697 --> 00:25:32.699 align:middle
当它正在记录并存储
在HealthKit中

00:25:33.534 --> 00:25:35.702 align:middle
HealthKit和WatchOS
的另一件很棒的事情是

00:25:35.769 --> 00:25:39.706 align:middle
它为API提供了
提醒你开始锻炼的功能

00:25:40.507 --> 00:25:43.877 align:middle
这些锻炼会话能够做很多这一类的事情

00:25:44.178 --> 00:25:48.348 align:middle
Watch本身的锻炼app也能做

00:25:48.448 --> 00:25:53.453 align:middle
例如如果你开始跑步
你想要记录用户的高频率心率数据

00:25:53.620 --> 00:25:55.822 align:middle
可以使用HealthKit API
打开那个会话

00:25:55.889 --> 00:26:00.627 align:middle
选择记录高频率的心率数据信息

00:25:55.889 --> 00:26:00.627 align:middle
选择记录高频率的心率数据信息

00:26:01.895 --> 00:26:05.599 align:middle
使用这个API中健身应用的
另一个很棒的事情是

00:26:06.133 --> 00:26:12.639 align:middle
每当用户举起手腕使用的时候
它允许程序继续回前台

00:26:13.106 --> 00:26:17.411 align:middle
如果你在写一个骑行APP
用户开始一个骑行会话

00:26:17.911 --> 00:26:19.213 align:middle
每次他们举起手腕的时候

00:26:19.279 --> 00:26:21.582 align:middle
在会话中他们能够通过app
查看最新的实时的数据

00:26:21.782 --> 00:26:26.753 align:middle
并看到自己在运动的时候表现的怎么样

00:26:28.322 --> 00:26:32.426 align:middle
现在当用户放下手腕
屏幕关闭的时候 应用程序被暂停

00:26:33.060 --> 00:26:36.864 align:middle
但是HealthKit将
默默地为你记录所有的数据

00:26:37.097 --> 00:26:39.633 align:middle
所以当用户举起手腕
能够再次运行起来

00:26:39.833 --> 00:26:43.770 align:middle
app被暂停时的数据得到了更新

00:26:45.239 --> 00:26:51.678 align:middle
这提供了一种很棒的方法
实现所有数据的统一

00:26:51.912 --> 00:26:54.381 align:middle
并为用户提供优秀的用户体验

00:26:56.583 --> 00:26:59.386 align:middle
也有一个完整的讲座
叫做HealthKit的新功能

00:26:59.753 --> 00:27:02.623 align:middle
如果你正在写一个锻炼类型的app

00:26:59.753 --> 00:27:02.623 align:middle
如果你正在写一个锻炼类型的app

00:27:03.090 --> 00:27:05.492 align:middle
或者任何可能使用
Health Kit数据优点的程序

00:27:06.927 --> 00:27:09.496 align:middle
我也想花一点时间讲一下
关于安全构架的问题

00:27:09.563 --> 00:27:12.499 align:middle
这也许不是最令人兴奋的消磨时间方法

00:27:13.033 --> 00:27:14.801 align:middle
但是请相信我
这里有非常重要的东西

00:27:15.969 --> 00:27:19.273 align:middle
如果你使用过IOS的安全构架

00:27:19.706 --> 00:27:23.043 align:middle
你就会知道它允许你
访问Keychain

00:27:24.278 --> 00:27:26.780 align:middle
Apple Watch上的
Keychain非常有意思

00:27:26.914 --> 00:27:29.183 align:middle
Apple Watch独一无二的是

00:27:29.349 --> 00:27:32.553 align:middle
当它在用户的手腕上的时候
它会保持开启

00:27:33.220 --> 00:27:35.122 align:middle
一旦当用户摘掉手表

00:27:35.756 --> 00:27:37.324 align:middle
这个设备就会马上锁定

00:27:38.392 --> 00:27:39.760 align:middle
你可以利用这一点

00:27:40.027 --> 00:27:44.932 align:middle
在Keychain中存储
你的凭据和安全数据

00:27:46.466 --> 00:27:47.301 align:middle
这样可以保证

00:27:47.367 --> 00:27:51.638 align:middle
当手表在用户的手腕上的时候
你能够访问数据

00:27:52.172 --> 00:27:56.643 align:middle
一旦手表被取下来
数据将不能够被访问因为手表被锁定了

00:28:00.214 --> 00:28:01.048 align:middle
谢谢

00:28:03.984 --> 00:28:05.185 align:middle
他感到非常兴奋

00:28:08.322 --> 00:28:09.790 align:middle
好吧
这就是安全部分

00:28:11.258 --> 00:28:12.259 align:middle
接下来是MapKit

00:28:13.861 --> 00:28:18.599 align:middle
有一个MapKit API子集可以
作为WatchOS STK的一部分

00:28:18.832 --> 00:28:21.168 align:middle
特别是MK Map API

00:28:21.802 --> 00:28:22.769 align:middle
它很酷的方面是

00:28:22.836 --> 00:28:27.241 align:middle
你可以从你的应用程序中
发送一个定位到地图APP

00:28:27.474 --> 00:28:30.010 align:middle
可以让用户在完整的地图应用中查看

00:28:30.611 --> 00:28:35.916 align:middle
他们不仅能够查看
还能够开始导航并在APP中寻找路线

00:28:36.483 --> 00:28:40.521 align:middle
如果你有一个位置
并且想使用户能够找到直接到那里

00:28:40.854 --> 00:28:42.389 align:middle
你可以在Apple Watch
和iPhone上

00:28:42.456 --> 00:28:45.292 align:middle
使用MapKit API开始导航

00:28:45.459 --> 00:28:48.262 align:middle
向用户发送导航信息

00:28:50.163 --> 00:28:51.765 align:middle
同样有一个关于MapKit的讲座

00:28:51.832 --> 00:28:54.268 align:middle
叫做MapKit的新功能
你可以了解到所有信息

00:28:55.936 --> 00:28:57.938 align:middle
最后两个我想要讲的构架是

00:28:58.005 --> 00:29:01.642 align:middle
都是关于访问
Apple Watch上数据的

00:28:58.005 --> 00:29:01.642 align:middle
都是关于访问
Apple Watch上数据的

00:29:02.042 --> 00:29:04.077 align:middle
在Apple
Watch上的用户数据类型

00:29:04.478 --> 00:29:07.047 align:middle
我们已经进行了同步处理

00:29:08.615 --> 00:29:10.350 align:middle
第一个是联系构架

00:29:11.385 --> 00:29:15.289 align:middle
在IOS 9和WatchOS 2中
联系是一个全新的构架

00:29:15.722 --> 00:29:19.927 align:middle
可以让你访问
Apple Watch中的通讯簿

00:29:19.993 --> 00:29:23.397 align:middle
因为在我们的应用程序中使用了
所以它已经同步了

00:29:23.597 --> 00:29:27.134 align:middle
你不需要传输就可以访问本地数据

00:29:28.035 --> 00:29:29.803 align:middle
有一个讲座讲了这个全新的构架

00:29:30.137 --> 00:29:33.040 align:middle
叫做iOS和OS 10的联系架构

00:29:33.340 --> 00:29:36.243 align:middle
如果你准备使用联系信息的话
就应该查看一下

00:29:36.844 --> 00:29:38.579 align:middle
就像Core Location一样

00:29:38.846 --> 00:29:41.682 align:middle
访问IOS APP
和WatchOS APP的

00:29:41.748 --> 00:29:44.785 align:middle
共享通讯簿数据需要用户的授权

00:29:45.452 --> 00:29:49.423 align:middle
当用户授权你访问通讯簿

00:29:49.656 --> 00:29:51.091 align:middle
你在任何一边都有访问的授权

00:29:51.391 --> 00:29:56.964 align:middle
在Apple Watch和
iPhone上都有个管理授权信息

00:29:59.099 --> 00:30:00.868 align:middle
最后一个是EventKit

00:29:59.099 --> 00:30:00.868 align:middle
最后一个是EventKit

00:30:01.168 --> 00:30:03.704 align:middle
EventKit是用作
访问用户日历的

00:30:04.638 --> 00:30:08.675 align:middle
这和我们讲过的联系构架上
有很多相同点

00:30:09.076 --> 00:30:10.944 align:middle
一旦你得到访问它的授权

00:30:11.311 --> 00:30:14.114 align:middle
对于iPhone APP
和Watch APP来讲是相同的

00:30:16.817 --> 00:30:20.487 align:middle
所以在WatchOS 2中
有非常多的东西

00:30:21.688 --> 00:30:23.156 align:middle
三个全新的构架

00:30:23.891 --> 00:30:28.896 align:middle
三个全新的构架
WatchKit 手表连接

00:30:34.568 --> 00:30:35.869 align:middle
还有Clock Kit
谢谢

00:30:42.709 --> 00:30:45.279 align:middle
WatchOS独有的三个全新的构架

00:30:45.979 --> 00:30:51.051 align:middle
在所有的其他构架中
有很多新功能是WatchOS特有的

00:30:51.351 --> 00:30:54.688 align:middle
有一些是在你的App之间共享的

00:30:55.689 --> 00:31:02.129 align:middle
当你在一个平台上学习并将其运用到其
他平台上的app时有大量的工作要做

00:30:55.689 --> 00:31:02.129 align:middle
当你在一个平台上学习并将其运用到其
他平台上的app时有大量的工作要做

00:31:02.396 --> 00:31:05.499 align:middle
其他的框架能够利用
Watch独有的功能

00:31:06.466 --> 00:31:10.070 align:middle
这一周有非常多的讲座
可以在其他地方学到更多东西

00:31:10.704 --> 00:31:12.840 align:middle
在文档中有一个过渡指南

00:31:12.906 --> 00:31:14.541 align:middle
WatchKit过渡指南

00:31:14.808 --> 00:31:18.545 align:middle
将帮你学习支持
WatchOS1的WatchKit

00:31:18.745 --> 00:31:23.350 align:middle
升级后支持在WatchOS 2上
运行作为手表本身的本地程序运行

00:31:24.484 --> 00:31:27.454 align:middle
有非常多的实例代码和开发者论坛

00:31:27.521 --> 00:31:31.658 align:middle
技术支撑是最好的解决所有问题的去处

00:31:32.025 --> 00:31:33.560 align:middle
这就是WatchKit的新东西

00:31:33.627 --> 00:31:35.162 align:middle
感谢您今早的到来

00:31:35.395 --> 00:31:39.166 align:middle
我非常期待你们
使用这些东西能做出来什么
