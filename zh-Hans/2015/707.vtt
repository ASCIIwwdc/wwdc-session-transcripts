WEBVTT

00:00:19.319 --> 00:00:24.558 align:middle
全天电池续航的会议

00:00:24.725 --> 00:00:25.626 align:middle
早上好

00:00:30.297 --> 00:00:33.500 align:middle
感谢您来观看关于
实现全天电池续航的会议

00:00:34.101 --> 00:00:36.737 align:middle
很兴奋能够和您讨论这个领域

00:00:37.204 --> 00:00:39.139 align:middle
我是来自于Core OS
的 強·安德魯斯

00:00:39.206 --> 00:00:41.408 align:middle
同时我的同事
桑仁·斯碧丝也将加入我们

00:00:42.910 --> 00:00:46.413 align:middle
我希望你们所有人
昨天晚上都把手机充满电了

00:00:46.480 --> 00:00:48.248 align:middle
而且在这个早晨不要看它

00:00:49.316 --> 00:00:51.218 align:middle
我们希望你能在当天晚些时候再去看

00:00:52.085 --> 00:00:55.189 align:middle
事实上 我们想让你看到
它比你已经看到它的时间要晚

00:00:56.190 --> 00:00:57.357 align:middle
我们将会讨论

00:00:57.891 --> 00:01:01.128 align:middle
在iOS的环境下如何去实现
全天电池续航的一些具体内容

00:00:57.891 --> 00:01:01.128 align:middle
在iOS的环境下如何去实现
全天电池续航的一些具体内容

00:01:03.263 --> 00:01:06.166 align:middle
我们将会谈到
用户对于全天电池续航的期待

00:01:07.434 --> 00:01:14.074 align:middle
计算做出改进后的大致功耗

00:01:14.975 --> 00:01:19.112 align:middle
你在帮助我们实现
全天电池续航中的任务

00:01:19.780 --> 00:01:22.249 align:middle
之后 桑仁 也将会更深入的

00:01:22.316 --> 00:01:26.019 align:middle
指导你们怎样改进程序
从而实现这些目的

00:01:27.855 --> 00:01:30.057 align:middle
先让我们了解一下
究竟什么是电池全天续航

00:01:31.925 --> 00:01:36.096 align:middle
用户在一天中不是一直使用他们的手机
8或者10个小时

00:01:36.997 --> 00:01:39.600 align:middle
他们实际上只是在某个密集的时间
才会使用它

00:01:39.666 --> 00:01:42.603 align:middle
可能是他们在早上上班的时候

00:01:43.103 --> 00:01:45.906 align:middle
然后手机就会被闲置

00:01:46.373 --> 00:01:47.975 align:middle
那么它就可以做一些后台工作

00:01:48.041 --> 00:01:51.578 align:middle
比如维护工作和网络通信
或下载邮件等

00:01:53.013 --> 00:01:56.049 align:middle
这种模式将会持续一整天
伴随着工作负载的激增

00:01:56.950 --> 00:01:58.552 align:middle
随后出现了一段空闲阶段

00:02:00.020 --> 00:02:04.124 align:middle
为了实现全天续航
需要保持一个较低的功耗

00:02:06.293 --> 00:02:10.531 align:middle
因此在一天中平均的功耗都很低

00:02:12.900 --> 00:02:17.804 align:middle
而那就是我们在关注操作系统的过程中
一直去努力追求的目标

00:02:20.407 --> 00:02:24.912 align:middle
因此让我们看一下
计算功耗的基本原理

00:02:25.879 --> 00:02:29.082 align:middle
首先功耗有两个要素 功率和时间

00:02:29.883 --> 00:02:32.219 align:middle
而时间因素经常被忽略

00:02:33.820 --> 00:02:39.293 align:middle
你可以做些耗费很多功率的密集操作

00:02:39.893 --> 00:02:41.762 align:middle
但你需要知道它工作多长时间

00:02:43.430 --> 00:02:47.167 align:middle
如果在待机的状态下
它并不会消耗过多的功率

00:02:48.101 --> 00:02:50.704 align:middle
但是你可以在很长的一段时间内
保持在待机状态

00:02:51.638 --> 00:02:55.475 align:middle
对于我们的设备来说
播放音频是另一项低功率的应用

00:02:55.742 --> 00:02:58.045 align:middle
因此可以提供很长的播放时间

00:02:59.112 --> 00:03:02.583 align:middle
但是当你进一步加强工作负载时

00:02:59.112 --> 00:03:02.583 align:middle
但是当你进一步加强工作负载时

00:03:03.116 --> 00:03:07.521 align:middle
消耗的功率也会随之增加
所以我们才希望你能减少使用设备时间

00:03:09.356 --> 00:03:14.161 align:middle
如果工作负载像空闲状态那样
实现全天续航将会变得非常简单

00:03:15.729 --> 00:03:18.265 align:middle
只要在平均功耗很低的情况下

00:03:18.332 --> 00:03:23.337 align:middle
意味着也可以产生
比较高的功率脉冲

00:03:25.138 --> 00:03:27.808 align:middle
现在我们的设备正在增加动态范围

00:03:29.042 --> 00:03:32.279 align:middle
我们正在开始接近MacBook领域

00:03:32.346 --> 00:03:34.815 align:middle
在这里你可以从系统中获取可观的性能

00:03:34.882 --> 00:03:36.416 align:middle
所以你需要非常小心的去使用它

00:03:37.618 --> 00:03:38.685 align:middle
其它要记住的事情就是

00:03:38.752 --> 00:03:40.754 align:middle
随着我们不断的增加动态范围

00:03:41.255 --> 00:03:45.425 align:middle
每一代的硬件效率也变得更好

00:03:45.926 --> 00:03:50.764 align:middle
因此我们将会给你更好的能力
去实现这些低功耗的操作

00:03:51.431 --> 00:03:54.801 align:middle
但是你也可以为了
实现密集操作或者超爽的用户体验

00:03:55.269 --> 00:03:58.238 align:middle
去使用更高的峰值性能

00:04:00.107 --> 00:04:03.310 align:middle
因此让我们从一个应用程序
生命循环周期的角度去审视它

00:04:05.345 --> 00:04:08.982 align:middle
这幅图中的区域
表示被应用程序所使用的功耗

00:04:10.450 --> 00:04:13.253 align:middle
你启动应用程序时
有些需要进行的工作

00:04:14.688 --> 00:04:18.358 align:middle
比如去初始化应用程序
可能在开始的时候有一些动画

00:04:19.091 --> 00:04:23.697 align:middle
当你的用户与应用程序进行交互时
可以会有一些活动的爆发

00:04:24.965 --> 00:04:27.835 align:middle
你需要记住的是
那样可能需要一些固定的消耗

00:04:28.335 --> 00:04:32.840 align:middle
而且那些功耗正是
被系统和功耗所正使用的

00:04:33.340 --> 00:04:35.776 align:middle
而那时用户的工作负载是最重要的

00:04:37.377 --> 00:04:40.214 align:middle
当用户结束使用应用程序之后

00:04:40.380 --> 00:04:44.218 align:middle
你希望在应用程序
进入后台时可以进行一些操作

00:04:44.718 --> 00:04:46.954 align:middle
然而最终应用程序被暂停了

00:04:48.288 --> 00:04:52.759 align:middle
在这儿我们可以看到
有着固定和动态损耗的时间因素

00:04:54.628 --> 00:04:59.099 align:middle
现在我们也只需要
从一个系统的角度来考虑

00:05:00.300 --> 00:05:03.337 align:middle
那么就让我们看看
系统在待机状态中的情况

00:05:05.706 --> 00:05:08.275 align:middle
在这里绝大部分的组件
都处于睡眠状态的形式下

00:05:09.543 --> 00:05:14.214 align:middle
屏幕是关闭的
内存也处于一种低功耗的

00:05:14.982 --> 00:05:17.117 align:middle
刷新模式下

00:05:17.918 --> 00:05:23.056 align:middle
只有一些无线电在开着
仅允许接收传入的流量或者唤醒系统

00:05:24.157 --> 00:05:25.859 align:middle
这种模式的功耗非常低

00:05:27.794 --> 00:05:32.332 align:middle
然后我们讨论一下用户闲置的情况
在这儿有更多系统的组件被唤醒

00:05:34.034 --> 00:05:39.640 align:middle
你也可看到显示屏处于开启运行状态
这带来了一些伴随着的的软系统

00:05:41.508 --> 00:05:45.279 align:middle
其他的组件
例如CPU 和GPU等

00:05:45.946 --> 00:05:49.583 align:middle
绝大多数是不活跃的并且闲置时间短

00:05:49.950 --> 00:05:51.652 align:middle
因此这个周期也很低

00:05:52.586 --> 00:05:56.890 align:middle
如果我们把它做成动画
并且展示功耗可能会是什么样子的话

00:05:57.090 --> 00:06:01.195 align:middle
那么在一天当中
用户的电池消耗将会得到很好的减缓

00:05:57.090 --> 00:06:01.195 align:middle
那么在一天当中
用户的电池消耗将会得到很好的减缓

00:06:01.595 --> 00:06:05.832 align:middle
希望在进入夜晚
你准备睡觉时为手机充电

00:06:08.302 --> 00:06:13.207 align:middle
然而假如你想运行
大功耗的程序比如3D游戏

00:06:13.774 --> 00:06:16.310 align:middle
这将会使用系统的绝大部分

00:06:17.077 --> 00:06:19.746 align:middle
你已经让所有的组件都处于运行状态

00:06:19.813 --> 00:06:26.486 align:middle
为了让GPU复杂的渲染跑起来
你可能正在使用大量的CPU

00:06:27.020 --> 00:06:31.992 align:middle
播放游戏音频会导致音频系统启动

00:06:32.926 --> 00:06:39.900 align:middle
因此预期的使用功率稍高
电池持续的时间相应的也会比较短

00:06:45.572 --> 00:06:51.311 align:middle
对于这三个组件
我们有一个非常简单的策略去优化功耗

00:06:52.346 --> 00:06:53.780 align:middle
你想做更少的工作

00:06:55.582 --> 00:07:00.187 align:middle
就需要考虑一下工作
是否需要现在去做或者随后再做

00:06:55.582 --> 00:07:00.187 align:middle
就需要考虑一下工作
是否需要现在去做或者随后再做

00:07:02.689 --> 00:07:06.593 align:middle
最终进行那项工作的时候
需要设法尽可能高效率地完成

00:07:09.329 --> 00:07:12.900 align:middle
桑仁 将会在下次讨论的部分
涉及到更多的细节问题

00:07:15.302 --> 00:07:17.137 align:middle
那么让我们讨论一下
在iOS 9下的情况

00:07:18.438 --> 00:07:21.475 align:middle
我们的已经有了一流的电池续航能力

00:07:22.342 --> 00:07:24.011 align:middle
然而我们确实认为我们能够做的更好

00:07:24.912 --> 00:07:26.847 align:middle
除此之外我们的顾客
也希望我们做的更好

00:07:27.314 --> 00:07:28.415 align:middle
你也希望我们做的更好

00:07:29.550 --> 00:07:32.853 align:middle
我们开始通过优化
操作系统和集成的应用程序

00:07:33.654 --> 00:07:35.789 align:middle
从而在现存的硬件中促进电池续航

00:07:37.024 --> 00:07:41.395 align:middle
去增加电池的额外一个小时的寿命

00:07:42.963 --> 00:07:45.999 align:middle
现在我们的做法
对于你们中的一些人可能很熟悉

00:07:46.066 --> 00:07:48.936 align:middle
因为我们在OS X Mavericks中
曾有过相似的努力

00:07:50.137 --> 00:07:53.373 align:middle
我们取消了应用程序
框架和驱动程序的轮询

00:07:53.440 --> 00:07:54.508 align:middle
我们优化了内核

00:07:56.276 --> 00:08:00.180 align:middle
同时把我们的服务质量
应用到我们的线程中

00:07:56.276 --> 00:08:00.180 align:middle
同时把我们的服务质量
应用到我们的线程中

00:08:00.948 --> 00:08:03.016 align:middle
采用了更多的NS操作

00:08:03.750 --> 00:08:06.153 align:middle
以及用更加正确的服务质量
去安排输入输出

00:08:08.021 --> 00:08:13.093 align:middle
我们结合定时器去减少CPU

00:08:13.594 --> 00:08:16.029 align:middle
以及像午睡app这样速率限制的
应用程序的唤醒次数

00:08:17.364 --> 00:08:21.502 align:middle
从系统的角度来看
重新执行我们的CPU电源管理单元

00:08:22.002 --> 00:08:24.538 align:middle
功耗将会得到显著的降低

00:08:25.439 --> 00:08:29.710 align:middle
然后我们添加了个非常受欢迎的特性

00:08:29.977 --> 00:08:34.181 align:middle
即为电池目录添加“重大能源”标示

00:08:34.414 --> 00:08:38.217 align:middle
从而使得你能够看到哪个应用程序
正在从电池中消耗比较大的能量

00:08:40.687 --> 00:08:43.657 align:middle
因此现在回到iOS中
看一下我们怎样应用这些措施的

00:08:44.191 --> 00:08:45.726 align:middle
我们之所以专注于iPhone

00:08:46.360 --> 00:08:50.931 align:middle
是因为我们得到很多人的反馈说
希望提高iphone的电池续航能力

00:08:52.199 --> 00:08:56.236 align:middle
然而从某种程度上来说这些提高措施
已经应用到我们所有的iOS设备中

00:08:58.172 --> 00:09:01.208 align:middle
现在让我们通过这三个组件的策略

00:08:58.172 --> 00:09:01.208 align:middle
现在让我们通过这三个组件的策略

00:09:02.643 --> 00:09:03.510 align:middle
以减少工作量

00:09:05.646 --> 00:09:11.285 align:middle
我们希望进一步优化闲置负载
以及特别关注睡眠定时器

00:09:11.919 --> 00:09:15.923 align:middle
在用户完成交互之后
系统的绝大部分时间都用在睡眠上

00:09:16.323 --> 00:09:20.394 align:middle
现在是基于用户在设备上的
操作基础上去优化

00:09:21.094 --> 00:09:25.465 align:middle
他们与推送的交互究竟是否进行

00:09:27.267 --> 00:09:29.503 align:middle
我们减少CPU在空闲时刻
被唤醒的次数

00:09:29.837 --> 00:09:33.240 align:middle
我们已经给它添加了
关于屏幕检测的一个很酷的特性

00:09:34.007 --> 00:09:37.878 align:middle
因此当手机屏幕面向桌面时

00:09:39.847 --> 00:09:41.215 align:middle
收到一条通知

00:09:42.082 --> 00:09:44.451 align:middle
屏幕不会为处理那个通知而去亮起来

00:09:44.651 --> 00:09:48.088 align:middle
我们让系统尽可能少的做准备工作

00:09:48.155 --> 00:09:51.525 align:middle
这样 只有当用户接电话的时候
通知才被提供给他们

00:09:54.027 --> 00:09:55.596 align:middle
现在开始后续的一些工作

00:09:58.031 --> 00:10:00.300 align:middle
我们做了很多努力去将工作推迟到

00:09:58.031 --> 00:10:00.300 align:middle
我们做了很多努力去将工作推迟到

00:10:00.667 --> 00:10:02.669 align:middle
设备被充电时

00:10:03.504 --> 00:10:09.276 align:middle
进行用户不需要的后台和维持工作
是没有意义的

00:10:09.676 --> 00:10:12.946 align:middle
他们可能是一个日常的活动
所以当给手机充电时可以完成一些操作

00:10:13.013 --> 00:10:16.650 align:middle
因为我们知道用户只会
在一天的某些时候给手机充电

00:10:18.151 --> 00:10:21.722 align:middle
因为人们需要对Wi-Fi付费

00:10:21.855 --> 00:10:24.458 align:middle
所以连接Wi-Fi时
我们同样也可以推迟网络

00:10:25.626 --> 00:10:28.362 align:middle
然后我们甚至更多的
持续利用应用程序接口

00:10:28.695 --> 00:10:31.765 align:middle
使得当接收器开启时

00:10:31.832 --> 00:10:36.537 align:middle
即使接收器在做一些后台工作
我们也可以完成一些相应的工作

00:10:38.839 --> 00:10:42.743 align:middle
现在对于那项工作来说一切都很好
但我们想能更有效率的去完成那项工作

00:10:44.011 --> 00:10:45.179 align:middle
因此让我们做一些改变

00:10:45.612 --> 00:10:47.714 align:middle
我们优化我们的iOS和网络堆栈

00:10:48.182 --> 00:10:52.786 align:middle
去让4G网络
特别是4G接收器工作的更好

00:10:53.887 --> 00:10:55.689 align:middle
我们再一次优化我们的电源管理单元

00:10:55.989 --> 00:10:59.493 align:middle
去减少维持系统
在低功耗状态而产生的消耗

00:11:00.661 --> 00:11:03.330 align:middle
我们已经降低了日志记录机制的消耗

00:11:03.830 --> 00:11:07.201 align:middle
以至于它们不能和系统进行交互

00:11:07.901 --> 00:11:12.706 align:middle
当然我们继续优化
我们的numerics库

00:11:13.173 --> 00:11:15.309 align:middle
使他们更好去优化每一个硬件

00:11:16.043 --> 00:11:18.846 align:middle
我认为明天可能会有
关于那个话题的会议

00:11:22.082 --> 00:11:26.119 align:middle
所以我们谈论一下用户反馈
及怎样添加进Mavericks中

00:11:26.620 --> 00:11:32.626 align:middle
我们已经设置好了电池
使其能够显示你的应用程序的使用方法

00:11:33.760 --> 00:11:38.632 align:middle
或允许给你提供
一些周围环境因素的信息

00:11:38.699 --> 00:11:42.202 align:middle
以及给想提高电池续航的用户一些建议

00:11:43.237 --> 00:11:44.838 align:middle
在这儿已经进入到更进一步的阶段

00:11:45.205 --> 00:11:49.877 align:middle
添加每一个应用屏幕或后台时间...

00:11:51.111 --> 00:11:52.312 align:middle
到这个设置面板上

00:11:53.080 --> 00:11:55.082 align:middle
所以你在角落里可以看到一个控制

00:11:55.349 --> 00:11:56.850 align:middle
让我们回过头继续向前走

00:11:57.417 --> 00:11:59.953 align:middle
你可以看到一个小的控制
可以让您切换模式

00:12:04.992 --> 00:12:07.060 align:middle
然后我们已经添加了低功耗的模式

00:12:09.196 --> 00:12:13.500 align:middle
而用户的偏好也将会影响电池的寿命

00:12:14.568 --> 00:12:17.571 align:middle
它将限制CPU以及后台操作

00:12:17.638 --> 00:12:19.840 align:middle
导致以前我们引入的
后台应用程序刷新机制

00:12:19.907 --> 00:12:21.808 align:middle
在这个模式下失效了

00:12:23.377 --> 00:12:26.747 align:middle
我们关掉自由裁量和后台工作

00:12:27.114 --> 00:12:31.485 align:middle
所以如果你想在后台完成预定的下载
在用户退出前这些行为是不被允许的

00:12:32.853 --> 00:12:34.488 align:middle
邮件获取也被禁用了

00:12:35.122 --> 00:12:38.358 align:middle
是因为如果收发太多的邮件
将会让系统产生一个较大的功耗

00:12:41.161 --> 00:12:43.130 align:middle
我们已经讨论了
关于操作系统的内容

00:12:43.530 --> 00:12:47.034 align:middle
现在让我们谈论一些将会帮助你
提高电池续航能力的事情

00:12:49.069 --> 00:12:53.340 align:middle
我们已经使用了一个相当周到的方式

00:12:54.875 --> 00:12:57.211 align:middle
把OS X上能量计移植到iOS中

00:12:57.277 --> 00:13:02.282 align:middle
从而能量计对iOS产生最显著的影响

00:12:57.277 --> 00:13:02.282 align:middle
从而能量计对iOS产生最显著的影响

00:13:02.349 --> 00:13:08.388 align:middle
系统除了其它的仪器
我们又添加了定位仪

00:13:09.489 --> 00:13:13.193 align:middle
除了改善OS X的能源指南

00:13:13.894 --> 00:13:17.564 align:middle
我们还在网站上写了个
全新的iOS能源指南

00:13:20.200 --> 00:13:22.236 align:middle
现在你能用这个指南做些什么事情呢？

00:13:23.770 --> 00:13:27.107 align:middle
我们希望你能够优化应用程序的功耗

00:13:27.908 --> 00:13:29.643 align:middle
给你一个简单的例子吧

00:13:32.012 --> 00:13:33.547 align:middle
比如你正在全屏播放一个视频

00:13:33.881 --> 00:13:37.084 align:middle
现在让我们做一个优化
很可能像家里的电视那样

00:13:37.351 --> 00:13:38.986 align:middle
减少backlight
调整伽玛补偿

00:13:39.286 --> 00:13:42.856 align:middle
从而给出同样视觉图像

00:13:43.857 --> 00:13:44.691 align:middle
现在

00:13:46.260 --> 00:13:48.362 align:middle
这些措施将会使得功耗少量减少

00:13:48.662 --> 00:13:52.699 align:middle
但是因为时间的因素
节省的功耗是相当可观的

00:13:53.467 --> 00:13:56.003 align:middle
因此你在观看全屏视频的时候

00:13:56.136 --> 00:13:58.972 align:middle
我们也可以得到额外的续航时间
只是在这个机制非常简单

00:13:59.673 --> 00:14:05.345 align:middle
一旦你想在屏幕上放置任何用户界面
这个机制就会失效

00:13:59.673 --> 00:14:05.345 align:middle
一旦你想在屏幕上放置任何用户界面
这个机制就会失效

00:14:06.013 --> 00:14:12.352 align:middle
我们也可以看到全透明用户界面层的
全屏应用程序会完全禁用这个机制

00:14:12.419 --> 00:14:14.021 align:middle
这对于用户没有任何好处

00:14:18.892 --> 00:14:22.029 align:middle
在讨论过OS X后
现在让我们说说iOS

00:14:23.096 --> 00:14:25.232 align:middle
在早些时候我们推出了
的MacBook

00:14:25.532 --> 00:14:27.568 align:middle
因为那是我们
第一个fanless系统

00:14:27.868 --> 00:14:30.137 align:middle
所以它会有点散热的约束

00:14:30.637 --> 00:14:34.575 align:middle
而MacBook被设计为
可以很好的应对突发性的工作负载

00:14:35.209 --> 00:14:39.279 align:middle
我们也已经对操作系统进行优化
让它能与那些机器一起工作

00:14:40.180 --> 00:14:45.219 align:middle
你也应当用适当的线程服务质量去
去标记所有的工作

00:14:46.553 --> 00:14:50.190 align:middle
使用我们已经预装在OS X上
可用的仪表和仪器

00:14:50.557 --> 00:14:52.826 align:middle
可以确保你
利用NSOperation和GCD

00:14:53.727 --> 00:14:55.629 align:middle
来对你的工作进行优先级的考虑

00:14:56.129 --> 00:14:59.566 align:middle
如果现在有用户启动的操作
确保它被尽可能的标记

00:14:59.633 --> 00:15:02.002 align:middle
但是如果它后台工作的话
仍像那样去标记它

00:14:59.633 --> 00:15:02.002 align:middle
但是如果它后台工作的话
仍像那样去标记它

00:15:02.669 --> 00:15:08.108 align:middle
而操作系统在为这些任务
提供更强性能的同时

00:15:08.442 --> 00:15:13.113 align:middle
还会管理
该设备的电源和散热

00:15:17.818 --> 00:15:21.321 align:middle
最后总结一下
我们知道了功耗是功率乘以时间

00:15:21.722 --> 00:15:25.092 align:middle
当你为提高电池续航的能力
在思考怎样优化应用程序的时候

00:15:25.759 --> 00:15:27.895 align:middle
一定要记住时间的因素是非常重要的

00:15:29.062 --> 00:15:30.964 align:middle
硬件的动态范围正在变得更大

00:15:31.231 --> 00:15:36.470 align:middle
因此当你正在操作的时候
必须认真的考虑怎样有效率的完成

00:15:36.737 --> 00:15:40.340 align:middle
进行这些工作时认真考虑
是否这些工作全部需要完成

00:15:41.675 --> 00:15:44.912 align:middle
为了实现全天电池续航

00:15:45.579 --> 00:15:48.715 align:middle
你需要让平均功耗尽可能的低

00:15:49.983 --> 00:15:53.287 align:middle
现在我将会把这个任务交给我的同事
桑仁 去更详细的讨论

00:16:01.862 --> 00:16:03.030 align:middle
早上好
谢谢

00:16:03.397 --> 00:16:05.732 align:middle
真的很高兴看到
你们在这儿学习能量效率的知识

00:16:06.099 --> 00:16:11.438 align:middle
也很希望自己能够帮助你们理解
代码在电池续航中心是怎样工作的

00:16:14.074 --> 00:16:16.410 align:middle
我们将讨论两大类事情

00:16:17.811 --> 00:16:21.582 align:middle
但是首先我们要从一些
強 已经讨论过的原则开始

00:16:21.648 --> 00:16:22.883 align:middle
我们将把这个原则和用户

00:16:22.950 --> 00:16:26.920 align:middle
及用户为何是在你的应用程序上
获取正确的时间关键因素相互联系起来

00:16:27.654 --> 00:16:29.356 align:middle
我们也准备讨论一下能量究竟去了哪里

00:16:29.423 --> 00:16:33.126 align:middle
特别是CPU以及GPU对OS X
和iOS来说都是非常重要的

00:16:35.062 --> 00:16:38.298 align:middle
通过这一部分的讨论
我将会详细的向你们解释

00:16:39.066 --> 00:16:44.371 align:middle
怎样实现较低的平均功耗
从而最终实现全天的电池续航

00:16:45.038 --> 00:16:46.807 align:middle
此外我们也特别的讨论一下iOS

00:16:46.874 --> 00:16:50.143 align:middle
在我们的iOS设备上
你可以利用的许多硬件组件

00:16:50.210 --> 00:16:53.413 align:middle
为了让电池能够全天续航

00:16:53.480 --> 00:16:57.451 align:middle
需要同时注意功率和时间

00:16:57.751 --> 00:17:02.589 align:middle
最后我们谈一下
怎样把这些理论融入在你的开发过程中

00:16:57.751 --> 00:17:02.589 align:middle
最后我们谈一下
怎样把这些理论融入在你的开发过程中

00:17:02.689 --> 00:17:06.226 align:middle
以便每天你都能思考
一点关于功耗的东西

00:17:09.563 --> 00:17:12.398 align:middle
在更进一步讨论之前
我们并不能看到太好的一面

00:17:12.766 --> 00:17:15.435 align:middle
但是如果你家的某个地方有个LED灯
请举起你的手

00:17:16.670 --> 00:17:19.039 align:middle
好的 你们应该知道什么是LED灯
很好

00:17:19.373 --> 00:17:21.775 align:middle
你们家里可能还会留着一些白炽灯
我家确实还留着一些

00:17:21.842 --> 00:17:23.644 align:middle
最近我把冰箱中的白炽灯换掉了

00:17:23.710 --> 00:17:25.679 align:middle
而如果在冰箱中放LED灯泡
则很有意思

00:17:29.183 --> 00:17:31.585 align:middle
请不在家时仍然让灯
一直开的人举起你的手

00:17:33.353 --> 00:17:34.922 align:middle
好的 有一个人是那样做的

00:17:34.988 --> 00:17:37.758 align:middle
他是我的办公室同事
我准备给他一个艰难的时刻

00:17:38.392 --> 00:17:40.894 align:middle
他在办公室时并不是让灯一直开的人

00:17:42.863 --> 00:17:47.000 align:middle
关键是当我们换了LED灯的时候
功率可以明显的降下来

00:17:47.601 --> 00:17:50.070 align:middle
而且我们也不会让它们整天运行
不用的时候也会把它关掉

00:17:50.137 --> 00:17:51.271 align:middle
这样的话时间也降下来了

00:17:52.339 --> 00:17:54.174 align:middle
在你的屋子里可能有很多的设备

00:17:54.408 --> 00:17:57.578 align:middle
网络 DVR甚至计算机和服务器

00:17:58.212 --> 00:17:59.646 align:middle
而这些设备都将会整天运行

00:17:59.713 --> 00:18:02.249 align:middle
因为它们并不像灯泡那样点着
或许你并不会关注它们

00:17:59.713 --> 00:18:02.249 align:middle
因为它们并不像灯泡那样点着
或许你并不会关注它们

00:18:02.349 --> 00:18:05.552 align:middle
而我准备帮助你们
在软件的角度去思考这些问题

00:18:05.686 --> 00:18:10.057 align:middle
因为最终是软件来控制硬件上
所有灯的开关

00:18:10.290 --> 00:18:13.026 align:middle
所以为了实现电池的全天续航
我们必须让灯的开关

00:18:13.093 --> 00:18:14.795 align:middle
在绝大部分的时间中都处于关闭的状态

00:18:15.062 --> 00:18:17.097 align:middle
那么让我们谈论一下具体的措施

00:18:17.831 --> 00:18:20.734 align:middle
因为最终我们的目的
就是完成用户驱动的工作

00:18:21.134 --> 00:18:23.837 align:middle
所以我们也希望用户
能从电池的能量中获益

00:18:23.904 --> 00:18:24.738 align:middle
他们已经实现了

00:18:25.472 --> 00:18:29.176 align:middle
软件在很多时候都是很相似的

00:18:29.309 --> 00:18:30.878 align:middle
我现在有一些事情去处理
我能去做吗？

00:18:30.944 --> 00:18:32.880 align:middle
哦 是的 可以
让我们再一次完成它

00:18:33.580 --> 00:18:34.548 align:middle
不 不 不

00:18:35.249 --> 00:18:37.651 align:middle
我们必须消除
任何类型的轮询或者计时器

00:18:37.918 --> 00:18:41.355 align:middle
计算机操作的比人类更加的快

00:18:41.655 --> 00:18:43.290 align:middle
确切的说在键击之间

00:18:43.590 --> 00:18:45.692 align:middle
即使你是一个超快的打字
一分钟可以打一百个字

00:18:45.759 --> 00:18:48.262 align:middle
在微秒时间尺度的键击之间

00:18:48.662 --> 00:18:52.866 align:middle
我们仍然可以闲置部分系统
处理器将会在按键间隙处于休眠状态

00:18:53.267 --> 00:18:55.636 align:middle
而当用户利用键盘 鼠标
和计算机进行交互的间隙

00:18:56.403 --> 00:18:59.540 align:middle
对计算机来说仍有很多的运行时间

00:18:59.606 --> 00:19:03.510 align:middle
所以你希望你的软件不要
按照计算机运行的速度运行

00:18:59.606 --> 00:19:03.510 align:middle
所以你希望你的软件不要
按照计算机运行的速度运行

00:19:04.011 --> 00:19:06.380 align:middle
除非它直接为用户工作

00:19:08.015 --> 00:19:10.050 align:middle
你回应用户
那样很棒

00:19:10.284 --> 00:19:13.320 align:middle
使用我们超强的硬件
然后回到空闲状态

00:19:13.921 --> 00:19:15.455 align:middle
变得完全平坦
最后归零

00:19:17.958 --> 00:19:19.560 align:middle
強 已经讨论过延时工作了

00:19:19.793 --> 00:19:22.196 align:middle
很多时候你可以无限期的延时工作

00:19:22.262 --> 00:19:23.163 align:middle
我现在需要延时吗？

00:19:23.230 --> 00:19:25.532 align:middle
并不需要
稍后或许会用到

00:19:26.600 --> 00:19:28.235 align:middle
但总的来说结果就是我们不需要延时

00:19:28.535 --> 00:19:29.636 align:middle
如果现在有少量的任务

00:19:30.137 --> 00:19:32.072 align:middle
而现在用户不需要它

00:19:32.139 --> 00:19:35.642 align:middle
那么最好将其推迟
可以说

00:19:36.210 --> 00:19:40.013 align:middle
“嗨 系统 请完成这个
如果有计时器的话”

00:19:40.080 --> 00:19:41.548 align:middle
在下个小时的任何时刻

00:19:41.615 --> 00:19:44.651 align:middle
希望你能给出十分钟
或者其它有余量的时间

00:19:45.786 --> 00:19:47.554 align:middle
如果没有计时器的话
那么只能完成上传和下载了

00:19:47.621 --> 00:19:49.690 align:middle
因为系统在随后可能会安排其他

00:19:50.123 --> 00:19:51.658 align:middle
可能发生的工作

00:19:52.059 --> 00:19:53.794 align:middle
你也可以把所有的任务集中在一起

00:19:54.695 --> 00:19:58.465 align:middle
因为批处理是获得效率的重要途径

00:19:58.665 --> 00:20:01.001 align:middle
你想打开那个硬件
但是把它打开需要一些功耗

00:19:58.665 --> 00:20:01.001 align:middle
你想打开那个硬件
但是把它打开需要一些功耗

00:20:01.068 --> 00:20:04.738 align:middle
而你希望在它被关闭之前去使用它

00:20:04.805 --> 00:20:07.708 align:middle
需要在硬件开启状态下
尽可能多的完成工作

00:20:08.208 --> 00:20:13.947 align:middle
我们能再一次降低功耗
节省时间是很重要的因素

00:20:14.715 --> 00:20:18.519 align:middle
这是我特别指出的有趣的关键信息

00:20:18.585 --> 00:20:22.122 align:middle
我们有所有的可用能源
但是你不能在电池上整天的运行

00:20:22.322 --> 00:20:24.858 align:middle
否则设备会变得很热
而且电池也不能持续运行

00:20:25.425 --> 00:20:31.031 align:middle
我们真正想让你考虑的是
占用整个系统10%的负载

00:20:31.131 --> 00:20:34.101 align:middle
这些负载不仅是软件
还包括你所做的其它操作

00:20:34.535 --> 00:20:38.038 align:middle
那么你怎样才能利用你可以实现的措施

00:20:38.305 --> 00:20:42.009 align:middle
把负载降到1/10或1/100呢

00:20:42.376 --> 00:20:44.978 align:middle
这是当你在屏幕上的情况
当你后台的时候 我们需要的更少

00:20:46.180 --> 00:20:47.614 align:middle
这里我要说一个比较坏的消息

00:20:48.081 --> 00:20:50.918 align:middle
我也对我们所有的硬件
做过一些这方面的研究

00:20:50.984 --> 00:20:52.819 align:middle
人们表现出就像...
哦不对

00:20:52.886 --> 00:20:55.689 align:middle
这也不是谈话的要点
关键在于让你去思考这个问题

00:20:56.623 --> 00:21:00.761 align:middle
大概百分之十到百分之五的负载之间
是仅在打开显示器时产生的

00:20:56.623 --> 00:21:00.761 align:middle
大概百分之十到百分之五的负载之间
是仅在打开显示器时产生的

00:21:01.828 --> 00:21:03.297 align:middle
现在显示器打开之后的状态良好

00:21:03.363 --> 00:21:07.201 align:middle
因为用户正在从系统中得到更多的好处
所以这有很大的希望不仅仅是一个通知

00:21:09.503 --> 00:21:11.038 align:middle
然后有百分之十的目标

00:21:11.672 --> 00:21:13.307 align:middle
这就是平均水平

00:21:13.373 --> 00:21:14.942 align:middle
这听起来就像只实现了5%

00:21:15.275 --> 00:21:17.244 align:middle
在长周期下的确如此

00:21:17.578 --> 00:21:20.013 align:middle
但在短时间内争取100%

00:21:20.180 --> 00:21:22.883 align:middle
将你完成的工作优先呈现出来

00:21:22.983 --> 00:21:25.452 align:middle
我们将会安排它

00:21:26.353 --> 00:21:29.523 align:middle
这部分就是这样 你必须让它
处于百分之5到百分之10之间

00:21:30.824 --> 00:21:34.094 align:middle
现在让我们讨论一下CPU和GPU

00:21:34.161 --> 00:21:38.198 align:middle
在OS X中CPU和GPU
会消耗大部分的能量

00:21:39.199 --> 00:21:40.133 align:middle
它们也是最具活力的

00:21:40.200 --> 00:21:46.640 align:middle
我们有非常强大的多核CPU
和大规模并行GPU完成各样任务

00:21:47.241 --> 00:21:49.209 align:middle
然而如果你把设备插入电源的话

00:21:49.776 --> 00:21:52.212 align:middle
CPU和GPU一般来说
确实会消耗电池很多能量

00:21:52.779 --> 00:21:55.182 align:middle
在这儿你已经可以看到
我们已经完成了大部分工作

00:21:55.249 --> 00:21:58.018 align:middle
我们已经让CPU开始运行了
同时也让GPU运行一会儿

00:21:58.218 --> 00:22:00.921 align:middle
而事实上这并不会持续一整天

00:21:58.218 --> 00:22:00.921 align:middle
而事实上这并不会持续一整天

00:22:01.121 --> 00:22:05.225 align:middle
但如果这个对于
你工作方式非常重要的模式

00:22:05.626 --> 00:22:08.262 align:middle
如果这个模式持续的话
将会使得我们不能实现全天续航

00:22:08.328 --> 00:22:10.197 align:middle
因为平均功耗太高了

00:22:14.034 --> 00:22:16.236 align:middle
那么我们仅唤醒CPU又会怎么样呢？

00:22:16.503 --> 00:22:18.172 align:middle
是否有工作要做？
是否有工作要做？

00:22:18.238 --> 00:22:19.640 align:middle
是否有邮件？
用户是否点击过？

00:22:19.706 --> 00:22:20.741 align:middle
有没有什么事情发生？

00:22:21.542 --> 00:22:22.376 align:middle
嗨 服务器

00:22:23.210 --> 00:22:24.044 align:middle
不要那样做

00:22:24.111 --> 00:22:25.679 align:middle
当唤醒CPU或者GPU时

00:22:26.513 --> 00:22:29.483 align:middle
我们需要大量的能量去让他们加速

00:22:32.419 --> 00:22:33.353 align:middle
有工作要做么？

00:22:35.722 --> 00:22:36.557 align:middle
没有收到任何工作

00:22:38.458 --> 00:22:41.495 align:middle
所有你能看到的这些三角形
即使是iOS的三角形

00:22:41.562 --> 00:22:44.731 align:middle
也在5%到10%的范围中
占据了很重要的一部分

00:22:46.300 --> 00:22:47.901 align:middle
不要尝试不必要的唤醒

00:22:48.502 --> 00:22:50.237 align:middle
在OS X上如果你整天唤醒CPU

00:22:50.304 --> 00:22:52.139 align:middle
那么事实上你的电池
根本不能实现全天续航

00:22:52.206 --> 00:22:54.641 align:middle
即使你不运行
甚至只是做一些检查工作

00:22:55.108 --> 00:22:55.943 align:middle
不要那样做

00:22:56.009 --> 00:22:59.546 align:middle
GPU是一个时间尺度略有不同的怪物

00:23:00.848 --> 00:23:03.116 align:middle
它工作的频率比
你需要唤醒GPU的频率更高

00:23:03.183 --> 00:23:05.953 align:middle
甚至对于一些漂亮的图形

00:23:06.019 --> 00:23:09.389 align:middle
在下一帧之前需要15ms

00:23:09.456 --> 00:23:12.860 align:middle
然而在1ms之内
GPU已经可以完成大量的工作了

00:23:15.562 --> 00:23:16.797 align:middle
现在让我们讨论一下性能

00:23:17.564 --> 00:23:19.666 align:middle
你来到这里的目的是关注能源性能

00:23:20.100 --> 00:23:22.336 align:middle
而且你做事的时间效率也更高
完成任务的时间更快

00:23:22.402 --> 00:23:26.139 align:middle
这些对用户是有好处的
对能源的效率也是一个关键因素

00:23:26.306 --> 00:23:27.207 align:middle
现在让我解释其原因

00:23:29.142 --> 00:23:31.144 align:middle
这里是一个工作负载
而是一个固定的工作负载

00:23:31.211 --> 00:23:32.779 align:middle
它的状态也不能持续下去

00:23:32.846 --> 00:23:34.548 align:middle
我只需要完成这个工作

00:23:35.949 --> 00:23:37.050 align:middle
但是它的工作负载很大

00:23:37.451 --> 00:23:38.952 align:middle
因此我可能需要优化我的代码

00:23:39.019 --> 00:23:41.622 align:middle
可以访问代码的内部循环

00:23:41.688 --> 00:23:44.791 align:middle
做更少的内存访问和传统的性能工作

00:23:45.592 --> 00:23:47.227 align:middle
这样就会使得执行更加的有效率

00:23:47.895 --> 00:23:48.962 align:middle
但功率增加了

00:23:49.496 --> 00:23:52.065 align:middle
然而时间却又变短了

00:23:52.399 --> 00:23:54.034 align:middle
从而功耗可以大幅的降低

00:23:54.468 --> 00:23:56.570 align:middle
前面的工作做的非常好
但是我们能做的更好

00:23:56.670 --> 00:24:00.174 align:middle
可以将工作并行化
并使用多核

00:23:56.670 --> 00:24:00.174 align:middle
可以将工作并行化
并使用多核

00:24:00.607 --> 00:24:03.610 align:middle
最后我们可以更疯狂一点
让GPU跑起来

00:24:04.344 --> 00:24:07.881 align:middle
现在的好消息就是
通常你并不需要写优化代码

00:24:07.948 --> 00:24:09.750 align:middle
但是你却需要找到这个优化代码

00:24:09.816 --> 00:24:12.152 align:middle
你需要找到这些优化的数字库

00:24:12.653 --> 00:24:15.722 align:middle
在后面我们有一个
关于会议和能源文件的链接

00:24:16.356 --> 00:24:20.694 align:middle
你必须找到正确的数据结构
然后审视一下你的应用程序

00:24:21.028 --> 00:24:25.499 align:middle
最后谈一下为什么我一直在搅动
及在规则的旧时间中我又能够优化什么

00:24:27.968 --> 00:24:29.403 align:middle
这幅图片中的东西是很重要的

00:24:30.304 --> 00:24:33.607 align:middle
那是直接执行的低功耗解决方案

00:24:33.674 --> 00:24:35.475 align:middle
在这个方案中系统就像开始工作一样

00:24:35.542 --> 00:24:37.344 align:middle
而你只需要一等等待存储和加载

00:24:37.411 --> 00:24:38.846 align:middle
你已经让一个核心运行了

00:24:39.279 --> 00:24:41.148 align:middle
如果我们让多核都运行的话

00:24:41.281 --> 00:24:44.084 align:middle
那我们才是真正的在使用该系统
但如果只有单核情况会怎么样呢？

00:24:44.318 --> 00:24:48.155 align:middle
因为时间的因素只会导致
虽然功率很低但是功耗却很大

00:24:50.424 --> 00:24:53.594 align:middle
现在让我们研究一下为什么会这样

00:24:53.961 --> 00:24:57.898 align:middle
在运行系统的其他部分的时候

00:24:57.965 --> 00:24:59.933 align:middle
无论CPU GPU
或是系统的其它部分

00:25:00.868 --> 00:25:03.003 align:middle
固定功耗都会慢慢增加

00:25:03.403 --> 00:25:06.106 align:middle
你越快把这些固定消耗关掉
效果自然就越好

00:25:06.807 --> 00:25:09.943 align:middle
我自己也为GPU增加以下额外的功耗

00:25:10.010 --> 00:25:12.913 align:middle
因为事实上在使用GPU的过程中
会产生更多的功耗

00:25:12.980 --> 00:25:15.782 align:middle
观察绿色的部分我们看出

00:25:16.383 --> 00:25:19.453 align:middle
当我们节省时间之后
是否使用了更少的能量

00:25:21.655 --> 00:25:24.725 align:middle
关键课程
高速也是能源效率

00:25:25.759 --> 00:25:27.394 align:middle
我们在看这些在线下是否满足的时候

00:25:27.728 --> 00:25:29.830 align:middle
请谨记按照重要性排列

00:25:31.031 --> 00:25:32.833 align:middle
这是最直接的一个措施

00:25:33.233 --> 00:25:36.937 align:middle
因为任何一个熟悉高中几何的
都很清楚那并不满足

00:25:37.638 --> 00:25:39.072 align:middle
我们会把它拉到平均水平

00:25:39.139 --> 00:25:40.507 align:middle
在这里不再是功率乘以时间

00:25:40.574 --> 00:25:41.408 align:middle
这只是平均水平

00:25:42.109 --> 00:25:42.943 align:middle
将不再适合

00:25:43.477 --> 00:25:44.545 align:middle
至于其他的

00:25:44.878 --> 00:25:47.414 align:middle
注意
效率有所提高

00:25:48.315 --> 00:25:49.316 align:middle
但是依然不够

00:25:50.150 --> 00:25:53.520 align:middle
可以看到除了CPU/GPU
平行线几乎都在线下

00:25:53.720 --> 00:25:56.490 align:middle
因为时间很短
所以确实满足条件

00:25:56.557 --> 00:25:59.126 align:middle
同时虽然功率很高
但时间很短

00:25:59.193 --> 00:26:00.794 align:middle
这些就是你在设计程序
要遵从的方法

00:25:59.193 --> 00:26:00.794 align:middle
这些就是你在设计程序
要遵从的方法

00:26:00.861 --> 00:26:03.864 align:middle
但是不要重复的使用这些措施

00:26:04.431 --> 00:26:06.166 align:middle
在你做这些之前请稍等一下你的用户

00:26:09.436 --> 00:26:10.671 align:middle
现在让我们调整一下

00:26:10.971 --> 00:26:13.640 align:middle
这些是应用在OS X和iOS的
所有CPU和GPU

00:26:13.774 --> 00:26:16.643 align:middle
而它们对OS X尤其重要

00:26:16.743 --> 00:26:18.812 align:middle
此外我们在衡量能量
对OS X的影响时

00:26:18.879 --> 00:26:20.614 align:middle
除了系统可以处理的CPU指令

00:26:20.814 --> 00:26:23.283 align:middle
还可以通过人们可以唤醒系统的次数

00:26:24.051 --> 00:26:28.021 align:middle
现在让我们切换到iOS

00:26:28.555 --> 00:26:31.625 align:middle
我们知道iOS设备
不仅有CPU和GPU性能非常强悍

00:26:32.159 --> 00:26:37.197 align:middle
而且iOS的网络定位
和后台运行的能力也很强大

00:26:43.036 --> 00:26:47.975 align:middle
其中网络的功率很大
大量的硬件网络

00:26:48.642 --> 00:26:52.012 align:middle
此外还涉及到很重要的时间组件
也需要详细考虑

00:26:53.013 --> 00:26:56.049 align:middle
定位是一个很好的功能
用起来很棒

00:26:56.383 --> 00:26:57.718 align:middle
但是它主要的设计目的

00:26:58.118 --> 00:26:59.586 align:middle
比如我正在观察地图上的一个点

00:26:59.653 --> 00:27:01.722 align:middle
此时我准备穿过舞台
而小点也相应的跟着移动

00:26:59.653 --> 00:27:01.722 align:middle
此时我准备穿过舞台
而小点也相应的跟着移动

00:27:01.788 --> 00:27:05.192 align:middle
我很喜欢这个功能让人印象非常深刻
可以告诉我自己正在穿过舞台

00:27:07.261 --> 00:27:10.130 align:middle
不幸的是这个应用程序的接口
很容易被留下继续运行

00:27:10.531 --> 00:27:11.765 align:middle
甚至当我不在看地图的时候

00:27:12.299 --> 00:27:16.270 align:middle
因此我需要除了改进应用程序的接口

00:27:16.670 --> 00:27:20.407 align:middle
我们也需要你在自己需要的最短
时间之内去使用定位

00:27:21.074 --> 00:27:23.677 align:middle
最终任何时刻都在后台运行

00:27:24.378 --> 00:27:27.414 align:middle
那就会使得设备

00:27:29.249 --> 00:27:32.286 align:middle
增加了保持唤醒的时间

00:27:32.486 --> 00:27:34.888 align:middle
每次我按屏幕上的home键
离开你的应用程序的时候

00:27:35.189 --> 00:27:37.658 align:middle
你都在后台运行
可能时间很短也许时间会很长

00:27:38.692 --> 00:27:40.827 align:middle
我们希望尽可能的消除这种情况

00:27:40.894 --> 00:27:43.597 align:middle
因为我们希望设备
能保持在良好的待机状态

00:27:44.031 --> 00:27:47.201 align:middle
从而使得设备的随机存储器和接收器
可以保持在一个低功耗的模式下

00:27:48.769 --> 00:27:50.470 align:middle
让我们讨论一下网络

00:27:51.939 --> 00:27:54.041 align:middle
幻灯片橘色的部分状态不好

00:27:54.575 --> 00:27:55.642 align:middle
因为它代表的是消耗

00:27:56.577 --> 00:28:01.014 align:middle
思考一下
当你想向网络上特别是蜂窝设备

00:27:56.577 --> 00:28:01.014 align:middle
思考一下
当你想向网络上特别是蜂窝设备

00:28:01.081 --> 00:28:03.817 align:middle
发送一些数据的时候会发生什么

00:28:04.651 --> 00:28:08.522 align:middle
系统可能会说“我现在必须发送数据
因为应用程序告诉我的”

00:28:09.489 --> 00:28:12.893 align:middle
不要把它标记为后台任务
它不可延迟 必须立即完成

00:28:13.894 --> 00:28:17.865 align:middle
我们之间没有连接起来
只是通过入站连接与蜂窝系统联系

00:28:18.131 --> 00:28:19.366 align:middle
但是我们没有出站

00:28:20.300 --> 00:28:21.201 align:middle
所以举起来

00:28:21.735 --> 00:28:24.404 align:middle
找到一个基站
已经找到基站

00:28:24.471 --> 00:28:26.106 align:middle
但是总体情况并不太好
尝试另一个

00:28:26.540 --> 00:28:28.442 align:middle
这个基站非常好

00:28:28.809 --> 00:28:29.910 align:middle
我们连上了

00:28:29.977 --> 00:28:32.279 align:middle
好的 我发送一些数据
好的 数据发送了

00:28:34.681 --> 00:28:36.517 align:middle
没有数据发送了 但是仍然连接着

00:28:36.750 --> 00:28:38.519 align:middle
连接时的代价很高
当我把设备打开时

00:28:39.152 --> 00:28:40.988 align:middle
按照蜂窝网络的工作方式

00:28:41.054 --> 00:28:43.724 align:middle
我必须让它运行一到两秒

00:28:44.424 --> 00:28:47.828 align:middle
它可能只需要几毫秒时间去发送数据

00:28:47.995 --> 00:28:50.697 align:middle
但它可能需要停留长达10秒
去连接到网络

00:28:51.031 --> 00:28:52.699 align:middle
显然不是高功率模式

00:28:52.766 --> 00:28:56.170 align:middle
但是功率仍远高于输入连接的闲置等待

00:28:56.870 --> 00:28:59.540 align:middle
因此消耗是一个重要的能源影响

00:29:00.207 --> 00:29:02.876 align:middle
正在运行的网络工作量大小并不重要

00:29:03.210 --> 00:29:06.647 align:middle
在某些情况下如果接收机关闭的话
必须重启后运行

00:29:07.047 --> 00:29:11.385 align:middle
耗费的时间比你实际上
需要发送数据的时间长一千倍

00:29:12.486 --> 00:29:16.056 align:middle
而且没有任何方法能降低功率至预期值

00:29:16.223 --> 00:29:19.359 align:middle
收音机不能一直开启
去实现全天续航的目标

00:29:20.694 --> 00:29:22.129 align:middle
这对聊天应用程序是一个坏消息

00:29:22.863 --> 00:29:27.034 align:middle
好消息是人们并不会在他们的手机上
点击聊天应用程序长达10个小时

00:29:27.100 --> 00:29:27.935 align:middle
他们不会这样的

00:29:28.168 --> 00:29:30.037 align:middle
因此只要你能够明白

00:29:30.103 --> 00:29:33.941 align:middle
如果没有实时聊天让网络继续下去

00:29:35.175 --> 00:29:36.810 align:middle
那么你就可以让电池实现全天续航

00:29:38.378 --> 00:29:40.347 align:middle
我们如何解决这个问题
我们怎样让它更好

00:29:40.714 --> 00:29:42.683 align:middle
因为它们不是一天可以解决的事情
难度很高

00:29:44.151 --> 00:29:48.021 align:middle
我们必须通过合并把它们组合在一起
通过批处理的方式去解决它

00:29:48.622 --> 00:29:50.824 align:middle
所以在这个特殊的例子里

00:29:50.891 --> 00:29:53.360 align:middle
我们将会把未来的工作
纳入到旧的工作中

00:29:53.427 --> 00:29:55.963 align:middle
如今将来的工作更加的重要

00:29:56.029 --> 00:29:58.665 align:middle
所以你应当推迟以前的工作
那样可能更容易去完成目标

00:29:58.765 --> 00:30:01.568 align:middle
但是如果你想了解那两项工作
究竟哪一个更重要

00:29:58.765 --> 00:30:01.568 align:middle
但是如果你想了解那两项工作
究竟哪一个更重要

00:30:01.969 --> 00:30:05.205 align:middle
对于你的应用程序来说目标就是
现在你可以实现哪一个

00:30:05.272 --> 00:30:07.107 align:middle
现在我们将这些很棒的工具展示给你

00:30:07.274 --> 00:30:12.579 align:middle
基本上在Xcode上的这些图形
图形表示的新工具都将装在你的软件上

00:30:12.846 --> 00:30:13.680 align:middle
它非常好

00:30:14.414 --> 00:30:17.885 align:middle
你可以看一下再谈谈为什么我要去做
这些没有必要 也许没有必要的事情

00:30:18.785 --> 00:30:21.388 align:middle
为什么我的网络模式没有一点效率

00:30:21.555 --> 00:30:23.490 align:middle
为什么它时分散的？
我怎样才能通力合作？

00:30:23.891 --> 00:30:27.828 align:middle
然后我们才能真正达到这个目标
平均低功耗

00:30:28.195 --> 00:30:29.363 align:middle
那就意味着全天的续航

00:30:30.130 --> 00:30:32.132 align:middle
因此对网络进行总结

00:30:32.566 --> 00:30:35.035 align:middle
如果你想在网络上做更少的工作

00:30:35.769 --> 00:30:37.971 align:middle
就必须正确的设计你的系统

00:30:39.239 --> 00:30:42.809 align:middle
即使你有一分钟的网络
这只增加了几秒钟的消耗

00:30:43.177 --> 00:30:47.981 align:middle
此外 除非用户请求你现在访问网络

00:30:48.615 --> 00:30:52.419 align:middle
否则直到确实重要的事情
请不要访问网络

00:30:53.253 --> 00:30:56.857 align:middle
就设计来说 对于卸载系统

00:30:56.924 --> 00:30:59.026 align:middle
以及让系统决定什么时候

00:30:59.092 --> 00:31:03.463 align:middle
在接下来的十分钟内
下一个小时 下一个二十四小时

00:30:59.092 --> 00:31:03.463 align:middle
在接下来的十分钟内
下一个小时 下一个二十四小时

00:31:04.264 --> 00:31:07.201 align:middle
怎样变化来说你所能做的就是对允许
我们对任务进行批量处理

00:31:07.267 --> 00:31:08.869 align:middle
使得你卸载网络

00:31:08.936 --> 00:31:12.673 align:middle
当工作完成的时候
我们将会给你打电话叫醒你

00:31:15.442 --> 00:31:17.778 align:middle
很多时候 你可以在工作的时候等待

00:31:18.612 --> 00:31:21.748 align:middle
背景更新 NSURLSession
都有这个特性

00:31:22.015 --> 00:31:23.417 align:middle
只要等着 推迟它

00:31:24.051 --> 00:31:25.452 align:middle
去排队吧 这很好

00:31:26.086 --> 00:31:27.788 align:middle
但不要强迫它马上发生

00:31:29.356 --> 00:31:33.393 align:middle
这些通知很棒

00:31:33.927 --> 00:31:36.496 align:middle
但是它们有时候也会脱离控制

00:31:36.563 --> 00:31:37.865 align:middle
比如在服务器端

00:31:37.931 --> 00:31:41.535 align:middle
记得我曾提到过我们总是和
进站连接服务器相连接么

00:31:41.602 --> 00:31:42.603 align:middle
強 也提到过

00:31:44.071 --> 00:31:45.172 align:middle
入站连接很便宜

00:31:45.239 --> 00:31:46.673 align:middle
它们基本上都是可靠的

00:31:46.974 --> 00:31:51.278 align:middle
所以继续发送一些信息而不是轮询

00:31:51.578 --> 00:31:55.148 align:middle
最好把一些信息发送出去
而且把这些通知标记为PushKit

00:31:55.582 --> 00:31:58.552 align:middle
有了一个适当的优先级
这样我们就可以批量处理了

00:31:58.619 --> 00:32:02.022 align:middle
而当我得到一个即时消息的时候
迅速地完成是最重要的

00:31:58.619 --> 00:32:02.022 align:middle
而当我得到一个即时消息的时候
迅速地完成是最重要的

00:32:02.089 --> 00:32:05.692 align:middle
也可能是把
带有新内容的通知下载到你的

00:32:05.759 --> 00:32:07.394 align:middle
新应用程序或者其他类似的东西上

00:32:08.962 --> 00:32:10.664 align:middle
现在让我们讨论一下定位

00:32:12.799 --> 00:32:17.171 align:middle
定位也有两个要素
好消息是定位的功率相对较低

00:32:17.638 --> 00:32:19.640 align:middle
如果你让定位一直运行

00:32:19.706 --> 00:32:22.109 align:middle
那么只会有很少的空间去做其他的事情

00:32:22.176 --> 00:32:24.311 align:middle
因此不要让精确定位一直运行

00:32:24.778 --> 00:32:26.580 align:middle
事实上 最好不要一直运行定位

00:32:26.647 --> 00:32:33.520 align:middle
除非用户确实希望在生活中
一直运行定位程序

00:32:33.587 --> 00:32:36.023 align:middle
他们会看你的电池目录

00:32:36.089 --> 00:32:38.325 align:middle
从而知道 后台定位会占用...

00:32:39.526 --> 00:32:40.594 align:middle
25%的电池

00:32:40.794 --> 00:32:41.628 align:middle
那样并不好

00:32:41.828 --> 00:32:43.363 align:middle
除非你的应用程序就是那样

00:32:43.664 --> 00:32:44.631 align:middle
那很好

00:32:46.900 --> 00:32:48.936 align:middle
如此精确的定位是很昂贵的

00:32:49.002 --> 00:32:50.971 align:middle
我们必须打开更多的硬件
与卫星对话

00:32:51.038 --> 00:32:52.773 align:middle
联系所有的卫星

00:32:52.840 --> 00:32:53.740 align:middle
完成

00:32:56.410 --> 00:32:58.712 align:middle
不精确的定位便宜很多
我们只能说

00:32:58.779 --> 00:33:01.215 align:middle
我已连接哪个Wi-Fi网络
我附近的基站是什么

00:32:58.779 --> 00:33:01.215 align:middle
我已连接哪个Wi-Fi网络
我附近的基站是什么

00:33:01.748 --> 00:33:02.716 align:middle
然后我们才能真正

00:33:02.783 --> 00:33:06.353 align:middle
你看到的绿色正是系统运行的地方
显示正在运行

00:33:06.420 --> 00:33:08.822 align:middle
虽然我们的系统大部分是关闭的

00:33:09.156 --> 00:33:11.458 align:middle
但是仍然在跟踪你的位置
甚至精确定位

00:33:11.525 --> 00:33:12.359 align:middle
它不是免费的

00:33:12.426 --> 00:33:14.695 align:middle
不会一直运行
这些是漏洞

00:33:14.761 --> 00:33:16.797 align:middle
从而使得我可以确定你在家里

00:33:17.197 --> 00:33:18.765 align:middle
特别是加利福利亚居民

00:33:20.834 --> 00:33:22.102 align:middle
定位只不过是滴、滴、滴

00:33:22.603 --> 00:33:24.805 align:middle
因此我们可以优化它

00:33:25.906 --> 00:33:26.740 align:middle
尽量少用它

00:33:26.874 --> 00:33:28.976 align:middle
你知道 如果你准备去申请更新定位

00:33:29.176 --> 00:33:30.143 align:middle
请不要马上申请

00:33:30.210 --> 00:33:32.679 align:middle
那有一些应用程序
当我启动时我想知道我的位置

00:33:32.746 --> 00:33:34.681 align:middle
我想知道公交车什么时候来

00:33:35.682 --> 00:33:36.517 align:middle
那很好

00:33:36.583 --> 00:33:39.219 align:middle
我周围的食物网络应用程序 很棒

00:33:39.453 --> 00:33:40.821 align:middle
启动 获取位置

00:33:41.154 --> 00:33:44.591 align:middle
否则等待用户去搜索
或者无论你需要什么

00:33:45.125 --> 00:33:48.996 align:middle
然后尽快为用户完成设置
你已经得到了你想要的精确定位

00:33:49.263 --> 00:33:50.097 align:middle
然后去申请停止

00:33:51.331 --> 00:33:54.801 align:middle
对iOS 9来说 我们已经引入了
新的应用程序接口来完成这些任务

00:33:54.868 --> 00:33:56.170 align:middle
这被称为请求定位

00:33:56.937 --> 00:33:58.338 align:middle
它通过启动和停止

00:33:58.405 --> 00:34:00.474 align:middle
确保你得到适当的精度

00:33:58.405 --> 00:34:00.474 align:middle
确保你得到适当的精度

00:34:00.741 --> 00:34:04.745 align:middle
你也不必管理开始和停止
这种情况只对iOS 9种适用

00:34:04.811 --> 00:34:07.181 align:middle
对老版的操作系统仍然要按照
以前的方法去操作

00:34:07.481 --> 00:34:09.616 align:middle
在幻灯片的结尾有关于定位讨论的链接

00:34:10.684 --> 00:34:15.121 align:middle
我们改变了系统中后台定位的行为方式

00:34:15.188 --> 00:34:17.958 align:middle
因此你的应用程序可以请求
使用后台定位

00:34:18.192 --> 00:34:21.628 align:middle
但在请求被允许之前
可能会和用户有更多的交互

00:34:22.029 --> 00:34:25.232 align:middle
如果不想再后台使用的话
你必须对你的应用程序谨慎一点

00:34:25.866 --> 00:34:28.835 align:middle
保持允许后台定位更新的属性

00:34:29.136 --> 00:34:32.940 align:middle
除非当你在后台中积极的完成它
否则就把它设置为假

00:34:33.739 --> 00:34:36.310 align:middle
当你打开硬件定位的时候
要能够意识到

00:34:36.376 --> 00:34:38.779 align:middle
就像打开电灯开关一样
你实际上在给它供电

00:34:38.846 --> 00:34:40.848 align:middle
切换状态也是非常容易的

00:34:42.416 --> 00:34:44.985 align:middle
当你实际使用它的时候
想把功耗降下来

00:34:45.052 --> 00:34:46.920 align:middle
当我们讨论到时间的时说到要节省时间

00:34:47.353 --> 00:34:48.388 align:middle
当涉及把功率降下来

00:34:48.922 --> 00:34:50.657 align:middle
我提到过我们实际上可以卸载

00:34:50.724 --> 00:34:53.025 align:middle
所以让我们说一下我们正在做的
我喜欢自行车

00:34:53.260 --> 00:34:56.996 align:middle
我可以跟踪我的自行车
你知道 非常准确

00:34:57.297 --> 00:34:59.466 align:middle
但那是硬件而不是软件

00:34:59.533 --> 00:35:04.538 align:middle
所以推迟那些更新
所以每15分钟就会打电话给你

00:34:59.533 --> 00:35:04.538 align:middle
所以推迟那些更新
所以每15分钟就会打电话给你

00:35:04.605 --> 00:35:07.207 align:middle
嘿 看 这里是所有的跟踪信息

00:35:07.508 --> 00:35:10.477 align:middle
但是大多数系统和你的软件都在休眠

00:35:10.544 --> 00:35:12.646 align:middle
只有定位芯片在运行

00:35:14.414 --> 00:35:16.783 align:middle
最后 我们第三个因素
对调试软件来说

00:35:16.850 --> 00:35:19.653 align:middle
这确实是我们希望你做的三件事

00:35:20.454 --> 00:35:23.056 align:middle
你知道 减少网络 减少定位

00:35:23.490 --> 00:35:24.892 align:middle
和后台运行

00:35:27.127 --> 00:35:31.598 align:middle
这些只是用户通常看不到的功耗
当他们推出这个应用程序的时候

00:35:31.665 --> 00:35:33.634 align:middle
用户可能会喜欢
这个实时更新的应用程序

00:35:33.700 --> 00:35:35.936 align:middle
但是尝试使用后台应用程序刷新

00:35:36.003 --> 00:35:37.838 align:middle
尽量呈现优质
大量的leeways

00:35:38.472 --> 00:35:40.707 align:middle
如果你发送通知随后被忽略

00:35:41.141 --> 00:35:44.011 align:middle
会点亮屏幕
它正在发射网络 这只是

00:35:44.711 --> 00:35:47.581 align:middle
不仅是这个消耗

00:35:47.648 --> 00:35:49.850 align:middle
如果你一直运行的话
将会很快的消耗你的电池

00:35:49.917 --> 00:35:51.952 align:middle
但是这是一个...

00:35:53.153 --> 00:35:55.556 align:middle
这基本上只是去掉了

00:35:56.256 --> 00:35:58.292 align:middle
适用于其它事物的能量

00:35:58.358 --> 00:36:00.694 align:middle
它正在减少基本上
如果我降低了障碍

00:35:58.358 --> 00:36:00.694 align:middle
它正在减少基本上
如果我降低了障碍

00:36:00.761 --> 00:36:04.298 align:middle
那么就是说你已经实现了...
9%以下而不是10%

00:36:04.765 --> 00:36:05.866 align:middle
我们需要避免...

00:36:06.333 --> 00:36:07.968 align:middle
而这20%更糟

00:36:08.502 --> 00:36:11.138 align:middle
因为平均下来你只有5%

00:36:11.939 --> 00:36:14.241 align:middle
只要确定你不在后台运行
怎样去实现这一目的呢

00:36:15.209 --> 00:36:17.377 align:middle
调用后台任务时

00:36:17.444 --> 00:36:19.713 align:middle
我们将让设备保持几分钟的唤醒状态

00:36:20.647 --> 00:36:23.417 align:middle
这样你可以尽快的
终止后台任务

00:36:23.851 --> 00:36:27.688 align:middle
除了能量指南之外
还有一个很好的应用程序指南

00:36:27.754 --> 00:36:29.857 align:middle
那还有一个应用程序生命周期指南

00:36:29.923 --> 00:36:34.361 align:middle
这个消息会通知你
你将进入后台

00:36:35.462 --> 00:36:38.398 align:middle
你的用户界面状态保存在那儿

00:36:38.465 --> 00:36:40.234 align:middle
和用户界面对话 保持当前状态

00:36:40.601 --> 00:36:42.870 align:middle
如果你有需要保存的重要数据

00:36:44.371 --> 00:36:46.974 align:middle
去开一个后台操作

00:36:48.308 --> 00:36:50.978 align:middle
但是确定
所有的代码申请终止后台任务

00:36:51.044 --> 00:36:52.613 align:middle
不要泄露后台任务

00:36:53.814 --> 00:36:55.449 align:middle
如果你有网络

00:36:55.516 --> 00:36:58.719 align:middle
也许像保存到磁盘那样
这也可能会发生

00:36:59.119 --> 00:37:00.387 align:middle
网络活动...

00:36:59.119 --> 00:37:00.387 align:middle
网络活动...

00:37:00.654 --> 00:37:04.925 align:middle
这是把网络从操作系统中卸载的好机会

00:37:04.992 --> 00:37:06.627 align:middle
嗨 我有这个网络 它需要发生

00:37:06.693 --> 00:37:09.363 align:middle
但它不是时间的关键
只要在一定的时间范围内

00:37:09.963 --> 00:37:11.265 align:middle
有机会就一定需要完成它

00:37:11.598 --> 00:37:14.468 align:middle
给系统一个机会去优化

00:37:15.669 --> 00:37:17.504 align:middle
这也是很好的一个设计时间

00:37:17.905 --> 00:37:21.441 align:middle
在这方面可以让你
在设计应用程序的时候更灵活

00:37:23.110 --> 00:37:24.211 align:middle
这是我理想的应用程序

00:37:24.411 --> 00:37:25.712 align:middle
強 展示了一个很好的幻灯片

00:37:25.846 --> 00:37:28.248 align:middle
典型的应用程序
在你启动它的时候会有很多工作

00:37:28.916 --> 00:37:31.818 align:middle
我理想的应用程序
是在你退出的时候几乎没有任何工作

00:37:31.952 --> 00:37:33.253 align:middle
它不做任何工作

00:37:33.754 --> 00:37:35.255 align:middle
直到用户实际交互

00:37:35.556 --> 00:37:36.857 align:middle
这很疯狂！

00:37:37.558 --> 00:37:39.793 align:middle
很多工作 需要我们完成
这是所有的工作

00:37:39.860 --> 00:37:41.228 align:middle
请优先考虑

00:37:41.728 --> 00:37:44.131 align:middle
然后 在它完成之后再返回

00:37:44.498 --> 00:37:45.599 align:middle
它是好的而且是空闲的

00:37:45.766 --> 00:37:49.670 align:middle
那样你就可以推翻泛美金字塔

00:37:50.070 --> 00:37:51.872 align:middle
这达到了预期要求

00:37:54.741 --> 00:37:56.376 align:middle
那么你的应用程序是怎样运行的呢

00:37:56.510 --> 00:37:58.645 align:middle
我们真的很希望你们回家的
时候运行一下这个工具

00:37:58.712 --> 00:38:01.081 align:middle
完整的运行一遍来检查你的应用程序

00:37:58.712 --> 00:38:01.081 align:middle
完整的运行一遍来检查你的应用程序

00:38:01.148 --> 00:38:03.717 align:middle
之后这些工具将会告诉
你对应用程序的操作是什么

00:38:04.184 --> 00:38:07.020 align:middle
确定应用程序正在做的事情
对功耗产生的影响

00:38:07.354 --> 00:38:09.990 align:middle
就相当于用户被交付的利益

00:38:10.490 --> 00:38:14.561 align:middle
除了OS X 对于iOS来说Xcode
现在也有了一个能量计

00:38:14.995 --> 00:38:17.064 align:middle
它突出我刚才讨论到的事情

00:38:17.130 --> 00:38:19.666 align:middle
比如有中央处理器
网络 定位以及后台

00:38:20.300 --> 00:38:23.036 align:middle
把所有的网络融合然后
控制所有的定位

00:38:23.403 --> 00:38:25.339 align:middle
最后再取消后台任务

00:38:25.939 --> 00:38:27.941 align:middle
那么就来到我们下一个话题
了解一下它

00:38:28.675 --> 00:38:31.512 align:middle
首先当你设计你的下一个特征

00:38:31.812 --> 00:38:34.848 align:middle
设计你的下一个应用程序的时候
请思考一下这些消耗

00:38:35.148 --> 00:38:38.719 align:middle
比如原处理器功率
CPU和GPU的模式

00:38:38.785 --> 00:38:40.387 align:middle
我是正在醒来或是准备去休息

00:38:40.454 --> 00:38:42.589 align:middle
我能对它做出更多的约束么

00:38:43.390 --> 00:38:45.325 align:middle
任何像那样的闪烁

00:38:45.526 --> 00:38:48.595 align:middle
你们中的一些人可能还记得
早些时候网页上闪烁的标签

00:38:48.829 --> 00:38:51.265 align:middle
没有闪烁 特别是在高频下

00:38:52.499 --> 00:38:55.636 align:middle
比用户交互更快的任何东西
都是高频率的

00:38:56.770 --> 00:38:58.705 align:middle
尝试着给自己设定一个期望值

00:38:58.772 --> 00:39:01.175 align:middle
因为如果你准备写一个聊天应用程序

00:38:58.772 --> 00:39:01.175 align:middle
因为如果你准备写一个聊天应用程序

00:39:01.408 --> 00:39:03.343 align:middle
全天下来
你自己本身可能都变成流媒体了

00:39:03.410 --> 00:39:05.812 align:middle
你应当把程序安装
在一个新的硬件设备上

00:39:06.480 --> 00:39:09.149 align:middle
这样的话用户就很有可能在你的
应用程序中实现全天续航

00:39:09.216 --> 00:39:11.852 align:middle
他们必须买一个单独的手机
事实上是三部手机

00:39:11.919 --> 00:39:13.387 align:middle
以确保可以整天运行

00:39:15.689 --> 00:39:17.391 align:middle
但很遗憾 那个应用程序卖的并不好

00:39:19.493 --> 00:39:21.662 align:middle
在你的商业模式中这种计划

00:39:21.728 --> 00:39:23.931 align:middle
是否与这个应用程序的电池续航能力
表现的一样呢

00:39:24.364 --> 00:39:28.769 align:middle
我正在使用很多的定位以及很多的网络
我在后台去完成这些任务

00:39:29.102 --> 00:39:30.270 align:middle
主要是因为它们很昂贵

00:39:31.772 --> 00:39:34.074 align:middle
看一下执行效果
可以通过查阅能源指南

00:39:34.141 --> 00:39:36.844 align:middle
确保你可以给应用程序接口
传递最佳参数

00:39:37.244 --> 00:39:39.079 align:middle
看一下你自己的代码
再看一下我们的代码

00:39:39.146 --> 00:39:41.582 align:middle
如果我们的代码在做一些奇怪的事情
比如提交一个错误

00:39:41.648 --> 00:39:43.984 align:middle
最后看一下你可能使用的第三方代码

00:39:44.751 --> 00:39:48.455 align:middle
你有一个广告框架 广告本身很好
因为它可以支持我们的平台

00:39:49.990 --> 00:39:53.360 align:middle
但是 如果他们像其它广告那样
做很多的下载

00:39:53.427 --> 00:39:55.629 align:middle
下载显示 下载显示 下载显示

00:39:56.063 --> 00:39:58.398 align:middle
在很长一段时间之间
我们必须保持网络开启

00:39:58.799 --> 00:40:00.701 align:middle
那样并不好
必须要注意到这一点

00:39:58.799 --> 00:40:00.701 align:middle
那样并不好
必须要注意到这一点

00:40:01.335 --> 00:40:02.302 align:middle
在最后 进行测试

00:40:02.369 --> 00:40:04.071 align:middle
可以通过定期运行这些工具

00:40:04.137 --> 00:40:07.808 align:middle
去确保你的应用程序
可以按照你期望的方式去运行

00:40:09.743 --> 00:40:13.614 align:middle
如果你已经把这些事情都完成了
我怀疑你没有 但也许你有

00:40:13.680 --> 00:40:14.982 align:middle
在这项任务中 最重要的工作

00:40:15.682 --> 00:40:19.119 align:middle
就是继续进行
检查你的后台更新间隔

00:40:19.186 --> 00:40:22.689 align:middle
你能够减少或者给你的系统
更大的自由度么

00:40:23.657 --> 00:40:25.592 align:middle
你能够更加谨慎的使用声明么

00:40:25.659 --> 00:40:29.263 align:middle
特别是当你开发VoIP应用程序的时候
我们给应用程序的接口做了一些改变

00:40:29.396 --> 00:40:31.231 align:middle
请记住 这些传入连接是很便宜的

00:40:31.532 --> 00:40:34.034 align:middle
但并不是免费的
他们会让你回电话

00:40:34.101 --> 00:40:35.602 align:middle
但不要退出

00:40:36.603 --> 00:40:38.172 align:middle
不要弄混显示屏的亮度

00:40:38.839 --> 00:40:41.041 align:middle
绘画可能是下一个过度的前奏...

00:40:41.375 --> 00:40:44.077 align:middle
我讨论到闪烁的知识
那仍有很多绘画的事情你可以去完成

00:40:44.144 --> 00:40:46.680 align:middle
去年谈论到这个话题
在末尾的链接中

00:40:46.947 --> 00:40:48.715 align:middle
可以知道相关的主题图是正确的

00:40:49.016 --> 00:40:49.983 align:middle
也获得了一些工具

00:40:50.250 --> 00:40:51.084 align:middle
最后...

00:40:51.919 --> 00:40:54.755 align:middle
对于OS X和iOS来说
我们现在已经有一些能量指南

00:40:54.821 --> 00:40:57.591 align:middle
我只是提出把所有的这些信息
都记录下来

00:40:57.658 --> 00:40:59.693 align:middle
我将会继续
在developer.Apple.com中

00:40:59.760 --> 00:41:01.328 align:middle
更新这些信息

00:40:59.760 --> 00:41:01.328 align:middle
更新这些信息

00:41:01.929 --> 00:41:04.131 align:middle
所以总结我们所讲过的内容

00:41:05.032 --> 00:41:06.233 align:middle
就是功耗是功率

00:41:07.034 --> 00:41:09.236 align:middle
乘以时间
如果你想减少功耗

00:41:09.570 --> 00:41:13.607 align:middle
那么相对于你运行的时间来说
功率是很重要的

00:41:14.208 --> 00:41:16.143 align:middle
我们希望你能够降低功率

00:41:16.210 --> 00:41:19.313 align:middle
当然我们的工具本身就是低功率的
我们的工具在低功率方面表现的不错

00:41:19.379 --> 00:41:20.681 align:middle
你也将会在下一次讨论中涉及到它

00:41:20.747 --> 00:41:23.350 align:middle
这些可以支持用户实现
电池提供全天续航

00:41:24.418 --> 00:41:26.119 align:middle
做更少的工作

00:41:26.587 --> 00:41:28.622 align:middle
或者延迟工作
以及提高完成工作的效率

00:41:29.756 --> 00:41:31.291 align:middle
这里是我谈论到的链接

00:41:31.792 --> 00:41:36.330 align:middle
文档、视频、指南 以及去年的谈话

00:41:37.865 --> 00:41:39.766 align:middle
我们有我们的标准论坛

00:41:39.833 --> 00:41:42.769 align:middle
你可以和其他人交流
你能够联系我或者DTS的人

00:41:43.170 --> 00:41:44.171 align:middle
他们有我的手机号码

00:41:44.371 --> 00:41:48.008 align:middle
你不必要我的手机号码 他们有
和他们谈一下 他们可能会帮助你

00:41:48.075 --> 00:41:50.978 align:middle
如果他们不能的话 他们可以联系我
或者我的一个出色的队友

00:41:51.879 --> 00:41:54.248 align:middle
保羅 也在这里
他的电子邮箱附在这张幻灯片中

00:41:56.850 --> 00:41:57.851 align:middle
参加相关会议

00:41:58.952 --> 00:42:00.687 align:middle
或下一届会议的人请留下来

00:41:58.952 --> 00:42:00.687 align:middle
或下一届会议的人请留下来

00:42:00.921 --> 00:42:03.190 align:middle
我们有一些网络的参数性能

00:42:03.724 --> 00:42:05.893 align:middle
可以看一下 他们将会帮助你

00:42:05.959 --> 00:42:08.362 align:middle
去思考怎样优化
我刚才所谈论到的所有事情

00:42:08.762 --> 00:42:11.632 align:middle
请继续为了节能优化你的应用程序
