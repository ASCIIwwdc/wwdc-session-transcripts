WEBVTT

00:00:20.053 --> 00:00:22.823 align:middle
Metal技术最新内容 第一部分

00:00:31.064 --> 00:00:31.899 align:middle
下午好

00:00:32.499 --> 00:00:33.867 align:middle
欢迎来到WWDC 2015

00:00:40.040 --> 00:00:40.874 align:middle
欢迎参加

00:00:40.941 --> 00:00:42.843 align:middle
《Metal技术最新内容》
讲座的上半场

00:00:44.411 --> 00:00:46.914 align:middle
本周的三次讲座中

00:00:46.980 --> 00:00:48.482 align:middle
有许多Metal的内容

00:00:49.550 --> 00:00:51.919 align:middle
实际上 我们已经
在API中加入很多新内容

00:00:51.985 --> 00:00:54.288 align:middle
所以决定要把
《Metal技术的最新内容》

00:00:54.354 --> 00:00:56.456 align:middle
讲座分为两部分

00:00:58.258 --> 00:00:59.293 align:middle
那么今天

00:00:59.359 --> 00:01:01.929 align:middle
我主要
对过去12个月的Metal

00:00:59.359 --> 00:01:01.929 align:middle
我主要
对过去12个月的Metal

00:01:02.196 --> 00:01:05.331 align:middle
生态系统进行
扼要回顾

00:01:06.466 --> 00:01:09.536 align:middle
像诸位这样的开发人员
已经运用Metal

00:01:09.603 --> 00:01:10.904 align:middle
创造了很多应用

00:01:12.639 --> 00:01:14.541 align:middle
我会介绍我们
今年推出的

00:01:14.842 --> 00:01:16.076 align:middle
部分新功能

00:01:16.910 --> 00:01:18.912 align:middle
最后 我们会
通过具体实例

00:01:19.213 --> 00:01:21.048 align:middle
介绍
app瘦身技术

00:01:21.181 --> 00:01:22.349 align:middle
将Metal如何与

00:01:22.749 --> 00:01:25.352 align:middle
系统的其他部分
相整合

00:01:28.589 --> 00:01:30.691 align:middle
在下半场《Metal
技术最新内容》讲座中

00:01:30.757 --> 00:01:32.960 align:middle
丹·大汀和安娜·蒂科诺娃

00:01:33.026 --> 00:01:34.361 align:middle
将详细介绍今年

00:01:34.661 --> 00:01:36.763 align:middle
我们用Metal新推出的

00:01:36.830 --> 00:01:38.699 align:middle
一款非常棒的支持库

00:01:39.666 --> 00:01:41.535 align:middle
或是两个
这样的支持库

00:01:42.503 --> 00:01:45.906 align:middle
MetalKit可为API
提供便捷

00:01:45.973 --> 00:01:48.575 align:middle
让你可以生成出色的
Metal应用

00:01:49.576 --> 00:01:51.945 align:middle
和MetalPerformance
Shaders

00:01:52.279 --> 00:01:54.715 align:middle
我们高度优化的着色器库

00:01:55.082 --> 00:01:57.885 align:middle
可以直接从
应用调用

00:02:00.754 --> 00:02:02.923 align:middle
最后 在后一场讲座中

00:02:02.990 --> 00:02:03.924 align:middle
菲尔·贝内特

00:02:03.991 --> 00:02:07.327 align:middle
会深入介绍利用...
Metal应用

00:02:07.528 --> 00:02:10.097 align:middle
实现
可能的最好

00:02:10.330 --> 00:02:11.698 align:middle
表现的出色技巧

00:02:12.999 --> 00:02:14.768 align:middle
在本次讲座中

00:02:14.835 --> 00:02:18.839 align:middle
我们将
介绍最新GPU

00:02:19.072 --> 00:02:21.375 align:middle
System Trace工具
所以一定要看看

00:02:25.879 --> 00:02:27.281 align:middle
去年的WWDC上

00:02:27.347 --> 00:02:29.716 align:middle
我们介绍了
iOS 8的Metal技术

00:02:31.518 --> 00:02:34.588 align:middle
目标是
图形的重新实现

00:02:34.655 --> 00:02:37.191 align:middle
并计算API
在我们的平台上

00:02:37.257 --> 00:02:41.395 align:middle
给你提供最好的GPU表现

00:02:42.396 --> 00:02:46.266 align:middle
我们通过让你和
GPU之间的软件

00:02:46.466 --> 00:02:48.402 align:middle
发挥最大效用实现这些

00:02:51.638 --> 00:02:53.207 align:middle
为更形象地说明

00:02:53.273 --> 00:02:55.275 align:middle
我们现在来看

00:02:55.342 --> 00:02:57.878 align:middle
在去年的WWDC
举的例子

00:02:57.945 --> 00:02:59.546 align:middle
其中描述

00:02:59.613 --> 00:03:02.883 align:middle
GPU和CPU每帧
完成的工作

00:02:59.613 --> 00:03:02.883 align:middle
GPU和CPU每帧
完成的工作

00:03:04.251 --> 00:03:05.419 align:middle
在本例中

00:03:05.485 --> 00:03:08.722 align:middle
头部工具条
代表CPU所用时间

00:03:09.156 --> 00:03:12.192 align:middle
底部工具条代表
GPU时间

00:03:13.227 --> 00:03:15.863 align:middle
正如大家所见
目前CPU密集

00:03:16.930 --> 00:03:19.766 align:middle
GPU在帧的部分位置
比较空闲

00:03:21.335 --> 00:03:22.469 align:middle
有了Metal 我们可以

00:03:22.536 --> 00:03:26.340 align:middle
大幅减少GPU
API开销

00:03:26.740 --> 00:03:28.008 align:middle
有效地

00:03:29.576 --> 00:03:31.478 align:middle
将GPU
作为高帧数的瓶颈

00:03:32.713 --> 00:03:35.549 align:middle
这其中最棒的是
你可以利用CPU

00:03:35.616 --> 00:03:37.718 align:middle
额外的空闲时间

00:03:38.285 --> 00:03:39.620 align:middle
让游戏效果更好

00:03:41.088 --> 00:03:43.690 align:middle
例如 可以增加
更多物理应用或AI

00:03:45.058 --> 00:03:47.160 align:middle
如果你可以签署更多

00:03:47.561 --> 00:03:49.530 align:middle
绘制调用来增加
场景的复杂性

00:03:52.132 --> 00:03:53.400 align:middle
但是我们不会止步于此

00:03:54.301 --> 00:03:57.504 align:middle
Metal还可以实现
成本较高的操作

00:03:57.971 --> 00:03:59.406 align:middle
例如 着色器编译

00:03:59.840 --> 00:04:02.376 align:middle
和状态确认

00:03:59.840 --> 00:04:02.376 align:middle
和状态确认

00:04:02.743 --> 00:04:05.412 align:middle
从每帧数千次的绘制时间

00:04:06.313 --> 00:04:08.815 align:middle
到发生频率不高的

00:04:09.683 --> 00:04:11.885 align:middle
加载时间均有涉及
更好的是在部分情况下

00:04:11.952 --> 00:04:12.786 align:middle
是构建时间

00:04:13.520 --> 00:04:16.322 align:middle
这样用户
根本不会发现任何影响

00:04:19.125 --> 00:04:20.260 align:middle
此外

00:04:20.327 --> 00:04:21.894 align:middle
在iOS 8中

00:04:21.962 --> 00:04:24.798 align:middle
我们不仅为iOS设备

00:04:24.865 --> 00:04:28.068 align:middle
引入了计算或首次
面对此类计算

00:04:28.802 --> 00:04:33.807 align:middle
而且还提供了
图形和计算

00:04:34.107 --> 00:04:36.476 align:middle
API之间的凝聚
整合性内容

00:04:37.244 --> 00:04:41.682 align:middle
以便在支持Metal的设备上
有效交叉进行渲染

00:04:41.849 --> 00:04:43.417 align:middle
和计算操作

00:04:47.521 --> 00:04:48.689 align:middle
最后

00:04:48.755 --> 00:04:49.723 align:middle
通过Metal

00:04:49.790 --> 00:04:51.258 align:middle
你的应用可以

00:04:51.325 --> 00:04:53.794 align:middle
更高效地
运用多线程

00:04:54.094 --> 00:04:55.929 align:middle
而不会受到API的影响
可以实现

00:04:56.730 --> 00:04:59.466 align:middle
多线程编码

00:05:02.035 --> 00:05:03.537 align:middle
结果会
非常出色

00:05:04.605 --> 00:05:05.572 align:middle
去年

00:05:05.639 --> 00:05:07.107 align:middle
我们展示了

00:05:07.174 --> 00:05:10.711 align:middle
Epic开发的《禅境花园》演示

00:05:10.944 --> 00:05:13.847 align:middle
其中用到Metal
实现场景中十倍

00:05:13.914 --> 00:05:15.382 align:middle
数量的绘画调用

00:05:17.451 --> 00:05:20.888 align:middle
我们还展示了EA的
《植物大战僵尸》技术演示

00:05:21.421 --> 00:05:25.025 align:middle
其中使用Metal
把控制台渲染引擎

00:05:25.459 --> 00:05:26.894 align:middle
才能得到支持

00:05:28.328 --> 00:05:31.031 align:middle
这就为开发界
设定了高标准

00:05:31.765 --> 00:05:34.501 align:middle
在去年 我们见证了
充分利用Metal API

00:05:34.568 --> 00:05:36.470 align:middle
而推出的部分

00:05:36.937 --> 00:05:39.640 align:middle
水平极高的
作品

00:05:41.308 --> 00:05:43.644 align:middle
诸如Super
Evil Mega Corp公司

00:05:43.710 --> 00:05:45.612 align:middle
推出的MOBA
Vainglory游戏

00:05:46.513 --> 00:05:49.816 align:middle
其中运用了Metal
实现每秒60帧的效果

00:05:51.718 --> 00:05:54.021 align:middle
迪斯尼的《Infinity:Toy
Box 2》

00:05:54.488 --> 00:05:55.522 align:middle
Metal使其

00:05:55.589 --> 00:05:57.925 align:middle
可将控制器
图形和游戏

00:05:58.292 --> 00:06:00.527 align:middle
体验带到了iOS

00:05:58.292 --> 00:06:00.527 align:middle
体验带到了iOS

00:06:02.629 --> 00:06:04.598 align:middle
Gameloft的
《Asphalt 8》

00:06:04.998 --> 00:06:07.234 align:middle
可以运用Metal

00:06:07.401 --> 00:06:10.270 align:middle
提高游戏可玩性
将游戏中的渲染速度

00:06:10.337 --> 00:06:11.772 align:middle
比对手高出3倍

00:06:13.874 --> 00:06:15.609 align:middle
但还不仅是游戏方面

00:06:16.844 --> 00:06:18.679 align:middle
随着用于iPhone的

00:06:19.546 --> 00:06:21.048 align:middle
新版本Pixelmator推出

00:06:21.114 --> 00:06:22.249 align:middle
Metal被用于
强大的

00:06:22.316 --> 00:06:23.917 align:middle
变形工具中的

00:06:24.017 --> 00:06:26.587 align:middle
加速图形
处理功能

00:06:28.288 --> 00:06:29.122 align:middle
实际上

00:06:29.923 --> 00:06:31.625 align:middle
相关反响非常强烈

00:06:32.226 --> 00:06:33.527 align:middle
有相当数量的

00:06:33.594 --> 00:06:35.095 align:middle
主要内容和
游戏开发人员

00:06:35.162 --> 00:06:36.396 align:middle
在OS X上使用Metal

00:06:38.165 --> 00:06:41.301 align:middle
因为我们对在iOS平台上

00:06:41.702 --> 00:06:42.769 align:middle
推出领先的游戏

00:06:43.103 --> 00:06:45.606 align:middle
控制台引擎所做承诺
大部分这样的内容

00:06:45.939 --> 00:06:47.441 align:middle
才能得到支持

00:06:48.008 --> 00:06:49.743 align:middle
这包括

00:06:49.810 --> 00:06:51.512 align:middle
Unity
Epic的《虚幻引擎4》

00:06:51.912 --> 00:06:52.980 align:middle
EA的《寒霜》

00:06:53.380 --> 00:06:55.516 align:middle
移动引擎

00:06:59.019 --> 00:07:00.754 align:middle
去年 我们还展示了

00:06:59.019 --> 00:07:00.754 align:middle
去年 我们还展示了

00:07:00.821 --> 00:07:01.989 align:middle
Metal怎样在

00:07:02.055 --> 00:07:05.959 align:middle
应用访问GPU的
全局图景中发挥作用

00:07:06.593 --> 00:07:09.963 align:middle
一方面 我们有着
高水准的2D和

00:07:10.030 --> 00:07:12.232 align:middle
3D场景图像API

00:07:12.599 --> 00:07:14.902 align:middle
以提供难以置信的

00:07:14.968 --> 00:07:16.670 align:middle
功能和便捷

00:07:16.970 --> 00:07:18.238 align:middle
另一方面

00:07:18.305 --> 00:07:19.239 align:middle
通过Metal

00:07:19.306 --> 00:07:22.109 align:middle
我们提供了
GPU的直接访问路径

00:07:22.910 --> 00:07:24.912 align:middle
这样你可以为

00:07:25.379 --> 00:07:27.414 align:middle
应用所做的事情

00:07:28.415 --> 00:07:30.083 align:middle
就会多了很多
如果选择使用

00:07:30.150 --> 00:07:31.585 align:middle
更高级的API

00:07:32.085 --> 00:07:33.020 align:middle
最棒的是

00:07:33.086 --> 00:07:35.722 align:middle
我们可以在
幕后实现很多改进

00:07:36.223 --> 00:07:38.025 align:middle
你可以从中受益

00:07:38.091 --> 00:07:40.861 align:middle
而我们不需改动
一行代码

00:07:42.829 --> 00:07:43.931 align:middle
今年

00:07:43.997 --> 00:07:46.466 align:middle
我们很高兴
宣布了

00:07:47.000 --> 00:07:49.703 align:middle
我们做到了这些
并让Metal

00:07:49.970 --> 00:07:51.672 align:middle
在整个系统技术中表现得
更强大更高效

00:07:52.506 --> 00:07:55.275 align:middle
我相信
这将会提升

00:07:55.342 --> 00:07:56.777 align:middle
用户在我们的
平台上的体验

00:08:00.581 --> 00:08:04.184 align:middle
这也是支持Metal
设备的很棒的一年

00:08:05.018 --> 00:08:09.556 align:middle
iPhone 5S和iPad
Air在去年的WWDC上

00:08:10.524 --> 00:08:13.427 align:middle
都是主打产品
随着iPhone 6

00:08:13.861 --> 00:08:16.663 align:middle
6+和 iPad Air 2的推出

00:08:16.730 --> 00:08:18.866 align:middle
我们现在有了支持Metal设备的

00:08:18.932 --> 00:08:21.068 align:middle
难以置信的安装基础

00:08:22.035 --> 00:08:23.437 align:middle
但是当然
还不止于此

00:08:24.838 --> 00:08:26.473 align:middle
我们很高兴地宣布

00:08:26.540 --> 00:08:29.610 align:middle
将Metal纳入了
OS X平台

00:08:33.113 --> 00:08:34.948 align:middle
我们在所有的

00:08:35.015 --> 00:08:37.818 align:middle
传送配置中
都广泛支持Metal

00:08:37.885 --> 00:08:42.789 align:middle
实际上 自2012年起
所有的Mac就已支持Metal

00:08:44.024 --> 00:08:46.793 align:middle
当然 这意味着
我们会支持所有

00:08:46.860 --> 00:08:50.364 align:middle
三家GPU厂商：
Intel AMD和Nvidia

00:08:53.333 --> 00:08:55.569 align:middle
其他好消息还包括

00:08:55.636 --> 00:08:58.071 align:middle
我们将大家熟悉的

00:08:58.138 --> 00:09:00.908 align:middle
iOS上的所有工具
也都加在了Mac平台

00:08:58.138 --> 00:09:00.908 align:middle
iOS上的所有工具
也都加在了Mac平台

00:09:01.608 --> 00:09:03.310 align:middle
这其中包括Frame

00:09:04.478 --> 00:09:06.680 align:middle
Debugger
Shader Profiler

00:09:07.047 --> 00:09:09.283 align:middle
和所有API分析工具

00:09:10.017 --> 00:09:11.451 align:middle
这相当了不起

00:09:11.652 --> 00:09:14.121 align:middle
我们了解调试复杂图形

00:09:14.188 --> 00:09:16.190 align:middle
和计算
应用的难度

00:09:16.623 --> 00:09:19.860 align:middle
并认为这对
大家在OS X上的

00:09:19.927 --> 00:09:20.928 align:middle
开发工作
意义重大

00:09:22.362 --> 00:09:23.931 align:middle
当然 所有这些在

00:09:23.997 --> 00:09:26.567 align:middle
OS X El
Capitan版本

00:09:26.934 --> 00:09:28.936 align:middle
搭建的种子中可以获得
如今这一版本可以下载

00:09:31.004 --> 00:09:32.406 align:middle
OS X上的Metal

00:09:32.472 --> 00:09:35.042 align:middle
是你所熟悉的同样API

00:09:35.509 --> 00:09:36.577 align:middle
用的是iOS

00:09:37.044 --> 00:09:38.378 align:middle
增加了几项主要功能

00:09:39.580 --> 00:09:42.316 align:middle
新款API支持设备选择

00:09:43.150 --> 00:09:44.384 align:middle
离散内存

00:09:44.718 --> 00:09:46.186 align:middle
和新的纹理格式

00:09:46.687 --> 00:09:49.089 align:middle
Metal可以让
你将iOS应用带入

00:09:49.156 --> 00:09:51.859 align:middle
OS X变得异常容易

00:09:54.127 --> 00:09:55.529 align:middle
这里有几个实例

00:09:55.596 --> 00:09:57.497 align:middle
开发人员正是
这样做的

00:09:58.665 --> 00:10:01.768 align:middle
大家从主题演讲中听到
我们在与Epic合作

00:09:58.665 --> 00:10:01.768 align:middle
大家从主题演讲中听到
我们在与Epic合作

00:10:02.236 --> 00:10:05.506 align:middle
将其iOS Metal
开发代码带到

00:10:05.839 --> 00:10:07.474 align:middle
Mac中的《虚幻引擎》

00:10:08.775 --> 00:10:10.544 align:middle
Epic运用Metal

00:10:10.744 --> 00:10:13.180 align:middle
和延迟渲染器

00:10:13.247 --> 00:10:16.350 align:middle
在《堡垒之夜》游戏中
创建这种神奇的风格效果

00:10:18.452 --> 00:10:20.854 align:middle
此外 Unity在几周内

00:10:20.921 --> 00:10:22.623 align:middle
就推出了他们的引擎

00:10:23.123 --> 00:10:25.659 align:middle
并展示了
他们的《海盗村》

00:10:25.726 --> 00:10:27.327 align:middle
演示

00:10:27.761 --> 00:10:31.298 align:middle
很高兴能在OS X的Metal中
看到这样的内容

00:10:33.600 --> 00:10:36.670 align:middle
我们在与
若干Mac开发者合作

00:10:36.904 --> 00:10:40.474 align:middle
帮助他们通过
Metal使用Metal的强大功能

00:10:43.977 --> 00:10:45.646 align:middle
同样 大家从主题演讲中听到

00:10:45.712 --> 00:10:48.282 align:middle
数字内容
生成应用的相关介绍

00:10:49.449 --> 00:10:50.784 align:middle
Adobe这样的开发者

00:10:50.851 --> 00:10:52.953 align:middle
在使用Metal访问GPU

00:10:53.020 --> 00:10:54.888 align:middle
加速图像处理能力

00:10:57.357 --> 00:10:58.825 align:middle
The Foundry公司

00:10:58.892 --> 00:11:00.594 align:middle
也在运用Metal

00:10:58.892 --> 00:11:00.594 align:middle
也在运用Metal

00:11:00.661 --> 00:11:04.097 align:middle
加速其3D
建模应用MODO

00:11:05.632 --> 00:11:06.900 align:middle
今天

00:11:06.967 --> 00:11:10.270 align:middle
来自The Foundry
公司的杰克•格里斯雷

00:11:10.604 --> 00:11:12.639 align:middle
来谈谈他们在OS X
使用Metal的经验

00:11:14.741 --> 00:11:15.576 align:middle
欢迎杰克

00:11:15.642 --> 00:11:16.476 align:middle
谢谢 拉夫

00:11:19.913 --> 00:11:21.215 align:middle
大家好我是杰克•格里斯雷

00:11:21.281 --> 00:11:23.817 align:middle
在The Foundry公司
负责新技术部门

00:11:24.751 --> 00:11:28.121 align:middle
在The Foundry 我们为
数码艺术家创建工具

00:11:29.656 --> 00:11:31.491 align:middle
我们的软件在全世界

00:11:31.558 --> 00:11:33.994 align:middle
用于游戏 影视等领域

00:11:34.561 --> 00:11:37.064 align:middle
包括拍摄
真实的秘鲁熊

00:11:38.465 --> 00:11:39.566 align:middle
变形怪物猎人

00:11:40.767 --> 00:11:42.102 align:middle
但并非仅限于
虚拟世界

00:11:42.870 --> 00:11:44.571 align:middle
我们的部分设计客户
如阿迪达斯是

00:11:44.638 --> 00:11:45.839 align:middle
是在切实生产产品

00:11:47.140 --> 00:11:48.742 align:middle
如果你询问设计师

00:11:49.476 --> 00:11:52.513 align:middle
他们会告知你 任何产品都是
经过成千上万次试验才会成型

00:11:54.982 --> 00:11:56.283 align:middle
我们理解这一过程

00:11:56.350 --> 00:11:57.417 align:middle
我们创造的工具

00:11:57.484 --> 00:11:59.152 align:middle
就是针对此类支持

00:12:01.355 --> 00:12:03.323 align:middle
MODO是我们的著名3D

00:12:03.390 --> 00:12:05.526 align:middle
建模动画和渲染系统

00:12:06.460 --> 00:12:08.762 align:middle
它可用来制作游戏
电影和产品设计

00:12:09.129 --> 00:12:10.163 align:middle
等等很多不同的应用

00:12:11.231 --> 00:12:13.100 align:middle
我们的用户创造出

00:12:13.467 --> 00:12:15.869 align:middle
非常精彩的画面和动画在真实世界和
虚幻世界中都有

00:12:18.138 --> 00:12:20.207 align:middle
在我们的MODO 9.01
最新版本中

00:12:20.841 --> 00:12:23.277 align:middle
对GPU渲染器做了修改

00:12:24.645 --> 00:12:27.581 align:middle
旨在为设计者
提供尽可能

00:12:28.315 --> 00:12:30.317 align:middle
高质量的
流畅互动体验

00:12:31.418 --> 00:12:34.054 align:middle
这样做的好处在于
如果视口是实时

00:12:34.588 --> 00:12:36.256 align:middle
你就可以完成
数十倍单个软件

00:12:36.323 --> 00:12:38.091 align:middle
渲染器的决定

00:12:40.928 --> 00:12:43.864 align:middle
在iOS中 我们已经
完成了部分早期工作

00:12:44.831 --> 00:12:47.868 align:middle
但是在几个月前
我们有个绝好的机会

00:12:48.202 --> 00:12:49.803 align:middle
可以在OS X上
开始使用Metal

00:12:50.404 --> 00:12:52.539 align:middle
我们组织了一个小团队
让他们来接受挑战

00:12:53.207 --> 00:12:56.143 align:middle
只给4周时间
来看他们可以将

00:12:56.510 --> 00:12:58.712 align:middle
生成多少新的MODO视口
并在Metal上运行

00:12:59.313 --> 00:13:01.849 align:middle
我们机会立刻会
得到一些很令人震惊的结果

00:12:59.313 --> 00:13:01.849 align:middle
我们机会立刻会
得到一些很令人震惊的结果

00:13:05.853 --> 00:13:06.687 align:middle
虽然

00:13:06.753 --> 00:13:08.155 align:middle
这不过是
小三角

00:13:08.222 --> 00:13:10.057 align:middle
但是这代表了
我们的一个巨大里程碑

00:13:10.757 --> 00:13:13.594 align:middle
一旦我们可以做到这点
就可以很快的取得进步

00:13:14.228 --> 00:13:16.530 align:middle
我们的进攻计划
其实是从下往上

00:13:17.130 --> 00:13:20.234 align:middle
并开始将新视口的功能
带到了Metal

00:13:20.801 --> 00:13:22.135 align:middle
第一天

00:13:22.202 --> 00:13:23.337 align:middle
我们
是从环境开始入手

00:13:25.339 --> 00:13:27.708 align:middle
我们添加了更多的三角

00:13:31.245 --> 00:13:32.813 align:middle
加一点着色处理会

00:13:32.880 --> 00:13:34.748 align:middle
让它看似更像是
真正的汽车

00:13:38.385 --> 00:13:39.887 align:middle
加上柔和的阴影

00:13:39.953 --> 00:13:40.888 align:middle
还有特殊的高光处理

00:13:40.954 --> 00:13:42.289 align:middle
加上了闪闪发亮的效果

00:13:42.356 --> 00:13:43.490 align:middle
人人都喜欢亮闪闪的东西

00:13:45.125 --> 00:13:47.327 align:middle
就这样
四周后

00:13:47.394 --> 00:13:48.929 align:middle
大家还记得那个
单一的三角形吗？

00:13:49.296 --> 00:13:50.697 align:middle
结果难以置信

00:13:54.701 --> 00:13:56.370 align:middle
把这些都放入Metal

00:13:56.436 --> 00:13:58.572 align:middle
仅仅用四周时间

00:13:58.872 --> 00:14:00.440 align:middle
我们就实现了

00:13:58.872 --> 00:14:00.440 align:middle
我们就实现了

00:14:00.507 --> 00:14:02.442 align:middle
所有视口
都在Metal的MODO运行

00:14:03.977 --> 00:14:05.279 align:middle
很棒的一点是

00:14:05.345 --> 00:14:08.749 align:middle
这提供了跨iOS和OS X的
标准化渲染器

00:14:09.983 --> 00:14:13.353 align:middle
我们在两个平台间
生成了WYSIWYG工作流

00:14:15.889 --> 00:14:17.324 align:middle
那么我们学到了什么？

00:14:18.058 --> 00:14:20.227 align:middle
首先我们了解到
使用Metal充满乐趣

00:14:20.861 --> 00:14:22.963 align:middle
我使用OpenGL工作
已经20年时间

00:14:23.030 --> 00:14:25.065 align:middle
我可以告知大家
API轻松易用

00:14:25.132 --> 00:14:27.067 align:middle
就像是呼吸新鲜空气一般

00:14:29.002 --> 00:14:29.970 align:middle
其次

00:14:30.437 --> 00:14:32.139 align:middle
Metal中的
调试和

00:14:32.206 --> 00:14:33.807 align:middle
优化工具
也非常神奇

00:14:34.908 --> 00:14:35.742 align:middle
我刚说过

00:14:35.809 --> 00:14:37.411 align:middle
如果你在
GPU上做过调试

00:14:37.477 --> 00:14:38.846 align:middle
就会知道为什么这点很重要

00:14:40.214 --> 00:14:41.882 align:middle
Metal的速度非常快

00:14:42.516 --> 00:14:44.585 align:middle
在部分测试中
我们实现了3倍加速

00:14:45.252 --> 00:14:47.921 align:middle
这是在同样的GPU
使用完全相同的数据的结果

00:14:49.590 --> 00:14:52.626 align:middle
继续来看 我们对
新的视口有些很大的计划

00:14:52.693 --> 00:14:55.963 align:middle
我们想将它整合到The
Foundry公司的所有工具中

00:14:56.463 --> 00:14:58.565 align:middle
希望 能很快
看到Metal

00:14:58.632 --> 00:14:59.867 align:middle
出现在
有趣的地方

00:15:00.801 --> 00:15:03.136 align:middle
请拉夫回到台上
非常感谢

00:15:10.511 --> 00:15:11.345 align:middle
谢谢 杰克

00:15:14.515 --> 00:15:15.482 align:middle
非常好

00:15:16.583 --> 00:15:19.720 align:middle
接下来我会聊聊iOS 9和OS X
El Capitan

00:15:19.786 --> 00:15:22.890 align:middle
引入的
新功能

00:15:24.691 --> 00:15:25.659 align:middle
这样的功能有很多

00:15:27.027 --> 00:15:28.262 align:middle
只能对我们

00:15:28.328 --> 00:15:29.796 align:middle
今年新增的功能
选择性介绍一番

00:15:30.864 --> 00:15:33.500 align:middle
实在没时间
各个都讲一遍

00:15:33.834 --> 00:15:35.536 align:middle
我先来说说
子集问题

00:15:36.370 --> 00:15:38.472 align:middle
包括GPU系列集

00:15:38.872 --> 00:15:40.307 align:middle
我们的新内存模型

00:15:40.374 --> 00:15:41.675 align:middle
纹理壁垒

00:15:41.742 --> 00:15:43.644 align:middle
<br/>
和扩展的纹理支持

00:15:44.878 --> 00:15:46.213 align:middle
当然 我之前提过

00:15:46.280 --> 00:15:47.514 align:middle
在本周晚些时候的
讲座中

00:15:47.581 --> 00:15:48.415 align:middle
大家可以
了解到

00:15:49.082 --> 00:15:50.717 align:middle
MetalKit
MetalPerformance

00:15:50.784 --> 00:15:52.853 align:middle
Shaders
新的Metal System

00:15:53.320 --> 00:15:54.888 align:middle
Trace工具等更多内容

00:15:56.823 --> 00:15:58.325 align:middle
我们现在就来详细介绍

00:15:59.393 --> 00:16:01.395 align:middle
我想先从GPU开始

00:15:59.393 --> 00:16:01.395 align:middle
我想先从GPU开始

00:16:01.461 --> 00:16:02.896 align:middle
这是我们的Metal功能集

00:16:03.397 --> 00:16:06.200 align:middle
Metal定义了
专门针对生成GPU

00:16:06.266 --> 00:16:09.403 align:middle
硬件的功能集合

00:16:10.003 --> 00:16:13.040 align:middle
Metal调用这些GPU系列

00:16:14.741 --> 00:16:16.210 align:middle
因此GPU功能集

00:16:16.276 --> 00:16:19.780 align:middle
是由iOS或OS X平台所定义

00:16:20.981 --> 00:16:23.116 align:middle
Family Name
主要针对

00:16:23.183 --> 00:16:24.384 align:middle
硬件生成

00:16:25.152 --> 00:16:26.220 align:middle
版本则可以

00:16:26.286 --> 00:16:29.156 align:middle
让我们随着时间推移
增加功能

00:16:30.424 --> 00:16:32.926 align:middle
询问功能集
意义不大

00:16:33.861 --> 00:16:36.797 align:middle
只需在Metal设备上

00:16:36.864 --> 00:16:39.967 align:middle
调用supportFeature
Set 来决定是否GPU系列即可

00:16:42.269 --> 00:16:45.072 align:middle
这里是iOS
功能集矩阵

00:16:46.073 --> 00:16:48.642 align:middle
大家会注意到
我们会支持

00:16:48.709 --> 00:16:50.777 align:middle
两个主要GPU系列

00:16:50.844 --> 00:16:51.945 align:middle
和版本来区分

00:16:52.012 --> 00:16:54.248 align:middle
iOS 8

00:16:54.314 --> 00:16:56.383 align:middle
和
iOS 9功能

00:16:59.019 --> 00:17:00.287 align:middle
在OS X中

00:16:59.019 --> 00:17:00.287 align:middle
在OS X中

00:17:00.354 --> 00:17:02.990 align:middle
GPUFamily1 v1
功能集代表

00:17:03.056 --> 00:17:07.227 align:middle
我们将在OS X El
Capitan推出的新功能

00:17:07.828 --> 00:17:10.763 align:middle
这在桌面平台
定义了支持Metal

00:17:10.830 --> 00:17:12.098 align:middle
设备的基础

00:17:15.602 --> 00:17:16.603 align:middle
现在 我想谈谈

00:17:16.670 --> 00:17:20.240 align:middle
两个新的着色器常数
更新我们所添加的API

00:17:21.175 --> 00:17:22.476 align:middle
首先来看看
背景

00:17:23.210 --> 00:17:25.878 align:middle
对于在命令
缓冲区的每个

00:17:26.280 --> 00:17:28.715 align:middle
绘画编码
都需要发送给

00:17:29.416 --> 00:17:30.684 align:middle
着色器部分常数数据

00:17:30.751 --> 00:17:32.786 align:middle
若要每个绘画
都有单独的

00:17:32.853 --> 00:17:34.354 align:middle
常数缓冲区
那么效率就会变得极低

00:17:34.488 --> 00:17:36.490 align:middle
所以一般来说 大多数
Metal应用

00:17:36.557 --> 00:17:39.026 align:middle
会每帧分配
一个单独的常数缓冲区

00:17:39.092 --> 00:17:40.594 align:middle
接着在为
绘画编码时

00:17:41.595 --> 00:17:46.099 align:middle
将常数数据增加到缓冲区

00:17:47.267 --> 00:17:48.569 align:middle
代码会是什么样呢？

00:17:49.803 --> 00:17:50.704 align:middle
首先 我们为

00:17:50.771 --> 00:17:52.673 align:middle
常数缓冲区
和数据设置

00:17:53.440 --> 00:17:55.876 align:middle
正如示意图
在绘图环中

00:17:56.743 --> 00:17:59.880 align:middle
你发送新的
常数数据

00:17:59.947 --> 00:18:02.416 align:middle
或将新的常数数据
圈入常数缓冲器

00:17:59.947 --> 00:18:02.416 align:middle
或将新的常数数据
圈入常数缓冲器

00:18:03.483 --> 00:18:04.685 align:middle
现在 值得注意的是

00:18:04.751 --> 00:18:06.887 align:middle
setVertexBuffer调用

00:18:06.954 --> 00:18:09.056 align:middle
实际上在做两件事

00:18:10.524 --> 00:18:12.059 align:middle
它在设置
常数缓冲区

00:18:12.960 --> 00:18:14.862 align:middle
也在更新
其中的偏移

00:18:15.629 --> 00:18:18.165 align:middle
现在 在这两个
操作中 设置常数

00:18:18.899 --> 00:18:22.269 align:middle
缓冲区的调用
造价最高

00:18:23.036 --> 00:18:24.571 align:middle
Metald的API
可以实现

00:18:24.638 --> 00:18:26.974 align:middle
分离这两个操作

00:18:27.341 --> 00:18:29.209 align:middle
并将造价高的调用

00:18:29.276 --> 00:18:30.744 align:middle
用来设置常数缓冲区

00:18:31.144 --> 00:18:33.347 align:middle
或顶点缓冲
在绘画环之外

00:18:34.748 --> 00:18:37.317 align:middle
如果每帧有数千
绘图调用

00:18:37.651 --> 00:18:39.319 align:middle
这就会有大量
的节约

00:18:41.722 --> 00:18:44.291 align:middle
但是如果你只有
少量的常数数据

00:18:44.491 --> 00:18:46.260 align:middle
让Metal来管理
常数缓冲区效率

00:18:46.326 --> 00:18:47.995 align:middle
也许
会更高

00:18:49.496 --> 00:18:52.266 align:middle
Metal有setVertex
Bytes API

00:18:52.733 --> 00:18:54.835 align:middle
你可以用它来为

00:18:54.902 --> 00:18:58.605 align:middle
每个绘画调用增加新常数

00:19:00.841 --> 00:19:02.376 align:middle
实际上 关于这一点
我还要补充一些

00:19:02.809 --> 00:19:04.511 align:middle
我说过

00:19:04.578 --> 00:19:06.547 align:middle
如果只有
少量常数

00:19:06.613 --> 00:19:08.982 align:middle
API很好
可以有数十字节常数

00:19:09.917 --> 00:19:12.219 align:middle
如果有更大的
常数集

00:19:12.286 --> 00:19:13.754 align:middle
你想在

00:19:13.820 --> 00:19:15.455 align:middle
其他API中使用

00:19:16.356 --> 00:19:18.325 align:middle
很可能 这样会
效果更好

00:19:20.394 --> 00:19:22.362 align:middle
好 我现在来谈谈
新的内存模型

00:19:24.631 --> 00:19:27.167 align:middle
新内存模型的目标
是支持统一

00:19:27.234 --> 00:19:29.670 align:middle
和离散的内存
系统 而无需

00:19:29.736 --> 00:19:32.105 align:middle
做出
太多改变

00:19:32.739 --> 00:19:34.842 align:middle
Metal现在支持
离散内存

00:19:34.908 --> 00:19:38.045 align:middle
这是高速内存
部分桌面的

00:19:38.111 --> 00:19:41.014 align:middle
GPU可以访问

00:19:42.182 --> 00:19:43.483 align:middle
我们实现
这些的方式

00:19:43.951 --> 00:19:46.820 align:middle
是通过新的存储模式

00:19:47.387 --> 00:19:49.022 align:middle
你可以明确

00:19:49.323 --> 00:19:50.424 align:middle
资源在
内存中的位置

00:19:51.124 --> 00:19:52.426 align:middle
模式可以是共享

00:19:53.060 --> 00:19:55.128 align:middle
专用和

00:19:55.562 --> 00:19:57.297 align:middle
托管状态

00:19:58.398 --> 00:20:00.234 align:middle
在接下来的幻灯片中

00:19:58.398 --> 00:20:00.234 align:middle
在接下来的幻灯片中

00:20:00.300 --> 00:20:01.802 align:middle
我会依次来介绍

00:20:03.303 --> 00:20:05.939 align:middle
先来看看
共享内存模式

00:20:06.740 --> 00:20:09.376 align:middle
这就是在iOS 8

00:20:09.443 --> 00:20:10.744 align:middle
现有执行的
模式

00:20:11.445 --> 00:20:13.447 align:middle
在统一的内存系统
用于存储

00:20:13.514 --> 00:20:15.983 align:middle
缓冲区或纹理的

00:20:16.049 --> 00:20:19.753 align:middle
内存共享
于CPU和GPU之间

00:20:21.421 --> 00:20:22.956 align:middle
内存只有
一份拷贝

00:20:23.524 --> 00:20:26.460 align:middle
内存在命令
缓存区边界方面保持一致

00:20:26.894 --> 00:20:29.563 align:middle
也就是说
在通过CPU访问之前

00:20:29.897 --> 00:20:31.865 align:middle
需要用GPU
做此番处理

00:20:32.633 --> 00:20:34.501 align:middle
这会令它易于使用

00:20:36.436 --> 00:20:38.505 align:middle
但在iOS 9

00:20:38.572 --> 00:20:40.374 align:middle
和OS X
El Capitan中

00:20:40.440 --> 00:20:43.777 align:middle
我们
引入了专用存储模式

00:20:44.511 --> 00:20:45.812 align:middle
专用内存

00:20:45.879 --> 00:20:48.148 align:middle
只能
通过渲染 计算

00:20:48.482 --> 00:20:51.084 align:middle
或传送操作
由GPU进行访问

00:20:52.052 --> 00:20:54.788 align:middle
专用内存的优势
在于性能

00:20:55.455 --> 00:20:57.658 align:middle
Metal可以用
最便于GPU

00:20:57.724 --> 00:21:00.260 align:middle
访问的方式存储数据

00:20:57.724 --> 00:21:00.260 align:middle
访问的方式存储数据

00:21:01.528 --> 00:21:03.830 align:middle
例如 使用
帧缓冲压缩

00:21:06.567 --> 00:21:10.938 align:middle
专用存储模式
与离散内存系统

00:21:11.338 --> 00:21:14.107 align:middle
配合很好
可以将资源

00:21:14.174 --> 00:21:16.743 align:middle
放入GPU可以最快
访问的内存中

00:21:19.313 --> 00:21:21.615 align:middle
现在 只有在OS X中

00:21:22.049 --> 00:21:24.151 align:middle
我们引入了托管
存储模式

00:21:24.351 --> 00:21:27.921 align:middle
有了托管内存
资源就可以在

00:21:27.988 --> 00:21:28.889 align:middle
离散内存

00:21:28.956 --> 00:21:30.624 align:middle
和系统
内存中进行存储

00:21:31.024 --> 00:21:34.361 align:middle
Metal管理着两个
拷贝的一致性

00:21:36.029 --> 00:21:38.899 align:middle
这样可以提供
分享存储模式的

00:21:38.966 --> 00:21:40.901 align:middle
便捷性和灵活性

00:21:40.968 --> 00:21:42.135 align:middle
在多数情况下

00:21:42.202 --> 00:21:44.338 align:middle
是专用存储模式的性能

00:21:46.907 --> 00:21:49.610 align:middle
如果你有统一内存系统的

00:21:50.244 --> 00:21:52.546 align:middle
桌面系统

00:21:52.613 --> 00:21:54.047 align:middle
就你不必担心

00:21:54.114 --> 00:21:55.749 align:middle
托管额外的
开销

00:21:56.116 --> 00:21:59.119 align:middle
只有Metal维护的资源的
一份拷贝

00:22:02.789 --> 00:22:05.225 align:middle
如果要调整CPU
或GPU的数据

00:22:05.292 --> 00:22:07.461 align:middle
还有另外
两方面需要

00:22:07.528 --> 00:22:09.596 align:middle
考虑

00:22:10.464 --> 00:22:11.331 align:middle
首先

00:22:11.398 --> 00:22:13.333 align:middle
如果要用
CPU调整数据

00:22:13.767 --> 00:22:17.804 align:middle
则要通过调用缓冲
didModifyRange

00:22:18.238 --> 00:22:21.008 align:middle
或纹理replaceRegion
API 让Metal了解

00:22:22.342 --> 00:22:24.578 align:middle
同样 如果要
读回数据

00:22:24.912 --> 00:22:27.915 align:middle
则需要调用synchronize
Resource API

00:22:28.815 --> 00:22:29.983 align:middle
还要注意的是

00:22:30.050 --> 00:22:32.386 align:middle
在真正用CPU读取

00:22:32.452 --> 00:22:34.855 align:middle
数据前 要等到
操作完成之后才行

00:22:38.492 --> 00:22:40.427 align:middle
我们现在来看
之前展示的

00:22:40.494 --> 00:22:42.563 align:middle
着色器常数升级实例

00:22:43.063 --> 00:22:46.266 align:middle
这个实例正在
使用共享内存

00:22:47.901 --> 00:22:49.803 align:middle
在离散内存系统中

00:22:49.870 --> 00:22:52.139 align:middle
你很想让常数

00:22:52.506 --> 00:22:53.640 align:middle
在离散内存中

00:22:54.107 --> 00:22:56.610 align:middle
这就可能要用到
专用缓冲区

00:22:57.044 --> 00:22:59.613 align:middle
还是必须要
将转移托管到缓冲区

00:23:00.480 --> 00:23:03.817 align:middle
使用托管缓冲区
则要简单很多

00:23:03.884 --> 00:23:05.586 align:middle
有它就会相当容易

00:23:05.652 --> 00:23:07.387 align:middle
只需要
做两点

00:23:08.255 --> 00:23:09.223 align:middle
首先

00:23:09.289 --> 00:23:11.959 align:middle
在生成
常数缓冲区时

00:23:12.025 --> 00:23:13.627 align:middle
必须明确
托管存储模式

00:23:14.862 --> 00:23:15.696 align:middle
然后

00:23:15.762 --> 00:23:18.031 align:middle
要调用
didModifyRange

00:23:18.098 --> 00:23:22.002 align:middle
告知Metal 你已经用
CPU升级了常数

00:23:22.503 --> 00:23:23.470 align:middle
就这样

00:23:23.537 --> 00:23:26.073 align:middle
代码的其余部分
仍然保持不变

00:23:28.642 --> 00:23:30.677 align:middle
值得注意的是
在默认情况下

00:23:30.744 --> 00:23:32.746 align:middle
缓冲区可以在所有平台共享

00:23:34.047 --> 00:23:35.182 align:middle
在iOS

00:23:35.249 --> 00:23:37.618 align:middle
在默认状况下
纹理也是同样如此

00:23:38.118 --> 00:23:40.187 align:middle
但是在OS X上

00:23:40.654 --> 00:23:43.290 align:middle
我们选择为纹理托管

00:23:43.657 --> 00:23:45.025 align:middle
制作默认模式
因为它可以允许

00:23:45.092 --> 00:23:47.828 align:middle
编写携带版代码
而不影响性能

00:23:50.831 --> 00:23:53.133 align:middle
但是在有些情况下
你不会想要

00:23:53.200 --> 00:23:54.434 align:middle
使用托管纹理

00:23:54.635 --> 00:23:55.569 align:middle
这就是其中之一

00:23:56.069 --> 00:23:57.371 align:middle
当你有帧缓冲区

00:23:57.437 --> 00:23:58.839 align:middle
或可渲染纹理时

00:23:58.906 --> 00:24:01.441 align:middle
你想用专用
存储模式

00:23:58.906 --> 00:24:01.441 align:middle
你想用专用
存储模式

00:24:01.508 --> 00:24:02.843 align:middle
还获取最佳性能

00:24:03.510 --> 00:24:05.445 align:middle
如果只有GPU可以

00:24:05.712 --> 00:24:07.381 align:middle
访问数据
这就非常重要

00:24:09.016 --> 00:24:11.985 align:middle
这就是我们在Metal中的
新内存模式

00:24:12.052 --> 00:24:14.588 align:middle
我想来介绍Metal中的
两个部分功能

00:24:15.155 --> 00:24:18.058 align:middle
都是OS X特有的
我觉得你会喜欢

00:24:19.026 --> 00:24:20.961 align:middle
首先是分层渲染

00:24:21.495 --> 00:24:23.530 align:middle
API的意图是要

00:24:23.597 --> 00:24:26.533 align:middle
让你可以将绘制的

00:24:26.600 --> 00:24:28.969 align:middle
每个三角形的纹理

00:24:29.036 --> 00:24:30.604 align:middle
的具体层次
都能进行渲染

00:24:31.238 --> 00:24:34.041 align:middle
因此这可以是
数组纹理的切片

00:24:34.641 --> 00:24:36.677 align:middle
3D纹理的平面
或立体纹理的表面

00:24:37.077 --> 00:24:39.079 align:middle
在每个三角形的基础上
你可以明确

00:24:40.714 --> 00:24:43.083 align:middle
要渲染哪一层

00:24:43.450 --> 00:24:45.919 align:middle
只要在顶点着色器中

00:24:45.986 --> 00:24:49.156 align:middle
明确数组索引即可

00:24:50.424 --> 00:24:53.160 align:middle
游戏《堡垒之夜》
就是用的这种技术

00:24:53.360 --> 00:24:56.230 align:middle
为部分环境照明
渲染立方体

00:24:56.296 --> 00:24:58.131 align:middle
贴图的表面

00:24:58.298 --> 00:25:01.001 align:middle
我们认为 你也会
觉得这个功能同样有用

00:24:58.298 --> 00:25:01.001 align:middle
我们认为 你也会
觉得这个功能同样有用

00:25:04.271 --> 00:25:06.840 align:middle
第二个功能
也是OS X所特有

00:25:07.174 --> 00:25:09.409 align:middle
就是纹理壁垒

00:25:10.644 --> 00:25:12.746 align:middle
在默认状态
GPU会倾向于覆盖

00:25:12.813 --> 00:25:14.648 align:middle
绘画调用的执行

00:25:15.382 --> 00:25:17.317 align:middle
不能在随后的调用中

00:25:17.384 --> 00:25:19.620 align:middle
可靠使用绘画
调用的输出

00:25:19.686 --> 00:25:22.189 align:middle
而无需某种形式的显性同步

00:25:23.290 --> 00:25:24.992 align:middle
Metal现有一个API

00:25:25.058 --> 00:25:26.360 align:middle
可以在这些

00:25:26.426 --> 00:25:28.295 align:middle
绘画调用之间插入壁垒

00:25:30.264 --> 00:25:31.398 align:middle
对于在OS X

00:25:31.465 --> 00:25:34.935 align:middle
执行有效的可编程
混合非常关键

00:25:37.337 --> 00:25:39.306 align:middle
API很易于使用

00:25:39.740 --> 00:25:41.608 align:middle
只是在你想要同步的
绘画操作中间

00:25:41.675 --> 00:25:44.378 align:middle
插入壁垒

00:25:47.614 --> 00:25:49.616 align:middle
最后 当然不是
最不重要的内容

00:25:49.683 --> 00:25:50.617 align:middle
我谈谈

00:25:50.684 --> 00:25:53.787 align:middle
今年Metal的扩展
纹理支持

00:25:55.122 --> 00:25:57.758 align:middle
在默认条件下

00:25:57.824 --> 00:25:59.660 align:middle
iOS中所有纹理的

00:25:59.726 --> 00:26:02.896 align:middle
最大限制已经
增至8k

00:25:59.726 --> 00:26:02.896 align:middle
最大限制已经
增至8k

00:26:03.430 --> 00:26:06.266 align:middle
我们还增加了
OS X的立方体数组支持

00:26:07.000 --> 00:26:08.936 align:middle
在所有平台上
的各板中

00:26:09.002 --> 00:26:11.939 align:middle
都能提高
防叠效果

00:26:13.440 --> 00:26:15.876 align:middle
我们还大量
增加了像素格式

00:26:15.943 --> 00:26:18.412 align:middle
便于在计算着色器
编写

00:26:18.478 --> 00:26:20.714 align:middle
或读取数据

00:26:24.551 --> 00:26:27.321 align:middle
还有是纹理
使用属性

00:26:28.188 --> 00:26:30.324 align:middle
这可以实现
对纹理标签

00:26:30.791 --> 00:26:33.694 align:middle
告知Metal 你准备
怎样使用它们

00:26:33.894 --> 00:26:36.697 align:middle
Metal会对使用进行优化

00:26:37.531 --> 00:26:38.799 align:middle
例如

00:26:38.866 --> 00:26:40.534 align:middle
如果你有
可渲染纹理时

00:26:40.868 --> 00:26:42.769 align:middle
想要设置renderTarget

00:26:42.836 --> 00:26:44.938 align:middle
和shaderRead旗标

00:26:46.173 --> 00:26:47.374 align:middle
这会告知Metal

00:26:47.441 --> 00:26:48.909 align:middle
你计划在纹理上

00:26:48.976 --> 00:26:51.044 align:middle
所渲染 然后还要
从中取样

00:26:53.146 --> 00:26:54.414 align:middle
默认状态下

00:26:54.481 --> 00:26:56.416 align:middle
使用是未知的

00:26:56.817 --> 00:26:59.987 align:middle
Metal不会做任何假设
纹理会如何使用

00:27:00.320 --> 00:27:02.222 align:middle
允许Metal在系统的
任何地方进行使用

00:27:05.893 --> 00:27:07.628 align:middle
与iOS不同

00:27:07.694 --> 00:27:08.962 align:middle
桌面
GPU 更喜欢

00:27:09.029 --> 00:27:11.565 align:middle
单独境深
模板纹理

00:27:13.100 --> 00:27:16.370 align:middle
我们添加了两个
新的组合境深模板格式

00:27:17.004 --> 00:27:18.238 align:middle
32-8格式

00:27:18.305 --> 00:27:21.875 align:middle
在所有
硬件

00:27:21.942 --> 00:27:23.911 align:middle
iOS和OS X
都会支持

00:27:24.645 --> 00:27:27.981 align:middle
不过只有部分会
支持24-8格式

00:27:28.549 --> 00:27:30.584 align:middle
如果这意味着
是精度要求

00:27:30.651 --> 00:27:32.085 align:middle
就需要检查
是否可用

00:27:37.090 --> 00:27:39.059 align:middle
我们来谈谈
纹理压缩

00:27:40.027 --> 00:27:43.030 align:middle
所以所用压缩格式类型
取决于所

00:27:43.096 --> 00:27:44.398 align:middle
针对的设备

00:27:44.698 --> 00:27:46.733 align:middle
以及编码的
数据类型

00:27:47.467 --> 00:27:48.569 align:middle
在iOS

00:27:48.635 --> 00:27:50.404 align:middle
我们支持
若干格式

00:27:50.470 --> 00:27:52.439 align:middle
包括PVRTC

00:27:52.506 --> 00:27:54.074 align:middle
ETC2

00:27:54.141 --> 00:27:55.609 align:middle
和EAC

00:27:55.676 --> 00:27:58.512 align:middle
对于GPUFamily2的
新增内容是

00:27:58.579 --> 00:28:01.014 align:middle
我们也支持ASTC

00:27:58.579 --> 00:28:01.014 align:middle
我们也支持ASTC

00:28:03.317 --> 00:28:06.553 align:middle
因此ASTC是高质量
压缩

00:28:07.221 --> 00:28:08.655 align:middle
要比相同大小的

00:28:09.156 --> 00:28:11.859 align:middle
PVRTC和ETC
要好很多

00:28:12.926 --> 00:28:16.129 align:middle
它可以实现
对若干不同格式的

00:28:16.597 --> 00:28:18.465 align:middle
图像内容

00:28:18.532 --> 00:28:19.733 align:middle
高度图

00:28:19.800 --> 00:28:21.902 align:middle
法线图等等进行编码

00:28:25.172 --> 00:28:29.076 align:middle
它还提供了
尺寸和质量之间的

00:28:29.142 --> 00:28:30.544 align:middle
细粒度控制

00:28:30.777 --> 00:28:32.312 align:middle
每个像素为
1到8 bits

00:28:32.913 --> 00:28:33.981 align:middle
在低端

00:28:34.047 --> 00:28:37.050 align:middle
这是PVRTC
所需的一般存储

00:28:38.785 --> 00:28:39.920 align:middle
最后

00:28:39.987 --> 00:28:41.722 align:middle
如我之前提到

00:28:41.788 --> 00:28:44.224 align:middle
这只在支持GPUFamily2的

00:28:44.291 --> 00:28:45.526 align:middle
设备上可用

00:28:45.592 --> 00:28:46.760 align:middle
所以 大家
要留意这点

00:28:51.098 --> 00:28:52.733 align:middle
最后 在OS X中

00:28:52.799 --> 00:28:55.002 align:middle
我们介绍了桌面GPU

00:28:55.068 --> 00:28:58.505 align:middle
支持的所有原生纹理
压缩格式

00:28:59.840 --> 00:29:01.642 align:middle
这些BCn格式

00:28:59.840 --> 00:29:01.642 align:middle
这些BCn格式

00:29:01.708 --> 00:29:03.076 align:middle
大家
应该都很熟悉

00:29:03.744 --> 00:29:05.679 align:middle
如果是在桌面平台

00:29:05.746 --> 00:29:07.281 align:middle
或游戏控制台工作过

00:29:07.347 --> 00:29:10.717 align:middle
你可能已经有了
这种格式的资产

00:29:12.252 --> 00:29:14.288 align:middle
这是我们的扩展
纹理支持

00:29:14.788 --> 00:29:17.291 align:middle
我今天就
介绍这些功能

00:29:19.493 --> 00:29:21.094 align:middle
我想换个话题

00:29:21.161 --> 00:29:22.296 align:middle
谈谈一种

00:29:22.362 --> 00:29:24.331 align:middle
名为app瘦身的
新技术

00:29:24.531 --> 00:29:26.400 align:middle
在上次讲座中
大家可能听到过一些

00:29:27.668 --> 00:29:30.003 align:middle
这不是Metal特有的
功能

00:29:30.337 --> 00:29:31.638 align:middle
但是它是基于

00:29:31.705 --> 00:29:35.509 align:middle
以前我在讲座中之前介绍的
GPU系列

00:29:36.710 --> 00:29:38.512 align:middle
首先 设定上下文

00:29:39.146 --> 00:29:41.582 align:middle
开发人员典型的游戏开发

00:29:41.648 --> 00:29:44.184 align:middle
和开发流程
在我们的平台上

00:29:44.251 --> 00:29:45.419 align:middle
基本是
这个样子

00:29:46.820 --> 00:29:48.522 align:middle
你一般会有
艺术管道

00:29:48.589 --> 00:29:49.690 align:middle
来生成部分资产

00:29:51.491 --> 00:29:53.594 align:middle
资产是通过Xcode搭建

00:29:53.660 --> 00:29:55.295 align:middle
或自定义工具管道

00:29:55.362 --> 00:29:56.697 align:middle
是二进制格式

00:29:57.865 --> 00:29:59.466 align:middle
然后二进制格式再

00:29:59.533 --> 00:30:01.435 align:middle
发送到App Store的某处
这个具体的

00:29:59.533 --> 00:30:01.435 align:middle
发送到App Store的某处
这个具体的

00:30:02.236 --> 00:30:04.538 align:middle
或是相同的二进制
要部署到

00:30:04.605 --> 00:30:08.642 align:middle
你的所有用户的
设备中

00:30:09.309 --> 00:30:10.377 align:middle
这样很好

00:30:11.478 --> 00:30:13.146 align:middle
但是一旦开始有了
具备具体设备

00:30:13.213 --> 00:30:15.148 align:middle
功能的资产

00:30:15.215 --> 00:30:18.385 align:middle
就会开始遇到
一些问题

00:30:22.055 --> 00:30:23.724 align:middle
例如

00:30:23.790 --> 00:30:25.659 align:middle
如果
有些资产是专门针对

00:30:25.726 --> 00:30:26.960 align:middle
Metal设备

00:30:27.027 --> 00:30:29.930 align:middle
有些资产
是特别用于旧式设备

00:30:31.198 --> 00:30:33.700 align:middle
现在必须要下载
两种版本

00:30:33.767 --> 00:30:36.103 align:middle
以便用于所有的用户设备

00:30:37.971 --> 00:30:39.473 align:middle
显然 这并不理想

00:30:41.942 --> 00:30:44.378 align:middle
App瘦身可以通过
允许按照功能

00:30:44.444 --> 00:30:47.748 align:middle
为资产贴标签 来解决这个问题

00:30:48.115 --> 00:30:50.751 align:middle
这样只有
设备需要的资产

00:30:50.817 --> 00:30:54.421 align:middle
才会真正
下载到设备中

00:30:55.923 --> 00:30:56.990 align:middle
具体怎么做呢？

00:30:58.225 --> 00:30:59.593 align:middle
app瘦身

00:30:59.860 --> 00:31:02.095 align:middle
可以实现

00:30:59.860 --> 00:31:02.095 align:middle
可以实现

00:31:02.162 --> 00:31:06.166 align:middle
跨越两级来定义功能

00:31:06.733 --> 00:31:08.368 align:middle
即GPUFamily版本

00:31:08.435 --> 00:31:10.237 align:middle
和
设备内存大小

00:31:10.304 --> 00:31:12.906 align:middle
这就会生成一个矩阵
可以用来针对

00:31:12.973 --> 00:31:14.942 align:middle
具体设备

00:31:18.512 --> 00:31:21.281 align:middle
我们现在来看
典型的法线图实例

00:31:22.783 --> 00:31:25.752 align:middle
理想状态下 你希望将
法线图压缩存储

00:31:26.520 --> 00:31:28.322 align:middle
EAC是不错的
格式

00:31:29.523 --> 00:31:31.358 align:middle
但是因为部分

00:31:31.425 --> 00:31:33.894 align:middle
就是设备不支持压缩纹理

00:31:33.961 --> 00:31:36.163 align:middle
特别是EAC
你可能需要

00:31:36.230 --> 00:31:38.565 align:middle
该资产的
未压缩格式

00:31:40.667 --> 00:31:43.837 align:middle
app瘦身可以
为资产加标签

00:31:43.904 --> 00:31:45.038 align:middle
并仅下载

00:31:45.105 --> 00:31:48.509 align:middle
压缩格式到支持Metal的设备上

00:31:48.575 --> 00:31:51.879 align:middle
未压缩版本到
旧式设备中

00:31:52.746 --> 00:31:55.115 align:middle
但是app瘦身
的功能还不仅如此

00:31:55.182 --> 00:31:56.750 align:middle
我们来继续扩展实例

00:31:57.918 --> 00:31:59.786 align:middle
它可以支持
更多设备

00:31:59.853 --> 00:32:02.456 align:middle
具体在本例中
我们将生成5个资产

00:31:59.853 --> 00:32:02.456 align:middle
具体在本例中
我们将生成5个资产

00:32:03.190 --> 00:32:06.660 align:middle
我们先从高分辨率的
ASTC版本

00:32:07.327 --> 00:32:10.230 align:middle
用于最强大的2GB设备

00:32:10.364 --> 00:32:13.500 align:middle
然后 我们会包括
稍低的分辨率

00:32:13.734 --> 00:32:16.270 align:middle
用于1GB版本的
设备

00:32:16.603 --> 00:32:20.007 align:middle
因为部分Metal设备
并不支持ASTC

00:32:20.741 --> 00:32:22.476 align:middle
我们也会包括
EAC版本

00:32:23.510 --> 00:32:25.879 align:middle
然后 对于
旧式设备

00:32:25.946 --> 00:32:28.115 align:middle
我们有未压缩
版本的资产

00:32:29.183 --> 00:32:31.818 align:middle
我们可以把这个
实例进一步扩展

00:32:31.885 --> 00:32:35.989 align:middle
通过最低未压缩
资产的较低

00:32:36.590 --> 00:32:39.359 align:middle
分辨率的版本
用于较低端的设备

00:32:39.459 --> 00:32:40.561 align:middle
512MB的配置

00:32:42.196 --> 00:32:44.598 align:middle
你可能不希望
生成5个资产

00:32:45.098 --> 00:32:46.834 align:middle
但是我想要
说明的一点是

00:32:46.900 --> 00:32:49.236 align:middle
你有着极大的
灵活度来

00:32:49.303 --> 00:32:51.205 align:middle
锁定具体设备

00:32:51.271 --> 00:32:54.041 align:middle
为用户生成
最佳体验

00:32:56.643 --> 00:32:59.112 align:middle
Xcode整合了
很好的UI 可以

00:32:59.179 --> 00:33:01.648 align:middle
这样来为资产加标签

00:32:59.179 --> 00:33:01.648 align:middle
这样来为资产加标签

00:33:03.116 --> 00:33:04.718 align:middle
首先需要做的是
定义你要

00:33:04.785 --> 00:33:07.654 align:middle
锁定的
设备功能

00:33:09.256 --> 00:33:10.991 align:middle
这会生成
小矩阵

00:33:11.491 --> 00:33:13.293 align:middle
然后只需要

00:33:13.360 --> 00:33:14.995 align:middle
留下资产

00:33:15.062 --> 00:33:18.332 align:middle
以便与GPUFamily系列的

00:33:18.398 --> 00:33:21.235 align:middle
相互交叉和
准备锁定的设备内存大小相匹配即可

00:33:22.970 --> 00:33:24.137 align:middle
这非常简单

00:33:25.539 --> 00:33:26.740 align:middle
但是 当然我们

00:33:26.807 --> 00:33:28.709 align:middle
意识到并非所有的
开发人员都有

00:33:28.775 --> 00:33:31.144 align:middle
存在于Xcode的工具管道

00:33:31.211 --> 00:33:33.080 align:middle
所以我们也包括了这些

00:33:33.614 --> 00:33:36.450 align:middle
我们支持app瘦身的
JSON文件格式

00:33:36.517 --> 00:33:40.320 align:middle
以便明确
资产分类

00:33:41.288 --> 00:33:42.856 align:middle
正如在Xcode一样

00:33:42.923 --> 00:33:45.359 align:middle
你需要明确GPUFamily版本

00:33:46.193 --> 00:33:48.562 align:middle
以及希望包含在
分类中的各资产的

00:33:48.629 --> 00:33:50.264 align:middle
设备类型

00:33:53.934 --> 00:33:56.203 align:middle
一旦将资产分类
定义完毕

00:33:56.970 --> 00:33:58.906 align:middle
怎样在运行时间
获取数据呢？

00:34:00.807 --> 00:34:03.577 align:middle
答案就是
NSDataAsset类

00:34:03.944 --> 00:34:06.680 align:middle
它可以提供
与运行设备的

00:34:06.747 --> 00:34:09.248 align:middle
功能相匹配的
资产

00:34:10.317 --> 00:34:13.286 align:middle
通过NSDataAsset
很容易做到

00:34:14.688 --> 00:34:15.688 align:middle
只要

00:34:16.989 --> 00:34:19.025 align:middle
用赋予
资产分类的名称

00:34:19.092 --> 00:34:21.929 align:middle
分配NSDataAsset
对象即可

00:34:22.529 --> 00:34:23.730 align:middle
然后在数据中使用

00:34:25.465 --> 00:34:28.635 align:middle
通过我开始展示的
示意图和法线图

00:34:28.969 --> 00:34:30.469 align:middle
实例来把它
接合在一起

00:34:31.638 --> 00:34:33.774 align:middle
在这种情况下
你的艺术家可以

00:34:33.841 --> 00:34:36.476 align:middle
生成一系列法线图
部分压缩 部分未压缩

00:34:36.543 --> 00:34:38.110 align:middle
锁定你想要的
具体设备

00:34:39.980 --> 00:34:42.549 align:middle
可以通过Xcode
或自定义工具管道

00:34:42.616 --> 00:34:45.485 align:middle
做成二进制格式
包括很多资产的

00:34:45.552 --> 00:34:48.522 align:middle
庞大二进制格式
上传到App Store

00:34:49.523 --> 00:34:51.324 align:middle
最棒的是

00:34:51.391 --> 00:34:53.025 align:middle
只有用户所需的法线图

00:34:53.092 --> 00:34:56.295 align:middle
才会下载到
他们的设备中

00:35:02.903 --> 00:35:04.338 align:middle
这就是app瘦身

00:35:05.439 --> 00:35:08.408 align:middle
我们认为 这将会
改变大家

00:35:08.475 --> 00:35:10.644 align:middle
在支持Metal的设备上

00:35:11.111 --> 00:35:12.746 align:middle
生成和部署内容的方法

00:35:14.781 --> 00:35:16.650 align:middle
这就是在过去12个月间

00:35:16.717 --> 00:35:19.386 align:middle
Metal生态系统

00:35:19.453 --> 00:35:20.621 align:middle
的旋风之旅

00:35:21.188 --> 00:35:23.290 align:middle
我们看到像诸位这样的
开发人员 使用Metal

00:35:23.357 --> 00:35:24.825 align:middle
生成非常出色的内容

00:35:25.659 --> 00:35:27.828 align:middle
我们将Metal带入了OS X

00:35:28.161 --> 00:35:31.832 align:middle
我们也将所有出色的
Metal GPU工具带入OS X

00:35:33.333 --> 00:35:35.602 align:middle
我们引入了部分强大的
新款API

00:35:35.969 --> 00:35:37.337 align:middle
相信大家
一定会喜欢

00:35:38.372 --> 00:35:40.541 align:middle
最后 我们谈到了
Metal怎样与

00:35:40.607 --> 00:35:43.810 align:middle
系统相整合
通过app瘦身技术来实现

00:35:45.212 --> 00:35:47.514 align:middle
总之 这是
相当不错的一年

00:35:47.581 --> 00:35:50.450 align:middle
我们非常渴望
看到大家

00:35:50.951 --> 00:35:52.886 align:middle
在来年能对Metal
有怎样的出色应用

00:35:55.355 --> 00:35:57.858 align:middle
请来访问我们的
在线文档资料

00:36:00.093 --> 00:36:02.095 align:middle
还可以到支持论坛
看看

00:36:02.162 --> 00:36:04.064 align:middle
如果问题没有
得到解答 当然还可以

00:36:04.131 --> 00:36:07.034 align:middle
联系我们的
游戏技术开发顾问

00:36:07.100 --> 00:36:09.102 align:middle
阿兰·斯卡夫

00:36:10.504 --> 00:36:12.306 align:middle
本周还有两场讲座

00:36:12.873 --> 00:36:15.742 align:middle
《Metal技术最新内容》下半场

00:36:15.809 --> 00:36:17.311 align:middle
安排在周四上午

00:36:17.377 --> 00:36:20.581 align:middle
《Metal性能优化技术》
讲座则是

00:36:20.647 --> 00:36:22.015 align:middle
在周五

00:36:22.082 --> 00:36:23.684 align:middle
请务必要记得参加

00:36:24.117 --> 00:36:24.985 align:middle
非常感谢
