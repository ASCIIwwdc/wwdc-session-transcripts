WEBVTT

00:00:17.451 --> 00:00:21.388 align:middle line:0
（高效使用集合 演讲229）

00:00:21.922 --> 00:00:22.923 align:middle line:-1
早上好

00:00:23.991 --> 00:00:24.992 align:middle line:-1
我叫Michael LeHew

00:00:25.092 --> 00:00:27.995 align:middle line:-2
我在Apple Foundation团队
从事集合相关工作

00:00:28.962 --> 00:00:31.465 align:middle line:-1
今天我想谈一些

00:00:31.532 --> 00:00:34.268 align:middle line:-2
你应该知道的事
以确保你能够尽可能高效地

00:00:34.334 --> 00:00:35.636 align:middle line:-1
在Swift中使用集合

00:00:37.104 --> 00:00:39.006 align:middle line:-1
今天我会讨论很多领域

00:00:39.339 --> 00:00:43.277 align:middle line:-2
关于Swift中可用集合的
详细信息和各个方面

00:00:43.844 --> 00:00:45.812 align:middle line:-1
我们将探索一些常见的误区

00:00:46.113 --> 00:00:48.048 align:middle line:-2
以及如何避免它们
包括性能问题

00:00:48.115 --> 00:00:50.250 align:middle line:-1
我也将提供非常具体的建议

00:00:50.317 --> 00:00:52.553 align:middle line:-1
关于何时该选择哪些特定集合

00:00:53.287 --> 00:00:54.288 align:middle line:-1
让我们开始吧

00:00:54.988 --> 00:00:56.356 align:middle line:-1
我想让你想象一个

00:00:57.758 --> 00:00:59.326 align:middle line:-1
没有集合的世界

00:01:01.795 --> 00:01:03.797 align:middle line:-2
在这个世界中
我们可能没有数组

00:01:04.063 --> 00:01:05.432 align:middle line:-1
但它仍然有熊

00:01:07.100 --> 00:01:08.702 align:middle line:-1
但每次当我们需要另一只熊

00:01:09.870 --> 00:01:11.939 align:middle line:-1
我们就需要定义另一个变量

00:01:12.005 --> 00:01:13.607 align:middle line:-1
我们想对这些熊做些事情

00:01:13.674 --> 00:01:15.475 align:middle line:-1
我们只能够重复自己

00:01:16.243 --> 00:01:17.311 align:middle line:-1
很可怕 对吧

00:01:18.545 --> 00:01:21.448 align:middle line:-2
但更糟的是
这个世界也没有字典

00:01:22.482 --> 00:01:24.451 align:middle line:-1
但幸好我们是聪明的开发者

00:01:24.785 --> 00:01:26.520 align:middle line:-1
我们可以用函数来解决这个问题

00:01:26.820 --> 00:01:29.690 align:middle line:-2
我们煞费苦心地定义了
我们关心的每种情况

00:01:30.691 --> 00:01:33.427 align:middle line:0
使用这个函数与使用字典非常相似

00:01:33.627 --> 00:01:36.163 align:middle line:0
除了我们需要的那些动态功能

00:01:36.630 --> 00:01:37.965 align:middle line:0
但谁喜欢可变状态 对吧？

00:01:38.899 --> 00:01:41.268 align:middle line:0
但幸运的是
我们并不生活在这个世界中

00:01:42.336 --> 00:01:44.805 align:middle line:-2
值得庆幸的是
我们的世界有既有熊也有集合

00:01:45.072 --> 00:01:47.741 align:middle line:-1
以及用于定义它们的丰富的原生语法

00:01:49.576 --> 00:01:52.212 align:middle line:-2
还有当我们迭代时
帮助我们不必重复自己

00:01:53.847 --> 00:01:55.949 align:middle line:-1
或获取集合中的元素的API

00:01:57.584 --> 00:02:01.021 align:middle line:-2
集合非常普遍并且共享如此多的
常见特性和算法

00:01:57.584 --> 00:02:01.021 align:middle line:-2
集合非常普遍并且共享如此多的
常见特性和算法

00:02:01.088 --> 00:02:03.490 align:middle line:-2
因此在Swift中
它们都遵守一个通用协议

00:02:05.058 --> 00:02:07.027 align:middle line:-2
毫不奇怪
它叫Collection

00:02:08.161 --> 00:02:09.795 align:middle line:-1
在Swift中 集合就是序列

00:02:09.863 --> 00:02:12.199 align:middle line:-1
其中的元素可以以非破坏性的方式

00:02:12.366 --> 00:02:13.367 align:middle line:-1
多次遍历

00:02:13.534 --> 00:02:15.802 align:middle line:-1
并且其元素可以通过下标访问

00:02:16.103 --> 00:02:17.771 align:middle line:-1
（COLLECTION协议）

00:02:17.838 --> 00:02:19.139 align:middle line:-1
我们看看这是如何做到的

00:02:19.206 --> 00:02:21.808 align:middle line:-1
考虑一下集合的抽象表示

00:02:21.875 --> 00:02:22.876 align:middle line:-1
（集合存储元素）

00:02:22.943 --> 00:02:25.445 align:middle line:-2
这可能是一个在连续内存中
定义的数组

00:02:25.646 --> 00:02:27.681 align:middle line:-1
哈希表 红黑树

00:02:28.815 --> 00:02:30.918 align:middle line:-2
链接、列表或你可以想象的
任何其它东西

00:02:31.451 --> 00:02:34.154 align:middle line:-1
重要的是它支持初始索引的概念

00:02:34.221 --> 00:02:35.489 align:middle line:-1
其被称为起始索引

00:02:35.556 --> 00:02:36.723 align:middle line:-1
（起始索引）

00:02:36.790 --> 00:02:39.726 align:middle line:-1
它可以用来访问集合的初始元素

00:02:40.561 --> 00:02:41.562 align:middle line:-1
它还有一个结束索引

00:02:41.628 --> 00:02:43.230 align:middle line:-1
其标识集合的结束

00:02:43.297 --> 00:02:44.131 align:middle line:-1
（结束索引）

00:02:44.198 --> 00:02:45.999 align:middle line:-1
集合支持从其起始索引

00:02:46.133 --> 00:02:48.302 align:middle line:-1
到结束索引之间遍历元素的能力

00:02:49.436 --> 00:02:51.038 align:middle line:-1
它们可以多次进行这种遍历

00:02:51.438 --> 00:02:54.474 align:middle line:-1
它们也支持使用下标来获取

00:02:54.541 --> 00:02:56.043 align:middle line:-1
集合中的元素

00:02:56.109 --> 00:02:57.377 align:middle line:-1
（SUBSCRIPT[INDEX]）

00:02:57.444 --> 00:02:58.812 align:middle line:-1
我们看看它在代码中的样子

00:02:59.680 --> 00:03:01.715 align:middle line:-1
的确 如果我们看一下集合的定义

00:02:59.680 --> 00:03:01.715 align:middle line:-1
的确 如果我们看一下集合的定义

00:03:01.949 --> 00:03:03.750 align:middle line:-1
它被声明为一个元素序列

00:03:04.852 --> 00:03:07.688 align:middle line:-1
它还有一个关联类型称为Index

00:03:07.788 --> 00:03:08.989 align:middle line:-2
其必须遵守
Comparable协议

00:03:10.490 --> 00:03:12.659 align:middle line:-1
它提供了一个下标来检索元素

00:03:12.793 --> 00:03:13.961 align:middle line:-1
或使用该索引

00:03:14.695 --> 00:03:16.330 align:middle line:-1
我们定义一个起始和结束索引

00:03:16.563 --> 00:03:18.498 align:middle line:-1
以确定集合的范围

00:03:18.932 --> 00:03:22.202 align:middle line:-2
最后 这里有一个
index(after)函数

00:03:22.269 --> 00:03:24.638 align:middle line:-2
可以让我们从一个索引
到达另一个索引

00:03:25.572 --> 00:03:27.508 align:middle line:-1
最后这个函数非常重要

00:03:27.875 --> 00:03:30.077 align:middle line:-1
因为它允许标准库

00:03:30.410 --> 00:03:32.679 align:middle line:-1
通过强大的协议扩展来定义

00:03:32.946 --> 00:03:35.215 align:middle line:-1
许多有用且强大的默认行为

00:03:35.415 --> 00:03:36.650 align:middle line:-1
让我们看看其中的一些

00:03:37.518 --> 00:03:38.352 align:middle line:-1
（协议扩展）

00:03:38.418 --> 00:03:39.820 align:middle line:-2
当你遵守
Collection协议时

00:03:39.887 --> 00:03:42.422 align:middle line:-1
你可以访问各种丰富的功能

00:03:42.656 --> 00:03:46.059 align:middle line:-1
如能够让你获取首尾元素的属性

00:03:46.360 --> 00:03:47.394 align:middle line:-1
或识别集合大小

00:03:48.195 --> 00:03:49.963 align:middle line:-1
或检查集合是否为空

00:03:50.397 --> 00:03:52.666 align:middle line:-2
你还可以通过API
使用forEach语法

00:03:52.733 --> 00:03:54.234 align:middle line:-1
来遍历集合元素

00:03:55.369 --> 00:03:58.172 align:middle line:-2
及超有用的函数 如map
filter和reduce

00:03:59.206 --> 00:04:01.108 align:middle line:-1
我们还可以通过添加自己的扩展

00:03:59.206 --> 00:04:01.108 align:middle line:-1
我们还可以通过添加自己的扩展

00:04:01.175 --> 00:04:02.576 align:middle line:-1
来让集合更加强大

00:04:03.043 --> 00:04:03.911 align:middle line:-1
（间隔元素）

00:04:03.977 --> 00:04:06.713 align:middle line:-1
集合已经提供了遍历每个元素的方法

00:04:06.780 --> 00:04:10.584 align:middle line:-2
但我想要一个函数
能够让我遍历间隔元素

00:04:10.651 --> 00:04:12.519 align:middle line:-1
即在遍历过程中跳过一些值

00:04:13.587 --> 00:04:15.989 align:middle line:-2
我们将通过向集合添加扩展
来实现这点

00:04:16.055 --> 00:04:17.858 align:middle line:-1
我们从方法签名开始

00:04:18.158 --> 00:04:19.793 align:middle line:-2
我们称该函数为
everyOther

00:04:19.860 --> 00:04:23.397 align:middle line:-2
并且它将采用一个闭包
来调用我们想要的每个元素

00:04:24.064 --> 00:04:25.766 align:middle line:-1
我们得到迭代的边界

00:04:26.500 --> 00:04:29.403 align:middle line:-2
并定义一个初始值为
start的值的变量

00:04:29.469 --> 00:04:30.904 align:middle line:-1
该变量值将随运行而改变

00:04:32.105 --> 00:04:34.174 align:middle line:-1
我们在当前元素上调用闭包

00:04:34.441 --> 00:04:37.177 align:middle line:-1
并递增我们的索引

00:04:37.911 --> 00:04:39.646 align:middle line:-1
此时我们的索引可能已经无效

00:04:39.713 --> 00:04:40.848 align:middle line:-1
即我们已到集合的最后

00:04:40.914 --> 00:04:42.916 align:middle line:-1
因此我们需要确保检查它

00:04:43.250 --> 00:04:45.819 align:middle line:-2
如果还没越界
那么我们可以再次增加索引

00:04:46.353 --> 00:04:47.888 align:middle line:-1
从而跳过间隔元素

00:04:48.355 --> 00:04:51.825 align:middle line:0
如果我们在1到10的封闭范围内
调用这个函数

00:04:52.092 --> 00:04:54.261 align:middle line:0
可以看到我们跳过了偶数元素

00:04:55.929 --> 00:04:59.366 align:middle line:-2
我们看到集合可以让我们
描述一些非常强大的行为

00:05:00.200 --> 00:05:02.102 align:middle line:-1
但实际上集合并不孤单

00:05:02.436 --> 00:05:03.971 align:middle line:-1
其实集合不是我们唯一的协议

00:05:04.037 --> 00:05:05.205 align:middle line:-1
在Swift中 我们可以访问

00:05:05.272 --> 00:05:07.674 align:middle line:-1
丰富的集合协议层次结构

00:05:07.741 --> 00:05:09.676 align:middle line:-1
其中每个都对我们提供的类型假设

00:05:09.743 --> 00:05:11.345 align:middle line:-1
做了极大改善

00:05:11.678 --> 00:05:13.247 align:middle line:-1
让我们继续讨论其中一些协议

00:05:13.313 --> 00:05:14.615 align:middle line:-1
（集合协议层次结构）

00:05:14.681 --> 00:05:18.318 align:middle line:-2
我们知道集合可以让你
从给定的索引向前移动

00:05:18.385 --> 00:05:19.586 align:middle line:-1
（集合）

00:05:19.653 --> 00:05:21.455 align:middle line:-1
但也存在双向集合

00:05:21.522 --> 00:05:23.323 align:middle line:-1
它可以让你沿着另一个方向移动

00:05:23.390 --> 00:05:24.791 align:middle line:-1
（双向集合）

00:05:24.858 --> 00:05:27.995 align:middle line:-1
当然 双向集合也是集合

00:05:28.061 --> 00:05:29.997 align:middle line:-1
所以我们仍然可以向前迭代

00:05:31.565 --> 00:05:33.367 align:middle line:-1
下一个最灵活的集合形式

00:05:33.433 --> 00:05:35.302 align:middle line:-1
就是所谓的随机访问集合

00:05:35.369 --> 00:05:39.239 align:middle line:-1
它要求当根据某个索引计算另一个

00:05:39.306 --> 00:05:41.909 align:middle line:-1
或计算两个索引之间的距离的时候

00:05:41.975 --> 00:05:44.111 align:middle line:-1
所需的时间是常量

00:05:44.411 --> 00:05:46.346 align:middle line:-1
编译器无法保证这一点

00:05:46.413 --> 00:05:48.515 align:middle line:-1
所以当你使用随机访问集合时

00:05:48.582 --> 00:05:49.750 align:middle line:-1
你正在作出一项承诺

00:05:50.517 --> 00:05:52.786 align:middle line:-2
但如果你满足这个承诺
如果你能兑现承诺

00:05:52.853 --> 00:05:54.021 align:middle line:-1
这个协议就可以让你

00:05:54.087 --> 00:05:57.090 align:middle line:-1
在常量时间内访问集合中的任何索引

00:05:57.991 --> 00:06:00.327 align:middle line:-1
当然 随机访问集合仍然是集合

00:05:57.991 --> 00:06:00.327 align:middle line:-1
当然 随机访问集合仍然是集合

00:06:00.394 --> 00:06:02.663 align:middle line:-1
所以你仍然可以向前和向后迭代

00:06:02.729 --> 00:06:04.264 align:middle line:-1
（随机访问集合）

00:06:04.331 --> 00:06:07.401 align:middle line:-2
作为Swift开发人员
我们可以访问遵守这些协议的

00:06:07.467 --> 00:06:08.702 align:middle line:-1
许多有用的集合

00:06:10.237 --> 00:06:12.406 align:middle line:-2
这类集合包括Array
Set和Dictionary等

00:06:12.506 --> 00:06:14.007 align:middle line:-2
（SWIFT中的集合
ARRAY - SET- DICTIONARY）

00:06:14.074 --> 00:06:15.943 align:middle line:-1
但由于这些协议的通用目的

00:06:16.009 --> 00:06:19.413 align:middle line:-1
许多其它类型也遵守这些集合协议

00:06:19.479 --> 00:06:21.582 align:middle line:-2
如Data
Range和String

00:06:21.648 --> 00:06:22.783 align:middle line:-1
（DATA - RANGE - STRING）

00:06:22.850 --> 00:06:24.051 align:middle line:-1
或是索引集合

00:06:24.284 --> 00:06:26.553 align:middle line:-1
它们都可以访问所有这些丰富的功能

00:06:26.620 --> 00:06:29.189 align:middle line:-1
只要它们以自己的方式遵守集合协议

00:06:29.389 --> 00:06:31.959 align:middle line:-2
确实 一旦你知道其中任意一种类型
的工作原理

00:06:32.025 --> 00:06:34.228 align:middle line:-2
你就可以将该知识
应用于任何其它类型

00:06:34.795 --> 00:06:35.963 align:middle line:-1
并且这些类型还不少

00:06:37.231 --> 00:06:40.667 align:middle line:-2
我将谈谈类型如何
遵守集合协议的细节

00:06:40.934 --> 00:06:44.171 align:middle line:-1
这一切都从描述如何索引开始

00:06:44.838 --> 00:06:46.306 align:middle line:-1
（索引）

00:06:46.373 --> 00:06:48.308 align:middle line:-1
每个集合都有自己的索引

00:06:49.843 --> 00:06:51.378 align:middle line:-2
该索引必须遵守
Comparable协议

00:06:52.246 --> 00:06:56.483 align:middle line:-2
在某些情况下 索引可能是整数
如数组中的索引

00:06:56.683 --> 00:06:58.819 align:middle line:-1
但仅仅因为索引碰巧是一个整数

00:06:58.886 --> 00:07:00.854 align:middle line:-1
并不意味着你只能这样用

00:06:58.886 --> 00:07:00.854 align:middle line:-1
并不意味着你只能这样用

00:07:01.421 --> 00:07:04.458 align:middle line:-2
现在我想问几个问题
其答案可能出乎预料

00:07:05.125 --> 00:07:07.194 align:middle line:-2
第一个是
我们如何获得数组的第一个元素

00:07:08.595 --> 00:07:12.499 align:middle line:-2
你可能马上会想“这个简单
我只需调用array[0]”

00:07:12.966 --> 00:07:14.635 align:middle line:-1
数组的索引恰好是整数

00:07:14.701 --> 00:07:17.604 align:middle line:-2
所以你有时可以这样说
并得到你想要的结果

00:07:17.971 --> 00:07:19.540 align:middle line:-1
但这不是最好的办法

00:07:19.640 --> 00:07:21.341 align:middle line:-1
我要继续问同样的问题

00:07:21.408 --> 00:07:23.410 align:middle line:-1
但这次是关于另一种集合

00:07:25.078 --> 00:07:26.547 align:middle line:-1
Set的第一个元素是什么？

00:07:26.947 --> 00:07:29.416 align:middle line:-1
听起来像一个很奇怪的问题 对吧？

00:07:29.483 --> 00:07:30.484 align:middle line:-1
Set是无序的

00:07:30.984 --> 00:07:32.319 align:middle line:-1
然而它们的确是集合

00:07:32.386 --> 00:07:34.388 align:middle line:-1
并且作为集合 你可以遍历它们

00:07:34.454 --> 00:07:35.522 align:middle line:-1
当遍历一个Set时

00:07:35.589 --> 00:07:37.724 align:middle line:-1
你将首先遍历一个元素

00:07:37.791 --> 00:07:40.127 align:middle line:-1
所以这正是我们刚才问的问题

00:07:40.827 --> 00:07:42.062 align:middle line:-1
我能用set[0]吗？

00:07:42.896 --> 00:07:44.631 align:middle line:-1
编译器会说不

00:07:45.132 --> 00:07:48.235 align:middle line:-1
这是因为Set的索引类型不是整数

00:07:48.969 --> 00:07:51.471 align:middle line:-2
类型系统希望我们
使用正确的索引类型

00:07:52.940 --> 00:07:54.675 align:middle line:-1
幸运的是 我们已知如何做到这点

00:07:54.741 --> 00:07:57.778 align:middle line:-2
我们知道集合协议告诉我们所有集合
都有一个startIndex

00:07:57.845 --> 00:07:58.712 align:middle line:-1
让我们继续并使用它

00:07:58.779 --> 00:07:59.646 align:middle line:-1
如果我们这样做

00:07:59.713 --> 00:08:01.448 align:middle line:-1
这实际上适用于所有集合

00:07:59.713 --> 00:08:01.448 align:middle line:-1
这实际上适用于所有集合

00:08:01.515 --> 00:08:05.185 align:middle line:-2
startIndex
将始终代表你在遍历时

00:08:05.252 --> 00:08:06.887 align:middle line:-1
看到的第一个元素

00:08:06.954 --> 00:08:08.522 align:middle line:-1
但在任何集合中使用下标索引时

00:08:08.589 --> 00:08:11.458 align:middle line:-1
有一个细微之处需要注意

00:08:12.960 --> 00:08:15.095 align:middle line:-1
那就是 它可能会崩溃

00:08:16.063 --> 00:08:18.565 align:middle line:-2
我实际上还没有断言
这些集合中有内容

00:08:18.632 --> 00:08:22.836 align:middle line:-2
我直接使用了startIndex
然而这些集合可能是空的

00:08:23.570 --> 00:08:26.306 align:middle line:-1
事实证明 访问集合中的第一个元素

00:08:26.373 --> 00:08:29.276 align:middle line:-2
是一个很普遍的任务
所以我们有更好的方法

00:08:29.343 --> 00:08:30.944 align:middle line:-1
（致命错误：索引超出范围）

00:08:31.011 --> 00:08:32.246 align:middle line:-1
即只需调用first

00:08:32.880 --> 00:08:35.015 align:middle line:-2
如果你调用first
这会更安全

00:08:35.082 --> 00:08:37.116 align:middle line:-1
因为其返回类型为可选的

00:08:37.417 --> 00:08:40.386 align:middle line:-2
回忆一下并非所有集合
都具有第一个元素的事实

00:08:42.456 --> 00:08:43.724 align:middle line:-1
我还有另一个问题

00:08:44.591 --> 00:08:48.028 align:middle line:-2
集合的第二个元素是什么
我想在这里强调集合本身

00:08:48.262 --> 00:08:49.263 align:middle line:-1
它可以是任何集合

00:08:49.329 --> 00:08:51.865 align:middle line:-2
一个数组、一个Set
或者甚至还不存在的东西

00:08:52.866 --> 00:08:55.636 align:middle line:-2
我们通过协议扩展向集合
添加一个新属性

00:08:55.702 --> 00:08:56.870 align:middle line:-1
我们称其为second

00:08:56.937 --> 00:08:58.739 align:middle line:-2
和first一样
它的返回类型为可选的

00:08:58.805 --> 00:09:00.908 align:middle line:-1
因为并非所有集合都有两个元素

00:08:58.805 --> 00:09:00.908 align:middle line:-1
因为并非所有集合都有两个元素

00:09:02.176 --> 00:09:06.547 align:middle line:-1
我们试试这样写 self[1]

00:09:06.780 --> 00:09:10.017 align:middle line:-2
但这里我们的基于0的索引直觉
会将我们带入歧途

00:09:10.317 --> 00:09:12.386 align:middle line:-1
然后我们会再次被编译器抓个正着

00:09:13.854 --> 00:09:15.756 align:middle line:-1
我们希望此代码能够适用于每种集合

00:09:15.822 --> 00:09:18.091 align:middle line:-1
而不只是使用整数作为索引的集合

00:09:18.959 --> 00:09:20.561 align:middle line:-1
所以我们尝试一种不同的方法

00:09:21.195 --> 00:09:23.864 align:middle line:-2
我真正想要的是
比startIndex大1的索引

00:09:23.931 --> 00:09:25.566 align:middle line:-1
（找到一个集合的第二个元素）

00:09:25.632 --> 00:09:27.968 align:middle line:-1
但编译器仍不依不饶

00:09:29.102 --> 00:09:31.471 align:middle line:-1
你不能将对任意索引类型加一

00:09:31.572 --> 00:09:34.107 align:middle line:-2
索引类型应该是不透明的
或者可以是不透明的

00:09:35.576 --> 00:09:36.777 align:middle line:-1
我们在这里真正要做的

00:09:36.844 --> 00:09:39.513 align:middle line:-2
是我们需要使用
集合协议提供的API

00:09:39.580 --> 00:09:40.447 align:middle line:-1
来做到这一点

00:09:40.514 --> 00:09:41.849 align:middle line:-1
我们来试试

00:09:42.683 --> 00:09:45.519 align:middle line:-1
我注释了为了找到第二个元素

00:09:45.586 --> 00:09:46.854 align:middle line:-1
需要做的事情的框架

00:09:47.187 --> 00:09:48.422 align:middle line:-1
我们需要做的第一件事是

00:09:48.488 --> 00:09:50.691 align:middle line:-1
我们需要检查集合是否为空

00:09:51.024 --> 00:09:52.526 align:middle line:-1
集合在其startIndex

00:09:52.593 --> 00:09:54.561 align:middle line:-1
等于endIndex时为空

00:09:54.862 --> 00:09:56.763 align:middle line:-1
所以我们来检查一下并返回nil

00:09:57.431 --> 00:10:00.901 align:middle line:-1
因为这样的集合没有第二个元素

00:09:57.431 --> 00:10:00.901 align:middle line:-1
因为这样的集合没有第二个元素

00:10:03.136 --> 00:10:06.139 align:middle line:0
现在可以假设我们的集合有一个元素

00:10:07.774 --> 00:10:11.144 align:middle line:-2
我们可以使用index(after)函数
来获取第二个元素或第二个索引

00:10:11.612 --> 00:10:13.714 align:middle line:-1
但我们需要确保该索引是有效的

00:10:14.147 --> 00:10:15.182 align:middle line:-1
我们直观地来看一下

00:10:15.282 --> 00:10:17.985 align:middle line:-2
我们向前移动了一个元素
但如果集合中只有一个元素

00:10:18.051 --> 00:10:19.786 align:middle line:-1
我们现在的索引实际上是无效的

00:10:19.853 --> 00:10:21.288 align:middle line:-1
如果我们试图用下标索引它

00:10:21.355 --> 00:10:23.557 align:middle line:-1
我们就会得到刚才看到的严重错误

00:10:23.624 --> 00:10:24.691 align:middle line:-1
所以我们检查它是否有效

00:10:24.758 --> 00:10:26.159 align:middle line:-1
这与空链非常相似

00:10:26.226 --> 00:10:27.961 align:middle line:-1
我们只需要确保我们的索引

00:10:28.028 --> 00:10:30.163 align:middle line:-2
不等于endIndex
否则返回nil

00:10:30.564 --> 00:10:35.102 align:middle line:-2
同样 因为单元素集合
没有第二个元素

00:10:35.969 --> 00:10:37.838 align:middle line:0
这时我们确认了所有假设都成立

00:10:37.905 --> 00:10:40.107 align:middle line:0
并知道我们的集合至少有两个元素

00:10:40.407 --> 00:10:42.743 align:middle line:0
所以我们可以安全地
为该索引使用下标运算符

00:10:43.877 --> 00:10:45.279 align:middle line:0
从而检索我们想要的值

00:10:47.181 --> 00:10:49.883 align:middle line:-1
这些代码看起来很多

00:10:50.150 --> 00:10:52.753 align:middle line:-2
但值得指出的是
这个通用目的索引

00:10:52.819 --> 00:10:55.322 align:middle line:-2
将可以处理任何集合
这非常棒

00:10:55.889 --> 00:10:58.425 align:middle line:-2
但其实Swift有更好的方法
来做到这一点

00:10:58.859 --> 00:11:00.394 align:middle line:-1
即一个叫做切片的东西

00:10:58.859 --> 00:11:00.394 align:middle line:-1
即一个叫做切片的东西

00:11:00.627 --> 00:11:02.229 align:middle line:-2
但在展示如何使用切片
做到这点之前

00:11:02.296 --> 00:11:05.365 align:middle line:-2
我想谈谈什么是切片
以及它们如何工作

00:11:06.934 --> 00:11:08.202 align:middle line:-1
（构造一个切片）

00:11:08.268 --> 00:11:11.872 align:middle line:-1
切片是仅描述集合的一部分的类型

00:11:13.207 --> 00:11:16.376 align:middle line:-1
每个切片都有自己的起始和结束索引

00:11:17.077 --> 00:11:20.881 align:middle line:-1
并且切片与其原始集合分开存在

00:11:21.481 --> 00:11:24.484 align:middle line:-2
切片如此高效的原因是
它们不占用额外的存储空间

00:11:24.551 --> 00:11:26.854 align:middle line:-1
它们只是引用原始集合

00:11:27.788 --> 00:11:31.592 align:middle line:0
当使用切片下标时
它将读出原始缓冲区中的数据

00:11:32.726 --> 00:11:33.994 align:middle line:-1
它们可以这样做是因为

00:11:34.728 --> 00:11:37.264 align:middle line:-1
它们与其原始集合共享同样的索引

00:11:37.497 --> 00:11:39.833 align:middle line:-2
我们来看看这是如何工作的
我们可以证明这一点

00:11:40.133 --> 00:11:41.335 align:middle line:-1
我们将从一个数组开始

00:11:41.869 --> 00:11:43.704 align:middle line:0
我们丢弃该数组的第一个元素

00:11:43.770 --> 00:11:46.273 align:middle line:0
以生成一个少了一个元素的切片

00:11:47.107 --> 00:11:49.309 align:middle line:0
由于我们想要证明索引

00:11:49.376 --> 00:11:51.411 align:middle line:0
我们需要得到数组的第二个索引

00:11:51.745 --> 00:11:54.281 align:middle line:0
即得到起始索引之后的一个索引

00:11:54.515 --> 00:11:55.415 align:middle line:0
然后比较它们

00:11:55.482 --> 00:11:57.184 align:middle line:0
它们的确是一样的

00:11:58.485 --> 00:11:59.620 align:middle line:-1
这个dropFirst函数

00:11:59.686 --> 00:12:02.890 align:middle line:-2
看起来就是我们得到集合中
第二个元素的简便方法

00:11:59.686 --> 00:12:02.890 align:middle line:-2
看起来就是我们得到集合中
第二个元素的简便方法

00:12:03.724 --> 00:12:05.125 align:middle line:-1
让我们回到之前的解决方案

00:12:05.192 --> 00:12:07.561 align:middle line:-1
看看切片的表达能力有多强

00:12:08.629 --> 00:12:10.597 align:middle line:-1
还记得我们之前写的复杂的

00:12:10.664 --> 00:12:11.765 align:middle line:-1
索引检查代码吗

00:12:12.799 --> 00:12:15.235 align:middle line:-2
通过使用dropFirst
我们将让切片

00:12:15.302 --> 00:12:17.371 align:middle line:-2
替我们处理那些复杂的
索引边界检查过程

00:12:18.005 --> 00:12:19.706 align:middle line:-1
由于第一个返回值是可选的

00:12:20.941 --> 00:12:24.444 align:middle line:-2
这在集合为空或只有一个元素时
也能按预期工作

00:12:25.078 --> 00:12:26.880 align:middle line:-1
让我们将发生的事情可视化出来

00:12:27.614 --> 00:12:28.615 align:middle line:-1
我们从一个数组开始

00:12:28.682 --> 00:12:31.185 align:middle line:0
我们通过丢弃第一个元素
来构造一个切片

00:12:32.352 --> 00:12:37.624 align:middle line:0
然后我们使用first属性
对切片进行下标运算

00:12:37.691 --> 00:12:39.760 align:middle line:0
并从原始集合中获取元素

00:12:39.927 --> 00:12:42.863 align:middle line:-2
我不知道你怎么想
但我更愿意维护这样的代码

00:12:44.898 --> 00:12:47.034 align:middle line:-2
每种类型都可以
自由描述自己的切片类型

00:12:47.100 --> 00:12:48.101 align:middle line:-1
很多也正是这样做的

00:12:48.669 --> 00:12:51.038 align:middle line:-2
例如 Array
定义了ArraySlice

00:12:51.104 --> 00:12:53.240 align:middle line:-1
它们是为了数组最经常处理的情况

00:12:53.307 --> 00:12:54.508 align:middle line:-1
所特别定制的

00:12:54.908 --> 00:12:58.378 align:middle line:-2
类似地 String定义了
Substring切片类型

00:12:58.946 --> 00:13:00.147 align:middle line:-1
而Substring也是为了

00:12:58.946 --> 00:13:00.147 align:middle line:-1
而Substring也是为了

00:13:00.214 --> 00:13:02.616 align:middle line:-1
处理最常见的字符串行为而定制的

00:13:03.350 --> 00:13:04.785 align:middle line:-1
一些类型 如Set

00:13:05.953 --> 00:13:07.855 align:middle line:-1
将使用标准库中定义的

00:13:07.921 --> 00:13:09.189 align:middle line:-1
广义切片类型

00:13:09.289 --> 00:13:10.390 align:middle line:-1
因为Set是无序的

00:13:10.457 --> 00:13:11.758 align:middle line:-1
它们能做的事情并不多

00:13:11.825 --> 00:13:14.161 align:middle line:-2
它们基本上只需要维护
一个起始和一个结束索引

00:13:14.228 --> 00:13:16.230 align:middle line:-1
以及一个指向原始集合的指针

00:13:16.864 --> 00:13:19.800 align:middle line:-2
另一方面 Data和Range是
它们自己的切片类型

00:13:20.300 --> 00:13:22.469 align:middle line:-1
所以这里有很多选项

00:13:22.970 --> 00:13:25.172 align:middle line:-1
在继续之前我还想谈一件

00:13:25.239 --> 00:13:26.240 align:middle line:-1
关于切片的事情

00:13:27.708 --> 00:13:29.743 align:middle line:-1
假设我们有一个非常大的集合

00:13:29.810 --> 00:13:32.079 align:middle line:-1
比如有上亿个元素

00:13:33.180 --> 00:13:35.816 align:middle line:-2
然后我们为该集合的一部分
创建几个小切片

00:13:36.650 --> 00:13:38.418 align:middle line:-1
重要的是要记住切片

00:13:38.485 --> 00:13:41.455 align:middle line:-1
使整个原始集合保持活跃状态

00:13:41.688 --> 00:13:43.423 align:middle line:-1
只要切片还存在

00:13:43.524 --> 00:13:45.092 align:middle line:-1
而这可能导致令人惊讶的问题

00:13:45.158 --> 00:13:46.527 align:middle line:-1
我们看看这在代码中是什么样的

00:13:48.095 --> 00:13:49.963 align:middle line:-1
假设我在数组上有一个扩展

00:13:50.030 --> 00:13:51.465 align:middle line:-1
允许我返回其前半部分

00:13:51.532 --> 00:13:55.269 align:middle line:-2
我在这里使用dropLast函数
来做到这一点

00:13:55.836 --> 00:13:57.504 align:middle line:-1
我们有一个包含8个数字的数组

00:13:57.571 --> 00:13:58.739 align:middle line:-1
我们调用扩展

00:13:59.773 --> 00:14:00.774 align:middle line:-1
生成切片

00:13:59.773 --> 00:14:00.774 align:middle line:-1
生成切片

00:14:01.008 --> 00:14:03.977 align:middle line:-2
然后尝试释放这8个数字的
原始存储空间

00:14:04.178 --> 00:14:06.346 align:middle line:-1
我将该数组设为一个空数组

00:14:07.514 --> 00:14:10.050 align:middle line:-1
第一件趣事的线索是

00:14:10.117 --> 00:14:12.786 align:middle line:-1
发生在我们访问切片的第一个元素时

00:14:13.520 --> 00:14:14.788 align:middle line:-1
我们竟然能够得到1

00:14:14.855 --> 00:14:19.126 align:middle line:-2
尽管我们已经释放了
原始数组的存储空间

00:14:19.526 --> 00:14:22.229 align:middle line:-2
要么它有一个副本
要么发生了一些不可思议的事情

00:14:23.330 --> 00:14:26.533 align:middle line:0
如果我们想要消除那个缓冲区

00:14:27.100 --> 00:14:30.003 align:middle line:0
这里发生的神奇的事
是我们还能访问那个缓冲区

00:14:30.103 --> 00:14:31.471 align:middle line:0
所以如果我们想清除它

00:14:31.538 --> 00:14:32.773 align:middle line:0
我们可以做的是

00:14:33.073 --> 00:14:35.042 align:middle line:0
从切片创建一个
数组的真实副本

00:14:35.809 --> 00:14:38.445 align:middle line:0
然后如果我们将该切片
设置为一个空数组

00:14:39.079 --> 00:14:40.480 align:middle line:0
那个副本仍然有效

00:14:41.415 --> 00:14:43.050 align:middle line:-1
让我们看看发生了什么

00:14:43.250 --> 00:14:44.384 align:middle line:-1
我们从一个数组开始

00:14:45.018 --> 00:14:47.387 align:middle line:-2
然后我们根据该数组的前半部分
构造了一个切片

00:14:47.454 --> 00:14:49.756 align:middle line:-1
（复制切片）

00:14:49.823 --> 00:14:51.758 align:middle line:-1
然后我们创建了它的一个副本

00:14:52.426 --> 00:14:54.928 align:middle line:-2
将数组设置为空
并将该切片也设置为空

00:14:54.995 --> 00:14:59.032 align:middle line:-2
只有在我们这样做后
底层存储才会真正消失

00:15:01.201 --> 00:15:03.837 align:middle line:-1
就这点而言 切片有点像延迟拷贝

00:15:04.204 --> 00:15:05.205 align:middle line:-1
你可以选择

00:15:05.572 --> 00:15:07.574 align:middle line:-1
何时自己创建元素的副本

00:15:08.242 --> 00:15:11.478 align:middle line:-2
事实证明 这种“懒”行为
和延迟做某事的概念

00:15:12.179 --> 00:15:14.114 align:middle line:-1
在其他情况下也非常有用

00:15:15.516 --> 00:15:17.684 align:middle line:-1
其中一种情况是函数调用

00:15:17.751 --> 00:15:18.719 align:middle line:-1
（“急切的”函数）

00:15:18.785 --> 00:15:21.321 align:middle line:-2
默认情况下 Swift中的
函数调用是"急切的"

00:15:22.022 --> 00:15:26.126 align:middle line:-2
也就是说 它们接收了输入
并按照要求返回它们的输出

00:15:27.261 --> 00:15:28.328 align:middle line:-1
考虑这个例子

00:15:28.529 --> 00:15:30.397 align:middle line:-2
我们从一个1到4,000
的Range开始

00:15:30.664 --> 00:15:33.767 align:middle line:-2
Range是代表大量数字的
一种非常简洁的方式

00:15:33.867 --> 00:15:36.637 align:middle line:-2
它只需要首和尾
就能够知道如何生成它们

00:15:37.271 --> 00:15:39.706 align:middle line:-1
我们将其映射为每个值乘以2

00:15:39.773 --> 00:15:42.543 align:middle line:-2
所以我们现在已经分配了
包含4000个元素的数组

00:15:42.743 --> 00:15:45.612 align:middle line:-2
并在它们中的每一个上
执行我们的映射函数

00:15:46.413 --> 00:15:48.282 align:middle line:-1
然后我们将过滤出四个元素

00:15:48.815 --> 00:15:50.317 align:middle line:-1
迄今为止 我们已经

00:15:50.384 --> 00:15:54.988 align:middle line:-1
分配了4,004个元素的空间

00:15:56.156 --> 00:15:57.991 align:middle line:-1
但我们只需要最后四个

00:16:00.427 --> 00:16:02.529 align:middle line:-1
这其中具有大量的中间计算

00:16:02.596 --> 00:16:04.198 align:middle line:-1
而我们并不总是希望这样

00:16:04.731 --> 00:16:06.934 align:middle line:-2
如果有办法不进行这些计算
除非绝对需要

00:16:07.000 --> 00:16:08.502 align:middle line:-1
那就太好了

00:16:10.337 --> 00:16:13.440 align:middle line:-2
Swift对此的回答称为“懒惰”
就像在现实生活中一样

00:16:13.507 --> 00:16:14.675 align:middle line:-1
（惰性函数）

00:16:14.741 --> 00:16:17.511 align:middle line:-1
我们仍然从Range开始

00:16:17.978 --> 00:16:19.813 align:middle line:-2
我们会告诉该Range
让它"懒惰"一点

00:16:19.913 --> 00:16:21.582 align:middle line:-2
当我们这样做时
所发生的事是

00:16:21.648 --> 00:16:25.452 align:middle line:-2
我们用LazyCollection
包装了原始集合

00:16:25.919 --> 00:16:28.455 align:middle line:-2
当我们对这个LazyCollection
执行操作时

00:16:28.622 --> 00:16:30.824 align:middle line:-2
所发生的事是
我们要再次包装它

00:16:30.891 --> 00:16:34.127 align:middle line:-2
所以当我们在它上面调用map时
我们实际上并没有映射

00:16:34.328 --> 00:16:35.429 align:middle line:-1
我们没对该闭包做任何事

00:16:35.495 --> 00:16:38.232 align:middle line:-1
除了将其存储以便我们将来需要它

00:16:38.532 --> 00:16:41.068 align:middle line:-2
如果我进一步过滤了
LazyMapCollection

00:16:41.335 --> 00:16:43.470 align:middle line:-1
过滤器只是简单地包装该映射集合

00:16:43.770 --> 00:16:45.639 align:middle line:-1
请注意它会在将来按需过滤

00:16:45.706 --> 00:16:46.707 align:middle line:-1
而不是现在

00:16:47.841 --> 00:16:49.176 align:middle line:-1
现在让我们继续并请求

00:16:49.243 --> 00:16:51.478 align:middle line:-2
LazyFilterCollection
的第一个元素

00:16:55.516 --> 00:16:56.517 align:middle line:0
当我们这样做时

00:16:57.117 --> 00:16:59.253 align:middle line:0
我们将首先请求
LazyFilterCollection的

00:16:59.319 --> 00:17:00.320 align:middle line:0
第一个元素

00:16:59.319 --> 00:17:00.320 align:middle line:0
第一个元素

00:17:00.687 --> 00:17:02.723 align:middle line:0
但LazyFilterCollection
并不知道

00:17:02.956 --> 00:17:04.724 align:middle line:0
然而它包装了可能知道它的东西

00:17:05.025 --> 00:17:06.492 align:middle line:0
因此它将询问
MapCollection

00:17:06.627 --> 00:17:09.663 align:middle line:0
而MapCollection
也不知道它的第一个元素

00:17:10.163 --> 00:17:11.632 align:middle line:0
但它包装了一个可能知道的集合

00:17:11.832 --> 00:17:13.934 align:middle line:0
的确 Range知道
它的第一个元素

00:17:14.935 --> 00:17:17.171 align:middle line:0
Range的第一个元素是值1

00:17:17.538 --> 00:17:19.473 align:middle line:0
它被返回到
LazyMapCollection

00:17:19.705 --> 00:17:23.109 align:middle line:0
现在LazyMapCollection
可以实际执行它的闭包

00:17:23.877 --> 00:17:25.012 align:middle line:0
计算出值为2

00:17:25.444 --> 00:17:27.214 align:middle line:0
该值被返回到
LazyFilterCollection

00:17:27.281 --> 00:17:28.782 align:middle line:0
并作为候选的第一个元素

00:17:29.283 --> 00:17:32.319 align:middle line:0
在这种情况下 我们很幸运
因为2恰好比10小

00:17:32.419 --> 00:17:35.656 align:middle line:0
所以LazyFilterCollection
在第一次尝试中就找到了它的第一个元素

00:17:36.256 --> 00:17:37.891 align:middle line:0
并将其返回给调用者

00:17:38.992 --> 00:17:40.961 align:middle line:-1
这是很不同的计算方式

00:17:41.328 --> 00:17:45.499 align:middle line:-2
我提到懒惰的目的是
只根据需要进行计算

00:17:46.033 --> 00:17:49.036 align:middle line:-1
但它避免的另一件事是创建中间存储

00:17:49.203 --> 00:17:50.737 align:middle line:-1
所以我想向你展示一个例子

00:17:52.339 --> 00:17:54.842 align:middle line:-2
假设我们有一个
包含不同类型的熊的数组

00:17:55.242 --> 00:17:58.879 align:middle line:-2
然而我想指出的是
其中一些熊是多余的

00:17:59.379 --> 00:18:00.914 align:middle line:-1
我们已经知道他们是熊

00:17:59.379 --> 00:18:00.914 align:middle line:-1
我们已经知道他们是熊

00:18:00.981 --> 00:18:02.449 align:middle line:-1
它们不必再告诉我们

00:18:03.350 --> 00:18:06.119 align:middle line:-2
所以让我们编写一些代码
来找到那些愚蠢的冗余熊

00:18:06.286 --> 00:18:08.455 align:middle line:-2
我们将像刚才一样用惰性过滤器
执行此操作

00:18:08.689 --> 00:18:09.690 align:middle line:-1
在这个例子中

00:18:10.824 --> 00:18:14.261 align:middle line:-2
所生成的惰性过滤器将是一个
LazyFilterCollection

00:18:14.494 --> 00:18:16.063 align:middle line:-1
包装的一个字符串数组

00:18:16.697 --> 00:18:17.698 align:middle line:-1
在我们的闭包中

00:18:17.764 --> 00:18:20.501 align:middle line:-2
我们将在做断言检查之前
打印出我们目前

00:18:20.567 --> 00:18:22.069 align:middle line:-1
正在迭代的那只熊

00:18:22.302 --> 00:18:23.637 align:middle line:-1
这样做是因为我想

00:18:23.704 --> 00:18:26.273 align:middle line:-2
更好理解过滤器工作原理
然后我们将调用first

00:18:26.340 --> 00:18:29.142 align:middle line:-2
当我们这样做时 执行过程将被交给
LazyFilterCollection

00:18:30.210 --> 00:18:34.515 align:middle line:-2
随后LazyFilterCollection
将调用原始存储

00:18:36.450 --> 00:18:37.985 align:middle line:-2
这时我们将打印出
“Grizzly”

00:18:40.621 --> 00:18:43.390 align:middle line:-2
并检查断言
在这种情况下结果为false

00:18:43.457 --> 00:18:44.892 align:middle line:-2
因为“Grizzly”
不包含“Bear”

00:18:44.958 --> 00:18:46.159 align:middle line:-1
并移动到下一个“Panda”

00:18:47.294 --> 00:18:48.462 align:middle line:-1
当我们到达“Panda”时…

00:18:50.764 --> 00:18:53.166 align:middle line:-2
当我们到达“Panda”时
我们会再次打印出“Panda”

00:18:53.867 --> 00:18:55.769 align:middle line:-1
检查它是否包含单词“Bear”

00:18:55.836 --> 00:18:57.304 align:middle line:-1
并移动到“Spectacled”

00:18:57.938 --> 00:19:01.008 align:middle line:-2
“Spectacled”被打印
它也不包含“Bear”一词

00:18:57.938 --> 00:19:01.008 align:middle line:-2
“Spectacled”被打印
它也不包含“Bear”一词

00:19:01.074 --> 00:19:02.976 align:middle line:-2
最后我们移动到
“Gummy Bears”

00:19:03.610 --> 00:19:05.612 align:middle line:-1
它包含“Bear”这个词

00:19:06.680 --> 00:19:10.651 align:middle line:-2
LazyFilterCollection
现在可以将其返回给它的调用者

00:19:12.085 --> 00:19:14.154 align:middle line:-2
若我们再次调用first
会发生什么？

00:19:15.255 --> 00:19:18.492 align:middle line:-1
其实还是一样的过程

00:19:18.892 --> 00:19:22.396 align:middle line:-2
我们询问LazyFilterCollection
它将再次询问底层集合

00:19:22.462 --> 00:19:25.866 align:middle line:-2
底层集合重复刚才的计算
并将结果返回给调用者

00:19:27.935 --> 00:19:29.970 align:middle line:-1
现在这可能不是你想要的

00:19:30.237 --> 00:19:32.806 align:middle line:-2
所以如果你发现自己需要
反复调用惰性集合

00:19:32.873 --> 00:19:34.107 align:middle line:-1
来计算其结果

00:19:34.541 --> 00:19:36.910 align:middle line:-2
有一种方法可以确保
该计算只发生一次

00:19:37.911 --> 00:19:40.380 align:middle line:-2
我们可以通过从惰性集合
创建一个新的非惰性集合

00:19:40.447 --> 00:19:43.684 align:middle line:-1
来确保惰性集合只迭代一次

00:19:44.384 --> 00:19:45.385 align:middle line:-1
当你这样做时

00:19:45.752 --> 00:19:47.654 align:middle line:-1
它仍然会将计算委托给惰性集合

00:19:47.721 --> 00:19:48.555 align:middle line:-1
但现在迭代过程

00:19:48.622 --> 00:19:51.658 align:middle line:-1
将处理完整个底层集合

00:19:53.760 --> 00:19:55.028 align:middle line:-1
从而产生

00:19:55.095 --> 00:19:57.331 align:middle line:-1
该惰性计算的非惰性版本

00:19:57.865 --> 00:20:00.934 align:middle line:-2
这例子中 我们得到一个包含字符串
“Gummy Bears”的数组

00:19:57.865 --> 00:20:00.934 align:middle line:-2
这例子中 我们得到一个包含字符串
“Gummy Bears”的数组

00:20:01.535 --> 00:20:03.570 align:middle line:-1
如果我们打印该数组的第一个元素

00:20:03.637 --> 00:20:06.106 align:middle line:-2
我们根本不需要咨询闭包
或者惰性集合

00:20:06.173 --> 00:20:09.276 align:middle line:-2
我们基本消除了其惰性
并得到一个“急切的”数组

00:20:11.879 --> 00:20:13.046 align:middle line:-1
我们何时该懒惰呢？

00:20:14.081 --> 00:20:16.517 align:middle line:-1
惰性集合是一种非常好的能够消除

00:20:16.583 --> 00:20:18.485 align:middle line:-1
链式映射和过滤器的开销的方法

00:20:18.585 --> 00:20:19.786 align:middle line:-1
当你发现你只需要

00:20:19.853 --> 00:20:22.556 align:middle line:-2
集合运算的部分结果时
它们就非常有用

00:20:23.257 --> 00:20:27.027 align:middle line:-2
但如果你的闭包有副作用
你就应该避免使用懒惰策略

00:20:27.127 --> 00:20:29.396 align:middle line:-1
你的闭包应该鲜有副作用

00:20:29.830 --> 00:20:31.765 align:middle line:-2
并且记得一定要恢复…
或者应该说

00:20:31.832 --> 00:20:34.234 align:middle line:-1
一定要考虑重新恢复到普通集合

00:20:34.301 --> 00:20:35.736 align:middle line:-1
当你跨越API边界时

00:20:36.069 --> 00:20:38.172 align:middle line:-1
惰性通常应该是一个实现细节

00:20:38.238 --> 00:20:39.940 align:middle line:-1
（建议：何时使用惰性？）

00:20:40.007 --> 00:20:42.142 align:middle line:-1
到目前为止 我们已经使用可变集合

00:20:42.209 --> 00:20:43.677 align:middle line:-1
做了很多很酷的事情

00:20:44.978 --> 00:20:47.681 align:middle line:-2
但Swift也允许我们
改变我们的集合

00:20:47.748 --> 00:20:48.982 align:middle line:-1
（集合协议层次结构）

00:20:49.049 --> 00:20:50.751 align:middle line:-1
让我们来谈谈

00:20:50.817 --> 00:20:52.319 align:middle line:-1
这两种尚未讨论过的集合

00:20:53.187 --> 00:20:55.088 align:middle line:-1
其中第一个是可变集合

00:20:55.989 --> 00:20:57.191 align:middle line:-1
它为下标添加了一个setter

00:20:57.257 --> 00:20:59.092 align:middle line:-1
以便你可以更改集合的内容

00:20:59.159 --> 00:21:00.160 align:middle line:-1
但不能更改它的长度

00:20:59.159 --> 00:21:00.160 align:middle line:-1
但不能更改它的长度

00:21:00.427 --> 00:21:02.596 align:middle line:-2
你必须能够
在常数时间内完成这项任务

00:21:02.663 --> 00:21:04.031 align:middle line:-1
（可变集合）

00:21:05.632 --> 00:21:08.502 align:middle line:-1
下一个被称为范围可替换集合

00:21:08.569 --> 00:21:10.504 align:middle line:-1
你可以在这种集合中

00:21:10.571 --> 00:21:14.308 align:middle line:-1
删除元素或插入元素

00:21:16.076 --> 00:21:18.779 align:middle line:-2
现在我想谈谈
我一直被问到的一个问题

00:21:20.347 --> 00:21:22.916 align:middle line:-2
为什么我的完全合理的
集合代码会崩溃？

00:21:23.784 --> 00:21:25.185 align:middle line:-1
像所有好问题的答案一样

00:21:25.252 --> 00:21:27.688 align:middle line:-1
一般我会反问他们我自己的一些问题

00:21:28.355 --> 00:21:31.425 align:middle line:-2
有时候我会从经典问题开始
“你想做什么？”

00:21:31.692 --> 00:21:33.293 align:middle line:-1
接下来我马上会问

00:21:33.360 --> 00:21:35.262 align:middle line:-1
“你是怎么使用集合的？”

00:21:35.362 --> 00:21:36.363 align:middle line:-1
“你在尝试改变它们吗？”

00:21:36.430 --> 00:21:38.866 align:middle line:-2
“你确定没有从多个线程
访问你的集合吗？”

00:21:38.932 --> 00:21:41.401 align:middle line:-1
我问这些问题是因为其答案

00:21:42.436 --> 00:21:45.038 align:middle line:-1
常常能引出导致问题的根本原因

00:21:46.039 --> 00:21:48.141 align:middle line:-1
首先让我们先假设跟线程没关系

00:21:48.208 --> 00:21:50.878 align:middle line:-2
我还没准备好考虑线程
现在9:30都还没到呢

00:21:50.944 --> 00:21:52.079 align:middle line:-1
（崩溃的集合代码）

00:21:52.145 --> 00:21:53.280 align:middle line:-1
假设我们有一个数组

00:21:53.780 --> 00:21:56.350 align:middle line:-1
我们获取一个已知元素的索引

00:21:57.184 --> 00:21:58.418 align:middle line:-1
这个例子中 值为“E”

00:21:58.652 --> 00:22:01.755 align:middle line:-2
然后我们通过删除它的第一个元素
来改变集合

00:21:58.652 --> 00:22:01.755 align:middle line:-2
然后我们通过删除它的第一个元素
来改变集合

00:22:02.656 --> 00:22:05.526 align:middle line:-1
我们继续并打印与该索引关联的元素

00:22:06.360 --> 00:22:07.995 align:middle line:-2
当我们这样做时
不幸的是

00:22:08.996 --> 00:22:10.430 align:middle line:-1
这会产生一个严重错误

00:22:12.032 --> 00:22:13.166 align:middle line:-1
索引不再有效

00:22:13.233 --> 00:22:16.904 align:middle line:-2
实际上当我们改变集合时
索引立即变得无效了

00:22:18.939 --> 00:22:20.040 align:middle line:-1
更安全的方法

00:22:20.340 --> 00:22:24.411 align:middle line:-2
是首先改变我们的集合
然后计算索引

00:22:24.511 --> 00:22:26.446 align:middle line:-1
（避免索引失效）

00:22:26.513 --> 00:22:28.949 align:middle line:-2
值得指出的是
集合改变总会使索引无效

00:22:29.016 --> 00:22:30.651 align:middle line:-1
这不仅适用于数组

00:22:31.118 --> 00:22:34.321 align:middle line:-2
我们来看看这个问题
如何在字典中体现出来

00:22:34.988 --> 00:22:38.225 align:middle line:-2
我们假设有一个字典
其存储了一些熊最喜欢的东西

00:22:39.092 --> 00:22:41.195 align:middle line:-1
我们获取熊最喜爱的食物的索引

00:22:41.361 --> 00:22:44.031 align:middle line:-2
并打印出来
它的确是“salmon”

00:22:45.199 --> 00:22:47.835 align:middle line:0
接下来我们将添加更多
这只熊喜欢的东西

00:22:48.602 --> 00:22:50.938 align:middle line:0
然后我们会确保熊最喜欢的食物
仍然是“salmon”

00:22:51.104 --> 00:22:52.639 align:middle line:0
我们会看到…等一下

00:22:52.706 --> 00:22:55.209 align:middle line:0
熊最喜欢的食物不是“hibernation”
而是"salmon"

00:22:57.077 --> 00:22:58.078 align:middle line:0
就像数组一样

00:22:58.145 --> 00:23:00.948 align:middle line:0
在我们改变字典的那一刻
我们使索引无效了

00:22:58.145 --> 00:23:00.948 align:middle line:0
在我们改变字典的那一刻
我们使索引无效了

00:23:01.448 --> 00:23:03.851 align:middle line:0
值得指出的是
这段代码可能会崩溃

00:23:05.085 --> 00:23:06.553 align:middle line:0
我们该如何解决这个问题呢？

00:23:07.688 --> 00:23:10.524 align:middle line:0
其实这与我们在数组中
使用的修复方法完全一样

00:23:11.225 --> 00:23:13.493 align:middle line:-2
我们只需要在发生改变后
重新计算索引

00:23:14.328 --> 00:23:15.429 align:middle line:-1
请记住一件事

00:23:15.562 --> 00:23:16.997 align:middle line:-1
当你重新计算索引时

00:23:17.297 --> 00:23:18.899 align:middle line:-1
这有时会造成很大的开销

00:23:18.966 --> 00:23:21.768 align:middle line:-1
一些索引搜索方法需要线性时间

00:23:22.336 --> 00:23:25.205 align:middle line:-1
而且你只关心你所需要的那个索引

00:23:26.874 --> 00:23:27.708 align:middle line:-1
所以如果你想

00:23:27.774 --> 00:23:30.344 align:middle line:-2
避免陷入这种情况
以下是我的建议

00:23:30.410 --> 00:23:33.580 align:middle line:-2
请记住 改变集合几乎
总是使你的索引无效

00:23:33.914 --> 00:23:35.983 align:middle line:-1
你有时可能会侥幸成功

00:23:36.049 --> 00:23:38.385 align:middle line:-1
但最好将这视为一条硬性规则

00:23:38.585 --> 00:23:39.953 align:middle line:-1
你最终会为此感到高兴

00:23:40.854 --> 00:23:42.422 align:middle line:-1
还要记住切片依赖于

00:23:42.489 --> 00:23:45.058 align:middle line:-1
其底层的原始集合的状态

00:23:45.125 --> 00:23:46.493 align:middle line:-1
即使是在它发生了改变之后

00:23:46.894 --> 00:23:50.831 align:middle line:-2
因此当底层集合是可变的时
如果你还想继续使用索引或切片

00:23:51.164 --> 00:23:53.133 align:middle line:-1
请务必三思而后行

00:23:53.767 --> 00:23:55.502 align:middle line:-1
并记住索引计算

00:23:55.636 --> 00:23:57.771 align:middle line:-1
有时可能花费大量的时间

00:23:57.838 --> 00:23:59.139 align:middle line:-1
（建议：索引和切片）

00:23:59.206 --> 00:24:01.441 align:middle line:-1
所以注意只在必要时才进行索引计算

00:23:59.206 --> 00:24:01.441 align:middle line:-1
所以注意只在必要时才进行索引计算

00:24:02.910 --> 00:24:05.746 align:middle line:-1
现在让我们来讨论一下线程

00:24:05.812 --> 00:24:07.481 align:middle line:-1
我提到我问的其中一个问题是

00:24:07.548 --> 00:24:10.317 align:middle line:-2
“你的线程是否可以
由多个线程访问？”

00:24:11.618 --> 00:24:12.853 align:middle line:-1
我之所以这样问

00:24:13.053 --> 00:24:14.555 align:middle line:-1
是因为我们的集合假设

00:24:14.621 --> 00:24:16.723 align:middle line:-1
你将从单个线程访问它们

00:24:17.691 --> 00:24:20.294 align:middle line:-1
这对性能来说是一件好事

00:24:20.694 --> 00:24:22.429 align:middle line:-1
这是因为单线程用例

00:24:22.496 --> 00:24:26.300 align:middle line:-2
不需要花费大量资源在锁
或任何其它你用来

00:24:26.366 --> 00:24:29.069 align:middle line:-1
确保互斥的原语上面

00:24:30.237 --> 00:24:33.140 align:middle line:-2
当涉及到线程时
只有使用集合的开发人员

00:24:33.207 --> 00:24:35.375 align:middle line:-1
才拥有以适当的锁或串行队列

00:24:35.442 --> 00:24:37.578 align:middle line:-1
限制访问所需的所有信息

00:24:37.644 --> 00:24:38.912 align:middle line:-1
这些信息的抽象层次要比

00:24:38.979 --> 00:24:41.381 align:middle line:-2
我们这些底层框架开发人员
所能提供的层次高

00:24:42.683 --> 00:24:45.285 align:middle line:-1
我们看看这些问题会是什么样子的

00:24:45.385 --> 00:24:46.486 align:middle line:-1
假设我们有一个数组

00:24:46.553 --> 00:24:48.488 align:middle line:-1
我们想将睡着的熊添加进去

00:24:49.256 --> 00:24:51.892 align:middle line:-1
为了模拟每只熊都是独立的

00:24:51.959 --> 00:24:52.793 align:middle line:-1
并能够管理自己

00:24:52.860 --> 00:24:55.362 align:middle line:-1
我们将访问并发调度队列

00:24:56.230 --> 00:24:58.232 align:middle line:-1
我们将用它来告诉每只熊去睡觉

00:24:58.899 --> 00:25:00.534 align:middle line:-1
并且由于这是一个并发调度队列

00:24:58.899 --> 00:25:00.534 align:middle line:-1
并且由于这是一个并发调度队列

00:25:00.601 --> 00:25:03.637 align:middle line:-1
想象代码同时运行是很有帮助的

00:25:03.904 --> 00:25:06.240 align:middle line:-2
我将它们放在同一行上
以代表并发执行的情况

00:25:07.007 --> 00:25:08.108 align:middle line:-1
稍后在app中

00:25:08.175 --> 00:25:10.043 align:middle line:-1
让我们检查一下那些睡觉的熊

00:25:11.245 --> 00:25:14.548 align:middle line:0
有时我们会看到Grandpa
和Cub在快乐地打盹

00:25:15.048 --> 00:25:18.752 align:middle line:0
其他时候 Cub会先睡觉
然后才是Grandpa

00:25:19.419 --> 00:25:22.389 align:middle line:0
有时 非常神秘
只有Grandpa在睡觉

00:25:23.790 --> 00:25:25.425 align:middle line:0
其他时候
则是只有Cub在睡觉

00:25:26.560 --> 00:25:28.962 align:middle line:0
有时候 我们的程序崩溃了

00:25:29.029 --> 00:25:30.497 align:middle line:0
并且没有熊能够睡觉

00:25:32.132 --> 00:25:33.166 align:middle line:-1
所有这些可能性

00:25:33.233 --> 00:25:35.068 align:middle line:-1
表明存在可能的竞争条件

00:25:35.135 --> 00:25:36.770 align:middle line:-1
其实考虑到这个例子中的线程

00:25:36.837 --> 00:25:40.140 align:middle line:-1
这的确有可能发生

00:25:41.074 --> 00:25:42.176 align:middle line:-1
我们可以使用Xcode中的

00:25:42.242 --> 00:25:45.179 align:middle line:-2
ThreadSanitizer
或TSan来证明这一点

00:25:45.646 --> 00:25:46.647 align:middle line:-1
假设我们这样做的话

00:25:47.214 --> 00:25:49.216 align:middle line:-1
我们将得到这样的输出

00:25:49.783 --> 00:25:51.585 align:middle line:-1
TSan的确发现了竞争

00:25:51.652 --> 00:25:54.121 align:middle line:-2
它告诉我们当前存在
Swift访问竞争

00:25:54.655 --> 00:25:56.590 align:middle line:-1
它会告诉我们涉及哪些线程

00:25:57.491 --> 00:25:58.625 align:middle line:-1
并在最后给个总结

00:25:58.692 --> 00:26:01.695 align:middle line:-2
告诉我们应该从哪一行代码开始
寻找我们的问题

00:25:58.692 --> 00:26:01.695 align:middle line:-2
告诉我们应该从哪一行代码开始
寻找我们的问题

00:26:02.329 --> 00:26:06.700 align:middle line:-2
所有这些证据对于我们发现错误
都非常有帮助

00:26:06.934 --> 00:26:08.268 align:middle line:-1
我们已证明这里有一个漏洞

00:26:08.335 --> 00:26:11.238 align:middle line:-2
在我的经历中
TSan从未撒过谎

00:26:12.606 --> 00:26:13.607 align:middle line:-1
我们可以

00:26:13.841 --> 00:26:16.710 align:middle line:-2
通过解除熊的同时入睡能力
来解决这个问题

00:26:16.910 --> 00:26:18.979 align:middle line:-1
我们将使用串行调度队列来实现这点

00:26:19.746 --> 00:26:21.715 align:middle line:-1
现在一次只有一只熊可以入睡

00:26:21.949 --> 00:26:24.184 align:middle line:-2
所以如果我们现在再次查看
sleepingBears变量

00:26:24.885 --> 00:26:26.887 align:middle line:-1
并在适当的队列上小心操作

00:26:27.988 --> 00:26:29.122 align:middle line:-1
我们可以看到 果然

00:26:29.189 --> 00:26:31.959 align:middle line:-2
Grandpa和Cub
如预期的那样 平静地打瞌睡

00:26:34.194 --> 00:26:36.830 align:middle line:-2
所以对于在多线程环境下使用集合
我的建议是

00:26:36.897 --> 00:26:40.133 align:middle line:-2
尝试隔离你的数据
以便它只能被单个线程访问

00:26:40.300 --> 00:26:41.635 align:middle line:-1
当你不能这样做时

00:26:42.436 --> 00:26:44.705 align:middle line:-1
确保你实现适当形式的互斥

00:26:44.771 --> 00:26:47.040 align:middle line:-1
如串行调度队列或锁

00:26:47.741 --> 00:26:50.511 align:middle line:-2
并总是使用ThreadSanitizer
来检查你的工作

00:26:50.844 --> 00:26:54.248 align:middle line:-2
在app发布之前发现错误
要比之后好得多

00:26:54.314 --> 00:26:55.716 align:middle line:-1
（建议：多线程）

00:26:55.782 --> 00:26:58.519 align:middle line:-1
我对使用可变集合还有更多的建议

00:26:59.753 --> 00:27:03.490 align:middle line:-2
第一个是如果你可以避免它
就尽量不要使用可变状态

00:26:59.753 --> 00:27:03.490 align:middle line:-2
第一个是如果你可以避免它
就尽量不要使用可变状态

00:27:04.391 --> 00:27:06.193 align:middle line:-1
到目前为止我所描述的所有困难

00:27:06.260 --> 00:27:08.562 align:middle line:-1
都是因为我们一直在使用可变状态

00:27:08.862 --> 00:27:10.697 align:middle line:-1
你可以通过避免使用可变集合

00:27:10.764 --> 00:27:13.133 align:middle line:-1
来从一开始就杜绝各种可能的复杂性

00:27:13.834 --> 00:27:16.803 align:middle line:-2
很多时候 你可以通过使用切片
或惰性包装器

00:27:17.004 --> 00:27:20.207 align:middle line:-1
来模拟你想要执行的改变

00:27:20.641 --> 00:27:23.744 align:middle line:-1
而且理解不可变数据几乎总是更容易

00:27:24.178 --> 00:27:26.380 align:middle line:-1
多亏Swift内置的可变性

00:27:26.513 --> 00:27:27.648 align:middle line:-1
若在你没有改变状态时

00:27:27.714 --> 00:27:30.551 align:middle line:-2
却试图留下可变的状态
则编译器会帮助你进行处理

00:27:30.617 --> 00:27:32.619 align:middle line:-1
（建议：首选不可变集合）

00:27:32.686 --> 00:27:34.288 align:middle line:-1
现在我还有一条建议

00:27:34.788 --> 00:27:37.858 align:middle line:-2
关于如何在必要时
最好地使用可变状态

00:27:38.825 --> 00:27:40.494 align:middle line:-1
那就是当你正在构造新的集合时

00:27:40.561 --> 00:27:41.495 align:middle line:-1
你可以改善性能

00:27:41.562 --> 00:27:43.964 align:middle line:-2
如果你碰巧知道
你所需要元素的

00:27:44.531 --> 00:27:45.699 align:middle line:-1
确切数量

00:27:45.766 --> 00:27:47.634 align:middle line:-1
或者非常好的近似值的话

00:27:47.734 --> 00:27:50.804 align:middle line:-2
大多数集合API都能够
提供这种提示

00:27:51.171 --> 00:27:52.973 align:middle line:-2
当你这样做时
会得到所需的确切大小

00:27:53.040 --> 00:27:54.041 align:middle line:-1
而且没有额外开销

00:27:54.441 --> 00:27:57.344 align:middle line:-2
如果你不这样做
我们的集合就是通用工具

00:27:57.978 --> 00:27:59.713 align:middle line:-1
它们可以在各种情况下工作

00:27:59.780 --> 00:28:01.448 align:middle line:-1
随着你逐步添加元素

00:27:59.780 --> 00:28:01.448 align:middle line:-1
随着你逐步添加元素

00:28:01.515 --> 00:28:05.319 align:middle line:-2
你最终可能会分配比你所需要的
更多的存储空间

00:28:06.186 --> 00:28:09.289 align:middle line:-2
但请注意 在提供此类提示时
请不要高估

00:28:09.489 --> 00:28:11.391 align:middle line:-1
否则你会发现自己处于同样的情况

00:28:11.458 --> 00:28:14.061 align:middle line:-1
即你使用的存储空间比实际需要的多

00:28:15.028 --> 00:28:17.364 align:middle line:-1
现在我想继续今天的最后一个话题

00:28:18.832 --> 00:28:21.969 align:middle line:-2
当你导入foundation
集合时 你可以使用的

00:28:22.536 --> 00:28:25.472 align:middle line:-2
各种各样的集合
以及你何时应该考虑使用它们

00:28:27.307 --> 00:28:28.876 align:middle line:-1
除了标准库集合之外

00:28:28.942 --> 00:28:30.143 align:middle line:-1
当你导入foundation时

00:28:30.210 --> 00:28:32.513 align:middle line:-1
你可以访问很棒的引用类型集合

00:28:32.579 --> 00:28:35.315 align:middle line:-2
它们已被Objective-C
开发人员用了几十年

00:28:36.350 --> 00:28:39.253 align:middle line:-1
其中许多都可以兼容Swift

00:28:39.319 --> 00:28:42.222 align:middle line:-2
因此它们与我们一直在谈论的
集合行为一致

00:28:42.289 --> 00:28:44.558 align:middle line:-2
也就是说 有几件重要的事情
需要记住

00:28:45.993 --> 00:28:49.296 align:middle line:-1
首先要记住的是这些NS类集合

00:28:49.363 --> 00:28:50.464 align:middle line:-1
是引用类型

00:28:50.564 --> 00:28:52.900 align:middle line:-1
我们通过一个例子来更好的理解这点

00:28:53.634 --> 00:28:55.302 align:middle line:-1
我们将定义值类型和引用类型

00:28:55.369 --> 00:28:57.604 align:middle line:-1
并在两边对它们做同样的事情

00:28:58.338 --> 00:29:00.240 align:middle line:-2
对于我们的值类型
我们将它称为x

00:28:58.338 --> 00:29:00.240 align:middle line:-2
对于我们的值类型
我们将它称为x

00:29:00.307 --> 00:29:01.542 align:middle line:-1
它将是一个字符串数组

00:29:02.409 --> 00:29:04.711 align:middle line:-1
我们得到一个名为x的空数组

00:29:05.012 --> 00:29:07.047 align:middle line:-2
对于引用类型
我们得到一个空数组

00:29:07.381 --> 00:29:08.549 align:middle line:-1
但x只是指向它

00:29:09.983 --> 00:29:12.719 align:middle line:-1
然后我们用数值类型来改变这个数组

00:29:12.886 --> 00:29:14.288 align:middle line:-1
该数组内联地发生改变

00:29:14.755 --> 00:29:15.923 align:middle line:-1
对于引用类型

00:29:16.123 --> 00:29:20.494 align:middle line:-1
正在被引用的数组内联地发生改变

00:29:21.328 --> 00:29:22.496 align:middle line:-1
我们创建另一个变量

00:29:23.130 --> 00:29:25.432 align:middle line:-2
使用值类型时
会发生一些非常特殊的事情

00:29:25.499 --> 00:29:27.301 align:middle line:-1
这时我们实际上并不复制存储

00:29:27.367 --> 00:29:31.471 align:middle line:-2
y是一个数组
但它知道它的存储实际上由x所有

00:29:32.539 --> 00:29:34.208 align:middle line:-1
并且y实际上不会进行复制

00:29:34.274 --> 00:29:36.343 align:middle line:-1
除非这些集合中的任何一个发生变化

00:29:36.610 --> 00:29:38.679 align:middle line:-1
引用类型有点不同

00:29:38.912 --> 00:29:41.782 align:middle line:-2
y只是另一个
指向同一个底层数组的指针

00:29:43.016 --> 00:29:46.019 align:middle line:-2
所以让我们继续并改变y
我们会在该数组中再放一只熊

00:29:46.086 --> 00:29:47.421 align:middle line:-1
对于值类型 所发生的事是

00:29:47.487 --> 00:29:49.423 align:middle line:-1
我们首先进行复制

00:29:49.489 --> 00:29:51.825 align:middle line:-2
我们正在对y写入值
所以我们需要复制它

00:29:53.260 --> 00:29:54.895 align:middle line:-1
然后我们就可以插入下一个熊

00:29:56.363 --> 00:29:57.931 align:middle line:-1
对于引用 情况较为简单

00:29:57.998 --> 00:30:01.068 align:middle line:-2
只存在一个数组
我们只是把熊猫放到数组中

00:29:57.998 --> 00:30:01.068 align:middle line:-2
只存在一个数组
我们只是把熊猫放到数组中

00:30:01.134 --> 00:30:03.303 align:middle line:-1
（值和引用集合）

00:30:03.537 --> 00:30:05.038 align:middle line:-2
在Swift中
使用foundation集合时

00:30:05.105 --> 00:30:08.675 align:middle line:-1
你需要记住的第二件事

00:30:09.476 --> 00:30:12.446 align:middle line:-2
是Swift中的所有
Objective-C API

00:30:12.513 --> 00:30:14.581 align:middle line:-1
都以Swift原生值类型出现

00:30:15.048 --> 00:30:17.951 align:middle line:-2
这实际上非常棒
因为它允许每种语言的代码

00:30:18.018 --> 00:30:20.554 align:middle line:-1
自然而然使用它们各自最擅长的类型

00:30:20.988 --> 00:30:22.022 align:middle line:-1
但是这如何实现呢？

00:30:22.155 --> 00:30:24.024 align:middle line:-1
这两种语言对这些集合

00:30:24.091 --> 00:30:25.192 align:middle line:-1
有完全不同的实现

00:30:25.259 --> 00:30:26.360 align:middle line:-2
（SWIFT中的
OBJECTIVE-C API）

00:30:26.426 --> 00:30:29.062 align:middle line:-1
这能起作用的原因就是所谓的桥接

00:30:29.496 --> 00:30:33.033 align:middle line:-2
桥接是我们如何在两种不同的
运行时表示之间进行转换

00:30:33.100 --> 00:30:36.203 align:middle line:-2
这是必要的 因为Swift
和Objective-C

00:30:36.270 --> 00:30:38.739 align:middle line:-2
我相信你已经注意到
是非常不同的语言

00:30:38.906 --> 00:30:41.208 align:middle line:-2
它们具有完全不同的
编译和运行时特性

00:30:41.275 --> 00:30:42.309 align:middle line:-1
（桥接）

00:30:42.376 --> 00:30:46.213 align:middle line:-2
尽管我们已经优化了桥接速度
但这并不是免费的

00:30:46.480 --> 00:30:49.516 align:middle line:-1
在两种语言之间桥接时总会产生开销

00:30:50.884 --> 00:30:52.252 align:middle line:-1
当我们桥接时会发生什么？

00:30:52.920 --> 00:30:54.555 align:middle line:-1
当我们在语言之间桥接时

00:30:54.621 --> 00:30:57.357 align:middle line:-2
我们必须先建立新的存储空间
对等的存储空间

00:30:57.424 --> 00:30:59.059 align:middle line:-1
如果你用一种语言占用N个单位

00:30:59.126 --> 00:31:00.827 align:middle line:-1
在另一种语言中这也将占用N个

00:30:59.126 --> 00:31:00.827 align:middle line:-1
在另一种语言中这也将占用N个

00:31:01.128 --> 00:31:05.032 align:middle line:-2
然后我们需要逐个元素地
在它们之间进行转换

00:31:05.098 --> 00:31:07.568 align:middle line:-2
并且这种按元素桥接
有时可以递归执行

00:31:07.634 --> 00:31:09.536 align:middle line:-1
比如我有一个字符串数组

00:31:09.603 --> 00:31:10.704 align:middle line:-1
首先我们将桥接数组

00:31:10.771 --> 00:31:12.840 align:middle line:-1
然后我们将桥接每个单独的字符串

00:31:13.941 --> 00:31:16.176 align:middle line:-1
当这发生在两种语言的边界时

00:31:16.243 --> 00:31:17.411 align:middle line:-1
称之为“急切桥接”

00:31:18.812 --> 00:31:20.681 align:middle line:-1
当集合中的元素也需要桥接时

00:31:20.747 --> 00:31:23.584 align:middle line:-1
集合本身将总是“急切”进行桥接

00:31:24.151 --> 00:31:27.321 align:middle line:-2
这种情况最常出现在
以字符串作为键的字典中

00:31:28.789 --> 00:31:31.325 align:middle line:-2
当集合桥接并不急切时
我们称之为惰性

00:31:31.658 --> 00:31:33.627 align:middle line:-1
当集合元素的类型并不是桥接时

00:31:33.694 --> 00:31:36.230 align:middle line:-2
就会发生这种情况
比如NSView

00:31:36.463 --> 00:31:38.298 align:middle line:-2
在这种情况下
桥接将被推迟

00:31:38.365 --> 00:31:40.701 align:middle line:-1
直到首次使用该集合

00:31:41.435 --> 00:31:43.437 align:middle line:-1
让我们用一些例子来说明这个问题

00:31:43.637 --> 00:31:47.074 align:middle line:-2
我们首先考虑一个Objective-C API
即NSArray

00:31:47.808 --> 00:31:49.643 align:middle line:-1
NSArray被桥接到数组

00:31:49.710 --> 00:31:51.845 align:middle line:-2
而NSData
被桥接到值类型的数据

00:31:51.979 --> 00:31:54.381 align:middle line:-1
所以这样的集合将会被急切的桥接

00:31:54.448 --> 00:31:55.649 align:middle line:-1
（桥接示例）

00:31:55.716 --> 00:31:58.352 align:middle line:-2
我刚才提到NSView
没有在Swift中被桥接

00:31:58.418 --> 00:32:00.554 align:middle line:-1
它们在Swift中仍然是引用类型

00:31:58.418 --> 00:32:00.554 align:middle line:-1
它们在Swift中仍然是引用类型

00:32:00.621 --> 00:32:04.157 align:middle line:-1
所以NSArray将被延迟桥接

00:32:04.258 --> 00:32:05.259 align:middle line:-1
桥接不会发生

00:32:05.325 --> 00:32:08.228 align:middle line:-1
直到你第一次访问或尝试使用该数组

00:32:10.831 --> 00:32:15.269 align:middle line:-2
最后 键类型为NSString的
NSDictionary

00:32:15.335 --> 00:32:16.537 align:middle line:-1
将被急切桥接

00:32:17.070 --> 00:32:19.439 align:middle line:-1
因为字符串需在Swift中转换为

00:32:19.506 --> 00:32:21.308 align:middle line:-1
值类型的字符串

00:32:22.242 --> 00:32:25.312 align:middle line:-2
现在我们知道了桥接是什么
它的原理以及何时发生

00:32:25.579 --> 00:32:27.648 align:middle line:-1
我们可以继续讨论最重要的问题

00:32:27.748 --> 00:32:29.550 align:middle line:-1
即你何时应该关心它

00:32:29.716 --> 00:32:31.285 align:middle line:-1
答案非常简单

00:32:31.351 --> 00:32:33.654 align:middle line:-2
当你估计它会对你的app
产生负面影响时

00:32:35.889 --> 00:32:38.392 align:middle line:-2
具体而言 当你使用时间分析器
或追踪仪器时

00:32:38.559 --> 00:32:41.795 align:middle line:-2
要特别注意你的代码
在不同语言之间的交叉部分

00:32:41.862 --> 00:32:44.097 align:middle line:-1
特别是当这发生在循环内时

00:32:44.898 --> 00:32:47.434 align:middle line:-1
少量的桥接完全没问题

00:32:47.501 --> 00:32:48.836 align:middle line:-1
你所关心的是

00:32:48.902 --> 00:32:51.872 align:middle line:-2
不成比例的时间
或者一个惊人的时间

00:32:52.072 --> 00:32:55.042 align:middle line:-2
被花费在不是你写的代码中
并且其中包含单词“bridge”

00:32:56.476 --> 00:32:57.978 align:middle line:-1
我们来看一个具体的例子

00:32:58.846 --> 00:33:01.215 align:middle line:-2
假设我正在写一本
关于儿童故事的手稿

00:32:58.846 --> 00:33:01.215 align:middle line:-2
假设我正在写一本
关于儿童故事的手稿

00:33:01.515 --> 00:33:02.749 align:middle line:-1
但它非常长

00:33:02.816 --> 00:33:04.351 align:middle line:-1
所以我只会在这里展示一部分

00:33:04.418 --> 00:33:05.953 align:middle line:-1
但为了让它受欢迎

00:33:07.154 --> 00:33:10.324 align:middle line:-1
我想让每个单词“brown”

00:33:10.390 --> 00:33:11.725 align:middle line:-1
都真的显示为棕色

00:33:12.092 --> 00:33:13.126 align:middle line:-1
为了节省空间

00:33:13.193 --> 00:33:15.495 align:middle line:-1
我将只突出显示第一个单词

00:33:16.330 --> 00:33:18.732 align:middle line:-2
为此 我将使用
NSMutableAttributedString

00:33:18.799 --> 00:33:20.067 align:middle line:-1
我把我的故事传进去

00:33:20.968 --> 00:33:24.738 align:middle line:-2
然后使用属性字符串的
string属性

00:33:25.005 --> 00:33:27.274 align:middle line:-2
我要得到Swift字符串
“Brown”的范围

00:33:27.541 --> 00:33:30.077 align:middle line:-2
这将产生一个
字符串本地索引类型范围

00:33:31.311 --> 00:33:32.980 align:middle line:-2
因为可变字符串
能与NSRange协同工作

00:33:33.046 --> 00:33:34.515 align:middle line:-1
所以我会使用我们去年

00:33:34.581 --> 00:33:35.816 align:middle line:-1
推出的便捷初始化器

00:33:36.216 --> 00:33:38.151 align:middle line:-1
来将其转换为NSRange

00:33:38.218 --> 00:33:42.489 align:middle line:-2
在这里我再次调用
属性字符串的string属性

00:33:43.090 --> 00:33:44.091 align:middle line:-1
来进行转换

00:33:44.391 --> 00:33:47.060 align:middle line:-2
然后我们将为“brown”
这个词的第一个实例着色

00:33:47.194 --> 00:33:49.696 align:middle line:-2
当我运行这段代码时
我发现它有点慢

00:33:50.898 --> 00:33:51.899 align:middle line:-1
所以我对其进行分析

00:33:52.266 --> 00:33:54.468 align:middle line:-1
我看到 令我惊讶的是

00:33:54.535 --> 00:33:56.336 align:middle line:-2
我以为大部分时间都会花在
为单词“brown”着色上

00:33:56.403 --> 00:33:57.938 align:middle line:-1
但它实际上是在计算索引

00:33:58.005 --> 00:33:59.006 align:middle line:-1
为什么会这样

00:34:00.707 --> 00:34:02.509 align:middle line:-1
其中的原因是我们实际上正在

00:34:02.576 --> 00:34:04.244 align:middle line:-1
两种语言间多次桥接字符串

00:34:04.511 --> 00:34:08.014 align:middle line:-2
MutableAttributedString是一个
Objective-C引用类型

00:34:08.081 --> 00:34:10.284 align:middle line:-1
所以当我们访问string属性时

00:34:10.350 --> 00:34:13.120 align:middle line:-2
我们实际上需要从NSString
转换为string

00:34:13.554 --> 00:34:16.657 align:middle line:-2
当我们计算第一个范围时
我们在这里进行一次桥接

00:34:16.956 --> 00:34:19.659 align:middle line:-2
我们在转换为NSRange时
进行第二次桥接

00:34:20.694 --> 00:34:22.329 align:middle line:-1
你可以想象这样的开销有多大

00:34:22.396 --> 00:34:24.864 align:middle line:-2
如果我们在一个循环中
查找所有文本以进行着色

00:34:25.465 --> 00:34:27.367 align:middle line:-2
现在我们来看看为什么
会发生这种情况

00:34:27.434 --> 00:34:31.071 align:middle line:-2
每次调用text.string时
都会在Swift执行上下文中启动

00:34:31.737 --> 00:34:34.908 align:middle line:-2
然而NSMutableAttributedString
是用Objective-C实现的

00:34:34.975 --> 00:34:36.577 align:middle line:-1
所以为了提供结果

00:34:36.643 --> 00:34:39.279 align:middle line:-1
我们实际上必须咨询其原始实现

00:34:39.346 --> 00:34:40.614 align:middle line:-1
（桥接发生时）

00:34:40.681 --> 00:34:44.284 align:middle line:-2
原始实现返回NSString
它是引用类型

00:34:44.451 --> 00:34:46.820 align:middle line:-2
所以当返回到字符串时
它需要被桥接

00:34:47.521 --> 00:34:49.755 align:middle line:-1
逐个图像集

00:34:50.824 --> 00:34:51.992 align:middle line:-1
逐个字符

00:34:52.826 --> 00:34:58.098 align:middle line:-2
无论是返回类型还是参数
都会发生桥接

00:35:01.268 --> 00:35:03.237 align:middle line:-1
现在我们知道了这些细节

00:35:03.470 --> 00:35:06.306 align:middle line:-1
我们可以做得更好一些

00:35:06.373 --> 00:35:07.474 align:middle line:-1
我们只需桥接一次

00:35:08.709 --> 00:35:10.010 align:middle line:-1
让我们重新测量代码

00:35:10.944 --> 00:35:13.614 align:middle line:-1
并看到我们的确已将性能提高了一半

00:35:13.680 --> 00:35:15.949 align:middle line:-1
但今年我们可以做得更好一点

00:35:16.650 --> 00:35:18.986 align:middle line:-1
哦 现在我们在这里不再进行桥接

00:35:19.486 --> 00:35:21.421 align:middle line:-1
但今年我们可以做得更好一点

00:35:21.722 --> 00:35:23.991 align:middle line:-2
今年当我们获取
text.string属性时

00:35:24.057 --> 00:35:25.659 align:middle line:-2
如果我们使用as语法
转换为NSString

00:35:25.726 --> 00:35:29.263 align:middle line:-2
当我们得到变量时
实际上不会发生任何桥接

00:35:30.564 --> 00:35:34.868 align:middle line:-2
并且通过这样做
该字符串现是一个NSString

00:35:35.035 --> 00:35:36.336 align:middle line:-2
当我们调用
range(of)属性时

00:35:36.403 --> 00:35:39.873 align:middle line:-2
我们实际上
会自动获得NSRange

00:35:39.940 --> 00:35:41.642 align:middle line:-1
我们不需要在Swift原生类型

00:35:41.708 --> 00:35:45.379 align:middle line:-2
和NSRange之间
做任何范围转换

00:35:45.612 --> 00:35:46.613 align:middle line:-1
这非常棒

00:35:46.680 --> 00:35:49.082 align:middle line:-1
我们来看看这段代码的效率

00:35:49.149 --> 00:35:50.150 align:middle line:-1
这看起来很不错

00:35:50.217 --> 00:35:52.686 align:middle line:-1
这比我们刚才耗费的

00:35:52.753 --> 00:35:54.354 align:middle line:-1
几乎800毫秒的时间要快得多

00:35:55.489 --> 00:35:57.658 align:middle line:-2
然而我想指出的是
这里仍然发生了桥接

00:35:57.724 --> 00:35:59.026 align:middle line:-1
这是很小的桥

00:35:59.660 --> 00:36:00.827 align:middle line:-1
但我们仍进行了桥接

00:35:59.660 --> 00:36:00.827 align:middle line:-1
但我们仍进行了桥接

00:36:01.328 --> 00:36:03.830 align:middle line:-2
这里的“brown”是一个
Swift值类型的字符串

00:36:05.032 --> 00:36:10.938 align:middle line:-2
每当我们调用Objective-C API
中NSString的range(of)属性时

00:36:11.004 --> 00:36:13.774 align:middle line:-2
我们实际上会将这个小小的
字符串桥接回NSString

00:36:14.908 --> 00:36:17.144 align:middle line:-2
在这种情况下它的开销不大
我只进行了一次

00:36:17.211 --> 00:36:18.946 align:middle line:-2
但你可以想象
如果这是一个循环

00:36:19.079 --> 00:36:20.948 align:middle line:-2
随着时间推移
这些小开销会积少成多

00:36:21.014 --> 00:36:22.549 align:middle line:-1
所以你要注意

00:36:22.616 --> 00:36:25.219 align:middle line:-1
避免重复桥接相同的小字符串

00:36:25.485 --> 00:36:28.222 align:middle line:-2
但在你做这样的优化之前
总是要进行测量

00:36:29.723 --> 00:36:31.258 align:middle line:-1
现在我们看过了桥接的细节

00:36:31.358 --> 00:36:34.294 align:middle line:-2
我想提供些关于何时使用
foundation集合的建议

00:36:35.662 --> 00:36:37.564 align:middle line:-1
当你需要具有引用语义的集合时

00:36:37.631 --> 00:36:39.800 align:middle line:-1
你应该考虑明确使用它们

00:36:40.467 --> 00:36:42.102 align:middle line:-1
你不需要自己写一个

00:36:42.169 --> 00:36:43.637 align:middle line:-1
我们已经有很多很棒的集合了

00:36:44.238 --> 00:36:45.706 align:middle line:-1
当你知道你在处理引用类型时

00:36:45.772 --> 00:36:46.974 align:middle line:-1
也应该使用它

00:36:47.040 --> 00:36:49.743 align:middle line:-2
像NS代理或核心数据托管对象
之类的东西

00:36:51.078 --> 00:36:52.679 align:middle line:-1
最后应该考虑使用它们的情景是

00:36:52.746 --> 00:36:54.848 align:middle line:-2
当你在与Objective-C
代码之间来回切换时

00:36:55.148 --> 00:36:56.884 align:middle line:-2
但我强烈建议你
只有在测量并确定

00:36:57.351 --> 00:37:00.053 align:middle line:-1
桥接确实是性能问题的罪魁祸首后

00:36:57.351 --> 00:37:00.053 align:middle line:-1
桥接确实是性能问题的罪魁祸首后

00:37:00.120 --> 00:37:02.556 align:middle line:-1
你才这样做

00:37:03.690 --> 00:37:06.026 align:middle line:-1
现在我们对Swift中强大的

00:37:06.093 --> 00:37:08.929 align:middle line:-1
集合世界的探索已经接近尾声

00:37:09.630 --> 00:37:11.598 align:middle line:-1
我希望你能够使用这种新视角

00:37:11.698 --> 00:37:13.667 align:middle line:-1
来检视你现有的集合使用情况

00:37:13.967 --> 00:37:15.903 align:middle line:-1
寻找可以通过更有效地

00:37:15.969 --> 00:37:18.272 align:middle line:-1
使用索引和切片来改进代码的地方

00:37:18.839 --> 00:37:19.840 align:middle line:-1
测量你的代码

00:37:20.574 --> 00:37:23.110 align:middle line:-2
寻找你可以因惰性
或通过调整桥接方式

00:37:24.411 --> 00:37:25.779 align:middle line:-1
而受益的地方

00:37:26.947 --> 00:37:29.616 align:middle line:-2
用ThreadSanitizer
辅助审计可变状态

00:37:30.517 --> 00:37:32.252 align:middle line:-1
并通过应用今天讨论的所有概念

00:37:32.319 --> 00:37:34.054 align:middle line:-2
在Playground
或你自己的app中

00:37:34.121 --> 00:37:36.623 align:middle line:-1
进一步锻炼你对集合的掌握

00:37:37.824 --> 00:37:39.326 align:middle line:-1
如果你对集合有任何疑问

00:37:39.393 --> 00:37:41.094 align:middle line:-1
请到访我们今天最后几个实验室

00:37:41.161 --> 00:37:42.162 align:middle line:-1
我们将在那里提供帮助

00:37:42.629 --> 00:37:45.232 align:middle line:-2
非常感谢
在实践中变得更高效吧
