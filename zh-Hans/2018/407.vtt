WEBVTT

00:00:07.516 --> 00:00:18.516 A:middle
［ 音乐 ］

00:00:19.516 --> 00:00:25.416 A:middle
［ 掌声 ］

00:00:25.916 --> 00:00:26.946 A:middle
&gt;&gt; 大家下午好

00:00:27.406 --> 00:00:28.456 A:middle
我是 John Hess

00:00:28.456 --> 00:00:30.586 A:middle
今天我将和 Matthew Lucas 一起

00:00:30.586 --> 00:00:31.606 A:middle
与在座的各位

00:00:31.606 --> 00:00:33.166 A:middle
谈谈提高 App 性能的

00:00:33.166 --> 00:00:34.506 A:middle
一些实用的方法

00:00:35.406 --> 00:00:36.906 A:middle
我现在是一名 Xcode 团队的工程师

00:00:36.906 --> 00:00:38.286 A:middle
在过去的七年

00:00:38.346 --> 00:00:39.796 A:middle
我有幸一直专注于

00:00:39.796 --> 00:00:42.236 A:middle
提高性能的工作

00:00:42.736 --> 00:00:44.226 A:middle
首先是在 Xcode 的两个领域

00:00:44.226 --> 00:00:47.186 A:middle
“Project Find” 和 “Open Quickly”

00:00:47.826 --> 00:00:49.896 A:middle
二者的主要功能 都是提高性能

00:00:50.766 --> 00:00:52.056 A:middle
最近 我有机会去

00:00:52.056 --> 00:00:54.136 A:middle
做一项关于

00:00:54.136 --> 00:00:55.846 A:middle
Xcode GY 响应性的调查

00:00:55.846 --> 00:00:57.126 A:middle
我想与你们分享的是

00:00:57.126 --> 00:00:58.326 A:middle
在进行性能工作时

00:00:58.326 --> 00:01:00.296 A:middle
我所使用的方法

00:00:58.326 --> 00:01:00.296 A:middle
我所使用的方法

00:01:00.296 --> 00:01:01.376 A:middle
其中包括我十分熟悉的代码

00:01:01.376 --> 00:01:03.136 A:middle
也包括我

00:01:03.136 --> 00:01:04.596 A:middle
第一次接触到的代码

00:01:05.936 --> 00:01:07.716 A:middle
那么 如果各位想从今天的演讲中有所收获

00:01:07.716 --> 00:01:09.496 A:middle
我希望各位至少能

00:01:09.496 --> 00:01:11.886 A:middle
记住一点 那就是

00:01:11.946 --> 00:01:13.276 A:middle
你们所有提高性能的工作

00:01:13.276 --> 00:01:14.716 A:middle
都要基于测量的结果

00:01:15.696 --> 00:01:17.096 A:middle
在开始解决一个性能问题时

00:01:17.096 --> 00:01:18.816 A:middle
你需要进行测量

00:01:18.816 --> 00:01:21.126 A:middle
来建立一个基线

00:01:21.366 --> 00:01:22.536 A:middle
让你知道自己所处的位置

00:01:23.666 --> 00:01:25.196 A:middle
当你重复解决

00:01:25.196 --> 00:01:26.716 A:middle
同一个性能问题时

00:01:26.716 --> 00:01:28.146 A:middle
你应该测量每一步所使用的方法

00:01:28.576 --> 00:01:29.826 A:middle
以确保性能的改变

00:01:29.826 --> 00:01:32.026 A:middle
能够带来你所期待的效果

00:01:33.336 --> 00:01:34.346 A:middle
当你解决了一个性能问题

00:01:34.346 --> 00:01:35.916 A:middle
你还需要再测量一遍

00:01:35.916 --> 00:01:37.656 A:middle
这样你可以与原先的基线

00:01:37.656 --> 00:01:38.846 A:middle
进行对比

00:01:38.846 --> 00:01:41.046 A:middle
从而给出一个量化的结果

00:01:41.046 --> 00:01:43.166 A:middle
关于你将 App 的性能

00:01:43.166 --> 00:01:44.746 A:middle
真正提高了多少

00:01:45.196 --> 00:01:46.766 A:middle
你想要将成果报告给你的老板

00:01:46.766 --> 00:01:49.506 A:middle
分享给你的同事和用户

00:01:50.566 --> 00:01:52.966 A:middle
那么 当你想要为你的用户提高性能时

00:01:52.966 --> 00:01:55.166 A:middle
你需要考虑这一点

00:01:55.166 --> 00:01:56.826 A:middle
我喜欢称它为

00:01:56.826 --> 00:01:57.786 A:middle
总体性能影响

00:01:58.656 --> 00:02:01.246 A:middle
如果你将 App 的

00:01:58.656 --> 00:02:01.246 A:middle
如果你将 App 的

00:02:01.246 --> 00:02:03.216 A:middle
一个领域的性能

00:02:03.216 --> 00:02:06.706 A:middle
提高了 50%

00:02:06.706 --> 00:02:08.136 A:middle
但你的用户

00:02:08.136 --> 00:02:10.006 A:middle
只体验到了其中的 1%

00:02:10.006 --> 00:02:11.456 A:middle
那么这种提升的影响广度

00:02:11.456 --> 00:02:13.286 A:middle
还不及你只提高了其他领域的 10%

00:02:13.286 --> 00:02:15.526 A:middle
但所有用户都能体验到

00:02:15.526 --> 00:02:16.806 A:middle
这全部的 10%

00:02:17.336 --> 00:02:19.676 A:middle
所以一定不要去优化边缘的案例

00:02:19.676 --> 00:02:20.816 A:middle
要确保你的性能的优化

00:02:20.816 --> 00:02:22.596 A:middle
能够为全部的用户所体验

00:02:24.536 --> 00:02:27.736 A:middle
那么我们如何修复

00:02:27.736 --> 00:02:28.086 A:middle
性能漏洞呢

00:02:28.086 --> 00:02:29.526 A:middle
如何修复常规的漏洞呢

00:02:29.966 --> 00:02:31.586 A:middle
一般来说 最开始用户反馈给我们

00:02:31.586 --> 00:02:33.036 A:middle
某方面的缺陷报告

00:02:33.036 --> 00:02:35.026 A:middle
我们接收到这个报告

00:02:35.026 --> 00:02:36.466 A:middle
了解到用户对 App 的性能

00:02:36.466 --> 00:02:38.216 A:middle
有一些不满意的地方

00:02:38.216 --> 00:02:39.946 A:middle
于是我们会设法

00:02:40.066 --> 00:02:41.696 A:middle
来综合步骤进行故障重现

00:02:41.696 --> 00:02:42.866 A:middle
以便我们可以随意地使程序出错

00:02:43.646 --> 00:02:45.346 A:middle
一旦我们成功的做到 我们就给

00:02:45.346 --> 00:02:46.526 A:middle
程序附加一个调试器

00:02:46.526 --> 00:02:48.826 A:middle
以便我们看到我们的程序出错的时候

00:02:48.826 --> 00:02:49.376 A:middle
在做什么

00:02:50.866 --> 00:02:51.706 A:middle
再结合我们的知识

00:02:51.706 --> 00:02:52.656 A:middle
想想代码应该如何工作

00:02:52.656 --> 00:02:54.576 A:middle
在必要时修改它

00:02:54.576 --> 00:02:56.176 A:middle
来消除那些

00:02:56.176 --> 00:02:57.156 A:middle
不如意的部分

00:02:57.936 --> 00:02:58.966 A:middle
我们要确保我们没有

00:02:58.966 --> 00:03:00.516 A:middle
带来任何不想要的副作用

00:02:58.966 --> 00:03:00.516 A:middle
带来任何不想要的副作用

00:03:00.516 --> 00:03:02.046 A:middle
同时 要进行必要的重复

00:03:02.046 --> 00:03:03.546 A:middle
直到我们完全地

00:03:03.546 --> 00:03:04.186 A:middle
解决了这个漏洞

00:03:05.736 --> 00:03:07.686 A:middle
我已经用相同的方法

00:03:07.686 --> 00:03:08.996 A:middle
修复了许多性能漏洞

00:03:10.086 --> 00:03:11.136 A:middle
只不过我并没有使用调试器

00:03:11.136 --> 00:03:13.766 A:middle
而是使用了一个分析器

00:03:13.826 --> 00:03:16.246 A:middle
分析器就是一个很好的测量工具

00:03:16.996 --> 00:03:18.666 A:middle
我用一些步骤

00:03:18.666 --> 00:03:20.806 A:middle
来重现运行很慢的

00:03:20.806 --> 00:03:21.216 A:middle
程序

00:03:21.966 --> 00:03:23.386 A:middle
我用一个附加的分析器

00:03:23.386 --> 00:03:25.106 A:middle
来执行这些步骤

00:03:25.106 --> 00:03:26.606 A:middle
因此我可以深入地了解

00:03:26.606 --> 00:03:27.656 A:middle
当我的代码运行缓慢时

00:03:27.656 --> 00:03:28.106 A:middle
它发生了什么

00:03:29.226 --> 00:03:31.016 A:middle
然后再结合

00:03:31.016 --> 00:03:32.556 A:middle
我的程序必须要如何运行

00:03:32.556 --> 00:03:34.206 A:middle
才能完成手边的任务

00:03:34.266 --> 00:03:36.056 A:middle
我找到其中正在进行的步骤

00:03:36.236 --> 00:03:37.606 A:middle
并删除了它们

00:03:37.606 --> 00:03:39.926 A:middle
因为想让你的代码变快的

00:03:39.926 --> 00:03:42.286 A:middle
首要方法就是删除多余的步骤

00:03:42.286 --> 00:03:44.326 A:middle
无论它正在计算的是什么

00:03:45.736 --> 00:03:47.456 A:middle
现在 我修改了源代码

00:03:47.456 --> 00:03:49.136 A:middle
在必要时进行反复测量

00:03:49.136 --> 00:03:50.486 A:middle
直到我对整体的结果

00:03:50.486 --> 00:03:52.886 A:middle
感到满意为止

00:03:54.936 --> 00:03:57.666 A:middle
当我通过这种方法提高性能时

00:03:57.666 --> 00:03:59.486 A:middle
我发现自己常常处于

00:03:59.486 --> 00:04:00.176 A:middle
一些场景当中

00:03:59.486 --> 00:04:00.176 A:middle
一些场景当中

00:04:00.736 --> 00:04:02.026 A:middle
这些不同的场景

00:04:02.056 --> 00:04:03.406 A:middle
改变了我测试有问题代码的方式

00:04:03.496 --> 00:04:05.166 A:middle
以及复制这些

00:04:05.196 --> 00:04:06.126 A:middle
漏洞的方法

00:04:06.776 --> 00:04:09.046 A:middle
有时我会遇到

00:04:09.096 --> 00:04:10.926 A:middle
严重的性能衰退问题 对吗

00:04:11.006 --> 00:04:12.086 A:middle
开始一切都在平稳地运行

00:04:12.086 --> 00:04:14.116 A:middle
然后我们的团队里

00:04:14.116 --> 00:04:15.396 A:middle
有人对其进行了检测

00:04:15.446 --> 00:04:17.086 A:middle
这个人也许是我

00:04:17.086 --> 00:04:18.226 A:middle
然后发现性能出现了严重的衰退

00:04:18.226 --> 00:04:19.495 A:middle
那么我们就需要回去

00:04:19.495 --> 00:04:21.296 A:middle
找出这种衰退的原因

00:04:22.065 --> 00:04:23.246 A:middle
如果这种衰退十分明显

00:04:23.246 --> 00:04:25.986 A:middle
或者是它出现在一个

00:04:25.986 --> 00:04:27.186 A:middle
我认为近期

00:04:27.186 --> 00:04:28.086 A:middle
不可能再次衰退的地方

00:04:28.086 --> 00:04:29.576 A:middle
我也许会自己手动地

00:04:29.676 --> 00:04:31.966 A:middle
运用附加的分析器

00:04:32.086 --> 00:04:33.216 A:middle
对它进行测试

00:04:34.386 --> 00:04:36.116 A:middle
但是 想提高你的性能

00:04:36.116 --> 00:04:37.376 A:middle
这是一个不大容易的过程

00:04:37.376 --> 00:04:40.056 A:middle
因为很可能

00:04:40.056 --> 00:04:42.126 A:middle
只是一系列轻微的衰退

00:04:42.126 --> 00:04:43.196 A:middle
就会让你功亏一篑

00:04:43.986 --> 00:04:45.806 A:middle
我建议你们所有人

00:04:45.806 --> 00:04:46.926 A:middle
创建自动化的性能测试

00:04:46.926 --> 00:04:48.986 A:middle
来捕捉你的 App 的性能

00:04:48.986 --> 00:04:50.356 A:middle
这样你就可以

00:04:50.356 --> 00:04:52.316 A:middle
保证它不会随着时间而衰退

00:04:55.256 --> 00:04:56.596 A:middle
我经常所处的另一个场景是

00:04:56.596 --> 00:04:58.726 A:middle
App 的性能

00:04:58.726 --> 00:05:00.326 A:middle
在很长一段时间后

00:04:58.726 --> 00:05:00.326 A:middle
在很长一段时间后

00:05:00.326 --> 00:05:01.246 A:middle
还能保持不变吗

00:05:01.656 --> 00:05:03.356 A:middle
也许在一些绘图测试中

00:05:03.356 --> 00:05:04.666 A:middle
它运行的速度是 45 帧每秒

00:05:05.156 --> 00:05:06.826 A:middle
但是我们希望的运行速度是 60 每秒

00:05:06.826 --> 00:05:07.886 A:middle
所以我们需要小幅地提高它

00:05:07.886 --> 00:05:09.426 A:middle
并且我们有理由相信

00:05:09.426 --> 00:05:10.986 A:middle
通过我们先前的性能工作

00:05:10.986 --> 00:05:12.736 A:middle
我们可以利用现场修复

00:05:12.736 --> 00:05:14.126 A:middle
以及增量式变化

00:05:14.126 --> 00:05:15.546 A:middle
来对它进行提高

00:05:16.326 --> 00:05:17.726 A:middle
在这种场景下

00:05:17.726 --> 00:05:19.186 A:middle
我或许也已经自动地

00:05:19.186 --> 00:05:20.876 A:middle
开始进行测试了

00:05:20.876 --> 00:05:22.216 A:middle
因为随着时间的推移

00:05:24.796 --> 00:05:24.896 A:middle
我已经很了解我的性能了

00:05:25.106 --> 00:05:26.856 A:middle
还有第三种场景

00:05:26.856 --> 00:05:28.176 A:middle
我们的 App

00:05:28.176 --> 00:05:29.336 A:middle
因为设计不良而受到损害

00:05:29.446 --> 00:05:30.666 A:middle
性能也远远比不上

00:05:30.666 --> 00:05:32.226 A:middle
它原应达到的效果

00:05:33.516 --> 00:05:34.726 A:middle
我们知道我们不能用

00:05:34.726 --> 00:05:36.626 A:middle
简单的场地修复来提高性能

00:05:36.626 --> 00:05:37.666 A:middle
因为过去我们这么尝试过

00:05:37.906 --> 00:05:39.356 A:middle
但并没有成功

00:05:39.606 --> 00:05:41.416 A:middle
无法提高性能

00:05:42.006 --> 00:05:43.856 A:middle
在这样的情况下

00:05:43.856 --> 00:05:45.986 A:middle
你会想要做一次彻底的性能检修

00:05:45.986 --> 00:05:47.446 A:middle
你会想重新设计一些特性的核心部分

00:05:47.446 --> 00:05:48.716 A:middle
或是有问题的算法

00:05:48.716 --> 00:05:50.516 A:middle
以使性能成为一个

00:05:50.786 --> 00:05:51.916 A:middle
首要的约束条件

00:05:52.456 --> 00:05:53.746 A:middle
在这些情况里

00:05:53.906 --> 00:05:55.216 A:middle
你必然要对性能进行检测

00:05:55.536 --> 00:05:56.686 A:middle
以测量你确实

00:05:56.686 --> 00:05:58.136 A:middle
达到了你的性能目标

00:05:59.246 --> 00:06:01.936 A:middle
知道你要测试什么 很重要

00:05:59.246 --> 00:06:01.936 A:middle
知道你要测试什么 很重要

00:06:02.346 --> 00:06:03.686 A:middle
我想要提醒你的是

00:06:03.686 --> 00:06:05.096 A:middle
我从来都不会立刻投入

00:06:05.096 --> 00:06:06.086 A:middle
这些性能检修

00:06:06.086 --> 00:06:08.106 A:middle
将其视为解决

00:06:08.106 --> 00:06:08.896 A:middle
某种性能问题的方法

00:06:09.296 --> 00:06:10.816 A:middle
我喜欢这么做

00:06:10.816 --> 00:06:12.046 A:middle
这是一种未曾开发的工程

00:06:12.046 --> 00:06:14.326 A:middle
你能够从头开始 设计这些东西

00:06:14.326 --> 00:06:16.126 A:middle
但这也颇具风险

00:06:16.556 --> 00:06:17.346 A:middle
你最终要的是

00:06:17.346 --> 00:06:18.666 A:middle
一个性能更好的产品

00:06:18.666 --> 00:06:19.686 A:middle
但这却是一个曲折的过程

00:06:19.686 --> 00:06:21.376 A:middle
因为你需要重新设计

00:06:21.376 --> 00:06:23.976 A:middle
整个特性

00:06:24.116 --> 00:06:25.186 A:middle
当你做这种工作的时候

00:06:25.186 --> 00:06:26.666 A:middle
你不仅需要知道

00:06:26.666 --> 00:06:28.156 A:middle
这些代码的

00:06:28.286 --> 00:06:29.436 A:middle
功能约束条件

00:06:29.436 --> 00:06:31.336 A:middle
你还要知道

00:06:31.336 --> 00:06:32.986 A:middle
性能约束条件

00:06:32.986 --> 00:06:34.356 A:middle
以及你的用户应用这一特性时

00:06:34.356 --> 00:06:35.616 A:middle
最常使用的

00:06:35.616 --> 00:06:37.386 A:middle
典型的模式

00:06:37.386 --> 00:06:39.106 A:middle
而你只能从

00:06:39.256 --> 00:06:40.276 A:middle
过去这方面的性能工作中

00:06:40.276 --> 00:06:40.736 A:middle
获得这方面信息

00:06:41.636 --> 00:06:43.326 A:middle
我想和你们分享一件轶事

00:06:43.326 --> 00:06:45.046 A:middle
是我们的一个

00:06:45.046 --> 00:06:46.216 A:middle
在 Xcode 里工作的案例

00:06:47.216 --> 00:06:49.406 A:middle
在 Xcode 9 中 我们重做了 “Project Find”

00:06:49.406 --> 00:06:50.606 A:middle
将性能作为一个

00:06:50.606 --> 00:06:51.406 A:middle
首要的目标

00:06:52.366 --> 00:06:53.716 A:middle
我们的目标就是要

00:06:53.716 --> 00:06:55.376 A:middle
在短短几十毫秒中

00:06:55.376 --> 00:06:56.076 A:middle
传递出搜索结果

00:06:56.926 --> 00:06:59.156 A:middle
当我们与同事

00:06:59.156 --> 00:07:00.006 A:middle
讨论这个特性时

00:06:59.156 --> 00:07:00.006 A:middle
讨论这个特性时

00:07:00.006 --> 00:07:01.366 A:middle
我们常常遇到一些挑战

00:07:01.366 --> 00:07:03.536 A:middle
比如让我们在一些大的项目上

00:07:03.536 --> 00:07:05.286 A:middle
搜索一些类似于字符串

00:07:05.286 --> 00:07:07.106 A:middle
或者甚至是字母 E

00:07:07.106 --> 00:07:07.336 A:middle
这样的东西

00:07:07.446 --> 00:07:08.976 A:middle
这些东西能搜索出成千上万种结果

00:07:08.976 --> 00:07:10.446 A:middle
不是吗

00:07:10.446 --> 00:07:12.106 A:middle
当然如果你的 App

00:07:12.216 --> 00:07:13.426 A:middle
能够迅速生产出成千上万的结果

00:07:13.426 --> 00:07:14.866 A:middle
它搜索任何东西

00:07:14.866 --> 00:07:15.776 A:middle
都会很快

00:07:16.476 --> 00:07:17.896 A:middle
但是如果你思考一下

00:07:17.896 --> 00:07:20.516 A:middle
什么是典型的模式

00:07:20.516 --> 00:07:22.046 A:middle
我们搜索我们使用的 API

00:07:22.046 --> 00:07:24.336 A:middle
我们自己的类名称

00:07:24.496 --> 00:07:25.616 A:middle
还有我们引用的图片名称

00:07:25.616 --> 00:07:26.286 A:middle
诸如此类的东西

00:07:26.346 --> 00:07:27.546 A:middle
它能搜索出很多结果

00:07:27.546 --> 00:07:28.606 A:middle
也许上百种结果

00:07:28.936 --> 00:07:30.276 A:middle
当然十分重要的是 当有一百万种搜索结果时

00:07:30.276 --> 00:07:32.076 A:middle
你的 App 能够

00:07:32.076 --> 00:07:33.236 A:middle
正常地工作运转

00:07:33.496 --> 00:07:35.086 A:middle
但是通常的使用情况是

00:07:35.156 --> 00:07:36.026 A:middle
有数百种搜索结果

00:07:36.806 --> 00:07:38.486 A:middle
那么 在进行搜索这样的任务时

00:07:38.486 --> 00:07:40.186 A:middle
你所做的一些工作

00:07:40.186 --> 00:07:41.396 A:middle
要与生成原始结果

00:07:41.746 --> 00:07:43.816 A:middle
这样的东西相对应

00:07:43.816 --> 00:07:45.326 A:middle
而其余的工作则要基于

00:07:45.326 --> 00:07:46.916 A:middle
你能多有效地索引

00:07:46.916 --> 00:07:48.296 A:middle
项目中的文本

00:07:48.296 --> 00:07:49.666 A:middle
并预先避免工作

00:07:50.156 --> 00:07:51.996 A:middle
在这两种场景中

00:07:51.996 --> 00:07:53.976 A:middle
你可能会有完全

00:07:53.976 --> 00:07:55.286 A:middle
不同的优化目标

00:07:55.286 --> 00:07:56.826 A:middle
让其中一个目标的搜索速度

00:07:56.826 --> 00:07:59.046 A:middle
快于其他的目标 对吗

00:07:59.046 --> 00:08:00.156 A:middle
因而你有必要了解

00:07:59.046 --> 00:08:00.156 A:middle
因而你有必要了解

00:08:00.156 --> 00:08:02.426 A:middle
你的用户将要

00:08:02.426 --> 00:08:03.316 A:middle
如何使用该产品

00:08:03.506 --> 00:08:04.696 A:middle
这样你就可以优化

00:08:04.726 --> 00:08:05.536 A:middle
应该优化的案例

00:08:07.956 --> 00:08:09.696 A:middle
在所有的这些案例中

00:08:09.696 --> 00:08:11.206 A:middle
我需要进行一些形式的测试

00:08:11.686 --> 00:08:13.556 A:middle
无论是手动地 还是自动地

00:08:16.246 --> 00:08:17.556 A:middle
我想要与你分享

00:08:17.556 --> 00:08:18.886 A:middle
两类典型的性能测试

00:08:18.886 --> 00:08:20.196 A:middle
我通常用它们

00:08:20.196 --> 00:08:22.186 A:middle
来测量 Xcode 的性能

00:08:23.436 --> 00:08:25.436 A:middle
我们或者进行单元测试

00:08:25.436 --> 00:08:26.376 A:middle
或者进行综合测试

00:08:26.956 --> 00:08:28.176 A:middle
我们来对比一下这两种测试

00:08:29.376 --> 00:08:31.306 A:middle
在性能的单元测试中

00:08:31.306 --> 00:08:33.616 A:middle
你的目标就是对你的 App 的

00:08:33.616 --> 00:08:35.096 A:middle
某些特征进行隔离

00:08:35.096 --> 00:08:36.356 A:middle
并单独地对其进行测量

00:08:36.966 --> 00:08:37.726 A:middle
你也许会抹去它的相关性

00:08:37.756 --> 00:08:39.236 A:middle
然后在一个

00:08:39.236 --> 00:08:41.126 A:middle
隔离的环境中

00:08:41.126 --> 00:08:42.736 A:middle
启动它

00:08:43.496 --> 00:08:45.666 A:middle
如果我要为 Xcode 的代码完成

00:08:45.666 --> 00:08:47.266 A:middle
性能的单元测试

00:08:47.266 --> 00:08:48.676 A:middle
那我也许会编写

00:08:48.676 --> 00:08:50.406 A:middle
一系列的三个小测试

00:08:51.076 --> 00:08:52.896 A:middle
其中一个测试会测量

00:08:53.256 --> 00:08:54.616 A:middle
与编译器的对话

00:08:54.616 --> 00:08:56.426 A:middle
并得到原始的结果

00:08:56.426 --> 00:08:57.876 A:middle
和原始的代码完成候选的结果

00:08:58.946 --> 00:09:01.056 A:middle
另一个性能测试则会测量

00:08:58.946 --> 00:09:01.056 A:middle
另一个性能测试则会测量

00:09:01.056 --> 00:09:02.906 A:middle
那些结果的相互关联

00:09:02.906 --> 00:09:04.386 A:middle
对它们进行排列以及评分

00:09:04.386 --> 00:09:05.406 A:middle
以便我们知道要将哪些结果

00:09:05.406 --> 00:09:05.806 A:middle
显示给用户

00:09:06.926 --> 00:09:08.896 A:middle
第三个测试会选取

00:09:08.926 --> 00:09:10.636 A:middle
那些已经准备好的结果

00:09:10.636 --> 00:09:11.636 A:middle
并测量将它们放入 UI 元素

00:09:11.636 --> 00:09:13.156 A:middle
后最终展示出来的情况

00:09:13.156 --> 00:09:15.016 A:middle
为了涉及到全部三个方面

00:09:15.016 --> 00:09:17.986 A:middle
我会很好地覆盖 IDE 中

00:09:17.986 --> 00:09:20.546 A:middle
代码完成的主要的组件

00:09:23.136 --> 00:09:24.796 A:middle
这些性能单元测试

00:09:24.886 --> 00:09:26.976 A:middle
有一些很好的方面

00:09:27.596 --> 00:09:28.326 A:middle
我们将高度聚焦这些方面

00:09:28.326 --> 00:09:30.026 A:middle
这意味着如果它们

00:09:30.026 --> 00:09:31.276 A:middle
在将来出现衰退

00:09:31.276 --> 00:09:32.706 A:middle
我会很清楚地知道

00:09:32.706 --> 00:09:33.986 A:middle
这些衰退出现在哪里

00:09:34.026 --> 00:09:35.066 A:middle
因为这些正在运行的代码

00:09:35.066 --> 00:09:36.086 A:middle
已经处于检查之中了

00:09:36.706 --> 00:09:38.976 A:middle
而它们也将在不断地运行过程中

00:09:39.286 --> 00:09:40.626 A:middle
产生出更多的

00:09:40.626 --> 00:09:41.336 A:middle
可重复的结果

00:09:41.466 --> 00:09:42.436 A:middle
而它们产生的时间

00:09:42.436 --> 00:09:45.036 A:middle
也不会有太大的波动

00:09:45.426 --> 00:09:46.676 A:middle
因为这些代码

00:09:46.676 --> 00:09:47.156 A:middle
是高度聚焦的

00:09:48.176 --> 00:09:49.186 A:middle
现在 我们来将单元测试与

00:09:49.186 --> 00:09:50.056 A:middle
综合测试进行对比

00:09:51.076 --> 00:09:52.936 A:middle
在综合测试中

00:09:52.936 --> 00:09:54.796 A:middle
你要做的是

00:09:54.796 --> 00:09:56.616 A:middle
在用户使用 App 时

00:09:56.616 --> 00:09:59.016 A:middle
对其性能进行全面地测量

00:09:59.866 --> 00:10:01.506 A:middle
所以 如果我为 Xcode 编写

00:09:59.866 --> 00:10:01.506 A:middle
所以 如果我为 Xcode 编写

00:10:01.506 --> 00:10:03.106 A:middle
代码完成单元测试

00:10:03.756 --> 00:10:05.996 A:middle
哦不对 是综合测试

00:10:05.996 --> 00:10:08.466 A:middle
我会启动全部的 Xcode App

00:10:08.466 --> 00:10:09.566 A:middle
我会打开一个源文件

00:10:09.566 --> 00:10:11.136 A:middle
我会定位到该源文件

00:10:11.136 --> 00:10:13.366 A:middle
然后进行书写

00:10:13.366 --> 00:10:15.306 A:middle
再反复地进行代码完成

00:10:16.076 --> 00:10:17.636 A:middle
当我执行这些步骤的时候

00:10:17.636 --> 00:10:18.686 A:middle
看看 Xcode 在做什么

00:10:18.686 --> 00:10:20.316 A:middle
看看它花了多少时间

00:10:20.316 --> 00:10:22.956 A:middle
我会发现这个测试 一点也不聚焦

00:10:24.006 --> 00:10:25.476 A:middle
Xcode 会在我书写的时候

00:10:25.476 --> 00:10:26.986 A:middle
进行绘制和布局

00:10:26.986 --> 00:10:29.906 A:middle
当我归类时 它还会同时进行语法着色

00:10:30.556 --> 00:10:31.536 A:middle
在后台 Xcode 也许正在进行索引

00:10:31.536 --> 00:10:33.636 A:middle
读取获取状态 并决定把新的文件

00:10:34.086 --> 00:10:35.976 A:middle
显示在 Assistant Editor 中

00:10:36.056 --> 00:10:36.866 A:middle
而所有的这些

00:10:37.166 --> 00:10:40.056 A:middle
都将与代码完成一起

00:10:40.116 --> 00:10:42.246 A:middle
来竞争 CPU 的资源

00:10:43.086 --> 00:10:44.046 A:middle
也许当我查看 Profiler 时

00:10:44.046 --> 00:10:45.786 A:middle
我会看到我们花费了

00:10:45.786 --> 00:10:47.636 A:middle
80% 的时间在做语法着色

00:10:47.916 --> 00:10:50.626 A:middle
而剩下的 20% 则用在了代码完成上

00:10:51.086 --> 00:10:52.636 A:middle
从这个数据我可以知道

00:10:52.636 --> 00:10:54.776 A:middle
要提高代码完成性能

00:10:54.816 --> 00:10:55.976 A:middle
最好的方法就是

00:10:56.256 --> 00:10:58.076 A:middle
推迟语法着色

00:10:58.686 --> 00:11:00.256 A:middle
这样的知识

00:10:58.686 --> 00:11:00.256 A:middle
这样的知识

00:11:00.256 --> 00:11:01.946 A:middle
是我在高度聚焦的单元测试中

00:11:01.946 --> 00:11:02.546 A:middle
所无法获得的

00:11:02.546 --> 00:11:04.366 A:middle
所以如果今天各位听完这个演讲

00:11:04.366 --> 00:11:05.606 A:middle
只能带走两样东西的话

00:11:05.606 --> 00:11:07.476 A:middle
第二样就是

00:11:07.746 --> 00:11:08.866 A:middle
要调查你的性能

00:11:08.866 --> 00:11:10.936 A:middle
必然应该从这些

00:11:10.936 --> 00:11:12.506 A:middle
广泛的综合测试开始

00:11:12.506 --> 00:11:14.226 A:middle
它们会测量你的用户

00:11:14.226 --> 00:11:16.406 A:middle
使用 App 时的用户体验

00:11:18.026 --> 00:11:19.296 A:middle
对 我说的就是测试

00:11:19.626 --> 00:11:21.026 A:middle
测量以及分析

00:11:21.456 --> 00:11:22.346 A:middle
现在我想向你们

00:11:22.346 --> 00:11:24.166 A:middle
介绍一下用工具

00:11:24.216 --> 00:11:25.546 A:middle
在 Xcode 中进行分析

00:11:25.786 --> 00:11:26.646 A:middle
让我们来看一下

00:11:26.646 --> 00:11:27.166 A:middle
demo machine

00:11:35.056 --> 00:11:35.926 A:middle
今天我们要看的是一个

00:11:35.926 --> 00:11:37.146 A:middle
我们在 Xcode 9 和

00:11:37.146 --> 00:11:39.516 A:middle
Xcode 10 之间修复了的性能问题

00:11:39.516 --> 00:11:41.216 A:middle
我想展示给你们

00:11:41.696 --> 00:11:44.436 A:middle
下面我先启动 Xcode 9

00:11:44.436 --> 00:11:45.856 A:middle
打开我们的 Solar System App

00:11:47.056 --> 00:11:47.766 A:middle
那么 我们所

00:11:47.766 --> 00:11:49.796 A:middle
面临的问题就是创建标记

00:11:50.456 --> 00:11:51.486 A:middle
接着我要快速地

00:11:51.486 --> 00:11:52.956 A:middle
按几下快捷键 “Command-T”

00:11:52.956 --> 00:11:54.996 A:middle
如你所见

00:11:54.996 --> 00:11:56.896 A:middle
整个屏幕闪现了黑色

00:11:56.896 --> 00:11:58.166 A:middle
并且创建这些标记

00:11:58.166 --> 00:11:58.996 A:middle
花了好几秒的时间

00:11:59.626 --> 00:12:01.116 A:middle
这肯定达不到

00:11:59.626 --> 00:12:01.116 A:middle
这肯定达不到

00:12:01.116 --> 00:12:02.216 A:middle
我对性能的预期

00:12:02.216 --> 00:12:04.596 A:middle
我们需要来对它进行修复

00:12:04.956 --> 00:12:06.376 A:middle
那么我们来看看

00:12:06.376 --> 00:12:06.826 A:middle
如何进行修复

00:12:08.266 --> 00:12:09.566 A:middle
首先 我将启动 Instruments

00:12:09.606 --> 00:12:10.716 A:middle
这是我们的分析工具

00:12:11.436 --> 00:12:12.686 A:middle
你可以从 Xcode 菜单中打开它

00:12:12.686 --> 00:12:14.586 A:middle
在 Instruments 中的

00:12:14.886 --> 00:12:15.506 A:middle
Open Developer Tool 里面

00:12:15.976 --> 00:12:17.766 A:middle
现在 我在 Xcode 9 里面

00:12:18.106 --> 00:12:19.146 A:middle
所以如果我选择这个选项

00:12:19.146 --> 00:12:20.036 A:middle
那我启动的是

00:12:20.036 --> 00:12:21.476 A:middle
Xcode 9 中的 Instruments

00:12:21.476 --> 00:12:22.606 A:middle
当然我想要从 Xcode 10 中启动 Instruments

00:12:22.706 --> 00:12:23.766 A:middle
我已经把我的文件放在这里了

00:12:24.066 --> 00:12:26.066 A:middle
我将隐藏 Xcode

00:12:26.066 --> 00:12:28.956 A:middle
打开 Instruments

00:12:29.146 --> 00:12:30.366 A:middle
当 Instruments 启动时

00:12:31.796 --> 00:12:33.026 A:middle
就会出现一系列的分析工具

00:12:33.026 --> 00:12:34.226 A:middle
我们可以用它们

00:12:34.226 --> 00:12:35.546 A:middle
测量我们的 App

00:12:36.356 --> 00:12:37.426 A:middle
这里是各种各样的工具

00:12:37.786 --> 00:12:38.736 A:middle
它们能够测量

00:12:38.736 --> 00:12:41.186 A:middle
图形的利用率 内存消耗

00:12:41.836 --> 00:12:44.006 A:middle
IO 以及整体的时间

00:12:45.726 --> 00:12:47.096 A:middle
你们也许会对从哪个工具

00:12:47.096 --> 00:12:48.406 A:middle
先开始学习

00:12:48.406 --> 00:12:49.676 A:middle
而感到不安

00:12:51.236 --> 00:12:53.936 A:middle
那么我对你们的建议是

00:12:53.936 --> 00:12:55.596 A:middle
如果只学习其中的一个工具

00:12:55.596 --> 00:12:56.976 A:middle
那么你们应该学习

00:12:56.976 --> 00:12:57.516 A:middle
Time Profiler

00:12:58.296 --> 00:13:00.426 A:middle
在我的性能工作中

00:12:58.296 --> 00:13:00.426 A:middle
在我的性能工作中

00:13:00.426 --> 00:13:01.166 A:middle
有 95% 甚至更多的情况下都在使用它

00:13:01.736 --> 00:13:03.246 A:middle
当你的用户抱怨

00:13:03.246 --> 00:13:04.546 A:middle
你的 App 运行很慢时

00:13:04.546 --> 00:13:05.726 A:middle
他们是在抱怨

00:13:05.726 --> 00:13:07.796 A:middle
它花费了太多的时间

00:13:08.746 --> 00:13:10.116 A:middle
假如你的 App 太慢了

00:13:10.116 --> 00:13:10.926 A:middle
是因为你运行了太多的 IO

00:13:10.926 --> 00:13:12.636 A:middle
从而花费了太多的时间

00:13:12.636 --> 00:13:13.706 A:middle
那么你就能在 Time Profiler

00:13:13.706 --> 00:13:15.036 A:middle
上看到这一点

00:13:15.036 --> 00:13:17.146 A:middle
所以如果你只学习一个工具

00:13:17.146 --> 00:13:19.126 A:middle
那就学 Time Profiler

00:13:20.276 --> 00:13:22.636 A:middle
我们来看看它是如何工作的

00:13:25.346 --> 00:13:26.646 A:middle
我要启动 Time Profiler

00:13:26.646 --> 00:13:28.496 A:middle
只需要双击这里

00:13:28.496 --> 00:13:31.246 A:middle
然后将 Instruments

00:13:31.336 --> 00:13:32.226 A:middle
全屏显示

00:13:33.646 --> 00:13:35.396 A:middle
下面 我想要记录 Xcode

00:13:36.416 --> 00:13:38.086 A:middle
在 Instruments 视窗的左上角

00:13:38.256 --> 00:13:39.836 A:middle
你可以控制

00:13:39.836 --> 00:13:42.466 A:middle
你想要附加和记录的进程

00:13:43.096 --> 00:13:45.236 A:middle
在默认情况下 只要按下这个记录按钮

00:13:45.236 --> 00:13:46.726 A:middle
我的 Mac 上的所有进程

00:13:46.726 --> 00:13:47.636 A:middle
都会被记录

00:13:48.286 --> 00:13:50.926 A:middle
而我只想锁定到 Xcode

00:13:54.856 --> 00:13:56.866 A:middle
我会将这个弹出框

00:13:56.956 --> 00:13:59.046 A:middle
切换到 Xcode 然后点击记录

00:13:59.536 --> 00:14:00.786 A:middle
现在 当我记录的时候

00:13:59.536 --> 00:14:00.786 A:middle
现在 当我记录的时候

00:14:00.786 --> 00:14:02.256 A:middle
我就要关注视窗中的这个区域

00:14:02.256 --> 00:14:03.396 A:middle
来追踪轨迹视图

00:14:03.786 --> 00:14:05.216 A:middle
我要调整 Xcode 视窗的大小

00:14:05.216 --> 00:14:06.866 A:middle
将它调小一点

00:14:06.866 --> 00:14:08.026 A:middle
我就能看到那个区域

00:14:08.256 --> 00:14:09.896 A:middle
然后我就要进行让它变慢的操作

00:14:09.896 --> 00:14:11.316 A:middle
我要多创建几个标记

00:14:12.726 --> 00:14:15.826 A:middle
你可以看到这里的图表 发生了变化

00:14:15.826 --> 00:14:17.016 A:middle
现在 我要退出 App

00:14:17.086 --> 00:14:19.636 A:middle
然后回到 Instruments

00:14:21.316 --> 00:14:23.056 A:middle
所以刚刚发生了什么

00:14:23.936 --> 00:14:25.266 A:middle
当分析器在运行时

00:14:26.126 --> 00:14:27.476 A:middle
它被附加在我们的进程之中

00:14:27.476 --> 00:14:28.076 A:middle
像一个调试器

00:14:28.076 --> 00:14:30.586 A:middle
这个分析器每秒钟

00:14:30.586 --> 00:14:32.816 A:middle
都数千次地停止

00:14:32.816 --> 00:14:34.936 A:middle
我们的进程 并且它采集了跟踪轨迹

00:14:35.236 --> 00:14:37.026 A:middle
那么 提醒一下

00:14:37.026 --> 00:14:38.546 A:middle
跟踪轨迹描述了

00:14:38.546 --> 00:14:39.706 A:middle
你的程序如何到达

00:14:39.706 --> 00:14:40.386 A:middle
它目前所处的位置

00:14:40.876 --> 00:14:42.006 A:middle
所以如果你现在

00:14:42.006 --> 00:14:43.716 A:middle
处于 C 函数的第 6 行

00:14:43.716 --> 00:14:45.286 A:middle
你到达那里的原因是因为 Main 函数调用了 A B C

00:14:45.326 --> 00:14:48.256 A:middle
那么你的跟踪轨迹就是 Main A B C

00:14:49.006 --> 00:14:50.346 A:middle
当 Instruments 捕捉到

00:14:50.346 --> 00:14:51.946 A:middle
这些跟踪轨迹中的其中一个时

00:14:52.226 --> 00:14:53.356 A:middle
它会说 嘿 我们刚刚在 C 函数中

00:14:53.356 --> 00:14:54.686 A:middle
花了一毫秒

00:14:54.686 --> 00:14:56.916 A:middle
它说一毫秒

00:14:56.916 --> 00:14:58.056 A:middle
是因为我们的

00:14:58.056 --> 00:14:59.016 A:middle
记录采样间隔为

00:14:59.016 --> 00:14:59.546 A:middle
一毫秒每次

00:15:01.016 --> 00:15:02.696 A:middle
那么 在主线程上

00:15:02.696 --> 00:15:03.626 A:middle
所有的这些跟踪轨迹都要

00:15:03.626 --> 00:15:04.556 A:middle
从 Main 函数开始

00:15:04.556 --> 00:15:05.596 A:middle
它们也许将要调用

00:15:05.596 --> 00:15:06.666 A:middle
Application Main

00:15:06.796 --> 00:15:08.356 A:middle
之后它们将会通过你的源代码

00:15:08.356 --> 00:15:09.536 A:middle
不断地进行扩展

00:15:10.206 --> 00:15:11.896 A:middle
我们可以将这些跟踪轨迹

00:15:11.956 --> 00:15:13.266 A:middle
折叠在一起

00:15:13.266 --> 00:15:15.316 A:middle
将它们覆盖放进一个前缀树

00:15:15.316 --> 00:15:16.983 A:middle
以便它们从 Main 开始 进行下去

00:15:17.156 --> 00:15:18.646 A:middle
我们可以将我们

00:15:18.646 --> 00:15:19.836 A:middle
捕捉到的这些毫秒计数器

00:15:19.836 --> 00:15:21.386 A:middle
放在顶端 这样我们就能够

00:15:21.386 --> 00:15:23.416 A:middle
看到在我们源代码的

00:15:23.486 --> 00:15:24.716 A:middle
所有不同层级的区域上

00:15:24.716 --> 00:15:26.126 A:middle
我们都花费了多少时间

00:15:26.686 --> 00:15:27.636 A:middle
我们要看看这个数据

00:15:27.636 --> 00:15:29.416 A:middle
试着找出多余的

00:15:29.416 --> 00:15:31.066 A:middle
和不必要的操作

00:15:31.066 --> 00:15:32.696 A:middle
这样我们就可以提高速度

00:15:32.696 --> 00:15:33.836 A:middle
这是我们提高

00:15:33.836 --> 00:15:34.916 A:middle
App 性能的

00:15:34.916 --> 00:15:36.076 A:middle
首要方法

00:15:37.026 --> 00:15:39.316 A:middle
现在 正如你能想象到那样

00:15:39.316 --> 00:15:40.606 A:middle
我们每秒能捕捉

00:15:40.606 --> 00:15:41.456 A:middle
上千的跟踪轨迹

00:15:41.456 --> 00:15:43.326 A:middle
在 Instruments 里

00:15:43.326 --> 00:15:45.246 A:middle
有大量的数据需要你去处理

00:15:46.146 --> 00:15:48.356 A:middle
我首先要给你的建议就是

00:15:48.356 --> 00:15:49.946 A:middle
你想要尽可能多地

00:15:49.946 --> 00:15:51.596 A:middle
过滤这里的数据

00:15:51.596 --> 00:15:53.166 A:middle
你需要看整个过程的性能

00:15:53.166 --> 00:15:55.616 A:middle
不要把精力集中在细节点上

00:15:55.616 --> 00:15:56.376 A:middle
好吧

00:15:56.376 --> 00:15:57.786 A:middle
我想要给你演示

00:15:57.786 --> 00:16:00.086 A:middle
如何应用一堆强大的过滤器和工具

00:15:57.786 --> 00:16:00.086 A:middle
如何应用一堆强大的过滤器和工具

00:16:04.276 --> 00:16:06.196 A:middle
因为我之前做了记录

00:16:06.196 --> 00:16:07.806 A:middle
还记得吧 我让轨迹视图显示了出来

00:16:09.356 --> 00:16:10.476 A:middle
我这么做是因为我想要

00:16:10.476 --> 00:16:12.296 A:middle
看看当我创建标记的时候

00:16:12.296 --> 00:16:13.766 A:middle
CPU 的利用率是如何变化的

00:16:13.766 --> 00:16:15.836 A:middle
以及在哪里发生了变化

00:16:15.836 --> 00:16:18.156 A:middle
然后我告诉自己

00:16:18.156 --> 00:16:19.416 A:middle
就在这儿

00:16:20.186 --> 00:16:21.786 A:middle
我只是拖动鼠标并选中了

00:16:21.856 --> 00:16:26.076 A:middle
轨迹所在的区域

00:16:26.076 --> 00:16:27.786 A:middle
我让 Instruments

00:16:27.786 --> 00:16:31.666 A:middle
将它的跟踪轨迹数据只专注于

00:16:31.666 --> 00:16:32.706 A:middle
那里的时间间隔上

00:16:33.126 --> 00:16:34.356 A:middle
所有在这里的东西

00:16:34.356 --> 00:16:35.556 A:middle
都是我创建标记之前的

00:16:36.026 --> 00:16:37.516 A:middle
而所有这里的东西

00:16:37.626 --> 00:16:38.666 A:middle
都是我创建了标记

00:16:38.666 --> 00:16:39.786 A:middle
退出 App 之后的

00:16:40.056 --> 00:16:40.976 A:middle
那不是我现在要优化的地方

00:16:40.976 --> 00:16:42.576 A:middle
所以我不需要

00:16:42.676 --> 00:16:45.016 A:middle
看那里的数据

00:16:45.196 --> 00:16:48.376 A:middle
现在 在 Instruments 视窗的底部区域

00:16:48.376 --> 00:16:49.836 A:middle
Instruments 会显示出所有它

00:16:49.836 --> 00:16:51.366 A:middle
所采集到的轨迹

00:16:51.786 --> 00:16:55.376 A:middle
默认情况下

00:16:55.446 --> 00:16:56.206 A:middle
每个线程上只有一行在运作

00:16:56.646 --> 00:16:57.756 A:middle
在这个例子里

00:16:57.756 --> 00:16:59.126 A:middle
看起来只有四个线程在运作

00:16:59.386 --> 00:17:00.556 A:middle
而有时候则会更多

00:16:59.386 --> 00:17:00.556 A:middle
而有时候则会更多

00:17:00.626 --> 00:17:01.716 A:middle
这取决于你的 App

00:17:01.716 --> 00:17:02.436 A:middle
是如何并行的

00:17:03.306 --> 00:17:04.796 A:middle
我通常喜欢以聚焦的名义

00:17:06.276 --> 00:17:07.756 A:middle
我也喜欢折叠它们

00:17:07.756 --> 00:17:10.356 A:middle
让他们建立在每个线程中的

00:17:10.356 --> 00:17:11.976 A:middle
函数执行的最顶层上

00:17:11.976 --> 00:17:13.346 A:middle
而不是线程 ID 上

00:17:13.346 --> 00:17:14.636 A:middle
因为前者与我使用

00:17:14.636 --> 00:17:16.165 A:middle
Grand Central Dispatch 的方式

00:17:16.165 --> 00:17:17.406 A:middle
更为契合

00:17:18.616 --> 00:17:19.715 A:middle
接下来我们看看

00:17:19.715 --> 00:17:21.076 A:middle
Instruments 视窗的底部

00:17:21.076 --> 00:17:22.236 A:middle
我要点击这个叫 Call Tree 的按钮

00:17:22.266 --> 00:17:24.576 A:middle
然后放大它

00:17:24.576 --> 00:17:25.536 A:middle
这样你就能看到

00:17:25.536 --> 00:17:26.076 A:middle
我要做什么了

00:17:26.806 --> 00:17:28.556 A:middle
这里有几个可用的过滤器

00:17:28.906 --> 00:17:30.516 A:middle
其中一个被线程分开了

00:17:30.516 --> 00:17:31.756 A:middle
默认情况下它就已经开启了

00:17:31.886 --> 00:17:33.176 A:middle
接下来我要禁用它

00:17:33.176 --> 00:17:36.326 A:middle
相反地 所有的线程都将按照

00:17:36.326 --> 00:17:37.586 A:middle
它们的最顶层入口点来分组

00:17:37.586 --> 00:17:39.666 A:middle
而不是它们的线程 ID

00:17:42.356 --> 00:17:45.646 A:middle
现在 来看这个轨迹

00:17:45.646 --> 00:17:46.946 A:middle
可以看到所有这些

00:17:46.946 --> 00:17:49.336 A:middle
正在运作的线程 顺便提一下

00:17:49.336 --> 00:17:50.816 A:middle
在主要轨迹的下面

00:17:50.816 --> 00:17:53.126 A:middle
是总的 CPU 使用率

00:17:53.126 --> 00:17:54.416 A:middle
CPU 使用率被分解到每一个线程上

00:17:54.416 --> 00:17:56.086 A:middle
我们可以看到在这个轨迹中

00:17:56.086 --> 00:17:57.046 A:middle
几乎其他所有的线程

00:17:57.176 --> 00:17:58.826 A:middle
大部分都是闲置的

00:17:59.416 --> 00:18:00.836 A:middle
我可以只聚焦主线程

00:17:59.416 --> 00:18:00.836 A:middle
我可以只聚焦主线程

00:18:00.836 --> 00:18:03.036 A:middle
从这里选择它

00:18:03.036 --> 00:18:04.626 A:middle
现在我们就可以只看

00:18:04.776 --> 00:18:06.476 A:middle
在这个时间段内

00:18:06.526 --> 00:18:07.046 A:middle
主线程的轨迹

00:18:08.086 --> 00:18:09.606 A:middle
我准备开始深入到

00:18:09.606 --> 00:18:11.336 A:middle
这个调用层级当中

00:18:11.336 --> 00:18:12.376 A:middle
这样就能看到我的 App

00:18:12.416 --> 00:18:12.676 A:middle
在做什么

00:18:13.606 --> 00:18:15.106 A:middle
通常我会键入这一过程

00:18:15.106 --> 00:18:17.116 A:middle
只要按下向右箭头和向下箭头

00:18:17.116 --> 00:18:18.666 A:middle
然后不断地进行重复就可以了

00:18:19.366 --> 00:18:21.026 A:middle
但是我想要给你们演示

00:18:21.026 --> 00:18:22.526 A:middle
Instruments 提供的

00:18:22.526 --> 00:18:24.136 A:middle
最密集的跟踪轨迹检测

00:18:24.496 --> 00:18:25.416 A:middle
如果你的检测是不可见的

00:18:25.416 --> 00:18:26.886 A:middle
你可以用这个按钮

00:18:26.886 --> 00:18:28.756 A:middle
进行切换

00:18:28.756 --> 00:18:29.746 A:middle
最密集的追踪轨迹就都会在这

00:18:29.836 --> 00:18:31.706 A:middle
在这个标记里

00:18:31.706 --> 00:18:32.046 A:middle
“Extended Detail”

00:18:32.866 --> 00:18:34.296 A:middle
那么 最密集的追踪轨迹

00:18:34.296 --> 00:18:35.496 A:middle
正是出现得最频繁的

00:18:35.496 --> 00:18:36.566 A:middle
那个轨迹

00:18:36.566 --> 00:18:37.486 A:middle
当我们在当前选择下

00:18:37.486 --> 00:18:39.196 A:middle
进行记录的时候

00:18:39.196 --> 00:18:41.476 A:middle
追踪轨迹出现得最为频繁

00:18:42.116 --> 00:18:43.516 A:middle
你可以利用这个

00:18:43.516 --> 00:18:45.556 A:middle
在一段时间内 快速浏览许多帧

00:18:46.496 --> 00:18:47.846 A:middle
我通常会浏览这里

00:18:48.096 --> 00:18:49.366 A:middle
寻找我自己的 API

00:18:49.656 --> 00:18:50.816 A:middle
还有值得我花这么多时间

00:18:50.816 --> 00:18:51.856 A:middle
来寻找的东西

00:18:51.856 --> 00:18:54.336 A:middle
或者是寻找

00:18:54.336 --> 00:18:56.036 A:middle
我们在样本数中

00:18:56.036 --> 00:18:57.306 A:middle
有重要分支点的地方

00:18:58.356 --> 00:18:59.996 A:middle
现在我们看这里

00:18:59.996 --> 00:19:02.036 A:middle
我看到这个给 IDE 的调用

00:18:59.996 --> 00:19:02.036 A:middle
我看到这个给 IDE 的调用

00:19:02.036 --> 00:19:04.636 A:middle
Navigator Replacement View

00:19:04.636 --> 00:19:05.576 A:middle
Did Install View Controller

00:19:05.936 --> 00:19:07.106 A:middle
我十分熟悉这个 API

00:19:07.106 --> 00:19:09.176 A:middle
因为这是一个 Xcode 内部的 API

00:19:10.156 --> 00:19:12.686 A:middle
在这个轨迹中 我可以查看这里

00:19:12.686 --> 00:19:13.636 A:middle
在视窗的左手边

00:19:13.636 --> 00:19:14.686 A:middle
这里负责的是

00:19:14.686 --> 00:19:18.656 A:middle
我们记录的总时间中的

00:19:18.656 --> 00:19:21.596 A:middle
或者 45% 的时间中的 1.19 秒

00:19:22.176 --> 00:19:24.196 A:middle
这种方法要花费的时间

00:19:24.196 --> 00:19:27.756 A:middle
远远超出了我的预期

00:19:27.936 --> 00:19:29.526 A:middle
但是 我们很难聚焦在这里

00:19:29.526 --> 00:19:30.386 A:middle
看看究竟发生了什么

00:19:30.586 --> 00:19:32.336 A:middle
对吗 这是这个轨迹下面的

00:19:32.336 --> 00:19:33.346 A:middle
其他所有的东西

00:19:33.346 --> 00:19:35.926 A:middle
那么 它看起来就好像

00:19:35.926 --> 00:19:37.736 A:middle
30 到 40 的堆线范围深度

00:19:38.056 --> 00:19:39.096 A:middle
这是很吓人的

00:19:39.456 --> 00:19:40.726 A:middle
我要给你演示如何聚焦这里

00:19:41.276 --> 00:19:43.006 A:middle
第一种方法就在这里

00:19:43.006 --> 00:19:46.976 A:middle
我们又要使用 “Call Tree” 弹出框

00:19:47.176 --> 00:19:49.126 A:middle
我要在这个弹出框里

00:19:49.126 --> 00:19:50.516 A:middle
选择 “flattened recursion”

00:19:51.756 --> 00:19:55.126 A:middle
让我们来继续完成这步

00:19:55.196 --> 00:19:56.326 A:middle
现在你就可以看到

00:19:56.326 --> 00:19:57.526 A:middle
就在这里

00:19:57.526 --> 00:20:00.466 A:middle
一组重复的方法调用

00:19:57.526 --> 00:20:00.466 A:middle
一组重复的方法调用

00:20:00.466 --> 00:20:01.086 A:middle
被折叠了

00:20:02.396 --> 00:20:04.536 A:middle
不好意思 让我滑下来

00:20:05.586 --> 00:20:06.466 A:middle
它被折叠了

00:20:06.816 --> 00:20:08.436 A:middle
事实上 我就是想要

00:20:08.436 --> 00:20:09.586 A:middle
继续我的性能测试

00:20:09.586 --> 00:20:11.556 A:middle
在这个 IDE Navigator 范围里

00:20:11.556 --> 00:20:14.506 A:middle
在这个 API 调用中

00:20:14.506 --> 00:20:16.336 A:middle
我可以根据上下文

00:20:17.216 --> 00:20:19.376 A:middle
重新聚焦整个 Call Tree 点击这里

00:20:19.376 --> 00:20:20.746 A:middle
然后选择 “Focus on Subtree”

00:20:21.516 --> 00:20:22.446 A:middle
之后 Instruments 就会

00:20:22.446 --> 00:20:23.896 A:middle
将这个符号放到

00:20:23.896 --> 00:20:25.386 A:middle
整个调用图的最顶层

00:20:25.386 --> 00:20:26.556 A:middle
其他的所有东西都会被删除

00:20:26.556 --> 00:20:28.456 A:middle
它会重新将百分比设置为 100%

00:20:28.726 --> 00:20:30.166 A:middle
因此我可以就聚焦在这里

00:20:30.796 --> 00:20:33.096 A:middle
现在 我可以用键盘上的箭头键

00:20:33.096 --> 00:20:35.686 A:middle
来继续运行这个样本

00:20:35.686 --> 00:20:36.486 A:middle
看看我们在做什么

00:20:36.686 --> 00:20:38.906 A:middle
我很熟悉这些 API

00:20:38.906 --> 00:20:40.046 A:middle
看起来我们好像正在进行

00:20:40.206 --> 00:20:41.196 A:middle
状态恢复

00:20:41.766 --> 00:20:43.136 A:middle
当我继续扩大这个

00:20:43.136 --> 00:20:45.936 A:middle
我可以看到我们几乎

00:20:45.936 --> 00:20:47.176 A:middle
深入了这个表格视图

00:20:47.466 --> 00:20:49.696 A:middle
除了有这种

00:20:49.696 --> 00:20:51.476 A:middle
热调用路径以外

00:20:51.476 --> 00:20:52.986 A:middle
你知道 这种调用路径占了

00:20:52.986 --> 00:20:54.116 A:middle
大部分的总百分比

00:20:54.436 --> 00:20:56.566 A:middle
同时还有其他的这些附带样本

00:20:58.266 --> 00:20:59.896 A:middle
它们很容易分散

00:20:59.896 --> 00:21:00.236 A:middle
我们的注意力

00:20:59.896 --> 00:21:00.236 A:middle
我们的注意力

00:21:01.286 --> 00:21:03.766 A:middle
它们的其中之一就是

00:21:03.766 --> 00:21:04.076 A:middle
OPC Message Send

00:21:04.646 --> 00:21:06.926 A:middle
它可以遍布你的追踪器

00:21:06.926 --> 00:21:08.296 A:middle
只要你在写 Objective C

00:21:08.606 --> 00:21:09.916 A:middle
即使你在写 Swift 代码

00:21:09.916 --> 00:21:10.936 A:middle
当你按照你的方式

00:21:10.936 --> 00:21:11.966 A:middle
进入系统库时

00:21:11.966 --> 00:21:12.296 A:middle
你也会看到这个

00:21:12.636 --> 00:21:13.856 A:middle
你会经常看到它的对应函数

00:21:13.856 --> 00:21:15.916 A:middle
OPC LoadStrong LoadWeak

00:21:15.916 --> 00:21:18.726 A:middle
Retain 等等 你可以

00:21:18.726 --> 00:21:20.936 A:middle
将所有的内容从调用关系树里删除

00:21:20.936 --> 00:21:23.826 A:middle
根据上下文点开这里

00:21:23.866 --> 00:21:28.706 A:middle
选择 “Charge OPC to Callers”

00:21:29.406 --> 00:21:30.436 A:middle
它就会告诉 Instruments

00:21:30.466 --> 00:21:31.886 A:middle
来选取所有

00:21:31.886 --> 00:21:33.686 A:middle
来自于 OPC 库的样本

00:21:33.686 --> 00:21:35.176 A:middle
然后将它们从调用数据中删除

00:21:35.176 --> 00:21:36.456 A:middle
但是要将时间的属性归于

00:21:36.456 --> 00:21:37.846 A:middle
调用它们的父框架

00:21:38.176 --> 00:21:39.776 A:middle
我倾向于将那些

00:21:39.776 --> 00:21:41.126 A:middle
Objective C 运行时的函数

00:21:41.126 --> 00:21:42.266 A:middle
视为在书写 Objective C 代码时

00:21:42.266 --> 00:21:43.306 A:middle
的代价成本

00:21:43.706 --> 00:21:46.136 A:middle
我很少会去试图优化它们

00:21:46.136 --> 00:21:48.396 A:middle
所以我只会

00:21:48.456 --> 00:21:49.596 A:middle
将它们从数据中删除

00:21:49.596 --> 00:21:50.886 A:middle
这样我就可以聚焦在

00:21:50.886 --> 00:21:51.916 A:middle
我可能要处理的地方

00:21:53.176 --> 00:21:55.466 A:middle
还有一个你们可以应用的

00:21:55.466 --> 00:21:56.866 A:middle
强大的过滤器

00:21:56.866 --> 00:21:59.076 A:middle
我要用它来删除所有

00:21:59.076 --> 00:22:00.356 A:middle
出现在这一组帧中的小样本

00:21:59.076 --> 00:22:00.356 A:middle
出现在这一组帧中的小样本

00:22:00.356 --> 00:22:02.186 A:middle
它就在这里

00:22:02.226 --> 00:22:05.596 A:middle
Call Tree 约束条件的部分

00:22:06.126 --> 00:22:07.646 A:middle
让我来给你演示

00:22:11.146 --> 00:22:12.716 A:middle
我将要告诉 Instruments

00:22:12.716 --> 00:22:14.006 A:middle
我想要看到的轨迹范围

00:22:14.486 --> 00:22:16.236 A:middle
只包括我们所说的

00:22:16.236 --> 00:22:18.966 A:middle
20 或者更多的样本

00:22:19.256 --> 00:22:20.566 A:middle
我选择 20 是因为

00:22:20.566 --> 00:22:21.606 A:middle
我知道我已经选择了

00:22:21.606 --> 00:22:23.066 A:middle
一个两秒的间隔

00:22:23.066 --> 00:22:24.376 A:middle
那么 20 毫秒

00:22:24.376 --> 00:22:26.076 A:middle
将会呈现出整个工作的大约 1%

00:22:26.076 --> 00:22:27.036 A:middle
而就包含了

00:22:27.036 --> 00:22:29.846 A:middle
在默认情况下 我想进行工作的粒度

00:22:31.336 --> 00:22:32.926 A:middle
因此将 Call Tree 约束条件

00:22:33.986 --> 00:22:37.206 A:middle
设置为一个最小值 20

00:22:37.206 --> 00:22:39.516 A:middle
我就能更有效地聚焦在这里

00:22:40.456 --> 00:22:41.346 A:middle
那么 我在这里提到过

00:22:41.346 --> 00:22:43.296 A:middle
我们在扩展我的视图项目

00:22:43.336 --> 00:22:45.026 A:middle
我看到在这里

00:22:45.026 --> 00:22:46.446 A:middle
我们其实在调用 NS 大纲视图

00:22:46.446 --> 00:22:47.836 A:middle
扩展项目 扩展子项

00:22:48.436 --> 00:22:51.816 A:middle
在这里 很多人都会将调用图

00:22:51.876 --> 00:22:52.146 A:middle
停在这里

00:22:52.556 --> 00:22:55.226 A:middle
我们会看到 我正在调用一个系统框架

00:22:55.226 --> 00:22:56.346 A:middle
我在那里花了很多时间

00:22:56.706 --> 00:22:58.086 A:middle
这不是我的错 对吗

00:22:58.086 --> 00:22:58.926 A:middle
那么我能做什么呢

00:22:58.926 --> 00:23:00.486 A:middle
我不能优化 NS 大纲视图

00:22:58.926 --> 00:23:00.486 A:middle
我不能优化 NS 大纲视图

00:23:00.486 --> 00:23:01.976 A:middle
扩大项目

00:23:03.126 --> 00:23:04.606 A:middle
但你肯定有能力

00:23:04.606 --> 00:23:05.806 A:middle
改变这些情况

00:23:06.336 --> 00:23:07.706 A:middle
例如 花费在系统框架上的

00:23:07.706 --> 00:23:08.936 A:middle
所有这些时间

00:23:08.936 --> 00:23:10.976 A:middle
都是因为

00:23:10.976 --> 00:23:12.526 A:middle
它在运算你提供给它的数据

00:23:13.366 --> 00:23:14.546 A:middle
这需要花费很多的时间

00:23:14.616 --> 00:23:15.496 A:middle
因为你在成千上万次地

00:23:15.496 --> 00:23:17.476 A:middle
调用这个方法

00:23:18.366 --> 00:23:19.526 A:middle
它会花这么多时间

00:23:19.526 --> 00:23:20.666 A:middle
还因为它还要通过授权

00:23:20.666 --> 00:23:22.376 A:middle
回调你的代码

00:23:22.376 --> 00:23:24.566 A:middle
而最重要的是

00:23:24.566 --> 00:23:25.906 A:middle
你可以深入地了解

00:23:25.906 --> 00:23:27.836 A:middle
系统框架在做什么

00:23:27.836 --> 00:23:28.886 A:middle
只要沿着 Instruments 树

00:23:28.886 --> 00:23:30.186 A:middle
不断地进行扩展

00:23:30.186 --> 00:23:31.816 A:middle
并查看这些被调用的函数的名称

00:23:32.216 --> 00:23:33.766 A:middle
其实 我就是这样学会

00:23:33.766 --> 00:23:36.966 A:middle
修复这个漏洞的

00:23:37.166 --> 00:23:39.166 A:middle
当我将这个轨迹

00:23:39.166 --> 00:23:41.406 A:middle
扩展到大纲视图中

00:23:41.406 --> 00:23:42.966 A:middle
我能看到 它正在调用这里的两种方法

00:23:44.716 --> 00:23:47.106 A:middle
用项目入口来

00:23:47.106 --> 00:23:49.266 A:middle
批量处理扩展项目和子项

00:23:49.266 --> 00:23:50.686 A:middle
然后再进行最后更新后的工作

00:23:51.756 --> 00:23:53.356 A:middle
现在 那些对我来说都是重要的线索

00:23:53.356 --> 00:23:54.366 A:middle
说明我们或许

00:23:54.366 --> 00:23:56.226 A:middle
有可能通过批量处理来提高效率

00:23:56.226 --> 00:23:58.326 A:middle
正如你能想象的那样

00:23:58.326 --> 00:24:00.886 A:middle
大纲视图从一小组项目开始

00:23:58.326 --> 00:24:00.886 A:middle
大纲视图从一小组项目开始

00:24:00.886 --> 00:24:02.386 A:middle
然后我们试着

00:24:02.386 --> 00:24:03.906 A:middle
在我们代码的这个区域内

00:24:03.906 --> 00:24:05.676 A:middle
不断修复扩展状态

00:24:05.676 --> 00:24:06.666 A:middle
我们会告诉它打开

00:24:06.666 --> 00:24:08.256 A:middle
比如说顶部的项目

00:24:08.506 --> 00:24:09.436 A:middle
而当我告诉它打开顶部的项目时

00:24:09.436 --> 00:24:11.406 A:middle
你能够想象

00:24:11.406 --> 00:24:12.576 A:middle
它同时将里面的其他项目

00:24:12.576 --> 00:24:13.296 A:middle
都向下移了

00:24:14.056 --> 00:24:15.716 A:middle
然后我继续扩展第二个项目

00:24:16.106 --> 00:24:17.516 A:middle
它就会再次下移其他项目

00:24:17.906 --> 00:24:19.386 A:middle
接着是第三个项目 以此类推

00:24:19.386 --> 00:24:20.666 A:middle
而等到你做完这些

00:24:20.966 --> 00:24:22.546 A:middle
你已经将这些底部的项目

00:24:22.586 --> 00:24:24.246 A:middle
向下移动了数千次

00:24:25.166 --> 00:24:26.396 A:middle
那这些都是多余的工作

00:24:26.396 --> 00:24:27.626 A:middle
而它们正是

00:24:27.656 --> 00:24:28.976 A:middle
我在提高性能时

00:24:29.206 --> 00:24:30.736 A:middle
想要消除的东西

00:24:31.406 --> 00:24:32.596 A:middle
现在 这些方法调用

00:24:32.596 --> 00:24:35.376 A:middle
谈到的批量处理

00:24:35.376 --> 00:24:36.666 A:middle
让我觉得或许

00:24:36.666 --> 00:24:38.006 A:middle
在一些 API 中我可以

00:24:38.006 --> 00:24:39.416 A:middle
让大纲视图批量地进行工作

00:24:39.416 --> 00:24:41.436 A:middle
因此它就可以对所有的位置

00:24:41.436 --> 00:24:43.336 A:middle
只进行一次计算

00:24:43.336 --> 00:24:44.386 A:middle
而不是在我进行调用的时候

00:24:44.426 --> 00:24:44.986 A:middle
反复地计算

00:24:46.236 --> 00:24:48.256 A:middle
我还看到一个调用

00:24:48.256 --> 00:24:50.056 A:middle
用来进行最后更新之后的工作

00:24:50.406 --> 00:24:52.616 A:middle
那么 有时 API 会提供那种

00:24:52.726 --> 00:24:53.956 A:middle
在一组列阵上进行运算的

00:24:53.956 --> 00:24:55.696 A:middle
整体方法

00:24:55.696 --> 00:24:57.416 A:middle
而有时它则会提供一种

00:24:57.416 --> 00:24:59.456 A:middle
事务型 API

00:24:59.456 --> 00:25:00.806 A:middle
它会说我要开始进行更改

00:24:59.456 --> 00:25:00.806 A:middle
它会说我要开始进行更改

00:25:01.046 --> 00:25:01.716 A:middle
然后就做了一系列的变化

00:25:01.716 --> 00:25:02.996 A:middle
然后你说你完成了

00:25:02.996 --> 00:25:05.856 A:middle
之后它会对你变化的全程

00:25:05.856 --> 00:25:07.356 A:middle
进行计算

00:25:07.356 --> 00:25:08.656 A:middle
这比它自己独自完成这些

00:25:08.656 --> 00:25:10.116 A:middle
要更有效率

00:25:11.126 --> 00:25:12.306 A:middle
那么这时候 我会前往

00:25:12.306 --> 00:25:14.336 A:middle
NS 大纲视图或者

00:25:14.336 --> 00:25:15.996 A:middle
NS 表格视图 API

00:25:15.996 --> 00:25:17.296 A:middle
我会找一些这样的方法

00:25:17.686 --> 00:25:19.646 A:middle
那里确实有一个

00:25:19.646 --> 00:25:20.936 A:middle
在 NS 表格视图里

00:25:20.936 --> 00:25:22.176 A:middle
有一些开始和结束更新

00:25:22.176 --> 00:25:23.546 A:middle
所使用的方法

00:25:23.546 --> 00:25:25.096 A:middle
它们允许合并表格视图

00:25:25.096 --> 00:25:26.666 A:middle
并能够大大提高这些工作的效率

00:25:27.426 --> 00:25:29.606 A:middle
当然 我们要在 Xcode 10 中使用它

00:25:30.246 --> 00:25:32.966 A:middle
让我来给你演示

00:25:33.046 --> 00:25:34.376 A:middle
我要启动 Xcode 10

00:25:38.056 --> 00:25:39.136 A:middle
我要把 Source

00:25:39.136 --> 00:25:43.086 A:middle
作为一个 App 打开

00:25:43.086 --> 00:25:44.056 A:middle
然后我来创建一些标记

00:25:44.586 --> 00:25:46.116 A:middle
你可以看到

00:25:46.116 --> 00:25:47.666 A:middle
这里屏幕没有出现闪黑

00:25:47.666 --> 00:25:48.626 A:middle
标记也打开得更快了

00:25:49.506 --> 00:25:52.686 A:middle
现在 我想让标记打开的速度

00:25:52.876 --> 00:25:54.846 A:middle
比这个更快 对吗

00:25:54.846 --> 00:25:55.916 A:middle
那么我接下来应该怎么做呢

00:25:56.596 --> 00:25:57.586 A:middle
我很幸运

00:25:58.536 --> 00:25:59.496 A:middle
因为你不是每天

00:25:59.496 --> 00:26:00.956 A:middle
都需要进入轨迹中去寻找

00:25:59.496 --> 00:26:00.956 A:middle
都需要进入轨迹中去寻找

00:26:00.956 --> 00:26:02.406 A:middle
一些如此明显且容易修复的东西

00:26:02.406 --> 00:26:03.996 A:middle
而这样的东西在样本里

00:26:03.996 --> 00:26:05.156 A:middle
占到了 50%

00:26:05.916 --> 00:26:08.456 A:middle
对吗 其实并没有

00:26:08.456 --> 00:26:09.896 A:middle
什么巨大的严重问题

00:26:09.896 --> 00:26:10.806 A:middle
等待我来解决

00:26:11.686 --> 00:26:12.746 A:middle
相反 我要做的其实就是

00:26:12.746 --> 00:26:14.626 A:middle
检查整个样本

00:26:14.626 --> 00:26:15.656 A:middle
并在此过程中应用过滤器

00:26:15.656 --> 00:26:17.616 A:middle
所以我只是寻找

00:26:17.616 --> 00:26:20.286 A:middle
一些只占到 1% 或者更多时间的操作

00:26:20.286 --> 00:26:21.816 A:middle
我要寻找每一个

00:26:21.816 --> 00:26:23.436 A:middle
我认为能够运用一些方法

00:26:23.436 --> 00:26:24.836 A:middle
来将其速度

00:26:24.836 --> 00:26:26.536 A:middle
提高一点的东西

00:26:28.056 --> 00:26:29.016 A:middle
我会将它们都记下来

00:26:29.016 --> 00:26:30.496 A:middle
放在一张纸上或一个文档里

00:26:30.496 --> 00:26:32.216 A:middle
或者其他什么东西上

00:26:32.216 --> 00:26:33.436 A:middle
然后我就会着手解决它们

00:26:33.746 --> 00:26:34.736 A:middle
现在 我需要选择一个

00:26:34.736 --> 00:26:35.656 A:middle
解决它们的顺序 对吗

00:26:35.656 --> 00:26:37.326 A:middle
因为有的时候

00:26:37.326 --> 00:26:38.716 A:middle
用修复第二件事情时

00:26:38.716 --> 00:26:40.016 A:middle
所用的方法来修复

00:26:40.016 --> 00:26:40.816 A:middle
列表中的第五件事情

00:26:40.816 --> 00:26:42.516 A:middle
这方法可能会是过时的

00:26:42.516 --> 00:26:43.646 A:middle
如果没有排好顺序

00:26:43.646 --> 00:26:44.516 A:middle
你就会做多余的工作

00:26:44.516 --> 00:26:45.536 A:middle
这是十分糟糕的

00:26:45.586 --> 00:26:47.506 A:middle
因为我们首先要删除的就是

00:26:47.506 --> 00:26:48.116 A:middle
多余的工作

00:26:48.746 --> 00:26:50.476 A:middle
但是这些工作都是如何进行的

00:26:50.476 --> 00:26:51.826 A:middle
我们又很难去预测

00:26:52.066 --> 00:26:54.316 A:middle
你通常无法事先知道这些

00:26:54.746 --> 00:26:57.746 A:middle
所以不要因为这个

00:26:57.746 --> 00:26:59.446 A:middle
停下你开始的脚步

00:26:59.446 --> 00:27:00.956 A:middle
因为你想要把速度提高 30%

00:26:59.446 --> 00:27:00.956 A:middle
因为你想要把速度提高 30%

00:27:00.956 --> 00:27:03.536 A:middle
就得进行 103% 的

00:27:03.536 --> 00:27:04.186 A:middle
改善工作

00:27:05.706 --> 00:27:05.976 A:middle
明白吗

00:27:07.316 --> 00:27:10.756 A:middle
现在 回到我们的幻灯片

00:27:10.756 --> 00:27:13.516 A:middle
我要给你演示

00:27:13.516 --> 00:27:14.766 A:middle
一些我们常用的方法

00:27:14.766 --> 00:27:16.126 A:middle
用来持续改善我们的性能

00:27:21.346 --> 00:27:22.326 A:middle
毫无疑问

00:27:22.326 --> 00:27:23.896 A:middle
我们最常见的就是

00:27:23.896 --> 00:27:25.246 A:middle
使用那些与大纲视觉里

00:27:25.246 --> 00:27:26.236 A:middle
相同的方法

00:27:26.396 --> 00:27:28.276 A:middle
批量处理和推迟处理 对吗

00:27:28.276 --> 00:27:29.736 A:middle
你有一个 API

00:27:29.736 --> 00:27:31.526 A:middle
而当这个 API 被调用时

00:27:31.526 --> 00:27:31.836 A:middle
会出现一些副作用

00:27:32.196 --> 00:27:33.226 A:middle
然后你用一些代码

00:27:33.226 --> 00:27:34.426 A:middle
调用你在循环中的 API

00:27:34.426 --> 00:27:35.396 A:middle
这就是你在做的

00:27:35.586 --> 00:27:36.536 A:middle
被请求的首要工作

00:27:36.536 --> 00:27:38.566 A:middle
这其中有一个副作用

00:27:39.206 --> 00:27:40.986 A:middle
好 如果没有人读取

00:27:40.986 --> 00:27:42.516 A:middle
这个副作用的结果

00:27:42.516 --> 00:27:43.416 A:middle
那你就是在反复地

00:27:43.416 --> 00:27:44.916 A:middle
进行多余的工作

00:27:45.736 --> 00:27:47.016 A:middle
你通常可以

00:27:47.016 --> 00:27:48.696 A:middle
通过使用成批的接口

00:27:48.696 --> 00:27:50.366 A:middle
得到一个更加有效的接口

00:27:50.366 --> 00:27:52.376 A:middle
在这里客户端会给你一系列的

00:27:52.376 --> 00:27:53.476 A:middle
或者某种集合 包括所有要完成的工作

00:27:53.476 --> 00:27:54.796 A:middle
以便你能够一次性地

00:27:54.796 --> 00:27:56.056 A:middle
计算那个副作用

00:27:57.156 --> 00:27:59.526 A:middle
那么 有时你有很多个客户端 对吗

00:27:59.526 --> 00:28:00.766 A:middle
你无法对它们进行

00:27:59.526 --> 00:28:00.766 A:middle
你无法对它们进行

00:28:00.766 --> 00:28:02.186 A:middle
批量处理 那也没关系

00:28:02.596 --> 00:28:03.606 A:middle
你仍然可以通过推迟工作

00:28:03.606 --> 00:28:04.946 A:middle
以及缓慢地进行工作

00:28:04.946 --> 00:28:06.796 A:middle
来获得一样的性能风格

00:28:09.196 --> 00:28:10.996 A:middle
第三种提高你的性能的

00:28:10.996 --> 00:28:11.966 A:middle
简单的方法

00:28:11.966 --> 00:28:14.026 A:middle
是检查整个 Instruments 的轨迹

00:28:14.026 --> 00:28:15.156 A:middle
来寻找你看到它

00:28:15.156 --> 00:28:17.016 A:middle
对同样的东西进行反复计算

00:28:17.016 --> 00:28:17.656 A:middle
的地方

00:28:18.236 --> 00:28:19.556 A:middle
比如说 有一个方法

00:28:19.676 --> 00:28:20.856 A:middle
在它计算某个文档的大小的过程中

00:28:20.856 --> 00:28:22.526 A:middle
你看到同样的事情

00:28:22.526 --> 00:28:24.156 A:middle
在之后的几帧中也出现了

00:28:24.156 --> 00:28:25.946 A:middle
对于相同的文档

00:28:25.946 --> 00:28:27.006 A:middle
不断地重复

00:28:27.436 --> 00:28:28.426 A:middle
好 在这样的情况下

00:28:28.496 --> 00:28:29.536 A:middle
当然 你肯定想

00:28:29.536 --> 00:28:31.076 A:middle
一次性计算出该值

00:28:32.076 --> 00:28:33.226 A:middle
在最顶端计算它

00:28:33.226 --> 00:28:35.406 A:middle
让它不断地传下去 或者缓存它

00:28:36.476 --> 00:28:37.846 A:middle
另一个你可以在你的

00:28:37.846 --> 00:28:38.876 A:middle
UI App 中使用的方法

00:28:38.876 --> 00:28:41.166 A:middle
就是考虑

00:28:41.166 --> 00:28:42.296 A:middle
你使用了多少视图

00:28:42.296 --> 00:28:43.146 A:middle
来渲染你的 UI

00:28:43.146 --> 00:28:46.466 A:middle
使用一些带有小的

00:28:46.466 --> 00:28:48.106 A:middle
函数集的很小的视图

00:28:48.106 --> 00:28:50.216 A:middle
然后再将它们一起

00:28:50.216 --> 00:28:51.306 A:middle
生成大的函数

00:28:51.306 --> 00:28:52.286 A:middle
以此来组织你的源代码

00:28:52.286 --> 00:28:53.066 A:middle
这是很好的

00:28:53.516 --> 00:28:55.216 A:middle
但是你使用的视图越多

00:28:55.216 --> 00:28:57.516 A:middle
你就越难负担绘图

00:28:57.516 --> 00:28:58.276 A:middle
进行系统的布局

00:28:59.306 --> 00:29:01.066 A:middle
现在 这是一条双向道

00:28:59.306 --> 00:29:01.066 A:middle
现在 这是一条双向道

00:29:01.336 --> 00:29:02.776 A:middle
因为更小的视图通常会

00:29:02.776 --> 00:29:04.086 A:middle
让你有更多精密的捕捉

00:29:04.086 --> 00:29:06.156 A:middle
它们也可以提高你的性能

00:29:07.266 --> 00:29:08.896 A:middle
但是一般来说 你可以微调

00:29:08.896 --> 00:29:10.446 A:middle
你拥有的视图的数量

00:29:10.446 --> 00:29:11.606 A:middle
以对性能产生

00:29:11.606 --> 00:29:12.666 A:middle
显著的影响

00:29:12.786 --> 00:29:14.596 A:middle
但视图更少的话

00:29:14.596 --> 00:29:16.556 A:middle
也并不都是最好的

00:29:16.556 --> 00:29:17.606 A:middle
否则我们所有的 App

00:29:17.686 --> 00:29:18.866 A:middle
都会只有一个包括所有内容的

00:29:18.866 --> 00:29:19.116 A:middle
巨大视图了

00:29:21.266 --> 00:29:22.396 A:middle
另一个经常

00:29:22.396 --> 00:29:24.806 A:middle
用到的方法就是直接观察

00:29:25.356 --> 00:29:26.916 A:middle
我们的源代码中通常

00:29:26.916 --> 00:29:30.136 A:middle
有两个松散耦合的方面

00:29:30.286 --> 00:29:31.466 A:middle
也许它们彼此知道对方

00:29:31.466 --> 00:29:33.296 A:middle
而它们是通过一些

00:29:33.296 --> 00:29:34.996 A:middle
间接的机制

00:29:34.996 --> 00:29:36.016 A:middle
进行交流的

00:29:36.456 --> 00:29:37.796 A:middle
也许它们用

00:29:37.796 --> 00:29:39.916 A:middle
NS Notification Center

00:29:39.966 --> 00:29:41.316 A:middle
一些基于代码块的回调

00:29:41.516 --> 00:29:43.606 A:middle
授权或者关键值观察

00:29:45.006 --> 00:29:46.156 A:middle
我常常见到

00:29:46.216 --> 00:29:47.326 A:middle
我们会有一些模型代码

00:29:47.326 --> 00:29:49.076 A:middle
它们在一个循环中

00:29:49.076 --> 00:29:50.946 A:middle
被不断地改变

00:29:50.946 --> 00:29:51.856 A:middle
而每次它走向循环

00:29:52.206 --> 00:29:55.136 A:middle
就会引起许多 KVO 通告机制

00:29:55.386 --> 00:29:56.286 A:middle
当然 你其实并不能

00:29:56.286 --> 00:29:57.876 A:middle
在模块代码中看到它

00:29:57.956 --> 00:29:59.236 A:middle
但是在一些其他的控件里

00:29:59.526 --> 00:30:00.946 A:middle
它会十分活跃地作出回应

00:29:59.526 --> 00:30:00.946 A:middle
它会十分活跃地作出回应

00:30:00.946 --> 00:30:01.966 A:middle
并试图与模块里的变化

00:30:01.966 --> 00:30:03.126 A:middle
保持一致

00:30:03.126 --> 00:30:04.786 A:middle
这时你就花费了许多 CPU 时间

00:30:04.786 --> 00:30:06.636 A:middle
最终当你考虑整个的

00:30:06.636 --> 00:30:07.656 A:middle
变化的时候

00:30:07.656 --> 00:30:08.806 A:middle
这些都是多余的工作

00:30:09.496 --> 00:30:12.306 A:middle
那么 如果这是模块代码中的

00:30:12.776 --> 00:30:13.826 A:middle
直接调用 那么

00:30:13.826 --> 00:30:14.866 A:middle
不论是通过通告机制或授权

00:30:15.416 --> 00:30:17.106 A:middle
还是手动进行基于代码块的回调

00:30:17.106 --> 00:30:19.506 A:middle
改变都会发生地更加明显

00:30:19.506 --> 00:30:20.936 A:middle
当你编辑该模块代码时

00:30:21.396 --> 00:30:22.556 A:middle
你也许认为

00:30:22.556 --> 00:30:24.366 A:middle
将一些通告机制从循环中

00:30:24.366 --> 00:30:26.126 A:middle
拖出到循环之外

00:30:26.126 --> 00:30:27.916 A:middle
以对性能产生

00:30:27.916 --> 00:30:29.906 A:middle
较大的影响 是完全合适的

00:30:30.556 --> 00:30:31.856 A:middle
那么 或者

00:30:31.856 --> 00:30:33.476 A:middle
在控件这边 你可以用这些

00:30:33.476 --> 00:30:35.206 A:middle
推迟和批量处理方法中的一个

00:30:35.206 --> 00:30:36.946 A:middle
来避免多余的工作

00:30:36.946 --> 00:30:38.336 A:middle
只是它们的回应

00:30:38.336 --> 00:30:39.246 A:middle
是不同步的

00:30:41.136 --> 00:30:42.216 A:middle
最后 这是最简单的一个

00:30:42.836 --> 00:30:44.716 A:middle
一旦你的代码已经在

00:30:45.046 --> 00:30:46.386 A:middle
一个很好的路径上了

00:30:46.386 --> 00:30:47.586 A:middle
你知道 它已经是线性的了

00:30:47.586 --> 00:30:49.366 A:middle
而且不会有比线性更好的了

00:30:49.366 --> 00:30:50.346 A:middle
这是一种你要

00:30:51.796 --> 00:30:52.966 A:middle
获得的最低性能

00:30:53.626 --> 00:30:54.876 A:middle
毕竟 你要尽可能地

00:30:54.876 --> 00:30:57.186 A:middle
改进常数时间

00:30:57.246 --> 00:30:58.676 A:middle
那么 很简单

00:30:58.676 --> 00:31:00.096 A:middle
如果你将词典

00:30:58.676 --> 00:31:00.096 A:middle
如果你将词典

00:31:00.096 --> 00:31:01.366 A:middle
作为对象使用

00:31:01.366 --> 00:31:02.636 A:middle
那你或许已经看到这点

00:31:02.926 --> 00:31:04.216 A:middle
如果你有一堆为秘钥准备的

00:31:04.216 --> 00:31:06.166 A:middle
字符串常数

00:31:06.166 --> 00:31:07.466 A:middle
那么你就可以大幅度提高

00:31:07.466 --> 00:31:09.186 A:middle
代码的清晰性

00:31:09.186 --> 00:31:11.396 A:middle
提高代码完成和重构

00:31:11.396 --> 00:31:12.396 A:middle
以及源代码验证

00:31:12.396 --> 00:31:14.966 A:middle
通过使用特定的形式

00:31:15.076 --> 00:31:16.136 A:middle
用它们的 strucks 和 swift

00:31:16.136 --> 00:31:18.066 A:middle
用它们隐含的初始化器和一致性

00:31:18.066 --> 00:31:19.196 A:middle
来平等哈希值

00:31:19.196 --> 00:31:20.816 A:middle
这再简单不过了

00:31:21.336 --> 00:31:23.646 A:middle
而这能轻而易举地

00:31:23.646 --> 00:31:24.586 A:middle
改进你的源代码

00:31:24.586 --> 00:31:26.206 A:middle
如果你在许多小目标上

00:31:26.206 --> 00:31:27.916 A:middle
完成数百万次的

00:31:27.916 --> 00:31:29.546 A:middle
字符串哈希映射

00:31:29.546 --> 00:31:31.126 A:middle
和字符串 equation 的话

00:31:31.126 --> 00:31:32.546 A:middle
你会惊讶于你花费了

00:31:32.546 --> 00:31:33.316 A:middle
多少时间

00:31:34.516 --> 00:31:35.736 A:middle
那么接下来的时间

00:31:35.736 --> 00:31:37.386 A:middle
我想请 Matthew 上台来

00:31:37.386 --> 00:31:38.966 A:middle
谈谈我们如何将这些方法

00:31:39.056 --> 00:31:40.686 A:middle
应用到“照片”中去

00:31:42.516 --> 00:31:47.866 A:middle
［ 掌声 ］

00:31:48.366 --> 00:31:48.806 A:middle
&gt;&gt; 谢谢 Jim

00:31:49.966 --> 00:31:50.656 A:middle
大家好

00:31:50.826 --> 00:31:52.746 A:middle
我是 Matthew Lucas

00:31:52.806 --> 00:31:56.076 A:middle
一名“照片”团队的工程师

00:31:56.076 --> 00:31:57.536 A:middle
今天我想给你们一些

00:31:57.536 --> 00:31:59.316 A:middle
直接从“照片”中来的

00:31:59.316 --> 00:32:00.296 A:middle
实用的性能的例子

00:31:59.316 --> 00:32:00.296 A:middle
实用的性能的例子

00:32:01.306 --> 00:32:02.556 A:middle
那么首先 让我们先来

00:32:02.556 --> 00:32:03.536 A:middle
简单谈谈“照片”

00:32:04.076 --> 00:32:05.466 A:middle
我们都十分熟悉这个 App

00:32:06.026 --> 00:32:07.766 A:middle
它可以供你存储 浏览

00:32:07.846 --> 00:32:09.696 A:middle
并体验你最喜爱的时刻

00:32:10.236 --> 00:32:11.686 A:middle
因此你可以浏览你最喜欢的时刻

00:32:11.716 --> 00:32:13.526 A:middle
从这个“时刻”视图里

00:32:13.646 --> 00:32:14.596 A:middle
在这里可以看到

00:32:14.596 --> 00:32:15.496 A:middle
这是默认视图

00:32:15.926 --> 00:32:17.526 A:middle
但是你也可以

00:32:17.526 --> 00:32:19.456 A:middle
切换到另一种视图“精选”

00:32:19.456 --> 00:32:19.926 A:middle
或者“年度”

00:32:20.566 --> 00:32:22.736 A:middle
这个我一会再细说

00:32:23.446 --> 00:32:25.306 A:middle
现在图片库里可以有

00:32:25.306 --> 00:32:28.346 A:middle
1000 到 100000 张先前的素材

00:32:29.126 --> 00:32:30.636 A:middle
这取决于你对拍照的喜爱

00:32:31.196 --> 00:32:33.036 A:middle
我们都喜欢捕捉每天的生活中

00:32:33.036 --> 00:32:34.976 A:middle
那些快乐而珍贵的瞬间

00:32:36.336 --> 00:32:37.366 A:middle
所以我们都很耐心地去捕捉它们

00:32:37.366 --> 00:32:38.846 A:middle
但是当这样的事发生时

00:32:38.846 --> 00:32:40.576 A:middle
我们并不是那么地有耐心

00:32:41.286 --> 00:32:42.346 A:middle
在你启动“照片”

00:32:42.346 --> 00:32:44.226 A:middle
这个 App 的时候

00:32:44.226 --> 00:32:45.296 A:middle
如果你的“时刻”变成了这样

00:32:45.296 --> 00:32:46.926 A:middle
你会有什么感受

00:32:47.386 --> 00:32:48.636 A:middle
那么 你也许

00:32:48.636 --> 00:32:50.596 A:middle
还会遇到这样的情况

00:32:50.596 --> 00:32:51.716 A:middle
在这里只有许多的

00:32:51.716 --> 00:32:53.106 A:middle
空白图片框 这样看起来

00:32:53.106 --> 00:32:53.586 A:middle
并不是非常好

00:32:54.266 --> 00:32:55.356 A:middle
也许你轻轻滑动

00:32:55.856 --> 00:32:57.216 A:middle
这个灰色的地方就会消失

00:32:57.216 --> 00:33:00.736 A:middle
照片就会开始加载

00:32:57.216 --> 00:33:00.736 A:middle
照片就会开始加载

00:33:00.736 --> 00:33:01.766 A:middle
但你继续滑动

00:33:01.766 --> 00:33:02.886 A:middle
你就会遇到一些掉帧

00:33:02.886 --> 00:33:04.326 A:middle
因为视图被更新了

00:33:05.556 --> 00:33:06.836 A:middle
好 我们的目标就是

00:33:06.836 --> 00:33:07.626 A:middle
不要出现这样的视图

00:33:08.666 --> 00:33:09.876 A:middle
我们认为这种视图

00:33:09.926 --> 00:33:12.066 A:middle
并不是好的用户体验

00:33:12.066 --> 00:33:13.366 A:middle
但是我们知道有时候

00:33:13.366 --> 00:33:14.156 A:middle
这是不可避免的

00:33:14.556 --> 00:33:15.706 A:middle
但是当它过于频繁时

00:33:15.706 --> 00:33:16.666 A:middle
就无法忍受了

00:33:18.546 --> 00:33:19.666 A:middle
现在 当你运行一个 App 时

00:33:19.666 --> 00:33:20.756 A:middle
你想要确保它一开始就能用

00:33:20.756 --> 00:33:22.456 A:middle
能够做出响应

00:33:23.576 --> 00:33:25.296 A:middle
你还要确保

00:33:25.296 --> 00:33:26.516 A:middle
动画是很流畅的

00:33:27.226 --> 00:33:30.516 A:middle
而这两个属性

00:33:30.516 --> 00:33:31.796 A:middle
对用户体验来说

00:33:31.796 --> 00:33:32.786 A:middle
都是十分重要的

00:33:33.446 --> 00:33:35.766 A:middle
如果用户发现你的 App

00:33:35.766 --> 00:33:37.256 A:middle
并不相关

00:33:37.256 --> 00:33:38.146 A:middle
他们也许不会再使用它了

00:33:39.526 --> 00:33:40.706 A:middle
现在我来举例说明这两点

00:33:40.706 --> 00:33:42.626 A:middle
我要给你们

00:33:42.626 --> 00:33:43.426 A:middle
举两个例子

00:33:43.716 --> 00:33:45.726 A:middle
第一个就是我们如何

00:33:45.726 --> 00:33:47.406 A:middle
对这个“时刻”视图的启动

00:33:47.406 --> 00:33:48.166 A:middle
进行优化

00:33:48.886 --> 00:33:50.506 A:middle
第二个则是我们如何

00:33:50.506 --> 00:33:52.576 A:middle
创建这个“精选”和“年度”视图

00:33:52.576 --> 00:33:53.866 A:middle
以更好地适应用户的偏好

00:33:56.696 --> 00:33:59.876 A:middle
首先是启动“时刻”

00:34:00.296 --> 00:34:02.296 A:middle
[ 音质不清晰 ]

00:34:02.716 --> 00:34:03.876 A:middle
那么什么是启动

00:34:04.046 --> 00:34:05.386 A:middle
我们有三种启动

00:34:06.696 --> 00:34:08.176 A:middle
第一种也是更为昂贵的一种

00:34:08.176 --> 00:34:09.476 A:middle
即我们所说的冷启动

00:34:09.476 --> 00:34:11.406 A:middle
它取决于在重启后

00:34:11.406 --> 00:34:13.186 A:middle
第一次重新启动你的 App

00:34:14.346 --> 00:34:15.606 A:middle
所以里面基本上

00:34:15.606 --> 00:34:17.446 A:middle
还没有缓存任何东西

00:34:17.446 --> 00:34:19.096 A:middle
也许你需要载入一些后台过程

00:34:19.096 --> 00:34:19.946 A:middle
或者一些库

00:34:21.136 --> 00:34:23.116 A:middle
下面在这样的情况也会冷启动

00:34:23.206 --> 00:34:24.916 A:middle
系统在内存压力下运行

00:34:24.916 --> 00:34:29.686 A:middle
开始回收一些内存

00:34:30.045 --> 00:34:31.485 A:middle
那么 如果你关闭一个 App

00:34:31.485 --> 00:34:32.906 A:middle
也许不会触发代码运行

00:34:32.906 --> 00:34:34.606 A:middle
因为是系统决定了资源

00:34:34.606 --> 00:34:38.766 A:middle
应该何时被放在

00:34:38.766 --> 00:34:38.976 A:middle
页面上

00:34:39.065 --> 00:34:40.466 A:middle
而如果你关闭了一个 App

00:34:40.466 --> 00:34:41.646 A:middle
然后几秒之后重新打开它

00:34:41.726 --> 00:34:43.835 A:middle
几乎可以肯定

00:34:43.835 --> 00:34:45.565 A:middle
你进行的是一个热启动

00:34:46.036 --> 00:34:47.706 A:middle
我们称其为热启动

00:34:47.706 --> 00:34:50.386 A:middle
是因为资源或从属的东西

00:34:50.386 --> 00:34:52.116 A:middle
都仍然在缓存里

00:34:52.116 --> 00:34:52.996 A:middle
所以它能更快地启动

00:34:54.525 --> 00:34:56.636 A:middle
那么 最后一种类型就是

00:34:56.636 --> 00:34:59.026 A:middle
我们所说的热启动

00:34:59.026 --> 00:35:00.926 A:middle
根本上说它就是继续启动

00:34:59.026 --> 00:35:00.926 A:middle
根本上说它就是继续启动

00:35:00.926 --> 00:35:02.526 A:middle
因为这时 App 已经处于运行状态

00:35:02.526 --> 00:35:04.206 A:middle
直接把它带回前台就可以了

00:35:05.046 --> 00:35:06.136 A:middle
所以当你开始测量启动时

00:35:06.136 --> 00:35:07.656 A:middle
你应该从测量

00:35:07.656 --> 00:35:08.786 A:middle
热启动开始

00:35:09.456 --> 00:35:12.636 A:middle
它所用的时间

00:35:12.636 --> 00:35:14.036 A:middle
要比冷启动所花的时间

00:35:14.036 --> 00:35:17.326 A:middle
变量更小

00:35:17.326 --> 00:35:18.656 A:middle
而测试迭代也更快

00:35:18.656 --> 00:35:19.656 A:middle
因为你不需要

00:35:19.656 --> 00:35:20.536 A:middle
重启你的设备

00:35:21.846 --> 00:35:23.226 A:middle
那么 我们用来测量启动的方法

00:35:23.226 --> 00:35:25.156 A:middle
是对从你点击这个 App

00:35:25.156 --> 00:35:26.566 A:middle
的图标的那一刻

00:35:26.676 --> 00:35:28.236 A:middle
到你可以开始与你的 App 进行互动

00:35:28.236 --> 00:35:30.696 A:middle
的整个时间进行评估

00:35:30.986 --> 00:35:32.316 A:middle
我说互动的意思就是

00:35:32.316 --> 00:35:34.386 A:middle
它真的可以使用了

00:35:34.386 --> 00:35:35.726 A:middle
而不再有旋转的圈

00:35:37.436 --> 00:35:38.826 A:middle
它通常会在显示

00:35:38.856 --> 00:35:40.536 A:middle
这个旋转的圈的同时

00:35:40.536 --> 00:35:41.956 A:middle
分派一些工作

00:35:41.956 --> 00:35:43.126 A:middle
但并不能让 App 更快地投入使用

00:35:43.126 --> 00:35:44.526 A:middle
所以我们想要

00:35:44.526 --> 00:35:47.086 A:middle
避免这些

00:35:47.386 --> 00:35:48.656 A:middle
现在 我们有三个针对

00:35:48.656 --> 00:35:49.886 A:middle
“照片”的目标

00:35:50.576 --> 00:35:52.056 A:middle
第一个就是我们想要瞬时

00:35:52.056 --> 00:35:54.486 A:middle
我们不想出现任何

00:35:54.486 --> 00:35:57.666 A:middle
等待的圆圈

00:35:57.666 --> 00:35:59.266 A:middle
我们不想出现任何

00:36:00.996 --> 00:36:02.256 A:middle
空白的图片框

00:36:03.286 --> 00:36:04.346 A:middle
坦白地说

00:36:04.346 --> 00:36:06.686 A:middle
你也许会看到一些空白图片框

00:36:06.686 --> 00:36:07.886 A:middle
在你第一次

00:36:07.886 --> 00:36:09.536 A:middle
同步 iClub 的时候

00:36:09.536 --> 00:36:11.196 A:middle
但是当数据本地化后

00:36:11.266 --> 00:36:13.746 A:middle
就尽可能地不显示了

00:36:13.996 --> 00:36:15.446 A:middle
那么 我所说的瞬时是什么意思呢

00:36:16.356 --> 00:36:17.606 A:middle
就是它启动所花的时间

00:36:17.606 --> 00:36:18.836 A:middle
应该和从主屏幕上

00:36:18.836 --> 00:36:20.646 A:middle
放大的动画过程的时间 保持一致

00:36:21.086 --> 00:36:22.506 A:middle
这个时间通常是 500 到

00:36:22.506 --> 00:36:24.796 A:middle
600 毫秒之间

00:36:25.176 --> 00:36:26.386 A:middle
这样一来 从主屏幕到

00:36:26.386 --> 00:36:27.726 A:middle
App 的转换

00:36:27.836 --> 00:36:29.426 A:middle
就是无缝连接的了

00:36:29.426 --> 00:36:31.036 A:middle
用户可以立刻与 App 互动

00:36:31.036 --> 00:36:32.876 A:middle
只要它显示完动画过程

00:36:33.446 --> 00:36:34.666 A:middle
顺便说一下

00:36:34.666 --> 00:36:35.986 A:middle
这是最基本的建议

00:36:35.986 --> 00:36:37.546 A:middle
这不只是给“照片”的

00:36:37.546 --> 00:36:40.186 A:middle
所以它适用于所有的 App

00:36:40.346 --> 00:36:41.666 A:middle
那么让我们来看看“照片”

00:36:41.666 --> 00:36:42.266 A:middle
现在是如何启动的

00:36:43.436 --> 00:36:44.956 A:middle
如果我们近距离地

00:36:44.956 --> 00:36:46.576 A:middle
看看到底发生了什么

00:36:46.576 --> 00:36:48.656 A:middle
你就能看到“照片”

00:36:48.656 --> 00:36:50.146 A:middle
在动画过程完成之前

00:36:50.146 --> 00:36:50.576 A:middle
就已经准备好了

00:36:53.466 --> 00:36:55.216 A:middle
如果我们深入剖析这个启动

00:36:55.216 --> 00:36:57.356 A:middle
我们就会看到

00:36:57.356 --> 00:36:58.326 A:middle
这里主要有两个部分

00:36:58.746 --> 00:37:00.256 A:middle
第一部分时间花在 DYD 中

00:36:58.746 --> 00:37:00.256 A:middle
第一部分时间花在 DYD 中

00:37:00.256 --> 00:37:02.156 A:middle
这是载入器

00:37:02.156 --> 00:37:03.466 A:middle
它将加载并连接

00:37:03.466 --> 00:37:05.416 A:middle
你所有的动态链接器

00:37:05.416 --> 00:37:06.436 A:middle
而它还要运行你的

00:37:06.436 --> 00:37:07.576 A:middle
静态初始化器

00:37:08.766 --> 00:37:10.316 A:middle
虽然你对这部分

00:37:10.426 --> 00:37:11.476 A:middle
的控制是有限的

00:37:11.476 --> 00:37:11.886 A:middle
但也有可能做到

00:37:12.576 --> 00:37:14.886 A:middle
我鼓励你们去看看

00:37:14.886 --> 00:37:17.166 A:middle
去年 DYD 的部分

00:37:18.196 --> 00:37:21.496 A:middle
就能得到这个方面

00:37:21.496 --> 00:37:21.896 A:middle
更多的细节

00:37:23.566 --> 00:37:25.686 A:middle
那么 DYD 也要

00:37:25.686 --> 00:37:27.486 A:middle
在你的项目表中调用 Main

00:37:27.486 --> 00:37:28.716 A:middle
这就将我们带到了第二个部分

00:37:29.106 --> 00:37:30.356 A:middle
在这里你有很多控件

00:37:30.356 --> 00:37:32.236 A:middle
这个部分里 你需要确保

00:37:32.236 --> 00:37:34.016 A:middle
将它的时间保持在

00:37:34.016 --> 00:37:35.056 A:middle
500 毫秒以内

00:37:35.976 --> 00:37:38.386 A:middle
现在 第一个布局正好被排在

00:37:38.386 --> 00:37:39.786 A:middle
Did Finish Launching 之后

00:37:40.276 --> 00:37:41.286 A:middle
它将标记启动的结束

00:37:41.286 --> 00:37:42.796 A:middle
而这时你基本上

00:37:42.796 --> 00:37:43.946 A:middle
就可以使用你的 App 了

00:37:46.016 --> 00:37:47.556 A:middle
在这个部分

00:37:47.606 --> 00:37:49.116 A:middle
我们将要提到

00:37:49.116 --> 00:37:51.056 A:middle
一些原则

00:37:51.056 --> 00:37:52.316 A:middle
它们的确是我们在

00:37:52.316 --> 00:37:53.456 A:middle
进行性能工作时

00:37:53.456 --> 00:37:53.846 A:middle
最大的收获

00:37:55.116 --> 00:37:56.976 A:middle
第一是我们需要惰性

00:37:56.976 --> 00:37:59.566 A:middle
推迟我们不需要

00:37:59.616 --> 00:38:00.876 A:middle
的工作

00:37:59.616 --> 00:38:00.876 A:middle
的工作

00:38:01.396 --> 00:38:02.546 A:middle
第二则是要积极主动

00:38:02.546 --> 00:38:04.506 A:middle
而这两个方面

00:38:04.506 --> 00:38:05.256 A:middle
都有它的效用

00:38:05.256 --> 00:38:07.866 A:middle
积极主动能够

00:38:08.006 --> 00:38:09.716 A:middle
十分有效地预料

00:38:09.716 --> 00:38:12.296 A:middle
我们之后要做的工作

00:38:12.296 --> 00:38:13.526 A:middle
我们想要积极主动地

00:38:13.526 --> 00:38:15.176 A:middle
快速捕捉到衰退

00:38:15.176 --> 00:38:16.116 A:middle
因而你要确保

00:38:16.116 --> 00:38:18.716 A:middle
你设置了连续的综合测试

00:38:21.536 --> 00:38:23.116 A:middle
最后一点就是

00:38:23.116 --> 00:38:24.726 A:middle
无论我们总共需要

00:38:24.806 --> 00:38:26.046 A:middle
加载多少数据

00:38:26.046 --> 00:38:26.566 A:middle
我们都要持续不变

00:38:29.496 --> 00:38:31.646 A:middle
现在 如果我们用这个方法

00:38:31.646 --> 00:38:32.986 A:middle
我们载入所有在启动中

00:38:32.986 --> 00:38:34.186 A:middle
要用到的东西

00:38:34.186 --> 00:38:35.366 A:middle
这是它大概会在一个

00:38:35.366 --> 00:38:37.806 A:middle
有 30000 项的库里

00:38:37.806 --> 00:38:38.556 A:middle
花费的时间

00:38:39.696 --> 00:38:41.106 A:middle
首先你需要初始化数据库

00:38:41.106 --> 00:38:42.696 A:middle
然后你需要

00:38:42.696 --> 00:38:43.986 A:middle
准备一些视图控件

00:38:44.356 --> 00:38:45.516 A:middle
接着需要配置数据资源

00:38:45.516 --> 00:38:47.236 A:middle
加载一些库图像

00:38:47.236 --> 00:38:49.066 A:middle
然后读取云状态

00:38:49.986 --> 00:38:52.236 A:middle
你要记住 这个时间也许会

00:38:52.306 --> 00:38:54.496 A:middle
随着数据的生长发生变化

00:38:54.496 --> 00:38:56.666 A:middle
而其实数据将会一直生长

00:38:56.666 --> 00:38:59.593 A:middle
只要人们每天都拍照

00:39:00.046 --> 00:39:01.666 A:middle
所以在“照片”里一定要记住

00:39:01.666 --> 00:39:02.646 A:middle
我们要处理的是没有边界的

00:39:02.646 --> 00:39:05.526 A:middle
数据集

00:39:05.766 --> 00:39:07.016 A:middle
那么让我们来看看

00:39:07.016 --> 00:39:09.166 A:middle
如何优化“照片”的每一个步骤

00:39:09.166 --> 00:39:11.846 A:middle
就让我们从初始化数据库开始

00:39:13.236 --> 00:39:15.146 A:middle
首先 数据库通常

00:39:15.146 --> 00:39:16.606 A:middle
是在执行第一个查询的时候

00:39:16.606 --> 00:39:18.056 A:middle
被初始化和载入的

00:39:18.656 --> 00:39:19.886 A:middle
我们发现了一个非常

00:39:19.886 --> 00:39:21.806 A:middle
值得优化的地方 就是尽快地

00:39:21.806 --> 00:39:22.796 A:middle
在后台线程中完成初始化

00:39:22.796 --> 00:39:24.586 A:middle
这样它就不需要

00:39:24.586 --> 00:39:26.346 A:middle
在执行第一个查询时

00:39:26.346 --> 00:39:27.636 A:middle
再进行初始化工作了

00:39:28.996 --> 00:39:30.736 A:middle
这是个问题 特别是

00:39:30.946 --> 00:39:32.256 A:middle
如果第一个查询已经

00:39:32.256 --> 00:39:33.006 A:middle
从主线程当中完成了

00:39:34.756 --> 00:39:39.696 A:middle
现在 我们已经花了很多时间

00:39:39.696 --> 00:39:40.646 A:middle
而我们仍要花费很多时间

00:39:40.706 --> 00:39:41.956 A:middle
来检查我们在启动过程中的

00:39:41.956 --> 00:39:43.116 A:middle
所有的查询

00:39:43.626 --> 00:39:44.766 A:middle
我们想要确保

00:39:44.846 --> 00:39:46.396 A:middle
我们正在做的工作

00:39:46.396 --> 00:39:47.786 A:middle
是必要的

00:39:47.786 --> 00:39:49.276 A:middle
我们不再做更多的工作

00:39:53.246 --> 00:39:56.106 A:middle
那么最后 我们要确保

00:39:56.106 --> 00:39:57.586 A:middle
我们所做的所有查询

00:39:57.586 --> 00:39:59.576 A:middle
都要尽可能地高效

00:39:59.576 --> 00:40:01.086 A:middle
我们也想尽可能地

00:39:59.576 --> 00:40:01.086 A:middle
我们也想尽可能地

00:40:01.086 --> 00:40:04.876 A:middle
避免复杂的查询

00:40:05.276 --> 00:40:06.986 A:middle
我们有时知道

00:40:06.986 --> 00:40:08.646 A:middle
我们需要这样做 针对这类情况

00:40:08.686 --> 00:40:10.676 A:middle
我们设置了一些索引

00:40:10.676 --> 00:40:12.276 A:middle
以便我们能提高速度

00:40:15.676 --> 00:40:17.396 A:middle
现在我们的目标是

00:40:17.396 --> 00:40:19.546 A:middle
在初始化上花费的时间

00:40:19.546 --> 00:40:20.406 A:middle
不超过 30 毫秒

00:40:21.286 --> 00:40:22.526 A:middle
那么接下来让我们看看

00:40:22.526 --> 00:40:23.826 A:middle
我们如何准备视图控件

00:40:25.106 --> 00:40:25.986 A:middle
这里我们有四个标记

00:40:25.986 --> 00:40:27.796 A:middle
呈现在 App 的

00:40:27.906 --> 00:40:29.486 A:middle
主要特性上

00:40:29.656 --> 00:40:30.966 A:middle
那么我们需要注意的第一件事

00:40:30.966 --> 00:40:32.826 A:middle
就是我们想要

00:40:32.826 --> 00:40:33.926 A:middle
通过做最少的工作

00:40:33.926 --> 00:40:35.756 A:middle
来初始化这三个

00:40:35.756 --> 00:40:37.306 A:middle
不可见的标记

00:40:37.746 --> 00:40:39.896 A:middle
这里我们要遵循的原则

00:40:39.896 --> 00:40:41.516 A:middle
就是做尽可能地

00:40:41.566 --> 00:40:43.666 A:middle
少的工作来进行初始化

00:40:44.396 --> 00:40:45.436 A:middle
我们想要将工作最小化

00:40:45.436 --> 00:40:47.246 A:middle
同时记录载入的视图中的

00:40:47.246 --> 00:40:47.946 A:middle
所有的数据

00:40:50.486 --> 00:40:52.716 A:middle
这也让我们可以

00:40:52.786 --> 00:40:54.646 A:middle
在恒定时间内

00:40:54.706 --> 00:40:56.446 A:middle
初始化我们的控件

00:40:58.206 --> 00:40:59.936 A:middle
那么最后 我们想要

00:40:59.936 --> 00:41:02.376 A:middle
确保我们只加载了可见视图

00:40:59.936 --> 00:41:02.376 A:middle
确保我们只加载了可见视图

00:41:02.896 --> 00:41:06.116 A:middle
这很简单 而我们通常是

00:41:06.116 --> 00:41:07.806 A:middle
在那个部分出现衰退的

00:41:07.806 --> 00:41:11.376 A:middle
因此你应该格外小心

00:41:12.016 --> 00:41:12.706 A:middle
那么在准备视图控件的工作上

00:41:12.706 --> 00:41:14.106 A:middle
我们现在的目标是

00:41:14.106 --> 00:41:15.696 A:middle
花费 120 毫秒

00:41:16.626 --> 00:41:18.376 A:middle
但是准备视图控件意味着

00:41:18.376 --> 00:41:19.646 A:middle
要配置数据资源

00:41:19.646 --> 00:41:22.216 A:middle
接下来我们就来看这一块

00:41:25.056 --> 00:41:26.716 A:middle
所以在“时刻”视图里

00:41:26.716 --> 00:41:27.996 A:middle
会呈现出这些东西

00:41:27.996 --> 00:41:30.086 A:middle
呈现你生活中的事件

00:41:30.086 --> 00:41:31.376 A:middle
而 UI 则通过获得

00:41:31.426 --> 00:41:32.796 A:middle
这组照片来呈现出

00:41:32.866 --> 00:41:33.266 A:middle
这些标题栏

00:41:34.206 --> 00:41:35.866 A:middle
比如说在这个图库中

00:41:35.866 --> 00:41:38.596 A:middle
我们也许有 500 张照片

00:41:38.596 --> 00:41:40.026 A:middle
为了创建一个视图

00:41:40.026 --> 00:41:40.976 A:middle
我们需要预先加载所有的图片

00:41:43.236 --> 00:41:44.706 A:middle
但是我们只是需要

00:41:44.956 --> 00:41:46.846 A:middle
这些照片的元数据

00:41:46.846 --> 00:41:48.986 A:middle
这样我们就可以创建视图了

00:41:49.706 --> 00:41:50.676 A:middle
我们不需要你的内容

00:41:51.226 --> 00:41:54.846 A:middle
因此我们首先要做的就是

00:41:54.846 --> 00:41:56.726 A:middle
执行那个超高速的询问

00:41:56.926 --> 00:41:59.356 A:middle
然后我们只加载

00:41:59.396 --> 00:42:01.086 A:middle
我们这里需要的内容

00:41:59.396 --> 00:42:01.086 A:middle
我们这里需要的内容

00:42:02.286 --> 00:42:04.046 A:middle
既然是这样

00:42:04.046 --> 00:42:05.016 A:middle
我们只要加载可见内容

00:42:05.016 --> 00:42:07.466 A:middle
在我们这个例子里

00:42:07.466 --> 00:42:09.616 A:middle
可见内容在 7 到 10 个图片之间

00:42:10.956 --> 00:42:12.536 A:middle
因为我们的可见内容

00:42:12.876 --> 00:42:14.616 A:middle
是有限值 所以我们可以

00:42:14.616 --> 00:42:16.066 A:middle
在主线程上

00:42:16.066 --> 00:42:18.376 A:middle
同时进行加载

00:42:18.696 --> 00:42:20.896 A:middle
同时 我们还想预先安排工作

00:42:20.896 --> 00:42:23.526 A:middle
这样我们就可以

00:42:23.526 --> 00:42:25.546 A:middle
开始异步加载

00:42:25.546 --> 00:42:26.596 A:middle
剩下的数据

00:42:27.156 --> 00:42:28.406 A:middle
我们在后台线程上

00:42:28.406 --> 00:42:30.236 A:middle
以正确的特性进行加载

00:42:30.316 --> 00:42:31.356 A:middle
来确保它不会

00:42:31.356 --> 00:42:33.886 A:middle
抢占主线程的运行

00:42:38.416 --> 00:42:40.516 A:middle
在这里我们的目标是

00:42:40.516 --> 00:42:41.416 A:middle
100 毫秒

00:42:44.706 --> 00:42:48.266 A:middle
那么最后 我们的数据源

00:42:48.266 --> 00:42:50.226 A:middle
还提供一些图像

00:42:50.226 --> 00:42:51.736 A:middle
我们来看看如何优化这个部分

00:42:53.666 --> 00:42:54.916 A:middle
所以目前为止

00:42:54.916 --> 00:42:55.936 A:middle
这是我们面对的

00:42:55.936 --> 00:42:57.986 A:middle
最大的数据块

00:42:57.986 --> 00:42:59.066 A:middle
当我们意识到在启动时

00:42:59.066 --> 00:43:00.376 A:middle
我们花费了好几秒的时间

00:42:59.066 --> 00:43:00.376 A:middle
我们花费了好几秒的时间

00:43:00.376 --> 00:43:02.536 A:middle
来加载这个图像 我们就意识到

00:43:02.586 --> 00:43:04.686 A:middle
我们做了太多的工作

00:43:05.086 --> 00:43:06.296 A:middle
所以我们所做的第一件事

00:43:06.296 --> 00:43:08.686 A:middle
就是估计我们在启动时

00:43:08.686 --> 00:43:10.246 A:middle
需要用到多少张图像

00:43:10.246 --> 00:43:12.556 A:middle
然后在第一个事务中

00:43:12.556 --> 00:43:14.566 A:middle
我们只加载那些图像

00:43:15.286 --> 00:43:17.216 A:middle
这种情况下 这一数量

00:43:17.216 --> 00:43:19.436 A:middle
可以达到 60 张

00:43:19.436 --> 00:43:19.876 A:middle
包括上下堆起的

00:43:20.576 --> 00:43:23.386 A:middle
接下来 为了先加载那些图像

00:43:23.386 --> 00:43:25.036 A:middle
我们需要确保

00:43:25.036 --> 00:43:26.676 A:middle
我们只加载

00:43:26.676 --> 00:43:28.046 A:middle
低分辨率的图像

00:43:28.806 --> 00:43:29.956 A:middle
这样我们加载在

00:43:29.956 --> 00:43:32.026 A:middle
内存里的像素就越少

00:43:32.026 --> 00:43:32.546 A:middle
这样就能更高效

00:43:35.316 --> 00:43:36.566 A:middle
呈现出这个数据块

00:43:36.566 --> 00:43:37.486 A:middle
现在需要 200 毫秒

00:43:39.316 --> 00:43:40.846 A:middle
这是目前为止

00:43:40.846 --> 00:43:41.566 A:middle
我们提速最多的部分

00:43:42.296 --> 00:43:43.466 A:middle
我要它成为一个常数时间

00:43:43.466 --> 00:43:46.966 A:middle
真的很不错

00:43:47.786 --> 00:43:49.346 A:middle
那么 有时候你禁不住

00:43:49.346 --> 00:43:50.806 A:middle
问问自己这个问题

00:43:50.806 --> 00:43:52.056 A:middle
这在启动的时候真的需要吗

00:43:52.286 --> 00:43:54.116 A:middle
我们这里的一个例子

00:43:54.116 --> 00:43:54.896 A:middle
是页脚视图

00:43:55.486 --> 00:43:57.256 A:middle
它通过网络或数据库

00:43:57.256 --> 00:44:00.316 A:middle
来搜集信息

00:43:57.256 --> 00:44:00.316 A:middle
来搜集信息

00:44:00.316 --> 00:44:01.666 A:middle
而其实我们最先的设计

00:44:01.666 --> 00:44:03.616 A:middle
是不要在启动时显示它

00:44:04.086 --> 00:44:05.806 A:middle
以优先所有我们

00:44:05.806 --> 00:44:06.636 A:middle
在这里看到的图像

00:44:06.906 --> 00:44:08.946 A:middle
我们想要显示尽可能多的图像

00:44:09.366 --> 00:44:10.356 A:middle
那这样可能就更简单了

00:44:11.456 --> 00:44:12.936 A:middle
我们现在只要安排

00:44:12.996 --> 00:44:14.596 A:middle
启动后的工作

00:44:14.596 --> 00:44:16.216 A:middle
我们缓存并加工之后要

00:44:16.216 --> 00:44:18.756 A:middle
显示的信息

00:44:20.686 --> 00:44:21.716 A:middle
现在 如果我们已经需要

00:44:21.716 --> 00:44:22.936 A:middle
显示这个信息

00:44:22.936 --> 00:44:24.606 A:middle
有一个方法可以办到

00:44:24.606 --> 00:44:25.786 A:middle
利用后台来

00:44:25.786 --> 00:44:27.176 A:middle
从 UA 工具包中

00:44:27.176 --> 00:44:29.506 A:middle
刷新 API

00:44:29.506 --> 00:44:31.036 A:middle
它便会主动清除你的 App

00:44:31.086 --> 00:44:32.376 A:middle
这样当用户要启动 App 的时候

00:44:32.376 --> 00:44:33.856 A:middle
你就可以开始

00:44:33.856 --> 00:44:35.446 A:middle
准备一些内容了

00:44:37.156 --> 00:44:38.836 A:middle
所以现在 这个部分已经从启动中删除了

00:44:38.836 --> 00:44:40.726 A:middle
为我们节省了 400 秒的

00:44:40.726 --> 00:44:42.066 A:middle
CPU 时间

00:44:43.486 --> 00:44:45.276 A:middle
现在我们看这里的

00:44:45.276 --> 00:44:47.046 A:middle
更新后的分解图

00:44:47.046 --> 00:44:48.866 A:middle
可以看到这些工作

00:44:48.866 --> 00:44:50.216 A:middle
只值得花费 450 毫秒

00:44:50.896 --> 00:44:53.776 A:middle
而我们现在在这个 500 毫秒

00:44:53.836 --> 00:44:55.866 A:middle
窗口之中

00:44:55.866 --> 00:44:58.006 A:middle
而且不论如何

00:44:58.006 --> 00:44:59.486 A:middle
将其同时呈现出来

00:44:59.486 --> 00:45:00.816 A:middle
最重要的是

00:44:59.486 --> 00:45:00.816 A:middle
最重要的是

00:45:01.246 --> 00:45:02.626 A:middle
一定要确保

00:45:02.626 --> 00:45:03.596 A:middle
你要考虑你

00:45:03.636 --> 00:45:04.656 A:middle
准备内容的时间成本

00:45:05.296 --> 00:45:07.466 A:middle
我这里说的考虑

00:45:07.466 --> 00:45:09.086 A:middle
是要真的去测量它

00:45:10.606 --> 00:45:12.806 A:middle
现在 你应该争取

00:45:12.806 --> 00:45:13.746 A:middle
在常量时间里进行工作

00:45:13.746 --> 00:45:14.926 A:middle
无论你加载的

00:45:14.926 --> 00:45:15.896 A:middle
数据总共有多少

00:45:16.676 --> 00:45:17.796 A:middle
在我们的例子里

00:45:17.796 --> 00:45:19.526 A:middle
我们的确有许多数据集

00:45:19.746 --> 00:45:21.976 A:middle
我们需要保持常量时间

00:45:24.756 --> 00:45:25.846 A:middle
既然我们已经启动了 App

00:45:25.846 --> 00:45:27.746 A:middle
我们要开始使用它

00:45:27.746 --> 00:45:28.866 A:middle
那么我们来看看我们是

00:45:29.096 --> 00:45:30.256 A:middle
如何创建“精选”和“年度”视图的

00:45:30.256 --> 00:45:31.146 A:middle
以便我们提高性能

00:45:31.226 --> 00:45:34.416 A:middle
正如我之前提到过

00:45:34.416 --> 00:45:37.236 A:middle
我们的用户能够进行

00:45:37.236 --> 00:45:39.136 A:middle
从动画过程到“时刻”视图的无缝转换

00:45:39.436 --> 00:45:40.966 A:middle
再通过“精选”

00:45:40.966 --> 00:45:41.496 A:middle
到“年度”视图

00:45:44.316 --> 00:45:46.206 A:middle
这是一个复杂的层级

00:45:46.886 --> 00:45:48.746 A:middle
我们要展示数千张的照片

00:45:49.606 --> 00:45:51.116 A:middle
我们要支持实时更新

00:45:51.686 --> 00:45:53.436 A:middle
我们也要支持

00:45:53.436 --> 00:45:55.186 A:middle
这些图层间的动画过程

00:45:55.816 --> 00:45:57.276 A:middle
我们还有一些手势

00:46:00.436 --> 00:46:02.076 A:middle
那么 我们这里还有一些目标

00:46:02.956 --> 00:46:05.356 A:middle
对于带给我们用户的体验

00:46:06.426 --> 00:46:07.726 A:middle
第一个和之前一样

00:46:07.726 --> 00:46:08.706 A:middle
我们不想有任何

00:46:08.706 --> 00:46:09.436 A:middle
等待的圆圈

00:46:09.436 --> 00:46:10.156 A:middle
我们不想有空白的图片框

00:46:10.256 --> 00:46:12.586 A:middle
当然我们想要

00:46:12.586 --> 00:46:13.806 A:middle
流畅的动画过程

00:46:13.996 --> 00:46:15.576 A:middle
这里所说的流畅

00:46:15.846 --> 00:46:19.396 A:middle
是指 60 到 120 帧每秒

00:46:19.446 --> 00:46:21.686 A:middle
这依赖于你正在运行的屏幕

00:46:23.266 --> 00:46:25.356 A:middle
记得之前我们说过的原则

00:46:25.876 --> 00:46:27.236 A:middle
现在 它们在这里都是有用的

00:46:27.586 --> 00:46:28.926 A:middle
我们想要懈怠并推迟

00:46:28.926 --> 00:46:30.036 A:middle
我们预先递交的工作

00:46:30.786 --> 00:46:31.876 A:middle
我们想要积极地

00:46:31.876 --> 00:46:34.316 A:middle
快速捕捉衰退

00:46:34.316 --> 00:46:35.956 A:middle
但是我们也想要

00:46:35.956 --> 00:46:37.476 A:middle
在布局关口中保持不变

00:46:37.476 --> 00:46:39.686 A:middle
无论我们要加载多少数据

00:46:41.566 --> 00:46:42.886 A:middle
那么 这次我们还想要及时

00:46:42.886 --> 00:46:44.396 A:middle
我们想要记住

00:46:44.396 --> 00:46:46.046 A:middle
绘制循环周期

00:46:47.076 --> 00:46:48.426 A:middle
这里我的意思是

00:46:48.426 --> 00:46:49.676 A:middle
你要记住

00:46:49.676 --> 00:46:52.096 A:middle
我们只有 8 或 16 毫秒

00:46:52.096 --> 00:46:53.426 A:middle
来绘制那一帧

00:46:53.426 --> 00:46:54.206 A:middle
所以我们需要确保

00:46:54.256 --> 00:46:55.876 A:middle
我们不超时

00:46:55.916 --> 00:46:57.156 A:middle
否则就会开始掉帧

00:46:59.356 --> 00:47:01.486 A:middle
现在 让我们返回一步

00:46:59.356 --> 00:47:01.486 A:middle
现在 让我们返回一步

00:47:01.486 --> 00:47:02.636 A:middle
看看我们要在这里

00:47:02.636 --> 00:47:03.176 A:middle
获取什么

00:47:03.866 --> 00:47:05.076 A:middle
我们要这个便捷视图

00:47:05.076 --> 00:47:07.466 A:middle
里面有分栏和小单元格

00:47:09.846 --> 00:47:11.226 A:middle
而这基本上就是

00:47:11.226 --> 00:47:12.836 A:middle
“精选”视图给你提供的

00:47:12.836 --> 00:47:13.076 A:middle
对吗

00:47:13.636 --> 00:47:15.036 A:middle
只不过在这样极端的例子里

00:47:15.036 --> 00:47:16.246 A:middle
我们会限制

00:47:16.246 --> 00:47:17.506 A:middle
我们使用这个基本的方法

00:47:17.506 --> 00:47:18.576 A:middle
可以获得的极限

00:47:18.746 --> 00:47:20.546 A:middle
那样就会导致过多的

00:47:20.546 --> 00:47:21.616 A:middle
视图和过多的图层

00:47:23.796 --> 00:47:26.256 A:middle
但是随着分层的复杂性不断增加

00:47:26.256 --> 00:47:28.396 A:middle
花在内存上的时间

00:47:28.396 --> 00:47:30.086 A:middle
也在不断增加

00:47:31.706 --> 00:47:33.086 A:middle
所以这里我们需要创新

00:47:33.846 --> 00:47:35.126 A:middle
我们大幅地限制视图的数量

00:47:35.126 --> 00:47:36.436 A:middle
同时仍使用一个

00:47:36.436 --> 00:47:37.966 A:middle
“精选”视图

00:47:40.176 --> 00:47:42.066 A:middle
我们使用的这种方法

00:47:42.066 --> 00:47:43.466 A:middle
在电子游戏里更为常见

00:47:43.466 --> 00:47:44.606 A:middle
它叫做图谱法

00:47:45.146 --> 00:47:47.106 A:middle
它基本上就是

00:47:47.106 --> 00:47:48.766 A:middle
把一组图像组合

00:47:48.766 --> 00:47:49.406 A:middle
成为一个

00:47:50.536 --> 00:47:52.186 A:middle
我们高效地完成了它

00:47:52.186 --> 00:47:53.806 A:middle
开始只用很小的缩略图

00:47:53.806 --> 00:47:56.736 A:middle
然后我们将所有的原始图像数据

00:47:56.736 --> 00:47:58.856 A:middle
标记在一个我们用作

00:47:58.856 --> 00:47:59.716 A:middle
带状的画布上

00:48:01.156 --> 00:48:03.336 A:middle
接着 我们使用图像原始数据

00:48:03.336 --> 00:48:04.866 A:middle
这样就能够避免去解码每一个

00:48:04.866 --> 00:48:07.766 A:middle
我们发送的缩略图

00:48:08.376 --> 00:48:09.576 A:middle
因此基本上我们会显示一条

00:48:09.576 --> 00:48:10.726 A:middle
随机的图像

00:48:12.406 --> 00:48:14.286 A:middle
那么 我们飞速生成并缓存它们

00:48:14.286 --> 00:48:16.206 A:middle
因此我们可以更加灵活

00:48:18.436 --> 00:48:20.086 A:middle
当我们将多个图片绘制成一个时

00:48:20.086 --> 00:48:22.026 A:middle
我们会大量寄存

00:48:22.026 --> 00:48:24.716 A:middle
单元格 图层及目标的数量

00:48:24.716 --> 00:48:26.006 A:middle
这样便简化了布局

00:48:26.006 --> 00:48:29.066 A:middle
节省了创建它要花费的时间

00:48:29.686 --> 00:48:31.266 A:middle
现在这样很好

00:48:31.266 --> 00:48:32.356 A:middle
但是也要有所取舍

00:48:32.356 --> 00:48:34.966 A:middle
这就是它们的其中一个

00:48:36.806 --> 00:48:38.606 A:middle
如果有人试着长按

00:48:38.606 --> 00:48:40.996 A:middle
或强制搜索一个这里的项目

00:48:40.996 --> 00:48:42.866 A:middle
我们就需要计算它的位置

00:48:42.916 --> 00:48:44.536 A:middle
这样我们才能

00:48:44.536 --> 00:48:45.426 A:middle
正确地获得预览

00:48:45.996 --> 00:48:48.136 A:middle
因为只要我们显示一张图像

00:48:48.136 --> 00:48:50.776 A:middle
我们就需要维持

00:48:50.776 --> 00:48:53.156 A:middle
每个图像的映射

00:48:53.156 --> 00:48:54.736 A:middle
以及它的绘制条

00:48:56.086 --> 00:48:57.226 A:middle
现在你也许在想

00:48:57.226 --> 00:48:58.536 A:middle
我们为什么要飞速地生成它们

00:49:00.016 --> 00:49:01.736 A:middle
我们要支持实时更新

00:49:01.736 --> 00:49:03.626 A:middle
这就是原因

00:49:04.416 --> 00:49:06.536 A:middle
我们也需要不一样的视图大小

00:49:07.426 --> 00:49:09.016 A:middle
比如说 我们这里有风景图

00:49:09.516 --> 00:49:11.476 A:middle
但也有人像图

00:49:12.976 --> 00:49:16.276 A:middle
但是这没有关系

00:49:16.276 --> 00:49:17.096 A:middle
因为我们的用户增长

00:49:17.096 --> 00:49:18.786 A:middle
在很长一段时间里

00:49:18.786 --> 00:49:20.606 A:middle
是十分典型的

00:49:20.606 --> 00:49:22.766 A:middle
而我们需要生成

00:49:22.766 --> 00:49:24.076 A:middle
数千张图像这样的例子

00:49:24.076 --> 00:49:25.016 A:middle
相当地罕见

00:49:27.716 --> 00:49:29.086 A:middle
现在 你或许想知道

00:49:29.086 --> 00:49:30.236 A:middle
那我们为什么不生成

00:49:30.236 --> 00:49:31.016 A:middle
整个这部分呢

00:49:32.616 --> 00:49:33.776 A:middle
答案就是我们的设计记录

00:49:33.776 --> 00:49:35.306 A:middle
就是完成这个动画过程

00:49:35.306 --> 00:49:36.966 A:middle
在这里你能看到

00:49:36.966 --> 00:49:37.926 A:middle
在“精选”视图中它们

00:49:37.926 --> 00:49:39.036 A:middle
都扩展到自己的那部分中

00:49:39.036 --> 00:49:40.436 A:middle
或者相反地

00:49:40.436 --> 00:49:42.986 A:middle
折叠进它们的小组里

00:49:45.616 --> 00:49:47.206 A:middle
所以如果说第二部分里

00:49:47.206 --> 00:49:48.376 A:middle
你只要记住一件事情

00:49:48.376 --> 00:49:49.776 A:middle
那就是你应该考虑

00:49:49.776 --> 00:49:50.916 A:middle
你的层级的布局成本

00:49:50.916 --> 00:49:54.506 A:middle
然后对它进行测量

00:49:56.356 --> 00:49:59.106 A:middle
最后 你要时刻考虑性能

00:49:59.566 --> 00:50:01.066 A:middle
在“照片”里我们十分关心这点

00:49:59.566 --> 00:50:01.066 A:middle
在“照片”里我们十分关心这点

00:50:01.066 --> 00:50:02.916 A:middle
这正是我们日常工作的一部分

00:50:04.906 --> 00:50:06.796 A:middle
要了解更多的信息

00:50:06.796 --> 00:50:09.026 A:middle
你们可以观看我在这里提到的

00:50:09.026 --> 00:50:10.146 A:middle
三个实验室

00:50:10.246 --> 00:50:12.486 A:middle
祝你们

00:50:12.486 --> 00:50:13.026 A:middle
参会愉快

00:50:13.526 --> 00:50:13.806 A:middle
谢谢

00:50:14.516 --> 00:50:20.450 A:middle
［ 掌声 ］
