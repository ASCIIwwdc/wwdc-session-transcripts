WEBVTT

00:00:17.284 --> 00:00:21.421 align:middle line:0
（测试提示和技巧 演讲417）

00:00:32.432 --> 00:00:33.300 align:middle line:-1
大家好

00:00:33.367 --> 00:00:35.169 align:middle line:-1
欢迎来到“测试提示和技巧”

00:00:36.069 --> 00:00:37.571 align:middle line:-1
我叫Brian Croom

00:00:38.305 --> 00:00:39.806 align:middle line:-1
我的同事Stuart和我

00:00:39.873 --> 00:00:42.943 align:middle line:-2
真的很高兴与你们分享
一些很棒的测试技术

00:00:43.010 --> 00:00:44.578 align:middle line:-1
我们最近一直在学习这些技术

00:00:47.848 --> 00:00:50.717 align:middle line:-2
随着会议的临近
我们觉得如果我们能有一个app

00:00:50.784 --> 00:00:52.486 align:middle line:-1
用它能够在会议中心周围

00:00:52.553 --> 00:00:56.423 align:middle line:-2
找一些我们能够去看和做的东西
这会是一件很酷的事情

00:00:57.791 --> 00:00:59.026 align:middle line:-1
我们一直在创建这app

00:00:59.393 --> 00:01:03.497 align:middle line:-2
为它在圣何塞周围寻找
各种兴趣点提供视图

00:00:59.393 --> 00:01:03.497 align:middle line:-2
为它在圣何塞周围寻找
各种兴趣点提供视图

00:01:03.864 --> 00:01:05.699 align:middle line:-1
并列出了它们离你有多远

00:01:07.568 --> 00:01:09.503 align:middle line:-1
现在当然我们想要确保

00:01:09.570 --> 00:01:11.738 align:middle line:-1
我们有一个非常棒的测试套件

00:01:12.372 --> 00:01:16.143 align:middle line:-2
我们可以运行这个app
让我们相信我们的代码能够正常工作

00:01:16.443 --> 00:01:18.812 align:middle line:-2
并且随着开发的继续
可以保证代码继续工作

00:01:21.882 --> 00:01:25.419 align:middle line:-1
今天我们想与你们分享四套

00:01:25.485 --> 00:01:28.622 align:middle line:-2
我们在为app编写测试时
发现的非常有用的技术

00:01:30.290 --> 00:01:33.627 align:middle line:-1
一些在app中测试网络代码的策略

00:01:34.895 --> 00:01:38.732 align:middle line:-2
一些用于处理基础通知对象的
测试技巧

00:01:40.300 --> 00:01:44.671 align:middle line:-2
在测试中使用模拟对象时
利用协议的方法

00:01:45.639 --> 00:01:48.775 align:middle line:-2
以及一些使测试运行速度
非常快的技术

00:01:52.446 --> 00:01:54.248 align:middle line:-1
现在让我们开始讨论网络吧

00:01:55.883 --> 00:01:59.253 align:middle line:-2
为了允许动态内容更新
我们一直在开发app

00:01:59.319 --> 00:02:01.421 align:middle line:-1
以便从远程网络服务器加载数据

00:01:59.319 --> 00:02:01.421 align:middle line:-1
以便从远程网络服务器加载数据

00:02:02.856 --> 00:02:04.491 align:middle line:-1
这里我们发现一些

00:02:04.558 --> 00:02:06.460 align:middle line:-1
网络代码编写测试时有用的东西

00:02:08.794 --> 00:02:11.565 align:middle line:-1
首先快速回顾一下去年的情况

00:02:12.332 --> 00:02:16.637 align:middle line:-2
在2017年WWDC
“可测试性工程”演讲中

00:02:17.070 --> 00:02:18.939 align:middle line:-1
我们讨论了金字塔模型

00:02:19.306 --> 00:02:21.508 align:middle line:-1
它是如何构造测试套件

00:02:21.909 --> 00:02:26.480 align:middle line:-2
平衡彻底性
可理解性和执行速度的指南

00:02:28.615 --> 00:02:31.818 align:middle line:-1
总之 理想的测试套件往往是

00:02:31.885 --> 00:02:34.488 align:middle line:-1
由大量集中的单元测试组成

00:02:34.555 --> 00:02:38.025 align:middle line:-2
能够在你的app中
执行单独的分类和方法

00:02:39.693 --> 00:02:42.262 align:middle line:-1
它们的特点是阅读简单

00:02:42.963 --> 00:02:46.099 align:middle line:-2
在检测到问题时
能产生明确的失败消息

00:02:47.000 --> 00:02:48.569 align:middle line:-1
并且运行速度非常快

00:02:48.802 --> 00:02:51.939 align:middle line:-1
通常是每分钟数百或数千次测试

00:02:54.741 --> 00:02:59.379 align:middle line:-2
这些测试由较小数量的
中型集成测试作为补充

00:03:00.214 --> 00:03:03.951 align:middle line:-2
这些测试以app中的
离散子系统或类集群为目标

00:03:04.918 --> 00:03:06.787 align:middle line:-1
检查它们是否一起正常工作

00:03:07.087 --> 00:03:09.089 align:middle line:-1
每个测试只需几秒钟即可运行

00:03:11.792 --> 00:03:15.095 align:middle line:-1
这个套件是一些端到端的系统测试

00:03:15.562 --> 00:03:17.898 align:middle line:-1
最常见的形式是UI测试

00:03:18.432 --> 00:03:20.734 align:middle line:-1
它非常类似于终端用户

00:03:20.801 --> 00:03:23.203 align:middle line:-1
在他们的设备上的操作方式

00:03:24.538 --> 00:03:26.807 align:middle line:-2
检查所有的部分
是否正确地连接在一起

00:03:27.107 --> 00:03:31.678 align:middle line:-2
以及检查与底层操作系统
和外部资源进行良好的交互

00:03:33.680 --> 00:03:35.782 align:middle line:-1
遵循该模型的测试套件

00:03:36.116 --> 00:03:39.520 align:middle line:-1
可以全面描述app代码的基本功能

00:03:43.790 --> 00:03:45.826 align:middle line:-1
为了测试这个app中的网络堆栈

00:03:46.193 --> 00:03:48.362 align:middle line:-2
我们真的很想
把这个金字塔模型放在心上

00:03:48.929 --> 00:03:51.565 align:middle line:-1
将它作为如何构建测试套件的指南

00:03:53.333 --> 00:03:55.202 align:middle line:-1
在这里我们看到了

00:03:55.269 --> 00:03:57.504 align:middle line:-1
在app中发出网络请求并将数据

00:03:57.804 --> 00:03:59.573 align:middle line:-1
输入UI所涉及的高级数据流

00:04:02.342 --> 00:04:03.911 align:middle line:-1
在这个app的早期原型中

00:04:04.444 --> 00:04:05.846 align:middle line:-1
我们在视图控制器中有个方法

00:04:05.913 --> 00:04:08.382 align:middle line:-1
它可以在一个地方完成所有这些工作

00:04:09.116 --> 00:04:10.284 align:middle line:-1
它看起来和这个很相似

00:04:12.486 --> 00:04:15.455 align:middle line:-1
该方法接受一个带有用户位置的参数

00:04:17.357 --> 00:04:20.928 align:middle line:-2
并使用该参数为我们的
服务器API端点构造URL

00:04:21.161 --> 00:04:23.230 align:middle line:-1
并将该位置作为查询参数

00:04:26.133 --> 00:04:29.069 align:middle line:-2
然后它使用Foundation的
URLSession API

00:04:29.336 --> 00:04:32.606 align:middle line:-2
为向那个URL得到一个请求
而创建一个数据任务

00:04:34.908 --> 00:04:37.978 align:middle line:-1
当服务器响应时它将打开数据

00:04:39.479 --> 00:04:42.349 align:middle line:-2
使用foundation的
JSONDecoder API对其解码

00:04:42.950 --> 00:04:45.519 align:middle line:-1
将其解码为一个有关值的数组

00:04:45.586 --> 00:04:47.521 align:middle line:-1
这是我在其他地方声明过的一个结构

00:04:47.855 --> 00:04:49.823 align:middle line:-1
并符合可解码协议

00:04:51.825 --> 00:04:53.360 align:middle line:-1
然后将其存储到属性中

00:04:53.427 --> 00:04:55.829 align:middle line:-1
以驱实现动表视图数据源

00:04:56.029 --> 00:04:57.264 align:middle line:-1
并将其放到屏幕上

00:05:00.567 --> 00:05:03.303 align:middle line:-2
现在非常值得注意的是
我能够

00:05:03.370 --> 00:05:05.305 align:middle line:-2
利用Swift
和Foundation的强大功能

00:05:05.739 --> 00:05:08.075 align:middle line:-2
能够在大约15行代码中
完成所有这一切

00:05:09.443 --> 00:05:11.778 align:middle line:-1
但是通过一个方法来做所有这些

00:05:12.179 --> 00:05:13.947 align:middle line:-1
那么我就损害了代码的可维护性

00:05:14.014 --> 00:05:16.383 align:middle line:-1
特别是代码的可测试性

00:05:20.921 --> 00:05:23.257 align:middle line:-1
来看看我们的测试金字塔的基础

00:05:23.457 --> 00:05:26.860 align:middle line:-1
我们真正想要做的是为每个流的

00:05:26.927 --> 00:05:28.662 align:middle line:-1
每个部分编写焦点单元测试

00:05:30.864 --> 00:05:34.935 align:middle line:-2
让我们首先考虑请求准备
和响应解析步骤

00:05:38.772 --> 00:05:41.141 align:middle line:-1
为了使这段代码更具可测试性

00:05:41.842 --> 00:05:44.111 align:middle line:-2
我们首先从视图控制器中取出它
并在这个专用的

00:05:45.546 --> 00:05:49.316 align:middle line:-2
PointsOfInterestRequest
类型上创建了两个方法

00:05:50.584 --> 00:05:53.287 align:middle line:-1
这给出了两个很好的解耦方法

00:05:53.353 --> 00:05:55.822 align:middle line:-1
每个都取一些值作为输入

00:05:56.223 --> 00:06:00.160 align:middle line:-2
并将它们转换为一些输出值
而不产生任何副作用

00:05:56.223 --> 00:06:00.160 align:middle line:-2
并将它们转换为一些输出值
而不产生任何副作用

00:06:03.330 --> 00:06:05.232 align:middle line:-1
这使得我们很容易

00:06:05.599 --> 00:06:07.901 align:middle line:-1
为代码编写一个集中的单元测试

00:06:09.503 --> 00:06:11.371 align:middle line:-2
在这里我们测试
makeRequest方法

00:06:12.039 --> 00:06:14.208 align:middle line:-1
只要做一个样本并放置位置

00:06:14.274 --> 00:06:15.742 align:middle line:-1
将其传递到这个方法中

00:06:16.210 --> 00:06:18.846 align:middle line:-1
并对其返回值做出一些认定

00:06:22.082 --> 00:06:26.253 align:middle line:-2
类似地 我们可以通过传入
一些模拟JSON

00:06:26.386 --> 00:06:28.522 align:middle line:-2
并对解析的结果进行断言
来测试响应解析

00:06:31.491 --> 00:06:34.027 align:middle line:-1
关于这个测试的另一点需要注意的是

00:06:34.428 --> 00:06:36.864 align:middle line:-1
我正在使用XCTest支持

00:06:36.930 --> 00:06:38.999 align:middle line:-1
来用于标记为抛出的测试方法

00:06:39.399 --> 00:06:42.169 align:middle line:-1
这允许我在测试代码中使用try

00:06:42.336 --> 00:06:44.705 align:middle line:-2
而不需在测试代码周围使用
明确的do-catch块围绕它

00:06:49.042 --> 00:06:52.112 align:middle line:-2
现在让我们看看
与URL会话交互的代码

00:06:54.581 --> 00:06:56.884 align:middle line:-1
这里我们再次将其拉出视图控制器

00:06:57.985 --> 00:07:00.220 align:middle line:-1
并使用与我们刚才看到的

00:06:57.985 --> 00:07:00.220 align:middle line:-1
并使用与我们刚才看到的

00:07:00.287 --> 00:07:02.055 align:middle line:-1
请求类型匹配方法签名的方法

00:07:02.122 --> 00:07:04.291 align:middle line:-1
创建了APIRequest协议

00:07:05.526 --> 00:07:08.362 align:middle line:-2
这是被请求类型初始化的
APIRequestLoader

00:07:09.530 --> 00:07:13.901 align:middle line:-2
和urlSession实例类
来使用的

00:07:17.504 --> 00:07:20.174 align:middle line:-2
这个类有一个
loadAPIRequest方法

00:07:20.674 --> 00:07:24.478 align:middle line:-2
它使用该apiRequest值
来生成一个URL请求

00:07:25.412 --> 00:07:27.314 align:middle line:-1
将其输入到urlSession中

00:07:28.415 --> 00:07:31.151 align:middle line:-2
然后再用apiRequest
在你的响应中进行解析

00:07:34.721 --> 00:07:37.491 align:middle line:-2
现在我们可以继续为这个方法
编写单元测试

00:07:37.925 --> 00:07:40.194 align:middle line:-2
但是现在我实际上想要向上
移动金字塔

00:07:40.527 --> 00:07:42.629 align:middle line:-1
并查看一个中级集成测试

00:07:42.696 --> 00:07:44.898 align:middle line:-1
它涵盖了这个数据流的几个部分

00:07:47.000 --> 00:07:49.903 align:middle line:-2
在套件的这一层我还能够进行的
另一个测试是

00:07:49.970 --> 00:07:53.106 align:middle line:-1
我与URLSession API

00:07:53.173 --> 00:07:55.375 align:middle line:-1
的交互是正确的

00:07:57.010 --> 00:07:59.847 align:middle line:-2
事实证明
foundation URL加载

00:07:59.913 --> 00:08:01.682 align:middle line:-1
系统为实现这点提供了很大的帮助

00:07:59.913 --> 00:08:01.682 align:middle line:-1
系统为实现这点提供了很大的帮助

00:08:04.184 --> 00:08:07.588 align:middle line:-2
URLSession为用于
执行网络请求的app

00:08:07.654 --> 00:08:09.089 align:middle line:-1
提供了一个高级API

00:08:10.424 --> 00:08:12.459 align:middle line:-1
弯曲对象 如表示飞行请求的

00:08:12.526 --> 00:08:14.561 align:middle line:-1
URLSession数据任务

00:08:15.896 --> 00:08:17.264 align:middle line:-1
然而在幕后还有另一个较低级别的

00:08:17.497 --> 00:08:20.701 align:middle line:-1
API URLProtocol

00:08:21.368 --> 00:08:24.571 align:middle line:-1
它来执行打开网络连接 编写请求

00:08:24.738 --> 00:08:27.674 align:middle line:-1
和读取响应的底层工作

00:08:29.810 --> 00:08:32.145 align:middle line:-2
URLProtocol
被设计为子类

00:08:32.546 --> 00:08:35.849 align:middle line:-1
为URL加载系统提供了一个扩展点

00:08:39.253 --> 00:08:42.589 align:middle line:-2
Foundation为诸如
HTTPS这样的公共协议

00:08:42.789 --> 00:08:44.725 align:middle line:-1
提供内置协议子类

00:08:45.592 --> 00:08:49.229 align:middle line:-1
但是我们可以在测试中覆盖这些内容

00:08:50.063 --> 00:08:51.932 align:middle line:-1
方法是提供一个模拟协议

00:08:51.999 --> 00:08:55.636 align:middle line:-2
允许我们对即将发出的请求进行断言
并提供模拟响应

00:08:59.673 --> 00:09:02.509 align:middle line:-2
URLProtocol通过
URLProtocol客户端实例

00:08:59.673 --> 00:09:02.509 align:middle line:-2
URLProtocol通过
URLProtocol客户端实例

00:09:02.676 --> 00:09:05.279 align:middle line:-1
将进程通信回系统

00:09:08.015 --> 00:09:09.850 align:middle line:-1
我们可以用这个方法

00:09:10.984 --> 00:09:13.987 align:middle line:-2
我们在测试包中创建一个
MockURLProtocol类

00:09:14.821 --> 00:09:18.458 align:middle line:-1
重写canInit请求

00:09:18.525 --> 00:09:21.295 align:middle line:-2
以向系统表明
我们对它提供的任何请求感兴趣

00:09:23.864 --> 00:09:26.099 align:middle line:-2
实现canonicalRequest
用于请求

00:09:26.567 --> 00:09:29.970 align:middle line:-2
但startLoading和StopLoading
方法用于大多数操作发生的地方

00:09:34.808 --> 00:09:37.611 align:middle line:-2
为了给我们的测试提供一种连接到
这个URLProtocol的方法

00:09:38.078 --> 00:09:41.949 align:middle line:-2
我们将提供一个闭包属性
requestHandler来设置测试

00:09:44.885 --> 00:09:47.120 align:middle line:-2
当一个URLSession
任务开始时

00:09:47.187 --> 00:09:50.224 align:middle line:-2
系统将实例化我们的
URLProtocol子类

00:09:50.591 --> 00:09:55.395 align:middle line:-2
为它提供URLRequest值和
URLProtocol客户端实例

00:09:57.264 --> 00:09:59.132 align:middle line:-2
然后它将调用
startLoading方法

00:09:59.733 --> 00:10:02.703 align:middle line:-2
在该方法中我们将使用测试设置的
requestHandler

00:09:59.733 --> 00:10:02.703 align:middle line:-2
在该方法中我们将使用测试设置的
requestHandler

00:10:03.437 --> 00:10:05.906 align:middle line:-2
并在参数处使用
URLRequest调用它

00:10:07.574 --> 00:10:10.344 align:middle line:-2
我们将获取它返回的内容
并将其作为URL响应

00:10:10.978 --> 00:10:13.547 align:middle line:-1
和数据传递回系统

00:10:14.748 --> 00:10:15.782 align:middle line:-1
或作为一个错误传递回系统

00:10:18.619 --> 00:10:20.787 align:middle line:-1
如果你想要取消测试请求

00:10:20.854 --> 00:10:24.591 align:middle line:-2
我们可以在停止加载方法实现中
执行类似的操作

00:10:28.862 --> 00:10:31.832 align:middle line:-1
有了存根协议我们就可以编写测试了

00:10:33.400 --> 00:10:36.336 align:middle line:-2
我们创建一个
APIRequestLoader实例

00:10:36.637 --> 00:10:40.340 align:middle line:-1
用一个请求类型和一个配置为使用

00:10:40.407 --> 00:10:42.776 align:middle line:-2
我们的URLProtocol的
URLSession来配置它

00:10:46.313 --> 00:10:50.851 align:middle line:-2
在测试体中我们在MockURLProtocol上
设置了一个requestHandler

00:10:51.752 --> 00:10:54.621 align:middle line:-1
对将要发出的请求作出断言

00:10:55.889 --> 00:10:57.524 align:middle line:-1
然后提供一个存根响应

00:10:59.826 --> 00:11:01.862 align:middle line:-2
然后我们可以调用
loadAPIRequest

00:10:59.826 --> 00:11:01.862 align:middle line:-2
然后我们可以调用
loadAPIRequest

00:11:03.030 --> 00:11:04.898 align:middle line:-1
等待调用完成块

00:11:06.166 --> 00:11:08.368 align:middle line:-1
并对解析响应作出断言

00:11:11.038 --> 00:11:14.575 align:middle line:-2
在这一层上的几个测试可以给
我们很大的信心

00:11:14.641 --> 00:11:16.410 align:middle line:-2
使我们相信我们的代码
能够很好地协同工作

00:11:16.476 --> 00:11:19.179 align:middle line:-1
而且我们正在与系统进行适当的集成

00:11:19.780 --> 00:11:23.083 align:middle line:-2
例如如果我忘记在我的数据任务中
调用简历的话

00:11:23.150 --> 00:11:25.953 align:middle line:-1
那么我们刚才看到的测试就会失败

00:11:26.553 --> 00:11:28.655 align:middle line:-1
我相信我不是唯一犯过这个错误的人

00:11:33.360 --> 00:11:35.529 align:middle line:-1
最后包含一些系统级的

00:11:35.596 --> 00:11:38.699 align:middle line:-1
端到端测试也是非常有价值的

00:11:39.766 --> 00:11:42.769 align:middle line:-2
实际上测试
UI测试是一个很好的工具

00:11:44.471 --> 00:11:46.173 align:middle line:-1
要了解更多关于UI测试的信息

00:11:46.240 --> 00:11:50.711 align:middle line:-2
请参考2015年WWDC的
“Xcode中的UI测试”演讲

00:11:53.981 --> 00:11:56.917 align:middle line:-2
现在当你开始编写真正的
端到端测试时

00:11:56.984 --> 00:11:59.620 align:middle line:-2
你遇到的一个重大挑战是
当发生问题时

00:12:00.120 --> 00:12:02.456 align:middle line:-1
当你遇到测试失败时

00:12:02.523 --> 00:12:04.925 align:middle line:-1
很难知道从哪里开始

00:12:04.992 --> 00:12:06.193 align:middle line:-1
寻找问题的根源

00:12:07.928 --> 00:12:10.731 align:middle line:-2
我们最近在测试中
帮助缓解这种情况的一件事是

00:12:11.298 --> 00:12:13.867 align:middle line:-1
设置一个模拟服务器的本地实例

00:12:14.301 --> 00:12:18.639 align:middle line:-2
中断我们的UI测试来对其发出请求
而不是对真正的服务器进行请求

00:12:19.706 --> 00:12:22.309 align:middle line:-1
这使得我们的UI测试更加可靠

00:12:22.376 --> 00:12:25.512 align:middle line:-2
因为我们可以控制
反馈到app中的数据

00:12:28.649 --> 00:12:31.785 align:middle line:-2
虽然在这个上下文中
使用模拟服务器是非常有用的

00:12:32.186 --> 00:12:35.989 align:middle line:-2
但是让一些测试针对真正的
服务器发出请求也是很好的

00:12:38.926 --> 00:12:40.561 align:middle line:-1
其一种很酷的技术就是

00:12:40.627 --> 00:12:43.230 align:middle line:-1
可以在单元测试包中进行一些测试

00:12:43.497 --> 00:12:46.233 align:middle line:-2
直接调用
在Stack中工作的app

00:12:47.000 --> 00:12:49.770 align:middle line:-2
并使用这些测试
将请求指向真正的服务器

00:12:51.071 --> 00:12:54.908 align:middle line:-2
这提供了一种验证服务器
接受请求的方式

00:12:54.975 --> 00:12:56.643 align:middle line:-1
是否与app的方式相同的方法

00:12:57.544 --> 00:12:59.847 align:middle line:-1
并且你可以解析服务器的响应

00:13:00.347 --> 00:13:02.516 align:middle line:-1
而不必同时处理

00:13:02.583 --> 00:13:04.618 align:middle line:-1
测试UI的复杂问题

00:13:10.357 --> 00:13:13.327 align:middle line:-1
因此最后我们看到了一个

00:13:13.393 --> 00:13:16.230 align:middle line:-1
将代码分解成更小独立的部分

00:13:16.296 --> 00:13:17.831 align:middle line:-1
以便单元测试的例子

00:13:19.566 --> 00:13:24.571 align:middle line:-2
我们已看到了如何使用URLProtocol
作为模拟网络请求的工具

00:13:26.340 --> 00:13:29.209 align:middle line:-2
我们还讨论了如何使用
金字塔的强大功能

00:13:29.276 --> 00:13:31.745 align:middle line:-2
来帮助我们构建
一个平衡良好的测试套件

00:13:31.812 --> 00:13:33.714 align:middle line:-1
这将使我们对我们的代码充满信心

00:13:35.449 --> 00:13:39.253 align:middle line:-2
现在我想把Stuart叫到台上
来谈谈更多的技术

00:13:43.190 --> 00:13:44.124 align:middle line:-1
谢谢

00:13:46.560 --> 00:13:47.494 align:middle line:-1
谢谢 Brian

00:13:48.195 --> 00:13:50.430 align:middle line:-1
那么我想要讨论的第一个领域是

00:13:50.497 --> 00:13:53.000 align:middle line:-1
测试通知的一些最佳实践方法

00:13:54.735 --> 00:13:57.471 align:middle line:-1
澄清一下 这里的通知

00:13:57.538 --> 00:14:00.107 align:middle line:-2
我说的是基础级别的通知
即NSNotification

00:13:57.538 --> 00:14:00.107 align:middle line:-2
我说的是基础级别的通知
即NSNotification

00:14:00.174 --> 00:14:02.576 align:middle line:-1
和Objective-C

00:14:03.377 --> 00:14:07.114 align:middle line:-2
是的 有时我们需要测试
一个主题是否观察到一个通知

00:14:07.281 --> 00:14:10.617 align:middle line:-2
而另一些时候我们需要测试
一个主题是否发布了一个通知

00:14:11.451 --> 00:14:14.588 align:middle line:-1
通知是一种一对多的通信机制

00:14:14.788 --> 00:14:17.824 align:middle line:-1
这意味着在发布单个通知时

00:14:17.891 --> 00:14:20.694 align:middle line:-2
它可能会通过
你的app发送给多个收件人

00:14:20.928 --> 00:14:24.131 align:middle line:-2
甚至是你的app进程运行的
框架代码中

00:14:24.198 --> 00:14:28.001 align:middle line:-1
因此正因为这一点 我们必须始终

00:14:28.068 --> 00:14:33.540 align:middle line:-2
以独立的方式测试通知
以避免意外的副作用

00:14:33.607 --> 00:14:37.044 align:middle line:-1
因为这可能导致不稳定不可靠的测试

00:14:37.578 --> 00:14:40.280 align:middle line:-2
让我们看一个
有这个问题的代码的例子

00:14:41.348 --> 00:14:43.750 align:middle line:-2
在这里有 Brian和我
正在构建的app

00:14:43.817 --> 00:14:45.552 align:middle line:-2
的PointsOfInterest
TableViewController

00:14:46.119 --> 00:14:49.590 align:middle line:-1
表视图中显示了附近有趣地点的列表

00:14:49.723 --> 00:14:52.526 align:middle line:-1
每当app的位置授权发生变化时

00:14:52.593 --> 00:14:54.228 align:middle line:-1
它可能需要重新加载数据

00:14:54.695 --> 00:14:57.464 align:middle line:-2
因此它从app的
CurrentLocationProvider类中

00:14:57.531 --> 00:15:00.167 align:middle line:-2
观察到一个名为
AuthChanged的通知

00:14:57.531 --> 00:15:00.167 align:middle line:-2
观察到一个名为
AuthChanged的通知

00:15:00.767 --> 00:15:04.338 align:middle line:-1
当它观察到这个通知时

00:15:04.404 --> 00:15:07.608 align:middle line:-2
它会在必要时重新加载它的数据
为了这个例子 它设置一个标志

00:15:08.275 --> 00:15:11.478 align:middle line:-1
这样我们的测试代码就可以检查标志

00:15:11.545 --> 00:15:13.614 align:middle line:-1
看看是否实际收到了通知

00:15:14.548 --> 00:15:17.451 align:middle line:-1
这里我们可以看到它正在使用

00:15:17.518 --> 00:15:18.752 align:middle line:-1
默认的通知中心来添加观察者

00:15:19.853 --> 00:15:22.623 align:middle line:-2
让我们来看看
这个代码的单元测试可能是什么样子

00:15:23.857 --> 00:15:25.759 align:middle line:-1
在这个类的测试中

00:15:25.826 --> 00:15:29.229 align:middle line:-2
我们发布了AuthChanged
方法通知来模拟它

00:15:29.296 --> 00:15:31.532 align:middle line:-2
并将它发布到默认的
NotificationCenter

00:15:31.598 --> 00:15:33.367 align:middle line:-1
与我们的视图控制器使用相同

00:15:34.034 --> 00:15:37.437 align:middle line:-1
现在这个测试起作用了

00:15:37.504 --> 00:15:38.906 align:middle line:-2
但它可能在app代码的
其他地方有未知的副作用

00:15:39.439 --> 00:15:41.608 align:middle line:-2
一些系统通知很常见
比如UI app

00:15:41.675 --> 00:15:45.345 align:middle line:-2
appDidFinish
Launchingnotification

00:15:45.412 --> 00:15:48.549 align:middle line:-1
被许多层观察到并且有未知的副作用

00:15:48.849 --> 00:15:51.218 align:middle line:-1
或者它只会减慢我们的测试速度

00:15:51.585 --> 00:15:54.788 align:middle line:-2
因此我们想
更好地隔离这些代码来测试它

00:15:56.790 --> 00:15:59.760 align:middle line:-2
我们可以使用一种技术
来更好地隔离这些测试

00:16:00.294 --> 00:16:01.962 align:middle line:-1
要使用它我们首先必须认识到

00:16:02.029 --> 00:16:04.831 align:middle line:-2
NotificationCenter
可以有多个实例

00:16:05.465 --> 00:16:10.137 align:middle line:-2
你可能会注意到
它有一个作为类属性的默认实例

00:16:10.204 --> 00:16:13.340 align:middle line:-1
但它支持在必要时创建其他实例

00:16:13.407 --> 00:16:15.709 align:middle line:-1
这将是隔离我们测试的关键

00:16:16.443 --> 00:16:20.647 align:middle line:-2
因此要应用这种技术我们首先
必须创建一个新的NotificationCenter

00:16:20.848 --> 00:16:24.618 align:middle line:-2
将它传递给我们的主题并使用它
而不是使用默认的实例

00:16:25.519 --> 00:16:27.754 align:middle line:-1
这通常被称为依赖注入

00:16:28.488 --> 00:16:30.824 align:middle line:-2
我们来看看
如何在视图控制器中使用它

00:16:31.892 --> 00:16:35.662 align:middle line:-2
在这里我有使用默认
NotificationCenter的原始代码

00:16:35.863 --> 00:16:38.198 align:middle line:-1
我将它修改为使用一个单独的实例

00:16:39.433 --> 00:16:41.768 align:middle line:-2
我添加了一个新的
NotificationCenter属性

00:16:41.969 --> 00:16:44.104 align:middle line:-2
并在设置它的初始化器中
添加了一个参数

00:16:44.738 --> 00:16:47.708 align:middle line:-1
它使用这个新属性

00:16:48.108 --> 00:16:49.643 align:middle line:-1
而不是向默认中心添加一个观察者

00:16:51.879 --> 00:16:56.183 align:middle line:-2
我还将向初始化器添加默认的
默认参数值

00:16:56.250 --> 00:16:59.253 align:middle line:-2
这样可以避免在我的app中
破坏任何现有代码

00:16:59.319 --> 00:17:02.189 align:middle line:-2
因为现有的客户端不需要通过
新的参数

00:16:59.319 --> 00:17:02.189 align:middle line:-2
因为现有的客户端不需要通过
新的参数

00:17:02.256 --> 00:17:03.757 align:middle line:-1
只有我们的单元测试会需要

00:17:05.925 --> 00:17:07.828 align:middle line:-1
现在让我们回去并更新我们的测试

00:17:08.862 --> 00:17:10.396 align:middle line:-1
这是最初的测试代码

00:17:11.031 --> 00:17:14.434 align:middle line:-2
我已修改它以使用单独的
NotificationCenter

00:17:18.105 --> 00:17:21.608 align:middle line:-2
这显示了如何测试
我们的主题是否观察到了通知

00:17:21.675 --> 00:17:24.578 align:middle line:-2
但是如何测试
我们的主题是否发布了通知呢？

00:17:25.479 --> 00:17:29.116 align:middle line:-2
我们将再次使用相同的
单独NotificationCenter技巧

00:17:29.183 --> 00:17:32.252 align:middle line:-2
但我还将展示如何使用
内置的预期API

00:17:32.319 --> 00:17:34.087 align:middle line:-1
来添加通知观察者

00:17:35.489 --> 00:17:37.691 align:middle line:-1
这是我们app的另一部分代码

00:17:37.958 --> 00:17:39.893 align:middle line:-1
CurrentLocationProvider类

00:17:40.527 --> 00:17:44.431 align:middle line:-2
稍后我将详细讨论这个类
但是请注意

00:17:44.498 --> 00:17:46.700 align:middle line:-2
它有向我app中其他类
发送消息的方法

00:17:46.767 --> 00:17:50.771 align:middle line:-2
即该app的位置授权
已经通过发布通知进行更改

00:17:51.939 --> 00:17:53.273 align:middle line:-1
和我们的视图控制器一样

00:17:53.340 --> 00:17:56.276 align:middle line:-2
它目前正硬编码默认的
NotificationCenter

00:17:58.545 --> 00:18:00.881 align:middle line:-1
这是我为这个类写的单元测试

00:17:58.545 --> 00:18:00.881 align:middle line:-1
这是我为这个类写的单元测试

00:18:01.014 --> 00:18:03.050 align:middle line:-1
它用来验证

00:18:03.116 --> 00:18:05.652 align:middle line:-2
在调用NotifyAuthChanged
方法时是否发布通知

00:18:06.887 --> 00:18:10.824 align:middle line:-2
我们可以在这里的中间部分看到
这个测试使用addObserver方法

00:18:10.891 --> 00:18:12.726 align:middle line:-1
创建一个基于块的观察者

00:18:12.926 --> 00:18:15.095 align:middle line:-1
然后它移除块内的观察者

00:18:16.063 --> 00:18:18.031 align:middle line:-1
现在我可以对这个测试做一个改进

00:18:18.098 --> 00:18:19.399 align:middle line:-1
就是使用内置的

00:18:19.466 --> 00:18:22.402 align:middle line:-2
XCTNSNotificationExpectation
API

00:18:22.469 --> 00:18:26.373 align:middle line:-2
来为我们创建这个
NotificationCenter观察者

00:18:27.574 --> 00:18:28.876 align:middle line:-1
这是一个很好的改进

00:18:29.142 --> 00:18:31.612 align:middle line:-1
它允许我们删除几行代码

00:18:32.713 --> 00:18:34.515 align:middle line:-1
但它仍然有我们之前看到的问题

00:18:34.581 --> 00:18:37.417 align:middle line:-2
即隐式使用默认
NotificationCenter

00:18:37.484 --> 00:18:38.652 align:middle line:-1
我们来解决这个问题

00:18:40.120 --> 00:18:41.388 align:middle line:-1
这是我们的原始代码

00:18:42.556 --> 00:18:44.525 align:middle line:-1
我将应用前面看到的相同的技术

00:18:44.591 --> 00:18:47.728 align:middle line:-2
在初始化器中使用一个单独的
NotificationCenter

00:18:47.928 --> 00:18:50.664 align:middle line:-1
存储它并使用它而不是默认值

00:18:53.734 --> 00:18:55.369 align:middle line:-2
现在回到我们的测试代码
我将修改它

00:18:56.203 --> 00:18:59.339 align:middle line:-2
将一个新的NotificationCenter
传递给我们的主题

00:19:00.240 --> 00:19:02.342 align:middle line:-1
但是现在我们来看一下期望

00:19:03.310 --> 00:19:07.381 align:middle line:-2
当我们的测试期望接收到
一个特定中心的通知时

00:19:07.614 --> 00:19:10.083 align:middle line:-2
我们可以将
NotificationCenter参数

00:19:10.150 --> 00:19:11.852 align:middle line:-1
传递给预期的初始化器

00:19:13.720 --> 00:19:18.759 align:middle line:-1
我还想指出这个期望的超时值是0

00:19:18.926 --> 00:19:21.628 align:middle line:-1
这是因为我们实际上期望

00:19:21.695 --> 00:19:22.996 align:middle line:-1
它在我们等待它时已实现

00:19:23.830 --> 00:19:26.466 align:middle line:-2
这是因为在
NotifyAuthChanged方法返回时

00:19:26.533 --> 00:19:29.369 align:middle line:-1
方法返回时通知应该已经发布了

00:19:30.571 --> 00:19:33.740 align:middle line:-1
因此使用这对技术来测试通知

00:19:34.107 --> 00:19:36.443 align:middle line:-2
我们可以确保我们的测试
保持完全隔离

00:19:36.977 --> 00:19:40.814 align:middle line:-2
并且我们在不需要修改app中的
现有代码的情况下进行了更改

00:19:40.948 --> 00:19:43.383 align:middle line:-1
因为我们指定了默认的参数值

00:19:47.921 --> 00:19:50.190 align:middle line:-1
接下来我想谈谈在编写单元

00:19:50.257 --> 00:19:53.827 align:middle line:-2
测试时经常遇到的一个挑战
即与外部类交互

00:19:55.896 --> 00:19:59.166 align:middle line:-2
在开发app时
你可能会遇到这样的情况

00:19:59.233 --> 00:20:01.869 align:middle line:-1
你的类正在与其他类对话

00:19:59.233 --> 00:20:01.869 align:middle line:-1
你的类正在与其他类对话

00:20:01.935 --> 00:20:05.239 align:middle line:-2
无论是在app的其他地方
或者还是由SDK提供的

00:20:05.639 --> 00:20:07.941 align:middle line:-1
你发现编写测试很困难

00:20:08.008 --> 00:20:12.179 align:middle line:-1
因为创建外部类很难甚至是不可能的

00:20:12.846 --> 00:20:15.249 align:middle line:-1
这种情况经常发生 特别是

00:20:15.315 --> 00:20:17.417 align:middle line:-1
对于那些没有被直接创建的API中

00:20:17.751 --> 00:20:21.822 align:middle line:-2
而且当这些API具有需要测试的
委托方法时就更加困难了

00:20:22.890 --> 00:20:25.826 align:middle line:-1
我想展示如何通过模拟

00:20:25.959 --> 00:20:28.762 align:middle line:-2
与外部类的交互来使用协议
进而解决这个问题

00:20:28.929 --> 00:20:31.899 align:middle line:-1
而且这样做并不会降低测试的可靠性

00:20:34.134 --> 00:20:37.437 align:middle line:-2
在我们的app中
我们有一个使用CoreLocation的

00:20:37.504 --> 00:20:38.939 align:middle line:-1
CurrentLocationProvider类

00:20:39.806 --> 00:20:41.708 align:middle line:-2
它创建一个
CLLocationManager

00:20:41.842 --> 00:20:43.610 align:middle line:-1
并在它的初始化器中配置它

00:20:43.944 --> 00:20:47.614 align:middle line:-2
设置它想要的精度属性
并将自己设置为委托

00:20:50.017 --> 00:20:51.351 align:middle line:-1
这是这门类的重点

00:20:51.518 --> 00:20:53.654 align:middle line:-2
它是一个名为
checkCurrentLocation的方法

00:20:54.154 --> 00:20:56.857 align:middle line:-1
它请求当前位置并获取一个完成块

00:20:56.924 --> 00:20:59.693 align:middle line:-1
该块返回该位置是否为感兴趣的点

00:21:00.894 --> 00:21:03.197 align:middle line:-1
请注意我们在这里调用

00:21:03.263 --> 00:21:05.032 align:middle line:-2
CLLocationManager
上的请求位置方法

00:21:05.899 --> 00:21:09.069 align:middle line:-2
当我们调用它时
它将尝试获取当前位置

00:21:09.303 --> 00:21:11.738 align:middle line:-1
并最终调用类上的委托方法

00:21:12.172 --> 00:21:13.841 align:middle line:-1
那么 让我们来看看委托方法

00:21:15.309 --> 00:21:19.680 align:middle line:-2
我们使用一个扩展来遵循这里的
CLLocationManagerDelegate协议

00:21:19.813 --> 00:21:21.682 align:middle line:-1
我们并且调用一个存储完成块

00:21:22.449 --> 00:21:25.285 align:middle line:-2
好的
让我们为这个类写一个单元测试

00:21:26.753 --> 00:21:29.289 align:middle line:-2
这里是我尝试编写的一个
如果我们阅读它

00:21:29.489 --> 00:21:33.093 align:middle line:-2
我们可以看到它首先创建一个
CurrentLocationProvider

00:21:33.594 --> 00:21:37.197 align:middle line:-2
然后检查所需的精度
以及委托是否设置好

00:21:37.497 --> 00:21:38.532 align:middle line:-1
到现在为止还好

00:21:39.166 --> 00:21:40.734 align:middle line:-1
但事情就变得棘手了

00:21:41.301 --> 00:21:43.871 align:middle line:-2
我们想测试
checkCurrentLocation方法

00:21:44.137 --> 00:21:47.674 align:middle line:-2
因为这是我们的主要逻辑所在
但是我们有一个问题

00:21:48.175 --> 00:21:51.745 align:middle line:-1
我们无法知道何时调用请求位置方法

00:21:52.012 --> 00:21:55.983 align:middle line:-2
因为这是CLLocationManager上的
一个方法而非代码的一部分

00:21:57.551 --> 00:22:00.053 align:middle line:-2
我们在这个测试中
可能会遇到的另一个问题是

00:21:57.551 --> 00:22:00.053 align:middle line:-2
我们在这个测试中
可能会遇到的另一个问题是

00:22:00.287 --> 00:22:03.190 align:middle line:-2
CoreLocation
需要用户授权

00:22:03.724 --> 00:22:05.893 align:middle line:-1
如果之前没有授权

00:22:05.959 --> 00:22:07.494 align:middle line:-1
它会在设备上显示权限对话框

00:22:08.362 --> 00:22:10.931 align:middle line:-1
这导致我们的测试依赖于设备状态

00:22:10.998 --> 00:22:14.368 align:middle line:-2
并且使它们更难维护
最终更有可能失败

00:22:16.336 --> 00:22:18.572 align:middle line:-1
因此如果你在过去遇到过这个问题

00:22:18.639 --> 00:22:21.575 align:middle line:-1
你可能会考虑对外部类进行子类化

00:22:21.642 --> 00:22:24.444 align:middle line:-1
并重写你调用它的任何方法

00:22:24.845 --> 00:22:29.016 align:middle line:-2
例如我们可以在这里尝试子类
CLLocationManager

00:22:29.082 --> 00:22:31.385 align:middle line:-1
并重写RequestLocation方法

00:22:31.952 --> 00:22:34.688 align:middle line:-1
这在一开始可能行得通 但有风险

00:22:35.622 --> 00:22:38.525 align:middle line:-2
SDK中的一些类
不是被设计成子类的

00:22:38.592 --> 00:22:39.826 align:middle line:-1
它们的行为可能不同

00:22:40.694 --> 00:22:43.797 align:middle line:-2
另外我们仍然需要调用
超类的初始化程序

00:22:43.864 --> 00:22:45.465 align:middle line:-1
这不是我们可以重写的代码

00:22:46.266 --> 00:22:47.701 align:middle line:-1
但是主要的问题是

00:22:47.768 --> 00:22:51.905 align:middle line:-2
如果我修改代码来调用
CLLocationManager上的另一个方法

00:22:52.139 --> 00:22:54.174 align:middle line:-1
我也要必须记住

00:22:54.241 --> 00:22:56.243 align:middle line:-1
在我的测试子类上重写该方法

00:22:57.044 --> 00:23:00.013 align:middle line:-1
如果我依赖子类 编译器不会通知我

00:22:57.044 --> 00:23:00.013 align:middle line:-1
如果我依赖子类 编译器不会通知我

00:23:00.080 --> 00:23:02.482 align:middle line:-1
我已经开始调用另一个方法

00:23:02.549 --> 00:23:04.685 align:middle line:-1
这很容易忘记和破坏我的测试

00:23:05.552 --> 00:23:07.321 align:middle line:-1
因此我不推荐这种方法

00:23:07.387 --> 00:23:11.225 align:middle line:-1
而我推荐使用协议模拟外部类型

00:23:11.291 --> 00:23:12.960 align:middle line:-1
我们来看看怎么做

00:23:14.494 --> 00:23:16.129 align:middle line:-1
这是原始代码

00:23:16.330 --> 00:23:19.032 align:middle line:-1
第一步是定义一个新协议

00:23:20.300 --> 00:23:22.703 align:middle line:-2
我已经命名了新协议
LocationFetcher

00:23:22.936 --> 00:23:25.405 align:middle line:-2
它包含了我的代码
从CLLocationManager中

00:23:25.472 --> 00:23:28.075 align:middle line:-1
使用的方法和属性的确切集合

00:23:28.976 --> 00:23:32.012 align:middle line:-1
成员名称和类型完全匹配

00:23:32.079 --> 00:23:35.883 align:middle line:-2
这允许我在
CLLocationManager上

00:23:35.949 --> 00:23:37.384 align:middle line:-1
创建一个符合协议的空扩展

00:23:37.451 --> 00:23:39.286 align:middle line:-1
因为它已经满足了所有要求

00:23:41.321 --> 00:23:44.858 align:middle line:-2
然后我将LocationManager属性
重命名为LocationFetcher

00:23:45.092 --> 00:23:47.794 align:middle line:-2
并将其类型更改为
LocationFetcher协议

00:23:49.663 --> 00:23:52.599 align:middle line:-2
我还将向初始化器添加一个
默认参数值

00:23:52.666 --> 00:23:56.170 align:middle line:-2
就像我之前所做的那样
以避免破坏任何现有的app代码

00:23:58.438 --> 00:24:01.708 align:middle line:-2
我需要对checkCurrentLocation
方法做一个小的更改

00:23:58.438 --> 00:24:01.708 align:middle line:-2
我需要对checkCurrentLocation
方法做一个小的更改

00:24:02.009 --> 00:24:03.544 align:middle line:-1
以使用重命名的属性

00:24:05.445 --> 00:24:07.548 align:middle line:-1
最后让我们看一下委托方法

00:24:08.182 --> 00:24:09.850 align:middle line:-1
这个部分处理起来有点棘手

00:24:09.917 --> 00:24:12.786 align:middle line:-1
因为委托期望Manager参数

00:24:12.853 --> 00:24:16.623 align:middle line:-2
是真正的CLLocationManager
而不是我的新协议

00:24:17.558 --> 00:24:20.627 align:middle line:-2
因此当委托参与时
事情会变得有点复杂

00:24:20.694 --> 00:24:22.930 align:middle line:-1
但是我们仍然可以在这里应用协议

00:24:23.130 --> 00:24:24.431 align:middle line:-1
让我们来看看

00:24:26.400 --> 00:24:29.770 align:middle line:-2
我将回到前面定义的
LocationFetcher协议

00:24:30.337 --> 00:24:34.141 align:middle line:-2
并将该委托属性重命名为
LocationFetcherDelegate

00:24:34.641 --> 00:24:36.677 align:middle line:-1
我将其类型更改为一个新协议

00:24:36.743 --> 00:24:40.514 align:middle line:-2
该协议的接口与
CLLocationManagerDelegate几乎相同

00:24:40.848 --> 00:24:42.516 align:middle line:-1
但是我调整了方法名

00:24:42.583 --> 00:24:45.719 align:middle line:-2
我将第一个参数的类型改为
LocationFetcher

00:24:49.356 --> 00:24:52.125 align:middle line:-1
现在我需要在扩展中实现

00:24:52.192 --> 00:24:56.063 align:middle line:-2
LocationFetcherDelegate属性
因为它不再满足这个要求

00:24:56.997 --> 00:24:59.867 align:middle line:-2
我将实现getter
和setter来使用强制转换

00:24:59.933 --> 00:25:03.070 align:middle line:-2
来回转换到
CLLocationManagerDelegate

00:24:59.933 --> 00:25:03.070 align:middle line:-2
来回转换到
CLLocationManagerDelegate

00:25:03.570 --> 00:25:06.240 align:middle line:-2
稍后我会解释为什么
我在这里使用强制转换

00:25:08.242 --> 00:25:09.810 align:middle line:-1
然后在我的类的初始化器中

00:25:09.877 --> 00:25:12.913 align:middle line:-2
我需要用locationFetcher
Delegate替换委托属性

00:25:14.915 --> 00:25:17.818 align:middle line:-1
最后一步是修改原来的扩展

00:25:17.885 --> 00:25:21.655 align:middle line:-2
以符合新的模拟委托协议
这部分很容易

00:25:21.722 --> 00:25:25.726 align:middle line:-1
我需要做的就是替换协议和方法签名

00:25:26.560 --> 00:25:28.629 align:middle line:-1
但是 我实际上仍然需要遵守旧的

00:25:28.695 --> 00:25:31.965 align:middle line:-2
CLLocationManagerDelegate
协议

00:25:32.499 --> 00:25:34.601 align:middle line:-2
这是因为真正的
CLLocationManager

00:25:34.668 --> 00:25:37.004 align:middle line:-1
不知道我的模拟委托协议

00:25:38.272 --> 00:25:40.841 align:middle line:-2
因此这里的诀窍是
将符合实际委托协议的

00:25:40.908 --> 00:25:43.076 align:middle line:-1
扩展添加回来

00:25:43.143 --> 00:25:46.580 align:middle line:-2
但让它调用上面等效的
locationFetcher委托方法

00:25:47.981 --> 00:25:50.284 align:middle line:-1
前面我提到我在委托

00:25:50.350 --> 00:25:51.885 align:middle line:-2
getter和setter中
使用了强制转换

00:25:52.419 --> 00:25:55.455 align:middle line:-1
这是为了确保我的类符合这两种协议

00:25:55.522 --> 00:25:57.824 align:middle line:-1
我没有忘记其中的一种或另一种

00:26:01.562 --> 00:26:03.130 align:middle line:-1
因此在我的单元测试中

00:26:03.197 --> 00:26:06.733 align:middle line:-2
我将为模拟定义一个嵌套在
我的测试类中的struct

00:26:06.800 --> 00:26:08.969 align:middle line:-2
它符合
locationFetcher协议

00:26:09.036 --> 00:26:10.537 align:middle line:-1
并满足其要求

00:26:11.505 --> 00:26:13.407 align:middle line:-1
注意在它的requestLocation方法中

00:26:13.473 --> 00:26:17.611 align:middle line:-2
它调用一个块来获取一个假的位置
我可以在测试中自定义它

00:26:18.245 --> 00:26:21.682 align:middle line:-2
然它后调用委托方法
将那个假位置传递给它

00:26:24.585 --> 00:26:27.254 align:middle line:-2
现在我有了我所需要的一切
我可以写我的测试

00:26:27.988 --> 00:26:30.057 align:middle line:-2
我创建一个
MockLocationFetcher结构

00:26:30.123 --> 00:26:32.593 align:middle line:-2
并配置它的
handleRequestLocation块

00:26:32.659 --> 00:26:34.161 align:middle line:-1
以提供假位置

00:26:35.262 --> 00:26:39.600 align:middle line:-2
然后我创建CurrentLocationProvider
并将MockLocationFetcher传递给它

00:26:40.167 --> 00:26:43.637 align:middle line:-2
最后我用一个完成块调用
checkCurrentLocation

00:26:44.238 --> 00:26:45.606 align:middle line:-1
在完成块中有一个断言

00:26:45.672 --> 00:26:47.441 align:middle line:-1
用于检查位置

00:26:47.508 --> 00:26:49.076 align:middle line:-1
是一个感兴趣的点

00:26:51.178 --> 00:26:52.012 align:middle line:-1
所以它很管用

00:26:52.079 --> 00:26:54.948 align:middle line:-2
我现在可以模拟我的类使用
CLLocationManager

00:26:55.015 --> 00:26:56.850 align:middle line:-2
而不需要创建一个真正的
CLLocationManager

00:26:58.185 --> 00:27:00.120 align:middle line:-1
因此在这里我展示了如何使用

00:26:58.185 --> 00:27:00.120 align:middle line:-1
因此在这里我展示了如何使用

00:27:00.187 --> 00:27:03.690 align:middle line:-1
协议来模拟与外部类及其委托的交互

00:27:04.224 --> 00:27:06.760 align:middle line:-2
这是很多步骤
让我们回顾一下我们所做的

00:27:08.862 --> 00:27:10.764 align:middle line:-1
首先我们定义了一个新的协议

00:27:10.831 --> 00:27:13.600 align:middle line:-1
表示外部类的接口

00:27:14.301 --> 00:27:17.171 align:middle line:-2
该协议需要包含
我们在外部类上使用的

00:27:17.237 --> 00:27:19.339 align:middle line:-1
所有方法和属性

00:27:19.540 --> 00:27:22.409 align:middle line:-1
并且通常它们的声明可以完全匹配

00:27:23.777 --> 00:27:27.147 align:middle line:-2
接下来我们在原始的
外部类上创建了一个扩展

00:27:27.214 --> 00:27:29.082 align:middle line:-1
它声明符合协议

00:27:30.450 --> 00:27:32.953 align:middle line:-1
然后我们用我们的新协议替换了

00:27:33.020 --> 00:27:34.321 align:middle line:-1
外部类的所有用法

00:27:34.755 --> 00:27:36.523 align:middle line:-1
并添加了一个初始化器参数

00:27:36.590 --> 00:27:38.959 align:middle line:-1
以便在测试中设置该类型

00:27:41.028 --> 00:27:43.830 align:middle line:-1
我们还讨论了如何模拟委托协议

00:27:43.897 --> 00:27:45.933 align:middle line:-1
这是SDK中常见的模式

00:27:46.934 --> 00:27:48.669 align:middle line:-1
这里还有一些步骤

00:27:48.735 --> 00:27:49.837 align:middle line:-1
但这里是我们所做的

00:27:51.004 --> 00:27:55.008 align:middle line:-1
首先我们定义了一个模拟委托协议

00:27:55.075 --> 00:27:56.643 align:middle line:-2
其方法签名
与我们正模拟的协议相似

00:27:57.077 --> 00:28:00.747 align:middle line:-2
但是我们用模拟协议类型
代替了真正的类型

00:27:57.077 --> 00:28:00.747 align:middle line:-2
但是我们用模拟协议类型
代替了真正的类型

00:28:02.015 --> 00:28:05.719 align:middle line:-2
然后在我们最初的模拟协议中
我们重新命名了委托属性

00:28:05.953 --> 00:28:08.488 align:middle line:-1
并在扩展中实现了该重命名属性

00:28:09.857 --> 00:28:12.960 align:middle line:-2
因此虽然这种方法
可能需要更多的代码

00:28:13.026 --> 00:28:15.062 align:middle line:-1
而不是子类之类的替代方法

00:28:15.596 --> 00:28:17.731 align:middle line:-1
,它会更可靠 更不可能打破

00:28:17.798 --> 00:28:19.600 align:middle line:-1
我扩大我的代码

00:28:20.200 --> 00:28:22.069 align:middle line:-2
因为这样编译器将强制执行
我为代码调用的任何新方法

00:28:22.135 --> 00:28:27.207 align:middle line:-1
必须包括在这些新协议中

00:28:31.778 --> 00:28:35.716 align:middle line:-1
最后我想谈谈测试执行速度

00:28:38.118 --> 00:28:40.120 align:middle line:-1
当你的测试需要很长时间运行时

00:28:40.387 --> 00:28:42.422 align:middle line:-1
你就不太可能在开发期间运行它们

00:28:42.689 --> 00:28:45.292 align:middle line:-2
或者你可能会尝试跳过
运行时间最长的测试

00:28:46.159 --> 00:28:48.595 align:middle line:-2
我们的测试套件
会帮助我们及早发现问题

00:28:48.662 --> 00:28:50.497 align:middle line:-1
而修复回归是最容易的

00:28:50.731 --> 00:28:53.767 align:middle line:-2
因此我们希望确保我们的测试
总是尽可能快地运行

00:28:54.935 --> 00:28:56.770 align:middle line:-1
现在你可能在过去遇到过一些

00:28:56.837 --> 00:28:59.806 align:middle line:-1
需要在测试中人工等待或休眠的情况

00:28:59.873 --> 00:29:03.443 align:middle line:-2
因为你的测试是异步的
或者使用了计时器

00:28:59.873 --> 00:29:03.443 align:middle line:-2
因为你的测试是异步的
或者使用了计时器

00:29:04.378 --> 00:29:05.812 align:middle line:-1
延迟操作是很棘手的

00:29:05.879 --> 00:29:07.948 align:middle line:-2
我们希望确保
在我们的测试中包含它们

00:29:08.182 --> 00:29:11.118 align:middle line:-2
但是如果我们不小心的话
它们也会使事情变慢很多

00:29:11.818 --> 00:29:13.220 align:middle line:-1
因此我想谈谈一些

00:29:13.287 --> 00:29:15.722 align:middle line:-2
我们可以避免
在我们的测试中人为延迟的方法

00:29:15.789 --> 00:29:17.357 align:middle line:-1
因为它们永远都是不必要的

00:29:19.059 --> 00:29:20.194 align:middle line:-1
下面是一个例子

00:29:20.594 --> 00:29:22.930 align:middle line:-2
在Brian和我正在构建的
兴趣点app上

00:29:23.297 --> 00:29:25.432 align:middle line:-1
在主UI上 我们在底部有一个条带

00:29:25.499 --> 00:29:27.134 align:middle line:-1
它显示了特色的地方

00:29:27.534 --> 00:29:29.903 align:middle line:-1
它基本上是绕着附近的顶部旋转

00:29:30.237 --> 00:29:32.873 align:middle line:-1
每隔十秒钟就会显示一个新的位置

00:29:33.507 --> 00:29:36.343 align:middle line:-1
现在有几种方法可以实现这个功能

00:29:36.410 --> 00:29:38.812 align:middle line:-2
但是这里我使用的是
foundation中的timer API

00:29:40.948 --> 00:29:43.317 align:middle line:-2
让我们看一下我可能
为这个类编写的单元测试

00:29:44.051 --> 00:29:46.119 align:middle line:-2
它创建一个
FeaturedPlaceManager

00:29:46.520 --> 00:29:50.858 align:middle line:-2
并在调用scheduleNextPlace方法之前
存储它的当前位置

00:29:51.491 --> 00:29:54.127 align:middle line:-1
然后运行循环11秒

00:29:54.361 --> 00:29:56.496 align:middle line:-1
我加了一秒钟作为宽限期

00:29:57.397 --> 00:30:00.234 align:middle line:-2
最后它检查当前位置
在最后发生了变化

00:29:57.397 --> 00:30:00.234 align:middle line:-2
最后它检查当前位置
在最后发生了变化

00:30:01.001 --> 00:30:04.137 align:middle line:-2
现在这不是很好
它需要很长时间才能运行

00:30:04.972 --> 00:30:08.208 align:middle line:-2
为了缓解这一问题
我们可以在代码中公开一个属性

00:30:08.275 --> 00:30:12.246 align:middle line:-2
以允许我们将超时定制为更短的时间
比如一秒

00:30:12.946 --> 00:30:16.216 align:middle line:-1
这就是代码改变的样子

00:30:20.754 --> 00:30:24.691 align:middle line:-2
现在使用这种方法
我们可以将测试延迟减少到1秒

00:30:25.359 --> 00:30:27.794 align:middle line:-1
这个方法比以前的好

00:30:27.861 --> 00:30:31.932 align:middle line:-2
我们的测试肯定会运行得更快
但仍然不理想

00:30:32.366 --> 00:30:35.002 align:middle line:-1
我们的代码还有延迟只是时间更短

00:30:35.669 --> 00:30:39.506 align:middle line:-2
真正的问题是
我们正在测试的代码仍然依赖于时间

00:30:39.773 --> 00:30:43.110 align:middle line:-2
这意味着
当我们使预期的延迟越来越短

00:30:43.177 --> 00:30:45.212 align:middle line:-1
我们的测试可能变得不那么可靠

00:30:45.345 --> 00:30:48.582 align:middle line:-2
因为它们将更依赖于CPU
来预测事情的进度

00:30:48.715 --> 00:30:51.919 align:middle line:-2
这并不总是正确的
尤其是对于异步代码

00:30:52.786 --> 00:30:54.755 align:middle line:-1
那么让我们来看看一个更好的方法

00:30:56.557 --> 00:30:59.793 align:middle line:-1
我建议首先确定延迟机制

00:31:00.127 --> 00:31:01.962 align:middle line:-1
在我的示例中它是一个定时器

00:31:02.029 --> 00:31:05.832 align:middle line:-2
但你也可以使用DispatchQueue
的asyncAfter API

00:31:06.867 --> 00:31:09.136 align:middle line:-1
我们想要模拟这个机制

00:31:09.203 --> 00:31:12.806 align:middle line:-2
以便我们能够
立即调用延迟的操作并绕过延迟

00:31:16.043 --> 00:31:17.544 align:middle line:-1
这里是我们的原始代码

00:31:17.845 --> 00:31:21.481 align:middle line:-2
让我们从这个scheduledTimer方法的
实际功能开始

00:31:22.516 --> 00:31:25.786 align:middle line:-2
ScheduledTimer
方法实际上为我们做了两件事

00:31:26.253 --> 00:31:30.224 align:middle line:-2
它创建一个计时器 然后将
该计时器添加到当前运行循环中

00:31:31.158 --> 00:31:34.394 align:middle line:-2
现在这个API
可以非常方便地创建计时器

00:31:34.628 --> 00:31:36.530 align:middle line:-1
但是如果我将这两个步骤分开

00:31:36.597 --> 00:31:38.699 align:middle line:-1
它将帮助我们使代码更可测试

00:31:40.601 --> 00:31:44.137 align:middle line:-1
在这里 我将前面的代码从使用

00:31:44.238 --> 00:31:48.442 align:middle line:-2
scheduledTimer转换为先创建计时器
后将其添加到当前的runLoop秒中

00:31:48.509 --> 00:31:50.210 align:middle line:-1
我已经将其存储在一个新属性中

00:31:51.545 --> 00:31:54.014 align:middle line:-1
现在这段代码相当于我们以前的代码

00:31:54.214 --> 00:31:56.183 align:middle line:-1
但是一旦我们将这两个步骤分开

00:31:56.650 --> 00:31:59.520 align:middle line:-1
我们就可以看到runLoop

00:31:59.586 --> 00:32:00.854 align:middle line:-1
只是这个类与之交互的另一个外部类

00:31:59.586 --> 00:32:00.854 align:middle line:-1
只是这个类与之交互的另一个外部类

00:32:01.355 --> 00:32:02.589 align:middle line:-1
因此我们可以应用

00:32:02.656 --> 00:32:05.292 align:middle line:-2
我们前面讨论过的
带有协议的模拟技术

00:32:06.126 --> 00:32:10.464 align:middle line:-2
为此我们将创建一个小协议
其中包含这个addTimer方法

00:32:12.099 --> 00:32:14.401 align:middle line:-2
我调用了该新协议
TimerScheduler

00:32:14.601 --> 00:32:17.104 align:middle line:-1
它只有一个addTimer方法

00:32:17.271 --> 00:32:20.040 align:middle line:-2
它与runLoop API
的签名相匹配

00:32:22.242 --> 00:32:25.012 align:middle line:-1
现在回到我的代码中

00:32:25.078 --> 00:32:27.014 align:middle line:-2
我需用刚刚创建的协议
替换runLoop

00:32:29.683 --> 00:32:33.520 align:middle line:-2
在我的测试中我不想使用真正的
runLoop作为我的TimerScheduler

00:32:33.820 --> 00:32:38.125 align:middle line:-2
相反我想创建一个模拟调度器
它将计时器传递给我的测试

00:32:39.660 --> 00:32:43.096 align:middle line:-1
为此 我将创建一个嵌套在

00:32:43.163 --> 00:32:46.967 align:middle line:-2
我的单元测试类MockTimerScheduler中的新结构
它符合TimerScheduler协议

00:32:47.935 --> 00:32:51.471 align:middle line:-2
它存储一个块 每当被告知要
添加计时器时 该块就会被调用

00:32:53.907 --> 00:32:56.977 align:middle line:-2
有了所有的片段
我就可以写我的最后单元测试了

00:32:57.811 --> 00:33:02.683 align:middle line:-2
首先我创建一个MockTimerScheduler
并配置它的handleAddTimer块

00:32:57.811 --> 00:33:02.683 align:middle line:-2
首先我创建一个MockTimerScheduler
并配置它的handleAddTimer块

00:33:03.450 --> 00:33:04.785 align:middle line:-1
这个块接收计时器

00:33:04.852 --> 00:33:08.589 align:middle line:-2
一旦它被添加到调度程序中
它将记录计时器的延迟

00:33:08.789 --> 00:33:13.627 align:middle line:-2
然后通过触发计时器来绕过延迟
来调用块

00:33:14.995 --> 00:33:18.832 align:middle line:-2
然后我们创建一个FeaturedPlaceManager
并为它提供MockTimerScheduler

00:33:19.933 --> 00:33:22.936 align:middle line:-2
最后 我们调用scheduleNextPlace
开始测试

00:33:23.837 --> 00:33:26.540 align:middle line:-1
好啊 我们的测试不再有任何延迟

00:33:27.040 --> 00:33:29.810 align:middle line:-1
它们执行得非常快而且不依赖于时间

00:33:29.877 --> 00:33:31.345 align:middle line:-1
所以它会更可靠

00:33:32.179 --> 00:33:36.016 align:middle line:-2
作为奖励
我现在可以使用底部的这个断言

00:33:36.083 --> 00:33:37.751 align:middle line:-1
来验证计时器延迟的数量

00:33:38.051 --> 00:33:40.587 align:middle line:-1
这不是我在之前的测试中所能做

00:33:42.890 --> 00:33:47.194 align:middle line:-2
所以就像我说的
我们代码的延迟已经完全消除了

00:33:48.028 --> 00:33:51.331 align:middle line:-2
我们认为这是测试涉及
延迟操作代码的一种很好的方法

00:33:51.765 --> 00:33:54.735 align:middle line:-1
但是对于测试中最快的总体执行速度

00:33:54.935 --> 00:33:57.571 align:middle line:-1
最好是直接构建大部分测试

00:33:57.638 --> 00:34:00.741 align:middle line:-1
而根本不需要模拟延迟操作

00:33:57.638 --> 00:34:00.741 align:middle line:-1
而根本不需要模拟延迟操作

00:34:01.975 --> 00:34:03.510 align:middle line:-1
例如 在我们的app中

00:34:03.677 --> 00:34:07.347 align:middle line:-2
被延迟的动作
正在更改到下一个功能位置

00:34:07.781 --> 00:34:12.886 align:middle line:-2
我可能只需要一两次测试
就可以证明计时器延迟正常工作

00:34:13.219 --> 00:34:14.388 align:middle line:-1
对于其余的类

00:34:14.454 --> 00:34:17.056 align:middle line:-2
我可以直接调用
ShowNextPlace方法

00:34:17.123 --> 00:34:19.560 align:middle line:-1
根本不需要模拟一个计时器调度程序

00:34:22.563 --> 00:34:24.864 align:middle line:-1
在我们讨论测试执行速度这一主题时

00:34:24.931 --> 00:34:26.632 align:middle line:-1
我们还有一些其他的技巧要分享

00:34:27.701 --> 00:34:31.271 align:middle line:-2
我们已经看到的一个领域是
NSPredicateExpections的使用

00:34:31.839 --> 00:34:34.341 align:middle line:-1
我们指出的是这些类

00:34:34.408 --> 00:34:36.143 align:middle line:-1
几乎不像其他预期类那样具有性能

00:34:36.342 --> 00:34:39.880 align:middle line:-2
因为它们依赖于轮询机制
而不是更直接的回调机制

00:34:40.547 --> 00:34:42.449 align:middle line:-1
它们主要用于UI测试

00:34:42.516 --> 00:34:46.053 align:middle line:-1
其中评估的条件发生在另一个进程中

00:34:46.386 --> 00:34:49.556 align:middle line:-2
因此在单元测试中
我们建议使用更直接的机制

00:34:49.623 --> 00:34:55.495 align:middle line:-2
例如常规的XCTestExec
NSNotification或KVOExec

00:34:58.031 --> 00:34:59.600 align:middle line:-1
另一个测试速度提示是

00:34:59.666 --> 00:35:02.469 align:middle line:-1
确保你的app尽快启动

00:34:59.666 --> 00:35:02.469 align:middle line:-1
确保你的app尽快启动

00:35:03.337 --> 00:35:06.540 align:middle line:-2
现在大多数app都必须
在启动时做一些设置工作

00:35:06.840 --> 00:35:09.877 align:middle line:-2
尽管这种工作
对于常规app的启动是必要的

00:35:10.310 --> 00:35:12.913 align:middle line:-2
但当你的app作为
测试运行程序启动时

00:35:12.980 --> 00:35:14.648 align:middle line:-1
很多工作可能是不必要的

00:35:15.249 --> 00:35:19.152 align:middle line:-1
例如加载视图控制器 启动网络请求

00:35:19.219 --> 00:35:21.588 align:middle line:-1
或配置分析包

00:35:21.655 --> 00:35:24.091 align:middle line:-1
这些都是单元测试场景中

00:35:24.157 --> 00:35:25.692 align:middle line:-1
通常不必要的东西

00:35:27.094 --> 00:35:30.898 align:middle line:-1
XCTest在开始运行测试之前

00:35:30.964 --> 00:35:32.699 align:middle line:-1
等待app委托完成启动方法返回

00:35:33.133 --> 00:35:35.302 align:middle line:-2
因此若你分析并注意到
app启动在测试中

00:35:35.369 --> 00:35:37.371 align:middle line:-1
花费了很长时间

00:35:38.071 --> 00:35:41.008 align:middle line:-2
一个技巧就是检测你的app
何时作为测试运行程序启动

00:35:41.074 --> 00:35:42.176 align:middle line:-1
并避免这项工作

00:35:44.111 --> 00:35:49.016 align:middle line:-2
一种方法是指定自定义环境变量
或启动参数

00:35:49.850 --> 00:35:53.353 align:middle line:-2
打开方案编辑器
转到左侧的测试操作

00:35:53.620 --> 00:35:55.155 align:middle line:-1
然后到参数选项卡

00:35:55.355 --> 00:35:58.559 align:middle line:-2
然后添加一个环境变量
或一个启动参数

00:35:59.259 --> 00:36:01.862 align:middle line:-2
在这个屏幕截图中
我添加了一个环境变量

00:35:59.259 --> 00:36:01.862 align:middle line:-2
在这个屏幕截图中
我添加了一个环境变量

00:36:01.929 --> 00:36:04.264 align:middle line:-2
名为IS-UNIT-TESTING
设置为1

00:36:06.400 --> 00:36:09.770 align:middle line:-2
然后 修改app委托的
appDidFinishLaunching代码

00:36:09.837 --> 00:36:12.639 align:middle line:-1
使用类似于此的代码检查此条件

00:36:13.540 --> 00:36:16.343 align:middle line:-1
现在 如果你这样做

00:36:16.410 --> 00:36:19.213 align:middle line:-2
请确保你跳过的代码
对于单元测试的功能来说并不重要

00:36:22.916 --> 00:36:28.989 align:middle line:-2
最后总结一下Brian开始时候
提醒我们测试金字塔

00:36:29.423 --> 00:36:31.792 align:middle line:-2
以及如何在app中
有一个均衡的测试策略

00:36:32.292 --> 00:36:35.896 align:middle line:-1
展示几种测试网络操作的实用技术

00:36:36.897 --> 00:36:40.167 align:middle line:-1
然后我讨论了隔离基础通知

00:36:40.734 --> 00:36:42.269 align:middle line:-1
并使用依赖项注入

00:36:43.437 --> 00:36:46.039 align:middle line:-1
我们为编写测试时最常见的挑战之一

00:36:46.106 --> 00:36:49.343 align:middle line:-2
即与外部类交互
提供了一个解决方案

00:36:49.877 --> 00:36:51.245 align:middle line:-1
即使它们有一个委托

00:36:52.312 --> 00:36:54.982 align:middle line:-1
我们还分享了一些保持测试快速运行

00:36:55.048 --> 00:36:56.850 align:middle line:-1
和避免人为延迟的技巧

00:36:57.784 --> 00:36:59.486 align:middle line:-1
我们真的希望你觉得这些测试有用

00:36:59.553 --> 00:37:02.089 align:middle line:-2
并在下次编写测试时
寻找应用它们的方法

00:36:59.553 --> 00:37:02.089 align:middle line:-2
并在下次编写测试时
寻找应用它们的方法

00:37:04.625 --> 00:37:07.628 align:middle line:-2
要了解更多信息
请查看这个链接上的演讲网页

00:37:07.895 --> 00:37:08.962 align:middle line:-1
如果你错过了

00:37:09.029 --> 00:37:12.733 align:middle line:-2
我们希望你能看看
周三“视频测试新特性”演讲

00:37:13.700 --> 00:37:16.003 align:middle line:-2
非常感谢
希望你们度过一个很棒的WWDC
