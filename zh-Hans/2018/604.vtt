WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:21.516 --> 00:00:27.776 A:middle
[ 掌声 ]

00:00:28.276 --> 00:00:28.666 A:middle
&gt;&gt; 谢谢

00:00:29.326 --> 00:00:30.746 A:middle
我叫 Dan Omachi

00:00:30.746 --> 00:00:32.946 A:middle
我是 Apple Metal Ecosystem 团队的工程师

00:00:33.606 --> 00:00:35.536 A:middle
现在我在团队内的主要工作是

00:00:35.536 --> 00:00:37.136 A:middle
帮助开发者们学习 Metal

00:00:37.136 --> 00:00:38.766 A:middle
以及获得很好的使用体验

00:00:39.476 --> 00:00:41.326 A:middle
但是在这之前很多年

00:00:41.326 --> 00:00:43.456 A:middle
我都致力于 Apple 的 OpenGL 和

00:00:43.636 --> 00:00:44.686 A:middle
OpenGL ES 框架

00:00:45.086 --> 00:00:46.716 A:middle
在我加入 Apple 以前

00:00:46.716 --> 00:00:47.746 A:middle
我曾参与实现其他几个

00:00:47.746 --> 00:00:48.936 A:middle
OpenGL 应用

00:00:50.926 --> 00:00:53.286 A:middle
所以我非常骄傲

00:00:53.446 --> 00:00:55.576 A:middle
我过去几年在

00:00:55.736 --> 00:00:57.866 A:middle
OpenGL 上的成就

00:00:57.866 --> 00:00:59.976 A:middle
但是对于 Metal 带领我们的方向

00:00:59.976 --> 00:01:02.166 A:middle
我也非常激动

00:00:59.976 --> 00:01:02.166 A:middle
我也非常激动

00:01:02.936 --> 00:01:04.726 A:middle
今天我和我的同事

00:01:04.726 --> 00:01:05.906 A:middle
Sukanya Sudugu

00:01:05.906 --> 00:01:07.556 A:middle
将会向你们简略地

00:01:07.556 --> 00:01:10.066 A:middle
介绍 Metal 同时对于

00:01:10.456 --> 00:01:12.526 A:middle
如何轻松地移植你们的 OpenGL App

00:01:12.526 --> 00:01:15.156 A:middle
提供一些建议

00:01:15.386 --> 00:01:16.906 A:middle
今年尤其的重要

00:01:16.906 --> 00:01:19.016 A:middle
因为 就像昨天

00:01:19.016 --> 00:01:20.876 A:middle
在 union OpenGL 上说的

00:01:20.876 --> 00:01:23.466 A:middle
OpenGL ES 和 OpenCL

00:01:23.676 --> 00:01:25.366 A:middle
是不被允许的

00:01:26.336 --> 00:01:28.206 A:middle
现在和即将发布的

00:01:28.206 --> 00:01:30.346 A:middle
App 仍可在 tvOS 和 iOS 12 上使用

00:01:30.716 --> 00:01:35.006 A:middle
OpenGL ES 以及在 macOS 10.14 Mojave 上

00:01:35.636 --> 00:01:40.706 A:middle
使用 OpenGL and OpenCL

00:01:40.706 --> 00:01:44.626 A:middle
而且这将持续一段时间

00:01:45.476 --> 00:01:48.286 A:middle
但是 新项目应该

00:01:48.286 --> 00:01:50.486 A:middle
从开始就面向 Metal

00:01:51.026 --> 00:01:51.886 A:middle
所以如果你还不熟悉 Metal

00:01:51.886 --> 00:01:54.156 A:middle
那么 你应该开始熟悉一下它

00:01:55.806 --> 00:01:56.886 A:middle
在你把所有 OpenGL 代码都销毁

00:01:56.886 --> 00:01:58.416 A:middle
并开始把所有东西 都转移到 Metal 之前

00:01:58.416 --> 00:01:59.526 A:middle
你还有几个选择

00:01:59.526 --> 00:02:00.446 A:middle
可以考虑

00:01:59.526 --> 00:02:00.446 A:middle
可以考虑

00:02:01.376 --> 00:02:03.156 A:middle
Apple 提供了很多高层面

00:02:03.226 --> 00:02:04.906 A:middle
的渲染框架

00:02:05.466 --> 00:02:06.446 A:middle
不同种类的渲染

00:02:06.836 --> 00:02:08.846 A:middle
适用于 2D 游戏的 SpriteKit

00:02:08.846 --> 00:02:10.756 A:middle
适用于 3D 游戏的 SceneKit

00:02:10.756 --> 00:02:11.966 A:middle
能有很棒效果的 Core Image

00:02:13.526 --> 00:02:15.456 A:middle
另外 每个主要的

00:02:15.566 --> 00:02:17.366 A:middle
第三方游戏引擎已经

00:02:17.366 --> 00:02:19.596 A:middle
使用 Metal 作为他们的主要渲染器

00:02:20.776 --> 00:02:22.886 A:middle
但你或许会认为

00:02:22.886 --> 00:02:24.426 A:middle
这些方法不适合你

00:02:24.756 --> 00:02:25.866 A:middle
你也可以

00:02:25.866 --> 00:02:28.086 A:middle
自己在 Metal 里实现这些

00:02:28.086 --> 00:02:30.416 A:middle
这就是我们今天要讨论的东西

00:02:30.566 --> 00:02:31.746 A:middle
所以我们从 Metal 的设计

00:02:31.746 --> 00:02:33.966 A:middle
和一些基本概念说起

00:02:35.536 --> 00:02:37.246 A:middle
OpenGL 最开始

00:02:37.246 --> 00:02:39.326 A:middle
是 25 年前开发的

00:02:39.366 --> 00:02:41.286 A:middle
它的核心是反映了

00:02:41.286 --> 00:02:43.226 A:middle
3D 图像的硬件加速

00:02:44.696 --> 00:02:46.676 A:middle
所以新版本的更新

00:02:46.676 --> 00:02:48.266 A:middle
和拓展确实为我们

00:02:48.266 --> 00:02:49.766 A:middle
探索新的 GPU 特性和

00:02:49.836 --> 00:02:51.666 A:middle
性能技术提供了服务

00:02:52.806 --> 00:02:54.436 A:middle
但是 仍旧有一些

00:02:54.436 --> 00:02:56.276 A:middle
基础设计决策

00:02:56.276 --> 00:02:58.396 A:middle
不再适用于现在的硬件设备

00:03:00.856 --> 00:03:02.326 A:middle
OpenGL 管道你曾是

00:03:02.326 --> 00:03:03.826 A:middle
完全固定的功能

00:03:03.826 --> 00:03:07.526 A:middle
虽然现在 OpenGL 提供可编程的管道

00:03:07.526 --> 00:03:12.826 A:middle
但是它并不完全匹配当代 GPU

00:03:13.036 --> 00:03:15.356 A:middle
另外 异步处理不再是

00:03:15.356 --> 00:03:16.726 A:middle
API 的核心特性

00:03:17.476 --> 00:03:18.436 A:middle
还有很多其他功能

00:03:18.436 --> 00:03:19.576 A:middle
暗示 GPU 会与

00:03:19.576 --> 00:03:20.656 A:middle
你的 App 同时工作

00:03:20.656 --> 00:03:22.586 A:middle
但大多数都是隐式的

00:03:23.046 --> 00:03:27.766 A:middle
25 年前 只有最贵的工作站

00:03:27.766 --> 00:03:29.186 A:middle
和服务器是多核的

00:03:29.676 --> 00:03:30.956 A:middle
所以 设计一个高效的

00:03:30.956 --> 00:03:33.216 A:middle
多线模型 不是最优选择

00:03:33.216 --> 00:03:37.516 A:middle
所以在 2014 年的时候很明显

00:03:37.516 --> 00:03:39.116 A:middle
设计新的 GPU

00:03:39.116 --> 00:03:40.836 A:middle
App 接口是必要的

00:03:41.696 --> 00:03:42.856 A:middle
很明显我们需要

00:03:42.856 --> 00:03:45.406 A:middle
一个可以高效利用 GPU 能力的接口

00:03:46.576 --> 00:03:48.076 A:middle
要做到这一点

00:03:48.076 --> 00:03:49.826 A:middle
App 需要 CPU 让道

00:03:49.826 --> 00:03:51.946 A:middle
才能让 GPU 可以做他的事情

00:03:52.146 --> 00:03:53.836 A:middle
但是当 App 需要 CPU 做渲染时

00:03:53.836 --> 00:03:54.976 A:middle
它又可以

00:03:54.976 --> 00:03:56.466 A:middle
调用所有的 CPU

00:03:56.906 --> 00:03:58.176 A:middle
包括它的多核

00:03:59.626 --> 00:04:01.146 A:middle
如果接口需要预测

00:03:59.626 --> 00:04:01.146 A:middle
如果接口需要预测

00:04:01.146 --> 00:04:04.056 A:middle
去避免开发者陷入

00:04:04.136 --> 00:04:08.586 A:middle
API 的隐藏陷阱

00:04:08.586 --> 00:04:09.926 A:middle
那么每一个调用需要有明显的结果

00:04:09.926 --> 00:04:12.146 A:middle
并且最好不要有

00:04:12.206 --> 00:04:13.846 A:middle
隐式的操作

00:04:14.336 --> 00:04:16.476 A:middle
这种预测的一部分

00:04:16.576 --> 00:04:17.805 A:middle
需要去控制

00:04:17.805 --> 00:04:19.916 A:middle
资源分布和

00:04:19.956 --> 00:04:22.376 A:middle
什么时候需要同步

00:04:27.896 --> 00:04:29.456 A:middle
我们想要这个接口

00:04:29.456 --> 00:04:31.416 A:middle
是可触及的

00:04:31.416 --> 00:04:32.536 A:middle
它需要正确的

00:04:32.536 --> 00:04:34.306 A:middle
平衡低层次控制和明确的用量

00:04:34.306 --> 00:04:36.436 A:middle
因为当你了解一个东西以后

00:04:36.436 --> 00:04:40.566 A:middle
你能更高效和有效的使用它

00:04:41.976 --> 00:04:43.766 A:middle
当然 我们设计 Metal

00:04:43.766 --> 00:04:46.516 A:middle
是为了更好地映射到各种当代 GPU 上

00:04:46.516 --> 00:04:49.486 A:middle
特别是我们知道

00:04:49.486 --> 00:04:50.446 A:middle
管道中的硬件

00:04:50.496 --> 00:04:53.216 A:middle
需要软件去推动它

00:04:53.906 --> 00:04:55.556 A:middle
这就包括了 Apple 设计的

00:04:55.696 --> 00:04:58.486 A:middle
所有 A11 仿生 GPU

00:04:59.956 --> 00:05:01.736 A:middle
所以为什么 Metal 不同于 OpenGL

00:04:59.956 --> 00:05:01.736 A:middle
所以为什么 Metal 不同于 OpenGL

00:05:02.196 --> 00:05:03.556 A:middle
你会更少地去进行

00:05:03.626 --> 00:05:06.036 A:middle
昂贵的操作

00:05:07.046 --> 00:05:08.236 A:middle
对象的设计是这样的

00:05:08.236 --> 00:05:09.916 A:middle
API 的状态可以被转换

00:05:09.916 --> 00:05:12.226 A:middle
并且在创建时被预包装进

00:05:12.226 --> 00:05:13.926 A:middle
GPU 命令

00:05:15.726 --> 00:05:17.406 A:middle
这样做会在真正渲染时

00:05:17.406 --> 00:05:19.266 A:middle
最大程度减少成本

00:05:20.576 --> 00:05:21.656 A:middle
拥有 Vertex 和片段着色器的

00:05:21.686 --> 00:05:23.286 A:middle
图形管道也

00:05:23.286 --> 00:05:24.756 A:middle
反映了当代 GPU

00:05:25.716 --> 00:05:27.396 A:middle
所以这会降低

00:05:27.516 --> 00:05:29.986 A:middle
将 API 设置转换到 GP 命令的成本

00:05:31.236 --> 00:05:32.926 A:middle
这并不表示

00:05:32.926 --> 00:05:34.296 A:middle
管道是截然不同的

00:05:34.296 --> 00:05:36.026 A:middle
或者说需要一个全新的方式去考虑

00:05:36.946 --> 00:05:38.256 A:middle
Metal 最大的区别是

00:05:38.256 --> 00:05:39.406 A:middle
将管道的各个阶段

00:05:39.436 --> 00:05:41.686 A:middle
分组成对象

00:05:41.686 --> 00:05:43.326 A:middle
是更高效的

00:05:43.326 --> 00:05:45.396 A:middle
并不是管道本身改变了

00:05:46.816 --> 00:05:49.366 A:middle
Metal 为了执行多线程

00:05:49.366 --> 00:05:50.616 A:middle
还有一个清晰的模型

00:05:51.496 --> 00:05:52.356 A:middle
有很多种不同的方法

00:05:52.356 --> 00:05:53.976 A:middle
让 App 在不同线程上

00:05:53.976 --> 00:05:55.796 A:middle
去驱动 GPU

00:05:56.286 --> 00:05:57.906 A:middle
但是对于每一个

00:05:57.996 --> 00:05:59.686 A:middle
都有明确但不受限的规则去实现它

00:06:01.036 --> 00:06:02.546 A:middle
此外最常用的对象

00:06:02.546 --> 00:06:05.936 A:middle
像纹理 缓冲和着色器 可以安全

00:06:05.936 --> 00:06:07.726 A:middle
并有效地在不同线程中使用

00:06:08.526 --> 00:06:10.156 A:middle
Metal 并不需要去实现

00:06:10.326 --> 00:06:11.776 A:middle
昂贵的内部日志操作

00:06:11.776 --> 00:06:13.306 A:middle
去防止这些

00:06:13.306 --> 00:06:14.546 A:middle
对象进入

00:06:14.546 --> 00:06:15.456 A:middle
无效状态

00:06:17.516 --> 00:06:21.036 A:middle
最后 它的执行模式反映了软件与 GPU 之间

00:06:21.076 --> 00:06:22.696 A:middle
真正发生的事

00:06:23.266 --> 00:06:24.926 A:middle
很多通过 OpenGL 展现

00:06:25.046 --> 00:06:26.406 A:middle
的隐性操作

00:06:26.406 --> 00:06:28.116 A:middle
通过 Metal 在 App 中

00:06:28.116 --> 00:06:29.886 A:middle
被明显地展示出来

00:06:30.636 --> 00:06:31.836 A:middle
这就让你可以对于什么时候

00:06:31.836 --> 00:06:33.666 A:middle
和怎样在 App 中使用 GPU

00:06:33.666 --> 00:06:35.966 A:middle
做出明智的决定

00:06:36.946 --> 00:06:37.966 A:middle
这还代表着

00:06:37.966 --> 00:06:39.036 A:middle
你的 App 和 GPU 之间将有

00:06:39.036 --> 00:06:40.586 A:middle
更少的软件

00:06:41.216 --> 00:06:43.286 A:middle
大多数的 Metal 调用直接

00:06:43.286 --> 00:06:45.096 A:middle
指向 GPU 驱动

00:06:45.096 --> 00:06:46.726 A:middle
这样驱动也需要做更少的处理

00:06:46.726 --> 00:06:49.526 A:middle
去将 API 调用转换为 GPU 命令

00:06:51.216 --> 00:06:52.216 A:middle
所以让我们来跟深入地看看

00:06:52.216 --> 00:06:52.636 A:middle
它是怎么工作的

00:06:53.256 --> 00:06:56.466 A:middle
所有的 GL 调用都在 OpenGL 中

00:06:56.466 --> 00:06:57.506 A:middle
展现出来

00:06:57.916 --> 00:06:59.846 A:middle
这个内容就包含了很多东西

00:06:59.846 --> 00:07:01.966 A:middle
它追踪 API 的状态

00:06:59.846 --> 00:07:01.966 A:middle
它追踪 API 的状态

00:07:02.166 --> 00:07:03.766 A:middle
它管理 OpenGL 对象和其它内存

00:07:03.766 --> 00:07:05.246 A:middle
同时还转换

00:07:05.246 --> 00:07:06.506 A:middle
并递交 GPU 命令

00:07:07.366 --> 00:07:09.066 A:middle
Metal 将所有这些

00:07:09.066 --> 00:07:10.626 A:middle
OpenGL 内容的工作分成

00:07:10.626 --> 00:07:12.956 A:middle
很多个小对象

00:07:14.056 --> 00:07:18.616 A:middle
第一个被创建的对象就是 Metal 设备

00:07:18.716 --> 00:07:20.626 A:middle
它是一个物理 GPU 的

00:07:20.776 --> 00:07:21.686 A:middle
抽象表现

00:07:22.256 --> 00:07:26.286 A:middle
这个设备创建对象

00:07:26.286 --> 00:07:27.646 A:middle
比如说纹理 缓冲

00:07:27.646 --> 00:07:29.906 A:middle
和包含着色器的管道对象

00:07:31.026 --> 00:07:32.886 A:middle
它还创建了一个关键对象

00:07:33.136 --> 00:07:34.636 A:middle
叫做 Metal 命令队列

00:07:35.196 --> 00:07:37.816 A:middle
这个命令队列只有一个工作

00:07:37.816 --> 00:07:39.796 A:middle
就是去创建

00:07:39.796 --> 00:07:41.176 A:middle
一系列的命令缓存

00:07:41.956 --> 00:07:43.506 A:middle
这里我们已经创建了一个命令缓存

00:07:43.506 --> 00:07:44.856 A:middle
并且这个命令缓存是

00:07:44.856 --> 00:07:46.706 A:middle
一系列 GPU 命令的简单列表

00:07:46.956 --> 00:07:48.956 A:middle
你的 App 将填写这个列表

00:07:48.956 --> 00:07:50.146 A:middle
并且发送给 GPU 去执行

00:07:51.166 --> 00:07:52.836 A:middle
通常你的 App 要在每一帧去创建一个

00:07:52.836 --> 00:07:54.926 A:middle
单独的命令缓存

00:07:55.016 --> 00:07:55.866 A:middle
但是有些情况下

00:07:55.866 --> 00:07:57.566 A:middle
它也会觉得需要

00:07:57.696 --> 00:08:00.886 A:middle
在一帧里创建两三个

00:07:57.696 --> 00:08:00.886 A:middle
在一帧里创建两三个

00:08:01.026 --> 00:08:02.256 A:middle
但是 App 本身并不会直接写这些

00:08:02.256 --> 00:08:03.606 A:middle
命令到命令缓存里

00:08:03.606 --> 00:08:05.216 A:middle
它是创建了一个

00:08:05.216 --> 00:08:06.586 A:middle
Metal 命令编码器

00:08:07.886 --> 00:08:09.356 A:middle
这个命令编码器将

00:08:09.446 --> 00:08:11.686 A:middle
API 调用转换成 GPU 指令

00:08:11.906 --> 00:08:13.266 A:middle
并将它们写入命令缓存

00:08:14.336 --> 00:08:15.666 A:middle
在一系列命令

00:08:15.666 --> 00:08:17.426 A:middle
被编码以后 App 就会

00:08:17.426 --> 00:08:19.336 A:middle
结束编码 并且释放编码对象

00:08:20.536 --> 00:08:22.756 A:middle
事实上有不同的编码器

00:08:22.756 --> 00:08:24.146 A:middle
你的 App 可以从命令缓存中

00:08:24.146 --> 00:08:25.876 A:middle
创建新的编码器 去编码更多的指令

00:08:31.156 --> 00:08:32.616 A:middle
特别注意一点是

00:08:32.616 --> 00:08:34.346 A:middle
直到现在在这流程上

00:08:34.346 --> 00:08:36.186 A:middle
GPU 还什么都没做

00:08:37.106 --> 00:08:40.726 A:middle
Metal 创建了对象和编码命令

00:08:40.775 --> 00:08:41.145 A:middle
都是基于 CPU 的

00:08:41.876 --> 00:08:43.166 A:middle
只有在你的 App

00:08:43.216 --> 00:08:45.356 A:middle
完成编码命令和

00:08:45.356 --> 00:08:46.356 A:middle
提交命令缓存以后

00:08:47.446 --> 00:08:49.226 A:middle
GPU 才会开始工作并

00:08:49.226 --> 00:08:51.376 A:middle
执行那些命令

00:08:52.576 --> 00:08:54.566 A:middle
你也可以将这些命令编译成

00:08:54.566 --> 00:08:56.226 A:middle
多个并行的命令缓存

00:08:56.266 --> 00:08:57.816 A:middle
到分开的线程上

00:08:58.466 --> 00:09:02.056 A:middle
现在我已经谈到了

00:08:58.466 --> 00:09:02.056 A:middle
现在我已经谈到了

00:09:02.056 --> 00:09:03.876 A:middle
命令队列是如何

00:09:03.876 --> 00:09:06.276 A:middle
产生一个命令缓存的序列

00:09:06.276 --> 00:09:07.606 A:middle
并且你能从命令缓存中

00:09:07.606 --> 00:09:09.286 A:middle
创建一个命令编译器

00:09:10.196 --> 00:09:11.216 A:middle
让我们更细致地看一看

00:09:11.216 --> 00:09:13.096 A:middle
这些用来写入命令缓存的

00:09:13.096 --> 00:09:14.466 A:middle
编码器对象

00:09:15.726 --> 00:09:17.036 A:middle
它们有三种主要类型

00:09:18.096 --> 00:09:18.986 A:middle
Render Command Encoder

00:09:18.986 --> 00:09:20.606 A:middle
它的命令类似于 OpenGL 命令字符串

00:09:20.606 --> 00:09:22.266 A:middle
对于这些命令你可以

00:09:22.356 --> 00:09:23.776 A:middle
设置状态

00:09:23.776 --> 00:09:25.316 A:middle
绑定对象和发出绘图申请

00:09:26.446 --> 00:09:27.736 A:middle
还有一个是 Blit Command Encoder

00:09:27.906 --> 00:09:29.306 A:middle
基于它你可以发出纹理

00:09:29.306 --> 00:09:31.246 A:middle
和缓存拷贝操作

00:09:31.576 --> 00:09:32.786 A:middle
你也可以用它来生成

00:09:32.786 --> 00:09:34.526 A:middle
用于纹理和从缓存中 转移

00:09:34.566 --> 00:09:36.156 A:middle
像素数据的 Mipmap 就类似于

00:09:36.156 --> 00:09:38.076 A:middle
glReadPixels 如何对 OpenGL 的

00:09:38.076 --> 00:09:40.266 A:middle
像素缓存对象操作的

00:09:40.806 --> 00:09:43.496 A:middle
最后是 Compute Command Encoder

00:09:43.756 --> 00:09:46.076 A:middle
它让你可以

00:09:46.076 --> 00:09:48.466 A:middle
分派内核

00:09:49.316 --> 00:09:50.826 A:middle
Render Command Encoder 可能将会是

00:09:50.826 --> 00:09:51.746 A:middle
你最熟悉的编码器

00:09:51.746 --> 00:09:54.346 A:middle
因为它负责

00:09:54.346 --> 00:09:56.206 A:middle
大部分基于图形的 App

00:09:56.206 --> 00:09:57.976 A:middle
需要的操作

00:09:59.306 --> 00:10:00.816 A:middle
这一组命令编译进

00:09:59.306 --> 00:10:00.816 A:middle
这一组命令编译进

00:10:00.816 --> 00:10:01.966 A:middle
Render Command Encoder

00:10:02.006 --> 00:10:03.836 A:middle
通常被称为 Render Pass

00:10:05.406 --> 00:10:06.576 A:middle
在 Render Pass 中你可以设置

00:10:06.576 --> 00:10:08.016 A:middle
为图形管道建立的渲染对象

00:10:08.016 --> 00:10:10.236 A:middle
和发出与这些对象一起的

00:10:10.676 --> 00:10:11.586 A:middle
绘图命令

00:10:12.226 --> 00:10:13.726 A:middle
这就包括了一些

00:10:13.726 --> 00:10:15.946 A:middle
类似于 glDrawArrays 和

00:10:15.946 --> 00:10:18.696 A:middle
glDrawElements 和其他一些

00:10:18.816 --> 00:10:19.566 A:middle
OpenGL 绘图命令

00:10:21.006 --> 00:10:22.416 A:middle
每个 Render Command Encoder 都

00:10:22.416 --> 00:10:24.156 A:middle
紧密地与一系列渲染对象

00:10:24.306 --> 00:10:25.126 A:middle
联系在一起

00:10:26.976 --> 00:10:28.806 A:middle
渲染目标就是一个

00:10:28.806 --> 00:10:30.306 A:middle
可以绘制的简单纹理

00:10:30.846 --> 00:10:32.636 A:middle
它包括了颜色 深度和

00:10:32.666 --> 00:10:34.166 A:middle
模板纹理以及

00:10:34.166 --> 00:10:35.356 A:middle
多样本纹理

00:10:36.436 --> 00:10:37.606 A:middle
你可以指定一系列渲染目标

00:10:37.606 --> 00:10:38.976 A:middle
在你从命令缓存中

00:10:38.976 --> 00:10:42.336 A:middle
创建渲染命令编码器的时候

00:10:42.516 --> 00:10:43.906 A:middle
所有绘图命令

00:10:43.906 --> 00:10:45.596 A:middle
都在编码器的寿命内

00:10:45.596 --> 00:10:47.036 A:middle
指向这些目标

00:10:48.506 --> 00:10:49.826 A:middle
如果想要导向 一个命令去新的对象

00:10:49.826 --> 00:10:51.396 A:middle
你可以通过当前的渲染命令编译器

00:10:51.396 --> 00:10:52.886 A:middle
结束编码过程

00:10:53.116 --> 00:10:55.536 A:middle
然后去和新的对象去

00:10:55.536 --> 00:10:56.256 A:middle
创建新的编译器

00:10:57.216 --> 00:10:58.836 A:middle
这就明确地

00:10:58.836 --> 00:11:01.076 A:middle
区分了导向

00:10:58.836 --> 00:11:01.076 A:middle
区分了导向

00:11:01.126 --> 00:11:03.506 A:middle
不同渲染对象的命令

00:11:04.186 --> 00:11:06.196 A:middle
我们再说一说

00:11:06.506 --> 00:11:08.256 A:middle
你们在渲染过程中要用到的对象

00:11:09.446 --> 00:11:10.476 A:middle
Metal 有很多类似于

00:11:10.476 --> 00:11:11.276 A:middle
OpenGL 的对象

00:11:11.276 --> 00:11:14.346 A:middle
包括纹理 缓存

00:11:15.136 --> 00:11:17.846 A:middle
采样器和管道状态对象

00:11:17.846 --> 00:11:19.666 A:middle
这些对象类似于 OpenGL 的

00:11:19.696 --> 00:11:22.086 A:middle
程序对象

00:11:22.206 --> 00:11:23.766 A:middle
还有深度模板状态对象

00:11:23.766 --> 00:11:24.966 A:middle
它们并不真的存在于 OpenGL 中

00:11:25.176 --> 00:11:26.706 A:middle
而只是 OpenGL 有的

00:11:26.706 --> 00:11:28.156 A:middle
有相同深度和

00:11:28.396 --> 00:11:29.346 A:middle
模板状态的容器

00:11:31.496 --> 00:11:32.996 A:middle
一个区别 OpenGL 和 Metal 对象

00:11:33.076 --> 00:11:35.556 A:middle
的重要不同是

00:11:35.906 --> 00:11:37.866 A:middle
它们怎么被创建的和管理的

00:11:39.176 --> 00:11:40.336 A:middle
这些对象都是通过

00:11:40.336 --> 00:11:41.756 A:middle
设备对象创建的

00:11:41.756 --> 00:11:43.426 A:middle
所以它们只与单个 GPU 相关联

00:11:44.716 --> 00:11:46.156 A:middle
你设置大部分对象状态

00:11:46.276 --> 00:11:48.316 A:middle
是你通过指定属性

00:11:48.646 --> 00:11:50.656 A:middle
在描述符对象中创建它的时候

00:11:51.936 --> 00:11:53.656 A:middle
所有状态都是在

00:11:53.656 --> 00:11:55.166 A:middle
对象被创建的时候设置的

00:11:55.166 --> 00:11:55.596 A:middle
这些状态是固定的 并且不可改变的

00:11:56.946 --> 00:11:58.306 A:middle
虽然这个纹理和缓存的状态

00:11:58.306 --> 00:11:59.856 A:middle
是在创建时就被固定的

00:11:59.856 --> 00:12:02.226 A:middle
但是这些对象包含的数据

00:11:59.856 --> 00:12:02.226 A:middle
但是这些对象包含的数据

00:12:02.226 --> 00:12:03.976 A:middle
是可以被改变的

00:12:04.626 --> 00:12:07.296 A:middle
Metal 可以为这些对象

00:12:07.446 --> 00:12:09.596 A:middle
创建新的编码器 当它被创建的时候

00:12:10.396 --> 00:12:12.146 A:middle
OpenGL 的可变模型

00:12:12.176 --> 00:12:13.766 A:middle
完全可能让

00:12:13.766 --> 00:12:15.186 A:middle
你的 App 在触碰到一小块状态的时候

00:12:15.186 --> 00:12:18.176 A:middle
这个对象会重新

00:12:18.176 --> 00:12:19.206 A:middle
开始编译

00:12:19.946 --> 00:12:21.256 A:middle
即便你的 App 没有

00:12:21.256 --> 00:12:23.846 A:middle
改变对象的状态

00:12:23.846 --> 00:12:25.176 A:middle
OpenGL 也会需要检查标记的层次结构

00:12:25.226 --> 00:12:27.326 A:middle
这样做是为了在绘图之前确认无误

00:12:28.186 --> 00:12:30.596 A:middle
所以通过这个不可改变的模型

00:12:30.596 --> 00:12:32.176 A:middle
Metal 永远不需要检查

00:12:32.176 --> 00:12:34.106 A:middle
对象状态的改变

00:12:34.106 --> 00:12:36.016 A:middle
这就使绘图调用快很多

00:12:37.556 --> 00:12:39.166 A:middle
另外 对象能在跨线程中

00:12:39.256 --> 00:12:41.106 A:middle
更高效的被利用

00:12:41.516 --> 00:12:42.756 A:middle
Metal 永远不用锁定一个对象

00:12:42.756 --> 00:12:43.746 A:middle
只是因为避免它

00:12:43.746 --> 00:12:44.996 A:middle
在转换到其他线程的时候

00:12:45.146 --> 00:12:45.956 A:middle
陷入无效状态

00:12:51.306 --> 00:12:52.826 A:middle
那么我们再来谈谈移植

00:12:52.826 --> 00:12:57.256 A:middle
这是一个典型的阶段

00:12:57.256 --> 00:12:59.286 A:middle
这些是一些经典的

00:12:59.286 --> 00:13:00.226 A:middle
渲染 App 的阶段

00:12:59.286 --> 00:13:00.226 A:middle
渲染 App 的阶段

00:13:01.046 --> 00:13:02.166 A:middle
你搭建一个 App 去编译资源

00:13:02.166 --> 00:13:03.746 A:middle
和捆绑资产

00:13:04.696 --> 00:13:05.926 A:middle
开始并初始化它

00:13:06.306 --> 00:13:07.796 A:middle
加载这些资产

00:13:07.796 --> 00:13:09.666 A:middle
初始化将会一直

00:13:09.666 --> 00:13:11.986 A:middle
出现在你 App 里的对象

00:13:13.236 --> 00:13:14.966 A:middle
然后你不断地重复

00:13:15.456 --> 00:13:16.976 A:middle
渲染设定状态

00:13:16.976 --> 00:13:19.336 A:middle
发布多个绘图需求

00:13:19.486 --> 00:13:19.986 A:middle
然后一帧一帧地展现

00:13:20.676 --> 00:13:23.816 A:middle
我将会谈谈

00:13:23.816 --> 00:13:25.686 A:middle
在早期阶段 App 中的

00:13:25.686 --> 00:13:26.796 A:middle
Metal 开发过程

00:13:28.316 --> 00:13:29.806 A:middle
包括着色器的离线创建

00:13:29.806 --> 00:13:32.136 A:middle
创建对象的初始化

00:13:33.256 --> 00:13:34.666 A:middle
之后 Sukanya 会解释如何

00:13:34.666 --> 00:13:36.656 A:middle
移植每一帧的渲染代码

00:13:38.676 --> 00:13:39.936 A:middle
所以让我们从

00:13:39.936 --> 00:13:41.706 A:middle
App 的创建时间开始

00:13:41.706 --> 00:13:43.736 A:middle
就是着色器被编译的时候

00:13:44.896 --> 00:13:47.006 A:middle
我们将从着色语言开始

00:13:47.866 --> 00:13:49.006 A:middle
Metal 的着色语言

00:13:49.126 --> 00:13:50.476 A:middle
是基于 C++ 的

00:13:50.936 --> 00:13:53.316 A:middle
所以就像你创建 C++ 的

00:13:53.386 --> 00:13:55.206 A:middle
类 模板 结构

00:13:55.606 --> 00:13:57.336 A:middle
定义 名称空间 一样

00:13:58.466 --> 00:14:00.156 A:middle
比如说 GLSL

00:13:58.466 --> 00:14:00.156 A:middle
比如说 GLSL

00:14:00.156 --> 00:14:02.796 A:middle
我们有内置的向量和矩阵类型

00:14:02.796 --> 00:14:04.176 A:middle
也有很多的内置方法和

00:14:04.176 --> 00:14:06.436 A:middle
图形处理常用的运算符

00:14:06.486 --> 00:14:09.236 A:middle
也有一些类

00:14:09.316 --> 00:14:11.006 A:middle
指定采样器的状态

00:14:11.006 --> 00:14:11.426 A:middle
并在纹理上执行

00:14:12.966 --> 00:14:13.986 A:middle
描述这个语言最好的方式

00:14:13.986 --> 00:14:15.166 A:middle
刚才已经展示给你们了

00:14:15.396 --> 00:14:17.846 A:middle
所以这是顶点和片段着色器对

00:14:19.336 --> 00:14:20.966 A:middle
顶部方法中的顶点关键字

00:14:20.966 --> 00:14:24.196 A:middle
说明了它是一个顶点着色器

00:14:24.196 --> 00:14:25.886 A:middle
同样适用于

00:14:25.886 --> 00:14:28.306 A:middle
底部方法的片段关键字

00:14:29.706 --> 00:14:31.366 A:middle
注意它们有自定义的名字

00:14:31.426 --> 00:14:33.226 A:middle
这一点不像 GLSL 一样每个着色器

00:14:33.266 --> 00:14:34.116 A:middle
就只是被叫做 main

00:14:34.756 --> 00:14:35.726 A:middle
这非常的关键 因为

00:14:35.726 --> 00:14:37.166 A:middle
它允许你去构建一个大型的库

00:14:37.166 --> 00:14:38.976 A:middle
库里的每一个着色器都用名字

00:14:39.206 --> 00:14:41.506 A:middle
去表明它们的功能

00:14:41.936 --> 00:14:44.446 A:middle
每一个从你的 App 传出的东西

00:14:44.446 --> 00:14:47.266 A:middle
都是这些其中一个着色器的参数

00:14:48.026 --> 00:14:49.316 A:middle
并且它不像 GLSL 一样

00:14:49.316 --> 00:14:50.486 A:middle
会在方法外有

00:14:50.486 --> 00:14:51.416 A:middle
松散变量

00:14:52.486 --> 00:14:53.786 A:middle
就像你看到的

00:14:53.846 --> 00:14:55.646 A:middle
这些参数旁边会有括号

00:14:56.226 --> 00:14:58.136 A:middle
它们是属性说明符

00:14:58.386 --> 00:14:59.946 A:middle
这是从 C++ 里拓展来的

00:14:59.946 --> 00:15:02.236 A:middle
为了表示特殊的变量

00:14:59.946 --> 00:15:02.236 A:middle
为了表示特殊的变量

00:15:03.456 --> 00:15:05.666 A:middle
所以这个顶点 ID 属性

00:15:05.746 --> 00:15:07.446 A:middle
表明了这个 VID 参数

00:15:07.446 --> 00:15:08.576 A:middle
应该在顶点被执行时包括

00:15:08.666 --> 00:15:12.826 A:middle
当前顶点的索引值

00:15:13.196 --> 00:15:14.906 A:middle
在这两个地方我们会用到它

00:15:14.906 --> 00:15:17.676 A:middle
去将索引值放置到顶点数组中

00:15:18.226 --> 00:15:20.636 A:middle
这些带有缓存属性的

00:15:20.636 --> 00:15:22.866 A:middle
参数说明符

00:15:22.866 --> 00:15:24.186 A:middle
表明了这些变量

00:15:24.226 --> 00:15:26.106 A:middle
被 Metal API 里设定的

00:15:26.246 --> 00:15:27.436 A:middle
缓存对象所填满

00:15:27.436 --> 00:15:29.596 A:middle
我一会将会多说一些

00:15:29.596 --> 00:15:31.596 A:middle
Metal API 是怎么与这些有关联的

00:15:32.266 --> 00:15:33.626 A:middle
但是首先我们先来看看

00:15:33.626 --> 00:15:35.136 A:middle
这里用到的一些类型

00:15:36.056 --> 00:15:37.776 A:middle
现在这些都是你可以定义的

00:15:38.366 --> 00:15:39.386 A:middle
自定义类型

00:15:40.406 --> 00:15:41.656 A:middle
这里的顶点参数

00:15:41.656 --> 00:15:43.606 A:middle
被定义为指向顶点类型的指针

00:15:43.606 --> 00:15:45.886 A:middle
这就是它的定义

00:15:46.706 --> 00:15:48.836 A:middle
这个结构包括两个成员

00:15:48.836 --> 00:15:50.586 A:middle
一个是模型位置成员

00:15:50.586 --> 00:15:51.736 A:middle
另一个是纹理坐标成员

00:15:52.446 --> 00:15:54.116 A:middle
它在顶点数组里定义了 每一个顶点的

00:15:54.146 --> 00:15:56.186 A:middle
布局和内存

00:15:56.526 --> 00:15:58.096 A:middle
这个数据会被传递到这个顶点的着色器

00:15:59.836 --> 00:16:01.336 A:middle
我们再来看看这个顶点的输出类型

00:15:59.836 --> 00:16:01.336 A:middle
我们再来看看这个顶点的输出类型

00:16:01.336 --> 00:16:03.186 A:middle
它是从顶点着色器里返回的

00:16:03.776 --> 00:16:06.506 A:middle
它这里的定义指定了

00:16:06.506 --> 00:16:07.736 A:middle
什么被传递下去用于

00:16:07.736 --> 00:16:09.186 A:middle
光栈化阶段并

00:16:09.186 --> 00:16:10.806 A:middle
最终用于分片程序

00:16:11.336 --> 00:16:13.756 A:middle
包含了四个部分的

00:16:13.756 --> 00:16:15.146 A:middle
浮动点成员被称为 clipPos

00:16:15.186 --> 00:16:17.396 A:middle
clipPos 在他的旁边有

00:16:17.396 --> 00:16:18.766 A:middle
位置属性说明符

00:16:19.336 --> 00:16:20.756 A:middle
这就表明了这个成员

00:16:20.756 --> 00:16:22.096 A:middle
会作为一个顶点着色器的

00:16:22.136 --> 00:16:23.746 A:middle
位置输出

00:16:25.116 --> 00:16:26.376 A:middle
这个 texCoord 成员

00:16:26.376 --> 00:16:27.326 A:middle
并不带有默认为变量的

00:16:27.326 --> 00:16:30.096 A:middle
属性说明符

00:16:30.306 --> 00:16:31.656 A:middle
它会和其他顶点的纹理坐标值

00:16:31.656 --> 00:16:36.726 A:middle
一起被插入去定义

00:16:36.726 --> 00:16:38.616 A:middle
光栅化三角形

00:16:38.616 --> 00:16:39.986 A:middle
这就跟 GLSL 很不一样

00:16:41.616 --> 00:16:42.616 A:middle
我们再来看看

00:16:42.616 --> 00:16:44.046 A:middle
我们分片着色器的参数

00:16:45.146 --> 00:16:46.796 A:middle
所以我们会用到这个 vertexOutput 结构体

00:16:46.796 --> 00:16:48.966 A:middle
我们刚刚看过的这个结构体

00:16:49.406 --> 00:16:51.716 A:middle
会作为我们分片着色器的输入

00:16:52.336 --> 00:16:53.966 A:middle
同时它给了我们插入的

00:16:54.006 --> 00:16:55.446 A:middle
纹理坐标

00:16:55.716 --> 00:16:57.346 A:middle
这个坐标我们已经在顶点着色器里构造了

00:16:58.486 --> 00:17:00.206 A:middle
我们这里用它来

00:16:58.486 --> 00:17:00.206 A:middle
我们这里用它来

00:17:00.366 --> 00:17:02.966 A:middle
从纹理中取样

00:17:03.086 --> 00:17:04.586 A:middle
在我们写好的 Objective-C

00:17:04.586 --> 00:17:06.486 A:middle
App 代码中

00:17:06.486 --> 00:17:08.316 A:middle
我们用 Render Command Encoder 去

00:17:08.406 --> 00:17:10.226 A:middle
将对象映射到着色器参数

00:17:12.915 --> 00:17:15.016 A:middle
这个带有请求的索引参数

00:17:15.016 --> 00:17:16.396 A:middle
非常类似于

00:17:16.396 --> 00:17:18.316 A:middle
OpenGL 的属性索引

00:17:18.366 --> 00:17:20.715 A:middle
顶点属性索引和纹理单元

00:17:21.336 --> 00:17:23.415 A:middle
它们指定了哪一个索引

00:17:23.526 --> 00:17:25.836 A:middle
映射到了我们着色器参数

00:17:27.026 --> 00:17:29.056 A:middle
所以通过请求编译器的含有三个索引值的

00:17:29.106 --> 00:17:30.526 A:middle
集合片段缓存方法

00:17:30.526 --> 00:17:33.046 A:middle
我们可以将我的标准缓存对象

00:17:33.046 --> 00:17:37.446 A:middle
映射到我们的着色器的

00:17:37.446 --> 00:17:38.936 A:middle
标准编码器参数

00:17:39.536 --> 00:17:42.326 A:middle
我们进行类似的请求去

00:17:42.326 --> 00:17:44.836 A:middle
设置我们的纹理和采样器对象

00:17:50.396 --> 00:17:52.096 A:middle
现在我们来多说一下

00:17:52.096 --> 00:17:53.996 A:middle
着色器开发里

00:17:54.106 --> 00:17:55.606 A:middle
特别有用的一个库

00:17:57.236 --> 00:17:58.576 A:middle
它叫 SIMD

00:17:58.896 --> 00:18:00.666 A:middle
现在 SIMD 实际上是一个

00:17:58.896 --> 00:18:00.666 A:middle
现在 SIMD 实际上是一个

00:18:00.966 --> 00:18:02.616 A:middle
分离于 Metal 的库

00:18:03.126 --> 00:18:05.246 A:middle
经常用于许多正交框架

00:18:05.836 --> 00:18:07.366 A:middle
但是它在思想上

00:18:07.366 --> 00:18:07.686 A:middle
跟 Metal 很相似

00:18:08.936 --> 00:18:10.886 A:middle
SIMD 定义了常用的

00:18:10.886 --> 00:18:12.786 A:middle
向量和矩阵类型

00:18:13.286 --> 00:18:15.056 A:middle
去实现图形化算法

00:18:15.056 --> 00:18:16.036 A:middle
所以它包括了三四个

00:18:16.036 --> 00:18:17.846 A:middle
向量类型和

00:18:17.846 --> 00:18:19.976 A:middle
三乘三和四乘四 矩阵类型

00:18:24.046 --> 00:18:24.906 A:middle
这个库最棒的特性之一是

00:18:24.906 --> 00:18:26.676 A:middle
你能用它

00:18:26.676 --> 00:18:30.496 A:middle
在你的 App 代码

00:18:30.496 --> 00:18:33.306 A:middle
和着色语言代码之间

00:18:33.306 --> 00:18:34.966 A:middle
分享代码

00:18:35.596 --> 00:18:37.216 A:middle
这真的很有用

00:18:37.216 --> 00:18:38.856 A:middle
因为你可以定义数据的布局

00:18:38.926 --> 00:18:39.986 A:middle
这些数据和结构就是通过这些类型

00:18:39.986 --> 00:18:42.066 A:middle
从你的 App 传递

00:18:42.066 --> 00:18:43.426 A:middle
到你的着色器

00:18:44.046 --> 00:18:44.766 A:middle
它怎么工作的呢

00:18:45.996 --> 00:18:47.276 A:middle
你先创建一个带有数据的结构

00:18:47.346 --> 00:18:48.216 A:middle
这些数据是你想要从你的 App

00:18:48.216 --> 00:18:49.516 A:middle
传递到你的着色器的

00:18:49.836 --> 00:18:51.396 A:middle
所以举例来说

00:18:51.396 --> 00:18:52.536 A:middle
如果你想传递一个

00:18:52.536 --> 00:18:55.206 A:middle
模型视图投影矩阵

00:18:55.206 --> 00:18:56.646 A:middle
和这个 SIMD 的首要光源位置

00:18:56.646 --> 00:18:58.696 A:middle
你就可以在你的结构中

00:18:58.696 --> 00:19:01.546 A:middle
通过 SIMD 类型去实现

00:18:58.696 --> 00:19:01.546 A:middle
通过 SIMD 类型去实现

00:19:01.976 --> 00:19:02.746 A:middle
你将结构的定义

00:19:02.746 --> 00:19:05.106 A:middle
和头文件都包含在

00:19:05.106 --> 00:19:08.796 A:middle
你的 App 代码和 Metal 文件里

00:19:09.116 --> 00:19:10.756 A:middle
这样的话你着色器里用的

00:19:10.756 --> 00:19:12.566 A:middle
数据布局就能与你的代码

00:19:12.566 --> 00:19:14.036 A:middle
匹配上 因为它们

00:19:14.036 --> 00:19:15.286 A:middle
使用了相同的类型

00:19:16.686 --> 00:19:18.296 A:middle
这样布局不匹配的问题就会

00:19:18.296 --> 00:19:19.976 A:middle
出现的更少

00:19:24.046 --> 00:19:25.556 A:middle
Metal 实现高效的

00:19:25.556 --> 00:19:27.716 A:middle
一个关键因素是

00:19:27.716 --> 00:19:30.456 A:middle
更早地开始工作并且频率更低

00:19:31.376 --> 00:19:33.426 A:middle
所以你将需要在建立 App 的时候

00:19:33.426 --> 00:19:34.896 A:middle
用 Xcode 去编译

00:19:34.896 --> 00:19:35.856 A:middle
Metal 着色器

00:19:36.986 --> 00:19:38.206 A:middle
这运行了一个前端编译

00:19:38.206 --> 00:19:39.866 A:middle
来执行字符串解析

00:19:39.866 --> 00:19:41.826 A:middle
着色器分析和

00:19:41.826 --> 00:19:43.226 A:middle
一些基本的优化

00:19:43.986 --> 00:19:45.526 A:middle
它将你的代码转换成

00:19:45.526 --> 00:19:46.796 A:middle
一个二进制的中间表示

00:19:46.796 --> 00:19:49.456 A:middle
它在任何硬件上都能使用

00:19:50.456 --> 00:19:52.566 A:middle
实际的 GPU 机器代码

00:19:52.566 --> 00:19:54.156 A:middle
直到你的代码在用户系统上运行以前

00:19:54.156 --> 00:19:54.976 A:middle
都不会被构建的

00:19:55.516 --> 00:19:56.726 A:middle
但是这在你的代码运行的时候

00:19:56.726 --> 00:19:58.976 A:middle
移除了一半的编译时间

00:19:59.996 --> 00:20:02.886 A:middle
这个搭建的

00:19:59.996 --> 00:20:02.886 A:middle
这个搭建的

00:20:02.886 --> 00:20:05.286 A:middle
二进制中间表示

00:20:05.376 --> 00:20:07.926 A:middle
是通过 Metal 库文件实现的

00:20:08.576 --> 00:20:10.376 A:middle
Xcode 会将所有 Metal

00:20:10.376 --> 00:20:11.656 A:middle
着色器源文件编译进

00:20:11.776 --> 00:20:13.856 A:middle
一个默认的 Metal 库

00:20:13.856 --> 00:20:16.256 A:middle
为了运行时检索

00:20:16.256 --> 00:20:17.276 A:middle
将他放进你的 App 包中

00:20:17.936 --> 00:20:20.686 A:middle
除了有 Xcode 建立的着色器

00:20:20.686 --> 00:20:23.286 A:middle
你也可以在 App

00:20:23.286 --> 00:20:24.726 A:middle
运行过程中创建着色器

00:20:26.126 --> 00:20:27.436 A:middle
一些 OpenGL App 在运行过程中

00:20:27.436 --> 00:20:28.446 A:middle
创建着色器是通过

00:20:28.546 --> 00:20:30.096 A:middle
连接字符串或者运行

00:20:30.096 --> 00:20:31.616 A:middle
源代码生成器实现的

00:20:32.646 --> 00:20:33.846 A:middle
要在构建期间

00:20:33.846 --> 00:20:35.826 A:middle
获取所有着色器会非常有挑战性

00:20:36.846 --> 00:20:38.756 A:middle
但是为了特定的目的或者

00:20:38.856 --> 00:20:40.476 A:middle
如果构建时间编译

00:20:40.476 --> 00:20:41.486 A:middle
在你的 App 里并不可能实现

00:20:41.876 --> 00:20:43.486 A:middle
那么 Metal 是可以像 OpenGL 一样

00:20:43.486 --> 00:20:45.326 A:middle
在运行期间通过源文件

00:20:45.326 --> 00:20:45.836 A:middle
编译着色器的

00:20:46.386 --> 00:20:49.346 A:middle
然而 这样做

00:20:49.346 --> 00:20:50.896 A:middle
会有很多不好的地方

00:20:50.896 --> 00:20:52.416 A:middle
最明显的是你会放弃

00:20:52.416 --> 00:20:53.636 A:middle
节约性能

00:20:53.636 --> 00:20:54.986 A:middle
因为这在用户系统之外工作

00:20:56.216 --> 00:20:57.206 A:middle
你不会在构建期间

00:20:57.206 --> 00:20:58.546 A:middle
看见任何的着色器编译错误

00:20:58.546 --> 00:21:00.776 A:middle
所以你只能在你运行代码的时候才发现

00:20:58.546 --> 00:21:00.776 A:middle
所以你只能在你运行代码的时候才发现

00:21:01.896 --> 00:21:03.436 A:middle
最后 如果你是在运行时编译

00:21:03.436 --> 00:21:04.766 A:middle
你就不能在着色器中包含

00:21:04.766 --> 00:21:06.246 A:middle
头文件 所以你就不能

00:21:06.246 --> 00:21:07.526 A:middle
在你的 App 代码

00:21:07.526 --> 00:21:09.686 A:middle
和着色器代码之间分享代码

00:21:10.236 --> 00:21:12.776 A:middle
如果你在运行期间通过

00:21:12.776 --> 00:21:14.546 A:middle
分享编译来使你的 App 工作

00:21:14.546 --> 00:21:16.066 A:middle
那我强烈地建议你

00:21:16.066 --> 00:21:18.146 A:middle
花点时间让你的

00:21:18.146 --> 00:21:19.966 A:middle
着色器在 Xcode 里边编译

00:21:20.586 --> 00:21:21.676 A:middle
这样做你可以获得很多好处

00:21:21.676 --> 00:21:23.056 A:middle
比如说节约运行时间

00:21:23.056 --> 00:21:24.246 A:middle
和更为方便

00:21:24.246 --> 00:21:26.046 A:middle
你的着色器开发

00:21:26.526 --> 00:21:29.426 A:middle
我们来看看

00:21:29.426 --> 00:21:30.646 A:middle
你的 App

00:21:30.646 --> 00:21:31.946 A:middle
初始化你的 Metal 渲染器 的步骤

00:21:32.186 --> 00:21:33.376 A:middle
这要创建

00:21:33.376 --> 00:21:34.246 A:middle
很多对象

00:21:34.746 --> 00:21:36.286 A:middle
我将从设备入手

00:21:36.286 --> 00:21:37.666 A:middle
然后是命令队列

00:21:37.666 --> 00:21:39.826 A:middle
之后我会描述怎样

00:21:39.826 --> 00:21:40.966 A:middle
建立对象

00:21:40.966 --> 00:21:43.426 A:middle
包括纹理 缓存器和管道对象

00:21:45.046 --> 00:21:47.566 A:middle
所以设备和队列

00:21:47.726 --> 00:21:50.016 A:middle
是你要创建的第一个对象

00:21:50.636 --> 00:21:53.506 A:middle
设备是 GPU 的一个

00:21:53.506 --> 00:21:54.866 A:middle
抽象表现

00:21:56.226 --> 00:21:57.346 A:middle
它负责创建

00:21:57.346 --> 00:21:58.436 A:middle
用于渲染的对象

00:21:58.436 --> 00:21:59.416 A:middle
它们包括

00:21:59.456 --> 00:22:01.386 A:middle
纹理 缓存和管道对象

00:21:59.456 --> 00:22:01.386 A:middle
纹理 缓存和管道对象

00:22:02.846 --> 00:22:04.506 A:middle
在 iOS 还只有一个

00:22:04.506 --> 00:22:06.826 A:middle
GPU 的时候

00:22:06.826 --> 00:22:08.626 A:middle
你只能有一个设备

00:22:08.916 --> 00:22:10.356 A:middle
但是在 macOS 系统上可以有

00:22:10.356 --> 00:22:12.216 A:middle
多个设备因为它们可能

00:22:12.216 --> 00:22:14.126 A:middle
都集成在了分散的 GPU

00:22:14.126 --> 00:22:16.026 A:middle
或多个 eGPU 上

00:22:17.236 --> 00:22:18.286 A:middle
虽然通常情况下

00:22:18.286 --> 00:22:20.146 A:middle
用默认的设备对于大多数 App

00:22:20.146 --> 00:22:21.126 A:middle
都足够了

00:22:21.886 --> 00:22:23.776 A:middle
而且获取这个设备

00:22:23.826 --> 00:22:25.216 A:middle
是很简单的

00:22:25.276 --> 00:22:26.876 A:middle
你调用 MTLCreateSystem

00:22:26.876 --> 00:22:27.616 A:middle
DefaultDevice 即可

00:22:28.296 --> 00:22:31.136 A:middle
对于这个设备

00:22:31.136 --> 00:22:33.396 A:middle
你要做的第一件事就是

00:22:33.396 --> 00:22:33.966 A:middle
创建一个命令队列

00:22:35.746 --> 00:22:37.416 A:middle
这个队列主要用于你的

00:22:37.416 --> 00:22:38.736 A:middle
App 渲染循环

00:22:38.736 --> 00:22:40.036 A:middle
去在每一帧里获取命令缓存

00:22:40.086 --> 00:22:41.536 A:middle
但是你需要在

00:22:41.536 --> 00:22:42.836 A:middle
初始化的时候创建

00:22:42.996 --> 00:22:43.826 A:middle
命令队列

00:22:45.036 --> 00:22:46.176 A:middle
通常情况下 单个队列就足够了

00:22:46.176 --> 00:22:48.006 A:middle
但是更复杂的 App

00:22:48.276 --> 00:22:49.926 A:middle
会在多个队列中

00:22:49.926 --> 00:22:51.986 A:middle
同时被执行

00:22:53.206 --> 00:22:54.696 A:middle
创建一个队列也是非常简单的

00:22:54.696 --> 00:22:56.666 A:middle
你可以调用 newCommandQueue

00:22:56.906 --> 00:22:58.336 A:middle
和刚才你创建好的设备

00:22:58.956 --> 00:22:59.996 A:middle
一旦你获取了你的队列

00:23:00.276 --> 00:23:02.306 A:middle
你就可以得到渲染循环的命令缓存

00:23:02.806 --> 00:23:06.846 A:middle
我们继续来看一看创建

00:23:06.846 --> 00:23:07.546 A:middle
渲染对象

00:23:08.216 --> 00:23:10.546 A:middle
我将会说一说创建

00:23:10.736 --> 00:23:12.106 A:middle
三种类型的对象

00:23:12.106 --> 00:23:14.426 A:middle
它们用于渲染 纹理 缓存和管道

00:23:15.496 --> 00:23:17.846 A:middle
我们先从纹理开始

00:23:18.106 --> 00:23:19.466 A:middle
就像之前所提到的

00:23:19.466 --> 00:23:21.066 A:middle
你通过设备对象 创建渲染对象

00:23:22.416 --> 00:23:23.756 A:middle
你大部分情况下 将会用到描述符对象

00:23:23.756 --> 00:23:24.836 A:middle
去创造这些对象

00:23:25.546 --> 00:23:26.916 A:middle
描述符是非常简单的对象

00:23:26.916 --> 00:23:28.756 A:middle
它没有任何真方法

00:23:29.296 --> 00:23:31.856 A:middle
它们只包含用于对象建立的属性

00:23:33.146 --> 00:23:34.526 A:middle
举个例子

00:23:34.526 --> 00:23:36.326 A:middle
你会需要一个纹理描述符去创建纹理

00:23:37.076 --> 00:23:38.306 A:middle
你可以指定

00:23:38.306 --> 00:23:39.666 A:middle
你想要创建的纹理的属性

00:23:40.186 --> 00:23:41.406 A:middle
比如说纹理的类型

00:23:41.436 --> 00:23:43.396 A:middle
2D 3D 和 cubeMap

00:23:44.146 --> 00:23:45.296 A:middle
纹理的维度和

00:23:45.296 --> 00:23:47.286 A:middle
它所需要的 Mipmap 的数量

00:23:47.286 --> 00:23:49.746 A:middle
还有纹理中包含的

00:23:50.676 --> 00:23:51.576 A:middle
数据像素格式

00:23:51.706 --> 00:23:53.416 A:middle
一旦你设定好

00:23:53.416 --> 00:23:54.346 A:middle
每一个属性需要的值

00:23:54.346 --> 00:23:56.076 A:middle
你就可以在设备上调用方法

00:23:56.076 --> 00:23:58.856 A:middle
去创建可用的纹理对象

00:24:00.816 --> 00:24:03.156 A:middle
这也需要为返回纹理图像

00:24:03.266 --> 00:24:04.726 A:middle
分配内存

00:24:06.086 --> 00:24:07.946 A:middle
一旦你创建了对象 你就不再需要

00:24:07.946 --> 00:24:09.286 A:middle
描述符了 因为它只是用来

00:24:09.286 --> 00:24:10.126 A:middle
创建对象的

00:24:11.256 --> 00:24:12.296 A:middle
然后你设置在描述符中的属性

00:24:12.296 --> 00:24:14.396 A:middle
就会被锁定并且不能再改变

00:24:15.766 --> 00:24:17.056 A:middle
然后 纹理图像的内容

00:24:17.056 --> 00:24:18.726 A:middle
是可以修改的

00:24:18.756 --> 00:24:21.816 A:middle
所以我会再说一下一个

00:24:21.816 --> 00:24:22.816 A:middle
你将设定在纹理描述符中的属性

00:24:22.816 --> 00:24:24.096 A:middle
同时你也能

00:24:24.096 --> 00:24:25.876 A:middle
在创建缓存的时候使用

00:24:26.626 --> 00:24:28.166 A:middle
这被称为存储模式

00:24:29.286 --> 00:24:30.366 A:middle
就像之前提到的

00:24:30.366 --> 00:24:31.966 A:middle
在你创建纹理的时候

00:24:31.966 --> 00:24:33.596 A:middle
Metal 会为它分配内存

00:24:34.106 --> 00:24:35.276 A:middle
存储模式属性告诉

00:24:35.276 --> 00:24:37.406 A:middle
Metal 要在哪一个内存池中去分配内存

00:24:38.576 --> 00:24:40.056 A:middle
最简单的方式

00:24:40.056 --> 00:24:42.436 A:middle
去共享存储模式就是同时给

00:24:42.876 --> 00:24:44.046 A:middle
CPU 和 GPU 访问权限

00:24:44.656 --> 00:24:46.076 A:middle
对于缓存来说这就是

00:24:46.076 --> 00:24:47.666 A:middle
你为指向对象的内存

00:24:47.666 --> 00:24:48.156 A:middle
获取了一个指针

00:24:48.996 --> 00:24:50.166 A:middl
Protector 代表着你可以

00:24:50.166 --> 00:24:51.926 A:middle
调用简易的方法

00:24:52.196 --> 00:24:54.196 A:middle
从纹理中去设定和获取数据

00:24:54.736 --> 00:24:57.246 A:middle
你可以用私有存储模式

00:24:57.246 --> 00:24:58.836 A:middle
这种模式只给了 GPU 访问

00:24:58.926 --> 00:25:00.486 A:middle
数据的权限

00:24:58.926 --> 00:25:00.486 A:middle
数据的权限

00:25:00.486 --> 00:25:01.356 A:middle
这就允许了 Metal

00:25:01.356 --> 00:25:03.906 A:middle
去执行优化

00:25:03.906 --> 00:25:05.786 A:middle
不然可能在 CPU 有访问数据权限的时候

00:25:05.786 --> 00:25:06.206 A:middle
是无法达成的

00:25:06.896 --> 00:25:08.776 A:middle
但是只有 GPU 可以直接

00:25:08.886 --> 00:25:11.096 A:middle
填写这种纹理类型的内容

00:25:12.606 --> 00:25:14.016 A:middle
你也可以间接的通过 CPU 去填写数据

00:25:14.206 --> 00:25:15.996 A:middle
这可以通过使用 blit 编码器让 CPU 实现

00:25:15.996 --> 00:25:17.786 A:middle
blit 通过共享的存储

00:25:18.076 --> 00:25:21.026 A:middle
从第二中间资源去拷贝

00:25:22.446 --> 00:25:23.966 A:middle
在具有专用视频内存的设备上

00:25:23.966 --> 00:25:25.656 A:middle
设定这个资源去使用

00:25:25.656 --> 00:25:27.306 A:middle
私有存储

00:25:27.306 --> 00:25:28.396 A:middle
将它分配成仅用于视频存储

00:25:30.396 --> 00:25:32.776 A:middle
最后 在 macOS 上你可以使用

00:25:32.866 --> 00:25:34.756 A:middle
第三种存储模式 托管存储

00:25:35.696 --> 00:25:37.796 A:middle
这种模式允许 GPU 和 CPU 一起

00:25:37.826 --> 00:25:39.066 A:middle
访问对象数据

00:25:39.776 --> 00:25:40.946 A:middle
而且对于有专用视频内存的系统

00:25:40.946 --> 00:25:43.226 A:middle
Metal 会建立一个镜像内存

00:25:43.226 --> 00:25:46.696 A:middle
反向用于两个处理器的高效访问

00:25:47.926 --> 00:25:49.396 A:middle
正因为这样

00:25:49.396 --> 00:25:51.166 A:middle
显性的调用对于确认

00:25:51.236 --> 00:25:53.876 A:middle
数据在 CPU GPU 上的同步访问是很有必要的

00:25:58.126 --> 00:26:00.376 A:middle
这里是一个创建纹理对象的例子

00:25:58.126 --> 00:26:00.376 A:middle
这里是一个创建纹理对象的例子

00:26:00.816 --> 00:26:04.256 A:middle
首先你创建一个纹理描述符

00:26:04.256 --> 00:26:06.126 A:middle
以及内部的一系列属性

00:26:06.126 --> 00:26:08.586 A:middle
包括存储模式

00:26:09.106 --> 00:26:12.836 A:middle
然后我们通过这个设备

00:26:13.586 --> 00:26:14.556 A:middle
去创建一个纹理

00:26:15.916 --> 00:26:17.166 A:middle
为了去填充纹理的图像数据

00:26:17.316 --> 00:26:18.936 A:middle
我们计算每一行的字节数

00:26:19.886 --> 00:26:21.336 A:middle
这就像用 GLText 一样

00:26:21.336 --> 00:26:23.466 A:middle
[ 音质不清晰 ] 我们指定一个区域去加载

00:26:26.196 --> 00:26:27.536 A:middle
然后我们调用纹理对象的

00:26:27.536 --> 00:26:29.506 A:middle
替换区域方法

00:26:29.756 --> 00:26:31.596 A:middle
它从我们提供的指针中

00:26:31.596 --> 00:26:32.926 A:middle
复制数据到纹理中

00:26:37.046 --> 00:26:38.266 A:middle
这里是一些值得注意的

00:26:38.266 --> 00:26:39.396 A:middle
OpenGL 和 Metal 纹理对象

00:26:39.396 --> 00:26:40.446 A:middle
之间的一些区别

00:26:40.816 --> 00:26:42.556 A:middle
虽然 OpenGL 确实有采样器对象

00:26:42.556 --> 00:26:43.886 A:middle
但是他们是可选的

00:26:44.406 --> 00:26:45.576 A:middle
在 OpenGL 中

00:26:45.576 --> 00:26:46.826 A:middle
包装模式和过滤器可以被设定在

00:26:46.826 --> 00:26:47.886 A:middle
纹理对象中

00:26:48.276 --> 00:26:49.736 A:middle
在 Metal 里你需要在着色器中

00:26:49.816 --> 00:26:51.376 A:middle
去创建单独的采样器对象

00:26:51.376 --> 00:26:53.576 A:middle
或者是指定的

00:26:54.206 --> 00:26:55.096 A:middle
采样器参数

00:26:55.786 --> 00:26:57.336 A:middle
在 Metal 里纹理图像数据

00:26:57.416 --> 00:26:57.946 A:middle
是不可被翻转的

00:26:58.496 --> 00:27:00.996 A:middle
OpenGL 使用的是左下角原点

00:26:58.496 --> 00:27:00.996 A:middle
OpenGL 使用的是左下角原点

00:27:01.306 --> 00:27:03.196 A:middle
但是 Metal 用的是左上角原点

00:27:03.196 --> 00:27:04.426 A:middle
所以在你加载纹理的时候

00:27:04.426 --> 00:27:06.266 A:middle
你要留意这些区别

00:27:06.686 --> 00:27:09.696 A:middle
桌面版 OpenGL 同时也执行转化

00:27:09.796 --> 00:27:10.866 A:middle
当提供的数据是

00:27:10.916 --> 00:27:13.376 A:middle
不同的格式而不是

00:27:13.376 --> 00:27:15.016 A:middle
内部格式的时候

00:27:16.456 --> 00:27:18.106 A:middle
但是 Metal 和 OpenGL ES 很类似

00:27:18.206 --> 00:27:20.346 A:middle
所以你需要确认

00:27:20.346 --> 00:27:21.406 A:middle
你的数据都已经被

00:27:21.436 --> 00:27:23.436 A:middle
设定成了合适的格式或者

00:27:23.696 --> 00:27:25.696 A:middle
执行路径去进行转化

00:27:29.066 --> 00:27:32.316 A:middle
我们再来看看缓存器

00:27:32.456 --> 00:27:34.266 A:middle
Metal 对于所有非结构体数据

00:27:34.266 --> 00:27:34.976 A:middle
都是用的缓存器

00:27:41.456 --> 00:27:42.406 A:middle
它们非常类似于 OpenGL 的顶点

00:27:42.406 --> 00:27:45.646 A:middle
元素和标准缓存

00:27:45.926 --> 00:27:47.076 A:middle
所以如果你已经在 OpenGL 中用了这些缓存器

00:27:47.076 --> 00:27:48.456 A:middle
你在处理你的端口的时候

00:27:48.506 --> 00:27:50.126 A:middle
就会更容易一些

00:27:51.506 --> 00:27:52.686 A:middle
通过设备你能很轻易地创建缓存器

00:27:52.686 --> 00:27:54.456 A:middle
这个设备是你通过 newBufferWithLength

00:27:54.516 --> 00:27:55.986 A:middle
调用的 它指定了你想要

00:27:55.986 --> 00:27:57.146 A:middle
多大的缓存

00:27:57.826 --> 00:27:59.626 A:middle
你也可以指定存储模式

00:28:00.986 --> 00:28:01.996 A:middle
你通过内容属性

00:28:02.036 --> 00:28:03.506 A:middle
去加载缓存器

00:28:03.506 --> 00:28:05.026 A:middle
这个属性是一个没有返回值的指针

00:28:05.026 --> 00:28:06.186 A:middle
指向返回缓存器的内存

00:28:07.276 --> 00:28:08.706 A:middle
对于 Metal 的核

00:28:08.706 --> 00:28:10.076 A:middle
这个数据是完全没有结构的

00:28:10.076 --> 00:28:11.896 A:middle
所以这就取决于你要怎么去定义

00:28:12.196 --> 00:28:14.066 A:middle
你 App 的布局和怎样

00:28:14.066 --> 00:28:14.296 A:middle
去分享你的代码

00:28:15.086 --> 00:28:16.746 A:middle
这里我们分配一个内容指针

00:28:16.826 --> 00:28:18.486 A:middle
指向一个使用了一些 SIMD 类型的结构

00:28:18.486 --> 00:28:20.546 A:middle
这个在之前

00:28:20.546 --> 00:28:21.236 A:middle
我已经提到过了

00:28:21.236 --> 00:28:23.796 A:middle
我们设置一系列结构体

00:28:23.796 --> 00:28:25.466 A:middle
这些结构体填充缓存区的数据

00:28:25.466 --> 00:28:26.936 A:middle
这是通过使用已经通过

00:28:26.936 --> 00:28:28.286 A:middle
结构体的定义 定义过的布局或 App

00:28:28.606 --> 00:28:29.816 A:middle
来实现的

00:28:31.306 --> 00:28:32.506 A:middle
就像之前提到的

00:28:32.506 --> 00:28:34.026 A:middle
你可以在你的 App

00:28:34.276 --> 00:28:35.406 A:middle
之间分享你的代码

00:28:35.406 --> 00:28:36.736 A:middle
这就确定了你的布局

00:28:36.736 --> 00:28:38.886 A:middle
在这两个部件之间可以匹配

00:28:39.466 --> 00:28:44.846 A:middle
一个很常见的错误是

00:28:44.886 --> 00:28:46.456 A:middle
缓存数据和它

00:28:46.456 --> 00:28:48.226 A:middle
如何在着色器中被翻译不匹配

00:28:48.356 --> 00:28:49.556 A:middle
这是因为一个关于

00:28:49.556 --> 00:28:51.196 A:middle
校准的假设

00:28:52.136 --> 00:28:53.476 A:middle
举个例子

00:28:53.476 --> 00:28:54.496 A:middle
你可能会假设着色器的语言是

00:28:54.826 --> 00:28:57.256 A:middle
flout3 的类型

00:28:57.296 --> 00:28:57.576 A:middle
它只消耗 12 个字节的内存

00:28:58.266 --> 00:29:00.506 A:middle
三个 4 字节的部件就是

00:28:58.266 --> 00:29:00.506 A:middle
三个 4 字节的部件就是

00:29:00.506 --> 00:29:01.096 A:middle
12 个字节对吧

00:29:01.936 --> 00:29:03.436 A:middle
那么如果你将你的数据这样打包

00:29:03.436 --> 00:29:04.716 A:middle
你就会有麻烦的

00:29:05.356 --> 00:29:06.586 A:middle
因为你的着色器语言

00:29:06.666 --> 00:29:08.296 A:middle
实际上将 float3 类型解释为

00:29:08.296 --> 00:29:09.586 A:middle
会消耗 16 个字节

00:29:10.336 --> 00:29:11.236 A:middle
这是因为类型被更严格

00:29:11.236 --> 00:29:12.936 A:middle
地定义了对准方式

00:29:12.936 --> 00:29:16.366 A:middle
这是为了 CPU 和 GPU 的优化以及

00:29:16.366 --> 00:29:16.816 A:middle
CPU 和 GPU 的用量

00:29:18.026 --> 00:29:19.626 A:middle
类似的错误还经常发生在

00:29:19.996 --> 00:29:21.176 A:middle
三乘三的矩阵中

00:29:22.316 --> 00:29:23.936 A:middle
如果你真的想追踪它

00:29:23.936 --> 00:29:26.046 A:middle
如果你真的想紧密地包装数据

00:29:26.186 --> 00:29:28.996 A:middle
我们在 Metal 着色器语言中

00:29:28.996 --> 00:29:30.776 A:middle
提供了包装类型

00:29:31.246 --> 00:29:33.126 A:middle
在你将打包好的数据传进缓存以后

00:29:33.126 --> 00:29:34.596 A:middle
你的着色器代码将会

00:29:34.596 --> 00:29:37.356 A:middle
去包装数据

00:29:37.356 --> 00:29:38.846 A:middle
在你处理这些数据以前

00:29:38.846 --> 00:29:40.686 A:middle
你需要将这些包装好的数据传递给

00:29:40.686 --> 00:29:42.236 A:middle
一个规则向量

00:29:43.716 --> 00:29:45.436 A:middle
所以在你发布你的 App 时

00:29:45.436 --> 00:29:48.446 A:middle
我建议你使用

00:29:48.756 --> 00:29:50.376 A:middle
最方便的存储模式

00:29:51.396 --> 00:29:53.436 A:middle
这使得你在那些资源中

00:29:53.466 --> 00:29:55.976 A:middle
访问数据变得更简单

00:29:57.006 --> 00:29:58.676 A:middle
所以在 iOS 系统中

00:29:58.676 --> 00:29:59.696 A:middle
我们通过 StorageModeShared 创建所有的

00:30:00.086 --> 00:30:00.976 A:middle
纹理和缓存

00:30:02.386 --> 00:30:03.726 A:middle
在 macOS 系统上 你就不能用

00:30:03.726 --> 00:30:05.076 A:middle
StorageModeShared 处理纹理

00:30:05.246 --> 00:30:07.146 A:middle
但是 StorageModeManaged 会让你访问

00:30:07.146 --> 00:30:08.526 A:middle
图像数据变得更容易一些

00:30:08.856 --> 00:30:10.846 A:middle
虽然私有存储是最优选择

00:30:16.046 --> 00:30:16.996 A:middle
你可以在 macOS 上使用

00:30:16.996 --> 00:30:19.216 A:middle
StorageModeShared 和缓存

00:30:19.216 --> 00:30:19.906 A:middle
但你需要特别的小心

00:30:20.526 --> 00:30:22.456 A:middle
如果你混合了 CPU 和 GPU

00:30:22.576 --> 00:30:26.066 A:middle
都需要访问的数据和只有

00:30:26.066 --> 00:30:28.336 A:middle
GPU 需要访问的数据

00:30:28.376 --> 00:30:29.456 A:middle
你可能在之后会很难去

00:30:29.456 --> 00:30:31.246 A:middle
分开这两种类型的数据

00:30:31.246 --> 00:30:33.046 A:middle
再把它们放到

00:30:33.046 --> 00:30:34.286 A:middle
单独的内存池中

00:30:34.906 --> 00:30:37.816 A:middle
现在我已经说了一些

00:30:37.816 --> 00:30:39.166 A:middle
关于创建纹理和

00:30:39.166 --> 00:30:41.186 A:middle
缓存对象的内容

00:30:41.186 --> 00:30:42.106 A:middle
我会再提一下 MetalKit 框架

00:30:42.156 --> 00:30:43.526 A:middle
它是用来更简单地去

00:30:43.526 --> 00:30:44.676 A:middle
通过常用文件格式去

00:30:44.676 --> 00:30:46.606 A:middle
创建纹理和顶点的框架

00:30:47.146 --> 00:30:48.336 A:middle
这里面包含了纹理加载类

00:30:48.626 --> 00:30:50.286 A:middle
和一些功能去创建

00:30:50.286 --> 00:30:52.216 A:middle
Metal 缓存支持的网格

00:30:52.376 --> 00:30:53.936 A:middle
这些网格是通过 Model I/O 加载的

00:30:58.046 --> 00:30:59.106 A:middle
现在我们来说一说

00:30:59.106 --> 00:31:00.506 A:middle
包含它们的着色器和

00:30:59.106 --> 00:31:00.506 A:middle
包含它们的着色器和

00:31:00.506 --> 00:31:02.036 A:middle
渲染管道对象

00:31:02.776 --> 00:31:04.046 A:middle
你可以通过渲染

00:31:04.046 --> 00:31:05.766 A:middle
管道描述符对象创建

00:31:05.766 --> 00:31:07.096 A:middle
管道状态对象

00:31:08.466 --> 00:31:10.116 A:middle
这个对象包含了顶点和

00:31:10.116 --> 00:31:11.066 A:middle
分片着色器对它

00:31:12.446 --> 00:31:13.886 A:middle
也指定了提供

00:31:13.886 --> 00:31:16.416 A:middle
顶点着色器的顶点布局

00:31:17.066 --> 00:31:19.506 A:middle
你也能混合状态和

00:31:19.586 --> 00:31:21.586 A:middle
渲染目标的像素格式

00:31:21.866 --> 00:31:23.706 A:middle
这里的渲染目标是分片和着色器

00:31:23.706 --> 00:31:24.136 A:middle
可以渲染到的

00:31:25.666 --> 00:31:27.206 A:middle
就像用纹理对象一样

00:31:27.206 --> 00:31:28.556 A:middle
你在设备上调用方法

00:31:28.556 --> 00:31:30.136 A:middle
这会产生一个不可改变的

00:31:30.136 --> 00:31:32.406 A:middle
渲染状态管道对象

00:31:33.706 --> 00:31:34.926 A:middle
也就像纹理对象一样

00:31:35.056 --> 00:31:36.306 A:middle
你只需要使用描述符

00:31:36.306 --> 00:31:37.546 A:middle
去创建这些对象

00:31:38.156 --> 00:31:40.456 A:middle
这里是一些代码

00:31:40.456 --> 00:31:41.726 A:middle
展现了怎样去搭建这些

00:31:41.726 --> 00:31:42.226 A:middle
管道状态对象

00:31:43.536 --> 00:31:44.916 A:middle
在你创建管道以前

00:31:45.096 --> 00:31:47.456 A:middle
你需要从 Metal 库中

00:31:47.456 --> 00:31:48.686 A:middle
获取着色器

00:31:49.256 --> 00:31:51.446 A:middle
这一行代码加载了我们在 Xcode 里

00:31:51.446 --> 00:31:54.586 A:middle
搭建的默认的 Metal 库文件

00:31:54.726 --> 00:31:56.616 A:middle
对于这个库你可以

00:31:56.616 --> 00:31:58.316 A:middle
通过他们的函数名

00:31:59.116 --> 00:32:00.726 A:middle
获取你的顶点和分片着色器

00:31:59.116 --> 00:32:00.726 A:middle
获取你的顶点和分片着色器

00:32:01.906 --> 00:32:03.146 A:middle
你创建一个渲染管道

00:32:03.146 --> 00:32:05.316 A:middle
描述符对象在

00:32:05.316 --> 00:32:06.866 A:middle
你设定这些着色函数的地方

00:32:06.866 --> 00:32:09.356 A:middle
同时还有指定渲染目标像素格式

00:32:10.306 --> 00:32:12.336 A:middle
最后你用设备和

00:32:12.336 --> 00:32:13.726 A:middle
我们已经设定好的描述符对象

00:32:13.726 --> 00:32:17.026 A:middle
来生成管道状态对象

00:32:18.136 --> 00:32:19.836 A:middle
OpenGL 和 Metal

00:32:19.866 --> 00:32:21.906 A:middle
图形化管道之间

00:32:21.936 --> 00:32:25.316 A:middle
最大的区别就是

00:32:25.316 --> 00:32:26.856 A:middle
OpenGL 编写的对象

00:32:26.896 --> 00:32:28.196 A:middle
只包含顶点和

00:32:28.226 --> 00:32:29.906 A:middle
分片着色对

00:32:29.946 --> 00:32:31.816 A:middle
但是 Metal 管道对象还包括了

00:32:31.816 --> 00:32:33.536 A:middle
顶点布局 混合状态和

00:32:33.536 --> 00:32:34.726 A:middle
渲染目标像素格式

00:32:35.566 --> 00:32:36.776 A:middle
所以你需要在你搭建管道之前

00:32:36.816 --> 00:32:39.896 A:middle
知道所有这些东西

00:32:40.016 --> 00:32:41.576 A:middle
这些管道状态中的

00:32:41.646 --> 00:32:43.166 A:middle
额外部分

00:32:43.166 --> 00:32:44.886 A:middle
使得 Metal 可以在对象建立中完

00:32:44.886 --> 00:32:46.746 A:middle
全将着色器编译进

00:32:46.816 --> 00:32:47.576 A:middle
GPU 机器语言

00:32:48.116 --> 00:32:49.006 A:middle
这是在 OpenGL 编程对象中

00:32:49.006 --> 00:32:50.836 A:middle
根本不可能实现的

00:32:51.706 --> 00:32:52.796 A:middle
现在你就需要去建立一个系统

00:32:52.796 --> 00:32:54.146 A:middle
这个系统允许你在

00:32:54.146 --> 00:32:56.086 A:middle
初始化你的 app 的时候去创建管道

00:32:57.266 --> 00:32:58.236 A:middle
它可以很有用

00:32:58.236 --> 00:32:59.816 A:middle
如果你选择一个规范的顶点布局

00:32:59.816 --> 00:33:01.546 A:middle
和有限的渲染目标集合

00:32:59.816 --> 00:33:01.546 A:middle
和有限的渲染目标集合

00:33:02.156 --> 00:33:03.766 A:middle
这就减少了你 App

00:33:03.766 --> 00:33:05.486 A:middle
的状态组合

00:33:05.486 --> 00:33:07.706 A:middle
和需要的管道对象的数量

00:33:08.976 --> 00:33:10.786 A:middle
然而不是所有人都知道

00:33:10.846 --> 00:33:12.656 A:middle
他们的 App 会需要哪些管道

00:33:13.286 --> 00:33:14.666 A:middle
一般情况下移植

00:33:14.666 --> 00:33:16.306 A:middle
App 到 Metal 的第一步

00:33:16.306 --> 00:33:17.786 A:middle
是持有一个管道词典

00:33:17.786 --> 00:33:18.396 A:middle
这个词典是之前就已经建立好了的

00:33:19.326 --> 00:33:20.566 A:middle
介于你的 App 会遇到

00:33:20.566 --> 00:33:22.196 A:middle
新的状态组合

00:33:22.196 --> 00:33:23.836 A:middle
它可以将描述符看作是钥匙

00:33:23.836 --> 00:33:25.326 A:middle
去建立和存储管道

00:33:26.626 --> 00:33:28.206 A:middle
一定要记得我刚才说到的这个方法

00:33:28.206 --> 00:33:30.326 A:middle
是一种破解方法

00:33:30.326 --> 00:33:31.406 A:middle
同时你也会想要你的 App 避免

00:33:31.406 --> 00:33:31.856 A:middle
通过这种方法被传输

00:33:32.426 --> 00:33:33.856 A:middle
这是因为创建这些对象中的

00:33:33.856 --> 00:33:35.316 A:middle
任何一个都是很昂贵的

00:33:36.346 --> 00:33:37.196 A:middle
当你想要创建管道对象的时候

00:33:37.196 --> 00:33:39.336 A:middle
GPU 编译器会起到作用

00:33:39.336 --> 00:33:41.396 A:middle
并且翻译和优化

00:33:41.396 --> 00:33:42.786 A:middle
着色器的二进制中间

00:33:42.786 --> 00:33:44.636 A:middle
表示到机器代码

00:33:45.386 --> 00:33:46.356 A:middle
如果你的 App 在你的渲染器循环中

00:33:46.386 --> 00:33:47.986 A:middle
及时地创建了这些

00:33:47.986 --> 00:33:51.046 A:middle
你就很有可能会看到

00:33:51.356 --> 00:33:53.046 A:middle
短时间内

00:33:53.046 --> 00:33:55.786 A:middle
减少帧率

00:33:55.986 --> 00:33:57.366 A:middle
给纹理和缓存

00:33:57.366 --> 00:33:58.906 A:middle
分配内存也是很昂贵的操作

00:33:58.906 --> 00:34:00.526 A:middle
这甚至不是

00:33:58.906 --> 00:34:00.526 A:middle
这甚至不是

00:34:00.526 --> 00:34:01.586 A:middle
要考虑将数据

00:34:01.586 --> 00:34:03.726 A:middle
填充到这些资源中的操作

00:34:04.946 --> 00:34:06.076 A:middle
然而一旦你创建了这些对象

00:34:06.076 --> 00:34:07.866 A:middle
在你在渲染循环中使用它们的时候

00:34:07.866 --> 00:34:09.646 A:middle
就只需要非常小的 CPU 了

00:34:09.746 --> 00:34:11.045 A:middle
[ 音质不清晰 ] 因为这在之前的操作中

00:34:11.045 --> 00:34:12.966 A:middle
已经做得够多了

00:34:14.176 --> 00:34:15.485 A:middle
现在我们交给 Sukanya 去解释

00:34:15.485 --> 00:34:16.716 A:middle
他会告诉你们

00:34:16.716 --> 00:34:17.735 A:middle
如何移植你的渲染循环

00:34:18.516 --> 00:34:22.545 A:middle
[ 掌声 ]

00:34:23.045 --> 00:34:24.065 A:middle
&gt;&gt; 晚上好各位

00:34:24.065 --> 00:34:25.886 A:middle
我是 Sukanya Sudugu

00:34:25.886 --> 00:34:26.856 A:middle
是 Apple 的 GPU 软件工程师

00:34:27.646 --> 00:34:29.696 A:middle
我真的超级兴奋去跟你们分享一些

00:34:29.696 --> 00:34:31.496 A:middle
我们在移植上的经验

00:34:31.496 --> 00:34:32.976 A:middle
所以我们来继续看看移植问题

00:34:35.876 --> 00:34:37.096 A:middle
Dan 已经说了很多关于

00:34:37.096 --> 00:34:39.496 A:middle
App 的建立 所以目前为止

00:34:39.496 --> 00:34:40.795 A:middle
你已经建立了所有的

00:34:40.795 --> 00:34:43.596 A:middle
着色器同时也创建了所有的

00:34:43.596 --> 00:34:45.216 A:middle
帧分片所需要的

00:34:45.216 --> 00:34:46.275 A:middle
持久对象

00:34:47.196 --> 00:34:48.656 A:middle
那么现在我们来深入了解一下

00:34:48.656 --> 00:34:50.795 A:middle
你的 App 的渲染循环

00:34:50.795 --> 00:34:52.926 A:middle
它是在每一帧里都会执行的代码

00:34:53.186 --> 00:34:55.996 A:middle
通过 Metal 你会

00:34:55.996 --> 00:34:57.616 A:middle
在你的渲染循环里明确地

00:34:57.616 --> 00:35:00.196 A:middle
管理 GPU 执行的异步性

00:34:57.616 --> 00:35:00.196 A:middle
管理 GPU 执行的异步性

00:35:00.876 --> 00:35:03.156 A:middle
所以这包括了

00:35:03.206 --> 00:35:04.826 A:middle
和 GPU 命令一起获取

00:35:04.826 --> 00:35:06.736 A:middle
和提交命令缓存到 GPU

00:35:06.736 --> 00:35:10.046 A:middle
同时以这样的方式 更新你的资源

00:35:10.046 --> 00:35:12.206 A:middle
使得你的 GPU

00:35:12.206 --> 00:35:13.926 A:middle
可以异步地从它里边读取信息

00:35:14.566 --> 00:35:16.086 A:middle
这些资源是你之前 就已经写好在你的

00:35:16.176 --> 00:35:16.726 A:middle
渲染循环里的

00:35:17.266 --> 00:35:19.526 A:middle
然后通过创建渲染命令编码器

00:35:19.526 --> 00:35:21.326 A:middle
来编码渲染通行证

00:35:21.936 --> 00:35:24.636 A:middle
最后将你的帧

00:35:24.636 --> 00:35:25.776 A:middle
展现出来

00:35:25.776 --> 00:35:29.196 A:middle
所以我们先来说一说

00:35:29.196 --> 00:35:30.356 A:middle
命令缓存对象

00:35:32.396 --> 00:35:34.066 A:middle
与 OpenGL 最大的不同点之一就是

00:35:34.066 --> 00:35:36.536 A:middle
Metal 通过命令缓存

00:35:36.606 --> 00:35:38.196 A:middle
提供了准确的控制

00:35:38.196 --> 00:35:40.366 A:middle
这表示着创建这些命令缓存

00:35:40.366 --> 00:35:42.396 A:middle
完全是取决于你

00:35:42.396 --> 00:35:44.106 A:middle
同时你也能决定什么时候

00:35:44.106 --> 00:35:46.486 A:middle
去将这些执行提交给 GPU

00:35:47.306 --> 00:35:49.496 A:middle
一种直接的实现方法就是

00:35:49.496 --> 00:35:51.056 A:middle
创建一个命令缓存

00:35:51.056 --> 00:35:53.236 A:middle
它可以渲染你的整个帧

00:35:53.946 --> 00:35:55.796 A:middle
然后一旦你的 App 准备好了

00:35:55.796 --> 00:35:57.916 A:middle
并且可以跑了并且如果

00:35:57.916 --> 00:35:59.816 A:middle
你在 GPU 上看到一些空余时间

00:35:59.816 --> 00:36:01.976 A:middle
这样的话你就可以去考虑

00:35:59.816 --> 00:36:01.976 A:middle
这样的话你就可以去考虑

00:36:02.146 --> 00:36:03.396 A:middle
将你的帧分开到

00:36:03.396 --> 00:36:04.606 A:middle
多个命令缓存内

00:36:05.006 --> 00:36:08.086 A:middle
然后 GPU 就可以在

00:36:08.086 --> 00:36:09.796 A:middle
CPU 编译其他命令缓存的时候开始

00:36:10.086 --> 00:36:11.886 A:middle
执行一个命令缓存

00:36:13.346 --> 00:36:15.106 A:middle
或者将你的帧

00:36:15.106 --> 00:36:17.386 A:middle
分割编译进多个线程

00:36:17.386 --> 00:36:19.136 A:middle
这就需要你去

00:36:19.136 --> 00:36:20.436 A:middle
在每一帧里都创建一个命令缓存

00:36:20.436 --> 00:36:23.196 A:middle
但是一定要记住

00:36:23.196 --> 00:36:25.056 A:middle
每一个命令缓存都会需要

00:36:25.056 --> 00:36:27.056 A:middle
额外的 CPU 消耗

00:36:27.496 --> 00:36:30.066 A:middle
所以你最好尽可能的少用

00:36:32.216 --> 00:36:34.306 A:middle
Metal 也提供 API 来

00:36:34.356 --> 00:36:36.436 A:middle
注册一个完整的回调

00:36:37.136 --> 00:36:38.846 A:middle
它会在 GPU 完成执行

00:36:38.846 --> 00:36:41.386 A:middle
这些命令缓存的时候被涉及到

00:36:41.986 --> 00:36:43.686 A:middle
让我来给你们展现一下

00:36:43.686 --> 00:36:44.766 A:middle
这些 API

00:36:45.216 --> 00:36:48.316 A:middle
你将会在你的

00:36:48.316 --> 00:36:49.516 A:middle
App 初始化方法里

00:36:49.516 --> 00:36:50.856 A:middle
创建命令队列

00:36:51.356 --> 00:36:53.246 A:middle
现在 在渲染循环里你将会用到它

00:36:53.246 --> 00:36:55.676 A:middle
去获取命令缓存

00:36:55.676 --> 00:36:57.386 A:middle
这是通过调用它的命令缓存方法来实现的

00:36:57.946 --> 00:37:00.156 A:middle
现在你要把这些命令编译进

00:36:57.946 --> 00:37:00.156 A:middle
现在你要把这些命令编译进

00:37:00.156 --> 00:37:01.156 A:middle
这个命令缓存里

00:37:01.156 --> 00:37:03.086 A:middle
我将会简短地说一下

00:37:03.146 --> 00:37:04.616 A:middle
这个编码器

00:37:05.936 --> 00:37:06.936 A:middle
当你完成编码以后

00:37:06.936 --> 00:37:08.846 A:middle
你需要调用提交方法

00:37:08.846 --> 00:37:11.446 A:middle
来让这个命令缓存

00:37:11.446 --> 00:37:14.366 A:middle
被提交到 GPU 里执行

00:37:14.366 --> 00:37:17.846 A:middle
现在你有两个选择

00:37:17.916 --> 00:37:19.686 A:middle
去决定在这个命令缓存在 GPU 上被执行的时候

00:37:19.686 --> 00:37:21.806 A:middle
应该去做点什么

00:37:22.316 --> 00:37:25.526 A:middle
你可以通过调用这个

00:37:25.526 --> 00:37:27.436 A:middle
waitUntilCompleted 方法来等待

00:37:27.436 --> 00:37:29.256 A:middle
这就像 OpenGL 里边的

00:37:29.256 --> 00:37:29.956 A:middle
glFinish

00:37:30.896 --> 00:37:33.026 A:middle
这个方法会同步等待

00:37:33.026 --> 00:37:35.456 A:middle
并且只在所有命令缓存里的

00:37:35.456 --> 00:37:38.806 A:middle
命令被 GPU 执行完以后才会返回

00:37:40.916 --> 00:37:44.816 A:middle
或者在你提交这个

00:37:44.816 --> 00:37:46.206 A:middle
命令缓存给 GPU 以前

00:37:46.206 --> 00:37:48.566 A:middle
你可以添加一个完成处理器

00:37:49.406 --> 00:37:51.286 A:middle
这个处理器会在 GPU

00:37:51.286 --> 00:37:53.296 A:middle
完成执行以后被调用

00:37:53.946 --> 00:37:56.476 A:middle
这就允许 CPU 和 GPU 去

00:37:56.476 --> 00:37:57.576 A:middle
并行执行

00:37:58.456 --> 00:38:00.486 A:middle
同时这样就允许我们去追踪

00:37:58.456 --> 00:38:00.486 A:middle
同时这样就允许我们去追踪

00:38:00.486 --> 00:38:02.116 A:middle
和有效地更新

00:38:02.116 --> 00:38:04.236 A:middle
在每一帧里都被改变的

00:38:04.236 --> 00:38:05.076 A:middle
分享的资源

00:38:05.556 --> 00:38:08.676 A:middle
既然我们到了这里 我们再来说一说

00:38:08.676 --> 00:38:09.876 A:middle
这些资源的更新

00:38:09.876 --> 00:38:12.486 A:middle
和看一看我们如何

00:38:12.486 --> 00:38:14.656 A:middle
通过完成处理器来让它们更高效

00:38:14.656 --> 00:38:18.626 A:middle
几乎所有的 App 都会在

00:38:18.626 --> 00:38:21.436 A:middle
每一帧将新的数据推送给 GPU

00:38:21.926 --> 00:38:24.206 A:middle
举个例子比如说动画里需要的

00:38:24.316 --> 00:38:25.716 A:middle
新的渲染单元

00:38:26.256 --> 00:38:29.146 A:middle
在 Metal 里 CPU 可以在任意时候

00:38:29.146 --> 00:38:31.776 A:middle
写入这些共享资源

00:38:31.886 --> 00:38:33.966 A:middle
即使 GPU 是在同一时刻访问

00:38:35.206 --> 00:38:36.276 A:middle
同一内存

00:38:37.376 --> 00:38:38.876 A:middle
Metal 并不能保护你不被这些

00:38:38.876 --> 00:38:40.456 A:middle
数据竞争影响

00:38:41.256 --> 00:38:44.176 A:middle
相比之下

00:38:44.176 --> 00:38:45.666 A:middle
OpenGL 默认地会避免这些

00:38:45.666 --> 00:38:48.056 A:middle
数据竞争

00:38:48.056 --> 00:38:50.676 A:middle
要么是等待 GPU 完成工作

00:38:50.676 --> 00:38:53.166 A:middle
要么是制作额外的副本

00:38:53.166 --> 00:38:54.586 A:middle
这样对你的 App 而言 可能并不是

00:38:54.586 --> 00:38:55.376 A:middle
最优选择

00:38:56.256 --> 00:38:58.756 A:middle
通过 Metal 你可以实现任何

00:38:58.756 --> 00:39:01.546 A:middle
最适合你 App 的

00:38:58.756 --> 00:39:01.546 A:middle
最适合你 App 的

00:39:01.546 --> 00:39:03.376 A:middle
优化同步策略

00:39:04.256 --> 00:39:06.966 A:middle
所以在很多情况下

00:39:07.026 --> 00:39:08.686 A:middle
最好的方法是 你分享资源使用的多个缓存

00:39:08.686 --> 00:39:11.706 A:middle
这样的话 CPU 和 GPU

00:39:11.706 --> 00:39:13.286 A:middle
就永远不会同时试图

00:39:13.286 --> 00:39:15.136 A:middle
访问同一个缓存

00:39:17.436 --> 00:39:19.916 A:middle
让我们来看一个例子

00:39:19.916 --> 00:39:22.126 A:middle
你有一个 OpenGL App

00:39:22.126 --> 00:39:24.676 A:middle
并且你刚刚把它移植到 Metal

00:39:24.736 --> 00:39:26.296 A:middle
这个 App 使用的是单个缓存去

00:39:26.296 --> 00:39:28.956 A:middle
更新这些数据并且

00:39:28.956 --> 00:39:30.386 A:middle
你还没有在 App 里

00:39:30.386 --> 00:39:32.766 A:middle
实现任何同步方法

00:39:32.766 --> 00:39:36.356 A:middle
那么 可能发生的事情是

00:39:36.906 --> 00:39:38.316 A:middle
你的 App 会在

00:39:38.316 --> 00:39:39.956 A:middle
生成第一个帧的命令的时候

00:39:39.956 --> 00:39:41.866 A:middle
写进那个缓存里

00:39:41.866 --> 00:39:45.426 A:middle
然后将这个命令缓存提交给 GPU

00:39:45.426 --> 00:39:47.406 A:middle
然后当你的 GPU 在

00:39:47.406 --> 00:39:48.876 A:middle
执行这个命令缓存的时候

00:39:48.876 --> 00:39:49.896 A:middle
会尝试从缓存里读取信息

00:39:50.436 --> 00:39:53.796 A:middle
并且当你在为下一帧

00:39:53.796 --> 00:39:55.446 A:middle
更新同一个缓存的时候

00:39:55.686 --> 00:39:57.816 A:middle
GPU 依旧会从这个缓存里读取

00:39:58.076 --> 00:40:01.266 A:middle
所以这很明显是个

00:39:58.076 --> 00:40:01.266 A:middle
所以这很明显是个

00:40:01.266 --> 00:40:03.806 A:middle
竞争条件并且结果还是未知的

00:40:03.806 --> 00:40:06.826 A:middle
有一些潜在的修复

00:40:07.356 --> 00:40:09.806 A:middle
你可以在你的 App 中实现它们

00:40:10.396 --> 00:40:13.386 A:middle
最简单的方法是在每一帧之后

00:40:13.386 --> 00:40:14.396 A:middle
调用命令缓存里的

00:40:14.396 --> 00:40:17.306 A:middle
waitUntilCompleted 方法

00:40:18.516 --> 00:40:22.556 A:middle
但是这样的话需要等到 GPU

00:40:22.556 --> 00:40:24.246 A:middle
在你为了下一帧重写这一缓存之前

00:40:24.246 --> 00:40:26.296 A:middle
完成读取工作之后

00:40:27.096 --> 00:40:30.936 A:middle
不过就像你看到的

00:40:30.936 --> 00:40:32.866 A:middle
这里 CPU 和 GPU 的利用率都很差

00:40:33.036 --> 00:40:35.606 A:middle
所以这并不是

00:40:35.606 --> 00:40:38.166 A:middle
你想要完成的传输代码

00:40:38.936 --> 00:40:40.756 A:middle
但是如果你想要你的 Metal

00:40:40.756 --> 00:40:42.856 A:middle
App 设置好并跑起来它还是很有用的

00:40:43.746 --> 00:40:45.976 A:middle
甚至如果你的 App

00:40:45.976 --> 00:40:47.766 A:middle
真的有这样的数据冲突

00:40:47.766 --> 00:40:49.716 A:middle
它是能检测出来的

00:40:51.756 --> 00:40:54.366 A:middle
一个高效的方法去同步

00:40:54.366 --> 00:40:55.926 A:middle
你的资源更新是使用

00:40:55.926 --> 00:40:56.826 A:middle
多个缓存

00:40:57.546 --> 00:40:58.906 A:middle
所以在这种情况下我们会用到

00:40:58.956 --> 00:41:00.526 A:middle
三个缓存去更新

00:40:58.956 --> 00:41:00.526 A:middle
三个缓存去更新

00:41:00.526 --> 00:41:02.126 A:middle
我们的动态数据

00:41:02.816 --> 00:41:04.756 A:middle
我们在第一帧里写进缓存

00:41:04.756 --> 00:41:06.846 A:middle
然后之后 GPU 会

00:41:06.846 --> 00:41:07.516 A:middle
从中读取

00:41:08.206 --> 00:41:10.166 A:middle
然后在第二帧里我们为了

00:41:10.166 --> 00:41:11.856 A:middle
避免竞争的情况我们写进

00:41:11.856 --> 00:41:12.666 A:middle
第二个缓存里

00:41:13.326 --> 00:41:15.246 A:middle
类似的我们在第三帧里

00:41:15.246 --> 00:41:18.146 A:middle
写第三个缓存

00:41:18.346 --> 00:41:20.176 A:middle
但是现在我们已经用完了所有

00:41:20.176 --> 00:41:22.406 A:middle
三个缓存并且用尽了我们的缓存池

00:41:23.526 --> 00:41:25.246 A:middle
我们需要等到 GPU

00:41:25.246 --> 00:41:27.166 A:middle
完成第一帧这样我们才能

00:41:27.166 --> 00:41:28.616 A:middle
在第四帧重复使用

00:41:29.186 --> 00:41:33.736 A:middle
现在这个完成处理器就变得

00:41:33.736 --> 00:41:35.906 A:middle
得心应手了

00:41:35.906 --> 00:41:38.046 A:middle
它会让我们知道什么时候 GPU 完成了

00:41:38.096 --> 00:41:38.406 A:middle
这一帧的执行

00:41:39.096 --> 00:41:41.396 A:middle
所以当第一帧完成以后

00:41:41.396 --> 00:41:43.586 A:middle
我们可以在第四帧里重新使用它的缓存

00:41:44.396 --> 00:41:48.696 A:middle
以此类推 所以我们现在来看一个例子

00:41:49.226 --> 00:41:52.916 A:middle
对于你渲染循环外的

00:41:53.326 --> 00:41:55.316 A:middle
三个缓存实现

00:41:55.316 --> 00:41:56.996 A:middle
第一件事是我们会为三个缓存

00:41:57.086 --> 00:41:57.726 A:middle
创建一个 FIFO 队列

00:41:58.286 --> 00:42:01.006 A:middle
同时我们还需要一个

00:41:58.286 --> 00:42:01.006 A:middle
同时我们还需要一个

00:42:01.006 --> 00:42:02.616 A:middle
frameBoundarySemaphore

00:42:02.616 --> 00:42:04.466 A:middle
它在初始化的时候被设置成了 3

00:42:05.096 --> 00:42:06.906 A:middle
所以这就表明信号量

00:42:06.906 --> 00:42:09.276 A:middle
会在每一帧的边缘被测到

00:42:09.576 --> 00:42:11.246 A:middle
就是在 GPU 完成

00:42:11.246 --> 00:42:14.046 A:middle
执行一帧的时候

00:42:14.046 --> 00:42:17.466 A:middle
这允许 CPU 去重复使用它的缓存

00:42:17.466 --> 00:42:19.826 A:middle
同样 初始化缓存索引去

00:42:19.826 --> 00:42:23.466 A:middle
指向当前帧的缓存

00:42:23.806 --> 00:42:26.386 A:middle
而且在你的渲染循环里

00:42:26.386 --> 00:42:28.006 A:middle
在你写进缓存之前我们需要

00:42:28.006 --> 00:42:30.006 A:middle
先确定它的

00:42:30.006 --> 00:42:31.276 A:middle
响应帧已经

00:42:31.326 --> 00:42:33.926 A:middle
在 GPU 上完成了执行

00:42:34.366 --> 00:42:35.836 A:middle
所以在帧的一开始

00:42:36.236 --> 00:42:37.386 A:middle
我们等待

00:42:37.386 --> 00:42:38.656 A:middle
frameBoundarySemaphore

00:42:39.696 --> 00:42:41.386 A:middle
一旦信号量被检测到了

00:42:41.506 --> 00:42:42.786 A:middle
这就表明当前帧

00:42:42.786 --> 00:42:44.166 A:middle
已经完成了它的

00:42:44.166 --> 00:42:46.126 A:middle
GPU 上的执行

00:42:47.536 --> 00:42:50.846 A:middle
所以为了新的一帧的数据

00:42:50.846 --> 00:42:51.716 A:middle
去重复利用缓存是安全的

00:42:52.406 --> 00:42:55.426 A:middle
而且现在我们会编码一些

00:42:55.426 --> 00:42:59.176 A:middle
命令去绑定这个缓存和 GPU

00:42:59.176 --> 00:43:01.186 A:middle
在我们提交这个命令缓存给 GPU 之前

00:42:59.176 --> 00:43:01.186 A:middle
在我们提交这个命令缓存给 GPU 之前

00:43:01.186 --> 00:43:03.066 A:middle
我们会给这一帧添加

00:43:03.066 --> 00:43:05.156 A:middle
一个完成处理器

00:43:05.156 --> 00:43:06.556 A:middle
到命令缓存里

00:43:07.186 --> 00:43:10.066 A:middle
在添加完 完成处理器之后

00:43:10.066 --> 00:43:12.026 A:middle
我们会提交这个命令缓存给 GPU

00:43:12.926 --> 00:43:16.036 A:middle
现在一旦 GPU 完成了

00:43:16.036 --> 00:43:17.806 A:middle
执行这一帧

00:43:17.806 --> 00:43:19.846 A:middle
我们的完成处理器就会被调用

00:43:19.846 --> 00:43:22.006 A:middle
处理器之后就会在这一帧发出信号

00:43:23.766 --> 00:43:26.156 A:middle
这就允许 CPU 去重复使用它的缓存

00:43:26.186 --> 00:43:27.986 A:middle
给新的帧编码

00:43:28.786 --> 00:43:30.666 A:middle
所以这是一个简单的

00:43:30.666 --> 00:43:32.196 A:middle
三缓存实现

00:43:32.196 --> 00:43:33.846 A:middle
你可以用它来执行任何

00:43:33.846 --> 00:43:35.996 A:middle
动态数据的资源更新

00:43:36.476 --> 00:43:39.376 A:middle
现在我们有了命令缓存

00:43:39.376 --> 00:43:41.426 A:middle
同时我们还处理了

00:43:41.726 --> 00:43:44.246 A:middle
资源更新现在我们

00:43:44.246 --> 00:43:46.136 A:middle
来多说一点关于渲染通行编码器

00:43:46.626 --> 00:43:48.306 A:middle
它是你将会在你的绘图请求中

00:43:48.306 --> 00:43:49.796 A:middle
用到的编码

00:43:50.276 --> 00:43:52.496 A:middle
就像 Dan 之前提到的

00:43:52.496 --> 00:43:56.906 A:middle
命令编码器在命令缓存里

00:43:57.146 --> 00:43:59.046 A:middle
将 API 请求转换成

00:43:59.046 --> 00:43:59.926 A:middle
GPU 硬件命令

00:43:59.926 --> 00:44:02.936 A:middle
我将会谈到渲染命令编码器

00:43:59.926 --> 00:44:02.936 A:middle
我将会谈到渲染命令编码器

00:44:02.936 --> 00:44:06.656 A:middle
它提供了一些针对典型图形的 API

00:44:06.816 --> 00:44:08.216 A:middle
一些操作 如设定管道

00:44:08.216 --> 00:44:10.186 A:middle
纹理缓存对象

00:44:10.186 --> 00:44:12.276 A:middle
还有绘图请求

00:44:12.786 --> 00:44:16.816 A:middle
所以当你们创建编码器时

00:44:16.966 --> 00:44:18.906 A:middle
你需要先去设定渲染目标

00:44:18.936 --> 00:44:20.756 A:middle
所以这是个渲染通行描述符

00:44:20.756 --> 00:44:22.396 A:middl
这里你将会设置你的

00:44:22.396 --> 00:44:24.746 A:middle
渲染目标并且在之后请求

00:44:24.746 --> 00:44:26.586 A:middle
命令缓存为了这个渲染通行

00:44:26.586 --> 00:44:28.706 A:middle
去创建一个新的编码器

00:44:29.366 --> 00:44:31.186 A:middle
现在你就可以用这个编码器

00:44:31.186 --> 00:44:33.256 A:middle
去编码你的绘图请求了

00:44:35.136 --> 00:44:37.946 A:middle
跟 OpenGL 不一样的一个地方是

00:44:38.106 --> 00:44:40.666 A:middle
在 Metal 里一旦编码器被创建了

00:44:40.666 --> 00:44:42.736 A:middle
你不能再更改它的渲染目标

00:44:42.736 --> 00:44:45.606 A:middle
因为 GPU 如果看见了一个

00:44:45.696 --> 00:44:47.646 A:middle
巨大的绘图请求跨度

00:44:47.646 --> 00:44:49.776 A:middle
它会表现得好很多

00:44:49.776 --> 00:44:51.436 A:middle
这些请求是去渲染同一个

00:44:51.436 --> 00:44:53.106 A:middle
渲染目标集合

00:44:54.046 --> 00:44:56.906 A:middle
所以 Metal API 通过给渲染通行一个

00:44:57.246 --> 00:44:59.876 A:middle
明确的开始和结束

00:44:59.956 --> 00:45:00.906 A:middle
来反映这一点

00:44:59.956 --> 00:45:00.906 A:middle
来反映这一点

00:45:01.316 --> 00:45:03.636 A:middle
现在这个编码器给出的所有绘图请求

00:45:03.636 --> 00:45:05.596 A:middle
会渲染进

00:45:05.596 --> 00:45:06.936 A:middle
这些渲染目标里

00:45:08.566 --> 00:45:09.816 A:middle
当你想要向不同的渲染目标

00:45:09.816 --> 00:45:11.406 A:middle
绘图的时候

00:45:11.576 --> 00:45:13.246 A:middle
你可以结束这个渲染通行

00:45:13.246 --> 00:45:14.226 A:middle
然后开启一个新的

00:45:14.756 --> 00:45:18.936 A:middle
这就是我们创建

00:45:18.936 --> 00:45:20.286 A:middle
一个渲染通行描述符

00:45:20.286 --> 00:45:23.876 A:middle
并且绑定颜色和深度关系的地方

00:45:25.166 --> 00:45:27.036 A:middle
现在你可以使用那个描述符

00:45:27.086 --> 00:45:29.716 A:middle
并且创建一个渲染命令编码器

00:45:30.436 --> 00:45:33.116 A:middle
现在所有由这个编码器发出的图画

00:45:33.116 --> 00:45:34.966 A:middle
都会被渲染到这些目标

00:45:37.216 --> 00:45:39.426 A:middle
另外在 Metal 里

00:45:39.426 --> 00:45:41.856 A:middle
你也可以为这些附件提供

00:45:41.856 --> 00:45:43.546 A:middle
加载和存储行为

00:45:43.786 --> 00:45:46.126 A:middle
这是为了优化 GPU 的带宽用量

00:45:48.236 --> 00:45:50.076 A:middle
所以这些加载和存储的行为

00:45:50.076 --> 00:45:52.086 A:middle
允许你去控制

00:45:52.086 --> 00:45:53.796 A:middle
纹理内容会在渲染通行

00:45:53.956 --> 00:45:55.876 A:middle
之前和之后被怎样处理

00:45:56.266 --> 00:45:59.016 A:middle
现在我们有了为渲染通行产生的

00:45:59.016 --> 00:46:01.856 A:middle
颜色和深度附属品

00:45:59.016 --> 00:46:01.856 A:middle
颜色和深度附属品

00:46:02.066 --> 00:46:03.856 A:middle
如果它清晰地为两个

00:46:03.856 --> 00:46:05.906 A:middle
渲染目标指定了加载行为

00:46:05.906 --> 00:46:08.346 A:middle
GPU 就会首先

00:46:08.386 --> 00:46:09.836 A:middle
清除它们的内容

00:46:10.266 --> 00:46:13.246 A:middle
之后 GPU 会在这个编码器中

00:46:13.246 --> 00:46:14.556 A:middle
执行命令

00:46:14.556 --> 00:46:16.346 A:middle
来渲染这些渲染目标

00:46:16.886 --> 00:46:19.616 A:middle
现在你可以指定

00:46:19.616 --> 00:46:21.026 A:middle
在渲染通行的末尾

00:46:21.136 --> 00:46:22.176 A:middle
进行的存储行为

00:46:22.536 --> 00:46:24.486 A:middle
这里对于颜色缓存来说

00:46:24.486 --> 00:46:25.996 A:middle
介于存储行为被存储起来了

00:46:25.996 --> 00:46:28.656 A:middle
它会在渲染通行

00:46:28.686 --> 00:46:30.966 A:middle
的最后保留颜色缓存的内容

00:46:31.576 --> 00:46:33.006 A:middle
然后对于深度附件来说

00:46:33.006 --> 00:46:35.286 A:middle
因为我们说了存储行为是不关心的

00:46:35.286 --> 00:46:37.786 A:middle
所以它会放弃它的内容

00:46:39.006 --> 00:46:40.876 A:middle
所以这些纹理加载和存储

00:46:40.876 --> 00:46:42.806 A:middle
是非常昂贵的

00:46:42.806 --> 00:46:44.376 A:middle
消耗内存带宽的操作

00:46:44.946 --> 00:46:47.346 A:middle
所以慎重地选择并且不要关心

00:46:47.346 --> 00:46:48.416 A:middle
是不是可能

00:46:48.976 --> 00:46:52.246 A:middle
那么这就是你怎么设定你行为的过程

00:46:52.526 --> 00:46:54.876 A:middle
在这个例子里我们指定了清除为

00:46:54.876 --> 00:46:57.966 A:middle
加载行为并且设定了清除颜色

00:46:59.186 --> 00:47:01.236 A:middle
然后这里我们指定了存储行为为存储

00:46:59.186 --> 00:47:01.236 A:middle
然后这里我们指定了存储行为为存储

00:47:01.806 --> 00:47:03.656 A:middle
相似的你可以为每一个渲染目标

00:47:03.656 --> 00:47:05.636 A:middle
指定加载和存储行为

00:47:05.636 --> 00:47:07.196 A:middle
这些渲染目标是你设定在

00:47:07.196 --> 00:47:08.326 A:middle
渲染通行描述符里的

00:47:08.926 --> 00:47:11.936 A:middle
所以这就是我们如何配置我们的

00:47:11.936 --> 00:47:12.896 A:middle
渲染目标

00:47:12.946 --> 00:47:16.596 A:middle
现在你可以从这个描述符

00:47:16.596 --> 00:47:19.076 A:middle
创建编码器

00:47:19.076 --> 00:47:20.526 A:middle
然后我们就可以开始编码绘图请求了

00:47:21.886 --> 00:47:23.606 A:middle
但是在这之前我想给你们展现

00:47:23.606 --> 00:47:25.756 A:middle
一些 OpenGL 命令

00:47:25.756 --> 00:47:27.326 A:middle
然后它们会向你们展现它们的

00:47:27.326 --> 00:47:28.146 A:middle
Metal 等价表示

00:47:28.686 --> 00:47:32.626 A:middle
这就是典型 OpenGL 绘图序列

00:47:33.156 --> 00:47:36.526 A:middle
在这个分片里我们先绑定一个

00:47:36.526 --> 00:47:38.776 A:middle
会设定所有渲染目标的

00:47:38.776 --> 00:47:39.826 A:middle
帧缓存器

00:47:41.096 --> 00:47:42.966 A:middle
然后我们绑定我们的程序

00:47:42.966 --> 00:47:45.676 A:middle
程序内包含了顶点和分片着色器

00:47:46.226 --> 00:47:48.206 A:middle
然后我们绑定带有顶点数据的

00:47:48.206 --> 00:47:49.676 A:middle
顶点缓存器

00:47:50.136 --> 00:47:53.036 A:middle
之后我们再绑定另一个

00:47:53.036 --> 00:47:54.576 A:middle
含有所有标准数据的缓存器

00:47:55.416 --> 00:47:57.686 A:middle
再然后我们就会设定一个

00:47:57.686 --> 00:47:58.536 A:middle
被采样的纹理

00:47:59.776 --> 00:48:00.916 A:middle
最后绘图

00:47:59.776 --> 00:48:00.916 A:middle
最后绘图

00:48:01.546 --> 00:48:03.956 A:middle
所以这就是 Metal 的等价操作

00:48:04.566 --> 00:48:05.956 A:middle
这会稍微多出几行代码

00:48:05.996 --> 00:48:07.936 A:middle
因为它是明确的但是它

00:48:07.936 --> 00:48:09.766 A:middle
和 OpenGL 非常类似

00:48:10.586 --> 00:48:11.866 A:middle
首先我们用渲染通行描述符

00:48:11.866 --> 00:48:13.336 A:middle
创建一个渲染命令编码器

00:48:13.336 --> 00:48:15.456 A:middle
这个描述符含有我们的

00:48:15.456 --> 00:48:16.346 A:middle
渲染目标

00:48:17.696 --> 00:48:19.296 A:middle
然后我们设定含有

00:48:19.296 --> 00:48:20.506 A:middle
着色器的管道对象

00:48:21.836 --> 00:48:24.606 A:middle
然后我们再去设定缓存器

00:48:24.606 --> 00:48:26.276 A:middle
去访问顶点着色器

00:48:26.676 --> 00:48:27.836 A:middle
同时它还含有我们要画的

00:48:27.836 --> 00:48:29.226 A:middle
图像的顶点

00:48:30.436 --> 00:48:32.316 A:middle
值得注意的是 Metal 并不会

00:48:32.316 --> 00:48:33.846 A:middle
区别包含标准数据

00:48:33.846 --> 00:48:36.026 A:middle
的缓存器和那些

00:48:36.026 --> 00:48:37.176 A:middle
包含顶点的缓存器

00:48:37.816 --> 00:48:40.276 A:middle
所以我们会用相同的 API

00:48:40.276 --> 00:48:41.386 A:middle
去设置标准缓存

00:48:41.386 --> 00:48:44.026 A:middle
所以这里第一个请求会给

00:48:44.026 --> 00:48:46.026 A:middle
缓存器访问顶点着色器的权限

00:48:46.026 --> 00:48:47.236 A:middle
第二个请求会给出访问

00:48:47.236 --> 00:48:48.746 A:middle
分片着色器的权限

00:48:49.286 --> 00:48:52.166 A:middle
接下来我们为要去采样的

00:48:52.166 --> 00:48:54.026 A:middle
分片着色器设定纹理

00:48:54.516 --> 00:48:56.556 A:middle
然后绘图

00:48:57.076 --> 00:48:59.846 A:middle
一旦我们完成了编码命令

00:48:59.846 --> 00:49:01.456 A:middle
我们会通过在编码对象上

00:48:59.846 --> 00:49:01.456 A:middle
我们会通过在编码对象上

00:49:01.456 --> 00:49:03.396 A:middle
调用 endEncoding 向 Metal

00:49:03.396 --> 00:49:05.376 A:middle
指出这些

00:49:06.196 --> 00:49:07.916 A:middle
所以这就是一个简单的

00:49:07.916 --> 00:49:09.406 A:middle
Metal 渲染通行的例子

00:49:09.926 --> 00:49:12.926 A:middle
现在我们已经有了一个完整的渲染通行

00:49:12.926 --> 00:49:14.696 A:middle
我们再来看看怎样去

00:49:14.696 --> 00:49:16.806 A:middle
让这些渲染表现出来

00:49:17.336 --> 00:49:21.526 A:middle
通过 OpenGl 你将你的渲染帧

00:49:21.526 --> 00:49:23.156 A:middle
展现到屏幕上

00:49:23.436 --> 00:49:25.336 A:middle
但是你并没有明确地管理

00:49:25.336 --> 00:49:27.996 A:middle
系统的渲染缓存

00:49:27.996 --> 00:49:29.006 A:middle
依旧被设定为 drawable

00:49:30.336 --> 00:49:32.126 A:middle
但是要是通过 Metal 将你的

00:49:32.126 --> 00:49:34.476 A:middle
内容显示在屏幕上

00:49:34.906 --> 00:49:36.186 A:middle
首先你需要确认包含特殊的纹理

00:49:36.186 --> 00:49:37.516 A:middle
这种特殊纹理在系统里

00:49:37.516 --> 00:49:39.116 A:middle
被称为 drawable

00:49:39.746 --> 00:49:41.676 A:middle
所以你可以使用 MetalKit 视图

00:49:41.816 --> 00:49:42.756 A:middle
MetalKit 视图提供了每一帧中的

00:49:42.756 --> 00:49:44.846 A:middle
drawable 纹理

00:49:45.426 --> 00:49:46.886 A:middle
然后一旦你获得这个 drawable

00:49:46.886 --> 00:49:49.276 A:middle
你就可以编码渲染通行

00:49:49.276 --> 00:49:51.226 A:middle
并且渲染到这些

00:49:51.226 --> 00:49:53.096 A:middle
drawable 就像你

00:49:53.096 --> 00:49:54.586 A:middle
渲染到任意其他一个纹理一样

00:49:55.126 --> 00:49:57.766 A:middle
然而并不像其他纹理一样

00:49:57.766 --> 00:49:59.976 A:middle
现在你可以将这个 drawable 展现出来

00:50:00.096 --> 00:50:02.996 A:middle
那么让我来给你们展示一下代码例子

00:50:03.516 --> 00:50:06.196 A:middle
首先我需要说一下

00:50:06.196 --> 00:50:07.886 A:middle
这些 drawable 受限于你的

00:50:08.166 --> 00:50:10.696 A:middle
着色器系统资源

00:50:10.696 --> 00:50:12.206 A:middle
所以你应该尽可能简单

00:50:12.206 --> 00:50:13.536 A:middle
地处理他们

00:50:14.236 --> 00:50:15.776 A:middle
这代表着你应该

00:50:15.776 --> 00:50:18.096 A:middle
在你获取 drawable 以前编码

00:50:18.126 --> 00:50:20.606 A:middle
所有的离线渲染通行

00:50:21.906 --> 00:50:23.626 A:middle
之后你可以创建一个 MetalKit 视图

00:50:23.626 --> 00:50:26.856 A:middle
不但可以去看一个完整的

00:50:26.856 --> 00:50:29.206 A:middle
填充渲染通行描述符

00:50:29.466 --> 00:50:30.926 A:middle
这个描述符你可以直接用来

00:50:30.926 --> 00:50:33.836 A:middle
创建编码器 就是这里你们看到的这个

00:50:33.836 --> 00:50:36.336 A:middle
同时你还可以通过

00:50:36.336 --> 00:50:37.746 A:middle
view.currentDrawable 属性

00:50:37.976 --> 00:50:41.626 A:middle
请求指定的纹理

00:50:41.626 --> 00:50:42.706 A:middle
之后你可以围绕它创建你自己的

00:50:42.706 --> 00:50:45.086 A:middle
渲染通行描述符

00:50:47.136 --> 00:50:48.846 A:middle
一旦你完成了编码你的帧

00:50:48.846 --> 00:50:50.496 A:middle
你可以调用

00:50:50.496 --> 00:50:51.896 A:middle
现有的命令缓存中的

00:50:51.896 --> 00:50:53.456 A:middle
drawable 方法

00:50:53.456 --> 00:50:55.626 A:middle
这在 GPU 完成执行命令换内存后

00:50:55.626 --> 00:50:58.166 A:middle
将你的 drawable 输出到屏幕上

00:50:58.986 --> 00:51:00.946 A:middle
所以一旦 GPU 完成了

00:50:58.986 --> 00:51:00.946 A:middle
所以一旦 GPU 完成了

00:51:00.946 --> 00:51:02.586 A:middle
执行这一帧

00:51:02.586 --> 00:51:04.116 A:middle
你就可以在显示上看到这一帧

00:51:04.646 --> 00:51:07.606 A:middle
这样的话通过 Metal

00:51:07.606 --> 00:51:09.286 A:middle
将你的渲染展现出来

00:51:09.286 --> 00:51:10.596 A:middle
就变得相当的快了

00:51:11.156 --> 00:51:14.166 A:middle
但是我还有几个小建议与你们分享

00:51:15.366 --> 00:51:17.296 A:middle
将一个渲染器

00:51:17.966 --> 00:51:19.936 A:middle
传递到 Metal 是可行的

00:51:19.936 --> 00:51:21.436 A:middle
IOSurface 和 CVPixelBuffer

00:51:21.436 --> 00:51:25.696 A:middle
API 可以被用来创建纹理

00:51:25.726 --> 00:51:27.596 A:middle
这个纹理可以在

00:51:27.596 --> 00:51:29.266 A:middle
OpenGL 和 Metal 之间共享

00:51:30.376 --> 00:51:32.586 A:middle
这就允许你在 OpenGL 里面

00:51:32.586 --> 00:51:34.596 A:middle
渲染一个纹理

00:51:34.596 --> 00:51:36.746 A:middle
然后从 Metal 里读取

00:51:36.746 --> 00:51:36.926 A:middle
反之亦然

00:51:36.926 --> 00:51:39.876 A:middle
所以一些 App 可以

00:51:39.876 --> 00:51:41.616 A:middle
利用这一点去

00:51:41.616 --> 00:51:43.476 A:middle
逐步移植

00:51:43.756 --> 00:51:45.076 A:middle
特别是当存在搭建在 OpenGL 里的

00:51:45.076 --> 00:51:46.466 A:middle
插件结构的时候

00:51:47.206 --> 00:51:49.546 A:middle
所以这里有一个关联到这个会话的

00:51:49.686 --> 00:51:51.796 A:middle
示例代码准确地展现了

00:51:51.796 --> 00:51:52.846 A:middle
如何做到这一点

00:51:55.416 --> 00:51:56.796 A:middle
现在你已经有了一个 Metal App

00:51:56.796 --> 00:51:58.806 A:middle
你可以采用所有

00:51:58.806 --> 00:51:59.906 A:middle
新的 Metal 特性

00:52:01.076 --> 00:52:03.046 A:middle
如果你的 App 是与 CPU 绑定的

00:52:03.046 --> 00:52:05.436 A:middle
那么使你的 CPU 编码多线程工作

00:52:05.436 --> 00:52:07.006 A:middle
会很有用

00:52:07.746 --> 00:52:09.636 A:middle
你可以在不同线程上

00:52:09.636 --> 00:52:11.316 A:middle
同时编码多个

00:52:11.316 --> 00:52:12.346 A:middle
命令缓存

00:52:12.926 --> 00:52:14.776 A:middle
你甚至可以将一个单独的命令缓存

00:52:14.776 --> 00:52:16.556 A:middle
拆分编码到

00:52:16.556 --> 00:52:18.346 A:middle
多个线程中

00:52:18.346 --> 00:52:18.976 A:middle
这是通过使用并行渲染命令编码器实现的

00:52:25.046 --> 00:52:26.926 A:middle
同样的通过计划处理

00:52:26.926 --> 00:52:30.186 A:middle
API 来做的 GPU 计算内置于 Metal 中

00:52:30.776 --> 00:52:33.536 A:middle
你可以用全新的方法去使用 GPU

00:52:34.046 --> 00:52:36.666 A:middle
不用 CPU 去开始的话

00:52:36.666 --> 00:52:38.976 A:middle
你可以利用计算管道来

00:52:38.976 --> 00:52:40.746 A:middle
生成图像的 GPU 数据

00:52:41.336 --> 00:52:43.616 A:middle
通过让 GPU 去生成它自己的数据

00:52:43.616 --> 00:52:45.346 A:middle
你不但可以

00:52:45.346 --> 00:52:47.846 A:middle
减少 CPU 的利用率和同步率

00:52:47.846 --> 00:52:49.776 A:middle
同时你还可以

00:52:49.776 --> 00:52:50.796 A:middle
自由地决定数据对于 GPU

00:52:50.796 --> 00:52:52.106 A:middle
所需的带宽

00:52:53.176 --> 00:52:54.946 A:middle
现在通过这个高带宽

00:52:55.246 --> 00:52:56.846 A:middle
计算处理器你可以

00:52:56.846 --> 00:52:58.456 A:middle
实现更多更复杂的

00:52:58.456 --> 00:52:58.966 A:middle
算法 就像这些

00:53:03.356 --> 00:53:05.256 A:middle
Metal 支持很多很强大的特性

00:53:05.296 --> 00:53:07.216 A:middle
这些功能你可以用到

00:53:07.216 --> 00:53:09.706 A:middle
你的 App 里来提高其自身的性能

00:53:10.256 --> 00:53:13.556 A:middle
此外作为你移植过程的一部分

00:53:13.596 --> 00:53:15.186 A:middle
我们强烈地鼓励你

00:53:15.186 --> 00:53:17.406 A:middle
去使用我们的 Metal

00:53:17.406 --> 00:53:19.096 A:middle
的极其强大的调试和

00:53:19.096 --> 00:53:21.226 A:middle
优化工具

00:53:21.256 --> 00:53:23.456 A:middle
它们都被集合在了 Xcode 里

00:53:24.446 --> 00:53:26.476 A:middle
所以 Metal 有一个很强大的 API

00:53:26.476 --> 00:53:28.536 A:middle
验证层来表明

00:53:28.796 --> 00:53:30.816 A:middle
任何不正常的 API 用量

00:53:30.816 --> 00:53:33.176 A:middle
的细节信息

00:53:33.176 --> 00:53:34.756 A:middle
同时也会给出一些可能的修复策略

00:53:36.316 --> 00:53:38.826 A:middle
这是一个可以让你

00:53:38.826 --> 00:53:40.536 A:middle
一步一步进行 Metal

00:53:40.596 --> 00:53:42.706 A:middle
的调用和

00:53:42.706 --> 00:53:44.466 A:middle
一步一步看到你的帧是如何被渲染的

00:53:44.466 --> 00:53:45.816 A:middle
GPU 调试器

00:53:46.726 --> 00:53:48.796 A:middle
你可以看到和你的帧

00:53:48.796 --> 00:53:50.246 A:middle
一起出现的所有资源

00:53:50.926 --> 00:53:53.116 A:middle
它也基于资源的用量

00:53:53.166 --> 00:53:55.036 A:middle
给 GPU 提供了专业的建议

00:53:55.586 --> 00:53:58.916 A:middle
今年我们还添加了

00:53:58.916 --> 00:54:00.556 A:middle
着色器调试器

00:53:58.916 --> 00:54:00.556 A:middle
着色器调试器

00:54:00.916 --> 00:54:02.326 A:middle
这样你可以调试你的着色器方法

00:54:02.326 --> 00:54:04.006 A:middle
就像其他的函数一样

00:54:04.516 --> 00:54:07.686 A:middle
我们还添加了着色器分析器

00:54:07.956 --> 00:54:09.646 A:middle
它会显示一个

00:54:09.646 --> 00:54:11.266 A:middle
与你的着色器有关的

00:54:11.266 --> 00:54:11.936 A:middle
性能矩阵集合

00:54:12.046 --> 00:54:15.556 A:middle
同时还有一个依赖观察器

00:54:15.556 --> 00:54:17.156 A:middle
让你能评判

00:54:17.156 --> 00:54:18.626 A:middle
渲染通行的依赖关系

00:54:18.626 --> 00:54:22.096 A:middle
你也可以潜在的

00:54:22.096 --> 00:54:24.336 A:middle
合并任何多余的渲染通行

00:54:24.336 --> 00:54:26.726 A:middle
以此来提高你的

00:54:26.726 --> 00:54:27.976 A:middle
App 的性能

00:54:30.216 --> 00:54:32.166 A:middle
最后 在instruments 里的

00:54:32.166 --> 00:54:33.966 A:middle
Metal 系统追踪工具

00:54:33.966 --> 00:54:36.696 A:middle
会给你展现一个完整的

00:54:36.736 --> 00:54:38.486 A:middle
App 表现和性能

00:54:38.486 --> 00:54:40.276 A:middle
所以我们强烈建议你

00:54:40.276 --> 00:54:42.396 A:middle
使用这些工具去

00:54:42.396 --> 00:54:44.146 A:middle
简化你的移植工作量

00:54:45.296 --> 00:54:47.906 A:middle
将它打包起来

00:54:47.906 --> 00:54:49.536 A:middle
OpenGL 和 OpenCL 已经被放弃了

00:54:49.536 --> 00:54:52.656 A:middle
但是它们依旧在

00:54:52.656 --> 00:54:54.466 A:middle
我们很担忧它们的未来使用率

00:54:54.826 --> 00:54:56.526 A:middle
现在是时候接受 Metal 了

00:54:57.216 --> 00:54:59.106 A:middle
我们有一整套的开发者工具

00:54:59.106 --> 00:55:00.806 A:middle
很多经验来

00:54:59.106 --> 00:55:00.806 A:middle
很多经验来

00:55:00.806 --> 00:55:02.896 A:middle
帮助开发团队成功地

00:55:02.896 --> 00:55:04.616 A:middle
完成了这项工作

00:55:04.616 --> 00:55:07.006 A:middle
并且大幅提高了性能

00:55:07.736 --> 00:55:09.236 A:middle
我希望我今天分享的信息

00:55:09.236 --> 00:55:10.846 A:middle
可以给予你们

00:55:10.846 --> 00:55:12.356 A:middle
顺利移植地经验

00:55:12.866 --> 00:55:15.846 A:middle
同时我们也很愿意与你们沟通

00:55:15.846 --> 00:55:17.376 A:middle
谈一谈你们的 App 和

00:55:17.376 --> 00:55:19.406 A:middle
你们如何通过 Metal 让他们运行的

00:55:20.006 --> 00:55:21.776 A:middle
所以明天下午我们将

00:55:21.776 --> 00:55:23.506 A:middle
在 OpenGL 到 Metal 移植实验室里

00:55:23.666 --> 00:55:25.736 A:middle
介时会有很多

00:55:25.736 --> 00:55:27.696 A:middle
关于 Metal 的会议

00:55:28.006 --> 00:55:29.426 A:middle
我建议你们来参加这些会议

00:55:29.426 --> 00:55:31.546 A:middle
可以学到很多关于

00:55:31.546 --> 00:55:33.106 A:middle
如何利用 Metal 去调试和

00:55:33.106 --> 00:55:34.466 A:middle
优化你的 App 的方法

00:55:36.106 --> 00:55:37.866 A:middle
在此感谢大家参与这次会议

00:55:37.866 --> 00:55:39.706 A:middle
希望你们能享受这一周

00:55:39.706 --> 00:55:40.716 A:middle
剩下的时光

00:55:41.516 --> 00:55:44.500 A:middle
[ 掌声 ]
