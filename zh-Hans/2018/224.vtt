WEBVTT

00:00:07.016 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:21.416 --> 00:00:21.976 A:middle
&gt;&gt; 大家下午好

00:00:22.516 --> 00:00:27.406 A:middle
[ 掌声 ]

00:00:27.906 --> 00:00:29.096 A:middle
欢迎来到

00:00:29.096 --> 00:00:29.806 A:middle
核心数据最佳实践

00:00:29.926 --> 00:00:30.886 A:middle
我叫 Scott Perry

00:00:30.886 --> 00:00:32.016 A:middle
在核心数据工作

00:00:32.466 --> 00:00:33.776 A:middle
一会儿也会请到我的同事

00:00:33.776 --> 00:00:35.016 A:middle
Nick Gillett 加入

00:00:36.516 --> 00:00:39.286 A:middle
今天我们计划

00:00:39.286 --> 00:00:40.886 A:middle
首先从核心数据是如何

00:00:40.886 --> 00:00:41.866 A:middle
随着时间的推移

00:00:41.866 --> 00:00:43.216 A:middle
进行优化开始讲起

00:00:43.956 --> 00:00:45.946 A:middle
然后我们将讲到一些

00:00:45.946 --> 00:00:47.346 A:middle
通过利用持久化容器

00:00:47.346 --> 00:00:48.706 A:middle
里的扩展点

00:00:48.706 --> 00:00:49.886 A:middle
来更简单地

00:00:49.886 --> 00:00:50.836 A:middle
优化 App 的方法

00:00:51.486 --> 00:00:53.556 A:middle
接着会介绍

00:00:53.556 --> 00:00:55.026 A:middle
当 App 的要求发生变化

00:00:55.026 --> 00:00:56.676 A:middle
以及数据量增大时

00:00:56.676 --> 00:00:57.236 A:middle
该如何优化我们的 App

00:00:59.106 --> 00:01:00.666 A:middle
随后 Nick 将谈到

00:00:59.106 --> 00:01:00.666 A:middle
随后 Nick 将谈到

00:01:00.666 --> 00:01:01.946 A:middle
几种使我们的 App

00:01:01.946 --> 00:01:03.226 A:middle
保持性能的方法

00:01:03.226 --> 00:01:04.726 A:middle
即使它超过了我们的想象

00:01:04.726 --> 00:01:07.666 A:middle
最后我们将用

00:01:08.406 --> 00:01:09.196 A:middle
转换器

00:01:09.196 --> 00:01:11.046 A:middle
调试和测试来收尾

00:01:11.586 --> 00:01:15.976 A:middle
但是首先 我们先创建一个 App

00:01:15.976 --> 00:01:17.716 A:middle
我很喜欢拍照 我们

00:01:17.716 --> 00:01:18.416 A:middle
创建一个能让我

00:01:18.416 --> 00:01:19.486 A:middle
和朋友们分享照片

00:01:19.486 --> 00:01:21.746 A:middle
并得到反馈的 App

00:01:21.746 --> 00:01:22.946 A:middle
即使只是 Nick 在问

00:01:22.946 --> 00:01:25.316 A:middle
我的幻灯片放得怎么样

00:01:26.236 --> 00:01:28.406 A:middle
我们该如何保留 App 的数据呢

00:01:28.586 --> 00:01:30.016 A:middle
我们可以将它存在网上

00:01:30.016 --> 00:01:31.456 A:middle
但是我通常都

00:01:31.456 --> 00:01:32.776 A:middle
在旅行时拍照

00:01:32.776 --> 00:01:33.696 A:middle
网络连接可能会不稳定

00:01:33.696 --> 00:01:35.756 A:middle
我们需要存在本地

00:01:35.756 --> 00:01:37.736 A:middle
将它整合进存储器里

00:01:40.296 --> 00:01:42.596 A:middle
我们现在有贴文 评论

00:01:42.596 --> 00:01:44.006 A:middle
以及它们的实例

00:01:44.006 --> 00:01:45.606 A:middle
二者之间的关系形成了一个

00:01:45.606 --> 00:01:47.386 A:middle
对象图

00:01:47.386 --> 00:01:48.846 A:middle
我们决定将它们保存在

00:01:48.846 --> 00:01:52.316 A:middle
磁盘上

00:01:52.316 --> 00:01:53.096 A:middle
这就该核心数据上场了

00:01:56.006 --> 00:01:57.236 A:middle
我们将使用它

00:01:57.236 --> 00:01:59.166 A:middle
将模型转化为

00:01:59.216 --> 00:02:01.006 A:middle
存储器

00:01:59.216 --> 00:02:01.006 A:middle
存储器

00:02:01.006 --> 00:02:02.606 A:middle
能够理解的托管项目模型

00:02:03.616 --> 00:02:04.276 A:middle
所有东西都需要字段

00:02:04.276 --> 00:02:05.816 A:middle
比如图片的属性

00:02:05.816 --> 00:02:07.406 A:middle
比如图像数据

00:02:07.406 --> 00:02:08.606 A:middle
和发布时间

00:02:09.076 --> 00:02:11.266 A:middle
此外我们还需要

00:02:11.266 --> 00:02:12.236 A:middle
贴文和评论间的关系

00:02:12.596 --> 00:02:14.066 A:middle
我们已经定义了

00:02:14.066 --> 00:02:15.446 A:middle
存储器的需求

00:02:15.446 --> 00:02:17.366 A:middle
但是随着时间的推移

00:02:17.366 --> 00:02:18.156 A:middle
数据的维护涉及到很多工作

00:02:19.056 --> 00:02:20.386 A:middle
幸运的是核心数据提供了一个

00:02:20.386 --> 00:02:21.956 A:middle
持久化存储协调器

00:02:21.956 --> 00:02:22.546 A:middle
来进行管理

00:02:22.986 --> 00:02:24.836 A:middle
这个协调器可以处理例如

00:02:24.836 --> 00:02:26.246 A:middle
与存储器的模型版本

00:02:26.246 --> 00:02:27.806 A:middle
对比 App 模型

00:02:27.806 --> 00:02:29.276 A:middle
并随着 App 的优化

00:02:29.276 --> 00:02:30.306 A:middle
进行自动迁移

00:02:30.786 --> 00:02:32.916 A:middle
最终托管对象上下文 会对我们的数据

00:02:32.916 --> 00:02:34.436 A:middle
提供安全快捷

00:02:34.436 --> 00:02:35.936 A:middle
且可预测的访问权限

00:02:36.616 --> 00:02:37.826 A:middle
即便我们

00:02:37.826 --> 00:02:39.426 A:middle
同时使用很多功能

00:02:39.426 --> 00:02:40.636 A:middle
例如查询生成

00:02:40.716 --> 00:02:41.896 A:middle
连接池以及

00:02:41.896 --> 00:02:42.376 A:middle
历史跟踪

00:02:44.236 --> 00:02:46.486 A:middle
设置这些要求

00:02:46.566 --> 00:02:47.736 A:middle
找到模型 进行加载

00:02:47.736 --> 00:02:49.236 A:middle
然后决定如何保存存储器

00:02:49.236 --> 00:02:51.186 A:middle
但是很多错误路径

00:02:51.186 --> 00:02:53.026 A:middle
在你迁移 App 之后

00:02:53.026 --> 00:02:54.816 A:middle
并不会失败

00:02:54.816 --> 00:02:56.246 A:middle
因此核心数据提供了一个容器类型

00:02:56.576 --> 00:02:57.716 A:middle
能极大的降低

00:02:57.716 --> 00:02:58.946 A:middle
你在设置堆栈时所需的样板文件

00:02:58.946 --> 00:03:00.736 A:middle
只需要按名称引用模型

00:02:58.946 --> 00:03:00.736 A:middle
只需要按名称引用模型

00:03:00.736 --> 00:03:03.486 A:middle
然后持久化容器将

00:03:03.486 --> 00:03:05.046 A:middle
从主束中加载它 并将它

00:03:05.046 --> 00:03:06.766 A:middle
储存在持久化的位置

00:03:07.306 --> 00:03:10.386 A:middle
这种持久化容器类型

00:03:10.386 --> 00:03:11.926 A:middle
囊括了一整个堆栈以及

00:03:11.926 --> 00:03:13.526 A:middle
共享主队列视图上下文的

00:03:13.526 --> 00:03:15.256 A:middle
便利构造函数和

00:03:15.806 --> 00:03:17.926 A:middle
用于生成

00:03:18.246 --> 00:03:20.286 A:middle
背景语上下文的工厂方法

00:03:20.286 --> 00:03:21.676 A:middle
以及执行后台工作

00:03:22.426 --> 00:03:23.796 A:middle
在我们的 App 扩展的同时

00:03:23.796 --> 00:03:25.366 A:middle
它同样易于操作

00:03:25.776 --> 00:03:27.706 A:middle
举个例子 要将我们的

00:03:27.706 --> 00:03:29.956 A:middle
模型层纳入到它自己的框架中

00:03:30.836 --> 00:03:31.856 A:middle
我们可以通过在 Xcode 里

00:03:31.856 --> 00:03:33.166 A:middle
创建一个新的框架目标然后将

00:03:33.166 --> 00:03:34.116 A:middle
我们的代码移动进去

00:03:34.446 --> 00:03:36.166 A:middle
这都非常简单 但是当我们将

00:03:36.166 --> 00:03:37.116 A:middle
我们的模型移动到新的目标时

00:03:37.116 --> 00:03:38.836 A:middle
在已构建的产品中

00:03:38.836 --> 00:03:40.836 A:middle
目标从 App 移动到了新的框架

00:03:40.836 --> 00:03:42.736 A:middle
本应如此

00:03:42.736 --> 00:03:43.806 A:middle
但是现在

00:03:43.806 --> 00:03:45.246 A:middle
NSPersistentContainer 不知道

00:03:45.436 --> 00:03:46.896 A:middle
在哪才能找到我们的模型

00:03:47.476 --> 00:03:48.566 A:middle
这是因为 默认下

00:03:48.566 --> 00:03:49.846 A:middle
它只会检查主束

00:03:50.416 --> 00:03:51.056 A:middle
为什么停在那里呢

00:03:51.806 --> 00:03:53.296 A:middle
因为检索 App 里所有束

00:03:53.296 --> 00:03:54.826 A:middle
会非常缓慢

00:03:54.826 --> 00:03:56.526 A:middle
你不会希望每次

00:03:56.526 --> 00:03:57.816 A:middle
加速堆栈的时候

00:03:57.816 --> 00:03:58.866 A:middle
都花好长时间

00:04:00.206 --> 00:04:01.506 A:middle
如何修复呢

00:04:02.666 --> 00:04:03.926 A:middle
我们可以自己

00:04:03.926 --> 00:04:05.206 A:middle
在框架束外恢复这个模型

00:04:05.206 --> 00:04:06.766 A:middle
然后使用

00:04:06.766 --> 00:04:07.456 A:middle
容器的其他初始化 App

00:04:07.456 --> 00:04:08.666 A:middle
比如那个使用

00:04:08.736 --> 00:04:10.606 A:middle
显式托管对象模型的 App

00:04:10.606 --> 00:04:12.986 A:middle
但是事实上 NSPersistentContainer

00:04:12.986 --> 00:04:14.486 A:middle
提供了一种更改

00:04:14.486 --> 00:04:16.036 A:middle
检索对象的方法

00:04:17.856 --> 00:04:19.856 A:middle
看 NSPersistentContainer 知道

00:04:19.856 --> 00:04:21.086 A:middle
它什么时候子类化

00:04:21.086 --> 00:04:24.106 A:middle
然后在搜索模型时 将子类类型

00:04:24.106 --> 00:04:24.666 A:middle
作为提示

00:04:25.156 --> 00:04:26.256 A:middle
我们所要做的就是

00:04:26.256 --> 00:04:27.566 A:middle
利用这个功能

00:04:27.566 --> 00:04:28.236 A:middle
创建一个子类

00:04:28.756 --> 00:04:29.826 A:middle
里面甚至可以

00:04:29.826 --> 00:04:30.466 A:middle
什么都没有

00:04:31.916 --> 00:04:33.976 A:middle
然后 任何通过容器设置

00:04:33.976 --> 00:04:35.816 A:middle
并希望使用我们的模型的代码

00:04:35.816 --> 00:04:37.466 A:middle
可以采用那个子类

00:04:37.466 --> 00:04:38.646 A:middle
然后持久化容器将

00:04:38.646 --> 00:04:40.586 A:middle
替代它在框架束中检索模型

00:04:41.196 --> 00:04:45.856 A:middle
这很有趣 但是因为我们需要努力

00:04:45.856 --> 00:04:47.286 A:middle
分解我们 App 的资源

00:04:47.436 --> 00:04:48.486 A:middle
如果我们能提升

00:04:48.486 --> 00:04:49.696 A:middle
我们磁盘上数据的组织

00:04:49.696 --> 00:04:50.426 A:middle
不是更好吗

00:04:51.146 --> 00:04:53.306 A:middle
在默认情况下

00:04:53.306 --> 00:04:54.276 A:middle
新的持久化容器

00:04:54.276 --> 00:04:55.986 A:middle
带有一个 SQLite 存储的存储描述

00:04:56.116 --> 00:04:58.136 A:middle
它的自动迁移功能在

00:04:58.136 --> 00:04:59.926 A:middle
iOS 系统中存在我们的 App 的

00:04:59.926 --> 00:05:00.366 A:middle
文件目录里

00:04:59.926 --> 00:05:00.366 A:middle
文件目录里

00:05:00.796 --> 00:05:02.056 A:middle
当我们的模型代码是 App 的一部分时

00:05:02.056 --> 00:05:04.066 A:middle
这确实很好

00:05:04.066 --> 00:05:04.876 A:middle
但我们需要避免让我们的

00:05:04.876 --> 00:05:06.116 A:middle
新框架文件与 App

00:05:06.116 --> 00:05:07.286 A:middle
过度混合

00:05:08.376 --> 00:05:09.566 A:middle
既然我们已经将

00:05:09.566 --> 00:05:10.976 A:middle
NSPersistentContainer 子类化

00:05:10.976 --> 00:05:12.706 A:middle
以使搜索模型更加简单

00:05:12.706 --> 00:05:14.086 A:middle
我们在这个基础上进行提升

00:05:16.476 --> 00:05:18.456 A:middle
硬性更改储存位置的方法

00:05:18.456 --> 00:05:20.786 A:middle
是在加载存储之前

00:05:20.786 --> 00:05:23.446 A:middle
就在 persistentStoreDescription 里面

00:05:23.446 --> 00:05:26.716 A:middle
更改 URL 有时候这就是你想要的

00:05:26.716 --> 00:05:27.826 A:middle
我们可以在这里使用这种模式

00:05:27.826 --> 00:05:29.406 A:middle
但是我们不需要这样做

00:05:29.716 --> 00:05:31.516 A:middle
因为 NSPersistentContainer

00:05:31.516 --> 00:05:33.996 A:middle
在创建持久化存储描述文件

00:05:33.996 --> 00:05:35.816 A:middle
时会调用它自己默认的

00:05:35.816 --> 00:05:37.086 A:middle
目录 URL 方法

00:05:37.286 --> 00:05:38.626 A:middle
它是用来被覆盖的

00:05:39.166 --> 00:05:40.516 A:middle
在这种情况下

00:05:40.516 --> 00:05:42.066 A:middle
我们可以增加一个路径组件

00:05:42.066 --> 00:05:43.076 A:middle
但是为了缓存

00:05:43.076 --> 00:05:45.776 A:middle
或其他类型的堆栈

00:05:45.776 --> 00:05:46.826 A:middle
比如说你的任务

00:05:46.826 --> 00:05:47.926 A:middle
需要将它们的存储放在不同位置

00:05:47.926 --> 00:05:49.756 A:middle
设置容器也是一种很好的方式

00:05:50.306 --> 00:05:53.046 A:middle
现在我们已经搞清楚了

00:05:53.046 --> 00:05:54.256 A:middle
核心数据的存量

00:05:54.386 --> 00:05:55.686 A:middle
我们来看看我们的 App 以及

00:05:55.686 --> 00:05:57.706 A:middle
一些我们所写的视图控制器

00:05:58.376 --> 00:06:00.896 A:middle
看起来 我们有一些非常特别的

00:05:58.376 --> 00:06:00.896 A:middle
看起来 我们有一些非常特别的

00:06:00.896 --> 00:06:01.606 A:middle
视图控制器

00:06:02.296 --> 00:06:03.386 A:middle
这里有一个可以显示我所有的帖子

00:06:03.386 --> 00:06:04.826 A:middle
另一个可以显示

00:06:04.826 --> 00:06:06.746 A:middle
所有作者发布的所有帖子

00:06:07.226 --> 00:06:08.226 A:middle
甚至连详细评论都被

00:06:08.346 --> 00:06:09.166 A:middle
复制了

00:06:09.306 --> 00:06:10.796 A:middle
看起来

00:06:10.796 --> 00:06:13.386 A:middle
我们只需要写一半的代码

00:06:13.776 --> 00:06:15.656 A:middle
我们真正需要的

00:06:15.656 --> 00:06:16.916 A:middle
是一个用来展示帖子列表的视图控制器

00:06:16.916 --> 00:06:18.556 A:middle
和另一个显示单个帖子的

00:06:18.556 --> 00:06:19.926 A:middle
视图控制器

00:06:20.626 --> 00:06:21.656 A:middle
我们可以通过

00:06:21.656 --> 00:06:23.526 A:middle
在使用模型对象的

00:06:23.526 --> 00:06:25.516 A:middle
界面形式里

00:06:25.516 --> 00:06:26.916 A:middle
在视图控制器之间

00:06:26.916 --> 00:06:27.786 A:middle
定义良好边界

00:06:29.286 --> 00:06:30.576 A:middle
每个控制器均由其

00:06:30.576 --> 00:06:33.026 A:middle
模型参数配置

00:06:33.026 --> 00:06:34.136 A:middle
可以基于

00:06:34.136 --> 00:06:35.306 A:middle
是否展示我的帖子

00:06:35.306 --> 00:06:36.626 A:middle
或别人的帖子

00:06:36.626 --> 00:06:37.386 A:middle
来自定义单元格中的视图

00:06:37.906 --> 00:06:40.936 A:middle
当使用核心数据

00:06:40.936 --> 00:06:42.566 A:middle
草拟视图控制器时

00:06:42.566 --> 00:06:44.016 A:middle
列表视图应获得读取请求

00:06:44.016 --> 00:06:45.406 A:middle
评论详情应获得

00:06:45.406 --> 00:06:46.096 A:middle
托管对象

00:06:47.506 --> 00:06:48.776 A:middle
视图控制器也需要一个

00:06:48.776 --> 00:06:50.446 A:middle
托管对象上下文

00:06:50.446 --> 00:06:52.076 A:middle
容器的评论上下文或者

00:06:52.076 --> 00:06:53.886 A:middle
一些其它的主队列上下文

00:06:54.046 --> 00:06:55.536 A:middle
这个用核心数据来

00:06:55.536 --> 00:06:56.806 A:middle
生成视图控制器的模式

00:06:56.806 --> 00:06:58.176 A:middle
不仅可以为 UI 服务

00:06:58.176 --> 00:06:59.596 A:middle
也能很好地

00:06:59.596 --> 00:07:00.836 A:middle
服务于实用 App 类型

00:06:59.596 --> 00:07:00.836 A:middle
服务于实用 App 类型

00:07:01.806 --> 00:07:02.926 A:middle
无需传递核心数据类型给演示文稿

00:07:02.926 --> 00:07:06.446 A:middle
我们可以将 URL 或

00:07:06.446 --> 00:07:08.106 A:middle
序列化数据等传递给

00:07:08.106 --> 00:07:10.496 A:middle
后台工作控制器

00:07:10.496 --> 00:07:11.896 A:middle
然后用后台上下文代替

00:07:11.896 --> 00:07:13.446 A:middle
视图上下文来完成我们的工作

00:07:13.506 --> 00:07:14.876 A:middle
将它们变为

00:07:14.876 --> 00:07:16.476 A:middle
全新的升级的托管对象

00:07:18.016 --> 00:07:19.136 A:middle
采用这种连接和工具类型

00:07:19.136 --> 00:07:20.616 A:middle
非常简单

00:07:20.616 --> 00:07:22.146 A:middle
因为我们拥有初始化器

00:07:22.146 --> 00:07:23.936 A:middle
我们可以要求参数去创建一个

00:07:23.936 --> 00:07:24.466 A:middle
控制器

00:07:24.566 --> 00:07:26.316 A:middle
但我们如何将

00:07:26.316 --> 00:07:27.416 A:middle
边缘变量放入

00:07:27.416 --> 00:07:28.086 A:middle
视图控制器中呢

00:07:28.676 --> 00:07:31.946 A:middle
如果我们使用 segues

00:07:31.946 --> 00:07:33.226 A:middle
就可以覆盖 prepare method

00:07:34.636 --> 00:07:35.706 A:middle
然后得到一个

00:07:35.706 --> 00:07:37.086 A:middle
对 destinationViewController 的引用

00:07:37.086 --> 00:07:38.186 A:middle
然后在那儿配置它

00:07:38.806 --> 00:07:40.636 A:middle
如果我们使用故事板或者 nibs

00:07:40.636 --> 00:07:42.656 A:middle
那么我们已经有可以汇成

00:07:42.656 --> 00:07:43.576 A:middle
destinationViewController 的代码

00:07:43.576 --> 00:07:45.676 A:middle
我们需要做的是

00:07:45.676 --> 00:07:47.976 A:middle
在演示前设置属性

00:07:48.506 --> 00:07:50.586 A:middle
如果我们在操纵杆

00:07:50.586 --> 00:07:51.676 A:middle
我们可以写一个可以

00:07:51.676 --> 00:07:52.826 A:middle
明确的定义边界条件的初始化 App

00:07:52.826 --> 00:07:54.256 A:middle
就像我们在没有效用类型时

00:07:54.256 --> 00:07:55.676 A:middle
所做的那样

00:07:56.276 --> 00:07:59.656 A:middle
好了 现在我们已经有了一个读取请求

00:07:59.656 --> 00:08:01.056 A:middle
和视图控制器的上下文

00:07:59.656 --> 00:08:01.056 A:middle
和视图控制器的上下文

00:08:01.056 --> 00:08:02.656 A:middle
但是在我们

00:08:02.656 --> 00:08:04.136 A:middle
混合二者得到结果之前

00:08:04.136 --> 00:08:05.486 A:middle
我们需要对

00:08:05.486 --> 00:08:06.746 A:middle
读取请求多做一些配置

00:08:06.746 --> 00:08:07.986 A:middle
来确定我们的控制器

00:08:07.986 --> 00:08:09.136 A:middle
会表现不错

00:08:10.856 --> 00:08:12.276 A:middle
有时应该设置读取限制

00:08:12.276 --> 00:08:13.806 A:middle
但按照列表视图的情况

00:08:13.806 --> 00:08:15.036 A:middle
使用批处理更合适

00:08:15.036 --> 00:08:16.036 A:middle
因为我们希望显示所有的数据

00:08:16.036 --> 00:08:18.596 A:middle
我们也知道

00:08:18.596 --> 00:08:20.126 A:middle
我们的视图控制器

00:08:20.126 --> 00:08:21.806 A:middle
一次可以在屏幕上 显示多少个单元格

00:08:22.546 --> 00:08:24.306 A:middle
总的来说 至少这些选项中的一个

00:08:24.306 --> 00:08:25.886 A:middle
需要设置为读取请求

00:08:25.886 --> 00:08:27.156 A:middle
它返回的结果

00:08:27.156 --> 00:08:29.276 A:middle
可能是无限数量

00:08:29.956 --> 00:08:32.346 A:middle
所以这时我们可以

00:08:32.346 --> 00:08:33.676 A:middle
将读取请求更改为对象

00:08:33.676 --> 00:08:35.025 A:middle
然后用返回结果填充列表视图

00:08:35.056 --> 00:08:37.196 A:middle
但是如果我们想要

00:08:37.196 --> 00:08:39.155 A:middle
让 UI 和发生的更改保持一致

00:08:39.155 --> 00:08:40.366 A:middle
该怎么做

00:08:41.666 --> 00:08:42.846 A:middle
我们在这里已经讲到了核心数据

00:08:42.846 --> 00:08:44.246 A:middle
和读取结果控制器

00:08:44.726 --> 00:08:46.356 A:middle
自 Sierra 系统以来

00:08:46.356 --> 00:08:47.976 A:middle
读取结果控制器可用于所有平台

00:08:47.976 --> 00:08:49.366 A:middle
要采用它只要求

00:08:49.366 --> 00:08:50.556 A:middle
在委托协议和它驱动的视图之间

00:08:50.556 --> 00:08:52.536 A:middle
写一个适配器

00:08:53.136 --> 00:08:54.556 A:middle
要创建它 我们只需要

00:08:54.556 --> 00:08:55.836 A:middle
一个读取请求和一个上下文

00:08:57.176 --> 00:08:58.136 A:middle
读取结果控制器

00:08:58.136 --> 00:08:59.276 A:middle
甚至可以支持对类似区段这样的

00:08:59.276 --> 00:09:01.316 A:middle
更加高级的列表视图概念

00:08:59.276 --> 00:09:01.316 A:middle
更加高级的列表视图概念

00:09:01.316 --> 00:09:02.026 A:middle
进行驱动

00:09:03.066 --> 00:09:05.066 A:middle
如果我们希望将帖子

00:09:05.066 --> 00:09:06.206 A:middle
根据发布的日期分成区段

00:09:06.206 --> 00:09:07.596 A:middle
我们可以

00:09:07.596 --> 00:09:09.046 A:middle
通过使用计算属性

00:09:09.046 --> 00:09:10.696 A:middle
将 Xcode 生成的帖子类型进行扩展

00:09:10.696 --> 00:09:12.436 A:middle
然后将它的名称

00:09:12.436 --> 00:09:14.436 A:middle
传递给读取结果控制器的

00:09:14.436 --> 00:09:15.076 A:middle
初始化 App

00:09:16.336 --> 00:09:18.156 A:middle
这样可以运行得很好

00:09:18.156 --> 00:09:19.226 A:middle
但是如果我们有比

00:09:19.226 --> 00:09:20.596 A:middle
仅有一个对象列表 更复杂的视图控制器时

00:09:20.596 --> 00:09:21.656 A:middle
我们该怎么做

00:09:21.806 --> 00:09:22.786 A:middle
如果我们希望

00:09:22.786 --> 00:09:24.686 A:middle
在 App 上显示类似每日发帖图表的东西

00:09:24.686 --> 00:09:25.966 A:middle
该怎么做

00:09:27.556 --> 00:09:28.776 A:middle
我们需要做的第一件事就是

00:09:28.776 --> 00:09:31.266 A:middle
不要低估了读取请求的能力

00:09:31.816 --> 00:09:33.126 A:middle
我只是一个人

00:09:33.126 --> 00:09:34.326 A:middle
所以在上个月

00:09:34.326 --> 00:09:36.576 A:middle
我没能每天发布

00:09:36.576 --> 00:09:36.926 A:middle
多于 40 张的照片

00:09:37.706 --> 00:09:39.196 A:middle
在 30 天内

00:09:39.336 --> 00:09:40.646 A:middle
这仍然是

00:09:40.646 --> 00:09:41.706 A:middle
一次从存储中取出的

00:09:41.706 --> 00:09:42.566 A:middle
合理的数据量

00:09:43.446 --> 00:09:45.466 A:middle
如果我们先前定义的

00:09:45.466 --> 00:09:46.856 A:middle
日期属性是

00:09:46.856 --> 00:09:48.236 A:middle
模型中实体的一部分

00:09:48.646 --> 00:09:49.386 A:middle
我们可以写一个读取请求

00:09:49.386 --> 00:09:50.506 A:middle
能够将帖子数量

00:09:50.506 --> 00:09:52.916 A:middle
根据发布的日期进行分组

00:09:53.456 --> 00:09:55.236 A:middle
这个请求有三部分

00:09:55.616 --> 00:09:56.986 A:middle
第一个是

00:09:56.986 --> 00:09:57.426 A:middle
设置范围

00:09:57.596 --> 00:09:58.966 A:middle
我们希望有

00:09:58.966 --> 00:09:59.316 A:middle
至少 30 天的数据

00:09:59.316 --> 00:10:02.316 A:middle
接下来 我们希望

00:09:59.316 --> 00:10:02.316 A:middle
接下来 我们希望

00:10:02.316 --> 00:10:04.536 A:middle
将所有日期属性的值相同的日期

00:10:04.536 --> 00:10:05.716 A:middle
分到一组

00:10:06.316 --> 00:10:07.076 A:middle
因为我们现在抓取的是

00:10:07.076 --> 00:10:08.566 A:middle
总量而不是单个的对象

00:10:08.566 --> 00:10:09.796 A:middle
我们也需要将结果类型修改得

00:10:09.796 --> 00:10:10.876 A:middle
更加合理

00:10:10.876 --> 00:10:13.066 A:middle
在这里是字典

00:10:14.726 --> 00:10:17.346 A:middle
最后 我们要定义一个

00:10:17.346 --> 00:10:19.316 A:middle
在每个组里代表对象数量的表达式

00:10:19.316 --> 00:10:20.976 A:middle
然后告诉读取请求

00:10:20.976 --> 00:10:23.616 A:middle
返回它所代表的日期的计数

00:10:24.926 --> 00:10:26.996 A:middle
这个读取请求返回了 30 个结果

00:10:26.996 --> 00:10:28.416 A:middle
它们中的每一个都是

00:10:28.416 --> 00:10:29.876 A:middle
图表中的一个点

00:10:31.216 --> 00:10:34.466 A:middle
如果你进入数据库

00:10:34.466 --> 00:10:35.546 A:middle
这是核心数据从

00:10:35.546 --> 00:10:36.686 A:middle
读取请求里

00:10:36.686 --> 00:10:37.186 A:middle
生成的 SQLite 查询

00:10:37.646 --> 00:10:38.846 A:middle
如果你自己写查询语句

00:10:38.846 --> 00:10:39.516 A:middle
那么这就是

00:10:39.516 --> 00:10:40.046 A:middle
你要做的

00:10:40.496 --> 00:10:41.816 A:middle
核心数据知道如何

00:10:41.816 --> 00:10:43.226 A:middle
将许多表达功能

00:10:43.226 --> 00:10:45.196 A:middle
转换成最佳的数据库查询

00:10:45.776 --> 00:10:46.856 A:middle
一个通过查询得到的组

00:10:46.856 --> 00:10:48.066 A:middle
可以聚合

00:10:48.066 --> 00:10:50.076 A:middle
例如平均 求和 以及标量查询

00:10:50.076 --> 00:10:51.736 A:middle
比如一般的读取请求

00:10:51.736 --> 00:10:53.336 A:middle
可以使用标量计数以及日期功能

00:10:53.336 --> 00:10:54.926 A:middle
就像 abs 之于绝对值

00:10:54.926 --> 00:10:57.026 A:middle
now 之于当前时间一样

00:10:57.156 --> 00:10:59.366 A:middle
如果你想知道

00:10:59.366 --> 00:11:00.236 A:middle
更多的关于 NSExpression 的内容

00:10:59.366 --> 00:11:00.236 A:middle
更多的关于 NSExpression 的内容

00:11:00.266 --> 00:11:01.306 A:middle
你可以去了解一下

00:11:01.306 --> 00:11:03.286 A:middle
功能列表的资料

00:11:03.356 --> 00:11:04.366 A:middle
在核心数据里

00:11:04.366 --> 00:11:07.336 A:middle
很多都受到读取请求的支持

00:11:08.366 --> 00:11:10.586 A:middle
所以通过使用表达式

00:11:10.586 --> 00:11:12.566 A:middle
读取请求可以完成很多事

00:11:12.566 --> 00:11:14.606 A:middle
但是 SQLite 仍旧会在

00:11:14.606 --> 00:11:16.286 A:middle
处理图表时

00:11:16.286 --> 00:11:18.636 A:middle
读取每一个帖子

00:11:19.126 --> 00:11:20.976 A:middle
用图表展示

00:11:20.976 --> 00:11:23.566 A:middle
一个人的发帖数量时运行良好

00:11:23.566 --> 00:11:24.586 A:middle
但是如果我们希望

00:11:24.586 --> 00:11:25.796 A:middle
为更庞大的数据

00:11:25.796 --> 00:11:26.746 A:middle
制作图表呢

00:11:27.086 --> 00:11:28.676 A:middle
如果我们想展示一整年的数据

00:11:28.676 --> 00:11:30.536 A:middle
或者我们的 App

00:11:30.536 --> 00:11:32.136 A:middle
要开始处理

00:11:32.136 --> 00:11:33.386 A:middle
更大数量级的数据呢

00:11:34.706 --> 00:11:35.686 A:middle
现在 读取请求至少可以

00:11:35.686 --> 00:11:37.566 A:middle
一个一个地

00:11:37.566 --> 00:11:39.226 A:middle
计算 50,000 个帖子

00:11:39.226 --> 00:11:41.956 A:middle
只为显示 30 个点 这不够快

00:11:42.436 --> 00:11:44.076 A:middle
视图与模型之间的不协调

00:11:44.076 --> 00:11:45.436 A:middle
已经到了需要我们

00:11:45.436 --> 00:11:47.596 A:middle
做一些 denormalization 了

00:11:50.226 --> 00:11:52.266 A:middle
denormalization 是当我们

00:11:52.266 --> 00:11:53.596 A:middle
增加冗余的数据副本

00:11:53.596 --> 00:11:55.266 A:middle
或者元数据时

00:11:55.266 --> 00:11:56.556 A:middle
以增加簿记为代价

00:11:56.556 --> 00:11:57.576 A:middle
来提升读取性能

00:11:58.156 --> 00:11:59.546 A:middle
数据库索引就是一个

00:11:59.546 --> 00:12:00.466 A:middle
很好的例子

00:11:59.546 --> 00:12:00.466 A:middle
很好的例子

00:12:01.396 --> 00:12:02.766 A:middle
在我们的存储里加入计数元数据

00:12:02.766 --> 00:12:04.526 A:middle
是为了使我们的图表

00:12:04.526 --> 00:12:07.866 A:middle
能够再次显示 而做出的牺牲

00:12:08.666 --> 00:12:10.676 A:middle
让我们看看 我们的模型

00:12:10.676 --> 00:12:12.366 A:middle
如何将帖子按照发布的

00:12:12.366 --> 00:12:12.736 A:middle
日期分组

00:12:13.626 --> 00:12:15.556 A:middle
我们将需要一个新的实体和两个属性

00:12:15.556 --> 00:12:17.246 A:middle
加上一些额外的维护

00:12:17.246 --> 00:12:18.316 A:middle
以保证其准确性

00:12:19.186 --> 00:12:20.796 A:middle
按照日期分组很大地提升了

00:12:20.796 --> 00:12:22.396 A:middle
读取请求

00:12:22.396 --> 00:12:23.756 A:middle
使它保证在覆盖好几年的数据时

00:12:23.756 --> 00:12:25.386 A:middle
也能有好的表现

00:12:25.766 --> 00:12:26.776 A:middle
我们只需要创建

00:12:26.776 --> 00:12:29.376 A:middle
与我们向图表视图控制器

00:12:29.376 --> 00:12:30.516 A:middle
传递的同样水平的 denormalization

00:12:30.516 --> 00:12:31.496 A:middle
和读取请求即可

00:12:32.386 --> 00:12:33.446 A:middle
这非常简单

00:12:34.416 --> 00:12:35.256 A:middle
这和我们向其他列表视图

00:12:35.256 --> 00:12:36.336 A:middle
传递的读取请求

00:12:36.336 --> 00:12:37.576 A:middle
没有多大不同

00:12:37.576 --> 00:12:39.386 A:middle
事实上如果你看得够仔细

00:12:39.506 --> 00:12:40.636 A:middle
会发现它

00:12:40.636 --> 00:12:42.176 A:middle
有点像一种图表视图

00:12:43.766 --> 00:12:44.866 A:middle
但是特殊维护

00:12:44.866 --> 00:12:45.396 A:middle
该如何进行呢

00:12:46.186 --> 00:12:47.656 A:middle
当帖子发布时

00:12:47.656 --> 00:12:48.986 A:middle
我们需要增加计数

00:12:48.986 --> 00:12:50.236 A:middle
当帖子被移除时

00:12:50.236 --> 00:12:50.846 A:middle
我们需要减少计数

00:12:51.556 --> 00:12:53.016 A:middle
我们可以使用

00:12:53.016 --> 00:12:54.296 A:middle
更改帖子对象的相关状态的方法

00:12:54.296 --> 00:12:55.836 A:middle
来实现它

00:12:55.836 --> 00:12:56.886 A:middle
但一个更简单明了的方式是去

00:12:56.886 --> 00:12:58.046 A:middle
根据响应上下文存储

00:12:58.046 --> 00:12:58.796 A:middle
来更新计数

00:12:59.356 --> 00:13:04.546 A:middle
我们可以为

00:12:59.356 --> 00:13:04.546 A:middle
我们可以为

00:13:04.976 --> 00:13:07.156 A:middle
托管对象 contextWillSave 提醒

00:13:07.156 --> 00:13:08.866 A:middle
注册一个功能

00:13:09.296 --> 00:13:10.286 A:middle
使它可以检查所有

00:13:10.286 --> 00:13:11.406 A:middle
添加的帖子

00:13:11.696 --> 00:13:13.136 A:middle
对所有相关的日期增加计数

00:13:13.136 --> 00:13:15.626 A:middle
让另外一个循环

00:13:16.066 --> 00:13:18.186 A:middle
检查所有被删除的对象

00:13:18.186 --> 00:13:18.956 A:middle
为每天减少计数

00:13:19.646 --> 00:13:20.656 A:middle
这样就可以在交付数据库之前

00:13:20.656 --> 00:13:22.106 A:middle
影响上下文状态

00:13:22.106 --> 00:13:23.516 A:middle
最后它们会在

00:13:23.516 --> 00:13:25.166 A:middle
一次交付中完成

00:13:25.166 --> 00:13:27.236 A:middle
这样做 延展性很好

00:13:27.236 --> 00:13:28.916 A:middle
非常有用

00:13:28.916 --> 00:13:30.366 A:middle
因为我的同事 Nick Gilett 将

00:13:30.366 --> 00:13:31.676 A:middle
探讨当我们的 App 扩展到超出想象时

00:13:31.676 --> 00:13:33.296 A:middle
核心数据

00:13:33.296 --> 00:13:34.186 A:middle
将如何帮助我们

00:13:34.846 --> 00:13:34.976 A:middle
Nick

00:13:35.271 --> 00:13:37.271 A:middle
[ 掌声 ]

00:13:37.526 --> 00:13:37.976 A:middle
&gt;&gt; 谢谢 Scott

00:13:38.416 --> 00:13:40.416 A:middle
[ 掌声 ]

00:13:40.816 --> 00:13:42.296 A:middle
就像 Scott 所说

00:13:42.296 --> 00:13:43.876 A:middle
在你的 App 扩张时

00:13:43.876 --> 00:13:46.606 A:middle
它们变得更加复杂

00:13:46.606 --> 00:13:48.196 A:middle
对于核心数据而言

00:13:48.196 --> 00:13:50.656 A:middle
很重要的一点是 你的 App 确实在扩张

00:13:50.656 --> 00:13:51.746 A:middle
事实上 这是我们想要的

00:13:51.746 --> 00:13:53.336 A:middle
这是我们出现

00:13:53.426 --> 00:13:54.626 A:middle
并帮助你管理扩展的全部理由

00:13:54.626 --> 00:13:56.166 A:middle
通过使用它

00:13:56.166 --> 00:13:58.026 A:middle
使你的工作更有效率

00:13:58.026 --> 00:13:59.656 A:middle
帮助你为顾客创造更多的价值

00:14:00.306 --> 00:14:03.046 A:middle
但是这种方式

00:14:03.046 --> 00:14:04.936 A:middle
对你的 App 来说 会非常特别

00:14:05.416 --> 00:14:06.976 A:middle
高度匹配

00:14:06.976 --> 00:14:08.696 A:middle
顾客的体验

00:14:08.696 --> 00:14:09.936 A:middle
或者你希望顾客以何种方式

00:14:09.936 --> 00:14:11.266 A:middle
体验你的 App

00:14:12.056 --> 00:14:13.816 A:middle
不幸的是

00:14:13.816 --> 00:14:15.696 A:middle
就像所有的复杂系统一样

00:14:15.696 --> 00:14:18.516 A:middle
它也会出现混乱

00:14:19.376 --> 00:14:20.716 A:middle
所有我们今天将

00:14:20.716 --> 00:14:22.136 A:middle
探讨核心数据如何帮助你

00:14:22.136 --> 00:14:23.876 A:middle
管理这些混乱

00:14:23.876 --> 00:14:24.896 A:middle
并且使系统更有条理

00:14:25.466 --> 00:14:26.536 A:middle
我们将讨论构建

00:14:26.536 --> 00:14:28.996 A:middle
可预测的行为

00:14:28.996 --> 00:14:30.436 A:middle
并帮助你构建

00:14:30.436 --> 00:14:31.826 A:middle
可调容器

00:14:31.826 --> 00:14:32.976 A:middle
来与你的经验指标匹配

00:14:36.236 --> 00:14:37.346 A:middle
这是什么意思呢

00:14:38.246 --> 00:14:39.996 A:middle
当我们想到指标时

00:14:39.996 --> 00:14:42.946 A:middle
我们有很多不同的方式去思考它

00:14:43.396 --> 00:14:45.696 A:middle
第一个是 与用户保持一致

00:14:46.326 --> 00:14:48.586 A:middle
我们一般会将它们定义为

00:14:48.586 --> 00:14:49.836 A:middle
用户会体验的东西

00:14:49.836 --> 00:14:51.176 A:middle
比如有持久化用户界面或者

00:14:51.176 --> 00:14:53.536 A:middle
一个响应滚动视图

00:14:53.536 --> 00:14:57.786 A:middle
或者顾客喜悦度

00:14:58.486 --> 00:15:01.106 A:middle
但对于我们工程师来说

00:14:58.486 --> 00:15:01.106 A:middle
但对于我们工程师来说

00:15:01.106 --> 00:15:02.476 A:middle
这些都很难捕捉

00:15:03.256 --> 00:15:04.326 A:middle
我们将它们

00:15:04.326 --> 00:15:06.186 A:middle
翻译为工程指标

00:15:06.296 --> 00:15:08.276 A:middle
比如运行时的峰值内存

00:15:08.276 --> 00:15:09.836 A:middle
在运行一个任务时电池的消耗

00:15:09.836 --> 00:15:12.056 A:middle
或者在运行一个任务时

00:15:12.436 --> 00:15:13.896 A:middle
所需要的中央处理时间

00:15:14.316 --> 00:15:17.906 A:middle
最后 我们在给予的任务中做了多少 IO

00:15:18.806 --> 00:15:19.656 A:middle
为了让它更具体一些

00:15:19.656 --> 00:15:21.626 A:middle
我们将使用这个 App

00:15:22.286 --> 00:15:23.236 A:middle
你们中的有些人

00:15:23.236 --> 00:15:24.736 A:middle
可能还记得去年的 WWDC

00:15:24.836 --> 00:15:26.886 A:middle
我们介绍的历史演示 App

00:15:27.306 --> 00:15:28.536 A:middle
为了这个演讲

00:15:28.536 --> 00:15:29.676 A:middle
我对它进行了修改

00:15:30.506 --> 00:15:32.156 A:middle
当用户用你的 App 时

00:15:32.156 --> 00:15:34.526 A:middle
这里有一些它们可以做的事

00:15:35.036 --> 00:15:36.676 A:middle
第一个是它们可以

00:15:36.676 --> 00:15:38.826 A:middle
通过敲击 + 键

00:15:38.826 --> 00:15:39.746 A:middle
将单个的帖子添加到你的数据库中去

00:15:40.786 --> 00:15:42.256 A:middle
它们也可以

00:15:42.256 --> 00:15:44.546 A:middle
通过点击下载

00:15:44.546 --> 00:15:45.406 A:middle
从服务器下载未决数据

00:15:50.716 --> 00:15:53.966 A:middle
最终 对那些还没有被上传到服务区的东西

00:15:53.966 --> 00:15:55.636 A:middle
它们可以点击发布全部

00:15:56.596 --> 00:16:00.416 A:middle
现在 这个 App 有少数几个

00:15:56.596 --> 00:16:00.416 A:middle
现在 这个 App 有少数几个

00:16:00.416 --> 00:16:02.366 A:middle
可供顾客使用的交互

00:16:02.366 --> 00:16:04.156 A:middle
但是当这些功能同时发生时

00:16:04.156 --> 00:16:07.516 A:middle
会产生混乱

00:16:08.306 --> 00:16:11.536 A:middle
我们可以看到

00:16:11.536 --> 00:16:12.936 A:middle
即便是这么少的系列动作

00:16:13.596 --> 00:16:14.806 A:middle
它们同时发生也会导致

00:16:14.806 --> 00:16:15.676 A:middle
很多不同 App 的状态变化

00:16:15.676 --> 00:16:18.776 A:middle
对我们而言最糟糕的是

00:16:18.776 --> 00:16:21.826 A:middle
出现像这样的用户体验

00:16:22.696 --> 00:16:25.336 A:middle
这些部分完整性的概念

00:16:25.336 --> 00:16:26.196 A:middle
对于用户没有意义

00:16:26.196 --> 00:16:28.156 A:middle
事实上 这对我们也没有意义

00:16:29.816 --> 00:16:30.836 A:middle
在这里 核心数据将帮助我们

00:16:30.886 --> 00:16:32.676 A:middle
处理查询生成

00:16:33.066 --> 00:16:36.556 A:middle
在 2016 年的核心数据新品介绍会议上

00:16:36.556 --> 00:16:37.656 A:middle
我们介绍了查询生成

00:16:38.116 --> 00:16:39.076 A:middle
如果你还不了解它

00:16:39.076 --> 00:16:40.286 A:middle
我非常建议你

00:16:40.286 --> 00:16:41.516 A:middle
了解一下那场会议

00:16:41.516 --> 00:16:42.806 A:middle
并获得更多

00:16:42.806 --> 00:16:43.356 A:middle
有关它如何工作的信息

00:16:43.996 --> 00:16:45.626 A:middle
你需要知道的是

00:16:45.886 --> 00:16:47.506 A:middle
它需要预写日志模式

00:16:47.606 --> 00:16:48.786 A:middle
并且只能使用 SQLite

00:16:49.906 --> 00:16:51.746 A:middle
查询生成的目标是

00:16:51.746 --> 00:16:53.186 A:middle
将你的托管对象上下文

00:16:53.186 --> 00:16:54.896 A:middle
从相互矛盾的工作中隔离出来

00:16:55.346 --> 00:16:56.406 A:middle
它可能直接作用于后台

00:16:56.406 --> 00:16:58.566 A:middle
或者你还没有准备在

00:16:58.566 --> 00:17:00.176 A:middle
给定文本中显示的

00:16:58.566 --> 00:17:00.176 A:middle
给定文本中显示的

00:17:00.176 --> 00:17:03.006 A:middle
用户正在进行的行为

00:17:04.026 --> 00:17:05.286 A:middle
查询生成提供了一个

00:17:05.286 --> 00:17:07.026 A:middle
数据库的一致而长久的视图

00:17:07.026 --> 00:17:08.806 A:middle
它将向读取返回同样的结果

00:17:08.806 --> 00:17:10.435 A:middle
无论在给定时间内

00:17:10.435 --> 00:17:11.606 A:middle
数据库被写入

00:17:11.606 --> 00:17:14.165 A:middle
何种其它的上下文

00:17:17.415 --> 00:17:19.695 A:middle
最好的是我们可以通过

00:17:19.695 --> 00:17:20.816 A:middle
一行代码来实现它

00:17:21.715 --> 00:17:23.116 A:middle
这里是重新加载一个表格视图的

00:17:23.116 --> 00:17:24.256 A:middle
典型变化

00:17:24.675 --> 00:17:26.626 A:middle
我们可以仅仅对 NSManagedObjectContext

00:17:26.626 --> 00:17:28.496 A:middle
setQueryGenerationFrom

00:17:28.496 --> 00:17:31.276 A:middle
增加一个带有现有查询生成

00:17:31.276 --> 00:17:31.966 A:middle
的调用

00:17:33.456 --> 00:17:34.746 A:middle
需要更新时

00:17:34.746 --> 00:17:37.206 A:middle
我们可以像往常一样

00:17:37.206 --> 00:17:40.056 A:middle
使用 NSMangedObjectContextDidSave 提醒

00:17:40.056 --> 00:17:40.766 A:middle
来进行更新

00:17:41.236 --> 00:17:45.806 A:middle
这使我们可以在对的时间 在 UI 里

00:17:45.806 --> 00:17:48.876 A:middle
对 App 的数据实现修改

00:17:52.096 --> 00:17:53.536 A:middle
但是如果我们写的数据

00:17:53.536 --> 00:17:54.986 A:middle
和 UI 没有关联呢

00:17:55.676 --> 00:17:56.716 A:middle
例如下载之前

00:17:56.716 --> 00:17:58.466 A:middle
Scott 提到的一些评论

00:17:59.556 --> 00:18:02.046 A:middle
这种情况下

00:17:59.556 --> 00:18:02.046 A:middle
这种情况下

00:18:02.046 --> 00:18:03.406 A:middle
我们不希望数据出现在用户界面里

00:18:03.406 --> 00:18:05.716 A:middle
或者对它产生更改

00:18:05.716 --> 00:18:06.776 A:middle
因为所有的变化对用户

00:18:06.776 --> 00:18:07.996 A:middle
都是不可视的

00:18:08.526 --> 00:18:09.876 A:middle
我们需要通过使用

00:18:09.876 --> 00:18:11.976 A:middle
历史追踪 来过滤掉这些更新

00:18:12.786 --> 00:18:14.276 A:middle
持续历史追踪是

00:18:14.276 --> 00:18:17.456 A:middle
iOS 11 和 macOS 10.13 的新功能

00:18:18.206 --> 00:18:19.996 A:middle
我们在去年的全球开发者大会中的

00:18:19.996 --> 00:18:22.036 A:middle
核心数据的新功能部分

00:18:22.116 --> 00:18:23.526 A:middle
对它进行过介绍

00:18:23.526 --> 00:18:24.866 A:middle
要想了解更多它如何工作

00:18:24.866 --> 00:18:26.626 A:middle
或者它们重点功能是什么的信息

00:18:26.626 --> 00:18:27.866 A:middle
你可以将这个会议

00:18:28.516 --> 00:18:29.566 A:middle
作为参考

00:18:31.966 --> 00:18:33.406 A:middle
持续历史追踪是一个

00:18:33.406 --> 00:18:35.526 A:middle
获得每次与数据库相关的

00:18:35.526 --> 00:18:38.926 A:middle
事务处理的记录的好方式

00:18:38.926 --> 00:18:40.026 A:middle
对我们很有用

00:18:40.026 --> 00:18:41.186 A:middle
有几点原因

00:18:41.756 --> 00:18:43.506 A:middle
为了本次演讲

00:18:43.506 --> 00:18:45.626 A:middle
我们将使用 NSPersistentHistoryChange

00:18:45.796 --> 00:18:47.926 A:middle
它能给我们一个 changedObjectID

00:18:48.576 --> 00:18:52.546 A:middle
和一组 updatedProperties

00:18:53.036 --> 00:18:53.176 A:middle
还有 NSPersistentHistoryTransaction

00:18:53.296 --> 00:18:55.036 A:middle
它将给我们一组变化

00:18:55.686 --> 00:18:59.136 A:middle
以及一个 objectIDNotification

00:19:01.396 --> 00:19:05.176 A:middle
我们来想一下

00:19:05.176 --> 00:19:06.036 A:middle
接下来的变化

00:19:06.776 --> 00:19:08.236 A:middle
就像你所看到的

00:19:08.236 --> 00:19:09.376 A:middle
有一些帖子被加入到了数据库中

00:19:09.376 --> 00:19:12.436 A:middle
当这件事发生时

00:19:12.806 --> 00:19:14.206 A:middle
用表格视图来说

00:19:14.206 --> 00:19:17.046 A:middle
我们可以通过使用

00:19:17.046 --> 00:19:18.346 A:middle
objectIDNotification

00:19:18.346 --> 00:19:19.726 A:middle
来更新 UI

00:19:20.296 --> 00:19:21.356 A:middle
这和 NSManageObjectContextDidSave

00:19:21.486 --> 00:19:25.076 A:middle
提醒相似 它可以通过使用同一的 API

00:19:25.076 --> 00:19:26.586 A:middle
来进行合并

00:19:29.756 --> 00:19:31.186 A:middle
如果我们下载了一个

00:19:31.186 --> 00:19:33.516 A:middle
我们不希望在用户更新里显示的

00:19:33.516 --> 00:19:35.406 A:middle
评论列表

00:19:35.976 --> 00:19:39.936 A:middle
我们可以对它进行过滤

00:19:40.146 --> 00:19:41.556 A:middle
用少量的代码

00:19:41.616 --> 00:19:42.826 A:middle
我们可以从给定的事务处理中

00:19:42.826 --> 00:19:44.046 A:middle
将变化过滤出去

00:19:44.046 --> 00:19:45.086 A:middle
以决定它们中是否有与帖子实体有关的变化

00:19:45.086 --> 00:19:47.306 A:middle
这样我们就不需要更新 UI

00:19:48.876 --> 00:19:50.916 A:middle
从而为用户引起

00:19:50.916 --> 00:19:53.876 A:middle
不必要的波动

00:19:53.976 --> 00:19:55.276 A:middle
或断续

00:19:56.256 --> 00:19:57.436 A:middle
就像你在这里看到的

00:19:57.436 --> 00:19:58.906 A:middle
我们使用的是

00:19:58.906 --> 00:20:00.496 A:middle
小部分的帖子内容

00:19:58.906 --> 00:20:00.496 A:middle
小部分的帖子内容

00:20:01.246 --> 00:20:03.276 A:middle
事实上 我们只使用了

00:20:03.276 --> 00:20:05.906 A:middle
两个属性 图像和标题属性

00:20:07.406 --> 00:20:08.606 A:middle
我们可以有比

00:20:08.606 --> 00:20:10.126 A:middle
通过实体过滤更好的方式

00:20:10.416 --> 00:20:12.216 A:middle
事实上我们可以通过使用

00:20:12.216 --> 00:20:13.606 A:middle
历史变化来对更新的属性进行过滤

00:20:13.606 --> 00:20:17.416 A:middle
这样 我们就可以针对

00:20:17.416 --> 00:20:19.026 A:middle
与用户可以看到的变化一致

00:20:19.476 --> 00:20:20.666 A:middle
的用户体验

00:20:20.666 --> 00:20:21.916 A:middle
创建目标性很强的更新

00:20:22.546 --> 00:20:27.526 A:middle
核心数据还可以支持

00:20:28.146 --> 00:20:29.846 A:middle
你与你的用户

00:20:29.846 --> 00:20:30.446 A:middle
进行新的交互

00:20:31.336 --> 00:20:32.446 A:middle
当你的数据逐渐变得

00:20:32.446 --> 00:20:35.216 A:middle
更复杂更庞大

00:20:35.216 --> 00:20:36.756 A:middle
有些编辑操作

00:20:36.756 --> 00:20:37.346 A:middle
会变得更昂贵

00:20:37.346 --> 00:20:39.546 A:middle
例如一个简单的

00:20:39.546 --> 00:20:40.466 A:middle
图片浏览器

00:20:41.206 --> 00:20:42.796 A:middle
一般来说

00:20:42.796 --> 00:20:44.386 A:middle
当我们的 App 扩张时

00:20:44.386 --> 00:20:45.976 A:middle
我们希望引进新的

00:20:45.976 --> 00:20:47.276 A:middle
能让反复作业更加简单的功能

00:20:47.276 --> 00:20:50.136 A:middle
比如 多项选择

00:20:50.506 --> 00:20:53.236 A:middle
核心数据可以通过分批操作

00:20:53.266 --> 00:20:54.826 A:middle
来支持这个功能

00:20:55.976 --> 00:20:57.946 A:middle
事实上 通过几行代码

00:20:57.946 --> 00:20:59.436 A:middle
我们就能对整组图片

00:20:59.436 --> 00:21:02.826 A:middle
标记喜欢或不喜欢

00:20:59.436 --> 00:21:02.826 A:middle
标记喜欢或不喜欢

00:21:03.596 --> 00:21:05.376 A:middle
通过一行代码

00:21:05.376 --> 00:21:07.046 A:middle
我们可以使用分批删除

00:21:07.046 --> 00:21:09.706 A:middle
将记录从数据库里清除

00:21:09.976 --> 00:21:12.256 A:middle
这种行为规模

00:21:12.256 --> 00:21:14.716 A:middle
不可能将对象

00:21:14.716 --> 00:21:15.096 A:middle
分解进内存

00:21:15.886 --> 00:21:19.556 A:middle
举个例子 在删除过程中

00:21:19.556 --> 00:21:22.306 A:middle
传统的调用 NSManagedObject.delete 将使

00:21:22.446 --> 00:21:24.836 A:middle
数据库中记录的大小增加

00:21:24.906 --> 00:21:26.116 A:middle
当你删除对象时

00:21:26.116 --> 00:21:27.336 A:middle
你的内存被分解到上下文中

00:21:27.336 --> 00:21:29.436 A:middle
你的数据库越大

00:21:29.436 --> 00:21:32.086 A:middle
它就越贵

00:21:32.716 --> 00:21:34.036 A:middle
但是通过分批操作

00:21:34.036 --> 00:21:36.106 A:middle
我们可以在一小部分内存里

00:21:36.106 --> 00:21:37.706 A:middle
进行同样的变化

00:21:38.276 --> 00:21:39.716 A:middle
它有我们想要的曲线关系

00:21:39.716 --> 00:21:42.756 A:middle
即当数据增加时

00:21:42.756 --> 00:21:44.626 A:middle
数据集越大

00:21:44.626 --> 00:21:46.976 A:middle
我们使用的内存越小

00:21:46.976 --> 00:21:48.696 A:middle
删除 1000 万行

00:21:48.696 --> 00:21:50.606 A:middle
我们只需用到

00:21:50.606 --> 00:21:51.156 A:middle
传统内存的 7%

00:21:52.556 --> 00:21:54.076 A:middle
这是一个

00:21:54.076 --> 00:21:55.296 A:middle
节约你的用户设备内存的

00:21:55.296 --> 00:21:57.066 A:middle
有力方式

00:21:57.956 --> 00:21:59.176 A:middle
但是分批操作的

00:21:59.176 --> 00:22:00.976 A:middle
一个传统问题是

00:21:59.176 --> 00:22:00.976 A:middle
一个传统问题是

00:22:01.596 --> 00:22:02.776 A:middle
很难操作

00:22:02.776 --> 00:22:03.926 A:middle
因为它不生成

00:22:03.926 --> 00:22:05.606 A:middle
存储提醒

00:22:06.376 --> 00:22:07.426 A:middle
这里就是把历史追踪功能

00:22:07.426 --> 00:22:08.176 A:middle
引回来的部分

00:22:09.026 --> 00:22:10.016 A:middle
使用持续历史追踪

00:22:10.016 --> 00:22:11.306 A:middle
我们可以将

00:22:11.306 --> 00:22:12.846 A:middle
分组删除或者更新的处理

00:22:13.286 --> 00:22:14.266 A:middle
从数据库中分离出来

00:22:14.266 --> 00:22:17.156 A:middle
我们可以使用 objectIDNotification 方法

00:22:17.156 --> 00:22:18.996 A:middle
来生成一个提醒

00:22:18.996 --> 00:22:21.676 A:middle
让它像存储提醒

00:22:21.676 --> 00:22:22.866 A:middle
那样工作

00:22:23.386 --> 00:22:24.786 A:middle
这样 读取结果控制器或者

00:22:24.786 --> 00:22:26.666 A:middle
其他在你的 App 中的上下文就可以

00:22:26.666 --> 00:22:29.846 A:middle
渐增式地更新

00:22:29.846 --> 00:22:30.656 A:middle
这些提醒了

00:22:31.226 --> 00:22:35.546 A:middle
所以这些是你能

00:22:35.546 --> 00:22:37.016 A:middle
管理逐渐增加的数据的方式

00:22:37.016 --> 00:22:40.586 A:middle
但是工作流程自身呢

00:22:40.966 --> 00:22:43.396 A:middle
核心数据可以为开发者和程序员

00:22:43.396 --> 00:22:45.426 A:middle
做些什么

00:22:45.426 --> 00:22:46.886 A:middle
来使构建和测试你的 App 变得

00:22:46.886 --> 00:22:47.726 A:middle
更简单

00:22:49.166 --> 00:22:51.136 A:middle
我们能做的第一件事就是

00:22:51.136 --> 00:22:52.286 A:middle
帮助你感知未来

00:22:53.856 --> 00:22:55.576 A:middle
你可能知道

00:22:55.576 --> 00:22:56.326 A:middle
NSKeyedArchiver 是在变化的

00:22:57.056 --> 00:22:58.416 A:middle
我们在所有平台上

00:22:58.416 --> 00:23:00.926 A:middle
使用安全代码

00:22:58.416 --> 00:23:00.926 A:middle
使用安全代码

00:23:01.016 --> 00:23:03.146 A:middle
今年 KeyedArchiver API

00:23:03.146 --> 00:23:04.596 A:middle
的剧烈变化

00:23:04.596 --> 00:23:05.436 A:middle
也证实了这一点

00:23:06.496 --> 00:23:07.786 A:middle
对于核心数据来说

00:23:07.786 --> 00:23:09.586 A:middle
这意味着数值转换器是变化的

00:23:09.586 --> 00:23:11.066 A:middle
所以如果在你的托管对象模型中

00:23:11.066 --> 00:23:13.086 A:middle
有一个可转换的属性

00:23:13.086 --> 00:23:14.916 A:middle
而你今天没有发送数值转换器

00:23:14.916 --> 00:23:16.876 A:middle
你将与默认的

00:23:16.876 --> 00:23:17.836 A:middle
数值转换器一样

00:23:18.036 --> 00:23:20.696 A:middle
从 DataTransformer 得到

00:23:20.936 --> 00:23:22.316 A:middle
NSKeyedUnarchive

00:23:22.916 --> 00:23:25.616 A:middle
在未来 你将从 DataTransformer

00:23:25.736 --> 00:23:28.196 A:middle
得到 NSSecureUnarchive

00:23:28.196 --> 00:23:29.496 A:middle
它在内部执行安全代码

00:23:29.496 --> 00:23:31.576 A:middle
各位应该在今天就采用它

00:23:32.176 --> 00:23:33.416 A:middle
今天早上有一场非常棒的演讲

00:23:33.416 --> 00:23:35.496 A:middle
名为可以信赖的数据

00:23:36.976 --> 00:23:38.216 A:middle
我强烈建议各位

00:23:38.636 --> 00:23:40.006 A:middle
看看这个演讲

00:23:40.006 --> 00:23:41.666 A:middle
并对安全代码和

00:23:41.666 --> 00:23:43.496 A:middle
如何将你的 App 的适应力

00:23:43.496 --> 00:23:44.706 A:middle
变得更强

00:23:44.706 --> 00:23:45.146 A:middle
有更多的了解

00:23:48.246 --> 00:23:49.356 A:middle
你可以在数值转换器名称字段里

00:23:49.356 --> 00:23:50.266 A:middle
通过使用

00:23:50.266 --> 00:23:52.976 A:middle
带有可转换属性的模型编辑器

00:23:52.976 --> 00:23:54.766 A:middle
来指定它

00:23:55.716 --> 00:23:59.676 A:middle
今天 我希望各位可以自己执行它

00:24:00.146 --> 00:24:01.566 A:middle
在未来的版本中

00:24:01.566 --> 00:24:03.506 A:middle
它将成为默认项

00:24:03.506 --> 00:24:04.986 A:middle
在未来的 Xcode 版本中

00:24:04.986 --> 00:24:06.266 A:middle
它也将向使用

00:24:06.266 --> 00:24:07.886 A:middle
默认转换器名称的用户

00:24:07.886 --> 00:24:08.706 A:middle
发出警示

00:24:10.036 --> 00:24:10.956 A:middle
如果你在用代码

00:24:10.956 --> 00:24:13.056 A:middle
构建模型 你可以通过使用 NSAttribute

00:24:13.056 --> 00:24:15.996 A:middle
介绍上的 valueTransformerName 属性

00:24:15.996 --> 00:24:16.416 A:middle
来对它进行设置

00:24:17.726 --> 00:24:19.046 A:middle
如果你不是在编码自定义类类型

00:24:19.046 --> 00:24:21.176 A:middle
那么这对你来说

00:24:21.176 --> 00:24:22.256 A:middle
是很显而易见的

00:24:22.296 --> 00:24:23.926 A:middle
对于 plist 类型

00:24:23.926 --> 00:24:24.306 A:middle
这是一个无指令操作

00:24:24.756 --> 00:24:25.806 A:middle
你只需要简单的更改

00:24:25.806 --> 00:24:27.336 A:middle
数值转换器名称

00:24:27.336 --> 00:24:28.726 A:middle
就能得到新的安全编码行为

00:24:29.286 --> 00:24:30.856 A:middle
但如果你使用了自定义类

00:24:30.856 --> 00:24:32.456 A:middle
这些类则需要采用安全代码

00:24:32.456 --> 00:24:34.786 A:middle
你可以到实验室来

00:24:34.846 --> 00:24:37.616 A:middle
向我们寻求帮助

00:24:38.296 --> 00:24:40.486 A:middle
但我们其实可以帮你更多

00:24:41.286 --> 00:24:42.866 A:middle
在核心数据里

00:24:43.066 --> 00:24:44.726 A:middle
多年来我们花时间

00:24:45.026 --> 00:24:46.566 A:middle
构建新的调试工具

00:24:46.566 --> 00:24:47.796 A:middle
能够帮助你理解

00:24:47.796 --> 00:24:48.236 A:middle
在堆栈下发生的事

00:24:49.026 --> 00:24:52.536 A:middle
这是我们更喜欢的 默认方案配置

00:24:52.866 --> 00:24:54.686 A:middle
我们有一些过程参数

00:24:54.686 --> 00:24:56.396 A:middle
能帮助你获得更多关于 SQLite 的

00:24:56.396 --> 00:24:57.386 A:middle
调试信息

00:24:57.386 --> 00:25:00.746 A:middle
但是 有一个你需要永远记得运行的

00:24:57.386 --> 00:25:00.746 A:middle
但是 有一个你需要永远记得运行的

00:25:00.746 --> 00:25:02.566 A:middle
是 com.Apple.Core

00:25:02.566 --> 00:25:04.066 A:middle
和 Data.ConcurrencyDebug.

00:25:04.616 --> 00:25:06.266 A:middle
它将抓取你的 App 中

00:25:06.266 --> 00:25:07.746 A:middle
任何的队列异常

00:25:07.746 --> 00:25:09.396 A:middle
从主队列和后台队列上下文之间

00:25:09.396 --> 00:25:10.766 A:middle
你可能进行

00:25:10.766 --> 00:25:14.066 A:middle
传输的地方 或者

00:25:14.066 --> 00:25:15.566 A:middle
不遵循托管对象的

00:25:15.566 --> 00:25:18.666 A:middle
真实上下文的地方

00:25:18.746 --> 00:25:20.466 A:middle
SQLite 也有很多

00:25:20.466 --> 00:25:21.506 A:middle
有趣的环境变量

00:25:21.506 --> 00:25:23.206 A:middle
所以它们的线程和

00:25:23.206 --> 00:25:24.756 A:middle
文件的断言函数

00:25:24.756 --> 00:25:25.836 A:middle
能很好地

00:25:25.836 --> 00:25:27.286 A:middle
保证你的 App 中

00:25:27.286 --> 00:25:29.746 A:middle
的 API 以及文件系统的正确率

00:25:30.576 --> 00:25:32.386 A:middle
自动追踪是一种使你

00:25:32.386 --> 00:25:33.496 A:middle
看到内部发生了什么的好方法

00:25:33.496 --> 00:25:34.826 A:middle
是一个对调试日志的

00:25:34.826 --> 00:25:36.046 A:middle
追加行程

00:25:36.856 --> 00:25:39.646 A:middle
com.Apple.CoreData.SQLDebug

00:25:39.646 --> 00:25:40.676 A:middle
有四个层级

00:25:41.106 --> 00:25:43.206 A:middle
第一层级是最有趣的

00:25:43.206 --> 00:25:44.636 A:middle
也是系统还原备份

00:25:44.636 --> 00:25:45.466 A:middle
最少的

00:25:45.466 --> 00:25:47.826 A:middle
第四层是最冗长的

00:25:47.826 --> 00:25:49.126 A:middle
但是在运行过程中

00:25:49.126 --> 00:25:51.006 A:middle
产生大量的

00:25:51.006 --> 00:25:53.726 A:middle
系统还原备份

00:25:53.996 --> 00:25:55.696 A:middle
当你启用 SQL 调试

00:25:55.806 --> 00:25:57.146 A:middle
和多线程断言时

00:25:57.146 --> 00:25:58.476 A:middle
你会在控制台中看到

00:25:58.506 --> 00:26:00.456 A:middle
几个运行记录

00:25:58.506 --> 00:26:00.456 A:middle
几个运行记录

00:26:00.456 --> 00:26:01.356 A:middle
它们象征着

00:26:01.356 --> 00:26:02.526 A:middle
断言函数能够

00:26:02.526 --> 00:26:03.366 A:middle
正确运行

00:26:04.636 --> 00:26:06.076 A:middle
当我们使用 SQL debugging 时

00:26:06.076 --> 00:26:07.456 A:middle
你将可以看到例如

00:26:07.456 --> 00:26:08.656 A:middle
读取请求的选择语句

00:26:08.656 --> 00:26:10.866 A:middle
以及它需要花费多长时间

00:26:11.706 --> 00:26:13.016 A:middle
如果你被设置为第四级

00:26:13.016 --> 00:26:14.766 A:middle
你甚至会得到 explain

00:26:15.026 --> 00:26:16.056 A:middle
向你展示

00:26:16.056 --> 00:26:17.836 A:middle
给定的选择语句的

00:26:18.186 --> 00:26:19.016 A:middle
查询计划

00:26:19.586 --> 00:26:20.936 A:middle
在这里我们能看到

00:26:20.936 --> 00:26:23.786 A:middle
我们的表格视图通过

00:26:23.786 --> 00:26:25.856 A:middle
表扫描进行筛选

00:26:25.856 --> 00:26:27.866 A:middle
然后按照时间戳的顺序

00:26:27.866 --> 00:26:29.646 A:middle
使用内存中的 B 树

00:26:30.536 --> 00:26:31.876 A:middle
这是个潜在的性能问题

00:26:31.876 --> 00:26:33.766 A:middle
当你在运行你的 App 时

00:26:33.766 --> 00:26:35.006 A:middle
你可以使用这样的

00:26:35.006 --> 00:26:37.116 A:middle
信息来看

00:26:37.116 --> 00:26:38.506 A:middle
你是否做了比你所需要的做的

00:26:38.506 --> 00:26:39.086 A:middle
更多的工作

00:26:40.346 --> 00:26:41.496 A:middle
所以 我们该怎么修正它

00:26:42.946 --> 00:26:45.816 A:middle
事实上我们发现

00:26:45.816 --> 00:26:46.776 A:middle
SQLite3 可以告诉我们

00:26:47.476 --> 00:26:49.166 A:middle
如果我们打开一个数据库

00:26:49.166 --> 00:26:50.696 A:middle
将我们的 SQL 日志里的选择查询传递给它

00:26:50.696 --> 00:26:52.926 A:middle
我们就能够启动一个

00:26:52.926 --> 00:26:54.616 A:middle
成为 Expert 的模式

00:26:54.616 --> 00:26:56.396 A:middle
它能够对队列进行分析

00:26:56.436 --> 00:26:58.616 A:middle
然后通过创建覆盖索引

00:26:58.616 --> 00:27:00.366 A:middle
给出合适的优化方案

00:26:58.616 --> 00:27:00.366 A:middle
给出合适的优化方案

00:27:01.366 --> 00:27:02.606 A:middle
如果我们能通过

00:27:02.606 --> 00:27:05.256 A:middle
对发布实体增加读取索引

00:27:05.576 --> 00:27:06.416 A:middle
来在模型编辑器里做这件事

00:27:07.066 --> 00:27:10.216 A:middle
这里我已经将它配置在时间戳上

00:27:10.216 --> 00:27:12.676 A:middle
将它们以递减的顺序调出

00:27:12.676 --> 00:27:13.786 A:middle
我们将最近的帖子

00:27:13.786 --> 00:27:15.526 A:middle
展示在表格视图的最上端

00:27:17.676 --> 00:27:19.106 A:middle
当我们再次运行 App 时

00:27:19.106 --> 00:27:20.976 A:middle
我们会看到同样的选择日志

00:27:24.386 --> 00:27:26.546 A:middle
除了这一次

00:27:26.546 --> 00:27:27.876 A:middle
我们看到选择查询

00:27:27.876 --> 00:27:29.616 A:middle
在查询中达到了覆盖索引

00:27:30.126 --> 00:27:31.726 A:middle
解释命令告诉我们

00:27:31.726 --> 00:27:38.296 A:middle
查询将使用覆盖索引进行排序

00:27:38.536 --> 00:27:39.966 A:middle
核心数据支持很多类型的索引

00:27:39.966 --> 00:27:43.356 A:middle
包括使用 R 树的符合索引

00:27:43.906 --> 00:27:45.646 A:middle
这对创建

00:27:45.646 --> 00:27:47.346 A:middle
任何类型的查询

00:27:47.346 --> 00:27:49.806 A:middle
或者在选择语句里

00:27:50.406 --> 00:27:51.536 A:middle
使用边界框的优化查询都很有用

00:27:52.196 --> 00:27:53.386 A:middle
最常见的用途是为了定位

00:27:53.426 --> 00:27:55.216 A:middle
我们可以通过向发布实体

00:27:55.216 --> 00:27:57.396 A:middle
增加另一个索引来对它进行设置

00:27:57.396 --> 00:27:58.876 A:middle
为了展示这张幻灯片

00:27:58.876 --> 00:28:00.396 A:middle
我添加了

00:27:58.876 --> 00:28:00.396 A:middle
我添加了

00:28:00.396 --> 00:28:02.536 A:middle
经纬度属性

00:28:04.816 --> 00:28:06.836 A:middle
我们通过选择 R 树

00:28:06.836 --> 00:28:08.246 A:middle
更改了盒子里的查询类型

00:28:08.796 --> 00:28:10.836 A:middle
我们可以在读取请求上

00:28:10.836 --> 00:28:12.556 A:middle
设置谓词

00:28:13.206 --> 00:28:14.906 A:middle
然后获得所有

00:28:14.906 --> 00:28:16.516 A:middle
在中国大陆境内发布的帖子

00:28:18.406 --> 00:28:20.186 A:middle
这种谓词比较高级

00:28:20.186 --> 00:28:21.656 A:middle
因为它使用

00:28:21.716 --> 00:28:24.306 A:middle
实际选择语句里的功能

00:28:24.306 --> 00:28:26.256 A:middle
来找到

00:28:26.256 --> 00:28:27.676 A:middle
我们在托管对象模型里

00:28:27.676 --> 00:28:28.676 A:middle
创建的索引

00:28:31.556 --> 00:28:33.266 A:middle
我们在没有这个索引和谓词的情况下

00:28:33.266 --> 00:28:35.016 A:middle
运行 App

00:28:35.016 --> 00:28:36.596 A:middle
可以看到和我们之前

00:28:36.596 --> 00:28:38.266 A:middle
仅使用时间戳索引

00:28:38.726 --> 00:28:41.826 A:middle
得到的结果是相同的

00:28:42.366 --> 00:28:44.956 A:middle
但是当我们在没有

00:28:44.956 --> 00:28:47.196 A:middle
新的索引和谓词的情况下运行时

00:28:47.196 --> 00:28:48.956 A:middle
SQLite 会使用索引来

00:28:48.956 --> 00:28:51.626 A:middle
为两个语句

00:28:51.626 --> 00:28:53.056 A:middle
生成更快速的结果

00:28:55.026 --> 00:28:56.806 A:middle
不幸的是

00:28:56.806 --> 00:28:58.446 A:middle
我们的时间戳索引没有

00:28:58.446 --> 00:28:59.656 A:middle
任何的复合谓词

00:28:59.976 --> 00:29:01.566 A:middle
SQLite 不能用它

00:28:59.976 --> 00:29:01.566 A:middle
SQLite 不能用它

00:29:01.566 --> 00:29:02.006 A:middle
来进行排序

00:29:02.556 --> 00:29:04.776 A:middle
我们在这里选择的优化

00:29:04.776 --> 00:29:07.216 A:middle
是使用复合索引

00:29:07.216 --> 00:29:08.636 A:middle
首先过滤掉更小的对象组

00:29:08.636 --> 00:29:11.676 A:middle
然后用内存中的 B 树

00:29:11.676 --> 00:29:13.736 A:middle
来进行排序

00:29:14.336 --> 00:29:18.536 A:middle
就像各位看到的

00:29:18.536 --> 00:29:20.186 A:middle
这个索引将我们的读取性能

00:29:20.186 --> 00:29:22.286 A:middle
提高了 25%

00:29:23.986 --> 00:29:25.256 A:middle
这种情况下

00:29:25.256 --> 00:29:27.066 A:middle
性能测试是运行大概 100,000 行

00:29:27.066 --> 00:29:29.726 A:middle
我们看到

00:29:29.726 --> 00:29:31.616 A:middle
仅对于读取函数而言

00:29:31.616 --> 00:29:33.036 A:middle
就有了 130 毫秒的提高

00:29:34.476 --> 00:29:35.876 A:middle
这就引出了我的下一个话题

00:29:36.196 --> 00:29:37.466 A:middle
核心数据的测试

00:29:38.646 --> 00:29:40.716 A:middle
正如各位所知

00:29:40.716 --> 00:29:41.086 A:middle
我们非常喜欢测试

00:29:41.656 --> 00:29:42.476 A:middle
测试很棒

00:29:43.026 --> 00:29:45.156 A:middle
在核心数据里

00:29:45.156 --> 00:29:46.686 A:middle
我们在内部既使用它们检测正确性

00:29:46.686 --> 00:29:48.476 A:middle
又使用它们学习

00:29:48.906 --> 00:29:49.826 A:middle
核心数据的功能

00:29:49.826 --> 00:29:51.026 A:middle
以及 API

00:29:51.026 --> 00:29:54.406 A:middle
在给定的条件下的行为

00:29:55.316 --> 00:29:56.326 A:middle
同时也能很好地

00:29:56.326 --> 00:29:58.876 A:middle
验证你关于核心数据的工作

00:29:58.986 --> 00:30:00.806 A:middle
以及它将如何在你的 App 中

00:29:58.986 --> 00:30:00.806 A:middle
以及它将如何在你的 App 中

00:30:00.806 --> 00:30:02.916 A:middle
帮助你的顾客获得

00:30:02.916 --> 00:30:03.716 A:middle
更好的体验

00:30:04.266 --> 00:30:05.316 A:middle
就像各位在前一个例子中看到的

00:30:05.316 --> 00:30:06.916 A:middle
我们能够验证

00:30:06.916 --> 00:30:08.966 A:middle
R 树索引可以

00:30:08.966 --> 00:30:10.456 A:middle
优化性能

00:30:10.456 --> 00:30:11.466 A:middle
虽然它使用的是内存里的

00:30:11.466 --> 00:30:12.186 A:middle
B 树排序

00:30:14.276 --> 00:30:16.136 A:middle
但同样能捕捉到你的产品需求

00:30:16.136 --> 00:30:17.686 A:middle
在核心数据里

00:30:17.686 --> 00:30:19.456 A:middle
这对我们十分重要

00:30:19.456 --> 00:30:20.896 A:middle
因为它能帮助我们

00:30:20.896 --> 00:30:22.296 A:middle
与你的期望沟通

00:30:22.786 --> 00:30:24.026 A:middle
通过测试

00:30:24.026 --> 00:30:25.566 A:middle
我们可以看到你在用代码做什么

00:30:25.566 --> 00:30:27.296 A:middle
以及你希望这些代码

00:30:27.296 --> 00:30:28.546 A:middle
如何服务你的顾客

00:30:29.686 --> 00:30:30.816 A:middle
你可以设置一些重要的东西

00:30:30.816 --> 00:30:31.976 A:middle
使你的工作更容易一些

00:30:31.976 --> 00:30:36.196 A:middle
比如 能够生成持久化容器的

00:30:36.196 --> 00:30:37.236 A:middle
基础类别

00:30:38.406 --> 00:30:39.926 A:middle
屏幕上的基础类别

00:30:39.926 --> 00:30:41.856 A:middle
为持久化存储使用了

00:30:41.856 --> 00:30:43.426 A:middle
/dev/null 的文件 URL

00:30:43.426 --> 00:30:45.316 A:middle
这是一种很好的测试方式

00:30:45.316 --> 00:30:48.506 A:middle
它对一小部分的托管对象起作用

00:30:48.506 --> 00:30:50.446 A:middle
且运行十分迅速

00:30:50.446 --> 00:30:52.076 A:middle
因为它们将在整个内存里运行

00:30:52.776 --> 00:30:54.726 A:middle
当你这样做时

00:30:54.726 --> 00:30:56.306 A:middle
SQLite 实现了一个内存中的存储

00:30:56.306 --> 00:30:57.866 A:middle
非常高效

00:30:57.866 --> 00:30:59.596 A:middle
但是因为是在内存里

00:30:59.596 --> 00:31:00.756 A:middle
如果你有很多数据

00:30:59.596 --> 00:31:00.756 A:middle
如果你有很多数据

00:31:00.756 --> 00:31:03.536 A:middle
会导致你的测试套件中

00:31:03.976 --> 00:31:04.146 A:middle
内存大量增长

00:31:07.616 --> 00:31:11.676 A:middle
不过 你需要完成至少一次测试

00:31:11.676 --> 00:31:13.506 A:middle
在磁盘上将存储文件具体化

00:31:14.026 --> 00:31:15.746 A:middle
这是因为

00:31:15.746 --> 00:31:16.806 A:middle
如果不能为了

00:31:16.806 --> 00:31:18.316 A:middle
你的测试打开存储

00:31:18.316 --> 00:31:19.436 A:middle
那你的顾客也打不开

00:31:21.076 --> 00:31:22.546 A:middle
如果持久化容器

00:31:22.546 --> 00:31:24.156 A:middle
在 App 代理里

00:31:24.156 --> 00:31:25.506 A:middle
你会有一个测试基类

00:31:25.506 --> 00:31:26.866 A:middle
能将容器取出

00:31:26.866 --> 00:31:28.506 A:middle
然后直接写入内存

00:31:29.296 --> 00:31:31.496 A:middle
不过当你这样做时

00:31:31.496 --> 00:31:33.086 A:middle
我必须提醒你

00:31:33.086 --> 00:31:34.106 A:middle
因为这意味着

00:31:34.106 --> 00:31:35.566 A:middle
你在写入一个

00:31:35.566 --> 00:31:37.776 A:middle
被 App 使用的内存文件

00:31:37.776 --> 00:31:38.916 A:middle
所以如果你在个人设备上

00:31:38.916 --> 00:31:40.646 A:middle
运行测试

00:31:40.646 --> 00:31:42.006 A:middle
你将在下次打开 App 的时候

00:31:42.006 --> 00:31:47.316 A:middle
看到你单元测试的结果

00:31:47.536 --> 00:31:48.446 A:middle
如果我告诉你

00:31:48.446 --> 00:31:50.316 A:middle
我能用 7 行代码

00:31:50.316 --> 00:31:51.236 A:middle
添加 100,000 个记录呢

00:31:53.806 --> 00:31:55.036 A:middle
其实有一点作弊

00:31:55.036 --> 00:31:56.356 A:middle
我会把这个当做

00:31:56.356 --> 00:31:58.556 A:middle
留给观众的练习

00:31:58.556 --> 00:31:59.946 A:middle
但是这种方式的支架代码

00:31:59.946 --> 00:32:01.306 A:middle
可以帮助你构建一个

00:31:59.946 --> 00:32:01.306 A:middle
可以帮助你构建一个

00:32:01.306 --> 00:32:02.556 A:middle
测试套件

00:32:02.556 --> 00:32:04.016 A:middle
来评估你的数据的不变性

00:32:04.976 --> 00:32:06.386 A:middle
通过提前构建这些方法

00:32:06.386 --> 00:32:08.496 A:middle
当你的数据变化 或者你意识到

00:32:08.496 --> 00:32:09.876 A:middle
你的 App 的新用例时

00:32:09.876 --> 00:32:11.626 A:middle
你可以通过迭代

00:32:11.626 --> 00:32:13.486 A:middle
来构建新的边界情况

00:32:13.486 --> 00:32:14.756 A:middle
来为对象图

00:32:14.756 --> 00:32:15.826 A:middle
构建新的结构

00:32:15.826 --> 00:32:17.946 A:middle
或者在内部

00:32:17.946 --> 00:32:19.186 A:middle
评估一些特定功能的行为

00:32:19.186 --> 00:32:21.776 A:middle
例如性能

00:32:22.146 --> 00:32:25.606 A:middle
这是我用来为

00:32:25.606 --> 00:32:26.566 A:middle
R 树查询

00:32:26.566 --> 00:32:28.466 A:middle
构建性能测试的单元测试支架

00:32:29.176 --> 00:32:30.496 A:middle
仅仅在几行代码中

00:32:30.496 --> 00:32:32.456 A:middle
我们可以对

00:32:32.456 --> 00:32:33.886 A:middle
读取性能很有信心

00:32:34.836 --> 00:32:36.286 A:middle
这些类型的测试

00:32:36.286 --> 00:32:37.466 A:middle
信息量很大

00:32:37.466 --> 00:32:38.996 A:middle
当你尝试去评估

00:32:38.996 --> 00:32:40.386 A:middle
核心数据里

00:32:40.386 --> 00:32:44.896 A:middle
不一样的功能之间的权衡

00:32:45.316 --> 00:32:46.576 A:middle
这三行代码

00:32:46.576 --> 00:32:47.936 A:middle
生成了新的托管对象上下文

00:32:47.936 --> 00:32:49.976 A:middle
以及一个容器

00:32:49.976 --> 00:32:50.946 A:middle
供我们的测试使用

00:32:51.756 --> 00:32:54.206 A:middle
现在这点很重要

00:32:54.206 --> 00:32:55.606 A:middle
主要是因为在测试中

00:32:55.606 --> 00:32:57.786 A:middle
setup 和 teardown 方法的逻辑可以

00:32:57.786 --> 00:32:59.066 A:middle
对性能表现产生影响

00:32:59.696 --> 00:33:01.196 A:middle
所以需要注意分析

00:32:59.696 --> 00:33:01.196 A:middle
所以需要注意分析

00:33:01.196 --> 00:33:02.836 A:middle
你是否真的在测试

00:33:02.836 --> 00:33:04.226 A:middle
setup 方法

00:33:04.226 --> 00:33:05.256 A:middle
还是 teardown 方法

00:33:05.256 --> 00:33:06.946 A:middle
还是你在评估

00:33:06.946 --> 00:33:08.216 A:middle
查询命令的

00:33:08.216 --> 00:33:09.626 A:middle
实际运行性能

00:33:10.556 --> 00:33:11.546 A:middle
在你运行测试之后

00:33:11.546 --> 00:33:14.046 A:middle
你可以提交好的错误报告

00:33:15.526 --> 00:33:17.346 A:middle
我们喜欢错误

00:33:17.346 --> 00:33:18.546 A:middle
特别是从你们这里反馈的错误

00:33:18.546 --> 00:33:19.796 A:middle
因为我们在构建一个产品

00:33:19.796 --> 00:33:20.606 A:middle
希望它能帮助你构建你的 App

00:33:21.206 --> 00:33:26.486 A:middle
但是 没有测试或示例 App

00:33:26.486 --> 00:33:28.126 A:middle
对我们而言是很难理解的

00:33:28.126 --> 00:33:29.906 A:middle
就像我前面提到的

00:33:29.906 --> 00:33:30.696 A:middle
它们不会

00:33:30.696 --> 00:33:33.046 A:middle
像结构良好的测试那样

00:33:33.046 --> 00:33:35.206 A:middle
捕捉你的产品需求和期待

00:33:35.206 --> 00:33:37.366 A:middle
事实上

00:33:37.956 --> 00:33:39.716 A:middle
一个连接到 Radar 的 App

00:33:39.716 --> 00:33:41.756 A:middle
如果有测试套装

00:33:41.756 --> 00:33:43.526 A:middle
哪怕是一个空的

00:33:44.086 --> 00:33:46.186 A:middle
带有一些 UI 的示例 App

00:33:46.406 --> 00:33:48.436 A:middle
能向我们解释你的问题

00:33:48.436 --> 00:33:50.076 A:middle
我们也能更快回复你

00:33:50.236 --> 00:33:52.706 A:middle
并告诉你该怎么做

00:33:53.596 --> 00:33:55.106 A:middle
它们同样能帮助我们分辨

00:33:55.106 --> 00:33:56.616 A:middle
我们后续修复的准确性

00:33:57.066 --> 00:33:58.226 A:middle
所以 如果你要填写一份错误报告

00:33:58.226 --> 00:34:00.806 A:middle
请花一点时间

00:33:58.226 --> 00:34:00.806 A:middle
请花一点时间

00:34:00.806 --> 00:34:02.266 A:middle
写一个测试给我们

00:34:04.296 --> 00:34:05.476 A:middle
这就是我今天要讲的所有内容

00:34:05.956 --> 00:34:08.156 A:middle
大家明天可以到实验室来找我们

00:34:08.335 --> 00:34:10.946 A:middle
我们会从下午 1:30 开始

00:34:10.946 --> 00:34:13.315 A:middle
在 7 号技术实验室

00:34:13.315 --> 00:34:14.286 A:middle
我也强烈建议大家

00:34:14.286 --> 00:34:15.826 A:middle
了解一下明天下午 3:20 在大厅 2

00:34:15.826 --> 00:34:17.585 A:middle
举行的测试技巧与诀窍会议

00:34:18.896 --> 00:34:19.906 A:middle
谢谢

00:34:20.507 --> 00:34:22.507 A:middle
[ 掌声 ]
