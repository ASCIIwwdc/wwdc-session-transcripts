WEBVTT

00:00:17.150 --> 00:00:22.055 align:middle line:0
（Metal游戏性能优化）

00:00:22.122 --> 00:00:24.491 align:middle line:0
（演讲612）

00:00:29.329 --> 00:00:31.231 align:middle line:0
早上好 欢迎来到本次演讲

00:00:31.832 --> 00:00:34.368 align:middle line:-1
我叫Guillem Vinals Gangolells

00:00:34.434 --> 00:00:37.604 align:middle line:-2
在Apple的
GPU软件性能团队工作

00:00:38.839 --> 00:00:42.709 align:middle line:-2
你们这样的游戏开发者
使iOS成为一个优秀的游戏平台

00:00:43.243 --> 00:00:45.546 align:middle line:-2
在Apple
我们当然想助一臂之力

00:00:46.380 --> 00:00:49.216 align:middle line:-2
所以今年
我们检查了一些顶级的iOS游戏

00:00:49.583 --> 00:00:51.552 align:middle line:-1
并发现了一些常见的性能问题

00:00:52.386 --> 00:00:53.921 align:middle line:-1
我们分析了很多数据

00:00:54.188 --> 00:00:56.023 align:middle line:-1
作为调查的结果

00:00:56.423 --> 00:00:58.225 align:middle line:-1
我们决定做这个谈话

00:00:59.860 --> 00:01:01.862 align:middle line:-1
所以这将是今天的主题

00:00:59.860 --> 00:01:01.862 align:middle line:-1
所以这将是今天的主题

00:01:02.296 --> 00:01:03.730 align:middle line:-1
开发出色的游戏

00:01:04.965 --> 00:01:07.868 align:middle line:-1
但是 我只能在这里提供技术指导

00:01:07.935 --> 00:01:09.303 align:middle line:-1
所以我们只能满足于此

00:01:09.369 --> 00:01:11.238 align:middle line:-1
（开发技术出色的游戏）

00:01:11.305 --> 00:01:12.272 align:middle line:-1
在开始之前

00:01:12.940 --> 00:01:14.908 align:middle line:-1
我想借机感谢Croteam的朋友

00:01:15.309 --> 00:01:17.711 align:middle line:-1
他们是《塔洛斯法则》背后的开发者

00:01:18.011 --> 00:01:19.546 align:middle line:-1
这是一款非常棒的游戏

00:01:19.847 --> 00:01:22.716 align:middle line:-2
你将在这些幻灯片
和两个演示中看到它

00:01:23.917 --> 00:01:26.787 align:middle line:-1
请注意 它具有令人惊叹的视觉效果

00:01:27.221 --> 00:01:29.623 align:middle line:-1
但它确实在性能上没变差

00:01:29.990 --> 00:01:31.458 align:middle line:-1
这就是我们今天的目标

00:01:32.059 --> 00:01:34.027 align:middle line:-1
让我们快速过一下今天的议题

00:01:36.396 --> 00:01:38.398 align:middle line:-1
我将首先介绍这些工具

00:01:38.832 --> 00:01:40.367 align:middle line:-1
这是一个非常好的起步

00:01:40.868 --> 00:01:43.804 align:middle line:-1
然后我们将讨论实际的性能问题

00:01:44.371 --> 00:01:48.141 align:middle line:-1
有关帧速 线程优先级 热状态

00:01:48.509 --> 00:01:50.043 align:middle line:-1
和不必要的GPU工作

00:01:51.078 --> 00:01:53.780 align:middle line:-1
尽管所有这些问题似乎互不相关

00:01:54.281 --> 00:01:56.283 align:middle line:-1
它们会互相复合和影响

00:01:56.483 --> 00:01:58.118 align:middle line:-1
所以解决所有这些问题很重要

00:01:59.820 --> 00:02:01.021 align:middle line:-1
让我们从工具开始

00:01:59.820 --> 00:02:01.021 align:middle line:-1
让我们从工具开始

00:02:01.788 --> 00:02:03.690 align:middle line:-1
（分析工具）

00:02:03.757 --> 00:02:04.625 align:middle line:-1
（及早分析及经常分析）

00:02:04.691 --> 00:02:06.493 align:middle line:-1
这是最重要的建议

00:02:06.760 --> 00:02:09.429 align:middle line:-1
你应该尽早建档分析并经常更新

00:02:10.564 --> 00:02:13.233 align:middle line:-2
除非你已经对游戏进行了分析
否则不要推出游戏

00:02:13.967 --> 00:02:16.570 align:middle line:-1
为此 你需要了解这些工具

00:02:17.471 --> 00:02:19.940 align:middle line:-1
今天 我将关注其中两个

00:02:20.941 --> 00:02:22.709 align:middle line:-2
首先
我们看Instruments

00:02:23.043 --> 00:02:24.678 align:middle line:-1
这是我们的主要分析工具

00:02:25.345 --> 00:02:27.581 align:middle line:-1
你会想用它来理解性能

00:02:28.148 --> 00:02:30.284 align:middle line:-1
延迟和总体时间

00:02:31.151 --> 00:02:33.687 align:middle line:-1
其次 我们有Metal框架调试器

00:02:34.021 --> 00:02:35.689 align:middle line:-1
这也是一个非常强大的工具

00:02:36.323 --> 00:02:38.892 align:middle line:-1
你希望用它来调试GPU工作负载

00:02:40.627 --> 00:02:41.828 align:middle line:-1
我们从哪里开始呢？

00:02:42.763 --> 00:02:44.164 align:middle line:-1
这是我们经常遇到的问题

00:02:45.132 --> 00:02:47.701 align:middle line:-1
嗯 今年我们让你们更轻松

00:02:48.135 --> 00:02:50.237 align:middle line:0
我们正在推出一种新的仪器模板

00:02:50.671 --> 00:02:52.673 align:middle line:0
这将是一个很好的起点

00:02:53.073 --> 00:02:54.508 align:middle line:0
游戏性能模板

00:02:55.275 --> 00:02:57.744 align:middle line:0
这是现有工具的组合

00:02:58.245 --> 00:02:59.713 align:middle line:-1
例如系统跟踪

00:03:00.581 --> 00:03:01.548 align:middle line:-1
时间分析仪

00:03:02.082 --> 00:03:03.317 align:middle line:-1
和Metal系统跟踪

00:03:03.951 --> 00:03:05.319 align:middle line:-1
我们为你配置好了

00:03:05.619 --> 00:03:09.223 align:middle line:-2
它会记录与你的游戏相关的
所有CPU和GPU数据

00:03:09.656 --> 00:03:10.757 align:middle line:-1
所以你可以用它调试

00:03:12.259 --> 00:03:14.261 align:middle line:-2
那么我们如何推出呢？
我们怎么到那里？

00:03:14.695 --> 00:03:15.529 align:middle line:-1
嗯…

00:03:15.696 --> 00:03:18.899 align:middle line:-2
只需打开Instruments
它就在屏幕中心

00:03:19.967 --> 00:03:20.934 align:middle line:-1
选择后

00:03:21.001 --> 00:03:23.704 align:middle line:-1
你将像设任何其它模板一样设置

00:03:24.838 --> 00:03:27.407 align:middle line:-2
开始记录后
你将在窗口模式下执行此操作

00:03:27.808 --> 00:03:30.644 align:middle line:-1
允许你任意地玩游戏

00:03:30.978 --> 00:03:33.714 align:middle line:-1
只有最后几秒的数据会被记录下来

00:03:34.114 --> 00:03:37.317 align:middle line:-1
这就是最后几秒数据的样子

00:03:38.785 --> 00:03:42.422 align:middle line:-1
有很多信息 所以我们简单概述一下

00:03:43.457 --> 00:03:45.092 align:middle line:-1
（系统跟踪和时间分析仪）

00:03:45.158 --> 00:03:47.928 align:middle line:-1
首先 我们有系统跟踪和时间分析仪

00:03:47.995 --> 00:03:50.264 align:middle line:-1
它将为你提供系统负载的概述

00:03:50.330 --> 00:03:52.399 align:middle line:-1
以及你的app CPU使用情况

00:03:53.300 --> 00:03:55.636 align:middle line:-1
例如 用户交互式加载

00:03:55.702 --> 00:03:58.705 align:middle line:-1
将记录给定时间内的所有活动线程

00:03:59.273 --> 00:04:00.107 align:middle line:-1
在这种情况下

00:03:59.273 --> 00:04:00.107 align:middle line:-1
在这种情况下

00:04:00.807 --> 00:04:02.176 align:middle line:-1
你看到的橙色

00:04:02.643 --> 00:04:05.279 align:middle line:-1
表示可运行的线程数量

00:04:05.445 --> 00:04:06.547 align:middle line:-1
大于CPU核心数

00:04:06.813 --> 00:04:08.148 align:middle line:-1
所以有一些意外情况

00:04:09.016 --> 00:04:11.318 align:middle line:-1
这将提供系统的绝佳视图

00:04:12.753 --> 00:04:14.188 align:middle line:0
有几个很棒的谈话

00:04:14.388 --> 00:04:16.456 align:middle line:0
更深入地探讨这个工具

00:04:16.990 --> 00:04:18.225 align:middle line:-1
请进一步关注这些

00:04:20.327 --> 00:04:22.863 align:middle line:-1
下一个是Metal系统跟踪

00:04:23.096 --> 00:04:24.398 align:middle line:-1
我们的GPU分析工具

00:04:24.932 --> 00:04:27.534 align:middle line:-1
它提供了图形堆栈的绝佳视图

00:04:28.135 --> 00:04:29.870 align:middle line:-1
从Metal框架

00:04:30.270 --> 00:04:31.338 align:middle line:-1
一直到到显示

00:04:32.539 --> 00:04:33.740 align:middle line:-1
特别注意

00:04:33.974 --> 00:04:36.844 align:middle line:-1
我们要密切关注GPU硬件时间

00:04:37.344 --> 00:04:39.713 align:middle line:-1
分为顶点 片段

00:04:40.113 --> 00:04:41.582 align:middle line:-1
及计算 如果你的游戏用到

00:04:42.749 --> 00:04:44.384 align:middle line:-1
还要注意显示监视器

00:04:44.451 --> 00:04:46.987 align:middle line:-1
将是我们许多调查的起点

00:04:47.621 --> 00:04:49.756 align:middle line:-1
我们将识别长框架或启动器

00:04:49.823 --> 00:04:51.725 align:middle line:-1
我们将从那里开始一直调查下去

00:04:52.125 --> 00:04:53.861 align:middle line:-1
所以这是一个非常自然的起点

00:04:56.530 --> 00:04:58.432 align:middle line:-1
关于这个工具有很多信息

00:04:58.498 --> 00:05:00.367 align:middle line:-1
因为它确实是一个非常强大的工具

00:04:58.498 --> 00:05:00.367 align:middle line:-1
因为它确实是一个非常强大的工具

00:05:00.434 --> 00:05:02.302 align:middle line:-1
我鼓励大家去熟悉它

00:05:03.303 --> 00:05:04.638 align:middle line:-1
这几个演讲

00:05:04.705 --> 00:05:06.707 align:middle line:-1
将为你提供一个很好的起点

00:05:08.141 --> 00:05:08.976 align:middle line:-1
好

00:05:09.042 --> 00:05:10.077 align:middle line:-1
接下来要谈的是

00:05:10.577 --> 00:05:13.347 align:middle line:-1
我们今年推出了一个线程状态视图

00:05:14.314 --> 00:05:17.017 align:middle line:-1
此视图显示游戏中每个线程的状态

00:05:17.484 --> 00:05:20.587 align:middle line:-2
在这种情况下
每种颜色代表一种可能的线程状态

00:05:21.321 --> 00:05:24.124 align:middle line:-1
例如被抢占以橙色表示

00:05:24.458 --> 00:05:26.360 align:middle line:-1
已屏蔽以灰色表示

00:05:27.561 --> 00:05:29.930 align:middle line:-1
我们专门为你 游戏开发者

00:05:29.997 --> 00:05:31.231 align:middle line:-1
设计了此视图

00:05:31.698 --> 00:05:36.036 align:middle line:-2
因为我们知道
现代游戏中的线程系统非常复杂

00:05:36.270 --> 00:05:38.138 align:middle line:-1
我们希望这对你有所帮助

00:05:40.240 --> 00:05:43.443 align:middle line:-2
我们还为每个CPU核心
提供了一个轨道

00:05:44.278 --> 00:05:46.313 align:middle line:-1
它将显示在该核心上运行的线程

00:05:46.680 --> 00:05:50.184 align:middle line:-1
以及以颜色编码的该线程的优先级

00:05:51.552 --> 00:05:52.486 align:middle line:-1
用这个工具

00:05:52.553 --> 00:05:55.622 align:middle line:-1
你将能够一目了然地看到系统的状态

00:05:56.924 --> 00:05:57.758 align:middle line:-1
还有…

00:05:58.225 --> 00:06:02.262 align:middle line:-1
这是一个简短但相当宽泛的工具介绍

00:05:58.225 --> 00:06:02.262 align:middle line:-1
这是一个简短但相当宽泛的工具介绍

00:06:02.329 --> 00:06:05.432 align:middle line:-1
现在我们该转向实际的性能问题了

00:06:05.999 --> 00:06:08.569 align:middle line:-1
第一个是关于帧速度

00:06:10.237 --> 00:06:12.005 align:middle line:-1
让我们先看一下它

00:06:12.773 --> 00:06:16.476 align:middle line:-2
为此 我们用了Fox II
SceneKit演示的修改版本

00:06:16.677 --> 00:06:18.745 align:middle line:-1
这将有助于我们更好地说明问题

00:06:20.647 --> 00:06:24.084 align:middle line:-1
你能猜出哪个游戏生成得更快吗？

00:06:27.287 --> 00:06:28.121 align:middle line:-1
嗯…

00:06:28.956 --> 00:06:30.657 align:middle line:-1
你们中的一些人可能没有猜到

00:06:31.458 --> 00:06:35.429 align:middle line:-2
左边的游戏试图以
每秒60帧的速度生成

00:06:35.963 --> 00:06:37.564 align:middle line:-1
但它只达到40

00:06:38.198 --> 00:06:40.467 align:middle line:-1
所以它不流畅而有抖动

00:06:40.901 --> 00:06:42.636 align:middle line:-1
另一方面 右边的游戏

00:06:43.003 --> 00:06:45.105 align:middle line:-1
它的目标是每秒30帧

00:06:45.372 --> 00:06:47.241 align:middle line:-1
可以一贯地实现

00:06:47.841 --> 00:06:49.176 align:middle line:-1
这就是为何它看起来更顺畅

00:06:50.944 --> 00:06:53.814 align:middle line:-1
但这有点违反直觉

00:06:54.047 --> 00:06:57.417 align:middle line:-1
为什么生成速度更快的游戏

00:06:58.218 --> 00:06:59.353 align:middle line:-1
反倒看起来不太顺畅？

00:07:00.287 --> 00:07:02.856 align:middle line:-1
嗯 这个问题被称为微型口吃

00:07:03.223 --> 00:07:04.758 align:middle line:-1
或不一致帧速

00:07:06.059 --> 00:07:07.995 align:middle line:-1
它出现于帧时间

00:07:08.529 --> 00:07:10.597 align:middle line:-1
高于显示刷新间隔

00:07:11.265 --> 00:07:12.099 align:middle line:-1
例如

00:07:13.033 --> 00:07:15.969 align:middle line:-1
我们的游戏可能要25毫秒生成一帧

00:07:16.170 --> 00:07:17.538 align:middle line:-1
或每秒40帧

00:07:17.938 --> 00:07:21.275 align:middle line:-1
而显示屏可能会每16.6毫秒刷新

00:07:21.675 --> 00:07:23.143 align:middle line:-1
或每秒60帧

00:07:23.577 --> 00:07:25.045 align:middle line:-1
与我们刚看到的视频相同

00:07:25.345 --> 00:07:27.781 align:middle line:-1
这会产生一些视觉上的不一致

00:07:29.650 --> 00:07:31.151 align:middle line:-1
这种情况是怎么造成的？

00:07:31.718 --> 00:07:34.988 align:middle line:-1
我们在这种情况下做了什么？

00:07:35.789 --> 00:07:36.623 align:middle line:-1
嗯…

00:07:37.491 --> 00:07:38.592 align:middle line:-1
我们没有做什么

00:07:38.659 --> 00:07:40.527 align:middle line:-1
这就是问题所在

00:07:41.728 --> 00:07:43.163 align:middle line:-1
生成帧后

00:07:43.597 --> 00:07:46.033 align:middle line:-1
我们从显示链请求下一个可绘图

00:07:46.233 --> 00:07:47.701 align:middle line:-1
一旦我们得到了可绘图

00:07:48.101 --> 00:07:50.871 align:middle line:-1
我们完成了最后一步并立即展示

00:07:51.438 --> 00:07:53.473 align:middle line:-1
我们明确地告诉了系统

00:07:54.041 --> 00:07:56.410 align:middle line:-1
在下一个刷新间隔

00:07:56.643 --> 00:07:58.111 align:middle line:-1
尽快呈现可绘图

00:07:58.412 --> 00:07:59.246 align:middle line:-1
毕竟

00:07:59.413 --> 00:08:01.548 align:middle line:-1
我们的目标是每秒60帧 对吗？

00:07:59.413 --> 00:08:01.548 align:middle line:-1
我们的目标是每秒60帧 对吗？

00:08:03.350 --> 00:08:06.620 align:middle line:-1
还有另一类问题会导致微型口吃

00:08:06.687 --> 00:08:11.425 align:middle line:-1
有些游戏已经设定较低的帧率

00:08:12.392 --> 00:08:14.995 align:middle line:-1
但我们也发现了很多这样的游戏

00:08:15.495 --> 00:08:18.298 align:middle line:-2
在主线程或
图像生成线程上用usleep

00:08:18.365 --> 00:08:19.333 align:middle line:-2
（勿用usleep()
控制帧速！）

00:08:19.399 --> 00:08:21.168 align:middle line:-1
这在iOS中是一种很糟糕的做法

00:08:21.235 --> 00:08:22.936 align:middle line:-1
所以请不要那样做

00:08:23.737 --> 00:08:25.706 align:middle line:-1
耐心等我几分钟

00:08:25.772 --> 00:08:28.442 align:middle line:-1
我会告诉你在iOS中的正确方法

00:08:30.577 --> 00:08:31.411 align:middle line:-1
现在…

00:08:32.145 --> 00:08:36.350 align:middle line:-1
让我们深入了解系统中发生了什么

00:08:36.416 --> 00:08:38.118 align:middle line:-1
微型口吃是可见的

00:08:39.119 --> 00:08:40.888 align:middle line:-1
在这种情况下 我们在这里看到

00:08:40.953 --> 00:08:42.956 align:middle line:-1
生成中涉及的所有组件的时间表

00:08:43.924 --> 00:08:47.160 align:middle line:-1
我们开始正常生成我们的游戏

00:08:47.761 --> 00:08:51.298 align:middle line:-2
注意 这是一个三重缓冲区
在iOS中常见

00:08:51.532 --> 00:08:52.366 align:middle line:-1
在这种情况下

00:08:52.699 --> 00:08:55.769 align:middle line:-1
每个可绘图都用字母和颜色表示

00:08:56.670 --> 00:08:58.372 align:middle line:-1
注意这里的前提

00:08:58.972 --> 00:09:00.474 align:middle line:-1
生成可绘图B

00:08:58.972 --> 00:09:00.474 align:middle line:-1
生成可绘图B

00:09:01.108 --> 00:09:03.911 align:middle line:-1
历时超过一个显示刷新间隔

00:09:04.244 --> 00:09:05.913 align:middle line:-1
即Vsyncs之间的时间

00:09:07.281 --> 00:09:10.651 align:middle line:-2
在这种情况下
生成到B可能需要25毫秒

00:09:10.817 --> 00:09:14.121 align:middle line:-1
显示刷新间隔之间为16.6毫秒

00:09:16.223 --> 00:09:18.525 align:middle line:-1
所以 既然这是前提

00:09:18.592 --> 00:09:21.728 align:middle line:-1
这意味着我们需要在显示屏上保持A

00:09:22.162 --> 00:09:25.532 align:middle line:-1
为下一个间隔给出时间以便完成

00:09:26.633 --> 00:09:27.835 align:middle line:-1
我们会这样做

00:09:27.901 --> 00:09:29.503 align:middle line:-1
在那个时间段内

00:09:29.770 --> 00:09:32.739 align:middle line:-1
B实际上会完成

00:09:33.574 --> 00:09:35.275 align:middle line:-1
并准备好呈现

00:09:36.343 --> 00:09:38.979 align:middle line:-1
但注意我们刚在这里隐藏了一个问题

00:09:39.646 --> 00:09:43.050 align:middle line:-2
在此间隔期间
我们还完成了C的生成

00:09:43.617 --> 00:09:45.419 align:middle line:-1
我们已准备好立即呈现它

00:09:46.653 --> 00:09:49.723 align:middle line:-1
所以从这个时间段开始

00:09:49.790 --> 00:09:51.091 align:middle line:-1
我们会遇到不一致的帧速

00:09:51.592 --> 00:09:52.960 align:middle line:-1
我们陷入了这种模式

00:09:53.460 --> 00:09:55.596 align:middle line:-1
每隔一帧都不一致

00:09:56.330 --> 00:09:58.398 align:middle line:-1
用户将看到微型口吃

00:10:00.601 --> 00:10:01.435 align:middle line:-1
现在…

00:10:01.602 --> 00:10:05.472 align:middle line:-2
现实世界中
这可能在以不同的形状和形式出现

00:10:06.006 --> 00:10:08.108 align:middle line:-1
所以我们现在做的就是快速演示

00:10:08.442 --> 00:10:10.210 align:middle line:-1
我将向你展示《塔洛斯法则》

00:10:10.277 --> 00:10:11.912 align:middle line:-1
的仪器跟踪

00:10:12.412 --> 00:10:13.413 align:middle line:-1
我们会用它来观察

00:10:13.480 --> 00:10:16.083 align:middle line:-1
看能否识别现实世界中的微型口吃情况

00:10:25.225 --> 00:10:26.126 align:middle line:-1
好

00:10:26.193 --> 00:10:27.194 align:middle line:-1
我们在这里看到的

00:10:27.261 --> 00:10:29.963 align:middle line:-1
与我之前展示的信息相同

00:10:30.330 --> 00:10:31.331 align:middle line:-1
我们的游戏性能模板

00:10:31.398 --> 00:10:33.500 align:middle line:-1
已在默认状态下将此信息捕获

00:10:34.134 --> 00:10:36.203 align:middle line:-1
注意我谈到的所有相同的工具

00:10:36.270 --> 00:10:37.504 align:middle line:-1
显示在左侧

00:10:39.473 --> 00:10:41.875 align:middle line:-1
所有游戏线程都在中间

00:10:42.676 --> 00:10:46.480 align:middle line:-1
尤其我们现在正在寻找微型口吃

00:10:47.314 --> 00:10:50.484 align:middle line:-1
所以这很直观地会让我们看显示轨道

00:10:50.551 --> 00:10:54.488 align:middle line:-2
因为微型口吃的定义
即是不一致的帧显示

00:10:55.189 --> 00:10:57.157 align:middle line:-2
在这种情况下
我们在这里有显示轨道

00:10:58.492 --> 00:11:01.428 align:middle line:-1
注意 该显示轨道中有一些提示

00:10:58.492 --> 00:11:01.428 align:middle line:-1
注意 该显示轨道中有一些提示

00:11:02.029 --> 00:11:05.165 align:middle line:-2
我们添加了它们
这些是提示 这里

00:11:05.933 --> 00:11:06.867 align:middle line:-1
它们会告诉你

00:11:06.934 --> 00:11:08.569 align:middle line:-1
当表面显示

00:11:08.635 --> 00:11:12.306 align:middle line:-1
比正常生成时预期更长

00:11:13.040 --> 00:11:15.175 align:middle line:-1
也许这是一个开始观察的好地方

00:11:15.242 --> 00:11:16.844 align:middle line:-1
有一些堆砌

00:11:17.144 --> 00:11:18.278 align:middle line:-1
让我们放大一个

00:11:19.112 --> 00:11:21.014 align:middle line:-1
要放大 我们将长按选项键

00:11:21.281 --> 00:11:24.151 align:middle line:-1
并将指针拖动到感兴趣的区域

00:11:25.719 --> 00:11:28.355 align:middle line:-2
这种情况下
如果我们继续查看显示轨道

00:11:29.189 --> 00:11:31.959 align:middle line:-1
已经很明显存在微型口吃

00:11:32.025 --> 00:11:35.729 align:middle line:-2
我们可以看到
每个显示器都有不同的时间

00:11:36.363 --> 00:11:37.664 align:middle line:-1
所以在这种情况下 例如

00:11:37.731 --> 00:11:39.566 align:middle line:-1
我们有50、33

00:11:40.133 --> 00:11:42.302 align:middle line:-1
16 回到50

00:11:42.903 --> 00:11:43.937 align:middle line:-1
再回到33

00:11:44.438 --> 00:11:45.973 align:middle line:-1
所以当我们在仪器捕获中

00:11:46.640 --> 00:11:47.841 align:middle line:-1
看到这种模式时

00:11:47.908 --> 00:11:51.011 align:middle line:-2
这意味着存在微型口吃
我们应该纠正它

00:11:51.778 --> 00:11:52.746 align:middle line:-1
我们看看做法

00:11:53.146 --> 00:11:54.081 align:middle line:-1
回到幻灯片

00:11:58.051 --> 00:11:58.886 align:middle line:-1
好了…

00:11:59.453 --> 00:12:02.122 align:middle line:-2
我们刚刚看到了这个问题
及它在现实世界中的发生

00:11:59.453 --> 00:12:02.122 align:middle line:-2
我们刚刚看到了这个问题
及它在现实世界中的发生

00:12:02.389 --> 00:12:04.258 align:middle line:-1
模式基本相同

00:12:04.691 --> 00:12:06.393 align:middle line:-1
那我们该怎么做呢？

00:12:07.928 --> 00:12:11.498 align:middle line:-2
最佳做实践
是确定游戏可以达到的帧速率

00:12:12.165 --> 00:12:13.800 align:middle line:-1
所以在最小帧持续时间

00:12:14.401 --> 00:12:16.703 align:middle line:-1
长于帧生成时间

00:12:17.938 --> 00:12:20.674 align:middle line:-1
为此 有很多API可以帮助你

00:12:21.241 --> 00:12:24.111 align:middle line:-2
例如 MTLDrawable
addPresentedHandler

00:12:24.578 --> 00:12:27.781 align:middle line:-1
一旦可绘图出现 会给你一个回调

00:12:27.848 --> 00:12:30.851 align:middle line:-2
这样一旦微型口吃发生
你就可以识别

00:12:31.919 --> 00:12:35.355 align:middle line:-1
其它两个API会帮你解决这个问题

00:12:35.822 --> 00:12:39.793 align:middle line:-1
它们将允许你明确控制帧速

00:12:40.394 --> 00:12:42.863 align:middle line:-2
在这种情况下
我们提供了afterMinimumDuration

00:12:43.163 --> 00:12:44.231 align:middle line:-1
和atTime

00:12:45.165 --> 00:12:46.333 align:middle line:-1
我们这里的目的

00:12:46.867 --> 00:12:50.704 align:middle line:-2
是把帧的最小持续时间
设置得比生成时间长

00:12:51.839 --> 00:12:54.208 align:middle line:-2
这正是我们要做的
让我们看看

00:12:55.943 --> 00:12:57.778 align:middle line:-1
注意 当我们开始生成时

00:12:58.712 --> 00:13:00.714 align:middle line:-1
我们从一开始就保持一致

00:12:58.712 --> 00:13:00.714 align:middle line:-1
我们从一开始就保持一致

00:13:01.081 --> 00:13:04.952 align:middle line:-1
我们的帧显示时间长于生成时间

00:13:05.686 --> 00:13:07.254 align:middle line:-1
每一帧都是一致的

00:13:08.655 --> 00:13:11.358 align:middle line:-1
用户的观感也会一致

00:13:12.159 --> 00:13:12.993 align:middle line:-1
太好了

00:13:13.060 --> 00:13:15.462 align:middle line:-1
另外 注意有副作用

00:13:15.729 --> 00:13:16.964 align:middle line:-1
帧速率将降低

00:13:17.030 --> 00:13:20.367 align:middle line:-1
我们从每秒40帧降到30帧

00:13:20.968 --> 00:13:23.570 align:middle line:-1
所以这也给了我们额外的帧时间

00:13:25.138 --> 00:13:26.206 align:middle line:-1
我们是怎么做到的？

00:13:27.307 --> 00:13:31.678 align:middle line:-1
我们是如何修复帧速的？

00:13:31.745 --> 00:13:32.579 align:middle line:-1
嗯…

00:13:33.180 --> 00:13:35.415 align:middle line:-1
真的 只需几行代码

00:13:36.016 --> 00:13:37.818 align:middle line:-1
我们的模式与以前相同

00:13:38.118 --> 00:13:39.152 align:middle line:-1
我们生成场景

00:13:39.586 --> 00:13:40.687 align:middle line:-1
得到了下一个可绘图

00:13:41.188 --> 00:13:42.289 align:middle line:-1
我们做最后一步生成

00:13:43.090 --> 00:13:44.358 align:middle line:-1
唯一的区别

00:13:44.691 --> 00:13:47.995 align:middle line:-1
是我们指定帧的最小持续时间

00:13:48.428 --> 00:13:50.864 align:middle line:-1
并以最短持续时间呈现

00:13:51.598 --> 00:13:52.599 align:middle line:-1
就是这样

00:13:53.400 --> 00:13:56.470 align:middle line:-1
这将允许我们设置帧的最小持续时间

00:13:56.537 --> 00:13:58.005 align:middle line:-1
它们将保持一致

00:13:59.306 --> 00:14:01.408 align:middle line:-1
这样做之后 你可能会想

00:13:59.306 --> 00:14:01.408 align:middle line:-1
这样做之后 你可能会想

00:14:01.475 --> 00:14:04.778 align:middle line:-1
那么 最长持续时间呢？

00:14:05.646 --> 00:14:08.582 align:middle line:-1
我们的工作优先级概念如何体现？

00:14:08.649 --> 00:14:10.350 align:middle line:-1
或一帧可以花多长时间？

00:14:11.185 --> 00:14:13.754 align:middle line:-1
嗯 这是我们要谈的下一个问题

00:14:13.954 --> 00:14:14.855 align:middle line:-1
线程优先级

00:14:16.390 --> 00:14:18.859 align:middle line:-1
像之前一样 让我们先看一下它

00:14:19.593 --> 00:14:22.029 align:middle line:-1
还是用Fox II演示的修改版本

00:14:23.497 --> 00:14:25.232 align:middle line:-1
你可能在想 而你会是对的

00:14:25.299 --> 00:14:27.668 align:middle line:-1
有很多事情可能导致这类的口吃

00:14:27.734 --> 00:14:31.205 align:middle line:-1
也许你正在作资源加载或着色器编译

00:14:32.072 --> 00:14:34.675 align:middle line:-1
今天我们将重点关注更为根本

00:14:35.209 --> 00:14:37.411 align:middle line:-1
但也是非常常见的类型的口吃

00:14:38.912 --> 00:14:40.447 align:middle line:-1
即由线程停滞引起的口吃

00:14:42.316 --> 00:14:46.653 align:middle line:-1
如果工作优先级未很好地传达给系统

00:14:47.054 --> 00:14:48.989 align:middle line:-1
你的游戏可能有意想不到的停滞

00:14:50.123 --> 00:14:53.427 align:middle line:-2
除了生成游戏之外
iOS还做很多事

00:14:54.928 --> 00:14:57.164 align:middle line:-1
线程优先级用于保证

00:14:57.364 --> 00:14:59.533 align:middle line:-1
整个系统的服务质量

00:15:00.667 --> 00:15:02.503 align:middle line:-1
所以如果一个线程做了很多工作

00:15:02.970 --> 00:15:05.339 align:middle line:-1
其优先级将随时间的推移而降低

00:15:05.772 --> 00:15:07.441 align:middle line:-1
以让其它线程有机会运行

00:15:08.242 --> 00:15:10.511 align:middle line:-1
这就是优先级衰减的概念

00:15:11.979 --> 00:15:13.847 align:middle line:-1
另外 在我身后的幻灯片上可看到

00:15:14.615 --> 00:15:15.682 align:middle line:-1
优先级倒置

00:15:16.116 --> 00:15:19.887 align:middle line:-2
这是另一类
以非常类似的方式表现出来的问题

00:15:20.521 --> 00:15:23.257 align:middle line:-1
当生成线程依赖于来自同一引擎的

00:15:23.323 --> 00:15:27.194 align:middle line:-1
较低优先级的工作线程以完成工作时

00:15:28.028 --> 00:15:30.564 align:middle line:-1
在这种情况下 发生优先级倒置

00:15:31.298 --> 00:15:32.466 align:middle line:-1
我们看看它是怎么样的

00:15:32.533 --> 00:15:34.401 align:middle line:-1
与我们之前看到的时间表相同

00:15:35.802 --> 00:15:36.770 align:middle line:-1
在这种情况下

00:15:36.837 --> 00:15:38.906 align:middle line:-1
我们开始以每秒30帧的速度生成

00:15:39.273 --> 00:15:40.107 align:middle line:-1
很轻松

00:15:41.041 --> 00:15:43.844 align:middle line:-1
但是 有一些背景工作

00:15:44.678 --> 00:15:47.347 align:middle line:-2
iOS做很多东西
也许现在正在检查电子邮件

00:15:48.715 --> 00:15:49.950 align:middle line:-1
若我们的线程配置不正确

00:15:50.017 --> 00:15:52.286 align:middle line:-1
那问题就来了

00:15:53.487 --> 00:15:55.556 align:middle line:-1
你可能会被该后台工作抢占

00:15:55.989 --> 00:15:59.760 align:middle line:-2
你可能无法完成GPU上
所有工作安排

00:16:01.128 --> 00:16:04.498 align:middle line:-1
并且没有帧的最大持续时间的概念

00:16:05.165 --> 00:16:08.068 align:middle line:-1
所以帧生成可能会持续数百毫秒

00:16:08.735 --> 00:16:10.537 align:middle line:-1
用户会看到口吃

00:16:12.673 --> 00:16:14.675 align:middle line:-1
这就是它背后的理论

00:16:14.741 --> 00:16:19.213 align:middle line:-2
在实践中 它的发生遵循相同的模式
但以不同的方式显示

00:16:19.847 --> 00:16:20.981 align:middle line:-1
我们再作一个演示

00:16:21.048 --> 00:16:24.284 align:middle line:-2
我将向你展示另一个仪器捕捉的
《塔洛斯法则》信息

00:16:24.351 --> 00:16:27.087 align:middle line:-1
来看看如何识别此问题

00:16:37.998 --> 00:16:41.101 align:middle line:-1
在这种情况下 你看到的是

00:16:41.168 --> 00:16:43.604 align:middle line:-1
使用游戏性能模板作的信息捕捉

00:16:44.271 --> 00:16:46.073 align:middle line:-1
但这一次 我们已经放大了

00:16:46.373 --> 00:16:48.041 align:middle line:-1
进入我们感兴趣的帧

00:16:48.509 --> 00:16:50.110 align:middle line:-1
这是一个很长的帧

00:16:51.378 --> 00:16:54.081 align:middle line:-1
它的持续时间为233毫秒

00:16:54.147 --> 00:16:57.017 align:middle line:-1
所以我们应该调查这个很典型的口吃

00:16:58.619 --> 00:17:00.454 align:middle line:-1
一眼看去

00:16:58.619 --> 00:17:00.454 align:middle line:-1
一眼看去

00:17:00.521 --> 00:17:04.458 align:middle line:-1
我们已经知道GPU似乎未做什么

00:17:04.958 --> 00:17:06.425 align:middle line:-1
在此期间它处于闲置状态

00:17:07.094 --> 00:17:09.329 align:middle line:-1
这意味着我们没有喂饱它

00:17:10.130 --> 00:17:14.134 align:middle line:-1
现在 我们可以看一下CPU

00:17:14.800 --> 00:17:17.137 align:middle line:-1
CPU似乎相当忙

00:17:17.704 --> 00:17:18.771 align:middle line:-1
就像它们真的……

00:17:19.540 --> 00:17:20.874 align:middle line:-1
所有这些看起来都很稳固

00:17:22.476 --> 00:17:28.048 align:middle line:-2
注意 你在此处看到的是我们的
app的时间分析器视图

00:17:28.315 --> 00:17:30.284 align:middle line:-1
看上去没有在运行

00:17:31.318 --> 00:17:32.753 align:middle line:-1
为什么我们的游戏没有运行

00:17:33.587 --> 00:17:36.190 align:middle line:-1
这怎么会导致口吃？为什么？

00:17:36.924 --> 00:17:37.758 align:middle line:-1
嗯…

00:17:38.659 --> 00:17:41.094 align:middle line:-1
我们可以切换到我提到的新视图

00:17:41.161 --> 00:17:42.496 align:middle line:-1
新的线程状态视图

00:17:43.363 --> 00:17:47.034 align:middle line:-1
要做到这个 你进入app的图标

00:17:47.768 --> 00:17:49.837 align:middle line:-1
并点击此处的按钮

00:17:50.604 --> 00:17:52.406 align:middle line:-1
这将拉出轨道显示

00:17:53.640 --> 00:17:55.809 align:middle line:-2
在这种情况下
你可以切换到线程状态

00:17:57.711 --> 00:18:01.481 align:middle line:-1
这有望帮助你看到这里有问题

00:17:57.711 --> 00:18:01.481 align:middle line:-1
这有望帮助你看到这里有问题

00:18:02.349 --> 00:18:05.953 align:middle line:-1
它以橙色突出显示 这已经告诉我们

00:18:06.019 --> 00:18:09.756 align:middle line:-1
该线程已被抢占192毫秒

00:18:10.490 --> 00:18:13.493 align:middle line:-1
这就是问题所在 生成线程未运行

00:18:13.894 --> 00:18:15.062 align:middle line:-1
有些东西先占用了

00:18:16.263 --> 00:18:17.331 align:middle line:0
如果你想了解更多

00:18:18.232 --> 00:18:20.167 align:middle line:0
你可以在底部展开信息

00:18:20.234 --> 00:18:22.302 align:middle line:0
也将包含线程叙述

00:18:23.804 --> 00:18:26.907 align:middle line:0
并且通过单击被抢先的线程

00:18:27.741 --> 00:18:28.909 align:middle line:0
你会看到这里

00:18:29.676 --> 00:18:31.278 align:middle line:0
对正在发生的事情的解释

00:18:31.612 --> 00:18:32.446 align:middle line:0
在这里

00:18:33.046 --> 00:18:35.749 align:middle line:0
你的生成线程优先级为26

00:18:36.016 --> 00:18:36.917 align:middle line:0
非常低

00:18:36.984 --> 00:18:38.552 align:middle line:0
低于后台线程优先级

00:18:39.486 --> 00:18:41.088 align:middle line:0
因为App Store正更新

00:18:42.122 --> 00:18:43.657 align:middle line:0
这是不应该的

00:18:44.024 --> 00:18:47.060 align:middle line:0
我们想告诉系统
对我们的用户来说

00:18:47.494 --> 00:18:49.730 align:middle line:0
在那个特定的时刻 我们的游戏

00:18:49.796 --> 00:18:51.131 align:middle line:0
比App Store更新更重要

00:18:51.765 --> 00:18:54.134 align:middle line:-2
让我们回到幻灯片
看看该怎么做

00:19:02.276 --> 00:19:05.345 align:middle line:-1
最好的做法是配置你的生成线程

00:19:06.213 --> 00:19:10.017 align:middle line:-1
建议将生成线程优先级固定为45

00:19:11.118 --> 00:19:15.889 align:middle line:-2
注意 在iOS和macOS中
优先级具有升序值

00:19:16.823 --> 00:19:21.395 align:middle line:-1
因此优先级31高于优先级4

00:19:22.162 --> 00:19:25.999 align:middle line:-2
此外 我们需要选择退出
调度程序的服务质量

00:19:26.333 --> 00:19:30.337 align:middle line:-2
以防止优先级衰减
从而降低我们的优先级

00:19:31.738 --> 00:19:34.341 align:middle line:-2
我们看看配置良好的
生成线程是怎样的

00:19:36.043 --> 00:19:39.046 align:middle line:-1
现在我们按照刚才所说的来配置

00:19:39.847 --> 00:19:41.181 align:middle line:-1
我们开始正常生成

00:19:42.649 --> 00:19:44.751 align:middle line:-1
我们还有一些背景工作在运行

00:19:44.818 --> 00:19:46.186 align:middle line:-1
否则这不公平

00:19:46.787 --> 00:19:49.389 align:middle line:-2
而且 这个后台工作
可能是更新App Store

00:19:49.456 --> 00:19:50.791 align:middle line:-1
正如我们在演示中看到的

00:19:51.692 --> 00:19:56.563 align:middle line:-2
但请注意一个又一个Vsync后
正常生成

00:19:57.197 --> 00:20:01.401 align:middle line:-2
我们正在抢占CPU的
后台工作以运行

00:19:57.197 --> 00:20:01.401 align:middle line:-2
我们正在抢占CPU的
后台工作以运行

00:20:02.603 --> 00:20:04.872 align:middle line:-1
用户看不到口吃

00:20:05.339 --> 00:20:08.642 align:middle line:-1
你的游戏可以每秒30个固帧运行

00:20:09.243 --> 00:20:11.211 align:middle line:-1
即使系统负载很重

00:20:12.012 --> 00:20:14.815 align:middle line:-1
这在技术上很棒 这就是我们要做的

00:20:15.182 --> 00:20:18.418 align:middle line:-2
让我们看看如何通过
一点代码实现这一点

00:20:19.953 --> 00:20:22.322 align:middle line:-1
确实是一点代码

00:20:22.556 --> 00:20:23.991 align:middle line:-1
只有几行

00:20:24.791 --> 00:20:25.726 align:middle line:-1
在这种情况下

00:20:26.593 --> 00:20:28.929 align:middle line:-1
它只是配置pthread属性

00:20:29.229 --> 00:20:31.031 align:middle line:-1
在创建pthread之前

00:20:32.165 --> 00:20:36.904 align:middle line:-2
我们需要选择退出服务质量
将优先级设置为45

00:20:37.938 --> 00:20:40.741 align:middle line:-2
就是这样 现在我们
可以用这些属性创建pthread

00:20:41.074 --> 00:20:42.409 align:middle line:-1
它会正常工作

00:20:43.110 --> 00:20:45.012 align:middle line:-1
这很简单同时技术上很了不起

00:20:47.181 --> 00:20:48.649 align:middle line:-1
不是那么简单的

00:20:49.650 --> 00:20:51.285 align:middle line:-1
是我们要讲的下一个问题

00:20:52.586 --> 00:20:54.922 align:middle line:-1
处理多个热状态的问题

00:20:56.256 --> 00:20:57.724 align:middle line:-1
目的是明确的

00:20:59.092 --> 00:21:00.827 align:middle line:-1
为持续性能设计

00:20:59.092 --> 00:21:00.827 align:middle line:-1
为持续性能设计

00:21:02.930 --> 00:21:04.932 align:middle line:-1
并处理偶尔出现的热问题

00:21:05.666 --> 00:21:07.100 align:middle line:-1
我们看看我们如何来做

00:21:08.602 --> 00:21:12.639 align:middle line:-1
iOS设备可提供前所未有的电量

00:21:12.806 --> 00:21:15.075 align:middle line:-1
但是在一个非常小的外形中

00:21:15.609 --> 00:21:18.378 align:middle line:-2
因此 随着更多的app
在设备上使用更多资源

00:21:18.946 --> 00:21:21.582 align:middle line:-1
系统可能会开始采取措施

00:21:21.648 --> 00:21:24.084 align:middle line:-1
以保持低温和反应速度

00:21:25.118 --> 00:21:29.423 align:middle line:-1
此外 用户可能已启用低功耗模式

00:21:29.756 --> 00:21:32.192 align:middle line:-1
会产生相似的效果

00:21:34.561 --> 00:21:36.763 align:middle line:-1
好 所以最好的做法

00:21:37.130 --> 00:21:41.034 align:middle line:-1
是将工作负载调整为系统状态

00:21:42.269 --> 00:21:45.305 align:middle line:-1
你应该监控系统并相应调整工作负载

00:21:45.873 --> 00:21:48.308 align:middle line:-1
iOS有许多API可以有帮助

00:21:48.909 --> 00:21:52.379 align:middle line:-2
例如
用NSProcessInfo thermalState

00:21:52.746 --> 00:21:55.215 align:middle line:-1
来查询或注册通知

00:21:55.516 --> 00:21:57.251 align:middle line:-1
设备热状态变化

00:21:57.851 --> 00:22:02.155 align:middle line:-1
检查低功耗模式的方式类似

00:21:57.851 --> 00:22:02.155 align:middle line:-1
检查低功耗模式的方式类似

00:22:02.923 --> 00:22:06.426 align:middle line:-2
另外 请考虑查询
来自MTLCommandBuffer的

00:22:06.493 --> 00:22:07.928 align:middle line:-1
GPU启动/GPU结束时间

00:22:08.395 --> 00:22:12.432 align:middle line:-1
以了解系统负载如何影响GPU时间

00:22:14.434 --> 00:22:17.070 align:middle line:-2
我们看看如何用一个简单的
代码示例来做到这个

00:22:18.372 --> 00:22:20.407 align:middle line:-1
这直接来自我们的最佳实践

00:22:21.175 --> 00:22:24.478 align:middle line:-2
它的核心是一个
非常简单的switch语句

00:22:24.878 --> 00:22:27.281 align:middle line:-1
每个case对应一个热状态

00:22:27.681 --> 00:22:28.649 align:middle line:-1
这里有名义上的

00:22:30.083 --> 00:22:30.918 align:middle line:-1
一般

00:22:32.186 --> 00:22:33.020 align:middle line:-1
重要

00:22:33.754 --> 00:22:34.588 align:middle line:-1
和关键

00:22:37.424 --> 00:22:39.359 align:middle line:-1
这一切都很好

00:22:39.426 --> 00:22:41.862 align:middle line:-1
现在我们知道我们处于热状态

00:22:42.629 --> 00:22:45.165 align:middle line:-1
并且这些指令告诉我们要做些什么

00:22:45.999 --> 00:22:49.903 align:middle line:-2
我们怎样才能真正帮助
系统保持低温？

00:22:50.971 --> 00:22:51.805 align:middle line:-1
嗯…

00:22:52.940 --> 00:22:56.310 align:middle line:-2
我可以给一些建议
但这取决于游戏开发者

00:22:56.376 --> 00:22:58.478 align:middle line:-1
来决定要做出什么样的妥协

00:22:58.979 --> 00:23:00.547 align:middle line:-1
以帮助系统

00:22:58.979 --> 00:23:00.547 align:middle line:-1
以帮助系统

00:23:01.215 --> 00:23:05.252 align:middle line:-2
你知道什么行动最适合你的游戏
以在压力下保持出色

00:23:06.520 --> 00:23:10.390 align:middle line:-1
我的一些建议是针对帧速率

00:23:10.457 --> 00:23:12.960 align:middle line:-1
以在整个游戏会话保持

00:23:13.627 --> 00:23:16.697 align:middle line:-2
例如
如果你不能以每秒60帧

00:23:16.930 --> 00:23:20.067 align:middle line:-2
维持10分钟或更长
那么保持每秒30帧

00:23:21.435 --> 00:23:24.972 align:middle line:-1
调整GPU工作也非常有用

00:23:25.939 --> 00:23:28.041 align:middle line:-1
例如 考虑降低

00:23:28.108 --> 00:23:29.810 align:middle line:-1
中间生成目标的分辨率

00:23:30.777 --> 00:23:32.813 align:middle line:-1
或者简化阴影图

00:23:33.380 --> 00:23:34.648 align:middle line:-1
加载更简单的资产

00:23:34.982 --> 00:23:37.951 align:middle line:-1
甚至完全删除一些后期处理

00:23:38.585 --> 00:23:40.921 align:middle line:-1
什么办法最适合你的游戏

00:23:41.722 --> 00:23:43.056 align:middle line:-1
你就应该采取什么

00:23:44.892 --> 00:23:48.028 align:middle line:-1
而且这把我们带到我们的下一个议题

00:23:49.129 --> 00:23:51.698 align:middle line:0
关于处理不必要的GPU工作

00:23:51.899 --> 00:23:54.835 align:middle line:0
为此 请欢迎我的同事Ohad上台

00:23:54.902 --> 00:23:56.336 align:middle line:0
他会都告诉你

00:23:56.403 --> 00:23:59.773 align:middle line:0
（不必要的GPU工作）

00:24:00.574 --> 00:24:01.508 align:middle line:-1
谢谢 Guillem

00:24:04.845 --> 00:24:05.679 align:middle line:-1
大家好

00:24:06.213 --> 00:24:07.814 align:middle line:-1
我叫Ohad

00:24:07.881 --> 00:24:09.883 align:middle line:-1
Apple的游戏技术团队成员

00:24:10.751 --> 00:24:11.985 align:middle line:0
在之前的幻灯片中

00:24:12.519 --> 00:24:16.089 align:middle line:0
Guillem展示了
适应系统的重要性

00:24:17.157 --> 00:24:21.728 align:middle line:0
响应低功耗模式或不同的热状态等

00:24:22.229 --> 00:24:24.631 align:middle line:0
将要求你调整GPU工作负载

00:24:24.698 --> 00:24:26.667 align:middle line:0
以保持整个游戏阶段

00:24:26.733 --> 00:24:28.335 align:middle line:0
一致的帧速

00:24:29.303 --> 00:24:33.373 align:middle line:0
然而 对于许多开发人员来说
GPU有点像黑盒子

00:24:33.540 --> 00:24:35.709 align:middle line:0
藏在游戏引擎的窗帘后面

00:24:36.343 --> 00:24:38.545 align:middle line:-1
今天 我们来拉开这个窗帘

00:24:40.480 --> 00:24:43.283 align:middle line:-1
浪费GPU时间是一个很常见的问题

00:24:43.584 --> 00:24:45.719 align:middle line:-1
也经常被忽视

00:24:46.119 --> 00:24:47.487 align:middle line:-1
但我希望你记住这一点

00:24:47.688 --> 00:24:51.258 align:middle line:-2
技术上出色的游戏
不仅会达到其GPU预算

00:24:52.259 --> 00:24:57.331 align:middle line:-2
它们也是系统的好公民
帮助它保持低温并节能

00:24:57.898 --> 00:24:59.299 align:middle line:-1
所有流行的游戏引擎

00:24:59.366 --> 00:25:01.702 align:middle line:-1
都提供了一系列最佳实践

00:24:59.366 --> 00:25:01.702 align:middle line:-1
都提供了一系列最佳实践

00:25:02.102 --> 00:25:03.136 align:middle line:-1
我们不会介绍这些

00:25:03.370 --> 00:25:07.107 align:middle line:-2
相反 我们将专注于
如何判断生成的内容是否昂贵

00:25:08.041 --> 00:25:11.078 align:middle line:-1
正如我们今天已经对CPU多次做的

00:25:11.712 --> 00:25:15.449 align:middle line:-1
这最佳实践是对GPU进行分析

00:25:17.217 --> 00:25:19.753 align:middle line:-1
我们GPU的强大功能可以隐藏许多

00:25:19.820 --> 00:25:22.089 align:middle line:-1
内容或算法上的效率

00:25:22.689 --> 00:25:26.527 align:middle line:-2
你需要对工作量计时
但也要了解

00:25:26.593 --> 00:25:28.495 align:middle line:-1
你启用的每种生成技术

00:25:29.096 --> 00:25:33.100 align:middle line:-2
并只保留那些
明显增加游戏视觉质量的技术

00:25:34.268 --> 00:25:36.403 align:middle line:-1
但是你怎么发现效率问题？

00:25:37.070 --> 00:25:40.474 align:middle line:-2
你如何确定过程的
哪些部分完全不必要？

00:25:40.707 --> 00:25:43.544 align:middle line:-1
这当然让我们回到了工具

00:25:44.878 --> 00:25:47.414 align:middle line:-2
与往常一样 你的第一站
应该是Instruments

00:25:48.015 --> 00:25:49.983 align:middle line:-1
我们在这里看看Metal系统跟踪

00:25:50.517 --> 00:25:54.154 align:middle line:-1
它将为你提供精确的时间：

00:25:54.354 --> 00:25:56.023 align:middle line:-1
顶点、片段及计算工作

00:25:57.224 --> 00:26:00.394 align:middle line:-2
但是测量GPU时间
只是一半的工作

00:25:57.224 --> 00:26:00.394 align:middle line:-2
但是测量GPU时间
只是一半的工作

00:26:00.894 --> 00:26:05.599 align:middle line:-2
接下来 你想要真正了解
每一步正在做什么

00:26:07.000 --> 00:26:11.071 align:middle line:-2
为此我们今年为Metal系统跟踪
添加了一个新工具

00:26:11.371 --> 00:26:12.806 align:middle line:-1
这是依赖关系图

00:26:15.175 --> 00:26:18.912 align:middle line:0
依赖关系图是一个单帧的故事

00:26:20.080 --> 00:26:21.815 align:middle line:0
它由节点和边组成

00:26:21.882 --> 00:26:24.651 align:middle line:0
每一个都讲述了故事的不同部分

00:26:25.719 --> 00:26:29.590 align:middle line:0
边表示步与步之间的依赖关系

00:26:29.857 --> 00:26:31.525 align:middle line:0
当你从上到下跟踪它们时

00:26:31.758 --> 00:26:34.528 align:middle line:0
你将看到每一步
在哪里可嵌入你的生成管道

00:26:34.761 --> 00:26:37.598 align:middle line:0
以及它们如何协同工作来创建框架

00:26:39.032 --> 00:26:42.703 align:middle line:0
另一方面 节点是单个步的故事

00:26:44.271 --> 00:26:46.139 align:middle line:-1
它们由三个主要组成部分组成

00:26:46.440 --> 00:26:50.310 align:middle line:-1
首先 title元素将给出步名称

00:26:50.711 --> 00:26:52.346 align:middle line:-1
我想确实强调这一点

00:26:52.613 --> 00:26:53.714 align:middle line:-1
命名标记一切

00:26:54.114 --> 00:26:56.316 align:middle line:-2
这不仅有助于
Dependency查看器

00:26:56.383 --> 00:26:58.485 align:middle line:-1
也有助于我们的整个工具套件

00:26:59.586 --> 00:27:00.420 align:middle line:-1
其次

00:26:59.586 --> 00:27:00.420 align:middle line:-1
其次

00:27:00.487 --> 00:27:04.124 align:middle line:-2
它可以让你快速了解
正在查看的步类型

00:27:04.958 --> 00:27:07.127 align:middle line:-1
生成、位块传输还是计算

00:27:07.461 --> 00:27:09.997 align:middle line:-2
这里 从图标中
我们可以看到它是一个生成步

00:27:11.465 --> 00:27:13.567 align:middle line:-1
接下来 这里有一个统计列表

00:27:13.634 --> 00:27:15.736 align:middle line:-1
描述了此步中正在完成的工作

00:27:16.837 --> 00:27:20.407 align:middle line:0
最后 在底部 在此步中写入的

00:27:20.474 --> 00:27:22.743 align:middle line:-1
所有资源的列表

00:27:22.943 --> 00:27:24.778 align:middle line:-1
并且每个资源都带标签

00:27:25.212 --> 00:27:27.281 align:middle line:-1
允许预览的缩略图

00:27:27.681 --> 00:27:31.885 align:middle line:-1
以及具体描述每个资源的信息列表

00:27:33.086 --> 00:27:34.188 align:middle line:-1
所有这些一起

00:27:34.454 --> 00:27:37.191 align:middle line:-1
可让你真正了解每一步

00:27:37.791 --> 00:27:40.227 align:middle line:-1
好的 现在我们知道如何读图表了

00:27:40.294 --> 00:27:43.463 align:middle line:-2
让我们跳转到一个演示
看看它们是如何组合在一起的

00:27:52.940 --> 00:27:56.743 align:middle line:-2
我在我的机器上运行了
Fox II演示

00:27:57.077 --> 00:27:58.345 align:middle line:-1
它是在SceneKit中构建的

00:27:58.612 --> 00:28:01.148 align:middle line:-1
允许我添加各种很棒的效果

00:27:58.612 --> 00:28:01.148 align:middle line:-1
允许我添加各种很棒的效果

00:28:02.349 --> 00:28:05.352 align:middle line:-1
如你所见 我有瀑落式阴影图

00:28:06.420 --> 00:28:09.823 align:middle line:-1
高光 景深 所有这些合在一起

00:28:09.990 --> 00:28:11.792 align:middle line:-1
创建一个精美生成的场景

00:28:12.526 --> 00:28:15.329 align:middle line:-2
我们用依赖关系查看器
来查看它是如何工作的

00:28:15.929 --> 00:28:18.765 align:middle line:-2
首先 我们将转到Xcode
然后我们将捕获一个帧

00:28:18.832 --> 00:28:21.001 align:middle line:-2
用底部的
Capture GPU框架按钮

00:28:21.535 --> 00:28:23.403 align:middle line:-1
我们选择左边的主要步

00:28:25.906 --> 00:28:27.641 align:middle line:-1
并切换到自动模式

00:28:27.708 --> 00:28:30.043 align:middle line:-1
我们右边出现助手

00:28:30.344 --> 00:28:34.248 align:middle line:-2
现在 注意我在调试导航器中
选择的同一步

00:28:34.314 --> 00:28:38.185 align:middle line:-1
也是被选的 并且在主视图中心

00:28:38.519 --> 00:28:39.987 align:middle line:-1
这是一条双向的街

00:28:40.888 --> 00:28:43.624 align:middle line:-1
当我们与图表进行交互时

00:28:43.690 --> 00:28:48.929 align:middle line:-1
选择不同的步或纹理甚至缓冲区

00:28:49.730 --> 00:28:52.499 align:middle line:-1
左侧的导航器和右侧的助手

00:28:52.733 --> 00:28:54.601 align:middle line:-1
都会更新以显示你的选择

00:28:55.302 --> 00:28:58.238 align:middle line:-1
这是帧导航的一种非常棒的方式

00:29:01.108 --> 00:29:03.710 align:middle line:-2
现在当我缩小时
你会注意到的第一件事

00:29:03.777 --> 00:29:06.280 align:middle line:-1
是统计隐藏了 焦点消失了

00:29:06.346 --> 00:29:09.550 align:middle line:-1
视图从单独步转到了整个帧

00:29:10.217 --> 00:29:11.785 align:middle line:-1
我可以缩小更多

00:29:12.186 --> 00:29:15.656 align:middle line:-1
可以看到我整个帧的鸟瞰图

00:29:17.357 --> 00:29:19.359 align:middle line:-1
现在注意真正酷的是

00:29:19.560 --> 00:29:22.963 align:middle line:-1
由于依赖关系驱动图的互联

00:29:24.364 --> 00:29:27.668 align:middle line:-1
每个逻辑工作在空间中组合在一起

00:29:28.335 --> 00:29:29.870 align:middle line:-2
让我们放大
看看我是什么意思

00:29:30.437 --> 00:29:33.540 align:middle line:-2
这里我有一个工作分支
正在创建我的阴影图

00:29:35.642 --> 00:29:38.045 align:middle line:-1
在左边 我可以看到三步

00:29:39.112 --> 00:29:40.547 align:middle line:-1
生成阴影

00:29:41.114 --> 00:29:42.516 align:middle line:-1
这太好了

00:29:42.749 --> 00:29:46.086 align:middle line:-1
因为我不只是了解整个帧的状态

00:29:46.153 --> 00:29:49.122 align:middle line:-1
还有这两层之间的联系

00:29:49.756 --> 00:29:52.593 align:middle line:-1
每个生成技术是怎么构建起来的

00:29:53.293 --> 00:29:56.196 align:middle line:-1
而当你使用游戏引擎打开它们时

00:29:56.263 --> 00:29:58.365 align:middle line:-1
这并非总是显而易见的

00:29:58.432 --> 00:30:01.301 align:middle line:-1
例如 用我的阴影图 我可能不知道

00:29:58.432 --> 00:30:01.301 align:middle line:-1
例如 用我的阴影图 我可能不知道

00:30:01.602 --> 00:30:04.771 align:middle line:-1
每个级联都需要自己的步

00:30:05.572 --> 00:30:07.674 align:middle line:-1
如果我单独考虑这些中的每一个

00:30:08.108 --> 00:30:09.543 align:middle line:-1
这不会很明显

00:30:09.710 --> 00:30:12.212 align:middle line:-2
但现在我看到
我必须将它们视为一个群体

00:30:13.447 --> 00:30:17.317 align:middle line:-1
我在调整GPU工作负载作妥协时

00:30:17.551 --> 00:30:21.188 align:middle line:-1
这个认识帮我做出明智决策

00:30:22.890 --> 00:30:24.358 align:middle line:-1
这就是依赖关系查看器

00:30:24.758 --> 00:30:26.193 align:middle line:-1
我切换回幻灯片

00:30:26.260 --> 00:30:29.563 align:middle line:-2
欢迎Guillem回到台上
谈他最后几点想法

00:30:29.630 --> 00:30:30.464 align:middle line:-1
谢谢

00:30:36.270 --> 00:30:37.938 align:middle line:-1
谢谢 这是一个出色的演示

00:30:38.372 --> 00:30:39.206 align:middle line:-1
谢谢

00:30:43.911 --> 00:30:44.745 align:middle line:-1
酷

00:30:44.811 --> 00:30:46.313 align:middle line:-1
Ohad刚刚向我们展示过

00:30:46.547 --> 00:30:48.782 align:middle line:-1
通过依赖关系查看器查看图帧的方式

00:30:50.117 --> 00:30:54.054 align:middle line:-1
而且 你可以检查GPU工作负载

00:30:54.721 --> 00:30:59.493 align:middle line:-2
例如 我们通常可能
从一个非常小而简单的过程

00:30:59.560 --> 00:31:00.594 align:middle line:-1
像这个

00:30:59.560 --> 00:31:00.594 align:middle line:-1
像这个

00:31:01.728 --> 00:31:03.263 align:middle line:-1
演变到一个非常复杂的过程

00:31:03.897 --> 00:31:05.866 align:middle line:-1
经过后期处理

00:31:06.166 --> 00:31:08.368 align:middle line:-1
HDR中的多个阴影图

00:31:09.703 --> 00:31:12.372 align:middle line:-1
所有这些的实现方法可以是

00:31:12.539 --> 00:31:15.976 align:middle line:-2
在你的游戏引擎的相机对象中
添加几个属性

00:31:17.244 --> 00:31:20.614 align:middle line:-1
你会发现这些更改的代码复杂性很小

00:31:21.215 --> 00:31:25.485 align:middle line:-1
但生成复杂性可能增加了十倍

00:31:26.820 --> 00:31:29.923 align:middle line:-1
这就把我们带回到开头

00:31:29.990 --> 00:31:31.391 align:middle line:-1
就在我们开篇的地方

00:31:32.793 --> 00:31:33.627 align:middle line:-1
分析资料

00:31:34.361 --> 00:31:38.065 align:middle line:-1
了解游戏的功能非常重要

00:31:39.399 --> 00:31:42.970 align:middle line:-1
你花了数万小时开发游戏

00:31:43.437 --> 00:31:46.573 align:middle line:-1
你应该考虑花一些时间进行分析

00:31:47.608 --> 00:31:49.309 align:middle line:-1
我们今天看到的一切

00:31:50.043 --> 00:31:51.612 align:middle line:-1
可以在几分钟内找到

00:31:52.646 --> 00:31:53.514 align:middle line:-1
最好的部分是什么？

00:31:53.847 --> 00:31:55.916 align:middle line:-1
你无需知道自己在寻找什么

00:31:56.083 --> 00:31:58.719 align:middle line:-1
仅仅记录口吃 查到长帧

00:31:59.152 --> 00:32:01.188 align:middle line:-1
并从那里开始一直继续

00:31:59.152 --> 00:32:01.188 align:middle line:-1
并从那里开始一直继续

00:32:01.588 --> 00:32:02.623 align:middle line:-1
就这么简单

00:32:03.090 --> 00:32:05.325 align:middle line:-1
这个工具将为你提供所需的所有信息

00:32:05.592 --> 00:32:06.760 align:middle line:-1
来识别问题

00:32:07.594 --> 00:32:09.029 align:middle line:-1
但你需要使用该工具

00:32:10.564 --> 00:32:14.067 align:middle line:-1
这就是关键

00:32:14.535 --> 00:32:16.803 align:middle line:-1
我们看到了一堆常见的陷阱

00:32:17.171 --> 00:32:18.772 align:middle line:-1
和一些最佳的解决办法

00:32:19.806 --> 00:32:20.707 align:middle line:-1
所有这些问题

00:32:21.508 --> 00:32:22.943 align:middle line:-1
可以通过分析找到

00:32:23.177 --> 00:32:24.311 align:middle line:-1
我们就是这样找到问题

00:32:24.378 --> 00:32:27.214 align:middle line:-2
我们分析了大量游戏
发现了常见问题

00:32:27.281 --> 00:32:28.849 align:middle line:-1
并决定把它们放在一起

00:32:29.917 --> 00:32:32.920 align:middle line:-1
如果你有权访问引擎源代码

00:32:33.687 --> 00:32:37.324 align:middle line:-1
确保帧速度和线程优先级都配置好

00:32:37.824 --> 00:32:39.726 align:middle line:-1
这只是几行代码

00:32:40.694 --> 00:32:41.562 align:middle line:-1
但无论如何

00:32:41.895 --> 00:32:44.364 align:middle line:-1
你的游戏应该始终适应热量需求

00:32:44.765 --> 00:32:47.601 align:middle line:-1
并且不要提交不必要的GPU工作

00:32:48.435 --> 00:32:51.338 align:middle line:-1
确保遵循所有这些最佳实践

00:32:51.972 --> 00:32:54.408 align:middle line:-1
你也将开发技术上令人敬畏的游戏

00:32:54.741 --> 00:32:56.210 align:middle line:-1
这就是我们这个谈话的宗旨

00:32:57.344 --> 00:32:58.478 align:middle line:-1
更多信息

00:32:58.979 --> 00:33:01.515 align:middle line:-1
中午12点会设一个实验室

00:32:58.979 --> 00:33:01.515 align:middle line:-1
中午12点会设一个实验室

00:33:01.682 --> 00:33:03.083 align:middle line:-1
我们会在那儿 我会在那儿

00:33:03.150 --> 00:33:05.719 align:middle line:-1
如果你在这次会议之后有任何问题

00:33:05.786 --> 00:33:07.321 align:middle line:-1
我们非常乐意回答

00:33:07.955 --> 00:33:11.825 align:middle line:-2
或者也许你只是想坐下来
让我们分析你的游戏

00:33:12.659 --> 00:33:15.996 align:middle line:-1
此次WWDC还有两场精彩的演讲

00:33:16.063 --> 00:33:18.966 align:middle line:-2
关于游戏开发者的Metal
和我们的分析工具

00:33:21.068 --> 00:33:23.270 align:middle line:-1
非常感谢 祝你们今天愉快

00:33:23.770 --> 00:33:24.671 align:middle line:-1
度过愉快的一天
