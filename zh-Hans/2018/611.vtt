WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:17.516 --> 00:00:23.336 A:middle
[ 掌声 ]

00:00:23.836 --> 00:00:24.826 A:middle
&gt;&gt; 大家早上好

00:00:25.046 --> 00:00:26.676 A:middle
我叫 Karol Gasinski 我是

00:00:26.676 --> 00:00:29.566 A:middle
GPU 软件架构组的成员

00:00:29.566 --> 00:00:32.836 A:middle
在本次会议的开头

00:00:32.836 --> 00:00:35.186 A:middle
我们将简单概括

00:00:35.286 --> 00:00:38.196 A:middle
macOS 中的新功能 主要和 VR 的应用有关

00:00:38.946 --> 00:00:40.826 A:middle
然后 我们将深入探讨

00:00:41.046 --> 00:00:42.906 A:middle
Metal 2 的新特性

00:00:43.136 --> 00:00:45.016 A:middle
它是今年

00:00:45.016 --> 00:00:45.476 A:middle
专为 VR 而设计的

00:00:46.756 --> 00:00:48.576 A:middle
最后 在本次会议的结尾

00:00:48.576 --> 00:00:50.466 A:middle
我们将讨论

00:00:50.626 --> 00:00:52.236 A:middle
开发 VR App 的先进技术

00:00:53.856 --> 00:00:56.026 A:middle
近来 我们推出了全新的 iMac 和 iMac Pro

00:00:56.116 --> 00:00:57.976 A:middle
这两款产品使用了强大的

00:00:57.976 --> 00:01:00.776 A:middle
图形处理器

00:00:57.976 --> 00:01:00.776 A:middle
图形处理器

00:01:00.776 --> 00:01:01.936 A:middle
iMac 如今配有基于 ARM 的

00:01:01.936 --> 00:01:05.636 A:middle
图形处理器 并且拥有最高 8 GB

00:01:05.636 --> 00:01:06.976 A:middle
的视频存储器

00:01:07.716 --> 00:01:09.946 A:middle
而 iMac Pro 配有

00:01:09.946 --> 00:01:11.786 A:middle
更先进且更大的

00:01:11.786 --> 00:01:15.586 A:middle
图形处理器 视频存储器容量最高可达 16 GB

00:01:16.546 --> 00:01:18.636 A:middle
这是多么强大的功能

00:01:18.636 --> 00:01:19.536 A:middle
现在就掌握在大家的手中

00:01:20.386 --> 00:01:21.516 A:middle
但我们并没有

00:01:21.516 --> 00:01:23.406 A:middle
将服务限制在 iMac 上

00:01:24.166 --> 00:01:25.976 A:middle
我们最近宣布

00:01:25.976 --> 00:01:28.456 A:middle
扩展了图形处理器支持 这能让你

00:01:28.456 --> 00:01:30.816 A:middle
将任何一台 Mac 变成强大的工作站

00:01:30.936 --> 00:01:34.376 A:middle
它将赋予你超过

00:01:34.376 --> 00:01:35.116 A:middle
10 倍更强大的

00:01:35.176 --> 00:01:36.376 A:middle
处理能力

00:01:37.126 --> 00:01:37.886 A:middle
我们做的还不止这些

00:01:39.106 --> 00:01:40.786 A:middle
今天我们介绍的是

00:01:40.786 --> 00:01:43.276 A:middle
HTC Vive 这款头戴式显示器

00:01:43.406 --> 00:01:44.406 A:middle
的即插即用支持

00:01:45.196 --> 00:01:48.966 A:middle
它有两块 1440x1600

00:01:48.966 --> 00:01:54.826 A:middle
AMOLED 的屏幕和每英寸 615 像素

00:01:54.956 --> 00:01:58.366 A:middle
和 Vive 相比

00:01:58.366 --> 00:02:01.516 A:middle
分辨率提高了百分之 78

00:01:58.366 --> 00:02:01.516 A:middle
分辨率提高了百分之 78

00:02:01.566 --> 00:02:03.616 A:middle
像素密度提高了百分之 57

00:02:03.746 --> 00:02:06.676 A:middle
更强大的屏幕

00:02:06.786 --> 00:02:09.086 A:middle
为它的新前置双摄像头系统

00:02:09.186 --> 00:02:11.266 A:middle
提供了支持

00:02:11.666 --> 00:02:13.526 A:middle
这样 开发者们就可以

00:02:13.526 --> 00:02:14.886 A:middle
用这些摄像头

00:02:14.956 --> 00:02:16.386 A:middle
在 Mac 上

00:02:16.386 --> 00:02:18.036 A:middle
尝试直通视频

00:02:18.236 --> 00:02:19.486 A:middle
同时加上 Vive Pro 的支持

00:02:19.486 --> 00:02:21.966 A:middle
就得到了更加先进的跟踪系统

00:02:23.456 --> 00:02:25.186 A:middle
那么 你现在可能想知道如何

00:02:25.186 --> 00:02:26.426 A:middle
在 macOS 上

00:02:26.426 --> 00:02:28.036 A:middle
开始 VR App 的开发

00:02:28.906 --> 00:02:32.506 A:middle
HTC Vive 和 Vive Pro

00:02:32.506 --> 00:02:34.526 A:middle
同时能和 Valve 的

00:02:34.826 --> 00:02:37.456 A:middle
SteamVR Runtime 一起运行 这能提供

00:02:37.456 --> 00:02:40.226 A:middle
大量的服务 其中就包括 VR 生成器

00:02:40.676 --> 00:02:43.936 A:middle
Valve 也能让开放的 VR

00:02:43.936 --> 00:02:46.016 A:middle
框架运行于 macOS 上

00:02:46.016 --> 00:02:49.576 A:middle
这样你就能通过 SteamVR 建立地图

00:02:50.626 --> 00:02:54.876 A:middle
我们一直和 Valve 以及 HTC 紧密合作

00:02:54.876 --> 00:02:57.516 A:middle
确保 Vive Pro 在 macOS 上的

00:02:57.676 --> 00:03:00.356 A:middle
SteamVR Runtime 中获得支持

00:02:57.676 --> 00:03:00.356 A:middle
SteamVR Runtime 中获得支持

00:03:03.006 --> 00:03:04.796 A:middle
那么 接下来我们来了解一下

00:03:04.796 --> 00:03:06.486 A:middle
我们现在正在介绍的 Metal 新功能

00:03:06.486 --> 00:03:09.786 A:middle
会如何开发 macOS Mojave 可以用来

00:03:09.786 --> 00:03:11.946 A:middle
优化你的 VR App 的品质

00:03:12.036 --> 00:03:14.356 A:middle
为了帮助大家回忆 让我们

00:03:15.086 --> 00:03:16.736 A:middle
回顾一下当下

00:03:16.736 --> 00:03:18.786 A:middle
App 和 VR 生成器之间的交互

00:03:18.896 --> 00:03:21.386 A:middle
App 在启动时会

00:03:21.386 --> 00:03:23.106 A:middle
将针对左眼和右眼的图像

00:03:23.106 --> 00:03:26.026 A:middle
转换为 30 个多样本纹理

00:03:26.776 --> 00:03:28.306 A:middle
然后它会将这些图像分解成

00:03:28.306 --> 00:03:30.556 A:middle
iOS 表面背景纹理

00:03:30.726 --> 00:03:32.456 A:middle
它可以进一步

00:03:32.456 --> 00:03:33.816 A:middle
传递给 VR 生成器

00:03:33.816 --> 00:03:37.926 A:middle
VR 生成器将会执行最终

00:03:37.986 --> 00:03:39.476 A:middle
处理步骤

00:03:39.556 --> 00:03:42.446 A:middle
其中包括镜头失真校正

00:03:42.446 --> 00:03:44.356 A:middle
色差调整以及排序操作

00:03:44.986 --> 00:03:47.026 A:middle
简单来说就是变形

00:03:48.426 --> 00:03:49.866 A:middle
最终图像一旦生成

00:03:49.956 --> 00:03:52.066 A:middle
就会被发送到

00:03:52.066 --> 00:03:53.846 A:middle
头戴式设备或呈现的画面之中

00:03:54.936 --> 00:03:56.856 A:middle
这里涉及的很多操作

00:03:56.916 --> 00:03:59.446 A:middle
会发生两次 让我们来看一下

00:03:59.446 --> 00:04:02.456 A:middle
你可不可以对此做些什么

00:03:59.446 --> 00:04:02.456 A:middle
你可不可以对此做些什么

00:04:02.766 --> 00:04:04.126 A:middle
看 如今有了 VR App

00:04:04.126 --> 00:04:06.656 A:middle
它想要从多样本中获益

00:04:07.236 --> 00:04:08.806 A:middle
它需要针对每只眼睛使用

00:04:08.976 --> 00:04:12.016 A:middle
专用纹理 或者都使用

00:04:12.016 --> 00:04:13.666 A:middle
单一的共享纹理

00:04:13.716 --> 00:04:15.726 A:middle
但是这些布局都并不完美

00:04:16.576 --> 00:04:18.386 A:middle
专用纹理需要

00:04:18.386 --> 00:04:20.505 A:middle
独立的绘图调用和通道

00:04:20.886 --> 00:04:21.846 A:middle
这正如我们所见

00:04:23.166 --> 00:04:25.246 A:middle
而直接纹理可以

00:04:25.246 --> 00:04:27.296 A:middle
在单一渲染和结果通道中

00:04:27.656 --> 00:04:30.456 A:middle
进行双眼的渲染

00:04:30.456 --> 00:04:32.206 A:middle
这些纹理在

00:04:32.276 --> 00:04:34.196 A:middle
后期处理和效果方面会产生一些问题

00:04:34.736 --> 00:04:36.986 A:middle
对于分层纹理拥有

00:04:36.986 --> 00:04:38.956 A:middle
专用纹理和共享布局

00:04:39.126 --> 00:04:41.556 A:middle
的全部优势 但是

00:04:41.646 --> 00:04:44.056 A:middle
当下它们不能和多重采样抗锯齿一起使用

00:04:45.816 --> 00:04:47.506 A:middle
这促使 App 开发者们

00:04:47.566 --> 00:04:48.826 A:middle
使用不同的渲染兼用布局

00:04:48.936 --> 00:04:50.876 A:middle
具体取决于

00:04:51.096 --> 00:04:54.406 A:middle
他们是否想使用多重采样抗锯齿

00:04:54.936 --> 00:04:57.646 A:middle
或使用不同诀窍来解决这一问题

00:04:57.866 --> 00:04:59.416 A:middle
那么我们就来看看 我们可以如何优化

00:04:59.466 --> 00:05:00.116 A:middle
这一渲染

00:04:59.466 --> 00:05:00.116 A:middle
这一渲染

00:05:02.166 --> 00:05:03.966 A:middle
今天我们要介绍

00:05:04.056 --> 00:05:06.026 A:middle
一个新的纹理

00:05:06.026 --> 00:05:07.396 A:middle
2DMultisampleArray 纹理

00:05:08.366 --> 00:05:10.726 A:middle
这一纹理类型拥有

00:05:10.726 --> 00:05:13.166 A:middle
上述类型的所有优点

00:05:13.266 --> 00:05:15.336 A:middle
而没有上述类型的任何缺点

00:05:15.476 --> 00:05:17.806 A:middle
多亏有了它

00:05:17.806 --> 00:05:19.606 A:middle
现在可以区分每一

00:05:19.606 --> 00:05:22.516 A:middle
渲染空间

00:05:22.516 --> 00:05:24.696 A:middle
这简化了后期处理

00:05:24.696 --> 00:05:28.286 A:middle
效果 视图数

00:05:28.286 --> 00:05:30.016 A:middle
这样 App 就可以

00:05:30.016 --> 00:05:33.536 A:middle
轻松地返回单视场渲染

00:05:33.536 --> 00:05:35.406 A:middle
并能控制抗锯齿模式

00:05:36.436 --> 00:05:38.786 A:middle
作为结果 App 就能

00:05:38.786 --> 00:05:40.956 A:middle
拥有单一渲染文件

00:05:40.956 --> 00:05:43.456 A:middle
可以轻松运用于任何情形之中

00:05:43.556 --> 00:05:46.056 A:middle
最重要的是

00:05:46.056 --> 00:05:48.206 A:middle
在每种情景中 App 可以

00:05:48.206 --> 00:05:50.736 A:middle
通过单一绘图和渲染通道

00:05:50.736 --> 00:05:51.056 A:middle
被渲染

00:05:53.936 --> 00:05:55.686 A:middle
那么这里我们可以看到

00:05:55.686 --> 00:05:57.916 A:middle
创建上述 2DMultisampleArray

00:05:57.916 --> 00:05:59.126 A:middle
纹理的代码片段

00:06:01.146 --> 00:06:03.446 A:middle
我们将样本数设置为 4

00:06:03.446 --> 00:06:05.386 A:middle
这样就能在质量和性能之间

00:06:05.426 --> 00:06:07.486 A:middle
达到最佳平衡

00:06:07.486 --> 00:06:09.736 A:middle
与此同时 我们将

00:06:09.826 --> 00:06:12.436 A:middle
其他长度设置为 2 因为我们想

00:06:12.436 --> 00:06:16.346 A:middle
将每只眼睛的图像存储为

00:06:16.446 --> 00:06:17.226 A:middle
独立的切片

00:06:18.676 --> 00:06:21.776 A:middle
那么让我们让来看看 管线会怎样

00:06:21.776 --> 00:06:22.376 A:middle
发生变化

00:06:23.606 --> 00:06:25.126 A:middle
我们现在可以将那些 2D

00:06:25.126 --> 00:06:27.396 A:middle
多样本纹理用

00:06:27.396 --> 00:06:29.596 A:middle
单一 2D 多样本阵列纹理

00:06:32.066 --> 00:06:32.156 A:middle
纹理进行替换

00:06:33.136 --> 00:06:34.856 A:middle
那么现在 App 就能

00:06:34.966 --> 00:06:38.396 A:middle
在单一渲染通道进行双眼渲染

00:06:38.396 --> 00:06:40.686 A:middle
而且如果它使用实例化

00:06:40.976 --> 00:06:42.356 A:middle
它甚至可以在单一绘图代码中

00:06:42.356 --> 00:06:42.596 A:middle
做到这一点

00:06:42.596 --> 00:06:45.606 A:middle
这已经看起来很不错了

00:06:45.606 --> 00:06:47.266 A:middle
但是我们仍然需要将那些

00:06:47.726 --> 00:06:49.976 A:middle
2D 多样本阵列纹理切片

00:06:49.976 --> 00:06:52.346 A:middle
变为独立的 iOS

00:06:52.406 --> 00:06:54.636 A:middle
面部图像在我们将其传递到

00:06:54.636 --> 00:06:55.716 A:middle
生成器之前

00:06:56.936 --> 00:06:59.156 A:middle
那么让我们专注于我们自己的方式

00:06:59.156 --> 00:07:01.276 A:middle
App 和生成器

00:06:59.156 --> 00:07:01.276 A:middle
App 和生成器

00:07:01.306 --> 00:07:01.746 A:middle
共享纹理

00:07:01.746 --> 00:07:04.676 A:middle
那么现在 为了共享纹理

00:07:04.676 --> 00:07:05.826 A:middle
我们使用 IOSurface

00:07:06.786 --> 00:07:08.316 A:middle
它们在不同的进程空间

00:07:08.426 --> 00:07:10.086 A:middle
和不同的图形处理器之间

00:07:10.796 --> 00:07:14.086 A:middle
共享纹理 但是有着这样的

00:07:14.186 --> 00:07:15.466 A:middle
灵活性会产生代价

00:07:16.436 --> 00:07:19.466 A:middle
IOSurface 只可用于

00:07:19.466 --> 00:07:22.316 A:middle
共享简单的 2D 纹理

00:07:22.316 --> 00:07:23.876 A:middle
所以如果你有多样本纹理

00:07:24.266 --> 00:07:25.996 A:middle
存储困难或者拥有

00:07:26.806 --> 00:07:27.736 A:middle
复杂的纹理 它们不能被共享

00:07:29.046 --> 00:07:30.706 A:middle
这就是为什么我们今天要介绍

00:07:30.706 --> 00:07:32.836 A:middle
可共享的 Metal 纹理

00:07:32.836 --> 00:07:34.676 A:middle
他们能让你的 App

00:07:34.806 --> 00:07:36.486 A:middle
在进程空间之间共享

00:07:36.796 --> 00:07:39.736 A:middle
任意一种 Metal 纹理

00:07:39.836 --> 00:07:42.046 A:middle
只要这些纹理位于

00:07:42.046 --> 00:07:43.106 A:middle
单一图形处理器之中

00:07:43.996 --> 00:07:46.726 A:middle
这个文件的特色是

00:07:46.856 --> 00:07:49.116 A:middle
这些案例的高级视图

00:07:49.636 --> 00:07:51.956 A:middle
例如 将场景的深度

00:07:52.036 --> 00:07:53.946 A:middle
和 VR 生成器进行共享

00:07:54.486 --> 00:07:56.446 A:middle
但是 当然并不仅限于此

00:07:57.256 --> 00:07:59.016 A:middle
现在让我们看看如何

00:07:59.086 --> 00:08:00.236 A:middle
来创建那些纹理

00:07:59.086 --> 00:08:00.236 A:middle
来创建那些纹理

00:08:02.636 --> 00:08:03.906 A:middle
因为可共享的纹理

00:08:03.996 --> 00:08:06.316 A:middle
能让我们在进程之间

00:08:06.366 --> 00:08:08.296 A:middle
传递复杂纹理 所以我们

00:08:08.296 --> 00:08:10.676 A:middle
会创建 2D 阵列纹理

00:08:10.676 --> 00:08:12.936 A:middle
我们会将其传递给 VR 生成器

00:08:13.216 --> 00:08:16.116 A:middle
如你所见 我们为此

00:08:16.226 --> 00:08:18.126 A:middle
使用了新方式

00:08:18.206 --> 00:08:19.426 A:middle
用这个创建工具创建了新的共享纹理

00:08:19.976 --> 00:08:22.986 A:middle
与此同时

00:08:23.056 --> 00:08:24.926 A:middle
你必须记得使用

00:08:25.096 --> 00:08:27.036 A:middle
Private 存储模式

00:08:27.036 --> 00:08:29.286 A:middle
这一纹理仅能通过将其创建出来的

00:08:29.706 --> 00:08:33.126 A:middle
图形处理器获得

00:08:33.876 --> 00:08:35.996 A:middle
现在我们可以看到一个代码片段

00:08:36.456 --> 00:08:38.546 A:middle
向我们展示了以前我们的 VR

00:08:38.546 --> 00:08:41.416 A:middle
App 会如何将 IOSurface

00:08:41.556 --> 00:08:44.186 A:middle
发送到 VR 生成器

00:08:44.186 --> 00:08:45.526 A:middle
我们现在来看看这个代码片段

00:08:45.526 --> 00:08:47.656 A:middle
看看需要做出哪些改变

00:08:47.746 --> 00:08:50.676 A:middle
从而可以从使用 IOSurface

00:08:50.676 --> 00:08:53.516 A:middle
转变为共享的 Metal 纹理

00:08:54.976 --> 00:08:56.166 A:middle
所以我们无须再使用这两个

00:08:56.166 --> 00:08:59.366 A:middle
IOSurface 而且由它们

00:08:59.426 --> 00:09:01.006 A:middle
支持的两种纹理

00:08:59.426 --> 00:09:01.006 A:middle
支持的两种纹理

00:09:01.006 --> 00:09:03.256 A:middle
现在可以被替换为

00:09:03.256 --> 00:09:05.686 A:middle
单一可共享 Metal 纹理

00:09:05.976 --> 00:09:08.246 A:middle
这就是目前的 2D 阵列纹理

00:09:09.236 --> 00:09:11.956 A:middle
然后我们会将这一纹理分配给

00:09:12.146 --> 00:09:15.136 A:middle
来自开放式 VRSDK

00:09:15.176 --> 00:09:19.116 A:middle
的两个纹理描述器 并将它的类型

00:09:19.526 --> 00:09:21.416 A:middle
从 IOSurface 改变为 Metal

00:09:21.526 --> 00:09:25.076 A:middle
在完成这几项改变之后

00:09:25.836 --> 00:09:27.826 A:middle
我们可以将针对

00:09:27.826 --> 00:09:31.606 A:middle
左眼和右眼的图像 提交至生成器

00:09:32.346 --> 00:09:35.666 A:middle
然后生成器就会知道 我们已经传递了

00:09:35.666 --> 00:09:37.446 A:middle
拥有高级布局的 Metal 纹理

00:09:37.686 --> 00:09:40.366 A:middle
而非 IOSurface 而且当我们

00:09:40.366 --> 00:09:42.526 A:middle
查看的时候 如果它的类型是 2D 阵列纹理

00:09:42.856 --> 00:09:44.596 A:middle
或者 2D 多样本阵列纹理

00:09:45.246 --> 00:09:47.336 A:middle
如果是这样 那么生成器将

00:09:47.416 --> 00:09:49.736 A:middle
自动认定

00:09:49.736 --> 00:09:51.546 A:middle
对于左眼的图像存储于

00:09:51.546 --> 00:09:54.266 A:middle
切片 0 之中 对于右眼的图像

00:09:54.266 --> 00:09:55.876 A:middle
存储于 切片 1 之中

00:09:56.536 --> 00:09:57.916 A:middle
这样你的 App 就无须

00:09:57.966 --> 00:09:59.396 A:middle
再对此做任何其他操作

00:09:59.396 --> 00:10:03.326 A:middle
当然 在 App

00:09:59.396 --> 00:10:03.326 A:middle
当然 在 App

00:10:03.326 --> 00:10:05.266 A:middle
和生成器之间

00:10:05.266 --> 00:10:06.806 A:middle
共享 Metal

00:10:06.856 --> 00:10:08.636 A:middle
并非是 Metal 纹理的唯一用法

00:10:09.436 --> 00:10:11.126 A:middle
这里有几个简单的例子

00:10:11.126 --> 00:10:12.506 A:middle
展现了你可以如何

00:10:12.506 --> 00:10:14.156 A:middle
在任意两个进程之间

00:10:14.156 --> 00:10:14.956 A:middle
传递 Metal 纹理

00:10:15.816 --> 00:10:17.766 A:middle
那么我们完全按照同样的方式开始

00:10:18.046 --> 00:10:19.326 A:middle
我们创建我们的可共享 Metal 纹理

00:10:19.326 --> 00:10:23.206 A:middle
但如今我们从这一纹理中

00:10:23.286 --> 00:10:25.136 A:middle
创建出了可以在

00:10:25.286 --> 00:10:27.456 A:middle
进程空间之间传递的

00:10:27.456 --> 00:10:29.726 A:middle
特殊共享纹理句柄

00:10:30.136 --> 00:10:31.176 A:middle
可以通过跨进程

00:10:31.246 --> 00:10:32.556 A:middle
通信连接

00:10:33.236 --> 00:10:36.056 A:middle
一旦这一句柄被传递至

00:10:36.056 --> 00:10:39.306 A:middle
其他进程 它就可以用于

00:10:39.306 --> 00:10:41.496 A:middle
重新创建纹理对象

00:10:42.346 --> 00:10:44.906 A:middle
但在做此的同时 你必须

00:10:45.006 --> 00:10:46.936 A:middle
记得在与其他进程空间中

00:10:47.016 --> 00:10:49.096 A:middle
进行创建时

00:10:49.096 --> 00:10:51.616 A:middle
所使用的相同设备上

00:10:51.666 --> 00:10:53.326 A:middle
重新创建你的纹理对象

00:10:53.896 --> 00:10:56.176 A:middle
因为这一纹理不能脱离

00:10:56.176 --> 00:10:57.666 A:middle
图形处理器的范围

00:10:58.266 --> 00:11:02.476 A:middle
现在我们再回过来看我们的管线

00:10:58.266 --> 00:11:02.476 A:middle
现在我们再回过来看我们的管线

00:11:02.716 --> 00:11:05.576 A:middle
看看会发生什么变化

00:11:05.606 --> 00:11:07.806 A:middle
现在 App 可以

00:11:07.806 --> 00:11:10.466 A:middle
用一个 2D 阵列纹理

00:11:10.466 --> 00:11:13.096 A:middle
替换那些分离的 IOSurface

00:11:13.096 --> 00:11:14.256 A:middle
将针对双眼的图像存储起来

00:11:15.346 --> 00:11:17.406 A:middle
这能够促成进一步的优化

00:11:18.026 --> 00:11:20.166 A:middle
因为原始的 2D 多样本

00:11:20.166 --> 00:11:21.876 A:middle
阵列纹理现在也可以

00:11:21.876 --> 00:11:24.236 A:middle
在一个通道中加以解决

00:11:24.606 --> 00:11:25.906 A:middle
只需通过阵列纹理

00:11:25.906 --> 00:11:26.736 A:middle
将其创建成可共享的类型即可

00:11:27.706 --> 00:11:28.716 A:middle
而且不止如此

00:11:29.486 --> 00:11:30.786 A:middle
让我们来看一下生成器

00:11:32.286 --> 00:11:33.196 A:middle
一旦我们在 App 上

00:11:33.196 --> 00:11:35.006 A:middle
完成了渲染部件的简化

00:11:35.006 --> 00:11:36.596 A:middle
就没有什么

00:11:36.716 --> 00:11:38.176 A:middle
可以阻止生成器

00:11:38.406 --> 00:11:40.596 A:middle
从这些新特性中获益

00:11:41.246 --> 00:11:45.056 A:middle
所以生成器现在可以使用

00:11:45.126 --> 00:11:47.826 A:middle
这些即将发布的 2D 阵列纹理

00:11:47.826 --> 00:11:50.086 A:middle
并能在单一渲染通道中

00:11:50.086 --> 00:11:51.576 A:middle
针对双眼执行操作

00:11:51.736 --> 00:11:54.836 A:middle
正如你所见 我们刚刚完成了

00:11:54.836 --> 00:11:56.396 A:middle
整条管线的简化

00:11:57.816 --> 00:11:59.246 A:middle
那么让我们来总结一下

00:11:59.246 --> 00:11:59.766 A:middle
我们刚刚了解到的内容

00:12:01.776 --> 00:12:03.266 A:middle
我们刚刚描述了两种新的

00:12:03.266 --> 00:12:04.236 A:middle
Metal 纹理

00:12:04.576 --> 00:12:07.846 A:middle
可共享 Metal 纹理以及

00:12:07.846 --> 00:12:09.746 A:middle
2D 多样本阵列纹理

00:12:09.746 --> 00:12:12.356 A:middle
以及用他们来

00:12:12.406 --> 00:12:14.246 A:middle
进一步优化你的渲染管线

00:12:14.326 --> 00:12:14.856 A:middle
的方式

00:12:16.026 --> 00:12:17.406 A:middle
这两种纹理马上就会

00:12:17.406 --> 00:12:19.326 A:middle
在即将推出的 SteamVR

00:12:19.326 --> 00:12:20.836 A:middle
Runtime 更新中获得支持

00:12:22.016 --> 00:12:23.686 A:middle
那么现在让我们把注意力集中在

00:12:23.686 --> 00:12:25.166 A:middle
那些可以将你 App 的

00:12:25.166 --> 00:12:27.376 A:middle
中央处理器和图形处理器的使用

00:12:27.376 --> 00:12:28.736 A:middle
最大化的技术之上

00:12:29.796 --> 00:12:32.276 A:middle
这一部分我们会分为

00:12:32.366 --> 00:12:34.696 A:middle
两个小节 先进的帧同步技术

00:12:34.696 --> 00:12:36.656 A:middle
以及不断降低的空闲率

00:12:38.386 --> 00:12:40.436 A:middle
我们先来讲讲帧同步技术

00:12:41.276 --> 00:12:43.426 A:middle
在这一小节中

00:12:43.426 --> 00:12:45.446 A:middle
我们将分析 App 的帧同步技术

00:12:45.536 --> 00:12:47.266 A:middle
以及如何为了 VR 优化帧同步技术

00:12:48.306 --> 00:12:49.936 A:middle
那么我们先从简单的

00:12:50.146 --> 00:12:52.096 A:middle
单线程 App 入手

00:12:52.096 --> 00:12:53.646 A:middle
它们在执行所有操作时都会

00:12:53.646 --> 00:12:54.476 A:middle
采取串口监视的方式

00:12:55.406 --> 00:12:57.336 A:middle
这样的 App 会通过调用 WaitGet 停顿

00:12:57.336 --> 00:12:59.816 A:middle
开始处理其中的画面

00:13:00.866 --> 00:13:03.256 A:middle
从而接收停顿

00:13:03.256 --> 00:13:05.866 A:middle
并将其执行情况同步到

00:13:05.866 --> 00:13:07.256 A:middle
头戴式设备的帧率之中

00:13:09.026 --> 00:13:11.506 A:middle
Vive 和 Vive Pro 都拥有

00:13:11.506 --> 00:13:13.286 A:middle
每秒 90 帧的刷新率

00:13:13.286 --> 00:13:14.936 A:middle
这就意味着

00:13:14.986 --> 00:13:17.096 A:middle
App 只需要 11.1

00:13:17.096 --> 00:13:19.316 A:middle
毫秒就能处理一帧

00:13:20.086 --> 00:13:22.496 A:middle
对比之下 眨一下眼

00:13:22.746 --> 00:13:24.756 A:middle
大约需要 300 毫秒

00:13:25.536 --> 00:13:27.286 A:middle
那么在这一时间里

00:13:27.286 --> 00:13:28.666 A:middle
App 就能渲染 50 帧画面

00:13:30.326 --> 00:13:32.436 A:middle
所以一旦 App 收到了

00:13:32.616 --> 00:13:34.736 A:middle
来自 WaitGet 停顿的停顿

00:13:34.806 --> 00:13:37.636 A:middle
它就能开始模拟你的试验

00:13:38.816 --> 00:13:39.886 A:middle
一旦完成模拟

00:13:39.956 --> 00:13:41.676 A:middle
也就知道了

00:13:41.676 --> 00:13:43.756 A:middle
所有对象的状态

00:13:43.756 --> 00:13:46.076 A:middle
App 就能继续对

00:13:46.206 --> 00:13:48.286 A:middle
命令缓冲区进行编码

00:13:48.286 --> 00:13:50.386 A:middle
然后将其发送至图形处理器 以实现执行目的

00:13:51.886 --> 00:13:54.786 A:middle
一旦图形处理器完成操作

00:13:54.786 --> 00:13:57.416 A:middle
针对双眼的图像 也就渲染完成了

00:13:57.416 --> 00:13:59.906 A:middle
它可以被发送至 VR 生成器

00:13:59.906 --> 00:14:01.426 A:middle
进行我们在前几张幻灯片中所讲的

00:13:59.906 --> 00:14:01.426 A:middle
进行我们在前几张幻灯片中所讲的

00:14:01.516 --> 00:14:02.706 A:middle
最终后期处理

00:14:02.706 --> 00:14:07.316 A:middle
然后再从存储器中

00:14:07.646 --> 00:14:09.466 A:middle
将各帧图像扫描到 头戴式设备的面板中

00:14:09.596 --> 00:14:12.266 A:middle
这一传输需要额外的帧

00:14:12.266 --> 00:14:15.226 A:middle
因为在呈现图像之前

00:14:15.376 --> 00:14:17.986 A:middle
所有像素必须完成更新

00:14:19.296 --> 00:14:23.436 A:middle
一旦所有像素完成更新

00:14:23.566 --> 00:14:25.686 A:middle
头戴式设备的面板中和用户 可以看到

00:14:25.686 --> 00:14:26.106 A:middle
一帧图像

00:14:27.246 --> 00:14:28.346 A:middle
所以你可以看到

00:14:28.346 --> 00:14:29.846 A:middle
从 App 收到停顿的那一刻起

00:14:29.926 --> 00:14:32.036 A:middle
到图像真正投射出来

00:14:32.036 --> 00:14:35.896 A:middle
的那一刻为止 一共历时 25 毫秒

00:14:35.976 --> 00:14:39.556 A:middle
这就是为什么 App 要接收

00:14:39.686 --> 00:14:41.346 A:middle
已经预测到

00:14:41.346 --> 00:14:43.296 A:middle
会在未来发生的停顿

00:14:43.546 --> 00:14:45.116 A:middle
到了发射光子的那一刻

00:14:45.116 --> 00:14:47.806 A:middle
就可以使被渲染的

00:14:47.896 --> 00:14:49.946 A:middle
图像可以和用户的停顿相匹配

00:14:50.066 --> 00:14:54.336 A:middle
而这一连串

00:14:54.416 --> 00:14:56.046 A:middle
与上一帧以及下一帧

00:14:56.046 --> 00:14:58.486 A:middle
重叠的事件创建了我们的

00:14:58.516 --> 00:14:59.436 A:middle
帧基础图

00:14:59.436 --> 00:15:02.096 A:middle
如你所见

00:14:59.436 --> 00:15:02.096 A:middle
如你所见

00:15:02.096 --> 00:15:04.966 A:middle
在单线程 App 中 图形处理器

00:15:04.966 --> 00:15:06.446 A:middle
在大部分时间中都是空闲的

00:15:07.826 --> 00:15:08.816 A:middle
那就让我们来看看

00:15:08.816 --> 00:15:10.346 A:middle
是否可以对此做些什么

00:15:11.776 --> 00:15:13.606 A:middle
我们现在切换到了

00:15:13.606 --> 00:15:15.216 A:middle
多线程 App

00:15:15.716 --> 00:15:17.746 A:middle
它将视觉环境的模拟

00:15:17.776 --> 00:15:20.416 A:middle
和针对图形处理器的编码操作

00:15:20.446 --> 00:15:22.656 A:middle
分离开来

00:15:23.496 --> 00:15:24.996 A:middle
对于这些操作的编码

00:15:24.996 --> 00:15:26.596 A:middle
现在会在独立的

00:15:26.596 --> 00:15:27.356 A:middle
渲染线程中进行

00:15:28.796 --> 00:15:29.766 A:middle
因为我们已将模拟

00:15:29.866 --> 00:15:31.216 A:middle
和编码分离开来

00:15:31.766 --> 00:15:33.596 A:middle
所以对于帧的模拟

00:15:33.696 --> 00:15:36.786 A:middle
可与图形处理器操作

00:15:36.786 --> 00:15:38.636 A:middle
的上一帧编码

00:15:38.636 --> 00:15:39.336 A:middle
同时进行

00:15:40.636 --> 00:15:43.316 A:middle
这意味着编码现在

00:15:43.316 --> 00:15:45.746 A:middle
已经在时间上发生了变化

00:15:45.796 --> 00:15:47.596 A:middle
在我们收到预测的停顿之后

00:15:47.706 --> 00:15:48.656 A:middle
编码会立即开始

00:15:49.216 --> 00:15:50.846 A:middle
这意味着你的 App

00:15:50.846 --> 00:15:52.436 A:middle
现在可以有更多时间

00:15:52.436 --> 00:15:54.736 A:middle
对图形处理器进行编码

00:15:54.736 --> 00:15:56.666 A:middle
并且图形处理器也可以有更多时间

00:15:56.746 --> 00:15:57.406 A:middle
来处理它

00:15:57.406 --> 00:16:00.436 A:middle
这样一来 你的 App 可以拥有更好的

00:15:57.406 --> 00:16:00.436 A:middle
这样一来 你的 App 可以拥有更好的

00:16:00.436 --> 00:16:01.096 A:middle
视觉化效果

00:16:02.856 --> 00:16:04.216 A:middle
但这里有一点要注意

00:16:05.436 --> 00:16:07.386 A:middle
因为现在模拟

00:16:07.386 --> 00:16:09.256 A:middle
会在上一帧就开始

00:16:09.956 --> 00:16:12.196 A:middle
所以需要独立的一组

00:16:12.286 --> 00:16:13.326 A:middle
预测停顿

00:16:14.066 --> 00:16:16.586 A:middle
这一组可以预测到

00:16:16.586 --> 00:16:18.956 A:middle
未来的 56 毫秒

00:16:18.956 --> 00:16:20.276 A:middle
这样就能和针对渲染线程

00:16:20.366 --> 00:16:21.886 A:middle
进行预测的小组相匹配

00:16:22.416 --> 00:16:24.176 A:middle
而且这两组会

00:16:24.206 --> 00:16:25.266 A:middle
和发射光子的时刻相匹配

00:16:27.126 --> 00:16:28.646 A:middle
这张图从中央处理器来看

00:16:28.646 --> 00:16:31.056 A:middle
已经很不错了 正如我们所见

00:16:31.056 --> 00:16:32.276 A:middle
App 在中央处理器中

00:16:32.276 --> 00:16:35.236 A:middle
很好的分配了它的工作 但是

00:16:36.236 --> 00:16:37.566 A:middle
让我们把重点放在图形处理器上

00:16:38.446 --> 00:16:43.596 A:middle
如你所见 我们例子中的 App

00:16:43.596 --> 00:16:46.696 A:middle
现在正在对所有这些图形处理器

00:16:46.696 --> 00:16:48.576 A:middle
所有工作流程进行编码

00:16:48.746 --> 00:16:51.286 A:middle
从而使一帧进入单一的公用缓冲区

00:16:51.286 --> 00:16:54.016 A:middle
因此除非这一公用缓冲区已完成

00:16:54.016 --> 00:16:56.466 A:middle
否则图形处理器就会

00:16:56.466 --> 00:16:57.316 A:middle
处于空闲的等待状态

00:16:58.836 --> 00:17:00.306 A:middle
不过 值得注意的是

00:16:58.836 --> 00:17:00.306 A:middle
不过 值得注意的是

00:17:00.546 --> 00:17:02.676 A:middle
在中央处理器上 对图形处理器的操作

00:17:02.676 --> 00:17:05.336 A:middle
进行编码所花费的时间

00:17:05.586 --> 00:17:06.796 A:middle
比在图形处理器上处理这些操作

00:17:06.796 --> 00:17:08.165 A:middle
所花费的时间要少很多

00:17:08.986 --> 00:17:10.336 A:middle
因此我们可以利用这一事实

00:17:10.336 --> 00:17:13.935 A:middle
并将我们的编码操作

00:17:13.935 --> 00:17:15.656 A:middle
分解成为几个公用缓冲区

00:17:15.656 --> 00:17:17.876 A:middle
而几个公用缓冲区

00:17:17.876 --> 00:17:19.276 A:middle
可以进行快速编码

00:17:19.276 --> 00:17:21.266 A:middle
仅需几步操作而已

00:17:21.776 --> 00:17:23.715 A:middle
并尽快将其提交至

00:17:23.786 --> 00:17:24.336 A:middle
图形处理器

00:17:25.626 --> 00:17:30.426 A:middle
这样一来 我们就能

00:17:30.486 --> 00:17:33.016 A:middle
在图形处理器已经处理帧的同时

00:17:33.016 --> 00:17:34.626 A:middle
进行我们的编码

00:17:35.086 --> 00:17:36.826 A:middle
而且如你所见

00:17:36.826 --> 00:17:39.926 A:middle
在图形处理器进行处理的时候

00:17:40.036 --> 00:17:43.456 A:middle
我们延长了时间

00:17:43.456 --> 00:17:45.216 A:middle
作为结果 这样进一步增加了

00:17:45.216 --> 00:17:46.706 A:middle
你可以在一帧中提交的工作量

00:17:48.156 --> 00:17:49.226 A:middle
现在让我们回到我们的图表

00:17:49.266 --> 00:17:50.826 A:middle
看一下全部放在一起

00:17:50.826 --> 00:17:51.906 A:middle
看起来会如何

00:17:53.446 --> 00:17:55.636 A:middle
如你所见 现在中央处理器

00:17:55.636 --> 00:17:57.766 A:middle
和图形处理器都被完全利用起来了

00:17:58.746 --> 00:18:00.056 A:middle
那么这样的 App 已经

00:17:58.746 --> 00:18:00.056 A:middle
那么这样的 App 已经

00:18:00.056 --> 00:18:01.846 A:middle
为你的 App 提供了

00:18:01.846 --> 00:18:03.966 A:middle
很好的示范

00:18:03.966 --> 00:18:05.446 A:middle
但我们仍有提升的空间

00:18:07.196 --> 00:18:09.396 A:middle
你可能会注意到

00:18:09.506 --> 00:18:11.626 A:middle
在收到预测停顿之前

00:18:11.696 --> 00:18:13.786 A:middle
当对任何种类的图形处理器 进行编码时

00:18:14.306 --> 00:18:16.876 A:middle
渲染线程仍然处于等待状态

00:18:17.566 --> 00:18:19.186 A:middle
但是并非一帧里的所有工作流程

00:18:19.186 --> 00:18:21.486 A:middle
都需要这些停顿

00:18:22.536 --> 00:18:24.766 A:middle
那么让我们进行更加细致的分析

00:18:24.886 --> 00:18:26.086 A:middle
来选择帧的工作负荷

00:18:27.486 --> 00:18:29.956 A:middle
在这里 你可以看到

00:18:30.006 --> 00:18:32.916 A:middle
工作负荷列表 它们可能会在每一帧中被执行

00:18:34.056 --> 00:18:35.656 A:middle
其中一部分在屏幕空间中进行

00:18:35.656 --> 00:18:37.696 A:middle
或者需要了解

00:18:37.696 --> 00:18:39.766 A:middle
与为了渲染帧所产生的停顿

00:18:39.766 --> 00:18:40.736 A:middle
有关的总体信息

00:18:41.496 --> 00:18:42.726 A:middle
我们将这样的工作负荷

00:18:42.846 --> 00:18:44.116 A:middle
称为停顿依赖性工作负荷

00:18:44.986 --> 00:18:46.506 A:middle
与此同时

00:18:46.506 --> 00:18:48.746 A:middle
还有一般性的

00:18:48.746 --> 00:18:50.056 A:middle
无需与停顿有关的信息

00:18:50.096 --> 00:18:51.996 A:middle
就能立即执行的工作负荷

00:18:53.096 --> 00:18:54.886 A:middle
我们将这些工作负荷称为

00:18:54.886 --> 00:18:55.886 A:middle
非停顿依赖性工作负荷

00:18:56.496 --> 00:18:59.306 A:middle
那么现在 我们的 App

00:18:59.306 --> 00:19:01.346 A:middle
正在等待停顿

00:18:59.306 --> 00:19:01.346 A:middle
正在等待停顿

00:19:01.346 --> 00:19:02.996 A:middle
以对图形处理器的任何工作进行编码

00:19:03.626 --> 00:19:05.336 A:middle
但如果我们将这些工作负荷平分开来

00:19:05.336 --> 00:19:08.636 A:middle
我们就能立即

00:19:08.636 --> 00:19:09.676 A:middle
对非停顿依赖性工作负荷编码

00:19:09.766 --> 00:19:11.936 A:middle
然后等待停顿

00:19:12.026 --> 00:19:15.156 A:middle
以继续对停顿依赖性工作负荷编码

00:19:16.126 --> 00:19:19.456 A:middle
在这张幻灯片中 我们已经

00:19:19.456 --> 00:19:21.076 A:middle
将非停顿依赖性工作负荷

00:19:21.076 --> 00:19:23.006 A:middle
与停顿依赖性工作负荷

00:19:23.036 --> 00:19:23.346 A:middle
区分来开

00:19:24.516 --> 00:19:26.096 A:middle
非停顿依赖性工作负荷

00:19:26.096 --> 00:19:27.346 A:middle
现在已经在公用缓冲区

00:19:27.496 --> 00:19:29.096 A:middle
被编码 如果将它和后面的停顿依赖性

00:19:29.446 --> 00:19:31.066 A:middle
工作负荷比较的话

00:19:31.276 --> 00:19:32.746 A:middle
它被标记地

00:19:32.746 --> 00:19:33.446 A:middle
要更暗一些

00:19:34.336 --> 00:19:35.666 A:middle
因为停顿依赖性工作负荷

00:19:35.666 --> 00:19:36.886 A:middle
可以被立即编码

00:19:36.886 --> 00:19:39.146 A:middle
所以我们就会

00:19:39.146 --> 00:19:39.376 A:middle
采取如下操作

00:19:39.966 --> 00:19:41.526 A:middle
我们会在

00:19:41.636 --> 00:19:42.796 A:middle
上一帧工作负荷编码完成后

00:19:42.796 --> 00:19:43.286 A:middle
立即对其编码

00:19:44.766 --> 00:19:46.866 A:middle
这给了你的中央处理器更多时间

00:19:46.866 --> 00:19:49.246 A:middle
以对图形处理器工作进行编码

00:19:49.416 --> 00:19:51.646 A:middle
更重要的是 这确保了

00:19:51.646 --> 00:19:54.196 A:middle
这一图形处理器工作

00:19:54.196 --> 00:19:56.556 A:middle
已在图形处理器上等待被执行

00:19:56.556 --> 00:19:59.336 A:middle
因此图形处理器就没有

00:19:59.336 --> 00:20:00.576 A:middle
任何空闲时间

00:19:59.336 --> 00:20:00.576 A:middle
任何空闲时间

00:20:00.636 --> 00:20:01.846 A:middle
只要上一帧完成之后

00:20:01.846 --> 00:20:04.086 A:middle
图形处理器就会立即开始

00:20:04.626 --> 00:20:06.766 A:middle
下一帧处理

00:20:06.896 --> 00:20:09.376 A:middle
最后一个小节就是

00:20:09.376 --> 00:20:11.306 A:middle
多图形处理器工作负荷的分配

00:20:13.226 --> 00:20:15.666 A:middle
我们可以在多个图形处理器之间

00:20:15.666 --> 00:20:16.386 A:middle
分配工作负荷

00:20:16.386 --> 00:20:19.226 A:middle
当前的 Mac Book Pro 目前共有两个图形处理器

00:20:19.306 --> 00:20:21.166 A:middle
虽然它们具有

00:20:21.166 --> 00:20:22.056 A:middle
不同的性能特点

00:20:22.116 --> 00:20:23.616 A:middle
但是我们可以

00:20:23.616 --> 00:20:25.366 A:middle
畅通无阻地使用它们

00:20:26.036 --> 00:20:27.926 A:middle
类似地 如果每个图形处理器相互连接起来

00:20:27.986 --> 00:20:29.906 A:middle
那么 App 就能用它

00:20:29.906 --> 00:20:31.756 A:middle
对头戴式设备进行渲染

00:20:32.096 --> 00:20:34.866 A:middle
并同时使用 Mac 的主图形处理器

00:20:34.896 --> 00:20:35.936 A:middle
对一些工作进行分流

00:20:39.066 --> 00:20:40.516 A:middle
所以我们将

00:20:40.666 --> 00:20:43.286 A:middle
停顿依赖性工作分离出来

00:20:43.566 --> 00:20:45.256 A:middle
并将它移动至次图形处理器上

00:20:45.796 --> 00:20:48.436 A:middle
我们这样做是因为这些工作

00:20:48.436 --> 00:20:52.046 A:middle
在很久之前的帧中就已经

00:20:52.046 --> 00:20:53.576 A:middle
完成编码 而且现在

00:20:53.666 --> 00:20:55.866 A:middle
停顿依赖性工作负荷

00:20:55.866 --> 00:20:57.516 A:middle
在执行上一帧

00:20:57.616 --> 00:20:59.746 A:middle
停顿依赖性工作负荷的同时 被执行

00:21:00.196 --> 00:21:01.706 A:middle
因此 我们进一步

00:21:01.706 --> 00:21:03.596 A:middle
增加了你在帧方面拥有的

00:21:03.676 --> 00:21:04.916 A:middle
图形处理器时间量

00:21:07.546 --> 00:21:09.856 A:middle
但是 通过将这一工作分给

00:21:09.856 --> 00:21:13.146 A:middle
多个图形处理器 我们现在到达了

00:21:13.256 --> 00:21:14.926 A:middle
这么一种情况 我们需要一种方式

00:21:14.926 --> 00:21:16.886 A:middle
来将这些工作负荷

00:21:16.886 --> 00:21:17.446 A:middle
同步起来

00:21:22.676 --> 00:21:24.426 A:middle
所以我们今天要介绍新的

00:21:24.426 --> 00:21:26.006 A:middle
同步参数

00:21:26.066 --> 00:21:28.086 A:middle
来处理这样的情况

00:21:28.816 --> 00:21:31.196 A:middle
MTL Event 现在可以用于

00:21:31.196 --> 00:21:33.616 A:middle
在不同 Metal 线索之间

00:21:33.616 --> 00:21:35.566 A:middle
同步单个图形处理器范围内的

00:21:35.626 --> 00:21:38.826 A:middle
图形处理器工作 而 MTL Shared Event

00:21:39.276 --> 00:21:41.436 A:middle
拓展了这一功能

00:21:41.436 --> 00:21:42.886 A:middle
使其可以同步

00:21:42.886 --> 00:21:44.816 A:middle
不同图形处理器之间

00:21:44.986 --> 00:21:46.796 A:middle
甚至不同进程之间的工作负荷

00:21:49.136 --> 00:21:50.996 A:middle
那么在这里 我们来看看这个

00:21:51.106 --> 00:21:52.426 A:middle
简单的代码示例

00:21:53.546 --> 00:21:55.406 A:middle
我们的 Mac 拥有

00:21:55.406 --> 00:21:57.486 A:middle
外置图形处理器 它通过 Thunderbolt 3 接口

00:21:57.486 --> 00:21:58.166 A:middle
进行连接

00:21:58.266 --> 00:22:00.936 A:middle
这一外置图形处理器将成为我们的

00:21:58.266 --> 00:22:00.936 A:middle
这一外置图形处理器将成为我们的

00:22:00.936 --> 00:22:04.396 A:middle
主图形处理器 用于驱动头戴式设备

00:22:04.396 --> 00:22:06.576 A:middle
这样我们就能使用 Mac 中

00:22:06.576 --> 00:22:08.676 A:middle
已有的图形处理器作为辅助的

00:22:08.676 --> 00:22:09.136 A:middle
次图形处理器

00:22:10.496 --> 00:22:12.766 A:middle
然后我们会使用共享事件来

00:22:12.766 --> 00:22:16.896 A:middle
同步两个图形处理器中的

00:22:18.486 --> 00:22:18.716 A:middle
工作负荷

00:22:19.206 --> 00:22:21.816 A:middle
事件的初始值为 0

00:22:21.816 --> 00:22:22.996 A:middle
因此有必要

00:22:22.996 --> 00:22:25.526 A:middle
从 1 开始启动同步计数器

00:22:26.176 --> 00:22:27.516 A:middle
这是因为当我们

00:22:27.516 --> 00:22:30.096 A:middle
在初始化事件中等待之时

00:22:30.276 --> 00:22:32.476 A:middle
如果事件的计数器显示为 0

00:22:32.476 --> 00:22:34.696 A:middle
事件就会立刻恢复原状

00:22:34.696 --> 00:22:35.976 A:middle
所以就无法实现同步

00:22:37.786 --> 00:22:39.276 A:middle
那么我们的渲染线程现在

00:22:39.276 --> 00:22:41.826 A:middle
立即开始了针对辅助图形处理器

00:22:41.826 --> 00:22:43.836 A:middle
的编码工作

00:22:44.536 --> 00:22:46.426 A:middle
它会对停顿依赖性工作

00:22:46.426 --> 00:22:48.796 A:middle
进行编码 这会发生在我们的

00:22:48.796 --> 00:22:50.996 A:middle
次图形处理器上

00:22:51.026 --> 00:22:53.426 A:middle
一旦这一工作完成

00:22:53.426 --> 00:22:55.496 A:middle
结果将会存储在

00:22:55.646 --> 00:22:56.156 A:middle
锁定存储器之中

00:22:56.796 --> 00:22:59.146 A:middle
这就是为什么我们采用

00:22:59.146 --> 00:23:01.396 A:middle
编码简单操作

00:22:59.146 --> 00:23:01.396 A:middle
编码简单操作

00:23:01.396 --> 00:23:03.736 A:middle
将这些结果传输到

00:23:03.736 --> 00:23:05.806 A:middle
对两个图形处理器都可见

00:23:05.806 --> 00:23:06.676 A:middle
的系统内存中

00:23:07.426 --> 00:23:08.786 A:middle
一旦传输完成

00:23:08.786 --> 00:23:12.436 A:middle
我们的次图形处理器就能

00:23:12.906 --> 00:23:15.216 A:middle
安全地向我们的共享事件发出信号

00:23:15.866 --> 00:23:18.256 A:middle
这一信号会告诉外置图形处理器

00:23:18.316 --> 00:23:20.236 A:middle
现在接受这些结果是安全的

00:23:21.496 --> 00:23:23.536 A:middle
所以我们的渲染线程

00:23:23.536 --> 00:23:24.576 A:middle
执行这一些

00:23:24.576 --> 00:23:26.886 A:middle
共用缓冲区 并且辅助图形处理器

00:23:26.916 --> 00:23:29.246 A:middle
已经在处理这一工作

00:23:30.016 --> 00:23:32.336 A:middle
与此同时 我们可以开始

00:23:32.336 --> 00:23:34.086 A:middle
对驱动头戴式设备的

00:23:34.166 --> 00:23:36.486 A:middle
主图形处理器的命令缓冲区进行编码

00:23:37.676 --> 00:23:39.356 A:middle
在这一命令缓冲区中

00:23:39.356 --> 00:23:41.626 A:middle
我们一开始会等待我们的

00:23:41.626 --> 00:23:43.446 A:middle
共享事件 确保数据存储在

00:23:43.446 --> 00:23:45.516 A:middle
在系统内存里

00:23:45.516 --> 00:23:47.426 A:middle
只要它在那里  并且共享事件

00:23:47.426 --> 00:23:50.066 A:middle
收到信号 那么我们可以执行一个

00:23:50.066 --> 00:23:51.306 A:middle
简单操作

00:23:51.306 --> 00:23:52.516 A:middle
它会通过 Thunderbolt 3 接口

00:23:52.516 --> 00:23:54.826 A:middle
将这一数据传回

00:23:55.096 --> 00:23:57.856 A:middle
我们的外部图形处理器中

00:23:57.956 --> 00:23:59.856 A:middle
一旦传输完成

00:23:59.856 --> 00:24:01.936 A:middle
执行停顿依赖性工作就会变得安全

00:23:59.856 --> 00:24:01.936 A:middle
执行停顿依赖性工作就会变得安全

00:24:01.966 --> 00:24:05.246 A:middle
因此第二个命令缓冲区

00:24:05.556 --> 00:24:08.206 A:middle
就会发出封锁事件的信号

00:24:08.356 --> 00:24:10.166 A:middle
让停顿依赖性工作知道

00:24:10.166 --> 00:24:11.546 A:middle
它可以开始执行操作了

00:24:12.366 --> 00:24:14.346 A:middle
在将这两个命令缓冲区

00:24:14.416 --> 00:24:15.776 A:middle
编码并提交之后

00:24:16.386 --> 00:24:18.436 A:middle
渲染线程可以向往常一样继续

00:24:18.436 --> 00:24:20.566 A:middle
等待停顿

00:24:20.816 --> 00:24:21.826 A:middle
并在之后

00:24:21.916 --> 00:24:26.076 A:middle
对停顿依赖性工作进行编码

00:24:26.296 --> 00:24:28.296 A:middle
那么现在我们就有了一个

00:24:28.296 --> 00:24:30.306 A:middle
同步不同图形处理器间

00:24:30.306 --> 00:24:31.146 A:middle
不同工作负荷的机制

00:24:31.146 --> 00:24:35.156 A:middle
但是你可以看到

00:24:35.156 --> 00:24:37.426 A:middle
我们的次图形处理器仍然

00:24:37.426 --> 00:24:38.176 A:middle
有些空闲

00:24:38.226 --> 00:24:40.506 A:middle
这是因为在这个例子里

00:24:40.926 --> 00:24:43.886 A:middle
我们想要设法完成

00:24:44.316 --> 00:24:45.846 A:middle
停顿依赖性工作负荷

00:24:45.846 --> 00:24:47.396 A:middle
即那些拥有依赖于

00:24:47.396 --> 00:24:48.856 A:middle
停顿依赖性的工作

00:24:49.346 --> 00:24:49.786 A:middle
抱歉

00:24:50.796 --> 00:24:52.156 A:middle
不过 当然也有一些

00:24:52.206 --> 00:24:53.396 A:middle
工作负荷不具

00:24:53.396 --> 00:24:55.086 A:middle
依赖性 它们可以

00:24:55.216 --> 00:24:57.496 A:middle
在较低频率中发生

00:24:57.496 --> 00:24:58.806 A:middle
也就是头戴式设备的频率

00:24:59.576 --> 00:25:01.076 A:middle
这样的工作负荷

00:24:59.576 --> 00:25:01.076 A:middle
这样的工作负荷

00:25:01.196 --> 00:25:03.456 A:middle
比如可以是

00:25:03.456 --> 00:25:05.076 A:middle
基于物理的精准

00:25:05.076 --> 00:25:07.076 A:middle
异常值的模拟

00:25:07.766 --> 00:25:11.236 A:middle
或者需要大量更新时间

00:25:11.976 --> 00:25:12.826 A:middle
的任何东西

00:25:13.326 --> 00:25:15.846 A:middle
这样的工作负荷可以发生在

00:25:15.846 --> 00:25:17.316 A:middle
背景中 完全

00:25:17.316 --> 00:25:18.846 A:middle
和渲染画面不同步

00:25:18.846 --> 00:25:20.596 A:middle
而且在它每次

00:25:20.596 --> 00:25:23.336 A:middle
准备完成后 它的结果就会被发送至

00:25:23.456 --> 00:25:24.536 A:middle
主图形处理器

00:25:25.316 --> 00:25:27.296 A:middle
这里灰色的标记

00:25:27.626 --> 00:25:28.996 A:middle
是用来表示它

00:25:28.996 --> 00:25:31.036 A:middle
和任何特定一帧无关

00:25:32.516 --> 00:25:33.616 A:middle
那么 当然会有

00:25:33.616 --> 00:25:36.016 A:middle
具有不同性能特点的

00:25:36.066 --> 00:25:38.086 A:middle
不同图形处理器 而且

00:25:38.086 --> 00:25:38.976 A:middle
它们会具有不同

00:25:38.976 --> 00:25:40.146 A:middle
带宽的连接

00:25:40.606 --> 00:25:42.966 A:middle
而且你的 App 将会

00:25:43.086 --> 00:25:44.976 A:middle
在一帧中拥有不同的工作负荷

00:25:44.976 --> 00:25:47.876 A:middle
它们之间分别具有不同的关系

00:25:48.986 --> 00:25:51.676 A:middle
因此你需要设计出一种方式

00:25:51.786 --> 00:25:53.446 A:middle
让你能分配这一工作负荷

00:25:53.446 --> 00:25:56.406 A:middle
但是说了这么多

00:25:56.406 --> 00:25:58.166 A:middle
开始考虑

00:25:58.166 --> 00:26:00.076 A:middle
这一图形处理器工作负荷的分配

00:25:58.166 --> 00:26:00.076 A:middle
这一图形处理器工作负荷的分配

00:26:00.116 --> 00:26:02.106 A:middle
非常重要

00:26:02.106 --> 00:26:04.026 A:middle
因为多图形处理器配置如今

00:26:04.136 --> 00:26:05.956 A:middle
在 Apple 应用平台上十分常见

00:26:07.956 --> 00:26:10.266 A:middle
那么让我们来总结一下

00:26:10.266 --> 00:26:11.326 A:middle
我们在这一节中学到的

00:26:11.416 --> 00:26:11.866 A:middle
所有内容

00:26:12.496 --> 00:26:13.426 A:middle
我们展示了多线程 App

00:26:13.426 --> 00:26:15.986 A:middle
来充分利用

00:26:16.076 --> 00:26:17.396 A:middle
所有的中央处理器代码

00:26:17.466 --> 00:26:20.556 A:middle
并分离了命令缓冲区

00:26:20.786 --> 00:26:22.666 A:middle
确保图形处理器没有处于空闲状态

00:26:23.756 --> 00:26:25.776 A:middle
在这一过程中 在可能的条件下

00:26:26.066 --> 00:26:26.916 A:middle
我们尽量将

00:26:27.046 --> 00:26:28.396 A:middle
非停顿依赖性工作负荷

00:26:28.466 --> 00:26:31.036 A:middle
与停顿依赖性工作负荷划分开来

00:26:31.036 --> 00:26:32.946 A:middle
从而尽快对这一工作进行编码

00:26:32.946 --> 00:26:35.746 A:middle
除此之外

00:26:36.206 --> 00:26:38.086 A:middle
我们还根据更新频率划分工作负荷

00:26:38.086 --> 00:26:41.126 A:middle
所以如果你的 App

00:26:41.126 --> 00:26:42.586 A:middle
会在多图形处理器配置下执行

00:26:42.586 --> 00:26:44.486 A:middle
你可以轻松地

00:26:44.486 --> 00:26:47.576 A:middle
在那些图形处理器中对其进行分配

00:26:48.126 --> 00:26:50.726 A:middle
而且在这一过程中

00:26:51.136 --> 00:26:53.296 A:middle
确保你驱动各个图形处理器时

00:26:53.296 --> 00:26:55.566 A:middle
使用了独立的渲染线程

00:26:55.566 --> 00:26:57.446 A:middle
从而确保它们在执行时

00:26:57.446 --> 00:26:58.206 A:middle
是不同步的

00:26:59.116 --> 00:27:01.766 A:middle
现在 你来到了降低填充率的部分

00:26:59.116 --> 00:27:01.766 A:middle
现在 你来到了降低填充率的部分

00:27:03.186 --> 00:27:04.986 A:middle
Vive Pro

00:27:05.046 --> 00:27:07.466 A:middle
为 VR App 的开发者带来了新挑战

00:27:08.026 --> 00:27:09.516 A:middle
为了更好地认识到

00:27:09.516 --> 00:27:11.186 A:middle
问题的严重性 我们将比较

00:27:11.186 --> 00:27:12.676 A:middle
不同的媒介填充率

00:27:12.676 --> 00:27:15.756 A:middle
例如

00:27:15.756 --> 00:27:18.556 A:middle
按默认缩放比例

00:27:18.616 --> 00:27:21.966 A:middle
对 Vive 头戴式设备进行渲染的 App

00:27:22.266 --> 00:27:27.776 A:middle
每秒可产生 4.36 亿像素

00:27:27.776 --> 00:27:29.766 A:middle
而对于目前便宜的高清屏幕相比于

00:27:30.236 --> 00:27:32.776 A:middle
最先进驱动的屏幕

00:27:32.776 --> 00:27:39.546 A:middle
拥有每秒 4.75 亿像素

00:27:39.606 --> 00:27:40.156 A:middle
的填充率

00:27:40.916 --> 00:27:43.806 A:middle
这些数据已经过于大了

00:27:44.136 --> 00:27:45.416 A:middle
以至于游戏开发者

00:27:45.476 --> 00:27:47.486 A:middle
做出了不同的改进 来降低这一填充率

00:27:48.246 --> 00:27:49.856 A:middle
接下来让我们看看 Vive Pro

00:27:49.856 --> 00:27:51.226 A:middle
在这些数据上的对比情况

00:27:53.046 --> 00:27:55.116 A:middle
Vive Pro 拥有正常的填充率

00:27:55.116 --> 00:27:58.676 A:middle
为每秒 7.75 亿像素

00:27:59.146 --> 00:28:00.826 A:middle
如果你增加

00:27:59.146 --> 00:28:00.826 A:middle
如果你增加

00:28:00.826 --> 00:28:02.976 A:middle
4 倍多样本抗锯齿

00:28:03.206 --> 00:28:05.186 A:middle
或者更大的缩放率

00:28:05.186 --> 00:28:06.486 A:middle
这一数据就会变得更大

00:28:06.486 --> 00:28:09.786 A:middle
这就是降低填充率

00:28:09.786 --> 00:28:11.206 A:middle
为何如此重要

00:28:12.146 --> 00:28:13.406 A:middle
现在已经有多种技术

00:28:13.406 --> 00:28:14.956 A:middle
而且每一天都会

00:28:14.956 --> 00:28:15.826 A:middle
产生新的技术

00:28:16.316 --> 00:28:19.046 A:middle
所以我建议你们 把它们都尝试一遍

00:28:19.046 --> 00:28:22.106 A:middle
但是今天我们

00:28:22.106 --> 00:28:24.506 A:middle
只关注其中的一小部分 因为它们

00:28:24.506 --> 00:28:27.746 A:middle
执行起来最为简单

00:28:27.746 --> 00:28:29.836 A:middle
并能带来不错的性能提升

00:28:30.356 --> 00:28:31.986 A:middle
那么我们先讲讲裁剪

00:28:31.986 --> 00:28:33.056 A:middle
不可见的像素

00:28:33.946 --> 00:28:36.186 A:middle
这里 你可以看到渲染的图像

00:28:36.186 --> 00:28:37.076 A:middle
它针对的是左眼

00:28:38.526 --> 00:28:40.566 A:middle
但是因为

00:28:40.566 --> 00:28:44.766 A:middle
镜头的性质 大约 20% 的

00:28:44.896 --> 00:28:47.646 A:middle
像素会在生成器

00:28:47.726 --> 00:28:50.156 A:middle
执行失真校正后丢失

00:28:50.786 --> 00:28:52.166 A:middle
在右侧 你可以看到

00:28:52.216 --> 00:28:53.796 A:middle
将在通过镜头之前

00:28:53.796 --> 00:28:55.746 A:middle
展示在头戴式设备面板上

00:28:55.746 --> 00:28:56.706 A:middle
的图像

00:28:58.746 --> 00:29:00.896 A:middle
所以 最简单的

00:28:58.746 --> 00:29:00.896 A:middle
所以 最简单的

00:29:00.896 --> 00:29:03.836 A:middle
降低填充率的方式就是防止我们的

00:29:03.836 --> 00:29:05.426 A:middle
App 渲染那些

00:29:05.486 --> 00:29:07.066 A:middle
完全不可见的像素

00:29:07.066 --> 00:29:09.616 A:middle
你可以

00:29:09.616 --> 00:29:12.176 A:middle
通过使用 SteamVR Stencil Mask

00:29:12.176 --> 00:29:12.946 A:middle
轻松实现

00:29:14.416 --> 00:29:18.836 A:middle
那么我们刚刚降低了百分之 20 的

00:29:18.836 --> 00:29:20.406 A:middle
填充率 借助了这一

00:29:20.406 --> 00:29:22.626 A:middle
简单的遮罩 并将我们 Vive

00:29:22.966 --> 00:29:26.806 A:middle
Pro 的填充率降至 6.2 亿像素

00:29:29.286 --> 00:29:32.236 A:middle
现在我们来分析一下

00:29:32.276 --> 00:29:33.776 A:middle
执行这一镜头失真校正

00:29:33.776 --> 00:29:35.326 A:middle
的更多细节

00:29:36.336 --> 00:29:40.836 A:middle
我们可以将我们的视场

00:29:40.836 --> 00:29:42.936 A:middle
分为九个区域

00:29:43.886 --> 00:29:45.986 A:middle
中心区域的视野

00:29:45.986 --> 00:29:48.396 A:middle
水平为 80 度

00:29:48.456 --> 00:29:51.276 A:middle
垂直为 80 度

00:29:51.276 --> 00:29:53.206 A:middle
周围区域

00:29:53.266 --> 00:29:54.396 A:middle
位于边缘和角落里

00:29:55.306 --> 00:29:57.596 A:middle
我们为它们上了色

00:29:57.596 --> 00:29:58.956 A:middle
从而可以更好地看到

00:29:58.956 --> 00:30:00.726 A:middle
它们对最终图像的影响

00:29:58.956 --> 00:30:00.726 A:middle
它们对最终图像的影响

00:30:01.306 --> 00:30:05.196 A:middle
正如你所见

00:30:05.196 --> 00:30:08.236 A:middle
角落几乎完全不可见

00:30:08.506 --> 00:30:11.786 A:middle
和原来的相比

00:30:11.786 --> 00:30:13.596 A:middle
边缘对图像的影响

00:30:13.626 --> 00:30:14.696 A:middle
会更小

00:30:15.486 --> 00:30:17.996 A:middle
事实上 如果你

00:30:17.996 --> 00:30:19.996 A:middle
在头戴式设备中看这幅图像

00:30:20.066 --> 00:30:22.616 A:middle
你是无法直接看到红色

00:30:22.726 --> 00:30:23.346 A:middle
区域的

00:30:24.126 --> 00:30:25.846 A:middle
可以看到这些图像的唯一方式

00:30:25.846 --> 00:30:27.366 A:middle
就是使用你的周边视觉

00:30:28.886 --> 00:30:31.666 A:middle
这就给了我们很大的启发

00:30:33.306 --> 00:30:35.186 A:middle
我们可以通过较低的填充率

00:30:35.236 --> 00:30:37.626 A:middle
渲染这些边角区域

00:30:37.626 --> 00:30:40.086 A:middle
因为不管怎么说

00:30:40.086 --> 00:30:41.046 A:middle
它们几乎不可见

00:30:42.276 --> 00:30:45.056 A:middle
我们渲染了中心区域

00:30:45.056 --> 00:30:45.956 A:middle
如同之前一样

00:30:47.296 --> 00:30:49.046 A:middle
但之后在渲染垂直边缘时

00:30:49.046 --> 00:30:51.856 A:middle
我们会将宽度减半

00:30:51.906 --> 00:30:53.946 A:middle
对于水平区域

00:30:53.976 --> 00:30:54.686 A:middle
则将高度减半

00:30:54.686 --> 00:30:56.966 A:middle
最后 在渲染角落区域时

00:30:57.026 --> 00:31:00.306 A:middle
我们会将分辨率降至

00:30:57.026 --> 00:31:00.306 A:middle
我们会将分辨率降至

00:31:00.306 --> 00:31:01.066 A:middle
四分之一

00:31:03.076 --> 00:31:05.166 A:middle
当我们完成昂贵的

00:31:05.246 --> 00:31:06.976 A:middle
渲染通道之后 我们会

00:31:06.976 --> 00:31:09.606 A:middle
执行廉价的放大通道

00:31:09.606 --> 00:31:11.416 A:middle
让这些区域

00:31:11.646 --> 00:31:13.276 A:middle
拉伸至

00:31:13.276 --> 00:31:15.356 A:middle
需要提交给生成器的分辨率

00:31:16.386 --> 00:31:18.186 A:middle
那么你可能会好奇

00:31:18.226 --> 00:31:20.166 A:middle
这样我们可以获得多少提升

00:31:21.316 --> 00:31:23.576 A:middle
对于 80x80 度

00:31:23.576 --> 00:31:25.546 A:middle
的中央区域 我们将我们的

00:31:25.546 --> 00:31:27.556 A:middle
填充率一下子降到了

00:31:27.556 --> 00:31:30.586 A:middle
每秒 4.91 亿像素

00:31:31.736 --> 00:31:32.936 A:middle
但是你应该记得我们刚刚

00:31:32.996 --> 00:31:34.666 A:middle
提到了裁剪不可见像素

00:31:34.666 --> 00:31:36.866 A:middle
所以让我们

00:31:36.946 --> 00:31:38.036 A:middle
将这两个技术结合起来

00:31:40.016 --> 00:31:42.456 A:middle
通过将像素裁剪

00:31:42.456 --> 00:31:44.016 A:middle
和多分辨率变化结合起来

00:31:44.016 --> 00:31:45.696 A:middle
你甚至可以进一步将填充率

00:31:45.696 --> 00:31:48.796 A:middle
降至每秒 4.56 亿像素

00:31:48.796 --> 00:31:50.996 A:middle
这并不是一个随机数字

00:31:51.696 --> 00:31:54.196 A:middle
事实上这是

00:31:54.196 --> 00:31:57.456 A:middle
Vive 头戴式设备的默认填充率

00:31:57.456 --> 00:31:59.176 A:middle
所以仅仅通过使用这两项优化技术

00:31:59.176 --> 00:32:01.246 A:middle
你的 App 就可以

00:31:59.176 --> 00:32:01.246 A:middle
你的 App 就可以

00:32:01.246 --> 00:32:03.536 A:middle
使用与渲染 Vive 头戴式设备时

00:32:03.536 --> 00:32:05.796 A:middle
所使用的相同图形处理器

00:32:05.796 --> 00:32:08.386 A:middle
而得到更高的分辨率

00:32:08.386 --> 00:32:09.796 A:middle
对 Vive Pro 进行渲染

00:32:10.816 --> 00:32:12.486 A:middle
当然 你也可以

00:32:12.556 --> 00:32:13.626 A:middle
在对 Vive 进行渲染时

00:32:13.626 --> 00:32:15.346 A:middle
使用这些技术

00:32:15.346 --> 00:32:17.306 A:middle
这能让你 App 的视觉化效果

00:32:17.566 --> 00:32:19.386 A:middle
更加突出

00:32:20.106 --> 00:32:21.046 A:middle
更加美观

00:32:21.626 --> 00:32:25.306 A:middle
这里要提醒一下

00:32:25.676 --> 00:32:27.166 A:middle
多分辨率变化

00:32:27.296 --> 00:32:30.356 A:middle
需要一些新的渲染通道

00:32:30.356 --> 00:32:34.006 A:middle
所以它会在几何管线上

00:32:34.126 --> 00:32:36.356 A:middle
增加你的工作负荷

00:32:36.356 --> 00:32:38.466 A:middle
但你可以轻松缓解这一问题

00:32:38.516 --> 00:32:39.996 A:middle
只需将你的中心区域

00:32:39.996 --> 00:32:41.746 A:middle
降低几度

00:32:42.556 --> 00:32:44.036 A:middle
这里 仅将我们的中心视野

00:32:44.036 --> 00:32:45.996 A:middle
降低了 10 度

00:32:46.486 --> 00:32:48.026 A:middle
我们就将填充率一下子降低到了

00:32:48.026 --> 00:32:50.826 A:middle
每秒 3.82 亿像素

00:32:51.546 --> 00:32:53.956 A:middle
而且如果你的几何图形的工作负荷

00:32:53.956 --> 00:32:56.606 A:middle
非常高 你可以更进一步

00:32:56.696 --> 00:32:59.146 A:middle
尝试更低的填充率

00:32:59.146 --> 00:33:02.116 A:middle
更低的区域

00:32:59.146 --> 00:33:02.116 A:middle
更低的区域

00:33:02.446 --> 00:33:03.966 A:middle
这会将填充率降得更低

00:33:04.846 --> 00:33:07.206 A:middle
对于 55x55 度的

00:33:07.206 --> 00:33:10.446 A:middle
中心区域 你百分之 80 的

00:33:11.266 --> 00:33:12.536 A:middle
眼部动作仍然会

00:33:12.536 --> 00:33:15.546 A:middle
位于这一区域之中 但是

00:33:15.546 --> 00:33:17.426 A:middle
我们将我们的填充率

00:33:17.426 --> 00:33:20.016 A:middle
减少了一大半

00:33:20.146 --> 00:33:23.476 A:middle
降至每秒 3.6 亿像素

00:33:23.696 --> 00:33:25.116 A:middle
当然 还有其他

00:33:25.116 --> 00:33:26.316 A:middle
方法可以实现

00:33:26.366 --> 00:33:29.446 A:middle
多分辨率变化

00:33:30.466 --> 00:33:32.326 A:middle
而且你会从中获得

00:33:32.416 --> 00:33:34.626 A:middle
不同的性能提升

00:33:34.816 --> 00:33:36.366 A:middle
所以我建议大家

00:33:36.366 --> 00:33:37.966 A:middle
尝试这一技术

00:33:38.006 --> 00:33:39.446 A:middle
看看什么最适合你

00:33:41.546 --> 00:33:42.926 A:middle
下面让我们来总结一下

00:33:42.926 --> 00:33:46.986 A:middle
我们在本次会议中 学到的所有内容

00:33:47.086 --> 00:33:48.676 A:middle
我们刚刚公布了针对 Vive Pro 头戴式设备

00:33:48.716 --> 00:33:50.446 A:middle
的即插即用支持

00:33:50.486 --> 00:33:53.526 A:middle
并且介绍了

00:33:53.526 --> 00:33:55.256 A:middle
Metal 2 的新特性 它们能使你

00:33:55.256 --> 00:33:57.306 A:middle
开发更多的

00:33:57.306 --> 00:33:58.916 A:middle
先进的 VR App

00:33:59.726 --> 00:34:01.486 A:middle
然后我建议大家

00:33:59.726 --> 00:34:01.486 A:middle
然后我建议大家

00:34:01.486 --> 00:34:03.246 A:middle
利用多图形处理器配置

00:34:03.246 --> 00:34:05.006 A:middle
因为它们现在

00:34:05.006 --> 00:34:07.416 A:middle
在 Apple 平台上变得越来越常见

00:34:08.076 --> 00:34:12.136 A:middle
你可以通过这个链接

00:34:12.136 --> 00:34:14.106 A:middle
了解有关本次会议的更多内容

00:34:14.106 --> 00:34:16.335 A:middle
我想邀请大家

00:34:16.525 --> 00:34:17.606 A:middle
在 Metal 4 VR 实验室里

00:34:17.606 --> 00:34:19.616 A:middle
和我以及我的同事见面

00:34:19.616 --> 00:34:21.766 A:middle
时间就定在今天

00:34:21.766 --> 00:34:24.136 A:middle
中午 12 点 地点在 6 号

00:34:24.136 --> 00:34:24.536 A:middle
科技实验室

00:34:24.626 --> 00:34:26.976 A:middle
非常感谢大家

00:34:27.516 --> 00:34:30.500 A:middle
[ 掌声 ]
