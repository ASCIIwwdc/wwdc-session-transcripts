WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:27.516 --> 00:00:34.116 A:middle
[ 掌声 ]

00:00:34.616 --> 00:00:36.876 A:middle
大家好 我是 Ben

00:00:37.016 --> 00:00:38.306 A:middle
我是 Swift 标准程序库的员工

00:00:38.386 --> 00:00:40.816 A:middle
今天我要和来自编译团队的同事 Doug 一起

00:00:40.946 --> 00:00:43.136 A:middle
跟大家分享关于 Swift 通用型的信息

00:00:43.726 --> 00:00:48.056 A:middle
Swift 最近发布的版本添加了一些重要的新特性

00:00:48.826 --> 00:00:52.446 A:middle
包括条件一致性和递归协议约束条件

00:00:53.536 --> 00:00:58.506 A:middle
其实在 Swift 发布的每个版本中
我们都会改善通用型系统

00:00:58.506 --> 00:00:59.266 A:middle
让它变得更有表现性

00:00:59.396 --> 00:01:03.166 A:middle
我们觉得 4.2 版本是一个重要节点

00:00:59.396 --> 00:01:03.166 A:middle
我们觉得 4.2 版本是一个重要节点

00:01:04.296 --> 00:01:08.056 A:middle
从这个节点开始 我们终于可以完全实施

00:01:08.056 --> 00:01:10.746 A:middle
许多期待应用到标准程序库的设计中了

00:01:10.936 --> 00:01:12.196 A:middle
这在达到 Swift 中

00:01:12.626 --> 00:01:15.176 A:middle
ABI 的稳定性的目标方面 对于我们来说非常重要

00:01:16.696 --> 00:01:19.406 A:middle
因此我们之前也针对通用型做了很多次演讲

00:01:19.406 --> 00:01:20.516 A:middle
但我们一直没有往后退一步

00:01:20.546 --> 00:01:22.756 A:middle
将通用型作为一个整体来讲

00:01:23.496 --> 00:01:26.306 A:middle
今天我们要给大家分享一些不同的功能

00:01:26.306 --> 00:01:29.626 A:middle
关于通用型系统 有新功能也有老功能

00:01:29.626 --> 00:01:31.026 A:middle
以便帮你们理解它们如何共同协作

00:01:31.026 --> 00:01:35.426 A:middle
我要快速回顾一下通用型的动机

00:01:37.076 --> 00:01:39.356 A:middle
我们会谈到设计协议

00:01:39.356 --> 00:01:41.116 A:middle
给出一系列具体类型

00:01:41.116 --> 00:01:43.236 A:middle
通过从标准程序库中获取的示例

00:01:44.016 --> 00:01:47.146 A:middle
我们会回顾一下协议继承

00:01:47.146 --> 00:01:48.626 A:middle
并谈谈条件一致性的新功能

00:01:48.626 --> 00:01:50.186 A:middle
以及它如何与协议继承相互作用

00:01:50.226 --> 00:01:55.486 A:middle
最后我们会通过对类和通用型的讨论
总结一下今天的内容

00:01:55.486 --> 00:02:01.026 A:middle
为何通用型对于 Swift 是如此重要的部分？

00:01:55.486 --> 00:02:01.026 A:middle
为何通用型对于 Swift 是如此重要的部分？

00:02:01.836 --> 00:02:06.606 A:middle
了解它们之间相互影响的一个方式
是通过设计简单的集合 比如类型

00:02:08.205 --> 00:02:09.666 A:middle
我们把它叫做缓冲器

00:02:09.666 --> 00:02:11.816 A:middle
它类似于标准程序库中的数组类型

00:02:12.876 --> 00:02:15.856 A:middle
现在对于缓冲器的可读部分来说 最简单的 API

00:02:15.856 --> 00:02:17.276 A:middle
可能包括元素的一个计数

00:02:17.276 --> 00:02:21.026 A:middle
以及把每个元素获取到索引中指定位置的方式

00:02:21.026 --> 00:02:23.376 A:middle
但我们怎么让它返回类型呢？

00:02:23.376 --> 00:02:28.136 A:middle
现在如果我们没有通用型 我们得做一个

00:02:28.136 --> 00:02:29.126 A:middle
有些类型可以表达

00:02:29.126 --> 00:02:31.376 A:middle
我们想在缓冲器内放置的一切东西

00:02:32.096 --> 00:02:35.226 A:middle
你可以调用那个类型 ID 或对象或 Void Star

00:02:35.506 --> 00:02:38.006 A:middle
Swift 中 我们把它叫做 Any

00:02:38.006 --> 00:02:40.936 A:middle
它是一个可以在 Swift 中
代替任意不同类型的类型

00:02:40.936 --> 00:02:45.996 A:middle
因此若你想在缓冲器中处理任意一个元素

00:02:45.996 --> 00:02:47.356 A:middle
你可以让自定义下标返回 Any

00:02:47.356 --> 00:02:49.496 A:middle
但是当然了 你很可能知道

00:02:49.496 --> 00:02:51.906 A:middle
那会营造一种令用户愉悦的体验

00:02:52.136 --> 00:02:55.086 A:middle
那会营造一种 你不得不把那个类型从方框内拿出来

00:02:55.086 --> 00:02:57.906 A:middle
以便能实际使用它

00:03:00.576 --> 00:03:04.406 A:middle
这不仅烦人 还容易出错

00:03:04.826 --> 00:03:07.806 A:middle
如果你代码中的某个位置也许是偶然

00:03:07.806 --> 00:03:10.286 A:middle
如果你代码中的某个位置放了一个整型会怎么样呢？

00:03:11.226 --> 00:03:13.926 A:middle
但那不仅仅关系到易用性

00:03:13.926 --> 00:03:15.246 A:middle
我们还想解决一些问题

00:03:15.246 --> 00:03:18.506 A:middle
关于如何在内存中表达这些值

00:03:18.506 --> 00:03:24.986 A:middle
现在对于字符串的缓冲器来说 最理想的表达方式

00:03:24.986 --> 00:03:26.716 A:middle
就是内存的连续块

00:03:27.146 --> 00:03:28.936 A:middle
每个元素之间用线隔开

00:03:28.936 --> 00:03:34.076 A:middle
但如果是无类型方法 这就不会那么有效了

00:03:34.076 --> 00:03:37.856 A:middle
因为缓冲器不会提前知道 它将会包含哪种类型

00:03:37.856 --> 00:03:40.696 A:middle
它得使用一种像 Any 一样的类型

00:03:40.746 --> 00:03:42.126 A:middle
那可以涵盖任意一个可能性

00:03:42.126 --> 00:03:46.086 A:middle
并且在那个 Any 中
在追踪类型、把类型装盒

00:03:46.086 --> 00:03:49.146 A:middle
和把类型从箱中取出方面 还有许多消耗

00:03:50.296 --> 00:03:54.056 A:middle
在这里 我可能只想要一个整型缓冲器

00:03:54.186 --> 00:03:55.686 A:middle
但我不能在编译器中表达它

00:03:55.686 --> 00:04:01.266 A:middle
因此我必须为灵活性付出代价 即使我对它并不感兴趣

00:03:55.686 --> 00:04:01.266 A:middle
因此我必须为灵活性付出代价 即使我对它并不感兴趣

00:04:01.586 --> 00:04:04.526 A:middle
另外 因为 Any 得解释任意一种不同的类型

00:04:04.526 --> 00:04:10.666 A:middle
包括那些太大以至于
不能在自己内部存储器内存储的类型

00:04:10.666 --> 00:04:11.866 A:middle
它有时候不得不使用间接存储

00:04:11.866 --> 00:04:13.456 A:middle
它得给值保留一个指针

00:04:13.456 --> 00:04:16.565 A:middle
那个值可以在整个内存中定位找到

00:04:17.886 --> 00:04:18.875 A:middle
我们真的想要解决这些问题

00:04:18.875 --> 00:04:23.556 A:middle
不仅仅是为了易用性和正确性 还为了性能原因

00:04:24.146 --> 00:04:28.556 A:middle
并且我们通过一种叫做参数多态性的技术来实现

00:04:29.376 --> 00:04:32.776 A:middle
它就是 Swift 中通用型的另一个术语

00:04:32.776 --> 00:04:38.346 A:middle
通过通用型方法 我们可以在缓冲器中存放更多信息

00:04:38.346 --> 00:04:40.596 A:middle
用于表达缓冲器即将要包含的类型

00:04:41.746 --> 00:04:42.836 A:middle
我们那个类型叫做元素

00:04:44.196 --> 00:04:45.826 A:middle
元素是类型的一个通用型参数

00:04:45.826 --> 00:04:47.436 A:middle
这就是术语参数多态性

00:04:47.436 --> 00:04:52.626 A:middle
你可以把它看作类似一个编译时间参数

00:04:52.626 --> 00:04:54.396 A:middle
它会告诉缓冲器即将要包含什么

00:04:55.716 --> 00:04:57.706 A:middle
现在它有一种方式可以提及那个元素类型

00:04:57.976 --> 00:05:00.316 A:middle
它可以使用那个元素类型 而以前它用的是 Any

00:04:57.976 --> 00:05:00.316 A:middle
它可以使用那个元素类型 而以前它用的是 Any

00:05:03.336 --> 00:05:05.476 A:middle
那意味着不再需要任何转换

00:05:05.476 --> 00:05:06.416 A:middle
当你从缓冲器中获取类型时

00:05:06.416 --> 00:05:10.456 A:middle
如果你意外分配了错误的类型

00:05:10.456 --> 00:05:13.566 A:middle
或者类似的情况 编译器会捕捉你

00:05:15.216 --> 00:05:19.406 A:middle
现在并没有这种不带相关联的
元素类型的缓冲器类型了

00:05:19.406 --> 00:05:23.646 A:middle
如果你尝试声明一个那样的类型
你会得到一个编译错误

00:05:23.646 --> 00:05:29.106 A:middle
你可能会感觉有点吃惊 因为有时候你会看到

00:05:29.106 --> 00:05:32.386 A:middle
你可以声明不带任何元素类型的类型 比如缓冲器

00:05:33.206 --> 00:05:33.926 A:middle
但那仅仅是因为编译器

00:05:33.926 --> 00:05:36.896 A:middle
可以根据情境推断 应该是哪种元素类型

00:05:37.206 --> 00:05:40.676 A:middle
在本例中 是从右手边这儿的字面进行推断

00:05:41.686 --> 00:05:44.576 A:middle
元素仍然还在那里 就是有点含蓄

00:05:46.356 --> 00:05:48.046 A:middle
到底包含哪种类型

00:05:48.126 --> 00:05:50.506 A:middle
诸如缓冲器一样的类型

00:05:50.506 --> 00:05:54.276 A:middle
可以应用在编译和运行期的整个过程中

00:05:54.276 --> 00:06:01.266 A:middle
这意味着我们可以实现在内存的
连续块中保留全部元素的目标

00:05:54.276 --> 00:06:01.266 A:middle
这意味着我们可以实现在内存的
连续块中保留全部元素的目标

00:06:01.306 --> 00:06:02.416 A:middle
而不会超前

00:06:02.416 --> 00:06:05.476 A:middle
即使那些类型任意大

00:06:05.476 --> 00:06:12.416 A:middle
因为编译器始终能直接了解

00:06:12.416 --> 00:06:15.376 A:middle
关于缓冲器具体包含哪种元素类型

00:06:15.956 --> 00:06:16.976 A:middle
它就有机会进行优化

00:06:16.976 --> 00:06:19.646 A:middle
而其它时候却没有

00:06:20.586 --> 00:06:23.436 A:middle
那么在本例中 在我声明整型缓冲器的位置

00:06:24.296 --> 00:06:27.366 A:middle
一个类似这样的循环应该被编译为

00:06:27.366 --> 00:06:28.766 A:middle
仅仅应用于某些非常有效的 CPU 指令

00:06:28.766 --> 00:06:36.186 A:middle
现在如果你正在一个常规基础上写一个这样的循环

00:06:36.546 --> 00:06:37.826 A:middle
用于总计整型缓冲器

00:06:38.006 --> 00:06:40.776 A:middle
把它提取到一个方法中可能会有意义

00:06:40.876 --> 00:06:44.086 A:middle
缓冲器上的扩展单位-可测试性更好

00:06:44.086 --> 00:06:46.966 A:middle
把它提取到一个方法中也可读性也更强

00:06:47.026 --> 00:06:50.306 A:middle
但你很可能知道 如果你像这样写代码

00:06:50.706 --> 00:06:52.026 A:middle
你会出现编译问题

00:06:52.516 --> 00:06:57.366 A:middle
因为并不是所有的元素类型
都可以像这样总计起来

00:06:57.666 --> 00:06:58.916 A:middle
我们需要告诉编译器

00:06:59.126 --> 00:07:03.646 A:middle
更多关于元素所需要具备的性能的信息

00:06:59.126 --> 00:07:03.646 A:middle
更多关于元素所需要具备的性能的信息

00:07:03.646 --> 00:07:05.636 A:middle
以便让这个方法在缓冲器上可用

00:07:05.636 --> 00:07:10.626 A:middle
现在最简单的方式就是 通过限制元素类型

00:07:10.626 --> 00:07:13.856 A:middle
为指定类型实现 就好像原始循环中的整型

00:07:14.676 --> 00:07:20.656 A:middle
如果你采用这种简单的方法来实现
并和扩展一起运行

00:07:20.656 --> 00:07:21.726 A:middle
那么稍后的推广会很简单

00:07:22.176 --> 00:07:23.676 A:middle
当你发现你需要做一些不同的操作时

00:07:23.676 --> 00:07:25.906 A:middle
比如总计双精度浮点型缓冲器
或单精度浮点型缓冲器

00:07:26.966 --> 00:07:28.256 A:middle
请看看你所限制的类型

00:07:28.256 --> 00:07:31.006 A:middle
查看它所遵循的协议

00:07:31.006 --> 00:07:34.816 A:middle
并保持追踪 直到你获得最通用的协议

00:07:34.816 --> 00:07:35.736 A:middle
那你就万事俱备了

00:07:35.736 --> 00:07:39.206 A:middle
在本例中 数字协议

00:07:39.206 --> 00:07:41.756 A:middle
给我们提供了 我们在这里所依赖的两个功能

00:07:42.486 --> 00:07:46.596 A:middle
创建值为 0 的新元素的能力

00:07:46.596 --> 00:07:48.096 A:middle
以及添加新元素的能力

00:07:48.096 --> 00:07:49.876 A:middle
这是数字协议的一部分

00:07:49.876 --> 00:07:54.776 A:middle
现在让我们谈谈

00:07:54.776 --> 00:07:58.496 A:middle
从不同类型中析出协议的过程

00:07:59.456 --> 00:08:03.366 A:middle
那么我们一直在谈这个缓冲器类型

00:07:59.456 --> 00:08:03.366 A:middle
那么我们一直在谈这个缓冲器类型

00:08:03.366 --> 00:08:04.336 A:middle
我们可以让它在不同的元素之间通用

00:08:04.336 --> 00:08:08.596 A:middle
但是要在不同用法中通用的通用代码要怎么写呢？

00:08:09.156 --> 00:08:11.236 A:middle
一段可以在任意不同种类的集合中使用的代码？

00:08:11.236 --> 00:08:16.136 A:middle
比如数组 非常类似于我们的缓冲器类型

00:08:16.886 --> 00:08:18.766 A:middle
但拥有更多不同种类的类型

00:08:18.906 --> 00:08:23.226 A:middle
比如字典 它是关键值对的一个集合

00:08:23.226 --> 00:08:24.806 A:middle
或者也许是不通用的类型

00:08:24.806 --> 00:08:27.656 A:middle
或者不同的元素类型 比如数据或字符串

00:08:27.656 --> 00:08:29.086 A:middle
返回特定的元素类型

00:08:29.086 --> 00:08:36.025 A:middle
我们想要创建一个协议
可以捕捉它们全部常见的功能

00:08:36.635 --> 00:08:40.236 A:middle
我们要创建一个简化版本

00:08:40.236 --> 00:08:41.976 A:middle
标准程序库自己的集合协议

00:08:45.126 --> 00:08:49.906 A:middle
那么请注意 我们首先要考虑到
各式各样的具体类型

00:08:49.906 --> 00:08:51.806 A:middle
现在我们正在思考一种协议

00:08:51.806 --> 00:08:53.546 A:middle
可以把它们全部结合在一起

00:08:53.546 --> 00:08:55.656 A:middle
有必要以这种方式进行思考

00:08:55.656 --> 00:08:58.726 A:middle
我们要从一些具体类型开始

00:08:58.726 --> 00:09:01.816 A:middle
然后尝试通过一个协议把它们统一起来

00:08:58.726 --> 00:09:01.816 A:middle
然后尝试通过一个协议把它们统一起来

00:09:03.336 --> 00:09:04.176 A:middle
那些类型共同拥有什么？

00:09:04.176 --> 00:09:06.456 A:middle
它们不共同拥有什么？

00:09:07.356 --> 00:09:08.706 A:middle
当你正设计一个这样的协议时

00:09:08.706 --> 00:09:11.246 A:middle
你可以把它看作是一种诸如合约谈判一样的东西

00:09:11.246 --> 00:09:14.686 A:middle
这里有一个很常见的拉锯战

00:09:14.686 --> 00:09:17.086 A:middle
在一致性类型之间 一方面

00:09:17.526 --> 00:09:20.896 A:middle
在执行那个约束方面 想要尽可能多的灵活性

00:09:20.896 --> 00:09:24.636 A:middle
而协议的用户

00:09:24.636 --> 00:09:25.856 A:middle
想要一个漂亮、紧凑、简单的协议

00:09:26.086 --> 00:09:28.546 A:middle
以便实现他们的扩展

00:09:28.546 --> 00:09:32.196 A:middle
这就是为什么非常重要的原因

00:09:32.226 --> 00:09:35.006 A:middle
同时考虑到 尽可能多的种类的一致性类型

00:09:35.006 --> 00:09:37.226 A:middle
和一系列不同用例

00:09:37.226 --> 00:09:42.246 A:middle
当你正在设计协议时 因为它是一种平衡做法

00:09:43.076 --> 00:09:46.546 A:middle
那么让我们开始具体化集合协议吧

00:09:46.726 --> 00:09:48.616 A:middle
那么首先我们需要表达元素类型

00:09:49.036 --> 00:09:52.556 A:middle
现在在协议中 我们使用了一个相关联类型

00:09:52.956 --> 00:09:55.906 A:middle
每个一致性类型 都需要对元素进行适当的设置

00:09:55.906 --> 00:09:59.096 A:middle
在缓冲器或数组的例子中

00:09:59.096 --> 00:10:02.516 A:middle
对于 Swift 4.2 来说 这是自动发生的

00:09:59.096 --> 00:10:02.516 A:middle
对于 Swift 4.2 来说 这是自动发生的

00:10:03.256 --> 00:10:06.016 A:middle
因为我们也把它们的通用参数命名为元素

00:10:06.016 --> 00:10:09.136 A:middle
这是一很棒的附带利益

00:10:09.136 --> 00:10:11.856 A:middle
可以赋予你的通用参数一个有意义的名字

00:10:11.856 --> 00:10:14.226 A:middle
遵循共同的惯例 就像元素这个词一样

00:10:15.726 --> 00:10:17.856 A:middle
而不是随意给它们一个名字 比如 T

00:10:17.856 --> 00:10:19.256 A:middle
你要分别陈述的是元素类型

00:10:19.256 --> 00:10:24.186 A:middle
对于其它数据类型 你可能需要做的更具体一些

00:10:24.186 --> 00:10:27.466 A:middle
比如字典 需要把元素类型设置为

00:10:27.466 --> 00:10:28.986 A:middle
它的关键值对和值类型

00:10:29.066 --> 00:10:34.646 A:middle
接下来让我们谈谈添加自定义下标

00:10:35.896 --> 00:10:38.566 A:middle
接下来让我们谈谈诸如数组类型一样的协议

00:10:38.626 --> 00:10:42.576 A:middle
我们可能会让自定义下标 以整型作为它的参数

00:10:42.576 --> 00:10:49.006 A:middle
但是让自定义下标用整型
可能会意味着非常强的约束

00:10:49.006 --> 00:10:52.466 A:middle
每个一致性类型都要提供

00:10:52.586 --> 00:10:57.396 A:middle
把元素取到由整数表达的指定位置的功能

00:10:57.916 --> 00:11:00.716 A:middle
那对于像数组一样的类型来说没问题

00:10:57.916 --> 00:11:00.716 A:middle
那对于像数组一样的类型来说没问题

00:11:01.596 --> 00:11:04.586 A:middle
对于协议的用户来说也非常容易理解

00:11:04.586 --> 00:11:08.526 A:middle
但它对于稍微有些复杂的类型来说灵活性够吗？

00:11:08.626 --> 00:11:09.506 A:middle
比如字典？

00:11:11.136 --> 00:11:13.636 A:middle
现在无论你如何处理它

00:11:13.866 --> 00:11:15.256 A:middle
字典很可能会被阻碍

00:11:15.256 --> 00:11:17.746 A:middle
被一些非常复杂的内部数据结构

00:11:17.746 --> 00:11:21.466 A:middle
在从一个元素移动到下一个元素方面
有特定逻辑的数据结构

00:11:21.466 --> 00:11:26.046 A:middle
比如它可能会被某种内部缓冲器阻碍

00:11:26.046 --> 00:11:30.736 A:middle
它可以使用在那个缓冲器中存储有位移的索引类型

00:11:30.736 --> 00:11:34.526 A:middle
然后它会把参数作为自定义下标

00:11:34.526 --> 00:11:37.346 A:middle
以便把元素获取到那个位置 使用那个位移

00:11:38.166 --> 00:11:41.496 A:middle
但有一点很重要 字典的索引类型

00:11:41.496 --> 00:11:44.416 A:middle
是一个隐含类型 只有字典可以控制

00:11:45.206 --> 00:11:47.506 A:middle
你不希望别人在你的位移中添加 1

00:11:47.506 --> 00:11:50.076 A:middle
那未必会在字典中移动到下一个元素

00:11:50.076 --> 00:11:52.466 A:middle
它可能会移动到任意元素

00:11:52.466 --> 00:11:55.706 A:middle
也许会移动到字典的内部存储器中
未初始化的部分

00:11:56.826 --> 00:12:00.486 A:middle
因此我们希望字典能控制继续向前移动

00:11:56.826 --> 00:12:00.486 A:middle
因此我们希望字典能控制继续向前移动

00:12:00.486 --> 00:12:03.346 A:middle
通过集合 通过改善索引实现

00:12:04.096 --> 00:12:05.986 A:middle
那么为此我们添加了另一个提供索引的方法

00:12:06.926 --> 00:12:12.256 A:middle
为你提供一个可以在它之后标记位置的索引

00:12:12.506 --> 00:12:14.376 A:middle
一旦你采取了这个步骤 你需要更多的东西

00:12:14.376 --> 00:12:17.706 A:middle
你需一个 startIndex 属性
和一个 endIndex 属性

00:12:18.226 --> 00:12:19.356 A:middle
因为简单的计数不再起作用了

00:12:19.356 --> 00:12:21.346 A:middle
不能再告诉我们是否已经到达末端

00:12:21.346 --> 00:12:24.696 A:middle
现在我们不再在索引类型中使用整型了

00:12:26.376 --> 00:12:28.466 A:middle
那么让我们把这些带回到集合协议中

00:12:30.086 --> 00:12:33.136 A:middle
那么我们得到了一个自定义下标 让某个索引类型

00:12:33.136 --> 00:12:35.056 A:middle
表示一个位置 并给你提供一个元素

00:12:35.636 --> 00:12:37.916 A:middle
我们还有一种
可以向前移动那个位置的方法

00:12:39.076 --> 00:12:41.176 A:middle
但我们还需要类型提供

00:12:41.176 --> 00:12:43.576 A:middle
它们即将在索引中使用的类型

00:12:43.816 --> 00:12:45.916 A:middle
我们通过另一个相关联类型实现

00:12:47.886 --> 00:12:50.736 A:middle
一致性类型可以提供适当的类型

00:12:50.736 --> 00:12:54.536 A:middle
因此数组或数据可以提供一个整型
作为它们的索引类型

00:12:55.206 --> 00:12:58.096 A:middle
然而字典可以提供
它自己的自定义实施

00:12:58.176 --> 00:12:59.426 A:middle
处理它自己的内部逻辑

00:12:59.426 --> 00:13:07.456 A:middle
那么让我们返回到一分钟之前我们所讲的内容

00:12:59.426 --> 00:13:07.456 A:middle
那么让我们返回到一分钟之前我们所讲的内容

00:13:07.456 --> 00:13:09.106 A:middle
以便推广我们的索引模型

00:13:09.106 --> 00:13:11.396 A:middle
它仍然是一个非常有用的属性

00:13:11.396 --> 00:13:15.856 A:middle
因此我们很想把它重新添加到集合中 作为一个扩展

00:13:16.656 --> 00:13:20.296 A:middle
可以跨过集合 让索引向前移动

00:13:20.296 --> 00:13:23.376 A:middle
让计数器增长然后就返回

00:13:23.376 --> 00:13:29.406 A:middle
现在如果我们尝试实施它
我们就遇到了另一个漏掉的要求

00:13:30.346 --> 00:13:33.746 A:middle
因为我们把整型移动到一个通用的索引类型

00:13:33.746 --> 00:13:36.596 A:middle
我们再也不能假定索引类型是等同的了

00:13:37.526 --> 00:13:40.306 A:middle
整型是 但任意索引类型却没有必要

00:13:40.306 --> 00:13:43.936 A:middle
并且我们需要它 以便了解我们是否到达了末端

00:13:45.226 --> 00:13:48.846 A:middle
现在我们可以用之前所采用过的
同样的方法来解决这个问题

00:13:49.316 --> 00:13:50.636 A:middle
约束我们的扩展

00:13:50.706 --> 00:13:53.486 A:middle
比如它只能在索引类型是等同时使用

00:13:54.706 --> 00:13:55.976 A:middle
但感觉似乎不对劲

00:13:57.456 --> 00:13:59.006 A:middle
我们想要一个易用的协议

00:13:59.006 --> 00:14:01.556 A:middle
但看起来非常非常烦人

00:13:59.006 --> 00:14:01.556 A:middle
但看起来非常非常烦人

00:14:01.556 --> 00:14:04.276 A:middle
如果我们不得不经常在我们所写的每一个扩展上

00:14:04.276 --> 00:14:06.696 A:middle
应用这个约束

00:14:06.696 --> 00:14:09.396 A:middle
因为我们几乎总是需要比较两个索引

00:14:10.316 --> 00:14:13.556 A:middle
相反 它作为协议的要求 很可能更好地进行表述

00:14:13.556 --> 00:14:19.016 A:middle
作为我们索引相关联类型的约束

00:14:20.386 --> 00:14:21.406 A:middle
把这个约束应用到协议上

00:14:21.406 --> 00:14:23.246 A:middle
意味着遵循协议的全部类型

00:14:23.246 --> 00:14:26.266 A:middle
都需要向它们的索引提供一个
等同的类型

00:14:26.266 --> 00:14:32.046 A:middle
那样你就不需要在每次写扩展时都要指定它了

00:14:33.476 --> 00:14:36.936 A:middle
这是协商协议约束的另一个例子

00:14:36.936 --> 00:14:39.946 A:middle
协议的用户有一个要求

00:14:39.946 --> 00:14:41.306 A:middle
他们需要能比较索引

00:14:41.306 --> 00:14:48.186 A:middle
一致性协议 他们查看了一下
他们可以很合理地进行调整

00:14:48.186 --> 00:14:49.566 A:middle
而不需要放弃太多的灵活性

00:14:50.726 --> 00:14:52.116 A:middle
在本例中他们当然可以

00:14:56.296 --> 00:14:59.646 A:middle
并且通过 Swift 4.2 的
新功能自动合成等同的一致性

00:14:59.646 --> 00:15:03.976 A:middle
字典可以很简单地把它的索引类型变为等同

00:14:59.646 --> 00:15:03.976 A:middle
字典可以很简单地把它的索引类型变为等同

00:15:07.346 --> 00:15:10.246 A:middle
接下来让我们谈谈优化这个计数操作

00:15:10.426 --> 00:15:12.256 A:middle
通过一个自定义点

00:15:14.416 --> 00:15:19.126 A:middle
那么我们已经写了一个版本的计数

00:15:19.126 --> 00:15:19.886 A:middle
计算集合中元素的数量

00:15:19.886 --> 00:15:21.446 A:middle
通过跨过整个集合

00:15:21.446 --> 00:15:24.846 A:middle
但很明显 许多集合很可能做得更快

00:15:24.846 --> 00:15:29.736 A:middle
比如 假如字典在内部保留

00:15:29.736 --> 00:15:30.946 A:middle
它所持有的元素数量

00:15:30.946 --> 00:15:32.516 A:middle
用于实现自己的目的

00:15:33.256 --> 00:15:34.946 A:middle
如果它拥有这个信息

00:15:34.946 --> 00:15:37.416 A:middle
它就可以在它自己的计数实施中使用它

00:15:38.386 --> 00:15:41.806 A:middle
那意味着当人们在字典上调用计数时

00:15:42.036 --> 00:15:43.676 A:middle
他们会获得快速、恒定的时间

00:15:44.096 --> 00:15:45.416 A:middle
而不是线性时间

00:15:45.416 --> 00:15:48.256 A:middle
是指那个适用于任意集合的原始版本
所需要的线性时间

00:15:49.116 --> 00:15:52.196 A:middle
但当添加这样的优化时
你需要注意几点

00:15:52.196 --> 00:15:55.476 A:middle
即旅行协议的要求之间的不同点

00:15:55.476 --> 00:15:59.546 A:middle
和仅在指定类型上添加大量负载

00:15:59.546 --> 00:16:05.686 A:middle
直到现在 这个字典上的计数新版本
就是一个负载

00:15:59.546 --> 00:16:05.686 A:middle
直到现在 这个字典上的计数新版本
就是一个负载

00:16:05.686 --> 00:16:07.626 A:middle
那意味着当你有一个字典时

00:16:07.626 --> 00:16:09.436 A:middle
你知道它是一个字典

00:16:09.436 --> 00:16:12.446 A:middle
你将会获得更新、更好的计数版本

00:16:13.226 --> 00:16:15.886 A:middle
但如果在通用算法内部调用它会怎么样呢？

00:16:17.816 --> 00:16:21.206 A:middle
那么假如我们希望 比如说

00:16:21.206 --> 00:16:22.486 A:middle
写一个标准程序库的地图版本？

00:16:23.116 --> 00:16:25.656 A:middle
如果你还不熟悉它 它真的是一个很有用的操作

00:16:25.656 --> 00:16:29.476 A:middle
可以转换集合中的每一个元素

00:16:29.526 --> 00:16:30.946 A:middle
并给你返回一个新数组

00:16:30.946 --> 00:16:34.216 A:middle
这个实施非常简单

00:16:34.216 --> 00:16:36.686 A:middle
它只是创建一个新数组

00:16:37.486 --> 00:16:38.466 A:middle
在集合内部移动

00:16:39.056 --> 00:16:42.846 A:middle
转换每一个元素 然后把它添加到数组中

00:16:42.846 --> 00:16:46.606 A:middle
现在随着你在像这样的数组中添加元素

00:16:46.606 --> 00:16:47.846 A:middle
数组会自动增长

00:16:48.626 --> 00:16:53.116 A:middle
它随着需要增长
有时候会重新分配它的内部存储

00:16:53.216 --> 00:16:55.586 A:middle
以便拥有更多的空间来容纳新元素

00:16:56.256 --> 00:16:59.276 A:middle
在一个这样的循环中 可能会多次执行上述过程

00:16:59.276 --> 00:17:00.356 A:middle
取决于它要变得多大

00:16:59.276 --> 00:17:00.356 A:middle
取决于它要变得多大

00:17:00.356 --> 00:17:02.696 A:middle
那么这个过程需要时间

00:17:02.926 --> 00:17:04.715 A:middle
分配内存的消耗非常大

00:17:04.715 --> 00:17:09.106 A:middle
有一个很棒的优化小技巧
我们可以应用于这种实施上

00:17:09.106 --> 00:17:13.986 A:middle
我们已经了解
最终的数组具体会有多大了

00:17:14.016 --> 00:17:16.945 A:middle
它会跟我们原始集合的尺寸一样大

00:17:16.945 --> 00:17:22.766 A:middle
那么我们可以提前在数组中储备好空间

00:17:22.766 --> 00:17:26.435 A:middle
在我们开始添加之前
这是一次很漂亮的加速

00:17:26.435 --> 00:17:29.106 A:middle
为此我们要调用计数

00:17:29.196 --> 00:17:32.466 A:middle
但我们在这里调用计数

00:17:32.466 --> 00:17:34.226 A:middle
在通用情境中

00:17:34.226 --> 00:17:40.626 A:middle
也就是集合类型是完全通用的情境
而不是特定的情境

00:17:40.626 --> 00:17:43.296 A:middle
可以是一个数组或字典或链表或任意

00:17:43.296 --> 00:17:46.286 A:middle
那么我们不知道有一个

00:17:46.286 --> 00:17:49.396 A:middle
更好的计数实施可用

00:17:49.396 --> 00:17:51.646 A:middle
当编译器编译这段代码时

00:17:51.646 --> 00:17:56.376 A:middle
那么在这种情况下 即将被调用的计数版本

00:17:56.376 --> 00:18:01.086 A:middle
实际上是计数的通用版本 可以应用在任意集合上

00:17:56.376 --> 00:18:01.086 A:middle
实际上是计数的通用版本 可以应用在任意集合上

00:18:01.086 --> 00:18:02.256 A:middle
并会在整个集合上进行迭代

00:18:02.256 --> 00:18:04.536 A:middle
如果你在字典上调用地图

00:18:04.536 --> 00:18:08.606 A:middle
就不会调用我们刚写的计数的新版本

00:18:11.156 --> 00:18:13.316 A:middle
为了在通用情境中调用

00:18:13.316 --> 00:18:17.526 A:middle
像这样的自定义方法或属性

00:18:17.526 --> 00:18:21.446 A:middle
它需要在协议上 把自己声明为一个要求

00:18:21.446 --> 00:18:24.256 A:middle
我们已经确定一定有一种方式

00:18:24.256 --> 00:18:27.576 A:middle
它需要在协议上提供计数的优化版本

00:18:27.576 --> 00:18:32.566 A:middle
这样它在协议上
把自己声明为一个要求就有意义了

00:18:32.566 --> 00:18:40.036 A:middle
现在即便我们把它作为
一个要求来实施

00:18:40.036 --> 00:18:42.066 A:middle
所有集合都不需要提供它们自己的实施

00:18:42.066 --> 00:18:45.976 A:middle
因为我们已经通过我们的扩展 提供了一个

00:18:45.976 --> 00:18:47.076 A:middle
可以应用在任意集合上

00:18:48.306 --> 00:18:51.856 A:middle
向协议中添加一个要求 并且在旁边

00:18:51.856 --> 00:18:55.576 A:middle
通过一个扩展添加一个默认实施

00:18:55.576 --> 00:18:57.706 A:middle
这就是我们称为自定义点的东西

00:18:57.706 --> 00:19:03.126 A:middle
通过一个扩展 编译器可以了解

00:18:57.706 --> 00:19:03.126 A:middle
通过一个扩展 编译器可以了解

00:19:03.126 --> 00:19:06.026 A:middle
有一个可用的方法 或属性的更好的实施

00:19:06.026 --> 00:19:09.956 A:middle
因此在通用情境中

00:19:09.956 --> 00:19:13.416 A:middle
它会在协议中动态地调遣那个实施

00:19:13.416 --> 00:19:18.856 A:middle
那么现在如果你在字典上调用地图

00:19:18.856 --> 00:19:19.876 A:middle
即便是一个完全通用的函数

00:19:20.596 --> 00:19:22.456 A:middle
你将会得到计数的更好的实施

00:19:24.596 --> 00:19:26.086 A:middle
添加这样的自定义点

00:19:26.086 --> 00:19:28.756 A:middle
同时通过扩展添加默认实施

00:19:28.756 --> 00:19:32.906 A:middle
是一种很强大的方式 可以获得同样的好处

00:19:32.976 --> 00:19:34.396 A:middle
跟你用类获得的好处一样

00:19:34.396 --> 00:19:37.086 A:middle
实施继承和方法重写

00:19:37.086 --> 00:19:41.916 A:middle
但这个技巧可以用在 结构和枚举以及类上

00:19:41.916 --> 00:19:48.476 A:middle
现在并不是每一个方法 都可以像这样进行优化

00:19:49.026 --> 00:19:53.146 A:middle
并且自定义点在你的二进制尺寸上
有一个小但非零的影响

00:19:53.146 --> 00:19:55.006 A:middle
你的编译器运行时间的性能

00:19:55.056 --> 00:19:59.506 A:middle
那么只有当明确有机会自定义时

00:19:59.506 --> 00:20:00.036 A:middle
添加自定义点才有意义

00:19:59.506 --> 00:20:00.036 A:middle
添加自定义点才有意义

00:20:00.036 --> 00:20:05.006 A:middle
比如在我们刚写的地图操作中

00:20:05.446 --> 00:20:08.026 A:middle
并没有合理的方式让任意种类的集合

00:20:08.026 --> 00:20:11.436 A:middle
提供更好的实施

00:20:12.046 --> 00:20:14.636 A:middle
因此把它添加为一个自定义点就没有意义

00:20:14.996 --> 00:20:16.376 A:middle
仅仅保持为一个扩展就可以了

00:20:16.376 --> 00:20:20.966 A:middle
那么我们已经创建了这个集合类型

00:20:20.966 --> 00:20:21.976 A:middle
且它其实已拥有了完整的功能

00:20:21.976 --> 00:20:24.926 A:middle
它有尽可能多的不同的一致性类型

00:20:25.236 --> 00:20:28.356 A:middle
你可以为它写许多不同但有用的算法

00:20:28.616 --> 00:20:31.696 A:middle
但有时候 你不是只需要一个单一的协议

00:20:31.696 --> 00:20:33.116 A:middle
为了将各种类型进行分类

00:20:33.116 --> 00:20:36.356 A:middle
你需要协议继承

00:20:36.656 --> 00:20:38.936 A:middle
为了让大家了解更多信息 请 Doug 上台来

00:20:40.516 --> 00:20:45.586 A:middle
[ 掌声 ]

00:20:46.086 --> 00:20:46.706 A:middle
&gt;&gt; 谢谢 Ben

00:20:47.936 --> 00:20:50.976 A:middle
那么协议继承自 Swift 创建之初就有了

00:20:50.976 --> 00:20:54.956 A:middle
为了考虑我们在哪里需要协议继承

00:20:55.026 --> 00:20:57.206 A:middle
让我们看一下
我们一直在创建的这个集合协议

00:20:57.206 --> 00:20:59.906 A:middle
它是一个很好的协议 设计很棒

00:21:00.566 --> 00:21:02.136 A:middle
它描述了一组一致性类型

00:21:02.136 --> 00:21:05.136 A:middle
可以让你在类型上写一些有趣的通用算法

00:21:05.136 --> 00:21:10.906 A:middle
但我们不用做太多
就能找到其它类似集合的算法

00:21:10.906 --> 00:21:14.186 A:middle
依据目前的集合协议 我们不能实施

00:21:14.186 --> 00:21:16.466 A:middle
比如如果我们想在集合中找到

00:21:16.466 --> 00:21:20.026 A:middle
匹配某谓语的最后一个元素索引

00:21:20.026 --> 00:21:23.736 A:middle
最佳方式就是从末端开始 然后倒着进行

00:21:23.786 --> 00:21:26.086 A:middle
集合协议不允许我们这样做

00:21:26.086 --> 00:21:30.616 A:middle
或者加入我们想创建一个洗牌操作

00:21:30.616 --> 00:21:31.716 A:middle
以便在集合中的元素之间随机洗牌

00:21:31.716 --> 00:21:35.316 A:middle
嗯 那需要突变 而集合不允许这样

00:21:35.716 --> 00:21:38.426 A:middle
现在并不是因为集合协议错了

00:21:39.876 --> 00:21:41.206 A:middle
而是我们需要更多的东西

00:21:41.206 --> 00:21:44.246 A:middle
来描述这些额外的通用算法

00:21:44.636 --> 00:21:45.866 A:middle
这就需要协议继承

00:21:45.866 --> 00:21:47.806 A:middle
这是 BidirectionalCollection 协议

00:21:47.806 --> 00:21:51.856 A:middle
继承自集合或者继承集合

00:21:52.426 --> 00:21:55.026 A:middle
意思就是

00:21:55.066 --> 00:21:57.866 A:middle
遵循 BidirectionalCollection 协议的
任意类型

00:21:58.376 --> 00:21:59.816 A:middle
同样也会遵循集合

00:21:59.816 --> 00:22:00.776 A:middle
你可以使用那些集合算法

00:21:59.816 --> 00:22:00.776 A:middle
你可以使用那些集合算法

00:22:00.776 --> 00:22:04.976 A:middle
但是 BidirectionalCollection
添加了这个额外要求

00:22:05.016 --> 00:22:07.226 A:middle
就是能在集合中倒着操作

00:22:07.226 --> 00:22:09.866 A:middle
有一个重点需要注意

00:22:10.006 --> 00:22:12.386 A:middle
并不是每个集合都可以实施
这个特定的要求

00:22:12.436 --> 00:22:16.936 A:middle
思考一下 SinglyLinkedList
你只能让这些指针

00:22:17.496 --> 00:22:19.856 A:middle
从一个位置跳到下一个位置

00:22:20.156 --> 00:22:22.786 A:middle
并没有一种有效的方式
可以按照这个顺序倒着进行

00:22:22.926 --> 00:22:25.406 A:middle
因此它不能是 BidirectionalCollection

00:22:25.776 --> 00:22:26.566 A:middle
那么一旦我们引入了继承

00:22:26.566 --> 00:22:28.046 A:middle
你就已经限制了一致性类型

00:22:28.046 --> 00:22:33.346 A:middle
但你也允许你自己实施更多有趣的算法

00:22:33.346 --> 00:22:37.136 A:middle
那么这是这个 lastIndex(where:)
操作背后的代码

00:22:37.356 --> 00:22:41.496 A:middle
非常简单
我们只是在集合中倒着进行

00:22:41.496 --> 00:22:44.166 A:middle
使用这个来自 BidirectionalCollection
协议的新要求

00:22:44.166 --> 00:22:47.996 A:middle
让我们看一个更有意思的算法

00:22:47.996 --> 00:22:50.346 A:middle
那么这是一个洗牌操作

00:22:50.516 --> 00:22:53.526 A:middle
那么它在 Swift 4.2 中
针对集合进行了引入

00:22:53.666 --> 00:22:54.506 A:middle
你不需要自己实施它

00:22:54.506 --> 00:22:55.646 A:middle
我们会查看算法自身

00:22:55.646 --> 00:22:56.816 A:middle
了解它引入了哪些要求

00:22:56.816 --> 00:23:01.566 A:middle
从而算出如何有意义地将那些归类到协议中

00:22:56.816 --> 00:23:01.566 A:middle
从而算出如何有意义地将那些归类到协议中

00:23:01.566 --> 00:23:05.276 A:middle
Fisher-Yates 洗牌算法是一个很古老的算法

00:23:05.276 --> 00:23:07.216 A:middle
它也非常简单

00:23:11.586 --> 00:23:13.836 A:middle
然后随机选择

00:23:14.186 --> 00:23:17.196 A:middle
集合中另一个元素
并把这两个元素交换一下

00:23:18.556 --> 00:23:22.596 A:middle
在下一次迭代中
你把左边的索引向前移动一个

00:23:23.476 --> 00:23:25.996 A:middle
在那个和最后一个之间随机选择
然后交换那些元素

00:23:25.996 --> 00:23:28.196 A:middle
那么算法非常简单

00:23:28.196 --> 00:23:29.886 A:middle
只是集合中的线性移动

00:23:30.146 --> 00:23:33.636 A:middle
随机选择另一个元素进行交换

00:23:33.636 --> 00:23:37.516 A:middle
在最后你会得到一个经过漂亮洗牌的集合

00:23:37.886 --> 00:23:40.676 A:middle
那么我们可以看一下代码

00:23:40.676 --> 00:23:43.236 A:middle
有一点复杂 但不要担心

00:23:43.626 --> 00:23:46.366 A:middle
我们要在某个集合上实施它

00:23:46.896 --> 00:23:48.576 A:middle
那么让我们看一下这里的核心操作

00:23:48.906 --> 00:23:49.966 A:middle
那么首先我们需要能获取

00:23:49.966 --> 00:23:53.156 A:middle
随机编号在我们目前在集合中的位置

00:23:53.156 --> 00:23:55.626 A:middle
和集合末端之间 通过这个随机功能

00:23:55.626 --> 00:23:57.206 A:middle
但那儿有一个整型

00:23:57.366 --> 00:23:59.316 A:middle
我们需要的是集合中的索引

00:23:59.316 --> 00:24:00.226 A:middle
我们知道那是不同的

00:23:59.316 --> 00:24:00.226 A:middle
我们知道那是不同的

00:24:00.526 --> 00:24:02.066 A:middle
所以我们需要一些操作

00:24:02.116 --> 00:24:03.706 A:middle
让我们把它叫做 Index offsetBy

00:24:04.506 --> 00:24:06.106 A:middle
从 startIndex 迅速跳到

00:24:06.516 --> 00:24:07.606 A:middle
我们所选择的任意位置

00:24:07.606 --> 00:24:13.276 A:middle
我们所需要的另一个操作是 可以交换两个元素

00:24:13.276 --> 00:24:18.086 A:middle
很棒 我们有两个操作 我们需要添加

00:24:18.086 --> 00:24:21.026 A:middle
到集合的概念中 以便可以实施洗牌

00:24:21.336 --> 00:24:23.686 A:middle
因此我们有一个
新的 ShuffleCollection 协议

00:24:25.976 --> 00:24:27.606 A:middle
请不要这样做

00:24:28.096 --> 00:24:29.396 A:middle
那么这是一个反面模式

00:24:29.396 --> 00:24:33.096 A:middle
这里的反面模式是我们有一个算法

00:24:33.276 --> 00:24:34.956 A:middle
我们找到它的要求

00:24:34.956 --> 00:24:38.366 A:middle
然后我们把它打包到一个协议中 就是那个…

00:24:39.316 --> 00:24:40.296 A:middle
描述那一个算法

00:24:40.296 --> 00:24:44.236 A:middle
如果你这样做了 你就拥有了许多协议

00:24:44.236 --> 00:24:45.756 A:middle
但并没有任何意义

00:24:45.756 --> 00:24:48.526 A:middle
你并不是在从那些协议中学习什么

00:24:49.026 --> 00:24:51.486 A:middle
因此你应该做的是注意

00:24:51.486 --> 00:24:53.956 A:middle
我们实际上在这里有不同的功能

00:24:54.436 --> 00:24:57.496 A:middle
那么洗牌使用的是随机存取 并使用了突变

00:24:57.956 --> 00:25:01.546 A:middle
但这些是不同的 并且我们可以
把它们归类为不同的协议

00:24:57.956 --> 00:25:01.546 A:middle
但这些是不同的 并且我们可以
把它们归类为不同的协议

00:25:02.056 --> 00:25:04.576 A:middle
比如 RandomAccessCollection 协议

00:25:04.976 --> 00:25:08.516 A:middle
就是可以让我们在集合中跳来跳去的协议

00:25:08.596 --> 00:25:09.756 A:middle
可以迅速移动索引

00:25:10.466 --> 00:25:11.476 A:middle
还有像 UnsafeBufferPointer 的类型

00:25:11.476 --> 00:25:16.616 A:middle
可以给你提供随机存取 但不允许任何突变

00:25:16.736 --> 00:25:18.096 A:middle
这是不同的功能

00:25:19.036 --> 00:25:21.436 A:middle
我们这里还有 MutableCollection 协议

00:25:22.366 --> 00:25:24.976 A:middle
我们可以认为这里的类型允许突变

00:25:24.976 --> 00:25:25.896 A:middle
但不允许随机获取

00:25:25.896 --> 00:25:27.826 A:middle
就像我们刚讲过的 SinglyLinkedList 一样

00:25:28.556 --> 00:25:31.946 A:middle
现在请注意我们已经从根本上分离了继承等级

00:25:33.246 --> 00:25:35.846 A:middle
我们有用于随机存取双向作用等等的存取端

00:25:35.846 --> 00:25:37.446 A:middle
然后我们有这个突变端

00:25:37.446 --> 00:25:43.736 A:middle
非常完美 因为客户自己可以编写多个协议

00:25:43.736 --> 00:25:44.776 A:middle
用来实施他们所写的通用算法

00:25:44.776 --> 00:25:46.876 A:middle
那么让我们返回到我们的洗牌算法

00:25:46.876 --> 00:25:50.396 A:middle
它可以在 RandomAccessCollection 上
作为一个扩展

00:25:50.396 --> 00:25:52.056 A:middle
带有自类型

00:25:52.056 --> 00:25:54.246 A:middle
所以这是一个既遵循
RandomAccessCollection

00:25:54.246 --> 00:25:56.756 A:middle
又遵循 MutableCollection 协议的类型

00:25:56.756 --> 00:26:00.556 A:middle
现在我们把这两个协议的功能放在了一起

00:25:56.756 --> 00:26:00.556 A:middle
现在我们把这两个协议的功能放在了一起

00:26:00.556 --> 00:26:06.216 A:middle
现在当你拥有许多一致性类型时

00:26:06.216 --> 00:26:07.986 A:middle
以及许多通用算法时

00:26:07.986 --> 00:26:09.806 A:middle
你常常会形成协议等级

00:26:09.806 --> 00:26:12.156 A:middle
这些等级不应该太长

00:26:12.156 --> 00:26:14.026 A:middle
不应该太深入

00:26:14.026 --> 00:26:18.066 A:middle
因为你其实是希望要少量的协议

00:26:18.066 --> 00:26:21.426 A:middle
只要能描述在域名中出现的类型即可 对吧？

00:26:21.876 --> 00:26:23.766 A:middle
现在你一定注意到了

00:26:23.766 --> 00:26:25.846 A:middle
当你着手创建这些协议等级时

00:26:25.846 --> 00:26:29.646 A:middle
那么随着你从等级的底层到顶层

00:26:29.646 --> 00:26:32.176 A:middle
你得到的协议会拥有较少的要求

00:26:32.306 --> 00:26:35.306 A:middle
因此有更多的一致性类型 可以实施那些要求

00:26:35.306 --> 00:26:39.416 A:middle
现在从另一方面说 随着你往等级的底层移动

00:26:39.466 --> 00:26:42.646 A:middle
并结合等级中不同的协议

00:26:42.696 --> 00:26:46.076 A:middle
你就要实施更复杂、更专业的算法

00:26:46.076 --> 00:26:47.676 A:middle
要求更高级的功能

00:26:47.676 --> 00:26:50.836 A:middle
但实际上只能用于较少的一致性类型上

00:26:54.556 --> 00:26:56.306 A:middle
好的

00:26:56.306 --> 00:26:57.246 A:middle
让我们谈谈条件一致性

00:26:57.306 --> 00:27:00.396 A:middle
这是 当然了 Swift 中的一个较新的功能

00:26:57.306 --> 00:27:00.396 A:middle
这是 当然了 Swift 中的一个较新的功能

00:27:00.646 --> 00:27:02.216 A:middle
让我们首先从切片开始看

00:27:02.216 --> 00:27:07.276 A:middle
对于你所拥有的任意一个集合
你可以形成那个集合的一个切片

00:27:07.276 --> 00:27:12.236 A:middle
通过带有指定 索引范围的自定义下标实现

00:27:12.236 --> 00:27:16.256 A:middle
并且那个切片 其实是集合的某一个部分的视图

00:27:16.256 --> 00:27:21.366 A:middle
现在你在切片集合中所得到的一种默认类型

00:27:21.366 --> 00:27:23.696 A:middle
叫做切片

00:27:24.486 --> 00:27:26.146 A:middle
并且切片是一个通用的适配器类型

00:27:26.146 --> 00:27:32.016 A:middle
那么它在基础集合类型上参数化了

00:27:32.016 --> 00:27:33.216 A:middle
它自己就是一个集合

00:27:33.936 --> 00:27:37.636 A:middle
所以我们对于切片的期待就是
你可以对切片做任何

00:27:37.636 --> 00:27:38.676 A:middle
你能对下面的集合所做的事

00:27:38.676 --> 00:27:41.266 A:middle
这个要求很合理

00:27:41.966 --> 00:27:44.496 A:middle
我们当然可以使用向前搜索操作

00:27:44.496 --> 00:27:47.406 A:middle
比如 index(where:)
来查找匹配某个谓语的东西

00:27:47.406 --> 00:27:50.226 A:middle
那适用于集合以及那个集合的任意切片

00:27:50.226 --> 00:27:54.506 A:middle
我们想用向后搜索来做同样的事

00:27:54.506 --> 00:27:55.456 A:middle
但在这里我们会产生一个问题

00:27:55.456 --> 00:27:59.756 A:middle
即便缓冲器是一个
BidirectionalCollection

00:27:59.756 --> 00:28:01.976 A:middle
并没说切片也是一个
BidirectionalCollection

00:27:59.756 --> 00:28:01.976 A:middle
并没说切片也是一个
BidirectionalCollection

00:28:02.636 --> 00:28:05.966 A:middle
我们可以修复这个问题

00:28:05.966 --> 00:28:09.156 A:middle
让我们把切片扩展一下
使它遵循 BidirectionalCollection 协议

00:28:09.156 --> 00:28:13.026 A:middle
我们需要实施这个
index(before:) 操作

00:28:13.026 --> 00:28:16.176 A:middle
这样我们可以按照下面的基础集合进行实施

00:28:17.146 --> 00:28:18.666 A:middle
除非编译器会在这里进行约束

00:28:19.736 --> 00:28:22.676 A:middle
关于基础集合
我们所了解的唯一一件事就是

00:28:22.676 --> 00:28:23.516 A:middle
它是一个集合

00:28:23.666 --> 00:28:26.286 A:middle
它并没有 index(before:) 操作

00:28:27.806 --> 00:28:28.966 A:middle
我们知道如何修复这个问题

00:28:29.516 --> 00:28:32.646 A:middle
我们所需要做的就是在这个扩展中引入一个要求

00:28:32.646 --> 00:28:35.016 A:middle
换句话说就是基础集合需要是
BidirectionalCollection

00:28:35.786 --> 00:28:37.186 A:middle
这是条件一致性

00:28:38.146 --> 00:28:41.836 A:middle
其实就是扩展声明遵循某个协议

00:28:41.836 --> 00:28:45.416 A:middle
然后那个协议下的约束条件实际上就有意义了

00:28:45.416 --> 00:28:49.146 A:middle
关于条件一致性的最棒的事就是

00:28:49.146 --> 00:28:51.516 A:middle
当你拥有这些协议等级时
它会漂亮地进行堆栈

00:28:51.836 --> 00:28:55.656 A:middle
所以我们还可以说切片是一个
RandomAccessCollection

00:28:56.026 --> 00:28:59.286 A:middle
当它下面的基础类型是
RandomAccessCollection 时

00:29:00.486 --> 00:29:02.806 A:middle
现在请注意 我在这里写了两个不同的扩展

00:29:03.806 --> 00:29:05.086 A:middle
它是常见的 Swift 样式

00:29:05.086 --> 00:29:07.026 A:middle
写扩展 让它遵循某个协议

00:29:07.026 --> 00:29:10.966 A:middle
这样你就知道该扩展是干什么的
你就了解了它的意思

00:29:11.466 --> 00:29:15.106 A:middle
它有条件一致性特别重要

00:29:15.456 --> 00:29:19.006 A:middle
因为你在这些扩展上有不同的要求

00:29:19.006 --> 00:29:22.036 A:middle
这就允许有可组合性

00:29:22.036 --> 00:29:26.316 A:middle
无论下面的基层集合可以做什么

00:29:26.316 --> 00:29:27.326 A:middle
切片类型同样也可以做

00:29:28.796 --> 00:29:32.326 A:middle
那么让我们看看条件一致性的另一个 App

00:29:32.326 --> 00:29:33.556 A:middle
也是在标准程序库中

00:29:33.556 --> 00:29:34.866 A:middle
也是在标准程序库中 这些是范围

00:29:34.866 --> 00:29:37.666 A:middle
那么范围永远存在于 Swift 中

00:29:37.666 --> 00:29:40.156 A:middle
你可以形成一个范围 比如说这些操作符

00:29:40.156 --> 00:29:44.506 A:middle
因此你可以形成双精度浮点型范围
也可以形成整型范围

00:29:44.506 --> 00:29:48.156 A:middle
但有些范围比另外一些更强大

00:29:48.416 --> 00:29:52.316 A:middle
那么你可以在整型范围内迭代元素

00:29:52.926 --> 00:29:53.876 A:middle
为什么你能这样做呢？

00:29:53.876 --> 00:29:55.066 A:middle
那是因为 intRange 遵循集合

00:29:55.576 --> 00:29:59.276 A:middle
现在如果你查看一下类型

00:29:59.276 --> 00:30:00.606 A:middle
由那个运算符创建的类型

00:29:59.276 --> 00:30:00.606 A:middle
由那个运算符创建的类型

00:30:00.646 --> 00:30:04.306 A:middle
它适当地命名了范围类型

00:30:04.306 --> 00:30:08.126 A:middle
它相对于下面的绑定类型来说是通用的

00:30:08.126 --> 00:30:11.126 A:middle
这种情况下 我们有一系列双浮点精度型

00:30:11.126 --> 00:30:12.456 A:middle
它仅仅存储较低和较高的绑定型

00:30:12.646 --> 00:30:13.456 A:middle
非常简单

00:30:14.286 --> 00:30:18.816 A:middle
但在 Swift 4.2 之前 你从整型范围中得到的

00:30:18.876 --> 00:30:20.036 A:middle
实际上是一个不同的类型

00:30:20.466 --> 00:30:22.176 A:middle
这是 CountableRange 类型

00:30:23.126 --> 00:30:26.056 A:middle
现在请注意 它与范围类型的结构一模一样

00:30:26.056 --> 00:30:27.236 A:middle
它有一个类型参数

00:30:27.236 --> 00:30:28.696 A:middle
它有较低和较高绑定型

00:30:29.246 --> 00:30:32.686 A:middle
但它在那个绑定型上增加了一些额外的要求

00:30:32.686 --> 00:30:34.876 A:middle
那个绑定型是可跨过的 对吧？

00:30:35.286 --> 00:30:37.436 A:middle
意思是你可以枚举全部元素

00:30:37.866 --> 00:30:40.056 A:middle
现在这是你所需要的功能 从而可以

00:30:40.056 --> 00:30:42.456 A:middle
让 CountableRange 遵循
RandomAccessCollection

00:30:43.676 --> 00:30:46.826 A:middle
那就启用了 forEach 迭代循环
和其它功能

00:30:48.076 --> 00:30:50.736 A:middle
但是通过条件一致性 当然了
我们可以做得更好

00:30:51.516 --> 00:30:57.306 A:middle
让我们把基础范围类型变成一个集合

00:30:57.306 --> 00:31:01.376 A:middle
当绑定类型拥有这些额外的可跨过的要求时

00:30:57.306 --> 00:31:01.376 A:middle
当绑定类型拥有这些额外的可跨过的要求时

00:31:01.736 --> 00:31:03.706 A:middle
它是条件一致性的简单 App

00:31:04.166 --> 00:31:09.266 A:middle
但它让范围类型变得更强大
当和更好的类型参数一起使用时

00:31:10.806 --> 00:31:14.876 A:middle
现在请注意我只是遵循
RandomAccessCollection

00:31:15.496 --> 00:31:19.326 A:middle
我其实没有提到集合
或 BidirectionalCollection

00:31:20.366 --> 00:31:22.546 A:middle
这是无条件顺应 没问题

00:31:23.036 --> 00:31:26.446 A:middle
声明遵循 RandomAccessCollection

00:31:26.446 --> 00:31:28.276 A:middle
暗示着遵循它所继承的任何协议

00:31:28.276 --> 00:31:31.416 A:middle
在本例中是
BidirectionalCollection 和集合

00:31:31.416 --> 00:31:35.326 A:middle
然而对于条件一致性 这实际上是个错误

00:31:35.326 --> 00:31:37.636 A:middle
现在如果你回想一下切片例子

00:31:37.636 --> 00:31:39.666 A:middle
我们需要有不同的约束

00:31:39.776 --> 00:31:43.186 A:middle
来处理那些不同的等级

00:31:43.186 --> 00:31:45.746 A:middle
针对集合与 BidirectionalCollection

00:31:45.746 --> 00:31:47.176 A:middle
与 RandomAccessCollection

00:31:47.756 --> 00:31:50.636 A:middle
因此编译器会强制执行 你要考虑到这个

00:31:50.636 --> 00:31:52.096 A:middle
并确保你拥有正确的约束条件

00:31:52.146 --> 00:31:53.426 A:middle
对于条件一致性来说

00:31:53.736 --> 00:31:58.596 A:middle
在本例中 整个等级的约束条件都是相同的

00:31:58.596 --> 00:32:01.646 A:middle
我们可以只明确写出集合
和 BidirectionalCollection

00:31:58.596 --> 00:32:01.646 A:middle
我们可以只明确写出集合
和 BidirectionalCollection

00:32:01.646 --> 00:32:06.056 A:middle
以宣称这就是全部一致性的位置

00:32:06.506 --> 00:32:07.936 A:middle
或者我们可以做得更好

00:32:07.936 --> 00:32:09.616 A:middle
分离不同的一致性

00:32:09.616 --> 00:32:15.346 A:middle
现在这点上 我们的范围类型非常强大

00:32:15.346 --> 00:32:17.016 A:middle
它会做一切 CountableRange
所能做的工作

00:32:17.296 --> 00:32:18.686 A:middle
我们应该如何使用 CountableRange 呢？

00:32:19.536 --> 00:32:20.206 A:middle
我们可以把它丢到一边去

00:32:20.726 --> 00:32:23.066 A:middle
在本例中我们讲的是标准程序库

00:32:23.066 --> 00:32:25.706 A:middle
有许多代码实际上使用了 CountableRange

00:32:25.986 --> 00:32:29.586 A:middle
因此我们可以把它作为通用类型别名
保留下来

00:32:30.886 --> 00:32:32.476 A:middle
这是一个很棒的方案

00:32:32.476 --> 00:32:34.466 A:middle
那么通用类型别名添加了

00:32:34.546 --> 00:32:37.306 A:middle
让范围可计数所需要的全部额外要求

00:32:37.306 --> 00:32:39.276 A:middle
你需要把这些要求放在集合中

00:32:39.276 --> 00:32:44.706 A:middle
但它只是下面范围类型的一个可替换的名字

00:32:46.826 --> 00:32:47.806 A:middle
这对于源兼容性来说很棒

00:32:47.806 --> 00:32:50.846 A:middle
因为代码仍可使用 CountableRange

00:32:51.116 --> 00:32:52.416 A:middle
从另一方面说 它还可以

00:32:52.466 --> 00:32:56.046 A:middle
给那些拥有额外功能的范围取一个漂亮的名字

00:32:56.046 --> 00:32:59.286 A:middle
额外功能只是成为
RandomAccessCollection

00:32:59.916 --> 00:33:02.206 A:middle
事实上我们可以用此来清理其它代码

00:32:59.916 --> 00:33:02.206 A:middle
事实上我们可以用此来清理其它代码

00:33:02.206 --> 00:33:04.476 A:middle
比如 我们知道什么是 CountableRange

00:33:04.876 --> 00:33:09.106 A:middle
它是带有这种额外跨越功能的范围

00:33:09.106 --> 00:33:10.616 A:middle
因此我们可以扩展 CountableRanges

00:33:10.916 --> 00:33:14.466 A:middle
这就是我们拥有 RandomAccessCollection
一致性的情况

00:33:14.466 --> 00:33:17.426 A:middle
Swift 4.2 中引入了这个

00:33:17.426 --> 00:33:20.906 A:middle
用于帮助简化我们要处理的类型

00:33:20.906 --> 00:33:24.656 A:middle
并让现有核心类型 比如范围

00:33:24.656 --> 00:33:25.346 A:middle
组合性更强 也更灵活

00:33:27.756 --> 00:33:30.726 A:middle
&gt;&gt; 递归约束描述了协议

00:33:30.726 --> 00:33:32.316 A:middle
及其关联类型之间的关系

00:33:32.316 --> 00:33:34.836 A:middle
这是我们在 WWDC 的版本中

00:33:34.836 --> 00:33:36.616 A:middle
没有涉及的话题

00:33:36.616 --> 00:33:38.776 A:middle
它是标准库使用

00:33:38.776 --> 00:33:41.666 A:middle
Swift 泛型系统的重要组成部分

00:33:42.216 --> 00:33:43.006 A:middle
让我们直接开始吧

00:33:43.936 --> 00:33:47.046 A:middle
递归约束不过是涉及到相同协议

00:33:47.076 --> 00:33:50.336 A:middle
的一个协议中的约束

00:33:51.036 --> 00:33:53.986 A:middle
这里 集合具有一个名为子序列的关联类型

00:33:53.986 --> 00:33:57.136 A:middle
它本身就是一个集合

00:33:57.726 --> 00:34:02.566 A:middle
那么你为什么需要它呢
让我们来看一个基于它的泛型算法

00:33:57.726 --> 00:34:02.566 A:middle
那么你为什么需要它呢
让我们来看一个基于它的泛型算法

00:34:03.086 --> 00:34:06.006 A:middle
这里是一个给定的已经排序过的集合

00:34:06.316 --> 00:34:09.496 A:middle
我们想要找到应该插入一个新值的索引

00:34:09.496 --> 00:34:12.076 A:middle
从而保持排序的顺序

00:34:12.456 --> 00:34:14.656 A:middle
我们将要计算值为 11 的排序插入点

00:34:14.656 --> 00:34:19.936 A:middle
当我们在索引处插入 11 时

00:34:19.936 --> 00:34:21.406 A:middle
结果仍然是一个排序好的数组

00:34:22.036 --> 00:34:25.386 A:middle
函数的排序插入点是通过二进制搜索实现的

00:34:25.386 --> 00:34:26.846 A:middle
是通过二进制搜索实现的

00:34:27.536 --> 00:34:30.716 A:middle
二进制搜索是一种经典的分治算法

00:34:31.005 --> 00:34:34.646 A:middle
这意味着在每个步骤中它都会做出一个决策

00:34:34.646 --> 00:34:37.056 A:middle
从而显著地减小问题的规模

00:34:37.196 --> 00:34:41.476 A:middle
需要考虑的下一步是对于二进制查找

00:34:41.476 --> 00:34:43.216 A:middle
我们首先观察中间元素 8

00:34:43.735 --> 00:34:46.545 A:middle
然后与我们要插入的值进行比较 也就是 11

00:34:47.226 --> 00:34:49.085 A:middle
因为 11 大于 8

00:34:49.085 --> 00:34:54.556 A:middle
所以 11 需要在 8 之后插入
在集合的后半部分

00:34:54.556 --> 00:34:57.826 A:middle
所以我们把搜索空间限制了一半

00:34:59.096 --> 00:35:02.956 A:middle
在下一步中我们找到新的中间值 14

00:34:59.096 --> 00:35:02.956 A:middle
在下一步中我们找到新的中间值 14

00:35:02.956 --> 00:35:04.246 A:middle
并将其与我们想要插入的值进行比较

00:35:05.196 --> 00:35:07.546 A:middle
11 小于 14

00:35:07.546 --> 00:35:10.776 A:middle
所以插入点必须在中间值之前

00:35:11.246 --> 00:35:13.676 A:middle
再把剩下的集合部分分成两半

00:35:14.586 --> 00:35:16.976 A:middle
继续将我们观察的集合分成两半

00:35:17.096 --> 00:35:19.626 A:middle
直到我们指向到合适的插入点

00:35:19.966 --> 00:35:20.986 A:middle
这就是我们的解决方案

00:35:22.546 --> 00:35:25.216 A:middle
像这样的分治算法十分出色

00:35:25.556 --> 00:35:27.316 A:middle
因为它们的效率非常高

00:35:27.806 --> 00:35:30.486 A:middle
二进制搜索所需的时间呈对数变化

00:35:30.726 --> 00:35:33.616 A:middle
这意味着把输入的大小加倍

00:35:33.616 --> 00:35:36.436 A:middle
并不会像线性算法一样 使算法的运行慢两倍

00:35:36.436 --> 00:35:38.716 A:middle
对于像二进制搜索

00:35:38.716 --> 00:35:40.646 A:middle
只需要执行一个额外的步骤

00:35:40.646 --> 00:35:44.906 A:middle
就可以再次将问题的规模减半

00:35:44.906 --> 00:35:47.646 A:middle
现在我们把它转换成代码

00:35:48.226 --> 00:35:51.996 A:middle
首先要做的是找到中间元素的索引

00:35:51.996 --> 00:35:55.446 A:middle
我们可以通过一个函数使用

00:35:55.446 --> 00:35:56.746 A:middle
randomAccessCollections 指数偏移

00:35:57.616 --> 00:36:01.716 A:middle
接下来 我们需要检查值是否位于中间元素之前

00:35:57.616 --> 00:36:01.716 A:middle
接下来 我们需要检查值是否位于中间元素之前

00:36:01.956 --> 00:36:05.516 A:middle
所以我们知道了集合的哪一半包含插入点

00:36:06.516 --> 00:36:10.316 A:middle
在我们的示例中要插入的值大于中间的元素

00:36:10.656 --> 00:36:13.766 A:middle
我们从中间值之后的索引中取出集合的一个切片

00:36:13.766 --> 00:36:16.036 A:middle
直到完成

00:36:16.556 --> 00:36:19.616 A:middle
然后递归地调用切片上的排序和插入点

00:36:19.616 --> 00:36:22.936 A:middle
这在分治算法中很常见

00:36:23.126 --> 00:36:26.036 A:middle
也就是减少问题的规模 然后递归

00:36:26.036 --> 00:36:30.116 A:middle
为了使它能够使用 现在我们需要那个切片的语法

00:36:30.116 --> 00:36:32.316 A:middle
为了提供集合中适当的切片

00:36:33.076 --> 00:36:37.846 A:middle
我们可以为所有的集合引入一个
获取一系列索引

00:36:37.846 --> 00:36:41.816 A:middle
并生成切片的通用操作 就像这样

00:36:42.966 --> 00:36:46.086 A:middle
现在请记住我们前面讨论的适配式切片

00:36:46.126 --> 00:36:51.576 A:middle
适用于任何集合 提供基础集合中元素的视图

00:36:51.866 --> 00:36:53.956 A:middle
而基础集合本身就是集合

00:36:54.616 --> 00:36:57.776 A:middle
这就使得 我们的分治算法适用于任何集合

00:36:58.196 --> 00:37:02.186 A:middle
以及为所有集合提供切片语法

00:36:58.196 --> 00:37:02.186 A:middle
以及为所有集合提供切片语法

00:37:02.766 --> 00:37:04.776 A:middle
这的确很棒 但有一个问题

00:37:05.536 --> 00:37:08.786 A:middle
有些集合不需要这种特殊的切片类型

00:37:09.306 --> 00:37:12.226 A:middle
它们真正想要提供自己的切片操作

00:37:12.466 --> 00:37:16.086 A:middle
来产生不同的类型 字符串是最常见的例子

00:37:16.086 --> 00:37:20.406 A:middle
当你切片一个字符串时
你会得到一个子字符串

00:37:21.516 --> 00:37:25.436 A:middle
如果你把分治算法应用到字符串集合中

00:37:25.666 --> 00:37:29.196 A:middle
它们将会是子字符串的形式 而不是其他

00:37:29.196 --> 00:37:32.526 A:middle
字符串切片之类的类型 区间是另一个有趣的例子

00:37:32.526 --> 00:37:35.146 A:middle
因为它的切片操作

00:37:35.376 --> 00:37:40.626 A:middle
返回的将是带有不同的边界
却是相同区间类型的实例

00:37:41.306 --> 00:37:44.766 A:middle
因此 为了在符合集合的不同类型之间

00:37:44.766 --> 00:37:46.676 A:middle
捕获这种变量

00:37:46.676 --> 00:37:51.486 A:middle
我们可以在集合协议中引入新的要求
尤其是切片

00:37:52.396 --> 00:37:58.316 A:middle
因此在这里 我们将切片下标作为要求
引入到集合协议本身中

00:37:59.136 --> 00:38:02.846 A:middle
现在请注意 这个下标的结果类型

00:37:59.136 --> 00:38:02.846 A:middle
现在请注意 这个下标的结果类型

00:38:02.846 --> 00:38:04.216 A:middle
由一个新的关联类型来描述

00:38:04.676 --> 00:38:05.426 A:middle
它就是子序列

00:38:06.886 --> 00:38:10.656 A:middle
现在字符串类型和区间类型
都满足了这些新的集合要求

00:38:10.656 --> 00:38:15.256 A:middle
对于字符串 子序列类型是子字符串

00:38:16.506 --> 00:38:20.166 A:middle
对于区间子序列类型将是区间本身

00:38:20.166 --> 00:38:23.596 A:middle
这对于字符串类型和区间类型来说都很适用

00:38:23.736 --> 00:38:26.856 A:middle
但是对于所有其他不想定制实际的

00:38:26.856 --> 00:38:28.646 A:middle
子序列类型的集合类型而言

00:38:28.646 --> 00:38:31.736 A:middle
我们可以提供切片的默认限制

00:38:32.396 --> 00:38:33.326 A:middle
因此这些集合类型的构建者

00:38:33.326 --> 00:38:37.666 A:middle
实际上不需要做任何额外的工作
来符合这些集合

00:38:37.906 --> 00:38:40.126 A:middle
他们可以免费获得所有的切片行为

00:38:41.056 --> 00:38:42.366 A:middle
那么我们从子序列开始

00:38:42.366 --> 00:38:47.706 A:middle
关联类型本身可以具有默认值

00:38:48.176 --> 00:38:50.036 A:middle
记录在等号的后面

00:38:50.436 --> 00:38:54.156 A:middle
对于子序列来说
适配式切片类型是一个完美的默认类型

00:38:54.156 --> 00:38:56.076 A:middle
因为它适用于所有集合

00:38:56.076 --> 00:38:58.806 A:middle
因此这个默认值将用于

00:38:58.806 --> 00:39:00.736 A:middle
不提供自己的子序列类型的

00:38:58.806 --> 00:39:00.736 A:middle
不提供自己的子序列类型的

00:39:00.736 --> 00:39:02.626 A:middle
任何符合的集合类型

00:39:02.626 --> 00:39:08.446 A:middle
这与前面从切片下标开始的实现匹配得很好

00:39:08.446 --> 00:39:12.326 A:middle
在集合协议的扩展中进行编写

00:39:12.756 --> 00:39:16.336 A:middle
它还可以作为默认的实现

00:39:16.336 --> 00:39:18.946 A:middle
提供返回切片的切片下标操作

00:39:19.886 --> 00:39:21.736 A:middle
我们甚至可以更进一步

00:39:21.946 --> 00:39:25.426 A:middle
在选择默认子序列类型的情况下

00:39:25.426 --> 00:39:29.046 A:middle
限制默认切片下标实现的适用性

00:39:29.046 --> 00:39:34.546 A:middle
因此这种模式可以防止默认实现

00:39:34.546 --> 00:39:36.706 A:middle
显示为对自定义子序列的

00:39:36.706 --> 00:39:39.486 A:middle
集合类型的重载

00:39:39.486 --> 00:39:41.256 A:middle
比如字符串和区间类型

00:39:41.806 --> 00:39:43.666 A:middle
所以这种模式很好地符合了各种类型

00:39:43.916 --> 00:39:45.766 A:middle
它们可以免费得到切片

00:39:45.766 --> 00:39:47.446 A:middle
或者根据需要自定义切片

00:39:48.606 --> 00:39:49.896 A:middle
但请记住我们的目标

00:39:50.256 --> 00:39:52.926 A:middle
我们希望编写出针对集合协议的分治算法

00:39:52.926 --> 00:39:54.416 A:middle
针对集合协议的分治算法

00:39:55.016 --> 00:39:58.116 A:middle
所以我们必须回答一个非常重要的问题

00:39:58.706 --> 00:40:00.596 A:middle
子序列的作用是什么

00:39:58.706 --> 00:40:00.596 A:middle
子序列的作用是什么

00:40:01.266 --> 00:40:04.296 A:middle
关于子序列 我们现在所知道的就是

00:40:04.296 --> 00:40:05.456 A:middle
它是切片下标操作的结果类型

00:40:05.456 --> 00:40:08.666 A:middle
但我们需要了解更多从而真正地使用它

00:40:08.666 --> 00:40:10.816 A:middle
为了回答这个问题

00:40:10.816 --> 00:40:15.196 A:middle
我们必须回顾刚才
我们想要用子序列表示的算法

00:40:15.776 --> 00:40:17.666 A:middle
我们的算法是递归的

00:40:18.186 --> 00:40:22.186 A:middle
它形成一个切片 也就是现在的子序列类型的值

00:40:22.186 --> 00:40:26.856 A:middle
然后递归地调用切片上的排序插入点

00:40:26.856 --> 00:40:32.176 A:middle
只有当返回的子序列类型本身就是一个集合时

00:40:32.176 --> 00:40:35.716 A:middle
它才有意义 当它执行该调用时

00:40:35.916 --> 00:40:39.076 A:middle
我们将传递集合的元素类型的值

00:40:39.666 --> 00:40:45.126 A:middle
但是递归调用本身期望
这个子序列的元素类型的值

00:40:45.816 --> 00:40:49.716 A:middle
唯有这些元素类型相同时算法才有意义

00:40:49.716 --> 00:40:56.196 A:middle
当从递归调用返回一个索引时

00:40:56.196 --> 00:40:58.766 A:middle
也会出现相同的问题 递归调用将由子序列计算

00:40:58.766 --> 00:41:06.406 A:middle
但是返回的索引 也需要是当前集合的有效索引

00:40:58.766 --> 00:41:06.406 A:middle
但是返回的索引 也需要是当前集合的有效索引

00:41:06.766 --> 00:41:10.246 A:middle
我们可以在集合协议中捕获所有这些要求

00:41:10.246 --> 00:41:15.376 A:middle
现在我们要做的第一件事是定义集合的子序列

00:41:15.376 --> 00:41:17.076 A:middle
本身就是一个集合

00:41:17.076 --> 00:41:19.606 A:middle
这就是所谓的“递归约束”

00:41:19.606 --> 00:41:23.626 A:middle
因为关联的类型符合它自己的封闭协议

00:41:23.626 --> 00:41:27.176 A:middle
然后我们可以使用关联类型

00:41:27.176 --> 00:41:30.736 A:middle
where 子句来进一步约束我们的子序列

00:41:31.356 --> 00:41:34.576 A:middle
如前所述它有一个元素类型

00:41:34.576 --> 00:41:38.006 A:middle
这个元素类型需要与原始集合相同

00:41:38.006 --> 00:41:41.656 A:middle
我们可以用同样的类型约束来表示

00:41:41.856 --> 00:41:43.416 A:middle
子序列元素与元素相同

00:41:43.416 --> 00:41:47.466 A:middle
由此也可以推及到索引类型

00:41:48.266 --> 00:41:51.696 A:middle
这些覆盖了我们通过观察算法的

00:41:51.696 --> 00:41:54.926 A:middle
排序插入点的实现而发现的所有属性

00:41:55.076 --> 00:41:58.886 A:middle
这就引出了一个有趣的问题

00:41:58.886 --> 00:42:01.666 A:middle
你能切片一个子序列吗

00:41:58.886 --> 00:42:01.666 A:middle
你能切片一个子序列吗

00:42:02.416 --> 00:42:03.936 A:middle
每个子序列都是一个集合

00:42:03.936 --> 00:42:05.856 A:middle
每个集合都有一个切片操作

00:42:05.856 --> 00:42:09.706 A:middle
因此你当然可以切片一个子序列

00:42:09.986 --> 00:42:14.146 A:middle
结果将是子序列的一个子序列

00:42:15.156 --> 00:42:18.166 A:middle
现在你可以再执行一次得到一个子序列的

00:42:18.166 --> 00:42:19.996 A:middle
一个子序列的一个子序列

00:42:20.566 --> 00:42:22.956 A:middle
如此一直继续下去

00:42:22.956 --> 00:42:28.226 A:middle
有趣的是 在每一点
我们都可以得到一个全新的类型

00:42:28.226 --> 00:42:31.376 A:middle
于是我们就拥有了这个潜在的无尽的模型塔

00:42:31.906 --> 00:42:33.156 A:middle
这实际上很好理解

00:42:33.896 --> 00:42:36.546 A:middle
我们的泛型算法中的每个递归步骤

00:42:36.546 --> 00:42:41.236 A:middle
都可以创建一个基于当前集合类型的新类型

00:42:41.236 --> 00:42:46.166 A:middle
只要递归最终在运行时终止就没有问题

00:42:46.166 --> 00:42:49.116 A:middle
然而 通常情况下

00:42:49.166 --> 00:42:51.646 A:middle
我们可以使分治算法不具备递归特性

00:42:51.646 --> 00:42:53.376 A:middle
从而更有效地实现

00:42:53.376 --> 00:43:01.496 A:middle
这里是算法的排序和插入点的非递归实现

00:42:53.376 --> 00:43:01.496 A:middle
这里是算法的排序和插入点的非递归实现

00:43:02.096 --> 00:43:04.356 A:middle
我们来看看核心的算法并没有不同

00:43:04.356 --> 00:43:09.816 A:middle
但它是用这个 while 循环迭代
而不是递归表示的

00:43:10.536 --> 00:43:11.626 A:middle
所以我们要做的第一件事

00:43:11.626 --> 00:43:14.546 A:middle
就是获取整个集合的一个切片

00:43:15.306 --> 00:43:18.546 A:middle
这个切片变量将表示我们在每次

00:43:18.546 --> 00:43:21.196 A:middle
迭代中看到的集合的一部分

00:43:21.986 --> 00:43:24.726 A:middle
现在我们看到了熟悉的分治模式

00:43:25.226 --> 00:43:26.766 A:middle
找到切片的中间位置

00:43:27.206 --> 00:43:31.836 A:middle
然后将插入值与切片中的中间元素进行比较

00:43:32.616 --> 00:43:34.536 A:middle
然后 在再次进入循环之前

00:43:34.846 --> 00:43:37.986 A:middle
我们通过分割切片来缩小搜索范围

00:43:39.286 --> 00:43:41.246 A:middle
然而 我们碰到了一个问题

00:43:41.556 --> 00:43:46.566 A:middle
我们对切片变量赋值为子序列类型

00:43:46.566 --> 00:43:50.526 A:middle
另一个方面 右边是切片的切片

00:43:50.526 --> 00:43:52.646 A:middle
正如我们之前讨论过的

00:43:53.006 --> 00:43:57.216 A:middle
子序列的子序列可能是一个完全不同的类型

00:43:57.636 --> 00:43:58.556 A:middle
我们会得到一个编译错误

00:43:58.556 --> 00:44:01.496 A:middle
告诉我们这两种类型不一定相同

00:43:58.556 --> 00:44:01.496 A:middle
告诉我们这两种类型不一定相同

00:44:01.496 --> 00:44:04.296 A:middle
这一点很不方便

00:44:04.296 --> 00:44:06.646 A:middle
因为它阻止我们编写这个非递归算法

00:44:06.646 --> 00:44:10.996 A:middle
它并不能真正反映特定集合类型的行为

00:44:10.996 --> 00:44:12.706 A:middle
考虑一下字符串

00:44:13.266 --> 00:44:15.996 A:middle
当你切片一个字符串时
你会得到一个子字符串

00:44:16.446 --> 00:44:18.276 A:middle
如果你切片一个子字符串

00:44:18.276 --> 00:44:20.586 A:middle
你并不会得到子字符串的子字符串

00:44:21.256 --> 00:44:24.296 A:middle
你只会得到子字符串的另一个实例

00:44:25.206 --> 00:44:28.646 A:middle
让我们讨论之前的
这个适配型切片的工作方式

00:44:28.646 --> 00:44:29.816 A:middle
来概括这个概念

00:44:30.306 --> 00:44:32.426 A:middle
我们有一个集合 命名为 Self

00:44:32.776 --> 00:44:34.606 A:middle
并将其分割为 I 到 J 几个切片

00:44:35.536 --> 00:44:37.996 A:middle
现在将构建一个 Self 的类型切片

00:44:37.996 --> 00:44:40.676 A:middle
它只是底层 Self 集合的一个视图

00:44:40.676 --> 00:44:45.276 A:middle
如果我们分割这个切片

00:44:45.276 --> 00:44:47.676 A:middle
我们将得到 Self 的切片的一个切片

00:44:47.866 --> 00:44:50.586 A:middle
它是一个相同的基础 Self 集合上的视图

00:44:50.586 --> 00:44:52.576 A:middle
的一个视图

00:44:52.576 --> 00:44:56.876 A:middle
这就是我们在实践中得到的无限塔

00:44:57.346 --> 00:44:58.956 A:middle
然而也可以不必这样

00:44:58.956 --> 00:45:04.246 A:middle
请记住 切片类型使用与其基础集合

00:44:58.956 --> 00:45:04.246 A:middle
请记住 切片类型使用与其基础集合

00:45:04.246 --> 00:45:07.546 A:middle
相同的索引 它们了解自己的基础集合

00:45:07.546 --> 00:45:11.686 A:middle
所以当我们切片的时候

00:45:11.686 --> 00:45:14.286 A:middle
我们可以取那些新的索引 I2 和 J2

00:45:14.286 --> 00:45:18.766 A:middle
将它们置入原始的基础集合

00:45:18.766 --> 00:45:19.936 A:middle
并从那里形成新的切片

00:45:19.936 --> 00:45:23.946 A:middle
它的作用是 当你分割一个切片的时候

00:45:23.946 --> 00:45:25.436 A:middle
你会得到相同的切片类型

00:45:25.436 --> 00:45:28.746 A:middle
有效地约束了递归

00:45:28.746 --> 00:45:32.946 A:middle
这和子字符串的行为完全一样

00:45:33.246 --> 00:45:38.706 A:middle
并且有理由预想所有子序列类型
都以这种方式运行

00:45:39.026 --> 00:45:43.746 A:middle
让我们将其建模为集合协议需求的
一个显式部分

00:45:44.416 --> 00:45:49.976 A:middle
这里我们定义一个子序列的子序列
和子序列的类型是一样的

00:45:49.976 --> 00:45:55.356 A:middle
换句话说 当你分割切片的时候
你会得到相同类型的切片

00:45:56.326 --> 00:45:59.256 A:middle
这样我们的非递归
分治算法将得以运行

00:45:59.336 --> 00:46:01.286 A:middle
而且简化了集合协议的使用

00:45:59.336 --> 00:46:01.286 A:middle
而且简化了集合协议的使用

00:46:01.286 --> 00:46:06.226 A:middle
不再需要对无尽的类型塔进行推理

00:46:06.226 --> 00:46:10.276 A:middle
最后一个问题 涉及子序列

00:46:10.616 --> 00:46:11.906 A:middle
我们说过它需要是一个集合

00:46:11.906 --> 00:46:14.546 A:middle
但是我们需要子序列类型

00:46:14.546 --> 00:46:16.426 A:middle
是一个随机访问集合

00:46:16.616 --> 00:46:18.826 A:middle
来执行这个索引偏移操作

00:46:18.826 --> 00:46:22.556 A:middle
为了描述这一点

00:46:22.766 --> 00:46:24.456 A:middle
我们可以使用协议 where 子句

00:46:24.846 --> 00:46:28.116 A:middle
因此当 bidirectionalCollection
从集合承继时

00:46:28.386 --> 00:46:32.056 A:middle
它可以在子序列上添加一个新的约束

00:46:32.056 --> 00:46:34.346 A:middle
要求它遵守
bidirectionalCollection 协议

00:46:34.346 --> 00:46:37.136 A:middle
这又是一个递归约束

00:46:37.136 --> 00:46:40.156 A:middle
但现在它在
bidirectionalCollection 协议上表示

00:46:40.156 --> 00:46:42.806 A:middle
对于 randomAccessCollection 也是同理

00:46:42.806 --> 00:46:47.876 A:middle
例如随机访问集合的子序列

00:46:47.876 --> 00:46:50.156 A:middle
其本身也符合
randomAccessCollection

00:46:50.706 --> 00:46:54.566 A:middle
注意子序列的约束是如何遵循封闭协议的

00:46:54.566 --> 00:46:57.106 A:middle
这听起来有点耳熟

00:46:57.106 --> 00:47:02.076 A:middle
递归约束和条件一致性都倾向于像这样

00:46:57.106 --> 00:47:02.076 A:middle
递归约束和条件一致性都倾向于像这样

00:47:02.076 --> 00:47:05.646 A:middle
跟踪协议层级结构 并且这些特性相互支持

00:47:05.646 --> 00:47:07.926 A:middle
这一点特别重要

00:47:07.926 --> 00:47:13.256 A:middle
因为我们希望子序列 也就是 Self 的切片
的默认关联类型

00:47:13.256 --> 00:47:14.666 A:middle
能够适用于集合的每一层级结构

00:47:14.666 --> 00:47:17.356 A:middle
切片总是一个集合

00:47:18.116 --> 00:47:20.386 A:middle
当我们继续创建
bidirectionalCollection 协议时

00:47:20.386 --> 00:47:26.136 A:middle
那么子序列类型也需要符合
bidirectionalCollection

00:47:26.996 --> 00:47:29.026 A:middle
适配式切片与 bidirectionalCollection 的
条件一致性

00:47:29.026 --> 00:47:34.296 A:middle
在任何时候都被认为是
bidirectionalCollection

00:47:34.716 --> 00:47:38.696 A:middle
满足这一要求
RandomAccessCollection 也是如此

00:47:38.696 --> 00:47:42.116 A:middle
子序列获得一个
randomAccessCollection 需求

00:47:42.116 --> 00:47:47.146 A:middle
然后切片与 randomAccessCollection
的条件一致性

00:47:47.146 --> 00:47:49.916 A:middle
将满足该需求
也就是 randomAccessCollection 本身

00:47:49.916 --> 00:47:54.836 A:middle
这种关联类型默认适用于层级结构中的

00:47:54.946 --> 00:47:59.906 A:middle
每个协议的行为指示了一个优秀的内聚设计

00:48:00.726 --> 00:48:03.256 A:middle
如果你发现 你在集合层级结构中的不同位置

00:48:03.256 --> 00:48:05.896 A:middle
需要不同的默认关联类型

00:48:06.216 --> 00:48:07.686 A:middle
那么你的设计可能出现了问题

00:48:08.316 --> 00:48:09.396 A:middle
递归约束是一个强大的工具

00:48:09.396 --> 00:48:13.916 A:middle
协同关联类型以及协议 where 子句

00:48:13.916 --> 00:48:14.996 A:middle
它们帮助我们编写协议需求

00:48:14.996 --> 00:48:17.016 A:middle
从而能够用泛型代码

00:48:17.016 --> 00:48:20.116 A:middle
自然地表达分治算法

00:48:20.596 --> 00:48:23.606 A:middle
现在我们回到 WWDC 演讲的最后一部分

00:48:25.026 --> 00:48:26.506 A:middle
那么 Swift 是一个多范式语言

00:48:26.506 --> 00:48:29.636 A:middle
现在我们一直在专心讲通用型

00:48:29.636 --> 00:48:32.136 A:middle
但是当然了 Swift 也支持面向对象的编程

00:48:32.136 --> 00:48:37.686 A:middle
那么我想花一些时间谈谈这两个功能
之间的相互影响

00:48:37.686 --> 00:48:40.646 A:middle
以及它们如何在 Swift 语言中协同合作

00:48:41.166 --> 00:48:44.546 A:middle
那么对于类继承
我们知道类继承是如何运作的

00:48:44.576 --> 00:48:45.866 A:middle
非常简单

00:48:46.386 --> 00:48:48.386 A:middle
你可以声明一个超类 比如汽车

00:48:48.536 --> 00:48:52.786 A:middle
你可以声明某些子类 比如出租车和警车
它们都继承自汽车

00:48:53.606 --> 00:48:56.466 A:middle
一旦你这么做了
你就拥有了这个面向对象的等级

00:48:56.956 --> 00:48:59.636 A:middle
你期望那些子类可以在哪里使用

00:48:59.636 --> 00:49:04.376 A:middle
那么如果我要用一个新方法扩展汽车

00:48:59.636 --> 00:49:04.376 A:middle
那么如果我要用一个新方法扩展汽车

00:49:04.376 --> 00:49:07.066 A:middle
让它变成驱动器

00:49:07.166 --> 00:49:08.736 A:middle
我非常期待我可以在我的一个子类上

00:49:08.736 --> 00:49:10.086 A:middle
调用那个方法 比如出租车

00:49:11.016 --> 00:49:15.426 A:middle
那么这是面向对象编程中的一个根本方面

00:49:15.756 --> 00:49:18.836 A:middle
Barbara Liskov 其实很好地描述了相关信息

00:49:18.836 --> 00:49:20.106 A:middle
在 80 年代的一场演讲中

00:49:20.846 --> 00:49:23.656 A:middle
自那时起 我们就把这个叫做 Liskov 替换原则

00:49:23.656 --> 00:49:25.856 A:middle
理念其实很简单

00:49:25.856 --> 00:49:28.986 A:middle
那么如果你的程序中有一些地方

00:49:28.986 --> 00:49:34.246 A:middle
引用了一个超类型或超类 比如汽车

00:49:34.376 --> 00:49:37.316 A:middle
你就应该可以获取它的子类型

00:49:37.316 --> 00:49:39.056 A:middle
或子类的任意实例

00:49:39.056 --> 00:49:44.346 A:middle
比如出租车或汽车子类 并使用它

00:49:44.806 --> 00:49:47.996 A:middle
程序应该仍然继续监测类型 并正常运行

00:49:48.746 --> 00:49:51.226 A:middle
那么这里的替换是作为子类的实例

00:49:51.226 --> 00:49:53.756 A:middle
应该可以去到子类所能去到的任何地方

00:49:53.756 --> 00:49:56.476 A:middle
这是一个很简单的原则

00:49:56.476 --> 00:50:00.026 A:middle
我们把它内在化了 但它仍然很强大

00:49:56.476 --> 00:50:00.026 A:middle
我们把它内在化了 但它仍然很强大

00:50:00.586 --> 00:50:03.346 A:middle
如果你思考一下的话
请考虑你程序中的任何一点

00:50:03.346 --> 00:50:05.906 A:middle
如果我得到一个不同的子类 会发生什么

00:50:05.906 --> 00:50:07.086 A:middle
也许是一个我没有想到的子类？

00:50:07.086 --> 00:50:11.786 A:middle
那么返回到通用型

00:50:12.756 --> 00:50:15.906 A:middle
当在通用型系统上应用 Liskov 替换原则时

00:50:15.906 --> 00:50:18.326 A:middle
我们期待什么呢？

00:50:18.976 --> 00:50:21.126 A:middle
也许我们添加了一个新协议 可驾驶

00:50:21.426 --> 00:50:25.146 A:middle
无论是什么 并把汽车扩展为可驾驶

00:50:25.496 --> 00:50:26.786 A:middle
我们期待发生什么呢？

00:50:26.786 --> 00:50:29.066 A:middle
我们期待你可以使用协议一致性

00:50:29.066 --> 00:50:32.436 A:middle
把汽车的一致性 用于可驾驶的一致性

00:50:32.436 --> 00:50:33.626 A:middle
并用在它的某些子类上

00:50:34.616 --> 00:50:38.316 A:middle
比如你在可驾驶协议中添加了一个

00:50:38.316 --> 00:50:39.966 A:middle
简单的通用算法 比如 sundayDrive

00:50:40.386 --> 00:50:44.476 A:middle
现在你应该可以在警车上使用
那个 API 了

00:50:44.956 --> 00:50:46.116 A:middle
即使这并不是最好的方式

00:50:46.116 --> 00:50:52.096 A:middle
那么子类有效地继承了协议一致性

00:50:52.306 --> 00:50:55.906 A:middle
并且这在一致性上添加了约束

00:50:55.906 --> 00:50:59.446 A:middle
你所写的那个一致性 就是让汽车可驾驶的东西

00:50:59.866 --> 00:51:06.416 A:middle
现在必须适用于汽车的全部子类
以及稍后出现的子类

00:50:59.866 --> 00:51:06.416 A:middle
现在必须适用于汽车的全部子类
以及稍后出现的子类

00:51:06.416 --> 00:51:09.916 A:middle
大部分时候就是有用

00:51:09.916 --> 00:51:12.586 A:middle
然而在某些情况下

00:51:12.586 --> 00:51:16.086 A:middle
它会在子类上添加一些新要求

00:51:16.726 --> 00:51:20.266 A:middle
最常见的就是
当处理初始化程序要求时

00:51:20.266 --> 00:51:25.316 A:middle
那么如果你查看了可解协议

00:51:25.316 --> 00:51:26.286 A:middle
它有一个有趣的要求

00:51:26.286 --> 00:51:31.036 A:middle
就是初始化程序要求从解码器中
创建符合型的新实例

00:51:31.616 --> 00:51:35.156 A:middle
我们要如何使用它呢？

00:51:35.506 --> 00:51:37.746 A:middle
让我们继续向可解协议中
添加一个便捷方法

00:51:37.746 --> 00:51:40.366 A:middle
它是一个静态方法解码

00:51:40.516 --> 00:51:41.646 A:middle
从解码器中生成新实例

00:51:41.646 --> 00:51:44.166 A:middle
其实就是初始化程序的一个包装
让它简单易用

00:51:44.166 --> 00:51:49.376 A:middle
关于这个特定的方法
你需要注意两个有意思的事情

00:51:49.376 --> 00:51:53.456 A:middle
首先它是否一个带大写字母 S 的 Self

00:51:53.456 --> 00:51:54.736 A:middle
请记住这是一致性类型

00:51:54.766 --> 00:51:58.526 A:middle
它与你在静态方法上调用的类型相同

00:52:00.136 --> 00:52:03.006 A:middle
现在第二件有意思的事是 我们要如何实施它？

00:52:03.006 --> 00:52:04.956 A:middle
我们调用上边那个初始化程序

00:52:04.956 --> 00:52:07.206 A:middle
来创建一个全新的实例

00:52:07.206 --> 00:52:12.516 A:middle
是我们所拥有的可解码类型的实例 然后返回它

00:52:12.516 --> 00:52:15.326 A:middle
很公平

00:52:16.146 --> 00:52:18.466 A:middle
我们可以继续并让汽车类型可解码

00:52:19.426 --> 00:52:22.776 A:middle
然后我们期待当应用 Liskov 替换原理时

00:52:22.776 --> 00:52:26.426 A:middle
我们可以使用汽车的任意子类

00:52:27.146 --> 00:52:29.176 A:middle
带有我们通过协议一致性 创建的这些新 API

00:52:29.176 --> 00:52:32.806 A:middle
那么我们可以在出租车子类上调用解码

00:52:33.486 --> 00:52:35.726 A:middle
而我们得到的不是汽车 也不是任意汽车实例

00:52:35.726 --> 00:52:39.076 A:middle
而是出租车 出租车的实例

00:52:40.476 --> 00:52:41.846 A:middle
很棒 但应该如何使用它？

00:52:41.846 --> 00:52:45.496 A:middle
让我们看看出租车会包含什么？

00:52:45.496 --> 00:52:47.296 A:middle
也许这里有一个按小时计费的工具

00:52:47.356 --> 00:52:51.496 A:middle
当我们调用 Taxi.decode(from:) 时

00:52:51.496 --> 00:52:53.856 A:middle
我们就会通过协议 通过协议初始化程序要求

00:52:53.856 --> 00:52:58.096 A:middle
它其实只能调用一个初始化程序

00:52:58.096 --> 00:53:02.266 A:middle
就是在汽车类内部声明的初始化程序

00:52:58.096 --> 00:53:02.266 A:middle
就是在汽车类内部声明的初始化程序

00:53:03.176 --> 00:53:08.306 A:middle
在这里的超类中 那么那个初始化工具

00:53:08.306 --> 00:53:09.746 A:middle
它知道如何解码汽车的全部状态

00:53:09.866 --> 00:53:12.366 A:middle
但它并不了解出租车子类

00:53:12.366 --> 00:53:16.786 A:middle
那么如果我们要直接使用这个初始化程序

00:53:16.786 --> 00:53:18.126 A:middle
我们会产生一个问题

00:53:18.126 --> 00:53:21.116 A:middle
hourlyRate 完全未被初始化

00:53:21.116 --> 00:53:23.556 A:middle
那会导致一些更不幸的误解

00:53:23.556 --> 00:53:27.476 A:middle
当你在最后得到账单时 我们该如何解决这个？

00:53:27.626 --> 00:53:30.626 A:middle
看起来 Swift 不会让你陷入这个问题中

00:53:31.416 --> 00:53:34.426 A:middle
它会在你尝试让汽车遵循可解码协议时进行判断

00:53:34.426 --> 00:53:37.466 A:middle
是指那个初始化程序中 有问题的可解码协议

00:53:37.466 --> 00:53:41.006 A:middle
它应该被标记为必需

00:53:42.836 --> 00:53:46.306 A:middle
现在必须在全部超类中实施所必需的初始化程序

00:53:46.306 --> 00:53:52.276 A:middle
不仅仅是直接的超类 而是任意一个超类

00:53:52.276 --> 00:53:54.426 A:middle
以及你现在还不知道的将来可能会出现的超类

00:53:55.846 --> 00:53:59.936 A:middle
现在通过添加那个要求
意味着当出租车从汽车中继承时

00:53:59.996 --> 00:54:05.086 A:middle
它还需要引入一个
拥有相同名称的初始化程序

00:53:59.996 --> 00:54:05.086 A:middle
它还需要引入一个
拥有相同名称的初始化程序

00:54:05.086 --> 00:54:07.966 A:middle
现在这非常重要

00:54:07.966 --> 00:54:11.556 A:middle
因为这个初始化程序负责解码 hourlyRate

00:54:11.556 --> 00:54:16.886 A:middle
然后锁住超类初始化程序
以便解码剩余的汽车类型

00:54:18.746 --> 00:54:21.006 A:middle
好的

00:54:21.006 --> 00:54:22.756 A:middle
现在如果你快速阅读了那些红色方框

00:54:22.916 --> 00:54:26.006 A:middle
你可能会注意到子短语并不是最终

00:54:26.836 --> 00:54:30.456 A:middle
那么从定义上说最终类没有子类

00:54:30.456 --> 00:54:33.866 A:middle
因此从本质上说它稍后会让它们免于替换

00:54:35.046 --> 00:54:39.056 A:middle
意思是拥有一个必需初始化程序没有意义

00:54:39.056 --> 00:54:40.136 A:middle
因为你知道那儿没有子类

00:54:40.136 --> 00:54:43.896 A:middle
因此最终类用起来稍微简单点儿

00:54:43.896 --> 00:54:45.806 A:middle
当处理诸如可解码或其它初始化程序要求方面

00:54:45.806 --> 00:54:48.446 A:middle
因为它们不需遵循这些规则

00:54:48.446 --> 00:54:53.766 A:middle
即拥有必需初始化程序 那么当你用类引用语义时

00:54:53.766 --> 00:54:57.936 A:middle
考虑使用最终类

00:54:57.936 --> 00:54:59.316 A:middle
当你不再需要自定义类时

00:54:59.316 --> 00:55:01.236 A:middle
通过集成机制

00:54:59.316 --> 00:55:01.236 A:middle
通过集成机制

00:55:01.236 --> 00:55:03.866 A:middle
现在这并不意味着

00:55:04.246 --> 00:55:05.336 A:middle
你稍后不能自定义你的类

00:55:05.336 --> 00:55:07.046 A:middle
你仍然可以在类上写扩展

00:55:07.046 --> 00:55:09.776 A:middle
与你扩展结构或枚举的方式一样

00:55:10.626 --> 00:55:13.066 A:middle
你还可以给它添加一致性
以获取更加动态的调遣

00:55:13.066 --> 00:55:17.156 A:middle
但最终类可以通过通用系统简化相互作用

00:55:17.156 --> 00:55:18.576 A:middle
也会解锁在运行时间内

00:55:18.576 --> 00:55:20.836 A:middle
优化编译器的机会

00:55:24.396 --> 00:55:26.196 A:middle
我们今天谈了谈 Swift 的通用型

00:55:27.966 --> 00:55:29.706 A:middle
Swift 通用型背后的理念
是提供重复使用代码的能力

00:55:29.706 --> 00:55:31.606 A:middle
同时保持静态类型信息

00:55:31.606 --> 00:55:36.076 A:middle
使得写正确的程序变得较为简单

00:55:36.076 --> 00:55:38.976 A:middle
并把这些有效地编译到执行程序中

00:55:39.726 --> 00:55:43.826 A:middle
当你设计协议时 让这个进行拉锯战

00:55:43.826 --> 00:55:46.246 A:middle
在你想要写的协议的通用算法之间

00:55:46.246 --> 00:55:49.466 A:middle
并且一致性类型需要实施那个协议

00:55:49.736 --> 00:55:52.506 A:middle
以便指导你的设计成为一个有意义的提取

00:55:53.636 --> 00:55:55.266 A:middle
引入协议继承

00:55:55.516 --> 00:55:59.996 A:middle
当你需要更多特定功能来实施新的通用算法时

00:56:00.216 --> 00:56:03.626 A:middle
只有一致性类型的子集支持那些算法

00:56:04.726 --> 00:56:06.116 A:middle
还有条件一致性

00:56:06.446 --> 00:56:11.046 A:middle
当你写通用类型时 以便它们可以编写得很漂亮

00:56:11.046 --> 00:56:13.686 A:middle
尤其是当与协议继承一起使用时

00:56:14.456 --> 00:56:18.126 A:middle
最后 当你针对棘手的相互作用产生疑问时

00:56:18.126 --> 00:56:19.976 A:middle
在类继承和通用系统之间

00:56:20.536 --> 00:56:23.306 A:middle
返回到 Liskov 替换原理

00:56:23.306 --> 00:56:26.036 A:middle
思考一下这里发生了什么

00:56:26.036 --> 00:56:27.866 A:middle
如果我引入子类而不是超类

00:56:27.866 --> 00:56:30.406 A:middle
我在子类而非超类上写了一个一致性

00:56:32.576 --> 00:56:37.536 A:middle
非常感谢 还有一些关于拥抱算法的相关演讲

00:56:37.536 --> 00:56:39.706 A:middle
你可以了解它们会如何帮助你创建更好的代码

00:56:39.976 --> 00:56:43.296 A:middle
以及如何在你的日常编程中
有效地使用 Swift 集合

00:56:43.296 --> 00:56:45.536 A:middle
谢谢

00:56:46.508 --> 00:56:48.508 A:middle
[ 掌声 ]
