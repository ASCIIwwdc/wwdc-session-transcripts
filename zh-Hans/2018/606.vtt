WEBVTT

00:00:17.084 --> 00:00:21.221 align:middle line:0
（Metal光线追踪加速技术
演讲606）

00:00:23.590 --> 00:00:24.625 align:middle line:-1
嗨 各位

00:00:25.092 --> 00:00:28.128 align:middle line:-2
我是Sean James
是GPU软件工程师

00:00:28.695 --> 00:00:30.964 align:middle line:-1
今天 我们将会讨论光线追踪技术

00:00:31.465 --> 00:00:33.333 align:middle line:-1
你们可能已经在“国情咨文”中

00:00:33.400 --> 00:00:36.036 align:middle line:-2
看过我们的光线追踪演示
而且想要了解更多

00:00:36.770 --> 00:00:39.473 align:middle line:-2
也许你们想要在自己的app中
使用光线追踪技术

00:00:40.007 --> 00:00:44.011 align:middle line:-2
今天 我将会介绍
如何在app中使用光线追踪

00:00:44.144 --> 00:00:47.514 align:middle line:-2
以及如何使用Metal
在GPU上进行加速

00:00:48.549 --> 00:00:51.285 align:middle line:-2
特别会介绍如何
使用Metal性能着色器

00:00:52.586 --> 00:00:56.323 align:middle line:-2
Metal性能着色器
是一个GPU计算基元

00:00:56.456 --> 00:00:59.760 align:middle line:-2
已经针对所有iOS
和macOS设备进行优化

00:01:00.961 --> 00:01:03.463 align:middle line:-1
MPS内置图像处理

00:01:03.664 --> 00:01:05.866 align:middle line:-1
线性代数和机器学习支持功能

00:01:06.800 --> 00:01:10.337 align:middle line:-2
在前面的演讲里
我们大量讨论了这些主题

00:01:11.305 --> 00:01:14.241 align:middle line:-1
今年 我们还增加了训练支持功能

00:01:14.908 --> 00:01:17.444 align:middle line:-1
关于这个主题 明天会有一个演讲

00:01:18.345 --> 00:01:19.213 align:middle line:-1
今天…

00:01:19.279 --> 00:01:22.916 align:middle line:-2
我将会介绍今年我们
为光线追踪添加的新支持功能

00:01:23.750 --> 00:01:25.953 align:middle line:-2
那么我们首先要问
什么是光线追踪？

00:01:27.788 --> 00:01:30.891 align:middle line:-2
光线追踪app的基本原理是
在光线与场景互动时

00:01:30.958 --> 00:01:33.594 align:middle line:-1
追踪光线的路径

00:01:34.561 --> 00:01:37.931 align:middle line:-2
光线可以建模光照、声音
和其他形式的能量

00:01:38.498 --> 00:01:42.503 align:middle line:-1
光线追踪在渲染、音频

00:01:42.569 --> 00:01:43.837 align:middle line:-1
和物理仿真方面均有应用

00:01:44.872 --> 00:01:47.875 align:middle line:-1
但是光线也可以表示更抽象的概念

00:01:47.941 --> 00:01:50.377 align:middle line:-2
比如是否可以从一个点
看到另一个点

00:01:51.278 --> 00:01:54.181 align:middle line:-1
因此光线追踪还可以应用于冲撞检测

00:01:54.248 --> 00:01:56.817 align:middle line:-1
人工智能和路径寻找

00:01:57.951 --> 00:02:00.654 align:middle line:-1
但是今天我将会以渲染为例

00:01:57.951 --> 00:02:00.654 align:middle line:-1
但是今天我将会以渲染为例

00:02:00.721 --> 00:02:03.190 align:middle line:-1
讲述如何在app中使用光线追踪

00:02:05.125 --> 00:02:07.694 align:middle line:-1
你们可以已经熟悉光栅化管道程序

00:02:08.328 --> 00:02:09.696 align:middle line:-1
光栅化工作原理是

00:02:09.763 --> 00:02:12.900 align:middle line:-1
一次将一个三角形投影到屏幕上

00:02:13.133 --> 00:02:15.035 align:middle line:-1
并且投射相应像素点的阴影

00:02:15.669 --> 00:02:18.639 align:middle line:-2
在GPU硬件中
可以很快地实现此效果

00:02:18.839 --> 00:02:20.274 align:middle line:-1
因此很多游戏和其他实时app

00:02:20.340 --> 00:02:22.643 align:middle line:-1
都选择使用此方法

00:02:24.244 --> 00:02:25.412 align:middle line:-1
但是光栅化模型

00:02:25.946 --> 00:02:29.049 align:middle line:-1
难以模拟光线的特定物理行为

00:02:30.784 --> 00:02:32.386 align:middle line:-1
其中一个例子是反射

00:02:33.053 --> 00:02:34.188 align:middle line:-1
在光栅化方法中

00:02:34.254 --> 00:02:37.124 align:middle line:-1
反射通常是使用近似方法实现的

00:02:37.191 --> 00:02:39.693 align:middle line:-2
例如立方体贴图
屏幕空间反射

00:02:40.627 --> 00:02:41.628 align:middle line:-1
但使用光线追踪器

00:02:41.695 --> 00:02:44.464 align:middle line:-2
我们可以直接计算
精确的反射效果

00:02:45.866 --> 00:02:47.401 align:middle line:-1
另一个例子是阴影

00:02:48.168 --> 00:02:49.269 align:middle line:-1
在光栅化方法中

00:02:49.336 --> 00:02:51.972 align:middle line:-2
通常使用阴影贴图
来实现阴影效果

00:02:52.472 --> 00:02:54.007 align:middle line:-1
但是在实施会遇到一些问题

00:02:54.074 --> 00:02:56.944 align:middle line:-1
比如偏差和分辨率问题

00:02:57.744 --> 00:02:58.612 align:middle line:-1
此外

00:02:58.779 --> 00:03:02.549 align:middle line:-2
软阴影贴图技术
会产生不均匀的软阴影

00:02:58.779 --> 00:03:02.549 align:middle line:-2
软阴影贴图技术
会产生不均匀的软阴影

00:03:03.717 --> 00:03:04.818 align:middle line:-1
利用光线追踪技术

00:03:04.985 --> 00:03:08.388 align:middle line:-2
我们可以直接计算
确定点是否在阴影之中

00:03:08.822 --> 00:03:10.490 align:middle line:-1
因此可以生成清晰的阴影

00:03:10.757 --> 00:03:13.994 align:middle line:-1
包括在物体之间的距离增大时

00:03:14.061 --> 00:03:16.163 align:middle line:-1
生成从硬到软的真实阴影过渡效果

00:03:18.532 --> 00:03:20.834 align:middle line:-1
最后一个例子是球形淡出

00:03:22.202 --> 00:03:24.838 align:middle line:-2
它模拟光线在场景表面上的
淡出效果

00:03:25.706 --> 00:03:29.476 align:middle line:-2
使用光栅化方法
很难实现球形淡出效果

00:03:29.743 --> 00:03:32.613 align:middle line:-2
但是使用光线追踪器
却可以进行十分自然的建模

00:03:33.013 --> 00:03:35.516 align:middle line:-1
事实上 许多游戏和实时app

00:03:35.582 --> 00:03:37.718 align:middle line:-1
都包含球形淡出效果组件

00:03:37.985 --> 00:03:40.454 align:middle line:-2
这些组件使用光线追踪器
进行预计算

00:03:40.621 --> 00:03:42.422 align:middle line:-1
然后将结果存储到材质之中

00:03:42.556 --> 00:03:45.192 align:middle line:-1
在运行时映射到几何形状上

00:03:47.327 --> 00:03:50.797 align:middle line:-2
当然 我们还可以使用
光线追踪器模拟许多其他效果

00:03:50.864 --> 00:03:54.801 align:middle line:-2
例如环境光遮蔽
折射和面光源

00:03:55.169 --> 00:03:58.238 align:middle line:-2
以及摄像机效果
例如景深和运动模糊

00:03:59.573 --> 00:04:01.375 align:middle line:-1
因此 光线追踪技术被用于

00:03:59.573 --> 00:04:01.375 align:middle line:-1
因此 光线追踪技术被用于

00:04:01.441 --> 00:04:04.511 align:middle line:-1
许多高真实性离线渲染app

00:04:05.879 --> 00:04:07.381 align:middle line:-1
光线追踪技术的不足之处是

00:04:07.447 --> 00:04:09.583 align:middle line:-1
相比于光栅化方法

00:04:09.650 --> 00:04:10.751 align:middle line:-1
它需要明显更多的计算资源

00:04:10.984 --> 00:04:12.386 align:middle line:-1
因为需要进行更多的计算

00:04:12.452 --> 00:04:13.787 align:middle line:-1
来模拟这些效果

00:04:15.088 --> 00:04:16.356 align:middle line:-1
让我们来详细了解

00:04:16.423 --> 00:04:18.492 align:middle line:-1
光线追踪器的渲染原理

00:04:18.559 --> 00:04:21.060 align:middle line:-2
然后了解如何
使用Metal进行加速

00:04:23.597 --> 00:04:25.532 align:middle line:-1
我们使用名为路径追踪的算法

00:04:26.500 --> 00:04:29.403 align:middle line:-2
在现实世界中
光源发射光子

00:04:29.570 --> 00:04:32.873 align:middle line:-2
它们在周围反射
直到进入摄像机或你的眼睛

00:04:33.907 --> 00:04:37.077 align:middle line:-2
但是大多数光子
实际上并没有进入摄像机

00:04:37.377 --> 00:04:39.580 align:middle line:-1
因此模拟效率非常低

00:04:40.547 --> 00:04:41.515 align:middle line:-1
幸运的是…

00:04:41.782 --> 00:04:44.718 align:middle line:-2
根据光线的属性
我们可以进行反向推理

00:04:44.785 --> 00:04:46.153 align:middle line:-1
从摄像机开始

00:04:47.187 --> 00:04:51.892 align:middle line:-2
我们将光线从摄像机
投射到场景之中

00:04:53.460 --> 00:04:55.863 align:middle line:-1
然后计算交叉点的阴影

00:04:56.797 --> 00:04:58.198 align:middle line:-1
在生成阴影时 需要明白

00:04:58.265 --> 00:05:00.767 align:middle line:-1
多少光线到达阴影点

00:04:58.265 --> 00:05:00.767 align:middle line:-1
多少光线到达阴影点

00:05:01.235 --> 00:05:04.705 align:middle line:-2
以及哪一部分的光线
反射到摄像机

00:05:05.572 --> 00:05:08.809 align:middle line:-2
实际上有两个光源
我们将会分别讨论

00:05:10.777 --> 00:05:12.679 align:middle line:-1
第一个光源是直射光线

00:05:13.213 --> 00:05:14.982 align:middle line:-1
此光线从光源

00:05:15.048 --> 00:05:17.017 align:middle line:-1
直接到达阴影点

00:05:18.218 --> 00:05:21.388 align:middle line:-2
我们可以轻松地计算出
多少光线会直接到达

00:05:21.455 --> 00:05:24.525 align:middle line:-2
以及哪一部分光线
会反射到摄像机

00:05:25.158 --> 00:05:26.159 align:middle line:-1
我们需要做的是

00:05:26.226 --> 00:05:29.096 align:middle line:-1
在将光线添加到图像之前

00:05:29.162 --> 00:05:31.164 align:middle line:-1
检查阴影点是否位于阴影之中

00:05:32.566 --> 00:05:35.569 align:middle line:-2
为此 我们可以从阴影点位置
朝向光源

00:05:35.636 --> 00:05:37.738 align:middle line:-1
投射更多阴影光线

00:05:39.006 --> 00:05:41.775 align:middle line:-1
如果阴影光线不能到达光源

00:05:41.842 --> 00:05:44.044 align:middle line:-2
那么原始阴影点
就位于阴影之中

00:05:44.278 --> 00:05:46.446 align:middle line:-1
我们不应该为图像添加光照效果

00:05:48.916 --> 00:05:51.218 align:middle line:-1
另一个光源是非直射光线

00:05:52.085 --> 00:05:54.288 align:middle line:-2
这是场景中
在到达阴影点之前

00:05:54.354 --> 00:05:56.857 align:middle line:-1
从其他表面反射的光线

00:05:57.991 --> 00:05:59.493 align:middle line:-1
为了收集非直射光线

00:05:59.560 --> 00:06:02.329 align:middle line:-2
我们可以从阴影点
朝向随机方向

00:05:59.560 --> 00:06:02.329 align:middle line:-2
我们可以从阴影点
朝向随机方向

00:06:02.396 --> 00:06:03.597 align:middle line:-1
投射二次光线

00:06:04.631 --> 00:06:08.402 align:middle line:-2
然后我们在第二个交叉点
重复阴影效果流程

00:06:09.903 --> 00:06:12.940 align:middle line:-1
首先计算多少光线

00:06:13.006 --> 00:06:14.708 align:middle line:-1
直接到达第二个交叉点

00:06:15.042 --> 00:06:17.477 align:middle line:-2
以及哪一部分光线
会被反射回来

00:06:17.544 --> 00:06:19.446 align:middle line:-1
朝向前一个交叉点

00:06:19.746 --> 00:06:21.849 align:middle line:-1
最终进入摄像机

00:06:22.916 --> 00:06:24.918 align:middle line:-1
我们需要从二次交叉点

00:06:24.985 --> 00:06:26.820 align:middle line:-1
投射另一束阴影光线

00:06:28.989 --> 00:06:31.658 align:middle line:-1
我们可以多次重复这个过程

00:06:31.892 --> 00:06:33.861 align:middle line:-1
以模拟场景中的光线反射

00:06:36.964 --> 00:06:39.099 align:middle line:-2
现在 为了获得
这些美观的软阴影

00:06:39.166 --> 00:06:40.601 align:middle line:-1
和反射光线效果…

00:06:41.134 --> 00:06:43.937 align:middle line:-1
对于路径上的每个点

00:06:44.004 --> 00:06:45.372 align:middle line:-2
我们都需要投射许多阴影光线
和二次光线

00:06:46.507 --> 00:06:49.576 align:middle line:-1
反射光线数量

00:06:49.643 --> 00:06:50.911 align:middle line:-1
将会呈指数增长

00:06:51.912 --> 00:06:53.647 align:middle line:-1
为了避免这种指数增长

00:06:54.414 --> 00:06:56.316 align:middle line:-1
我们只会选一条阴影光线

00:06:56.383 --> 00:06:58.919 align:middle line:-2
和每次反射时的
一个二次光线方向

00:07:00.087 --> 00:07:02.122 align:middle line:-1
这时图像中有很多噪讯

00:07:02.589 --> 00:07:05.526 align:middle line:-2
但是我们可以通过多帧叠加
使图像变得均匀

00:07:06.260 --> 00:07:09.129 align:middle line:-2
每个帧将会生成
自己的一次光线集合

00:07:09.196 --> 00:07:12.499 align:middle line:-1
因此我们能够实施摄像机效果

00:07:12.566 --> 00:07:14.401 align:middle line:-1
例如景深和运动模糊

00:07:16.570 --> 00:07:18.572 align:middle line:-2
让我们将这些过程
转换成为一个流程图

00:07:20.007 --> 00:07:21.909 align:middle line:-1
首先 我们生成一次光线

00:07:22.910 --> 00:07:24.811 align:middle line:-1
然后找到场景中的交叉点

00:07:26.313 --> 00:07:28.849 align:middle line:-1
计算交叉点位置的阴影

00:07:28.982 --> 00:07:31.218 align:middle line:-1
请记住 这是一个迭代过程

00:07:31.285 --> 00:07:34.188 align:middle line:-1
将会产生更多的阴影和二次光线

00:07:34.254 --> 00:07:36.290 align:middle line:-2
将会在场景中
再次产生交叉点

00:07:36.890 --> 00:07:38.525 align:middle line:-1
最后 将阴影颜色

00:07:38.592 --> 00:07:39.660 align:middle line:-1
写入图像

00:07:40.961 --> 00:07:43.297 align:middle line:-1
这是渲染app的流程

00:07:43.630 --> 00:07:45.399 align:middle line:-1
但是 大量的时间

00:07:45.465 --> 00:07:48.268 align:middle line:-2
实际上被花费在
光线三角形交叉测试上

00:07:49.403 --> 00:07:51.705 align:middle line:-1
这意味着 交叉区的渲染性能

00:07:51.772 --> 00:07:54.608 align:middle line:-1
对总体渲染性能有很大的影响

00:07:54.675 --> 00:07:57.411 align:middle line:-1
即使它与实际光照和阴影无关

00:07:58.478 --> 00:08:00.280 align:middle line:-1
这个核心交叉问题

00:07:58.478 --> 00:08:00.280 align:middle line:-1
这个核心交叉问题

00:08:00.347 --> 00:08:02.916 align:middle line:-2
是所有光线追踪app
都会面临的问题

00:08:04.785 --> 00:08:07.821 align:middle line:-2
因此我们决定
解决这个核心交叉问题

00:08:08.088 --> 00:08:10.924 align:middle line:-1
以实现高水平的交叉区性能

00:08:11.091 --> 00:08:13.193 align:middle line:-1
并且专注于app的细节

00:08:14.728 --> 00:08:15.562 align:middle line:-1
为此 今年

00:08:15.629 --> 00:08:18.398 align:middle line:-2
我们引入了
MPSRayIntersector API

00:08:19.633 --> 00:08:22.970 align:middle line:-2
这个API加速
所有macOS设备

00:08:23.136 --> 00:08:24.238 align:middle line:-1
和iOs设备的

00:08:24.571 --> 00:08:27.107 align:middle line:-1
GPU上的光线三角线交叉测试

00:08:28.542 --> 00:08:31.345 align:middle line:-2
我们希望这个API能够
很容易地集成到现有app之中

00:08:31.478 --> 00:08:33.746 align:middle line:-2
因此我们通过Metal缓冲区
简单地接收光线

00:08:34.648 --> 00:08:37.351 align:middle line:-2
MPS将会沿每条光线
寻找最近的交叉点

00:08:37.885 --> 00:08:39.953 align:middle line:-2
然后在另一个Metal缓冲区中
返回结果

00:08:40.754 --> 00:08:41.889 align:middle line:-1
你只需要

00:08:42.389 --> 00:08:45.392 align:middle line:-2
在app中提供
一个Metal指令缓冲区

00:08:45.459 --> 00:08:47.561 align:middle line:-2
在这个缓冲区中
执行交叉测试

00:08:47.928 --> 00:08:49.763 align:middle line:-1
我们会将所有交叉测试工作

00:08:49.830 --> 00:08:51.298 align:middle line:-1
编码到指令缓冲区中

00:08:52.766 --> 00:08:55.335 align:middle line:-2
让我们来更深入地分析
我们想要解决的问题

00:08:59.706 --> 00:09:00.541 align:middle line:-1
好的

00:08:59.706 --> 00:09:00.541 align:middle line:-1
好的

00:09:01.742 --> 00:09:05.179 align:middle line:-2
3D模型通常表示为
三角形阵列

00:09:06.079 --> 00:09:08.949 align:middle line:-2
我们需要做的事情是
搜索这些三角形

00:09:09.149 --> 00:09:11.652 align:middle line:-2
找出哪些三角形
与每条光线交叉

00:09:12.920 --> 00:09:14.555 align:middle line:-1
此外 我们需要分析

00:09:14.688 --> 00:09:17.591 align:middle line:-2
哪些交叉点最接近
光线的起点

00:09:19.126 --> 00:09:20.761 align:middle line:-1
最简单的方法是

00:09:20.961 --> 00:09:22.896 align:middle line:-1
循环遍历所有三角形

00:09:22.963 --> 00:09:24.698 align:middle line:-1
检查光线的交叉点

00:09:25.332 --> 00:09:28.735 align:middle line:-2
但是 即使是最小的场景
这个过程也会非常慢

00:09:29.903 --> 00:09:33.740 align:middle line:-2
因此 我们创建了一个数据结构
名为“加速结构”

00:09:34.675 --> 00:09:35.742 align:middle line:-1
加速结构的工作原理

00:09:35.809 --> 00:09:39.146 align:middle line:-2
是递归地将场景划分为
多个三角形组

00:09:39.213 --> 00:09:41.148 align:middle line:-2
组中的三角形
在空间中相互邻近

00:09:42.482 --> 00:09:44.618 align:middle line:-1
当需要将一条光线与场景交叉时

00:09:45.118 --> 00:09:47.654 align:middle line:-1
将光线与树中的边界方框进行交叉

00:09:48.355 --> 00:09:51.992 align:middle line:-2
如果光线未与边界方框交叉
就可以跳过整个子树

00:09:53.093 --> 00:09:54.661 align:middle line:-1
最后 我们只需要

00:09:54.728 --> 00:09:56.396 align:middle line:-1
检查一小部分的三角形

00:09:56.463 --> 00:09:57.931 align:middle line:-1
以确定光线交叉

00:09:59.066 --> 00:10:00.100 align:middle line:-1
我们主要使用这方法

00:09:59.066 --> 00:10:00.100 align:middle line:-1
我们主要使用这方法

00:10:00.167 --> 00:10:02.035 align:middle line:-1
加速光线三角形交叉检查

00:10:03.303 --> 00:10:05.539 align:middle line:-1
当然 这是一个简单的例子

00:10:06.106 --> 00:10:07.107 align:middle line:-1
在实际场景中

00:10:07.174 --> 00:10:09.843 align:middle line:-1
加速结构可能会更加复杂

00:10:11.378 --> 00:10:14.581 align:middle line:-1
从这个图示中 我们可以看出

00:10:14.648 --> 00:10:16.984 align:middle line:-2
加速结构正在适应
复杂的几何形状

00:10:17.851 --> 00:10:19.786 align:middle line:-1
这意味着 我们的大多数时间

00:10:19.853 --> 00:10:23.824 align:middle line:-2
仅用于搜索高复杂性
几何区域中的交叉点

00:10:24.024 --> 00:10:25.025 align:middle line:-1
这正是我们想要的

00:10:26.460 --> 00:10:28.795 align:middle line:-2
我描述了加速结构是什么
以及它是如何工作

00:10:29.029 --> 00:10:31.965 align:middle line:-1
让你们有直观的感受

00:10:32.466 --> 00:10:34.668 align:middle line:-2
但实际上你们并不需要
过分关心这些内容

00:10:35.002 --> 00:10:37.070 align:middle line:-2
因为MPS将会为你们
处理所有的工作

00:10:39.039 --> 00:10:41.241 align:middle line:-2
请记住 我们使用三角形
建模我们的场景

00:10:41.808 --> 00:10:43.844 align:middle line:-2
这些三角形本身
可以使用顶点缓冲区中的

00:10:43.911 --> 00:10:45.779 align:middle line:-1
顶点进行表示

00:10:46.813 --> 00:10:50.784 align:middle line:-2
你只需要 调用MPS
顶点缓冲区中

00:10:50.851 --> 00:10:52.052 align:middle line:-1
创建一个加速结构

00:10:53.387 --> 00:10:55.122 align:middle line:-1
当准备搜索交叉时

00:10:55.289 --> 00:10:57.157 align:middle line:-1
只需要将这个加速结构

00:10:57.224 --> 00:10:58.525 align:middle line:-1
提供给交叉区域

00:10:59.693 --> 00:11:02.262 align:middle line:-2
让我们来看如何使用此方法
创建一个真实app

00:10:59.693 --> 00:11:02.262 align:middle line:-2
让我们来看如何使用此方法
创建一个真实app

00:11:03.463 --> 00:11:05.465 align:middle line:-1
我们将这个app划分为三个阶段

00:11:05.899 --> 00:11:10.003 align:middle line:-2
首先 我们生成一次光线
找到光线与场景的交叉点

00:11:10.070 --> 00:11:11.338 align:middle line:-1
然后计算阴影

00:11:11.972 --> 00:11:13.574 align:middle line:-2
这类似于我们使用
光栅化方法

00:11:13.640 --> 00:11:14.775 align:middle line:-1
实现的效果

00:11:15.108 --> 00:11:16.910 align:middle line:-2
但在接下来的步骤中
我们会更进一步

00:11:18.245 --> 00:11:19.680 align:middle line:-1
接下来 我们将会添加阴影

00:11:20.013 --> 00:11:22.316 align:middle line:-1
MPS提供特殊的阴影光线支持

00:11:22.516 --> 00:11:24.518 align:middle line:-1
可以加快app速度

00:11:26.119 --> 00:11:26.987 align:middle line:-1
最后

00:11:27.054 --> 00:11:29.189 align:middle line:-1
我们使用二次光线

00:11:29.256 --> 00:11:30.624 align:middle line:-1
模拟场景中的光线反射

00:11:31.391 --> 00:11:33.694 align:middle line:-2
使用光栅化方法很难
实现这种效果

00:11:33.760 --> 00:11:35.729 align:middle line:-2
但是 我们看到
使用光线追踪技术

00:11:35.796 --> 00:11:36.930 align:middle line:-1
很容易做到这一点

00:11:38.665 --> 00:11:40.133 align:middle line:-1
让我们从一次光线开始

00:11:41.401 --> 00:11:43.537 align:middle line:-1
我们需要做五件事

00:11:44.404 --> 00:11:46.974 align:middle line:-2
首先 我们创建一个
光线三角形交叉检查器

00:11:48.542 --> 00:11:50.043 align:middle line:-1
然后 在我们的顶点缓冲区中

00:11:50.110 --> 00:11:51.345 align:middle line:-1
创建一个加速结构

00:11:53.480 --> 00:11:56.884 align:middle line:-2
接下来 我们生成一次光线
将它们写入光线缓冲区

00:11:58.719 --> 00:12:01.822 align:middle line:-2
然后 我们使用
Intersector

00:11:58.719 --> 00:12:01.822 align:middle line:-2
然后 我们使用
Intersector

00:12:01.889 --> 00:12:03.257 align:middle line:-1
寻找光线与场景间的交叉区

00:12:04.024 --> 00:12:04.958 align:middle line:-1
最后

00:12:05.025 --> 00:12:07.694 align:middle line:-2
最后我们使用交叉区结果
计算阴影效果

00:12:09.263 --> 00:12:10.731 align:middle line:-1
我们先来看Intersector

00:12:12.566 --> 00:12:14.468 align:middle line:-1
MPSRayIntersector类

00:12:14.768 --> 00:12:17.304 align:middle line:-1
协调所有光线三角交叉区测试结果

00:12:18.305 --> 00:12:21.041 align:middle line:-2
我们只需要提供
想要用于交叉测试的

00:12:21.108 --> 00:12:23.043 align:middle line:-1
Metal设备

00:12:25.312 --> 00:12:27.314 align:middle line:-1
接下来 我们将创建加速结构

00:12:28.982 --> 00:12:29.917 align:middle line:-1
此加速结构用

00:12:29.983 --> 00:12:32.686 align:middle line:-2
MPSTriangle
AccelerationStructure类表示

00:12:33.120 --> 00:12:36.456 align:middle line:-2
同样地 要创建加速结构
我们只需要提供用于创建Intersector的

00:12:36.523 --> 00:12:38.158 align:middle line:-1
相同Metal设备

00:12:40.027 --> 00:12:43.230 align:middle line:-2
然后 加入我们的vertexBuffer
指定triangleCount

00:12:44.298 --> 00:12:46.967 align:middle line:-1
最后 我们创建加速结构

00:12:47.534 --> 00:12:48.869 align:middle line:0
只需要创建一次

00:12:48.936 --> 00:12:51.338 align:middle line:0
然后 就可以重复地

00:12:51.405 --> 00:12:52.739 align:middle line:0
多次使用这个加速结构

00:12:56.677 --> 00:12:59.947 align:middle line:-2
接下来 将生成一次光线
将它们写入光线缓冲区

00:13:01.148 --> 00:13:03.951 align:middle line:-2
为此 将启动
一个双线程计算内核

00:13:04.117 --> 00:13:05.652 align:middle line:-1
每个像素一个线程

00:13:06.486 --> 00:13:09.823 align:middle line:-2
每个线程将这个光线结构
写入光线缓冲区

00:13:11.458 --> 00:13:13.126 align:middle line:-1
可以设想 输出图像

00:13:13.193 --> 00:13:15.629 align:middle line:-1
在摄像机正方的平面上飘浮

00:13:17.397 --> 00:13:19.366 align:middle line:-1
一次光线从摄像机中发出

00:13:19.433 --> 00:13:21.768 align:middle line:-2
因此我以将原点
设置为摄像机位置

00:13:22.703 --> 00:13:24.004 align:middle line:-1
为了计算方向

00:13:24.471 --> 00:13:26.840 align:middle line:-1
将从摄像机位置寻找方向

00:13:27.007 --> 00:13:29.343 align:middle line:-1
穿过图像平面上的相应像素点

00:13:32.546 --> 00:13:34.047 align:middle line:-1
现在 已经生成一次光线

00:13:34.114 --> 00:13:36.583 align:middle line:-2
将用Intersector
寻找场景中的交叉区域

00:13:38.285 --> 00:13:40.087 align:middle line:-1
encodeIntersection调用

00:13:40.153 --> 00:13:42.456 align:middle line:-2
将我们创建的所有项目
关联在一起

00:13:43.457 --> 00:13:46.793 align:middle line:-2
首先请记住 我们将会编码到
一个Metal指令缓冲区之中

00:13:47.928 --> 00:13:49.162 align:middle line:-1
实际上 我们有多个选项

00:13:49.229 --> 00:13:51.498 align:middle line:-1
来选择进行哪种类型的交叉区搜索

00:13:51.999 --> 00:13:53.634 align:middle line:-1
本例中 我们使用最近的交叉区

00:13:53.700 --> 00:13:56.336 align:middle line:-1
将沿每条光线寻找最近的交叉区

00:13:58.172 --> 00:13:59.640 align:middle line:-1
然后 提供光线缓冲区

00:13:59.706 --> 00:14:02.776 align:middle line:-1
此缓冲区包含我们刚创建的一次光线

00:13:59.706 --> 00:14:02.776 align:middle line:-1
此缓冲区包含我们刚创建的一次光线

00:14:03.410 --> 00:14:04.778 align:middle line:-1
另外还提供交叉区缓冲区

00:14:04.845 --> 00:14:06.613 align:middle line:-1
此缓冲区包含交叉区结果

00:14:07.848 --> 00:14:09.583 align:middle line:-1
还需要提供rayCount

00:14:09.816 --> 00:14:11.485 align:middle line:-1
在本例中 它是图像宽度

00:14:11.552 --> 00:14:12.619 align:middle line:-1
乘以图像高度

00:14:13.787 --> 00:14:16.290 align:middle line:-1
最后 提供我们的加速结构

00:14:17.724 --> 00:14:20.494 align:middle line:-2
MPS将会沿每条光线
寻找最近的交叉区

00:14:20.561 --> 00:14:22.829 align:middle line:-1
并在交叉区缓冲中返回结果

00:14:23.230 --> 00:14:25.632 align:middle line:-2
最后剩下的工作是
使用交叉区数据

00:14:25.699 --> 00:14:26.700 align:middle line:-1
计算阴影

00:14:28.669 --> 00:14:30.771 align:middle line:-2
为此 我们启动
另外一个计算内核

00:14:31.705 --> 00:14:33.440 align:middle line:-1
可以像在片段着色器中那样

00:14:33.507 --> 00:14:35.742 align:middle line:-1
app光照和材质

00:14:36.043 --> 00:14:38.612 align:middle line:-1
在片段着色器中可以使用的

00:14:38.679 --> 00:14:40.547 align:middle line:-1
大多数标准材质和数学函数

00:14:40.714 --> 00:14:42.616 align:middle line:-1
都可以在计算内核中使用

00:14:43.784 --> 00:14:46.753 align:middle line:-2
但是一般来说
阴影取决于交叉点

00:14:46.820 --> 00:14:49.489 align:middle line:-2
和顶点属性
例如颜色和形态

00:14:50.023 --> 00:14:53.594 align:middle line:-2
在片段着色器中
GPU将为我们完成这些插值

00:14:53.927 --> 00:14:55.729 align:middle line:-1
但我们需要它们在交叉数据的基础上

00:14:55.796 --> 00:14:57.297 align:middle line:-1
自己进行插值

00:14:58.866 --> 00:15:01.368 align:middle line:-1
因此 让我们来看如何计算交叉点

00:14:58.866 --> 00:15:01.368 align:middle line:-1
因此 让我们来看如何计算交叉点

00:15:03.237 --> 00:15:06.373 align:middle line:0
请记住
光线使用源点和方向进行定义

00:15:09.510 --> 00:15:12.779 align:middle line:0
这是Intersector
返回的交叉区结构

00:15:13.547 --> 00:15:15.249 align:middle line:0
距离字段告诉我们

00:15:15.315 --> 00:15:17.618 align:middle line:0
需要在光线方向行进多远的距离

00:15:17.951 --> 00:15:20.454 align:middle line:0
才能从光线起点到达交叉点

00:15:21.088 --> 00:15:24.324 align:middle line:0
如果光线不会与任何物体交叉
此距离将是负值

00:15:26.527 --> 00:15:29.296 align:middle line:0
primitiveIndex
告诉我们遇到哪个三角形

00:15:30.330 --> 00:15:33.767 align:middle line:0
我们使用最后一个字段
进行顶点属性插值

00:15:35.169 --> 00:15:37.771 align:middle line:-1
这个字段包含前两个质心坐标

00:15:37.838 --> 00:15:39.039 align:middle line:-1
即U和V

00:15:39.473 --> 00:15:42.242 align:middle line:-1
第三个坐标对应于交叉点相对于

00:15:42.309 --> 00:15:44.211 align:middle line:-1
三角形顶点的

00:15:45.579 --> 00:15:47.714 align:middle line:-1
实际上有三个质心坐标

00:15:47.781 --> 00:15:48.982 align:middle line:-1
组成一个坐标集合

00:15:49.216 --> 00:15:51.652 align:middle line:-1
因此我们可以用1减去前两个坐标

00:15:51.818 --> 00:15:53.954 align:middle line:-1
计算出第三个坐标W

00:15:55.589 --> 00:15:59.092 align:middle line:-2
如果仅定义三角形的
每个顶点的顶点属性

00:15:59.459 --> 00:16:01.395 align:middle line:-1
插入的顶点属性

00:15:59.459 --> 00:16:01.395 align:middle line:-1
插入的顶点属性

00:16:02.329 --> 00:16:05.566 align:middle line:-1
仅仅是每个顶点的属性相加

00:16:05.632 --> 00:16:07.534 align:middle line:-1
并使用质心坐标加权

00:16:08.302 --> 00:16:11.205 align:middle line:-1
例如 如果设定每个顶点的颜色

00:16:11.271 --> 00:16:12.673 align:middle line:-1
那么插值颜色

00:16:12.739 --> 00:16:15.442 align:middle line:-1
就是每个顶点的颜色加权和

00:16:18.178 --> 00:16:20.480 align:middle line:-2
到此为止 我们创建了
一个光线Intersector

00:16:20.981 --> 00:16:22.583 align:middle line:-1
一个加速结构

00:16:23.584 --> 00:16:25.452 align:middle line:-1
然后生成一次光线

00:16:25.686 --> 00:16:27.521 align:middle line:-1
找到光线与场景的交叉区

00:16:28.288 --> 00:16:30.324 align:middle line:-1
在交叉点计算阴影

00:16:30.390 --> 00:16:32.793 align:middle line:-2
然后 我们将阴影颜色
写入图像

00:16:32.993 --> 00:16:34.361 align:middle line:-1
让我们来看图像

00:16:36.063 --> 00:16:39.199 align:middle line:-2
我们可以看到加速结构
表示的几何形状

00:16:39.399 --> 00:16:42.736 align:middle line:-2
以及插值顶点颜色
和计算出的光照效果

00:16:43.904 --> 00:16:45.372 align:middle line:-1
图像已经显示在屏幕上

00:16:45.439 --> 00:16:47.241 align:middle line:-1
我们添加一些其他效果

00:16:48.742 --> 00:16:51.011 align:middle line:0
首先 为图像增加阴影

00:16:53.447 --> 00:16:55.315 align:middle line:-1
为此 在添加阴影之前

00:16:55.883 --> 00:16:58.252 align:middle line:-1
需要检查

00:16:58.318 --> 00:16:59.953 align:middle line:-1
光线是否可以到达阴影点

00:17:00.888 --> 00:17:03.557 align:middle line:-2
为此 可以添加
更多的阴影光线

00:17:03.690 --> 00:17:06.026 align:middle line:-1
从交叉点投射到光源

00:17:07.594 --> 00:17:10.130 align:middle line:-1
如果阴影光线不能到达光源

00:17:10.196 --> 00:17:12.532 align:middle line:-1
那么初始阴影点就不是阴影

00:17:12.633 --> 00:17:14.667 align:middle line:-1
因此不应该添加其颜色到图像

00:17:17.704 --> 00:17:19.339 align:middle line:-1
我们将修改阴影内核

00:17:19.806 --> 00:17:22.910 align:middle line:-2
将附加阴影光线
写入另一个Metal缓冲区

00:17:24.444 --> 00:17:27.114 align:middle line:-2
然后 我们再次寻找
场景交叉区

00:17:28.115 --> 00:17:30.017 align:middle line:-1
然后启动最后一个内核

00:17:30.083 --> 00:17:33.220 align:middle line:-2
此内核根据阴影光线
是否与任何物体交叉

00:17:33.287 --> 00:17:35.889 align:middle line:-2
有条件地
将阴影颜色写入图像

00:17:36.990 --> 00:17:39.092 align:middle line:-1
因此 让我们开始修改阴影内核

00:17:40.894 --> 00:17:43.597 align:middle line:-2
现在 阴影光线略微
不同于一次光线

00:17:44.198 --> 00:17:45.032 align:middle line:-1
首先…

00:17:45.098 --> 00:17:47.768 align:middle line:-2
我们需要提供
一个最大交叉距离

00:17:47.901 --> 00:17:50.571 align:middle line:-2
这样 阴影光线
不会偏离光线

00:17:52.539 --> 00:17:54.908 align:middle line:-2
我们不需要知道
将会遇到哪个三角形

00:17:54.975 --> 00:17:56.910 align:middle line:-1
或质心坐标是多少

00:17:56.977 --> 00:17:58.912 align:middle line:-1
因此我们可以进行一些优化

00:18:00.314 --> 00:18:01.215 align:middle line:-1
最后…

00:18:01.281 --> 00:18:04.117 align:middle line:-2
记住 我们不能
将阴影颜色写入图像

00:18:04.184 --> 00:18:07.254 align:middle line:-2
除非我们知道原始阴影点
是否位于阴影之中

00:18:07.821 --> 00:18:11.058 align:middle line:-2
因此我们需要一种方法
通过Intersector将颜色

00:18:11.124 --> 00:18:14.127 align:middle line:-2
从阴影内核
传递到最终内核

00:18:14.194 --> 00:18:15.596 align:middle line:-1
这将会更新图像

00:18:16.296 --> 00:18:18.632 align:middle line:-2
为此 可以自定义
我们的光线结构

00:18:22.302 --> 00:18:23.904 align:middle line:-1
我们有多个选项

00:18:23.971 --> 00:18:26.507 align:middle line:-2
选择为Intersector
提供哪些数据

00:18:27.140 --> 00:18:28.742 align:middle line:-2
本例中
我们将使用一个数据类型

00:18:28.809 --> 00:18:31.445 align:middle line:-1
它包含最小和最大距离字段

00:18:32.379 --> 00:18:35.449 align:middle line:-2
MPS将会忽略
此范围之外的任何交叉

00:18:35.649 --> 00:18:38.552 align:middle line:-2
从而防止阴影射线
偏离光源

00:18:40.187 --> 00:18:41.054 align:middle line:-1
其次…

00:18:41.288 --> 00:18:44.758 align:middle line:-1
如果应用特定的光线相关数据

00:18:45.125 --> 00:18:47.261 align:middle line:-2
可以将这些数据追加到
光线结构的末尾

00:18:47.327 --> 00:18:48.996 align:middle line:-1
并且提供一个rayStride

00:18:49.730 --> 00:18:52.866 align:middle line:-2
MPS从你的光线缓冲区读取数据时
将会跳过此数据

00:18:53.867 --> 00:18:54.701 align:middle line:-1
在本例中

00:18:54.768 --> 00:18:57.004 align:middle line:-2
我们将阴影颜色添加到
光线结构的末尾

00:18:57.070 --> 00:18:59.339 align:middle line:-1
这样 可以将它从阴影内核

00:18:59.406 --> 00:19:00.607 align:middle line:-1
传递到最后内核

00:18:59.406 --> 00:19:00.607 align:middle line:-1
传递到最后内核

00:19:02.242 --> 00:19:04.611 align:middle line:-2
我们可以在光线Intersector上
配置这些选项

00:19:05.312 --> 00:19:06.146 align:middle line:0
首先…

00:19:06.346 --> 00:19:08.649 align:middle line:0
设置rayDataType
以匹配我们的结构类型

00:19:10.651 --> 00:19:11.885 align:middle line:0
然后 设置rayStride

00:19:11.952 --> 00:19:14.188 align:middle line:0
以跳过结构末尾的颜色

00:19:16.590 --> 00:19:18.859 align:middle line:-2
接下来 通过Intersector
运行阴影光线

00:19:20.894 --> 00:19:22.996 align:middle line:0
这是Intersector
首次调用

00:19:23.564 --> 00:19:26.200 align:middle line:0
记住 阴影光线仅检查

00:19:26.266 --> 00:19:28.836 align:middle line:0
原始阴影点与光源之间的可见性

00:19:28.902 --> 00:19:30.704 align:middle line:0
我们可以进行两项优化

00:19:31.538 --> 00:19:34.908 align:middle line:0
与自定义
rayDataType一样

00:19:34.975 --> 00:19:37.377 align:middle line:0
我们可以自定义
Intersection数据类型

00:19:37.711 --> 00:19:40.380 align:middle line:0
或Intersector的
返回数据类型

00:19:41.982 --> 00:19:45.152 align:middle line:0
在本例中只需要知道
距离是否为正值或负值

00:19:45.219 --> 00:19:46.820 align:middle line:0
表示是否存在交叉

00:19:47.454 --> 00:19:50.324 align:middle line:-2
因此可以将intersection数据类型
设置为distance

00:19:50.724 --> 00:19:52.326 align:middle line:-1
这会节省一些内存带宽

00:19:52.392 --> 00:19:55.162 align:middle line:-2
加快Intersection
缓冲区读写速度

00:19:57.497 --> 00:19:58.332 align:middle line:0
其次

00:19:58.398 --> 00:20:00.968 align:middle line:0
由于并不需要知道
将会遇到哪个三角形

00:19:58.398 --> 00:20:00.968 align:middle line:0
由于并不需要知道
将会遇到哪个三角形

00:20:01.034 --> 00:20:04.404 align:middle line:0
因此可以在遇到任意三角形时
结束交叉搜索

00:20:04.705 --> 00:20:05.672 align:middle line:0
通常情况下

00:20:05.739 --> 00:20:08.375 align:middle line:0
这比搜索最近交叉点的速度更快

00:20:09.142 --> 00:20:12.112 align:middle line:0
对此 MPS有一个专用模式
可以启用它

00:20:12.312 --> 00:20:15.349 align:middle line:0
方法是传递任意intersectionType
而不是传递nearest

00:20:18.385 --> 00:20:22.222 align:middle line:-2
最后 可以启动最后内核
将颜色添加到图像

00:20:24.191 --> 00:20:28.929 align:middle line:-2
每个线程将读入一阴影光线和相应的
intersection数据

00:20:30.297 --> 00:20:32.332 align:middle line:-1
如果交叉间距为正值

00:20:32.533 --> 00:20:34.902 align:middle line:-1
那么原始交叉点位于阴影之中

00:20:35.269 --> 00:20:36.703 align:middle line:-1
不需要做其他工作

00:20:37.504 --> 00:20:39.907 align:middle line:-1
否则 交叉点不在阴影之中

00:20:41.275 --> 00:20:44.745 align:middle line:-2
因此 应读入光线颜色
将它写入输出图像

00:20:45.979 --> 00:20:48.282 align:middle line:-2
这样就可以将阴影
添加到图像之中

00:20:50.817 --> 00:20:53.587 align:middle line:-2
我们可以看到
在添加光照到图像之前

00:20:53.654 --> 00:20:56.757 align:middle line:-2
每个阴影点检查
光源是否可见

00:20:57.591 --> 00:20:59.193 align:middle line:-1
由于我们使用光线追踪器

00:20:59.660 --> 00:21:02.429 align:middle line:-2
因此可以随机采样
光源的表面

00:20:59.660 --> 00:21:02.429 align:middle line:-2
因此可以随机采样
光源的表面

00:21:02.496 --> 00:21:04.398 align:middle line:-1
为我们提供这些美观的软阴影

00:21:07.301 --> 00:21:09.403 align:middle line:-1
最后 让我们来看二次光源

00:21:11.205 --> 00:21:14.608 align:middle line:-2
记住 二次光线模拟
场景反射光线

00:21:15.709 --> 00:21:19.947 align:middle line:-2
为了添加二次光源
只需要把所有内核移入一个循环流程

00:21:20.480 --> 00:21:23.383 align:middle line:-2
在每次迭代中
将选择一个新随机方向

00:21:23.450 --> 00:21:24.918 align:middle line:-1
以沿续光线路径

00:21:29.790 --> 00:21:31.358 align:middle line:-1
然后 修改阴影内核

00:21:31.592 --> 00:21:34.194 align:middle line:-1
为下次迭代生成光线

00:21:35.162 --> 00:21:36.964 align:middle line:-1
完成图像更新之后

00:21:37.364 --> 00:21:40.200 align:middle line:-1
循环回到第一次交叉测试

00:21:40.734 --> 00:21:44.171 align:middle line:-2
可以根据需要的反射次数
重复这个循环流程

00:21:47.274 --> 00:21:49.409 align:middle line:-1
我们来看阴影内核修改

00:21:51.945 --> 00:21:53.080 align:middle line:-1
在每次迭代中

00:21:53.480 --> 00:21:55.816 align:middle line:-1
我们将光线起点移至交叉点

00:21:57.651 --> 00:22:00.087 align:middle line:-2
然后选择一个随机方向
以继续光线路径

00:21:57.651 --> 00:22:00.087 align:middle line:-2
然后选择一个随机方向
以继续光线路径

00:22:01.388 --> 00:22:02.289 align:middle line:-1
最后

00:22:02.923 --> 00:22:05.893 align:middle line:-1
将光线颜色与插值顶点颜色相乘

00:22:06.894 --> 00:22:08.996 align:middle line:-1
这样光线就会使用

00:22:09.062 --> 00:22:11.031 align:middle line:-1
表面反射的颜色

00:22:11.832 --> 00:22:13.400 align:middle line:-1
在更高级的app中

00:22:13.467 --> 00:22:16.036 align:middle line:-1
计算将会更加复杂

00:22:16.436 --> 00:22:18.872 align:middle line:-1
但是 通过认真选择随机光线方向

00:22:18.939 --> 00:22:21.475 align:middle line:-1
可以取消其余的数学计算

00:22:22.543 --> 00:22:25.245 align:middle line:-2
即使从摄像机反向投射光线
也同样可行

00:22:25.479 --> 00:22:27.981 align:middle line:-2
只要在每个交叉点
使用光线颜色

00:22:28.048 --> 00:22:30.117 align:middle line:-1
严格地为直射光线着色

00:22:31.785 --> 00:22:33.687 align:middle line:-2
对于二次光线
这就是我们要做的事情

00:22:35.155 --> 00:22:38.125 align:middle line:-1
光线可以从墙面反射到

00:22:38.192 --> 00:22:40.594 align:middle line:-1
箱子侧面和天花板上

00:22:42.129 --> 00:22:43.564 align:middle line:-1
这是我们的示例app

00:22:44.865 --> 00:22:48.802 align:middle line:0
最初 屏幕上显示一幅图像
上面有一次光线和着色

00:22:49.670 --> 00:22:51.071 align:middle line:0
然后我们添加阴影

00:22:51.438 --> 00:22:52.306 align:middle line:0
最后

00:22:52.372 --> 00:22:55.309 align:middle line:0
使用二次光线模拟
场景中的光线反射

00:22:56.176 --> 00:22:59.847 align:middle line:0
让我们切换到演示
看看实时运行效果

00:23:03.951 --> 00:23:08.755 align:middle line:-2
这是我们编写的app运行在
12.9英寸iPad Pro上

00:23:09.656 --> 00:23:11.558 align:middle line:-1
我们可以扩展此app

00:23:11.892 --> 00:23:15.629 align:middle line:-2
以支持更高级的光照
阴影、材质和其他效果

00:23:16.096 --> 00:23:18.565 align:middle line:-1
让我们切换到更复杂的场景

00:23:18.732 --> 00:23:20.501 align:middle line:-1
这个场景使用了许多这样的特性

00:23:25.973 --> 00:23:28.108 align:middle line:-1
这是Amazon Lumberyard Bistro场景

00:23:28.175 --> 00:23:31.912 align:middle line:-2
在“国情咨文”中运行
使用四个GPU

00:23:32.713 --> 00:23:35.148 align:middle line:-1
这个场景有将近一百万个三角形

00:23:35.482 --> 00:23:37.985 align:middle line:-2
但是 使用这些先进的
光照和着色技术

00:23:38.051 --> 00:23:39.286 align:middle line:-1
我们仍能在iPad Pro上

00:23:39.353 --> 00:23:42.022 align:middle line:-2
实现将近两千万条光线/秒的
处理速度

00:23:42.456 --> 00:23:45.192 align:middle line:-2
这是一个综合指标
包括一次光线

00:23:45.259 --> 00:23:46.827 align:middle line:-1
阴影和二次光线

00:23:48.362 --> 00:23:51.498 align:middle line:-1
我们创建了便于使用的API

00:23:51.698 --> 00:23:54.835 align:middle line:-2
你们现在就可以使用它们
开始实施这些类型的app

00:23:56.069 --> 00:23:57.571 align:middle line:-1
这是我们的演示例子

00:23:59.239 --> 00:24:00.140 align:middle line:-1
谢谢

00:23:59.239 --> 00:24:00.140 align:middle line:-1
谢谢

00:24:03.477 --> 00:24:05.312 align:middle line:-2
如果你们没有完全理解
也不用着急

00:24:05.479 --> 00:24:08.482 align:middle line:-2
这个app作为例子
将会提供下载

00:24:09.116 --> 00:24:12.085 align:middle line:-2
这个例子演示了
我今天讲述的所有内容

00:24:12.686 --> 00:24:15.389 align:middle line:-1
强烈建议你们下载这个示例

00:24:15.556 --> 00:24:18.792 align:middle line:-2
添加你们自己的几何
光照、阴影等等

00:24:19.560 --> 00:24:21.495 align:middle line:-1
关于API 还有很多的内容

00:24:21.562 --> 00:24:23.297 align:middle line:-1
今天没有时间逐一讲解

00:24:23.797 --> 00:24:25.165 align:middle line:-1
因此 建议你们查看

00:24:25.232 --> 00:24:27.000 align:middle line:-1
文件和头文件

00:24:27.868 --> 00:24:30.304 align:middle line:-1
接下来 把舞台交给同事Wayne

00:24:30.737 --> 00:24:33.373 align:middle line:-2
他将会介绍我们如何
将这项技术扩展到多GPU平台

00:24:35.542 --> 00:24:36.376 align:middle line:-1
谢谢

00:24:42.149 --> 00:24:42.983 align:middle line:-1
谢谢Sean

00:24:43.550 --> 00:24:44.384 align:middle line:-1
大家好

00:24:47.988 --> 00:24:49.590 align:middle line:-1
你们很多人使用Mac计算机

00:24:50.424 --> 00:24:52.226 align:middle line:-1
它有一个内置GPU

00:24:52.559 --> 00:24:56.363 align:middle line:-2
但是你们可能添加了
多个高性能eGPU

00:24:57.464 --> 00:25:01.301 align:middle line:-1
我们希望能够使用所有这些GPU

00:24:57.464 --> 00:25:01.301 align:middle line:-1
我们希望能够使用所有这些GPU

00:25:01.368 --> 00:25:04.104 align:middle line:-1
以尽量提高光线追踪速度

00:25:05.272 --> 00:25:06.473 align:middle line:-1
我们应该怎么做？

00:25:06.840 --> 00:25:07.708 align:middle line:-1
我们需要

00:25:07.774 --> 00:25:09.309 align:middle line:-1
考虑三件事情

00:25:10.277 --> 00:25:11.178 align:middle line:-1
首先

00:25:11.512 --> 00:25:14.281 align:middle line:-2
我们如何在GPU之间
分配处理工作量？

00:25:15.749 --> 00:25:16.583 align:middle line:-1
其次

00:25:17.284 --> 00:25:20.387 align:middle line:-2
有时候 GPU需要
一种方法来交换数据

00:25:20.721 --> 00:25:22.623 align:middle line:-1
我们如何处理这个问题？

00:25:23.824 --> 00:25:24.658 align:middle line:-1
最后

00:25:24.725 --> 00:25:26.760 align:middle line:-1
还需要一个同步方法

00:25:27.594 --> 00:25:30.163 align:middle line:-2
对此 我将介绍如何使用
新的Metal Events特性

00:25:30.230 --> 00:25:31.798 align:middle line:-1
本周我们进行了相关的介绍

00:25:32.666 --> 00:25:33.767 align:middle line:-1
让我们开始

00:25:35.335 --> 00:25:36.537 align:middle line:-1
对于如何划分处理工作量

00:25:36.603 --> 00:25:39.006 align:middle line:-2
我们将会使用名称为
Split Frame Rendering的方法

00:25:39.806 --> 00:25:42.976 align:middle line:-1
其原理是将帧分为多个区域

00:25:43.043 --> 00:25:46.346 align:middle line:-2
然后将这些区域
分配给不同的GPU

00:25:46.880 --> 00:25:48.448 align:middle line:-1
从而可以并行地进行渲染

00:25:49.883 --> 00:25:50.851 align:middle line:-1
现在 每个GPU

00:25:50.918 --> 00:25:53.820 align:middle line:-2
都将运行完整渲染管道
前面Sean已经讲过

00:25:54.121 --> 00:25:56.590 align:middle line:-2
这包括所有的处理
从初始光线生成

00:25:56.924 --> 00:25:59.026 align:middle line:-1
到阴影光线和着色

00:26:00.360 --> 00:26:02.196 align:middle line:-1
所有GPU完成处理之后

00:26:02.262 --> 00:26:04.965 align:middle line:-1
我们选择连接到显示的GPU

00:26:05.732 --> 00:26:07.968 align:middle line:-1
将会复制所有已经完成的区域

00:26:08.035 --> 00:26:08.902 align:middle line:-1
以进行合成

00:26:10.537 --> 00:26:11.471 align:middle line:-1
合成是将各个区域

00:26:11.538 --> 00:26:13.307 align:middle line:-1
拼接在一起

00:26:13.373 --> 00:26:15.309 align:middle line:-1
然后放入帧缓冲区

00:26:16.043 --> 00:26:19.179 align:middle line:-2
你可能想要将它们
与先前的渲染组合在一起

00:26:19.246 --> 00:26:21.448 align:middle line:-1
以增强图像质量和消除噪讯

00:26:23.550 --> 00:26:25.485 align:middle line:-1
在开始进行渲染之前

00:26:25.619 --> 00:26:28.822 align:middle line:-2
需要确保每个GPU
都有完整的场景副本

00:26:30.123 --> 00:26:33.227 align:middle line:-1
需要在所有GPU上复制资产

00:26:33.293 --> 00:26:35.462 align:middle line:-1
例如顶点缓冲区和材质

00:26:36.563 --> 00:26:38.432 align:middle line:-1
然后 创建Sean前面说过的

00:26:38.498 --> 00:26:39.867 align:middle line:-1
三角形加速结构

00:26:42.436 --> 00:26:44.705 align:middle line:-1
现在… 对于加速结构

00:26:44.771 --> 00:26:47.808 align:middle line:-1
不需要为每个GPU

00:26:47.875 --> 00:26:48.976 align:middle line:0
重头进行创建

00:26:49.510 --> 00:26:54.147 align:middle line:0
我们添加一个API
让你能够使用现有的加速结构

00:26:54.214 --> 00:26:56.850 align:middle line:0
为每个想要使用的GPU
生成一个副本

00:26:58.118 --> 00:27:00.587 align:middle line:0
这个副本是非递归性的

00:26:58.118 --> 00:27:00.587 align:middle line:0
这个副本是非递归性的

00:27:01.088 --> 00:27:04.091 align:middle line:0
因此 添加到加速结构的任何缓冲区

00:27:04.224 --> 00:27:06.693 align:middle line:0
例如顶点和索引缓冲区

00:27:07.628 --> 00:27:09.096 align:middle line:0
都需要单独复制它们

00:27:09.162 --> 00:27:11.431 align:middle line:0
然后 将它们添加到

00:27:11.498 --> 00:27:12.766 align:middle line:0
刚才创建的加速结构

00:27:16.203 --> 00:27:19.039 align:middle line:-2
现在 已经在所有GPU上
复制数据

00:27:19.106 --> 00:27:20.340 align:middle line:-1
准备开始渲染

00:27:21.975 --> 00:27:24.845 align:middle line:-2
从多GPU角度来的
一件有趣的事情是

00:27:24.912 --> 00:27:28.048 align:middle line:-2
这部分的管道
其实与Sean前面描述的渲染管道

00:27:28.115 --> 00:27:29.383 align:middle line:-1
没有什么差别

00:27:30.250 --> 00:27:32.619 align:middle line:-1
唯一的差别在于对于多GPU

00:27:32.819 --> 00:27:35.989 align:middle line:-1
需要设定各个GPU所负责的

00:27:36.056 --> 00:27:37.891 align:middle line:-1
屏幕区域的光线生成工作

00:27:38.458 --> 00:27:39.893 align:middle line:-1
其他部分都是相同的

00:27:40.894 --> 00:27:41.929 align:middle line:-1
因此

00:27:41.995 --> 00:27:46.099 align:middle line:-2
让我们直接来看
多GPU方案中最复杂的阶段

00:27:46.500 --> 00:27:48.769 align:middle line:-1
也就是合成阶段

00:27:51.371 --> 00:27:54.007 align:middle line:-1
为了在macOS上获得最佳性能

00:27:54.074 --> 00:27:57.077 align:middle line:-2
每个GPU都将渲染结果
放入自己的私有缓冲区

00:27:58.078 --> 00:28:01.081 align:middle line:-2
渲染完成后
我们将缓冲区复制到

00:27:58.078 --> 00:28:01.081 align:middle line:-2
渲染完成后
我们将缓冲区复制到

00:28:01.148 --> 00:28:03.817 align:middle line:-1
用于进行合成的GPU

00:28:04.985 --> 00:28:07.187 align:middle line:-1
不能直接在缓冲区之间进行复制

00:28:07.254 --> 00:28:09.723 align:middle line:-1
因为Metal资源只能

00:28:09.790 --> 00:28:10.791 align:middle line:-1
在创建这些资源的设备上使用

00:28:11.425 --> 00:28:13.427 align:middle line:-2
因此 不能在一个GPU上
创建缓冲区

00:28:13.493 --> 00:28:16.230 align:middle line:-2
然后尝试将它添加到
不同GPU的Blit编码器

00:28:16.296 --> 00:28:17.598 align:middle line:-1
这样是不行的

00:28:18.832 --> 00:28:21.568 align:middle line:-2
这意味着 我们的副本
将需要经过系统内存

00:28:23.370 --> 00:28:25.472 align:middle line:-1
为了提高效率

00:28:25.539 --> 00:28:27.741 align:middle line:-1
我们使用缓冲区管理

00:28:29.343 --> 00:28:31.111 align:middle line:-1
我们创建两个Metal缓冲区

00:28:31.378 --> 00:28:34.882 align:middle line:-1
每台设备一个包装通用CPU分配

00:28:36.016 --> 00:28:38.652 align:middle line:-1
由于缓冲区包装相同的底层内存

00:28:39.052 --> 00:28:42.022 align:middle line:-2
在设备A上写入
Metal缓冲区的任何内容

00:28:42.489 --> 00:28:45.192 align:middle line:-2
对于设备B上的Metal缓冲区
来说都是可见的

00:28:46.927 --> 00:28:48.128 align:middle line:-1
如前所述

00:28:48.795 --> 00:28:50.731 align:middle line:-1
为了确保macOS上的处理性能

00:28:51.131 --> 00:28:54.368 align:middle line:-2
所有这些实际渲染工作
都使用私有缓冲区完成

00:28:55.169 --> 00:28:58.205 align:middle line:-1
然后 当需复制区域到不同GPU时

00:28:58.272 --> 00:29:00.307 align:middle line:-2
我们通过系统内存
Blit完成的区域

00:28:58.272 --> 00:29:00.307 align:middle line:-2
我们通过系统内存
Blit完成的区域

00:29:02.142 --> 00:29:03.944 align:middle line:-1
来看如何进行设置

00:29:05.012 --> 00:29:08.815 align:middle line:-2
首先 使用Metal共享存储模式
在设备A上创建缓冲区

00:29:09.783 --> 00:29:12.152 align:middle line:-1
这将会在内部分配系统内存

00:29:12.553 --> 00:29:15.522 align:middle line:-2
使用.contents方法
指向此内存区域

00:29:18.625 --> 00:29:20.460 align:middle line:-1
然后在设备B上创建缓冲区时

00:29:20.761 --> 00:29:25.032 align:middle line:-2
使用NoCopy API包装
刚才为缓冲区分配的内存

00:29:27.000 --> 00:29:29.136 align:middle line:-1
对于此API 需要知道的是

00:29:29.203 --> 00:29:32.406 align:middle line:-1
缓冲区必须是多页面大小

00:29:32.472 --> 00:29:35.442 align:middle line:-2
因此在创建原始缓冲区时
必须设置合适的内存大小

00:29:38.745 --> 00:29:41.381 align:middle line:-1
现在 我们可以在设备之间共享内存

00:29:41.448 --> 00:29:43.150 align:middle line:0
我们需要思考同步化问题

00:29:43.917 --> 00:29:46.420 align:middle line:0
为了描述这个问题
我们使用一个示例时间线

00:29:46.486 --> 00:29:48.989 align:middle line:0
来描述两个并行运行的GPU

00:29:49.489 --> 00:29:51.792 align:middle line:0
黑框表示指令缓冲区

00:29:51.859 --> 00:29:53.026 align:middle line:0
绿框表示我们编码进入

00:29:53.093 --> 00:29:55.996 align:middle line:0
这些指令缓冲区中的工作内容

00:29:56.296 --> 00:29:58.632 align:middle line:0
例如 使用计算指令编码器

00:30:00.033 --> 00:30:03.036 align:middle line:0
因此 上方GPU将进行渲染

00:30:03.470 --> 00:30:06.273 align:middle line:0
渲染完成之后
它将完成的区域

00:30:06.340 --> 00:30:08.408 align:middle line:0
Blit进入前面所述的共享缓冲区

00:30:09.910 --> 00:30:11.078 align:middle line:0
在此过程中

00:30:11.678 --> 00:30:13.714 align:middle line:0
GPU B也在进行渲染

00:30:15.082 --> 00:30:17.584 align:middle line:0
我们将使用这个GPU进行合成

00:30:18.118 --> 00:30:19.019 align:middle line:0
因此在某一时间点

00:30:19.086 --> 00:30:22.356 align:middle line:0
它将需要GPU A生成的缓冲区

00:30:23.357 --> 00:30:24.992 align:middle line:0
这里可看到 有一个问题

00:30:25.893 --> 00:30:28.228 align:middle line:0
这个区域没有同步化

00:30:28.996 --> 00:30:32.099 align:middle line:0
因此 在GPU完成写入缓冲区之前

00:30:32.165 --> 00:30:34.368 align:middle line:0
不能阻止GPU B读取缓冲区

00:30:35.669 --> 00:30:38.105 align:middle line:0
要处理该问题
可使用Metal Events

00:30:39.106 --> 00:30:41.008 align:middle line:0
利用Metal Events

00:30:41.074 --> 00:30:42.276 align:middle line:0
我们在指令缓冲区中
插入一个等待指令

00:30:43.043 --> 00:30:45.712 align:middle line:0
当GPU执行时
它会遇到等待指令

00:30:45.879 --> 00:30:47.447 align:middle line:0
然后就会停止

00:30:48.782 --> 00:30:51.818 align:middle line:0
它等待的是
其他GPU的信号

00:30:53.620 --> 00:30:55.022 align:middle line:0
收到信号之后

00:30:55.389 --> 00:30:58.058 align:middle line:0
我们就知道GPU A
已经完成缓冲区写入

00:30:58.125 --> 00:31:00.494 align:middle line:0
现在GPU B可以访问缓冲区

00:30:58.125 --> 00:31:00.494 align:middle line:0
现在GPU B可以访问缓冲区

00:31:02.596 --> 00:31:05.699 align:middle line:-2
这种方法可以巧妙地
解决同步化问题

00:31:06.800 --> 00:31:08.802 align:middle line:-1
但是很显然 使性能强劲的GPU

00:31:08.869 --> 00:31:13.106 align:middle line:-1
保持等待状态并不是一个良策

00:31:13.841 --> 00:31:16.210 align:middle line:-1
因此需要尽快缩短等待

00:31:16.276 --> 00:31:19.279 align:middle line:-2
理想的情况下 我们希望GPU
保持工作 而不是等待

00:31:20.848 --> 00:31:23.183 align:middle line:-2
在这里 我们讨论的是
负载平衡问题

00:31:24.585 --> 00:31:26.587 align:middle line:-1
因此 我们在GPU之间

00:31:26.653 --> 00:31:27.988 align:middle line:-1
均等地分配屏幕区域

00:31:28.055 --> 00:31:29.723 align:middle line:-1
这有一个问题

00:31:30.357 --> 00:31:32.159 align:middle line:-1
首先 这没有考虑

00:31:32.226 --> 00:31:34.661 align:middle line:-1
所使用的GPU性能可能存在差异

00:31:35.662 --> 00:31:37.464 align:middle line:-1
如果一个GPU速度更快

00:31:37.531 --> 00:31:40.067 align:middle line:-1
那么它会首先完成任务

00:31:41.535 --> 00:31:44.538 align:middle line:-2
另一个问题是
一些屏幕区域的渲染

00:31:44.605 --> 00:31:46.139 align:middle line:-1
比其他区域更加复杂

00:31:46.206 --> 00:31:47.107 align:middle line:-1
它们需要更长的时间

00:31:47.541 --> 00:31:50.777 align:middle line:-2
它们可能有更复杂的几何形状
或更复杂的材质

00:31:52.246 --> 00:31:53.380 align:middle line:-1
为了解决这个问题

00:31:53.614 --> 00:31:56.049 align:middle line:-2
我们需要自适应地
调整区域大小

00:31:56.850 --> 00:31:59.152 align:middle line:-1
这时的目标是确保每个GPU

00:31:59.219 --> 00:32:02.656 align:middle line:-2
使用大约相等的时间
完成其场景区域渲染

00:31:59.219 --> 00:32:02.656 align:middle line:-2
使用大约相等的时间
完成其场景区域渲染

00:32:04.291 --> 00:32:05.259 align:middle line:-1
为此 我们使用的方法是

00:32:05.325 --> 00:32:07.995 align:middle line:-1
从固定分区着手

00:32:08.362 --> 00:32:09.663 align:middle line:-1
然后我们渲染一个帧

00:32:10.597 --> 00:32:13.066 align:middle line:-2
测量每个GPU需要
多长时间完成渲染

00:32:13.500 --> 00:32:14.801 align:middle line:-1
然后我们根据此结果确定

00:32:14.868 --> 00:32:17.471 align:middle line:-1
为每个GPU分配多大的区域

00:32:19.940 --> 00:32:22.442 align:middle line:-2
将会在app运行时
完成这些工作

00:32:23.377 --> 00:32:25.846 align:middle line:-1
因此 它不断地适应

00:32:25.913 --> 00:32:26.847 align:middle line:-1
你的GPU的性能

00:32:27.181 --> 00:32:30.083 align:middle line:-2
无论使用哪个场景区域
来测量GPU的处理速度

00:32:32.953 --> 00:32:37.591 align:middle line:0
都会使用指令缓冲区完成处理程序
来获得结果

00:32:38.725 --> 00:32:41.662 align:middle line:0
完成处理程序是一个CPU代码块

00:32:41.728 --> 00:32:43.497 align:middle line:0
可在GPU完成执行
指令缓冲区之后

00:32:43.564 --> 00:32:45.432 align:middle line:0
运行此代码块

00:32:46.800 --> 00:32:48.535 align:middle line:0
现在iOS上

00:32:49.102 --> 00:32:50.904 align:middle line:0
指令缓冲区有多个有用的属性

00:32:50.971 --> 00:32:52.072 align:middle line:0
可以读取这些属性

00:32:52.139 --> 00:32:54.408 align:middle line:0
以发现在GPU上运行缓冲区的时间

00:32:55.609 --> 00:32:57.444 align:middle line:-1
但是它们在macOS上不可用

00:32:57.511 --> 00:32:59.446 align:middle line:-1
我们需要确保处理时间大致相当

00:33:00.747 --> 00:33:03.417 align:middle line:-2
我们使用的方法是
调用每个指令缓冲区完成处理程序时

00:33:03.483 --> 00:33:05.619 align:middle line:-1
存储主机时间

00:33:06.386 --> 00:33:08.188 align:middle line:-1
如果对每个指令缓冲区执行此操作

00:33:08.689 --> 00:33:10.591 align:middle line:-1
就可以根据这些时间差异

00:33:10.724 --> 00:33:12.593 align:middle line:-1
确定GPU运行时间

00:33:13.393 --> 00:33:14.294 align:middle line:-1
举例来说

00:33:15.195 --> 00:33:17.030 align:middle line:-1
为了估算这里显示的

00:33:17.097 --> 00:33:18.498 align:middle line:-1
三个指令缓冲区的执行时间

00:33:18.932 --> 00:33:21.301 align:middle line:-2
我们测量完成处理程序调用的
时间间隔

00:33:21.368 --> 00:33:24.004 align:middle line:-2
对于指令缓冲区3
和指令缓冲区0

00:33:26.640 --> 00:33:28.175 align:middle line:-1
这是理论性的

00:33:28.242 --> 00:33:29.743 align:middle line:-1
让我们来看实际运行情况

00:33:42.122 --> 00:33:44.591 align:middle line:-1
这是Sean前面展示过的

00:33:44.658 --> 00:33:46.760 align:middle line:-1
Amazon Lumberyard Bistro场景

00:33:47.561 --> 00:33:49.830 align:middle line:-2
这次它在MacBook Pro上
运行

00:33:50.797 --> 00:33:52.766 align:middle line:-1
在屏幕上方

00:33:52.833 --> 00:33:54.568 align:middle line:-1
有一个每秒光线数量指标

00:33:54.835 --> 00:33:56.870 align:middle line:-1
可以知道运行速度

00:33:57.471 --> 00:34:01.642 align:middle line:-2
这包括一次光线
二次光线和阴影光线

00:33:57.471 --> 00:34:01.642 align:middle line:-2
这包括一次光线
二次光线和阴影光线

00:34:01.708 --> 00:34:03.310 align:middle line:-1
都包含在这个指标中

00:34:04.444 --> 00:34:07.381 align:middle line:-2
可以看到
每秒处理三千万条光线

00:34:07.447 --> 00:34:08.282 align:middle line:-1
而且

00:34:08.415 --> 00:34:10.350 align:middle line:-1
如果速度加快 效果会更好

00:34:10.484 --> 00:34:11.685 align:middle line:-1
我想要启用

00:34:11.752 --> 00:34:13.987 align:middle line:-1
我连接的一个eGPU

00:34:17.024 --> 00:34:18.358 align:middle line:-1
这里的文字显示

00:34:18.425 --> 00:34:22.094 align:middle line:-2
我们运行RX 580
和内置GPU

00:34:22.629 --> 00:34:25.899 align:middle line:-2
性能提高了一倍
达到大约六千万条光线/秒

00:34:26.900 --> 00:34:28.268 align:middle line:-1
可以看到这里的绿线

00:34:28.335 --> 00:34:31.705 align:middle line:-2
它更好地显示
如何在GPU之间分配负载

00:34:32.039 --> 00:34:35.074 align:middle line:-1
一个GPU渲染绿线上方的场景

00:34:35.141 --> 00:34:37.344 align:middle line:-1
一个GPU渲染绿线下方的场景

00:34:38.745 --> 00:34:41.281 align:middle line:-1
因此 通过使用eGPU

00:34:41.348 --> 00:34:42.349 align:middle line:-1
能够将速度提高两倍

00:34:43.150 --> 00:34:45.452 align:middle line:-1
但是我还有更高的期望

00:34:45.786 --> 00:34:49.623 align:middle line:-2
问题是 eGPU
处于等待状态

00:34:50.123 --> 00:34:52.192 align:middle line:-1
这是因为我们使用固定分区方法

00:34:52.926 --> 00:34:55.429 align:middle line:-1
如果我们切换为自适应负载均衡方法

00:34:56.196 --> 00:34:59.233 align:middle line:-2
可以看到RX 580
现在承担了大部分的工作

00:34:59.299 --> 00:35:01.702 align:middle line:-1
相比以前速度明显更快

00:34:59.299 --> 00:35:01.702 align:middle line:-1
相比以前速度明显更快

00:35:04.638 --> 00:35:07.207 align:middle line:-1
这个场景大约有一百万个三角形

00:35:07.274 --> 00:35:09.877 align:middle line:-1
现在我们切换到室外场景

00:35:09.943 --> 00:35:13.213 align:middle line:-2
这也是Amazon Lumberyard场景
只不过是室外场景

00:35:13.313 --> 00:35:16.483 align:middle line:-1
这个场景大约有三百万个三角形

00:35:17.518 --> 00:35:20.921 align:middle line:-2
另外一个GPU处于等待状态
我们启用它

00:35:20.988 --> 00:35:21.822 align:middle line:-1
现在

00:35:22.656 --> 00:35:24.124 align:middle line:-1
这个GPU是Vega 64

00:35:24.858 --> 00:35:27.361 align:middle line:-2
可以看到Vega
承担了大部分的工作量

00:35:28.762 --> 00:35:30.831 align:middle line:-1
这个配置比较有趣

00:35:30.898 --> 00:35:33.634 align:middle line:-2
因为有三个不同的GPU
在共同工作

00:35:33.700 --> 00:35:35.235 align:middle line:-1
它们的架构不同

00:35:35.569 --> 00:35:37.037 align:middle line:-1
而且性能差异很大

00:35:37.104 --> 00:35:39.640 align:middle line:-2
但是它们协同工作
生成这幅高质量的图像

00:35:51.018 --> 00:35:53.954 align:middle line:-2
今天 我们介绍了
MPSRayIntersector

00:35:54.021 --> 00:35:55.389 align:middle line:-1
它是一个新的API

00:35:55.455 --> 00:35:58.325 align:middle line:-2
可用于在GPU上
加速光线三角形交叉

00:35:59.793 --> 00:36:01.028 align:middle line:-1
从前面的演示中可以看出

00:35:59.793 --> 00:36:01.028 align:middle line:-1
从前面的演示中可以看出

00:36:01.094 --> 00:36:04.364 align:middle line:-2
已经可以在所有的iOS
和macOS平台上使用此API

00:36:04.698 --> 00:36:08.001 align:middle line:-2
当你在macOS上添加GPU时
它具有良好的扩展性

00:36:09.770 --> 00:36:11.004 align:middle line:-1
我们希望看到

00:36:11.071 --> 00:36:13.540 align:middle line:-2
你们在app中
使用光线追踪技术

00:36:14.107 --> 00:36:16.977 align:middle line:-2
今天 我们在示例中
使用了路径追踪方法

00:36:17.311 --> 00:36:18.745 align:middle line:-1
以及混合渲染技术

00:36:18.812 --> 00:36:20.881 align:middle line:-1
你们可能希望使用光线追踪技术

00:36:20.948 --> 00:36:24.351 align:middle line:-2
生成美观的阴影
或环境光遮蔽 或反射

00:36:25.319 --> 00:36:27.254 align:middle line:-1
另外还有一些非渲染app

00:36:27.454 --> 00:36:31.225 align:middle line:-2
例如 自动模拟、物理
AI、冲撞检测

00:36:31.291 --> 00:36:32.926 align:middle line:-1
应用非常广泛

00:36:34.862 --> 00:36:35.963 align:middle line:-1
为了帮助你们上手

00:36:38.899 --> 00:36:41.535 align:middle line:-2
可以在developer.apple.com
查找示例代码

00:36:41.602 --> 00:36:43.003 align:middle line:-1
因此请务必查阅

00:36:43.470 --> 00:36:46.406 align:middle line:-1
另外还有头文件大量的文档

00:36:46.473 --> 00:36:48.742 align:middle line:-1
以及其他特性的相关信息

00:36:48.809 --> 00:36:50.344 align:middle line:-1
今天无法逐一讲解

00:36:51.411 --> 00:36:52.246 align:middle line:-1
最后

00:36:52.312 --> 00:36:54.014 align:middle line:-1
明天12:00还有实验室

00:36:54.515 --> 00:36:57.284 align:middle line:-2
Sean和我将会
更详细地讨论API

00:36:57.351 --> 00:37:00.120 align:middle line:-2
帮助你们在app中
使用光线追踪技术

00:36:57.351 --> 00:37:00.120 align:middle line:-2
帮助你们在app中
使用光线追踪技术

00:37:00.187 --> 00:37:01.755 align:middle line:-1
希望你们能参加

00:37:02.623 --> 00:37:03.490 align:middle line:-1
最后

00:37:03.557 --> 00:37:04.858 align:middle line:-1
感谢你们参加本演讲

00:37:04.925 --> 00:37:07.027 align:middle line:-2
希望你们在剩下的WWDC中
度过美好时光
