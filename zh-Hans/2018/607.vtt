WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:21.516 --> 00:00:26.466 A:middle
[ 掌声 ]

00:00:26.966 --> 00:00:27.686 A:middle
&gt;&gt; 欢迎大家

00:00:28.626 --> 00:00:30.496 A:middle
去年 我们介绍了第二代

00:00:30.616 --> 00:00:32.996 A:middle
Metal 技术 包括了新的用于

00:00:32.996 --> 00:00:34.426 A:middle
图形处理器（GPU）来驱动

00:00:34.426 --> 00:00:34.936 A:middle
渲染管线的方式

00:00:36.036 --> 00:00:37.526 A:middle
今年 我们将带来

00:00:37.526 --> 00:00:39.046 A:middle
更多新鲜的 激动人心的

00:00:39.046 --> 00:00:41.046 A:middle
技术来解决

00:00:41.046 --> 00:00:42.026 A:middle
常见的游戏开发中的挑战

00:00:43.086 --> 00:00:44.556 A:middle
我叫 Brian Ross

00:00:44.556 --> 00:00:45.676 A:middle
我将和我的同事

00:00:46.096 --> 00:00:48.016 A:middle
Michael Imbrogno 一起来展示

00:00:48.016 --> 00:00:49.416 A:middle
一些新的方式来使你的

00:00:49.416 --> 00:00:52.606 A:middle
App 更好 更快

00:00:52.606 --> 00:00:53.266 A:middle
并且更加有效率

00:00:54.776 --> 00:00:57.016 A:middle
但是首先 我想要谈一谈

00:00:57.016 --> 00:00:58.336 A:middle
那些我们试图去

00:00:58.336 --> 00:00:59.426 A:middle
帮助你们解决的问题

00:01:00.806 --> 00:01:02.086 A:middle
现在大家的游戏

00:01:02.086 --> 00:01:03.176 A:middle
使用了越来越多的

00:01:03.176 --> 00:01:05.896 A:middle
对象 材质 和光线

00:01:07.056 --> 00:01:08.706 A:middle
比如说 游戏“深处”（Inside）

00:01:09.156 --> 00:01:10.696 A:middle
使用了大量的特效

00:01:10.696 --> 00:01:12.956 A:middle
来捕捉和渲染

00:01:13.006 --> 00:01:14.316 A:middle
游戏带来的的情感

00:01:16.296 --> 00:01:17.486 A:middle
制作这样能让你全身心沉浸进去

00:01:17.586 --> 00:01:19.606 A:middle
的游戏是十分有挑战性的

00:01:19.606 --> 00:01:21.836 A:middle
因为它需要高效的

00:01:22.006 --> 00:01:23.196 A:middle
图形处理器（GPU）利用率

00:01:23.756 --> 00:01:27.176 A:middle
同时 游戏也需要

00:01:27.176 --> 00:01:28.886 A:middle
越来越多的 CPU 周期

00:01:28.886 --> 00:01:30.436 A:middle
为激动人心的游戏玩法做支撑

00:01:31.026 --> 00:01:33.116 A:middle
举个例子 游戏古墓丽影

00:01:33.116 --> 00:01:34.336 A:middle
不仅拥有

00:01:34.336 --> 00:01:36.256 A:middle
令人惊叹的风景和

00:01:36.256 --> 00:01:38.466 A:middle
极其细致的地形

00:01:38.526 --> 00:01:40.116 A:middle
他们还在

00:01:40.116 --> 00:01:41.946 A:middle
AI 中管理

00:01:41.946 --> 00:01:43.056 A:middle
复杂的物理仿真

00:01:44.066 --> 00:01:45.166 A:middle
这十分具有挑战性因为

00:01:45.166 --> 00:01:47.846 A:middle
预留了更少的 CPU 时间来实现渲染

00:01:49.556 --> 00:01:52.206 A:middle
最终 开发者们将把

00:01:52.206 --> 00:01:55.076 A:middle
3A 级游戏比如像来自 Epic Games

00:01:55.076 --> 00:01:57.456 A:middle
的《堡垒之夜》移植进

00:01:57.456 --> 00:01:59.606 A:middle
iOS 中 然后你们就

00:01:59.606 --> 00:02:02.326 A:middle
可以在手中玩游戏机级别的游戏了

00:01:59.606 --> 00:02:02.326 A:middle
可以在手中玩游戏机级别的游戏了

00:02:02.976 --> 00:02:04.746 A:middle
这是一个非常惊人的举动

00:02:05.496 --> 00:02:06.956 A:middle
但是它给我们带来了

00:02:06.956 --> 00:02:09.336 A:middle
更多的挑战 比如说像

00:02:09.336 --> 00:02:11.456 A:middle
如何平衡电池的寿命

00:02:11.456 --> 00:02:12.326 A:middle
和帧率之间的关系

00:02:12.896 --> 00:02:14.686 A:middle
现在 让我们来看一看 Metal 技术

00:02:14.906 --> 00:02:17.056 A:middle
是如何帮助我们解决这些挑战

00:02:18.656 --> 00:02:21.076 A:middle
今天 我将要展示给你们如何

00:02:21.076 --> 00:02:22.996 A:middle
在中央处理器（CPU）和图形处理器（GPU）

00:02:22.996 --> 00:02:25.806 A:middle
上利用并行来绘制

00:02:25.806 --> 00:02:26.756 A:middle
更复杂的场景

00:02:29.466 --> 00:02:31.386 A:middle
我们也将会谈到如何对堆

00:02:31.386 --> 00:02:33.456 A:middle
栅栏和事件进行

00:02:33.456 --> 00:02:35.306 A:middle
更加精确的控制

00:02:35.596 --> 00:02:36.946 A:middle
来最优化性能

00:02:37.386 --> 00:02:41.116 A:middle
然后 我将要展示

00:02:41.116 --> 00:02:43.366 A:middle
如何使用我们的最新功能

00:02:43.366 --> 00:02:44.816 A:middle
参数缓冲区和间接命令缓冲区

00:02:44.816 --> 00:02:46.656 A:middle
来构建图形处理器（GPU）

00:02:46.656 --> 00:02:47.896 A:middle
驱动的管线

00:02:48.306 --> 00:02:49.656 A:middle
虽然所有的这些 API 提升

00:02:49.656 --> 00:02:51.606 A:middle
都很关键

00:02:51.606 --> 00:02:53.446 A:middle
但理解支持他们运行的

00:02:53.446 --> 00:02:55.026 A:middle
底层硬件也十分重要

00:02:55.866 --> 00:02:57.776 A:middle
所以接下来

00:02:57.776 --> 00:02:59.226 A:middle
我的同事 Michael 将要给

00:02:59.226 --> 00:03:01.126 A:middle
你们展示如何针对

00:02:59.226 --> 00:03:01.126 A:middle
你们展示如何针对

00:03:01.126 --> 00:03:03.086 A:middle
A11 来进行优化以达到提升性能

00:03:03.246 --> 00:03:04.286 A:middle
延长游戏时间的目的

00:03:05.176 --> 00:03:08.616 A:middle
最后 我很高兴

00:03:08.616 --> 00:03:09.756 A:middle
来自 Epic Games 的 Nick Penwarden

00:03:09.756 --> 00:03:12.386 A:middle
将会加入我们

00:03:12.736 --> 00:03:14.366 A:middle
他将给我们展示

00:03:14.366 --> 00:03:15.836 A:middle
他们是如何运用 Metal 技术使

00:03:15.836 --> 00:03:17.736 A:middle
游戏机级别的游戏可以在

00:03:17.736 --> 00:03:18.206 A:middle
我们的设备上运行

00:03:19.216 --> 00:03:23.286 A:middle
让我们开始吧

00:03:23.286 --> 00:03:25.176 A:middle
利用中央处理器（CPU）和图形处理器（GPU）

00:03:25.176 --> 00:03:27.526 A:middle
并行可能是

00:03:27.526 --> 00:03:28.816 A:middle
你可以做到的最重要

00:03:28.816 --> 00:03:32.116 A:middle
也是最简单的优化

00:03:32.116 --> 00:03:33.346 A:middle
在单线程上构建

00:03:33.346 --> 00:03:35.476 A:middle
命令流已经不能满足现在的要求了

00:03:36.266 --> 00:03:38.076 A:middle
最新款的 iPhone 拥有 6 个内核

00:03:38.356 --> 00:03:40.476 A:middle
而 iMac Pro 拥有多达 18 个内核

00:03:41.186 --> 00:03:42.876 A:middle
因此 可扩展的多线程

00:03:42.876 --> 00:03:45.856 A:middle
架构是我们所有设备

00:03:45.856 --> 00:03:49.896 A:middle
拥有卓越表现的关键

00:03:49.896 --> 00:03:51.286 A:middle
Metal 技术是为了

00:03:51.286 --> 00:03:51.936 A:middle
多线程而设计的

00:03:51.936 --> 00:03:53.736 A:middle
我将先向你们展示在中央处理器（CPU）

00:03:53.736 --> 00:03:55.966 A:middle
进行并行操作的两种方法

00:03:55.966 --> 00:03:56.826 A:middle
接下来我将展示 Metal 科技是

00:03:56.826 --> 00:03:58.526 A:middle
如何在图形处理器（GPU）上

00:03:58.526 --> 00:04:00.036 A:middle
自动进行并行的

00:03:58.526 --> 00:04:00.036 A:middle
自动进行并行的

00:04:00.036 --> 00:04:01.346 A:middle
作为本节的结尾

00:04:02.606 --> 00:04:04.426 A:middle
我们来举一个典型的

00:04:04.466 --> 00:04:05.726 A:middle
游戏架构的例子

00:04:06.816 --> 00:04:08.486 A:middle
使用经典的单线程

00:04:08.486 --> 00:04:10.026 A:middle
渲染 [ 音质不清晰 ]

00:04:10.156 --> 00:04:13.146 A:middle
你会将图形处理器（GPU）命令和

00:04:13.146 --> 00:04:14.826 A:middle
图形处理器（GPU）执行依次在单个

00:04:14.826 --> 00:04:15.446 A:middle
命令缓冲区内构建

00:04:16.446 --> 00:04:17.596 A:middle
通常情况下 你将会把这个时间

00:04:17.596 --> 00:04:18.995 A:middle
匹配到适合你的

00:04:18.995 --> 00:04:20.266 A:middle
帧时间当中

00:04:21.016 --> 00:04:22.766 A:middle
而且当然 你将得到

00:04:22.766 --> 00:04:24.486 A:middle
最长的延迟时间

00:04:24.486 --> 00:04:26.096 A:middle
由于整个命令缓冲区必须在

00:04:26.096 --> 00:04:28.036 A:middle
图形处理器（GPU）可以使用之前

00:04:28.036 --> 00:04:29.086 A:middle
进行编码

00:04:29.436 --> 00:04:30.586 A:middle
显然 有更好的方法可以来

00:04:30.586 --> 00:04:32.366 A:middle
做到这一点

00:04:32.366 --> 00:04:34.346 A:middle
所以我们要做的就是

00:04:34.346 --> 00:04:35.976 A:middle
和中央处理器（CPU）一起

00:04:36.056 --> 00:04:36.546 A:middle
进行并行构建

00:04:37.036 --> 00:04:41.766 A:middle
渲染和计算传递

00:04:41.766 --> 00:04:43.156 A:middle
是 Metal 技术中多线程操作

00:04:43.156 --> 00:04:44.146 A:middle
的基本粒度

00:04:45.046 --> 00:04:46.376 A:middle
所有你需要做的

00:04:46.376 --> 00:04:48.616 A:middle
就是创建多个命令缓冲区

00:04:48.616 --> 00:04:50.326 A:middle
并在单独的线程上

00:04:50.326 --> 00:04:51.806 A:middle
分别对不同的通道进行编码

00:04:52.356 --> 00:04:55.226 A:middle
你可以按照任何你希望的顺序

00:04:55.226 --> 00:04:55.806 A:middle
对它们进行编码

00:04:56.236 --> 00:04:57.856 A:middle
最终的执行顺序

00:04:57.856 --> 00:04:59.156 A:middle
取决于它们添加到

00:04:59.156 --> 00:05:00.216 A:middle
命令队列的先后

00:04:59.156 --> 00:05:00.216 A:middle
命令队列的先后

00:05:01.026 --> 00:05:02.696 A:middle
所以 现在让我们来看一看

00:05:02.696 --> 00:05:04.316 A:middle
在代码中这是多么容易实现

00:05:04.316 --> 00:05:09.606 A:middle
你可以看到这并不需要很多代码

00:05:10.136 --> 00:05:11.016 A:middle
你要做的第一件事是

00:05:11.016 --> 00:05:13.816 A:middle
从队列中创建

00:05:13.816 --> 00:05:15.146 A:middle
任意数量的命令缓冲区

00:05:16.346 --> 00:05:19.126 A:middle
接下来 我们将通过使用

00:05:19.126 --> 00:05:21.456 A:middle
enqueue 接口来提前定义

00:05:21.456 --> 00:05:22.846 A:middle
图形处理器（GPU）的执行顺序

00:05:23.366 --> 00:05:25.526 A:middle
这非常棒 因为

00:05:25.526 --> 00:05:27.076 A:middle
你可以在不用等待命令缓冲区

00:05:27.076 --> 00:05:28.746 A:middle
首先 被编码的情况下完成所有操作

00:05:29.436 --> 00:05:31.906 A:middle
最后 我们将为

00:05:31.906 --> 00:05:33.696 A:middle
每个部分创建

00:05:33.696 --> 00:05:35.536 A:middle
单独的线程和调用编码函数

00:05:35.826 --> 00:05:36.506 A:middle
这就是全部了

00:05:36.966 --> 00:05:37.996 A:middle
这就是你需要做的内容

00:05:38.566 --> 00:05:40.186 A:middle
它非常快速 非常

00:05:40.186 --> 00:05:41.446 A:middle
高效 而且非常简单

00:05:42.136 --> 00:05:43.516 A:middle
所以现在 让我们回到

00:05:43.516 --> 00:05:45.896 A:middle
前面的图表 看一下另一个例子

00:05:46.246 --> 00:05:49.166 A:middle
就像你所看到的 我们能够在

00:05:49.166 --> 00:05:51.356 A:middle
中央处理器（CPU）上执行很好的

00:05:51.356 --> 00:05:54.196 A:middle
并行操作 但是如果

00:05:54.196 --> 00:05:58.826 A:middle
你有一个非常长的渲染通道呢

00:05:58.826 --> 00:06:01.036 A:middle
在这种情况下 Metal 技术

00:05:58.826 --> 00:06:01.036 A:middle
在这种情况下 Metal 技术

00:06:01.036 --> 00:06:02.726 A:middle
使用了一个专用的并行编码器

00:06:02.766 --> 00:06:04.986 A:middle
它允许你在多个线程上

00:06:04.986 --> 00:06:06.586 A:middle
进行编码 并且无需

00:06:06.586 --> 00:06:08.266 A:middle
明确划分

00:06:08.266 --> 00:06:10.026 A:middle
渲染通道或命令缓冲区

00:06:10.686 --> 00:06:12.286 A:middle
所以现在 让我们来看一看它

00:06:12.286 --> 00:06:13.786 A:middle
在你的代码里有多简单

00:06:14.866 --> 00:06:17.106 A:middle
它看起来非常像之前的例子

00:06:17.776 --> 00:06:18.956 A:middle
你要做的第一件事就是

00:06:18.956 --> 00:06:21.066 A:middle
创建一个并行编码器

00:06:21.606 --> 00:06:23.776 A:middle
并且从这个并行编码器中

00:06:23.776 --> 00:06:25.386 A:middle
创建任意数量的从属编码器

00:06:25.436 --> 00:06:27.066 A:middle
很重要的一点是意识到

00:06:27.066 --> 00:06:28.146 A:middle
这实际上就是你

00:06:28.146 --> 00:06:29.976 A:middle
定义图形处理器（GPU）执行顺序的地方

00:06:32.026 --> 00:06:35.356 A:middle
接下来 我们将创建

00:06:35.356 --> 00:06:37.736 A:middle
单独的线程并单独对

00:06:37.776 --> 00:06:40.406 A:middle
我们的每个 G 缓冲（G-buffer）函数进行编码

00:06:40.966 --> 00:06:44.956 A:middle
最后 我们会设置一个

00:06:44.956 --> 00:06:46.286 A:middle
通知 当线程

00:06:46.286 --> 00:06:48.726 A:middle
完成时 我们可以在

00:06:48.726 --> 00:06:50.296 A:middle
并行编码器上调用结束编码

00:06:50.296 --> 00:06:50.926 A:middle
这就是全部了

00:06:51.186 --> 00:06:52.866 A:middle
这就是你并行化渲染通道

00:06:52.866 --> 00:06:54.416 A:middle
所需要做的全部内容

00:06:54.486 --> 00:06:55.606 A:middle
它非常快速

00:06:55.606 --> 00:06:56.206 A:middle
而且非常简单

00:06:56.206 --> 00:06:58.126 A:middle
现在我已经向你展示了两种在

00:06:58.126 --> 00:06:59.886 A:middle
中央处理器（CPU）上并行化的方法

00:07:00.836 --> 00:07:01.986 A:middle
现在让我们看看 Metal 技术

00:07:01.986 --> 00:07:02.766 A:middle
如何在图形处理器（GPU）上

00:07:02.766 --> 00:07:04.366 A:middle
为你进行自动并行化

00:07:04.946 --> 00:07:07.316 A:middle
所以让我们先从头看一下

00:07:07.316 --> 00:07:10.176 A:middle
一个框架示例 然后看一看

00:07:10.176 --> 00:07:12.316 A:middle
图形处理器（GPU）如何执行这个框架

00:07:13.296 --> 00:07:14.546 A:middle
基于你平台的功能

00:07:14.546 --> 00:07:17.006 A:middle
Metal 技术可以通过

00:07:17.006 --> 00:07:19.376 A:middle
分析数据相关性

00:07:19.376 --> 00:07:20.956 A:middle
自动提取并行性

00:07:21.576 --> 00:07:22.746 A:middle
现在让我们看一看这些相关性

00:07:22.746 --> 00:07:23.376 A:middle
当中的 2 个

00:07:24.726 --> 00:07:26.436 A:middle
在这个例子中 粒子模拟会

00:07:26.436 --> 00:07:28.416 A:middle
写入数据 而这些数据稍后

00:07:28.416 --> 00:07:30.116 A:middle
将会被效果用来

00:07:30.316 --> 00:07:31.456 A:middle
渲染粒子

00:07:32.816 --> 00:07:35.586 A:middle
类似地 G 缓冲（G-buffer）通道

00:07:36.106 --> 00:07:37.796 A:middle
生成几何图形 稍后将会通过

00:07:37.796 --> 00:07:38.916 A:middle
延迟着色过程

00:07:38.916 --> 00:07:43.256 A:middle
来计算材质的明暗

00:07:43.486 --> 00:07:45.216 A:middle
所有这些信息都

00:07:45.216 --> 00:07:46.686 A:middle
允许 Metal 技术自动

00:07:46.686 --> 00:07:49.276 A:middle
并且便宜地识别

00:07:49.816 --> 00:07:51.236 A:middle
可以并行运行的整个通道

00:07:51.236 --> 00:07:52.416 A:middle
例如使用异步计算

00:07:55.616 --> 00:07:57.896 A:middle
所以你可以在

00:07:57.936 --> 00:08:00.166 A:middle
图形处理器（GPU）上获得免费的并

00:07:57.936 --> 00:08:00.166 A:middle
图形处理器（GPU）上获得免费的并

00:08:00.166 --> 00:08:00.786 A:middle
行和异步计算

00:08:01.256 --> 00:08:02.436 A:middle
它是免费的原因是

00:08:02.436 --> 00:08:03.446 A:middle
Metal 技术不需要你

00:08:03.446 --> 00:08:04.486 A:middle
做任何特别的事情

00:08:04.486 --> 00:08:07.366 A:middle
我认为我们都喜欢

00:08:07.366 --> 00:08:09.096 A:middle
在图形处理器（GPU）上获得免费优化

00:08:09.726 --> 00:08:10.896 A:middle
但有时候作为一名

00:08:10.896 --> 00:08:13.346 A:middle
开发人员 你可能需要走得

00:08:13.346 --> 00:08:14.136 A:middle
更远一点

00:08:14.786 --> 00:08:16.506 A:middle
所以对于你代码中最关键的部分

00:08:16.506 --> 00:08:18.286 A:middle
Metal 技术允许你

00:08:18.316 --> 00:08:20.646 A:middle
逐步控制一些更深层次的内容

00:08:21.126 --> 00:08:23.546 A:middle
例如 你可以禁用

00:08:23.546 --> 00:08:25.056 A:middle
自动引用计数并

00:08:25.056 --> 00:08:27.286 A:middle
自己执行以节省中央处理器（CPU）时间

00:08:28.116 --> 00:08:30.266 A:middle
你也可以使用 Metal 堆

00:08:30.626 --> 00:08:33.466 A:middle
来真正低消耗地严格控制分配

00:08:33.956 --> 00:08:36.616 A:middle
并且 Metal 堆可以

00:08:36.616 --> 00:08:39.025 A:middle
由栅栏和事件补充 这可以让你

00:08:39.025 --> 00:08:41.126 A:middle
明确控制图形处理器（GPU）

00:08:41.126 --> 00:08:42.316 A:middle
的并行操作

00:08:44.376 --> 00:08:46.736 A:middle
许多游戏使用

00:08:46.736 --> 00:08:48.906 A:middle
大量的资源 这可能需要花费高昂的代价

00:08:49.476 --> 00:08:51.526 A:middle
分配需要不断和 OS

00:08:51.526 --> 00:08:54.076 A:middle
进行双向沟通 OS 系统必须映射

00:08:54.076 --> 00:08:56.096 A:middle
并初始化每个请求的内存

00:08:56.876 --> 00:08:58.066 A:middle
如果你的游戏使用临时

00:08:58.066 --> 00:08:59.606 A:middle
渲染目标 这些

00:08:59.606 --> 00:09:00.796 A:middle
分配可能发生在

00:08:59.606 --> 00:09:00.796 A:middle
分配可能发生在

00:09:00.796 --> 00:09:02.866 A:middle
你的框架中间 造成卡顿

00:09:03.726 --> 00:09:05.156 A:middle
资源堆是解决

00:09:05.256 --> 00:09:06.396 A:middle
这个问题的好方法

00:09:07.556 --> 00:09:08.786 A:middle
堆也可以让你提前从

00:09:09.386 --> 00:09:12.196 A:middle
系统中分配大量内存

00:09:12.456 --> 00:09:13.566 A:middle
然后 你就可以在

00:09:13.606 --> 00:09:14.966 A:middle
这些内存上添加或删除纹理

00:09:14.966 --> 00:09:16.546 A:middle
和缓冲区 而无需进行

00:09:16.546 --> 00:09:18.286 A:middle
任何昂贵的双向沟通

00:09:18.836 --> 00:09:20.836 A:middle
因此 从分配

00:09:20.836 --> 00:09:22.996 A:middle
3 种常规纹理的情况开始

00:09:23.866 --> 00:09:25.406 A:middle
Metal 技术通常将这些放到

00:09:25.406 --> 00:09:27.876 A:middle
3 个单独的分配中 但是

00:09:27.986 --> 00:09:29.776 A:middle
将这些全部分配到

00:09:29.776 --> 00:09:31.976 A:middle
单个堆中可以让你

00:09:31.976 --> 00:09:34.396 A:middle
提前在堆创建时执行

00:09:34.396 --> 00:09:35.286 A:middle
所有的内存分配

00:09:35.696 --> 00:09:37.456 A:middle
那么创建纹理

00:09:37.456 --> 00:09:39.296 A:middle
将会变得非常低耗

00:09:40.506 --> 00:09:42.956 A:middle
另外 堆有时可以

00:09:42.956 --> 00:09:44.836 A:middle
通过使分配更紧密

00:09:45.206 --> 00:09:47.286 A:middle
来更有效地使用空间

00:09:48.396 --> 00:09:50.696 A:middle
因此在使用传统模型时

00:09:50.696 --> 00:09:51.886 A:middle
你将取消分配纹理

00:09:52.736 --> 00:09:53.836 A:middle
将页释放回系统

00:09:53.836 --> 00:09:55.836 A:middle
然后重新分配

00:09:56.536 --> 00:09:57.796 A:middle
重新分配将再一次分配

00:09:57.796 --> 00:09:58.976 A:middle
一组新的纹理

00:09:59.476 --> 00:10:02.006 A:middle
通过使用堆 你可以取消分配和

00:09:59.476 --> 00:10:02.006 A:middle
通过使用堆 你可以取消分配和

00:10:02.006 --> 00:10:04.436 A:middle
重新分配资源 而无需任何昂贵的

00:10:04.436 --> 00:10:06.226 A:middle
和系统进行的双向沟通

00:10:08.156 --> 00:10:09.846 A:middle
最后 堆也可以让你

00:10:09.846 --> 00:10:12.406 A:middle
互相分享不同的内存资源

00:10:14.086 --> 00:10:15.376 A:middle
这在当你的

00:10:15.376 --> 00:10:16.916 A:middle
游戏框架有很多

00:10:16.916 --> 00:10:18.166 A:middle
临时渲染目标时非常有用

00:10:18.686 --> 00:10:19.846 A:middle
没有理由让这些目标

00:10:19.846 --> 00:10:21.276 A:middle
不断地占用不同的内存

00:10:21.276 --> 00:10:23.696 A:middle
所以你可以替换入口

00:10:23.696 --> 00:10:25.546 A:middle
并省下数百兆字节

00:10:26.236 --> 00:10:28.376 A:middle
现在 在替换入口的方式中

00:10:28.376 --> 00:10:30.666 A:middle
分配速度更快 但在

00:10:30.666 --> 00:10:31.996 A:middle
涉及相关性跟踪时 它并不是

00:10:31.996 --> 00:10:32.946 A:middle
完全没有影响的

00:10:33.466 --> 00:10:34.536 A:middle
让我们回到

00:10:34.536 --> 00:10:35.546 A:middle
框架示例来进行

00:10:35.546 --> 00:10:36.306 A:middle
更好的解释

00:10:38.356 --> 00:10:40.786 A:middle
当使用了堆时

00:10:40.786 --> 00:10:42.556 A:middle
Metal 技术就看不到单个的资源

00:10:42.556 --> 00:10:43.346 A:middle
因此它不能

00:10:43.586 --> 00:10:44.956 A:middle
自动识别通道之间

00:10:44.956 --> 00:10:46.236 A:middle
的读写相关性

00:10:46.236 --> 00:10:48.366 A:middle
例如示例中的

00:10:48.366 --> 00:10:49.946 A:middle
G 缓冲（G-buffer）和延期着色通道

00:10:51.056 --> 00:10:53.516 A:middle
所以你必须使用栅栏

00:10:53.516 --> 00:10:55.076 A:middle
来明确地标记哪个

00:10:55.136 --> 00:10:57.276 A:middle
通道产生数据 哪个通道

00:10:57.386 --> 00:10:58.286 A:middle
消耗数据

00:10:58.906 --> 00:11:00.856 A:middle
在这个例子中 G 缓冲（G-buffer）

00:10:58.906 --> 00:11:00.856 A:middle
在这个例子中 G 缓冲（G-buffer）

00:11:00.856 --> 00:11:02.576 A:middle
更新了栅栏 并且

00:11:02.576 --> 00:11:03.766 A:middle
延迟着色等待着它的结果

00:11:04.686 --> 00:11:08.266 A:middle
所以现在 让我们来看一看

00:11:08.266 --> 00:11:09.406 A:middle
如何在你的代码中应用

00:11:09.406 --> 00:11:10.966 A:middle
这些基本概念

00:11:12.856 --> 00:11:15.206 A:middle
我们要做的第一件事

00:11:15.206 --> 00:11:16.006 A:middle
就是将这个

00:11:16.006 --> 00:11:17.456 A:middle
应用到我们的 G 缓冲（G-buffer）和

00:11:17.456 --> 00:11:18.676 A:middle
延迟着色示例中

00:11:19.966 --> 00:11:21.356 A:middle
首先 我们将

00:11:21.356 --> 00:11:23.046 A:middle
从堆中分配我们的

00:11:23.046 --> 00:11:23.436 A:middle
临时渲染目标

00:11:23.806 --> 00:11:24.866 A:middle
这看起来非常像

00:11:24.866 --> 00:11:26.046 A:middle
今天在分配纹理时可能

00:11:26.046 --> 00:11:28.706 A:middle
已经做的事情

00:11:28.846 --> 00:11:31.056 A:middle
接下来 我们将渲染

00:11:31.056 --> 00:11:32.246 A:middle
该临时渲染目标

00:11:33.166 --> 00:11:35.646 A:middle
最后 在分段阶段

00:11:36.316 --> 00:11:38.216 A:middle
完成后更新栅栏

00:11:38.386 --> 00:11:39.526 A:middle
这将确保所有数据

00:11:39.526 --> 00:11:41.656 A:middle
在下一个通道使用它

00:11:41.656 --> 00:11:42.956 A:middle
之前生成

00:11:43.706 --> 00:11:45.876 A:middle
现在 让我们切换到

00:11:45.876 --> 00:11:47.356 A:middle
延迟着色过程

00:11:48.156 --> 00:11:49.936 A:middle
我们将使用

00:11:49.936 --> 00:11:51.346 A:middle
这个临时渲染目标来

00:11:51.346 --> 00:11:52.606 A:middle
计算材质的明暗

00:11:54.836 --> 00:11:56.196 A:middle
然后 我们将等待栅栏

00:11:56.196 --> 00:11:57.986 A:middle
来确保它在我们使用

00:11:58.046 --> 00:11:59.566 A:middle
之前已经生产完成了

00:12:00.486 --> 00:12:03.486 A:middle
最后 资源是可以替换的

00:12:03.486 --> 00:12:05.046 A:middle
这样我们就可以重新使用它来

00:12:05.046 --> 00:12:06.456 A:middle
进行其他操作

00:12:06.456 --> 00:12:07.816 A:middle
节省数百兆字节

00:12:08.916 --> 00:12:09.886 A:middle
现在我们已经讨论了

00:12:09.886 --> 00:12:11.866 A:middle
如何通过明确的控制

00:12:11.906 --> 00:12:13.196 A:middle
来进行并行化和优化性能

00:12:13.196 --> 00:12:16.126 A:middle
这非常棒 但是

00:12:16.126 --> 00:12:18.696 A:middle
如果你想让 GPU 更多地进入

00:12:18.696 --> 00:12:19.526 A:middle
参与这个过程呢

00:12:20.936 --> 00:12:25.566 A:middle
那么接下来我们来讨论一下 GPU 驱动的管线

00:12:25.626 --> 00:12:27.356 A:middle
你们的游戏正在将越来

00:12:27.356 --> 00:12:29.816 A:middle
越多的决策逻辑

00:12:30.356 --> 00:12:32.556 A:middle
转移到 GPU 上 尤其是当在

00:12:32.556 --> 00:12:34.036 A:middle
处理包含数千个

00:12:34.036 --> 00:12:36.046 A:middle
对象的超大型数据集

00:12:36.046 --> 00:12:37.556 A:middle
或场景图时

00:12:38.666 --> 00:12:41.376 A:middle
Metal 二代技术使

00:12:41.496 --> 00:12:43.226 A:middle
我们在 GPU 驱动管线

00:12:43.226 --> 00:12:45.236 A:middle
方面又迈出了重要一步

00:12:46.236 --> 00:12:47.506 A:middle
去年 我们引入了

00:12:47.606 --> 00:12:49.086 A:middle
间接参数缓冲区

00:12:49.516 --> 00:12:51.386 A:middle
这可以进一步降低

00:12:51.386 --> 00:12:53.336 A:middle
CPU 使用率 并将大部分

00:12:53.336 --> 00:12:55.166 A:middle
工作量转移到 GPU 上

00:12:56.046 --> 00:12:57.056 A:middle
今年 我们再一次引入了

00:12:57.056 --> 00:12:59.346 A:middle
间接命令缓冲区

00:12:59.346 --> 00:13:02.566 A:middle
这将允许你将

00:12:59.346 --> 00:13:02.566 A:middle
这将允许你将

00:13:02.566 --> 00:13:05.526 A:middle
整个渲染循环转移到 GPU 上

00:13:06.776 --> 00:13:09.046 A:middle
首先 让我们简要回顾一下

00:13:09.146 --> 00:13:10.236 A:middle
参数缓冲区的功能

00:13:11.076 --> 00:13:12.826 A:middle
参数缓冲区就是像大屏幕上

00:13:12.826 --> 00:13:16.386 A:middle
呈现的这样一个结构

00:13:17.756 --> 00:13:18.946 A:middle
以前这里

00:13:18.946 --> 00:13:20.026 A:middle
只有常量 但有了

00:13:20.026 --> 00:13:21.256 A:middle
参数缓冲区 我们可以拥有

00:13:21.326 --> 00:13:22.916 A:middle
纹理和采样器

00:13:23.606 --> 00:13:24.716 A:middle
在一切之前 这些必须具有

00:13:24.716 --> 00:13:26.646 A:middle
独立的着色器绑定点

00:13:27.666 --> 00:13:30.226 A:middle
但是由于这种结构

00:13:30.226 --> 00:13:31.366 A:middle
你可以在你的处理中

00:13:31.366 --> 00:13:32.646 A:middle
使用 Metal 着色语言的所有

00:13:32.646 --> 00:13:34.216 A:middle
功能 因此它非常

00:13:34.216 --> 00:13:35.906 A:middle
灵活并且非常简单

00:13:36.196 --> 00:13:37.156 A:middle
你可以执行像添加

00:13:37.156 --> 00:13:39.476 A:middle
子结构或数组甚至

00:13:39.476 --> 00:13:41.476 A:middle
是指向其他参数缓冲区的指针的操作

00:13:43.156 --> 00:13:44.556 A:middle
你可以修改纹理和

00:13:44.556 --> 00:13:46.856 A:middle
采样器 在 GPU 上创建

00:13:46.856 --> 00:13:49.516 A:middle
新材质并且无需 CPU 参与

00:13:50.766 --> 00:13:52.746 A:middle
或者 你可以制作巨大的

00:13:52.746 --> 00:13:54.446 A:middle
材质数组 并且使用

00:13:54.446 --> 00:13:56.886 A:middle
单实例绘图调用

00:13:56.886 --> 00:13:58.956 A:middle
来呈现许多具有独特属性的对象

00:14:00.466 --> 00:14:02.346 A:middle
参数缓冲区允许你将

00:14:02.986 --> 00:14:04.536 A:middle
材质管理卸载到

00:14:05.176 --> 00:14:08.366 A:middle
GPU 上并节省宝贵的 CPU 资源

00:14:08.916 --> 00:14:10.206 A:middle
但今年 我们把它稍微扩展了

00:14:10.206 --> 00:14:11.546 A:middle
一点 再稍稍

00:14:11.546 --> 00:14:13.436 A:middle
扩展了一点

00:14:13.926 --> 00:14:15.506 A:middle
我们开始加入 2 个新的

00:14:15.506 --> 00:14:16.516 A:middle
参数类型

00:14:17.426 --> 00:14:19.046 A:middle
它们包括管线状态和

00:14:19.156 --> 00:14:20.126 A:middle
命令缓冲区

00:14:21.056 --> 00:14:22.646 A:middle
现在 这些将用于

00:14:22.646 --> 00:14:24.226 A:middle
支持我们全新的

00:14:24.226 --> 00:14:24.836 A:middle
间接命令缓冲区功能

00:14:26.116 --> 00:14:27.916 A:middle
通过间接命令缓冲区

00:14:27.916 --> 00:14:30.956 A:middle
你可以在 GPU 上编码整个场景

00:14:31.506 --> 00:14:33.066 A:middle
在 CPU 上 你只有几个线程

00:14:33.066 --> 00:14:34.426 A:middle
可用于渲染

00:14:34.866 --> 00:14:35.936 A:middle
但是在 GPU 上

00:14:35.936 --> 00:14:37.986 A:middle
你拥有数百甚至

00:14:37.986 --> 00:14:40.976 A:middle
数千个可以同时运行的线程

00:14:41.716 --> 00:14:42.856 A:middle
通过间接命令缓冲区

00:14:42.856 --> 00:14:44.416 A:middle
你可以充分利用这种

00:14:44.416 --> 00:14:45.916 A:middle
大规模的并行性质

00:14:47.236 --> 00:14:49.186 A:middle
此外 间接命令缓冲区是

00:14:49.186 --> 00:14:51.376 A:middle
完全可以复用的

00:14:51.376 --> 00:14:52.556 A:middle
因此你可以只花费

00:14:52.556 --> 00:14:55.196 A:middle
一次编码成本 然后不断重复使用它

00:14:55.886 --> 00:14:57.626 A:middle
由于 ICB 是一个可直接

00:14:57.716 --> 00:15:00.276 A:middle
访问的缓冲区 因此你可以

00:14:57.716 --> 00:15:00.276 A:middle
访问的缓冲区 因此你可以

00:15:00.276 --> 00:15:01.836 A:middle
随时修改它的内容

00:15:02.086 --> 00:15:03.976 A:middle
例如更改着色器类型

00:15:03.976 --> 00:15:05.276 A:middle
或相机矩阵 或者其他

00:15:05.276 --> 00:15:06.606 A:middle
任何你可能需要更改的内容

00:15:07.036 --> 00:15:09.476 A:middle
当然 通过将渲染

00:15:09.476 --> 00:15:11.566 A:middle
转移到 GPU 上

00:15:11.566 --> 00:15:13.886 A:middle
你可以移除昂贵的 CPU

00:15:13.886 --> 00:15:15.216 A:middle
和 GPU 同步点 这些

00:15:15.216 --> 00:15:17.126 A:middle
同步点通常需要提交数据给它们

00:15:18.346 --> 00:15:19.636 A:middle
让我们来看一个例子

00:15:20.706 --> 00:15:23.186 A:middle
这是一个典型的游戏框架

00:15:23.646 --> 00:15:24.856 A:middle
一般的渲染循环有

00:15:24.856 --> 00:15:26.366 A:middle
常见的几个阶段

00:15:27.046 --> 00:15:29.066 A:middle
首先 你通过浏览

00:15:29.246 --> 00:15:30.806 A:middle
场景图来确定哪些对象

00:15:30.806 --> 00:15:31.456 A:middle
需要被渲染

00:15:32.016 --> 00:15:34.836 A:middle
你可能使用

00:15:34.886 --> 00:15:36.226 A:middle
视锥体剔除来确定

00:15:36.226 --> 00:15:37.236 A:middle
视锥体内的物体

00:15:38.016 --> 00:15:39.266 A:middle
你们中的一些人可能会

00:15:39.266 --> 00:15:41.486 A:middle
使用更加复杂的方法来解决

00:15:41.486 --> 00:15:42.206 A:middle
遮挡问题

00:15:42.576 --> 00:15:44.956 A:middle
此外细节选择的程度自然

00:15:45.056 --> 00:15:46.816 A:middle
而然地产生在这个阶段

00:15:47.576 --> 00:15:49.326 A:middle
只有当你编码并

00:15:49.326 --> 00:15:51.176 A:middle
提交命令缓冲区后 GPU 才会

00:15:51.176 --> 00:15:55.136 A:middle
开始使用它

00:15:55.816 --> 00:15:57.356 A:middle
越来越多的游戏正在将

00:15:57.356 --> 00:15:58.776 A:middle
确定可见对象的过程

00:15:58.776 --> 00:16:00.496 A:middle
转移到 GPU 上

00:15:58.776 --> 00:16:00.496 A:middle
转移到 GPU 上

00:16:01.306 --> 00:16:03.236 A:middle
GPU 在处理最近游戏中出现的

00:16:03.476 --> 00:16:04.906 A:middle
越来越复杂的场景方面

00:16:04.906 --> 00:16:05.796 A:middle
做得更好

00:16:06.936 --> 00:16:09.526 A:middle
不幸的是 这会在你的框架中

00:16:09.526 --> 00:16:10.816 A:middle
创建一个同步点

00:16:12.456 --> 00:16:14.486 A:middle
而且它使得 CPU 不能对

00:16:14.486 --> 00:16:16.266 A:middle
绘制调用进行编码直到

00:16:16.266 --> 00:16:17.996 A:middle
GPU 产生数据

00:16:18.466 --> 00:16:19.826 A:middle
在不浪费宝贵的

00:16:19.826 --> 00:16:21.436 A:middle
CPU 和 GPU 同步时间的情况下

00:16:21.436 --> 00:16:24.636 A:middle
完成该任务是极其困难的

00:16:25.716 --> 00:16:28.216 A:middle
ICB 的好处是巨大的

00:16:28.726 --> 00:16:30.176 A:middle
你不仅可以将最后的处理

00:16:30.176 --> 00:16:32.086 A:middle
转移到 GPU 上 还可以

00:16:32.646 --> 00:16:34.176 A:middle
自然移除任何

00:16:34.176 --> 00:16:35.426 A:middle
交换数据所需的

00:16:35.426 --> 00:16:37.766 A:middle
同步点 并且提高 CPU 和 GPU

00:16:37.806 --> 00:16:39.076 A:middle
的利用率

00:16:39.706 --> 00:16:42.116 A:middle
同时 你可以把

00:16:42.116 --> 00:16:43.886 A:middle
CPU 开销降至一个常量

00:16:44.566 --> 00:16:47.086 A:middle
所以让我们来看一下

00:16:47.086 --> 00:16:48.136 A:middle
编码的细节

00:16:49.166 --> 00:16:51.806 A:middle
我将首先使用前面的

00:16:51.806 --> 00:16:53.566 A:middle
例子来看一看

00:16:53.566 --> 00:16:55.316 A:middle
只有 GPU 可以提供的

00:16:55.316 --> 00:16:57.216 A:middle
大规模并行化

00:16:57.876 --> 00:16:59.736 A:middle
我们从剔除调度中的

00:16:59.736 --> 00:17:03.076 A:middle
可见对象列表和 LOD 开始

00:16:59.736 --> 00:17:03.076 A:middle
可见对象列表和 LOD 开始

00:17:03.796 --> 00:17:05.165 A:middle
另外 请记住

00:17:05.165 --> 00:17:07.066 A:middle
我们正在使用参数缓冲区的能力

00:17:07.896 --> 00:17:09.866 A:middle
所以在这种情况下

00:17:10.266 --> 00:17:12.816 A:middle
每个元素都有一个

00:17:12.816 --> 00:17:14.165 A:middle
指向实际属性的指针 所以

00:17:14.165 --> 00:17:15.496 A:middle
我们不需要将所有内容都存储在

00:17:15.496 --> 00:17:15.896 A:middle
同一个缓冲区内

00:17:17.736 --> 00:17:20.136 A:middle
这种方式为我们

00:17:20.136 --> 00:17:21.906 A:middle
节省了大量的内存和性能

00:17:22.116 --> 00:17:23.726 A:middle
这是因为我们只构建了

00:17:23.726 --> 00:17:25.126 A:middle
一小部分信息

00:17:25.896 --> 00:17:27.026 A:middle
实际参数缓冲区

00:17:27.026 --> 00:17:29.866 A:middle
包含几个级别的几何细节

00:17:30.936 --> 00:17:33.726 A:middle
它们包括位置

00:17:33.726 --> 00:17:35.406 A:middle
顶点缓冲区 索引缓冲区

00:17:35.406 --> 00:17:36.626 A:middle
和材质参数缓冲区

00:17:37.256 --> 00:17:39.486 A:middle
关于渲染 我们只选择每个对象的

00:17:39.876 --> 00:17:41.206 A:middle
多个 LOD 中的一个

00:17:41.836 --> 00:17:45.026 A:middle
实际的编码发生在

00:17:45.026 --> 00:17:47.126 A:middle
一个计算内核中 我们把它

00:17:47.126 --> 00:17:48.716 A:middle
编码成一个间接命令缓冲区

00:17:49.826 --> 00:17:51.716 A:middle
计算内核的每个

00:17:51.716 --> 00:17:53.756 A:middle
线程都编码一个绘制调用

00:17:54.226 --> 00:17:55.976 A:middle
所以我们读取对象

00:17:55.976 --> 00:17:58.756 A:middle
具有的所有属性 并将它们编码

00:17:58.756 --> 00:18:00.526 A:middle
到 ICB 中

00:17:58.756 --> 00:18:00.526 A:middle
到 ICB 中

00:18:01.336 --> 00:18:03.216 A:middle
这里有一些值得

00:18:03.216 --> 00:18:03.936 A:middle
注意的细节

00:18:04.336 --> 00:18:06.036 A:middle
你可以把 ICB 视为

00:18:06.036 --> 00:18:07.196 A:middle
一系列渲染命令

00:18:07.796 --> 00:18:09.156 A:middle
一个渲染命令包含

00:18:09.156 --> 00:18:10.716 A:middle
带有着色器的管线对象

00:18:11.136 --> 00:18:12.846 A:middle
任意数量的缓冲区

00:18:12.846 --> 00:18:14.466 A:middle
和绘制调用

00:18:14.736 --> 00:18:16.366 A:middle
然后 ICB 是为并行

00:18:16.366 --> 00:18:18.446 A:middle
而构建的 因此你可以同时进行编码

00:18:18.446 --> 00:18:20.256 A:middle
并且不用担心顺序

00:18:20.756 --> 00:18:23.316 A:middle
最后 我们使 API 保持

00:18:23.316 --> 00:18:25.126 A:middle
简单 所以以上这些操作

00:18:25.126 --> 00:18:26.836 A:middle
就像你今天在可能在 CPU 上所做的一样

00:18:28.116 --> 00:18:29.886 A:middle
另外 每个命令

00:18:29.886 --> 00:18:31.196 A:middle
可以有不同的属性 甚至不同的

00:18:31.196 --> 00:18:32.306 A:middle
绘制类型

00:18:32.566 --> 00:18:35.116 A:middle
因此 这对于许多人

00:18:35.116 --> 00:18:36.486 A:middle
可能在其他地方

00:18:36.486 --> 00:18:37.876 A:middle
看到的所有

00:18:37.876 --> 00:18:38.996 A:middle
间接渲染 都是十分

00:18:38.996 --> 00:18:39.886 A:middle
重要的一步

00:18:40.976 --> 00:18:42.096 A:middle
现在 我们来看看如何在

00:18:42.096 --> 00:18:43.036 A:middle
代码中执行此操作

00:18:44.416 --> 00:18:46.476 A:middle
编码一个绘图调用

00:18:46.476 --> 00:18:47.526 A:middle
就是这么容易

00:18:48.436 --> 00:18:49.616 A:middle
你要做的第一件事就是

00:18:49.616 --> 00:18:51.096 A:middle
使用你的线程 ID 得到索引

00:18:51.096 --> 00:18:53.666 A:middle
并通过索引来选择渲染命令

00:18:54.816 --> 00:18:57.296 A:middle
然后 我们要设置属性

00:18:57.586 --> 00:18:58.906 A:middle
在这个例子中

00:18:58.906 --> 00:19:00.286 A:middle
我们设置了一个具有管线状态的着色器

00:18:58.906 --> 00:19:00.286 A:middle
我们设置了一个具有管线状态的着色器

00:19:00.286 --> 00:19:03.396 A:middle
然后为几何和材质设置了

00:19:03.396 --> 00:19:04.976 A:middle
单独的缓冲区

00:19:05.886 --> 00:19:07.646 A:middle
最后 这是你编码一个绘图调用

00:19:07.646 --> 00:19:08.566 A:middle
一个绘图调用的方式

00:19:09.096 --> 00:19:10.126 A:middle
由于 Metal 着色语言

00:19:10.126 --> 00:19:11.826 A:middle
在 GPU 上编码真的变得

00:19:11.996 --> 00:19:13.136 A:middle
非常 非常简单

00:19:13.906 --> 00:19:15.486 A:middle
即使是在计算着色器中

00:19:15.486 --> 00:19:17.146 A:middle
这看起来就像

00:19:17.146 --> 00:19:18.786 A:middle
就像你今天在可能在 CPU 上所做的事一样

00:19:18.786 --> 00:19:21.636 A:middle
现在 我们再看另一个例子

00:19:23.116 --> 00:19:24.336 A:middle
这些是创建 编码和

00:19:24.946 --> 00:19:26.706 A:middle
执行 ICB 所需做的

00:19:26.896 --> 00:19:28.746 A:middle
一些基本工作

00:19:29.956 --> 00:19:32.576 A:middle
你首先填写一个状态描述来创建它

00:19:33.016 --> 00:19:34.646 A:middle
状态描述包含

00:19:34.646 --> 00:19:38.136 A:middle
绘制类型 继承

00:19:38.136 --> 00:19:40.346 A:middle
属性和每层的绑定计数等内容

00:19:40.596 --> 00:19:42.306 A:middle
这描述了间接缓冲区的

00:19:42.306 --> 00:19:43.446 A:middle
行为方式

00:19:44.116 --> 00:19:47.726 A:middle
在对 ICB 进行编码时

00:19:47.726 --> 00:19:49.506 A:middle
你只需创建

00:19:49.506 --> 00:19:50.996 A:middle
计算编码器和调用调度

00:19:50.996 --> 00:19:52.276 A:middle
就像你已经在做的一样

00:19:54.046 --> 00:19:55.786 A:middle
一旦 ICB 被编码

00:19:55.786 --> 00:19:58.116 A:middle
你可以选择是否要优化它

00:19:58.486 --> 00:19:59.786 A:middle
当你决定优化它

00:19:59.886 --> 00:20:01.526 A:middle
你会删除所有的冗余状态

00:19:59.886 --> 00:20:01.526 A:middle
你会删除所有的冗余状态

00:20:01.526 --> 00:20:03.036 A:middle
最终的结果是

00:20:03.036 --> 00:20:05.196 A:middle
一组精简而高效的 GPU 命令

00:20:06.226 --> 00:20:08.876 A:middle
现在 一旦 ICB 被编码

00:20:08.876 --> 00:20:10.416 A:middle
和优化 就可以安排它进行

00:20:10.416 --> 00:20:11.286 A:middle
执行操作了

00:20:11.776 --> 00:20:12.986 A:middle
你会注意到

00:20:12.986 --> 00:20:14.996 A:middle
在这里你实际上可以

00:20:14.996 --> 00:20:16.396 A:middle
指定你执行的命令的确切范围

00:20:17.316 --> 00:20:18.736 A:middle
同样在这个例子中

00:20:18.736 --> 00:20:20.666 A:middle
我们使用了一个间接缓冲区

00:20:21.076 --> 00:20:22.476 A:middle
它本身就可以用 GPU 编码

00:20:25.586 --> 00:20:28.066 A:middle
所以一旦 ICB 完成编码

00:20:28.066 --> 00:20:29.746 A:middle
它就可以被一次又一次地

00:20:29.746 --> 00:20:31.526 A:middle
重复使用 并且开销是完全

00:20:31.526 --> 00:20:32.146 A:middle
可以被忽略不计的

00:20:32.856 --> 00:20:33.966 A:middle
我非常兴奋

00:20:33.966 --> 00:20:35.236 A:middle
但我们还要接着往下走

00:20:35.236 --> 00:20:36.686 A:middle
我们将一个例子与代码放在一起

00:20:36.686 --> 00:20:37.206 A:middle
以便你们可以看一下

00:20:39.216 --> 00:20:41.066 A:middle
在屏幕上

00:20:41.066 --> 00:20:42.756 A:middle
你可以看到一些城市中的校车

00:20:43.996 --> 00:20:46.766 A:middle
每辆校车由 500,000

00:20:46.766 --> 00:20:50.326 A:middle
个多边形和 2000 个独立部分组成

00:20:50.866 --> 00:20:53.446 A:middle
每个部分都需要

00:20:53.446 --> 00:20:55.116 A:middle
一个单独的绘图调用 它自己的

00:20:55.116 --> 00:20:56.836 A:middle
材质参数缓冲区 索引缓冲区

00:20:56.836 --> 00:20:57.636 A:middle
和顶点缓冲区

00:20:58.606 --> 00:21:00.006 A:middle
正如你想象的那样

00:20:58.606 --> 00:21:00.006 A:middle
正如你想象的那样

00:21:00.006 --> 00:21:01.966 A:middle
这将会有很多 CPU 上的 API 调用

00:21:02.036 --> 00:21:04.116 A:middle
但是我们在这里使用了

00:21:04.116 --> 00:21:05.106 A:middle
间接命令缓冲区

00:21:05.156 --> 00:21:07.356 A:middle
所以一切都将在 GPU 上编码

00:21:09.276 --> 00:21:10.786 A:middle
我们也会选择

00:21:10.926 --> 00:21:12.926 A:middle
合适的的细节级别

00:21:12.926 --> 00:21:13.906 A:middle
因此 我们可以在

00:21:13.906 --> 00:21:16.676 A:middle
呈现多个对象的同时

00:21:16.676 --> 00:21:19.046 A:middle
也不会增加 CPU 或 GPU 上的花费

00:21:19.736 --> 00:21:20.966 A:middle
在屏幕左边 你可以看到

00:21:20.966 --> 00:21:22.486 A:middle
常规相机的视图

00:21:22.776 --> 00:21:23.906 A:middle
而在屏幕右侧

00:21:23.906 --> 00:21:25.786 A:middle
我们放大了一辆校车

00:21:25.786 --> 00:21:27.916 A:middle
你可以看到细节级别在变化

00:21:29.126 --> 00:21:31.346 A:middle
ICB 使我们能够

00:21:31.346 --> 00:21:32.936 A:middle
推出另一个令人难以置信的

00:21:32.936 --> 00:21:33.746 A:middle
优化方式

00:21:35.886 --> 00:21:37.456 A:middle
我们能够将几何体

00:21:37.456 --> 00:21:39.036 A:middle
分成由几百个

00:21:39.036 --> 00:21:40.356 A:middle
三角形组成的块 并在单独的

00:21:40.356 --> 00:21:42.126 A:middle
计算内核中分析这些块

00:21:43.366 --> 00:21:44.466 A:middle
你可以在屏幕上看到

00:21:44.466 --> 00:21:45.706 A:middle
不同颜色的色块

00:21:47.106 --> 00:21:48.236 A:middle
内核的每个线程都会

00:21:48.236 --> 00:21:49.796 A:middle
确定三角形是否

00:21:49.796 --> 00:21:51.456 A:middle
背对着相机 或者它们

00:21:51.456 --> 00:21:52.696 A:middle
是否被场景中的

00:21:52.696 --> 00:21:54.906 A:middle
其他对象或几何体遮挡

00:21:55.756 --> 00:21:57.566 A:middle
这是真的非常快

00:21:57.566 --> 00:21:58.386 A:middle
因为我们只对一个块

00:21:58.386 --> 00:22:00.526 A:middle
进行计算 而不是每个

00:21:58.386 --> 00:22:00.526 A:middle
进行计算 而不是每个

00:22:00.526 --> 00:22:02.356 A:middle
单独的三角形

00:22:03.576 --> 00:22:05.496 A:middle
然后我们告诉 GPU

00:22:05.496 --> 00:22:06.536 A:middle
只渲染那些

00:22:06.536 --> 00:22:07.416 A:middle
实际可见的块

00:22:07.916 --> 00:22:11.956 A:middle
再一次 让我们看一下

00:22:11.956 --> 00:22:13.016 A:middle
屏幕左右侧的视图

00:22:13.406 --> 00:22:14.566 A:middle
左侧是相机视图

00:22:14.566 --> 00:22:16.376 A:middle
右侧是校车的

00:22:16.376 --> 00:22:17.556 A:middle
另一个​​视图

00:22:18.466 --> 00:22:20.346 A:middle
你可以在右侧看到红色和

00:22:20.346 --> 00:22:21.326 A:middle
粉红色的色调

00:22:21.326 --> 00:22:22.846 A:middle
这就是我们的计算着色器

00:22:22.846 --> 00:22:24.306 A:middle
所确定的不可见的部分

00:22:25.536 --> 00:22:27.606 A:middle
我们从未真正将此场景

00:22:27.606 --> 00:22:30.216 A:middle
发送给 GPU 因此它可以节省 50％

00:22:30.216 --> 00:22:32.536 A:middle
或更多的几何渲染成本

00:22:35.896 --> 00:22:38.316 A:middle
这是最后一个视图

00:22:38.316 --> 00:22:40.666 A:middle
它展示了这种技术 可以为你节省多少成本

00:22:41.846 --> 00:22:43.516 A:middle
注意右侧的画面

00:22:43.516 --> 00:22:44.876 A:middle
许多校车和救护车实际上

00:22:44.876 --> 00:22:45.976 A:middle
是隐形的

00:22:50.516 --> 00:22:52.036 A:middle
这实在是太神奇了

00:22:52.036 --> 00:22:52.866 A:middle
我喜欢这个

00:22:53.556 --> 00:22:55.156 A:middle
所以请尽情地探索代码

00:22:55.156 --> 00:22:56.996 A:middle
我希望我将来会在

00:22:57.136 --> 00:22:58.776 A:middle
一些游戏中看到

00:22:58.776 --> 00:22:59.986 A:middle
这种技术的应用

00:23:00.366 --> 00:23:02.496 A:middle
我想如果你使用了它

00:23:02.496 --> 00:23:03.746 A:middle
ICB 可以将你的游戏推向

00:23:03.746 --> 00:23:04.396 A:middle
更高的水平

00:23:05.356 --> 00:23:07.726 A:middle
现在 我很高兴向大家介绍

00:23:07.726 --> 00:23:09.346 A:middle
Michael 他将向你们

00:23:09.346 --> 00:23:11.596 A:middle
展示如何针对 A11 进行优化

00:23:11.596 --> 00:23:13.226 A:middle
改善性能并延长游戏时间

00:23:13.466 --> 00:23:14.266 A:middle
十分感谢

00:23:15.516 --> 00:23:20.156 A:middle
[ 掌声 ]

00:23:20.656 --> 00:23:21.196 A:middle
&gt;&gt; 谢谢 Brian

00:23:22.306 --> 00:23:23.386 A:middle
Brian 刚刚展示的

00:23:23.386 --> 00:23:24.996 A:middle
所有内容都适用于 iOS

00:23:25.296 --> 00:23:27.196 A:middle
tvOS 和 macOS

00:23:27.976 --> 00:23:29.226 A:middle
接下来 我将深入探讨

00:23:29.226 --> 00:23:30.696 A:middle
Apple 最新的 GPU A11 Bionic

00:23:30.696 --> 00:23:32.706 A:middle
拥有的 Metal 二代技术

00:23:32.706 --> 00:23:34.296 A:middle
的一些新功能 它们

00:23:34.296 --> 00:23:35.806 A:middle
旨在通过减少

00:23:35.866 --> 00:23:37.656 A:middle
系统内存带宽和降低功耗

00:23:37.656 --> 00:23:39.106 A:middle
来帮助你最大化游戏性能

00:23:39.256 --> 00:23:40.696 A:middle
并且延长游戏时间

00:23:45.046 --> 00:23:46.556 A:middle
Apple 设计的 GPU

00:23:46.556 --> 00:23:47.896 A:middle
拥有切片式延迟渲染架构

00:23:47.896 --> 00:23:49.506 A:middle
这是专为高性能和低功耗

00:23:49.506 --> 00:23:51.506 A:middle
而设计的

00:23:52.336 --> 00:23:53.446 A:middle
这种架构利用

00:23:53.446 --> 00:23:54.746 A:middle
高带宽低延迟的

00:23:54.936 --> 00:23:56.766 A:middle
内存来消除透支

00:23:57.036 --> 00:23:58.686 A:middle
和不必要的

00:23:58.686 --> 00:23:59.876 A:middle
内存流量

00:24:02.606 --> 00:24:03.796 A:middle
现在 Metal 技术在

00:24:03.796 --> 00:24:05.036 A:middle
每个渲染通道

00:24:05.036 --> 00:24:06.636 A:middle
加载和存储操作中都

00:24:06.636 --> 00:24:08.796 A:middle
自动利用 TBDR 架构

00:24:08.796 --> 00:24:10.636 A:middle
明确了渲染通道的

00:24:10.636 --> 00:24:11.936 A:middle
内容是如何写入和写出

00:24:11.996 --> 00:24:13.226 A:middle
Tile 内存的

00:24:16.386 --> 00:24:18.266 A:middle
但 A11 GPU 进一步利用了

00:24:18.266 --> 00:24:19.706 A:middle
TBDR 架构

00:24:20.306 --> 00:24:21.656 A:middle
我们在 Tile 的内存中

00:24:21.656 --> 00:24:23.046 A:middle
添加了新功能 并且增加了一个

00:24:23.046 --> 00:24:24.656 A:middle
全新的可编程阶段

00:24:25.556 --> 00:24:27.456 A:middle
这为高级的渲染技术

00:24:27.456 --> 00:24:28.826 A:middle
提供了至关重要

00:24:28.826 --> 00:24:30.056 A:middle
的新的优化机会

00:24:30.456 --> 00:24:31.706 A:middle
例如延迟着色

00:24:32.246 --> 00:24:33.546 A:middle
与顺序无关的透明度

00:24:34.086 --> 00:24:35.726 A:middle
平铺正向着色

00:24:35.726 --> 00:24:36.426 A:middle
和粒子渲染

00:24:37.676 --> 00:24:39.096 A:middle
让我们先

00:24:39.096 --> 00:24:40.796 A:middle
看一下 A11 GPU 的架构

00:24:44.066 --> 00:24:46.236 A:middle
好的 在屏幕的左边

00:24:46.236 --> 00:24:47.846 A:middle
我们有 A11 GPU 的展示

00:24:47.956 --> 00:24:49.246 A:middle
而在屏幕右边

00:24:49.246 --> 00:24:49.586 A:middle
我们有系统内存的展示

00:24:51.486 --> 00:24:53.736 A:middle
现在 A11 GPU 先处理

00:24:53.736 --> 00:24:54.866 A:middle
所有顶点阶段在

00:24:54.866 --> 00:24:56.596 A:middle
渲染通道中的几何

00:24:57.096 --> 00:24:58.646 A:middle
它将你的几何

00:24:58.646 --> 00:25:00.136 A:middle
变换并弯曲成屏幕对齐

00:24:58.646 --> 00:25:00.136 A:middle
变换并弯曲成屏幕对齐

00:25:00.526 --> 00:25:01.796 A:middle
的平铺顶点缓冲区

00:25:02.416 --> 00:25:03.766 A:middle
然后这些平铺的

00:25:03.766 --> 00:25:04.886 A:middle
顶点缓冲区 将会存储在系统内存中

00:25:07.606 --> 00:25:08.876 A:middle
现在 每个平铺的顶点缓冲区

00:25:08.876 --> 00:25:10.876 A:middle
将作为碎片阶段的一部分

00:25:10.976 --> 00:25:12.476 A:middle
在传输时完全处理完

00:25:13.606 --> 00:25:15.026 A:middle
这种平铺架构可

00:25:15.026 --> 00:25:16.586 A:middle
以让你的游戏免费获得

00:25:16.586 --> 00:25:18.436 A:middle
2 个主要优化

00:25:19.596 --> 00:25:22.156 A:middle
首先 GPU 在使用快速的

00:25:22.156 --> 00:25:23.306 A:middle
用于传输的内存对任何像素

00:25:23.306 --> 00:25:25.476 A:middle
进行着色之前 对所有图元进行

00:25:25.476 --> 00:25:26.176 A:middle
光栅化处理

00:25:26.846 --> 00:25:28.606 A:middle
这消除了内存的透支

00:25:28.606 --> 00:25:30.386 A:middle
从而提高了性能并

00:25:30.386 --> 00:25:30.756 A:middle
降低了功耗

00:25:32.436 --> 00:25:36.886 A:middle
其次 用更大 更灵活的 Tile 内存

00:25:36.886 --> 00:25:37.726 A:middle
来存储着色片段

00:25:38.366 --> 00:25:39.766 A:middle
混合操作速度很快

00:25:39.766 --> 00:25:40.796 A:middle
这是是由于所有数据都

00:25:40.796 --> 00:25:42.416 A:middle
存储在着色核心旁边用于

00:25:42.416 --> 00:25:42.806 A:middle
传输的内存上

00:25:43.326 --> 00:25:46.096 A:middle
现在 在所有 Tile 内存被

00:25:46.096 --> 00:25:48.266 A:middle
着色之后 每个

00:25:48.266 --> 00:25:50.476 A:middle
Tile 内存仅被写入系统内存一次

00:25:51.216 --> 00:25:52.946 A:middle
这会降低带宽

00:25:52.946 --> 00:25:54.256 A:middle
这同时也会提升你的性能

00:25:54.296 --> 00:25:56.696 A:middle
并降低功耗

00:25:56.826 --> 00:25:59.896 A:middle
现在 这些优化发生在一切之下

00:26:00.456 --> 00:26:01.736 A:middle
你只需在 iOS 上使用 Metal 技术即可

00:26:01.736 --> 00:26:02.306 A:middle
得到它们

00:26:03.106 --> 00:26:04.866 A:middle
但 Metal 技术还可以

00:26:04.866 --> 00:26:06.036 A:middle
通过明确控制 A11 的

00:26:06.036 --> 00:26:07.796 A:middle
Tile 的内存来优化

00:26:07.796 --> 00:26:08.596 A:middle
渲染技术

00:26:09.186 --> 00:26:12.166 A:middle
现在 在 A11 GPU 的

00:26:12.166 --> 00:26:13.866 A:middle
开发过程中 Apple 的硬件

00:26:13.866 --> 00:26:15.346 A:middle
和软件团队分析了

00:26:15.346 --> 00:26:16.946 A:middle
许多重要的现代

00:26:16.946 --> 00:26:17.846 A:middle
渲染技术

00:26:18.696 --> 00:26:20.406 A:middle
我们加速了内存

00:26:20.406 --> 00:26:22.166 A:middle
我们注意到了很多共同的主题

00:26:22.166 --> 00:26:23.476 A:middle
并且我们发现显式控制我们的

00:26:23.476 --> 00:26:26.906 A:middle
Tile 内存 可以为所有的这些内存加速

00:26:27.026 --> 00:26:28.036 A:middle
接下来 我们围绕

00:26:28.036 --> 00:26:29.656 A:middle
这种显式控制的想法

00:26:29.656 --> 00:26:31.416 A:middle
开发了硬件和软件功能

00:26:32.656 --> 00:26:34.976 A:middle
那么现在让我们来谈谈这些功能

00:26:41.656 --> 00:26:42.796 A:middle
可编程的混合让你

00:26:42.796 --> 00:26:43.676 A:middle
可以在着色器中编写

00:26:43.676 --> 00:26:44.976 A:middle
自定义的混合操作

00:26:45.386 --> 00:26:46.686 A:middle
它也是一个可以用来

00:26:46.686 --> 00:26:48.146 A:middle
合并渲染通道的

00:26:48.406 --> 00:26:49.396 A:middle
强大工具 实际上它可以

00:26:49.396 --> 00:26:51.446 A:middle
用于所有的 iOS 的 GPU

00:26:52.136 --> 00:26:53.726 A:middle
图像块（Imageblocks）是 A11 的新增功能

00:26:53.996 --> 00:26:55.046 A:middle
它们通过直接用

00:26:55.046 --> 00:26:56.756 A:middle
着色语言控制

00:26:56.756 --> 00:26:58.116 A:middle
像素布局 可以让你最大限度地

00:26:58.116 --> 00:26:58.936 A:middle
利用 Tile 的内存

00:26:59.466 --> 00:27:02.076 A:middle
Tile 的着色是我们

00:26:59.466 --> 00:27:02.076 A:middle
Tile 的着色是我们

00:27:02.076 --> 00:27:03.336 A:middle
全新的可编程舞台

00:27:03.336 --> 00:27:04.326 A:middle
它是专为需要混合图形

00:27:04.326 --> 00:27:05.526 A:middle
和计算处理的技术

00:27:05.526 --> 00:27:06.446 A:middle
而设计的

00:27:08.216 --> 00:27:09.856 A:middle
持久线程组内存是

00:27:09.856 --> 00:27:11.106 A:middle
组合渲染和计算的

00:27:11.106 --> 00:27:12.456 A:middle
重要工具 它允许

00:27:12.456 --> 00:27:13.556 A:middle
你通过绘制和调度

00:27:13.596 --> 00:27:14.556 A:middle
进行通信

00:27:15.076 --> 00:27:18.276 A:middle
多样本颜色覆盖控制

00:27:18.276 --> 00:27:20.026 A:middle
可以让你使用 Tile 的

00:27:20.026 --> 00:27:21.576 A:middle
着色器直接在 Tile 的内存中

00:27:21.576 --> 00:27:23.446 A:middle
执行解析操作

00:27:25.016 --> 00:27:26.036 A:middle
所以我要和你说一说

00:27:26.036 --> 00:27:27.066 A:middle
所有的这些功能

00:27:27.066 --> 00:27:28.336 A:middle
让我们从可编程混合开始吧

00:27:28.866 --> 00:27:33.006 A:middle
通过可编程混合

00:27:33.006 --> 00:27:34.056 A:middle
你的片段着色器

00:27:34.056 --> 00:27:35.796 A:middle
可以读取和写入像素和 Tile 的内存

00:27:36.466 --> 00:27:37.486 A:middle
这可以让你编写自定义的

00:27:37.486 --> 00:27:38.666 A:middle
混合操作

00:27:40.436 --> 00:27:42.256 A:middle
但是 可编程混合

00:27:42.256 --> 00:27:43.626 A:middle
还可以通过组合

00:27:43.626 --> 00:27:45.476 A:middle
多个读取和写入

00:27:45.476 --> 00:27:46.656 A:middle
相同内容的渲染通道来

00:27:46.656 --> 00:27:47.826 A:middle
消除系统内存带宽

00:27:49.916 --> 00:27:50.906 A:middle
现在 延迟着色

00:27:50.906 --> 00:27:52.166 A:middle
特别适合于

00:27:52.166 --> 00:27:53.466 A:middle
应用可编程混合 所以让

00:27:53.466 --> 00:27:58.016 A:middle
我们仔细看一下

00:27:58.496 --> 00:27:59.506 A:middle
延迟着色是

00:27:59.506 --> 00:28:00.456 A:middle
一种一般使用

00:27:59.506 --> 00:28:00.456 A:middle
一种一般使用

00:28:00.456 --> 00:28:02.446 A:middle
2 遍传递实现的多光技术

00:28:03.046 --> 00:28:04.916 A:middle
在第一遍中

00:28:04.916 --> 00:28:05.866 A:middle
多个附件填充了

00:28:05.906 --> 00:28:07.366 A:middle
每个像素可见的

00:28:07.366 --> 00:28:09.426 A:middle
几何属性 例如法线

00:28:09.886 --> 00:28:11.316 A:middle
反照率和粗糙度

00:28:12.136 --> 00:28:13.296 A:middle
在第二遍中 通过对那些

00:28:13.296 --> 00:28:14.776 A:middle
G 缓冲的内容进行采样来对

00:28:14.776 --> 00:28:15.856 A:middle
片段进行着色

00:28:16.456 --> 00:28:20.396 A:middle
现在 G 缓冲先被存储在

00:28:20.396 --> 00:28:21.766 A:middle
系统内存中 然后再次在

00:28:21.766 --> 00:28:23.146 A:middle
光照通道中读取

00:28:23.686 --> 00:28:24.976 A:middle
并且从 Tile 的内存到系统内存的

00:28:24.976 --> 00:28:26.516 A:middle
双向交流和再次回退

00:28:26.516 --> 00:28:28.046 A:middle
可能使你的游戏进入

00:28:28.046 --> 00:28:29.546 A:middle
瓶颈 因为 G 缓冲

00:28:29.546 --> 00:28:30.986 A:middle
轨道消耗了大量的带宽

00:28:31.566 --> 00:28:33.626 A:middle
现在 可编程混合可以

00:28:33.626 --> 00:28:35.206 A:middle
让你直接从 Tile 的内存

00:28:35.206 --> 00:28:36.646 A:middle
中读取到当前像素的

00:28:36.646 --> 00:28:38.636 A:middle
数据 从而跳过内存的

00:28:38.636 --> 00:28:40.916 A:middle
来回沟通

00:28:42.586 --> 00:28:43.506 A:middle
这也意味着我们

00:28:43.506 --> 00:28:44.666 A:middle
不再需要 2 次传递

00:28:44.966 --> 00:28:46.486 A:middle
我们 G 缓冲的填充

00:28:46.486 --> 00:28:48.096 A:middle
和光照步骤现在

00:28:48.096 --> 00:28:50.226 A:middle
被编码和运行在每个渲染通道中

00:28:51.536 --> 00:28:52.896 A:middle
这也意味着

00:28:52.896 --> 00:28:54.206 A:middle
我们不再需要系统内存中的

00:28:54.206 --> 00:28:55.856 A:middle
G 缓冲内容的副本

00:28:56.376 --> 00:28:59.166 A:middle
有了内存 Metal 技术的

00:28:59.166 --> 00:29:00.216 A:middle
无记忆渲染目标功能

00:28:59.166 --> 00:29:00.216 A:middle
无记忆渲染目标功能

00:29:00.216 --> 00:29:02.066 A:middle
对于节省内存来说真的非常

00:29:02.066 --> 00:29:03.066 A:middle
非常简单

00:29:03.616 --> 00:29:04.846 A:middle
你只需创建一个

00:29:04.846 --> 00:29:06.776 A:middle
带有无记忆标记的纹理

00:29:06.776 --> 00:29:08.246 A:middle
同时 Metal 技术仅允许

00:29:08.246 --> 00:29:09.416 A:middle
你在没有进行加载或存储操作的情况下

00:29:09.416 --> 00:29:10.176 A:middle
把它作为附件

00:29:10.746 --> 00:29:13.376 A:middle
所以 现在让我们来看一看

00:29:13.376 --> 00:29:14.476 A:middle
在着色器中使用可编程混合

00:29:14.476 --> 00:29:15.606 A:middle
是多么的容易

00:29:16.156 --> 00:29:20.056 A:middle
好的 这里是你的

00:29:20.056 --> 00:29:21.236 A:middle
光通道的

00:29:21.236 --> 00:29:23.366 A:middle
片段着色器在可编程混合中的样子

00:29:24.196 --> 00:29:25.786 A:middle
当你读取和写入

00:29:25.786 --> 00:29:27.606 A:middle
你的附件时 可编程混合将被启用

00:29:27.986 --> 00:29:29.526 A:middle
在这个例子中

00:29:29.526 --> 00:29:30.666 A:middle
我们看到 G 缓冲附件

00:29:30.666 --> 00:29:32.856 A:middle
既是我们函数的输入 又是函数的输出

00:29:32.956 --> 00:29:36.826 A:middle
我们首先使用我们的 G 缓冲的属性

00:29:36.826 --> 00:29:38.146 A:middle
来计算我们的照明

00:29:38.856 --> 00:29:39.886 A:middle
正如你在这里看到的

00:29:39.886 --> 00:29:41.006 A:middle
我们正在读取我们的附件

00:29:41.006 --> 00:29:41.866 A:middle
但我们并没有将它们作为纹理

00:29:41.866 --> 00:29:42.376 A:middle
进行采样

00:29:42.916 --> 00:29:45.676 A:middle
然后 我们将我们的照明的

00:29:45.676 --> 00:29:47.186 A:middle
累积结果返回 G 缓冲

00:29:47.186 --> 00:29:48.126 A:middle
在这一步中

00:29:48.126 --> 00:29:49.306 A:middle
我们都在读取和写入

00:29:49.306 --> 00:29:50.226 A:middle
我们的累积结果

00:29:50.616 --> 00:29:52.156 A:middle
这就是最后了

00:29:52.406 --> 00:29:53.946 A:middle
可编程混合真的非常简单

00:29:53.946 --> 00:29:55.256 A:middle
只要你有多个

00:29:55.256 --> 00:29:56.516 A:middle
读取和写入相同附件

00:29:56.516 --> 00:29:58.176 A:middle
的渲染过程 你就应该在

00:29:58.176 --> 00:29:59.356 A:middle
那里应用它

00:30:00.556 --> 00:30:02.416 A:middle
所以现在我们来讨论

00:30:02.416 --> 00:30:04.376 A:middle
一下图像块（Imageblocks）

00:30:04.376 --> 00:30:05.936 A:middle
它允许你在更多的情况下

00:30:05.936 --> 00:30:06.696 A:middle
合并渲染通道

00:30:12.476 --> 00:30:13.546 A:middle
图像块（Imageblocks）可以

00:30:13.546 --> 00:30:14.736 A:middle
让你在 Tile 的内存中完全

00:30:14.736 --> 00:30:15.116 A:middle
控制你的数据

00:30:15.536 --> 00:30:17.196 A:middle
图像块允许你以

00:30:17.196 --> 00:30:18.506 A:middle
结构体的形式直接用

00:30:18.506 --> 00:30:20.486 A:middle
着色语言声明像素布局

00:30:21.456 --> 00:30:22.696 A:middle
而不是将像素描述

00:30:22.696 --> 00:30:24.006 A:middle
为 Metal 技术的 API 中的

00:30:24.006 --> 00:30:25.816 A:middle
渲染通道内容中的数组

00:30:28.056 --> 00:30:29.336 A:middle
它将新的数据类型

00:30:29.336 --> 00:30:30.556 A:middle
添加到与你已经使用的

00:30:30.556 --> 00:30:31.856 A:middle
匹配纹理格式的

00:30:31.856 --> 00:30:33.446 A:middle
着色语言当中

00:30:33.446 --> 00:30:35.116 A:middle
并且在访问着色器时

00:30:35.116 --> 00:30:36.666 A:middle
这些类型被透明地打包和解压

00:30:37.646 --> 00:30:39.196 A:middle
实际上 你还可以在

00:30:39.196 --> 00:30:40.676 A:middle
顶点缓冲区和

00:30:40.676 --> 00:30:42.216 A:middle
常量缓冲区中使用

00:30:42.216 --> 00:30:43.976 A:middle
这些新的数据类型来更紧密地

00:30:43.976 --> 00:30:44.476 A:middle
打包所有数据

00:30:46.736 --> 00:30:47.946 A:middle
图像块（Imageblocks）还允许

00:30:47.946 --> 00:30:49.996 A:middle
你描述更复杂的每个像素

00:30:49.996 --> 00:30:50.826 A:middle
数据结构

00:30:51.176 --> 00:30:52.806 A:middle
你可以使用数组

00:30:52.806 --> 00:30:54.616 A:middle
嵌套结构或其组合

00:30:55.126 --> 00:30:56.586 A:middle
它们都可以正常运行

00:30:59.096 --> 00:31:01.016 A:middle
现在 直接控制

00:30:59.096 --> 00:31:01.016 A:middle
现在 直接控制

00:31:01.016 --> 00:31:02.176 A:middle
像素布局意味着

00:31:02.176 --> 00:31:03.666 A:middle
你现在可以在通道内

00:31:03.666 --> 00:31:04.186 A:middle
更改布局

00:31:04.796 --> 00:31:06.136 A:middle
这使你可以将渲染过程

00:31:06.136 --> 00:31:07.336 A:middle
组合起来 从而消除

00:31:07.336 --> 00:31:08.796 A:middle
系统内存带宽

00:31:08.796 --> 00:31:09.766 A:middle
而这种方式仅凭

00:31:09.766 --> 00:31:11.656 A:middle
可编程混合是无法实现的

00:31:11.656 --> 00:31:12.666 A:middle
让我们来看一个例子

00:31:15.156 --> 00:31:16.966 A:middle
在我们之前的例子中

00:31:16.966 --> 00:31:18.056 A:middle
我们使用可编程混合

00:31:18.056 --> 00:31:19.846 A:middle
来实现单通延迟着色

00:31:20.836 --> 00:31:21.756 A:middle
你也可以使用

00:31:21.756 --> 00:31:23.906 A:middle
图像块实现单通道延迟着色

00:31:25.346 --> 00:31:26.726 A:middle
图像块只存在于 Tile 内存中

00:31:26.726 --> 00:31:27.816 A:middle
所以没有渲染通道附件

00:31:27.816 --> 00:31:28.966 A:middle
需要处理

00:31:29.716 --> 00:31:31.066 A:middle
这不仅是一种

00:31:31.066 --> 00:31:32.406 A:middle
更加自然的表达算法的方式

00:31:32.716 --> 00:31:34.386 A:middle
而且现在你也可以在

00:31:34.386 --> 00:31:35.926 A:middle
完成照明后读取

00:31:35.926 --> 00:31:37.756 A:middle
G 缓冲 然后再重新使用 Tile 的内存

00:31:38.786 --> 00:31:39.996 A:middle
让我们继续

00:31:39.996 --> 00:31:41.396 A:middle
让我们重复使用

00:31:41.396 --> 00:31:43.006 A:middle
Tile 的内存来添加

00:31:43.196 --> 00:31:44.856 A:middle
一个称为多层 Alpha 混合的顺序无关的

00:31:44.896 --> 00:31:46.236 A:middle
透明度技术

00:31:51.466 --> 00:31:52.816 A:middle
多层 Alpha 混合（MLAB）

00:31:52.816 --> 00:31:55.676 A:middle
可维护每个像素

00:31:55.676 --> 00:31:57.896 A:middle
固定大小的半透明片段数组

00:31:58.556 --> 00:32:00.136 A:middle
每个传入的片段按

00:31:58.556 --> 00:32:00.136 A:middle
每个传入的片段按

00:32:00.136 --> 00:32:01.326 A:middle
深度排序加到数组中

00:32:02.186 --> 00:32:03.706 A:middle
如果一个片段的深度

00:32:03.706 --> 00:32:04.916 A:middle
超出了数组的最后

00:32:04.916 --> 00:32:06.246 A:middle
一个元素 那么

00:32:06.246 --> 00:32:07.536 A:middle
这些元素就会被合并

00:32:07.536 --> 00:32:09.126 A:middle
所以它实际上是

00:32:09.566 --> 00:32:09.766 A:middle
一个近似的技术

00:32:11.376 --> 00:32:12.976 A:middle
现在 对 MLAB 数组进行

00:32:12.976 --> 00:32:14.136 A:middle
排序速度非常快 因为它存在于

00:32:14.136 --> 00:32:14.746 A:middle
Tile 的内存中

00:32:15.556 --> 00:32:16.796 A:middle
由于额外的带宽

00:32:16.796 --> 00:32:18.186 A:middle
和同步开销 在芯片

00:32:18.186 --> 00:32:19.356 A:middle
上做同样的操作会变得

00:32:19.356 --> 00:32:20.346 A:middle
非常昂贵

00:32:20.856 --> 00:32:25.326 A:middle
A11 实际上是对

00:32:25.326 --> 00:32:26.826 A:middle
上一代支持的最大像素尺寸

00:32:26.826 --> 00:32:28.096 A:middle
进行了加倍

00:32:28.866 --> 00:32:30.466 A:middle
但这还不足以

00:32:30.466 --> 00:32:31.596 A:middle
同时包含

00:32:31.596 --> 00:32:34.606 A:middle
G 缓冲和 MLAB 数据结构

00:32:35.396 --> 00:32:37.366 A:middle
幸运的是 你不需要

00:32:37.366 --> 00:32:38.106 A:middle
同时使用两者

00:32:38.916 --> 00:32:40.076 A:middle
图像块（Imageblocks）允许

00:32:40.076 --> 00:32:41.896 A:middle
你在渲染过程中

00:32:41.896 --> 00:32:43.216 A:middle
更改像素布局以符合

00:32:43.916 --> 00:32:44.036 A:middle
你的当前需求

00:32:44.956 --> 00:32:47.296 A:middle
改变像素布局实际上

00:32:47.296 --> 00:32:48.926 A:middle
需要 Tile 的着色 所以我们接下来

00:32:48.926 --> 00:32:50.846 A:middle
来讨论一下这个

00:32:56.256 --> 00:32:58.036 A:middle
Tile 着色是

00:32:58.036 --> 00:32:59.516 A:middle
新的可编程阶段

00:32:59.516 --> 00:33:01.246 A:middle
它直接在渲染过程中提供了

00:32:59.516 --> 00:33:01.246 A:middle
它直接在渲染过程中提供了

00:33:01.246 --> 00:33:02.036 A:middle
计算能力

00:33:02.656 --> 00:33:04.016 A:middle
这个阶段将会在

00:33:04.016 --> 00:33:06.216 A:middle
每个 Tile 上执行一个可配置的线程组

00:33:06.756 --> 00:33:07.936 A:middle
举个例子

00:33:07.936 --> 00:33:09.626 A:middle
你可以为每个 Tile 启动一个线程

00:33:09.626 --> 00:33:10.846 A:middle
或者也可以为每个像素启动一个线程

00:33:14.286 --> 00:33:15.296 A:middle
Tile 的着色

00:33:15.336 --> 00:33:16.526 A:middle
可以让你交叉使用

00:33:16.526 --> 00:33:17.916 A:middle
对相同数据进行操作的绘制调用

00:33:17.916 --> 00:33:19.156 A:middle
和线程组调度

00:33:19.496 --> 00:33:21.796 A:middle
Tile 的着色器可

00:33:21.796 --> 00:33:23.066 A:middle
以访问所有 Tile 内存

00:33:23.066 --> 00:33:24.446 A:middle
因此它们可以读写图像块的任何像素

00:33:26.196 --> 00:33:27.696 A:middle
那么让我们来看一看

00:33:27.696 --> 00:33:31.286 A:middle
Tile 着色如何优化切片正向着色等技术

00:33:34.536 --> 00:33:36.406 A:middle
像延迟着色一样

00:33:36.406 --> 00:33:37.866 A:middle
切片正向着色是一种多层技术

00:33:38.616 --> 00:33:39.986 A:middle
我们通常会在

00:33:39.986 --> 00:33:41.406 A:middle
MSA 非常重要时

00:33:41.406 --> 00:33:43.356 A:middle
或需要各种材料时使用它

00:33:43.356 --> 00:33:44.676 A:middle
并且它对不透明和半透明几何图形

00:33:44.676 --> 00:33:48.476 A:middle
同样适用切片正向着色

00:33:48.476 --> 00:33:50.546 A:middle
一般由 3 次传递组成

00:33:51.226 --> 00:33:53.436 A:middle
首先 一个渲染通道生成了

00:33:53.436 --> 00:33:54.256 A:middle
一个场景深度缓冲区

00:33:55.136 --> 00:33:56.626 A:middle
其次 计算通道将会

00:33:56.626 --> 00:33:58.806 A:middle
生成并计算使用该场景

00:33:58.806 --> 00:34:00.716 A:middle
深度缓冲区的

00:33:58.806 --> 00:34:00.716 A:middle
深度缓冲区的

00:34:00.716 --> 00:34:02.446 A:middle
每个 Tile 深度边界和光源列表

00:34:03.326 --> 00:34:04.886 A:middle
最后 另一个渲染通道

00:34:04.886 --> 00:34:05.956 A:middle
将使用相应的光源列表

00:34:05.956 --> 00:34:08.096 A:middle
为每个 Tile 中的像素着色

00:34:08.706 --> 00:34:13.235 A:middle
现在 这种混合

00:34:13.235 --> 00:34:14.976 A:middle
渲染和计算的模式是很常见的

00:34:14.976 --> 00:34:17.366 A:middle
在 A11 之前

00:34:17.366 --> 00:34:19.226 A:middle
这些通道之间的交流需要系统内存

00:34:19.936 --> 00:34:21.755 A:middle
但是使用 Tile 着色

00:34:21.755 --> 00:34:22.856 A:middle
我们可以将计算内联

00:34:22.856 --> 00:34:24.036 A:middle
所以渲染通道就可以合并

00:34:26.396 --> 00:34:28.356 A:middle
在这里 深度边界和

00:34:28.356 --> 00:34:29.476 A:middle
光线剔除步骤被

00:34:29.476 --> 00:34:31.036 A:middle
作为 Tile 着色器实现

00:34:31.036 --> 00:34:32.576 A:middle
并内嵌到单个渲染通道中

00:34:33.496 --> 00:34:34.735 A:middle
深度现在只

00:34:34.735 --> 00:34:36.426 A:middle
存储在图像块中

00:34:36.525 --> 00:34:42.706 A:middle
但却可以在整个过程中被访问

00:34:42.906 --> 00:34:44.496 A:middle
所以现在 Tile 的着色

00:34:44.496 --> 00:34:45.696 A:middle
将帮助你消除大量带宽

00:34:45.696 --> 00:34:47.626 A:middle
但这些 Tile 的着色器的输出

00:34:47.626 --> 00:34:49.545 A:middle
仍然存储在系统内存中

00:34:50.545 --> 00:34:51.826 A:middle
Tile 的着色器

00:34:51.826 --> 00:34:53.226 A:middle
调度与绘制同步

00:34:53.226 --> 00:34:54.286 A:middle
所以这是完全安全的

00:34:54.656 --> 00:34:55.606 A:middle
但我认为我们仍然可以

00:34:55.606 --> 00:34:57.136 A:middle
使用我们的下一个功能

00:34:57.706 --> 00:34:59.426 A:middle
持久线程组内存 来使我们做得更好

00:35:05.336 --> 00:35:06.846 A:middle
好的 线程组内存

00:35:06.846 --> 00:35:08.206 A:middle
是 Metal 技术计算的一个众所周知的特性

00:35:08.826 --> 00:35:09.856 A:middle
它使线程组内的线程

00:35:09.856 --> 00:35:11.766 A:middle
可以使用快速的 用于传输的内存

00:35:11.766 --> 00:35:12.636 A:middle
来共享数据

00:35:13.736 --> 00:35:14.886 A:middle
现在 由于 Tile 着色

00:35:14.936 --> 00:35:16.096 A:middle
线程组内存也可以在

00:35:16.096 --> 00:35:17.396 A:middle
渲染通道中使用

00:35:18.446 --> 00:35:19.586 A:middle
但渲染通道中的

00:35:19.586 --> 00:35:20.756 A:middle
线程组内存含有

00:35:20.756 --> 00:35:21.946 A:middle
2 个传统上不可用于计算

00:35:21.946 --> 00:35:22.766 A:middle
的新功能

00:35:23.376 --> 00:35:25.286 A:middle
首先 片段着色器

00:35:25.286 --> 00:35:26.756 A:middle
现在也可以访问相同的

00:35:26.756 --> 00:35:27.446 A:middle
线程组内存

00:35:28.126 --> 00:35:29.366 A:middle
其次 线程组内存

00:35:29.366 --> 00:35:30.496 A:middle
的内容在整个

00:35:30.496 --> 00:35:32.116 A:middle
Tile 的整个生命周期中都存在

00:35:33.476 --> 00:35:35.706 A:middle
总而言之 这是

00:35:35.756 --> 00:35:37.146 A:middle
一个强大的工具

00:35:37.146 --> 00:35:39.286 A:middle
可以让数据在绘制和调度之间共享

00:35:40.486 --> 00:35:41.646 A:middle
实际上 我们相信

00:35:41.646 --> 00:35:42.666 A:middle
这会非常有用

00:35:42.666 --> 00:35:43.916 A:middle
因为我们实际上已经

00:35:43.916 --> 00:35:44.876 A:middle
使线程组内存的最大容量翻倍

00:35:44.876 --> 00:35:46.466 A:middle
比起上一代来说

00:35:46.466 --> 00:35:47.326 A:middle
你可以将更多的中间数据

00:35:47.326 --> 00:35:50.606 A:middle
存储在传输过程中

00:35:50.786 --> 00:35:52.956 A:middle
好的 现在让我们使用持久线程组

00:35:52.956 --> 00:35:54.176 A:middle
来进一步优化我们的

00:35:54.176 --> 00:35:55.106 A:middle
切片正向着色示例

00:35:55.686 --> 00:36:00.576 A:middle
因此 有了持久线程组

00:35:55.686 --> 00:36:00.576 A:middle
因此 有了持久线程组

00:36:00.706 --> 00:36:02.116 A:middle
Tile 的着色阶段

00:36:02.116 --> 00:36:03.716 A:middle
可以将深度边界和

00:36:03.716 --> 00:36:05.086 A:middle
剔除光线列表写入

00:36:05.086 --> 00:36:06.416 A:middle
线程组内存中供

00:36:06.416 --> 00:36:07.766 A:middle
以后使用

00:36:08.716 --> 00:36:09.996 A:middle
这意味着现在我们所有的

00:36:09.996 --> 00:36:11.256 A:middle
中间数据都会保留在传输过程上

00:36:11.766 --> 00:36:13.056 A:middle
并且永远不会离开 GPU

00:36:13.056 --> 00:36:14.506 A:middle
只有最终的图像存储

00:36:14.506 --> 00:36:15.186 A:middle
在系统内存中

00:36:16.556 --> 00:36:17.876 A:middle
尽量减少系统内存

00:36:17.876 --> 00:36:19.516 A:middle
的带宽对于游戏的

00:36:19.516 --> 00:36:21.596 A:middle
性能和游戏时间来说是非常重要的

00:36:21.676 --> 00:36:24.546 A:middle
现在 我们来看一看

00:36:24.546 --> 00:36:25.616 A:middle
在着色语言中

00:36:25.616 --> 00:36:27.466 A:middle
使用持久线程组有多容易

00:36:31.336 --> 00:36:33.166 A:middle
好的 所以这里的顶层函数

00:36:33.166 --> 00:36:34.376 A:middle
是我们的 Tile 着色器

00:36:34.376 --> 00:36:35.426 A:middle
它将执行我们的光线剔除过程

00:36:35.726 --> 00:36:37.396 A:middle
它将光线与

00:36:37.396 --> 00:36:39.276 A:middle
Tile 视锥相交以计算

00:36:39.276 --> 00:36:41.026 A:middle
主动的光掩码

00:36:41.876 --> 00:36:43.096 A:middle
底层函数是

00:36:43.096 --> 00:36:44.376 A:middle
我们的片段着色器

00:36:44.376 --> 00:36:45.206 A:middle
它执行我们的正向着色

00:36:45.696 --> 00:36:46.846 A:middle
它只使用该

00:36:46.846 --> 00:36:48.486 A:middle
主动光掩码遮住

00:36:48.486 --> 00:36:49.806 A:middle
与 Tile 相交的灯光

00:36:51.456 --> 00:36:53.256 A:middle
现在 在这两个着色器

00:36:53.256 --> 00:36:54.766 A:middle
通过使用相同类型和

00:36:54.766 --> 00:36:56.116 A:middle
绑定点实现跨函数

00:36:56.406 --> 00:36:59.116 A:middle
的共享线程组内存

00:37:00.296 --> 00:37:02.826 A:middle
这就是使用持久线程组有多容易

00:37:05.806 --> 00:37:07.806 A:middle
好吧 现在你已经看到了

00:37:07.806 --> 00:37:08.686 A:middle
Tile 着色和持久线程组

00:37:08.686 --> 00:37:10.206 A:middle
让我们再次回到

00:37:10.206 --> 00:37:11.876 A:middle
我们的顺序无关的透明度示例

00:37:14.166 --> 00:37:15.446 A:middle
好的 你们还记得我说的

00:37:15.446 --> 00:37:17.126 A:middle
改变图像块布局需要

00:37:17.126 --> 00:37:18.116 A:middle
Tile 着色的吗

00:37:18.916 --> 00:37:20.106 A:middle
这是因为 Tile 着色提供了

00:37:20.106 --> 00:37:22.336 A:middle
我们需要的同步

00:37:22.336 --> 00:37:24.176 A:middle
而这会安全地更改布局

00:37:24.686 --> 00:37:26.276 A:middle
这意味着我们实际上

00:37:26.276 --> 00:37:27.926 A:middle
必须在照明和 MLAB 步骤之间

00:37:27.926 --> 00:37:29.316 A:middle
插入 Tile 着色

00:37:33.226 --> 00:37:34.436 A:middle
因此在从 G 缓冲转换到

00:37:34.516 --> 00:37:35.406 A:middle
MLAB 之前 Tile 着色

00:37:35.406 --> 00:37:36.576 A:middle
必须等待

00:37:36.576 --> 00:37:38.436 A:middle
光照步骤完成

00:37:38.436 --> 00:37:40.426 A:middle
并且它还将把

00:37:40.426 --> 00:37:41.466 A:middle
光照步骤累积的

00:37:41.466 --> 00:37:42.646 A:middle
光照值转移到

00:37:42.646 --> 00:37:44.776 A:middle
MLAB 步骤中进行最终混合

00:37:49.146 --> 00:37:50.706 A:middle
好吧 现在我们已经

00:37:50.706 --> 00:37:52.496 A:middle
介绍了图像块 图块着色

00:37:52.496 --> 00:37:53.576 A:middle
和持久线程组 现在

00:37:53.576 --> 00:37:54.736 A:middle
是时候继续讨论我们的最终

00:37:54.736 --> 00:37:56.376 A:middle
主题 多重采样

00:37:56.376 --> 00:37:58.676 A:middle
抗锯齿和示例覆盖控制

00:38:03.286 --> 00:38:04.676 A:middle
多重采样抗锯齿功能

00:38:04.676 --> 00:38:06.016 A:middle
可通过超取样深度

00:38:06.016 --> 00:38:08.396 A:middle
模板和混合来

00:38:08.766 --> 00:38:10.026 A:middle
提高图像质量 但每个像素

00:38:10.026 --> 00:38:10.676 A:middle
只能着色一次

00:38:11.816 --> 00:38:13.026 A:middle
多个样本稍后

00:38:13.026 --> 00:38:14.716 A:middle
将会被简单平均法解析为

00:38:14.896 --> 00:38:15.836 A:middle
最终图像

00:38:18.166 --> 00:38:19.676 A:middle
现在 多重采样在

00:38:19.676 --> 00:38:21.696 A:middle
所有 A 系列 GPU 上

00:38:21.746 --> 00:38:23.196 A:middle
都是高效的 因为

00:38:23.196 --> 00:38:24.546 A:middle
样本存储在 Tile 内存中

00:38:24.546 --> 00:38:25.946 A:middle
从而其中混合和解析可以

00:38:25.946 --> 00:38:26.986 A:middle
快速地访问样本

00:38:29.236 --> 00:38:31.436 A:middle
A11 GPU 通过追踪

00:38:31.436 --> 00:38:33.356 A:middle
每个像素内的

00:38:33.356 --> 00:38:34.616 A:middle
独特颜色进一步优化了

00:38:34.616 --> 00:38:35.346 A:middle
多重采样

00:38:36.036 --> 00:38:37.416 A:middle
以前在每个样本上

00:38:37.416 --> 00:38:38.386 A:middle
进行的混合操作

00:38:38.386 --> 00:38:40.746 A:middle
现在仅对每种颜色进行操作

00:38:41.616 --> 00:38:42.636 A:middle
这可能是一个显著的

00:38:42.636 --> 00:38:44.036 A:middle
优化节约

00:38:44.036 --> 00:38:45.756 A:middle
因为每个三角形的内部

00:38:45.756 --> 00:38:46.386 A:middle
只包含 1 种独特的颜色

00:38:49.186 --> 00:38:50.246 A:middle
现在 独特颜色与

00:38:50.276 --> 00:38:53.406 A:middle
样本的映射被称为

00:38:53.406 --> 00:38:54.606 A:middle
颜色覆盖控制 并且

00:38:54.606 --> 00:38:55.576 A:middle
这由 GPU 管理

00:38:56.206 --> 00:38:57.966 A:middle
但是 Tile 着色器也可以读取

00:38:57.966 --> 00:38:59.506 A:middle
和修改这种颜色覆盖

00:39:00.806 --> 00:39:02.176 A:middle
我们可以使用它来执行

00:39:02.216 --> 00:39:04.566 A:middle
自定义解析和快速的

00:39:04.566 --> 00:39:05.406 A:middle
Tile 内存

00:39:06.186 --> 00:39:07.466 A:middle
现在 让我们来看一看

00:39:07.696 --> 00:39:08.516 A:middle
为什么这是有用的

00:39:08.516 --> 00:39:10.316 A:middle
让我们来看一下渲染粒子

00:39:10.316 --> 00:39:11.166 A:middle
的多重采样场景

00:39:14.196 --> 00:39:15.766 A:middle
粒子是透明的

00:39:15.766 --> 00:39:17.356 A:middle
所以我们将在渲染我们的

00:39:17.356 --> 00:39:18.646 A:middle
不透明场景几何体之后将它们混合

00:39:19.306 --> 00:39:20.706 A:middle
但是粒子渲染不能从

00:39:20.706 --> 00:39:21.886 A:middle
多重采样中受益

00:39:21.886 --> 00:39:23.716 A:middle
因为它实际上没有任何可见的边缘

00:39:24.766 --> 00:39:26.236 A:middle
因此 为了避免

00:39:26.236 --> 00:39:27.496 A:middle
无理由地混合

00:39:27.496 --> 00:39:29.256 A:middle
每个样本的额外成本

00:39:29.256 --> 00:39:30.236 A:middle
游戏将使用 2 次传递进行渲染

00:39:30.956 --> 00:39:32.546 A:middle
在第一遍中 你的不透明的

00:39:32.546 --> 00:39:33.956 A:middle
场景几何体

00:39:33.956 --> 00:39:35.756 A:middle
将使用多重采样来渲染以减少混叠

00:39:36.666 --> 00:39:37.536 A:middle
然后 你将解决

00:39:37.536 --> 00:39:38.696 A:middle
关于系统内存的颜色

00:39:38.696 --> 00:39:40.036 A:middle
和深度 并且处理

00:39:40.036 --> 00:39:41.506 A:middle
深度 因为之后它在之后

00:39:41.506 --> 00:39:42.846 A:middle
可以包含粒子

00:39:43.916 --> 00:39:45.696 A:middle
然后在第二遍中

00:39:45.696 --> 00:39:47.496 A:middle
使用解析颜色和

00:39:47.636 --> 00:39:49.576 A:middle
深度来渲染没有多次采样的粒子

00:39:51.256 --> 00:39:52.466 A:middle
现在 正如你现在可能

00:39:52.466 --> 00:39:54.326 A:middle
猜到的那样 我们的目标

00:39:54.326 --> 00:39:55.396 A:middle
是使用 Tile 着色来消除

00:39:55.396 --> 00:39:56.876 A:middle
中间传输的系统内存

00:39:56.876 --> 00:39:58.646 A:middle
以便合并这两个传递

00:40:01.126 --> 00:40:02.716 A:middle
但仅仅 Tile 着色是不够的

00:40:02.956 --> 00:40:04.266 A:middle
我们需要色彩覆盖控制来

00:40:04.266 --> 00:40:06.586 A:middle
改变多重采样率

00:40:07.576 --> 00:40:08.876 A:middle
颜色覆盖控制功能非常强大

00:40:08.996 --> 00:40:10.996 A:middle
并且使用非常简单

00:40:11.526 --> 00:40:12.496 A:middle
让我们来看一下着色器

00:40:16.176 --> 00:40:17.976 A:middle
好的 请记住

00:40:17.976 --> 00:40:19.336 A:middle
我们的目标是

00:40:19.336 --> 00:40:20.766 A:middle
平均每个像素的样本

00:40:20.766 --> 00:40:22.126 A:middle
然后将该结果

00:40:22.236 --> 00:40:24.106 A:middle
存储回图像块中作为整体像素值

00:40:25.616 --> 00:40:27.276 A:middle
现在 我们不是

00:40:27.276 --> 00:40:29.686 A:middle
循环每个颜色 循环

00:40:29.826 --> 00:40:30.776 A:middle
每个样本 而是

00:40:30.776 --> 00:40:32.146 A:middle
使用 A11 的色差率

00:40:32.146 --> 00:40:34.916 A:middle
功能 只循环独特的颜色

00:40:36.836 --> 00:40:38.726 A:middle
为了在所有样本中

00:40:38.726 --> 00:40:40.066 A:middle
正确地平均

00:40:40.066 --> 00:40:41.416 A:middle
我们需要根据与其相关的

00:40:41.416 --> 00:40:43.166 A:middle
样本数对每种颜色进行

00:40:43.166 --> 00:40:46.436 A:middle
加权 我们通过计算颜色掩码中

00:40:46.436 --> 00:40:47.866 A:middle
设置的位来实现这一点

00:40:49.186 --> 00:40:50.426 A:middle
然后 我们通过

00:40:50.426 --> 00:40:51.606 A:middle
除以总采样数来完成

00:40:51.606 --> 00:40:54.766 A:middle
平均 最后将

00:40:54.766 --> 00:40:56.616 A:middle
结果写回到图像块中

00:40:57.136 --> 00:40:58.526 A:middle
输出样本掩码告诉

00:40:58.526 --> 00:41:00.126 A:middle
Metal 技术将结果应用于

00:40:58.526 --> 00:41:00.126 A:middle
Metal 技术将结果应用于

00:41:00.126 --> 00:41:01.136 A:middle
像素的所有样本

00:41:01.986 --> 00:41:03.876 A:middle
而且 由于所有样本

00:41:03.876 --> 00:41:05.486 A:middle
现在都具有相同的值

00:41:05.486 --> 00:41:06.426 A:middle
因此后面的粒子绘制

00:41:06.426 --> 00:41:08.646 A:middle
将按每个像素而不是每个样本进行混合

00:41:11.096 --> 00:41:13.056 A:middle
这就是样本覆盖控制

00:41:15.736 --> 00:41:18.216 A:middle
现在 针对 Apple GPU

00:41:18.216 --> 00:41:19.306 A:middle
进行的优化对于

00:41:19.306 --> 00:41:20.556 A:middle
最大限度地提高

00:41:20.586 --> 00:41:21.926 A:middle
游戏性能并延长

00:41:21.966 --> 00:41:23.806 A:middle
游戏时间非常重要

00:41:23.806 --> 00:41:25.236 A:middle
但是在 iOS 平台上使用

00:41:25.236 --> 00:41:27.036 A:middle
Tile 你需要做更多的工作

00:41:27.036 --> 00:41:27.946 A:middle
特别是那些最初为电脑

00:41:27.946 --> 00:41:28.986 A:middle
和主机设计的游戏

00:41:29.476 --> 00:41:31.266 A:middle
现在我们将谈论

00:41:31.266 --> 00:41:32.456 A:middle
这个问题 并将我们刚刚讨论过的

00:41:32.456 --> 00:41:34.036 A:middle
内容付诸实践 我想邀请

00:41:34.036 --> 00:41:35.716 A:middle
Epic Games 的 Nick Penwarden 上台

00:41:36.146 --> 00:41:40.566 A:middle
Nick [ 掌声 ]

00:41:41.066 --> 00:41:41.736 A:middle
&gt;&gt; 谢谢 Michael

00:41:42.876 --> 00:41:44.086 A:middle
嗯 我想谈一谈

00:41:44.086 --> 00:41:46.236 A:middle
一些关于我们如何把

00:41:46.236 --> 00:41:47.906 A:middle
最初用于电脑和主机平台的游戏

00:41:47.986 --> 00:41:50.786 A:middle
使用 Metal 技术

00:41:50.786 --> 00:41:53.326 A:middle
将其引入 iOS 平台的问题

00:41:53.906 --> 00:41:56.126 A:middle
我们面临的一些

00:41:56.126 --> 00:41:57.206 A:middle
技术上的挑战

00:41:57.206 --> 00:42:00.556 A:middle
堡垒之夜的地图是 1 张地图

00:41:57.206 --> 00:42:00.556 A:middle
堡垒之夜的地图是 1 张地图

00:42:00.556 --> 00:42:02.426 A:middle
它大于 6 平方公里

00:42:02.946 --> 00:42:04.976 A:middle
这意味着它不适合

00:42:04.976 --> 00:42:05.856 A:middle
全部储存在内存中

00:42:06.466 --> 00:42:07.726 A:middle
我们也有动态的时间

00:42:07.726 --> 00:42:09.266 A:middle
流动和破坏

00:42:09.266 --> 00:42:10.476 A:middle
玩家可以摧毁

00:42:10.476 --> 00:42:11.866 A:middle
场景中的任何物体

00:42:12.286 --> 00:42:14.386 A:middle
玩家也可以建立自己的建筑

00:42:14.726 --> 00:42:15.896 A:middle
所以地图非常动态

00:42:15.956 --> 00:42:16.916 A:middle
这意味着我们不能做

00:42:16.996 --> 00:42:17.856 A:middle
很多预计算

00:42:18.286 --> 00:42:21.846 A:middle
我们在地图上有 100 个玩家

00:42:21.846 --> 00:42:24.166 A:middle
地图上有超过 50,000

00:42:24.166 --> 00:42:25.506 A:middle
个复制角色 这些

00:42:25.506 --> 00:42:27.286 A:middle
复制角色在服务器上模拟

00:42:27.286 --> 00:42:28.506 A:middle
并复制到客户端

00:42:29.806 --> 00:42:31.216 A:middle
最后 我们希望支持

00:42:31.216 --> 00:42:33.246 A:middle
主机和电脑

00:42:33.246 --> 00:42:35.336 A:middle
以及移动设备之间的联机游玩

00:42:36.126 --> 00:42:37.206 A:middle
这实际上是非常重要

00:42:37.206 --> 00:42:38.396 A:middle
的一点 因为它

00:42:38.396 --> 00:42:39.926 A:middle
限制了我们用

00:42:39.926 --> 00:42:42.546 A:middle
缩减游戏的体量

00:42:42.546 --> 00:42:45.486 A:middle
的方法来适应​​设备的

00:42:45.486 --> 00:42:46.686 A:middle
性能限制

00:42:47.096 --> 00:42:48.776 A:middle
基本上 如果有什么东西影响了

00:42:48.776 --> 00:42:50.496 A:middle
游戏玩法 我们不能改变它

00:42:50.756 --> 00:42:52.016 A:middle
所以如果有一个对象

00:42:52.016 --> 00:42:53.186 A:middle
它真的很小 它真的很遥远

00:42:53.186 --> 00:42:55.166 A:middle
也许通常情况下你会剔除它

00:42:55.316 --> 00:42:57.306 A:middle
但在以下这种情况下

00:42:57.306 --> 00:42:58.836 A:middle
我们不能 因为如果

00:42:58.836 --> 00:43:00.306 A:middle
玩家可以躲在它后面

00:42:58.836 --> 00:43:00.306 A:middle
玩家可以躲在它后面

00:43:00.306 --> 00:43:02.666 A:middle
我们就需要渲染它

00:43:02.936 --> 00:43:04.906 A:middle
所以现在我们来谈一谈

00:43:04.906 --> 00:43:05.906 A:middle
Metal 技术

00:43:05.906 --> 00:43:07.306 A:middle
Metal 技术在让我们

00:43:07.306 --> 00:43:09.946 A:middle
能够快速地运行游戏

00:43:09.946 --> 00:43:12.086 A:middle
以及让我们能够

00:43:12.116 --> 00:43:13.396 A:middle
实现的游戏品质方面

00:43:13.396 --> 00:43:13.816 A:middle
非常重要

00:43:14.486 --> 00:43:15.876 A:middle
绘制调用的表现是关键

00:43:15.876 --> 00:43:17.626 A:middle
因为我们有

00:43:17.626 --> 00:43:20.776 A:middle
一个非常复杂的场景

00:43:20.776 --> 00:43:22.066 A:middle
我们需要渲染来

00:43:22.066 --> 00:43:23.406 A:middle
呈现它 而 Metal 技术给了我们

00:43:23.446 --> 00:43:24.116 A:middle
这样的结果

00:43:24.696 --> 00:43:26.196 A:middle
Metal 技术还让我们

00:43:26.196 --> 00:43:27.386 A:middle
能够访问许多硬件功能

00:43:27.386 --> 00:43:28.636 A:middle
例如可编程混合

00:43:28.636 --> 00:43:30.486 A:middle
这些硬件特性使我们重新获得

00:43:30.486 --> 00:43:31.566 A:middle
重要的 GPU 性能

00:43:32.286 --> 00:43:33.546 A:middle
它还具有一套功能

00:43:33.546 --> 00:43:34.866 A:middle
这套功能包含了

00:43:34.866 --> 00:43:36.316 A:middle
可以让我们将堡垒之夜带到 iOS

00:43:36.316 --> 00:43:38.506 A:middle
所需的所有渲染技术

00:43:38.856 --> 00:43:40.236 A:middle
就渲染而言

00:43:40.676 --> 00:43:42.056 A:middle
我们使用可移动的

00:43:42.056 --> 00:43:43.446 A:middle
定向光来照明

00:43:43.446 --> 00:43:44.226 A:middle
级联阴影贴图

00:43:44.226 --> 00:43:45.386 A:middle
我们有一个可移动的天窗

00:43:45.386 --> 00:43:47.016 A:middle
因为天空整天都在变化

00:43:47.786 --> 00:43:49.936 A:middle
我们使用基于物理的材质

00:43:51.436 --> 00:43:52.936 A:middle
我们在 HDR 中进行渲染

00:43:52.936 --> 00:43:54.306 A:middle
并在最后进行色调映射

00:43:55.476 --> 00:43:57.286 A:middle
我们允许在 GPU 上

00:43:57.286 --> 00:43:58.036 A:middle
进行粒子模拟

00:43:58.076 --> 00:43:59.456 A:middle
我们也支持我们所有的

00:43:59.456 --> 00:44:00.806 A:middle
开发者自制的材质

00:43:59.456 --> 00:44:00.806 A:middle
开发者自制的材质

00:44:01.416 --> 00:44:03.616 A:middle
这实际上是非常重要的一点

00:44:03.646 --> 00:44:05.796 A:middle
因为我们的

00:44:05.796 --> 00:44:08.316 A:middle
一些材质实际上非常复杂

00:44:08.316 --> 00:44:10.786 A:middle
例如 我们用于

00:44:10.786 --> 00:44:12.006 A:middle
高效渲染树木的东西

00:44:12.006 --> 00:44:13.496 A:middle
完全是由开发者

00:44:13.496 --> 00:44:16.636 A:middle
在 Epic 中使用蓝图和

00:44:16.636 --> 00:44:20.796 A:middle
材质着色器图形创建的

00:44:22.676 --> 00:44:24.086 A:middle
接着我们刚刚说的话题

00:44:24.086 --> 00:44:25.896 A:middle
这里是堡垒之夜

00:44:25.896 --> 00:44:27.696 A:middle
以高可扩展性在 Mac 上

00:44:27.696 --> 00:44:28.806 A:middle
运行的图像

00:44:30.016 --> 00:44:31.506 A:middle
这在中等可扩展性下

00:44:31.506 --> 00:44:33.716 A:middle
运行在 Mac 上的图像

00:44:34.826 --> 00:44:36.296 A:middle
这里是在 iPhone 8 Plus

00:44:36.336 --> 00:44:36.826 A:middle
上运行的图像

00:44:37.296 --> 00:44:38.706 A:middle
所以我们能够在 iPhone 上

00:44:38.706 --> 00:44:41.136 A:middle
以我们在中端 Mac 上

00:44:41.556 --> 00:44:42.836 A:middle
呈现的品质完全地

00:44:42.836 --> 00:44:44.276 A:middle
表现游戏的质量

00:44:44.816 --> 00:44:48.796 A:middle
所以我们来谈一谈可扩展性

00:44:49.526 --> 00:44:50.736 A:middle
我们处理跨平台

00:44:50.736 --> 00:44:52.156 A:middle
和 iOS 系统的

00:44:52.156 --> 00:44:53.616 A:middle
可扩展性

00:44:54.216 --> 00:44:55.986 A:middle
因此 跨平台时

00:44:55.986 --> 00:44:57.616 A:middle
我们需要在平台上安装这一些东西

00:44:57.616 --> 00:44:59.936 A:middle
比如从网格中

00:44:59.936 --> 00:45:01.456 A:middle
移除永远不会显示的 LOD

00:44:59.936 --> 00:45:01.456 A:middle
移除永远不会显示的 LOD

00:45:01.456 --> 00:45:03.016 A:middle
因此我们可以把它

00:45:03.466 --> 00:45:06.096 A:middle
放入内存或更改我们在

00:45:06.096 --> 00:45:08.866 A:middle
特定级别上动画的

00:45:08.866 --> 00:45:11.696 A:middle
角色数量 以降低 CPU 成本

00:45:12.736 --> 00:45:14.776 A:middle
在 iOS 平台内部 我们还定义了 3 个

00:45:14.776 --> 00:45:17.116 A:middle
可扩展性 - 低

00:45:17.116 --> 00:45:19.056 A:middle
中 高 - 这些

00:45:19.056 --> 00:45:20.136 A:middle
通常与不同代

00:45:20.136 --> 00:45:21.736 A:middle
iPhone 相关

00:45:21.806 --> 00:45:24.116 A:middle
所以 iPhone 6 使用低端

00:45:24.116 --> 00:45:26.046 A:middle
iPhone 7 使用中档

00:45:26.046 --> 00:45:27.806 A:middle
iPhone 8 和

00:45:27.806 --> 00:45:31.366 A:middle
iPhone X 使用高端

00:45:31.366 --> 00:45:34.226 A:middle
分辨率显然是

00:45:34.226 --> 00:45:36.356 A:middle
我们拥有的最简单和最佳的

00:45:36.516 --> 00:45:37.446 A:middle
可扩展性选项

00:45:37.786 --> 00:45:39.266 A:middle
我们最终调整了每个设备

00:45:39.766 --> 00:45:41.186 A:middle
我们倾向于

00:45:41.186 --> 00:45:42.456 A:middle
在可能的情况下 使用后备缓冲分辨率

00:45:42.456 --> 00:45:43.836 A:middle
这是用户界面呈现的内容所决定的

00:45:44.346 --> 00:45:45.996 A:middle
因为如果我们这样做

00:45:45.996 --> 00:45:47.676 A:middle
那么我们不必支付单独的

00:45:47.676 --> 00:45:48.726 A:middle
上采样成本

00:45:49.196 --> 00:45:50.746 A:middle
但是 我们确实支持

00:45:50.786 --> 00:45:52.736 A:middle
以较低的分辨率

00:45:52.736 --> 00:45:54.566 A:middle
渲染 3D 分辨率 在某些情况下

00:45:54.566 --> 00:45:56.826 A:middle
我们需要一个清晰的用户界面

00:45:56.826 --> 00:45:58.886 A:middle
但不得不降低 3D 渲染

00:45:58.886 --> 00:46:00.746 A:middle
分辨率来适配

00:45:58.886 --> 00:46:00.746 A:middle
分辨率来适配

00:46:00.746 --> 00:46:01.866 A:middle
我们的性能

00:46:01.866 --> 00:46:04.456 A:middle
以 iPhone 6s 为例

00:46:06.176 --> 00:46:07.846 A:middle
阴影是可扩展性的另一个轴

00:46:07.846 --> 00:46:09.296 A:middle
并且它非常重要

00:46:09.296 --> 00:46:10.576 A:middle
因为它们同时影响

00:46:10.686 --> 00:46:12.376 A:middle
CPU 和 GPU

00:46:13.056 --> 00:46:15.076 A:middle
在低端设备上

00:46:15.076 --> 00:46:16.276 A:middle
我们不呈现任何阴影

00:46:16.586 --> 00:46:17.956 A:middle
在我们的中档设备上

00:46:17.956 --> 00:46:21.016 A:middle
我们有 1 个级联 1024 乘 1024 大小

00:46:21.506 --> 00:46:22.726 A:middle
我们将距离设置为

00:46:22.726 --> 00:46:24.006 A:middle
与近似于建筑物的大小的数值

00:46:24.006 --> 00:46:25.136 A:middle
因此如果你位于建筑物内部

00:46:25.426 --> 00:46:26.276 A:middle
则不会看到另一侧的

00:46:26.276 --> 00:46:28.056 A:middle
光线泄漏

00:46:28.736 --> 00:46:29.936 A:middle
高端设备增加了第二个级联

00:46:29.936 --> 00:46:31.246 A:middle
这样可以提供更清晰的

00:46:31.246 --> 00:46:32.586 A:middle
人物阴影

00:46:32.586 --> 00:46:34.096 A:middle
并让我们可以进一步

00:46:34.096 --> 00:46:35.966 A:middle
推出阴影距离

00:46:37.406 --> 00:46:38.956 A:middle
植物是可扩展性的

00:46:38.956 --> 00:46:39.646 A:middle
另一个轴

00:46:39.996 --> 00:46:41.426 A:middle
在低端设备上

00:46:41.426 --> 00:46:42.486 A:middle
我们根本不渲染植物

00:46:42.756 --> 00:46:43.656 A:middle
在中等设备内 我们

00:46:43.656 --> 00:46:45.556 A:middle
呈现了我们在主机上支持的大约

00:46:45.556 --> 00:46:46.516 A:middle
30％ 的密度的植物阴影

00:46:46.816 --> 00:46:47.936 A:middle
在高端设备上 我们

00:46:47.936 --> 00:46:49.716 A:middle
实际上可以实现

00:46:49.716 --> 00:46:50.836 A:middle
我们在主机上支持的

00:46:50.836 --> 00:46:51.266 A:middle
100％ 的密度

00:46:53.956 --> 00:46:55.666 A:middle
内存在可扩展性

00:46:55.666 --> 00:46:57.006 A:middle
方面很有意思

00:46:57.006 --> 00:46:58.296 A:middle
因为它并不总是与

00:46:58.336 --> 00:46:59.006 A:middle
性能相关

00:46:59.456 --> 00:47:00.866 A:middle
例如 iPhone 8

00:46:59.456 --> 00:47:00.866 A:middle
例如 iPhone 8

00:47:00.866 --> 00:47:02.336 A:middle
比 iPhone 7 Plus 快

00:47:02.336 --> 00:47:03.796 A:middle
但它的物理内存更少

00:47:04.256 --> 00:47:05.146 A:middle
这意味着当你考虑到

00:47:05.146 --> 00:47:06.506 A:middle
可扩展性时 你需要

00:47:06.506 --> 00:47:07.936 A:middle
以不同的方式处理内存

00:47:07.936 --> 00:47:09.786 A:middle
我们最终将它

00:47:09.786 --> 00:47:11.616 A:middle
视为可伸缩性的正交轴

00:47:12.226 --> 00:47:14.256 A:middle
并且只有 2 个分类

00:47:14.256 --> 00:47:15.226 A:middle
分别是低内存和高内存

00:47:16.046 --> 00:47:17.506 A:middle
对于低存储设备

00:47:17.506 --> 00:47:18.926 A:middle
我们禁用了植物和阴影

00:47:19.446 --> 00:47:21.656 A:middle
我们还减少了一些内存池

00:47:21.656 --> 00:47:23.296 A:middle
因此 例如 我们

00:47:23.296 --> 00:47:25.396 A:middle
将 GPU 颗粒限制在总计 16,000 个

00:47:25.846 --> 00:47:27.416 A:middle
并减少了美化和纹理记忆池

00:47:27.416 --> 00:47:29.246 A:middle
的使用量

00:47:29.816 --> 00:47:32.926 A:middle
但我们仍然需要

00:47:32.926 --> 00:47:34.266 A:middle
进行相当多的内存优化

00:47:34.266 --> 00:47:35.846 A:middle
才能让游戏在该设备上运行

00:47:36.366 --> 00:47:37.816 A:middle
最重要的是

00:47:37.816 --> 00:47:38.936 A:middle
级别流 基本上

00:47:38.936 --> 00:47:40.046 A:middle
只是确保如果

00:47:40.046 --> 00:47:41.176 A:middle
对象不在玩家身边

00:47:41.176 --> 00:47:41.566 A:middle
就不占任何内存

00:47:42.356 --> 00:47:44.606 A:middle
在大多数情况下

00:47:44.606 --> 00:47:46.116 A:middle
我们还使用 ASTC 纹理压缩

00:47:46.416 --> 00:47:48.776 A:middle
并倾向于在大小而不是

00:47:48.836 --> 00:47:50.476 A:middle
质量上进行压缩

00:47:50.846 --> 00:47:52.236 A:middle
而且我们还为我们的

00:47:52.236 --> 00:47:54.106 A:middle
开发者提供了很多工具

00:47:54.506 --> 00:47:57.426 A:middle
可以用来制作不同的 LOD

00:47:57.426 --> 00:47:59.946 A:middle
它们有些不是必须的

00:47:59.946 --> 00:48:02.326 A:middle
或者有些可以减少每个平台的音频变化

00:47:59.946 --> 00:48:02.326 A:middle
或者有些可以减少每个平台的音频变化

00:48:04.926 --> 00:48:06.736 A:middle
接下来我想谈一下帧速率目标

00:48:07.156 --> 00:48:08.566 A:middle
所以在 iOS 上 我们希望

00:48:08.566 --> 00:48:10.546 A:middle
可以达到最高的视觉

00:48:10.546 --> 00:48:11.626 A:middle
保真度 30 fps

00:48:12.176 --> 00:48:14.426 A:middle
但是 你不能仅仅将设备的性能达到最大化

00:48:14.426 --> 00:48:15.766 A:middle
如果我们在整个时间内

00:48:15.766 --> 00:48:17.676 A:middle
最大限度地利用 CPU 和 GPU

00:48:17.676 --> 00:48:19.466 A:middle
操作系统最终会降低

00:48:19.526 --> 00:48:21.206 A:middle
我们的速度 那么我们就

00:48:21.206 --> 00:48:22.486 A:middle
不会再达到目标帧速率

00:48:22.486 --> 00:48:25.126 A:middle
我们同时也想要延长电池寿命

00:48:25.476 --> 00:48:26.776 A:middle
如果玩家在通勤过程

00:48:26.776 --> 00:48:27.786 A:middle
中连续玩几场比赛 我们希望

00:48:27.786 --> 00:48:30.336 A:middle
在他们开始玩

00:48:30.336 --> 00:48:31.806 A:middle
之前帮助他们

00:48:31.806 --> 00:48:32.916 A:middle
而不是使他们的设备死机

00:48:33.766 --> 00:48:36.716 A:middle
所以为此 我们决定

00:48:36.716 --> 00:48:38.216 A:middle
做的是针对环境时

00:48:38.216 --> 00:48:39.686 A:middle
达到每秒 60 帧

00:48:39.686 --> 00:48:41.796 A:middle
但是在垂直同步（VSync）时

00:48:41.796 --> 00:48:42.936 A:middle
达到 30 帧 这意味着

00:48:43.106 --> 00:48:45.306 A:middle
大多数时候当你在堡垒之夜探索地图时

00:48:45.306 --> 00:48:47.146 A:middle
手机将闲置约 50％ 时间

00:48:47.216 --> 00:48:48.236 A:middle
我们利用这段时间来延长电池寿命

00:48:48.236 --> 00:48:49.986 A:middle
并保持设备凉爽

00:48:52.476 --> 00:48:53.916 A:middle
为了确保我们能够

00:48:53.916 --> 00:48:56.006 A:middle
达到这些目标 我们每天跟踪

00:48:56.006 --> 00:48:56.896 A:middle
帧速率的表现

00:48:57.396 --> 00:48:58.546 A:middle
我们每天都有

00:48:58.546 --> 00:49:00.496 A:middle
一个自动化的通道用来做这个

00:48:58.546 --> 00:49:00.496 A:middle
一个自动化的通道用来做这个

00:49:00.976 --> 00:49:04.106 A:middle
我们看一看地图中的关键位置

00:49:04.106 --> 00:49:06.056 A:middle
并捕捉性能

00:49:06.056 --> 00:49:08.126 A:middle
例如 斜塔小镇

00:49:08.126 --> 00:49:09.616 A:middle
和矿井以及

00:49:09.616 --> 00:49:11.396 A:middle
你在堡垒之夜中所有

00:49:11.396 --> 00:49:12.756 A:middle
熟悉的常见兴趣点

00:49:13.356 --> 00:49:15.126 A:middle
当超过预算时

00:49:15.126 --> 00:49:16.506 A:middle
我们需要深入了解

00:49:16.506 --> 00:49:17.676 A:middle
了解性能进展情况

00:49:17.676 --> 00:49:18.356 A:middle
并对它进行优化

00:49:18.966 --> 00:49:20.486 A:middle
我们每天都会有一个 100 人

00:49:20.486 --> 00:49:22.346 A:middle
的玩家测试

00:49:22.346 --> 00:49:23.566 A:middle
用来捕捉你只能在游戏中看到的

00:49:23.566 --> 00:49:24.696 A:middle
帧速率动态表现

00:49:25.246 --> 00:49:26.436 A:middle
我们跟踪比赛时的

00:49:26.436 --> 00:49:29.376 A:middle
帧速率的关键表现

00:49:29.376 --> 00:49:30.116 A:middle
然后我们可以看一看

00:49:30.116 --> 00:49:32.176 A:middle
看看它是如何工作的

00:49:32.176 --> 00:49:34.566 A:middle
如何寻找连结

00:49:34.566 --> 00:49:35.296 A:middle
类似于这样的东西

00:49:35.806 --> 00:49:37.966 A:middle
如果出现问题

00:49:37.966 --> 00:49:39.596 A:middle
我们可以从设备中

00:49:39.596 --> 00:49:41.256 A:middle
取出设备配置文件

00:49:41.256 --> 00:49:42.686 A:middle
查看时间到底去了哪里

00:49:42.686 --> 00:49:44.106 A:middle
找出我们需要优化的地方

00:49:45.086 --> 00:49:46.336 A:middle
我们也支持重播

00:49:46.336 --> 00:49:48.956 A:middle
这是虚幻引擎的一个功能

00:49:48.956 --> 00:49:50.546 A:middle
它允许我们从玩家的角度去

00:49:50.546 --> 00:49:51.986 A:middle
重放比赛

00:49:51.986 --> 00:49:53.266 A:middle
所以我们可以反复播放

00:49:53.266 --> 00:49:55.706 A:middle
分析它 解剖它

00:49:55.706 --> 00:49:57.306 A:middle
甚至看看优化会

00:49:57.306 --> 00:50:00.206 A:middle
如何影响客户在游戏中的表现

00:49:57.306 --> 00:50:00.206 A:middle
如何影响客户在游戏中的表现

00:50:01.976 --> 00:50:03.726 A:middle
接下来我们专门

00:50:03.726 --> 00:50:04.896 A:middle
讨论一下 Metal 技术

00:50:05.716 --> 00:50:09.006 A:middle
我们在大多数设备上

00:50:09.006 --> 00:50:11.786 A:middle
都有 2 个核心 是的

00:50:11.786 --> 00:50:13.626 A:middle
所以我们使用的方式是

00:50:14.206 --> 00:50:14.966 A:middle
我们有一个传统的游戏主线

00:50:14.966 --> 00:50:16.196 A:middle
和渲染线程的拆分

00:50:16.576 --> 00:50:17.676 A:middle
在游戏主线上

00:50:17.676 --> 00:50:19.086 A:middle
我们正在进行联网 模拟

00:50:19.086 --> 00:50:20.746 A:middle
动画 物理等等工作

00:50:21.316 --> 00:50:22.546 A:middle
渲染线程执行

00:50:22.546 --> 00:50:25.796 A:middle
所有场景遍历剔除并

00:50:25.796 --> 00:50:26.316 A:middle
发布所有 Metal API 调用

00:50:26.646 --> 00:50:29.316 A:middle
我们也有一个异步线程

00:50:29.626 --> 00:50:31.026 A:middle
大多数情况下 它处理

00:50:31.026 --> 00:50:32.796 A:middle
流式传输任务 纹理流式传输

00:50:32.796 --> 00:50:34.386 A:middle
以及级别流式传输

00:50:36.006 --> 00:50:37.726 A:middle
在拥有 2 个快速内核

00:50:37.726 --> 00:50:39.996 A:middle
和 4 个高效内核的新设备上

00:50:39.996 --> 00:50:41.456 A:middle
我们增加了 3 个任务线程

00:50:41.456 --> 00:50:42.656 A:middle
并启用了虚幻引擎中的一些

00:50:42.656 --> 00:50:44.186 A:middle
并行算法

00:50:44.796 --> 00:50:48.526 A:middle
所以我们采取动画在多帧

00:50:48.526 --> 00:50:51.126 A:middle
CPU 粒子 物理等条件下

00:50:51.126 --> 00:50:53.926 A:middle
进行模拟 场景剔除

00:50:53.926 --> 00:50:55.056 A:middle
以及其他一些任务

00:50:57.376 --> 00:50:59.166 A:middle
我之前提到过绘图调用

00:50:59.296 --> 00:51:00.916 A:middle
绘图调用是我们的主要的

00:50:59.296 --> 00:51:00.916 A:middle
绘图调用是我们的主要的

00:51:00.916 --> 00:51:02.586 A:middle
表现瓶颈 而这实际上

00:51:02.586 --> 00:51:03.836 A:middle
是 Metal 技术真正帮助

00:51:03.836 --> 00:51:04.536 A:middle
到我们的地方

00:51:05.516 --> 00:51:07.346 A:middle
我们发现使用 Metal 技术

00:51:07.346 --> 00:51:08.606 A:middle
比使用 OpenGL 速度要

00:51:08.606 --> 00:51:10.666 A:middle
快 3 到 4 倍 这使我们

00:51:10.666 --> 00:51:12.876 A:middle
能够在没有进行

00:51:12.876 --> 00:51:14.206 A:middle
大量关于减少绘图调用的

00:51:14.206 --> 00:51:15.876 A:middle
积极工作的情况下进行交流

00:51:16.186 --> 00:51:17.276 A:middle
我们做了一些工作

00:51:17.276 --> 00:51:19.116 A:middle
来减少绘图调用

00:51:19.116 --> 00:51:20.946 A:middle
主要是在装饰物体上

00:51:20.946 --> 00:51:23.236 A:middle
剔除距离 并利用

00:51:23.236 --> 00:51:25.236 A:middle
细节系统的层次结构

00:51:27.696 --> 00:51:29.066 A:middle
这里是一个例子

00:51:29.066 --> 00:51:30.656 A:middle
这是我们一直追踪的

00:51:30.656 --> 00:51:31.726 A:middle
感兴趣的地点之一

00:51:32.176 --> 00:51:33.006 A:middle
如果你对游戏非常熟悉

00:51:33.006 --> 00:51:34.216 A:middle
那么这从悬崖上俯视斜塔小镇

00:51:34.216 --> 00:51:38.386 A:middle
的视角 也是我们在

00:51:38.386 --> 00:51:40.866 A:middle
地图上的频繁使用绘图调用的地点

00:51:41.396 --> 00:51:42.686 A:middle
正如你所看到的

00:51:42.686 --> 00:51:45.056 A:middle
它大约需要 1300 次绘制调来渲染

00:51:45.196 --> 00:51:46.476 A:middle
这只是主要的传递

00:51:46.476 --> 00:51:47.896 A:middle
它不包括阴影

00:51:48.776 --> 00:51:50.126 A:middle
用户界面 其他任何

00:51:50.126 --> 00:51:50.686 A:middle
消耗绘图调用时间的内容

00:51:51.196 --> 00:51:52.606 A:middle
但在这里使用 Metal 技术 真的可以变得很快

00:51:52.606 --> 00:51:53.766 A:middle
在 iPhone 8 Plus 上

00:51:53.766 --> 00:51:56.266 A:middle
我们能够在 5 毫秒的时间内完成

00:51:58.456 --> 00:51:59.946 A:middle
我提到了分级 LOD

00:51:59.946 --> 00:52:01.446 A:middle
这是虚幻引擎中的一项功能

00:51:59.946 --> 00:52:01.446 A:middle
这是虚幻引擎中的一项功能

00:52:01.486 --> 00:52:02.806 A:middle
我们可以进行

00:52:03.276 --> 00:52:04.976 A:middle
多次绘图调用并生成

00:52:04.976 --> 00:52:06.226 A:middle
一个简化版本

00:52:06.226 --> 00:52:08.426 A:middle
简化网格以及材质

00:52:08.426 --> 00:52:09.466 A:middle
以便我们可以在

00:52:09.466 --> 00:52:10.286 A:middle
单个绘图调用中

00:52:10.286 --> 00:52:14.176 A:middle
渲染该区域的基本

00:52:14.176 --> 00:52:15.036 A:middle
表示形式

00:52:15.526 --> 00:52:18.116 A:middle
我们使用它来获取

00:52:18.356 --> 00:52:19.566 A:middle
我们感兴趣的地点

00:52:19.566 --> 00:52:20.906 A:middle
生成用于渲染当距离非常

00:52:20.906 --> 00:52:21.646 A:middle
非常遥远的简化版本

00:52:22.056 --> 00:52:22.816 A:middle
例如 在跳伞期间

00:52:22.816 --> 00:52:24.696 A:middle
你可以看到整个地图

00:52:25.166 --> 00:52:26.296 A:middle
事实上 当你在地图上时

00:52:26.296 --> 00:52:28.086 A:middle
你可以爬上悬崖

00:52:28.166 --> 00:52:29.606 A:middle
或者建造一座非常高的属于

00:52:29.606 --> 00:52:32.096 A:middle
自己的塔楼 你可以看到

00:52:32.096 --> 00:52:33.616 A:middle
距离自己 2 公里远的风景

00:52:35.936 --> 00:52:38.056 A:middle
接下来我将深入探讨

00:52:38.056 --> 00:52:40.476 A:middle
Metal 的其他细节

00:52:40.476 --> 00:52:41.376 A:middle
我想谈一谈一些关于

00:52:41.376 --> 00:52:42.366 A:middle
管线状态对象的内容

00:52:42.366 --> 00:52:43.546 A:middle
这是花一点时间

00:52:43.546 --> 00:52:44.706 A:middle
才能进入堡垒之夜的

00:52:44.706 --> 00:52:46.146 A:middle
内部运输状态

00:52:46.796 --> 00:52:48.116 A:middle
你非常想最小化

00:52:48.116 --> 00:52:50.446 A:middle
你在框架中模拟游戏时

00:52:50.446 --> 00:52:52.286 A:middle
创建的管线状态对象数量

00:52:52.586 --> 00:52:53.816 A:middle
如果你创造的太多

00:52:53.816 --> 00:52:55.396 A:middle
就很容易造成故障

00:52:55.396 --> 00:52:56.686 A:middle
并造成糟糕的游戏体验

00:52:57.236 --> 00:52:58.606 A:middle
首先 请遵循最佳

00:52:58.606 --> 00:52:59.456 A:middle
实践准则 对

00:52:59.846 --> 00:53:01.266 A:middle
离线编译你的函数

00:52:59.846 --> 00:53:01.266 A:middle
离线编译你的函数

00:53:01.266 --> 00:53:03.426 A:middle
离线构建你的函数库

00:53:03.476 --> 00:53:04.566 A:middle
并将所有函数提取到

00:53:04.566 --> 00:53:05.326 A:middle
单个函数库中

00:53:05.846 --> 00:53:07.056 A:middle
但是你实在是想

00:53:07.056 --> 00:53:08.656 A:middle
确保在加载时创建所有

00:53:08.656 --> 00:53:09.146 A:middle
管线状态对象

00:53:09.556 --> 00:53:11.346 A:middle
但是如果你不能这样做 你会怎么办

00:53:11.786 --> 00:53:12.966 A:middle
所以对于我们来说

00:53:12.966 --> 00:53:14.086 A:middle
置换矩阵只是一个疯狂的行为

00:53:14.136 --> 00:53:15.516 A:middle
对于我们来说

00:53:15.516 --> 00:53:18.016 A:middle
在加载时 实际创建的方式太多了

00:53:18.076 --> 00:53:20.586 A:middle
我们有多个开发者创作的着色器

00:53:20.586 --> 00:53:22.286 A:middle
数千个着色器

00:53:22.846 --> 00:53:24.306 A:middle
基于阴影级联数量

00:53:24.306 --> 00:53:26.356 A:middle
的多个照明场景等

00:53:26.356 --> 00:53:28.926 A:middle
不同渲染目标格式

00:53:28.926 --> 00:53:30.546 A:middle
MSAA

00:53:30.776 --> 00:53:31.516 A:middle
名单有很长

00:53:32.726 --> 00:53:33.576 A:middle
我们尽可能减少

00:53:33.576 --> 00:53:35.116 A:middle
排列组合的数量

00:53:35.116 --> 00:53:35.776 A:middle
这确实有帮助

00:53:35.776 --> 00:53:37.136 A:middle
有时候动态分支比

00:53:37.136 --> 00:53:38.626 A:middle
创建静态排列表现

00:53:38.626 --> 00:53:42.356 A:middle
更好 但有时候就不行

00:53:42.736 --> 00:53:44.716 A:middle
我们必须要做的是

00:53:44.716 --> 00:53:45.966 A:middle
决定可能需要的

00:53:45.966 --> 00:53:47.186 A:middle
最常见的子集

00:53:47.186 --> 00:53:49.196 A:middle
并且在载入时创建这些子集

00:53:49.566 --> 00:53:50.856 A:middle
我们不试图创造一切

00:53:51.306 --> 00:53:52.576 A:middle
我们实现这一目标

00:53:52.576 --> 00:53:54.116 A:middle
的方式是创建了一个自动化的管线

00:53:54.116 --> 00:53:55.296 A:middle
我们基本上是在环境中

00:53:55.296 --> 00:53:56.716 A:middle
安装了一台摄像机

00:53:56.716 --> 00:53:58.116 A:middle
并记录了所有的

00:53:58.116 --> 00:53:59.286 A:middle
需要实际渲染环境的

00:53:59.286 --> 00:53:59.876 A:middle
管线状态对象

00:54:00.316 --> 00:54:01.226 A:middle
然后 在我们的日常

00:54:01.226 --> 00:54:03.396 A:middle
测试中 我们获得了

00:54:03.396 --> 00:54:06.106 A:middle
所有未被该自动化管线

00:54:06.106 --> 00:54:07.576 A:middle
所捕获的管线状态对象

00:54:07.966 --> 00:54:09.276 A:middle
自动化管线也

00:54:09.756 --> 00:54:12.476 A:middle
可以捕获像美化

00:54:12.896 --> 00:54:14.176 A:middle
和发射不同武器的效果

00:54:14.176 --> 00:54:15.136 A:middle
等等对象

00:54:16.556 --> 00:54:18.056 A:middle
我们把从自动化

00:54:18.056 --> 00:54:19.126 A:middle
和游戏测试中获取

00:54:19.126 --> 00:54:20.666 A:middle
所有这些信息组合成一个列表

00:54:20.856 --> 00:54:22.486 A:middle
这是我们在加载时创建的

00:54:22.486 --> 00:54:24.416 A:middle
也是我们随游戏一起运行的内容

00:54:24.956 --> 00:54:26.266 A:middle
这并不完美 但我们发现

00:54:26.266 --> 00:54:27.556 A:middle
我们在运行时创建的

00:54:27.556 --> 00:54:28.686 A:middle
管线状态对象数量

00:54:28.686 --> 00:54:31.146 A:middle
平均为任何游戏部分创建的个位数

00:54:31.516 --> 00:54:32.926 A:middle
所以玩家不会遇到任何

00:54:32.926 --> 00:54:34.846 A:middle
生成管线状态对象的麻烦

00:54:37.356 --> 00:54:39.096 A:middle
资源分配

00:54:39.196 --> 00:54:43.216 A:middle
所以基本上 创建和

00:54:43.366 --> 00:54:46.466 A:middle
删除资源是昂贵的

00:54:46.466 --> 00:54:47.326 A:middle
或可能是昂贵的

00:54:47.326 --> 00:54:50.046 A:middle
这有点像 想一想

00:54:50.046 --> 00:54:50.113 A:middle
[ 音质不清晰 ]

00:54:50.113 --> 00:54:51.166 A:middle
你非常想尽可能

00:54:51.166 --> 00:54:52.276 A:middle
减少你每帧

00:54:52.276 --> 00:54:53.036 A:middle
制作的 [ 音质不清晰 ] 数量

00:54:53.436 --> 00:54:54.246 A:middle
你非常不想

00:54:54.246 --> 00:54:55.416 A:middle
动态创建和销毁

00:54:55.416 --> 00:54:57.246 A:middle
大量资源 但是当你

00:54:57.246 --> 00:54:58.476 A:middle
动态地在内容中进行流式传输时

00:54:58.656 --> 00:55:00.606 A:middle
当你有很多

00:54:58.656 --> 00:55:00.606 A:middle
当你有很多

00:55:00.606 --> 00:55:02.746 A:middle
可移动的对象时

00:55:02.866 --> 00:55:05.026 A:middle
有些操作是无法避免的

00:55:05.646 --> 00:55:09.636 A:middle
所以我们对缓冲区所做的

00:55:09.806 --> 00:55:11.276 A:middle
只是使用缓冲区子分配

00:55:11.276 --> 00:55:13.006 A:middle
基本上是一种不直接分配的策略

00:55:13.346 --> 00:55:14.476 A:middle
首先 我们分配一个大缓冲区

00:55:14.476 --> 00:55:15.996 A:middle
然后我们将大缓冲区

00:55:16.606 --> 00:55:19.146 A:middle
分成小块并重新分配回引擎

00:55:19.146 --> 00:55:20.906 A:middle
以回避始终向 Metal

00:55:20.906 --> 00:55:22.776 A:middle
请求新的缓冲区的操作

00:55:23.056 --> 00:55:24.446 A:middle
而这最终起到了很大的作用

00:55:25.976 --> 00:55:27.636 A:middle
我们还利用可编程混合

00:55:27.636 --> 00:55:30.186 A:middle
来减少解析

00:55:30.186 --> 00:55:31.906 A:middle
和恢复次数

00:55:31.906 --> 00:55:33.786 A:middle
以及我们使用的内存带宽量

00:55:34.356 --> 00:55:36.596 A:middle
具体来说 我们对此的

00:55:36.596 --> 00:55:38.536 A:middle
主要使用场景是任何我们

00:55:38.536 --> 00:55:40.336 A:middle
需要访问场景深度的地方

00:55:40.336 --> 00:55:41.416 A:middle
例如软粒子混合

00:55:41.416 --> 00:55:43.286 A:middle
或投影贴图

00:55:43.286 --> 00:55:45.036 A:middle
我们所做的是在

00:55:45.036 --> 00:55:46.586 A:middle
正向传递期间将线性深度

00:55:46.586 --> 00:55:47.546 A:middle
写入 Alpha 通道

00:55:47.946 --> 00:55:49.126 A:middle
然后 在我们

00:55:49.126 --> 00:55:50.546 A:middle
的贴图和半透明化的过程中

00:55:50.546 --> 00:55:52.246 A:middle
我们需要做的就是

00:55:52.246 --> 00:55:53.266 A:middle
使用可编程混合来

00:55:53.266 --> 00:55:55.146 A:middle
读取该 Alpha 通道

00:55:55.146 --> 00:55:57.796 A:middle
并且可以使用深度信息

00:55:57.916 --> 00:56:00.186 A:middle
而不必将深度缓冲区解析到主内存

00:55:57.916 --> 00:56:00.186 A:middle
而不必将深度缓冲区解析到主内存

00:56:01.916 --> 00:56:03.006 A:middle
我们也使用它来提高

00:56:03.006 --> 00:56:04.286 A:middle
MSAA 的质量

00:56:04.806 --> 00:56:06.356 A:middle
正如我所提到的

00:56:06.356 --> 00:56:08.316 A:middle
我们进行 HDR 渲染 但是

00:56:08.316 --> 00:56:10.906 A:middle
仅仅是 HDR 的 MSAA 解析仍然会

00:56:10.906 --> 00:56:12.116 A:middle
导致非常参差的边缘

00:56:12.506 --> 00:56:13.556 A:middle
想想你有一个

00:56:13.556 --> 00:56:15.226 A:middle
非常非常明亮的天空和

00:56:15.226 --> 00:56:16.636 A:middle
非常非常黑暗的前视图的情况

00:56:17.126 --> 00:56:19.616 A:middle
这时只需要做一个

00:56:19.616 --> 00:56:22.526 A:middle
盒式过滤器就可以了 基本上

00:56:22.526 --> 00:56:24.396 A:middle
是说如果其中一个子样本

00:56:24.576 --> 00:56:25.876 A:middle
非常明亮 其他样本非常

00:56:25.876 --> 00:56:27.516 A:middle
黑暗 那么结果将是

00:56:27.516 --> 00:56:29.106 A:middle
一个令人难以置信的明亮像素

00:56:29.106 --> 00:56:30.066 A:middle
当色调映射时

00:56:30.066 --> 00:56:31.136 A:middle
它会接近白色

00:56:31.516 --> 00:56:32.656 A:middle
你最终会看到边缘看起来

00:56:32.656 --> 00:56:33.766 A:middle
完全没有反锯齿的样子

00:56:33.766 --> 00:56:36.436 A:middle
因此 我们的解决方案

00:56:36.436 --> 00:56:38.866 A:middle
是对所有 MSAA 样本执行

00:56:38.866 --> 00:56:41.686 A:middle
预先的色调映射 然后

00:56:41.686 --> 00:56:43.606 A:middle
执行正常的 MSAA 分辨率

00:56:43.606 --> 00:56:44.766 A:middle
然后第一个后处理通道

00:56:44.766 --> 00:56:46.576 A:middle
只是反转之前的预映射图

00:56:47.486 --> 00:56:49.026 A:middle
我们使用可编程混合进行

00:56:49.026 --> 00:56:50.116 A:middle
预色调贴图过程

00:56:50.746 --> 00:56:51.946 A:middle
否则 我们必须将

00:56:51.946 --> 00:56:53.576 A:middle
整个 MSAA 颜色缓冲区

00:56:53.576 --> 00:56:55.366 A:middle
解析为内存并将其读回

00:56:55.366 --> 00:56:56.796 A:middle
这是我们负担不起的

00:56:58.676 --> 00:57:00.316 A:middle
接下来我将展望一下

00:56:58.676 --> 00:57:00.316 A:middle
接下来我将展望一下

00:57:00.316 --> 00:57:01.546 A:middle
未来我们希望在

00:57:01.546 --> 00:57:04.556 A:middle
Metal 中进行的一些工作并行渲染

00:57:04.556 --> 00:57:06.996 A:middle
所以在 macOS 上 我们

00:57:07.416 --> 00:57:08.626 A:middle
确实支持并行地创建

00:57:08.626 --> 00:57:09.216 A:middle
命令缓冲区

00:57:09.756 --> 00:57:12.186 A:middle
在 iOS 上 我们需要

00:57:12.186 --> 00:57:13.266 A:middle
支持并行命令

00:57:13.266 --> 00:57:14.876 A:middle
的编码器才能使用它

00:57:15.176 --> 00:57:16.476 A:middle
我们的很多绘制

00:57:16.476 --> 00:57:17.646 A:middle
最终都会发生在

00:57:17.646 --> 00:57:19.376 A:middle
主要正向传递中 因此将其

00:57:20.176 --> 00:57:21.546 A:middle
并行化非常重要

00:57:22.206 --> 00:57:23.436 A:middle
我认为 看到

00:57:23.436 --> 00:57:25.076 A:middle
并行渲染对单片快速

00:57:25.076 --> 00:57:27.876 A:middle
内核的影响和

00:57:28.006 --> 00:57:30.786 A:middle
在高端设备高效内核上使用

00:57:30.896 --> 00:57:33.156 A:middle
并行命令编码器

00:57:33.156 --> 00:57:34.616 A:middle
的效果进行比较会

00:57:34.616 --> 00:57:35.626 A:middle
非常有趣

00:57:35.946 --> 00:57:36.616 A:middle
这可能会在

00:57:36.616 --> 00:57:38.416 A:middle
电池使用方面产生

00:57:38.416 --> 00:57:38.896 A:middle
一些有趣的结果

00:57:40.656 --> 00:57:41.696 A:middle
Metal 堆

00:57:41.786 --> 00:57:42.736 A:middle
所以我们希望用 Metal 堆

00:57:42.736 --> 00:57:44.276 A:middle
来代替我们的缓冲区

00:57:44.276 --> 00:57:46.396 A:middle
子分配 首先

00:57:46.396 --> 00:57:47.586 A:middle
因为它只是简单的代码

00:57:47.586 --> 00:57:49.246 A:middle
其次 因为我们也可以

00:57:49.246 --> 00:57:50.056 A:middle
把它用于纹理

00:57:50.366 --> 00:57:51.576 A:middle
我们由于纹理流式传输

00:57:51.576 --> 00:57:52.746 A:middle
仍然偶尔会遇到麻烦

00:57:52.746 --> 00:57:54.546 A:middle
因为我们会在显式地

00:57:54.546 --> 00:57:55.736 A:middle
动态地创建和销毁纹理

00:57:55.736 --> 00:57:57.586 A:middle
就像把纹理不断的在内存里进行读写

00:57:58.146 --> 00:57:59.946 A:middle
使用堆可以摆脱

00:57:59.946 --> 00:58:01.516 A:middle
那些困境

00:57:59.946 --> 00:58:01.516 A:middle
那些困境

00:58:01.516 --> 00:58:05.016 A:middle
对我们来说

00:58:05.016 --> 00:58:05.976 A:middle
我们面前的工作就是

00:58:05.976 --> 00:58:08.226 A:middle
要在不同的通道

00:58:08.276 --> 00:58:10.636 A:middle
之间设置精确的栅栏

00:58:10.986 --> 00:58:13.266 A:middle
所以我们需要明确地

00:58:13.266 --> 00:58:14.786 A:middle
知道资源是否被顶点

00:58:14.786 --> 00:58:16.146 A:middle
或像素着色器在

00:58:16.146 --> 00:58:18.266 A:middle
不同的过程中读取或写入

00:58:18.266 --> 00:58:19.776 A:middle
并且这需要我们

00:58:19.776 --> 00:58:22.406 A:middle
对一些渲染器进行一些修改才能实现

00:58:22.936 --> 00:58:25.236 A:middle
当然 也要继续推动 iOS 上的图形学

00:58:25.236 --> 00:58:26.616 A:middle
向高端的发展

00:58:27.456 --> 00:58:29.686 A:middle
去年在 WWDC 上

00:58:29.736 --> 00:58:31.106 A:middle
我们展示了将我们的

00:58:31.106 --> 00:58:32.436 A:middle
桌面级正向渲染器

00:58:32.436 --> 00:58:33.966 A:middle
引入高端 iOS 设备的可能性

00:58:33.966 --> 00:58:35.916 A:middle
并且我们继续在做这件事

00:58:35.916 --> 00:58:37.126 A:middle
我们希望继续在 iOS 上

00:58:37.126 --> 00:58:39.656 A:middle
推动这一目标

00:58:39.656 --> 00:58:43.016 A:middle
继续为 iOS 带来

00:58:43.936 --> 00:58:47.026 A:middle
桌面级功能并寻找机会

00:58:47.026 --> 00:58:49.756 A:middle
将我们的桌面渲染器与

00:58:49.896 --> 00:58:51.506 A:middle
iOS 渲染器统一起来

00:58:52.046 --> 00:58:55.846 A:middle
然后 我要把场地交回给 Michael

00:58:57.516 --> 00:58:59.716 A:middle
[ 掌声 ]

00:59:00.216 --> 00:59:01.596 A:middle
&gt;&gt; Metal 技术

00:59:01.596 --> 00:59:03.696 A:middle
的开销很低

00:59:03.696 --> 00:59:05.106 A:middle
但可以通过多线程

00:59:05.106 --> 00:59:05.836 A:middle
高效地渲染许多对象

00:59:06.246 --> 00:59:07.736 A:middle
Metal 技术是

00:59:07.736 --> 00:59:09.736 A:middle
为了充分利用我们系统中的所有 GPU

00:59:09.736 --> 00:59:10.366 A:middle
和所有 CPU 而创建的

00:59:11.326 --> 00:59:13.156 A:middle
Metal 技术也是

00:59:13.156 --> 00:59:14.776 A:middle
真正可访问的 但高级渲染

00:59:14.776 --> 00:59:16.106 A:middle
有时需要显式控制

00:59:16.856 --> 00:59:18.386 A:middle
当你需要内存管理和

00:59:18.386 --> 00:59:19.226 A:middle
GPU 并行性时

00:59:19.226 --> 00:59:21.306 A:middle
Metal 技术提供了这种控制

00:59:22.526 --> 00:59:23.816 A:middle
我们还引入了间接命令缓冲区

00:59:23.816 --> 00:59:25.026 A:middle
这是我们的全新功能

00:59:25.026 --> 00:59:26.116 A:middle
它可以让你将命令

00:59:26.116 --> 00:59:27.616 A:middle
生成完全移至 GPU

00:59:27.616 --> 00:59:30.276 A:middle
释放 CPU 来执行其他任务

00:59:31.106 --> 00:59:32.666 A:middle
与参数缓冲区一起

00:59:32.906 --> 00:59:33.816 A:middle
这些功能为 GPU 驱动的

00:59:33.816 --> 00:59:36.216 A:middle
管线提供了完整的解决方案

00:59:37.306 --> 00:59:39.236 A:middle
最后 Metal 允许你

00:59:39.236 --> 00:59:40.086 A:middle
利用 A11 GPU 的

00:59:40.086 --> 00:59:42.256 A:middle
高级架构来优化

00:59:42.256 --> 00:59:43.426 A:middle
渲染技术

00:59:43.426 --> 00:59:44.796 A:middle
以实现最佳性能

00:59:44.796 --> 00:59:47.396 A:middle
和更长的游戏时间

00:59:49.126 --> 00:59:50.896 A:middle
想要了解更多信息

00:59:50.896 --> 00:59:52.656 A:middle
请访问我们的网站 并确保

00:59:52.736 --> 00:59:55.446 A:middle
访问我们明天的实验室 谢谢

00:59:56.516 --> 01:00:04.010 A:middle
[ 掌声 ]
