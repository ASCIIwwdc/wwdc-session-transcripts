WEBVTT

00:00:07.016 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:23.516 --> 00:00:27.616 A:middle
[ 掌声 ]

00:00:28.116 --> 00:00:28.656 A:middle
&gt;&gt; 大家好

00:00:29.016 --> 00:00:29.686 A:middle
我是 Kyle

00:00:29.686 --> 00:00:30.776 A:middle
我是一名 Apple 的软件工程师

00:00:30.876 --> 00:00:32.195 A:middle
今天我们要将深入

00:00:32.195 --> 00:00:33.386 A:middle
研究一下 iOS 内存

00:00:34.066 --> 00:00:35.986 A:middle
要知道的是

00:00:35.986 --> 00:00:36.986 A:middle
尽管这里说的是 iOS

00:00:36.986 --> 00:00:38.536 A:middle
我们接下来涉及到的很多内容

00:00:38.536 --> 00:00:42.546 A:middle
也适用于其他平台

00:00:43.186 --> 00:00:44.626 A:middle
我们首先要讨论的

00:00:44.626 --> 00:00:46.706 A:middle
是为什么要减少内存

00:00:48.886 --> 00:00:50.836 A:middle
当我们提到减少内存时

00:00:50.836 --> 00:00:51.746 A:middle
我们实际上

00:00:51.746 --> 00:00:53.116 A:middle
是在讨论减少内存占用

00:00:53.296 --> 00:00:53.976 A:middle
那么我们就来谈谈这点

00:00:55.326 --> 00:00:56.586 A:middle
我们将讨论一些

00:00:56.586 --> 00:00:57.986 A:middle
可以用来分析内存占用的工具

00:00:59.146 --> 00:01:00.706 A:middle
我们会有一些针对图像的提醒

00:00:59.146 --> 00:01:00.706 A:middle
我们会有一些针对图像的提醒

00:01:00.706 --> 00:01:03.116 A:middle
还会讲到后台优化

00:01:03.196 --> 00:01:05.096 A:middle
最后 我们会用一个很好的演示作为总结

00:01:06.446 --> 00:01:08.786 A:middle
为什么减少内存呢

00:01:10.496 --> 00:01:12.196 A:middle
简单的回答是

00:01:12.196 --> 00:01:13.086 A:middle
为了使用户获得更好的体验

00:01:13.396 --> 00:01:14.986 A:middle
不仅你的 App 会启动得更快

00:01:15.056 --> 00:01:16.276 A:middle
系统会表现得更好

00:01:16.906 --> 00:01:18.016 A:middle
你的 App 也会在内存中保留

00:01:18.016 --> 00:01:18.436 A:middle
更长的时间

00:01:18.666 --> 00:01:19.646 A:middle
其他 App 也会在内存中保留

00:01:19.646 --> 00:01:20.036 A:middle
更长的时间

00:01:20.266 --> 00:01:21.466 A:middle
几乎一切都变得更好

00:01:22.266 --> 00:01:23.176 A:middle
现在 如果你看看周围

00:01:23.356 --> 00:01:25.426 A:middle
你实际上也在通过

00:01:25.426 --> 00:01:26.796 A:middle
减少内存

00:01:26.796 --> 00:01:27.676 A:middle
来帮助其他开发者

00:01:28.766 --> 00:01:30.716 A:middle
我们讨论的是减少内存

00:01:30.716 --> 00:01:32.616 A:middle
但实际上减少的是内存占用

00:01:32.976 --> 00:01:34.376 A:middle
内存和人不同 它们生而“不”平等

00:01:34.816 --> 00:01:35.616 A:middle
这是什么意思呢

00:01:36.856 --> 00:01:38.186 A:middle
我们需要谈谈 “Pages”

00:01:38.656 --> 00:01:39.646 A:middle
不是这个 “Pages 文稿”

00:01:40.436 --> 00:01:41.876 A:middle
我们将要讨论内存的页面

00:01:42.436 --> 00:01:44.196 A:middle
系统给了你一个内存页

00:01:44.196 --> 00:01:46.096 A:middle
它可以堆的形式

00:01:46.096 --> 00:01:47.676 A:middle
存储多个对象

00:01:48.126 --> 00:01:50.206 A:middle
有些对象实际上

00:01:50.206 --> 00:01:51.496 A:middle
可以跨越多个内存页

00:01:52.056 --> 00:01:55.866 A:middle
它们的大小一般是 16KB

00:01:56.276 --> 00:01:57.816 A:middle
可以是净页

00:01:57.816 --> 00:01:58.176 A:middle
也可以是脏页

00:02:00.236 --> 00:02:01.806 A:middle
App 的内存使用

00:02:01.806 --> 00:02:03.036 A:middle
实际上指的是页面数量

00:02:03.116 --> 00:02:04.686 A:middle
乘以页面大小

00:02:05.366 --> 00:02:10.586 A:middle
这有一个净页和脏页的例子

00:02:10.586 --> 00:02:13.766 A:middle
假设我分配了一个含有 20000 个

00:02:13.766 --> 00:02:14.196 A:middle
整数的数组

00:02:14.816 --> 00:02:16.916 A:middle
系统可能会分配给我 6 个内存页面

00:02:18.036 --> 00:02:19.966 A:middle
当我分配这些页面时

00:02:19.966 --> 00:02:20.676 A:middle
它们是净页

00:02:21.156 --> 00:02:22.386 A:middle
但是 当我开始

00:02:22.386 --> 00:02:23.816 A:middle
对数据缓冲区进行写入时

00:02:23.816 --> 00:02:25.406 A:middle
例如 如果我写入到这个数组的第一个位置

00:02:25.406 --> 00:02:27.766 A:middle
这个内存页就会变成脏页

00:02:28.856 --> 00:02:30.996 A:middle
类似地

00:02:30.996 --> 00:02:33.396 A:middle
如果我写入到

00:02:33.396 --> 00:02:34.646 A:middle
缓冲区中的最后一个位置

00:02:34.646 --> 00:02:35.686 A:middle
最后一页也会变成 脏页

00:02:36.436 --> 00:02:37.416 A:middle
请注意 中间的四个页面

00:02:37.416 --> 00:02:38.566 A:middle
仍然是 净页

00:02:38.566 --> 00:02:42.896 A:middle
因为 App 还没有写入它们

00:02:42.896 --> 00:02:45.556 A:middle
另一个有趣的话题是内存映射文件

00:02:45.856 --> 00:02:48.206 A:middle
它是一种在磁盘上的文件

00:02:48.206 --> 00:02:49.306 A:middle
但加载到了内存中

00:02:50.296 --> 00:02:51.506 A:middle
如果你用的是只读文件

00:02:51.506 --> 00:02:52.976 A:middle
这些将一直是净页

00:02:53.846 --> 00:02:55.066 A:middle
内核实际上

00:02:55.066 --> 00:02:57.056 A:middle
是在它们离开磁盘写入 RAM 时进行管理的

00:02:57.746 --> 00:03:01.266 A:middle
JPEG 就是一个很好的例子

00:02:57.746 --> 00:03:01.266 A:middle
JPEG 就是一个很好的例子

00:03:01.656 --> 00:03:03.036 A:middle
如果我有一个 JPEG 文件

00:03:03.036 --> 00:03:05.586 A:middle
比如说 它有 50KB 大

00:03:05.646 --> 00:03:07.416 A:middle
当它被映射到内存中时

00:03:07.416 --> 00:03:09.746 A:middle
它实际上被映射到

00:03:09.746 --> 00:03:10.576 A:middle
大约 4 页内存中

00:03:10.976 --> 00:03:12.436 A:middle
第 4 页实际上

00:03:12.436 --> 00:03:13.936 A:middle
并没有被完全填满

00:03:13.936 --> 00:03:14.876 A:middle
所以它可以用来做其他的事情

00:03:14.876 --> 00:03:16.846 A:middle
内存就是像这样复杂

00:03:16.936 --> 00:03:18.376 A:middle
但是之前的那三页

00:03:18.456 --> 00:03:21.736 A:middle
总是可以被系统释放

00:03:22.056 --> 00:03:26.156 A:middle
当我们讨论某个典型的 App 时

00:03:26.446 --> 00:03:28.366 A:middle
它们的内存占用和分析文件

00:03:28.366 --> 00:03:30.146 A:middle
都会有一个脏的 一个压缩的

00:03:30.146 --> 00:03:31.166 A:middle
以及一个干净的内存段

00:03:32.136 --> 00:03:32.926 A:middle
让我分别来看看

00:03:34.766 --> 00:03:37.826 A:middle
净内存是可以被分页的数据

00:03:38.346 --> 00:03:40.676 A:middle
这些是我们刚刚讨论过的内存映射文件

00:03:41.016 --> 00:03:43.216 A:middle
可以是图像文件 Blob.data

00:03:43.566 --> 00:03:44.376 A:middle
或者 Training.model

00:03:44.916 --> 00:03:47.126 A:middle
也可以是框架

00:03:48.546 --> 00:03:50.566 A:middle
每个框架都有一个

00:03:50.566 --> 00:03:51.486 A:middle
_DATA_CONST 部分

00:03:52.506 --> 00:03:53.466 A:middle
它通常是 净内存

00:03:53.466 --> 00:03:54.406 A:middle
但是如果你做了任何运行时的小把戏

00:03:54.406 --> 00:03:55.726 A:middle
比如 “Method Swizzling（方法交换）”

00:03:55.726 --> 00:04:00.876 A:middle
那么它就会变成脏内存

00:03:55.726 --> 00:04:00.876 A:middle
那么它就会变成脏内存

00:04:01.056 --> 00:04:03.146 A:middle
脏内存是

00:04:03.146 --> 00:04:04.556 A:middle
App 写入的任何内存

00:04:05.676 --> 00:04:07.516 A:middle
它们可以是对象

00:04:07.946 --> 00:04:09.016 A:middle
比如 malloc

00:04:09.146 --> 00:04:10.416 A:middle
字符串 数组等等

00:04:11.056 --> 00:04:14.186 A:middle
它可以是已解码的图像缓冲

00:04:14.366 --> 00:04:15.426 A:middle
我们稍后会讲到这点

00:04:15.926 --> 00:04:18.576 A:middle
它也可以是框架

00:04:19.305 --> 00:04:21.196 A:middle
框架也有一个 _DATA 部分

00:04:21.196 --> 00:04:23.356 A:middle
和一个 _DATA_DIRTY 部分

00:04:24.256 --> 00:04:26.786 A:middle
它们总是指向脏内存

00:04:27.926 --> 00:04:29.216 A:middle
你可能注意到了

00:04:29.216 --> 00:04:30.446 A:middle
我曾两次提到了框架

00:04:30.776 --> 00:04:32.486 A:middle
是的 你链接的框架

00:04:32.486 --> 00:04:34.976 A:middle
实际上使用内存

00:04:34.976 --> 00:04:35.286 A:middle
和脏内存

00:04:35.766 --> 00:04:36.976 A:middle
它是一个

00:04:36.976 --> 00:04:39.066 A:middle
连接框架的必要部分

00:04:39.066 --> 00:04:39.756 A:middle
但如果你要保持自己的框架

00:04:39.756 --> 00:04:41.776 A:middle
可以使用单例

00:04:41.776 --> 00:04:43.726 A:middle
和全局初始化器

00:04:43.726 --> 00:04:45.256 A:middle
来减少他们使用的

00:04:45.256 --> 00:04:46.786 A:middle
脏内存

00:04:46.786 --> 00:04:48.146 A:middle
因为单例

00:04:48.226 --> 00:04:49.246 A:middle
在被创建之后

00:04:49.366 --> 00:04:51.376 A:middle
才会进入内存 初始化器也只有

00:04:51.376 --> 00:04:53.976 A:middle
在框架被链接或类被加载时

00:04:57.346 --> 00:05:00.986 A:middle
才会运行 压缩内存非常酷

00:04:57.346 --> 00:05:00.986 A:middle
才会运行 压缩内存非常酷

00:05:00.986 --> 00:05:03.066 A:middle
iOS 没有传统的磁盘交换系统

00:05:03.946 --> 00:05:06.446 A:middle
取而代之 它使用内存压缩器

00:05:06.626 --> 00:05:10.606 A:middle
它是在 iOS 7 中被引入的内存压缩器

00:05:10.606 --> 00:05:12.526 A:middle
接收未访问的内存页

00:05:12.526 --> 00:05:13.776 A:middle
并压缩它们

00:05:13.776 --> 00:05:15.656 A:middle
这实际上可以创建更多的空间

00:05:16.366 --> 00:05:17.586 A:middle
但在访问时

00:05:17.586 --> 00:05:19.226 A:middle
压缩器会对它们进行解压

00:05:19.516 --> 00:05:20.266 A:middle
以便读取内存

00:05:20.936 --> 00:05:22.076 A:middle
让我们看一个例子

00:05:23.296 --> 00:05:25.316 A:middle
假设我有一个用于缓存的字典

00:05:25.876 --> 00:05:27.336 A:middle
它占用了 3 页的内存

00:05:27.336 --> 00:05:29.796 A:middle
但是如果我有一段时间

00:05:29.796 --> 00:05:31.266 A:middle
没有访问过它

00:05:31.266 --> 00:05:32.436 A:middle
且系统需要一些空间

00:05:32.436 --> 00:05:33.366 A:middle
系统就可以把它

00:05:33.366 --> 00:05:35.436 A:middle
压缩到一个内存页中

00:05:35.896 --> 00:05:38.156 A:middle
它现在被压缩了

00:05:38.716 --> 00:05:40.806 A:middle
但同时我节省了空间

00:05:40.806 --> 00:05:42.246 A:middle
或者说我现在有了两个额外的内存页

00:05:42.896 --> 00:05:44.056 A:middle
如果在未来的某个时刻我想访问它

00:05:44.056 --> 00:05:45.786 A:middle
它将会恢复原来的大小

00:05:46.456 --> 00:05:48.696 A:middle
我们来谈谈内存警告

00:05:49.446 --> 00:05:51.586 A:middle
App 并不总是

00:05:51.946 --> 00:05:52.876 A:middle
引起内存警告的原因

00:05:53.736 --> 00:05:54.736 A:middle
如果你在一个低内存的设备上

00:05:54.736 --> 00:05:57.196 A:middle
接到一个电话

00:05:57.256 --> 00:05:58.156 A:middle
那也可能会触发一个内存警告

00:05:58.156 --> 00:05:59.036 A:middle
你就有麻烦了

00:05:59.126 --> 00:06:00.586 A:middle
所以不要想当然地认为

00:05:59.126 --> 00:06:00.586 A:middle
所以不要想当然地认为

00:06:00.996 --> 00:06:02.826 A:middle
内存警告是你造成的

00:06:03.986 --> 00:06:06.386 A:middle
压缩器使内存的释放

00:06:06.386 --> 00:06:08.636 A:middle
变得复杂

00:06:09.516 --> 00:06:10.146 A:middle
因为根据压缩的内容

00:06:10.146 --> 00:06:12.106 A:middle
实际上你可以 比以前使用更多的内存

00:06:12.356 --> 00:06:15.986 A:middle
因此我们建议修改策略

00:06:15.986 --> 00:06:17.136 A:middle
比如暂时不缓存任何内容

00:06:17.686 --> 00:06:18.896 A:middle
或者在发生内存警告时

00:06:18.896 --> 00:06:21.106 A:middle
限制一些后台工作

00:06:22.536 --> 00:06:24.386 A:middle
我们中的一些人可能在 App 中

00:06:24.386 --> 00:06:24.846 A:middle
遇到这种情况

00:06:25.476 --> 00:06:27.726 A:middle
我们得到一个内存警告

00:06:27.726 --> 00:06:28.826 A:middle
并决定从缓存中

00:06:28.826 --> 00:06:31.126 A:middle
删除所有对象

00:06:31.336 --> 00:06:33.856 A:middle
回到压缩字典的例子

00:06:34.646 --> 00:06:35.606 A:middle
会发生什么呢

00:06:35.896 --> 00:06:37.446 A:middle
既然我正在访问这个字典

00:06:37.446 --> 00:06:39.496 A:middle
我现在比以前

00:06:39.496 --> 00:06:41.216 A:middle
使用了更多的内存页

00:06:42.046 --> 00:06:43.866 A:middle
在内存受限的环境中

00:06:43.926 --> 00:06:45.546 A:middle
我们并不希望这样

00:06:46.466 --> 00:06:47.726 A:middle
因为我删除了所有的对象

00:06:47.726 --> 00:06:50.186 A:middle
我做了很多工作

00:06:50.186 --> 00:06:51.306 A:middle
只是为了让它回到

00:06:51.306 --> 00:06:52.356 A:middle
之前被压缩时的样子

00:06:52.356 --> 00:06:53.016 A:middle
也就是只占用一个内存页

00:06:54.246 --> 00:06:57.796 A:middle
所以我们要注意记忆警告

00:06:59.376 --> 00:07:02.466 A:middle
这就提出了一个关于缓存的重要问题

00:06:59.376 --> 00:07:02.466 A:middle
这就提出了一个关于缓存的重要问题

00:07:03.276 --> 00:07:05.926 A:middle
当我们缓存时 我们实际上是在试图

00:07:05.926 --> 00:07:07.466 A:middle
避免 CPU 重复工作

00:07:07.466 --> 00:07:08.826 A:middle
但是如果我们缓存太多

00:07:08.826 --> 00:07:10.306 A:middle
我们将耗尽所有的内存

00:07:10.716 --> 00:07:12.476 A:middle
这可能会给系统带来问题

00:07:13.436 --> 00:07:15.316 A:middle
所以请记住 我们有

00:07:15.316 --> 00:07:16.536 A:middle
内存压缩器和缓存

00:07:16.696 --> 00:07:17.966 A:middle
最好平衡一下

00:07:17.966 --> 00:07:20.326 A:middle
缓存与重新计算的内容

00:07:21.386 --> 00:07:22.676 A:middle
另一个注意事项是

00:07:22.676 --> 00:07:23.796 A:middle
如果使用的不是字典

00:07:23.796 --> 00:07:25.706 A:middle
而是 NSCache

00:07:25.706 --> 00:07:28.146 A:middle
这将是存储缓存对象的安全方法

00:07:28.506 --> 00:07:30.336 A:middle
由于 NSCache

00:07:30.336 --> 00:07:31.326 A:middle
分配内存的方式

00:07:31.326 --> 00:07:32.806 A:middle
它实际上是可被释放的

00:07:32.806 --> 00:07:33.396 A:middle
所以在内存受限的环境中

00:07:33.396 --> 00:07:34.436 A:middle
它的效果更好

00:07:34.876 --> 00:07:38.396 A:middle
回到典型的 App 中的

00:07:38.396 --> 00:07:40.136 A:middle
这三个部分

00:07:40.136 --> 00:07:41.166 A:middle
当我们讨论 App 的内存占用时

00:07:41.166 --> 00:07:42.636 A:middle
我们实际上是在讨论那些脏的

00:07:42.636 --> 00:07:44.046 A:middle
和压缩的部分

00:07:44.146 --> 00:07:46.766 A:middle
净内存在这里并不重要

00:07:47.876 --> 00:07:51.646 A:middle
每个 App 都有一个内存占用限制

00:07:53.016 --> 00:07:54.816 A:middle
这个限制对于一个 App 来说

00:07:54.816 --> 00:07:56.486 A:middle
是相当高的

00:07:56.556 --> 00:07:57.786 A:middle
但是请记住 根据设备的不同

00:07:58.276 --> 00:07:59.386 A:middle
这个限制也会改变

00:07:59.506 --> 00:08:01.346 A:middle
因此 你不能像

00:07:59.506 --> 00:08:01.346 A:middle
因此 你不能像

00:08:01.346 --> 00:08:02.556 A:middle
在内存 4GB 设备上那样

00:08:02.556 --> 00:08:03.946 A:middle
在 1GB 的设备上

00:08:03.946 --> 00:08:10.286 A:middle
使用同样多的内存 还有扩展

00:08:10.636 --> 00:08:11.896 A:middle
扩展的内存占用要小得多

00:08:11.896 --> 00:08:13.726 A:middle
所以在使用扩展时

00:08:13.726 --> 00:08:16.426 A:middle
你需要更加注意这一点

00:08:17.696 --> 00:08:19.836 A:middle
当你超过了内存占用限制

00:08:19.836 --> 00:08:21.356 A:middle
就会出现异常

00:08:22.146 --> 00:08:24.356 A:middle
这种异常就是

00:08:24.356 --> 00:08:26.196 A:middle
EXC_RESOURCE_EXCEPTION

00:08:27.366 --> 00:08:30.066 A:middle
现在我想邀请

00:08:30.066 --> 00:08:31.616 A:middle
James 来谈谈

00:08:31.616 --> 00:08:32.765 A:middle
如何分析我们的内存占用

00:08:34.515 --> 00:08:36.775 A:middle
[ 掌声 ]

00:08:37.275 --> 00:08:37.686 A:middle
谢谢 James

00:08:38.236 --> 00:08:38.616 A:middle
&gt;&gt; 谢谢你

00:08:40.655 --> 00:08:41.066 A:middle
谢谢 Kyle

00:08:41.256 --> 00:08:42.035 A:middle
好的

00:08:42.226 --> 00:08:42.736 A:middle
我是 James

00:08:42.736 --> 00:08:44.155 A:middle
我是一名 Apple 的软件工程师

00:08:44.456 --> 00:08:45.706 A:middle
我想向你们介绍一些

00:08:45.706 --> 00:08:47.886 A:middle
更高级的工具用于分析和研究

00:08:47.886 --> 00:08:49.406 A:middle
App 的内存占用情况

00:08:51.456 --> 00:08:52.346 A:middle
你可能已经熟悉了

00:08:52.346 --> 00:08:53.906 A:middle
Xcode 内存测量计

00:08:54.436 --> 00:08:57.036 A:middle
它就在调试导航器中

00:08:57.166 --> 00:08:59.086 A:middle
它是帮助你快速查看 App 内存占用

00:08:59.086 --> 00:09:00.546 A:middle
很好的一种方式

00:08:59.086 --> 00:09:00.546 A:middle
很好的一种方式

00:09:00.966 --> 00:09:03.086 A:middle
在 Xcode 10 中

00:09:03.086 --> 00:09:04.516 A:middle
它现在可向你输出

00:09:04.516 --> 00:09:05.696 A:middle
系统对你的评分值

00:09:05.696 --> 00:09:06.526 A:middle
所以如果看起来与 Xcode 9 不同

00:09:06.526 --> 00:09:08.186 A:middle
不要太在意

00:09:09.226 --> 00:09:11.676 A:middle
我正在 Xcode 中运行我的 App

00:09:11.676 --> 00:09:12.606 A:middle
我发现它消耗了更多的内存

00:09:13.386 --> 00:09:14.636 A:middle
那么下一步我应该用什么工具呢

00:09:15.316 --> 00:09:17.306 A:middle
显然是 Instruments

00:09:18.356 --> 00:09:19.826 A:middle
它提供了许多方法

00:09:19.826 --> 00:09:21.186 A:middle
来调查 App 的内存占用

00:09:21.916 --> 00:09:24.256 A:middle
你可能已经熟悉

00:09:24.256 --> 00:09:25.556 A:middle
“Allocations” 和 “Leaks”

00:09:25.776 --> 00:09:27.316 A:middle
“Allocations”

00:09:27.316 --> 00:09:28.466 A:middle
分析由你的 App 所分配的堆

00:09:28.886 --> 00:09:29.866 A:middle
“Leaks”

00:09:29.866 --> 00:09:31.056 A:middle
会检查一个进程中的内存泄漏

00:09:31.226 --> 00:09:32.756 A:middle
但是你可能不太熟悉

00:09:32.756 --> 00:09:33.946 A:middle
“VM Tracker”

00:09:33.946 --> 00:09:34.826 A:middle
和 “Virtual memory trace（虚拟内存追踪）”

00:09:35.376 --> 00:09:37.326 A:middle
如果你还记得

00:09:37.326 --> 00:09:38.066 A:middle
Kyle 谈论过的

00:09:38.066 --> 00:09:39.416 A:middle
iOS 内存的主要类别

00:09:39.486 --> 00:09:41.456 A:middle
他谈到了脏内存

00:09:41.456 --> 00:09:42.516 A:middle
和压缩内存

00:09:42.946 --> 00:09:44.556 A:middle
VM Tracker 提供了一种

00:09:44.556 --> 00:09:45.806 A:middle
很好的分析方式

00:09:47.116 --> 00:09:48.616 A:middle
它为脏内存

00:09:48.616 --> 00:09:50.046 A:middle
以及交换内存即 iOS 中的压缩内存

00:09:50.046 --> 00:09:51.646 A:middle
分别提供了独立的追踪

00:09:51.646 --> 00:09:52.386 A:middle
并告诉你

00:09:52.386 --> 00:09:53.186 A:middle
关于常驻内存大小的信息

00:09:53.996 --> 00:09:55.176 A:middle
我认为这对于

00:09:55.176 --> 00:09:57.926 A:middle
研究 App 的脏内存大小 非常有用

00:09:58.516 --> 00:09:59.866 A:middle
Instruments 中的最后一项是

00:09:59.866 --> 00:10:01.046 A:middle
“Virtual memory trace（虚拟内存追踪）”

00:09:59.866 --> 00:10:01.046 A:middle
“Virtual memory trace（虚拟内存追踪）”

00:10:01.786 --> 00:10:03.326 A:middle
你可以凭借它

00:10:03.326 --> 00:10:04.446 A:middle
与你 App 相关的虚拟内存系统的性能

00:10:04.446 --> 00:10:06.726 A:middle
进行深入的了解

00:10:08.736 --> 00:10:10.486 A:middle
我发现这里的 “By Operation” 标签页

00:10:10.486 --> 00:10:11.226 A:middle
非常有用

00:10:11.916 --> 00:10:12.996 A:middle
它为你提供了一个

00:10:12.996 --> 00:10:14.386 A:middle
虚拟内存系统文件

00:10:14.386 --> 00:10:16.376 A:middle
并向你展示虚拟内存的内存页缓存命中

00:10:16.376 --> 00:10:18.826 A:middle
以及内存页零填充之类的内容

00:10:21.016 --> 00:10:22.536 A:middle
Kyle 前面提到

00:10:22.536 --> 00:10:23.726 A:middle
如果你接近设备的内存限制

00:10:23.726 --> 00:10:25.146 A:middle
你将收到

00:10:25.146 --> 00:10:26.766 A:middle
EXC_RESOURCE_EXCEPTION 的异常

00:10:27.276 --> 00:10:28.346 A:middle
如果你正在 Xcode 10 中

00:10:28.346 --> 00:10:31.136 A:middle
运行你的 App

00:10:31.136 --> 00:10:32.586 A:middle
Xcode 将会捕获这个异常

00:10:32.586 --> 00:10:33.266 A:middle
并暂停你的 App

00:10:33.636 --> 00:10:35.636 A:middle
这意味着你可以启动内存调试器

00:10:35.636 --> 00:10:36.816 A:middle
并从那里开始调查

00:10:37.066 --> 00:10:38.436 A:middle
我认为这真的十分有用

00:10:39.016 --> 00:10:42.006 A:middle
Xcode 的内存调试器

00:10:42.006 --> 00:10:43.606 A:middle
是在 Xcode 8 中提供的

00:10:43.606 --> 00:10:44.926 A:middle
它可以帮助你跟踪对象的依赖

00:10:44.926 --> 00:10:46.546 A:middle
声明周期和泄漏

00:10:46.996 --> 00:10:48.336 A:middle
在 Xcode 10 中

00:10:48.336 --> 00:10:50.036 A:middle
内存调试器更新了布局

00:10:50.536 --> 00:10:52.066 A:middle
它非常适合用来查看

00:10:52.066 --> 00:10:52.986 A:middle
非常大的内存图文件

00:10:53.926 --> 00:10:55.836 A:middle
在内部

00:10:55.836 --> 00:10:57.456 A:middle
Xcode 使用 Memgraph 文件格式

00:10:57.456 --> 00:10:58.916 A:middle
存储有关 App 的

00:10:58.916 --> 00:10:59.706 A:middle
内存使用的信息

00:11:00.106 --> 00:11:01.356 A:middle
你可能不知道

00:11:01.726 --> 00:11:03.066 A:middle
你可以搭配我们的多种命令行工具

00:11:03.066 --> 00:11:04.496 A:middle
使用 Memgraph

00:11:06.366 --> 00:11:07.566 A:middle
首先 你需要从 Xcode 中

00:11:07.566 --> 00:11:08.586 A:middle
导出 Memgraph

00:11:08.956 --> 00:11:09.856 A:middle
这很简单

00:11:10.976 --> 00:11:12.336 A:middle
你只需点按 “File（文件）”菜单中的

00:11:12.336 --> 00:11:14.006 A:middle
“Export Memory Graph...（导出内存图）”

00:11:14.006 --> 00:11:14.686 A:middle
并将其保存

00:11:15.336 --> 00:11:18.216 A:middle
然后 你就可以将 Memgraph

00:11:18.256 --> 00:11:19.506 A:middle
传递给命令行工具

00:11:19.506 --> 00:11:20.456 A:middle
而不是目标本身

00:11:20.456 --> 00:11:21.036 A:middle
这样就可以了

00:11:22.176 --> 00:11:23.796 A:middle
我在 Xcode 10 中运行我的 App

00:11:23.796 --> 00:11:25.216 A:middle
然后收到一个

00:11:25.216 --> 00:11:25.996 A:middle
内存资源异常

00:11:26.356 --> 00:11:26.986 A:middle
这可不太好

00:11:27.176 --> 00:11:29.536 A:middle
我也许应该提取 Memgraph 来进一步研究

00:11:29.536 --> 00:11:30.536 A:middle
但接下来我该怎么做呢

00:11:31.046 --> 00:11:32.526 A:middle
显然 去终端

00:11:33.176 --> 00:11:35.396 A:middle
我经常使用的第一个工具

00:11:35.536 --> 00:11:36.026 A:middle
是 vmmap

00:11:36.626 --> 00:11:37.486 A:middle
通过输出

00:11:37.486 --> 00:11:38.696 A:middle
分配给进程的虚拟内存区域

00:11:38.696 --> 00:11:40.306 A:middle
它给你的 App 提供了

00:11:40.306 --> 00:11:42.106 A:middle
内存消耗的高级分析

00:11:43.576 --> 00:11:45.856 A:middle
-summary 参数 是一个很好的起点

00:11:46.716 --> 00:11:49.866 A:middle
它可以打印出很多细节

00:11:49.866 --> 00:11:52.946 A:middle
比如该区域的内存大小

00:11:52.946 --> 00:11:55.546 A:middle
脏区域的数量

00:11:55.546 --> 00:11:56.286 A:middle
以及交换内存

00:11:56.286 --> 00:11:58.026 A:middle
也就是 iOS 中的压缩内存的数量

00:11:58.196 --> 00:12:00.956 A:middle
请记住这里的脏和交换区域大小 是非常重要的

00:11:58.196 --> 00:12:00.956 A:middle
请记住这里的脏和交换区域大小 是非常重要的

00:12:02.016 --> 00:12:03.646 A:middle
值得注意的一点是

00:12:03.646 --> 00:12:05.066 A:middle
交换区域大小指的是

00:12:05.066 --> 00:12:07.486 A:middle
数据压缩前的大小

00:12:07.486 --> 00:12:08.746 A:middle
而不是压缩后的大小

00:12:10.226 --> 00:12:11.686 A:middle
如果你真的需要深入了解

00:12:11.756 --> 00:12:13.186 A:middle
想要更多的信息

00:12:13.546 --> 00:12:14.956 A:middle
你可以在 Memgraph 上

00:12:14.956 --> 00:12:16.186 A:middle
运行 vmmap

00:12:16.186 --> 00:12:17.786 A:middle
你会得到所有区域的具体信息

00:12:17.896 --> 00:12:19.606 A:middle
我们首先向你们展示

00:12:19.606 --> 00:12:20.686 A:middle
“Non-writable regions（不可写入区域）”

00:12:20.686 --> 00:12:22.156 A:middle
比如程序的文本

00:12:22.156 --> 00:12:24.536 A:middle
或可执行代码

00:12:24.536 --> 00:12:26.156 A:middle
然后是 “Writable regions（可写入区域）”

00:12:26.156 --> 00:12:27.186 A:middle
比如数据部分

00:12:27.256 --> 00:12:28.786 A:middle
这就是你的进程堆

00:12:29.286 --> 00:12:30.436 A:middle
所在的位置

00:12:30.676 --> 00:12:31.986 A:middle
除了这些之外还有很酷的一点

00:12:31.986 --> 00:12:33.456 A:middle
就是所有这些工具

00:12:33.456 --> 00:12:34.836 A:middle
都可以很好地使用

00:12:34.836 --> 00:12:35.976 A:middle
标准命令行实用程序

00:12:36.526 --> 00:12:38.286 A:middle
例如 前几天

00:12:38.286 --> 00:12:39.356 A:middle
我在 VM Tracker 中分析我的 App

00:12:39.356 --> 00:12:41.506 A:middle
然后我看到了

00:12:41.506 --> 00:12:42.526 A:middle
脏内存增加的情况

00:12:43.106 --> 00:12:45.316 A:middle
所以我导出了 Memgraph 文件

00:12:45.316 --> 00:12:48.036 A:middle
我想知道这些脏数据

00:12:48.036 --> 00:12:49.166 A:middle
是否有一部分是由我链接的

00:12:49.166 --> 00:12:52.076 A:middle
框架或库造成的

00:12:52.276 --> 00:12:54.216 A:middle
于是我在这个 Memgraph 上

00:12:54.216 --> 00:12:55.296 A:middle
运行 vmmap

00:12:56.296 --> 00:12:58.456 A:middle
我使用了 -pages 参数

00:12:58.866 --> 00:13:00.206 A:middle
这意味着 vmmap 将输出

00:12:58.866 --> 00:13:00.206 A:middle
这意味着 vmmap 将输出

00:13:00.206 --> 00:13:01.496 A:middle
内存页的数量

00:13:01.496 --> 00:13:02.376 A:middle
而不仅仅是原始字节

00:13:02.866 --> 00:13:06.796 A:middle
然后我将它传输到 grep

00:13:06.886 --> 00:13:08.206 A:middle
并在那搜索 ‘.dylib’

00:13:08.206 --> 00:13:09.456 A:middle
所以我在这里需要动态库

00:13:11.046 --> 00:13:12.166 A:middle
最后 我将它导入到

00:13:12.166 --> 00:13:13.536 A:middle
一个特别简单的 awk 脚本中

00:13:14.116 --> 00:13:15.816 A:middle
来合计脏列

00:13:15.816 --> 00:13:16.826 A:middle
然后最终将其输出为

00:13:16.826 --> 00:13:17.886 A:middle
脏内存页的数量

00:13:19.386 --> 00:13:20.556 A:middle
我觉得这很酷

00:13:20.556 --> 00:13:22.286 A:middle
而且我一直在使用它

00:13:22.286 --> 00:13:23.676 A:middle
它让你能够

00:13:23.676 --> 00:13:25.096 A:middle
为你和你的团队编写

00:13:25.096 --> 00:13:26.216 A:middle
非常强大的调试工作流

00:13:26.656 --> 00:13:30.466 A:middle
另一个 macOS 开发人员

00:13:30.466 --> 00:13:31.686 A:middle
可能已经熟悉的

00:13:31.686 --> 00:13:33.066 A:middle
命令行实用程序是 leaks

00:13:33.836 --> 00:13:35.306 A:middle
它在运行时跟踪堆中

00:13:35.696 --> 00:13:37.396 A:middle
没有根的对象

00:13:37.726 --> 00:13:38.586 A:middle
所以请记住

00:13:38.586 --> 00:13:39.816 A:middle
如果你在 leaks 中看到一个对象

00:13:39.816 --> 00:13:41.466 A:middle
那它占用的是你无法释放的脏内存

00:13:41.846 --> 00:13:44.866 A:middle
让我们看看 内存调试器中的内存泄漏

00:13:46.176 --> 00:13:48.176 A:middle
这里我有 3 个对象

00:13:48.176 --> 00:13:49.356 A:middle
它们相互之间都有很强的引用

00:13:49.356 --> 00:13:51.166 A:middle
创建了一个经典的 “Retain Cycle（留置环）”

00:13:51.876 --> 00:13:53.766 A:middle
让我们在 leaks 工具中

00:13:54.216 --> 00:13:56.446 A:middle
看看这个泄漏

00:13:56.646 --> 00:13:57.686 A:middle
今年 leaks 已被更新

00:13:57.686 --> 00:13:59.676 A:middle
不仅可以显示

00:13:59.676 --> 00:14:05.396 A:middle
泄漏的对象 还可显示它们所属的 Retain Cycle

00:13:59.676 --> 00:14:05.396 A:middle
泄漏的对象 还可显示它们所属的 Retain Cycle

00:14:05.396 --> 00:14:07.126 A:middle
如果进程中启用了

00:14:07.126 --> 00:14:08.856 A:middle
malloc 堆栈日志记录

00:14:08.856 --> 00:14:10.666 A:middle
我们甚至为你提供了

00:14:11.786 --> 00:14:14.146 A:middle
根节点 回溯

00:14:14.416 --> 00:14:15.796 A:middle
我经常问自己的一个问题是

00:14:15.906 --> 00:14:17.276 A:middle
内存都去哪了

00:14:18.096 --> 00:14:19.606 A:middle
我查看了 vmmap

00:14:19.606 --> 00:14:20.716 A:middle
发现堆很大

00:14:20.966 --> 00:14:22.006 A:middle
但是接下来要做什么呢

00:14:22.626 --> 00:14:24.426 A:middle
heap 工具提供了

00:14:24.426 --> 00:14:25.366 A:middle
关于进程堆中

00:14:25.366 --> 00:14:26.836 A:middle
对象分配的各种信息

00:14:27.046 --> 00:14:28.616 A:middle
它可以帮助你追踪

00:14:28.616 --> 00:14:30.216 A:middle
非常复杂的分配

00:14:30.216 --> 00:14:32.086 A:middle
或者很多同类的对象

00:14:34.036 --> 00:14:36.236 A:middle
我这里有一个 Memgraph 文件

00:14:36.236 --> 00:14:37.516 A:middle
它是我在 Xcode 捕获到

00:14:37.516 --> 00:14:39.336 A:middle
内存资源异常时得到的

00:14:39.336 --> 00:14:40.366 A:middle
我想研究它的堆

00:14:40.906 --> 00:14:43.416 A:middle
所以我把它传递给了 heap

00:14:43.926 --> 00:14:45.186 A:middle
它告诉我

00:14:45.186 --> 00:14:49.696 A:middle
每个对象的类名

00:14:49.696 --> 00:14:50.546 A:middle
它们的数量

00:14:50.546 --> 00:14:52.366 A:middle
它们的平均大小

00:14:52.366 --> 00:14:54.976 A:middle
以及这类对象的总大小

00:14:54.976 --> 00:14:56.446 A:middle
在这里

00:14:56.656 --> 00:14:58.156 A:middle
我看到了很多很多小对象

00:14:58.156 --> 00:14:58.976 A:middle
但我不认为

00:14:58.976 --> 00:14:59.676 A:middle
这是什么问题

00:14:59.946 --> 00:15:01.066 A:middle
我不认为

00:14:59.946 --> 00:15:01.066 A:middle
我不认为

00:15:01.066 --> 00:15:01.786 A:middle
这是主要的问题

00:15:05.336 --> 00:15:07.456 A:middle
默认情况下 堆将按数量排序

00:15:08.376 --> 00:15:09.786 A:middle
但是我希望看到的

00:15:09.936 --> 00:15:11.176 A:middle
是最大的对象

00:15:11.176 --> 00:15:12.586 A:middle
而不是数量最多的对象

00:15:12.586 --> 00:15:14.086 A:middle
因此将 -sortBySize 参数传递给堆

00:15:14.086 --> 00:15:15.176 A:middle
能让它们按大小排序

00:15:16.616 --> 00:15:17.606 A:middle
这里我看到了一些

00:15:17.606 --> 00:15:19.576 A:middle
硕大的 NSConcreteData 对象

00:15:19.926 --> 00:15:21.246 A:middle
我应该将这个输出

00:15:21.246 --> 00:15:22.586 A:middle
和 Memgraph

00:15:22.586 --> 00:15:24.726 A:middle
附加到 Bug 报告中

00:15:24.726 --> 00:15:25.216 A:middle
但这还不够

00:15:25.216 --> 00:15:25.966 A:middle
我得弄清楚

00:15:25.966 --> 00:15:26.446 A:middle
这些对象是怎么来的

00:15:27.806 --> 00:15:29.186 A:middle
首先 我需要获得

00:15:29.186 --> 00:15:30.896 A:middle
其中一个 NSConcreteData 对象的地址

00:15:31.606 --> 00:15:33.006 A:middle
然后是 heap 工具中的 -addresses 参数

00:15:33.396 --> 00:15:34.436 A:middle
当你将 -addresses 参数

00:15:34.436 --> 00:15:35.456 A:middle
与一个类名一起传给 heap 工具时

00:15:35.456 --> 00:15:36.656 A:middle
它将为你提供堆上的

00:15:36.656 --> 00:15:38.306 A:middle
每个实例的地址

00:15:39.516 --> 00:15:41.186 A:middle
现在我有了这些地址

00:15:41.186 --> 00:15:42.656 A:middle
我可以知道它们每一个都来自哪里

00:15:43.926 --> 00:15:44.866 A:middle
这就是 malloc 堆栈日志记录

00:15:44.866 --> 00:15:45.756 A:middle
派上用场的地方

00:15:46.526 --> 00:15:47.976 A:middle
当启用时

00:15:47.976 --> 00:15:49.826 A:middle
系统将记录每个分配的回溯

00:15:50.316 --> 00:15:52.196 A:middle
当我们记录一个 Memgraph 时

00:15:52.196 --> 00:15:53.576 A:middle
这些日志就会被捕获

00:15:53.576 --> 00:15:54.616 A:middle
它们将用于为我们的一些工具

00:15:54.616 --> 00:15:56.366 A:middle
注释现有的输出 你可以在

00:15:57.136 --> 00:15:58.306 A:middle
“Scheme Editor（Scheme 编辑器）”中的

00:15:58.306 --> 00:16:00.576 A:middle
“Diagnostics（诊断）”标签页中 轻松启用它

00:15:58.306 --> 00:16:00.576 A:middle
“Diagnostics（诊断）”标签页中 轻松启用它

00:16:01.426 --> 00:16:02.576 A:middle
我建议你们

00:16:02.576 --> 00:16:03.696 A:middle
在 Memgraph 中

00:16:03.696 --> 00:16:06.726 A:middle
使用实时分配选项

00:16:06.726 --> 00:16:08.986 A:middle
我的 Memgraph 文件

00:16:08.986 --> 00:16:10.196 A:middle
在 malloc 堆栈日志记录中被捕获

00:16:10.866 --> 00:16:12.926 A:middle
现在我们要找到分配的回溯

00:16:13.226 --> 00:16:14.776 A:middle
这就是 malloc_history 发挥作用的地方

00:16:15.566 --> 00:16:16.946 A:middle
你只需传递 malloc_history

00:16:17.136 --> 00:16:18.576 A:middle
Memgraph

00:16:18.576 --> 00:16:19.886 A:middle
以及内存中实例的地址

00:16:19.886 --> 00:16:20.876 A:middle
那么 如果捕获到它的回溯

00:16:20.876 --> 00:16:24.016 A:middle
malloc_history 就会将其提供给你

00:16:24.136 --> 00:16:25.276 A:middle
这里我取了其中

00:16:25.276 --> 00:16:27.276 A:middle
一个很大的 NSConcreteData 的地址

00:16:27.496 --> 00:16:28.376 A:middle
我把它传递给了 malloc_history

00:16:28.376 --> 00:16:31.026 A:middle
然后我就得到了一个回溯记录

00:16:31.486 --> 00:16:32.646 A:middle
有趣的是

00:16:32.646 --> 00:16:34.166 A:middle
看起来我的 NoirFilter.apply() 方法

00:16:34.166 --> 00:16:36.376 A:middle
创建了一个巨大的 NSConcreteData

00:16:37.126 --> 00:16:38.526 A:middle
我应该将这个和 Memgraph

00:16:38.526 --> 00:16:40.186 A:middle
附加到一个 Bug 报告中

00:16:40.186 --> 00:16:43.206 A:middle
其他人就可以查看它

00:16:43.476 --> 00:16:44.696 A:middle
这些只是几种

00:16:44.696 --> 00:16:46.756 A:middle
可以深入研究

00:16:46.756 --> 00:16:48.216 A:middle
App 行为的方法

00:16:48.626 --> 00:16:49.526 A:middle
当遇到内存问题时

00:16:49.526 --> 00:16:51.086 A:middle
你会选择哪个工具

00:16:52.096 --> 00:16:53.676 A:middle
有 3 种思考方式

00:16:53.956 --> 00:16:55.656 A:middle
你想看到对象的创建吗

00:16:55.656 --> 00:16:56.956 A:middle
你想要查看内存中

00:16:56.956 --> 00:16:58.696 A:middle
引用对象或地址的内容吗

00:16:59.056 --> 00:17:00.926 A:middle
或者你只是想看看 一个实例有多大

00:16:59.056 --> 00:17:00.926 A:middle
或者你只是想看看 一个实例有多大

00:17:02.376 --> 00:17:03.366 A:middle
如果你在进程启动时

00:17:03.366 --> 00:17:05.046 A:middle
启用了 malloc 堆栈日志记录

00:17:05.046 --> 00:17:06.185 A:middle
那么 malloc_history

00:17:06.185 --> 00:17:09.455 A:middle
可以帮助你查找 该对象的回溯

00:17:10.896 --> 00:17:11.646 A:middle
如果你只是想看看

00:17:11.646 --> 00:17:12.896 A:middle
在内存中引用对象的内容

00:17:13.486 --> 00:17:15.576 A:middle
你可以使用 leaks

00:17:15.576 --> 00:17:16.766 A:middle
和在内存页面中

00:17:16.766 --> 00:17:17.915 A:middle
提供的其他工具来帮助你

00:17:17.915 --> 00:17:20.366 A:middle
最后 如果你只是想了解

00:17:20.366 --> 00:17:23.296 A:middle
一个区域或一个实例有多大 vmmap

00:17:23.296 --> 00:17:24.056 A:middle
和 heap 是首选工具

00:17:24.626 --> 00:17:27.376 A:middle
作为起始点 我建议在进程的 Memgraph 上

00:17:27.376 --> 00:17:30.436 A:middle
运行带有 -summary 命令的 vmmap

00:17:30.626 --> 00:17:34.096 A:middle
然后顺着线程继续进行

00:17:34.096 --> 00:17:36.286 A:middle
现在 我想请回 Kyle 他将会讨论

00:17:36.436 --> 00:17:37.736 A:middle
iOS App 中最大的对象

00:17:37.736 --> 00:17:39.936 A:middle
那就是图像

00:17:40.646 --> 00:17:40.856 A:middle
有请 Kyle

00:17:42.516 --> 00:17:45.856 A:middle
[ 掌声 ]

00:17:46.356 --> 00:17:46.916 A:middle
&gt;&gt; 谢谢 James

00:17:47.916 --> 00:17:49.486 A:middle
说到图像

00:17:50.306 --> 00:17:51.586 A:middle
关于图像需要记住的

00:17:51.586 --> 00:17:54.296 A:middle
最重要的就是

00:17:54.296 --> 00:17:55.506 A:middle
内存使用与图像的尺寸有关

00:17:55.506 --> 00:17:58.536 A:middle
而不与它的文件大小有关

00:17:59.696 --> 00:18:01.846 A:middle
举个例子

00:17:59.696 --> 00:18:01.846 A:middle
举个例子

00:18:01.996 --> 00:18:03.786 A:middle
我有一张非常漂亮的图片

00:18:03.786 --> 00:18:04.986 A:middle
并且我想把它作为

00:18:04.986 --> 00:18:05.496 A:middle
一个 iPad App 的壁纸

00:18:06.646 --> 00:18:10.786 A:middle
它的尺寸是 2048*1536

00:18:10.786 --> 00:18:13.436 A:middle
磁盘上文件的大小是 590KB

00:18:13.966 --> 00:18:16.086 A:middle
但是它实际使用了多少内存呢

00:18:18.516 --> 00:18:19.646 A:middle
10MB

00:18:20.056 --> 00:18:21.746 A:middle
10MB 这可够大的

00:18:22.146 --> 00:18:23.746 A:middle
这是因为

00:18:23.746 --> 00:18:25.066 A:middle
把像素的宽度乘以高

00:18:25.066 --> 00:18:28.406 A:middle
即 2048 乘以 1536

00:18:28.406 --> 00:18:30.016 A:middle
然后每像素乘以 4 字节

00:18:30.016 --> 00:18:30.786 A:middle
就会达到 10MB

00:18:31.706 --> 00:18:33.956 A:middle
那么为什么它会大这么多呢

00:18:35.016 --> 00:18:36.916 A:middle
我们要谈谈图像

00:18:36.916 --> 00:18:38.076 A:middle
是如何在 iOS 上工作的

00:18:38.196 --> 00:18:39.676 A:middle
有加载 解码

00:18:39.706 --> 00:18:40.346 A:middle
和渲染三个阶段

00:18:41.306 --> 00:18:43.516 A:middle
在加载阶段

00:18:43.516 --> 00:18:45.646 A:middle
这个被压缩的 590KB 的 JPEG 文件被接收

00:18:45.646 --> 00:18:48.646 A:middle
并被加载到内存中

00:18:49.856 --> 00:18:51.996 A:middle
在解码阶段 JPEG 文件

00:18:51.996 --> 00:18:55.366 A:middle
将被转换为 GPU 可以读取的格式

00:18:55.936 --> 00:18:56.966 A:middle
图像需要被解压

00:18:56.966 --> 00:18:58.996 A:middle
这使得文件大小增至 10 mb

00:18:59.926 --> 00:19:01.446 A:middle
被解码之后

00:18:59.926 --> 00:19:01.446 A:middle
被解码之后

00:19:01.446 --> 00:19:02.556 A:middle
图像就可以被随意渲染了

00:19:03.136 --> 00:19:05.206 A:middle
要了解更多关于图像的信息

00:19:05.526 --> 00:19:06.936 A:middle
以及如何对它们进行优化

00:19:06.936 --> 00:19:08.346 A:middle
我建议你们查看

00:19:08.346 --> 00:19:10.296 A:middle
本周早些时候举行的

00:19:10.416 --> 00:19:11.646 A:middle
“Images and Graphics

00:19:11.646 --> 00:19:13.946 A:middle
Best Practices” 的讨论会

00:19:14.216 --> 00:19:16.076 A:middle
在 SRGB 格式中

00:19:16.176 --> 00:19:17.286 A:middle
每个像素有 4 个字节

00:19:18.236 --> 00:19:19.186 A:middle
这通常是图形中

00:19:19.186 --> 00:19:21.856 A:middle
图像最常见的格式

00:19:22.356 --> 00:19:26.196 A:middle
它是每个像素 8 位

00:19:26.816 --> 00:19:28.776 A:middle
所以红色 1 字节 绿色 1 字节

00:19:28.776 --> 00:19:30.816 A:middle
蓝色 1 字节

00:19:30.816 --> 00:19:31.596 A:middle
Alpha 通道 1 字节

00:19:33.126 --> 00:19:36.036 A:middle
但是 我们还可以将其继续变大

00:19:36.036 --> 00:19:39.176 A:middle
iOS 硬件可以渲染宽格式

00:19:39.356 --> 00:19:40.736 A:middle
宽格式中

00:19:40.736 --> 00:19:42.476 A:middle
为了得到有表现力的颜色

00:19:42.476 --> 00:19:44.356 A:middle
每个像素需要 2 个字节

00:19:44.356 --> 00:19:45.456 A:middle
所以我们将图像的大小加倍

00:19:46.356 --> 00:19:49.176 A:middle
iPhone 7 iPhone 8 iPhone X

00:19:49.356 --> 00:19:51.006 A:middle
以及一些 iPad Pro 上的摄像头

00:19:51.436 --> 00:19:53.036 A:middle
非常适合捕捉这种

00:19:53.266 --> 00:19:55.006 A:middle
高保真的内容

00:19:55.576 --> 00:19:56.966 A:middle
你也可以用它来制作

00:19:56.966 --> 00:19:57.976 A:middle
非常精确的颜色

00:19:57.976 --> 00:19:58.946 A:middle
比如运动商标等等

00:20:00.066 --> 00:20:01.706 A:middle
但是这些只在

00:20:01.706 --> 00:20:02.856 A:middle
宽格式显示器中有用

00:20:02.856 --> 00:20:03.766 A:middle
所以我们不希望

00:20:03.766 --> 00:20:04.616 A:middle
在不需要的时候使用它

00:20:05.756 --> 00:20:07.766 A:middle
另一方面 我们也可以使图像变小

00:20:08.356 --> 00:20:10.066 A:middle
比如 AL8 格式

00:20:10.606 --> 00:20:13.176 A:middle
这种格式只存储灰度值

00:20:13.176 --> 00:20:14.236 A:middle
和 Alpha 值

00:20:14.886 --> 00:20:16.486 A:middle
它通常用于着色器

00:20:16.486 --> 00:20:18.626 A:middle
比如 Metal App 等等

00:20:19.306 --> 00:20:21.246 A:middle
这个格式并不常用 实际上

00:20:21.446 --> 00:20:22.776 A:middle
我们还可以让它继续变小

00:20:23.736 --> 00:20:24.936 A:middle
我们可以使用所谓的

00:20:24.936 --> 00:20:26.086 A:middle
Alpha 8 格式

00:20:26.516 --> 00:20:28.096 A:middle
Alpha 8 只有 1 个通道

00:20:28.156 --> 00:20:30.196 A:middle
每个像素 1 个字节 非常小

00:20:30.196 --> 00:20:32.056 A:middle
它比 SRGB 小 75%

00:20:33.026 --> 00:20:34.546 A:middle
这很适合蒙版

00:20:34.546 --> 00:20:36.246 A:middle
或单色文本

00:20:36.246 --> 00:20:37.966 A:middle
因为我们节省了 75% 的内存

00:20:39.096 --> 00:20:41.396 A:middle
如果我们分开来看

00:20:42.296 --> 00:20:43.966 A:middle
我们可以从 Alpha 8 格式的

00:20:44.006 --> 00:20:45.786 A:middle
每个像素 1 个字节开始

00:20:45.786 --> 00:20:47.096 A:middle
一直增加到宽格式的每个像素 8 个字节

00:20:47.466 --> 00:20:48.606 A:middle
这个范围很大

00:20:48.916 --> 00:20:50.806 A:middle
所以我们真正需要做的是

00:20:50.806 --> 00:20:52.046 A:middle
知道如何选择正确的格式

00:20:52.926 --> 00:20:54.906 A:middle
那么我们如何选择正确的格式呢

00:20:55.656 --> 00:20:58.126 A:middle
简短的回答是不要选择格式

00:20:58.456 --> 00:20:59.646 A:middle
让格式来选择你

00:21:01.106 --> 00:21:03.006 A:middle
如果你不再使用

00:21:03.006 --> 00:21:04.876 A:middle
自 iOS 诞生起就存在于 iOS 的

00:21:04.876 --> 00:21:07.416 A:middle
UIGraphicsBeginImageContext

00:21:07.416 --> 00:21:09.276 A:middle
WithOptions API

00:21:09.276 --> 00:21:12.576 A:middle
而是切换到 UIGraphicsImageRenderer 格式

00:21:12.576 --> 00:21:14.206 A:middle
你可以节省很多内存

00:21:15.036 --> 00:21:17.456 A:middle
因为 UIGraphicsBeginImage

00:21:17.456 --> 00:21:19.006 A:middle
ContextWithOptions 总是一个

00:21:19.356 --> 00:21:20.916 A:middle
每像素 4 字节的格式

00:21:21.886 --> 00:21:22.866 A:middle
它总是 SRGB 格式

00:21:23.186 --> 00:21:25.446 A:middle
所以只要你不想 你就不会得到宽格式

00:21:25.446 --> 00:21:27.216 A:middle
也不会得到

00:21:27.216 --> 00:21:28.596 A:middle
每像素 1 字节的 A8 格式

00:21:28.716 --> 00:21:30.966 A:middle
如果你使用在 iOS 10 中引入的

00:21:31.566 --> 00:21:33.576 A:middle
UIGraphicsImageRenderer API

00:21:33.626 --> 00:21:35.156 A:middle
在 iOS 12 中

00:21:35.156 --> 00:21:36.396 A:middle
它会自动为你选择最好的图形格式

00:21:36.866 --> 00:21:39.176 A:middle
这有一个例子

00:21:39.716 --> 00:21:41.146 A:middle
假设我画了一个圆作为一个蒙版

00:21:41.956 --> 00:21:43.666 A:middle
使用旧 API

00:21:43.666 --> 00:21:45.626 A:middle
高亮的部分是

00:21:45.626 --> 00:21:46.866 A:middle
我的绘制代码

00:21:46.866 --> 00:21:48.326 A:middle
只是为了绘制一个黑色圆圈

00:21:48.326 --> 00:21:49.586 A:middle
我得到的却是每个像素 4 字节的格式

00:21:51.026 --> 00:21:52.366 A:middle
如果我转而使用新的 API

00:21:52.366 --> 00:21:54.826 A:middle
我使用的是完全相同的绘制代码

00:21:55.676 --> 00:21:57.406 A:middle
通过使用新的 API

00:21:57.406 --> 00:21:59.096 A:middle
我现在得到的是每个像素 1 字节的图像

00:21:59.176 --> 00:22:01.396 A:middle
这意味着它减少了

00:21:59.176 --> 00:22:01.396 A:middle
这意味着它减少了

00:22:01.706 --> 00:22:02.346 A:middle
75% 的内存使用

00:22:02.786 --> 00:22:04.316 A:middle
在保证相同保真度的同时

00:22:04.316 --> 00:22:05.086 A:middle
也获得了可观的内存节省

00:22:05.676 --> 00:22:11.916 A:middle
另外一个好处是 如果我想再次使用这个蒙版

00:22:11.916 --> 00:22:13.476 A:middle
我可以在一个 imageView 上

00:22:13.476 --> 00:22:16.006 A:middle
改变 tintColor

00:22:16.006 --> 00:22:17.366 A:middle
而且只用一个点号就可以做到

00:22:17.366 --> 00:22:20.906 A:middle
这意味着我不必再分配内存了

00:22:21.216 --> 00:22:23.006 A:middle
我不仅可以把它

00:22:23.006 --> 00:22:24.196 A:middle
设成一个黑色的圆圈

00:22:24.196 --> 00:22:25.646 A:middle
还可以设成蓝色的 红色的 绿色的圆圈

00:22:25.646 --> 00:22:26.896 A:middle
且没有额外的内存占用

00:22:27.216 --> 00:22:27.826 A:middle
这很酷

00:22:32.236 --> 00:22:34.136 A:middle
我们通常对图像做的另一件事是

00:22:34.136 --> 00:22:34.876 A:middle
对它们进行下采样

00:22:35.516 --> 00:22:36.936 A:middle
当我们想要制作

00:22:36.936 --> 00:22:38.286 A:middle
比如缩略图的时候

00:22:38.286 --> 00:22:38.866 A:middle
我们想要缩小它

00:22:39.196 --> 00:22:41.426 A:middle
我们不应该

00:22:41.426 --> 00:22:42.836 A:middle
用 UIImage 进行缩小

00:22:42.956 --> 00:22:44.336 A:middle
如果我们使用 UIImage 绘图

00:22:44.336 --> 00:22:46.126 A:middle
由于内部坐标空间变换

00:22:46.126 --> 00:22:48.856 A:middle
这种方法性能并不高

00:22:49.316 --> 00:22:50.946 A:middle
就像我们之前看到的

00:22:50.946 --> 00:22:52.656 A:middle
它会解压缩内存中的整个图像

00:22:53.616 --> 00:22:55.886 A:middle
取而代之 我们可以使用 ImageIO 框架

00:22:56.536 --> 00:22:58.196 A:middle
ImageIO 可以对图像进行下采样

00:22:58.196 --> 00:23:00.036 A:middle
它使用 Streaming API

00:22:58.196 --> 00:23:00.036 A:middle
它使用 Streaming API

00:23:00.036 --> 00:23:03.136 A:middle
这样你只需为生成图像

00:23:03.136 --> 00:23:03.996 A:middle
使用一些脏内存

00:23:04.196 --> 00:23:05.566 A:middle
这将为你节省一个内存峰值

00:23:06.076 --> 00:23:09.126 A:middle
例如 这里有一些代码

00:23:09.196 --> 00:23:10.346 A:middle
以及我在磁盘上获得的一个文件

00:23:10.506 --> 00:23:11.996 A:middle
也可以是我下载的一个文件

00:23:12.916 --> 00:23:16.456 A:middle
我现在用 UIImage 绘制一个

00:23:16.546 --> 00:23:17.696 A:middle
更小的矩形

00:23:18.106 --> 00:23:19.796 A:middle
仍然会有一个大峰值

00:23:21.036 --> 00:23:22.626 A:middle
如果切换到 ImageIO

00:23:22.626 --> 00:23:25.236 A:middle
我仍然需要从磁盘加载文件

00:23:25.896 --> 00:23:27.846 A:middle
因为它是一个较低级的 API

00:23:27.846 --> 00:23:29.476 A:middle
我设置了一些参数

00:23:29.476 --> 00:23:30.936 A:middle
来表示我希望这个图像有多大

00:23:31.186 --> 00:23:33.126 A:middle
所以我让它用

00:23:33.126 --> 00:23:34.206 A:middle
CGImageSourceCreateThumbnailAtIndex

00:23:34.246 --> 00:23:35.346 A:middle
创建图像

00:23:35.916 --> 00:23:37.506 A:middle
现在 我可以用 UIImage 封装这个 CGImage

00:23:37.506 --> 00:23:38.956 A:middle
并准备好进行下一步了

00:23:39.096 --> 00:23:40.246 A:middle
我有一个小得多的图像

00:23:40.526 --> 00:23:43.486 A:middle
而且比之前的代码快 50%

00:23:45.146 --> 00:23:47.086 A:middle
我们要讨论的

00:23:47.086 --> 00:23:48.406 A:middle
另一件事是

00:23:48.406 --> 00:23:49.096 A:middle
如何进行后台优化

00:23:49.946 --> 00:23:53.316 A:middle
假设我在一个 App 中

00:23:53.616 --> 00:23:54.886 A:middle
有一个全屏的图像 它很美

00:23:54.886 --> 00:23:55.446 A:middle
我很喜欢

00:23:55.906 --> 00:23:57.376 A:middle
但之后 我需要

00:23:57.376 --> 00:23:58.706 A:middle
到我的主屏幕上处理通知

00:23:58.706 --> 00:24:00.376 A:middle
或者转到

00:23:58.706 --> 00:24:00.376 A:middle
或者转到

00:24:00.376 --> 00:24:01.316 A:middle
另一个 App 上

00:24:01.986 --> 00:24:03.586 A:middle
那张图像还在内存中

00:24:04.626 --> 00:24:06.806 A:middle
经验之谈

00:24:06.806 --> 00:24:08.486 A:middle
我们建议你卸载

00:24:08.486 --> 00:24:09.826 A:middle
看不到的大型资源

00:24:10.276 --> 00:24:13.756 A:middle
有两种方法可供选择

00:24:13.986 --> 00:24:15.246 A:middle
第一种是 App 生命周期

00:24:15.296 --> 00:24:16.466 A:middle
如果你把你的 App

00:24:16.466 --> 00:24:17.656 A:middle
放在后台或者前台

00:24:17.656 --> 00:24:19.976 A:middle
App 生命周期事件

00:24:19.976 --> 00:24:20.736 A:middle
可以帮助你了解它

00:24:21.686 --> 00:24:22.926 A:middle
这主要适用于

00:24:22.926 --> 00:24:24.486 A:middle
屏幕上的视图

00:24:24.536 --> 00:24:25.316 A:middle
因为它们不遵循

00:24:25.316 --> 00:24:27.106 A:middle
UIViewController 外观的生命周期

00:24:27.756 --> 00:24:28.886 A:middle
UIViewController 方法

00:24:28.886 --> 00:24:30.576 A:middle
适用于标签控制器

00:24:31.476 --> 00:24:32.526 A:middle
或导航控制器

00:24:32.526 --> 00:24:34.446 A:middle
因为你会有多个视图控制器

00:24:34.446 --> 00:24:36.066 A:middle
但只有一个出现在屏幕上

00:24:36.716 --> 00:24:37.486 A:middle
如果你利用

00:24:37.486 --> 00:24:38.296 A:middle
viewWillAppear 和

00:24:38.296 --> 00:24:39.946 A:middle
viewDidDisappear 的代码或回调

00:24:40.176 --> 00:24:41.516 A:middle
就可以使

00:24:41.726 --> 00:24:42.766 A:middle
内存占用更小

00:24:44.036 --> 00:24:46.476 A:middle
举一个例子

00:24:46.476 --> 00:24:48.246 A:middle
如果我为进入后台的

00:24:48.246 --> 00:24:49.466 A:middle
App 注册通知

00:24:49.566 --> 00:24:50.916 A:middle
我可以卸载我的大型资源

00:24:50.916 --> 00:24:52.726 A:middle
在这里就是图像

00:24:53.826 --> 00:24:54.696 A:middle
当 App 回到前台时

00:24:54.696 --> 00:24:56.786 A:middle
我就会收到通知

00:24:57.556 --> 00:24:59.686 A:middle
如果我在这里重新加载图像

00:24:59.856 --> 00:25:00.746 A:middle
当用户返回时

00:24:59.856 --> 00:25:00.746 A:middle
当用户返回时

00:25:00.746 --> 00:25:02.406 A:middle
我就可以在后台保存内存

00:25:02.406 --> 00:25:04.206 A:middle
并保持同样的保真度

00:25:04.396 --> 00:25:05.436 A:middle
这对他们来说是完全一样的

00:25:05.436 --> 00:25:07.226 A:middle
但是系统有

00:25:07.226 --> 00:25:10.476 A:middle
更多的内存可用

00:25:10.476 --> 00:25:12.306 A:middle
与此类似 如果我在导航控制器

00:25:12.306 --> 00:25:14.056 A:middle
或标签控制器中

00:25:14.536 --> 00:25:15.776 A:middle
我的视图控制器可以

00:25:15.776 --> 00:25:17.146 A:middle
在图像消失时卸载它们

00:25:17.746 --> 00:25:18.976 A:middle
在返回 viewWillAppear() 方法之前

00:25:18.976 --> 00:25:21.916 A:middle
我可以重新加载它们

00:25:22.116 --> 00:25:23.076 A:middle
用户还是不会注意到

00:25:23.076 --> 00:25:24.066 A:middle
有什么不同

00:25:24.216 --> 00:25:25.506 A:middle
我们的 App 如今使用更少的内存

00:25:25.506 --> 00:25:26.696 A:middle
这很好

00:25:27.286 --> 00:25:31.176 A:middle
现在 我想邀请 Kris

00:25:31.216 --> 00:25:32.746 A:middle
用一个很好的演示

00:25:32.746 --> 00:25:33.566 A:middle
向你们展示之前的内容

00:25:34.376 --> 00:25:34.646 A:middle
Kris

00:25:35.516 --> 00:25:39.586 A:middle
[ 掌声 ]

00:25:40.086 --> 00:25:41.436 A:middle
&gt;&gt; 好的 我现在要

00:25:41.436 --> 00:25:42.376 A:middle
切换到演示机器

00:25:43.316 --> 00:25:43.756 A:middle
我们开始吧

00:25:44.116 --> 00:25:45.526 A:middle
我一直在开发这个 App

00:25:45.606 --> 00:25:47.596 A:middle
这些是我从

00:25:47.636 --> 00:25:50.386 A:middle
NASA 那里得到的

00:25:50.796 --> 00:25:52.426 A:middle
太阳系的高分辨率图像

00:25:52.426 --> 00:25:54.056 A:middle
这个 App 可以让你

00:25:54.056 --> 00:25:55.866 A:middle
对它们应用不同的滤镜

00:25:56.406 --> 00:25:57.416 A:middle
接下来我们会看到一个

00:25:57.416 --> 00:26:00.386 A:middle
简单的例子 在太阳上应用一个滤镜

00:25:57.416 --> 00:26:00.386 A:middle
简单的例子 在太阳上应用一个滤镜

00:26:00.996 --> 00:26:02.496 A:middle
我对目前的进展非常满意

00:26:02.496 --> 00:26:04.396 A:middle
所以我把它发给 James

00:26:04.396 --> 00:26:05.926 A:middle
征求他的意见

00:26:05.926 --> 00:26:07.956 A:middle
他给我回了一封

00:26:08.056 --> 00:26:09.146 A:middle
带有两个附件的邮件

00:26:09.826 --> 00:26:12.196 A:middle
一个附件是 Memgraph 文件

00:26:12.196 --> 00:26:13.626 A:middle
另一个是这个图像

00:26:15.776 --> 00:26:19.916 A:middle
James 是一个相当保守和低调的人

00:26:19.916 --> 00:26:21.676 A:middle
所以当他发送了两个红色的惊叹号

00:26:21.676 --> 00:26:23.746 A:middle
和一个尖叫的表情符号时

00:26:23.746 --> 00:26:24.706 A:middle
我知道他很难过

00:26:25.546 --> 00:26:27.156 A:middle
所以我去找 James

00:26:27.516 --> 00:26:28.496 A:middle
我说 “你知道

00:26:28.496 --> 00:26:29.386 A:middle
我不明白这有什么大不了的

00:26:29.736 --> 00:26:31.626 A:middle
很明显我需要

00:26:31.626 --> 00:26:33.026 A:middle
再使用至少 0.5 GB

00:26:33.086 --> 00:26:34.266 A:middle
才能出现内存不足的情况

00:26:34.266 --> 00:26:35.776 A:middle
然而我还有一些可用的内存

00:26:35.866 --> 00:26:36.796 A:middle
我难道不能用它吗”

00:26:37.826 --> 00:26:39.646 A:middle
James 一个比我

00:26:39.646 --> 00:26:41.016 A:middle
优秀得多的开发者

00:26:41.016 --> 00:26:42.736 A:middle
他指出了一些

00:26:42.736 --> 00:26:43.926 A:middle
我的逻辑有问题的地方

00:26:44.156 --> 00:26:46.976 A:middle
首先 这个测量计

00:26:47.026 --> 00:26:49.926 A:middle
测量的是一个有 2GB 内存的设备

00:26:50.566 --> 00:26:51.866 A:middle
并不是所有的设备

00:26:51.866 --> 00:26:52.406 A:middle
都有那么多的内存

00:26:52.876 --> 00:26:54.106 A:middle
如果这段代码运行在

00:26:54.106 --> 00:26:55.696 A:middle
只有 1GB 内存的设备上

00:26:55.696 --> 00:26:57.306 A:middle
那么很有可能

00:26:57.306 --> 00:27:00.056 A:middle
我们的 App 已经被操作系统终止了

00:26:57.306 --> 00:27:00.056 A:middle
我们的 App 已经被操作系统终止了

00:27:00.866 --> 00:27:04.076 A:middle
其次 操作系统

00:27:04.076 --> 00:27:06.796 A:middle
在决定何时

00:27:06.926 --> 00:27:08.396 A:middle
终止 App 时

00:27:08.396 --> 00:27:09.606 A:middle
不仅依照你的 App

00:27:09.606 --> 00:27:11.176 A:middle
使用的内存大小

00:27:11.176 --> 00:27:13.206 A:middle
还依照操作系统中的其他内容

00:27:13.696 --> 00:27:15.446 A:middle
所以仅仅因为

00:27:15.446 --> 00:27:16.956 A:middle
我们还没有耗尽内存

00:27:16.956 --> 00:27:19.176 A:middle
并不意味着我们没有被终止的危险

00:27:20.076 --> 00:27:22.196 A:middle
最后 这对用户来说

00:27:22.376 --> 00:27:24.076 A:middle
是一种糟糕的体验

00:27:24.636 --> 00:27:25.706 A:middle
事实上 如果你查看

00:27:25.706 --> 00:27:27.736 A:middle
使用比较图表

00:27:27.736 --> 00:27:29.776 A:middle
你可以看到其他进程的

00:27:29.776 --> 00:27:30.856 A:middle
内存为 0KB

00:27:31.496 --> 00:27:32.726 A:middle
那是因为它们都被

00:27:32.726 --> 00:27:33.866 A:middle
操作系统抛弃了

00:27:33.866 --> 00:27:36.906 A:middle
只是为我们的 App 腾出空间

00:27:36.906 --> 00:27:38.266 A:middle
你们可能都在静静地看着我

00:27:38.266 --> 00:27:39.856 A:middle
然后摆出一个嫌弃的表情

00:27:40.376 --> 00:27:41.686 A:middle
因为当用户想去

00:27:41.686 --> 00:27:43.156 A:middle
看你们的 App 时

00:27:43.156 --> 00:27:44.076 A:middle
它必须从头开始加载

00:27:45.246 --> 00:27:47.046 A:middle
James 说得很有道理

00:27:47.046 --> 00:27:48.316 A:middle
我认为 总的来说

00:27:48.316 --> 00:27:49.566 A:middle
我们应该让这个内存指针

00:27:49.566 --> 00:27:51.856 A:middle
尽可能向左

00:27:51.856 --> 00:27:53.216 A:middle
而不是向右

00:27:54.076 --> 00:27:55.766 A:middle
看看我们能做什么

00:27:56.256 --> 00:27:57.496 A:middle
让我先来看看

00:27:57.496 --> 00:27:58.706 A:middle
Memgraph 文件

00:27:59.266 --> 00:28:03.496 A:middle
我有一些

00:27:59.266 --> 00:28:03.496 A:middle
我有一些

00:28:04.286 --> 00:28:06.686 A:middle
在使用 Memgraph 文件

00:28:06.686 --> 00:28:08.216 A:middle
的日常技巧

00:28:08.216 --> 00:28:08.946 A:middle
或者说是策略

00:28:09.426 --> 00:28:10.756 A:middle
第一个

00:28:10.856 --> 00:28:12.636 A:middle
我需要把它向上拖动一下

00:28:13.076 --> 00:28:14.846 A:middle
就是寻找泄漏

00:28:15.406 --> 00:28:18.286 A:middle
如果我前往过滤器工具栏

00:28:18.286 --> 00:28:19.846 A:middle
轻点泄漏过滤器

00:28:19.846 --> 00:28:22.106 A:middle
它就会显示 Memgraph 文件中的

00:28:22.106 --> 00:28:23.736 A:middle
每一个泄漏

00:28:24.666 --> 00:28:27.746 A:middle
这个 Memgraph 文件没有泄漏

00:28:27.986 --> 00:28:29.526 A:middle
这既是好消息

00:28:29.526 --> 00:28:30.656 A:middle
又是坏消息

00:28:31.136 --> 00:28:32.136 A:middle
好处在于 没有泄漏

00:28:32.136 --> 00:28:33.516 A:middle
但现在我得弄清楚

00:28:33.516 --> 00:28:35.046 A:middle
到底发生了什么

00:28:35.906 --> 00:28:37.746 A:middle
Memgraph 的

00:28:37.746 --> 00:28:40.046 A:middle
另一个好处是

00:28:40.046 --> 00:28:41.926 A:middle
告诉我一个对象

00:28:41.926 --> 00:28:43.036 A:middle
在内存中有多少个实例

00:28:43.036 --> 00:28:44.226 A:middle
以及是否比我预期的要多

00:28:44.876 --> 00:28:46.166 A:middle
当我查看这个 Memgraph 文件时

00:28:46.166 --> 00:28:47.476 A:middle
如果我特意关注

00:28:47.476 --> 00:28:49.136 A:middle
代码中的对象

00:28:49.136 --> 00:28:52.146 A:middle
就可以看到

00:28:52.146 --> 00:28:53.966 A:middle
内存中只有 5 个对象

00:28:53.966 --> 00:28:55.526 A:middle
且每种都只有 1 个

00:28:56.136 --> 00:28:57.266 A:middle
如果内存中

00:28:57.266 --> 00:28:59.066 A:middle
有多个 RootViewController

00:28:59.336 --> 00:29:01.586 A:middle
多个 NoirFilter

00:28:59.336 --> 00:29:01.586 A:middle
多个 NoirFilter

00:29:01.586 --> 00:29:03.366 A:middle
多个滤镜

00:29:03.366 --> 00:29:04.676 A:middle
或其他预料之外的对象

00:29:04.676 --> 00:29:05.716 A:middle
那些就是我可以调查的东西

00:29:06.496 --> 00:29:09.736 A:middle
这里的实例数量

00:29:09.736 --> 00:29:10.816 A:middle
在我的预料内

00:29:10.816 --> 00:29:12.076 A:middle
但也许其中存在一个很大的实例

00:29:12.186 --> 00:29:13.726 A:middle
尽管不太可能

00:29:13.726 --> 00:29:14.366 A:middle
我还是得检查一下

00:29:14.566 --> 00:29:17.386 A:middle
所以我需要使用内存检查器

00:29:17.386 --> 00:29:18.206 A:middle
我要看看这些

00:29:18.286 --> 00:29:19.576 A:middle
它们中的每一个

00:29:19.576 --> 00:29:20.666 A:middle
都列出了每个对象的大小

00:29:21.016 --> 00:29:23.486 A:middle
我可以看到我的 AppDelegate 是 32 字节

00:29:23.966 --> 00:29:25.796 A:middle
DataViewController 是 1500 字节

00:29:26.216 --> 00:29:27.556 A:middle
当我浏览每一个的时候

00:29:28.506 --> 00:29:30.056 A:middle
没有一个明显地占用了

00:29:30.056 --> 00:29:33.596 A:middle
我的 App 正在使用的

00:29:33.596 --> 00:29:36.436 A:middle
1GB 多的内存

00:29:37.096 --> 00:29:38.766 A:middle
这就是我在 Xcode 中

00:29:38.766 --> 00:29:40.936 A:middle
处理 Memgraph 的技巧

00:29:41.466 --> 00:29:42.436 A:middle
我接下来要做什么

00:29:43.256 --> 00:29:45.106 A:middle
我刚刚看了这个

00:29:45.356 --> 00:29:48.236 A:middle
关于在 Memgraph 文件中

00:29:48.366 --> 00:29:50.646 A:middle
使用命令行工具的 WWDC 讨论会

00:29:51.516 --> 00:29:53.276 A:middle
让我来试试

00:29:53.276 --> 00:29:55.876 A:middle
能不能找到什么

00:29:55.876 --> 00:29:57.236 A:middle
回想起来

00:29:57.236 --> 00:29:59.036 A:middle
James 提出的第一件事

00:29:59.036 --> 00:30:01.636 A:middle
就是使用 vmmap 的 -summary 参数

00:29:59.036 --> 00:30:01.636 A:middle
就是使用 vmmap 的 -summary 参数

00:30:02.846 --> 00:30:04.196 A:middle
所以我来试试

00:30:04.386 --> 00:30:06.816 A:middle
传入 Memgraph 文件

00:30:06.886 --> 00:30:10.696 A:middle
我们来看看这个输出

00:30:11.756 --> 00:30:13.016 A:middle
现在 我应该在这里

00:30:13.016 --> 00:30:13.706 A:middle
寻找什么呢

00:30:14.476 --> 00:30:15.716 A:middle
总的来说

00:30:15.716 --> 00:30:16.776 A:middle
我在寻找非常大的数字

00:30:16.776 --> 00:30:17.846 A:middle
我想弄清楚

00:30:17.846 --> 00:30:19.196 A:middle
是什么在使用这些内存

00:30:19.196 --> 00:30:20.946 A:middle
大的数字意味着更多的内存使用

00:30:21.566 --> 00:30:25.876 A:middle
这里有很多列

00:30:25.876 --> 00:30:27.196 A:middle
有些列比其他列更重要

00:30:27.806 --> 00:30:30.166 A:middle
首先 “VIRTUAL SIZE（虚拟内存大小）”

00:30:30.166 --> 00:30:32.226 A:middle
虚拟意味着不是实际的

00:30:32.516 --> 00:30:34.846 A:middle
我几乎可以忽略这一列

00:30:34.916 --> 00:30:36.246 A:middle
它是 App 所需的内存

00:30:36.246 --> 00:30:38.056 A:middle
但不一定要使用

00:30:38.736 --> 00:30:40.356 A:middle
脏内存听起来像是

00:30:40.356 --> 00:30:42.036 A:middle
我绝对不希望在 App 里存在的东西

00:30:42.546 --> 00:30:44.466 A:middle
我希望我的 App 是干净的

00:30:44.466 --> 00:30:45.896 A:middle
而不是脏的

00:30:45.896 --> 00:30:46.916 A:middle
所以我想要这个数字尽量小

00:30:47.356 --> 00:30:48.416 A:middle
然后交换内存

00:30:48.446 --> 00:30:49.456 A:middle
因为我们谈的是 iOS

00:30:49.456 --> 00:30:52.316 A:middle
所以指的是压缩内存

00:30:52.316 --> 00:30:55.156 A:middle
正如 Kyle 和 James 之前提到的

00:30:55.236 --> 00:30:57.386 A:middle
操作系统凭借

00:30:57.386 --> 00:30:59.606 A:middle
脏内存大小

00:30:59.606 --> 00:31:00.816 A:middle
加上压缩内存大小的总和

00:30:59.606 --> 00:31:00.816 A:middle
加上压缩内存大小的总和

00:31:00.816 --> 00:31:02.586 A:middle
来确定我的 App 实际

00:31:02.586 --> 00:31:03.726 A:middle
实际使用了多少内存

00:31:04.266 --> 00:31:05.516 A:middle
所以这就是我想要

00:31:05.516 --> 00:31:06.796 A:middle
关注的两列

00:31:06.796 --> 00:31:08.596 A:middle
我们再来看一些较大的数字

00:31:08.596 --> 00:31:11.636 A:middle
我马上就看到了 “CG image” 非常显眼

00:31:11.636 --> 00:31:13.996 A:middle
它占用了非常多的

00:31:13.996 --> 00:31:15.206 A:middle
脏内存和交换内存

00:31:15.256 --> 00:31:16.906 A:middle
这是一个危险信号

00:31:16.956 --> 00:31:17.846 A:middle
让我们继续观察

00:31:18.496 --> 00:31:21.616 A:middle
我可以看到

00:31:21.616 --> 00:31:23.676 A:middle
“IOSurface” 占用了很多的 脏内存

00:31:23.676 --> 00:31:24.686 A:middle
但不占用交换内存

00:31:25.156 --> 00:31:29.876 A:middle
“MALLOC_LARGE” 占用了很多脏内存

00:31:30.146 --> 00:31:31.256 A:middle
但占用较少的交换内存

00:31:31.256 --> 00:31:33.396 A:middle
之后就没有

00:31:33.396 --> 00:31:35.056 A:middle
这么大的数字了

00:31:35.576 --> 00:31:37.696 A:middle
基于我在这里看到的

00:31:37.696 --> 00:31:39.036 A:middle
我认为我应该集中处理

00:31:39.036 --> 00:31:42.376 A:middle
CG image 的虚拟内存区域

00:31:43.096 --> 00:31:44.606 A:middle
让我们把它复制下来

00:31:45.586 --> 00:31:47.426 A:middle
下一步该是什么呢

00:31:48.096 --> 00:31:50.266 A:middle
我们想要了解更多

00:31:50.266 --> 00:31:52.326 A:middle
关于虚拟内存的信息

00:31:52.326 --> 00:31:53.986 A:middle
所以 vmmap 似乎还是我们要用的工具

00:31:54.636 --> 00:31:55.616 A:middle
这次我将不再

00:31:55.616 --> 00:31:57.216 A:middle
使用 -summary 参数

00:31:57.216 --> 00:32:00.376 A:middle
而是传递我的 Memgraph 文件

00:31:57.216 --> 00:32:00.376 A:middle
而是传递我的 Memgraph 文件

00:32:01.266 --> 00:32:02.806 A:middle
但我只关心

00:32:02.896 --> 00:32:04.126 A:middle
“CG image” 的内存

00:32:04.336 --> 00:32:05.936 A:middle
并不关心 vmmap

00:32:05.936 --> 00:32:09.186 A:middle
会告诉我的其他

00:32:09.186 --> 00:32:10.516 A:middle
虚拟内存区域

00:32:10.516 --> 00:32:12.026 A:middle
所以我应该使用 “grep”

00:32:12.026 --> 00:32:15.876 A:middle
只向我展示

00:32:15.906 --> 00:32:17.736 A:middle
关于 “CG image” 的行

00:32:18.016 --> 00:32:19.116 A:middle
让我们看看会发生什么

00:32:20.016 --> 00:32:21.336 A:middle
现在 我有三行信息

00:32:21.646 --> 00:32:25.096 A:middle
我可以看到 有两个虚拟内存区域

00:32:25.426 --> 00:32:26.646 A:middle
在那里我可以看到

00:32:26.646 --> 00:32:28.576 A:middle
它们的起始地址和终止地址

00:32:28.906 --> 00:32:30.416 A:middle
然后我可以看到

00:32:30.416 --> 00:32:31.636 A:middle
和之前相同的列

00:32:31.636 --> 00:32:34.006 A:middle
分别是虚拟内存 常驻内存

00:32:34.516 --> 00:32:36.066 A:middle
脏内存和压缩内存

00:32:36.686 --> 00:32:37.736 A:middle
这里显示的最后一行

00:32:37.736 --> 00:32:39.586 A:middle
是总结行

00:32:40.536 --> 00:32:43.666 A:middle
也就是和上面一样的数据

00:32:44.506 --> 00:32:45.966 A:middle
看看这两个区域

00:32:45.966 --> 00:32:47.616 A:middle
我有一个很小的区域

00:32:47.696 --> 00:32:49.026 A:middle
和一个很大的区域

00:32:49.416 --> 00:32:50.986 A:middle
我显然更想了解

00:32:50.986 --> 00:32:53.706 A:middle
这个大一点的区域

00:32:53.906 --> 00:32:55.876 A:middle
那么我怎样才能找到

00:32:55.876 --> 00:32:58.286 A:middle
更多关于这个虚拟内存区域的信息呢

00:32:58.936 --> 00:33:00.366 A:middle
我查看了

00:32:58.936 --> 00:33:00.366 A:middle
我查看了

00:33:00.366 --> 00:33:02.286 A:middle
vmmap 的文档

00:33:02.286 --> 00:33:03.746 A:middle
然后注意到一个 -verbose 参数

00:33:03.746 --> 00:33:05.786 A:middle
顾名思义

00:33:05.786 --> 00:33:08.506 A:middle
它会输出更多的信息

00:33:08.806 --> 00:33:10.446 A:middle
我想知道它能告诉我什么

00:33:11.486 --> 00:33:12.676 A:middle
让我们继续

00:33:12.706 --> 00:33:16.186 A:middle
传入 -verbose 和 Memgraph 文件

00:33:17.536 --> 00:33:21.266 A:middle
同样 我只关心 “CG image” 区域

00:33:22.306 --> 00:33:24.226 A:middle
所以我用 “grep”

00:33:24.226 --> 00:33:25.946 A:middle
来进行过滤

00:33:26.886 --> 00:33:28.396 A:middle
现在我看到了

00:33:28.396 --> 00:33:29.616 A:middle
更多的区域

00:33:30.156 --> 00:33:31.116 A:middle
为什么会这样

00:33:31.826 --> 00:33:33.576 A:middle
默认情况下

00:33:33.576 --> 00:33:35.166 A:middle
如果 vmmap 找到连续的区域

00:33:35.256 --> 00:33:37.686 A:middle
它会把它们

00:33:37.686 --> 00:33:38.466 A:middle
合并在一起

00:33:38.856 --> 00:33:39.896 A:middle
实际上

00:33:39.896 --> 00:33:41.276 A:middle
如果你从第二行开始看

00:33:41.276 --> 00:33:43.346 A:middle
这个区域的终止地址

00:33:43.346 --> 00:33:44.596 A:middle
和这个区域的起始地址

00:33:44.596 --> 00:33:46.106 A:middle
是一样的

00:33:46.426 --> 00:33:48.496 A:middle
下面也一样

00:33:48.966 --> 00:33:51.076 A:middle
因此 vmmap 在默认情况下

00:33:51.076 --> 00:33:52.426 A:middle
将其折叠成一个区域

00:33:52.886 --> 00:33:54.086 A:middle
但是看看这里的细节

00:33:54.086 --> 00:33:54.976 A:middle
却能发现一些

00:33:54.976 --> 00:33:55.776 A:middle
不同之处

00:33:55.836 --> 00:33:57.746 A:middle
特别是其中一些区域

00:33:57.746 --> 00:34:00.826 A:middle
使用了更多的 脏内存

00:33:57.746 --> 00:34:00.826 A:middle
使用了更多的 脏内存

00:34:00.826 --> 00:34:02.016 A:middle
而另一些使用了更多的压缩内存

00:34:02.016 --> 00:34:04.426 A:middle
这就会帮助我找到

00:34:04.426 --> 00:34:06.126 A:middle
应该关注的地方

00:34:06.126 --> 00:34:07.626 A:middle
但这里我要用

00:34:07.626 --> 00:34:08.786 A:middle
另一种策略

00:34:09.216 --> 00:34:10.775 A:middle
我知道 操作系统中

00:34:10.775 --> 00:34:14.266 A:middle
虽然不一定 但一般来说

00:34:14.266 --> 00:34:17.076 A:middle
虚拟内存区域创建得越晚

00:34:17.166 --> 00:34:19.696 A:middle
在 App 生命周期中

00:34:19.846 --> 00:34:21.565 A:middle
它发生得就越晚

00:34:22.136 --> 00:34:23.466 A:middle
由于这个 Memgraph 文件

00:34:23.466 --> 00:34:25.576 A:middle
是在内存使用峰值时获取的

00:34:25.576 --> 00:34:27.596 A:middle
所以很有可能

00:34:27.666 --> 00:34:29.775 A:middle
这些后面的区域

00:34:29.896 --> 00:34:31.775 A:middle
与导致峰值的原因更有关联

00:34:32.426 --> 00:34:33.686 A:middle
所以我不想寻找

00:34:33.686 --> 00:34:35.295 A:middle
最大的 脏内存

00:34:35.295 --> 00:34:36.565 A:middle
和压缩内存数字

00:34:36.565 --> 00:34:38.056 A:middle
而是要从底部这里开始

00:34:38.676 --> 00:34:40.666 A:middle
我要获取最后一个区域

00:34:40.666 --> 00:34:42.406 A:middle
的起始地址

00:34:43.166 --> 00:34:44.786 A:middle
我该怎么做呢

00:34:45.366 --> 00:34:47.755 A:middle
James 提到的一个工具是 heap

00:34:47.755 --> 00:34:50.815 A:middle
但它作用于堆上的对象

00:34:50.815 --> 00:34:51.856 A:middle
而我正在处理一个

00:34:51.856 --> 00:34:53.196 A:middle
虚拟内存区域

00:34:53.196 --> 00:34:56.366 A:middle
所以它并不适用

00:34:56.366 --> 00:34:58.436 A:middle
还有 leaks 工具

00:34:58.436 --> 00:34:59.516 A:middle
但是我这里并没有泄漏

00:34:59.516 --> 00:35:00.466 A:middle
我已经从 Memgraph 中

00:34:59.516 --> 00:35:00.466 A:middle
我已经从 Memgraph 中

00:35:00.466 --> 00:35:01.796 A:middle
知道了这里没有泄漏

00:35:02.096 --> 00:35:03.346 A:middle
所以它看起来不像是

00:35:03.346 --> 00:35:04.276 A:middle
我可以使用的工具

00:35:04.696 --> 00:35:06.636 A:middle
但是我查看了

00:35:06.776 --> 00:35:09.896 A:middle
关于 leaks 的帮助信息

00:35:09.896 --> 00:35:11.466 A:middle
发现 leaks 可以做很多事情

00:35:11.466 --> 00:35:14.016 A:middle
包括告诉我

00:35:14.016 --> 00:35:16.296 A:middle
哪些对堆上的对象

00:35:16.296 --> 00:35:18.736 A:middle
或虚拟内存区域有引用

00:35:19.226 --> 00:35:20.236 A:middle
我们来看看

00:35:20.236 --> 00:35:21.016 A:middle
它会告诉我们什么

00:35:21.696 --> 00:35:23.556 A:middle
我将使用 leaks

00:35:23.556 --> 00:35:25.746 A:middle
然后传递

00:35:25.806 --> 00:35:27.326 A:middle
-traceTree 参数

00:35:27.986 --> 00:35:29.146 A:middle
它的作用是

00:35:29.146 --> 00:35:32.056 A:middle
给了我一个树形视图

00:35:32.056 --> 00:35:33.556 A:middle
可以涵盖所有

00:35:33.556 --> 00:35:34.826 A:middle
与我要传入的地址有关的东西

00:35:34.826 --> 00:35:36.916 A:middle
在这个例子中 我传入的是

00:35:36.916 --> 00:35:39.786 A:middle
虚拟内存区域的

00:35:39.786 --> 00:35:41.886 A:middle
起始地址

00:35:42.446 --> 00:35:44.006 A:middle
最后我们提供

00:35:44.006 --> 00:35:44.956 A:middle
这个 Memgraph 文件

00:35:45.906 --> 00:35:47.276 A:middle
它会是什么样子呢

00:35:47.466 --> 00:35:49.526 A:middle
这里我们能看到

00:35:49.636 --> 00:35:50.936 A:middle
所有引用的树

00:35:50.936 --> 00:35:52.136 A:middle
如果我们向上滚动到顶部

00:35:53.196 --> 00:35:55.076 A:middle
在这里 我可以看到

00:35:55.076 --> 00:35:56.746 A:middle
这是我的虚拟内存区域

00:35:56.746 --> 00:35:58.716 A:middle
这是我的 “CG image” 区域

00:35:58.716 --> 00:35:59.856 A:middle
然后我可以看到

00:35:59.856 --> 00:36:02.346 A:middle
这个树视图

00:35:59.856 --> 00:36:02.346 A:middle
这个树视图

00:36:02.346 --> 00:36:03.336 A:middle
包含了所有具有引用的东西

00:36:03.336 --> 00:36:04.676 A:middle
以及引用它们的东西

00:36:04.676 --> 00:36:06.006 A:middle
以及引用这些东西的东西

00:36:06.006 --> 00:36:06.616 A:middle
等等等等

00:36:06.616 --> 00:36:08.646 A:middle
如果我们回到 Xcode

00:36:08.646 --> 00:36:11.026 A:middle
我们实际上过滤了

00:36:11.026 --> 00:36:14.066 A:middle
相同的地址

00:36:14.066 --> 00:36:16.766 A:middle
我来看看这个对象

00:36:16.766 --> 00:36:18.406 A:middle
这个树视图和我从 leaks 中

00:36:18.406 --> 00:36:19.246 A:middle
看到的一样

00:36:19.436 --> 00:36:20.626 A:middle
如果我想的话

00:36:20.626 --> 00:36:22.146 A:middle
我可以沿着树走下去

00:36:22.146 --> 00:36:23.876 A:middle
并展开每一个节点

00:36:23.876 --> 00:36:25.436 A:middle
看看每个节点的细节

00:36:25.436 --> 00:36:26.946 A:middle
但是这需要一段时间

00:36:26.946 --> 00:36:28.306 A:middle
而且有点乏味

00:36:28.386 --> 00:36:29.986 A:middle
leaks 的输出的优点是

00:36:29.986 --> 00:36:32.566 A:middle
我不仅可以

00:36:32.566 --> 00:36:33.946 A:middle
快速浏览它

00:36:33.946 --> 00:36:36.296 A:middle
还可以随意搜索或筛选

00:36:36.296 --> 00:36:37.736 A:middle
或者我可以把它放进

00:36:37.736 --> 00:36:39.676 A:middle
一个 Bug 报告或电子邮件中

00:36:39.676 --> 00:36:40.786 A:middle
然而我却不能对 Xcode 中的图形视图

00:36:40.786 --> 00:36:42.786 A:middle
进行上述的操作

00:36:43.686 --> 00:36:44.996 A:middle
那么在这个 leaks 的输出中

00:36:44.996 --> 00:36:45.536 A:middle
我要找什么呢

00:36:46.116 --> 00:36:48.286 A:middle
理想情况下

00:36:48.286 --> 00:36:49.876 A:middle
我会找到一个

00:36:49.876 --> 00:36:51.326 A:middle
我负责的类

00:36:51.326 --> 00:36:52.146 A:middle
一个来自我的 App 的类

00:36:52.306 --> 00:36:54.066 A:middle
我之前看过这个

00:36:54.066 --> 00:36:55.106 A:middle
我知道这里

00:36:55.106 --> 00:36:56.846 A:middle
没有我的类

00:36:56.846 --> 00:36:57.976 A:middle
那么我还能找到什么呢

00:36:58.376 --> 00:37:00.236 A:middle
我正在创建的类

00:36:58.376 --> 00:37:00.236 A:middle
我正在创建的类

00:37:00.236 --> 00:37:01.566 A:middle
比如一个框架类

00:37:01.566 --> 00:37:02.766 A:middle
它也许是以我的名义创建的

00:37:02.766 --> 00:37:04.156 A:middle
也可能是我

00:37:04.206 --> 00:37:05.186 A:middle
直接创建的

00:37:05.596 --> 00:37:08.276 A:middle
我知道我的 App 有 UIViews

00:37:08.276 --> 00:37:09.156 A:middle
它有 UIImages

00:37:09.156 --> 00:37:11.966 A:middle
我可以用这些 Core Image 类

00:37:12.156 --> 00:37:13.926 A:middle
来进行过滤

00:37:13.926 --> 00:37:15.516 A:middle
我们继续看这里

00:37:15.606 --> 00:37:18.866 A:middle
我用的是一个非常复杂的

00:37:18.866 --> 00:37:20.716 A:middle
叫做 “My Eyeballs” 的调试工具

00:37:21.566 --> 00:37:23.576 A:middle
我们继续寻找

00:37:23.786 --> 00:37:29.346 A:middle
我看看能不能找到我想要的

00:37:29.836 --> 00:37:32.576 A:middle
这是一个很大的终端输出

00:37:32.826 --> 00:37:34.356 A:middle
所以让人更加困惑

00:37:35.116 --> 00:37:36.686 A:middle
举个例子

00:37:36.686 --> 00:37:38.376 A:middle
这里有一个字体引用

00:37:38.376 --> 00:37:39.546 A:middle
我知道我的 App

00:37:39.546 --> 00:37:42.196 A:middle
使用字体

00:37:42.196 --> 00:37:44.706 A:middle
但是字体并不会导致

00:37:44.706 --> 00:37:46.156 A:middle
很多的内存使用

00:37:46.156 --> 00:37:47.886 A:middle
所以它没有帮助

00:37:47.886 --> 00:37:49.126 A:middle
我们再往下看

00:37:49.126 --> 00:37:51.476 A:middle
我可以看到有很多

00:37:51.476 --> 00:37:54.976 A:middle
这样的 CI 类

00:37:54.976 --> 00:37:56.346 A:middle
它们是 Core Image 滤镜

00:37:56.346 --> 00:37:57.666 A:middle
或者是 Core Image

00:37:57.666 --> 00:37:58.926 A:middle
在我的 App 中

00:37:58.926 --> 00:38:00.346 A:middle
起滤镜作用的东西

00:37:58.926 --> 00:38:00.346 A:middle
起滤镜作用的东西

00:38:00.746 --> 00:38:02.076 A:middle
它也许也是我该

00:38:02.076 --> 00:38:04.036 A:middle
进一步研究的东西

00:38:04.036 --> 00:38:05.406 A:middle
我已经做了

00:38:05.406 --> 00:38:08.906 A:middle
但没有发现任何有用的东西

00:38:09.296 --> 00:38:11.286 A:middle
我无法进一步研究

00:38:11.286 --> 00:38:13.006 A:middle
leaks 的输出

00:38:13.216 --> 00:38:15.566 A:middle
这很不幸

00:38:15.666 --> 00:38:17.976 A:middle
接下来我该做什么呢

00:38:18.826 --> 00:38:21.716 A:middle
幸运的是

00:38:23.106 --> 00:38:25.536 A:middle
James 在捕获

00:38:25.536 --> 00:38:26.456 A:middle
这个 Memgraph 时

00:38:26.456 --> 00:38:29.736 A:middle
打开了配置内存的回溯记录

00:38:29.736 --> 00:38:31.366 A:middle
这意味着我可以使用

00:38:31.366 --> 00:38:33.336 A:middle
他谈到的另一个工具

00:38:33.336 --> 00:38:36.896 A:middle
来查看对象的创建回溯

00:38:36.896 --> 00:38:38.566 A:middle
我将使用 malloc_history

00:38:40.096 --> 00:38:42.206 A:middle
这一次 我先传入

00:38:42.206 --> 00:38:43.866 A:middle
Memgraph 文件

00:38:44.136 --> 00:38:48.836 A:middle
然后再传入这个从帮助文档中获知的

00:38:48.836 --> 00:38:50.256 A:middle
-fullStacks 参数

00:38:51.046 --> 00:38:52.546 A:middle
它的功能就是

00:38:52.546 --> 00:38:55.216 A:middle
使每一帧都在它自己的行上显示

00:38:55.216 --> 00:38:56.646 A:middle
这样让人更容易阅读

00:38:57.096 --> 00:38:58.366 A:middle
然后我将传递

00:38:58.556 --> 00:39:00.156 A:middle
虚拟内存区域的

00:38:58.556 --> 00:39:00.156 A:middle
虚拟内存区域的

00:39:00.156 --> 00:39:01.096 A:middle
起始内存地址

00:39:01.806 --> 00:39:02.856 A:middle
让我们看看是什么样子

00:39:04.036 --> 00:39:05.386 A:middle
实际上这并不是一个

00:39:05.386 --> 00:39:06.566 A:middle
很大的回溯

00:39:06.566 --> 00:39:09.066 A:middle
我可以看到我的代码

00:39:09.066 --> 00:39:10.126 A:middle
出现在这里的几行

00:39:10.576 --> 00:39:12.676 A:middle
第 6 行到第 9 行

00:39:12.676 --> 00:39:14.106 A:middle
实际上来自我的 App 代码

00:39:14.106 --> 00:39:16.066 A:middle
我可以在第 6 行看到

00:39:16.066 --> 00:39:19.046 A:middle
NoirFilter.apply() 函数

00:39:19.046 --> 00:39:21.186 A:middle
负责创建

00:39:21.186 --> 00:39:24.486 A:middle
这个特定的虚拟内存区域

00:39:24.996 --> 00:39:27.626 A:middle
这是一个很好的证据

00:39:27.626 --> 00:39:28.826 A:middle
展示了我如何在 App 中

00:39:28.826 --> 00:39:31.216 A:middle
找到造成这些内存使用的东西

00:39:31.746 --> 00:39:34.806 A:middle
如果我们回到 Memgraph 文件

00:39:34.806 --> 00:39:36.586 A:middle
就可以发现这和 Xcode 中

00:39:36.586 --> 00:39:38.626 A:middle
出现的回溯是一样的

00:39:39.186 --> 00:39:40.446 A:middle
你可以看到这里

00:39:40.446 --> 00:39:42.526 A:middle
也是 NoirFilter.apply() 方法

00:39:42.886 --> 00:39:44.046 A:middle
我们没有像

00:39:44.046 --> 00:39:45.646 A:middle
通常在回溯视图中看到的那样

00:39:45.646 --> 00:39:47.176 A:middle
得到很好的高亮显示

00:39:47.176 --> 00:39:48.796 A:middle
因为我们没有调试一个活动进程

00:39:48.796 --> 00:39:50.116 A:middle
我们正在加载一个 Memgraph 文件

00:39:50.526 --> 00:39:51.686 A:middle
但是你可以看到它的输出

00:39:51.686 --> 00:39:52.796 A:middle
和我们从 malloc_history 中得到的输出

00:39:52.796 --> 00:39:53.566 A:middle
是完全一样的

00:39:53.926 --> 00:39:57.786 A:middle
事实上

00:39:57.986 --> 00:39:59.616 A:middle
为了进一步确认

00:39:59.616 --> 00:40:02.036 A:middle
我需要查看

00:39:59.616 --> 00:40:02.036 A:middle
我需要查看

00:40:02.136 --> 00:40:05.956 A:middle
“CG image” 虚拟内存区域的完整列表

00:40:05.956 --> 00:40:09.066 A:middle
接下来我选取了

00:40:09.066 --> 00:40:10.156 A:middle
倒数第二个

00:40:10.156 --> 00:40:11.916 A:middle
我们来看看

00:40:11.916 --> 00:40:13.176 A:middle
这个区域的回溯

00:40:15.146 --> 00:40:17.326 A:middle
结果是相同的回溯

00:40:17.526 --> 00:40:18.896 A:middle
同样的代码路径

00:40:18.896 --> 00:40:20.496 A:middle
也指向这个区域

00:40:20.966 --> 00:40:23.486 A:middle
如果继续观察

00:40:23.486 --> 00:40:24.976 A:middle
其中的几个区域

00:40:24.976 --> 00:40:26.276 A:middle
实际上仍使用了相同的回溯

00:40:26.766 --> 00:40:27.886 A:middle
这样我就明白了

00:40:27.886 --> 00:40:30.086 A:middle
在我的 App 中

00:40:30.086 --> 00:40:32.326 A:middle
是什么创建了这些

00:40:32.326 --> 00:40:33.636 A:middle
占用了 App 中

00:40:33.636 --> 00:40:34.896 A:middle
大量内存的

00:40:34.896 --> 00:40:35.776 A:middle
虚拟内存区域

00:40:36.706 --> 00:40:37.836 A:middle
那么我们能做些什么呢

00:40:38.636 --> 00:40:40.186 A:middle
让我们回到 Xcode

00:40:40.186 --> 00:40:42.276 A:middle
我现在可以关闭 Memgraph 文件

00:40:43.396 --> 00:40:46.196 A:middle
我要做的第一件事是

00:40:46.196 --> 00:40:47.626 A:middle
看看这里的代码

00:40:48.406 --> 00:40:52.536 A:middle
如果看看与我的滤镜相关的代码

00:40:52.536 --> 00:40:54.436 A:middle
我可以看到这里是 apply() 函数

00:40:54.436 --> 00:40:55.926 A:middle
我可以马上看到

00:40:55.926 --> 00:40:57.026 A:middle
一些东西跳出来

00:40:57.026 --> 00:40:58.776 A:middle
它们是我正在使用的

00:40:58.776 --> 00:41:02.886 A:middle
UIGraphicsBeginImageContextWithOptions

00:40:58.776 --> 00:41:02.886 A:middle
UIGraphicsBeginImageContextWithOptions

00:41:02.886 --> 00:41:04.866 A:middle
以及 UIGraphicsEndImageContext

00:41:04.866 --> 00:41:06.086 A:middle
我记得 Kyle 说过

00:41:06.086 --> 00:41:06.846 A:middle
你们不应该使用它

00:41:06.846 --> 00:41:08.986 A:middle
在那些情况下有更好的 API 可以使用

00:41:09.346 --> 00:41:10.946 A:middle
这是我肯定想要

00:41:10.946 --> 00:41:12.386 A:middle
再次讨论的内容

00:41:12.386 --> 00:41:13.606 A:middle
但我首先需要的

00:41:13.606 --> 00:41:14.576 A:middle
是某种基线

00:41:14.576 --> 00:41:15.716 A:middle
我需要知道

00:41:15.716 --> 00:41:17.736 A:middle
我的 App 使用了多少内存

00:41:17.736 --> 00:41:18.886 A:middle
这样我就可以确保我的更改

00:41:18.886 --> 00:41:19.826 A:middle
能让结果变得不同

00:41:20.496 --> 00:41:21.726 A:middle
我要运行

00:41:21.726 --> 00:41:24.566 A:middle
我的 App

00:41:24.566 --> 00:41:26.786 A:middle
然后找到调试导航器

00:41:26.786 --> 00:41:28.456 A:middle
查看内存报告

00:41:28.626 --> 00:41:30.896 A:middle
现在 我可以看到我的 App

00:41:30.896 --> 00:41:32.566 A:middle
在运行时使用的内存

00:41:33.366 --> 00:41:35.946 A:middle
我真的很喜欢这个

00:41:35.946 --> 00:41:37.266 A:middle
土星北极的图像

00:41:37.836 --> 00:41:39.766 A:middle
它是一个奇怪的六边形

00:41:39.836 --> 00:41:41.346 A:middle
炫酷的同时

00:41:41.346 --> 00:41:42.356 A:middle
又有点古怪

00:41:42.816 --> 00:41:44.326 A:middle
我们来看看这个

00:41:44.326 --> 00:41:45.996 A:middle
应用这个滤镜

00:41:45.996 --> 00:41:46.716 A:middle
然后看看会得到什么

00:41:47.706 --> 00:41:51.336 A:middle
1GB 3GB 4GB

00:41:51.336 --> 00:41:52.576 A:middle
6GB 7GB

00:41:53.156 --> 00:41:54.706 A:middle
这可不太好

00:41:54.856 --> 00:41:58.636 A:middle
不过可以

00:41:58.636 --> 00:41:59.846 A:middle
很好地告诉我们

00:41:59.946 --> 00:42:02.006 A:middle
它根本不会在设备上流畅运行

00:41:59.946 --> 00:42:02.006 A:middle
它根本不会在设备上流畅运行

00:42:02.336 --> 00:42:03.186 A:middle
所以当你在模拟器中运行时

00:42:03.186 --> 00:42:04.586 A:middle
你必须记住

00:42:04.586 --> 00:42:06.036 A:middle
它对于调试和

00:42:06.036 --> 00:42:07.226 A:middle
测试变更很有用

00:42:07.226 --> 00:42:08.706 A:middle
但是你也需要在设备上

00:42:08.706 --> 00:42:09.796 A:middle
验证所有的东西

00:42:09.796 --> 00:42:11.206 A:middle
但同时 另一件好事是

00:42:11.206 --> 00:42:13.976 A:middle
模拟器永远不会耗尽内存

00:42:14.276 --> 00:42:15.616 A:middle
如果我遇到了 App 在设备上

00:42:15.616 --> 00:42:16.736 A:middle
被关闭的情况

00:42:16.736 --> 00:42:18.876 A:middle
可以在模拟器中试试

00:42:19.106 --> 00:42:20.296 A:middle
我可以等待一个

00:42:20.296 --> 00:42:21.836 A:middle
非常大的分配

00:42:21.836 --> 00:42:23.476 A:middle
而不会被关闭

00:42:23.476 --> 00:42:24.946 A:middle
然后从那里进行调查

00:42:25.666 --> 00:42:26.716 A:middle
我想指出的一点是

00:42:26.716 --> 00:42:28.786 A:middle
我们其实给你们看了

00:42:28.786 --> 00:42:31.336 A:middle
这里标志的内存峰值

00:42:31.336 --> 00:42:34.406 A:middle
在这个例子中 我最多使用了 7.7GB

00:42:35.226 --> 00:42:35.816 A:middle
这很糟糕

00:42:36.636 --> 00:42:39.126 A:middle
我们来看看能做些什么

00:42:39.226 --> 00:42:43.706 A:middle
回到我的 apply() 函数

00:42:44.326 --> 00:42:46.386 A:middle
现在

00:42:46.386 --> 00:42:47.026 A:middle
我想使用这个

00:42:47.026 --> 00:42:48.396 A:middle
beginImageContextWithOptions

00:42:48.396 --> 00:42:50.086 A:middle
但是回想一下 Kyle 说过的

00:42:50.086 --> 00:42:52.046 A:middle
当你处理图像时

00:42:52.046 --> 00:42:54.296 A:middle
内存使用中

00:42:54.296 --> 00:42:56.236 A:middle
最重要的是什么

00:42:56.696 --> 00:42:58.986 A:middle
是图像的尺寸

00:42:58.986 --> 00:43:00.446 A:middle
让我们看看它是什么样子

00:42:58.986 --> 00:43:00.446 A:middle
让我们看看它是什么样子

00:43:00.446 --> 00:43:03.056 A:middle
我要再次

00:43:03.056 --> 00:43:04.176 A:middle
使用这个滤镜

00:43:04.536 --> 00:43:07.896 A:middle
我在调试器中停止时

00:43:07.896 --> 00:43:11.936 A:middle
就可以看到

00:43:11.936 --> 00:43:14.476 A:middle
这个图像的尺寸

00:43:14.546 --> 00:43:15.556 A:middle
在我按回车

00:43:15.836 --> 00:43:19.516 A:middle
我要先喝一小口水

00:43:19.586 --> 00:43:22.836 A:middle
我其实并不想喝水

00:43:24.646 --> 00:43:27.466 A:middle
它是 15000*13000

00:43:27.986 --> 00:43:29.876 A:middle
我检查过文档

00:43:29.956 --> 00:43:32.196 A:middle
在 UIImage 上

00:43:32.476 --> 00:43:33.766 A:middle
那是点（pt） 不是像素（px）

00:43:33.766 --> 00:43:36.656 A:middle
如果这是 2X 设备

00:43:36.656 --> 00:43:38.896 A:middle
或 3X 设备

00:43:38.896 --> 00:43:40.906 A:middle
你必须把它乘以一个很大的数字

00:43:41.446 --> 00:43:43.026 A:middle
Kyle 会很生气

00:43:43.026 --> 00:43:44.846 A:middle
因为一张图片就占用了 10MB

00:43:45.276 --> 00:43:47.146 A:middle
没人告诉他这件事

00:43:47.986 --> 00:43:49.816 A:middle
为了证实这一点

00:43:49.816 --> 00:43:51.486 A:middle
我想尝试一下

00:43:51.486 --> 00:43:55.396 A:middle
我要将 15000 乘以 13000

00:43:56.126 --> 00:44:00.786 A:middle
iPhone X 是一个 3X 设备

00:43:56.126 --> 00:44:00.786 A:middle
iPhone X 是一个 3X 设备

00:44:00.786 --> 00:44:02.766 A:middle
所以是 3 倍的宽度

00:44:02.766 --> 00:44:06.436 A:middle
乘以 3 倍的高度

00:44:06.436 --> 00:44:09.696 A:middle
再乘以 4 字节每像素

00:44:10.506 --> 00:44:13.706 A:middle
这个数字看起来很熟悉

00:44:15.876 --> 00:44:17.786 A:middle
所以我很确定

00:44:17.786 --> 00:44:19.306 A:middle
我清楚地知道到底是什么

00:44:19.306 --> 00:44:20.886 A:middle
使用了 7.5GB 的内存

00:44:20.886 --> 00:44:24.386 A:middle
并不一定是

00:44:24.386 --> 00:44:25.966 A:middle
我的 beginImageContext

00:44:25.966 --> 00:44:27.376 A:middle
而是图像的尺寸

00:44:27.746 --> 00:44:29.186 A:middle
没有理由需要

00:44:29.186 --> 00:44:30.506 A:middle
这么大的图像

00:44:30.966 --> 00:44:32.146 A:middle
我要做的是把它缩小成

00:44:32.146 --> 00:44:33.826 A:middle
和我的视图

00:44:33.826 --> 00:44:34.666 A:middle
相同的尺寸

00:44:34.666 --> 00:44:36.086 A:middle
这样 它就会占用

00:44:36.086 --> 00:44:36.826 A:middle
更少的内存

00:44:37.526 --> 00:44:38.766 A:middle
那么 我要回到

00:44:38.766 --> 00:44:40.026 A:middle
上面的图像加载代码

00:44:40.136 --> 00:44:41.216 A:middle
实际上 在我这么做之前

00:44:41.216 --> 00:44:42.276 A:middle
我想先禁用这个断点

00:44:42.276 --> 00:44:45.146 A:middle
让我们看看

00:44:45.146 --> 00:44:46.286 A:middle
它是做什么的

00:44:46.286 --> 00:44:47.666 A:middle
很简单

00:44:47.666 --> 00:44:49.016 A:middle
它从一个 Bundle 中获取 URL

00:44:49.016 --> 00:44:51.176 A:middle
它从那个 URL 中

00:44:51.176 --> 00:44:52.796 A:middle
加载一些数据

00:44:52.796 --> 00:44:55.166 A:middle
并将其加载到 UIImage 中

00:44:55.346 --> 00:44:56.856 A:middle
然后传递给滤镜

00:44:57.406 --> 00:44:58.906 A:middle
我想做的是

00:44:58.906 --> 00:45:00.276 A:middle
在我把它发送到滤镜之前

00:44:58.906 --> 00:45:00.276 A:middle
在我把它发送到滤镜之前

00:45:00.276 --> 00:45:01.746 A:middle
我想缩小这个图像

00:45:02.096 --> 00:45:04.226 A:middle
然而 我还记得 Kyle 说的

00:45:04.536 --> 00:45:05.656 A:middle
我不应该在 UIImage 上进行缩放

00:45:05.656 --> 00:45:07.406 A:middle
因为它仍然会

00:45:07.406 --> 00:45:08.816 A:middle
把整个图像

00:45:08.816 --> 00:45:10.266 A:middle
加载到内存中

00:45:10.266 --> 00:45:11.396 A:middle
这是我要避免的

00:45:11.906 --> 00:45:13.876 A:middle
把这个函数

00:45:13.986 --> 00:45:15.826 A:middle
折叠起来

00:45:16.106 --> 00:45:17.556 A:middle
我要用 Kyle 建议的代码

00:45:17.676 --> 00:45:19.946 A:middle
来替换它

00:45:20.496 --> 00:45:23.386 A:middle
好的 我们来看看

00:45:23.386 --> 00:45:24.656 A:middle
这段代码在做什么

00:45:25.886 --> 00:45:28.696 A:middle
这里是一样的

00:45:28.996 --> 00:45:31.286 A:middle
我们从 Bundle 中获取图像

00:45:31.286 --> 00:45:33.206 A:middle
但是这一次

00:45:33.206 --> 00:45:35.376 A:middle
我得稍微调宽一点

00:45:35.746 --> 00:45:38.066 A:middle
我调用了 CGImageSourceCreateWithURL

00:45:38.066 --> 00:45:39.796 A:middle
来获取对图像的引用

00:45:39.796 --> 00:45:41.016 A:middle
然后将其传递给

00:45:41.096 --> 00:45:43.816 A:middle
CGImageSourceCreateThumbnailAtIndex

00:45:44.156 --> 00:45:45.906 A:middle
现在 我可以将图像

00:45:45.906 --> 00:45:47.526 A:middle
缩放到我想要的大小

00:45:47.526 --> 00:45:49.026 A:middle
而不需要将整个内容载入内存

00:45:49.656 --> 00:45:51.366 A:middle
让我们试一试

00:45:51.366 --> 00:45:52.506 A:middle
看看会不会有什么不同

00:45:52.626 --> 00:45:53.506 A:middle
我将重新构建

00:45:53.506 --> 00:45:56.866 A:middle
然后等待它

00:45:56.866 --> 00:45:58.176 A:middle
在 App 上启动

00:45:59.486 --> 00:46:02.356 A:middle
重新生成中

00:45:59.486 --> 00:46:02.356 A:middle
重新生成中

00:46:02.356 --> 00:46:05.636 A:middle
哦 有一个警告

00:46:06.216 --> 00:46:09.566 A:middle
我需要再调整一下这个

00:46:10.996 --> 00:46:11.676 A:middle
再来看一下

00:46:12.786 --> 00:46:14.226 A:middle
好了 正在构建

00:46:15.256 --> 00:46:16.466 A:middle
构建 构建 构建

00:46:17.236 --> 00:46:19.576 A:middle
好的 正在启动 没有问题

00:46:19.636 --> 00:46:20.406 A:middle
现在 让我们来看看

00:46:20.406 --> 00:46:21.526 A:middle
内存报告

00:46:22.886 --> 00:46:25.646 A:middle
让我们回到

00:46:25.686 --> 00:46:27.036 A:middle
我一直很喜欢的

00:46:27.036 --> 00:46:28.556 A:middle
土星北极的图像

00:46:29.926 --> 00:46:32.036 A:middle
我们应用这个图像

00:46:32.036 --> 00:46:33.496 A:middle
看看会占用多少内存

00:46:33.496 --> 00:46:35.936 A:middle
现在是 75

00:46:35.936 --> 00:46:36.456 A:middle
93MB

00:46:36.966 --> 00:46:38.786 A:middle
在这里 我们的内存峰值

00:46:38.786 --> 00:46:41.046 A:middle
是 93MB

00:46:41.626 --> 00:46:42.866 A:middle
明显地改善

00:46:44.946 --> 00:46:46.816 A:middle
[ 掌声 ] 这要比

00:46:46.816 --> 00:46:48.126 A:middle
几乎百分百被关闭的

00:46:48.176 --> 00:46:50.886 A:middle
7.5GB 的内存占用要好得多

00:46:51.516 --> 00:46:53.076 A:middle
但现在 我记得有件事

00:46:53.076 --> 00:46:55.126 A:middle
我想回去

00:46:55.126 --> 00:46:58.186 A:middle
先停止运行

00:46:58.186 --> 00:46:59.806 A:middle
我还是想回到

00:46:59.806 --> 00:47:03.556 A:middle
我的 filter() 方法

00:46:59.806 --> 00:47:03.556 A:middle
我的 filter() 方法

00:47:03.556 --> 00:47:05.456 A:middle
改变这个 UIBeginImageContext 代码

00:47:05.456 --> 00:47:06.746 A:middle
然后按照 Kyle 的建议去做

00:47:06.826 --> 00:47:08.206 A:middle
所以我要删除这段代码

00:47:08.746 --> 00:47:12.986 A:middle
然后添加新的滤镜

00:47:14.456 --> 00:47:16.126 A:middle
在这里

00:47:16.126 --> 00:47:18.136 A:middle
我要创建一个

00:47:18.136 --> 00:47:19.076 A:middle
UIGraphicsImageRenderer

00:47:19.356 --> 00:47:21.946 A:middle
我要在这个渲染器中

00:47:21.946 --> 00:47:24.136 A:middle
使用 CIFilter

00:47:24.786 --> 00:47:26.506 A:middle
来应用这个滤镜

00:47:26.956 --> 00:47:28.936 A:middle
让我们运行这段代码

00:47:29.306 --> 00:47:30.866 A:middle
希望它可以成功构建

00:47:30.866 --> 00:47:32.076 A:middle
然后看看是否会对我的内存使用

00:47:32.076 --> 00:47:33.876 A:middle
产生影响

00:47:35.316 --> 00:47:37.286 A:middle
让我们回到调试导航器

00:47:37.286 --> 00:47:39.616 A:middle
和内存报告中

00:47:40.586 --> 00:47:42.406 A:middle
再一次

00:47:42.406 --> 00:47:46.516 A:middle
我们回到土星图像

00:47:46.746 --> 00:47:50.306 A:middle
然后应用我们的滤镜

00:47:51.076 --> 00:47:51.766 A:middle
让我们来看看

00:47:51.766 --> 00:47:54.846 A:middle
这次的内存峰值是多少

00:47:54.846 --> 00:47:55.496 A:middle
98MB

00:47:56.066 --> 00:47:59.136 A:middle
这和上次基本是一样的

00:47:59.136 --> 00:48:00.206 A:middle
但是如果你仔细思考

00:47:59.136 --> 00:48:00.206 A:middle
但是如果你仔细思考

00:48:00.206 --> 00:48:01.666 A:middle
这个其实就是我所期望的结果

00:48:02.216 --> 00:48:03.496 A:middle
在这种情况下

00:48:03.496 --> 00:48:05.346 A:middle
我的图像仍然是

00:48:05.346 --> 00:48:07.006 A:middle
每个像素 4 个字节

00:48:07.006 --> 00:48:08.076 A:middle
所以我不会使用

00:48:08.076 --> 00:48:10.476 A:middle
这个新方法来节省内存

00:48:10.906 --> 00:48:12.176 A:middle
然而 如果有一个

00:48:12.176 --> 00:48:13.926 A:middle
节省内存的机会

00:48:14.406 --> 00:48:17.356 A:middle
例如 如果操作系统可以判断

00:48:17.356 --> 00:48:20.666 A:middle
图像可以每像素使用更少

00:48:20.666 --> 00:48:21.866 A:middle
或更多的字节

00:48:21.866 --> 00:48:23.156 A:middle
那么系统就可以做出正确的处理

00:48:23.156 --> 00:48:24.206 A:middle
我就不需要担心了

00:48:24.546 --> 00:48:25.886 A:middle
因此 在代码经过这些更改后

00:48:25.886 --> 00:48:28.636 A:middle
即使我没有看到很大的改进

00:48:28.636 --> 00:48:29.486 A:middle
我也知道它变得更好了

00:48:30.526 --> 00:48:33.246 A:middle
我还可以做更多

00:48:33.566 --> 00:48:35.956 A:middle
我想确保当 App 进入后台时

00:48:35.956 --> 00:48:37.686 A:middle
我们会卸载图像

00:48:37.686 --> 00:48:39.536 A:middle
而且我们不会在屏幕之外的视图中

00:48:39.536 --> 00:48:41.346 A:middle
显示任何图像

00:48:41.346 --> 00:48:42.286 A:middle
我还有很多可以做的

00:48:42.286 --> 00:48:44.026 A:middle
但是我对这些结果

00:48:44.026 --> 00:48:45.516 A:middle
已经很满意了

00:48:45.516 --> 00:48:46.896 A:middle
所以我想把它们送回给 James

00:48:47.156 --> 00:48:48.416 A:middle
我要抓取一个屏幕快照

00:48:48.416 --> 00:48:50.096 A:middle
并给 James 添加一点备注

00:48:50.096 --> 00:48:53.236 A:middle
让他知道

00:48:53.236 --> 00:48:55.716 A:middle
我对这一切是多么的满意

00:48:56.286 --> 00:48:57.476 A:middle
我想我们可以

00:48:57.476 --> 00:48:59.466 A:middle
给他发一个

00:49:01.516 --> 00:49:03.616 A:middle
星星眼的表情符号

00:49:04.526 --> 00:49:06.166 A:middle
希望 James 会对这些结果

00:49:06.166 --> 00:49:07.326 A:middle
感到满意

00:49:07.326 --> 00:49:11.876 A:middle
现在 我想请回 Kyle

00:49:11.876 --> 00:49:12.816 A:middle
他会帮我们整理一遍

00:49:13.326 --> 00:49:13.696 A:middle
谢谢大家

00:49:14.386 --> 00:49:16.386 A:middle
[ 掌声 ]

00:49:16.756 --> 00:49:17.186 A:middle
&gt;&gt; 谢谢 Kris

00:49:20.096 --> 00:49:20.526 A:middle
谢谢 Kris

00:49:21.566 --> 00:49:22.366 A:middle
太棒了

00:49:22.666 --> 00:49:24.096 A:middle
只做了一点点工作

00:49:24.326 --> 00:49:30.076 A:middle
我们就能大大减少内存的使用

00:49:30.786 --> 00:49:34.896 A:middle
总结起来 内存是有限的

00:49:34.896 --> 00:49:35.356 A:middle
也是共享的

00:49:36.516 --> 00:49:37.786 A:middle
我们使用得越多

00:49:37.786 --> 00:49:39.156 A:middle
系统就为其他 App 分配越少的内存

00:49:39.236 --> 00:49:40.076 A:middle
我们真的需要做一个好市民

00:49:40.076 --> 00:49:41.786 A:middle
并注意我们对内存的使用

00:49:41.786 --> 00:49:43.366 A:middle
只使用我们需要的内存

00:49:46.336 --> 00:49:47.706 A:middle
在调试时

00:49:47.706 --> 00:49:50.276 A:middle
Xcode 中的内存报告是至关重要的

00:49:50.636 --> 00:49:51.726 A:middle
当我们的 App 运行时我们就可以打开它

00:49:51.726 --> 00:49:52.756 A:middle
因为当我们监视它的时候

00:49:52.756 --> 00:49:54.516 A:middle
随着调试的进行

00:49:54.516 --> 00:49:57.206 A:middle
我们能注意到内存使用的消退

00:49:59.076 --> 00:50:01.076 A:middle
我们要确保 iOS

00:49:59.076 --> 00:50:01.076 A:middle
我们要确保 iOS

00:50:01.956 --> 00:50:03.496 A:middle
可以为我们选择图像格式

00:50:03.746 --> 00:50:06.156 A:middle
通过使用新的 UIImage 的

00:50:06.156 --> 00:50:08.766 A:middle
GraphicsRenderer API

00:50:08.766 --> 00:50:10.576 A:middle
我们可以从 SRGB 到 alpha 8 的转变过程中

00:50:10.846 --> 00:50:11.996 A:middle
节省 75% 的内存使用

00:50:11.996 --> 00:50:14.596 A:middle
这对蒙版和文本来说都很重要

00:50:16.376 --> 00:50:18.166 A:middle
除此之外 我们可以使用 ImageIO

00:50:18.936 --> 00:50:20.446 A:middle
来对图像进行下采样

00:50:21.176 --> 00:50:22.836 A:middle
它可以防止过高的内存峰值

00:50:22.836 --> 00:50:24.646 A:middle
相较于将 UIImage 绘制到

00:50:24.646 --> 00:50:25.836 A:middle
更小的环境中时

00:50:25.836 --> 00:50:26.776 A:middle
它也会更快

00:50:27.176 --> 00:50:30.856 A:middle
最后 我们要卸载

00:50:30.856 --> 00:50:32.706 A:middle
不在屏幕上的

00:50:32.706 --> 00:50:33.516 A:middle
大型图像和资源

00:50:33.886 --> 00:50:34.886 A:middle
使用这些内存是没有意义的

00:50:34.886 --> 00:50:36.836 A:middle
因为用户看不到它们

00:50:38.166 --> 00:50:39.936 A:middle
即使经历了所有这些努力

00:50:40.156 --> 00:50:40.896 A:middle
我们仍然没有完成

00:50:42.006 --> 00:50:44.216 A:middle
正如我们刚才看到的

00:50:44.326 --> 00:50:45.926 A:middle
使用 Memgraph 可以帮助我们

00:50:46.346 --> 00:50:47.606 A:middle
进一步了解发生了什么

00:50:47.606 --> 00:50:48.306 A:middle
并减少内存占用

00:50:48.686 --> 00:50:49.576 A:middle
结合 malloc_history

00:50:49.576 --> 00:50:50.906 A:middle
我们可以深入了解

00:50:50.906 --> 00:50:52.966 A:middle
内存的去向以及用途

00:50:54.026 --> 00:50:56.046 A:middle
所以我建议

00:50:56.046 --> 00:50:58.456 A:middle
大家能在讨论会后打开 malloc_history

00:50:58.456 --> 00:51:00.426 A:middle
分析你的工具

00:50:58.456 --> 00:51:00.426 A:middle
分析你的工具

00:51:00.426 --> 00:51:02.106 A:middle
然后开始深入研究

00:51:03.256 --> 00:51:04.726 A:middle
要了解更多的信息

00:51:04.726 --> 00:51:06.816 A:middle
你们可以查看我们的幻灯片

00:51:07.426 --> 00:51:11.956 A:middle
除此之外 如果你们还有其他问题的话

00:51:11.956 --> 00:51:13.786 A:middle
我们稍后会去技术实验室

00:51:15.116 --> 00:51:15.906 A:middle
谢谢大家 希望你们享受

00:51:15.906 --> 00:51:17.286 A:middle
WWDC 中的其他讨论会

00:51:18.516 --> 00:51:22.500 A:middle
[ 掌声 ]
