WEBVTT

00:00:17.784 --> 00:00:21.288 align:middle line:0
（Natural Language
框架简介 演讲713）

00:00:26.093 --> 00:00:27.461 align:middle line:-1
大家下午好

00:00:27.761 --> 00:00:30.364 align:middle line:-1
欢迎参加关于自然语言处理的演讲

00:00:30.964 --> 00:00:33.033 align:middle line:-2
今天我很高兴见到
这里聚集了这么多人

00:00:33.267 --> 00:00:36.937 align:middle line:-2
我很激动地向大家介绍一些
我们在NLP领域研发的一些

00:00:37.004 --> 00:00:39.606 align:middle line:-1
又新又酷炫的功能

00:00:40.607 --> 00:00:43.076 align:middle line:-2
我是Vivek 我将与同事
Doug Davidson

00:00:43.277 --> 00:00:44.711 align:middle line:-1
一起进行这次演讲

00:00:45.012 --> 00:00:45.979 align:middle line:-1
让我们开始吧

00:00:47.648 --> 00:00:50.551 align:middle line:-1
去年我们重点关注你的app

00:00:50.751 --> 00:00:53.921 align:middle line:-1
并告诉你如何利用NLP的力量

00:00:54.788 --> 00:00:57.291 align:middle line:-1
来让你的app变得更聪明 更智能

00:00:58.225 --> 00:01:00.127 align:middle line:-1
我们曾通过向你演示

00:00:58.225 --> 00:01:00.127 align:middle line:-1
我们曾通过向你演示

00:01:00.194 --> 00:01:03.764 align:middle line:-2
NSLinguisticTagger中
提供的NLP API来做到这一点

00:01:05.065 --> 00:01:08.869 align:middle line:-1
正如大多数人熟悉或曾使用过的那样

00:01:09.603 --> 00:01:14.141 align:middle line:-2
NSLinguisticTagger是一个基础类
它为NLP的实现提供了基本构建单元

00:01:14.641 --> 00:01:18.412 align:middle line:-2
从语言识别到语言组织
以及词类标注

00:01:18.745 --> 00:01:19.580 align:middle line:-1
等等

00:01:20.347 --> 00:01:22.683 align:middle line:-1
我们在NSLinguisticTagger中

00:01:22.749 --> 00:01:26.386 align:middle line:-2
通过在幕后无缝地融合
语言学和机器学习技术来实现这一点

00:01:26.987 --> 00:01:30.591 align:middle line:-2
这样 你作为一名开发人员
就可以专注于使用这些API

00:01:30.657 --> 00:01:32.125 align:middle line:-1
并专注于完成你的任务

00:01:33.160 --> 00:01:34.194 align:middle line:-1
这很棒

00:01:34.528 --> 00:01:36.063 align:middle line:-1
今年NLP新特性是什么呢？

00:01:37.364 --> 00:01:41.168 align:middle line:-2
我们很高兴地宣布
我们有一个全新的NLP框架

00:01:41.235 --> 00:01:42.503 align:middle line:-2
我们称它为
Natural Language

00:01:43.203 --> 00:01:48.041 align:middle line:-2
Natural Language将成为
在所有Apple平台上的设备上

00:01:48.108 --> 00:01:50.544 align:middle line:-1
实现NLP所有功能的一站式商店

00:01:51.545 --> 00:01:53.881 align:middle line:-2
Natural Language
有一些非常酷的功能

00:01:53.947 --> 00:01:55.449 align:middle line:-1
让我们谈谈其中的每一个

00:01:57.117 --> 00:02:00.387 align:middle line:-2
首先 它有一个
完全重新设计的API接口

00:01:57.117 --> 00:02:00.387 align:middle line:-2
首先 它有一个
完全重新设计的API接口

00:02:01.255 --> 00:02:04.358 align:middle line:-1
因此它支持NSLinguisticTagger过去以及

00:02:04.424 --> 00:02:08.529 align:middle line:-2
现在仍在使用的所有功能
但它用真正的Swift API

00:02:09.496 --> 00:02:10.464 align:middle line:-1
但还不仅如此

00:02:11.064 --> 00:02:13.734 align:middle line:-1
我们现在支持自定义的NLP模型

00:02:14.067 --> 00:02:18.172 align:middle line:-2
这些是你可以使用
Create ML创建

00:02:18.238 --> 00:02:21.041 align:middle line:-2
并使用Core ML API或
Natural Language进行部署的模型

00:02:22.676 --> 00:02:24.444 align:middle line:-2
我们在Natural Language中
支持的所有功能

00:02:24.511 --> 00:02:27.581 align:middle line:-2
所有机器学习NLP
都具有很好的性能

00:02:27.814 --> 00:02:31.118 align:middle line:-2
它针对Apple硬件和模型大小
进行了优化

00:02:32.352 --> 00:02:35.956 align:middle line:-1
最后 这一切都是完全私有的

00:02:36.156 --> 00:02:39.760 align:middle line:-2
使用Natural Language框架的
NLP中的所有机器学习过程

00:02:40.093 --> 00:02:42.496 align:middle line:-1
都在设备上完成以保护用户的隐私

00:02:42.963 --> 00:02:45.832 align:middle line:-1
这正是我们在Apple中为了实现

00:02:46.200 --> 00:02:49.469 align:middle line:-1
在设备上进行NLP而使用的技术

00:02:50.537 --> 00:02:53.774 align:middle line:-2
我来谈谈Natural Language的
这些特征

00:02:54.007 --> 00:02:55.809 align:middle line:-1
我们从Swift API开始

00:02:58.312 --> 00:03:01.648 align:middle line:-2
正如我所提到的
Natural Language支持

00:02:58.312 --> 00:03:01.648 align:middle line:-2
正如我所提到的
Natural Language支持

00:03:01.715 --> 00:03:03.217 align:middle line:-1
所有NSLinguisticTagger的基本构建块

00:03:03.517 --> 00:03:07.020 align:middle line:0
但使用更好 更易于使用的API

00:03:08.055 --> 00:03:11.124 align:middle line:0
为了演示其中的一部分API

00:03:11.191 --> 00:03:13.560 align:middle line:0
我将用一个假想app来说明它们

00:03:15.229 --> 00:03:18.398 align:middle line:0
我们假设你写的第一个app

00:03:19.666 --> 00:03:22.402 align:middle line:-2
作为该app的一部分
你实现了社交消息

00:03:22.469 --> 00:03:23.971 align:middle line:-1
或点对点消息功能

00:03:25.439 --> 00:03:27.574 align:middle line:-1
你在此app中创建的附加功能

00:03:27.641 --> 00:03:30.944 align:middle line:-1
是显示正确的贴纸

00:03:31.545 --> 00:03:35.482 align:middle line:-1
根据消息的内容 在这个例子中是

00:03:35.549 --> 00:03:38.051 align:middle line:-2
“现在太晚了 我很累了
我们明早再继续 晚安”

00:03:38.352 --> 00:03:40.053 align:middle line:-1
你的app会显示合适的贴纸

00:03:40.120 --> 00:03:42.556 align:middle line:-1
你解析了这段文字 然后显示贴纸

00:03:42.823 --> 00:03:44.992 align:middle line:-1
用户可以附加并发送它作为回应

00:03:45.425 --> 00:03:47.561 align:middle line:-2
这一切都很棒
这个app做得很好

00:03:47.628 --> 00:03:48.929 align:middle line:-1
你得到的好评如潮

00:03:49.897 --> 00:03:52.833 align:middle line:-2
但是你也会收到反馈
说你的app不支持多语言

00:03:53.734 --> 00:03:56.336 align:middle line:-1
现在有越来越多的双语用户

00:03:56.403 --> 00:03:58.772 align:middle line:-1
他们倾向于用几种不同的语言沟通

00:03:59.106 --> 00:04:01.241 align:middle line:-1
当你的app收到中文信息时

00:03:59.106 --> 00:04:01.241 align:middle line:-1
当你的app收到中文信息时

00:04:01.542 --> 00:04:03.043 align:middle line:-1
它根本不知道如何处理它

00:04:04.077 --> 00:04:06.747 align:middle line:-2
我们如何使用Natural Language
来克服这个问题呢？

00:04:08.348 --> 00:04:11.652 align:middle line:-2
我们可以通过对两个不同API的
简单调用来完成此操作

00:04:12.219 --> 00:04:13.887 align:middle line:-1
首先是语言识别

00:04:15.088 --> 00:04:16.456 align:middle line:-1
使用新的Natural Language框架

00:04:16.523 --> 00:04:18.725 align:middle line:-1
首先你要导入NaturalLanguage

00:04:19.793 --> 00:04:23.197 align:middle line:-2
你创建一个
NLLanguageRecognizer类的实例

00:04:24.431 --> 00:04:26.433 align:middle line:-1
你附上你想要处理的字符串

00:04:27.201 --> 00:04:29.636 align:middle line:-2
你只需调用
dominantLanguage API

00:04:30.404 --> 00:04:33.373 align:middle line:-1
现在这将根据字符串的语言

00:04:34.074 --> 00:04:35.742 align:middle line:-1
返回最可能的语言类别

00:04:36.777 --> 00:04:39.479 align:middle line:0
这里的输出是简体中文

00:04:40.480 --> 00:04:43.150 align:middle line:0
现在在Natural Language中
我们也支持一个新的API

00:04:43.483 --> 00:04:45.219 align:middle line:0
有些情况下你想知道

00:04:45.285 --> 00:04:47.988 align:middle line:0
特定字符串的较优猜测

00:04:48.622 --> 00:04:50.958 align:middle line:0
所以你想知道最可能的语言是哪些

00:04:51.024 --> 00:04:52.759 align:middle line:0
及其相关概率

00:04:53.160 --> 00:04:56.230 align:middle line:0
你可以设想
在几个不同的app中使用它

00:04:56.296 --> 00:04:59.366 align:middle line:0
这些app中包含多语言信息
所以你需要

00:04:59.433 --> 00:05:01.435 align:middle line:0
为这些可能的语言留有余地

00:04:59.433 --> 00:05:01.435 align:middle line:0
为这些可能的语言留有余地

00:05:02.269 --> 00:05:05.839 align:middle line:0
你可以用一个叫做languageHypotheses的
新API来做到这一点

00:05:06.139 --> 00:05:08.775 align:middle line:0
你可以指定返回语言的最大数量

00:05:08.842 --> 00:05:11.778 align:middle line:0
其将返回的是最可能语言的对象

00:05:11.845 --> 00:05:13.447 align:middle line:0
以及各自的概率

00:05:14.581 --> 00:05:16.683 align:middle line:0
为了对这个中文文本进行分词

00:05:16.984 --> 00:05:19.253 align:middle line:-1
你可以看到它的用法非常类似

00:05:20.053 --> 00:05:21.688 align:middle line:-2
你再次导入
NaturalLanguage

00:05:22.356 --> 00:05:24.458 align:middle line:-2
创建一个
NLTokenizer的实例

00:05:25.158 --> 00:05:28.428 align:middle line:-2
在这个实例中
将单位设为“word”

00:05:28.495 --> 00:05:30.664 align:middle line:-1
因为你要将字符串切分为单词

00:05:32.799 --> 00:05:33.901 align:middle line:-1
你传入了字符串

00:05:34.535 --> 00:05:38.105 align:middle line:-2
然后只需在对象的字符串上
调用tokens方法即可

00:05:39.039 --> 00:05:41.175 align:middle line:0
在这里你得到一个tokens数组

00:05:41.975 --> 00:05:45.345 align:middle line:0
现在有了这个tokens数组
你可以查找一个特定的token

00:05:45.412 --> 00:05:46.580 align:middle line:0
这里是“晚安”

00:05:47.381 --> 00:05:50.250 align:middle line:0
瞧 你的app现在支持多语言了

00:05:50.984 --> 00:05:54.421 align:middle line:-1
因此 你的app现在可以通过

00:05:54.488 --> 00:05:57.858 align:middle line:-2
简单的调用语言识别和分词API
来支持中文

00:05:59.059 --> 00:06:01.261 align:middle line:-2
让我们看看另一种
不同类型的API 我的意思是

00:05:59.059 --> 00:06:01.261 align:middle line:-2
让我们看看另一种
不同类型的API 我的意思是

00:06:01.328 --> 00:06:05.065 align:middle line:-2
语言识别和分词都很好
但我们也想使用

00:06:05.132 --> 00:06:07.501 align:middle line:-1
自动语音标记 命名实体识别等功能

00:06:08.035 --> 00:06:11.238 align:middle line:-2
我来演示一下
如何在我们的假想app中

00:06:11.305 --> 00:06:12.806 align:middle line:-1
使用命名实体识别API

00:06:14.341 --> 00:06:17.110 align:middle line:-2
这里有一个app
它是一个新闻推荐app

00:06:17.644 --> 00:06:20.514 align:middle line:-2
在你的app中
你的用户一直在阅读

00:06:20.581 --> 00:06:23.383 align:middle line:-2
很多关于皇室婚礼的事情
这是一个非常好奇的用户

00:06:23.450 --> 00:06:25.085 align:middle line:-1
他们想了解有关皇室婚礼的一切

00:06:25.752 --> 00:06:27.955 align:middle line:-2
他们已经在你的app中
浏览了很多页面

00:06:28.488 --> 00:06:31.592 align:middle line:-2
然后他们进入搜索栏
并输入“Harry”

00:06:32.326 --> 00:06:35.662 align:middle line:-1
然而却看到与他们一直在寻找的

00:06:35.729 --> 00:06:37.231 align:middle line:-1
完全不相关的东西

00:06:37.297 --> 00:06:39.199 align:middle line:-1
比如哈利波特等等

00:06:39.566 --> 00:06:44.705 align:middle line:-2
你想看到的是
与皇室婚礼有关的哈里王子

00:06:45.372 --> 00:06:47.674 align:middle line:-1
现在你可以在app中

00:06:47.741 --> 00:06:50.310 align:middle line:-2
通过使用命名实体识别API
来解决这个问题

00:06:51.378 --> 00:06:54.348 align:middle line:-2
正如我所提到的
这里的语法非常相似

00:06:54.414 --> 00:06:57.684 align:middle line:-2
你们中那些习惯使用
NSLinguisticTagger的人

00:06:57.751 --> 00:07:00.487 align:middle line:-2
应该觉得这看起来感觉很熟悉
但是它更容易

00:06:57.751 --> 00:07:00.487 align:middle line:-2
应该觉得这看起来感觉很熟悉
但是它更容易

00:07:00.554 --> 00:07:01.788 align:middle line:-1
记忆和使用

00:07:02.656 --> 00:07:03.957 align:middle line:-2
你导入
NaturalLanguage

00:07:04.892 --> 00:07:07.127 align:middle line:-2
你现在创建一个
NLTagger的实例

00:07:07.694 --> 00:07:10.030 align:middle line:-2
并指定scheme类型
为nameType

00:07:10.898 --> 00:07:12.199 align:middle line:-1
若你想添加词性标注功能

00:07:12.266 --> 00:07:14.868 align:middle line:-2
你需要指定该scheme类型
为lexical类

00:07:16.036 --> 00:07:18.539 align:middle line:-1
你再次指定要处理的字符串

00:07:19.439 --> 00:07:21.141 align:middle line:-1
在这个例子中

00:07:21.208 --> 00:07:24.611 align:middle line:-1
你将语言设置为英语

00:07:25.379 --> 00:07:26.747 align:middle line:-1
如果你不熟悉

00:07:26.813 --> 00:07:28.982 align:middle line:-1
或者你不确定语言是什么

00:07:29.149 --> 00:07:32.252 align:middle line:-2
Natural Language
会使用语言识别API

00:07:32.319 --> 00:07:34.922 align:middle line:-1
在底层自动识别该语言种类

00:07:36.190 --> 00:07:40.561 align:middle line:0
最后 你在刚创建的对象上
调用tags方法

00:07:40.794 --> 00:07:44.131 align:middle line:0
将unit参数设为word
并将scheme参数设为nameType

00:07:44.998 --> 00:07:48.669 align:middle line:0
你得到的输出是这里的人名

00:07:48.735 --> 00:07:51.538 align:middle line:0
哈里王子和梅格汉马克尔
以及地点为温莎

00:07:51.805 --> 00:07:54.241 align:middle line:0
现在 如果用户返回到搜索栏

00:07:54.741 --> 00:07:57.811 align:middle line:-1
基于用户浏览的内容信息

00:07:57.878 --> 00:08:00.914 align:middle line:-1
你可以显著提高app中的搜索体验

00:07:57.878 --> 00:08:00.914 align:middle line:-1
你可以显著提高app中的搜索体验

00:08:03.817 --> 00:08:06.920 align:middle line:-2
若想了解更多
关于如何使用这些API的信息

00:08:06.987 --> 00:08:09.990 align:middle line:-1
你可以参考开发者文档

00:08:10.390 --> 00:08:15.696 align:middle line:-2
我想强调的是我们虽然仍支持
NSLinguisticTagger

00:08:16.029 --> 00:08:18.498 align:middle line:-2
但NLP的未来是
Natural Language

00:08:18.565 --> 00:08:22.903 align:middle line:-2
因此我们建议并鼓励你
迁移到Natural Language

00:08:22.970 --> 00:08:26.240 align:middle line:-2
以便可以在此框架中获得
NLP的所有最新功能

00:08:27.341 --> 00:08:30.777 align:middle line:-1
现在让我们思考另一种情况

00:08:30.944 --> 00:08:32.913 align:middle line:-1
你有一个app的想法

00:08:33.614 --> 00:08:35.948 align:middle line:-1
或者你需要在你的app中添加一个

00:08:36.316 --> 00:08:38.085 align:middle line:-2
Natural Language
不支持的功能

00:08:39.586 --> 00:08:40.419 align:middle line:-1
你该怎么办？

00:08:41.455 --> 00:08:45.025 align:middle line:-1
你当然可以创造这些东西 这很棒

00:08:45.292 --> 00:08:48.228 align:middle line:-2
但如果我们给你提供工具
来使这变得更容易呢？

00:08:50.931 --> 00:08:56.003 align:middle line:-2
为了讨论自定义NLP模型
以及如何使用Create ML构建自定义NLP模型

00:08:56.270 --> 00:08:59.873 align:middle line:-2
并使用这些在Natural Language中
实质上为Core ML模型的后续模型

00:08:59.940 --> 00:09:02.809 align:middle line:-2
我将把这个话题交给
Doug Davidson

00:08:59.940 --> 00:09:02.809 align:middle line:-2
我将把这个话题交给
Doug Davidson

00:09:09.750 --> 00:09:10.584 align:middle line:-1
感谢Vivek

00:09:11.118 --> 00:09:15.656 align:middle line:-2
我对新的Natural Language框架
感到非常激动

00:09:15.722 --> 00:09:19.526 align:middle line:-1
但我最感兴趣的部分是

00:09:19.593 --> 00:09:21.361 align:middle line:-1
对构建和使用定制化模型的支持

00:09:21.595 --> 00:09:22.663 align:middle line:-1
为什么呢？

00:09:23.397 --> 00:09:26.733 align:middle line:-1
我想让你考虑一下你的app

00:09:27.167 --> 00:09:30.871 align:middle line:-2
这可能是你已编写的app
或你想要编写的app

00:09:31.405 --> 00:09:35.008 align:middle line:-1
并考虑如果它们能够

00:09:35.075 --> 00:09:39.646 align:middle line:-2
更好理解他们所处理的文本
这将如何改善用户体验

00:09:40.380 --> 00:09:44.852 align:middle line:-1
然后想一想你自己是如何分析文本的

00:09:44.985 --> 00:09:48.088 align:middle line:-1
也许你看到一些样板文本

00:09:48.488 --> 00:09:49.990 align:middle line:-1
你从中学习一些信息

00:09:50.691 --> 00:09:55.262 align:middle line:-2
然后明白发生了什么
接着你就可以看一段其它的文本

00:09:55.329 --> 00:09:58.432 align:middle line:-2
并且马上可以理解
它说的是什么

00:09:59.333 --> 00:10:00.767 align:middle line:-1
那么 如果是这样的话

00:09:59.333 --> 00:10:00.767 align:middle line:-1
那么 如果是这样的话

00:10:00.934 --> 00:10:04.605 align:middle line:-1
你就有一定可能

00:10:05.572 --> 00:10:07.274 align:middle line:-1
通过设计一个机器学习模型

00:10:07.774 --> 00:10:13.347 align:middle line:-1
给它一些例子以便训练和学习

00:10:13.780 --> 00:10:17.150 align:middle line:-2
来在你的app中自动为你
进行这种分析 并最终训练出一个

00:10:17.684 --> 00:10:19.219 align:middle line:-1
能够进行这类分析的模型

00:10:19.920 --> 00:10:25.559 align:middle line:-2
当前NLP有很多种类的
机器学习模型

00:10:25.626 --> 00:10:27.194 align:middle line:-1
并且有许多不同的方式来训练它

00:10:27.261 --> 00:10:30.030 align:middle line:-2
你们中许多人可能已经
在训练机器学习模型

00:10:30.330 --> 00:10:34.468 align:middle line:-1
但我们这里的任务是寻找一种

00:10:34.535 --> 00:10:37.671 align:middle line:-1
让这种训练变得极其简单

00:10:38.372 --> 00:10:40.340 align:middle line:-1
并能够与Natural Language框架和API

00:10:40.641 --> 00:10:43.210 align:middle line:-1
整合得非常好的方法

00:10:43.510 --> 00:10:48.081 align:middle line:-2
考虑到这一点
我们现在支持两种类型的模型

00:10:48.282 --> 00:10:52.119 align:middle line:-2
我们认为这些模型能够
支持各种各样的功能

00:10:52.486 --> 00:10:54.955 align:middle line:-2
且能与NLTagger中的范式
很好地协同工作

00:10:55.022 --> 00:10:58.492 align:middle line:-1
即将标签app于文本片段

00:10:58.759 --> 00:11:02.429 align:middle line:-1
我们支持的第一个模型是文本分类器

00:10:58.759 --> 00:11:02.429 align:middle line:-1
我们支持的第一个模型是文本分类器

00:11:02.796 --> 00:11:03.630 align:middle line:0
这个…

00:11:03.697 --> 00:11:08.235 align:middle line:0
文本分类器读取一块文本
可能是一个句子或一个段落

00:11:08.302 --> 00:11:11.405 align:middle line:0
或整个文档 并为其打上一个标签

00:11:11.738 --> 00:11:15.976 align:middle line:0
我们现有的API中的例子
是语言识别

00:11:16.043 --> 00:11:17.377 align:middle line:0
脚本识别

00:11:18.245 --> 00:11:21.215 align:middle line:0
我们支持的第二种模型是单词标记器

00:11:21.648 --> 00:11:26.653 align:middle line:0
一个单词标记器将一个句子
视为一个单词序列

00:11:26.920 --> 00:11:31.225 align:middle line:0
然后根据上下文
为句子中的每个单词打上标签

00:11:31.458 --> 00:11:35.696 align:middle line:0
现有API中的例子
包括词性标注

00:11:35.762 --> 00:11:37.264 align:middle line:0
和命名实体识别

00:11:37.598 --> 00:11:43.337 align:middle line:0
但这些都是这类模型的通用示例

00:11:44.004 --> 00:11:45.906 align:middle line:0
如果你在app中
有一个特殊用途模型

00:11:45.973 --> 00:11:48.876 align:middle line:0
你可以用他们做更多的事情

00:11:48.942 --> 00:11:49.810 align:middle line:0
让我给你

00:11:49.877 --> 00:11:51.478 align:middle line:-1
一些假设的例子

00:11:51.912 --> 00:11:56.283 align:middle line:-2
对于文本分类
假设你正在处理用户评论

00:11:56.350 --> 00:11:58.118 align:middle line:-1
你想自动知道

00:11:58.352 --> 00:12:01.288 align:middle line:-1
给定的评论是正面评论

00:11:58.352 --> 00:12:01.288 align:middle line:-1
给定的评论是正面评论

00:12:01.588 --> 00:12:03.857 align:middle line:-1
还是负面评论或介于两者之间的地方

00:12:04.291 --> 00:12:06.960 align:middle line:-2
这是你可以通过
训练一个文本分类器来做到的事情

00:12:07.027 --> 00:12:08.595 align:middle line:-1
这属于情感分类

00:12:10.464 --> 00:12:13.567 align:middle line:-1
或者假设你有文章或文章摘要

00:12:13.634 --> 00:12:17.137 align:middle line:-1
甚至只是文章标题

00:12:17.504 --> 00:12:20.274 align:middle line:-1
而你想根据你最喜欢的主题分类方案

00:12:20.674 --> 00:12:22.376 align:middle line:-1
自动确定它们属于哪个主题

00:12:22.709 --> 00:12:25.045 align:middle line:-1
这也是你可以训练

00:12:25.779 --> 00:12:28.115 align:middle line:-1
一个文本分类器为你做的事情

00:12:30.050 --> 00:12:34.388 align:middle line:-2
或者再进一步
假设你正在写一个自动旅行代理

00:12:34.655 --> 00:12:37.124 align:middle line:-1
当你收到客户的请求时

00:12:37.191 --> 00:12:40.561 align:middle line:-2
你想知道的第一件事可能是
他们问的是什么

00:12:40.727 --> 00:12:44.331 align:middle line:-2
是酒店还是餐馆或是航班
还是任何其他你可以处理的内容

00:12:45.065 --> 00:12:49.236 align:middle line:-2
这是你可以训练一个文本分类器
来替你回答的事情

00:12:50.904 --> 00:12:52.506 align:middle line:-1
继续说单词标记

00:12:53.040 --> 00:12:57.711 align:middle line:-1
我们提供了能为许多语言

00:12:57.778 --> 00:13:01.815 align:middle line:-2
做词性标注的单词标记器
但假设你碰巧需要

00:12:57.778 --> 00:13:01.815 align:middle line:-2
做词性标注的单词标记器
但假设你碰巧需要

00:13:01.882 --> 00:13:05.886 align:middle line:-2
针对某种我们尚未支持的语言
做词性标注

00:13:06.420 --> 00:13:10.924 align:middle line:-2
而有了自定义模型的支持 你就可以
训练一个单词标记器为你完成这件事

00:13:12.259 --> 00:13:14.261 align:middle line:-1
或者命名实体识别

00:13:14.728 --> 00:13:16.730 align:middle line:-1
我们提供了内置的命名实体识别功能

00:13:16.797 --> 00:13:20.634 align:middle line:-1
它能够识别人名、地名和组织名称

00:13:21.368 --> 00:13:22.936 align:middle line:-2
但若你对其它类型名字
特别感兴趣

00:13:23.003 --> 00:13:26.173 align:middle line:-1
而这类名字我们碰巧不支持

00:13:26.473 --> 00:13:28.575 align:middle line:-1
例如产品名称

00:13:29.009 --> 00:13:31.912 align:middle line:-2
你可以训练你自己的
自定义命名实体识别器

00:13:31.979 --> 00:13:36.383 align:middle line:-1
作为可以识别你特别感兴趣的

00:13:36.450 --> 00:13:38.886 align:middle line:-1
名称或其他术语的单词标记器

00:13:40.587 --> 00:13:43.590 align:middle line:-1
再者 对于你的自动旅行代理

00:13:43.657 --> 00:13:45.726 align:middle line:-1
一旦你知道用户在问什么

00:13:46.159 --> 00:13:48.161 align:middle line:-1
可能你想知道的下一件事是

00:13:48.228 --> 00:13:50.464 align:middle line:-1
他们的请求中有哪些相关信息

00:13:50.597 --> 00:13:54.434 align:middle line:-2
例如 如果这是航班请求
他们想从哪里飞去哪里

00:13:55.502 --> 00:14:00.908 align:middle line:-2
单词标记器可以
识别句子中的各种条件

00:13:55.502 --> 00:14:00.908 align:middle line:-2
单词标记器可以
识别句子中的各种条件

00:14:02.309 --> 00:14:04.444 align:middle line:0
又或者假设有另一个app

00:14:04.511 --> 00:14:07.581 align:middle line:0
你需要把一个句子分成若干短语

00:14:07.648 --> 00:14:10.617 align:middle line:0
名词短语、动词短语、命题短语

00:14:10.984 --> 00:14:15.589 align:middle line:0
有了适当的标签 你可以训练
一个单词标记器来做到这一点

00:14:15.656 --> 00:14:22.029 align:middle line:-2
以及许多其他类型的
可以用标签来表达的任务

00:14:22.095 --> 00:14:26.600 align:middle line:-2
为文本块打上标签
无论其是序列中的单词

00:14:26.667 --> 00:14:29.903 align:middle line:-1
还是文本分类器中的文本块

00:14:33.674 --> 00:14:36.944 align:middle line:-1
这些都是有监督机器学习模型

00:14:37.010 --> 00:14:40.047 align:middle line:-1
所以总是包括两个阶段

00:14:40.214 --> 00:14:43.684 align:middle line:-2
第一阶段是训练
第二阶段是推理

00:14:43.750 --> 00:14:47.721 align:middle line:-1
训练是你在开发过程中需要做的部分

00:14:48.188 --> 00:14:51.058 align:middle line:-1
你将带标签的训练数据

00:14:51.892 --> 00:14:55.896 align:middle line:-2
输入Create ML
并生成一个模型

00:14:57.231 --> 00:15:00.367 align:middle line:0
推理就是当你在运行时

00:14:57.231 --> 00:15:00.367 align:middle line:0
推理就是当你在运行时

00:15:00.434 --> 00:15:04.538 align:middle line:0
将该模型整合到你的app中后
所发生的事情

00:15:04.605 --> 00:15:07.407 align:middle line:0
当它遇到来自用户的一些数据时

00:15:07.808 --> 00:15:09.176 align:middle line:0
它会分析这些数据

00:15:09.243 --> 00:15:11.311 align:middle line:0
并预测适当的标签

00:15:12.012 --> 00:15:13.847 align:middle line:0
让我们看看这些阶段是如何工作的

00:15:14.948 --> 00:15:18.852 align:middle line:-2
让我们从训练开始
而训练总是从数据开始

00:15:19.419 --> 00:15:23.557 align:middle line:-1
你将你的训练数据输入到

00:15:23.624 --> 00:15:29.429 align:middle line:-2
Playground或脚本
包装器中的Create ML

00:15:30.264 --> 00:15:32.199 align:middle line:-2
如你在Create ML演讲中
所见

00:15:32.633 --> 00:15:34.101 align:middle line:-1
Create ML在底层调用

00:15:34.168 --> 00:15:37.304 align:middle line:-2
Natural Language
框架来进行训练

00:15:38.005 --> 00:15:44.545 align:middle line:-2
其输出的是一个Core ML模型
并已针对设备上的使用进行了优化

00:15:45.979 --> 00:15:48.348 align:middle line:-1
让我们看看这些数据是什么样子的

00:15:49.750 --> 00:15:52.920 align:middle line:-2
Create ML支持
多种不同的数据格式

00:15:53.987 --> 00:15:58.692 align:middle line:-2
在这里我们使用JSON显示数据
因为JSON使事情变得非常清晰

00:16:00.093 --> 00:16:03.830 align:middle line:-1
这是一部分训练数据

00:16:03.897 --> 00:16:07.668 align:middle line:-2
被用来训练文本分类器
在这里也是一个情感分类器

00:16:07.901 --> 00:16:10.103 align:middle line:-1
每个训练的样例

00:16:11.104 --> 00:16:12.139 align:middle line:-1
比如这个

00:16:12.206 --> 00:16:15.142 align:middle line:-1
都由两部分组成 一块文本

00:16:15.509 --> 00:16:18.111 align:middle line:-1
以及与其对应的标签

00:16:18.679 --> 00:16:21.415 align:middle line:-1
例如这是一个表达正面情感的句子

00:16:21.481 --> 00:16:24.852 align:middle line:-2
所以其标签为“积极”
但你可以选择你想要的任何标签

00:16:27.754 --> 00:16:33.193 align:middle line:-2
当你开始使用Create ML时
Create ML提供了一个

00:16:33.260 --> 00:16:36.930 align:middle line:-2
极其简单的只需几行代码
就可以训练模型的方法

00:16:36.997 --> 00:16:42.803 align:middle line:-2
第一行 我们只是从JSON文件
加载我们的训练数据

00:16:42.870 --> 00:16:48.976 align:middle line:-2
我们给它一个JSON文件的URL
用它创建Create ML数据表

00:16:49.943 --> 00:16:55.649 align:middle line:-2
然后仅在一行代码中 使用这些数据
创建并训练一个文本分类器

00:16:55.782 --> 00:16:59.686 align:middle line:-2
你需要告诉它的只是字段名称
在这里是“文本”和“标签”

00:17:01.455 --> 00:17:02.589 align:middle line:-1
一旦训练完成

00:17:02.656 --> 00:17:05.291 align:middle line:-2
你就可以用一行代码
将该模型写入磁盘

00:17:07.261 --> 00:17:09.630 align:middle line:-1
训练一个单词标记器的方法与这类似

00:17:09.963 --> 00:17:12.199 align:middle line:-1
只是数据稍微复杂一些

00:17:12.266 --> 00:17:15.068 align:middle line:-1
因为每个示例不是一块单独的文本

00:17:15.301 --> 00:17:17.838 align:middle line:-1
而是一个token序列

00:17:18.704 --> 00:17:21.375 align:middle line:-1
并且标签也是一个

00:17:21.441 --> 00:17:24.611 align:middle line:-2
与token序列具有相同数量标签
的序列 每个标签对应一token

00:17:24.944 --> 00:17:29.883 align:middle line:-2
例如 这是训练
一个单词标记器的数据

00:17:29.950 --> 00:17:35.722 align:middle line:-2
它可以进行命名实体识别每个单词
即每个token 都有一个标签

00:17:36.023 --> 00:17:42.095 align:middle line:-2
若是“NONE”则不是一个名称
若是“ORG”则是一个组织名称

00:17:42.162 --> 00:17:45.532 align:middle line:-1
若是“PROD”则是产品名称

00:17:45.599 --> 00:17:47.901 align:middle line:-1
以及还有许多你想要识别的其他标签

00:17:48.268 --> 00:17:49.937 align:middle line:-1
每个token都有一个标签

00:17:50.737 --> 00:17:55.475 align:middle line:-1
每个样本由一个token序列

00:17:55.542 --> 00:17:57.044 align:middle line:-1
和它所对应的标签组成

00:17:58.579 --> 00:18:02.983 align:middle line:-2
用来训练它的Create ML
几乎是完全一样的

00:17:58.579 --> 00:18:02.983 align:middle line:-2
用来训练它的Create ML
几乎是完全一样的

00:18:03.951 --> 00:18:08.355 align:middle line:-2
你将训练数据
从JSON加载到数据表中

00:18:10.190 --> 00:18:13.927 align:middle line:-2
然后你创建并训练
一个WordTagger对象

00:18:13.994 --> 00:18:15.429 align:middle line:-1
而非之前的文本分类器对象

00:18:15.863 --> 00:18:17.931 align:middle line:-1
然后将其写入磁盘

00:18:18.298 --> 00:18:23.504 align:middle line:-2
Create ML中还有许多
其他选项和API可以使用

00:18:23.570 --> 00:18:25.305 align:middle line:-1
我鼓励你 如果你还没有的话

00:18:25.372 --> 00:18:28.876 align:middle line:-2
看看昨天举办的
Create ML演讲

00:18:28.942 --> 00:18:32.246 align:middle line:-2
以及Create ML文档
以获取更多信息

00:18:33.046 --> 00:18:36.550 align:middle line:0
现在 一旦你训练好了模型
我们就可以进入推理部分

00:18:36.717 --> 00:18:40.120 align:middle line:0
你把你的模型拖到
你的Xcode项目中

00:18:40.187 --> 00:18:44.091 align:middle line:0
Xcode将编译并将其
包含在你的app资源中

00:18:44.458 --> 00:18:48.929 align:middle line:0
然后你在运行时做什么呢？
记住这是一个Core ML模型

00:18:48.996 --> 00:18:50.998 align:middle line:0
你可以像使用其他任何
Core ML模型一样使用它

00:18:51.431 --> 00:18:56.270 align:middle line:-2
但有趣的是这些模型能够很好地
与Natural Language API共同工作

00:18:56.570 --> 00:19:01.441 align:middle line:-1
就像是我们自己的

00:18:56.570 --> 00:19:01.441 align:middle line:-1
就像是我们自己的

00:19:01.508 --> 00:19:05.279 align:middle line:-1
提供了NLP功能的内置模型一样

00:19:06.613 --> 00:19:07.447 align:middle line:-1
所以…

00:19:08.115 --> 00:19:10.384 align:middle line:-1
数据将进来

00:19:11.251 --> 00:19:15.856 align:middle line:0
你将它传递给Natural Language
其将使用该模型执行必要的工作

00:19:15.923 --> 00:19:19.993 align:middle line:0
来找出所有的标签

00:19:20.060 --> 00:19:23.830 align:middle line:0
然后为一个分类器传回单个标签

00:19:23.897 --> 00:19:27.167 align:middle line:0
或为一个标记器传回一个标签序列

00:19:30.370 --> 00:19:33.740 align:middle line:-2
你如何在Natural Language API中
做到这一点呢？

00:19:34.341 --> 00:19:37.945 align:middle line:-1
你首先需要做的是

00:19:38.011 --> 00:19:41.348 align:middle line:-2
在app资源中找到该模型
然后使用它创建

00:19:41.415 --> 00:19:44.852 align:middle line:-2
Natural Language中的一个类
NLModel的实例

00:19:45.986 --> 00:19:48.822 align:middle line:-1
然后 你可以用它做的最简单的事

00:19:48.889 --> 00:19:53.861 align:middle line:-2
至少对于一个分类器来说 就是向它
输入一个文本块并且获取一个标签

00:19:54.695 --> 00:19:59.066 align:middle line:-1
但更有趣的是你可以

00:19:59.132 --> 00:20:00.434 align:middle line:-1
在NLTagger中使用这些模型

00:19:59.132 --> 00:20:00.434 align:middle line:-1
在NLTagger中使用这些模型

00:20:01.468 --> 00:20:05.105 align:middle line:-1
其方式与你使用

00:20:05.639 --> 00:20:07.708 align:middle line:-1
内置模型中的功能的方式完全相同

00:20:08.175 --> 00:20:09.543 align:middle line:-1
让我向你展示这如何工作

00:20:10.344 --> 00:20:13.647 align:middle line:-1
除了我们现有的标签方案

00:20:13.714 --> 00:20:16.350 align:middle line:-1
像命名实体识别 词性标注

00:20:16.817 --> 00:20:20.020 align:middle line:-2
你可以创建自己的自定义标签方案
并为其命名

00:20:21.788 --> 00:20:23.924 align:middle line:-1
然后你可以创建一个包含任意数量的

00:20:24.424 --> 00:20:26.860 align:middle line:-1
不同标签方案的标记器

00:20:27.094 --> 00:20:29.796 align:middle line:-2
它可以包括自定义标签方案
或任何内置的标签方案

00:20:29.863 --> 00:20:30.697 align:middle line:-1
或者它们全部

00:20:32.266 --> 00:20:35.302 align:middle line:-1
然后你所要做的就是告诉标记器

00:20:35.369 --> 00:20:38.272 align:middle line:-1
使用自定义模型作为自定义标签方案

00:20:39.873 --> 00:20:42.776 align:middle line:-1
接下来你只需要正常使用它

00:20:43.210 --> 00:20:46.647 align:middle line:-1
你将一个字符串传给标记器

00:20:46.713 --> 00:20:48.115 align:middle line:-1
然后你可以

00:20:49.650 --> 00:20:53.620 align:middle line:-2
以最合适你的模型的单位
遍历这些标签

00:20:54.488 --> 00:20:56.990 align:middle line:-1
标记器会自动

00:20:57.257 --> 00:21:01.094 align:middle line:-2
根据需要调用该模型以获取标签
并将标签返回给你

00:20:57.257 --> 00:21:01.094 align:middle line:-2
根据需要调用该模型以获取标签
并将标签返回给你

00:21:01.161 --> 00:21:05.399 align:middle line:-2
并且还会执行NLTagger
自动执行的所有其他操作

00:21:05.465 --> 00:21:08.635 align:middle line:-1
像语言识别、分词等等

00:21:10.070 --> 00:21:14.107 align:middle line:-2
我想通过一个简单的例子
向你展示这一点

00:21:14.641 --> 00:21:21.014 align:middle line:-2
这个假设的例子是这样一个app
用户可以用它来

00:21:21.081 --> 00:21:24.251 align:middle line:-1
保存他们所遇到的文章的书签

00:21:24.318 --> 00:21:26.253 align:middle line:-1
用户可能打算稍后阅读这些文章

00:21:27.187 --> 00:21:30.357 align:middle line:-1
但是这个app目前的问题是

00:21:30.424 --> 00:21:32.459 align:middle line:-1
这个书签列表

00:21:32.526 --> 00:21:35.095 align:middle line:-1
只是一个未经组织的长列表

00:21:35.529 --> 00:21:36.597 align:middle line:-1
若我们可以自动分类这些文章

00:21:36.663 --> 00:21:39.800 align:middle line:-1
并根据主题将它们组织起来

00:21:40.167 --> 00:21:42.803 align:middle line:-1
这不是很好吗？

00:21:43.504 --> 00:21:46.340 align:middle line:-2
我们可以训练一个分类器
来为我们做这件事

00:21:47.040 --> 00:21:49.743 align:middle line:-1
另一件事是 当我们看这些文章时

00:21:49.810 --> 00:21:51.478 align:middle line:-1
它们是一段很长的文本

00:21:52.346 --> 00:21:56.750 align:middle line:-2
也许我们想在这些文章中
突出显示一些有趣的事情

00:21:56.817 --> 00:21:58.385 align:middle line:-1
比如名字

00:21:58.752 --> 00:22:02.823 align:middle line:-1
我们已经对人名、地名和组织名称

00:21:58.752 --> 00:22:02.823 align:middle line:-1
我们已经对人名、地名和组织名称

00:22:02.890 --> 00:22:05.425 align:middle line:-1
提供了内置的命名实体识别功能

00:22:06.260 --> 00:22:09.162 align:middle line:-1
但也许我们也想突出显示产品的名称

00:22:09.229 --> 00:22:13.467 align:middle line:-2
我们可以训练一个自定义单词标记器
来为我们识别这些名称

00:22:15.369 --> 00:22:17.271 align:middle line:-1
现在让我切换到演示机

00:22:22.809 --> 00:22:25.379 align:middle line:-1
这是我们在

00:22:25.445 --> 00:22:29.149 align:middle line:-2
app任何自然语言处理技术
之前的app

00:22:29.383 --> 00:22:33.153 align:middle line:-2
正如你所看到的
这只是一个长长的文章列表

00:22:33.220 --> 00:22:36.490 align:middle line:-1
以及我们右边文章的大块文本

00:22:36.557 --> 00:22:37.491 align:middle line:-1
让我们来解决这个问题

00:22:38.759 --> 00:22:41.061 align:middle line:-1
让我们进入…

00:22:42.162 --> 00:22:46.667 align:middle line:-1
训练模型的第一部分是数据

00:22:47.167 --> 00:22:50.671 align:middle line:-2
幸运的是 我在Apple有一些
非常努力的同事

00:22:50.737 --> 00:22:54.508 align:middle line:-2
他们收集了一些训练数据
来让我训练这两个模型

00:22:54.741 --> 00:22:57.811 align:middle line:-1
第一个模型是一个文本分类器

00:22:58.145 --> 00:23:00.480 align:middle line:-1
它将根据主题对文章进行分类

00:22:58.145 --> 00:23:00.480 align:middle line:-1
它将根据主题对文章进行分类

00:23:00.848 --> 00:23:03.217 align:middle line:-1
这是一部分训练数据的样子

00:23:03.717 --> 00:23:09.523 align:middle line:-2
每个训练示例都包括一个文本块
和对应主题的适当标签

00:23:09.590 --> 00:23:12.626 align:middle line:-1
娱乐、政治、体育等等

00:23:15.495 --> 00:23:20.601 align:middle line:-2
我还有一些用来训练单词标记器的
训练数据

00:23:21.235 --> 00:23:25.839 align:middle line:-2
这个标记器将被用来
识别句子中的产品名称

00:23:26.206 --> 00:23:28.175 align:middle line:-1
这些训练数据非常简单

00:23:28.675 --> 00:23:33.947 align:middle line:-1
每个例子都包含一个token序列

00:23:34.014 --> 00:23:37.885 align:middle line:-2
以及一个标签序列 每个标签
要么是“NONE” 代表非产品名

00:23:37.951 --> 00:23:41.388 align:middle line:-1
要么是“PROD” 代表是产品名

00:23:43.624 --> 00:23:46.493 align:middle line:-1
我们试着用这些数据进行训练

00:23:47.160 --> 00:23:48.896 align:middle line:-1
我想要做的第一件事

00:23:49.663 --> 00:23:54.067 align:middle line:-2
是启动一个运行Create ML
的Playground

00:23:54.935 --> 00:23:57.604 align:middle line:-1
这个Playground将会加载

00:23:58.372 --> 00:24:01.542 align:middle line:-1
我的产品单词标记器

00:23:58.372 --> 00:24:01.542 align:middle line:-1
我的产品单词标记器

00:24:01.742 --> 00:24:05.279 align:middle line:-2
它会加载训练数据
从中创建一个单词标记器

00:24:05.879 --> 00:24:08.348 align:middle line:-1
并将其写入磁盘

00:24:09.483 --> 00:24:10.817 align:middle line:-1
现在让我们运行它

00:24:11.151 --> 00:24:16.056 align:middle line:0
它加载了数据 我们在底层

00:24:16.123 --> 00:24:19.126 align:middle line:0
自动处理了所有的分词 特征提取
以及训练过程

00:24:19.459 --> 00:24:21.795 align:middle line:0
我们实现了这个训练过程
这是一个相当小的模型

00:24:22.162 --> 00:24:28.302 align:middle line:0
所以它不需要很长时间来训练
我已经将其设置为

00:24:28.368 --> 00:24:32.906 align:middle line:0
自动将我的模型保存到我的桌面上
它就在那里

00:24:36.109 --> 00:24:37.544 align:middle line:-1
好的 这是其中一个模型

00:24:38.579 --> 00:24:42.850 align:middle line:-2
这里有另一个Playground
来训练我的文本分类器

00:24:43.116 --> 00:24:46.153 align:middle line:-2
如你所见 它看起来非常相似
加载训练数据

00:24:47.421 --> 00:24:50.424 align:middle line:-2
从中创建一个文本分类器
并将其写入磁盘

00:24:51.692 --> 00:24:52.826 align:middle line:-1
现在运行它

00:24:53.393 --> 00:24:59.266 align:middle line:0
同样 Natural Language
自动加载所有数据对其进行分词

00:24:59.633 --> 00:25:00.901 align:middle line:0
并从中提取特征

00:24:59.633 --> 00:25:00.901 align:middle line:0
并从中提取特征

00:25:01.201 --> 00:25:04.471 align:middle line:0
这是一个更大的模型
训练需要几分钟

00:25:04.538 --> 00:25:07.574 align:middle line:0
我们让它跑去吧 同时

00:25:08.175 --> 00:25:12.112 align:middle line:-2
我们看看在运行时
必须用到的一些代码

00:25:12.713 --> 00:25:16.617 align:middle line:-2
我写了两个非常小的类
来完成我在运行时需要做的事情

00:25:17.117 --> 00:25:23.857 align:middle line:-2
第一个通过在我的app资源中
找到该模型来使用文本分类器

00:25:24.157 --> 00:25:25.859 align:middle line:-1
并为其创建一个NLModel对象

00:25:26.793 --> 00:25:29.162 align:middle line:-1
然后 当我碰到一篇文章时

00:25:30.430 --> 00:25:31.899 align:middle line:-1
我只是让模型返回

00:25:31.965 --> 00:25:36.637 align:middle line:-2
为该文章预测的标签
而这就是它的全部了

00:25:38.472 --> 00:25:43.577 align:middle line:-1
使用单词标记器的代码稍多一些

00:25:44.144 --> 00:25:47.214 align:middle line:-2
正如你之前所见
我有一个实现产品名称识别的

00:25:47.948 --> 00:25:50.350 align:middle line:-1
自定义标签方案

00:25:50.918 --> 00:25:54.621 align:middle line:-1
我真正感兴趣的唯一标签是产品标签

00:25:54.688 --> 00:25:56.890 align:middle line:-1
我为此创建了一个自定义标签

00:25:58.325 --> 00:26:01.962 align:middle line:-2
同样 我必须在捆绑资源中
找到该模型

00:25:58.325 --> 00:26:01.962 align:middle line:-2
同样 我必须在捆绑资源中
找到该模型

00:26:03.030 --> 00:26:04.498 align:middle line:-1
为它创建一个NLModel对象

00:26:05.232 --> 00:26:06.733 align:middle line:-1
然后创建一个NLTagger

00:26:07.067 --> 00:26:10.304 align:middle line:-2
在这个NLTagger中
我指定了两个方案

00:26:10.370 --> 00:26:15.509 align:middle line:-2
第一种是内置名称类型方案
用来进行命名实体识别

00:26:15.776 --> 00:26:18.412 align:middle line:-1
第二个是我的自定义产品标签方案

00:26:18.478 --> 00:26:20.681 align:middle line:-1
它们都以完全相同的方式运行

00:26:21.548 --> 00:26:23.650 align:middle line:-1
然后 我只需让那个标记器

00:26:23.717 --> 00:26:26.820 align:middle line:-2
将我的自定义模型
用于我的自定义方案

00:26:27.721 --> 00:26:29.523 align:middle line:-1
现在 如果我要支持多种语言

00:26:29.590 --> 00:26:32.326 align:middle line:-1
我可能会在这个方案中有多个模型

00:26:34.528 --> 00:26:40.334 align:middle line:-1
然后 我要做的是突出显示

00:26:40.667 --> 00:26:44.304 align:middle line:-1
这篇文章中被识别为一种名称的文本

00:26:44.505 --> 00:26:47.274 align:middle line:-1
我会得到一个可变属性字符串

00:26:47.341 --> 00:26:49.176 align:middle line:-1
我将向它添加一些属性

00:26:50.043 --> 00:26:53.547 align:middle line:-2
首先获取
这个可变属性字符串的字符串值

00:26:53.847 --> 00:26:55.215 align:middle line:-1
将其赋值给我的标记器

00:26:55.949 --> 00:26:59.253 align:middle line:-1
然后我将对标签进行几轮遍历

00:26:59.653 --> 00:27:03.123 align:middle line:-1
第一轮使用内置的名称类型方案

00:26:59.653 --> 00:27:03.123 align:middle line:-1
第一轮使用内置的名称类型方案

00:27:03.490 --> 00:27:06.860 align:middle line:-2
来为人物、地点和组织
进行命名实体识别

00:27:07.361 --> 00:27:12.165 align:middle line:-2
如果我找到标记为
人名或地名或组织名的内容

00:27:12.699 --> 00:27:15.969 align:middle line:0
我将添加一个属性到这个属性字符串

00:27:16.236 --> 00:27:18.071 align:middle line:0
这会给它设置一些颜色

00:27:20.240 --> 00:27:24.144 align:middle line:-2
然后我们可以用我们的自定义模型
做同样的事情

00:27:24.845 --> 00:27:28.182 align:middle line:-2
我们将使用我们的
自定义产品标签方案进行遍历

00:27:29.583 --> 00:27:32.186 align:middle line:-1
在这种情况下 如果我们发现有东西

00:27:32.252 --> 00:27:34.021 align:middle line:-1
被我们的自定义产品标签所标记

00:27:34.321 --> 00:27:37.891 align:middle line:-2
就可以以完全相同的方式
为它添加颜色

00:27:39.059 --> 00:27:43.363 align:middle line:-2
所以你可以在Natural Language API中
使用自定义模型

00:27:43.730 --> 00:27:47.000 align:middle line:-1
就像你使用内置模型一样

00:27:47.568 --> 00:27:49.169 align:middle line:-2
现在 让我们回到
Playground

00:27:49.903 --> 00:27:53.273 align:middle line:-1
我们看到模型训练已经完成

00:27:53.340 --> 00:27:56.143 align:middle line:-1
现在有两个模型显示在我的桌面上

00:27:58.045 --> 00:28:01.281 align:middle line:-2
我需要做的就是将它们
拖到我的app中

00:27:58.045 --> 00:28:01.281 align:middle line:-2
我需要做的就是将它们
拖到我的app中

00:28:02.082 --> 00:28:06.320 align:middle line:-1
让我们把这个拖到项目中

00:28:08.322 --> 00:28:09.189 align:middle line:-1
好了

00:28:11.892 --> 00:28:17.431 align:middle line:-1
我们把这个也拖进来

00:28:18.632 --> 00:28:22.569 align:middle line:-2
Xcode会自动编译它们
并将它们包含在我的app中

00:28:22.836 --> 00:28:26.073 align:middle line:0
我所要做的就是构建并运行它

00:28:31.378 --> 00:28:34.314 align:middle line:-1
让我们隐藏这个

00:28:34.915 --> 00:28:38.886 align:middle line:-2
这是我的新app
你会注意到我的文章列表

00:28:39.119 --> 00:28:42.289 align:middle line:-1
全部按主题自动分类

00:28:45.859 --> 00:28:50.464 align:middle line:-1
如果我进去看看其中一篇文章

00:28:50.697 --> 00:28:54.067 align:middle line:-1
你会注意到名称在其中突出显示

00:28:54.134 --> 00:28:56.937 align:middle line:-2
你可以看到
通过使用内置的命名实体识别功能

00:28:57.004 --> 00:28:59.940 align:middle line:-1
我们突出显示了人名、地名和组织名

00:29:00.274 --> 00:29:01.642 align:middle line:-1
但进一步来看

00:29:02.409 --> 00:29:06.180 align:middle line:-2
你可以看到它使用了
我们的自定义产品标记器

00:29:06.580 --> 00:29:11.818 align:middle line:-2
突显了iPad、MacBook
iPad mini等产品的名称

00:29:13.520 --> 00:29:18.625 align:middle line:-1
这显示了训练你自己的自定义模型

00:29:18.692 --> 00:29:22.563 align:middle line:-2
并将它们与Natural Language API
一起使用是多么容易

00:29:30.904 --> 00:29:34.341 align:middle line:-1
现在我要把话筒交给Vivek

00:29:34.408 --> 00:29:37.811 align:middle line:-1
来谈论训练模型的一些重要考虑因素

00:29:44.017 --> 00:29:46.887 align:middle line:-2
感谢Doug向我们展示如何使用
这些自定义NLP模型

00:29:46.954 --> 00:29:50.224 align:middle line:-2
我们非常高兴能将Natural Language
和Create ML

00:29:50.290 --> 00:29:53.293 align:middle line:-1
以及Core ML栈紧密整合

00:29:53.861 --> 00:29:57.631 align:middle line:-2
我们希望你能用这个新API
做一些真正令人难以置信的事情

00:29:58.765 --> 00:30:02.169 align:middle line:-1
现在我想再次转移话题并谈论性能

00:29:58.765 --> 00:30:02.169 align:middle line:-1
现在我想再次转移话题并谈论性能

00:30:03.103 --> 00:30:07.508 align:middle line:-2
正如我之前提到的 Natural Language
可以在所有Apple平台上使用

00:30:08.108 --> 00:30:12.379 align:middle line:-2
它也能为你提供我们称之为
“标准化文本处理”的特性

00:30:13.146 --> 00:30:15.682 align:middle line:-2
所以让我们再花点时间
来理解这其中的含义

00:30:16.383 --> 00:30:19.319 align:middle line:-2
若你看看不使用Create ML
的传统机器学习管道

00:30:19.386 --> 00:30:22.222 align:middle line:-1
你会从哪里开始呢？

00:30:22.289 --> 00:30:24.458 align:middle line:-1
你会从一些训练数据开始

00:30:25.292 --> 00:30:27.694 align:middle line:-2
你会获取训练数据
对其进行分词

00:30:27.761 --> 00:30:29.263 align:middle line:-1
还可能会提取一些特征

00:30:29.630 --> 00:30:32.799 align:middle line:-1
这对中文和日文等语言非常重要

00:30:32.866 --> 00:30:34.434 align:middle line:-1
它们的分词效果对训练结果至关重要

00:30:35.369 --> 00:30:37.704 align:middle line:-2
你会把这些东西丢到
你最喜欢的机器学习工具包中

00:30:38.472 --> 00:30:41.141 align:middle line:-1
然后你会得到一个机器学习模型

00:30:41.975 --> 00:30:43.577 align:middle line:-1
现在 为了在Apple设备上

00:30:43.644 --> 00:30:44.945 align:middle line:-1
使用该机器学习模型

00:30:45.012 --> 00:30:47.147 align:middle line:-2
你必须将其转换为
Core ML模型

00:30:47.981 --> 00:30:50.817 align:middle line:-2
你会怎么做？你会使用
Core ML转换器来做到这点

00:30:51.585 --> 00:30:56.523 align:middle line:-2
这是从数据到模型
并将其部署到Apple设备上的

00:30:56.590 --> 00:30:58.225 align:middle line:-1
整个训练过程

00:30:59.893 --> 00:31:00.727 align:middle line:-1
现在

00:30:59.893 --> 00:31:00.727 align:middle line:-1
现在

00:31:01.261 --> 00:31:04.998 align:middle line:-2
在推理阶段
你将你的模型放入app中

00:31:05.399 --> 00:31:06.466 align:middle line:-1
但这不是全部

00:31:07.234 --> 00:31:08.569 align:middle line:-1
你也必须确保

00:31:09.169 --> 00:31:13.207 align:middle line:-1
你编写的用于分词和特征提取的代码

00:31:13.273 --> 00:31:14.741 align:middle line:-1
与训练时所用代码效果一致

00:31:16.543 --> 00:31:18.879 align:middle line:-2
这需要付出很大的努力
因为你必须考虑

00:31:18.946 --> 00:31:20.681 align:middle line:-1
最大限度地提高模型的保真度

00:31:20.814 --> 00:31:24.785 align:middle line:-1
确保在训练和推理阶段都使用

00:31:24.852 --> 00:31:27.154 align:middle line:-1
相同的分词和特征提取方法非常重要

00:31:27.888 --> 00:31:31.291 align:middle line:-2
但现有了Natural Language
你可以完全避免这种情况

00:31:31.792 --> 00:31:35.929 align:middle line:-2
如果你看一下训练的流程
这是训练数据

00:31:37.231 --> 00:31:40.334 align:middle line:-2
你可通过我们讨论过的API
将它传递给Create ML

00:31:41.134 --> 00:31:43.971 align:middle line:0
Create ML在底层调用
Natural Language

00:31:44.037 --> 00:31:47.708 align:middle line:0
后者进行分词 特征提取
选择机器学习库

00:31:47.774 --> 00:31:52.045 align:middle line:0
完成所有这些工作
并返回一个Core ML模型

00:31:53.080 --> 00:31:56.850 align:middle line:0
在推理阶段 你做的事仍然是
将这个模型放入你的app中

00:31:58.151 --> 00:32:00.721 align:middle line:0
但你不必关心分词 特征提取

00:31:58.151 --> 00:32:00.721 align:middle line:0
但你不必关心分词 特征提取

00:32:00.787 --> 00:32:04.024 align:middle line:0
或其他任何东西
事实上你不必编写一行代码

00:32:04.091 --> 00:32:07.060 align:middle line:0
因为Natural Language
为你做了所有这些事

00:32:07.361 --> 00:32:11.298 align:middle line:-2
你只需专注于你的app和任务
并简单地拖放模型即可

00:32:13.834 --> 00:32:17.304 align:middle line:-2
正如我之前提到的
Natural Language的另一特性是

00:32:17.371 --> 00:32:19.540 align:middle line:-2
它针对Apple硬件
和模型大小做了优化

00:32:20.007 --> 00:32:22.676 align:middle line:-1
我们来看几个例子

00:32:23.810 --> 00:32:26.547 align:middle line:0
Doug谈到了命名实体识别和分块

00:32:27.114 --> 00:32:28.615 align:middle line:0
这里有两个不同的基准

00:32:28.682 --> 00:32:32.920 align:middle line:0
这些分别是我们使用
CRFSuite开源工具包

00:32:32.986 --> 00:32:35.389 align:middle line:0
和Natural Language建立的模型

00:32:35.689 --> 00:32:38.559 align:middle line:0
模型由相同的训练数据训练而成

00:32:38.625 --> 00:32:40.394 align:middle line:0
并在相同的测试数据上进行测试

00:32:40.827 --> 00:32:42.429 align:middle line:0
它们实现了相同的功能

00:32:42.496 --> 00:32:45.132 align:middle line:0
这两个模型所获得的准确度是相同的

00:32:45.732 --> 00:32:49.002 align:middle line:0
但是你看看Natural Language
所产生的模型大小

00:32:49.403 --> 00:32:53.307 align:middle line:0
它的命名实体识别模型
只有大约1.4兆字节

00:32:53.373 --> 00:32:56.143 align:middle line:0
分块只用了1.8兆字节

00:32:56.543 --> 00:33:00.113 align:middle line:0
这为你的app节省了大量的空间
以用来做一些其他事情

00:32:56.543 --> 00:33:00.113 align:middle line:0
这为你的app节省了大量的空间
以用来做一些其他事情

00:33:02.950 --> 00:33:04.885 align:middle line:-1
就机器学习算法而言

00:33:05.752 --> 00:33:07.521 align:middle line:-1
我们支持两种不同的选项

00:33:08.455 --> 00:33:10.090 align:middle line:-1
我们可为文本分类指定这些选项

00:33:10.157 --> 00:33:12.559 align:middle line:-2
对于文本分类
我们有两个不同的选择

00:33:12.960 --> 00:33:16.063 align:middle line:-2
一个是maxEnt
它是Maximum Entropy的缩写

00:33:16.563 --> 00:33:20.701 align:middle line:-2
在NLP中 我们认为maxEnt本质上
是一个多项式逻辑回归模型

00:33:20.934 --> 00:33:23.036 align:middle line:-2
我们在NLP领域中直接将其称为
Maximum Entropy

00:33:23.871 --> 00:33:25.305 align:middle line:-1
另一个是CRF

00:33:25.372 --> 00:33:27.674 align:middle line:-1
这是Conditional Random Field的缩写

00:33:28.642 --> 00:33:31.512 align:middle line:-2
这两种算法的选择实际上
取决于你的任务类型

00:33:31.912 --> 00:33:35.382 align:middle line:-2
因此我们鼓励你尝试
分别用这两个选项来建立模型

00:33:37.184 --> 00:33:38.585 align:middle line:-1
就单词标记而言

00:33:38.919 --> 00:33:41.688 align:middle line:-1
Conditional Random Field是默认选项

00:33:41.955 --> 00:33:44.224 align:middle line:-2
当你实例化一个MLWordTagger
并为其指定数据时

00:33:44.291 --> 00:33:49.162 align:middle line:-2
你将使用的默认模型就是
Conditional Random Field

00:33:50.531 --> 00:33:52.399 align:middle line:-2
正如我所提到的
如何选择这些算法

00:33:52.466 --> 00:33:53.734 align:middle line:-1
实际上取决于你的任务

00:33:54.168 --> 00:33:55.536 align:middle line:-1
但我想强调一下

00:33:55.602 --> 00:34:00.073 align:middle line:-1
这与你的传统开发过程有点类似

00:33:55.602 --> 00:34:00.073 align:middle line:-1
这与你的传统开发过程有点类似

00:34:00.307 --> 00:34:04.111 align:middle line:-2
当你有一个app的新想法时
你需要经历一个开发周期 对吧

00:34:04.278 --> 00:34:08.114 align:middle line:-2
你可以把机器学习看成是一种
与这非常类似的工作流程

00:34:08.982 --> 00:34:10.751 align:middle line:-1
你从哪里开始呢 从数据开始

00:34:11.752 --> 00:34:14.888 align:middle line:-2
当你有数据之后
你必须考虑几个问题

00:34:15.621 --> 00:34:18.725 align:middle line:-2
你必须验证你的训练数据
你必须确保

00:34:18.792 --> 00:34:21.460 align:middle line:-2
你的数据中没有虚假示例
并且数据没有受到污染

00:34:22.329 --> 00:34:23.330 align:middle line:-1
一旦你这样做

00:34:23.397 --> 00:34:26.500 align:middle line:-1
你可以检视每个类的训练实例的数量

00:34:26.567 --> 00:34:29.369 align:middle line:-1
假设你在训练一个情感分类模型

00:34:29.436 --> 00:34:31.471 align:middle line:-1
你有一千个积极情绪的例子

00:34:31.538 --> 00:34:33.373 align:middle line:-1
却只有五个负面情绪的例子

00:34:33.873 --> 00:34:36.510 align:middle line:-1
你无法训练出健壮的模型

00:34:36.577 --> 00:34:39.246 align:middle line:-1
来确定或区分这两个类

00:34:39.513 --> 00:34:41.648 align:middle line:-1
你必须确保训练样本的数量

00:34:41.715 --> 00:34:43.851 align:middle line:-1
对于每个类都是平衡的

00:34:44.918 --> 00:34:48.188 align:middle line:-2
一旦你准备好了数据
下一步就是训练

00:34:48.789 --> 00:34:49.922 align:middle line:-1
如前所述

00:34:49.989 --> 00:34:53.159 align:middle line:-1
我们的建议是你运行可选的不同选项

00:34:53.694 --> 00:34:54.962 align:middle line:-1
并弄清楚哪些是好的

00:34:55.462 --> 00:34:57.297 align:middle line:-1
但你如何定义什么是好的呢？

00:34:57.664 --> 00:35:01.835 align:middle line:-2
你必须对模型进行评估才能找出
适合你的app的模型

00:34:57.664 --> 00:35:01.835 align:middle line:-2
你必须对模型进行评估才能找出
适合你的app的模型

00:35:02.169 --> 00:35:05.305 align:middle line:-1
因此工作流程中的下一步就是评估

00:35:07.207 --> 00:35:10.477 align:middle line:-1
机器学习的传统评估方法是这样

00:35:10.544 --> 00:35:14.548 align:middle line:-2
当你获得训练数据时
你将数据分成一个训练集

00:35:14.915 --> 00:35:17.317 align:middle line:-1
一个验证集和一个测试集

00:35:17.751 --> 00:35:19.987 align:middle line:-1
你通常会使用验证集调整算法的参数

00:35:20.053 --> 00:35:22.723 align:middle line:-1
然后在测试集上对其进行测试

00:35:23.090 --> 00:35:26.093 align:middle line:-1
我们鼓励你做同样的事情 即app

00:35:26.159 --> 00:35:29.096 align:middle line:-2
这种长期以来一直被使用的
机器学习指导方针

00:35:29.997 --> 00:35:33.867 align:middle line:-2
我们鼓励你做的另一件事是
测试域外数据

00:35:34.134 --> 00:35:35.102 align:middle line:-1
这是什么意思

00:35:35.502 --> 00:35:38.939 align:middle line:-2
当你有一个app想法时
你会想到某种类型的数据

00:35:39.006 --> 00:35:41.608 align:middle line:-1
将被你的机器学习模型摄入

00:35:42.276 --> 00:35:45.612 align:middle line:-2
现在假设你正在构建一个
酒店评论app

00:35:45.679 --> 00:35:50.517 align:middle line:-1
你想将酒店评论分为不同的等级

00:35:51.485 --> 00:35:54.888 align:middle line:-2
这时用户抛出一个
完全在此领域外的数据

00:35:54.955 --> 00:35:57.624 align:middle line:-1
也许这是一条餐厅评论

00:35:57.691 --> 00:36:00.727 align:middle line:-2
或电影评论
你的模型能够强大到应付它吗

00:35:57.691 --> 00:36:00.727 align:middle line:-2
或电影评论
你的模型能够强大到应付它吗

00:36:01.595 --> 00:36:03.430 align:middle line:-1
这是一个你应该问自己的问题

00:36:04.097 --> 00:36:07.868 align:middle line:-1
最后一步 在传统的开发流程中

00:36:07.935 --> 00:36:11.705 align:middle line:-2
你会编写补丁程序 修复错误
并更新你的app

00:36:12.439 --> 00:36:13.907 align:middle line:-1
在机器学习中如何做到这点？

00:36:16.043 --> 00:36:20.147 align:middle line:-1
解决机器学习问题的方法就是找出

00:36:20.214 --> 00:36:22.382 align:middle line:-1
你的模型何时表现不佳

00:36:22.449 --> 00:36:24.718 align:middle line:-1
然后你必须用正确的数据来完善它

00:36:25.219 --> 00:36:29.656 align:middle line:-2
通过添加数据并重新训练你的模型
你基本上可以得到一个新模型

00:36:29.823 --> 00:36:33.493 align:middle line:-2
所以 正如我所提到的
它与开发流程非常相似

00:36:33.560 --> 00:36:35.495 align:middle line:-1
它们几乎是平行的

00:36:35.562 --> 00:36:39.700 align:middle line:-2
所以如果你正在app中
使用机器学习模型 你可以将其视为

00:36:39.766 --> 00:36:40.734 align:middle line:-1
基础结构的一部分

00:36:40.801 --> 00:36:43.570 align:middle line:-1
你可以将其融入开发流程本身之中

00:36:45.973 --> 00:36:48.842 align:middle line:-1
我想在这里强调的最后一件事是隐私

00:36:49.543 --> 00:36:51.345 align:middle line:-1
你在本次演讲中看到的所有内容

00:36:52.246 --> 00:36:55.182 align:middle line:-1
所有的机器学习和自然语言处理

00:36:55.382 --> 00:36:57.284 align:middle line:-1
都完全发生在设备上

00:36:57.918 --> 00:37:00.220 align:middle line:-1
我们Apple非常注重隐私

00:36:57.918 --> 00:37:00.220 align:middle line:-1
我们Apple非常注重隐私

00:37:00.287 --> 00:37:02.689 align:middle line:-1
而完全在设备上使用机器学习技术

00:37:02.756 --> 00:37:06.026 align:middle line:-1
可以很好的保护用户的隐私

00:37:06.693 --> 00:37:07.594 align:middle line:-1
因此

00:37:08.595 --> 00:37:10.330 align:middle line:-2
Natural Language
是迈向

00:37:10.397 --> 00:37:12.399 align:middle line:-1
隐私保护型机器学习的另一步

00:37:12.466 --> 00:37:14.301 align:middle line:-1
但这次我们将其app于NLP领域

00:37:16.203 --> 00:37:17.104 align:middle line:-1
总而言之

00:37:18.539 --> 00:37:21.742 align:middle line:-2
我们谈到了一个名为
Natural Language的新框架

00:37:22.376 --> 00:37:25.012 align:middle line:-2
它与Apple机器学习技术栈
紧密集成

00:37:25.579 --> 00:37:29.950 align:middle line:-2
你现可使用Create ML来训练模型
然后使用Core ML API

00:37:30.017 --> 00:37:32.920 align:middle line:-2
或Natural Language
来处理这些模型

00:37:34.421 --> 00:37:37.291 align:middle line:-2
我们使用Natural Language
及其API生成的模型

00:37:37.357 --> 00:37:40.227 align:middle line:-1
具有优秀的性能 并在所有平台上

00:37:40.294 --> 00:37:41.628 align:middle line:-1
针对Apple硬件进行了优化

00:37:42.229 --> 00:37:46.867 align:middle line:-2
最后 它支持隐私保护
因为NLP中的所有机器学习

00:37:46.934 --> 00:37:48.402 align:middle line:-1
都发生在用户的设备上

00:37:51.071 --> 00:37:54.474 align:middle line:0
屏幕上有更多信息 明天还有一个
Natural Language实验室

00:37:54.541 --> 00:37:58.378 align:middle line:0
我们鼓励你尝试这些API并与我们交流
或向我们提出

00:37:58.445 --> 00:38:01.682 align:middle line:0
你想要哪些改进的建议
或者甚至咨询你自己app

00:37:58.445 --> 00:38:01.682 align:middle line:0
你想要哪些改进的建议
或者甚至咨询你自己app

00:38:01.748 --> 00:38:02.816 align:middle line:0
的一些问题

00:38:03.750 --> 00:38:05.519 align:middle line:0
我们也有一个机器学习聚会

00:38:05.586 --> 00:38:09.690 align:middle line:0
并且随后还有一个
并行Create ML实验

00:38:09.990 --> 00:38:13.126 align:middle line:0
因此你可以来实验室继续与我们交谈

00:38:13.594 --> 00:38:16.296 align:middle line:0
感谢你的关注
谢谢
