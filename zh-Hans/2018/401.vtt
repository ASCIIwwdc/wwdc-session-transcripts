WEBVTT

00:00:07.016 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:25.516 --> 00:00:28.586 A:middle
[ 掌声 ]

00:00:29.086 --> 00:00:31.526 A:middle
&gt;&gt; 上午好 欢迎参加

00:00:31.526 --> 00:00:32.836 A:middle
Swift 新功能介绍会议

00:00:33.546 --> 00:00:36.986 A:middle
今年对于 Swift 和 Swift 社区来说

00:00:37.046 --> 00:00:37.596 A:middle
发生了许多激动人心的事

00:00:37.966 --> 00:00:39.076 A:middle
接下来的 40 分钟里

00:00:39.136 --> 00:00:40.606 A:middle
Slava 和我将很荣幸

00:00:40.606 --> 00:00:42.526 A:middle
向大家介绍一系列最新进展

00:00:43.696 --> 00:00:44.956 A:middle
本会议大致

00:00:44.956 --> 00:00:45.346 A:middle
分为两部分

00:00:46.126 --> 00:00:47.296 A:middle
首先 我会介绍

00:00:47.296 --> 00:00:48.606 A:middle
Swift 开源计划

00:00:48.646 --> 00:00:51.126 A:middle
以及整个社区的新情况

00:00:51.606 --> 00:00:52.796 A:middle
接下来 我们会探讨 Swift 4.2

00:00:52.796 --> 00:00:54.666 A:middle
Swift 4.2 将从今天起

00:00:54.666 --> 00:00:58.206 A:middle
在 Xcode 10 测试版中提供预览

00:00:58.756 --> 00:01:00.786 A:middle
2015 年年底开始

00:00:58.756 --> 00:01:00.786 A:middle
2015 年年底开始

00:01:00.786 --> 00:01:02.946 A:middle
Swift 作为开源项目登陆 GitHub

00:01:04.546 --> 00:01:06.476 A:middle
用户社区十分活跃

00:01:06.476 --> 00:01:10.226 A:middle
大家展开讨论 提交新功能

00:01:10.226 --> 00:01:11.556 A:middle
审核后将新功能

00:01:11.556 --> 00:01:13.366 A:middle
加入语言和标准库中

00:01:15.726 --> 00:01:17.476 A:middle
在此期间 有 600 人

00:01:17.476 --> 00:01:18.776 A:middle
向 GitHub 上的

00:01:18.776 --> 00:01:20.926 A:middle
Swift 开源项目

00:01:20.926 --> 00:01:21.706 A:middle
贡献了代码

00:01:22.576 --> 00:01:23.686 A:middle
总共合并了

00:01:23.686 --> 00:01:26.046 A:middle
18000 多项合并请求

00:01:27.316 --> 00:01:29.386 A:middle
自从 Swift.org 上线以来

00:01:29.386 --> 00:01:31.326 A:middle
Swift 便可以在

00:01:31.326 --> 00:01:33.966 A:middle
Swift.org 上下载

00:01:33.966 --> 00:01:36.956 A:middle
作为可下载工具链用于 Xcode

00:01:36.996 --> 00:01:38.216 A:middle
以及多个版本的 Ubuntu

00:01:38.646 --> 00:01:43.536 A:middle
其中既包括开发快照 也包括正式版本

00:01:45.016 --> 00:01:46.106 A:middle
我们希望 Swift

00:01:46.106 --> 00:01:48.646 A:middle
得到所有平台的支持

00:01:48.796 --> 00:01:50.396 A:middle
方便大家使用

00:01:50.396 --> 00:01:53.086 A:middle
重要工作之一

00:01:53.086 --> 00:01:54.766 A:middle
就是拓展社区的

00:01:55.116 --> 00:01:56.586 A:middle
测试支持

00:01:57.046 --> 00:01:58.476 A:middle
许多开源项目用户

00:01:58.506 --> 00:02:01.506 A:middle
也在努力让 Swift 支持

00:01:58.506 --> 00:02:01.506 A:middle
也在努力让 Swift 支持

00:02:01.506 --> 00:02:02.106 A:middle
其他平台

00:02:02.476 --> 00:02:04.166 A:middle
我们也想要助一臂之力

00:02:05.396 --> 00:02:07.726 A:middle
大约一个月前 我们

00:02:07.726 --> 00:02:08.545 A:middle
扩展了公共持续集成系统

00:02:08.545 --> 00:02:10.006 A:middle
以支持社区设立的

00:02:10.006 --> 00:02:12.066 A:middle
持续集成节点

00:02:12.566 --> 00:02:13.576 A:middle
如果你是社区的一员

00:02:13.576 --> 00:02:14.796 A:middle
想要让 Swift

00:02:14.796 --> 00:02:16.386 A:middle
得到其他平台的支持

00:02:16.436 --> 00:02:18.046 A:middle
你现在可以

00:02:18.046 --> 00:02:19.266 A:middle
直接接入你的硬件支持

00:02:19.266 --> 00:02:20.726 A:middle
并开始测试

00:02:21.146 --> 00:02:22.776 A:middle
这一前提可以帮助

00:02:22.776 --> 00:02:23.956 A:middle
Swift 得到

00:02:23.956 --> 00:02:24.566 A:middle
其他平台的支持

00:02:26.826 --> 00:02:28.816 A:middle
我们还投入了很多

00:02:29.056 --> 00:02:31.056 A:middle
建立了 Swift 开源项目的

00:02:31.106 --> 00:02:32.716 A:middle
周边社区 在这里

00:02:33.056 --> 00:02:35.966 A:middle
社区成员可以讨论语言中的所有变化

00:02:36.966 --> 00:02:38.936 A:middle
大约六个月前 我们

00:02:38.936 --> 00:02:40.196 A:middle
不再使用邮件列表

00:02:40.196 --> 00:02:42.556 A:middle
因为信息量太大 而改用论坛

00:02:42.986 --> 00:02:44.746 A:middle
这是当时社区的呼声

00:02:45.366 --> 00:02:48.776 A:middle
起初有很多人想要以适合

00:02:48.776 --> 00:02:50.446 A:middle
自己的方式真正

00:02:50.446 --> 00:02:54.126 A:middle
参与项目 但发现困难重重

00:02:54.666 --> 00:02:55.586 A:middle
有了论坛 你们就可以

00:02:55.586 --> 00:02:57.656 A:middle
以适合自己的

00:02:57.656 --> 00:03:00.926 A:middle
方式参与项目 论坛非常成功

00:02:57.656 --> 00:03:00.926 A:middle
方式参与项目 论坛非常成功

00:03:00.926 --> 00:03:02.476 A:middle
我们也想拓展

00:03:02.476 --> 00:03:04.586 A:middle
它的用途 支持

00:03:04.586 --> 00:03:06.746 A:middle
整个开源项目

00:03:07.476 --> 00:03:10.196 A:middle
如果你在维护

00:03:10.196 --> 00:03:11.696 A:middle
一个开源项目 例如

00:03:11.696 --> 00:03:13.526 A:middle
很受欢迎的 Swift 库

00:03:13.526 --> 00:03:14.906 A:middle
你就可以用论坛

00:03:15.186 --> 00:03:16.436 A:middle
来讨论项目内容

00:03:16.436 --> 00:03:18.506 A:middle
例如与用户沟通

00:03:18.506 --> 00:03:19.286 A:middle
或讨论开发进度

00:03:20.986 --> 00:03:22.376 A:middle
我们还想

00:03:22.376 --> 00:03:24.386 A:middle
拓展 Swift.org 的作用

00:03:24.426 --> 00:03:26.016 A:middle
让它能为整个社区所用

00:03:26.566 --> 00:03:28.936 A:middle
本周 我们将把 Swift 编程语言手册

00:03:29.006 --> 00:03:30.486 A:middle
迁移到 Swift.org

00:03:31.486 --> 00:03:33.706 A:middle
地址为 docs.swift.org

00:03:33.706 --> 00:03:35.146 A:middle
我们今后也会在这里

00:03:35.186 --> 00:03:37.716 A:middle
公布更多文档

00:03:37.716 --> 00:03:39.026 A:middle
供社区使用

00:03:39.606 --> 00:03:42.876 A:middle
关于 Swift

00:03:42.876 --> 00:03:45.006 A:middle
最激动人心的是

00:03:45.006 --> 00:03:46.776 A:middle
人们很喜欢使用 Swift

00:03:46.776 --> 00:03:48.406 A:middle
并且在很多场合

00:03:48.406 --> 00:03:49.376 A:middle
讨论 Swift

00:03:49.606 --> 00:03:51.246 A:middle
例如博客 聚会

00:03:51.696 --> 00:03:52.556 A:middle
还有会议

00:03:53.126 --> 00:03:54.916 A:middle
而 Apple 认为

00:03:54.916 --> 00:03:56.726 A:middle
我们很有必要

00:03:56.996 --> 00:03:59.966 A:middle
参与其中 因为讨论就是在这些地方发生

00:04:00.736 --> 00:04:02.696 A:middle
过去一年间

00:04:02.696 --> 00:04:04.116 A:middle
我们格外重视

00:04:04.116 --> 00:04:06.046 A:middle
参与这些会议

00:04:06.046 --> 00:04:09.016 A:middle
并且进行了技术展示

00:04:09.406 --> 00:04:10.826 A:middle
包括我们在 Swift 上的

00:04:10.826 --> 00:04:13.026 A:middle
工作 Swift 的工作原理

00:04:13.026 --> 00:04:14.386 A:middle
还有你们参与

00:04:14.386 --> 00:04:15.376 A:middle
开源项目的方式

00:04:16.375 --> 00:04:17.576 A:middle
这些我们在今后

00:04:17.576 --> 00:04:19.616 A:middle
也会致力于向前推进

00:04:21.466 --> 00:04:22.466 A:middle
其中一项重要努力

00:04:22.466 --> 00:04:25.096 A:middle
是周五在 WWDC

00:04:25.166 --> 00:04:27.266 A:middle
场地附近举办的 try Swift

00:04:27.336 --> 00:04:29.226 A:middle
圣何塞会议

00:04:29.866 --> 00:04:31.596 A:middle
届时会有工作坊

00:04:31.836 --> 00:04:33.256 A:middle
成员来自社区

00:04:33.256 --> 00:04:34.806 A:middle
帮助有兴趣

00:04:34.806 --> 00:04:36.326 A:middle
为 Swift 开源项目做贡献的

00:04:36.326 --> 00:04:38.196 A:middle
与会人员

00:04:38.626 --> 00:04:39.916 A:middle
届时 Apple 的

00:04:39.916 --> 00:04:41.836 A:middle
编译器团队也会出席

00:04:42.046 --> 00:04:44.416 A:middle
帮助大家进行交流

00:04:45.146 --> 00:04:48.446 A:middle
以上就是关于社区的新进展

00:04:49.066 --> 00:04:50.166 A:middle
我们来谈谈 Swift 4.2

00:04:50.166 --> 00:04:53.346 A:middle
我认为 首先应当谈谈 这个版本的

00:04:53.346 --> 00:04:55.466 A:middle
内容 以及在整体发展过程中的地位

00:04:58.276 --> 00:05:01.906 A:middle
Swift 更新 特别是大版本更新 大约

00:04:58.276 --> 00:05:01.906 A:middle
Swift 更新 特别是大版本更新 大约

00:05:01.906 --> 00:05:02.386 A:middle
两年一次

00:05:02.996 --> 00:05:04.926 A:middle
Swift 4.2 是继 Swift 4.1

00:05:04.956 --> 00:05:07.026 A:middle
和 4.0 之后的大版本更新

00:05:08.246 --> 00:05:10.116 A:middle
总体而言 这个版本

00:05:10.216 --> 00:05:11.736 A:middle
有两大要点

00:05:12.316 --> 00:05:14.686 A:middle
第一是进一步关注

00:05:14.686 --> 00:05:15.386 A:middle
开发者效率

00:05:15.826 --> 00:05:16.946 A:middle
你们可以在很多方面

00:05:16.946 --> 00:05:17.136 A:middle
感受到

00:05:17.686 --> 00:05:19.186 A:middle
项目构建速度更快

00:05:19.546 --> 00:05:20.826 A:middle
但整体而言

00:05:20.826 --> 00:05:22.876 A:middle
核心工具的体验

00:05:22.876 --> 00:05:24.676 A:middle
也大幅改善

00:05:24.676 --> 00:05:26.106 A:middle
例如调试器（Debugger）和编辑器（Editor）

00:05:26.186 --> 00:05:28.306 A:middle
Swift 社区也

00:05:28.306 --> 00:05:30.216 A:middle
也不断重视改进语言

00:05:30.616 --> 00:05:32.206 A:middle
从而改善一般的

00:05:32.206 --> 00:05:33.796 A:middle
开发者工作流

00:05:33.796 --> 00:05:34.386 A:middle
去除鸡肋代码

00:05:34.926 --> 00:05:36.936 A:middle
Apple 也一直在

00:05:36.936 --> 00:05:39.406 A:middle
改进 SDK 从而

00:05:39.406 --> 00:05:41.646 A:middle
让 Objective-C API 更好地

00:05:41.686 --> 00:05:44.226 A:middle
映射到 Swift 中

00:05:44.386 --> 00:05:45.456 A:middle
改善对语言

00:05:45.456 --> 00:05:47.006 A:middle
和 API 的运用

00:05:48.266 --> 00:05:49.626 A:middle
另一方面

00:05:49.626 --> 00:05:51.766 A:middle
语言底层得到

00:05:51.846 --> 00:05:53.736 A:middle
大幅改善

00:05:53.736 --> 00:05:55.636 A:middle
运行时间也有很多变化

00:05:55.636 --> 00:05:58.156 A:middle
以实现二进制兼容性

00:05:58.156 --> 00:06:01.946 A:middle
这一功能将在 Swift 5 中推出

00:05:58.156 --> 00:06:01.946 A:middle
这一功能将在 Swift 5 中推出

00:06:01.946 --> 00:06:04.916 A:middle
预计于 2019 年早些时候发布

00:06:05.926 --> 00:06:07.486 A:middle
什么是二进制兼容性

00:06:08.406 --> 00:06:09.806 A:middle
二进制兼容性指

00:06:09.806 --> 00:06:11.536 A:middle
构建 Swift 代码时

00:06:11.576 --> 00:06:13.286 A:middle
你可以使用 Swift 5 的编译器和层

00:06:13.286 --> 00:06:15.036 A:middle
而在二进制层面

00:06:15.036 --> 00:06:16.626 A:middle
代码可以与

00:06:16.696 --> 00:06:17.866 A:middle
同一编译器或其他编译器层

00:06:17.866 --> 00:06:19.686 A:middle
构建的代码

00:06:19.686 --> 00:06:20.016 A:middle
相互操作

00:06:20.496 --> 00:06:22.266 A:middle
这一点十分重要

00:06:22.266 --> 00:06:23.966 A:middle
标志着这门语言

00:06:23.966 --> 00:06:24.506 A:middle
走向成熟

00:06:25.146 --> 00:06:26.606 A:middle
有了这一功能

00:06:26.606 --> 00:06:28.436 A:middle
Apple 就可以将 Swift 运行时

00:06:28.586 --> 00:06:30.746 A:middle
移入操作系统

00:06:30.746 --> 00:06:32.156 A:middle
App 可以直接使用它

00:06:32.576 --> 00:06:33.496 A:middle
而不再需要

00:06:33.496 --> 00:06:34.976 A:middle
将其放入 App 包中

00:06:35.346 --> 00:06:37.446 A:middle
这样可以缩减代码体积

00:06:37.446 --> 00:06:38.966 A:middle
但同样重要的是

00:06:38.966 --> 00:06:40.146 A:middle
启动时间和

00:06:40.146 --> 00:06:42.286 A:middle
内存使用也能得到优化

00:06:42.286 --> 00:06:44.056 A:middle
对社区而言帮助很大

00:06:44.056 --> 00:06:46.876 A:middle
我们也会

00:06:46.876 --> 00:06:48.046 A:middle
公布实现

00:06:48.286 --> 00:06:50.196 A:middle
ABI 稳定性或二进制兼容性的

00:06:50.196 --> 00:06:50.906 A:middle
相关进展

00:06:51.286 --> 00:06:52.826 A:middle
可以访问 Swift.org 的

00:06:52.826 --> 00:06:54.366 A:middle
ABI 稳定性总览页面

00:06:54.406 --> 00:06:55.806 A:middle
跟踪进展

00:06:57.696 --> 00:07:00.186 A:middle
今天的重点是 Swift 4.2

00:06:57.696 --> 00:07:00.186 A:middle
今天的重点是 Swift 4.2

00:07:00.186 --> 00:07:01.596 A:middle
这是实现 Swift 5 的

00:07:01.916 --> 00:07:02.696 A:middle
重要一步

00:07:03.426 --> 00:07:05.446 A:middle
我们来谈谈

00:07:05.446 --> 00:07:06.166 A:middle
源兼容性

00:07:07.526 --> 00:07:10.106 A:middle
像 Xcode 9 一样

00:07:10.166 --> 00:07:12.696 A:middle
Xcode 10 只搭载一种 Swift 编译器

00:07:13.686 --> 00:07:15.086 A:middle
如果你使用 Xcode 10

00:07:15.086 --> 00:07:16.256 A:middle
你就在使用 Swift 4.2

00:07:17.226 --> 00:07:19.716 A:middle
但就像 Xcode 9 一样

00:07:20.276 --> 00:07:21.746 A:middle
这一编译器也支持

00:07:22.236 --> 00:07:23.896 A:middle
多种语言

00:07:23.896 --> 00:07:24.366 A:middle
兼容性模式

00:07:25.256 --> 00:07:27.906 A:middle
在所有模式中 你都可以使用新 API

00:07:28.676 --> 00:07:30.476 A:middle
可以使用全部新特性

00:07:30.856 --> 00:07:31.676 A:middle
这足以带来

00:07:31.676 --> 00:07:33.476 A:middle
影响代码源的变化

00:07:34.036 --> 00:07:37.286 A:middle
前两个模式

00:07:37.286 --> 00:07:39.026 A:middle
在 Xcode 9 中就已存在

00:07:39.426 --> 00:07:40.676 A:middle
保留它们是为了提供

00:07:40.676 --> 00:07:41.776 A:middle
开箱即用式的体验

00:07:41.776 --> 00:07:43.046 A:middle
你可以直接构建 Swift 3

00:07:43.046 --> 00:07:44.926 A:middle
和 Swift 4 代码 不需修改

00:07:45.656 --> 00:07:47.206 A:middle
Swift 4.2 模式与

00:07:47.206 --> 00:07:49.586 A:middle
Swift 4 模式基本相同

00:07:49.586 --> 00:07:51.216 A:middle
但包含刚才提到的

00:07:51.476 --> 00:07:52.266 A:middle
SDK 改进

00:07:53.426 --> 00:07:54.346 A:middle
就这样

00:07:54.976 --> 00:07:57.026 A:middle
如果使用之前版本的 Xcode

00:07:57.086 --> 00:07:58.526 A:middle
可以使用迁移帮助（Migrator Support）

00:07:58.526 --> 00:07:59.436 A:middle
该功能位于编辑（Edit）菜单

00:07:59.436 --> 00:08:01.556 A:middle
用来自动进行大部分修改

00:07:59.436 --> 00:08:01.556 A:middle
用来自动进行大部分修改

00:08:02.806 --> 00:08:03.876 A:middle
我想先做一项

00:08:03.876 --> 00:08:06.166 A:middle
关于 Swift 4.2 SDK 变化的

00:08:06.306 --> 00:08:07.146 A:middle
免责声明

00:08:07.496 --> 00:08:09.436 A:middle
后期的 Xcode 10 测试版可能

00:08:09.436 --> 00:08:11.036 A:middle
会进一步改进 SDK

00:08:11.416 --> 00:08:13.206 A:middle
这是为了能够

00:08:13.206 --> 00:08:14.916 A:middle
整合大家

00:08:14.916 --> 00:08:16.976 A:middle
关于 API 改进方向

00:08:16.976 --> 00:08:18.676 A:middle
和改进如何反映在 Swift 中

00:08:18.676 --> 00:08:19.626 A:middle
等反馈意见

00:08:20.236 --> 00:08:22.246 A:middle
这意味着 如果你提前

00:08:22.416 --> 00:08:23.926 A:middle
迁移到 Swift 4.2

00:08:23.926 --> 00:08:25.096 A:middle
就要注意后续可能出现的变化

00:08:25.576 --> 00:08:27.446 A:middle
你也可以先不迁移 之后再选择迁移

00:08:27.836 --> 00:08:28.816 A:middle
完全取决于你

00:08:30.616 --> 00:08:32.176 A:middle
Swift 4.2 中

00:08:32.176 --> 00:08:34.126 A:middle
我们在加速让

00:08:34.166 --> 00:08:35.476 A:middle
Swift 代码成型

00:08:35.876 --> 00:08:36.635 A:middle
并面向未来

00:08:36.666 --> 00:08:40.716 A:middle
这是语言成熟的重要阶段

00:08:41.506 --> 00:08:43.046 A:middle
因此 我们认为

00:08:43.046 --> 00:08:44.596 A:middle
大家都有必要

00:08:44.596 --> 00:08:47.486 A:middle
从 Swift 3 迁移到

00:08:47.486 --> 00:08:48.086 A:middle
Swift 4.2

00:08:48.086 --> 00:08:50.456 A:middle
代码体积得到了重要改善

00:08:50.456 --> 00:08:51.396 A:middle
语言整体也

00:08:51.396 --> 00:08:52.006 A:middle
有所改进

00:08:52.836 --> 00:08:54.106 A:middle
Xcode 10 将会是

00:08:54.156 --> 00:08:55.636 A:middle
最后一个支持

00:08:55.636 --> 00:08:58.916 A:middle
Swift 3 兼容模式的版本

00:08:59.586 --> 00:09:00.506 A:middle
我们来谈谈工具

00:08:59.586 --> 00:09:00.506 A:middle
我们来谈谈工具

00:09:00.506 --> 00:09:01.446 A:middle
方面的改进

00:09:02.536 --> 00:09:04.076 A:middle
在 Platform State of the Union 会议中

00:09:04.076 --> 00:09:05.006 A:middle
我们提到

00:09:05.106 --> 00:09:06.206 A:middle
Xcode 9 中的

00:09:06.206 --> 00:09:07.416 A:middle
Swift 项目构建

00:09:07.416 --> 00:09:09.366 A:middle
也得到了显著改善

00:09:10.176 --> 00:09:12.176 A:middle
这些结果是在一台配备

00:09:12.176 --> 00:09:13.516 A:middle
四核 i7 处理器的 MacBook Pro 上得到的

00:09:13.516 --> 00:09:17.416 A:middle
我们来仔细看看其中之一

00:09:18.896 --> 00:09:20.456 A:middle
这个项目混合了

00:09:20.456 --> 00:09:21.776 A:middle
Objective-C 和 Swift 代码

00:09:22.066 --> 00:09:24.666 A:middle
它最初是一个 Objective-C 项目 随后

00:09:24.666 --> 00:09:25.526 A:middle
开始采用 Swift

00:09:26.216 --> 00:09:27.786 A:middle
这种情况很常见

00:09:28.756 --> 00:09:29.576 A:middle
屏幕上的构建时间

00:09:29.576 --> 00:09:32.156 A:middle
提升无法反映

00:09:32.156 --> 00:09:33.826 A:middle
构建这段 Swift 代码

00:09:33.876 --> 00:09:35.536 A:middle
到底比之前快了多少

00:09:36.356 --> 00:09:37.526 A:middle
如果我们只关注

00:09:37.526 --> 00:09:39.826 A:middle
Swift 构建速度的提升

00:09:39.826 --> 00:09:42.896 A:middle
构建速度实际上快了三倍

00:09:43.386 --> 00:09:44.776 A:middle
这就是为什么

00:09:45.046 --> 00:09:47.536 A:middle
项目速度提升只有 1.6 倍

00:09:49.656 --> 00:09:51.096 A:middle
可以看到

00:09:51.096 --> 00:09:52.216 A:middle
构建速度提升

00:09:52.216 --> 00:09:53.706 A:middle
整体取决于

00:09:53.706 --> 00:09:54.766 A:middle
项目性质 使用多少

00:09:54.766 --> 00:09:56.816 A:middle
Swift 代码 以及处理器的

00:09:56.816 --> 00:09:58.606 A:middle
核数 但实际情况中

00:09:58.766 --> 00:10:01.476 A:middle
许多项目都提速多达两倍

00:09:58.766 --> 00:10:01.476 A:middle
许多项目都提速多达两倍

00:10:02.416 --> 00:10:04.366 A:middle
提升主要由于

00:10:04.366 --> 00:10:06.326 A:middle
Swift 目标

00:10:06.326 --> 00:10:08.286 A:middle
具有跨文件

00:10:08.286 --> 00:10:10.896 A:middle
可见性 这是 Swift 的优异特性之一

00:10:10.896 --> 00:10:11.946 A:middle
不需要头文件

00:10:12.606 --> 00:10:13.976 A:middle
过去编译器会执行

00:10:13.976 --> 00:10:15.586 A:middle
许多冗余工作

00:10:15.586 --> 00:10:17.056 A:middle
于是 我们就

00:10:17.056 --> 00:10:18.346 A:middle
重新设计了编译

00:10:18.346 --> 00:10:20.136 A:middle
流程 大幅减少了

00:10:20.136 --> 00:10:21.626 A:middle
冗余 并且更好的利用处理器

00:10:21.626 --> 00:10:22.936 A:middle
你机器上的核

00:10:23.096 --> 00:10:24.466 A:middle
因此才会有这样的速度提升

00:10:25.206 --> 00:10:27.616 A:middle
欲知更多细节 本周晚些时候

00:10:27.616 --> 00:10:28.886 A:middle
会有两场讲座

00:10:28.886 --> 00:10:30.346 A:middle
深入分析构建过程

00:10:30.396 --> 00:10:31.846 A:middle
背后的工作原理 会提到

00:10:31.846 --> 00:10:32.906 A:middle
更多细节 解释

00:10:32.946 --> 00:10:34.146 A:middle
为何会有如此性能提升

00:10:36.356 --> 00:10:37.906 A:middle
性能大幅提升是由于

00:10:38.606 --> 00:10:40.526 A:middle
调试版本构建的改进

00:10:41.566 --> 00:10:44.776 A:middle
我想重点讲这一功能

00:10:44.776 --> 00:10:47.846 A:middle
为何出现在 Xcode 的构建选项中

00:10:48.746 --> 00:10:49.926 A:middle
最近我们将

00:10:49.926 --> 00:10:51.386 A:middle
编译模式（Compilation Mode）从

00:10:51.386 --> 00:10:52.506 A:middle
优化水平（Optimization Level）中分离出来

00:10:53.206 --> 00:10:55.286 A:middle
编译模式决定

00:10:55.286 --> 00:10:56.726 A:middle
项目构建的方式

00:10:57.256 --> 00:10:58.566 A:middle
如果是构建发行版本（Release）

00:10:58.566 --> 00:10:59.566 A:middle
默认设置是全模组

00:10:59.566 --> 00:11:01.446 A:middle
编译（Whole Module Compilation）

00:10:59.566 --> 00:11:01.446 A:middle
编译（Whole Module Compilation）

00:11:01.446 --> 00:11:02.906 A:middle
目标中全部文件

00:11:02.906 --> 00:11:04.226 A:middle
总是一起构建

00:11:04.386 --> 00:11:05.836 A:middle
进行优化的

00:11:05.836 --> 00:11:07.326 A:middle
可能性最高

00:11:07.326 --> 00:11:09.756 A:middle
重点不是优化的数量 而是

00:11:09.756 --> 00:11:11.366 A:middle
进行优化的可能性

00:11:12.166 --> 00:11:14.146 A:middle
而如果是调试版本（Debug）

00:11:14.146 --> 00:11:15.176 A:middle
则是增量（Incremental）构建

00:11:15.386 --> 00:11:16.486 A:middle
并非所有文件

00:11:16.486 --> 00:11:18.626 A:middle
都会构建 或者再构建

00:11:19.616 --> 00:11:20.506 A:middle
这是性能表现

00:11:20.506 --> 00:11:22.536 A:middle
和构建时间权衡的结果

00:11:23.516 --> 00:11:24.826 A:middle
调试版本构建的

00:11:24.826 --> 00:11:25.746 A:middle
优化水平默认仍然是

00:11:25.746 --> 00:11:26.966 A:middle
无优化（No optimization）

00:11:26.966 --> 00:11:27.946 A:middle
这样构建速度更快

00:11:27.946 --> 00:11:29.806 A:middle
调试信息更全

00:11:29.806 --> 00:11:32.096 A:middle
发行版本构建则着重优化速度

00:11:32.636 --> 00:11:35.306 A:middle
我们稍后会再提到优化水平

00:11:38.436 --> 00:11:42.696 A:middle
好的 分离编译模式和

00:11:42.696 --> 00:11:45.296 A:middle
优化水平

00:11:45.356 --> 00:11:46.516 A:middle
反映了一个非常有趣的权宜之计

00:11:46.516 --> 00:11:48.096 A:middle
有人发现有时候

00:11:48.096 --> 00:11:50.176 A:middle
如果

00:11:50.176 --> 00:11:51.126 A:middle
结合全模组

00:11:51.126 --> 00:11:53.946 A:middle
编译并且无优化时

00:11:53.946 --> 00:11:54.876 A:middle
可以更快的

00:11:55.036 --> 00:11:56.026 A:middle
构建调试版本

00:11:56.966 --> 00:11:58.786 A:middle
这是因为

00:11:58.786 --> 00:12:02.246 A:middle
这一组合显著减少了

00:11:58.786 --> 00:12:02.246 A:middle
这一组合显著减少了

00:12:02.246 --> 00:12:04.136 A:middle
我们现在努力

00:12:04.136 --> 00:12:08.666 A:middle
消除或大幅减少的冗余工作

00:12:10.036 --> 00:12:12.496 A:middle
而这样组合的问题在于 它会减慢

00:12:12.496 --> 00:12:13.296 A:middle
增量构建的速度

00:12:13.506 --> 00:12:14.716 A:middle
只要你修改了目标中的

00:12:14.716 --> 00:12:16.806 A:middle
一个文件 整个目标就要重新构建

00:12:17.496 --> 00:12:18.836 A:middle
而 Xcode 10 改进了

00:12:18.836 --> 00:12:20.406 A:middle
调试版本构建 我们认为

00:12:20.406 --> 00:12:21.936 A:middle
你们不再需要

00:12:21.986 --> 00:12:24.416 A:middle
使用这种权宜之计 我们也

00:12:24.416 --> 00:12:25.626 A:middle
发现 默认的

00:12:25.626 --> 00:12:27.316 A:middle
增量构建 表现

00:12:27.316 --> 00:12:29.356 A:middle
同这种组合相当 甚至更好

00:12:29.356 --> 00:12:30.976 A:middle
特别是现在 增量构建得到了正式支持

00:12:34.696 --> 00:12:35.826 A:middle
我们来谈谈

00:12:35.826 --> 00:12:37.006 A:middle
运行时得到的

00:12:37.006 --> 00:12:38.256 A:middle
底层优化 这也是

00:12:38.256 --> 00:12:39.356 A:middle
实现二进制兼容的

00:12:39.406 --> 00:12:40.586 A:middle
环节之一

00:12:43.436 --> 00:12:45.126 A:middle
Swift 使用自动内存

00:12:45.126 --> 00:12:47.726 A:middle
管理 并且像 Objective-C 一样

00:12:47.726 --> 00:12:49.236 A:middle
使用引用计数（reference counting）

00:12:49.386 --> 00:12:51.026 A:middle
管理对象实例

00:12:51.916 --> 00:12:53.526 A:middle
这张幻灯片上 用备注

00:12:53.526 --> 00:12:54.786 A:middle
显示出编译器在哪里

00:12:54.786 --> 00:12:56.426 A:middle
插入（insert） 保留（retain） 释放（release）

00:12:57.516 --> 00:13:02.116 A:middle
这是 Swift 4.1 中的运行方式

00:12:57.516 --> 00:13:02.116 A:middle
这是 Swift 4.1 中的运行方式

00:13:02.316 --> 00:13:03.276 A:middle
对象创建时

00:13:03.276 --> 00:13:04.716 A:middle
会关联一个 +1

00:13:04.716 --> 00:13:05.896 A:middle
引用计数

00:13:05.896 --> 00:13:08.176 A:middle
惯例是 如果

00:13:08.176 --> 00:13:09.596 A:middle
对象作为一个参数

00:13:09.596 --> 00:13:10.806 A:middle
传递到另一个函数中

00:13:11.286 --> 00:13:12.406 A:middle
那个函数的调用

00:13:12.466 --> 00:13:14.526 A:middle
就应该释放对象

00:13:14.986 --> 00:13:16.626 A:middle
这基本上就是让

00:13:16.626 --> 00:13:18.036 A:middle
函数调用

00:13:18.036 --> 00:13:19.406 A:middle
释放对象

00:13:20.376 --> 00:13:21.556 A:middle
这样一来 就有

00:13:21.556 --> 00:13:22.926 A:middle
机会改进性能 缩减

00:13:22.926 --> 00:13:25.156 A:middle
一些对象的生命周期

00:13:25.156 --> 00:13:26.936 A:middle
限制到最小范围

00:13:27.806 --> 00:13:29.976 A:middle
但是 如果你的代码

00:13:30.056 --> 00:13:32.076 A:middle
将对象传递到

00:13:32.076 --> 00:13:33.886 A:middle
不同 API 的话

00:13:34.276 --> 00:13:35.236 A:middle
可能会是这样

00:13:35.906 --> 00:13:37.096 A:middle
由于存在这种

00:13:37.136 --> 00:13:38.856 A:middle
调用惯例 就依然存在

00:13:38.856 --> 00:13:40.226 A:middle
这种往复操作

00:13:40.226 --> 00:13:41.316 A:middle
最初的引用计数

00:13:41.366 --> 00:13:42.466 A:middle
在最后的调用中

00:13:42.516 --> 00:13:43.066 A:middle
抵消

00:13:43.466 --> 00:13:44.666 A:middle
但中间的步骤

00:13:44.666 --> 00:13:45.776 A:middle
又应当有额外的

00:13:45.776 --> 00:13:48.246 A:middle
保留和释放过程 因为

00:13:48.246 --> 00:13:49.956 A:middle
这是惯例

00:13:50.876 --> 00:13:52.406 A:middle
这样会造成浪费 因为

00:13:52.626 --> 00:13:53.886 A:middle
对象在函数

00:13:53.886 --> 00:13:55.156 A:middle
执行期间

00:13:55.156 --> 00:13:57.106 A:middle
始终存活（alive）

00:13:57.816 --> 00:13:59.876 A:middle
所以 Swift 4.2 中 我们改变了

00:13:59.876 --> 00:14:01.396 A:middle
调用惯例 这样一来

00:13:59.876 --> 00:14:01.396 A:middle
调用惯例 这样一来

00:14:01.396 --> 00:14:02.606 A:middle
就不再由被调用的

00:14:02.606 --> 00:14:04.806 A:middle
一方来释放对象

00:14:05.206 --> 00:14:06.526 A:middle
这样一来 所有的保留

00:14:06.526 --> 00:14:10.366 A:middle
和释放都不复存在

00:14:10.606 --> 00:14:12.066 A:middle
可以显著减少

00:14:12.066 --> 00:14:13.016 A:middle
保留和释放的数据量

00:14:13.936 --> 00:14:15.076 A:middle
这有两重意义

00:14:15.546 --> 00:14:16.916 A:middle
一 可以缩减代码体积

00:14:16.986 --> 00:14:19.026 A:middle
因为这些调用不复存在

00:14:19.026 --> 00:14:20.336 A:middle
二 可以改善运行时

00:14:21.776 --> 00:14:24.746 A:middle
另一项重要的优化

00:14:24.746 --> 00:14:25.746 A:middle
针对字符串

00:14:26.186 --> 00:14:28.506 A:middle
Swift 4.2 的字符串为 16 个

00:14:28.506 --> 00:14:30.316 A:middle
字节长 此前长度为 24

00:14:30.756 --> 00:14:31.976 A:middle
这也是我们

00:14:31.976 --> 00:14:33.266 A:middle
权衡内存使用和

00:14:33.266 --> 00:14:33.936 A:middle
性能的结果

00:14:35.346 --> 00:14:37.356 A:middle
但同时 这一长度

00:14:37.356 --> 00:14:38.936 A:middle
也足以对小字符串

00:14:38.936 --> 00:14:40.026 A:middle
进行优化

00:14:40.706 --> 00:14:42.746 A:middle
如果字符串不足 15

00:14:42.746 --> 00:14:45.226 A:middle
字节长 实际的字符串

00:14:45.226 --> 00:14:46.636 A:middle
就可以直接用

00:14:46.636 --> 00:14:48.246 A:middle
字符串类型表示 而不用

00:14:48.246 --> 00:14:49.306 A:middle
分配单独的

00:14:49.306 --> 00:14:50.806 A:middle
缓冲区来表示字符串

00:14:51.436 --> 00:14:53.456 A:middle
这显然既有利于内存

00:14:53.456 --> 00:14:55.066 A:middle
也有利于性能

00:14:55.716 --> 00:14:56.546 A:middle
这很像我们在

00:14:56.546 --> 00:14:57.866 A:middle
NSString 中

00:14:57.866 --> 00:14:58.286 A:middle
所做的优化

00:14:58.586 --> 00:15:00.516 A:middle
但我们可以存储更大的字符串

00:14:58.586 --> 00:15:00.516 A:middle
但我们可以存储更大的字符串

00:15:03.396 --> 00:15:05.096 A:middle
最后 在我把舞台交给

00:15:05.156 --> 00:15:06.126 A:middle
Slava 之前 我们来谈谈

00:15:06.126 --> 00:15:07.086 A:middle
语言本身的改进

00:15:07.086 --> 00:15:08.576 A:middle
我想多谈一下

00:15:08.576 --> 00:15:10.636 A:middle
缩减代码体积方面的努力

00:15:12.176 --> 00:15:13.146 A:middle
我之前在谈到

00:15:13.146 --> 00:15:14.586 A:middle
调用惯例改变的时候 提到了

00:15:14.586 --> 00:15:15.826 A:middle
缩减代码体积

00:15:15.826 --> 00:15:17.546 A:middle
我们还推出了一个新的

00:15:17.546 --> 00:15:19.936 A:middle
优化水平选项 即优化

00:15:19.936 --> 00:15:20.256 A:middle
体积（Optimize for Size [-Osize]）

00:15:21.466 --> 00:15:22.366 A:middle
这一点很有用

00:15:22.366 --> 00:15:23.986 A:middle
尤其是当 App 非常

00:15:24.056 --> 00:15:25.966 A:middle
关心体积限制的时候 例如

00:15:25.966 --> 00:15:27.216 A:middle
使用蜂窝网络进行

00:15:27.216 --> 00:15:28.056 A:middle
下载的限制

00:15:29.146 --> 00:15:30.626 A:middle
Swift 是一门强大的

00:15:30.696 --> 00:15:33.656 A:middle
静态语言 以静态的方式

00:15:33.656 --> 00:15:34.846 A:middle
理解程序行为

00:15:35.306 --> 00:15:36.306 A:middle
因此 编译器有很多

00:15:36.306 --> 00:15:38.626 A:middle
优化性能的

00:15:38.626 --> 00:15:40.016 A:middle
机会 例如

00:15:40.016 --> 00:15:41.596 A:middle
将函数调用内联（function call inlining）

00:15:41.596 --> 00:15:43.126 A:middle
以及推测性去虚化（speculative

00:15:43.126 --> 00:15:44.326 A:middle
devirtualization） 这些方法牺牲代码体积

00:15:44.326 --> 00:15:45.846 A:middle
以换取性能 然而

00:15:45.846 --> 00:15:46.936 A:middle
有时候 这部分性能

00:15:47.226 --> 00:15:49.346 A:middle
并非实际需要

00:15:49.956 --> 00:15:51.726 A:middle
这是对 Swift 源编译套件

00:15:51.786 --> 00:15:54.466 A:middle
实行 Osize 优化的结果 其中

00:15:54.466 --> 00:15:55.546 A:middle
包括一系列

00:15:55.546 --> 00:15:58.266 A:middle
GitHub 项目 如框架和 App

00:15:59.156 --> 00:16:00.176 A:middle
可以看到 优化范围

00:15:59.156 --> 00:16:00.176 A:middle
可以看到 优化范围

00:16:00.176 --> 00:16:01.626 A:middle
取决于使用了

00:16:01.626 --> 00:16:03.456 A:middle
哪些语言特性 代码体积

00:16:03.456 --> 00:16:05.136 A:middle
缩减了 10% 到 30%

00:16:05.826 --> 00:16:07.896 A:middle
这里所说的代码体积指的是编译

00:16:07.896 --> 00:16:09.636 A:middle
Swift 代码过程中

00:16:09.636 --> 00:16:11.046 A:middle
构建的机器码

00:16:11.046 --> 00:16:12.676 A:middle
不是 App 的整体体积

00:16:12.906 --> 00:16:14.206 A:middle
App 整体体积取决于

00:16:14.206 --> 00:16:15.766 A:middle
应用素材等多重因素

00:16:17.576 --> 00:16:19.416 A:middle
现实中 我们发现

00:16:19.416 --> 00:16:21.836 A:middle
运行时性能会下降大约 5%

00:16:21.836 --> 00:16:23.776 A:middle
这需要牺牲一小部分性能

00:16:24.336 --> 00:16:25.766 A:middle
对很多 App 而言 这一点

00:16:25.766 --> 00:16:26.496 A:middle
无伤大雅

00:16:26.926 --> 00:16:28.716 A:middle
所以确实取决于实际用例

00:16:29.216 --> 00:16:30.096 A:middle
但如果你对此

00:16:30.096 --> 00:16:31.516 A:middle
感兴趣 我们也鼓励你

00:16:31.516 --> 00:16:33.956 A:middle
进行尝试

00:16:34.456 --> 00:16:35.476 A:middle
现在 我要把舞台

00:16:35.476 --> 00:16:36.916 A:middle
交给 Slava  他会谈到

00:16:36.916 --> 00:16:37.806 A:middle
Swift 4.2 中

00:16:37.806 --> 00:16:39.826 A:middle
语言方面的重大改进

00:16:40.516 --> 00:16:45.546 A:middle
[ 掌声 ]

00:16:46.046 --> 00:16:47.856 A:middle
&gt;&gt; 大家好 我是 Slava Pestov

00:16:47.896 --> 00:16:49.586 A:middle
我负责 Swift 编译器

00:16:49.586 --> 00:16:50.886 A:middle
今天 我想谈谈

00:16:50.886 --> 00:16:52.366 A:middle
Swift 4.2 中的新语言特性

00:16:52.366 --> 00:16:54.216 A:middle
可以如何帮助你

00:16:54.216 --> 00:16:55.956 A:middle
写出更简单 更易维护的代码

00:16:57.556 --> 00:16:59.156 A:middle
在讲到语言的

00:16:59.196 --> 00:17:00.766 A:middle
新变化之前 先来

00:16:59.196 --> 00:17:00.766 A:middle
新变化之前 先来

00:17:00.766 --> 00:17:02.576 A:middle
回顾一下改进

00:17:02.576 --> 00:17:03.886 A:middle
语言的过程

00:17:04.516 --> 00:17:06.506 A:middle
如同 Ted 所说 Swift 是一个

00:17:06.506 --> 00:17:08.506 A:middle
开源项目 也具备

00:17:08.506 --> 00:17:09.556 A:middle
开放式设计

00:17:10.165 --> 00:17:11.435 A:middle
也就是说 如果你有

00:17:11.435 --> 00:17:13.066 A:middle
改进语言的想法

00:17:13.386 --> 00:17:14.636 A:middle
你可以在论坛上

00:17:14.715 --> 00:17:16.826 A:middle
提出来 如果想法

00:17:16.826 --> 00:17:18.536 A:middle
得到足够认可 并列入

00:17:18.606 --> 00:17:20.465 A:middle
提议案 你就可以

00:17:20.465 --> 00:17:21.606 A:middle
把想法和

00:17:21.606 --> 00:17:23.435 A:middle
实现提交给核心团队

00:17:23.506 --> 00:17:24.286 A:middle
以供审核

00:17:24.626 --> 00:17:26.165 A:middle
此时 会有正式审核期

00:17:26.165 --> 00:17:27.596 A:middle
社区成员

00:17:27.626 --> 00:17:28.946 A:middle
可以提供额外反馈

00:17:29.016 --> 00:17:30.726 A:middle
之后 核心团队

00:17:30.726 --> 00:17:32.486 A:middle
就会决定是否

00:17:32.486 --> 00:17:33.606 A:middle
接受提议

00:17:34.796 --> 00:17:36.196 A:middle
如果访问 Swift Evolution

00:17:36.196 --> 00:17:38.346 A:middle
网站 就能看到一系列

00:17:38.346 --> 00:17:39.596 A:middle
提议 这些提议均得到了

00:17:39.596 --> 00:17:42.406 A:middle
接受 并将在 Swift 4.2 中实现

00:17:43.396 --> 00:17:44.976 A:middle
列表中包含的提议

00:17:44.976 --> 00:17:46.646 A:middle
数量很多

00:17:46.646 --> 00:17:47.946 A:middle
我今天无法涉及

00:17:47.946 --> 00:17:48.316 A:middle
所有提议

00:17:48.776 --> 00:17:50.046 A:middle
但有一点我想要

00:17:50.046 --> 00:17:51.776 A:middle
强调 那就是

00:17:51.776 --> 00:17:53.086 A:middle
有很多提议是

00:17:53.086 --> 00:17:55.476 A:middle
由社区设计并

00:17:55.476 --> 00:17:56.136 A:middle
实现的

00:17:56.566 --> 00:17:58.066 A:middle
这表明 这些

00:17:58.066 --> 00:17:59.626 A:middle
提议针对

00:17:59.666 --> 00:18:01.406 A:middle
你们遇到的

00:17:59.666 --> 00:18:01.406 A:middle
你们遇到的

00:18:01.406 --> 00:18:03.276 A:middle
各类常见问题

00:18:03.276 --> 00:18:05.756 A:middle
也是你们想出了

00:18:05.756 --> 00:18:07.636 A:middle
解决方案

00:18:07.636 --> 00:18:09.246 A:middle
并向 Swift 贡献了

00:18:09.286 --> 00:18:11.766 A:middle
解决方案 使人人收益

00:18:12.166 --> 00:18:12.516 A:middle
谢谢大家

00:18:14.516 --> 00:18:19.016 A:middle
[ 掌声 ]

00:18:19.516 --> 00:18:20.936 A:middle
第一项改进

00:18:21.126 --> 00:18:22.226 A:middle
我们来看看

00:18:22.226 --> 00:18:23.636 A:middle
如何在使用枚举时

00:18:23.636 --> 00:18:25.486 A:middle
去除鸡肋代码

00:18:26.566 --> 00:18:28.196 A:middle
比如说 我要获得一个枚举

00:18:28.616 --> 00:18:30.486 A:middle
我想要打印出

00:18:30.486 --> 00:18:32.846 A:middle
这个枚举包含的所有值

00:18:33.376 --> 00:18:36.286 A:middle
在 Swift 4 中 我需要定义

00:18:36.286 --> 00:18:38.636 A:middle
一个属性 例如包括所有

00:18:39.026 --> 00:18:40.386 A:middle
可能样例的列表

00:18:41.056 --> 00:18:44.656 A:middle
如果我要添加新的样例

00:18:44.656 --> 00:18:46.016 A:middle
我要记得更新

00:18:46.086 --> 00:18:48.376 A:middle
属性 否则就会呈现

00:18:48.376 --> 00:18:49.706 A:middle
行为或运行时错误

00:18:50.976 --> 00:18:53.536 A:middle
这种做法并不好

00:18:53.536 --> 00:18:54.936 A:middle
因为你在向编译器

00:18:54.936 --> 00:18:56.406 A:middle
重复自己的工作

00:18:56.986 --> 00:18:59.296 A:middle
所以在 Swift 4.2 中 我们添加了

00:18:59.296 --> 00:19:01.966 A:middle
新的 CaseIterable 协议

00:18:59.296 --> 00:19:01.966 A:middle
新的 CaseIterable 协议

00:19:01.966 --> 00:19:03.346 A:middle
如果你表示遵从（conformance）

00:19:03.406 --> 00:19:04.726 A:middle
这一协议 编译器就会

00:19:04.726 --> 00:19:06.676 A:middle
将包含所有样例的属性

00:19:06.676 --> 00:19:07.096 A:middle
同步

00:19:07.096 --> 00:19:08.976 A:middle
简短而有效

00:19:09.516 --> 00:19:12.546 A:middle
[ 鼓掌 ]

00:19:13.046 --> 00:19:15.216 A:middle
下一项改进 我们

00:19:15.216 --> 00:19:16.476 A:middle
要去除另一个

00:19:16.476 --> 00:19:17.806 A:middle
鸡肋代码的根源

00:19:18.016 --> 00:19:19.216 A:middle
这种情况下

00:19:19.306 --> 00:19:20.436 A:middle
你的代码往往

00:19:20.626 --> 00:19:21.786 A:middle
不够泛型（generic）

00:19:22.726 --> 00:19:24.916 A:middle
Swift 4 中 我们为序列

00:19:24.956 --> 00:19:26.596 A:middle
引入了 contains() 方法

00:19:27.006 --> 00:19:28.506 A:middle
这就要求

00:19:28.506 --> 00:19:30.106 A:middle
序列的元素类型

00:19:30.106 --> 00:19:32.186 A:middle
为 Equatable

00:19:32.186 --> 00:19:33.666 A:middle
才能找出所需的元素

00:19:34.636 --> 00:19:36.736 A:middle
当然 我可以对

00:19:36.736 --> 00:19:37.966 A:middle
字符串组成的数组调用

00:19:38.236 --> 00:19:39.616 A:middle
因为字符串是 Equatable 类型

00:19:39.616 --> 00:19:41.516 A:middle
但如果对数组组成的数组

00:19:41.516 --> 00:19:42.346 A:middle
调用呢

00:19:43.226 --> 00:19:45.736 A:middle
如果子数组包含整型（integer）

00:19:45.736 --> 00:19:47.756 A:middle
类型就不为 Equatable

00:19:48.126 --> 00:19:49.486 A:middle
也就是说

00:19:49.486 --> 00:19:50.596 A:middle
编译时间错误

00:19:51.796 --> 00:19:53.796 A:middle
你可能会问 为什么

00:19:53.796 --> 00:19:55.106 A:middle
标准库不让

00:19:55.196 --> 00:19:56.796 A:middle
所有数列为 Equatable 呢

00:19:57.136 --> 00:19:58.316 A:middle
但那样不合逻辑

00:19:58.316 --> 00:20:00.666 A:middle
因为如果数列的

00:19:58.316 --> 00:20:00.666 A:middle
因为如果数列的

00:20:00.666 --> 00:20:01.836 A:middle
元素类型不为

00:20:01.836 --> 00:20:03.366 A:middle
Equatable 例如函数

00:20:03.396 --> 00:20:06.566 A:middle
你也不能让数列为 Equatable

00:20:07.956 --> 00:20:09.286 A:middle
但显然 如果数列的

00:20:09.326 --> 00:20:10.846 A:middle
元素类型为 Equatable

00:20:10.846 --> 00:20:12.726 A:middle
我就可以为数组

00:20:12.726 --> 00:20:14.516 A:middle
定义等值运算

00:20:14.516 --> 00:20:16.376 A:middle
以比较数组中的元素对

00:20:17.116 --> 00:20:18.516 A:middle
而这就是条件一致性

00:20:18.516 --> 00:20:20.116 A:middle
（conditional conformance）对标准库

00:20:20.116 --> 00:20:21.286 A:middle
发挥的作用

00:20:21.376 --> 00:20:23.076 A:middle
现在 如果数组元素

00:20:23.076 --> 00:20:24.916 A:middle
类型为 Equatable

00:20:24.916 --> 00:20:26.246 A:middle
那么数组样例也可以

00:20:26.246 --> 00:20:27.056 A:middle
实现 Equatable

00:20:27.416 --> 00:20:29.776 A:middle
Swift 4.2 中 之前展示的

00:20:29.776 --> 00:20:31.366 A:middle
例子可以运行

00:20:31.856 --> 00:20:34.776 A:middle
除了数组为 Equatable 外

00:20:34.776 --> 00:20:37.636 A:middle
标准库还定义了其他一些

00:20:37.636 --> 00:20:38.896 A:middle
条件一致性

00:20:39.436 --> 00:20:41.026 A:middle
例如 选项（options）

00:20:41.026 --> 00:20:42.726 A:middle
和字典（dictionaries）也是 Equatable

00:20:42.726 --> 00:20:44.126 A:middle
前提是它们的

00:20:44.126 --> 00:20:46.486 A:middle
元素类型为 Equatable

00:20:46.536 --> 00:20:49.576 A:middle
Hashable Encodable 和

00:20:49.576 --> 00:20:51.306 A:middle
Decodable 同理

00:20:52.516 --> 00:20:57.576 A:middle
[ 掌声 ]

00:20:58.076 --> 00:20:59.746 A:middle
这样一来 你就可以

00:20:59.746 --> 00:21:01.156 A:middle
用全新的方法

00:20:59.746 --> 00:21:01.156 A:middle
用全新的方法

00:21:01.156 --> 00:21:02.256 A:middle
构建集合（collections）

00:21:02.986 --> 00:21:05.886 A:middle
这里 有一些由

00:21:05.886 --> 00:21:08.166 A:middle
整数构成的数组

00:21:09.176 --> 00:21:10.366 A:middle
一切运行正常

00:21:10.916 --> 00:21:13.416 A:middle
欲知更多细节

00:21:13.416 --> 00:21:14.656 A:middle
本周晚些时候有一场会议

00:21:14.656 --> 00:21:17.026 A:middle
可以进一步了解

00:21:17.026 --> 00:21:18.476 A:middle
条件一致性

00:21:18.476 --> 00:21:19.946 A:middle
以及 Swift 4.2 中

00:21:19.946 --> 00:21:21.256 A:middle
今天无法提及的

00:21:21.256 --> 00:21:22.536 A:middle
泛型改进

00:21:23.896 --> 00:21:25.756 A:middle
如果要定义自己的

00:21:25.756 --> 00:21:26.776 A:middle
Equatable 和 Hashable

00:21:26.776 --> 00:21:27.606 A:middle
成员（conformances）呢

00:21:28.596 --> 00:21:30.376 A:middle
Swift 中的通用做法是

00:21:30.446 --> 00:21:32.446 A:middle
用包含许多存储属性（stored properties）的

00:21:32.446 --> 00:21:34.516 A:middle
结构体来实现

00:21:34.516 --> 00:21:36.006 A:middle
而这些存储属性

00:21:36.006 --> 00:21:37.096 A:middle
应为 Equatable

00:21:37.436 --> 00:21:38.546 A:middle
接下来 要想让

00:21:38.546 --> 00:21:40.656 A:middle
结构体 Equatable

00:21:40.656 --> 00:21:42.156 A:middle
只需比较两个值的

00:21:42.156 --> 00:21:43.056 A:middle
属性即可

00:21:43.516 --> 00:21:45.616 A:middle
此前在 Swift 4 中 你需要

00:21:45.616 --> 00:21:46.726 A:middle
亲手写出这些内容

00:21:47.166 --> 00:21:48.486 A:middle
这就是鸡肋代码

00:21:48.706 --> 00:21:50.276 A:middle
如果添加一个新的

00:21:50.276 --> 00:21:51.836 A:middle
存储属性 就要记得

00:21:51.836 --> 00:21:53.286 A:middle
更新 Equatable

00:21:53.286 --> 00:21:54.926 A:middle
实现 很容易在

00:21:54.926 --> 00:21:57.166 A:middle
拷贝粘贴等过程中出错

00:21:57.796 --> 00:21:59.676 A:middle
Swift 4.1 中 我们可以

00:21:59.676 --> 00:22:01.536 A:middle
合成 equality（相等性）

00:21:59.676 --> 00:22:01.536 A:middle
合成 equality（相等性）

00:22:01.536 --> 00:22:02.926 A:middle
的使用

00:22:03.386 --> 00:22:04.966 A:middle
如果忘记了实现部分

00:22:05.186 --> 00:22:06.326 A:middle
编译器会为你

00:22:06.326 --> 00:22:08.046 A:middle
补上 前提是

00:22:08.046 --> 00:22:10.036 A:middle
存储属性本身为 Equatable

00:22:11.076 --> 00:22:12.626 A:middle
这也适用于 Hashable

00:22:13.996 --> 00:22:15.726 A:middle
那么如果是泛型呢

00:22:16.266 --> 00:22:17.986 A:middle
这个数据类型中

00:22:17.986 --> 00:22:19.556 A:middle
值可能是

00:22:19.556 --> 00:22:22.316 A:middle
左类型的实例 或者是右类型的实例

00:22:22.936 --> 00:22:26.216 A:middle
我想让左右类型都为

00:22:26.216 --> 00:22:28.876 A:middle
Equatable  因为我想令这两个类型

00:22:28.876 --> 00:22:31.046 A:middle
为函数 错误（errors）

00:22:31.046 --> 00:22:32.446 A:middle
或其他不为 Equatable 的类型

00:22:32.916 --> 00:22:34.326 A:middle
但显然 我可以定义

00:22:34.326 --> 00:22:36.226 A:middle
条件一致性 这样

00:22:36.226 --> 00:22:37.506 A:middle
如果左右类型都为

00:22:37.506 --> 00:22:39.726 A:middle
Equatable  二者之一即为 Equatable

00:22:40.116 --> 00:22:41.696 A:middle
但还可以进一步改进

00:22:42.166 --> 00:22:43.666 A:middle
注意此处的可等性

00:22:43.666 --> 00:22:45.576 A:middle
实现 只有一种

00:22:45.576 --> 00:22:47.616 A:middle
显然正确的实现方式

00:22:47.946 --> 00:22:49.186 A:middle
需要确保两个值

00:22:49.186 --> 00:22:51.416 A:middle
包含相同的样例

00:22:51.416 --> 00:22:53.286 A:middle
如果确实如此 则需要检查载体（payloads）

00:22:53.286 --> 00:22:53.996 A:middle
以确保可等性

00:22:54.776 --> 00:22:56.396 A:middle
你可能会想

00:22:56.396 --> 00:22:57.426 A:middle
编译器应该能够

00:22:57.426 --> 00:22:58.926 A:middle
替你进行合成

00:22:58.926 --> 00:23:00.256 A:middle
Swift 4.2 中确实可以

00:22:58.926 --> 00:23:00.256 A:middle
Swift 4.2 中确实可以

00:23:01.176 --> 00:23:02.666 A:middle
该功能也可用于

00:23:02.666 --> 00:23:03.186 A:middle
Hashable

00:23:04.676 --> 00:23:07.166 A:middle
比方说 现在就可以创建

00:23:07.356 --> 00:23:09.786 A:middle
元素为整型或字符串的集合了

00:23:11.546 --> 00:23:11.656 A:middle
好的

00:23:12.516 --> 00:23:15.676 A:middle
[ 掌声 ]

00:23:16.176 --> 00:23:18.146 A:middle
有时 你确实需要

00:23:18.146 --> 00:23:19.526 A:middle
手动实现

00:23:19.586 --> 00:23:22.766 A:middle
可等性和哈希值（Hashing）

00:23:23.436 --> 00:23:25.456 A:middle
我们来看一个例子

00:23:26.616 --> 00:23:27.866 A:middle
假如说 有一个数据类型

00:23:28.006 --> 00:23:30.796 A:middle
表示一座城市 其中

00:23:30.796 --> 00:23:32.166 A:middle
包括城市名 包括所在的

00:23:32.166 --> 00:23:34.296 A:middle
州 还包括城市的人口

00:23:34.706 --> 00:23:35.556 A:middle
在这个例子中

00:23:35.556 --> 00:23:38.006 A:middle
我只需要

00:23:38.006 --> 00:23:39.536 A:middle
比较城市名和州

00:23:39.536 --> 00:23:41.456 A:middle
以确保可等性

00:23:41.456 --> 00:23:42.826 A:middle
如果数值相等 就不需要

00:23:42.826 --> 00:23:43.926 A:middle
对比人口了

00:23:44.616 --> 00:23:46.446 A:middle
如果我让编译器

00:23:46.446 --> 00:23:48.056 A:middle
合成可等性的

00:23:48.056 --> 00:23:49.706 A:middle
实现 就会产生

00:23:49.706 --> 00:23:52.006 A:middle
冗余 因为它还比较了

00:23:52.006 --> 00:23:53.046 A:middle
人口信息

00:23:53.776 --> 00:23:55.436 A:middle
我当然可以把这部分

00:23:55.436 --> 00:23:56.976 A:middle
写成代码 或许此时

00:23:56.976 --> 00:23:57.636 A:middle
这样还可以

00:23:58.556 --> 00:23:59.796 A:middle
但 Hashable 呢

00:24:01.286 --> 00:24:02.796 A:middle
如果我想计算

00:24:02.836 --> 00:24:04.566 A:middle
城市对象的哈希值

00:24:05.066 --> 00:24:06.986 A:middle
我就要算出

00:24:07.016 --> 00:24:08.336 A:middle
城市名的哈希值和

00:24:08.336 --> 00:24:09.636 A:middle
州的哈希值

00:24:09.636 --> 00:24:11.086 A:middle
再想办法结合二者

00:24:11.646 --> 00:24:12.686 A:middle
但该怎么做呢

00:24:13.296 --> 00:24:15.286 A:middle
可以用异或运算

00:24:15.286 --> 00:24:18.246 A:middle
也可以用

00:24:18.246 --> 00:24:20.196 A:middle
网上随便找的

00:24:20.196 --> 00:24:21.866 A:middle
或者自己编的

00:24:21.866 --> 00:24:22.656 A:middle
运算方式

00:24:23.246 --> 00:24:24.976 A:middle
但这两种办法

00:24:24.976 --> 00:24:27.306 A:middle
都不够好 好像

00:24:27.306 --> 00:24:28.896 A:middle
结合哈希值的函数

00:24:29.176 --> 00:24:30.556 A:middle
是一种魔法似的

00:24:30.876 --> 00:24:32.336 A:middle
而出错的成本

00:24:32.336 --> 00:24:34.376 A:middle
也相当高 因为

00:24:34.376 --> 00:24:35.846 A:middle
字典和集合

00:24:35.846 --> 00:24:37.526 A:middle
要想具备良好性能

00:24:37.526 --> 00:24:39.716 A:middle
确实需要依赖

00:24:39.716 --> 00:24:41.416 A:middle
高质量的哈希函数

00:24:42.146 --> 00:24:44.266 A:middle
同时也有安全考量

00:24:44.636 --> 00:24:46.966 A:middle
如果攻击者

00:24:46.966 --> 00:24:49.336 A:middle
打造的输入能生成

00:24:49.336 --> 00:24:51.086 A:middle
相同的哈希值

00:24:51.086 --> 00:24:52.336 A:middle
并通过互联网发给你的 App

00:24:52.396 --> 00:24:54.286 A:middle
就可能降低 App

00:24:54.286 --> 00:24:55.466 A:middle
运行速度 以致

00:24:55.466 --> 00:24:56.906 A:middle
无法使用 即发起

00:24:56.906 --> 00:24:58.056 A:middle
阻断服务攻击（denial-of-service attack）

00:24:58.536 --> 00:25:01.066 A:middle
所以 在 Swift 4.2 中 我们添加了

00:24:58.536 --> 00:25:01.066 A:middle
所以 在 Swift 4.2 中 我们添加了

00:25:01.066 --> 00:25:02.476 A:middle
更好的 API 实现该功能

00:25:03.316 --> 00:25:05.396 A:middle
可以回想一下 Swift 4

00:25:05.396 --> 00:25:06.896 A:middle
和 4.1 中的 Hashable 协议

00:25:07.486 --> 00:25:09.076 A:middle
其中一个 hashValue

00:25:09.076 --> 00:25:10.446 A:middle
要求（requirement） 返回一个

00:25:10.446 --> 00:25:11.696 A:middle
整型值

00:25:12.446 --> 00:25:14.676 A:middle
Swift 4.2 中 我们重新设计了

00:25:14.676 --> 00:25:16.936 A:middle
Hashable 协议 现在

00:25:17.296 --> 00:25:19.746 A:middle
有了新的 Hash into 要求

00:25:20.126 --> 00:25:21.346 A:middle
Hash into 不产生

00:25:21.346 --> 00:25:23.466 A:middle
单一哈希值

00:25:23.466 --> 00:25:26.146 A:middle
而是选用一个 Hasher 实例

00:25:26.146 --> 00:25:27.636 A:middle
之后可以将

00:25:27.636 --> 00:25:29.616 A:middle
多个值传入 Hasher

00:25:29.616 --> 00:25:31.376 A:middle
Hasher 会结合传入值 生成一个哈希值

00:25:32.306 --> 00:25:34.096 A:middle
回到城市数据类型的

00:25:34.096 --> 00:25:36.076 A:middle
例子 我们只需要

00:25:36.076 --> 00:25:38.226 A:middle
对我们给出的 Hasher 对象实例中

00:25:38.226 --> 00:25:42.576 A:middle
传入的城市名和州

00:25:42.576 --> 00:25:44.596 A:middle
进行递归的

00:25:44.596 --> 00:25:45.316 A:middle
Hash into 调用

00:25:46.486 --> 00:25:49.786 A:middle
Hasher 中的

00:25:49.786 --> 00:25:51.726 A:middle
哈希合并算法

00:25:51.726 --> 00:25:53.526 A:middle
可以有效平衡

00:25:53.526 --> 00:25:55.146 A:middle
哈希值质量和性能

00:25:55.476 --> 00:25:56.556 A:middle
还可以作为额外保护

00:25:56.606 --> 00:25:57.816 A:middle
抵御阻断服务攻击

00:25:57.816 --> 00:25:59.686 A:middle
为此 它使用了

00:25:59.686 --> 00:26:01.616 A:middle
App 启动时生成的

00:25:59.686 --> 00:26:01.616 A:middle
App 启动时生成的

00:26:01.616 --> 00:26:03.346 A:middle
随机预处理种子

00:26:05.136 --> 00:26:07.236 A:middle
我们认为 你可以

00:26:07.316 --> 00:26:09.136 A:middle
很轻松地迁移代码

00:26:09.136 --> 00:26:10.746 A:middle
来使用新的 Hashable

00:26:10.746 --> 00:26:12.756 A:middle
协议 我们也鼓励你这样做

00:26:13.206 --> 00:26:15.016 A:middle
有一条警告

00:26:15.016 --> 00:26:16.936 A:middle
你可能原本

00:26:16.936 --> 00:26:18.746 A:middle
希望哈希值

00:26:18.746 --> 00:26:20.426 A:middle
能够在多次运行 App 中

00:26:20.426 --> 00:26:22.296 A:middle
保持不变 或者

00:26:22.296 --> 00:26:23.566 A:middle
在遍历字典

00:26:23.566 --> 00:26:25.416 A:middle
或集合的时候

00:26:25.416 --> 00:26:26.976 A:middle
希望以同一顺序获取元素

00:26:27.256 --> 00:26:28.726 A:middle
这些已经不再可行

00:26:28.726 --> 00:26:29.656 A:middle
因为使用了随机

00:26:29.656 --> 00:26:30.676 A:middle
预处理种子

00:26:30.746 --> 00:26:32.116 A:middle
你可能需要调整代码

00:26:32.916 --> 00:26:35.096 A:middle
为了简化工作 我们

00:26:35.096 --> 00:26:37.336 A:middle
添加了一项构建设置 即

00:26:37.336 --> 00:26:38.426 A:middle
SWIFT_DETERMINISTIC_HASHING

00:26:38.426 --> 00:26:39.996 A:middle
环境变量 你可以

00:26:39.996 --> 00:26:41.666 A:middle
在方案编辑器（Scheme Editor）中激活

00:26:42.246 --> 00:26:43.736 A:middle
以暂时停用

00:26:43.786 --> 00:26:45.256 A:middle
随机预处理种子

00:26:45.796 --> 00:26:49.466 A:middle
接下来 来谈谈

00:26:49.606 --> 00:26:51.096 A:middle
随机数生成

00:26:52.396 --> 00:26:53.656 A:middle
现在 你们在 Swift 中

00:26:53.656 --> 00:26:54.706 A:middle
如何生成随机数

00:26:55.356 --> 00:26:58.376 A:middle
你需要导入 C 语言的 API

00:26:58.446 --> 00:26:59.876 A:middle
这确实不够理想

00:26:59.876 --> 00:27:01.446 A:middle
因为 API

00:26:59.876 --> 00:27:01.446 A:middle
因为 API

00:27:01.446 --> 00:27:03.866 A:middle
因平台而异

00:27:03.866 --> 00:27:04.876 A:middle
名字不同

00:27:04.876 --> 00:27:06.586 A:middle
行为不同

00:27:06.666 --> 00:27:08.156 A:middle
需要检查构建配置

00:27:08.566 --> 00:27:10.486 A:middle
此外 这些 API 位于底层

00:27:10.486 --> 00:27:12.806 A:middle
还会用到一些

00:27:12.806 --> 00:27:14.566 A:middle
不太直观的常见运算

00:27:15.316 --> 00:27:16.886 A:middle
例如 如果我想得到

00:27:16.886 --> 00:27:19.016 A:middle
1 到 6 之间的随机数

00:27:19.406 --> 00:27:21.446 A:middle
我需要调用

00:27:21.446 --> 00:27:23.716 A:middle
Darwin 中的 arc4random 函数

00:27:23.826 --> 00:27:25.366 A:middle
再除以 6

00:27:25.366 --> 00:27:26.556 A:middle
来求余

00:27:26.836 --> 00:27:27.916 A:middle
但这样的结果

00:27:27.916 --> 00:27:29.476 A:middle
往往并非均匀

00:27:29.476 --> 00:27:31.566 A:middle
分布在 1 到 6 之间

00:27:32.346 --> 00:27:35.386 A:middle
Swift 4.2 中 我们添加了

00:27:35.386 --> 00:27:37.236 A:middle
一组新的 API

00:27:37.236 --> 00:27:38.086 A:middle
以简化操作

00:27:39.146 --> 00:27:41.186 A:middle
首先 我们为所有数字类型

00:27:41.186 --> 00:27:43.296 A:middle
定义了 random 方法

00:27:43.486 --> 00:27:45.576 A:middle
可以获取一个范围 返回

00:27:45.576 --> 00:27:47.986 A:middle
平均分布在范围中的数字

00:27:48.196 --> 00:27:49.816 A:middle
这种方法使用了正确算法

00:27:49.816 --> 00:27:51.316 A:middle
也适用于浮点型（floats）

00:27:52.516 --> 00:27:58.596 A:middle
[ 掌声 ]

00:27:59.096 --> 00:28:00.676 A:middle
对于顶层代码 我们

00:27:59.096 --> 00:28:00.676 A:middle
对于顶层代码 我们

00:28:00.676 --> 00:28:03.076 A:middle
为集合协议添加了

00:28:03.076 --> 00:28:04.196 A:middle
randomElement 方法

00:28:04.786 --> 00:28:07.026 A:middle
可以像 min 和 max 方法一样

00:28:07.026 --> 00:28:08.636 A:middle
返回选项

00:28:08.636 --> 00:28:10.376 A:middle
如果传入空集合

00:28:10.526 --> 00:28:11.506 A:middle
会返回空

00:28:12.596 --> 00:28:14.326 A:middle
最后 我们为集合添加了

00:28:14.326 --> 00:28:17.116 A:middle
shuffle 方法

00:28:17.116 --> 00:28:18.926 A:middle
可以生成一个

00:28:18.926 --> 00:28:21.616 A:middle
该集合元素的随机排列组合的数组

00:28:22.146 --> 00:28:25.216 A:middle
我们认为 默认的随机数

00:28:25.216 --> 00:28:26.636 A:middle
生成器（Random Number Generator）

00:28:26.636 --> 00:28:27.996 A:middle
适合大多数 App

00:28:28.296 --> 00:28:29.883 A:middle
但你也可以采用自己的算法

00:28:30.676 --> 00:28:31.836 A:middle
现在 有了新的

00:28:31.836 --> 00:28:34.206 A:middle
RandomNumberGenerator 协议

00:28:34.206 --> 00:28:35.606 A:middle
一旦你创建一个符合

00:28:35.606 --> 00:28:37.826 A:middle
该协议的类型 就可以将它

00:28:37.826 --> 00:28:39.326 A:middle
传递给我提到的 API

00:28:39.326 --> 00:28:40.846 A:middle
API 拥有一个使用 using 参数的

00:28:40.846 --> 00:28:43.416 A:middle
额外重载（additional overload）

00:28:43.576 --> 00:28:44.706 A:middle
可以接收 RandomNumberGenerator

00:28:44.706 --> 00:28:45.236 A:middle
作为输入

00:28:46.746 --> 00:28:49.456 A:middle
好的 之前我们看到了

00:28:49.456 --> 00:28:51.446 A:middle
构建配置检查

00:28:51.526 --> 00:28:54.346 A:middle
我们再多了解一些

00:28:54.566 --> 00:28:56.806 A:middle
这是 Swift 中常见的情况

00:28:57.026 --> 00:28:58.356 A:middle
有一小段代码

00:28:58.356 --> 00:29:00.796 A:middle
在 iOS 和 macOS 间共用

00:28:58.356 --> 00:29:00.796 A:middle
在 iOS 和 macOS 间共用

00:29:00.796 --> 00:29:03.836 A:middle
在 iOS 上 你应该

00:29:03.836 --> 00:29:05.206 A:middle
使用 UIKit

00:29:05.586 --> 00:29:06.776 A:middle
在 macOS 上 你应该

00:29:06.776 --> 00:29:08.156 A:middle
使用 AppKit

00:29:08.896 --> 00:29:10.466 A:middle
现在要做到这一点

00:29:10.466 --> 00:29:11.816 A:middle
你要写一段 #if 代码

00:29:12.236 --> 00:29:14.186 A:middle
来进行编译时间检查

00:29:14.186 --> 00:29:15.386 A:middle
之后需要列出

00:29:15.386 --> 00:29:17.736 A:middle
支持 UIKit 的操作系统

00:29:18.566 --> 00:29:20.046 A:middle
但你真正关心的

00:29:20.046 --> 00:29:21.836 A:middle
不是你在运行

00:29:21.836 --> 00:29:23.016 A:middle
什么操作系统

00:29:23.016 --> 00:29:25.096 A:middle
而是导入 UIKit

00:29:25.626 --> 00:29:27.956 A:middle
Swift 4.2 中 我们添加了

00:29:27.956 --> 00:29:30.086 A:middle
canImport() 构建配置指令

00:29:30.086 --> 00:29:32.486 A:middle
（Build Configuration Directive）

00:29:32.486 --> 00:29:33.476 A:middle
帮助你表达本意

00:29:34.171 --> 00:29:36.171 A:middle
[ 掌声 ]

00:29:36.326 --> 00:29:38.026 A:middle
而利用 Swift 4.2 的新特性

00:29:38.026 --> 00:29:39.686 A:middle
我还可以进一步

00:29:39.686 --> 00:29:40.766 A:middle
完善代码

00:29:41.246 --> 00:29:43.326 A:middle
比方说 我还要

00:29:43.326 --> 00:29:44.966 A:middle
专门检查 AppKit

00:29:45.306 --> 00:29:47.036 A:middle
如果 UIKit 和

00:29:47.036 --> 00:29:48.866 A:middle
AppKit 都不可用

00:29:48.866 --> 00:29:50.576 A:middle
例如我在 Linux 上构建

00:29:50.576 --> 00:29:52.356 A:middle
我就可以使用新的 #error

00:29:52.546 --> 00:29:53.916 A:middle
构建指令来生成

00:29:53.916 --> 00:29:55.796 A:middle
编译时间错误信息

00:29:57.206 --> 00:29:59.376 A:middle
好的 还有一种类似的

00:29:59.376 --> 00:30:00.416 A:middle
鸡肋代码

00:29:59.376 --> 00:30:00.416 A:middle
鸡肋代码

00:30:01.616 --> 00:30:03.126 A:middle
如果我想在

00:30:03.126 --> 00:30:05.066 A:middle
模拟器环境中

00:30:05.066 --> 00:30:06.476 A:middle
编译代码

00:30:06.776 --> 00:30:09.266 A:middle
在 Swift 4 中 我需要

00:30:09.266 --> 00:30:11.546 A:middle
把这一段东西

00:30:11.546 --> 00:30:12.686 A:middle
拷贝 粘贴到所有我想要进行检查的地方 才能

00:30:12.686 --> 00:30:13.176 A:middle
进行检测

00:30:14.056 --> 00:30:16.456 A:middle
Swift 4.2 中 你可以使用新的

00:30:16.456 --> 00:30:18.596 A:middle
hasTargetEnvironment() 环境判断

00:30:18.906 --> 00:30:21.216 A:middle
来更好地表达本意

00:30:21.216 --> 00:30:23.006 A:middle
还可以直接询问

00:30:23.006 --> 00:30:25.026 A:middle
编译器 我是不是在

00:30:25.026 --> 00:30:26.106 A:middle
为模拟器编译

00:30:26.876 --> 00:30:28.826 A:middle
说到这里

00:30:28.826 --> 00:30:30.566 A:middle
我们再把 FIXME 换成

00:30:30.656 --> 00:30:32.036 A:middle
#warning 构建指令

00:30:32.076 --> 00:30:33.986 A:middle
来生成信息

00:30:34.046 --> 00:30:35.856 A:middle
或运行时间 提醒我别忘了

00:30:35.856 --> 00:30:38.126 A:middle
修复 FIXME

00:30:38.126 --> 00:30:40.916 A:middle
好的 这差不多就是

00:30:40.916 --> 00:30:42.306 A:middle
我今天要讲的

00:30:42.306 --> 00:30:43.516 A:middle
全部特性

00:30:43.516 --> 00:30:44.936 A:middle
但我还有几项要提一下

00:30:46.026 --> 00:30:47.646 A:middle
我们来解析一下

00:30:47.646 --> 00:30:48.586 A:middle
隐式解析选项（Implicitly Unwrapped

00:30:48.806 --> 00:30:49.646 A:middle
Optionals） 这个梗没效果啊

00:30:50.296 --> 00:30:52.986 A:middle
好吧 隐式解析选项

00:30:52.986 --> 00:30:54.326 A:middle
可能会有点

00:30:54.326 --> 00:30:57.686 A:middle
让人疑惑 我们先来

00:30:57.686 --> 00:31:00.196 A:middle
看看它的思维模型

00:30:57.686 --> 00:31:00.196 A:middle
看看它的思维模型

00:31:00.196 --> 00:31:01.266 A:middle
应该如何理解它

00:31:01.966 --> 00:31:04.426 A:middle
从 Swift 3 开始

00:31:04.426 --> 00:31:06.326 A:middle
不是表达式的一种类型

00:31:06.816 --> 00:31:08.006 A:middle
不要认为它是一种类型

00:31:08.446 --> 00:31:09.856 A:middle
而要认为

00:31:09.856 --> 00:31:11.256 A:middle
它是声明的

00:31:11.256 --> 00:31:13.096 A:middle
特性之一

00:31:13.996 --> 00:31:15.756 A:middle
当你引用这种声明是

00:31:15.756 --> 00:31:17.526 A:middle
编译器会首先

00:31:17.846 --> 00:31:19.186 A:middle
检查它的类型

00:31:19.186 --> 00:31:21.536 A:middle
看它是不是普通的选项

00:31:21.536 --> 00:31:23.006 A:middle
如果在它的使用场景中

00:31:23.006 --> 00:31:24.556 A:middle
它不合理

00:31:24.746 --> 00:31:26.916 A:middle
编译器就会将其解析

00:31:26.916 --> 00:31:28.096 A:middle
进行类型检查 将其标记为

00:31:28.096 --> 00:31:28.876 A:middle
下划线类型（underlined type）

00:31:30.296 --> 00:31:31.746 A:middle
我们来看看第一种

00:31:31.746 --> 00:31:32.506 A:middle
情况的例子

00:31:33.236 --> 00:31:34.886 A:middle
这里有两个函数

00:31:34.966 --> 00:31:36.596 A:middle
第一个会生成

00:31:36.596 --> 00:31:37.906 A:middle
整型的隐式解析选项

00:31:37.906 --> 00:31:39.656 A:middle
第二个则会接受

00:31:39.656 --> 00:31:41.226 A:middle
任何类型的传入值

00:31:41.836 --> 00:31:43.306 A:middle
我要用第一个函数的

00:31:43.306 --> 00:31:45.256 A:middle
结果 来调用第二个函数

00:31:45.916 --> 00:31:47.966 A:middle
这个例子中 我可以

00:31:47.966 --> 00:31:50.506 A:middle
在任意（Any）类型中存入整型选项

00:31:50.856 --> 00:31:53.206 A:middle
不会进行强制解析

00:31:53.466 --> 00:31:55.896 A:middle
值会变成一个普通的选项

00:31:55.896 --> 00:31:59.966 A:middle
我们再看看第二种情况的例子

00:32:00.876 --> 00:32:02.856 A:middle
现在 第一个函数生成

00:32:02.856 --> 00:32:05.486 A:middle
对不起 第二个函数

00:32:05.486 --> 00:32:07.086 A:middle
现在接受整型

00:32:07.516 --> 00:32:09.066 A:middle
如果我使用第一个函数的

00:32:09.066 --> 00:32:10.646 A:middle
结果 调用第二个

00:32:10.706 --> 00:32:13.006 A:middle
函数 我就不能

00:32:13.086 --> 00:32:14.986 A:middle
传递整型选项 因为

00:32:14.986 --> 00:32:16.126 A:middle
函数需要整型

00:32:16.596 --> 00:32:18.246 A:middle
所以 编译器必须进行

00:32:18.246 --> 00:32:21.296 A:middle
强制解析 之后

00:32:21.296 --> 00:32:22.656 A:middle
代码运行正常 因为这里需要整型

00:32:22.836 --> 00:32:26.266 A:middle
也传入了整型 这个思维模型

00:32:26.346 --> 00:32:27.626 A:middle
可以很好地

00:32:27.626 --> 00:32:29.506 A:middle
帮助理解隐式解析选项

00:32:30.206 --> 00:32:32.566 A:middle
但直到最近 编译器

00:32:32.776 --> 00:32:34.166 A:middle
还是会遇到一些不遵从

00:32:34.166 --> 00:32:35.636 A:middle
此模型的极端案例

00:32:36.316 --> 00:32:38.956 A:middle
所以记住 隐式解析选项

00:32:38.956 --> 00:32:41.696 A:middle
不能是其他类型的一部分

00:32:42.416 --> 00:32:43.706 A:middle
Swift 4.2 中

00:32:43.706 --> 00:32:44.646 A:middle
依然如此

00:32:44.816 --> 00:32:46.616 A:middle
数组不能包含

00:32:46.676 --> 00:32:48.296 A:middle
隐式解析整型

00:32:49.136 --> 00:32:51.566 A:middle
但在 Swift 4 中

00:32:51.876 --> 00:32:53.536 A:middle
有一些像这样的极端案例

00:32:53.536 --> 00:32:55.606 A:middle
我可以定义一个 typealias

00:32:55.796 --> 00:32:57.596 A:middle
它的实际类型可以是

00:32:57.776 --> 00:32:59.606 A:middle
隐式解析整型

00:32:59.606 --> 00:33:00.956 A:middle
接下来 我就可以用这个

00:32:59.606 --> 00:33:00.956 A:middle
接下来 我就可以用这个

00:33:01.016 --> 00:33:03.166 A:middle
typealias 创建数组

00:33:03.166 --> 00:33:04.756 A:middle
从而使编译器的行为

00:33:04.756 --> 00:33:06.906 A:middle
匪夷所思 令代码难以理解

00:33:07.596 --> 00:33:09.516 A:middle
因此 在 Swift 4.2 中 我们

00:33:09.516 --> 00:33:10.816 A:middle
重新采用了

00:33:10.816 --> 00:33:12.556 A:middle
隐式解析选项

00:33:12.666 --> 00:33:14.736 A:middle
完美契合我之前

00:33:14.736 --> 00:33:17.186 A:middle
提到的思维模型

00:33:17.386 --> 00:33:19.226 A:middle
这一段匪夷所思的代码

00:33:19.226 --> 00:33:20.986 A:middle
现在会生成编译时间错误

00:33:21.306 --> 00:33:23.586 A:middle
编译器也会将其

00:33:23.946 --> 00:33:25.816 A:middle
按照普通整型数组

00:33:25.816 --> 00:33:27.576 A:middle
或整型选项数组来解析

00:33:28.546 --> 00:33:30.836 A:middle
大多数代码不会

00:33:30.836 --> 00:33:32.266 A:middle
因隐式解析选项的

00:33:32.266 --> 00:33:33.626 A:middle
这一变化而受影响

00:33:34.036 --> 00:33:35.436 A:middle
但如果你碰巧

00:33:35.436 --> 00:33:37.426 A:middle
用到了这些极端案例

00:33:37.426 --> 00:33:38.696 A:middle
我建议你看一看

00:33:38.746 --> 00:33:41.096 A:middle
Swift.org 上的这篇博客文章

00:33:41.096 --> 00:33:42.486 A:middle
这篇文章包含更多细节

00:33:42.486 --> 00:33:44.736 A:middle
举了很多例子 来说明

00:33:44.736 --> 00:33:47.136 A:middle
变化的种类和方式

00:33:47.376 --> 00:33:50.566 A:middle
好的 还有最后一项

00:33:50.986 --> 00:33:52.566 A:middle
我们来谈谈内存

00:33:52.566 --> 00:33:53.866 A:middle
独占性检查（memory exclusivity checking）

00:33:55.196 --> 00:33:57.946 A:middle
大家还记得 在 Swift 4 中 我们

00:33:57.946 --> 00:33:59.896 A:middle
带来了所谓的

00:33:59.896 --> 00:34:01.386 A:middle
内存独占性检查

00:33:59.896 --> 00:34:01.386 A:middle
内存独占性检查

00:34:01.646 --> 00:34:02.896 A:middle
该功能结合了

00:34:02.956 --> 00:34:05.186 A:middle
运行时检查

00:34:05.436 --> 00:34:06.696 A:middle
和编译时检查

00:34:06.696 --> 00:34:08.856 A:middle
但一些功能受限

00:34:09.315 --> 00:34:10.976 A:middle
我们专门限制了

00:34:11.286 --> 00:34:13.376 A:middle
对同一内存区域的

00:34:13.376 --> 00:34:14.356 A:middle
重复访问

00:34:14.856 --> 00:34:15.656 A:middle
这意味着什么

00:34:15.815 --> 00:34:17.096 A:middle
我们来看个例子

00:34:17.666 --> 00:34:20.085 A:middle
这一段代码

00:34:20.085 --> 00:34:21.706 A:middle
为操作系统路径

00:34:21.896 --> 00:34:23.246 A:middle
实现了一个数据类型

00:34:23.766 --> 00:34:25.446 A:middle
表现为包含路径元素的

00:34:25.565 --> 00:34:27.005 A:middle
一个数组

00:34:27.576 --> 00:34:29.206 A:middle
还使用了 withAppended 方法

00:34:30.216 --> 00:34:31.946 A:middle
这个方法可以向数组中

00:34:31.946 --> 00:34:33.735 A:middle
添加元素 再调用 closure()

00:34:33.735 --> 00:34:35.806 A:middle
作用于你传入的元素

00:34:35.806 --> 00:34:37.626 A:middle
再将它从数组中移出

00:34:38.295 --> 00:34:40.036 A:middle
这段代码没有问题

00:34:40.036 --> 00:34:41.726 A:middle
在 Swift 4 中运行无误

00:34:42.755 --> 00:34:44.505 A:middle
但我们来看一下

00:34:44.505 --> 00:34:45.536 A:middle
Path 数据类型的使用

00:34:46.545 --> 00:34:47.976 A:middle
这个 path 变量

00:34:47.976 --> 00:34:49.746 A:middle
存储在局部变量中

00:34:50.056 --> 00:34:51.806 A:middle
我对它调用 withAppended 方法

00:34:52.295 --> 00:34:54.856 A:middle
在 closure 中 我再访问

00:34:54.856 --> 00:34:56.306 A:middle
这个局部变量

00:34:56.536 --> 00:34:57.056 A:middle
并将它打印出来

00:34:57.556 --> 00:34:58.696 A:middle
问题出在哪儿

00:34:59.436 --> 00:35:01.076 A:middle
事实上 这段代码

00:34:59.436 --> 00:35:01.076 A:middle
事实上 这段代码

00:35:01.076 --> 00:35:03.756 A:middle
有歧义 因为

00:35:03.756 --> 00:35:05.866 A:middle
当我访问 closure 中的

00:35:06.136 --> 00:35:08.436 A:middle
局部变量时 它已经被

00:35:08.436 --> 00:35:10.086 A:middle
withAppended

00:35:10.086 --> 00:35:11.686 A:middle
这一可变方法（mutating method）

00:35:11.686 --> 00:35:12.586 A:middle
修改过了

00:35:13.306 --> 00:35:16.136 A:middle
歧义之处在于

00:35:16.136 --> 00:35:18.466 A:middle
我所指的是 path

00:35:18.806 --> 00:35:20.556 A:middle
在调用 withAppended 之前的

00:35:20.556 --> 00:35:22.706 A:middle
原始值 还是

00:35:22.706 --> 00:35:24.106 A:middle
修改之后的

00:35:24.106 --> 00:35:25.926 A:middle
当前值

00:35:26.756 --> 00:35:28.636 A:middle
Swift 4 中 这是一处

00:35:28.636 --> 00:35:30.396 A:middle
编译时错误 因为

00:35:30.396 --> 00:35:32.226 A:middle
它违反了独占性

00:35:32.756 --> 00:35:34.716 A:middle
要解决这一问题

00:35:34.716 --> 00:35:35.976 A:middle
消除歧义 办法之一

00:35:35.976 --> 00:35:37.926 A:middle
是告诉编译器

00:35:37.926 --> 00:35:40.496 A:middle
我想要获得当前值 所以

00:35:40.496 --> 00:35:41.766 A:middle
我只将其作为参数

00:35:41.766 --> 00:35:44.986 A:middle
传入 closure 而不去捕获它

00:35:45.586 --> 00:35:47.936 A:middle
可以 但再看看这个例子

00:35:48.266 --> 00:35:49.586 A:middle
这个函数和刚才的

00:35:49.586 --> 00:35:51.376 A:middle
几乎相同 除了这是一个泛型

00:35:51.376 --> 00:35:53.326 A:middle
函数 参数由

00:35:53.326 --> 00:35:54.646 A:middle
closure 返回值的类型决定

00:35:55.306 --> 00:35:57.436 A:middle
这个例子中 我们会遇到

00:35:57.436 --> 00:35:59.286 A:middle
类似的歧义 因为

00:35:59.286 --> 00:36:01.246 A:middle
要从闭包内部获得

00:35:59.286 --> 00:36:01.246 A:middle
要从闭包内部获得

00:36:01.246 --> 00:36:02.166 A:middle
path 的值

00:36:02.496 --> 00:36:04.766 A:middle
但 Swift 4 无法在

00:36:04.766 --> 00:36:06.866 A:middle
编译时捕获到这个错误

00:36:08.286 --> 00:36:10.436 A:middle
Swift 4.2 中 我们改进了

00:36:10.436 --> 00:36:12.526 A:middle
静态独占性检查（static exclusivity

00:36:12.526 --> 00:36:15.256 A:middle
checking） 可以在更多情况下 指出这样的歧义

00:36:16.386 --> 00:36:18.546 A:middle
除了改进

00:36:19.146 --> 00:36:20.526 A:middle
好吧 你还可以用类似方法

00:36:20.526 --> 00:36:22.236 A:middle
将变量值作为

00:36:22.236 --> 00:36:23.566 A:middle
closure 的参数传入

00:36:23.566 --> 00:36:24.026 A:middle
来消除歧义

00:36:24.576 --> 00:36:26.876 A:middle
除了改进

00:36:26.876 --> 00:36:28.986 A:middle
静态检查 我们还新增了

00:36:28.986 --> 00:36:30.796 A:middle
使用运行时独占性检查

00:36:30.796 --> 00:36:32.906 A:middle
和释放构造的功能

00:36:33.336 --> 00:36:35.166 A:middle
这会牺牲一些性能

00:36:35.166 --> 00:36:36.606 A:middle
但如果你的 App 不注重

00:36:36.606 --> 00:36:38.096 A:middle
性能 我们鼓励你尝试一下

00:36:38.096 --> 00:36:39.746 A:middle
并且始终开启

00:36:39.746 --> 00:36:40.216 A:middle
这一功能

00:36:40.686 --> 00:36:42.386 A:middle
未来 我们会将

00:36:42.386 --> 00:36:44.236 A:middle
动态检查的性能损耗

00:36:44.306 --> 00:36:46.276 A:middle
大幅降低 这样就可以

00:36:46.276 --> 00:36:48.126 A:middle
始终开启这一功能

00:36:48.186 --> 00:36:49.226 A:middle
这一功能还能带来

00:36:49.226 --> 00:36:50.846 A:middle
额外保护 就像

00:36:50.896 --> 00:36:53.296 A:middle
数组边界检查（array bounds checking）

00:36:53.296 --> 00:36:54.596 A:middle
或整型溢出检查（integer overflow checking）

00:36:55.166 --> 00:36:58.316 A:middle
一样 Swift 4.2 中还有

00:36:58.316 --> 00:37:01.576 A:middle
很多我没有涉及的特性

00:36:58.316 --> 00:37:01.576 A:middle
很多我没有涉及的特性

00:37:02.096 --> 00:37:03.716 A:middle
我们鼓励大家

00:37:03.716 --> 00:37:05.496 A:middle
在现有 App 中尝试

00:37:05.546 --> 00:37:06.776 A:middle
我们希望大家多尝试

00:37:06.776 --> 00:37:08.536 A:middle
新特性 如果有

00:37:08.536 --> 00:37:10.056 A:middle
任何问题 欢迎来到

00:37:10.056 --> 00:37:11.966 A:middle
实验室 咨询我们

00:37:12.556 --> 00:37:12.956 A:middle
谢谢

00:37:14.516 --> 00:37:19.500 A:middle
[ 掌声 ]
