WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:19.516 --> 00:00:25.176 A:middle
[ 掌声 ]

00:00:25.676 --> 00:00:26.186 A:middle
&gt;&gt; 下午好

00:00:27.166 --> 00:00:28.956 A:middle
欢迎大家 我叫 Ken Ferry

00:00:29.246 --> 00:00:31.536 A:middle
今天我与 Kasia Wawer 将会给大家介绍

00:00:31.536 --> 00:00:32.686 A:middle
Auto Layout 的性能

00:00:33.666 --> 00:00:35.466 A:middle
上一次我站在这里谈论

00:00:35.466 --> 00:00:37.446 A:middle
Auto Layout 是 2011 年

00:00:38.056 --> 00:00:39.356 A:middle
当时我们刚刚推出这个功能

00:00:39.726 --> 00:00:42.216 A:middle
所以我很高兴可以回到这里

00:00:42.316 --> 00:00:43.446 A:middle
与你们一起探讨这个功能

00:00:44.956 --> 00:00:48.896 A:middle
好的 下面说 Auto Layout

00:00:49.796 --> 00:00:51.366 A:middle
我们像这样把内容

00:00:51.576 --> 00:00:52.916 A:middle
放置在 Mac 的 iOS 系统中

00:00:53.486 --> 00:00:55.096 A:middle
其中主要涉及的是

00:00:55.096 --> 00:00:57.456 A:middle
我们熟知的视图和约束

00:00:58.246 --> 00:00:59.096 A:middle
其中约束定义

00:00:59.096 --> 00:01:00.406 A:middle
视图之间的关系

00:00:59.096 --> 00:01:00.406 A:middle
视图之间的关系

00:01:01.206 --> 00:01:02.826 A:middle
那么关于性能

00:01:03.126 --> 00:01:04.756 A:middle
我想其中的挑战在于

00:01:04.756 --> 00:01:07.276 A:middle
如果只说这两个按钮的

00:01:07.416 --> 00:01:09.286 A:middle
间距为 20

00:01:09.286 --> 00:01:10.446 A:middle
就很难去理解机器

00:01:10.446 --> 00:01:12.606 A:middle
如何一步一步

00:01:12.606 --> 00:01:13.936 A:middle
完成这个过程

00:01:14.226 --> 00:01:15.466 A:middle
也就是说 很难去

00:01:15.466 --> 00:01:17.726 A:middle
正确理解对

00:01:17.726 --> 00:01:18.736 A:middle
其性能的期望

00:01:18.736 --> 00:01:19.826 A:middle
并了解什么运行得快

00:01:19.826 --> 00:01:21.296 A:middle
什么运行的慢 以及一般情况下

00:01:21.296 --> 00:01:22.006 A:middle
整个过程是如何工作的

00:01:22.986 --> 00:01:25.156 A:middle
这就是我们今天的目的

00:01:25.456 --> 00:01:29.556 A:middle
今天的目标是 真正理解并掌握整个过程如何运作

00:01:29.896 --> 00:01:31.146 A:middle
那么我们就

00:01:31.146 --> 00:01:32.696 A:middle
首先展示一些

00:01:32.696 --> 00:01:33.826 A:middle
我们在过去为了

00:01:33.826 --> 00:01:35.556 A:middle
iOS 12 发布而做的

00:01:35.556 --> 00:01:36.096 A:middle
性能方面的工作

00:01:36.436 --> 00:01:37.256 A:middle
我们有很多成果

00:01:37.706 --> 00:01:40.286 A:middle
在演讲中会进行介绍

00:01:41.206 --> 00:01:44.646 A:middle
这之后我们将会

00:01:44.646 --> 00:01:46.166 A:middle
讨论如何建立起

00:01:46.166 --> 00:01:48.376 A:middle
我刚才说的那种一步一步的理解

00:01:48.686 --> 00:01:50.506 A:middle
这样我们对于性能有

00:01:50.506 --> 00:01:52.006 A:middle
较好的判断和较好的期望

00:01:52.456 --> 00:01:53.626 A:middle
为此我们将会做

00:01:53.626 --> 00:01:55.496 A:middle
一些不寻常的事情

00:01:55.786 --> 00:01:57.076 A:middle
我们会谈到一些内在问题

00:01:57.746 --> 00:01:58.756 A:middle
请尽情享受

00:02:02.546 --> 00:02:04.756 A:middle
最后 如果你只依赖于

00:02:04.756 --> 00:02:06.316 A:middle
对性能的直观判断

00:02:06.546 --> 00:02:07.896 A:middle
这远远不够

00:02:08.286 --> 00:02:10.776 A:middle
那么我们将有请 Kasia

00:02:10.776 --> 00:02:12.376 A:middle
上台来分析代码

00:02:12.506 --> 00:02:14.686 A:middle
我们将会展示如何

00:02:14.686 --> 00:02:16.696 A:middle
将你的直观判断与

00:02:16.916 --> 00:02:17.736 A:middle
实践结合起来

00:02:18.846 --> 00:02:20.126 A:middle
现在开始吧

00:02:20.436 --> 00:02:22.226 A:middle
首先 作为一个

00:02:22.226 --> 00:02:23.326 A:middle
Apple 展示的传统

00:02:23.326 --> 00:02:24.676 A:middle
我们先来看到一些数据和自夸

00:02:25.516 --> 00:02:28.796 A:middle
[ 笑声 ]

00:02:29.296 --> 00:02:31.116 A:middle
我们目前看到的是

00:02:31.116 --> 00:02:32.806 A:middle
一个基准测试

00:02:33.416 --> 00:02:35.456 A:middle
我们进行工作的方法是

00:02:35.456 --> 00:02:37.536 A:middle
去寻找并查看

00:02:37.536 --> 00:02:38.816 A:middle
一些第三方 App

00:02:38.816 --> 00:02:40.406 A:middle
也包括我们自己的 App

00:02:40.406 --> 00:02:41.906 A:middle
并试图将看到的内容提取

00:02:41.906 --> 00:02:44.646 A:middle
为测试案例

00:02:44.646 --> 00:02:45.476 A:middle
因此我们可以进行基准测试

00:02:45.996 --> 00:02:47.056 A:middle
那么我们看到的

00:02:47.056 --> 00:02:49.006 A:middle
就是 UICollectionView

00:02:49.006 --> 00:02:51.486 A:middle
它具有自动调节大小的单元格

00:02:51.706 --> 00:02:53.236 A:middle
看起来糟糕的那一边

00:02:53.436 --> 00:03:00.086 A:middle
就是 iOS 11 它看起来很差劲

00:02:53.436 --> 00:03:00.086 A:middle
就是 iOS 11 它看起来很差劲

00:03:00.266 --> 00:03:02.946 A:middle
而在 iOS 12 中它表现完美

00:03:03.216 --> 00:03:04.116 A:middle
达到了全帧速率

00:03:05.096 --> 00:03:07.586 A:middle
这就是我们所关注的案例之一

00:03:07.896 --> 00:03:10.846 A:middle
这里还有一些其他的样本

00:03:10.846 --> 00:03:11.806 A:middle
这样的样本我们有很多

00:03:12.526 --> 00:03:14.186 A:middle
这些都是关于时间的

00:03:14.766 --> 00:03:16.446 A:middle
你们所看到的

00:03:16.446 --> 00:03:18.176 A:middle
灰色的条形代表 iOS 11

00:03:18.346 --> 00:03:19.666 A:middle
即在 iOS 11 上所需的时间

00:03:20.016 --> 00:03:21.506 A:middle
蓝色的代表 iOS 12

00:03:22.936 --> 00:03:24.236 A:middle
你们可以看到的是

00:03:24.236 --> 00:03:25.516 A:middle
我们发现很多地方

00:03:25.516 --> 00:03:27.476 A:middle
都有很大的改进空间

00:03:28.076 --> 00:03:31.546 A:middle
而这些会对你们的 App 有帮助

00:03:31.676 --> 00:03:32.646 A:middle
这会让产品

00:03:32.856 --> 00:03:35.616 A:middle
变得更好 希望如此

00:03:35.616 --> 00:03:36.896 A:middle
改进存在于整个

00:03:36.896 --> 00:03:37.466 A:middle
堆栈的过程

00:03:37.766 --> 00:03:39.336 A:middle
其中有的位于

00:03:39.336 --> 00:03:41.676 A:middle
核心中 可以影响到方方面面

00:03:42.166 --> 00:03:44.366 A:middle
有的存在于 UI Kit 中

00:03:44.366 --> 00:03:45.486 A:middle
有的则是存在于客户

00:03:45.486 --> 00:03:48.326 A:middle
层面 关于如何使用 Auto Layout

00:03:48.716 --> 00:03:51.246 A:middle
比如说 UICollectionView 基准测试

00:03:51.606 --> 00:03:52.776 A:middle
也就是刚刚展示的

00:03:52.776 --> 00:03:53.536 A:middle
就包括所有改进

00:03:54.016 --> 00:03:55.846 A:middle
它包括了

00:03:55.846 --> 00:03:57.386 A:middle
核心部分的 也包括了

00:03:57.446 --> 00:03:58.856 A:middle
一些非常

00:03:58.856 --> 00:04:00.236 A:middle
重要的改进

00:03:58.856 --> 00:04:00.236 A:middle
重要的改进

00:04:00.236 --> 00:04:01.876 A:middle
是关于 UICollectionView 如何

00:04:01.876 --> 00:04:03.576 A:middle
使用 Auto Layout 如何展现

00:04:04.296 --> 00:04:04.866 A:middle
更高的性能的

00:04:05.376 --> 00:04:07.186 A:middle
这对于接下来的演讲

00:04:07.186 --> 00:04:09.186 A:middle
是一个不错的例子

00:04:09.256 --> 00:04:10.116 A:middle
你们也可以做到

00:04:10.676 --> 00:04:11.786 A:middle
那应该如何正确使用它呢

00:04:12.606 --> 00:04:14.286 A:middle
当我们完成这些工作后

00:04:15.026 --> 00:04:16.505 A:middle
我常常会想到

00:04:16.505 --> 00:04:17.956 A:middle
我们之所以能够完成

00:04:17.956 --> 00:04:19.375 A:middle
这些改进是因为

00:04:19.375 --> 00:04:21.786 A:middle
我们有一个很好的心智模型

00:04:21.786 --> 00:04:24.336 A:middle
关于事物如何组建以及

00:04:24.366 --> 00:04:26.226 A:middle
如何执行 如何工作

00:04:27.366 --> 00:04:29.756 A:middle
我们希望帮助你们也构建起这一模型

00:04:30.286 --> 00:04:31.876 A:middle
为此我们会先

00:04:31.876 --> 00:04:34.126 A:middle
探讨一个示例

00:04:34.126 --> 00:04:36.726 A:middle
一些客户端代码

00:04:36.726 --> 00:04:38.676 A:middle
它们有一些问题 我们将会讨论问题的原因

00:04:39.266 --> 00:04:40.796 A:middle
你的代码或许不一定有

00:04:40.796 --> 00:04:42.166 A:middle
一模一样的问题 但我们

00:04:42.166 --> 00:04:43.226 A:middle
选择的是

00:04:43.226 --> 00:04:44.636 A:middle
我们认为

00:04:44.636 --> 00:04:45.816 A:middle
在看到的这些

00:04:46.056 --> 00:04:47.496 A:middle
客户端 App 中最为常见的问题

00:04:48.096 --> 00:04:49.146 A:middle
就算你没有这个

00:04:49.146 --> 00:04:50.876 A:middle
问题 我们所做的

00:04:50.876 --> 00:04:52.476 A:middle
对问题的探讨

00:04:52.706 --> 00:04:53.596 A:middle
将会对每个人都有所帮助

00:04:53.596 --> 00:04:56.026 A:middle
而且可能对所有人来说 都是新的内容

00:04:56.876 --> 00:04:58.426 A:middle
那么我们开始吧

00:04:59.656 --> 00:05:01.436 A:middle
这个示例是我们即将探讨的

00:04:59.656 --> 00:05:01.436 A:middle
这个示例是我们即将探讨的

00:05:01.436 --> 00:05:04.516 A:middle
要产生这个布局 显然非常简单

00:05:05.106 --> 00:05:06.976 A:middle
我想你们应该经常

00:05:06.976 --> 00:05:08.046 A:middle
在 Interface Builder 中创建它

00:05:08.806 --> 00:05:09.756 A:middle
这个做法很聪明

00:05:09.876 --> 00:05:11.716 A:middle
因为这样就能够

00:05:11.716 --> 00:05:12.786 A:middle
完全避免

00:05:12.786 --> 00:05:13.896 A:middle
我们可能遇到的

00:05:13.896 --> 00:05:15.796 A:middle
性能问题

00:05:16.076 --> 00:05:18.976 A:middle
那么假设我们没有这么做

00:05:19.406 --> 00:05:21.886 A:middle
假设我们像这样创建布局

00:05:24.066 --> 00:05:25.216 A:middle
让我们先大致看一看

00:05:25.216 --> 00:05:26.406 A:middle
再进行分析

00:05:26.406 --> 00:05:27.796 A:middle
首先看一看 这些代码是做什么的

00:05:28.826 --> 00:05:31.316 A:middle
首先我们覆写

00:05:31.316 --> 00:05:33.226 A:middle
UIView 中的 updateConstraints 方法

00:05:33.866 --> 00:05:34.976 A:middle
不管它是做什么的

00:05:35.366 --> 00:05:37.426 A:middle
后面会谈到它

00:05:37.916 --> 00:05:42.476 A:middle
接着 我们有一个成员变量叫 myConstraints

00:05:42.716 --> 00:05:45.446 A:middle
我们提取这个

00:05:45.446 --> 00:05:46.436 A:middle
变量中的所有内容

00:05:46.436 --> 00:05:47.836 A:middle
并停用所有的约束

00:05:48.586 --> 00:05:49.516 A:middle
我们然后创建

00:05:49.516 --> 00:05:51.176 A:middle
约束 这些约束

00:05:51.176 --> 00:05:52.416 A:middle
实现我们刚刚看到的布局

00:05:53.006 --> 00:05:54.106 A:middle
这非常直白

00:05:54.106 --> 00:05:55.546 A:middle
使用的是视觉格式语言

00:05:56.276 --> 00:05:57.276 A:middle
然后我们执行这些

00:05:57.276 --> 00:05:58.776 A:middle
约束 安装它们

00:05:59.236 --> 00:06:00.296 A:middle
最后我们调用

00:05:59.236 --> 00:06:00.296 A:middle
最后我们调用

00:06:00.296 --> 00:06:02.356 A:middle
super.updateConstraints

00:06:02.356 --> 00:06:04.256 A:middle
这很重要 因为这个方法

00:06:04.586 --> 00:06:08.976 A:middle
对 UIView 层面的执行很有用

00:06:09.166 --> 00:06:10.966 A:middle
好的 这就是基本的结构

00:06:11.436 --> 00:06:15.306 A:middle
表明了它的目的 并且确实可用有效果

00:06:15.906 --> 00:06:18.676 A:middle
但是我们接下来

00:06:18.676 --> 00:06:20.136 A:middle
进一步探讨它的运行过程

00:06:20.136 --> 00:06:21.276 A:middle
让我们更好地了解其性能

00:06:22.016 --> 00:06:23.116 A:middle
那么首先要了解的

00:06:23.116 --> 00:06:24.736 A:middle
就是到底什么是

00:06:24.856 --> 00:06:26.906 A:middle
updateConstraints 即我们正在覆写的方法

00:06:28.316 --> 00:06:30.646 A:middle
它属于渲染循环

00:06:31.636 --> 00:06:33.266 A:middle
渲染循环是一个过程

00:06:33.506 --> 00:06:36.476 A:middle
它每秒钟可用运行高达 120 次

00:06:37.216 --> 00:06:38.976 A:middle
从而确保所有内容

00:06:38.976 --> 00:06:40.656 A:middle
出现在每一帧上

00:06:41.656 --> 00:06:43.786 A:middle
好的 它包含 3 个阶段

00:06:43.786 --> 00:06:45.066 A:middle
分别是更新约束

00:06:45.066 --> 00:06:46.386 A:middle
布局与显示

00:06:47.096 --> 00:06:49.246 A:middle
首先所有需要的视图都会

00:06:49.246 --> 00:06:50.916 A:middle
收到 updateConstraints

00:06:51.306 --> 00:06:53.306 A:middle
然后从最末端的

00:06:53.306 --> 00:06:55.096 A:middle
视图开始 沿着视图层级向上运行

00:06:55.096 --> 00:06:55.786 A:middle
最终到达窗口

00:06:56.656 --> 00:06:59.086 A:middle
接着 每个视图会收到 layoutSubView

00:06:59.366 --> 00:07:00.616 A:middle
它沿着相反方向运行

00:06:59.366 --> 00:07:00.616 A:middle
它沿着相反方向运行

00:07:00.616 --> 00:07:02.516 A:middle
从窗口向下直到末端

00:07:03.176 --> 00:07:05.886 A:middle
最后 所有视图按需求提取

00:07:05.886 --> 00:07:07.856 A:middle
差不多就是这样

00:07:08.636 --> 00:07:11.166 A:middle
好的 那么这是为什么呢

00:07:11.166 --> 00:07:12.156 A:middle
它们为什么存在

00:07:13.306 --> 00:07:14.736 A:middle
它们全部具有完全

00:07:14.736 --> 00:07:17.016 A:middle
相同的目的以及完全

00:07:17.056 --> 00:07:18.226 A:middle
平行的方法

00:07:18.646 --> 00:07:20.586 A:middle
这个目的就是防止

00:07:20.846 --> 00:07:23.966 A:middle
工作的浪费 我后面会举例子解释

00:07:24.856 --> 00:07:28.516 A:middle
一个 UI 标签需要

00:07:28.516 --> 00:07:30.346 A:middle
约束来表述

00:07:30.576 --> 00:07:33.466 A:middle
其文本的尺寸 对吗

00:07:34.056 --> 00:07:34.986 A:middle
但是 有很多属性

00:07:34.986 --> 00:07:36.126 A:middle
都与文本尺寸相关

00:07:36.406 --> 00:07:37.426 A:middle
比如有文本本身属性

00:07:37.426 --> 00:07:39.936 A:middle
还有字体 以及

00:07:39.936 --> 00:07:41.356 A:middle
文本尺寸 等等

00:07:41.936 --> 00:07:44.946 A:middle
一种方法是每次这些

00:07:44.946 --> 00:07:47.576 A:middle
属性出现变化时 去重新测量你的文本

00:07:48.556 --> 00:07:52.096 A:middle
但是 那往往效率极低 因为

00:07:52.096 --> 00:07:53.766 A:middle
一般会连续改变多个属性

00:07:54.206 --> 00:07:55.076 A:middle
当你首次设置一个标签时

00:07:55.076 --> 00:07:56.176 A:middle
你可能会

00:07:56.176 --> 00:07:57.306 A:middle
调用一批此类属性设置

00:07:57.306 --> 00:07:58.506 A:middle
那么如果你

00:07:58.506 --> 00:07:59.976 A:middle
每次都重新测量文本

00:08:00.506 --> 00:08:01.536 A:middle
所有的中间环节就被

00:08:01.536 --> 00:08:02.856 A:middle
浪费了 你事实上只想

00:08:02.856 --> 00:08:03.516 A:middle
在完成后进行测量

00:08:03.816 --> 00:08:05.316 A:middle
那么这就是渲染循环为你做的

00:08:05.876 --> 00:08:07.656 A:middle
这样你只需选择

00:08:08.086 --> 00:08:10.646 A:middle
对于设置的字体调用

00:08:10.646 --> 00:08:13.206 A:middle
setNeedsUpdateConstraints

00:08:13.336 --> 00:08:14.986 A:middle
然后你就可以确保

00:08:15.176 --> 00:08:17.366 A:middle
在设置后更新约束

00:08:17.436 --> 00:08:18.826 A:middle
且在这一帧出现在屏幕上之前完成

00:08:19.816 --> 00:08:20.456 A:middle
这就是它的作用

00:08:21.486 --> 00:08:22.876 A:middle
那么有一些事情

00:08:22.876 --> 00:08:24.386 A:middle
需要了解

00:08:24.386 --> 00:08:26.176 A:middle
第一 它运行次数多

00:08:26.176 --> 00:08:27.626 A:middle
每秒钟 120 帧

00:08:28.406 --> 00:08:30.346 A:middle
第二 它们是平行的

00:08:30.686 --> 00:08:32.696 A:middle
因此你也可以用作直觉判断

00:08:32.726 --> 00:08:33.866 A:middle
如果你觉得你理解了

00:08:33.866 --> 00:08:35.035 A:middle
布局部分的运行

00:08:35.035 --> 00:08:37.506 A:middle
或是有了一些感觉 那么你在思考

00:08:37.506 --> 00:08:39.256 A:middle
更新约束或显示时也是一样

00:08:40.155 --> 00:08:41.746 A:middle
最后一件事就是

00:08:41.746 --> 00:08:43.756 A:middle
它存在的原因是

00:08:43.756 --> 00:08:45.886 A:middle
避免工作浪费

00:08:45.886 --> 00:08:48.036 A:middle
延迟工作 甚至有可能跳过工作 完全跳过

00:08:49.006 --> 00:08:53.316 A:middle
好了 看完这些之后

00:08:53.316 --> 00:08:54.876 A:middle
我们现在可以

00:08:54.876 --> 00:08:56.156 A:middle
分析这一方法的其他部分

00:08:56.896 --> 00:08:59.476 A:middle
可以看到 每一次

00:08:59.476 --> 00:09:01.076 A:middle
调用时 我们都停用

00:08:59.476 --> 00:09:01.076 A:middle
调用时 我们都停用

00:09:01.276 --> 00:09:03.996 A:middle
一些约束 然后执行一些新的约束

00:09:05.406 --> 00:09:07.326 A:middle
这与 layoutSubViews 类似

00:09:07.706 --> 00:09:09.616 A:middle
假设我们在

00:09:09.616 --> 00:09:11.966 A:middle
layoutSubViews 中写了相同的代码

00:09:11.966 --> 00:09:14.076 A:middle
像是这样

00:09:14.476 --> 00:09:16.996 A:middle
每一次 layoutSubViews

00:09:16.996 --> 00:09:18.436 A:middle
被调用时 你就销毁了之前所有的

00:09:18.436 --> 00:09:20.236 A:middle
子视图 然后从头开始

00:09:20.236 --> 00:09:22.346 A:middle
创建 再添加它们

00:09:23.436 --> 00:09:25.596 A:middle
我相信很多人都会有

00:09:25.596 --> 00:09:26.836 A:middle
非常准确的

00:09:26.836 --> 00:09:27.946 A:middle
直觉判断 认为这可能不会

00:09:27.946 --> 00:09:28.726 A:middle
很好的执行

00:09:29.306 --> 00:09:31.916 A:middle
所以只需要记住的是

00:09:31.916 --> 00:09:33.266 A:middle
它们一样的

00:09:33.586 --> 00:09:34.976 A:middle
不管你对此有什么直觉判断

00:09:34.976 --> 00:09:36.436 A:middle
都可以用在

00:09:36.436 --> 00:09:37.756 A:middle
updateConstraints 上

00:09:38.046 --> 00:09:39.216 A:middle
当你这样停用

00:09:39.216 --> 00:09:40.336 A:middle
各种约束时

00:09:40.336 --> 00:09:43.156 A:middle
其实做了很多无用功 那么如何解决这个问题呢

00:09:43.766 --> 00:09:46.076 A:middle
你需要做的是

00:09:46.076 --> 00:09:47.116 A:middle
正如我们说的 你需要确定

00:09:47.116 --> 00:09:49.286 A:middle
你不会重复工作

00:09:49.506 --> 00:09:50.606 A:middle
这就是延迟工作

00:09:51.566 --> 00:09:53.076 A:middle
情况应该是这样的

00:09:53.076 --> 00:09:55.056 A:middle
我们询问是否已经做过这个工作了呢

00:09:55.636 --> 00:09:57.856 A:middle
如果做过了 那么就不要再做任何事

00:09:57.856 --> 00:09:58.886 A:middle
如果还没有做过

00:09:58.886 --> 00:09:59.976 A:middle
那么当然要设置这些约束 只做一次

00:10:00.046 --> 00:10:03.816 A:middle
这样就能很好地执行了 对吧

00:10:04.176 --> 00:10:05.956 A:middle
那么 就像之前说的

00:10:05.956 --> 00:10:07.916 A:middle
这实际上是

00:10:07.916 --> 00:10:09.636 A:middle
客户端代码中最常见的错误

00:10:09.866 --> 00:10:12.146 A:middle
我们称之为约束流失

00:10:12.846 --> 00:10:14.116 A:middle
即不必要的删除约束

00:10:14.116 --> 00:10:16.036 A:middle
然后再次添加它们

00:10:16.036 --> 00:10:17.326 A:middle
好的

00:10:17.886 --> 00:10:19.396 A:middle
我们还有很多要做

00:10:19.766 --> 00:10:21.196 A:middle
但是现在先等一下

00:10:21.386 --> 00:10:22.676 A:middle
回顾一下渲染循环

00:10:22.676 --> 00:10:23.626 A:middle
仔细思考

00:10:24.296 --> 00:10:26.576 A:middle
如果你确实需要渲染循环

00:10:26.576 --> 00:10:27.696 A:middle
那它非常好用

00:10:27.926 --> 00:10:29.066 A:middle
它的目的是

00:10:29.066 --> 00:10:31.236 A:middle
有助于避免那些冗余的工作

00:10:32.106 --> 00:10:34.386 A:middle
但它也比较危险 因为

00:10:34.616 --> 00:10:35.506 A:middle
运行次数过多

00:10:35.826 --> 00:10:38.036 A:middle
这个代码非常敏感

00:10:38.356 --> 00:10:41.236 A:middle
所以像这种情况 一般来说你使用

00:10:41.236 --> 00:10:43.486 A:middle
这样敏感的代码时

00:10:43.486 --> 00:10:44.336 A:middle
你应该在写代码时

00:10:44.336 --> 00:10:45.196 A:middle
小心谨慎 同时也应该

00:10:45.196 --> 00:10:46.956 A:middle
试图减少

00:10:46.956 --> 00:10:48.216 A:middle
写此类敏感代码的次数

00:10:48.616 --> 00:10:50.636 A:middle
因为你有可能会

00:10:50.636 --> 00:10:51.846 A:middle
把事情搞砸

00:10:52.166 --> 00:10:53.426 A:middle
我们都有搞砸的时候

00:10:53.426 --> 00:10:55.096 A:middle
所以在这种情况下

00:10:55.096 --> 00:10:55.986 A:middle
你真的应该考虑

00:10:55.986 --> 00:10:57.716 A:middle
我是否可以只做一次

00:10:57.716 --> 00:10:59.956 A:middle
而非把它放入

00:11:00.346 --> 00:11:01.256 A:middle
updateConstraints 中 完成这个工作的好办法

00:11:01.326 --> 00:11:03.936 A:middle
就是使用 Interface Builder

00:11:04.286 --> 00:11:05.796 A:middle
如果你可以使用 Interface Builder

00:11:06.026 --> 00:11:06.506 A:middle
你就应该使用它

00:11:07.496 --> 00:11:08.946 A:middle
它的好处体现在方方面面

00:11:08.946 --> 00:11:11.276 A:middle
可以让你走上正确的路径

00:11:11.466 --> 00:11:13.206 A:middle
好的 很好

00:11:13.346 --> 00:11:14.876 A:middle
既然我们现在已经讨论过了

00:11:14.876 --> 00:11:15.856 A:middle
我认为 我们已经更好地理解了

00:11:15.856 --> 00:11:17.286 A:middle
为什么这是有问题的

00:11:17.286 --> 00:11:20.266 A:middle
至少是通过类比

00:11:21.336 --> 00:11:22.486 A:middle
但是这个演讲的目的

00:11:22.486 --> 00:11:23.846 A:middle
要求我们做的比这更好

00:11:23.846 --> 00:11:26.336 A:middle
我们并不只想说这样不好

00:11:26.536 --> 00:11:28.376 A:middle
我们希望真正的理解它

00:11:28.376 --> 00:11:29.666 A:middle
真正地理解这个过程

00:11:30.366 --> 00:11:32.956 A:middle
为此我们需要

00:11:33.016 --> 00:11:34.816 A:middle
拨开表面

00:11:34.816 --> 00:11:36.976 A:middle
看到真正发生了什么事情

00:11:37.546 --> 00:11:43.096 A:middle
那么当我们启用约束 添加约束时

00:11:43.096 --> 00:11:45.626 A:middle
这个过程是什么样的呢

00:11:46.916 --> 00:11:48.276 A:middle
我们以图表的形式进行直观阐述

00:11:48.626 --> 00:11:50.856 A:middle
假设这是一个视图

00:11:50.856 --> 00:11:51.946 A:middle
我们想在其中添加约束

00:11:53.056 --> 00:11:55.596 A:middle
这个视图在一个窗口中

00:11:55.726 --> 00:11:57.406 A:middle
窗口挂着

00:11:57.406 --> 00:12:00.086 A:middle
一个内部对象叫做引擎

00:11:57.406 --> 00:12:00.086 A:middle
一个内部对象叫做引擎

00:12:00.516 --> 00:12:03.296 A:middle
引擎是 Auto Layout 的计算内核

00:12:03.816 --> 00:12:06.246 A:middle
在添加约束后

00:12:06.576 --> 00:12:10.336 A:middle
我们要创建

00:12:10.336 --> 00:12:12.146 A:middle
一个与约束对应的等式

00:12:12.146 --> 00:12:13.616 A:middle
然后我们将

00:12:13.616 --> 00:12:15.846 A:middle
该等式添加到引擎中

00:12:16.516 --> 00:12:18.306 A:middle
这个图表中最后一个

00:12:18.306 --> 00:12:19.906 A:middle
需要理解的问题是该等式

00:12:20.186 --> 00:12:22.996 A:middle
是关于变量的

00:12:22.996 --> 00:12:24.526 A:middle
而变量 举个例子

00:12:24.526 --> 00:12:25.936 A:middle
假设我给你一个等式 然后我说

00:12:25.936 --> 00:12:28.336 A:middle
解出 X 那么 X 就是变量

00:12:29.396 --> 00:12:30.666 A:middle
在这个情况下我们

00:12:30.666 --> 00:12:33.326 A:middle
需要解决的就是

00:12:33.326 --> 00:12:34.746 A:middle
视图的帧数据

00:12:35.166 --> 00:12:36.356 A:middle
对于每一个视图

00:12:36.356 --> 00:12:37.916 A:middle
将会有 4 个变量 分别是

00:12:37.916 --> 00:12:40.906 A:middle
X 轴坐标 Y轴坐标 宽度和高度

00:12:41.126 --> 00:12:43.956 A:middle
好的 那么让我们进入这一过程

00:12:44.276 --> 00:12:45.906 A:middle
这是我们将要创建的布局

00:12:45.906 --> 00:12:46.976 A:middle
简单起见我们仅关注

00:12:46.976 --> 00:12:48.166 A:middle
横向约束

00:12:48.166 --> 00:12:49.386 A:middle
但是我们会

00:12:49.386 --> 00:12:50.486 A:middle
考虑整个过程

00:12:51.356 --> 00:12:52.496 A:middle
那么第一件事

00:12:52.636 --> 00:12:53.996 A:middle
如我们刚才所说 就是我们

00:12:53.996 --> 00:12:55.536 A:middle
创建等式 看起来是这样子的

00:12:57.156 --> 00:12:58.366 A:middle
这些看起来非常直观

00:12:58.676 --> 00:13:00.656 A:middle
我认为最有趣的是

00:12:58.676 --> 00:13:00.656 A:middle
我认为最有趣的是

00:13:00.656 --> 00:13:01.936 A:middle
两个文本框之间的空间

00:13:01.936 --> 00:13:03.896 A:middle
它看起来像是

00:13:03.896 --> 00:13:05.366 A:middle
看起来非常

00:13:05.366 --> 00:13:07.656 A:middle
近似于你写的

00:13:07.656 --> 00:13:08.896 A:middle
约束 但它相对是

00:13:08.896 --> 00:13:10.416 A:middle
更低层级的 因为它是

00:13:10.416 --> 00:13:11.756 A:middle
关于这些变量的

00:13:13.376 --> 00:13:16.806 A:middle
好的 然后每个等式

00:13:16.806 --> 00:13:18.336 A:middle
都需要被添加到引擎

00:13:18.336 --> 00:13:20.546 A:middle
事实上我们将会

00:13:20.546 --> 00:13:22.596 A:middle
再次研究这一过程

00:13:22.596 --> 00:13:24.006 A:middle
目标是对于

00:13:24.006 --> 00:13:27.386 A:middle
性能特点有一个更好的把握

00:13:27.746 --> 00:13:28.846 A:middle
那么 当我们这么写时发生了什么?

00:13:29.856 --> 00:13:31.856 A:middle
引擎试图解出

00:13:31.856 --> 00:13:33.806 A:middle
这些变量

00:13:33.806 --> 00:13:36.086 A:middle
这跟你在代数中学到的很像

00:13:36.086 --> 00:13:38.936 A:middle
看起来也完全相同

00:13:38.936 --> 00:13:40.106 A:middle
那么我们一起来看

00:13:40.386 --> 00:13:42.166 A:middle
首先是第一个等式

00:13:42.166 --> 00:13:44.146 A:middle
表明第一个区域的 X 轴坐标是 8

00:13:44.486 --> 00:13:47.846 A:middle
好的 它的宽度为 100 好

00:13:48.436 --> 00:13:50.696 A:middle
好的 这个等式中我们定义

00:13:50.696 --> 00:13:52.106 A:middle
定义第二个区域的 X 轴坐标

00:13:52.106 --> 00:13:53.556 A:middle
等于第一个 X 坐标加上

00:13:53.556 --> 00:13:54.406 A:middle
该宽度再加 20

00:13:54.406 --> 00:13:57.096 A:middle
在代数中你会怎么做

00:13:57.096 --> 00:13:59.666 A:middle
如果有人要求你解出这些变量

00:14:00.956 --> 00:14:02.836 A:middle
你会用已知的

00:14:02.836 --> 00:14:03.996 A:middle
数据来进行替换

00:14:04.146 --> 00:14:05.646 A:middle
这就是接下来即将发生的事情

00:14:06.636 --> 00:14:08.486 A:middle
如果你进行程序剖析

00:14:08.486 --> 00:14:10.356 A:middle
会看到 引擎中确实有一个方法

00:14:10.356 --> 00:14:12.186 A:middle
包含替换这个词

00:14:12.186 --> 00:14:13.986 A:middle
同时还包含了其他的

00:14:13.986 --> 00:14:16.956 A:middle
140 个字符 因为我们是

00:14:16.956 --> 00:14:18.776 A:middle
Cocoa 编程开发者

00:14:18.776 --> 00:14:21.716 A:middle
这就是引擎将要做的

00:14:22.266 --> 00:14:23.726 A:middle
然后 你知道 最后一个

00:14:23.726 --> 00:14:26.726 A:middle
等式进入后 看起来就完成了

00:14:27.126 --> 00:14:29.106 A:middle
看上去这就是全部的

00:14:29.106 --> 00:14:30.636 A:middle
工作 至少针对

00:14:30.636 --> 00:14:32.656 A:middle
这个案例 就可以解出

00:14:32.656 --> 00:14:34.466 A:middle
全部变量 确实如此

00:14:35.006 --> 00:14:36.646 A:middle
这就是我此时要了解的

00:14:36.646 --> 00:14:39.856 A:middle
那就是这些工作

00:14:39.856 --> 00:14:40.546 A:middle
并不复杂

00:14:41.046 --> 00:14:42.856 A:middle
它的过程

00:14:42.856 --> 00:14:43.956 A:middle
和手工计算

00:14:43.956 --> 00:14:46.566 A:middle
非常非常近似

00:14:46.566 --> 00:14:47.916 A:middle
同时 它也并不是高消耗

00:14:48.266 --> 00:14:50.296 A:middle
它只不过是完成替换 就像这样

00:14:50.536 --> 00:14:51.626 A:middle
这就是它所做的工作

00:14:52.626 --> 00:14:54.976 A:middle
好的 那么现在我们已经

00:14:55.326 --> 00:14:56.686 A:middle
在引擎中解出了这些变量

00:14:56.686 --> 00:14:57.936 A:middle
但是这并不是一个布局

00:14:58.386 --> 00:15:00.716 A:middle
下面让我们完成这个过程

00:14:58.386 --> 00:15:00.716 A:middle
下面让我们完成这个过程

00:15:02.036 --> 00:15:03.106 A:middle
接下来的过程中

00:15:03.106 --> 00:15:06.506 A:middle
每当引擎将一个值赋给

00:15:06.506 --> 00:15:07.816 A:middle
其中一个变量

00:15:07.816 --> 00:15:09.746 A:middle
它都会告知视图

00:15:09.746 --> 00:15:11.246 A:middle
变量从何而来 并告知

00:15:11.246 --> 00:15:12.036 A:middle
它已发生变化

00:15:12.496 --> 00:15:15.406 A:middle
那么视图会做什么作为回应呢

00:15:16.526 --> 00:15:17.556 A:middle
如果你想一想

00:15:17.556 --> 00:15:20.956 A:middle
它会调用上级视图

00:15:20.956 --> 00:15:23.816 A:middle
并使用 setNeedsLayout 因为需要发生变动

00:15:25.226 --> 00:15:27.196 A:middle
好的 这就是

00:15:27.226 --> 00:15:30.216 A:middle
更新约束阶段的全部内容

00:15:31.136 --> 00:15:32.106 A:middle
现在我们已经收到了

00:15:32.106 --> 00:15:33.716 A:middle
setNeedsLayout 在某个时间点

00:15:33.716 --> 00:15:35.536 A:middle
就会进入布局阶段

00:15:36.696 --> 00:15:39.846 A:middle
好的 最后一块拼图

00:15:39.846 --> 00:15:40.846 A:middle
就是我们将会收到

00:15:40.846 --> 00:15:42.236 A:middle
UIView 将会收到

00:15:42.236 --> 00:15:45.776 A:middle
layoutSubViews 而它要做的就是

00:15:45.776 --> 00:15:47.816 A:middle
把这部分数据

00:15:47.816 --> 00:15:49.096 A:middle
从引擎中复制到帧

00:15:50.336 --> 00:15:52.356 A:middle
那么它会询问引擎

00:15:52.356 --> 00:15:53.956 A:middle
那些变量的值是多少

00:15:54.446 --> 00:15:56.676 A:middle
引擎将会告知它 该上级视图

00:15:56.676 --> 00:15:58.746 A:middle
就会在下级视图中

00:15:58.746 --> 00:16:02.076 A:middle
调用 setCenter 和 setBounds

00:15:58.746 --> 00:16:02.076 A:middle
调用 setCenter 和 setBounds

00:16:03.306 --> 00:16:04.606 A:middle
这就是全部过程

00:16:06.146 --> 00:16:07.686 A:middle
那么 我们回顾一下

00:16:07.686 --> 00:16:09.976 A:middle
想一想这就是逐步创建布局的过程

00:16:10.206 --> 00:16:12.716 A:middle
如果你能够尝试吸收它

00:16:12.716 --> 00:16:13.906 A:middle
并找到感觉

00:16:14.166 --> 00:16:17.066 A:middle
你将会对性能期望

00:16:17.066 --> 00:16:19.586 A:middle
有更好地理解

00:16:20.486 --> 00:16:21.896 A:middle
事实上 让我们看看

00:16:21.896 --> 00:16:23.676 A:middle
现在是什么情况 因为现在

00:16:24.196 --> 00:16:26.886 A:middle
当我们看到这里 看着这个方法

00:16:26.886 --> 00:16:29.506 A:middle
也就是我们停用约束

00:16:29.506 --> 00:16:30.736 A:middle
以及重新启用约束的地方

00:16:31.106 --> 00:16:32.346 A:middle
回想一下我们刚才所做的

00:16:32.346 --> 00:16:33.656 A:middle
想一想引擎

00:16:33.656 --> 00:16:34.206 A:middle
将会怎么做

00:16:35.596 --> 00:16:36.626 A:middle
它看起来将是这样

00:16:40.426 --> 00:16:42.136 A:middle
我们称之为流失

00:16:42.556 --> 00:16:45.226 A:middle
它的每一次运行

00:16:45.226 --> 00:16:47.246 A:middle
并不是特别的高消耗 但是它

00:16:47.246 --> 00:16:49.576 A:middle
运行的次数很多

00:16:49.576 --> 00:16:51.086 A:middle
而这是完全不必要的

00:16:51.086 --> 00:16:52.196 A:middle
这部分工作被浪费了

00:16:52.726 --> 00:16:54.456 A:middle
那么如果你可以在心里感觉到

00:16:54.456 --> 00:16:56.336 A:middle
如果你可以真正感觉到

00:16:56.406 --> 00:16:57.636 A:middle
当你这么做时 发生的事情

00:16:58.046 --> 00:17:00.046 A:middle
那么你就能够处于一个很好的状态

00:16:58.046 --> 00:17:00.046 A:middle
那么你就能够处于一个很好的状态

00:17:00.356 --> 00:17:02.046 A:middle
那么你就会

00:17:02.046 --> 00:17:03.036 A:middle
与接下来我们

00:17:03.036 --> 00:17:05.056 A:middle
要做的处于同一水准

00:17:05.056 --> 00:17:05.715 A:middle
并对此具备一个良好的把握

00:17:06.636 --> 00:17:08.935 A:middle
好的 我希望目前一切都好

00:17:08.935 --> 00:17:14.246 A:middle
我们还有另外一个大话题

00:17:14.246 --> 00:17:15.236 A:middle
希望探讨

00:17:15.236 --> 00:17:16.256 A:middle
如果想要获得一个

00:17:16.256 --> 00:17:18.356 A:middle
较好的性能模型 我们的想法是

00:17:18.356 --> 00:17:20.766 A:middle
你只为你使用的内容消耗性能

00:17:20.766 --> 00:17:21.965 A:middle
这在 Auto Layout 中可以做到

00:17:22.086 --> 00:17:23.056 A:middle
当看过这些以后我认为

00:17:23.056 --> 00:17:26.665 A:middle
我们已经能够理解其中的含义 对吗

00:17:26.665 --> 00:17:28.346 A:middle
为此 我们假设

00:17:28.346 --> 00:17:29.476 A:middle
目前的情况是之前的两倍

00:17:29.476 --> 00:17:31.346 A:middle
那么我们有四个文本框

00:17:31.346 --> 00:17:33.076 A:middle
分别在两个互相独立的层级中

00:17:34.496 --> 00:17:36.886 A:middle
现在你可以做的是

00:17:36.886 --> 00:17:38.426 A:middle
创建一个约束

00:17:38.426 --> 00:17:40.606 A:middle
令其像这样跨越层级

00:17:40.976 --> 00:17:42.866 A:middle
那么你可以说

00:17:42.866 --> 00:17:44.286 A:middle
1 号文本框应该与

00:17:44.286 --> 00:17:45.316 A:middle
3 号文本框对齐

00:17:45.316 --> 00:17:46.656 A:middle
尽管它们的上级视图并不相同

00:17:48.186 --> 00:17:50.956 A:middle
我认为 有时候人们会有

00:17:50.956 --> 00:17:52.486 A:middle
一个印象 就是因为这是

00:17:52.516 --> 00:17:54.526 A:middle
可能完成的 就意味着它会

00:17:54.526 --> 00:17:56.606 A:middle
运行的较为缓慢

00:17:56.606 --> 00:17:58.226 A:middle
因为各个部分可能

00:17:58.226 --> 00:17:59.646 A:middle
随时相互影响

00:17:59.646 --> 00:18:00.746 A:middle
就像一团浆糊

00:17:59.646 --> 00:18:00.746 A:middle
就像一团浆糊

00:18:00.746 --> 00:18:04.296 A:middle
而性能可能很糟糕

00:18:05.056 --> 00:18:07.306 A:middle
好的 但我们了解过

00:18:07.306 --> 00:18:08.936 A:middle
刚才的内容后 再一起来看看

00:18:08.936 --> 00:18:11.086 A:middle
在普通情况下

00:18:11.086 --> 00:18:13.136 A:middle
不会进行这种操作 因为大部分时间

00:18:13.136 --> 00:18:14.006 A:middle
都没有必要

00:18:14.506 --> 00:18:16.476 A:middle
大多数情况下

00:18:16.476 --> 00:18:17.906 A:middle
视图仅受到上级视图或

00:18:17.906 --> 00:18:18.916 A:middle
同级视图的约束

00:18:19.736 --> 00:18:23.026 A:middle
你看到由于我们有两个

00:18:23.026 --> 00:18:25.586 A:middle
互相独立的区块

00:18:25.586 --> 00:18:27.036 A:middle
引擎内部

00:18:27.036 --> 00:18:28.366 A:middle
将会有两个

00:18:28.366 --> 00:18:29.926 A:middle
互相独立的等式块

00:18:29.926 --> 00:18:31.206 A:middle
它们完全不与

00:18:31.206 --> 00:18:32.366 A:middle
对方互动 也不具有任何

00:18:32.366 --> 00:18:33.636 A:middle
互相重合的变量

00:18:34.146 --> 00:18:36.776 A:middle
这样一来

00:18:36.776 --> 00:18:38.186 A:middle
由于它们完全不会

00:18:38.186 --> 00:18:39.596 A:middle
重合 就不会发生互动

00:18:39.996 --> 00:18:41.296 A:middle
如果我们只有一个等式快

00:18:41.296 --> 00:18:43.966 A:middle
就需要花一些时间来进行处理

00:18:44.246 --> 00:18:45.536 A:middle
如果我们有两个这样的等式块

00:18:45.536 --> 00:18:47.256 A:middle
就需要花费两倍的时间

00:18:47.556 --> 00:18:48.486 A:middle
因为它们之间并没有任何关系

00:18:49.246 --> 00:18:50.316 A:middle
如果有三个 就是三倍时间

00:18:50.546 --> 00:18:52.566 A:middle
以此类推 问题在于你

00:18:52.626 --> 00:18:54.366 A:middle
将会看到线性关系

00:18:54.366 --> 00:18:56.836 A:middle
你将会看到线性的

00:18:56.836 --> 00:18:58.026 A:middle
性能 这已经是你可以

00:18:58.026 --> 00:18:59.016 A:middle
得到的最优结果

00:18:59.276 --> 00:19:01.106 A:middle
已经是最好的情况了

00:18:59.276 --> 00:19:01.106 A:middle
已经是最好的情况了

00:19:01.246 --> 00:19:03.816 A:middle
我想要再次强调一下

00:19:03.816 --> 00:19:05.496 A:middle
之所以它是线性的

00:19:05.496 --> 00:19:06.306 A:middle
是因为它们之间

00:19:06.306 --> 00:19:07.886 A:middle
不存在任何互相依赖性

00:19:08.516 --> 00:19:09.596 A:middle
如果它们之间存在互相依赖性

00:19:10.066 --> 00:19:11.846 A:middle
那么这些等式块

00:19:11.846 --> 00:19:14.106 A:middle
将会被连在一起

00:19:14.106 --> 00:19:15.996 A:middle
将会有更多的

00:19:15.996 --> 00:19:18.096 A:middle
计算需要处理

00:19:18.566 --> 00:19:19.876 A:middle
但也只是使用的时候

00:19:20.396 --> 00:19:22.236 A:middle
当然如果你确实有这样的情况 你知道

00:19:22.236 --> 00:19:23.446 A:middle
如果你手动处理

00:19:23.446 --> 00:19:24.246 A:middle
当然它会比较

00:19:24.246 --> 00:19:25.396 A:middle
消耗性能

00:19:25.396 --> 00:19:27.446 A:middle
你也能想到 因为这件事情更为复杂

00:19:27.546 --> 00:19:29.626 A:middle
这样常见的情况

00:19:29.626 --> 00:19:31.456 A:middle
是我们在 Cocoa 中的目标

00:19:31.456 --> 00:19:32.626 A:middle
即让简单的事情

00:19:32.626 --> 00:19:34.976 A:middle
保持简单 让复杂的事情成为可能

00:19:35.306 --> 00:19:36.476 A:middle
在这一情况下 它们可能

00:19:36.476 --> 00:19:37.176 A:middle
性能消耗会高一点

00:19:37.596 --> 00:19:38.986 A:middle
但是你不必为此消耗性能

00:19:38.986 --> 00:19:41.296 A:middle
如果你不使用的话

00:19:41.296 --> 00:19:44.716 A:middle
事实上 用直觉理解整个引擎的

00:19:44.716 --> 00:19:46.726 A:middle
正确方法就是 你可以把它

00:19:46.726 --> 00:19:49.206 A:middle
想作一个布局的缓存

00:19:49.206 --> 00:19:50.446 A:middle
和一个依赖关系追踪器

00:19:51.296 --> 00:19:52.736 A:middle
它非常有针对性

00:19:52.776 --> 00:19:54.396 A:middle
它了解哪些约束

00:19:54.396 --> 00:19:55.896 A:middle
会影响哪些视图 而当你

00:19:55.896 --> 00:19:58.346 A:middle
做出改变时 它只会更新

00:19:58.346 --> 00:19:59.866 A:middle
需要改变的内容

00:20:00.396 --> 00:20:02.976 A:middle
这对于你写代码也有启发

00:20:04.696 --> 00:20:07.306 A:middle
有时候我们看到的一个问题是

00:20:07.306 --> 00:20:08.886 A:middle
有一些人会

00:20:08.886 --> 00:20:11.236 A:middle
费很大劲去避免创建

00:20:11.236 --> 00:20:13.686 A:middle
约束 因为他们

00:20:13.686 --> 00:20:15.546 A:middle
认为这样性能消耗太高

00:20:16.476 --> 00:20:18.296 A:middle
然而 事实上约束很有针对性

00:20:18.526 --> 00:20:19.736 A:middle
只要你创建的

00:20:19.736 --> 00:20:21.866 A:middle
约束能够有效对应

00:20:21.866 --> 00:20:22.746 A:middle
你正在解决的问题

00:20:22.746 --> 00:20:24.456 A:middle
那么 就不太可能发生

00:20:24.456 --> 00:20:25.556 A:middle
更好的情况

00:20:25.556 --> 00:20:26.646 A:middle
如果你试图去回避问题

00:20:26.646 --> 00:20:27.636 A:middle
也不会有更好的性能情况

00:20:28.126 --> 00:20:29.796 A:middle
我们经常看到有些人

00:20:29.796 --> 00:20:31.036 A:middle
进行非常复杂的测量

00:20:31.036 --> 00:20:33.006 A:middle
把问题复杂化

00:20:33.006 --> 00:20:34.406 A:middle
然后试图

00:20:34.406 --> 00:20:35.756 A:middle
获取信息 然后再

00:20:35.756 --> 00:20:37.496 A:middle
返回信息 这样往往

00:20:37.496 --> 00:20:38.986 A:middle
消耗更多 相对

00:20:38.986 --> 00:20:40.126 A:middle
直接表达一个

00:20:40.126 --> 00:20:41.296 A:middle
你所需要的约束而言

00:20:42.606 --> 00:20:45.456 A:middle
这个问题的反面是

00:20:45.456 --> 00:20:47.286 A:middle
有时候我们会看到

00:20:47.716 --> 00:20:49.366 A:middle
像这样的层级

00:20:49.526 --> 00:20:51.006 A:middle
在这样的层级中我们看到

00:20:51.006 --> 00:20:52.356 A:middle
非常多的约束

00:20:52.356 --> 00:20:54.456 A:middle
以及非常多的优先级 以至于

00:20:54.456 --> 00:20:56.176 A:middle
过程很不清晰

00:20:56.176 --> 00:20:58.146 A:middle
通常这种情况

00:20:58.146 --> 00:21:00.466 A:middle
表示事实上

00:20:58.146 --> 00:21:00.466 A:middle
表示事实上

00:21:00.466 --> 00:21:01.816 A:middle
情况可能是

00:21:01.816 --> 00:21:03.426 A:middle
这个人心里有两个完全

00:21:03.426 --> 00:21:04.896 A:middle
独立的布局

00:21:05.346 --> 00:21:07.406 A:middle
而试图把它们

00:21:07.406 --> 00:21:09.196 A:middle
打包到一套

00:21:09.196 --> 00:21:11.286 A:middle
约束中 然后一次性解决问题

00:21:11.836 --> 00:21:13.906 A:middle
这也不是一个好主意

00:21:14.276 --> 00:21:17.056 A:middle
那将会产生

00:21:17.056 --> 00:21:18.316 A:middle
许多虚假的依赖关系

00:21:18.616 --> 00:21:19.776 A:middle
它们看起来是

00:21:19.776 --> 00:21:20.846 A:middle
互动的 但事实上

00:21:20.846 --> 00:21:21.196 A:middle
并非如此

00:21:21.586 --> 00:21:22.786 A:middle
而且几乎没办法

00:21:22.786 --> 00:21:25.506 A:middle
进行调试 如果你不注意的话

00:21:26.186 --> 00:21:30.406 A:middle
那么我的总体建议是

00:21:30.406 --> 00:21:32.516 A:middle
试图以最直接的方式对问题建模

00:21:32.766 --> 00:21:33.826 A:middle
Kasia 将会带大家

00:21:33.826 --> 00:21:34.786 A:middle
探讨这类在

00:21:34.786 --> 00:21:35.736 A:middle
不同的布局间切换的例子

00:21:35.736 --> 00:21:37.396 A:middle
并且展示的更为明确

00:21:38.186 --> 00:21:40.106 A:middle
但是这只是一般性建议

00:21:40.346 --> 00:21:41.886 A:middle
你需要自然地使用它

00:21:42.036 --> 00:21:43.276 A:middle
这对于性能

00:21:43.606 --> 00:21:45.176 A:middle
和理解都有好处

00:21:45.736 --> 00:21:50.926 A:middle
好的 这就是我们今天要说的大部分内容

00:21:51.186 --> 00:21:52.526 A:middle
但是由于我们想要建立

00:21:52.526 --> 00:21:54.276 A:middle
一个总体的关于

00:21:54.276 --> 00:21:55.336 A:middle
布局性能特点的心理模型

00:21:55.336 --> 00:21:57.146 A:middle
我希望至少确保

00:21:57.146 --> 00:21:59.636 A:middle
我们谈到了全部主要特征

00:21:59.856 --> 00:22:01.546 A:middle
你还有很多其他的事情可以做

00:21:59.856 --> 00:22:01.546 A:middle
你还有很多其他的事情可以做

00:22:02.676 --> 00:22:04.046 A:middle
我们讨论一下

00:22:04.626 --> 00:22:05.946 A:middle
那么你可以定义一些

00:22:05.946 --> 00:22:07.186 A:middle
特定的视图

00:22:07.186 --> 00:22:08.346 A:middle
宽度至少为 100

00:22:08.466 --> 00:22:09.366 A:middle
你可以使用不等式

00:22:10.106 --> 00:22:10.806 A:middle
这样做的消耗如何

00:22:11.736 --> 00:22:12.816 A:middle
非常非常低

00:22:13.006 --> 00:22:13.876 A:middle
与仅仅定义

00:22:13.876 --> 00:22:15.736 A:middle
宽度等于 100 相比

00:22:15.736 --> 00:22:17.346 A:middle
由于我们已经对内部问题略有探讨

00:22:17.656 --> 00:22:20.636 A:middle
它的消耗仅仅是多一个变量 仅此而已

00:22:21.156 --> 00:22:23.936 A:middle
你也可以调用设置常量功能

00:22:24.436 --> 00:22:26.066 A:middle
对这个问题的用例

00:22:26.066 --> 00:22:27.926 A:middle
就如同我有一个

00:22:27.926 --> 00:22:29.206 A:middle
手势辨认器 而我

00:22:29.266 --> 00:22:31.396 A:middle
试图将一个视图四处拖拽

00:22:31.396 --> 00:22:32.676 A:middle
要做的是

00:22:32.676 --> 00:22:34.976 A:middle
每一次我从手势辨识器

00:22:34.976 --> 00:22:36.196 A:middle
获得信号时

00:22:36.196 --> 00:22:38.416 A:middle
我会使用它的翻译结果

00:22:38.416 --> 00:22:39.296 A:middle
并将其输入一个

00:22:39.296 --> 00:22:41.006 A:middle
约束 通过为

00:22:41.006 --> 00:22:43.866 A:middle
该约束设置常量的方式

00:22:44.626 --> 00:22:45.896 A:middle
输入翻译值

00:22:46.616 --> 00:22:48.966 A:middle
好的 它接下来要做的是

00:22:48.966 --> 00:22:50.616 A:middle
我们刚才讨论过的引擎如何充当

00:22:50.616 --> 00:22:51.786 A:middle
一个依赖关系追踪器

00:22:52.346 --> 00:22:53.976 A:middle
它将这一点发挥到了

00:22:53.976 --> 00:22:55.016 A:middle
最大水平

00:22:55.656 --> 00:22:58.016 A:middle
这是一个

00:22:58.016 --> 00:23:00.266 A:middle
非常快速的一步更新

00:22:58.016 --> 00:23:00.266 A:middle
非常快速的一步更新

00:23:00.266 --> 00:23:02.426 A:middle
由于约束的改变

00:23:02.696 --> 00:23:04.106 A:middle
而改变需要更改的内容

00:23:04.916 --> 00:23:06.606 A:middle
这是一种性能优化

00:23:06.606 --> 00:23:07.936 A:middle
这就是为什么我们要用这么一个

00:23:07.936 --> 00:23:08.936 A:middle
设置常量的方法

00:23:09.476 --> 00:23:11.526 A:middle
最后要讨论的是它的优先级

00:23:12.436 --> 00:23:14.536 A:middle
因此这里你可以定义

00:23:14.536 --> 00:23:16.266 A:middle
你可以定义这个视图

00:23:16.266 --> 00:23:18.676 A:middle
最好宽度为 100 但是

00:23:18.876 --> 00:23:20.046 A:middle
如果达不到

00:23:20.046 --> 00:23:22.236 A:middle
就尽量靠近这个数值

00:23:22.956 --> 00:23:24.636 A:middle
这确实会导致更多的工作

00:23:25.326 --> 00:23:26.196 A:middle
一定量的工作发生

00:23:26.196 --> 00:23:28.306 A:middle
那么让我们进一步讨论一下

00:23:28.576 --> 00:23:29.866 A:middle
另一个考虑的角度

00:23:30.206 --> 00:23:31.626 A:middle
是定义该文本框的宽度

00:23:31.626 --> 00:23:35.666 A:middle
等于 100 加一些误差 并且

00:23:35.666 --> 00:23:36.716 A:middle
最小化该误差

00:23:37.436 --> 00:23:38.496 A:middle
这就是你们想要的部分

00:23:39.776 --> 00:23:41.266 A:middle
因此这里有一个误差

00:23:41.266 --> 00:23:42.536 A:middle
最小化的阶段 我之前

00:23:42.536 --> 00:23:43.156 A:middle
没有讨论过

00:23:43.366 --> 00:23:46.816 A:middle
当视图询问引擎

00:23:46.816 --> 00:23:48.086 A:middle
作为布局子视图的一部分

00:23:48.086 --> 00:23:50.446 A:middle
“这些变量的值是多少?”

00:23:50.686 --> 00:23:51.866 A:middle
引擎需要确保

00:23:51.866 --> 00:23:53.366 A:middle
所有误差值

00:23:53.366 --> 00:23:54.626 A:middle
已经完成最小化

00:23:55.386 --> 00:23:58.546 A:middle
实际上我不会探讨具体

00:23:58.546 --> 00:24:00.726 A:middle
是如何工作的 但我会稍微讨论一下

00:23:58.546 --> 00:24:00.726 A:middle
是如何工作的 但我会稍微讨论一下

00:24:00.726 --> 00:24:02.006 A:middle
性能特点

00:24:02.056 --> 00:24:03.586 A:middle
我会说的简洁明了

00:24:04.536 --> 00:24:06.746 A:middle
因此你或许想要

00:24:06.746 --> 00:24:07.196 A:middle
看看这个

00:24:07.196 --> 00:24:08.476 A:middle
这是简单的 X 算法

00:24:08.476 --> 00:24:09.526 A:middle
这是实际的事

00:24:09.866 --> 00:24:11.206 A:middle
非常古老

00:24:11.676 --> 00:24:13.186 A:middle
是第二次世界大战期间开发的

00:24:13.576 --> 00:24:17.246 A:middle
甚至早于电脑的出现

00:24:17.416 --> 00:24:19.026 A:middle
事实上 过去有一些人

00:24:19.026 --> 00:24:20.356 A:middle
被称为电脑

00:24:20.356 --> 00:24:21.156 A:middle
就在机器被称为电脑之前

00:24:21.156 --> 00:24:23.016 A:middle
这就是他们所做的事情

00:24:23.486 --> 00:24:25.706 A:middle
他们手动完成计算

00:24:25.856 --> 00:24:27.146 A:middle
这会给你一些关于

00:24:27.146 --> 00:24:28.076 A:middle
性能特点的感觉

00:24:28.316 --> 00:24:29.566 A:middle
如果你手动计算

00:24:29.566 --> 00:24:30.816 A:middle
应该非常快 而且它确实是

00:24:31.126 --> 00:24:33.336 A:middle
这与我们刚才做的事情

00:24:33.336 --> 00:24:34.106 A:middle
几乎是相同的

00:24:34.166 --> 00:24:35.326 A:middle
更多的是替换过程

00:24:35.726 --> 00:24:37.066 A:middle
这就是你进行思考的方式

00:24:38.266 --> 00:24:39.676 A:middle
不管怎么说 你知道

00:24:39.676 --> 00:24:40.986 A:middle
当你使用优先级时

00:24:40.986 --> 00:24:42.116 A:middle
它确实会产生这么多性能消耗

00:24:42.256 --> 00:24:43.146 A:middle
这一点需要注意

00:24:44.226 --> 00:24:46.216 A:middle
好的 除此之外 它与之前相同

00:24:46.616 --> 00:24:50.546 A:middle
这就是我想说的内容

00:24:50.756 --> 00:24:52.556 A:middle
这就是我们试图建立

00:24:52.556 --> 00:24:54.836 A:middle
这种直观的

00:24:54.836 --> 00:24:56.086 A:middle
对于 Auto Layout 的

00:24:56.086 --> 00:24:58.046 A:middle
性能特点的理解

00:24:58.176 --> 00:24:59.746 A:middle
快速地回顾一下我们刚才讨论的内容

00:25:00.226 --> 00:25:01.766 A:middle
不要使你的约束流失

00:25:02.316 --> 00:25:03.036 A:middle
这在你完成

00:25:03.036 --> 00:25:04.826 A:middle
无意义工作时会发生

00:25:05.116 --> 00:25:05.686 A:middle
因此不要这么做

00:25:06.326 --> 00:25:09.876 A:middle
当你处理约束时 它实际上是基础代数

00:25:10.176 --> 00:25:11.566 A:middle
而这种代数也发生在

00:25:11.566 --> 00:25:12.706 A:middle
你添加约束

00:25:12.706 --> 00:25:14.586 A:middle
移除约束

00:25:14.586 --> 00:25:16.706 A:middle
以及调用设置常量功能时

00:25:16.706 --> 00:25:17.466 A:middle
以上是主要情况

00:25:17.956 --> 00:25:20.956 A:middle
还有 你知道 当我们

00:25:20.956 --> 00:25:22.866 A:middle
处于误差最小化阶段时 也是代数问题

00:25:23.436 --> 00:25:26.916 A:middle
理解 Auto Layout 的工作原理的方法是

00:25:26.916 --> 00:25:28.546 A:middle
把它想做是一个

00:25:28.546 --> 00:25:29.806 A:middle
布局缓存

00:25:29.806 --> 00:25:31.226 A:middle
可以看到引擎包含所有

00:25:31.226 --> 00:25:33.016 A:middle
已解出的值 并且它是一个

00:25:33.016 --> 00:25:34.766 A:middle
依赖关系追踪器 因此当

00:25:34.766 --> 00:25:36.916 A:middle
数据发生改变时我们可以

00:25:37.066 --> 00:25:39.296 A:middle
以一个非常有针对性的方法 更新那些值

00:25:39.896 --> 00:25:41.016 A:middle
这引出了我们最后一个点

00:25:41.186 --> 00:25:43.236 A:middle
那就是你只为

00:25:43.236 --> 00:25:44.216 A:middle
你在使用的功能消耗性能

00:25:45.266 --> 00:25:46.916 A:middle
这就是我们所谈到的内容

00:25:47.276 --> 00:25:48.566 A:middle
你知道 这就是你的直觉判断

00:25:48.956 --> 00:25:53.376 A:middle
接下来的部分我将会交给 Kasia

00:25:53.376 --> 00:25:54.556 A:middle
因为 再次强调 如果你

00:25:54.556 --> 00:25:56.586 A:middle
只是依赖于直觉判断 是无法完成布局的

00:25:56.866 --> 00:25:58.336 A:middle
所以她将会进行

00:25:58.336 --> 00:25:59.946 A:middle
一些分析

00:25:59.946 --> 00:26:01.286 A:middle
避免我们刚才讨论的问题 并把直觉判断

00:25:59.946 --> 00:26:01.286 A:middle
避免我们刚才讨论的问题 并把直觉判断

00:26:01.286 --> 00:26:02.006 A:middle
用于实践中

00:26:02.336 --> 00:26:03.926 A:middle
欢迎她

00:26:04.516 --> 00:26:11.546 A:middle
[ 掌声 ]

00:26:12.046 --> 00:26:13.096 A:middle
&gt;&gt; 好的 请让我开始我的部分

00:26:14.056 --> 00:26:15.696 A:middle
谢谢 Ken 大家好

00:26:15.956 --> 00:26:17.246 A:middle
我的名字是 Kasia Wawer

00:26:17.796 --> 00:26:20.886 A:middle
我是 iOS 键盘组的成员 我们使用

00:26:20.886 --> 00:26:22.106 A:middle
Auto Layout 也很喜欢它

00:26:22.646 --> 00:26:24.006 A:middle
所以接下来我想与大家讨论

00:26:24.006 --> 00:26:25.206 A:middle
如何创建有效的布局

00:26:26.286 --> 00:26:27.056 A:middle
好的 让我们快速

00:26:27.056 --> 00:26:28.586 A:middle
回顾一下约束流失问题

00:26:29.116 --> 00:26:30.396 A:middle
正如刚才听到的 约束流失

00:26:30.396 --> 00:26:31.876 A:middle
发生在你改变你的

00:26:31.876 --> 00:26:33.726 A:middle
约束 但是实际视图

00:26:33.726 --> 00:26:35.396 A:middle
并不需要变动时 因此你

00:26:35.396 --> 00:26:36.816 A:middle
向引擎发送了过多工作

00:26:37.276 --> 00:26:38.456 A:middle
而且可能会影响到

00:26:38.456 --> 00:26:39.106 A:middle
你的性能表现

00:26:39.106 --> 00:26:40.776 A:middle
所以你希望避免这种情况

00:26:41.636 --> 00:26:43.646 A:middle
那么让我们探讨一下你什么时候

00:26:43.646 --> 00:26:45.746 A:middle
可能遇到这一问题

00:26:45.746 --> 00:26:46.556 A:middle
以及如何解决它

00:26:46.556 --> 00:26:49.056 A:middle
因此我们将以一个规格说明为例

00:26:49.286 --> 00:26:50.866 A:middle
这是一个社交网络 App 使用的规格说明

00:26:51.586 --> 00:26:52.526 A:middle
有一个头像视图

00:26:52.526 --> 00:26:53.566 A:middle
可以显示谁在分享

00:26:53.566 --> 00:26:56.336 A:middle
有一个标题 一个日期

00:26:56.336 --> 00:26:59.206 A:middle
以及一个日志输入界面

00:26:59.206 --> 00:27:00.186 A:middle
你需要设置一些间隔

00:26:59.206 --> 00:27:00.186 A:middle
你需要设置一些间隔

00:27:00.186 --> 00:27:01.606 A:middle
可能需要

00:27:01.606 --> 00:27:04.516 A:middle
规定一些尺寸 你也有可能会用到对齐

00:27:05.566 --> 00:27:08.036 A:middle
而事实上这并非一个完全的

00:27:08.036 --> 00:27:08.946 A:middle
社交媒体 App

00:27:09.266 --> 00:27:11.036 A:middle
这是一个半社交媒体 App

00:27:11.476 --> 00:27:13.276 A:middle
你可以选择是否愿意分享内容

00:27:14.176 --> 00:27:15.986 A:middle
因此还有一个可选的

00:27:15.986 --> 00:27:16.756 A:middle
视图 显示你已经

00:27:16.756 --> 00:27:18.016 A:middle
分享的内容 以及分享的用户

00:27:18.946 --> 00:27:20.376 A:middle
而且一个社交媒体 App

00:27:20.376 --> 00:27:22.166 A:middle
如果不能分享猫的图片

00:27:22.166 --> 00:27:23.036 A:middle
就是不完整的

00:27:23.936 --> 00:27:24.896 A:middle
因此你可能会需要

00:27:24.896 --> 00:27:25.846 A:middle
添加另一个布局

00:27:26.836 --> 00:27:28.326 A:middle
也许你根本并不想

00:27:28.326 --> 00:27:29.236 A:middle
分享这个猫的图片 因为

00:27:29.236 --> 00:27:30.346 A:middle
它实在太好了 你想要

00:27:30.346 --> 00:27:31.066 A:middle
自己保留它

00:27:32.056 --> 00:27:33.976 A:middle
那么我们有四个非常相似的布局

00:27:34.626 --> 00:27:35.996 A:middle
它们并不是相同的

00:27:35.996 --> 00:27:36.776 A:middle
需要做一些调整

00:27:36.776 --> 00:27:38.196 A:middle
当这些表格视图

00:27:38.196 --> 00:27:39.306 A:middle
单元格出现在屏幕上时

00:27:39.396 --> 00:27:40.396 A:middle
当做我刚刚没有提到它们

00:27:40.396 --> 00:27:41.156 A:middle
存在于表格视图单元格中

00:27:42.026 --> 00:27:43.406 A:middle
让我们假设你正在

00:27:43.406 --> 00:27:45.236 A:middle
处理这个 App 的性能问题

00:27:45.236 --> 00:27:47.026 A:middle
你第一次运行它

00:27:47.026 --> 00:27:49.036 A:middle
这就是你获得的滑动性能

00:27:49.386 --> 00:27:51.316 A:middle
其中有很多卡顿现象

00:27:51.316 --> 00:27:52.976 A:middle
尤其是当向上滑动 返回顶部时

00:27:53.086 --> 00:27:55.666 A:middle
那么你会想 好的 我要怎样来

00:27:55.666 --> 00:27:57.026 A:middle
提升这个 App 呢

00:27:57.026 --> 00:27:57.716 A:middle
发生什么问题了呢

00:27:58.636 --> 00:28:00.986 A:middle
因此我想介绍

00:27:58.636 --> 00:28:00.986 A:middle
因此我想介绍

00:28:01.096 --> 00:28:02.406 A:middle
一个新的功能 它可以让你

00:28:02.406 --> 00:28:03.416 A:middle
对我们正在开发的内容先睹为快

00:28:03.886 --> 00:28:05.096 A:middle
目前它在

00:28:05.096 --> 00:28:07.486 A:middle
测试版中尚不可用 但是敬请期待

00:28:07.946 --> 00:28:08.886 A:middle
因为我们很快会

00:28:08.886 --> 00:28:10.386 A:middle
推出一个布局设计的工具

00:28:12.076 --> 00:28:12.796 A:middle
好的

00:28:13.516 --> 00:28:18.716 A:middle
[ 掌声 ]

00:28:19.216 --> 00:28:20.086 A:middle
我很高兴你们对此感到兴奋

00:28:20.606 --> 00:28:21.866 A:middle
让我们很有动力

00:28:22.576 --> 00:28:24.526 A:middle
不管怎么说 我们一起来看看 发生了什么

00:28:25.466 --> 00:28:27.186 A:middle
最顶部的轨迹显示的是

00:28:27.226 --> 00:28:28.856 A:middle
正在使用的 CPU 容量

00:28:29.496 --> 00:28:30.646 A:middle
某种程度上说

00:28:30.646 --> 00:28:31.556 A:middle
这是一个危险信号

00:28:31.756 --> 00:28:33.116 A:middle
如果存在许多峰值

00:28:33.446 --> 00:28:34.486 A:middle
这意味着你

00:28:34.486 --> 00:28:35.436 A:middle
你的布局

00:28:35.436 --> 00:28:36.846 A:middle
可能有一些问题

00:28:37.576 --> 00:28:38.686 A:middle
而如果它较为平滑

00:28:39.166 --> 00:28:40.106 A:middle
可能其它地方

00:28:40.106 --> 00:28:41.526 A:middle
会有别的问题

00:28:42.466 --> 00:28:43.906 A:middle
下面的轨迹则

00:28:43.906 --> 00:28:45.756 A:middle
具体地追踪约束流失

00:28:46.446 --> 00:28:47.616 A:middle
这些柱状图的高度

00:28:47.616 --> 00:28:49.846 A:middle
在这个例子中 反映的是

00:28:49.846 --> 00:28:51.196 A:middle
发生约束流失的

00:28:51.196 --> 00:28:52.596 A:middle
视图数量

00:28:53.506 --> 00:28:54.506 A:middle
因此当你看到很高的柱状图时

00:28:54.506 --> 00:28:56.226 A:middle
你就知道有许多视图受到了影响

00:28:57.446 --> 00:28:59.456 A:middle
我们也会展示如何

00:28:59.456 --> 00:29:00.746 A:middle
移除和改变约束

00:28:59.456 --> 00:29:00.746 A:middle
移除和改变约束

00:29:01.776 --> 00:29:05.326 A:middle
并最终设定

00:29:05.326 --> 00:29:06.716 A:middle
UILabel 和其他文本视图的尺寸

00:29:06.906 --> 00:29:08.286 A:middle
这里是 UILabel 是因为

00:29:08.286 --> 00:29:09.156 A:middle
这是 App 中的内容

00:29:09.956 --> 00:29:11.026 A:middle
它也可以追踪其他

00:29:11.026 --> 00:29:12.186 A:middle
类型的文本视图

00:29:13.786 --> 00:29:16.286 A:middle
那么这是 App

00:29:16.366 --> 00:29:18.816 A:middle
滑动时的情况 我们需要查看什么呢

00:29:19.206 --> 00:29:21.136 A:middle
有一些峰值发生在

00:29:21.136 --> 00:29:24.236 A:middle
CPU 视图中 但是让我们放大

00:29:24.236 --> 00:29:25.776 A:middle
这一个 因为在它下面

00:29:25.776 --> 00:29:27.106 A:middle
我看到了一个约束流失的

00:29:27.106 --> 00:29:28.926 A:middle
突然上升 这有些令人担忧

00:29:29.906 --> 00:29:31.396 A:middle
那么 如果你选中这个视图

00:29:31.526 --> 00:29:32.966 A:middle
然后进入 Instruments 中的

00:29:33.666 --> 00:29:35.486 A:middle
详细视图 你会看到的是

00:29:35.726 --> 00:29:36.846 A:middle
一个列表 根据视图描述列明

00:29:36.846 --> 00:29:38.896 A:middle
受到约束流失影响的视图

00:29:39.586 --> 00:29:40.556 A:middle
我们依据

00:29:40.556 --> 00:29:42.326 A:middle
上级视图将它们分类 那么

00:29:42.326 --> 00:29:44.576 A:middle
比如说在表格视图单元格中

00:29:44.576 --> 00:29:46.486 A:middle
很容易看出这个问题

00:29:46.486 --> 00:29:48.286 A:middle
一次又一次地发生在

00:29:48.286 --> 00:29:50.116 A:middle
某个特定的情况下 而非不同情况下

00:29:51.016 --> 00:29:52.536 A:middle
那么在这一实例中我们看到

00:29:52.536 --> 00:29:54.586 A:middle
头像视图和三个不同标签

00:29:54.966 --> 00:29:55.956 A:middle
都出现了流失问题

00:29:57.316 --> 00:29:59.646 A:middle
由于是我

00:29:59.646 --> 00:30:01.696 A:middle
负责在 Instruments 中运行的

00:29:59.646 --> 00:30:01.696 A:middle
负责在 Instruments 中运行的

00:30:01.696 --> 00:30:02.386 A:middle
我知道这些标签

00:30:02.426 --> 00:30:03.876 A:middle
对应的是 标题标签

00:30:03.876 --> 00:30:05.686 A:middle
日期标签和我们的日志输入标签

00:30:07.036 --> 00:30:08.516 A:middle
这几乎是单元格内的

00:30:08.516 --> 00:30:09.086 A:middle
全部视图了

00:30:09.086 --> 00:30:10.736 A:middle
这让人有点担心

00:30:11.406 --> 00:30:12.136 A:middle
我们一起来看看发生了什么

00:30:13.766 --> 00:30:15.376 A:middle
好的 回到我们的规格说明

00:30:16.326 --> 00:30:19.626 A:middle
通过查看代码发现

00:30:19.666 --> 00:30:21.566 A:middle
UpdateConstraints 正在被覆写

00:30:22.526 --> 00:30:25.956 A:middle
并且在该方法中 在发生任何改变或

00:30:25.956 --> 00:30:27.426 A:middle
UpdateConstraints 在运行时

00:30:27.896 --> 00:30:28.696 A:middle
都会移除全部约束

00:30:28.696 --> 00:30:30.716 A:middle
然后再添加

00:30:30.716 --> 00:30:32.276 A:middle
我们认为需要的约束

00:30:33.876 --> 00:30:35.956 A:middle
一切又回到

00:30:35.956 --> 00:30:37.206 A:middle
原来的样子

00:30:37.646 --> 00:30:39.436 A:middle
正是这种移除

00:30:39.436 --> 00:30:41.516 A:middle
导致性能问题

00:30:42.486 --> 00:30:44.986 A:middle
那么 这里的社交标签

00:30:44.986 --> 00:30:46.986 A:middle
也就是社交头像

00:30:47.356 --> 00:30:49.176 A:middle
被反复添加和移除

00:30:49.176 --> 00:30:50.626 A:middle
我们并不需要完全移除

00:30:51.806 --> 00:30:52.856 A:middle
当你查看

00:30:52.856 --> 00:30:54.966 A:middle
这一视图的约束时 你会看到

00:30:54.966 --> 00:30:56.036 A:middle
它们实际上

00:30:56.036 --> 00:30:57.316 A:middle
并不与其他任何东西互动

00:30:57.876 --> 00:30:58.946 A:middle
仅仅是一个单一的视图

00:30:59.516 --> 00:31:01.156 A:middle
此时你可以使用

00:30:59.516 --> 00:31:01.156 A:middle
此时你可以使用

00:31:01.156 --> 00:31:03.366 A:middle
这个非常简洁的功能叫做

00:31:03.566 --> 00:31:05.536 A:middle
setHidden 也许你听说过

00:31:05.656 --> 00:31:07.936 A:middle
而且由于它并不影响

00:31:07.936 --> 00:31:09.686 A:middle
任何周围的视图

00:31:09.686 --> 00:31:10.626 A:middle
它就会消失

00:31:10.626 --> 00:31:11.866 A:middle
其约束则会得到保留

00:31:11.866 --> 00:31:13.656 A:middle
这是一个非常非常简便的

00:31:14.136 --> 00:31:15.846 A:middle
方法来隐藏和显示视图

00:31:16.416 --> 00:31:18.036 A:middle
而非将它们从层级中移除

00:31:18.986 --> 00:31:19.736 A:middle
因此这是没有问题的

00:31:20.246 --> 00:31:21.556 A:middle
但是这是一个非常简单的例子

00:31:21.556 --> 00:31:22.546 A:middle
那么图像视图呢

00:31:23.016 --> 00:31:24.606 A:middle
好的 对于图像视图

00:31:24.606 --> 00:31:25.806 A:middle
我们可能再一次

00:31:25.806 --> 00:31:26.686 A:middle
试图将所有的

00:31:26.686 --> 00:31:28.176 A:middle
约束移除 而后再添加

00:31:28.626 --> 00:31:30.896 A:middle
已有的约束以及图像视图的约束

00:31:31.816 --> 00:31:34.446 A:middle
一切又回到原来的样子

00:31:34.446 --> 00:31:35.356 A:middle
这就是约束流失

00:31:36.566 --> 00:31:37.776 A:middle
在这样的情况下

00:31:38.156 --> 00:31:39.326 A:middle
我希望你们思考的方式是

00:31:39.326 --> 00:31:41.176 A:middle
分组查看约束

00:31:41.896 --> 00:31:43.446 A:middle
让我们从这个分组开始

00:31:43.446 --> 00:31:44.716 A:middle
我将其高亮为绿色

00:31:45.756 --> 00:31:48.256 A:middle
这些约束在

00:31:48.446 --> 00:31:49.476 A:middle
每个布局都是一样的

00:31:50.466 --> 00:31:53.286 A:middle
我们在隐藏或显示分享视图时

00:31:53.286 --> 00:31:54.196 A:middle
分享视图不需要发生变化

00:31:54.196 --> 00:31:56.356 A:middle
头像视图不会移动

00:31:56.356 --> 00:31:59.006 A:middle
这些标签也不会发生移动

00:31:59.006 --> 00:32:00.806 A:middle
除了日志输入标签会变得更长

00:31:59.006 --> 00:32:00.806 A:middle
除了日志输入标签会变得更长

00:32:01.616 --> 00:32:02.726 A:middle
因此这些绿色的约束

00:32:03.046 --> 00:32:04.866 A:middle
应该在你创建

00:32:04.866 --> 00:32:08.206 A:middle
视图时添加 然后被保留在原处

00:32:08.566 --> 00:32:09.046 A:middle
不要修改它们

00:32:09.276 --> 00:32:10.446 A:middle
它们要保持不变

00:32:12.026 --> 00:32:13.646 A:middle
现在我们有四个

00:32:13.646 --> 00:32:15.586 A:middle
约束控制着这个图像视图

00:32:15.846 --> 00:32:16.926 A:middle
要如何处理它们呢

00:32:17.216 --> 00:32:21.366 A:middle
我们把它们放入一个数组 然后我们再将

00:32:21.366 --> 00:32:22.276 A:middle
在没有图像时

00:32:22.276 --> 00:32:23.746 A:middle
将出现的约束放入另一个数组

00:32:24.126 --> 00:32:25.246 A:middle
我很有创造性地将它们叫做

00:32:25.246 --> 00:32:26.416 A:middle
imageConstraints 和

00:32:26.416 --> 00:32:27.696 A:middle
noImageConstraints 这样你们就可以

00:32:27.696 --> 00:32:28.526 A:middle
区分它们

00:32:29.216 --> 00:32:32.316 A:middle
当我们即将

00:32:32.316 --> 00:32:34.526 A:middle
需要添加

00:32:34.526 --> 00:32:36.366 A:middle
或删除该图像视图时 让我们看看

00:32:36.366 --> 00:32:37.556 A:middle
现在所处的布局

00:32:38.036 --> 00:32:40.546 A:middle
如果需要的话 停用 noImageConstraints

00:32:41.086 --> 00:32:42.776 A:middle
并且激活那些图像所需的约束

00:32:43.786 --> 00:32:45.516 A:middle
如果我们不需要图像

00:32:45.516 --> 00:32:46.716 A:middle
那么既然全部其他的

00:32:46.716 --> 00:32:48.886 A:middle
约束已经被激活了 我们只需要再激活

00:32:49.186 --> 00:32:49.846 A:middle
我们正在添加的约束即可

00:32:50.176 --> 00:32:51.416 A:middle
现在我把它们都放入数组中

00:32:51.416 --> 00:32:53.936 A:middle
尽管这是一个单一约束 因为这样可以

00:32:53.936 --> 00:32:55.226 A:middle
简化我的代码

00:32:55.756 --> 00:32:56.676 A:middle
我不需要检查

00:32:56.676 --> 00:32:57.486 A:middle
我是在处理一个

00:32:57.486 --> 00:32:58.846 A:middle
数组还是一个单一约束

00:32:59.206 --> 00:33:00.846 A:middle
这样我一直都是在处理约束的数组

00:32:59.206 --> 00:33:00.846 A:middle
这样我一直都是在处理约束的数组

00:33:01.856 --> 00:33:02.666 A:middle
只是长度的不同

00:33:03.526 --> 00:33:06.406 A:middle
这样做的好处是

00:33:06.406 --> 00:33:08.286 A:middle
如果你像这样 正确地

00:33:08.286 --> 00:33:09.766 A:middle
追踪你的约束

00:33:10.186 --> 00:33:11.716 A:middle
而且你知道你想要

00:33:11.716 --> 00:33:13.276 A:middle
实时地在用户面前

00:33:13.276 --> 00:33:15.876 A:middle
添加这个图像视图 你可以停用这些

00:33:15.876 --> 00:33:17.426 A:middle
noImageConstraints 启用

00:33:17.426 --> 00:33:18.966 A:middle
ImageConstraints 并调用

00:33:18.966 --> 00:33:20.326 A:middle
视觉动画模块中的

00:33:20.326 --> 00:33:22.026 A:middle
layoutIfNeeded

00:33:22.026 --> 00:33:23.416 A:middle
它就会很好地出现在你的视图中

00:33:24.126 --> 00:33:25.996 A:middle
如果你试图通过停用全部的

00:33:25.996 --> 00:33:26.886 A:middle
约束然后将它们

00:33:26.886 --> 00:33:29.236 A:middle
再次添加

00:33:29.236 --> 00:33:30.756 A:middle
委婉点说 情况会很有趣

00:33:31.696 --> 00:33:33.006 A:middle
好的 现在我们已经

00:33:33.006 --> 00:33:34.296 A:middle
调试了这个问题 我们正在

00:33:34.296 --> 00:33:35.266 A:middle
处理约束组

00:33:35.266 --> 00:33:36.536 A:middle
而非把所有约束堆在一起

00:33:36.536 --> 00:33:38.646 A:middle
让我们看一下 会是什么样子

00:33:38.706 --> 00:33:39.376 A:middle
提示一下 这是它

00:33:39.376 --> 00:33:40.566 A:middle
最开始的样子

00:33:41.706 --> 00:33:44.906 A:middle
我们向上滑动到顶部

00:33:44.906 --> 00:33:45.216 A:middle
非常糟糕

00:33:45.216 --> 00:33:46.256 A:middle
这是在我们调试之后

00:33:46.256 --> 00:33:48.876 A:middle
看起来的样子

00:33:48.966 --> 00:33:50.136 A:middle
这就顺滑多了

00:33:50.776 --> 00:33:51.676 A:middle
谢谢

00:33:52.031 --> 00:33:54.031 A:middle
[ 掌声 ]

00:33:54.046 --> 00:33:54.986 A:middle
但是等等 还有惊喜

00:33:55.596 --> 00:33:57.936 A:middle
我实际上是在 iOS 11 上录制的这个视频

00:33:57.936 --> 00:34:00.586 A:middle
没有利用

00:33:57.936 --> 00:34:00.586 A:middle
没有利用

00:34:00.586 --> 00:34:02.826 A:middle
我们在 iOS 12 上的性能提升

00:34:03.826 --> 00:34:05.376 A:middle
这只不过是一段

00:34:06.366 --> 00:34:07.396 A:middle
高效运行的客户端代码

00:34:07.396 --> 00:34:09.626 A:middle
在 iOS 12 中它看起来也非常棒

00:34:09.626 --> 00:34:13.416 A:middle
而且好的难以置信

00:34:13.416 --> 00:34:14.016 A:middle
[ 笑声 ]

00:34:14.516 --> 00:34:17.446 A:middle
[ 掌声 ] 是的 它非常棒

00:34:20.396 --> 00:34:21.815 A:middle
那么 我们如何避免

00:34:21.815 --> 00:34:22.106 A:middle
约束流失呢

00:34:23.176 --> 00:34:25.106 A:middle
避免移除全部约束

00:34:25.106 --> 00:34:26.206 A:middle
这样通常会让你

00:34:26.206 --> 00:34:27.406 A:middle
进入一个尴尬境地 你需要

00:34:27.406 --> 00:34:29.036 A:middle
把一部分的约束重新添加

00:34:29.036 --> 00:34:30.956 A:middle
而这会让你

00:34:30.956 --> 00:34:32.596 A:middle
重新布局

00:34:32.596 --> 00:34:33.626 A:middle
并不需要的帧

00:34:33.626 --> 00:34:34.795 A:middle
或是重新传送不需要

00:34:34.795 --> 00:34:35.636 A:middle
被再次展示的视图

00:34:36.866 --> 00:34:38.286 A:middle
如果你有一系列的约束

00:34:38.315 --> 00:34:39.626 A:middle
它们对于全部

00:34:39.626 --> 00:34:40.585 A:middle
你的 App 中可能的布局都是共用的

00:34:40.585 --> 00:34:42.556 A:middle
一次性将它们添加 然后不要

00:34:42.556 --> 00:34:43.085 A:middle
再修改它们

00:34:43.156 --> 00:34:44.295 A:middle
这对于使用 Interface

00:34:44.295 --> 00:34:45.326 A:middle
Builder 和你的 App 的

00:34:45.326 --> 00:34:46.916 A:middle
初始布局有好处

00:34:46.916 --> 00:34:47.786 A:middle
改变那些需要被改变的

00:34:47.786 --> 00:34:48.826 A:middle
约束 但不要去改变

00:34:48.826 --> 00:34:49.956 A:middle
那些不需要改变的

00:34:50.886 --> 00:34:52.755 A:middle
听起来有点像文字游戏 但是效果很不错

00:34:53.186 --> 00:34:54.606 A:middle
现在你已经有了简便的办法

00:34:54.606 --> 00:34:56.786 A:middle
隐藏视图而非

00:34:56.786 --> 00:34:58.436 A:middle
移除视图 可以解决你的需求

00:34:59.076 --> 00:35:00.096 A:middle
好的 这就是

00:34:59.076 --> 00:35:00.096 A:middle
好的 这就是

00:35:00.096 --> 00:35:01.546 A:middle
Instruments 中的约束流失问题

00:35:01.626 --> 00:35:02.596 A:middle
Instruments 中还有一个

00:35:02.596 --> 00:35:04.326 A:middle
底部视图 叫做 UILabel 尺寸计算

00:35:05.236 --> 00:35:07.186 A:middle
UILabel 尺寸计算追踪的是

00:35:07.186 --> 00:35:08.246 A:middle
标签计算其尺寸

00:35:08.246 --> 00:35:09.926 A:middle
所需要的时间

00:35:10.226 --> 00:35:11.566 A:middle
我们来讨论一下固有

00:35:11.566 --> 00:35:12.236 A:middle
内容尺寸

00:35:12.566 --> 00:35:15.036 A:middle
让我走到这边来

00:35:15.886 --> 00:35:17.546 A:middle
好的 并不是所有的视图

00:35:17.896 --> 00:35:19.096 A:middle
都需要有固有内容尺寸

00:35:20.716 --> 00:35:21.426 A:middle
一些视图需要

00:35:21.836 --> 00:35:24.076 A:middle
具有非视图内容的视图

00:35:24.076 --> 00:35:25.276 A:middle
会返回一个它们的

00:35:25.276 --> 00:35:26.936 A:middle
固有内容尺寸的大小

00:35:26.936 --> 00:35:28.086 A:middle
尺寸是基于该非视图内容的

00:35:28.486 --> 00:35:30.126 A:middle
举两个例子

00:35:30.126 --> 00:35:32.156 A:middle
一个是 UIImageView 它利用其

00:35:32.156 --> 00:35:33.826 A:middle
图像的尺寸来计算其

00:35:33.826 --> 00:35:36.036 A:middle
固有内容尺寸

00:35:36.036 --> 00:35:38.116 A:middle
另一个是 UILabel 它测量其文本

00:35:38.576 --> 00:35:39.976 A:middle
并依据此来返回其

00:35:39.976 --> 00:35:41.056 A:middle
固有内容尺寸

00:35:41.636 --> 00:35:43.666 A:middle
固有内容尺寸

00:35:43.666 --> 00:35:45.076 A:middle
并没有什么神奇之处

00:35:45.486 --> 00:35:47.856 A:middle
它的用处是通过 UIView 创建约束

00:35:48.486 --> 00:35:49.886 A:middle
确定约束的尺寸

00:35:49.886 --> 00:35:50.886 A:middle
仅此而已

00:35:51.596 --> 00:35:52.476 A:middle
你可以在

00:35:52.476 --> 00:35:54.106 A:middle
约束中定义全部的尺寸

00:35:54.576 --> 00:35:55.576 A:middle
并跳过这些内容

00:35:56.436 --> 00:35:57.496 A:middle
有一些情况下

00:35:57.496 --> 00:35:58.646 A:middle
它需要被覆写

00:35:58.646 --> 00:36:00.026 A:middle
这也是它存在的原因

00:35:58.646 --> 00:36:00.026 A:middle
这也是它存在的原因

00:36:00.026 --> 00:36:01.156 A:middle
这样的情况

00:36:01.156 --> 00:36:02.586 A:middle
以及一些其他的例子

00:36:02.586 --> 00:36:03.776 A:middle
都在 UIView 子集中

00:36:04.346 --> 00:36:05.786 A:middle
但是大部分情况下它被

00:36:05.786 --> 00:36:07.026 A:middle
覆写的原因是

00:36:07.026 --> 00:36:07.986 A:middle
人们认为这样会

00:36:07.986 --> 00:36:10.136 A:middle
更快或者更准确

00:36:10.136 --> 00:36:10.946 A:middle
但事实上都不会

00:36:12.076 --> 00:36:14.546 A:middle
但是 有一种情况下

00:36:14.546 --> 00:36:16.506 A:middle
覆写它会提高你的性能

00:36:18.206 --> 00:36:19.926 A:middle
因为文本测量可能消耗较高

00:36:21.186 --> 00:36:24.106 A:middle
在我们的这个 App 中 UILabel 尺寸计算

00:36:24.106 --> 00:36:25.626 A:middle
并没有花费很久

00:36:25.716 --> 00:36:27.386 A:middle
它的时间是很短的

00:36:27.826 --> 00:36:28.986 A:middle
因此 纠结这个问题

00:36:28.986 --> 00:36:29.766 A:middle
并不会提升

00:36:29.766 --> 00:36:31.096 A:middle
太多的性能

00:36:31.666 --> 00:36:32.956 A:middle
但如果你有一个文本密集型的

00:36:32.956 --> 00:36:34.586 A:middle
App 而你多次看到

00:36:34.586 --> 00:36:36.106 A:middle
在 UILabel 中发生

00:36:36.106 --> 00:36:37.886 A:middle
文本测量 或者你

00:36:37.886 --> 00:36:38.936 A:middle
在文本视图中有文本测量过程

00:36:39.066 --> 00:36:39.956 A:middle
或者其他功能中有文本测量

00:36:40.386 --> 00:36:42.136 A:middle
你或许能够通过这种方式

00:36:42.136 --> 00:36:43.566 A:middle
借助其他信息 提高性能

00:36:45.116 --> 00:36:46.296 A:middle
如果你知道

00:36:46.296 --> 00:36:47.886 A:middle
该文本所需要的尺寸

00:36:47.886 --> 00:36:49.696 A:middle
而无需完成文本测量

00:36:49.696 --> 00:36:50.746 A:middle
你可以返回该尺寸

00:36:50.746 --> 00:36:53.916 A:middle
和固有内容尺寸 或者是

00:36:53.916 --> 00:36:55.286 A:middle
在准备将

00:36:55.286 --> 00:36:56.726 A:middle
视图显示在屏幕时

00:36:56.726 --> 00:36:57.546 A:middle
完全使用约束

00:36:57.546 --> 00:36:58.706 A:middle
定义该尺寸

00:36:58.776 --> 00:36:59.976 A:middle
无论其中的文本

00:37:00.046 --> 00:37:00.846 A:middle
尺寸如何

00:37:00.946 --> 00:37:02.306 A:middle
举个例子 约束

00:37:02.306 --> 00:37:03.156 A:middle
总是会让尺寸

00:37:03.156 --> 00:37:04.706 A:middle
略大于你的文本量

00:37:05.546 --> 00:37:06.586 A:middle
然后你就可以直接不返回

00:37:06.586 --> 00:37:07.996 A:middle
任何固有内容尺寸

00:37:07.996 --> 00:37:10.446 A:middle
中对于宽度和高度的度量

00:37:11.146 --> 00:37:12.206 A:middle
这样做就是告诉

00:37:12.206 --> 00:37:13.486 A:middle
上一层级 “嘿我已经知道了

00:37:13.486 --> 00:37:15.846 A:middle
我的尺寸 不需要再进行文本测量了”

00:37:16.826 --> 00:37:18.226 A:middle
很明显 这只在

00:37:18.226 --> 00:37:19.096 A:middle
你不需要自己进行

00:37:19.096 --> 00:37:21.826 A:middle
测量时才适用 但是它可以

00:37:21.826 --> 00:37:23.646 A:middle
帮助一些 App 提高性能

00:37:23.646 --> 00:37:24.886 A:middle
因此我希望你们了解

00:37:24.886 --> 00:37:26.016 A:middle
这个小技巧

00:37:26.766 --> 00:37:27.766 A:middle
我们不能只谈

00:37:27.766 --> 00:37:29.116 A:middle
固有内容尺寸而不谈

00:37:29.116 --> 00:37:30.566 A:middle
系统布局适应尺寸

00:37:30.566 --> 00:37:33.326 A:middle
因为人们

00:37:33.326 --> 00:37:35.666 A:middle
往往混淆这两个概念

00:37:35.666 --> 00:37:37.846 A:middle
尽管它们几乎是相反的

00:37:37.846 --> 00:37:41.456 A:middle
很可惜固有内容尺寸是

00:37:41.456 --> 00:37:42.446 A:middle
你向引擎传输

00:37:42.446 --> 00:37:44.226 A:middle
需要添加的尺寸信息的方式

00:37:45.206 --> 00:37:46.796 A:middle
系统布局配合尺寸是

00:37:47.156 --> 00:37:48.206 A:middle
你将尺寸

00:37:48.206 --> 00:37:49.826 A:middle
信息从引擎中提取出来的方式

00:37:50.356 --> 00:37:52.486 A:middle
事实上它们几乎是相反的

00:37:52.486 --> 00:37:54.696 A:middle
这用于一些混合布局

00:37:54.696 --> 00:37:56.086 A:middle
出于有一些原因

00:37:56.086 --> 00:37:57.136 A:middle
导致你需要

00:37:57.136 --> 00:37:58.816 A:middle
从一个使用 Auto Layout

00:37:58.816 --> 00:38:00.576 A:middle
管理其子视图的视图中提取帧信息

00:37:58.816 --> 00:38:00.576 A:middle
管理其子视图的视图中提取帧信息

00:38:01.876 --> 00:38:03.616 A:middle
不是很常用 但是

00:38:03.616 --> 00:38:05.306 A:middle
确实可以这么使用

00:38:05.696 --> 00:38:07.346 A:middle
我想要告诉你们这个方法

00:38:07.346 --> 00:38:09.096 A:middle
如何运行 因为它可能

00:38:09.096 --> 00:38:10.306 A:middle
比你们认为的消耗更高一些

00:38:11.736 --> 00:38:13.046 A:middle
当你调用 systemLayoutSizeFittingSize 时

00:38:13.046 --> 00:38:15.386 A:middle
会创建一个引擎

00:38:16.086 --> 00:38:17.006 A:middle
约束被加入这个该引擎

00:38:17.006 --> 00:38:18.886 A:middle
计算布局

00:38:19.536 --> 00:38:23.546 A:middle
然后返回顶部视图的帧尺寸

00:38:23.546 --> 00:38:24.666 A:middle
之后此引擎被废弃

00:38:25.706 --> 00:38:26.646 A:middle
所以每次你调用

00:38:26.646 --> 00:38:27.916 A:middle
这个方法都会

00:38:27.916 --> 00:38:28.946 A:middle
创建然后废弃一个引擎

00:38:29.856 --> 00:38:31.386 A:middle
尽管对于小规模使用没问题

00:38:31.386 --> 00:38:33.006 A:middle
如果你多次使用

00:38:33.286 --> 00:38:34.306 A:middle
你可以看到它会

00:38:34.306 --> 00:38:35.486 A:middle
随着时间的流逝而堆积

00:38:35.706 --> 00:38:37.336 A:middle
因此谨慎使用

00:38:37.336 --> 00:38:38.616 A:middle
systemLayoutSizeFittingSize

00:38:39.636 --> 00:38:41.486 A:middle
其中的一个做法是

00:38:41.486 --> 00:38:42.956 A:middle
有时候看到有些人会

00:38:42.996 --> 00:38:44.646 A:middle
将这一调用从

00:38:44.646 --> 00:38:45.886 A:middle
自动调整选项或

00:38:45.886 --> 00:38:47.636 A:middle
表格视图单元格转到内容视图中

00:38:47.896 --> 00:38:49.186 A:middle
当你这么做时

00:38:49.186 --> 00:38:50.326 A:middle
你事实上在覆写一些

00:38:50.326 --> 00:38:51.886 A:middle
我们刚才做出的优化

00:38:51.886 --> 00:38:53.026 A:middle
让该视图滑动

00:38:53.026 --> 00:38:54.716 A:middle
更快的设置

00:38:54.716 --> 00:38:55.706 A:middle
并且还添加了多余的引擎

00:38:56.026 --> 00:38:57.086 A:middle
因此如果你目前这么做了

00:38:57.086 --> 00:38:58.106 A:middle
并且你的滑动不顺滑

00:38:58.106 --> 00:38:59.946 A:middle
你可以试着解决问题

00:39:01.026 --> 00:39:02.266 A:middle
好了 现在我们到了

00:39:02.266 --> 00:39:03.366 A:middle
我最喜欢的话题

00:39:03.836 --> 00:39:05.216 A:middle
不可满足约束

00:39:06.226 --> 00:39:10.146 A:middle
好的 那么什么是不可满足约束呢

00:39:10.226 --> 00:39:11.116 A:middle
如果你还未遇到过这个问题

00:39:11.116 --> 00:39:13.216 A:middle
这个问题发生的情况是

00:39:13.216 --> 00:39:14.856 A:middle
当你定义

00:39:15.396 --> 00:39:16.806 A:middle
这个视图的宽度应该是 50

00:39:16.806 --> 00:39:18.936 A:middle
同时也要是 200 的宽度

00:39:19.836 --> 00:39:21.606 A:middle
这不可能满足

00:39:21.976 --> 00:39:24.116 A:middle
事实上 量子手机不存在

00:39:25.276 --> 00:39:26.436 A:middle
你知道 我不能断言未来有没有

00:39:26.436 --> 00:39:30.696 A:middle
但是引擎不得不

00:39:30.696 --> 00:39:31.876 A:middle
计算得出结果

00:39:31.876 --> 00:39:33.906 A:middle
即不存在可用布局

00:39:33.906 --> 00:39:35.566 A:middle
于是破坏一个约束以

00:39:35.956 --> 00:39:37.556 A:middle
为你产生布局

00:39:38.536 --> 00:39:39.626 A:middle
它破坏约束时

00:39:40.246 --> 00:39:42.026 A:middle
会发送一个详细的日志

00:39:42.386 --> 00:39:43.496 A:middle
到你的调试器 也许你已经

00:39:43.496 --> 00:39:46.026 A:middle
见到过了 并且显示

00:39:46.026 --> 00:39:47.316 A:middle
不可满足约束

00:39:47.636 --> 00:39:49.876 A:middle
这是我破坏的约束 这些是其他

00:39:49.876 --> 00:39:51.476 A:middle
受到影响的约束 因此我

00:39:51.476 --> 00:39:52.186 A:middle
不得不破坏它

00:39:53.146 --> 00:39:54.836 A:middle
有时候这样会

00:39:55.366 --> 00:39:56.856 A:middle
直接影响性能

00:39:56.856 --> 00:39:57.986 A:middle
同时也可能掩盖其他问题

00:39:57.986 --> 00:39:59.596 A:middle
因此最好是调试解决此类情况

00:40:00.206 --> 00:40:01.346 A:middle
Auto Layout 的秘密 第二部分

00:40:01.346 --> 00:40:02.756 A:middle
提供了一些很好的

00:40:02.756 --> 00:40:04.566 A:middle
调试纠错信息

00:40:04.566 --> 00:40:05.706 A:middle
你可以看看

00:40:05.936 --> 00:40:06.786 A:middle
如果你在处理

00:40:06.786 --> 00:40:08.236 A:middle
不可满足约束时遇到了问题的话

00:40:09.806 --> 00:40:11.556 A:middle
好的 你们已经毕业了

00:40:11.556 --> 00:40:12.346 A:middle
恭喜你们

00:40:12.346 --> 00:40:13.946 A:middle
你们现在全部是 Auto Layout 专家了

00:40:14.746 --> 00:40:17.856 A:middle
你知道 我希望你们真正享受学习

00:40:17.856 --> 00:40:19.236 A:middle
它运作的内在问题

00:40:19.866 --> 00:40:21.736 A:middle
现在你们能够更好的了解

00:40:21.736 --> 00:40:23.056 A:middle
如何在更新约束之前思考

00:40:23.256 --> 00:40:24.416 A:middle
并且理解它们

00:40:24.416 --> 00:40:25.826 A:middle
所经历的过程 你们已经获得了一些

00:40:25.826 --> 00:40:27.916 A:middle
最新的关于尺寸

00:40:27.916 --> 00:40:29.846 A:middle
优先级和不等式的信息

00:40:29.846 --> 00:40:32.056 A:middle
你们的布局在 iOS 12 中会更快

00:40:32.056 --> 00:40:32.726 A:middle
这非常棒

00:40:33.416 --> 00:40:34.426 A:middle
我们明天会在实验室

00:40:34.496 --> 00:40:35.886 A:middle
如果任何人有问题的话

00:40:35.926 --> 00:40:36.386 A:middle
可以进行交流

00:40:37.006 --> 00:40:39.696 A:middle
这些是相关会议信息的链接

00:40:40.286 --> 00:40:40.976 A:middle
希望你们享受本周接下来的时间

00:40:41.516 --> 00:40:45.500 A:
[ 掌声 ]
