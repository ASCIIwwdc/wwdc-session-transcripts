WEBVTT

00:00:06.516 --> 00:00:13.500 A:middle
[ 音乐 ]

00:00:18.516 --> 00:00:25.786 A:middle
[ 掌声 ]

00:00:26.286 --> 00:00:27.426 A:middle
&gt;&gt; 上午好

00:00:27.536 --> 00:00:28.836 A:middle
我是 Chad Woolf

00:00:28.956 --> 00:00:30.186 A:middle
我是一名 Apple 的

00:00:30.186 --> 00:00:31.706 A:middle
性能工具工程师

00:00:31.706 --> 00:00:32.886 A:middle
欢迎各位参加今天的 410 号讨论会

00:00:32.886 --> 00:00:33.976 A:middle
我们将讨论

00:00:33.976 --> 00:00:35.336 A:middle
如何在 Instruments 10 中

00:00:35.336 --> 00:00:36.706 A:middle
创建自定义 Instrument

00:00:37.346 --> 00:00:38.666 A:middle
今天的讨论会是这样的

00:00:38.666 --> 00:00:39.576 A:middle
我们将讨论一下

00:00:39.796 --> 00:00:41.226 A:middle
为什么要创建

00:00:41.226 --> 00:00:42.246 A:middle
自定义 Instrument

00:00:42.296 --> 00:00:43.526 A:middle
我们将回顾一下

00:00:43.526 --> 00:00:45.406 A:middle
Instruments 的结构

00:00:45.406 --> 00:00:46.366 A:middle
我们今天有很多内容

00:00:46.366 --> 00:00:47.106 A:middle
所以讨论将会分为

00:00:47.106 --> 00:00:48.726 A:middle
三个部分

00:00:48.826 --> 00:00:50.256 A:middle
入门 中级和进阶部分

00:00:50.316 --> 00:00:51.626 A:middle
在那之后

00:00:51.626 --> 00:00:52.956 A:middle
我们会讨论一些最佳实践

00:00:52.956 --> 00:00:54.036 A:middle
以及一些在我们

00:00:54.096 --> 00:00:55.546 A:middle
编写我们自己的 Instrument 时

00:00:55.546 --> 00:00:56.346 A:middle
所学到的东西

00:00:57.166 --> 00:00:58.846 A:middle
首先

00:00:58.846 --> 00:01:00.566 A:middle
为什么要创建自定义 Instrument

00:00:58.846 --> 00:01:00.566 A:middle
为什么要创建自定义 Instrument

00:01:00.996 --> 00:01:02.576 A:middle
Instruments 已经集成了很多

00:01:02.576 --> 00:01:03.896 A:middle
非常强大的工具

00:01:03.896 --> 00:01:05.616 A:middle
例如这里我们有系统跟踪

00:01:05.616 --> 00:01:06.776 A:middle
你可以看到 App

00:01:06.776 --> 00:01:08.046 A:middle
如何与调度器

00:01:08.046 --> 00:01:09.456 A:middle
和虚拟内存交互

00:01:10.736 --> 00:01:12.076 A:middle
今年我们有一个新的

00:01:12.106 --> 00:01:13.396 A:middle
游戏性能模板 它结合了

00:01:13.396 --> 00:01:14.596 A:middle
系统跟踪和 Metal 系统跟踪

00:01:14.596 --> 00:01:17.496 A:middle
来帮助你发现 App 中的

00:01:17.496 --> 00:01:19.776 A:middle
故障和丢失的帧

00:01:20.176 --> 00:01:24.916 A:middle
在 App 的网络部分

00:01:24.916 --> 00:01:27.166 A:middle
我们也有网络连接 Instrument

00:01:27.166 --> 00:01:28.916 A:middle
它可以显示进出 App 的

00:01:28.916 --> 00:01:30.476 A:middle
TCP/IP 流量

00:01:30.476 --> 00:01:32.126 A:middle
当然还有

00:01:32.126 --> 00:01:34.156 A:middle
很多人都熟悉的时间分析器

00:01:34.276 --> 00:01:35.506 A:middle
时间分析器可以帮助你

00:01:35.506 --> 00:01:37.316 A:middle
查看 App

00:01:37.316 --> 00:01:38.866 A:middle
在何处花费时间

00:01:38.866 --> 00:01:40.006 A:middle
无论是网络层

00:01:40.006 --> 00:01:41.826 A:middle
游戏引擎还是其他部分

00:01:42.816 --> 00:01:45.756 A:middle
普遍来说

00:01:45.756 --> 00:01:48.896 A:middle
如果你了解

00:01:48.896 --> 00:01:50.376 A:middle
你正在编辑的代码

00:01:50.376 --> 00:01:51.646 A:middle
这些都是非常有用的

00:01:51.646 --> 00:01:52.466 A:middle
如果你知道这些 IP 地址

00:01:52.466 --> 00:01:53.416 A:middle
是什么意思

00:01:53.416 --> 00:01:54.856 A:middle
知道不同的函数

00:01:54.856 --> 00:01:56.306 A:middle
是什么意思

00:01:56.306 --> 00:01:58.236 A:middle
以及时间分析器的调用堆栈

00:01:58.306 --> 00:01:59.196 A:middle
它会让事情变得更简单

00:01:59.966 --> 00:02:01.826 A:middle
然而 如果有人打算分析你的 App

00:01:59.966 --> 00:02:01.826 A:middle
然而 如果有人打算分析你的 App

00:02:01.826 --> 00:02:02.916 A:middle
但他们不熟悉其中的代码

00:02:02.916 --> 00:02:04.176 A:middle
那该怎么办呢

00:02:04.176 --> 00:02:05.746 A:middle
要是他们只是想知道

00:02:05.746 --> 00:02:07.216 A:middle
App 是否在网络层上

00:02:07.216 --> 00:02:08.265 A:middle
花费了大量的时间

00:02:08.316 --> 00:02:10.086 A:middle
如果是 它在做什么

00:02:10.596 --> 00:02:12.946 A:middle
自定义 Instrument 的一个

00:02:12.946 --> 00:02:14.566 A:middle
很好的用途就是

00:02:14.696 --> 00:02:16.886 A:middle
尝试以一种

00:02:16.886 --> 00:02:18.096 A:middle
使原本无法理解代码的人

00:02:18.096 --> 00:02:19.936 A:middle
能够理解和欣赏代码的方式

00:02:19.936 --> 00:02:21.216 A:middle
讲述你的某一层或 App

00:02:21.496 --> 00:02:22.983 A:middle
正在做什么

00:02:24.856 --> 00:02:25.986 A:middle
在进阶部分中

00:02:25.986 --> 00:02:27.516 A:middle
我们将向你展示如何

00:02:27.516 --> 00:02:28.596 A:middle
利用在 Instruments

00:02:28.596 --> 00:02:30.296 A:middle
内部构建的

00:02:30.296 --> 00:02:31.846 A:middle
专家系统技术

00:02:31.846 --> 00:02:33.766 A:middle
以便你可以创建一个

00:02:33.846 --> 00:02:35.366 A:middle
即使你不亲力亲为

00:02:35.366 --> 00:02:36.476 A:middle
也能够查找错误模式

00:02:36.476 --> 00:02:38.206 A:middle
并在代码中

00:02:38.206 --> 00:02:38.786 A:middle
发现反面模式的 Instrument

00:02:40.376 --> 00:02:41.256 A:middle
好的 让我们来看看

00:02:41.256 --> 00:02:43.156 A:middle
使上述功能成为可能的架构

00:02:43.626 --> 00:02:45.226 A:middle
要做到这一点

00:02:45.226 --> 00:02:47.996 A:middle
我们必须从这里开始

00:02:47.996 --> 00:02:48.406 A:middle
回到原始版本

00:02:49.196 --> 00:02:51.276 A:middle
起初的 Instruments 的

00:02:51.276 --> 00:02:52.866 A:middle
工作原理和今天的差不多

00:02:52.936 --> 00:02:54.156 A:middle
同样有一个库

00:02:54.196 --> 00:02:55.546 A:middle
你仍然可以拖出 Instrument

00:02:55.546 --> 00:02:56.816 A:middle
并将它们放入跟踪文档中

00:02:56.816 --> 00:02:58.456 A:middle
然后按下记录按钮

00:02:58.456 --> 00:03:00.946 A:middle
多个性能工具就可以同时运行

00:02:58.456 --> 00:03:00.946 A:middle
多个性能工具就可以同时运行

00:03:01.616 --> 00:03:02.966 A:middle
那时和现在的 Instruments 之间的

00:03:02.966 --> 00:03:04.646 A:middle
主要区别是

00:03:04.716 --> 00:03:05.516 A:middle
当时的 Instruments 基础结构

00:03:05.516 --> 00:03:06.816 A:middle
并无法帮助我们

00:03:06.816 --> 00:03:08.976 A:middle
快速编写 Instrument

00:03:09.746 --> 00:03:11.606 A:middle
在当时这样还好

00:03:11.606 --> 00:03:12.866 A:middle
因为我们已经

00:03:12.916 --> 00:03:14.526 A:middle
继承了一些我们已有的

00:03:14.526 --> 00:03:16.336 A:middle
素材和性能工具

00:03:16.796 --> 00:03:17.956 A:middle
它们都有自己的

00:03:17.956 --> 00:03:18.726 A:middle
记录技术和分析逻辑

00:03:18.726 --> 00:03:20.436 A:middle
我们所要做的就是建立一个

00:03:20.436 --> 00:03:22.196 A:middle
自定义的存储机制

00:03:22.196 --> 00:03:23.266 A:middle
来获取跟踪中的数据

00:03:23.266 --> 00:03:25.506 A:middle
以及一个自定义的 UI 来帮助它

00:03:25.506 --> 00:03:27.786 A:middle
与 App 的其他部分集成

00:03:27.886 --> 00:03:29.816 A:middle
随着时间的推移

00:03:29.816 --> 00:03:31.126 A:middle
Instruments 的维护成本

00:03:31.126 --> 00:03:32.736 A:middle
和模型的维护成本都上升了

00:03:33.576 --> 00:03:34.626 A:middle
原因就是

00:03:34.626 --> 00:03:36.526 A:middle
每次我们想要

00:03:36.526 --> 00:03:37.876 A:middle
添加新特性时

00:03:37.876 --> 00:03:39.546 A:middle
我们必须修改 7 个自定义 UI

00:03:39.546 --> 00:03:41.846 A:middle
和 7 个自定义存储机制

00:03:42.196 --> 00:03:43.746 A:middle
但这不是我们想让你们

00:03:43.746 --> 00:03:44.676 A:middle
学习的处理方式

00:03:44.676 --> 00:03:45.626 A:middle
我们不想让你们

00:03:45.626 --> 00:03:46.756 A:middle
承担这种维护成本

00:03:47.216 --> 00:03:48.516 A:middle
所以在我们讨论

00:03:48.516 --> 00:03:49.646 A:middle
定制 Instrument 的特性之前

00:03:49.646 --> 00:03:51.236 A:middle
我们首先需要解决这个问题

00:03:51.236 --> 00:03:52.776 A:middle
我认为我们做到了

00:03:53.586 --> 00:03:54.556 A:middle
在新版本的 Instruments 中

00:03:54.556 --> 00:03:56.186 A:middle
我们没有自定义 UI

00:03:56.186 --> 00:03:57.516 A:middle
和自定义存储机制

00:03:57.516 --> 00:03:58.906 A:middle
而是有两个

00:03:58.906 --> 00:04:00.456 A:middle
标准化的组件

00:03:58.906 --> 00:04:00.456 A:middle
标准化的组件

00:04:00.456 --> 00:04:02.286 A:middle
它们是 “Standard UI（标准 UI）”和

00:04:02.286 --> 00:04:03.116 A:middle
“Analysis Core（分析核心）”

00:04:03.616 --> 00:04:06.606 A:middle
标准 UI 实现了新版 Instruments 的

00:04:06.606 --> 00:04:07.926 A:middle
整个用户界面

00:04:08.666 --> 00:04:09.986 A:middle
它与分析核心

00:04:09.986 --> 00:04:10.776 A:middle
紧密相连

00:04:11.496 --> 00:04:12.756 A:middle
而分析核心

00:04:12.756 --> 00:04:13.976 A:middle
你可以将其视为

00:04:13.976 --> 00:04:16.906 A:middle
数据库和专家系统的结合

00:04:17.305 --> 00:04:18.516 A:middle
这两种都针对

00:04:18.516 --> 00:04:19.745 A:middle
时间序列数据进行了优化

00:04:19.846 --> 00:04:21.966 A:middle
使得它们成为构建 Instrument 的重要基础

00:04:22.406 --> 00:04:23.786 A:middle
当你使用新型架构

00:04:24.226 --> 00:04:25.406 A:middle
构建一个 Instrument 时

00:04:25.626 --> 00:04:27.456 A:middle
实际上你所做的是

00:04:27.456 --> 00:04:29.236 A:middle
创建标准 UI

00:04:29.876 --> 00:04:30.876 A:middle
和分析核心

00:04:30.876 --> 00:04:32.916 A:middle
的自定义配置

00:04:34.126 --> 00:04:35.636 A:middle
如果你看一下

00:04:35.636 --> 00:04:36.826 A:middle
我一开始展示的那些强大的 Instrument

00:04:36.826 --> 00:04:38.286 A:middle
的屏幕快照

00:04:38.286 --> 00:04:40.006 A:middle
我们有系统跟踪

00:04:40.006 --> 00:04:42.276 A:middle
游戏性能模板

00:04:42.276 --> 00:04:44.196 A:middle
网络连接模板

00:04:44.196 --> 00:04:48.196 A:middle
以及时间分析器

00:04:48.886 --> 00:04:51.416 A:middle
所有这些文档中的所有 Instrument

00:04:51.476 --> 00:04:53.076 A:middle
都是完全基于标准 UI

00:04:53.076 --> 00:04:55.246 A:middle
和分析核心生成的

00:04:55.476 --> 00:04:56.616 A:middle
所以你也同样可以做

00:04:56.616 --> 00:04:57.586 A:middle
它们能做的事情

00:04:58.266 --> 00:05:01.516 A:middle
在 Xcode 10 和 Instruments 10 中

00:04:58.266 --> 00:05:01.516 A:middle
在 Xcode 10 和 Instruments 10 中

00:05:01.516 --> 00:05:02.976 A:middle
我们提供了相同的工具 来构建你的 Instrument

00:05:03.046 --> 00:05:05.966 A:middle
Xcode 集成的 Instrument

00:05:06.086 --> 00:05:07.156 A:middle
和你生成的 Instrument 之间的

00:05:07.466 --> 00:05:10.336 A:middle
唯一区别就是

00:05:10.336 --> 00:05:12.206 A:middle
谁生成了它

00:05:12.886 --> 00:05:16.116 A:middle
你的 Instrument 会显示在我们的库中

00:05:16.116 --> 00:05:18.266 A:middle
你可以看到顶部的活动监视器

00:05:19.106 --> 00:05:20.176 A:middle
就像这样

00:05:20.176 --> 00:05:21.696 A:middle
你可以将你的 Instrument 拖放到

00:05:21.696 --> 00:05:23.386 A:middle
跟踪文档中并进行记录

00:05:24.136 --> 00:05:25.076 A:middle
接下来

00:05:25.076 --> 00:05:26.036 A:middle
Instruments 将用数据

00:05:26.036 --> 00:05:27.646 A:middle
填充分析核心

00:05:27.646 --> 00:05:29.436 A:middle
标准 UI 将创建图形

00:05:29.436 --> 00:05:30.886 A:middle
和表格视图

00:05:31.846 --> 00:05:33.696 A:middle
Instruments 有两种

00:05:33.696 --> 00:05:34.306 A:middle
显示数据的方式

00:05:34.416 --> 00:05:35.686 A:middle
在顶部有一个图形化的视图

00:05:35.686 --> 00:05:36.876 A:middle
我们称之为轨道视图

00:05:36.876 --> 00:05:38.486 A:middle
一个 Instrument 可以根据需要

00:05:38.486 --> 00:05:41.186 A:middle
定义多个轨道

00:05:42.236 --> 00:05:43.796 A:middle
如果你想

00:05:43.796 --> 00:05:44.776 A:middle
在定义 Instrument 的图之间

00:05:44.776 --> 00:05:45.706 A:middle
进行选择

00:05:45.706 --> 00:05:47.056 A:middle
在 Instrument 图标上

00:05:47.056 --> 00:05:48.456 A:middle
有一个小控件

00:05:48.776 --> 00:05:49.886 A:middle
你可以把它

00:05:49.986 --> 00:05:52.106 A:middle
从 “CPU” 改为 “Network（网络）”

00:05:53.746 --> 00:05:55.966 A:middle
每个图都被允许

00:05:55.966 --> 00:05:57.496 A:middle
定义一定数量的轨道

00:05:57.736 --> 00:05:58.926 A:middle
这里我们定义了 3 个轨道

00:05:58.926 --> 00:06:00.156 A:middle
并绘制了 3 种不同类型的

00:05:58.926 --> 00:06:00.156 A:middle
并绘制了 3 种不同类型的

00:06:00.156 --> 00:06:01.576 A:middle
CPU 利用情况

00:06:02.266 --> 00:06:04.436 A:middle
这里的每一个轨道

00:06:04.436 --> 00:06:05.906 A:middle
都被绑定到分析核心中的

00:06:05.906 --> 00:06:07.426 A:middle
不同的表上

00:06:07.426 --> 00:06:08.796 A:middle
或者它可以被绑定到同一个表上

00:06:08.796 --> 00:06:09.646 A:middle
但是你看到的是

00:06:09.646 --> 00:06:11.046 A:middle
这个表中的另一列

00:06:12.266 --> 00:06:14.566 A:middle
这个 Instrument 的另一部分

00:06:14.566 --> 00:06:16.556 A:middle
就在下方

00:06:16.556 --> 00:06:17.786 A:middle
它同样也很重要

00:06:17.786 --> 00:06:18.736 A:middle
它叫做细节视图

00:06:18.896 --> 00:06:20.216 A:middle
在这里你可以看到

00:06:20.216 --> 00:06:22.536 A:middle
事件列表

00:06:22.816 --> 00:06:24.066 A:middle
以及数据的任何类型的

00:06:24.066 --> 00:06:26.086 A:middle
聚合和总结

00:06:26.986 --> 00:06:29.306 A:middle
就像这些轨道

00:06:29.306 --> 00:06:31.146 A:middle
抱歉 就像这些图一样

00:06:31.146 --> 00:06:32.836 A:middle
你可以为你的 Instrument

00:06:32.836 --> 00:06:34.176 A:middle
定义一些细节

00:06:34.176 --> 00:06:36.416 A:middle
你也可以通过点按跳转栏的这个部分

00:06:36.416 --> 00:06:37.976 A:middle
然后选择你定义的细节标题

00:06:37.976 --> 00:06:39.586 A:middle
来选择哪个细节是活跃的

00:06:40.966 --> 00:06:42.616 A:middle
就像图形视图中的轨道一样

00:06:42.616 --> 00:06:44.786 A:middle
所有的细节都被

00:06:44.786 --> 00:06:46.656 A:middle
绑定到分析核心的一个表上

00:06:46.656 --> 00:06:48.016 A:middle
这就是它们

00:06:48.016 --> 00:06:48.786 A:middle
接收数据的地方

00:06:49.166 --> 00:06:50.006 A:middle
记录开始

00:06:50.006 --> 00:06:50.966 A:middle
表格被填入

00:06:51.236 --> 00:06:52.626 A:middle
UI 就会做出反应

00:06:52.626 --> 00:06:55.366 A:middle
不需要你执行任何特殊代码

00:06:56.156 --> 00:06:58.836 A:middle
从标准 UI 的角度来看

00:06:58.836 --> 00:07:00.036 A:middle
分析核心中的所有内容

00:06:58.836 --> 00:07:00.036 A:middle
分析核心中的所有内容

00:07:00.036 --> 00:07:02.096 A:middle
似乎都是一个表格

00:07:02.096 --> 00:07:03.986 A:middle
我们来谈谈表格

00:07:05.196 --> 00:07:06.916 A:middle
表格是行的集合

00:07:06.916 --> 00:07:07.886 A:middle
它们有一个

00:07:07.886 --> 00:07:09.516 A:middle
由表格 Schema 定义的结构

00:07:09.666 --> 00:07:11.656 A:middle
所以它和数据库 App 非常相似

00:07:12.536 --> 00:07:14.106 A:middle
这个 Schema 定义了

00:07:14.106 --> 00:07:15.396 A:middle
列 列的名称

00:07:15.396 --> 00:07:16.236 A:middle
以及列的类型

00:07:16.746 --> 00:07:18.246 A:middle
分析核心使用了一个

00:07:18.246 --> 00:07:19.606 A:middle
非常丰富的类型系统

00:07:19.606 --> 00:07:21.296 A:middle
叫做工程类型

00:07:21.296 --> 00:07:22.446 A:middle
它告诉我们如何存储数据

00:07:22.446 --> 00:07:24.216 A:middle
以及如何在标准 UI 中

00:07:24.216 --> 00:07:25.806 A:middle
可视化和分析数据

00:07:27.556 --> 00:07:29.886 A:middle
除此之外

00:07:29.886 --> 00:07:31.426 A:middle
当 Schema 描述

00:07:31.546 --> 00:07:33.246 A:middle
表的结构时

00:07:33.246 --> 00:07:34.516 A:middle
你还可以使用 Key/value 这对属性

00:07:34.516 --> 00:07:36.146 A:middle
来描述内容

00:07:36.616 --> 00:07:38.986 A:middle
这能帮助我们描述表中的内容

00:07:39.566 --> 00:07:42.216 A:middle
你可以将 Schema

00:07:42.216 --> 00:07:44.606 A:middle
视为 Objective-C 或 Swift 中的一个类

00:07:44.606 --> 00:07:46.246 A:middle
而行则类似于实例

00:07:46.586 --> 00:07:47.886 A:middle
就像 Objective-C 中的

00:07:48.006 --> 00:07:50.236 A:middle
类名是单数的一样

00:07:50.236 --> 00:07:51.296 A:middle
你的 Schema 的名称

00:07:51.296 --> 00:07:53.516 A:middle
也必须是单数的

00:07:53.516 --> 00:07:55.416 A:middle
比如 NSString

00:07:55.416 --> 00:07:56.056 A:middle
而不是 NSStrings

00:07:56.246 --> 00:07:58.136 A:middle
当我们讲到进阶部分的时候

00:07:58.136 --> 00:07:58.906 A:middle
这一点会更为重要

00:07:58.906 --> 00:07:59.876 A:middle
但是我现在想把它强调一下

00:07:59.876 --> 00:08:01.496 A:middle
到时我们就能知道

00:07:59.876 --> 00:08:01.496 A:middle
到时我们就能知道

00:08:01.496 --> 00:08:03.026 A:middle
我们在讨论什么了

00:08:03.026 --> 00:08:05.596 A:middle
Schema 的一个例子是 Tick

00:08:06.136 --> 00:08:07.106 A:middle
它是 Instruments

00:08:07.106 --> 00:08:08.926 A:middle
内部的一种 Schema

00:08:08.926 --> 00:08:10.286 A:middle
用于创建

00:08:10.286 --> 00:08:11.666 A:middle
合成时钟节拍表

00:08:11.666 --> 00:08:13.676 A:middle
稍后我们将在建模器中

00:08:13.676 --> 00:08:15.146 A:middle
使用它进行统计计算

00:08:15.916 --> 00:08:17.076 A:middle
Tick Schema 很简单

00:08:17.076 --> 00:08:18.456 A:middle
它只有一个列要被定义

00:08:18.456 --> 00:08:19.956 A:middle
那就是 time

00:08:19.956 --> 00:08:20.626 A:middle
time 使用的工程类型是

00:08:20.626 --> 00:08:21.356 A:middle
sample-time

00:08:22.196 --> 00:08:24.046 A:middle
Tick Schema 还定义了

00:08:24.276 --> 00:08:26.796 A:middle
一个可以附加到表格实例中的可选属性

00:08:26.796 --> 00:08:27.346 A:middle
它叫做 frequency

00:08:27.856 --> 00:08:30.066 A:middle
如果你为 Tick Schema

00:08:30.066 --> 00:08:32.096 A:middle
创建一个

00:08:32.096 --> 00:08:34.456 A:middle
频率为 10 的表格

00:08:34.775 --> 00:08:36.576 A:middle
那么数据的提供者

00:08:36.576 --> 00:08:38.046 A:middle
就会知道它需要

00:08:38.346 --> 00:08:40.806 A:middle
每秒填充 10 个时间戳

00:08:40.806 --> 00:08:41.826 A:middle
这样你就可以表达

00:08:41.826 --> 00:08:43.176 A:middle
你想要填入表的内容

00:08:44.586 --> 00:08:45.916 A:middle
现在 我认为

00:08:46.356 --> 00:08:47.766 A:middle
我们有足够的信息

00:08:47.766 --> 00:08:48.366 A:middle
来开始入门部分

00:08:48.856 --> 00:08:50.076 A:middle
我们将展示

00:08:50.076 --> 00:08:52.256 A:middle
如何在 Xcode 中

00:08:52.296 --> 00:08:54.046 A:middle
创建你自己的 Instruments 包项目

00:08:54.046 --> 00:08:55.876 A:middle
还将向你展示 如何创建你的第一个 Instrument

00:08:55.876 --> 00:08:57.316 A:middle
来绘制这些 Tick

00:08:57.406 --> 00:08:59.886 A:middle
并在细节视图中 显示这些 Tick

00:09:00.376 --> 00:09:01.916 A:middle
为此我想请

00:09:01.916 --> 00:09:04.016 A:middle
我的同事 Kacper

00:09:04.016 --> 00:09:04.976 A:middle
给大家做一个展示

00:09:05.516 --> 00:09:07.966 A:middle
[ 掌声 ]

00:09:08.466 --> 00:09:09.276 A:middle
&gt;&gt; 谢谢大家

00:09:10.046 --> 00:09:12.136 A:middle
现在我将向你们展示

00:09:12.136 --> 00:09:13.986 A:middle
如何开始创建和运行

00:09:13.986 --> 00:09:15.306 A:middle
你们的第一个自定义 Instrument

00:09:16.346 --> 00:09:17.356 A:middle
你们将会使用

00:09:17.356 --> 00:09:19.426 A:middle
由 Chad 之前展示的 Tick Schema

00:09:19.426 --> 00:09:21.096 A:middle
并在频率恒定的节拍中

00:09:21.386 --> 00:09:22.556 A:middle
制作一个 Instrument

00:09:23.256 --> 00:09:25.426 A:middle
你们将会学到如何描述你们的包

00:09:25.426 --> 00:09:27.556 A:middle
如何使用 Xcode 对其进行迭代

00:09:27.596 --> 00:09:30.116 A:middle
以及如何在 Instruments 中进行测试

00:09:31.156 --> 00:09:31.866 A:middle
让我们开始吧

00:09:33.266 --> 00:09:34.636 A:middle
和在 Xcode 中

00:09:34.636 --> 00:09:36.596 A:middle
以前的操作一样

00:09:36.596 --> 00:09:37.976 A:middle
创建新的 Instruments 包项目

00:09:38.696 --> 00:09:40.216 A:middle
你需要点击 “New Xcode Project”

00:09:40.996 --> 00:09:42.776 A:middle
选择 “macOS” 作为平台

00:09:42.776 --> 00:09:43.706 A:middle
并点击 “Instruments Package”

00:09:45.366 --> 00:09:46.146 A:middle
你需要填写文件名称

00:09:46.146 --> 00:09:49.566 A:middle
这将成为这个 Instrument 包的默认名称

00:09:50.026 --> 00:09:51.016 A:middle
我们就命名为 “Ticks” 吧

00:09:51.626 --> 00:09:54.966 A:middle
点击 “Next（下一步）”和“Create（创建）”

00:09:59.536 --> 00:10:01.626 A:middle
Xcode 已经创建了

00:09:59.536 --> 00:10:01.626 A:middle
Xcode 已经创建了

00:10:01.776 --> 00:10:03.656 A:middle
带有包 Target 的项目和一个文件

00:10:04.406 --> 00:10:05.706 A:middle
里面有对包的定义

00:10:06.246 --> 00:10:09.286 A:middle
让我们来看看

00:10:10.176 --> 00:10:13.406 A:middle
包是基于 XML 语法描述的

00:10:13.816 --> 00:10:15.626 A:middle
首先 每个包最前面有

00:10:15.626 --> 00:10:18.846 A:middle
标识符 标题和所有者

00:10:19.406 --> 00:10:21.146 A:middle
当有人试图安装你的包时

00:10:21.146 --> 00:10:23.076 A:middle
这些栏将是可见的

00:10:24.876 --> 00:10:26.466 A:middle
通常 你可以从

00:10:26.466 --> 00:10:29.736 A:middle
定义自己的 Schema

00:10:29.736 --> 00:10:31.546 A:middle
和可选的建模器开始

00:10:31.756 --> 00:10:32.776 A:middle
但是因为这里我们将使用

00:10:32.816 --> 00:10:34.776 A:middle
预定义的 Tick Schema

00:10:34.776 --> 00:10:36.576 A:middle
我们将删除这些指示

00:10:38.876 --> 00:10:41.416 A:middle
要从基础包中导入 Tick Schema

00:10:41.416 --> 00:10:43.176 A:middle
你只需指定

00:10:43.206 --> 00:10:44.926 A:middle
import-schema 元素

00:10:45.586 --> 00:10:48.976 A:middle
和 Schema 的名称 “tick”

00:10:53.696 --> 00:10:56.156 A:middle
现在它可以被我们的 Instrument 使用了

00:10:58.516 --> 00:11:00.636 A:middle
为了让你们更容易地定义

00:10:58.516 --> 00:11:00.636 A:middle
为了让你们更容易地定义

00:11:00.636 --> 00:11:02.736 A:middle
更复杂的元素

00:11:02.736 --> 00:11:04.466 A:middle
我们在 Xcode 中配置了一些代码片段

00:11:05.296 --> 00:11:07.206 A:middle
要使用它们

00:11:07.206 --> 00:11:09.146 A:middle
只需写入元素名称

00:11:09.146 --> 00:11:11.436 A:middle
比如 “instrument” 然后按回车

00:11:11.436 --> 00:11:14.256 A:middle
你需要填写

00:11:14.256 --> 00:11:15.976 A:middle
你的 Instrument 的唯一标识符

00:11:20.706 --> 00:11:22.946 A:middle
以及稍后出现在

00:11:22.946 --> 00:11:23.976 A:middle
Instrument 库中的一些属性

00:11:29.626 --> 00:11:31.216 A:middle
这里是 “Instrument drawing

00:11:31.326 --> 00:11:34.946 A:middle
ticks every 10ms”

00:11:39.306 --> 00:11:41.186 A:middle
现在是创建表格的时候了

00:11:41.186 --> 00:11:42.696 A:middle
当这个 Instrument 从库中

00:11:42.696 --> 00:11:44.416 A:middle
被拖到跟踪文档时

00:11:44.546 --> 00:11:46.456 A:middle
这个表格将被实例化

00:11:47.956 --> 00:11:49.346 A:middle
在这个 Instrument 的定义中

00:11:49.346 --> 00:11:51.536 A:middle
表格标识符必须是唯一的

00:11:52.446 --> 00:11:56.116 A:middle
我们叫它 “tick-table”

00:11:56.226 --> 00:11:57.786 A:middle
在 <schema-ref> 中

00:11:57.786 --> 00:11:58.966 A:middle
我们需要引用以前

00:11:58.966 --> 00:12:03.816 A:middle
导入的 Schema“tick”

00:11:58.966 --> 00:12:03.816 A:middle
导入的 Schema“tick”

00:12:04.516 --> 00:12:05.986 A:middle
现在我们需要定义

00:12:05.986 --> 00:12:08.126 A:middle
在轨道视图和细节视图中

00:12:08.126 --> 00:12:09.556 A:middle
会出现的内容

00:12:10.276 --> 00:12:11.966 A:middle
我将使用 graph 元素

00:12:12.696 --> 00:12:15.886 A:middle
我们需要为我们的图形

00:12:15.886 --> 00:12:16.596 A:middle
填写 title

00:12:16.596 --> 00:12:19.166 A:middle
我会命名为 “Ticks”

00:12:19.486 --> 00:12:21.296 A:middle
轨道的标题也一样

00:12:21.916 --> 00:12:25.816 A:middle
我需要按照前面创建的

00:12:25.816 --> 00:12:30.276 A:middle
标识符来引用表格

00:12:30.276 --> 00:12:31.256 A:middle
因此我将引用 “tick-table”

00:12:34.346 --> 00:12:36.376 A:middle
现在我们要为我们的图

00:12:36.376 --> 00:12:37.186 A:middle
指定绘制

00:12:38.186 --> 00:12:39.646 A:middle
我会使用 plot 元素

00:12:40.556 --> 00:12:42.926 A:middle
在最基本的形式中

00:12:42.926 --> 00:12:44.226 A:middle
它只需要你传递

00:12:44.226 --> 00:12:45.446 A:middle
包含要绘制的值的

00:12:45.496 --> 00:12:46.686 A:middle
列的助记符

00:12:46.686 --> 00:12:48.876 A:middle
我们将绘制 “time”

00:12:52.696 --> 00:12:53.956 A:middle
我希望所有的时间戳

00:12:53.956 --> 00:12:57.156 A:middle
都能在表格中显示出来

00:12:57.826 --> 00:12:59.976 A:middle
为此 我将使用 list 元素

00:13:02.496 --> 00:13:04.916 A:middle
我们需要为一个

00:13:04.916 --> 00:13:06.236 A:middle
将会出现在 Instrument 中的列表

00:13:06.366 --> 00:13:11.516 A:middle
填写 title 元素

00:13:11.516 --> 00:13:12.816 A:middle
“table-ref” 就像之前的 lane 元素一样

00:13:12.816 --> 00:13:15.906 A:middle
以及我们想要看到的 column

00:13:20.566 --> 00:13:22.556 A:middle
现在我们的包已经准备好

00:13:22.556 --> 00:13:24.886 A:middle
在 Instruments 中构建并运行了

00:13:25.946 --> 00:13:27.656 A:middle
为此 你需要使用

00:13:27.656 --> 00:13:28.716 A:middle
“Xcode Scheme Run” 操作

00:13:29.676 --> 00:13:34.936 A:middle
我们就这样做吧

00:13:34.936 --> 00:13:35.336 A:middle
你可以看到出现了构建错误

00:13:35.906 --> 00:13:37.696 A:middle
在生成 Instruments 包时

00:13:37.696 --> 00:13:38.916 A:middle
你拥有完整的 IDE 支持

00:13:39.336 --> 00:13:41.526 A:middle
这里 出现了一行错误

00:13:41.526 --> 00:13:43.426 A:middle
告诉我们在 Tick Schema 中

00:13:43.426 --> 00:13:45.386 A:middle
找不到 “timestamp” 这一列

00:13:45.706 --> 00:13:46.816 A:middle
没错

00:13:46.816 --> 00:13:47.536 A:middle
因为它不是 “timestamp”

00:13:47.536 --> 00:13:48.616 A:middle
而应该是 “time”

00:13:48.836 --> 00:13:52.676 A:middle
我将修复这个问题并再次运行它

00:13:53.296 --> 00:13:58.256 A:middle
你可以看到它在运行

00:13:58.256 --> 00:13:59.796 A:middle
因为这个新的 Instrument 副本出现了

00:13:59.796 --> 00:14:02.226 A:middle
你可以通过不同的图标

00:13:59.796 --> 00:14:02.226 A:middle
你可以通过不同的图标

00:14:02.226 --> 00:14:03.786 A:middle
识别特殊的副本

00:14:04.816 --> 00:14:06.656 A:middle
它仅为这个运行会话

00:14:06.976 --> 00:14:08.226 A:middle
加载你的包

00:14:08.796 --> 00:14:10.516 A:middle
它允许你更容易地

00:14:10.516 --> 00:14:11.446 A:middle
对包进行迭代

00:14:12.066 --> 00:14:15.666 A:middle
为了确保你的包已经加载

00:14:15.666 --> 00:14:17.356 A:middle
我们可以在

00:14:17.356 --> 00:14:19.686 A:middle
新建包管理的 UI 中检查它

00:14:20.396 --> 00:14:22.386 A:middle
你可以在 “Instruments”-

00:14:22.556 --> 00:14:24.536 A:middle
“Preferences（偏好设置）”

00:14:24.536 --> 00:14:25.176 A:middle
-“Packages（包）”标签页中找到它

00:14:25.176 --> 00:14:29.556 A:middle
你可以在这里看到

00:14:29.556 --> 00:14:31.746 A:middle
我们新创建的包以及调试的下标

00:14:31.886 --> 00:14:33.466 A:middle
这意味着它已经被

00:14:33.466 --> 00:14:35.736 A:middle
临时加载

00:14:35.736 --> 00:14:37.296 A:middle
你也可以在这里看到

00:14:37.296 --> 00:14:37.996 A:middle
所有的系统包

00:14:38.396 --> 00:14:39.916 A:middle
你可以通过使用副标题

00:14:40.096 --> 00:14:41.866 A:middle
使用并链接它们

00:14:41.866 --> 00:14:46.576 A:middle
在这里 我们的 Ticks 包里包含了

00:14:46.576 --> 00:14:52.776 A:middle
Ticks Instrument 现在让我们用空白模板测试它

00:14:53.396 --> 00:14:55.966 A:middle
我将把 Target 切换到我的 MacBook

00:15:00.456 --> 00:15:01.586 A:middle
然后在 Instruments 库中

00:15:01.586 --> 00:15:03.386 A:middle
搜索我的 Instrument

00:15:03.546 --> 00:15:08.106 A:middle
我将填入 “Ticks”

00:15:08.606 --> 00:15:10.586 A:middle
然后它将显示在这里

00:15:10.586 --> 00:15:12.226 A:middle
包含从包定义中

00:15:12.226 --> 00:15:13.156 A:middle
填充的所有属性

00:15:13.726 --> 00:15:15.976 A:middle
让我们将它拖放到跟踪中

00:15:19.576 --> 00:15:20.976 A:middle
并记录一秒钟

00:15:25.476 --> 00:15:28.486 A:middle
你可以看到底部的面板

00:15:28.486 --> 00:15:30.506 A:middle
是以每 10 毫秒生成的数据

00:15:30.506 --> 00:15:31.676 A:middle
进行传递的

00:15:33.306 --> 00:15:35.896 A:middle
细节和图形是相互协调的

00:15:36.366 --> 00:15:37.826 A:middle
当我点击行时

00:15:37.826 --> 00:15:39.766 A:middle
你可以看到检查线在这里移动

00:15:40.796 --> 00:15:42.706 A:middle
我还可以通过 Option 点按并拖动

00:15:43.096 --> 00:15:48.806 A:middle
来而放大一个图

00:15:48.806 --> 00:15:50.316 A:middle
在这里 你可以看到

00:15:50.316 --> 00:15:51.656 A:middle
Ticks 确实被画出来了

00:15:53.656 --> 00:15:55.736 A:middle
这样你就可以创建

00:15:55.936 --> 00:15:56.886 A:middle
第一个 Instrument 包

00:15:57.306 --> 00:15:59.446 A:middle
现在让我们请回 Chad

00:15:59.446 --> 00:16:00.716 A:middle
他会告诉你更多 关于标准 UI 的内容

00:15:59.446 --> 00:16:00.716 A:middle
他会告诉你更多 关于标准 UI 的内容

00:16:01.516 --> 00:16:04.466 A:middle
[ 掌声 ]

00:16:04.966 --> 00:16:05.226 A:middle
&gt;&gt; 好的

00:16:05.226 --> 00:16:05.986 A:middle
谢谢 Kacper

00:16:06.786 --> 00:16:07.906 A:middle
我们已经知道了

00:16:07.906 --> 00:16:09.326 A:middle
如何创建一个非常基本的 Instrument

00:16:09.326 --> 00:16:11.136 A:middle
也了解了如何开始

00:16:11.326 --> 00:16:12.946 A:middle
在 Xcode 中创建你的第一个项目

00:16:13.706 --> 00:16:15.126 A:middle
现在让我们来谈谈

00:16:15.126 --> 00:16:17.416 A:middle
我们拥有的不同类型的图

00:16:17.416 --> 00:16:18.846 A:middle
不同类型的细节

00:16:18.846 --> 00:16:20.716 A:middle
以及如何利用真实数据进行操作

00:16:21.656 --> 00:16:23.686 A:middle
让我们从图形轨道开始

00:16:24.896 --> 00:16:27.206 A:middle
你已经看到了 Kacper

00:16:27.206 --> 00:16:28.626 A:middle
是如何使用我们称之为 plot 的元素

00:16:28.966 --> 00:16:30.636 A:middle
来定义一个图形和轨道的

00:16:31.066 --> 00:16:34.256 A:middle
plot 元素可以

00:16:34.366 --> 00:16:36.566 A:middle
指示标准 UI

00:16:36.566 --> 00:16:38.016 A:middle
获取表的全部内容

00:16:38.016 --> 00:16:39.816 A:middle
并尝试在特定的

00:16:39.816 --> 00:16:41.586 A:middle
轨道中绘制它

00:16:42.276 --> 00:16:44.406 A:middle
plot 元素

00:16:44.436 --> 00:16:46.536 A:middle
通过查看

00:16:46.536 --> 00:16:49.406 A:middle
Schema 和获取值的目标列

00:16:49.406 --> 00:16:52.446 A:middle
来决定如何绘制这个内容

00:16:52.446 --> 00:16:53.306 A:middle
以及如何处理图形

00:16:54.026 --> 00:16:55.586 A:middle
如果是一个区间 Schema

00:16:55.586 --> 00:16:56.856 A:middle
这意味着它有一个时间点

00:16:56.856 --> 00:16:58.286 A:middle
和一个持续时间

00:16:58.286 --> 00:16:59.636 A:middle
如果是一个点 Schema

00:16:59.636 --> 00:17:01.046 A:middle
这意味着它只是一个时间戳

00:16:59.636 --> 00:17:01.046 A:middle
这意味着它只是一个时间戳

00:17:01.046 --> 00:17:01.816 A:middle
我们需要用不同的方式处理

00:17:02.586 --> 00:17:04.705 A:middle
如果目标列有一个长度

00:17:04.705 --> 00:17:06.945 A:middle
这意味着可以

00:17:06.945 --> 00:17:08.296 A:middle
通过它画一个条形图

00:17:08.296 --> 00:17:10.396 A:middle
就像这样

00:17:11.126 --> 00:17:13.136 A:middle
另一种选择是

00:17:13.136 --> 00:17:15.476 A:middle
生命周期轨道

00:17:15.476 --> 00:17:16.935 A:middle
它仍然是一个区间 Schema

00:17:16.935 --> 00:17:18.756 A:middle
但是我们针对的是

00:17:18.756 --> 00:17:20.366 A:middle
一个状态列

00:17:20.366 --> 00:17:21.955 A:middle
而状态本身并没有长度

00:17:22.185 --> 00:17:23.126 A:middle
所以在这里画条形图

00:17:23.126 --> 00:17:23.896 A:middle
是没有意义的

00:17:24.516 --> 00:17:25.476 A:middle
标准 UI 会自动选择

00:17:25.476 --> 00:17:27.006 A:middle
状态风格的处理方法

00:17:27.006 --> 00:17:28.976 A:middle
包括用圆角矩形样式的标签

00:17:28.976 --> 00:17:31.626 A:middle
绘制这些区间

00:17:31.626 --> 00:17:33.096 A:middle
这样你就可以

00:17:33.096 --> 00:17:35.656 A:middle
把它与平面条形图区分开来

00:17:36.356 --> 00:17:37.296 A:middle
标准 UI 能够为你选择

00:17:37.296 --> 00:17:38.336 A:middle
这些处理的功能

00:17:38.336 --> 00:17:39.796 A:middle
是非常重要的

00:17:39.796 --> 00:17:42.086 A:middle
因为这可以保持 Instruments UI 的一致性

00:17:42.376 --> 00:17:43.616 A:middle
如果你定义一个状态图的同时

00:17:43.616 --> 00:17:45.356 A:middle
我们也定义一个状态图

00:17:45.356 --> 00:17:46.896 A:middle
标准 UI 就会强制它们

00:17:46.896 --> 00:17:48.046 A:middle
看起来一样

00:17:48.296 --> 00:17:49.686 A:middle
这样 Instruments 用户就可以

00:17:49.686 --> 00:17:51.526 A:middle
更容易在 Instrument 之间

00:17:51.526 --> 00:17:54.496 A:middle
进行切换

00:17:54.496 --> 00:17:58.236 A:middle
如果你想 基于数据的内容

00:17:58.236 --> 00:18:01.866 A:middle
动态地创建图形或轨道数目

00:17:58.236 --> 00:18:01.866 A:middle
动态地创建图形或轨道数目

00:18:01.986 --> 00:18:02.326 A:middle
你可以定义所谓的 “Plot Template”

00:18:02.996 --> 00:18:04.666 A:middle
Plot 模板的定义

00:18:04.666 --> 00:18:06.316 A:middle
与 Plot 非常类似

00:18:06.316 --> 00:18:07.406 A:middle
除了其中有一个额外的元素

00:18:07.406 --> 00:18:08.936 A:middle
允许你选择

00:18:08.936 --> 00:18:10.536 A:middle
表中的一列

00:18:10.536 --> 00:18:12.276 A:middle
它将为该列中的每个唯一值

00:18:12.276 --> 00:18:13.956 A:middle
创建单独的行

00:18:16.016 --> 00:18:17.046 A:middle
如果你正在寻找

00:18:17.046 --> 00:18:18.456 A:middle
活动的峰值或周期

00:18:18.576 --> 00:18:19.126 A:middle
我们有所谓的直方图

00:18:19.126 --> 00:18:21.016 A:middle
你所要做的就是

00:18:21.016 --> 00:18:22.846 A:middle
在不同的点

00:18:22.846 --> 00:18:24.066 A:middle
或区间相交时

00:18:24.066 --> 00:18:25.566 A:middle
打破超过某个特定大小的

00:18:25.566 --> 00:18:27.176 A:middle
存储器中的时间轴

00:18:27.176 --> 00:18:29.996 A:middle
假设 100 毫秒

00:18:29.996 --> 00:18:31.186 A:middle
然后使用像 count() sum()

00:18:31.416 --> 00:18:32.976 A:middle
min() 或 max() 这样的函数

00:18:32.976 --> 00:18:33.946 A:middle
来提升这些存储器的大小

00:18:33.946 --> 00:18:36.066 A:middle
这是一种寻找活动峰值的好方法

00:18:36.536 --> 00:18:38.136 A:middle
例如 在系统跟踪中

00:18:38.136 --> 00:18:39.046 A:middle
我们在环境切换

00:18:39.046 --> 00:18:40.216 A:middle
或虚拟内存中

00:18:40.216 --> 00:18:42.086 A:middle
寻找活动峰值

00:18:42.486 --> 00:18:45.126 A:middle
现在我们来谈谈细节

00:18:45.156 --> 00:18:47.396 A:middle
细节在这个 UI 的下半部分

00:18:48.486 --> 00:18:49.376 A:middle
你们已经看过了第一个

00:18:49.376 --> 00:18:50.626 A:middle
也就是列表

00:18:50.846 --> 00:18:52.266 A:middle
它是表格 分析核心

00:18:52.266 --> 00:18:53.666 A:middle
以及 UI 中表视图之间的

00:18:53.666 --> 00:18:56.896 A:middle
非常简单的映射

00:18:56.896 --> 00:19:00.066 A:middle
还有 “Aggregation（聚合）”

00:18:56.896 --> 00:19:00.066 A:middle
还有 “Aggregation（聚合）”

00:19:00.176 --> 00:19:01.976 A:middle
当你想要

00:19:01.976 --> 00:19:03.186 A:middle
去除时间分量

00:19:03.186 --> 00:19:04.586 A:middle
概览你的数据

00:19:04.586 --> 00:19:06.726 A:middle
而且想要在表格中应用一些

00:19:06.726 --> 00:19:07.956 A:middle
统计数据的时候

00:19:07.956 --> 00:19:08.556 A:middle
聚合是很适合的选择

00:19:09.376 --> 00:19:10.406 A:middle
当我们定义一个聚合

00:19:10.406 --> 00:19:12.316 A:middle
我们需要注意

00:19:12.316 --> 00:19:14.596 A:middle
列现在是函数

00:19:14.896 --> 00:19:15.956 A:middle
你可以使用

00:19:16.026 --> 00:19:19.186 A:middle
sum() average() count()

00:19:19.186 --> 00:19:20.436 A:middle
以及其他的一些统计函数

00:19:20.726 --> 00:19:24.396 A:middle
来帮助你创建

00:19:24.396 --> 00:19:26.256 A:middle
你想要创建的聚合视图

00:19:28.146 --> 00:19:30.776 A:middle
聚合的好处在于 你也可以定义

00:19:30.776 --> 00:19:32.096 A:middle
一个层级结构

00:19:32.266 --> 00:19:33.846 A:middle
这里我们在

00:19:33.926 --> 00:19:35.296 A:middle
虚拟内存操作结构中

00:19:35.296 --> 00:19:37.316 A:middle
定义了一个进程线程

00:19:37.316 --> 00:19:38.976 A:middle
我们可以看到它被分解为

00:19:38.976 --> 00:19:40.626 A:middle
进程 然后是

00:19:40.626 --> 00:19:41.766 A:middle
进程中的每个线程

00:19:42.086 --> 00:19:43.286 A:middle
然后是这个线程中的

00:19:43.286 --> 00:19:45.156 A:middle
这个进程中的

00:19:45.246 --> 00:19:46.036 A:middle
每个类型的操作

00:19:46.206 --> 00:19:47.556 A:middle
所以聚合是一种很好

00:19:47.626 --> 00:19:49.156 A:middle
很强大的方式

00:19:49.156 --> 00:19:50.386 A:middle
来总结很多数据

00:19:51.476 --> 00:19:53.396 A:middle
另一种类型的聚合

00:19:53.396 --> 00:19:54.476 A:middle
称为 “Call Tree（调用树）”

00:19:55.496 --> 00:19:56.696 A:middle
当你有一个列是回溯

00:19:56.696 --> 00:19:57.876 A:middle
而且另一个列是

00:19:57.876 --> 00:19:59.466 A:middle
权重的时候

00:19:59.466 --> 00:20:00.246 A:middle
调用树就会很有用处

00:19:59.466 --> 00:20:00.246 A:middle
调用树就会很有用处

00:20:00.476 --> 00:20:01.316 A:middle
你可以使用调用树

00:20:01.316 --> 00:20:02.556 A:middle
创建加权回溯

00:20:02.556 --> 00:20:04.546 A:middle
或加权调用的树视图

00:20:04.616 --> 00:20:05.976 A:middle
就像在时间分析器中看到的那样

00:20:07.136 --> 00:20:09.896 A:middle
另一种样式叫做 “Narrative（叙事）”

00:20:10.096 --> 00:20:12.426 A:middle
当你想要传达

00:20:12.426 --> 00:20:15.506 A:middle
只有技术语言的信息

00:20:15.506 --> 00:20:17.046 A:middle
比如专家系统的输出

00:20:17.046 --> 00:20:18.526 A:middle
以及和叙事工程类型

00:20:18.526 --> 00:20:19.696 A:middle
紧密相连的信息时

00:20:19.696 --> 00:20:21.346 A:middle
叙事是常用的选择

00:20:23.856 --> 00:20:25.776 A:middle
最后一种细节类型

00:20:25.866 --> 00:20:26.956 A:middle
叫做 “Time Slice（时间片）”

00:20:27.086 --> 00:20:28.346 A:middle
时间片看起来

00:20:28.346 --> 00:20:30.176 A:middle
很像一个列表

00:20:30.176 --> 00:20:31.866 A:middle
但是其中的内容被过滤

00:20:31.866 --> 00:20:33.506 A:middle
只包含与图形中蓝色线

00:20:33.506 --> 00:20:35.086 A:middle
相交的区间

00:20:35.236 --> 00:20:36.366 A:middle
这条蓝色线叫做检查线

00:20:36.746 --> 00:20:37.866 A:middle
当你把检查线

00:20:37.866 --> 00:20:39.436 A:middle
移到图形上时

00:20:39.656 --> 00:20:40.756 A:middle
列表的内容将被过滤

00:20:40.756 --> 00:20:42.586 A:middle
从而与检查线

00:20:42.586 --> 00:20:44.226 A:middle
相交的部分匹配

00:20:46.776 --> 00:20:49.156 A:middle
所有这些 UI 都与

00:20:49.156 --> 00:20:50.896 A:middle
分析核心中的表格绑定

00:20:51.306 --> 00:20:53.146 A:middle
当你开始记录时

00:20:53.146 --> 00:20:55.586 A:middle
数据进入 Instruments App

00:20:55.586 --> 00:20:57.176 A:middle
并填入分析核心中

00:20:57.936 --> 00:20:59.396 A:middle
让我们详细谈谈

00:20:59.396 --> 00:21:00.976 A:middle
这个过程是如何进行的

00:20:59.396 --> 00:21:00.976 A:middle
这个过程是如何进行的

00:21:02.786 --> 00:21:06.996 A:middle
在开始记录之前的第一步

00:21:06.996 --> 00:21:08.416 A:middle
分析核心将提取

00:21:08.416 --> 00:21:09.796 A:middle
在其中创建的表格

00:21:09.796 --> 00:21:11.006 A:middle
它将映射表格

00:21:11.006 --> 00:21:12.916 A:middle
并在核心中为表分配存储

00:21:13.756 --> 00:21:15.236 A:middle
如果一个表有

00:21:15.236 --> 00:21:16.516 A:middle
相同的 Schema 和相同的属性

00:21:16.516 --> 00:21:17.796 A:middle
那么根据定义

00:21:17.796 --> 00:21:19.686 A:middle
它就是相同的数据

00:21:19.686 --> 00:21:21.696 A:middle
所以它会被映射到相同的存储中

00:21:23.116 --> 00:21:24.956 A:middle
对于每个存储

00:21:24.956 --> 00:21:26.406 A:middle
第二步就是尝试为数据

00:21:26.406 --> 00:21:27.386 A:middle
找到一个提供者

00:21:27.776 --> 00:21:29.056 A:middle
有时 我们可以从

00:21:29.056 --> 00:21:30.196 A:middle
从 Target 中通过数据流

00:21:30.196 --> 00:21:32.196 A:middle
直接记录数据

00:21:32.196 --> 00:21:33.346 A:middle
有时 我们则必须使用

00:21:33.486 --> 00:21:34.246 A:middle
建模器来合成数据

00:21:35.296 --> 00:21:36.876 A:middle
建模器可以请求自己的输入

00:21:36.876 --> 00:21:38.556 A:middle
这些输入可以

00:21:38.556 --> 00:21:40.356 A:middle
是其他建模器的输出

00:21:40.396 --> 00:21:42.926 A:middle
或者直接从数据流中记录

00:21:42.926 --> 00:21:44.186 A:middle
我们就是这样合成

00:21:44.186 --> 00:21:45.476 A:middle
我们本来不知道如何直接记录的

00:21:45.476 --> 00:21:46.366 A:middle
其余数据的

00:21:47.476 --> 00:21:49.516 A:middle
现在我们已经得到了

00:21:49.516 --> 00:21:51.546 A:middle
分析核心中

00:21:51.686 --> 00:21:53.786 A:middle
所有存储的数据源

00:21:53.786 --> 00:21:54.866 A:middle
也就是所谓的绑定方案

00:21:55.026 --> 00:21:57.356 A:middle
第三步是优化绑定方案

00:21:57.546 --> 00:21:59.966 A:middle
在这里 你可以看到 Instruments 将自己的

00:21:59.966 --> 00:22:01.546 A:middle
绑定方案可视化

00:21:59.966 --> 00:22:01.546 A:middle
绑定方案可视化

00:22:01.546 --> 00:22:02.216 A:middle
我们称之为线程叙事

00:22:03.706 --> 00:22:04.736 A:middle
关于绑定方案的

00:22:04.736 --> 00:22:06.886 A:middle
下一部分是

00:22:06.886 --> 00:22:09.056 A:middle
它是 “Trace-wide（广跟踪）”的

00:22:09.056 --> 00:22:11.196 A:middle
当你将 Instrument 拖放到跟踪中时

00:22:11.386 --> 00:22:13.906 A:middle
Instruments 将计算

00:22:13.906 --> 00:22:15.956 A:middle
尽可能最好的记录方案

00:22:16.166 --> 00:22:17.616 A:middle
以尽量减少

00:22:17.616 --> 00:22:20.336 A:middle
对 Target 的记录影响

00:22:20.886 --> 00:22:21.786 A:middle
当你创建自己的表格

00:22:21.786 --> 00:22:23.256 A:middle
或表实例时

00:22:23.256 --> 00:22:24.616 A:middle
你必须给它们一个 Schema

00:22:25.256 --> 00:22:26.706 A:middle
Instruments 已经定义了

00:22:26.766 --> 00:22:28.786 A:middle
超过 100 种 Schema

00:22:29.536 --> 00:22:30.896 A:middle
所有这些 Schema

00:22:30.896 --> 00:22:31.956 A:middle
都可以使用

00:22:31.956 --> 00:22:33.896 A:middle
并存在于在包管理的 UI 中

00:22:33.896 --> 00:22:34.506 A:middle
所看到的包里面

00:22:35.236 --> 00:22:36.376 A:middle
你只需将 Schema 导入到

00:22:36.376 --> 00:22:38.466 A:middle
自己的包中

00:22:39.036 --> 00:22:41.216 A:middle
如果该 Schema 包含在

00:22:41.216 --> 00:22:42.516 A:middle
一个不是基础包的包中

00:22:42.516 --> 00:22:44.246 A:middle
你需要在 Xcode 中的

00:22:44.246 --> 00:22:45.756 A:middle
构建设置里面

00:22:45.756 --> 00:22:47.086 A:middle
将包设置为

00:22:47.086 --> 00:22:49.046 A:middle
“Linked Instruments Packages”

00:22:49.046 --> 00:22:50.116 A:middle
这样我们就可以在生成时

00:22:50.116 --> 00:22:51.526 A:middle
找到你涉及的额外的包

00:22:51.526 --> 00:22:53.096 A:middle
并做一些类型检查

00:22:54.716 --> 00:22:56.276 A:middle
因为所有这些 Schema

00:22:56.276 --> 00:22:57.586 A:middle
都是在其他包中定义的

00:22:57.676 --> 00:22:59.346 A:middle
当你开始记录时

00:22:59.386 --> 00:23:00.456 A:middle
所有具有这些 Schema 的表格

00:22:59.386 --> 00:23:00.456 A:middle
所有具有这些 Schema 的表格

00:23:00.456 --> 00:23:02.736 A:middle
都会被填充

00:23:02.736 --> 00:23:04.026 A:middle
因为要么它们定义了建模器

00:23:04.026 --> 00:23:04.866 A:middle
要么我们知道如何

00:23:04.866 --> 00:23:05.176 A:middle
从数据流中记录它们

00:23:05.176 --> 00:23:06.426 A:middle
这些都是你的 Instrument 的

00:23:06.426 --> 00:23:07.766 A:middle
出色的构件

00:23:08.216 --> 00:23:09.016 A:middle
但它们更是

00:23:09.086 --> 00:23:10.856 A:middle
编写建模器的

00:23:10.856 --> 00:23:11.706 A:middle
优秀输入

00:23:12.576 --> 00:23:14.356 A:middle
现在你已经可以编写一个建模器

00:23:14.356 --> 00:23:15.316 A:middle
或者在你的 Instrument 包中

00:23:15.316 --> 00:23:16.896 A:middle
用 modeler 元素

00:23:16.896 --> 00:23:19.046 A:middle
定义一个建模器

00:23:19.046 --> 00:23:22.236 A:middle
你还可以为该建模器

00:23:22.346 --> 00:23:23.676 A:middle
创建一个自定义输出 Schema

00:23:24.066 --> 00:23:25.616 A:middle
你可以只对一个时间点

00:23:25.616 --> 00:23:27.336 A:middle
使用 point-schema

00:23:27.336 --> 00:23:28.416 A:middle
或者如果你有一个时间点和一个区间

00:23:28.416 --> 00:23:29.726 A:middle
你可以使用 interval-schema

00:23:30.386 --> 00:23:33.216 A:middle
建模器可以定义

00:23:33.216 --> 00:23:35.126 A:middle
它需要的输入

00:23:35.126 --> 00:23:36.266 A:middle
这就告诉了绑定方案

00:23:36.266 --> 00:23:37.906 A:middle
如何填充

00:23:37.906 --> 00:23:39.706 A:middle
数据流图的其余部分

00:23:39.706 --> 00:23:41.976 A:middle
这样你的建模器

00:23:41.976 --> 00:23:43.076 A:middle
将融合到绑定方案中

00:23:43.906 --> 00:23:45.756 A:middle
建模器实际上是

00:23:45.756 --> 00:23:47.576 A:middle
微型专家系统

00:23:47.576 --> 00:23:48.626 A:middle
它们是用 CLIPS 语言编写的

00:23:48.626 --> 00:23:50.136 A:middle
这意味着

00:23:50.136 --> 00:23:52.006 A:middle
它们非常强大

00:23:52.006 --> 00:23:53.206 A:middle
同时非常先进

00:23:53.206 --> 00:23:54.346 A:middle
关于如何创建

00:23:54.346 --> 00:23:55.896 A:middle
建模器的细节

00:23:55.896 --> 00:23:57.106 A:middle
我们将留在进阶部分讨论

00:23:57.106 --> 00:24:01.336 A:middle
然而 能够定义自己的 Schema

00:23:57.106 --> 00:24:01.336 A:middle
然而 能够定义自己的 Schema

00:24:01.336 --> 00:24:02.856 A:middle
是非常重要的

00:24:02.856 --> 00:24:04.826 A:middle
我们今年有了一个新的 os_signpost API

00:24:04.826 --> 00:24:06.696 A:middle
它是把数据

00:24:06.696 --> 00:24:07.736 A:middle
导入 Instruments 的绝佳方式

00:24:08.596 --> 00:24:10.756 A:middle
我们为它创造了一条捷径

00:24:12.056 --> 00:24:14.246 A:middle
在你的包中 你可以定义所谓的

00:24:14.246 --> 00:24:16.346 A:middle
os-signpost-interval-schema

00:24:16.346 --> 00:24:17.616 A:middle
它既可以定义 Schema

00:24:17.616 --> 00:24:20.046 A:middle
也可以为我们提供足够的指令

00:24:20.046 --> 00:24:22.006 A:middle
以便能够代替你

00:24:22.106 --> 00:24:23.616 A:middle
生成一个建模器

00:24:24.226 --> 00:24:25.686 A:middle
在那里你可以

00:24:25.686 --> 00:24:26.776 A:middle
捕获在 os_signpost 调用的

00:24:26.776 --> 00:24:28.856 A:middle
元数据中

00:24:28.856 --> 00:24:31.926 A:middle
记录的数据

00:24:31.926 --> 00:24:33.986 A:middle
你可以使用捕获的元数据

00:24:33.986 --> 00:24:35.776 A:middle
和表达式来定义

00:24:35.776 --> 00:24:38.796 A:middle
如何填充你的 Schema 的列

00:24:39.816 --> 00:24:42.196 A:middle
我们来看一个非常简单的例子

00:24:43.136 --> 00:24:44.556 A:middle
假设我们要做 JSON 解码

00:24:44.556 --> 00:24:46.776 A:middle
我们有一个 os_signpost

00:24:47.026 --> 00:24:50.726 A:middle
标记了解码 Activity 的开始

00:24:50.726 --> 00:24:52.186 A:middle
和解码 Activity 的结束

00:24:52.746 --> 00:24:54.276 A:middle
在开始时

00:24:54.276 --> 00:24:55.936 A:middle
我们还需捕获一些元数据

00:24:55.936 --> 00:24:57.676 A:middle
以指示我们将要解析的

00:24:57.676 --> 00:24:59.526 A:middle
JSON 对象的大小

00:25:00.876 --> 00:25:01.956 A:middle
在你的 Instrument 包定义中

00:25:01.956 --> 00:25:03.496 A:middle
你可以创建一个

00:25:03.496 --> 00:25:06.136 A:middle
os-signpost-interval-schema

00:25:06.136 --> 00:25:08.396 A:middle
并在这里定义你的 Schema 名称

00:25:09.236 --> 00:25:11.656 A:middle
你可以选择

00:25:11.656 --> 00:25:12.726 A:middle
要记录的 signpost

00:25:12.786 --> 00:25:14.626 A:middle
包括 signpost 名称

00:25:15.086 --> 00:25:16.806 A:middle
然后在这里可以使用语法

00:25:16.806 --> 00:25:18.456 A:middle
从起始元数据消息中

00:25:18.456 --> 00:25:20.186 A:middle
捕获不同的

00:25:20.186 --> 00:25:21.586 A:middle
元数据片段

00:25:21.656 --> 00:25:22.986 A:middle
这里 我们将使用

00:25:23.016 --> 00:25:24.526 A:middle
这个捕获的值

00:25:24.526 --> 00:25:25.296 A:middle
我们将用它作为表达式

00:25:25.296 --> 00:25:27.016 A:middle
来教我们如何

00:25:27.016 --> 00:25:28.956 A:middle
填充我们刚才定义的

00:25:28.956 --> 00:25:30.256 A:middle
数据大小的列

00:25:32.646 --> 00:25:35.756 A:middle
在 405 号讨论会中 即

00:25:35.756 --> 00:25:37.686 A:middle
“Measuring Performance Using Logging”

00:25:37.686 --> 00:25:42.906 A:middle
我演示了《Trailblazer》App

00:25:43.216 --> 00:25:44.616 A:middle
还展示了一个 Instrument

00:25:44.616 --> 00:25:46.056 A:middle
你们可以根据这个 Instrument

00:25:46.196 --> 00:25:47.366 A:middle
里面的 signpost 来进行编写

00:25:47.956 --> 00:25:49.716 A:middle
现在我们对如何编写

00:25:49.716 --> 00:25:50.696 A:middle
自定义 Instrument

00:25:50.696 --> 00:25:52.406 A:middle
有了更多的了解

00:25:52.656 --> 00:25:54.696 A:middle
我想邀请 Kacper 回到台上

00:25:54.696 --> 00:25:56.136 A:middle
来给大家演示一下

00:25:56.386 --> 00:25:57.626 A:middle
我们是如何创建这个包的

00:25:58.516 --> 00:26:03.126 A:middle
[ 掌声 ]

00:25:58.516 --> 00:26:03.126 A:middle
[ 掌声 ]

00:26:03.626 --> 00:26:04.886 A:middle
&gt;&gt; 谢谢你 Chad

00:26:09.836 --> 00:26:12.576 A:middle
《Trailblazer》 App 是一款 iOS App

00:26:12.706 --> 00:26:14.676 A:middle
它可以显示你附近

00:26:14.796 --> 00:26:16.176 A:middle
流行的徒步旅行路线

00:26:16.856 --> 00:26:19.976 A:middle
作为 UI 组件 它使用了 UITabelView

00:26:21.006 --> 00:26:22.766 A:middle
每个单元异步加载

00:26:22.766 --> 00:26:24.156 A:middle
路线的图像

00:26:25.276 --> 00:26:26.936 A:middle
为了防止出现故障且作为优化

00:26:26.936 --> 00:26:28.876 A:middle
当单元被重复使用时

00:26:28.876 --> 00:26:30.376 A:middle
我们取消了下载

00:26:31.556 --> 00:26:33.276 A:middle
为了可视化我的下载流

00:26:33.276 --> 00:26:35.546 A:middle
我将每个下载都置入到

00:26:35.586 --> 00:26:36.356 A:middle
os_signpost 调用中

00:26:36.356 --> 00:26:36.936 A:middle
让我们看一下

00:26:41.536 --> 00:26:42.556 A:middle
当我的保存的单元显示时

00:26:42.556 --> 00:26:45.556 A:middle
调用 startImageDownload() 方法

00:26:46.046 --> 00:26:48.456 A:middle
我们创建了 downloader 和 signpost ID

00:26:48.456 --> 00:26:50.946 A:middle
它包含了 os 日志句柄

00:26:51.026 --> 00:26:52.466 A:middle
和 downloader 对象

00:26:53.306 --> 00:26:55.516 A:middle
然后我们获取 UI 表格视图

00:26:55.516 --> 00:26:59.366 A:middle
单元的地址

00:26:59.366 --> 00:27:03.016 A:middle
并调用 os_signpost(.begin)

00:26:59.366 --> 00:27:03.016 A:middle
并调用 os_signpost(.begin)

00:27:03.016 --> 00:27:04.676 A:middle
它自于 signpostlog.networking

00:27:04.946 --> 00:27:07.336 A:middle
让我们看一下

00:27:07.336 --> 00:27:08.916 A:middle
这个日志以 App 的

00:27:08.916 --> 00:27:11.076 A:middle
标识符为子系统

00:27:11.106 --> 00:27:12.296 A:middle
networking 为类别

00:27:15.046 --> 00:27:16.506 A:middle
我们传入 “Background Image” 这个名称

00:27:17.286 --> 00:27:18.996 A:middle
之前创建的 “signpostID”

00:27:19.436 --> 00:27:20.886 A:middle
以及信息格式

00:27:20.886 --> 00:27:22.016 A:middle
其中包含 “Image name”

00:27:23.956 --> 00:27:25.276 A:middle
在这里 我们将它放置在全局说明符中

00:27:25.276 --> 00:27:27.406 A:middle
因为它是一个字符串

00:27:28.286 --> 00:27:30.406 A:middle
还有 “Caller” 它是一个单元的地址

00:27:31.816 --> 00:27:33.916 A:middle
我们的下载可以

00:27:33.956 --> 00:27:35.476 A:middle
通过两种方法完成

00:27:36.106 --> 00:27:39.086 A:middle
我们现在来看看

00:27:39.166 --> 00:27:40.236 A:middle
当下载以这样的方式完成

00:27:40.756 --> 00:27:42.816 A:middle
就会调用委托方法

00:27:43.866 --> 00:27:45.636 A:middle
我们像之前一样创建 signpostID

00:27:45.636 --> 00:27:48.496 A:middle
并调用 os_signpost(.end)

00:27:49.546 --> 00:27:52.556 A:middle
这次我们传入 “Status” 和 “Size”

00:27:53.876 --> 00:27:56.956 A:middle
“Status” 值是 “Completed”

00:27:58.256 --> 00:28:01.786 A:middle
“Size” 设置为图像大小

00:27:58.256 --> 00:28:01.786 A:middle
“Size” 设置为图像大小

00:28:02.236 --> 00:28:04.456 A:middle
接下来让我们看一下

00:28:04.456 --> 00:28:06.166 A:middle
我们为重写所做的准备

00:28:06.766 --> 00:28:09.546 A:middle
当 downloader 正在运行时

00:28:09.546 --> 00:28:11.116 A:middle
我们会取消它

00:28:12.126 --> 00:28:14.076 A:middle
我们创建了 signpostID

00:28:14.076 --> 00:28:16.006 A:middle
并使用相同的格式字符串

00:28:16.006 --> 00:28:18.016 A:middle
调用我们的 os_signpost(.end)

00:28:18.016 --> 00:28:20.496 A:middle
但是这里 值是 “Canceled” 并且 “Size”

00:28:20.496 --> 00:28:21.896 A:middle
为 “0” 因为下载没有成功

00:28:22.406 --> 00:28:25.446 A:middle
让我们来看看

00:28:25.446 --> 00:28:26.786 A:middle
我们的 os-signpost-interval-schema 定义

00:28:26.786 --> 00:28:28.326 A:middle
以及我们如何在包中

00:28:28.376 --> 00:28:30.386 A:middle
捕获这些 signpost

00:28:32.456 --> 00:28:34.456 A:middle
我们定义了具有唯一 id 和 title 的

00:28:34.456 --> 00:28:36.936 A:middle
os-signpost-interval-schema

00:28:37.686 --> 00:28:40.306 A:middle
然后我们定义 subsystem 和 category

00:28:40.306 --> 00:28:41.856 A:middle
它与我们在创建

00:28:41.856 --> 00:28:43.326 A:middle
日志句柄时

00:28:43.326 --> 00:28:44.596 A:middle
传递的 category 相对应

00:28:46.816 --> 00:28:49.346 A:middle
我们创建 name 元素

00:28:49.346 --> 00:28:50.846 A:middle
它与我们在 os_signpost

00:28:50.846 --> 00:28:53.646 A:middle
调用 start-pattern 和 end-pattern 中

00:28:54.016 --> 00:28:56.156 A:middle
传递的 name 相对应

00:28:56.736 --> 00:28:58.496 A:middle
这两个都对应于

00:28:58.656 --> 00:29:00.296 A:middle
我们在 os_signpost 中传入的

00:28:58.656 --> 00:29:00.296 A:middle
我们在 os_signpost 中传入的

00:29:00.296 --> 00:29:01.756 A:middle
开始和结束调用

00:29:04.266 --> 00:29:05.966 A:middle
message 元素与

00:29:05.966 --> 00:29:07.596 A:middle
传递的格式字符串相同

00:29:07.596 --> 00:29:10.326 A:middle
但是在调用 os_signpost 时

00:29:10.326 --> 00:29:12.516 A:middle
为了捕获传入的值

00:29:12.516 --> 00:29:14.406 A:middle
你传递的将是这里的变量

00:29:14.406 --> 00:29:15.556 A:middle
而不是格式化参数

00:29:16.066 --> 00:29:18.786 A:middle
让我们看看如何

00:29:18.786 --> 00:29:20.576 A:middle
在列中填入这些值

00:29:23.926 --> 00:29:26.876 A:middle
在这里 你可以看到 status 列

00:29:27.066 --> 00:29:28.566 A:middle
它是字符串类型

00:29:28.566 --> 00:29:30.246 A:middle
因为它只可能是 “Completed” 或者 “Canceled”

00:29:31.486 --> 00:29:32.756 A:middle
所以我们用状态变量的值

00:29:32.756 --> 00:29:34.956 A:middle
来填充它

00:29:36.676 --> 00:29:38.806 A:middle
因为 expression 元素可以采用

00:29:38.926 --> 00:29:40.826 A:middle
任意的 CLIPS 表达式

00:29:41.706 --> 00:29:42.586 A:middle
所以我们可以在其中

00:29:42.586 --> 00:29:44.156 A:middle
做更复杂的事情

00:29:44.816 --> 00:29:47.056 A:middle
在这里我们可以通过查看图像大小

00:29:47.056 --> 00:29:49.006 A:middle
来计算事件影响

00:29:49.846 --> 00:29:51.536 A:middle
如果它大于 3.5MB

00:29:51.536 --> 00:29:53.326 A:middle
我们可以判定影响很大

00:29:53.416 --> 00:29:56.516 A:middle
否则操作的影响很小

00:29:58.076 --> 00:30:00.236 A:middle
这就是我们对 os-signpost-interval-schema

00:29:58.076 --> 00:30:00.236 A:middle
这就是我们对 os-signpost-interval-schema

00:30:00.236 --> 00:30:00.976 A:middle
所做的定义

00:30:01.106 --> 00:30:04.066 A:middle
现在让我们来看看表格的创建

00:30:05.796 --> 00:30:07.696 A:middle
对于 schema-ref

00:30:08.096 --> 00:30:10.456 A:middle
我们传入 os-signpost-interval-schema

00:30:10.456 --> 00:30:12.616 A:middle
的标识符

00:30:12.616 --> 00:30:13.846 A:middle
并为这个特定表格

00:30:13.846 --> 00:30:14.686 A:middle
创建唯一标识符

00:30:15.906 --> 00:30:17.736 A:middle
然后 我们可以在

00:30:17.736 --> 00:30:18.876 A:middle
UI 定义中引用它

00:30:20.296 --> 00:30:22.676 A:middle
对于 graph 我们创建一个单轨道

00:30:23.796 --> 00:30:26.036 A:middle
它利用我们的表

00:30:26.036 --> 00:30:28.056 A:middle
这次它通过使用 Plot 模板来绘制图形

00:30:28.796 --> 00:30:30.586 A:middle
Plot 模板

00:30:30.586 --> 00:30:31.476 A:middle
是创建图形的动态方法

00:30:32.146 --> 00:30:37.386 A:middle
它查看在实例中

00:30:37.386 --> 00:30:40.126 A:middle
按元素传递的列

00:30:40.226 --> 00:30:44.436 A:middle
并为该列的每个唯一值创建 Plot

00:30:44.606 --> 00:30:46.436 A:middle
label-format 元素

00:30:46.486 --> 00:30:49.966 A:middle
允许我们为这个 Plot 创建格式标题

00:30:50.336 --> 00:30:53.956 A:middle
这里是 img 列和 image-name 列中的值

00:30:54.516 --> 00:30:57.166 A:middle
我们传入 image-name

00:30:57.166 --> 00:30:57.656 A:middle
作为我们的 Plot 的值

00:30:58.766 --> 00:31:00.156 A:middle
我们的每个轨道

00:30:58.766 --> 00:31:00.156 A:middle
我们的每个轨道

00:31:00.206 --> 00:31:03.166 A:middle
都会以 impact 列上色

00:31:03.326 --> 00:31:06.076 A:middle
我们轨道上的标签

00:31:06.076 --> 00:31:06.976 A:middle
会从 image-size 中提取出来

00:31:09.436 --> 00:31:12.796 A:middle
接下来 我们看看 list

00:31:12.796 --> 00:31:14.726 A:middle
你已经在 Ticks 的例子中

00:31:14.756 --> 00:31:15.526 A:middle
见过它

00:31:16.866 --> 00:31:18.176 A:middle
这里 我们将传入

00:31:18.176 --> 00:31:21.286 A:middle
你希望看到的所有列

00:31:21.536 --> 00:31:22.766 A:middle
接下来是 aggregation

00:31:23.726 --> 00:31:25.266 A:middle
这个 aggregation 将跟踪

00:31:25.266 --> 00:31:26.406 A:middle
所有已完成的下载

00:31:27.236 --> 00:31:29.836 A:middle
因为我们的表

00:31:29.836 --> 00:31:31.146 A:middle
包含已完成和已取消的下载

00:31:31.146 --> 00:31:32.406 A:middle
所以我们需要应用

00:31:32.406 --> 00:31:34.836 A:middle
slice 元素来过滤一些数据

00:31:36.016 --> 00:31:37.866 A:middle
在 slice 元素中

00:31:37.866 --> 00:31:39.456 A:middle
我们可以指定

00:31:39.456 --> 00:31:42.066 A:middle
应用于 slice 的列

00:31:42.596 --> 00:31:43.496 A:middle
以及需要匹配的谓词值

00:31:43.926 --> 00:31:45.546 A:middle
在这里 我们只想从这个表中

00:31:45.546 --> 00:31:47.056 A:middle
取出 “Completed” 的行

00:31:48.306 --> 00:31:50.746 A:middle
我们定义了 hierarchy

00:31:50.746 --> 00:31:52.406 A:middle
它是只有一个层级的结构

00:31:52.486 --> 00:31:55.276 A:middle
具有 image-name

00:31:55.276 --> 00:31:55.836 A:middle
和可见的列

00:31:56.676 --> 00:31:58.786 A:middle
对于每个 image-name

00:31:58.786 --> 00:32:02.156 A:middle
我们将指定 count 和 image-size

00:31:58.786 --> 00:32:02.156 A:middle
我们将指定 count 和 image-size

00:32:02.156 --> 00:32:04.916 A:middle
所以我们要将图像的大小求和

00:32:05.386 --> 00:32:09.426 A:middle
接下来我们有 time-slice

00:32:10.456 --> 00:32:10.746 A:middle
抱歉

00:32:10.746 --> 00:32:12.186 A:middle
我们指定所有

00:32:12.186 --> 00:32:13.046 A:middle
将会可见的列

00:32:16.096 --> 00:32:18.636 A:middle
为了更容易地使用我们的 Instrument

00:32:18.636 --> 00:32:22.796 A:middle
我们可以指定我们的

00:32:22.796 --> 00:32:23.566 A:middle
自定义模板

00:32:24.126 --> 00:32:26.876 A:middle
我们现在尝试构建和运行

00:32:26.986 --> 00:32:27.306 A:middle
我们的包

00:32:34.416 --> 00:32:36.336 A:middle
你可以看到这里的模板

00:32:36.396 --> 00:32:36.976 A:middle
我可以选中它

00:32:41.536 --> 00:32:43.916 A:middle
Target 是我的 iPhone

00:32:43.916 --> 00:32:45.186 A:middle
和《Trailblazer》App

00:32:48.956 --> 00:32:50.976 A:middle
我需要记录一会

00:33:00.716 --> 00:33:03.786 A:middle
可以看到

00:33:03.786 --> 00:33:04.936 A:middle
跟踪视图是以数据传递的

00:33:06.616 --> 00:33:08.746 A:middle
每一个图像名称都创建了

00:33:08.746 --> 00:33:09.636 A:middle
一个绘图

00:33:11.366 --> 00:33:12.816 A:middle
你可以看到标签格式

00:33:12.816 --> 00:33:14.366 A:middle
与我们在包定义中

00:33:14.366 --> 00:33:15.586 A:middle
传入的格式相匹配

00:33:16.596 --> 00:33:19.056 A:middle
如果下载

00:33:19.056 --> 00:33:21.176 A:middle
高于 3.5 MB

00:33:21.176 --> 00:33:22.406 A:middle
那么我们的轨道将是红色的

00:33:23.596 --> 00:33:25.266 A:middle
具体的大小可以在轨道上查看

00:33:25.786 --> 00:33:28.576 A:middle
接下来我们看看

00:33:28.576 --> 00:33:30.286 A:middle
所有的细节

00:33:32.436 --> 00:33:35.146 A:middle
首先 我们看一下下载列表

00:33:36.066 --> 00:33:38.096 A:middle
这是刚才发生的

00:33:38.096 --> 00:33:38.976 A:middle
所有下载的列表

00:33:39.636 --> 00:33:42.346 A:middle
我们可以选择聚合

00:33:42.866 --> 00:33:46.746 A:middle
按照图像名称

00:33:46.746 --> 00:33:48.236 A:middle
划分所有下载

00:33:48.616 --> 00:33:49.926 A:middle
你可以在上面看到

00:33:49.926 --> 00:33:51.856 A:middle
我们下载了 12 张图像

00:33:52.156 --> 00:33:55.886 A:middle
“location7” 的图像

00:33:55.886 --> 00:33:59.436 A:middle
被下载了两次

00:33:59.616 --> 00:34:00.876 A:middle
接下来

00:33:59.616 --> 00:34:00.876 A:middle
接下来

00:34:00.876 --> 00:34:02.676 A:middle
我们可以查看活动请求

00:34:03.296 --> 00:34:05.166 A:middle
你可以在这里看到

00:34:05.166 --> 00:34:07.386 A:middle
当我拖动我的检查线时

00:34:09.356 --> 00:34:12.786 A:middle
细节视图中的数据发生了变化

00:34:13.646 --> 00:34:15.835 A:middle
我们可以跟踪

00:34:15.876 --> 00:34:17.505 A:middle
多个活动请求

00:34:17.505 --> 00:34:19.106 A:middle
并查看截至当前检查线为止的

00:34:19.106 --> 00:34:20.426 A:middle
持续时间

00:34:21.896 --> 00:34:23.976 A:middle
如果你想从不同的角度

00:34:23.976 --> 00:34:25.286 A:middle
查看你的数据

00:34:25.536 --> 00:34:28.226 A:middle
并想查看你的存储和建模器

00:34:28.226 --> 00:34:31.056 A:middle
我们通过 Instrument 检查器

00:34:31.056 --> 00:34:32.606 A:middle
为你提供了这个功能

00:34:33.576 --> 00:34:34.976 A:middle
它是调试自定义 Instrument 的

00:34:34.976 --> 00:34:36.076 A:middle
一种方法

00:34:36.716 --> 00:34:38.396 A:middle
在这里你可以看到

00:34:38.396 --> 00:34:41.646 A:middle
我选择了存储步骤

00:34:41.976 --> 00:34:43.876 A:middle
并看到创建 os-signpost 的存储

00:34:44.556 --> 00:34:46.916 A:middle
它属于网络类别

00:34:47.335 --> 00:34:48.956 A:middle
和 com.apple.trailblazer 子系统

00:34:48.956 --> 00:34:52.216 A:middle
我们在这里收集了 24 行

00:34:53.235 --> 00:34:55.376 A:middle
然后我们可以看到

00:34:55.466 --> 00:34:57.216 A:middle
创建的表格 image-download

00:34:57.366 --> 00:34:57.896 A:middle
它有 12 行

00:35:02.156 --> 00:35:04.326 A:middle
在底部的区域

00:35:04.326 --> 00:35:04.976 A:middle
你可以看到该表的整个内容

00:35:07.396 --> 00:35:09.146 A:middle
接下来 我们跳转到建模器

00:35:09.546 --> 00:35:10.706 A:middle
我们可以看到这里有

00:35:10.806 --> 00:35:12.936 A:middle
GENERATED-OS-LOG 建模器

00:35:13.456 --> 00:35:16.916 A:middle
它使用了 24 行 输出了 12 行

00:35:18.346 --> 00:35:20.756 A:middle
在右边 你可以看到绑定方案

00:35:21.546 --> 00:35:23.826 A:middle
所以我们的 GENERATED-OS-LOG 建模器

00:35:24.206 --> 00:35:26.026 A:middle
从 os-signpost 表格中获取数据

00:35:26.026 --> 00:35:28.216 A:middle
并将其放入图像下载表格中

00:35:29.386 --> 00:35:31.886 A:middle
然后被我们的 Instrument 使用

00:35:32.446 --> 00:35:35.766 A:middle
我们就是这样

00:35:35.766 --> 00:35:37.966 A:middle
捕获 os-signpost 调用

00:35:38.036 --> 00:35:40.366 A:middle
创建 UI 并使用 Instrument 检查器

00:35:40.366 --> 00:35:41.376 A:middle
查看数据

00:35:42.036 --> 00:35:43.866 A:middle
现在让我们请回 Chad

00:35:43.916 --> 00:35:44.846 A:middle
他会告诉你们更多

00:35:44.846 --> 00:35:45.836 A:middle
关于进阶建模的内容

00:35:46.516 --> 00:35:50.500 A:middle
[ 掌声 ]

00:35:54.716 --> 00:35:55.056 A:middle
&gt;&gt; 好的

00:35:55.326 --> 00:35:56.006 A:middle
谢谢 Kacper

00:35:57.646 --> 00:35:59.366 A:middle
现在我们已经了解了

00:35:59.366 --> 00:36:01.686 A:middle
如何将 os-signpost 数据

00:35:59.366 --> 00:36:01.686 A:middle
如何将 os-signpost 数据

00:36:01.746 --> 00:36:03.396 A:middle
与自定义 Instrument 结合起来

00:36:03.776 --> 00:36:10.106 A:middle
我们认为你们 能把这个结合做得很好

00:36:10.886 --> 00:36:13.846 A:middle
现在 我们可以讨论一些

00:36:13.846 --> 00:36:15.026 A:middle
进阶的内容

00:36:15.056 --> 00:36:16.546 A:middle
特别是如何创建

00:36:16.546 --> 00:36:18.286 A:middle
和定义建模器

00:36:19.366 --> 00:36:20.466 A:middle
建模器在概念上是

00:36:20.466 --> 00:36:21.296 A:middle
非常简单的机器

00:36:21.296 --> 00:36:23.156 A:middle
它需要一系列的输入

00:36:23.266 --> 00:36:24.256 A:middle
它对这些输入做出推理

00:36:24.256 --> 00:36:26.376 A:middle
然后进行输出

00:36:27.326 --> 00:36:28.506 A:middle
建模器的输入

00:36:28.506 --> 00:36:30.246 A:middle
是完全按照时间排序的

00:36:30.736 --> 00:36:32.116 A:middle
因此如果你请求

00:36:32.116 --> 00:36:33.506 A:middle
几个不同的输入表

00:36:33.506 --> 00:36:34.756 A:middle
这些表将首先按时间排序

00:36:34.756 --> 00:36:36.246 A:middle
然后合并到一个

00:36:36.246 --> 00:36:38.646 A:middle
按时间排序的队列中

00:36:38.646 --> 00:36:39.406 A:middle
该队列将提供工作内存

00:36:39.916 --> 00:36:41.356 A:middle
当我们把这些事件

00:36:41.356 --> 00:36:42.476 A:middle
一个接一个地取出时

00:36:42.536 --> 00:36:43.776 A:middle
它们被输入到所谓的

00:36:43.776 --> 00:36:44.356 A:middle
建模器的工作内存中

00:36:45.236 --> 00:36:47.886 A:middle
当建模器看到

00:36:47.886 --> 00:36:49.306 A:middle
这个工作内存的增长时

00:36:49.306 --> 00:36:51.006 A:middle
它就可以得出推论

00:36:51.226 --> 00:36:52.766 A:middle
当建模器看到需要为其

00:36:52.766 --> 00:36:54.086 A:middle
进行输出的模板时

00:36:54.086 --> 00:36:56.206 A:middle
它只需将其

00:36:56.206 --> 00:36:57.406 A:middle
写入对外输出表格

00:36:58.166 --> 00:37:00.256 A:middle
让我们以一个

00:36:58.166 --> 00:37:00.256 A:middle
让我们以一个

00:37:00.406 --> 00:37:01.766 A:middle
非常有趣的例子

00:37:01.766 --> 00:37:03.336 A:middle
来介绍如何使用建模器

00:37:03.606 --> 00:37:05.966 A:middle
假设你定义了一个 Schema

00:37:06.106 --> 00:37:07.906 A:middle
叫做 playing-with-matches

00:37:08.006 --> 00:37:10.166 A:middle
它是一个

00:37:10.166 --> 00:37:12.666 A:middle
os-signpost-interval-schema

00:37:12.876 --> 00:37:14.156 A:middle
可以使已经定义的 os_signpost

00:37:14.156 --> 00:37:15.036 A:middle
在你的代码中

00:37:15.036 --> 00:37:17.226 A:middle
做一些危险的操作

00:37:17.726 --> 00:37:19.996 A:middle
我们又定义了另一个 Schema

00:37:20.156 --> 00:37:21.766 A:middle
叫做 app-on-fire

00:37:22.186 --> 00:37:23.916 A:middle
它也是一个 signpost Schema

00:37:24.066 --> 00:37:25.206 A:middle
但是这些 signpost 意味着

00:37:25.206 --> 00:37:27.386 A:middle
App 进入了一个糟糕的状态

00:37:27.386 --> 00:37:29.396 A:middle
我们真的很想知道原因

00:37:30.406 --> 00:37:31.816 A:middle
还要创建一个输出 Schema

00:37:31.816 --> 00:37:33.306 A:middle
它是一个 point-schema

00:37:33.306 --> 00:37:35.836 A:middle
它会保存 playing-with-matches 的对象

00:37:35.836 --> 00:37:37.476 A:middle
以及对象“起火”的时间

00:37:37.956 --> 00:37:38.676 A:middle
我们打算将它

00:37:38.676 --> 00:37:39.796 A:middle
命名为 started-a-fire

00:37:39.796 --> 00:37:44.066 A:middle
建模器看起来是这样的

00:37:44.226 --> 00:37:46.686 A:middle
所有的输入

00:37:46.686 --> 00:37:48.486 A:middle
都按时间顺序设置好了

00:37:48.486 --> 00:37:51.096 A:middle
左边的虚线就是

00:37:51.096 --> 00:37:53.126 A:middle
所谓的建模器时钟

00:37:54.136 --> 00:37:55.976 A:middle
当我们获取第一个输入

00:37:55.976 --> 00:37:57.206 A:middle
将其置入到工作内存中时

00:37:57.206 --> 00:37:58.636 A:middle
建模器时钟

00:37:58.686 --> 00:37:59.686 A:middle
将移动到区间的起始处

00:37:59.686 --> 00:38:03.076 A:middle
然后我们获取下一个输入

00:37:59.686 --> 00:38:03.076 A:middle
然后我们获取下一个输入

00:38:03.076 --> 00:38:04.666 A:middle
建模器时钟

00:38:04.666 --> 00:38:06.036 A:middle
再次移动到区间的起始处

00:38:06.036 --> 00:38:08.046 A:middle
我们将其置入到工作内存中

00:38:08.836 --> 00:38:10.376 A:middle
建模器观察

00:38:10.376 --> 00:38:12.656 A:middle
工作内存的这两个区间

00:38:12.656 --> 00:38:14.366 A:middle
建模器可以观察

00:38:14.366 --> 00:38:16.256 A:middle
playing-with-matches 是否在

00:38:16.256 --> 00:38:17.336 A:middle
app-on-fire 之前开始

00:38:17.336 --> 00:38:18.886 A:middle
这其实没有多大区别

00:38:19.176 --> 00:38:19.956 A:middle
如果反过来

00:38:19.956 --> 00:38:22.406 A:middle
app-on-fire 也已经开始了

00:38:22.406 --> 00:38:24.086 A:middle
我们就可以得出一个合乎逻辑的结论

00:38:25.396 --> 00:38:27.936 A:middle
叫做 cause-of-fire

00:38:27.936 --> 00:38:29.846 A:middle
并将它置入工作内存中

00:38:31.676 --> 00:38:33.456 A:middle
当我们获取第三个输入时

00:38:33.756 --> 00:38:34.986 A:middle
你会注意到

00:38:34.986 --> 00:38:36.636 A:middle
建模器时钟已经移动

00:38:36.636 --> 00:38:38.996 A:middle
它不再与前两个输入相交

00:38:39.516 --> 00:38:41.956 A:middle
所以它们将被从工作内存中移除

00:38:42.766 --> 00:38:44.636 A:middle
如果 cause-of-fire 有

00:38:44.636 --> 00:38:45.886 A:middle
所谓的逻辑支持

00:38:46.326 --> 00:38:50.556 A:middle
它也会被从内存中移除

00:38:50.856 --> 00:38:52.926 A:middle
回顾一下 时钟总是被设置为

00:38:52.926 --> 00:38:54.926 A:middle
当前输入的时间戳

00:38:55.556 --> 00:38:57.576 A:middle
对于留在工作内存中的

00:38:57.576 --> 00:38:58.936 A:middle
输入而言

00:38:58.936 --> 00:39:01.836 A:middle
它必须与建模器中的

00:38:58.936 --> 00:39:01.836 A:middle
它必须与建模器中的

00:39:01.836 --> 00:39:02.406 A:middle
当前时钟相交

00:39:02.956 --> 00:39:04.876 A:middle
这可以帮助我们建立重合

00:39:04.876 --> 00:39:06.606 A:middle
它能让我们删除旧数据

00:39:06.606 --> 00:39:08.626 A:middle
也能让我们了解

00:39:08.666 --> 00:39:10.186 A:middle
是否存在

00:39:10.186 --> 00:39:13.386 A:middle
可能与时间相关的输入

00:39:13.916 --> 00:39:15.026 A:middle
建模器对其

00:39:15.156 --> 00:39:16.766 A:middle
工作内存的解释

00:39:17.066 --> 00:39:19.196 A:middle
是通过所谓的 “Production System”

00:39:19.196 --> 00:39:20.426 A:middle
来定义的

00:39:21.496 --> 00:39:23.466 A:middle
生产系统处理

00:39:23.466 --> 00:39:25.306 A:middle
工作内存中的 “Facts（事实）”

00:39:25.306 --> 00:39:26.486 A:middle
它们由具有左手边 (LHS)

00:39:26.486 --> 00:39:28.176 A:middle
一个生产操作符

00:39:28.176 --> 00:39:30.346 A:middle
和右手边 (RHS) 的规则定义

00:39:31.106 --> 00:39:32.896 A:middle
LHS 是工作内存

00:39:33.306 --> 00:39:35.106 A:middle
中的一种模板

00:39:35.106 --> 00:39:37.336 A:middle
它能够激活规则

00:39:37.336 --> 00:39:38.976 A:middle
而 RHS 则是规则触发时

00:39:38.976 --> 00:39:41.576 A:middle
发生的动作

00:39:42.036 --> 00:39:43.306 A:middle
这些操作可以包括

00:39:43.746 --> 00:39:45.686 A:middle
向输出表中添加一行

00:39:45.866 --> 00:39:48.476 A:middle
或者在建模过程进行时

00:39:48.526 --> 00:39:50.896 A:middle
将一个新的事实

00:39:50.896 --> 00:39:52.566 A:middle
添加到工作内存中

00:39:54.186 --> 00:39:56.826 A:middle
事实有两个来源

00:39:56.926 --> 00:39:58.046 A:middle
首先 它们可以来自

00:39:58.046 --> 00:39:59.566 A:middle
你看到过的表格输入

00:39:59.566 --> 00:40:01.206 A:middle
通过使用我在建模时钟中

00:39:59.566 --> 00:40:01.206 A:middle
通过使用我在建模时钟中

00:40:01.206 --> 00:40:03.336 A:middle
展示的规则

00:40:03.336 --> 00:40:04.246 A:middle
表输入将被判定为事实

00:40:04.246 --> 00:40:06.376 A:middle
事实也可以通过

00:40:06.376 --> 00:40:07.846 A:middle
来自生产的 RHS 的

00:40:07.846 --> 00:40:09.866 A:middle
判定生成

00:40:11.066 --> 00:40:12.196 A:middle
如果你要创建你自己的事实

00:40:12.196 --> 00:40:14.336 A:middle
CLIPS 允许你

00:40:14.336 --> 00:40:15.316 A:middle
找到所谓的“事实模板”

00:40:15.426 --> 00:40:16.106 A:middle
你可以为你的事实

00:40:16.106 --> 00:40:17.196 A:middle
提供结构

00:40:17.196 --> 00:40:17.976 A:middle
并做一些基本的类型检查

00:40:18.046 --> 00:40:21.306 A:middle
让我们来看看 CLIPS 中的

00:40:21.306 --> 00:40:22.356 A:middle
一些规则

00:40:23.226 --> 00:40:24.326 A:middle
我们要讲的第一个规则

00:40:24.326 --> 00:40:25.926 A:middle
叫做 found-cause

00:40:27.306 --> 00:40:30.446 A:middle
它指的是 如果有一个对象

00:40:30.446 --> 00:40:31.806 A:middle
它的 playing-with-matches

00:40:31.806 --> 00:40:35.526 A:middle
在 t1 时开始

00:40:35.526 --> 00:40:38.996 A:middle
app-on-fire 在 t2 时开始

00:40:39.286 --> 00:40:41.466 A:middle
且 t1 比 t2 提前

00:40:41.466 --> 00:40:42.236 A:middle
那么在这个生产的 RHS 中

00:40:42.236 --> 00:40:43.756 A:middle
我们可以判定一个新的事实

00:40:43.756 --> 00:40:46.026 A:middle
叫做 cause-of-fire

00:40:46.076 --> 00:40:47.616 A:middle
以及导致“起火”的对象

00:40:48.196 --> 00:40:49.336 A:middle
它将进入到

00:40:49.426 --> 00:40:50.096 A:middle
工作内存中

00:40:51.136 --> 00:40:53.156 A:middle
我们接下来讨论第二个规则

00:40:53.156 --> 00:40:54.666 A:middle
也就是 record-cause

00:40:54.666 --> 00:40:58.296 A:middle
如果我们有一个 App

00:40:58.296 --> 00:41:00.166 A:middle
在某个开始时间“起火”

00:40:58.296 --> 00:41:00.166 A:middle
在某个开始时间“起火”

00:41:00.166 --> 00:41:01.796 A:middle
并且我们知道“起火”的原因

00:41:01.796 --> 00:41:03.536 A:middle
我们有一个绑定到

00:41:03.536 --> 00:41:05.876 A:middle
side append 的表格

00:41:05.876 --> 00:41:08.876 A:middle
它是建模器的输出端

00:41:08.946 --> 00:41:11.336 A:middle
而且这个表是我们定义的

00:41:11.336 --> 00:41:12.926 A:middle
叫做 started-a-fire 的 Schema

00:41:12.926 --> 00:41:16.776 A:middle
我们可以创建一个表格的行

00:41:16.776 --> 00:41:18.126 A:middle
然后设置时间

00:41:18.246 --> 00:41:19.946 A:middle
以及导致

00:41:19.946 --> 00:41:21.276 A:middle
模板中所得的值

00:41:21.276 --> 00:41:23.826 A:middle
“起火”的 Schema

00:41:23.906 --> 00:41:25.826 A:middle
通过这两个规则

00:41:25.826 --> 00:41:27.756 A:middle
我们基本上创建了

00:41:27.756 --> 00:41:29.356 A:middle
第一个专家系统来查找

00:41:29.356 --> 00:41:31.406 A:middle
App 中的不良模式

00:41:32.436 --> 00:41:34.376 A:middle
现在你可能已经注意到

00:41:34.376 --> 00:41:36.016 A:middle
规则是由 MODELER::

00:41:36.016 --> 00:41:38.396 A:middle
或 RECORDER:: 预先编写的

00:41:38.966 --> 00:41:39.546 A:middle
这些都是 CLIPS 中的模块

00:41:39.546 --> 00:41:41.606 A:middle
它们允许你

00:41:41.606 --> 00:41:43.916 A:middle
同时把规则分组

00:41:43.916 --> 00:41:45.956 A:middle
并控制规则的执行顺序

00:41:46.526 --> 00:41:48.556 A:middle
举个例子

00:41:48.556 --> 00:41:50.946 A:middle
如果你保持了所有的

00:41:50.946 --> 00:41:52.176 A:middle
为 RECORDER:: 模块中的输出表格

00:41:52.176 --> 00:41:54.006 A:middle
生产输出的规则

00:41:55.116 --> 00:41:57.536 A:middle
你就可以确保

00:41:57.536 --> 00:41:59.896 A:middle
你不会在建模器的

00:41:59.896 --> 00:42:01.916 A:middle
推理过程中进行输出

00:41:59.896 --> 00:42:01.916 A:middle
推理过程中进行输出

00:42:02.246 --> 00:42:03.566 A:middle
因为在 MODELER:: 中的所有规则

00:42:03.566 --> 00:42:05.246 A:middle
必须在

00:42:05.246 --> 00:42:06.966 A:middle
RECORDER:: 中的规则

00:42:06.966 --> 00:42:07.746 A:middle
执行之前执行

00:42:08.686 --> 00:42:10.736 A:middle
我之前提到过的

00:42:10.736 --> 00:42:12.296 A:middle
逻辑支持

00:42:12.776 --> 00:42:14.556 A:middle
逻辑支持通常与

00:42:14.776 --> 00:42:17.066 A:middle
所谓的对等推理规则

00:42:17.066 --> 00:42:18.586 A:middle
联系在一起

00:42:18.586 --> 00:42:20.336 A:middle
这些规则就是 比如说

00:42:20.336 --> 00:42:21.736 A:middle
如果 A 和 B 那么 C

00:42:22.156 --> 00:42:23.756 A:middle
向生产中

00:42:23.756 --> 00:42:25.286 A:middle
添加逻辑支持

00:42:25.286 --> 00:42:29.646 A:middle
意思就是

00:42:29.646 --> 00:42:30.786 A:middle
如果 A 和 B 不再

00:42:30.786 --> 00:42:32.126 A:middle
处于工作内存中

00:42:32.126 --> 00:42:33.606 A:middle
那么 C 应该被自动收回

00:42:33.656 --> 00:42:35.726 A:middle
所以我们说

00:42:35.726 --> 00:42:37.016 A:middle
C 受 A 和 B 的存在的

00:42:37.016 --> 00:42:38.326 A:middle
逻辑支持

00:42:38.806 --> 00:42:40.346 A:middle
这很重要

00:42:40.346 --> 00:42:41.606 A:middle
因为它限制了工作内存膨胀

00:42:41.606 --> 00:42:43.156 A:middle
这有助于资源消耗

00:42:43.156 --> 00:42:44.436 A:middle
但从工作内存中

00:42:44.436 --> 00:42:46.096 A:middle
删除不再有效的事实

00:42:46.096 --> 00:42:48.076 A:middle
同样也很重要

00:42:48.326 --> 00:42:49.486 A:middle
如果 A 和 B 不再有效

00:42:49.486 --> 00:42:51.526 A:middle
那么你应该移除 C

00:42:52.076 --> 00:42:54.596 A:middle
为了向你的生产

00:42:54.826 --> 00:42:57.606 A:middle
添加逻辑支持 这里是相关的规则

00:42:57.906 --> 00:42:59.826 A:middle
你只需将关键字 logical

00:42:59.866 --> 00:43:01.226 A:middle
填入模板

00:42:59.866 --> 00:43:01.226 A:middle
填入模板

00:43:01.226 --> 00:43:02.146 A:middle
那么在向前移动的过程中

00:43:02.146 --> 00:43:03.866 A:middle
规则中的 RHS

00:43:03.866 --> 00:43:05.986 A:middle
所判定的任何内容

00:43:05.986 --> 00:43:06.836 A:middle
都将被自动收回

00:43:07.056 --> 00:43:08.566 A:middle
你们应该注意到了

00:43:08.816 --> 00:43:10.566 A:middle
来自我们的 Schema 的

00:43:11.146 --> 00:43:12.876 A:middle
这两个规则 抱歉

00:43:12.876 --> 00:43:14.326 A:middle
这两个事实

00:43:14.766 --> 00:43:16.446 A:middle
它们都是输入

00:43:16.446 --> 00:43:17.176 A:middle
所以当建模器时钟

00:43:17.176 --> 00:43:18.456 A:middle
向前移动时

00:43:18.456 --> 00:43:19.636 A:middle
这些将自动被收回

00:43:22.196 --> 00:43:23.626 A:middle
好的 现在我们已经了解了

00:43:23.626 --> 00:43:25.476 A:middle
如何在包中创建

00:43:25.476 --> 00:43:27.336 A:middle
建模器的基本内容

00:43:27.436 --> 00:43:29.746 A:middle
并且看到了一些 CLIPS 语言和规则

00:43:30.186 --> 00:43:32.096 A:middle
让我们来看看

00:43:32.096 --> 00:43:34.626 A:middle
是否可以在我们的网络 Instrument 中

00:43:34.626 --> 00:43:37.646 A:middle
添加一个专家系统

00:43:37.646 --> 00:43:39.216 A:middle
以查找我们的网络层中的

00:43:39.426 --> 00:43:41.106 A:middle
不良模式和潜在的误用

00:43:41.706 --> 00:43:43.286 A:middle
为此 让我们邀请 Kacper 上台

00:43:43.286 --> 00:43:44.886 A:middle
做最后一个演示

00:43:45.516 --> 00:43:50.500 A:middle
[ 掌声 ]

00:43:55.016 --> 00:43:56.486 A:middle
&gt;&gt; 有了现有的日志记录

00:43:56.526 --> 00:43:58.176 A:middle
我将尝试编写建模器

00:43:58.246 --> 00:43:59.796 A:middle
来检测 App 的

00:43:59.796 --> 00:44:00.956 A:middle
网络行为中的

00:43:59.796 --> 00:44:00.956 A:middle
网络行为中的

00:44:00.956 --> 00:44:01.976 A:middle
一些反面模式

00:44:02.756 --> 00:44:03.656 A:middle
我在运行我的

00:44:03.656 --> 00:44:05.646 A:middle
《Trailblazer》 App

00:44:05.646 --> 00:44:07.086 A:middle
如果我滚动得很快

00:44:07.136 --> 00:44:08.746 A:middle
这里就会出现

00:44:08.746 --> 00:44:09.476 A:middle
一些小故障

00:44:09.906 --> 00:44:11.886 A:middle
图像被多次替换

00:44:11.886 --> 00:44:14.516 A:middle
所以我怀疑我们的取消

00:44:14.516 --> 00:44:15.906 A:middle
并没有真正起作用

00:44:17.366 --> 00:44:19.736 A:middle
我想编写建模器来检测它

00:44:21.186 --> 00:44:23.746 A:middle
让我们来看看

00:44:23.746 --> 00:44:24.736 A:middle
我们的包定义

00:44:25.246 --> 00:44:27.916 A:middle
我们将从编写 modeler 元素开始

00:44:28.636 --> 00:44:31.336 A:middle
modeler 有 id title

00:44:31.336 --> 00:44:32.366 A:middle
和 purpose 几个栏

00:44:33.336 --> 00:44:35.316 A:middle
这些栏将被

00:44:35.316 --> 00:44:36.406 A:middle
提取到文档中

00:44:37.536 --> 00:44:39.366 A:middle
我们为 modeler 指定了

00:44:39.366 --> 00:44:41.576 A:middle
包含所有逻辑的

00:44:41.576 --> 00:44:42.756 A:middle
production system 的 path

00:44:45.086 --> 00:44:47.466 A:middle
然后 我们定义了 modeler 的 output

00:44:48.086 --> 00:44:50.006 A:middle
它将是一个 downloader-narrative Schema

00:44:50.916 --> 00:44:53.506 A:middle
我们的建模器的 required-input

00:44:53.506 --> 00:44:55.646 A:middle
将是 os-signpost 表格

00:44:56.556 --> 00:44:58.836 A:middle
这个表包含开始

00:44:58.836 --> 00:44:59.686 A:middle
和结束事件

00:45:00.926 --> 00:45:02.076 A:middle
现在让我们看一下

00:45:02.526 --> 00:45:03.816 A:middle
downloader-narrative

00:45:03.816 --> 00:45:04.946 A:middle
Schema 的定义

00:45:10.896 --> 00:45:13.006 A:middle
它是一个 point-schema

00:45:13.046 --> 00:45:15.026 A:middle
定义了两个列

00:45:15.526 --> 00:45:17.216 A:middle
timestamp

00:45:17.216 --> 00:45:19.046 A:middle
跟踪记录诊断消息的时间

00:45:20.176 --> 00:45:22.156 A:middle
description 含有

00:45:22.156 --> 00:45:23.666 A:middle
运行错误的信息

00:45:26.116 --> 00:45:28.346 A:middle
然后 我们可以在 Instrument 定义中

00:45:28.676 --> 00:45:30.086 A:middle
创建这个表

00:45:30.656 --> 00:45:33.316 A:middle
我们传入 downloader-narrative 的

00:45:33.316 --> 00:45:36.206 A:middle
schema-ref 和唯一的 id

00:45:37.896 --> 00:45:40.006 A:middle
然后我们可以在

00:45:40.136 --> 00:45:42.206 A:middle
narrative 元素定义中使用它

00:45:44.556 --> 00:45:46.266 A:middle
在这里我们定义 narrative

00:45:46.686 --> 00:45:49.006 A:middle
我们为之前创建的表格

00:45:49.006 --> 00:45:51.466 A:middle
传入 table-ref

00:45:51.546 --> 00:45:53.766 A:middle
定义 time-column

00:45:55.616 --> 00:45:55.846 A:middle
和 narrative-column

00:45:55.936 --> 00:45:57.876 A:middle
我们已经准备好

00:45:57.876 --> 00:45:58.756 A:middle
为我们的建模器定义逻辑

00:46:00.256 --> 00:46:01.826 A:middle
为此 我将创建

00:46:01.826 --> 00:46:03.736 A:middle
之前在 modeler 定义中

00:46:03.736 --> 00:46:04.766 A:middle
引用的文件

00:46:05.566 --> 00:46:07.256 A:middle
为了创建 CLIPS 文件

00:46:07.256 --> 00:46:12.796 A:middle
前往 “File（文件）”-“New（新建）”

00:46:14.276 --> 00:46:15.786 A:middle
选择 “macOS” 作为平台 “Other（其他）”部分的

00:46:15.786 --> 00:46:16.366 A:middle
“CLIPS File（CLIPS 文件）”

00:46:19.196 --> 00:46:27.586 A:middle
我把名称填好并创建

00:46:27.966 --> 00:46:30.286 A:middle
下面展示的将是

00:46:30.286 --> 00:46:31.936 A:middle
检测一个单元

00:46:31.936 --> 00:46:33.486 A:middle
是否同时执行

00:46:33.486 --> 00:46:34.256 A:middle
多个请求的算法

00:46:35.046 --> 00:46:37.036 A:middle
我们将在工作内存中

00:46:37.036 --> 00:46:38.756 A:middle
追踪每一个作为事实的请求

00:46:39.196 --> 00:46:40.856 A:middle
首先 我们需要

00:46:41.046 --> 00:46:42.946 A:middle
为这个事实创建模板

00:46:44.376 --> 00:46:47.696 A:middle
每个事实都会有

00:46:47.786 --> 00:46:49.996 A:middle
存储 time

00:46:49.996 --> 00:46:53.236 A:middle
caller-address 也就是单元地址

00:46:53.236 --> 00:46:56.286 A:middle
我们捕获到的 signpost-id

00:46:56.286 --> 00:46:57.286 A:middle
以及我们请求的 image-name

00:46:57.806 --> 00:46:59.796 A:middle
我们将这个事实叫做 started-download

00:47:01.036 --> 00:47:03.296 A:middle
然后编写

00:47:03.296 --> 00:47:05.816 A:middle
在工作内存中 创建此事件的建模器规则

00:47:08.576 --> 00:47:11.676 A:middle
这个规则查看 os-signpost 表格

00:47:12.536 --> 00:47:15.336 A:middle
我们指定 subsystem name

00:47:15.426 --> 00:47:18.006 A:middle
并把 “Begin” 作为 even-type 的值

00:47:18.006 --> 00:47:20.306 A:middle
并捕获我们想要的所有信息

00:47:21.186 --> 00:47:22.926 A:middle
我们需要捕获 ?image-name

00:47:22.926 --> 00:47:25.586 A:middle
?caller-address time 以及 ?identifier

00:47:25.586 --> 00:47:28.956 A:middle
然后 我们向工作内存判定新的事实

00:47:34.056 --> 00:47:36.676 A:middle
要在下载完成后清理它

00:47:36.746 --> 00:47:39.406 A:middle
我们需要从工作内存中

00:47:39.406 --> 00:47:40.666 A:middle
收回这一事实

00:47:44.426 --> 00:47:46.066 A:middle
这里我们查看的是同一个表格

00:47:46.066 --> 00:47:48.606 A:middle
但是我们只查看

00:47:48.866 --> 00:47:51.736 A:middle
event-type “End”

00:47:52.866 --> 00:47:54.836 A:middle
我们捕获 signpost 的 identifier

00:47:55.756 --> 00:47:57.426 A:middle
在这里我们使用的事实

00:47:57.846 --> 00:48:00.096 A:middle
signpost “Begin” 和 “End”

00:47:57.846 --> 00:48:00.096 A:middle
signpost “Begin” 和 “End”

00:48:00.136 --> 00:48:01.526 A:middle
必须有相同的标识符

00:48:02.706 --> 00:48:04.336 A:middle
我们在工作内存中

00:48:04.566 --> 00:48:07.296 A:middle
寻找一个具有我们捕获到的

00:48:07.296 --> 00:48:09.726 A:middle
signpost identifier 的事实

00:48:09.726 --> 00:48:11.346 A:middle
并收回这个事实

00:48:14.116 --> 00:48:16.286 A:middle
然后我们可以编写 RECORDER:: 规则

00:48:16.286 --> 00:48:18.976 A:middle
来生成所有的叙事数据

00:48:24.216 --> 00:48:27.106 A:middle
这个 RECORDER:: 规则

00:48:27.106 --> 00:48:28.546 A:middle
查看所有 started-download 事实

00:48:28.726 --> 00:48:29.986 A:middle
并捕获它们

00:48:30.616 --> 00:48:32.136 A:middle
我们捕获 time caller-address

00:48:32.136 --> 00:48:33.696 A:middle
以及 image-name

00:48:34.796 --> 00:48:36.936 A:middle
如果这里是 true

00:48:37.606 --> 00:48:39.176 A:middle
有另一个具有相同 caller-address 的

00:48:39.216 --> 00:48:40.996 A:middle
started-download 事实

00:48:40.996 --> 00:48:42.786 A:middle
你就可以注意到

00:48:42.786 --> 00:48:44.646 A:middle
这里引用的变量是相同的

00:48:45.376 --> 00:48:48.616 A:middle
并且在第一个事实之前发生

00:48:49.606 --> 00:48:51.136 A:middle
我们注意到

00:48:51.136 --> 00:48:52.326 A:middle
存在一些反向模式

00:48:52.326 --> 00:48:53.616 A:middle
而且在请求中存在重叠

00:48:54.716 --> 00:48:56.086 A:middle
我们可以检查

00:48:56.086 --> 00:48:57.346 A:middle
是否可以访问

00:48:57.346 --> 00:49:01.386 A:middle
downloader-narrative Schema

00:48:57.346 --> 00:49:01.386 A:middle
downloader-narrative Schema

00:49:01.386 --> 00:49:05.766 A:middle
在其中创建新的行

00:49:05.856 --> 00:49:08.976 A:middle
将列的时间设置为第一个事实的时间

00:49:08.976 --> 00:49:10.266 A:middle
并设置列的描述

00:49:11.036 --> 00:49:13.796 A:middle
你需要输出

00:49:13.796 --> 00:49:15.486 A:middle
关于这个问题的一些信息

00:49:15.846 --> 00:49:19.216 A:middle
以便之后有人可以调试它

00:49:19.456 --> 00:49:21.916 A:middle
现在我可以在 App 上运行 Instruments

00:49:22.636 --> 00:49:24.956 A:middle
让我们再次运行它

00:49:32.216 --> 00:49:38.156 A:middle
再次选择《Trailblazer》网络模板并记录

00:49:38.936 --> 00:49:41.766 A:middle
我将尝试执行一些

00:49:41.766 --> 00:49:44.976 A:middle
快速滚动并查看我的叙事表

00:49:49.636 --> 00:49:51.836 A:middle
你可以看到

00:49:51.886 --> 00:49:53.406 A:middle
叙事表包含大量

00:49:53.406 --> 00:49:55.066 A:middle
正在输出的诊断消息

00:49:56.026 --> 00:49:57.706 A:middle
我们可以看到

00:49:57.706 --> 00:49:59.126 A:middle
存在一些问题

00:49:59.126 --> 00:49:59.866 A:middle
之后再研究它们

00:50:00.876 --> 00:50:03.086 A:middle
你可以看到

00:50:03.176 --> 00:50:04.186 A:middle
叙事表是可互动的细节视图

00:50:04.876 --> 00:50:06.526 A:middle
例如 你可以检查

00:50:06.526 --> 00:50:07.746 A:middle
所有传入的参数

00:50:07.876 --> 00:50:09.066 A:middle
并进行筛选

00:50:09.496 --> 00:50:11.586 A:middle
我们可以添加这个调用者地址

00:50:11.586 --> 00:50:13.826 A:middle
成为一个细节过滤器

00:50:13.826 --> 00:50:15.476 A:middle
并拥有这个细节过滤器

00:50:17.476 --> 00:50:19.386 A:middle
现在 让我们请回 Chad

00:50:19.386 --> 00:50:21.146 A:middle
他将告诉你更多

00:50:21.216 --> 00:50:23.446 A:middle
关于开发 Instruments 的最佳实践经验

00:50:24.516 --> 00:50:29.896 A:middle
[ 掌声 ]

00:50:30.396 --> 00:50:30.646 A:middle
&gt;&gt; 好的

00:50:30.646 --> 00:50:31.326 A:middle
谢谢 Kacper

00:50:32.076 --> 00:50:34.616 A:middle
我们已经看到如何在 Instruments 中

00:50:34.616 --> 00:50:37.016 A:middle
创建一些基本的专家系统

00:50:37.106 --> 00:50:39.656 A:middle
好的 我们来谈谈

00:50:39.826 --> 00:50:42.316 A:middle
在这个过程中

00:50:42.316 --> 00:50:43.156 A:middle
我们学到的一些最佳实践经验

00:50:43.416 --> 00:50:46.796 A:middle
第一个是

00:50:46.796 --> 00:50:47.986 A:middle
编写多个 Instrument

00:50:48.236 --> 00:50:49.566 A:middle
我的意思并不是

00:50:49.566 --> 00:50:50.286 A:middle
练习编写 Instrument

00:50:50.776 --> 00:50:52.146 A:middle
而是 如果你

00:50:52.146 --> 00:50:52.926 A:middle
已经拥有了一个 Instrument

00:50:52.926 --> 00:50:54.096 A:middle
并且想给它添加一些特性

00:50:54.396 --> 00:50:55.486 A:middle
有时候 给你的 Instrument

00:50:55.486 --> 00:50:56.826 A:middle
添加额外的图形或细节

00:50:56.826 --> 00:50:57.826 A:middle
真的很容易

00:50:57.826 --> 00:50:59.346 A:middle
但是你应该

00:50:59.346 --> 00:51:00.306 A:middle
真正地思考

00:50:59.346 --> 00:51:00.306 A:middle
真正地思考

00:51:00.306 --> 00:51:01.876 A:middle
这样的话 它还可以成为自身的 Instrument 吗

00:51:02.226 --> 00:51:03.216 A:middle
这样想的原因是

00:51:03.216 --> 00:51:05.366 A:middle
如果你创建更细粒度的 Instrument

00:51:05.726 --> 00:51:07.326 A:middle
你会给这个 Instrument 的用户

00:51:07.326 --> 00:51:08.766 A:middle
更多的选择

00:51:09.256 --> 00:51:10.686 A:middle
他们可以从库中

00:51:10.686 --> 00:51:11.716 A:middle
拖出他们想要的 Instrument

00:51:11.716 --> 00:51:13.156 A:middle
这将最小化

00:51:13.156 --> 00:51:15.496 A:middle
对目标的记录影响

00:51:15.876 --> 00:51:17.306 A:middle
如果你把注意力集中在一个

00:51:17.306 --> 00:51:18.546 A:middle
有很多功能的 Instrument 上

00:51:18.546 --> 00:51:19.416 A:middle
那对用户来说 将是一个全盘接受

00:51:19.416 --> 00:51:20.026 A:middle
与被迫放弃之间的选择

00:51:20.986 --> 00:51:24.616 A:middle
如果你想创建

00:51:24.616 --> 00:51:26.066 A:middle
针对某个问题

00:51:26.636 --> 00:51:27.476 A:middle
的一组 Instrument

00:51:27.476 --> 00:51:29.666 A:middle
你一定想要看到

00:51:29.666 --> 00:51:31.366 A:middle
所有这些 Instrument 同时被使用

00:51:31.366 --> 00:51:33.616 A:middle
那么你所能做的就是

00:51:33.616 --> 00:51:34.976 A:middle
像我们创建网络模板那样

00:51:35.146 --> 00:51:36.156 A:middle
创建自己的自定义模板

00:51:36.696 --> 00:51:37.896 A:middle
所以你要做的应该是

00:51:37.896 --> 00:51:39.486 A:middle
创建一个文档

00:51:39.486 --> 00:51:42.126 A:middle
以你想要的方式拖拽 Instrument 配置它们

00:51:42.126 --> 00:51:44.116 A:middle
进入文件

00:51:44.116 --> 00:51:45.316 A:middle
然后保存为模板

00:51:45.706 --> 00:51:46.696 A:middle
然后你就可以在你的包中

00:51:46.696 --> 00:51:48.656 A:middle
使用那个模板

00:51:48.836 --> 00:51:50.666 A:middle
同时使用 Kacper

00:51:50.666 --> 00:51:52.496 A:middle
在我们的网络模板中添加的元素

00:51:53.226 --> 00:51:54.606 A:middle
使用多种 Instrument 编写

00:51:54.606 --> 00:51:56.486 A:middle
是使用工具更好的方式

00:51:58.046 --> 00:52:00.336 A:middle
第二 即时模式很难

00:51:58.046 --> 00:52:00.336 A:middle
第二 即时模式很难

00:52:01.156 --> 00:52:03.256 A:middle
即时模式指的是

00:52:03.256 --> 00:52:04.616 A:middle
Instruments 的记录模式

00:52:04.916 --> 00:52:07.016 A:middle
它可以在接近实时的时候

00:52:07.016 --> 00:52:08.916 A:middle
将数据可视化

00:52:08.916 --> 00:52:12.766 A:middle
有两个原因导致它很难

00:52:12.856 --> 00:52:14.246 A:middle
第一个原因是

00:52:14.246 --> 00:52:16.006 A:middle
它需要一些额外的支持

00:52:16.006 --> 00:52:17.176 A:middle
尽管今天我们很想向你们介绍这点

00:52:17.176 --> 00:52:18.436 A:middle
但是很遗憾没有办法

00:52:18.436 --> 00:52:19.546 A:middle
时间有限

00:52:19.956 --> 00:52:20.726 A:middle
所以我们将会

00:52:20.726 --> 00:52:21.936 A:middle
为此编写文档

00:52:22.426 --> 00:52:24.156 A:middle
第二个原因

00:52:24.156 --> 00:52:26.456 A:middle
也是更重要的原因

00:52:26.456 --> 00:52:29.296 A:middle
就是区间数据

00:52:29.296 --> 00:52:31.236 A:middle
区间不能被输入到

00:52:31.236 --> 00:52:32.766 A:middle
分析核心的表中

00:52:32.766 --> 00:52:34.406 A:middle
除非它们被关闭

00:52:34.406 --> 00:52:35.316 A:middle
这意味着这时我们已经

00:52:35.316 --> 00:52:36.346 A:middle
看到了开始和结束

00:52:36.496 --> 00:52:37.576 A:middle
所以当你查看

00:52:37.576 --> 00:52:39.386 A:middle
现场记录的时候

00:52:39.386 --> 00:52:40.696 A:middle
你会发现一堆所谓的“开区间”

00:52:40.886 --> 00:52:42.216 A:middle
如果你的建模器

00:52:42.216 --> 00:52:43.506 A:middle
需要它们作为输入

00:52:43.586 --> 00:52:45.576 A:middle
这是完全可行的

00:52:45.576 --> 00:52:46.956 A:middle
而且你会注意到

00:52:46.956 --> 00:52:48.936 A:middle
如果上游有一个开区间

00:52:48.936 --> 00:52:50.426 A:middle
那么下游的所有建模器时钟

00:52:50.426 --> 00:52:52.266 A:middle
都必须停止

00:52:52.266 --> 00:52:53.716 A:middle
直到那个区间关闭

00:52:53.716 --> 00:52:55.186 A:middle
因为建模器的视图

00:52:55.186 --> 00:52:56.986 A:middle
都是按时间排序的

00:52:57.116 --> 00:52:58.796 A:middle
除非所有的区间

00:52:58.796 --> 00:53:00.196 A:middle
都被关闭

00:52:58.796 --> 00:53:00.196 A:middle
都被关闭

00:53:00.196 --> 00:53:01.516 A:middle
否则无法把时钟向前移动

00:53:02.076 --> 00:53:03.086 A:middle
所以如果你有一些

00:53:03.086 --> 00:53:04.856 A:middle
占用时间很长的区间

00:53:04.856 --> 00:53:06.636 A:middle
你会注意到

00:53:06.636 --> 00:53:08.276 A:middle
建模器的输出似乎停止了

00:53:08.986 --> 00:53:11.336 A:middle
当用户点击

00:53:11.626 --> 00:53:13.506 A:middle
停止记录按钮

00:53:13.556 --> 00:53:14.516 A:middle
所有的开启的区间都被关闭时

00:53:14.516 --> 00:53:15.836 A:middle
所有的进程才将正常

00:53:15.976 --> 00:53:17.136 A:middle
数据也才会涌入

00:53:17.606 --> 00:53:19.036 A:middle
但这种用户体验并不好

00:53:19.416 --> 00:53:21.676 A:middle
如果停止录制

00:53:21.676 --> 00:53:22.396 A:middle
你将有两种选择

00:53:22.396 --> 00:53:24.686 A:middle
第一个是将 Instruments 退出

00:53:24.686 --> 00:53:26.066 A:middle
即时模式支持

00:53:26.066 --> 00:53:27.376 A:middle
为此你可以给你的 Instrument

00:53:27.376 --> 00:53:28.846 A:middle
添加一个限制元素

00:53:28.916 --> 00:53:31.396 A:middle
第二个是不再将区间数据

00:53:31.396 --> 00:53:34.096 A:middle
作为建模器的输入

00:53:34.096 --> 00:53:35.746 A:middle
就像我们在演示中

00:53:35.746 --> 00:53:38.136 A:middle
为我们的专家系统

00:53:38.136 --> 00:53:39.856 A:middle
所做的那样

00:53:39.856 --> 00:53:41.316 A:middle
我们实际上使用的是

00:53:41.316 --> 00:53:42.746 A:middle
os-signpost-point 事件

00:53:42.746 --> 00:53:44.176 A:middle
而不是 os-signpost-interval

00:53:45.316 --> 00:53:47.156 A:middle
我知道我们让它看起来简单

00:53:47.326 --> 00:53:49.086 A:middle
但是即时模式实现起来

00:53:49.086 --> 00:53:50.046 A:middle
确实有点棘手

00:53:50.436 --> 00:53:55.056 A:middle
第三 非常重要的一点

00:53:55.056 --> 00:53:56.256 A:middle
如果你要创建的 Instrument

00:53:56.256 --> 00:53:57.046 A:middle
针对的是

00:53:57.046 --> 00:53:59.156 A:middle
大量的输入数据

00:53:59.156 --> 00:54:00.646 A:middle
那么最后 5 秒

00:53:59.156 --> 00:54:00.646 A:middle
那么最后 5 秒

00:54:00.646 --> 00:54:03.466 A:middle
记录模式

00:54:03.466 --> 00:54:04.066 A:middle
是最有效的

00:54:04.346 --> 00:54:05.816 A:middle
你可以在跟踪文档的

00:54:05.816 --> 00:54:07.256 A:middle
记录选项中进行切换

00:54:07.256 --> 00:54:08.886 A:middle
之后你将看到

00:54:08.886 --> 00:54:09.776 A:middle
你可以在即时 延迟

00:54:09.776 --> 00:54:11.256 A:middle
和最后 n 秒模式之间

00:54:11.256 --> 00:54:12.676 A:middle
进行选择

00:54:13.246 --> 00:54:14.486 A:middle
更加有效的原因是

00:54:14.486 --> 00:54:16.476 A:middle
它允许记录技术

00:54:16.476 --> 00:54:18.016 A:middle
使用缓冲

00:54:18.296 --> 00:54:19.666 A:middle
来提高性能

00:54:19.716 --> 00:54:20.906 A:middle
这样它就不会一直尝试

00:54:20.906 --> 00:54:22.976 A:middle
实时向 Instruments 提供数据

00:54:23.376 --> 00:54:24.586 A:middle
这将产生深远的影响

00:54:24.586 --> 00:54:26.876 A:middle
它会对 signpost 数据

00:54:26.876 --> 00:54:28.286 A:middle
产生巨大的影响

00:54:28.286 --> 00:54:29.856 A:middle
在最后 5 秒模式下

00:54:30.096 --> 00:54:31.756 A:middle
速度可以提升 10 倍

00:54:32.246 --> 00:54:33.326 A:middle
当然 为此的权衡是

00:54:33.466 --> 00:54:34.796 A:middle
你只能看到

00:54:34.796 --> 00:54:37.136 A:middle
最后 5 秒的数据

00:54:37.296 --> 00:54:39.056 A:middle
但是对于产生大量

00:54:39.056 --> 00:54:40.736 A:middle
数据的 Instrument 来说

00:54:40.736 --> 00:54:41.276 A:middle
这通常是件好事

00:54:41.446 --> 00:54:43.016 A:middle
这使得它成为

00:54:43.016 --> 00:54:45.346 A:middle
系统跟踪和 Metal 系统跟踪

00:54:45.346 --> 00:54:46.916 A:middle
以及游戏性能模板的通用模式

00:54:47.176 --> 00:54:50.066 A:middle
如果你的目标是这类 App

00:54:50.066 --> 00:54:51.546 A:middle
我也会建议

00:54:51.546 --> 00:54:53.136 A:middle
你的 Instrument 不要支持即时模式

00:54:53.476 --> 00:54:54.506 A:middle
这样你的用户体验

00:54:54.506 --> 00:54:56.096 A:middle
就不会很糟糕

00:54:56.096 --> 00:54:58.086 A:middle
Instruments 在获取数据时

00:54:58.086 --> 00:54:59.236 A:middle
也不会出现延后

00:54:59.236 --> 00:55:00.746 A:middle
你在区间中也不会遇到类似的问题

00:54:59.236 --> 00:55:00.746 A:middle
你在区间中也不会遇到类似的问题

00:55:02.926 --> 00:55:04.326 A:middle
我们的讨论会差不多结束了

00:55:04.896 --> 00:55:08.026 A:middle
我们今天谈论很多

00:55:08.026 --> 00:55:09.116 A:middle
关于创建 Instrument 特性的内容

00:55:09.116 --> 00:55:10.456 A:middle
我们真的非常兴奋

00:55:10.456 --> 00:55:11.386 A:middle
因为我们能够

00:55:11.386 --> 00:55:12.306 A:middle
在今年向你们展示这一切

00:55:12.686 --> 00:55:14.636 A:middle
我们迫不及待地想知道

00:55:14.636 --> 00:55:15.746 A:middle
你们能通过 Instruments 创造什么样的成果

00:55:16.146 --> 00:55:17.906 A:middle
如果你想和我们

00:55:17.906 --> 00:55:18.926 A:middle
谈谈自定义 Instrument

00:55:18.926 --> 00:55:21.176 A:middle
我们将在今天下午 3 点

00:55:21.566 --> 00:55:23.986 A:middle
8 号实验室等待各位

00:55:23.986 --> 00:55:25.916 A:middle
另外 405 号讨论会详细介绍了

00:55:25.916 --> 00:55:27.256 A:middle
如何使用 os_signpost API

00:55:27.256 --> 00:55:29.156 A:middle
你可以通过它将数据输入 Instruments

00:55:29.856 --> 00:55:30.976 A:middle
请享受接下来的讨论会

00:55:31.516 --> 00:55:34.500 A:middle
[ 掌声 ]
