WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ 音乐 ]

00:00:17.516 --> 00:00:23.056 A:middle
[ 掌声 ]

00:00:23.556 --> 00:00:24.156 A:middle
&gt;&gt; 大家好

00:00:24.876 --> 00:00:26.136 A:middle
非常高兴见到今天

00:00:26.136 --> 00:00:26.446 A:middle
到场的各位

00:00:27.306 --> 00:00:29.676 A:middle
我是 Dave 之后的 40 分钟

00:00:29.676 --> 00:00:32.436 A:middle
是关于理解

00:00:32.485 --> 00:00:33.996 A:middle
和致敬 驱动我们的

00:00:34.036 --> 00:00:35.716 A:middle
程序运行的东西

00:00:36.766 --> 00:00:38.286 A:middle
我们将会聊到一些实用的建议

00:00:38.636 --> 00:00:40.986 A:middle
但这并不是一个关于

00:00:41.056 --> 00:00:43.116 A:middle
技巧 技术

00:00:43.116 --> 00:00:44.876 A:middle
或者任何具体算法的演讲

00:00:44.876 --> 00:00:45.816 A:middle
尽管我们仍会有所涉及

00:00:47.026 --> 00:00:49.156 A:middle
这个演讲主要的内容是

00:00:49.296 --> 00:00:50.956 A:middle
揭示一些根本的东西 它的潜力

00:00:51.036 --> 00:00:54.006 A:middle
已经在你的代码中有所体现

00:00:54.936 --> 00:00:57.216 A:middle
我希望至少对于你们之中的一些人

00:00:57.216 --> 00:00:58.796 A:middle
这标志着与编程实践

00:00:58.796 --> 00:01:01.056 A:middle
建立新关系的开始

00:00:58.796 --> 00:01:01.056 A:middle
建立新关系的开始

00:01:02.236 --> 00:01:03.446 A:middle
就个人而言

00:01:03.446 --> 00:01:05.116 A:middle
当我发现这种方法时

00:01:05.116 --> 00:01:06.446 A:middle
我的生活和事业的航向

00:01:06.756 --> 00:01:07.486 A:middle
就由此改变

00:01:08.446 --> 00:01:09.926 A:middle
这就是为什么

00:01:09.926 --> 00:01:11.966 A:middle
我如此关心软件库

00:01:11.966 --> 00:01:13.786 A:middle
但它也是

00:01:13.786 --> 00:01:15.866 A:middle
我所编写过的具体代码的

00:01:15.866 --> 00:01:17.976 A:middle
每一部分之中的可靠性

00:01:17.976 --> 00:01:19.436 A:middle
可维护性以及性能表现的来源

00:01:20.836 --> 00:01:22.876 A:middle
但在我们开始之前

00:01:22.876 --> 00:01:24.226 A:middle
请允许我向你们介绍

00:01:24.226 --> 00:01:24.396 A:middle
我的一个朋友

00:01:26.776 --> 00:01:27.506 A:middle
他就是 Crusty

00:01:28.516 --> 00:01:31.616 A:middle
[ 掌声 ]

00:01:32.116 --> 00:01:34.006 A:middle
Crusty 是一个传统派

00:01:34.896 --> 00:01:37.026 A:middle
他不相信调试工具

00:01:37.026 --> 00:01:40.016 A:middle
也不爱使用集成开发环境

00:01:40.806 --> 00:01:43.246 A:middle
没错 他喜欢那种 80 × 24

00:01:43.246 --> 00:01:45.436 A:middle
的纯文本终端窗口

00:01:45.506 --> 00:01:46.246 A:middle
非常感谢

00:01:47.516 --> 00:01:49.566 A:middle
现在 Crusty 对最新的编程潮流

00:01:49.566 --> 00:01:51.916 A:middle
持悲观态度

00:01:51.916 --> 00:01:53.476 A:middle
所以想把他拖到 21 世纪

00:01:53.476 --> 00:01:55.166 A:middle
有时会比较费力

00:01:56.126 --> 00:01:57.636 A:middle
他总是有不同的想法

00:01:58.656 --> 00:02:00.866 A:middle
但是如果你仔细听

00:01:58.656 --> 00:02:00.866 A:middle
但是如果你仔细听

00:02:00.866 --> 00:02:03.336 A:middle
你肯定会学到点东西

00:02:03.576 --> 00:02:05.356 A:middle
有时他会有一些

00:02:05.356 --> 00:02:07.666 A:middle
神奇的表达方式

00:02:07.666 --> 00:02:10.156 A:middle
比如“编程揭示本真”  甚至可以说

00:02:10.156 --> 00:02:10.675 A:middle
有点玄幻了

00:02:11.416 --> 00:02:13.576 A:middle
为了理解他

00:02:13.576 --> 00:02:15.096 A:middle
我发现一种方法很有帮助

00:02:15.096 --> 00:02:16.286 A:middle
那就是写代码

00:02:17.526 --> 00:02:18.796 A:middle
所以最近我在编写

00:02:18.796 --> 00:02:20.586 A:middle
一个叫做《Shapes》的小程序

00:02:21.656 --> 00:02:22.906 A:middle
我希望将它创造成

00:02:22.906 --> 00:02:24.216 A:middle
一个全能矢量绘图程序

00:02:24.216 --> 00:02:26.876 A:middle
但目前为止 它只能让你

00:02:26.876 --> 00:02:28.836 A:middle
在无限画布上排列形状

00:02:30.416 --> 00:02:31.376 A:middle
现在 我想与你们讲一个

00:02:31.376 --> 00:02:33.226 A:middle
关于删除选择指令的故事

00:02:33.226 --> 00:02:37.826 A:middle
因为我从实现这一功能的过程中

00:02:37.826 --> 00:02:38.266 A:middle
学习到了很多

00:02:39.596 --> 00:02:41.216 A:middle
我想我们可能都

00:02:41.216 --> 00:02:43.426 A:middle
经历过这个过程的一部分

00:02:43.426 --> 00:02:45.436 A:middle
作为程序员 我们要学会

00:02:45.436 --> 00:02:46.856 A:middle
如何从数组中删除东西

00:02:47.816 --> 00:02:49.106 A:middle
每一个人都会从

00:02:49.106 --> 00:02:51.000 A:middle
做这种事情开始

00:02:53.596 --> 00:02:57.026 A:middle
刚刚这个就是删除选择指令

00:02:58.656 --> 00:03:02.316 A:middle
我们从 0 开始循环计数

00:02:58.656 --> 00:03:02.316 A:middle
我们从 0 开始循环计数

00:03:02.316 --> 00:03:03.326 A:middle
当我们发现要删除的东西

00:03:03.326 --> 00:03:05.126 A:middle
我们就调用 remove(at: )方法

00:03:05.126 --> 00:03:07.546 A:middle
然后我们就可以继续循环

00:03:07.546 --> 00:03:11.846 A:middle
直到 哦 溢出了

00:03:13.366 --> 00:03:14.906 A:middle
数组会变短

00:03:14.906 --> 00:03:16.256 A:middle
但是当循环开始时

00:03:16.256 --> 00:03:17.166 A:middle
我们选择了固定的迭代次数

00:03:17.876 --> 00:03:19.196 A:middle
幸运的是 如果你使用 Swift

00:03:19.246 --> 00:03:20.796 A:middle
并测试你的代码 你不可能遗漏这个 Bug

00:03:20.826 --> 00:03:23.436 A:middle
因为程序会产生内中断

00:03:23.946 --> 00:03:25.226 A:middle
但如果你像我一样

00:03:25.266 --> 00:03:26.996 A:middle
是 C 语言出身的程序员

00:03:26.996 --> 00:03:28.966 A:middle
面对这种问题 你可能没那么幸运

00:03:29.926 --> 00:03:30.256 A:middle
好的

00:03:30.626 --> 00:03:32.796 A:middle
我们可以通过将 for 循环替换为

00:03:32.796 --> 00:03:34.096 A:middle
更难看的 while 循环

00:03:34.096 --> 00:03:36.346 A:middle
来修复它

00:03:36.346 --> 00:03:37.516 A:middle
这可以使我们在每一次迭代中

00:03:37.516 --> 00:03:38.096 A:middle
检查计数

00:03:38.646 --> 00:03:42.736 A:middle
但这里也有一个细微的 Bug

00:03:43.956 --> 00:03:46.056 A:middle
如果两个连续的元素被选中

00:03:46.056 --> 00:03:48.706 A:middle
它将会删除第一个

00:03:48.706 --> 00:03:51.916 A:middle
并且立即

00:03:51.916 --> 00:03:54.256 A:middle
跳过下一个

00:03:54.466 --> 00:03:56.956 A:middle
这个 Bug 更加的阴险

00:03:56.956 --> 00:03:58.496 A:middle
因为它隐藏了起来

00:03:58.496 --> 00:04:00.286 A:middle
除非你的测试碰巧

00:03:58.496 --> 00:04:00.286 A:middle
除非你的测试碰巧

00:04:00.286 --> 00:04:02.716 A:middle
试运行了它

00:04:02.946 --> 00:04:04.416 A:middle
但是如果我们足够幸运注意到了它

00:04:04.416 --> 00:04:06.496 A:middle
我们便可以继续

00:04:06.496 --> 00:04:08.826 A:middle
用一个 else 代码块

00:04:08.826 --> 00:04:10.026 A:middle
来保护自增语句 再次修复

00:04:10.026 --> 00:04:10.586 A:middle
这个实现

00:04:11.226 --> 00:04:13.596 A:middle
那么 我们完成了吗

00:04:13.596 --> 00:04:16.476 A:middle
我们有把握确定 这次是正确的吗

00:04:17.706 --> 00:04:19.906 A:middle
我认为我可以自证

00:04:19.995 --> 00:04:20.755 A:middle
它能够运行

00:04:21.875 --> 00:04:24.106 A:middle
不管怎样 经过这次的严峻的考验

00:04:24.106 --> 00:04:25.356 A:middle
我们收获了什么

00:04:25.746 --> 00:04:27.336 A:middle
当然 我们将这个

00:04:27.336 --> 00:04:28.696 A:middle
九行的代码套路 牢记在脑中

00:04:28.696 --> 00:04:30.506 A:middle
这样我们就可以在想要

00:04:30.506 --> 00:04:32.456 A:middle
删除什么的时候 把它调出来

00:04:33.026 --> 00:04:35.666 A:middle
现在 我确定你们中的许多人

00:04:35.666 --> 00:04:36.676 A:middle
正控制着自己

00:04:36.676 --> 00:04:38.566 A:middle
不向我大声喊叫

00:04:38.656 --> 00:04:40.506 A:middle
因为有一个

00:04:40.506 --> 00:04:41.906 A:middle
更加优雅的方式可以用

00:04:41.906 --> 00:04:43.206 A:middle
我仍然记得 自己发现了

00:04:43.206 --> 00:04:44.686 A:middle
这个技巧的那一天

00:04:45.106 --> 00:04:46.666 A:middle
因为一旦你发现了它 你就不用

00:04:46.666 --> 00:04:48.456 A:middle
再用那九行套路代码了

00:04:49.406 --> 00:04:51.496 A:middle
迭代限制以及

00:04:51.556 --> 00:04:52.786 A:middle
下一个要检查的项的索引

00:04:52.786 --> 00:04:54.956 A:middle
像传送带一样不断滚动

00:04:54.956 --> 00:04:56.866 A:middle
因为 remove(at: i)

00:04:57.746 --> 00:04:59.696 A:middle
改变了数组中 i 之后的部分

00:05:00.766 --> 00:05:06.266 A:middle
但是如果你从后往前检查

00:05:06.266 --> 00:05:07.526 A:middle
你只会迭代数组中

00:05:07.526 --> 00:05:08.896 A:middle
你还没有改变的部分

00:05:10.056 --> 00:05:10.776 A:middle
干得漂亮 对吗

00:05:11.456 --> 00:05:12.556 A:middle
这就是我一直

00:05:12.606 --> 00:05:14.916 A:middle
使用的模式

00:05:14.946 --> 00:05:19.476 A:middle
因为它简洁并且从不失败

00:05:20.086 --> 00:05:21.736 A:middle
直到几个月前

00:05:21.736 --> 00:05:24.056 A:middle
一天早晨 我刚吃完

00:05:24.056 --> 00:05:26.216 A:middle
我的牛油果吐司

00:05:26.306 --> 00:05:28.376 A:middle
并漫不经心地摆弄我的 App

00:05:28.376 --> 00:05:29.986 A:middle
当我尝试从一个非常复杂的画布中

00:05:29.986 --> 00:05:31.686 A:middle
删除差不多一半的图形时

00:05:33.016 --> 00:05:35.166 A:middle
我的 iPad 卡死了

00:05:35.526 --> 00:05:36.206 A:middle
将近 3 秒钟

00:05:36.886 --> 00:05:40.586 A:middle
所以 我喝了一口

00:05:40.626 --> 00:05:42.746 A:middle
装在竹质随行保温杯里的

00:05:43.156 --> 00:05:44.716 A:middle
三倍浓度半因拿铁咖啡压压惊

00:05:44.716 --> 00:05:45.936 A:middle
开始考虑我的对策

00:05:47.656 --> 00:05:48.526 A:middle
这令人十分不安

00:05:49.136 --> 00:05:50.006 A:middle
我的意思是 这是一个

00:05:50.006 --> 00:05:51.716 A:middle
非常简单的操作

00:05:51.716 --> 00:05:53.686 A:middle
我的代码如此简洁

00:05:53.686 --> 00:05:54.286 A:middle
怎么可能出错呢

00:05:56.176 --> 00:05:58.256 A:middle
性能分析结果告诉我

00:05:58.256 --> 00:06:01.156 A:middle
红点就在这 但是除了这个

00:05:58.256 --> 00:06:01.156 A:middle
红点就在这 但是除了这个

00:06:01.156 --> 00:06:02.056 A:middle
我一点头绪都没有

00:06:02.706 --> 00:06:05.636 A:middle
然后 就在这时

00:06:05.636 --> 00:06:07.076 A:middle
Crusty 在我身后经过

00:06:07.076 --> 00:06:09.416 A:middle
拿着一罐从当地超市买的

00:06:09.416 --> 00:06:10.796 A:middle
准备作为日常饮品的

00:06:10.796 --> 00:06:11.546 A:middle
杂牌咖啡

00:06:12.936 --> 00:06:15.876 A:middle
“卡住了？” 他说

00:06:16.086 --> 00:06:18.016 A:middle
“是的” 我叹了口气

00:06:18.016 --> 00:06:19.216 A:middle
并向他解释情况

00:06:19.706 --> 00:06:24.556 A:middle
“那么 你有为此

00:06:24.556 --> 00:06:25.796 A:middle
看过文档吗？”

00:06:27.826 --> 00:06:29.916 A:middle
显然我没有 所以我呼出了

00:06:29.916 --> 00:06:31.516 A:middle
remove(at: ) 的 “Quick Help（快速帮助）”

00:06:31.806 --> 00:06:33.526 A:middle
Crusty 靠近了一点

00:06:34.316 --> 00:06:35.856 A:middle
“你的问题就在这”

00:06:35.856 --> 00:06:38.986 A:middle
他说 并在我华丽的

00:06:38.986 --> 00:06:41.036 A:middle
视网膜显示屏上留下了一个指纹

00:06:42.906 --> 00:06:45.506 A:middle
我用一块手工制作的

00:06:45.546 --> 00:06:47.216 A:middle
意大利超细纤维布

00:06:47.216 --> 00:06:50.596 A:middle
小心地擦掉了指纹

00:06:50.596 --> 00:06:53.386 A:middle
这时 Crusty 说 “小子

00:06:53.996 --> 00:06:54.856 A:middle
它告诉你了什么”

00:06:55.096 --> 00:06:57.516 A:middle
“唔” 我说 “它说

00:06:57.596 --> 00:06:59.056 A:middle
移除一个元素

00:06:59.056 --> 00:07:01.216 A:middle
需要使用大量的步骤

00:06:59.056 --> 00:07:01.216 A:middle
需要使用大量的步骤

00:07:01.216 --> 00:07:02.476 A:middle
而且与数组的长度成正比”

00:07:02.476 --> 00:07:04.456 A:middle
这的确有些道理

00:07:04.456 --> 00:07:06.686 A:middle
因为数组需要将

00:07:06.686 --> 00:07:08.316 A:middle
之后所有的元素

00:07:08.316 --> 00:07:09.186 A:middle
放入它们的新位置

00:07:10.996 --> 00:07:12.466 A:middle
“那么 这对你的删除选择指令

00:07:12.466 --> 00:07:14.996 A:middle
又有什么意义呢” 他问道

00:07:16.166 --> 00:07:17.646 A:middle
“呃” 我说

00:07:18.186 --> 00:07:21.606 A:middle
就在这时他拿出

00:07:21.606 --> 00:07:22.976 A:middle
一包薄荷糖

00:07:22.976 --> 00:07:24.086 A:middle
然后排成线放在我的桌子上

00:07:24.756 --> 00:07:25.596 A:middle
“你自己试一试”

00:07:27.246 --> 00:07:29.216 A:middle
所以我走完一遍流程

00:07:29.216 --> 00:07:30.656 A:middle
试图回答他的问题

00:07:30.896 --> 00:07:32.096 A:middle
“嗯 既然删除选择指令

00:07:32.096 --> 00:07:34.116 A:middle
需要进行 O(n) 个步骤

00:07:34.116 --> 00:07:35.486 A:middle
每一步都对应每一个已选的元素

00:07:35.486 --> 00:07:36.996 A:middle
而且你可以选择最多 n 个元素

00:07:37.276 --> 00:07:38.396 A:middle
那么总步数将与

00:07:38.396 --> 00:07:40.906 A:middle
n 的二次方成正比”

00:07:42.276 --> 00:07:44.356 A:middle
Crusty 继续说 “那可是二次方

00:07:44.356 --> 00:07:46.296 A:middle
小子 无论你用丑陋的方式正着走

00:07:46.296 --> 00:07:48.186 A:middle
还是穿着花哨的

00:07:48.186 --> 00:07:50.346 A:middle
裤子倒着来”

00:07:50.976 --> 00:07:54.106 A:middle
我那时才意识到

00:07:54.106 --> 00:07:56.036 A:middle
对于我的 10 到 20 个元素的

00:07:56.036 --> 00:07:58.006 A:middle
小型测试案例 我们只需使用

00:07:58.006 --> 00:08:00.376 A:middle
几百个步骤

00:07:58.006 --> 00:08:00.376 A:middle
几百个步骤

00:08:00.376 --> 00:08:01.936 A:middle
由于每一步都运行迅速

00:08:02.046 --> 00:08:02.876 A:middle
一切看起来棒极了

00:08:04.116 --> 00:08:05.396 A:middle
但是问题是

00:08:05.396 --> 00:08:06.296 A:middle
它的延展性不足

00:08:06.796 --> 00:08:10.576 A:middle
50 的二次方是 2500

00:08:10.576 --> 00:08:11.986 A:middle
100 的二次方更能达到 10000

00:08:12.546 --> 00:08:15.326 A:middle
如果你所做的所有测试

00:08:15.326 --> 00:08:17.186 A:middle
都在这个狭小范围之内

00:08:17.476 --> 00:08:18.766 A:middle
那你可能永远发现不了问题

00:08:19.336 --> 00:08:21.746 A:middle
但是延展性很重要

00:08:21.746 --> 00:08:23.336 A:middle
因为人们正在使用他们的手机和 iPad

00:08:23.336 --> 00:08:25.626 A:middle
处理越来越多的数据

00:08:25.626 --> 00:08:27.376 A:middle
我们也一直提供带有

00:08:27.376 --> 00:08:29.096 A:middle
更多存储空间的设备

00:08:29.096 --> 00:08:29.586 A:middle
帮助他们这么做

00:08:30.606 --> 00:08:32.346 A:middle
你们要关心这一点

00:08:32.346 --> 00:08:34.476 A:middle
因为对你们的用户而言

00:08:34.476 --> 00:08:35.296 A:middle
延展性意味着可预测性

00:08:35.826 --> 00:08:39.946 A:middle
所以 我理解了问题所在

00:08:39.946 --> 00:08:41.986 A:middle
但是我仍然不能确定

00:08:41.986 --> 00:08:42.746 A:middle
我应该怎么解决它

00:08:43.326 --> 00:08:43.706 A:middle
“现在我该怎么办？”

00:08:43.706 --> 00:08:44.446 A:middle
我问 Crusty

00:08:45.526 --> 00:08:47.056 A:middle
“你知道吗 小伙子” 他一边说

00:08:47.496 --> 00:08:49.776 A:middle
一边把一粒薄荷糖放到嘴里

00:08:49.776 --> 00:08:51.466 A:middle
“有一个解决这个问题的算法”

00:08:53.056 --> 00:08:56.236 A:middle
我和他说 “听着 Crusty

00:08:56.236 --> 00:08:57.176 A:middle
我是一个 App 开发者

00:08:58.226 --> 00:09:00.716 A:middle
你说过你不做面向对象的东西

00:08:58.226 --> 00:09:00.716 A:middle
你说过你不做面向对象的东西

00:09:00.716 --> 00:09:02.646 A:middle
同样 我也不做算法

00:09:03.276 --> 00:09:04.406 A:middle
你关注在算法类中的

00:09:04.406 --> 00:09:06.066 A:middle
数据结构

00:09:06.396 --> 00:09:08.036 A:middle
因为你知道

00:09:08.036 --> 00:09:09.806 A:middle
找工作的时候

00:09:09.806 --> 00:09:10.946 A:middle
你的面试官会考你

00:09:11.346 --> 00:09:12.776 A:middle
但在真正的编程世界

00:09:12.776 --> 00:09:14.766 A:middle
区分大神和菜鸟的关键

00:09:14.926 --> 00:09:16.946 A:middle
是将控制器 委托

00:09:16.946 --> 00:09:18.396 A:middle
以及响应程序

00:09:18.396 --> 00:09:19.766 A:middle
连接在一起

00:09:19.766 --> 00:09:22.546 A:middle
构建一个工作系统的能力”

00:09:22.996 --> 00:09:24.906 A:middle
“豆包” 他说

00:09:24.906 --> 00:09:27.276 A:middle
我不知道为什么他这么称呼我

00:09:27.506 --> 00:09:28.656 A:middle
“计算机是做什么的”

00:09:30.096 --> 00:09:30.816 A:middle
“它们计算”

00:09:31.796 --> 00:09:33.086 A:middle
“那么 你的代码中的计算

00:09:33.086 --> 00:09:34.286 A:middle
在哪里呢”

00:09:35.356 --> 00:09:37.966 A:middle
“好吧” 我回答

00:09:37.966 --> 00:09:39.106 A:middle
“我想在我的代码里

00:09:39.106 --> 00:09:40.496 A:middle
我看不见什么东西像个算法”

00:09:41.046 --> 00:09:43.296 A:middle
但是 Crusty 不这么认为

00:09:43.806 --> 00:09:45.106 A:middle
“哦 你的 App 里面可全都是算法”

00:09:45.106 --> 00:09:46.646 A:middle
他说 接着将一本破旧的字典

00:09:46.646 --> 00:09:47.956 A:middle
扔在我的桌子上

00:09:48.526 --> 00:09:50.496 A:middle
“翻翻看”

00:09:51.266 --> 00:09:54.066 A:middle
在我镇定下来后

00:09:54.066 --> 00:09:55.396 A:middle
我小心地将书移到一边

00:09:55.396 --> 00:09:57.226 A:middle
在聚焦搜索栏中输入

00:09:57.226 --> 00:09:58.886 A:middle
“define: Algorithm (定义：算法)”

00:09:58.886 --> 00:10:00.000 A:middle
Crusty 认为这是个巧妙的技巧

00:10:03.976 --> 00:10:04.976 A:middle
嗯

00:10:05.046 --> 00:10:06.876 A:middle
在计算或其他解决问题的

00:10:06.876 --> 00:10:08.656 A:middle
运算中

00:10:08.656 --> 00:10:10.416 A:middle
要遵循的过程或规则集

00:10:11.756 --> 00:10:13.356 A:middle
好吧 细想一下

00:10:13.806 --> 00:10:16.016 A:middle
这听起来像大多数的代码

00:10:16.016 --> 00:10:16.906 A:middle
但是我仍不能确定

00:10:18.036 --> 00:10:19.446 A:middle
“你有做过长除法吗”

00:10:19.596 --> 00:10:20.236 A:middle
Crusty 问道

00:10:20.646 --> 00:10:21.576 A:middle
“那就是一个算法”

00:10:25.766 --> 00:10:27.606 A:middle
我又开始将它打到聚焦搜索中

00:10:27.606 --> 00:10:29.266 A:middle
但是他突然说

00:10:29.266 --> 00:10:29.646 A:middle
“在纸上算”

00:10:30.306 --> 00:10:31.616 A:middle
不想让自己难堪

00:10:31.616 --> 00:10:32.746 A:middle
我把话题转回到

00:10:32.746 --> 00:10:33.476 A:middle
我的代码上

00:10:35.316 --> 00:10:35.386 A:middle
“嗯”

00:10:36.256 --> 00:10:39.926 A:middle
我问 “所以 这个可以解决

00:10:39.926 --> 00:10:41.666 A:middle
我的代码性能问题的

00:10:41.666 --> 00:10:42.856 A:middle
神奇的算法是什么呢”

00:10:44.126 --> 00:10:45.496 A:middle
“那么 如果你愿意

00:10:45.496 --> 00:10:46.976 A:middle
让我用一下你的打字机”

00:10:46.976 --> 00:10:48.626 A:middle
他说 “这个东西怎么用

00:10:48.626 --> 00:10:49.816 A:middle
哦 这是一个触控板

00:10:49.816 --> 00:10:50.826 A:middle
我会尽量不碰它

00:10:51.226 --> 00:10:53.356 A:middle
所以首先 你要删掉这些

00:10:53.356 --> 00:10:54.330 A:middle
愚蠢的代码

00:10:57.046 --> 00:11:00.676 A:middle
然后 shapes.removeAll

00:10:57.046 --> 00:11:00.676 A:middle
然后 shapes.removeAll

00:11:00.676 --> 00:11:02.186 A:middle
(where: { $0.isSelected})

00:11:03.146 --> 00:11:03.326 A:middle
嗯

00:11:04.026 --> 00:11:05.236 A:middle
试试合不合身”

00:11:06.216 --> 00:11:07.756 A:middle
然后 Crusty 离开了

00:11:07.756 --> 00:11:08.856 A:middle
去洗他的咖啡机的拉花缸

00:11:08.856 --> 00:11:11.066 A:middle
留下我去琢磨

00:11:11.066 --> 00:11:12.816 A:middle
我的代码里到底

00:11:13.666 --> 00:11:13.766 A:middle
发生了什么

00:11:14.736 --> 00:11:17.756 A:middle
首先 我检查过并且发现

00:11:17.756 --> 00:11:19.286 A:middle
性能问题确实解决了

00:11:19.856 --> 00:11:20.226 A:middle
太棒了

00:11:21.536 --> 00:11:22.886 A:middle
我不想再听一遍

00:11:22.886 --> 00:11:24.226 A:middle
Crusty 唠叨说看文档

00:11:24.226 --> 00:11:26.626 A:middle
所以我弹出 removeAll(where: ) 的

00:11:26.626 --> 00:11:28.126 A:middle
“Quick Help”

00:11:28.676 --> 00:11:32.856 A:middle
然后我发现它的复杂度

00:11:32.856 --> 00:11:34.266 A:middle
也与集合的长度

00:11:34.266 --> 00:11:36.176 A:middle
成正地变化

00:11:36.176 --> 00:11:36.806 A:middle
就像 removeAt 一样

00:11:37.796 --> 00:11:39.656 A:middle
但是由于我不必

00:11:39.656 --> 00:11:41.576 A:middle
把它放入循环中

00:11:41.576 --> 00:11:42.836 A:middle
那么它就变成了我整个

00:11:42.836 --> 00:11:43.376 A:middle
运算的复杂度

00:11:44.576 --> 00:11:46.776 A:middle
现在 我想让你们

00:11:46.776 --> 00:11:48.026 A:middle
直观地理解

00:11:48.106 --> 00:11:50.106 A:middle
这能带来什么不同

00:11:50.566 --> 00:11:52.476 A:middle
O(n) 表示算法运行的时间

00:11:52.476 --> 00:11:54.216 A:middle
与问题的大小

00:11:54.566 --> 00:11:56.166 A:middle
成线性关系

00:11:56.696 --> 00:11:57.936 A:middle
这个图是一条直线

00:11:59.396 --> 00:12:00.826 A:middle
然后 这个橙色线是

00:11:59.396 --> 00:12:00.826 A:middle
然后 这个橙色线是

00:12:00.826 --> 00:12:02.076 A:middle
n 的二次方的形状

00:12:03.356 --> 00:12:04.846 A:middle
正如你所见

00:12:04.846 --> 00:12:06.406 A:middle
线性算法也许在小型问题中

00:12:06.406 --> 00:12:07.956 A:middle
表现稍差

00:12:07.956 --> 00:12:09.596 A:middle
但他最终比

00:12:09.596 --> 00:12:10.606 A:middle
二次方算法运行更快

00:12:11.926 --> 00:12:13.716 A:middle
很棒的是

00:12:13.716 --> 00:12:15.546 A:middle
不管你用线性算法

00:12:15.546 --> 00:12:16.856 A:middle
的成本有多高

00:12:16.856 --> 00:12:19.226 A:middle
如果你继续放更大的问题尺寸

00:12:19.226 --> 00:12:22.456 A:middle
你总是会找到

00:12:22.566 --> 00:12:24.736 A:middle
一个线性算法会赢

00:12:24.736 --> 00:12:27.206 A:middle
并且在后面

00:12:27.206 --> 00:12:28.206 A:middle
一直赢的点

00:12:29.346 --> 00:12:30.506 A:middle
所以 我们正在讨论的是

00:12:30.506 --> 00:12:33.000 A:middle
延展性 而不是绝对的性能

00:12:36.436 --> 00:12:40.346 A:middle
好了 我的延展性问题终于解决了

00:12:40.346 --> 00:12:42.316 A:middle
但我真的很想看看

00:12:42.316 --> 00:12:44.196 A:middle
标准程序库如何改进

00:12:44.196 --> 00:12:46.616 A:middle
我倒着来的删除方法

00:12:47.886 --> 00:12:49.586 A:middle
Crusty 提醒我说

00:12:49.586 --> 00:12:50.986 A:middle
Swift 是开放源码 所以我可以把它

00:12:50.986 --> 00:12:53.426 A:middle
放在他口中的“嬉皮士网”上

00:12:53.816 --> 00:12:55.500 A:middle
也就是我们其他人所知的 GitHub

00:12:59.266 --> 00:13:00.776 A:middle
现在 我注意到的第一件事

00:12:59.266 --> 00:13:00.776 A:middle
现在 我注意到的第一件事

00:13:00.776 --> 00:13:03.106 A:middle
便是点注释

00:13:03.136 --> 00:13:04.456 A:middle
它是所有 “Quick Help” 的来源

00:13:04.456 --> 00:13:09.136 A:middle
描述了算法的功能以及复杂度

00:13:09.596 --> 00:13:14.046 A:middle
接下来 结果是

00:13:14.046 --> 00:13:15.946 A:middle
removeAll(where) 不是什么

00:13:15.946 --> 00:13:18.486 A:middle
常规的方法

00:13:18.486 --> 00:13:20.466 A:middle
它是一个通用的算法

00:13:20.466 --> 00:13:22.126 A:middle
这意味着

00:13:22.126 --> 00:13:22.926 A:middle
它可以在各种不同的集合上运行

00:13:24.286 --> 00:13:25.296 A:middle
这取决于很多因素

00:13:25.296 --> 00:13:28.376 A:middle
重新排列元素的能力

00:13:28.376 --> 00:13:29.556 A:middle
它来自于

00:13:29.556 --> 00:13:31.636 A:middle
MutableCollection

00:13:31.966 --> 00:13:34.626 A:middle
改变长度和结构的能力

00:13:34.626 --> 00:13:36.506 A:middle
它来自于

00:13:36.506 --> 00:13:37.656 A:middle
RangeReplaceableCollection

00:13:38.186 --> 00:13:41.606 A:middle
它是由一些其他的

00:13:41.606 --> 00:13:43.206 A:middle
O(n) 算法构成的

00:13:44.016 --> 00:13:46.126 A:middle
第一个是 halfStablePartition

00:13:46.126 --> 00:13:48.096 A:middle
它将所有

00:13:48.096 --> 00:13:49.416 A:middle
满足某些谓词的元素

00:13:49.416 --> 00:13:53.456 A:middle
移动到末尾

00:13:53.456 --> 00:13:54.846 A:middle
并告诉我们后缀从哪里开始

00:13:56.136 --> 00:13:57.786 A:middle
halfStable 正如其名

00:13:58.186 --> 00:14:00.196 A:middle
表明了

00:13:58.186 --> 00:14:00.196 A:middle
表明了

00:14:00.196 --> 00:14:02.116 A:middle
它保留了不移动的

00:14:02.116 --> 00:14:03.646 A:middle
元素的顺序

00:14:04.486 --> 00:14:06.396 A:middle
但是它也可以打乱

00:14:06.436 --> 00:14:09.026 A:middle
移动到最后的元素

00:14:09.206 --> 00:14:10.426 A:middle
有些时候

00:14:10.426 --> 00:14:11.786 A:middle
这不是很重要

00:14:11.786 --> 00:14:13.166 A:middle
因为第二个算法 removeSubrange()

00:14:13.166 --> 00:14:14.146 A:middle
无论如何也会

00:14:14.146 --> 00:14:14.456 A:middle
删除子区间

00:14:16.476 --> 00:14:17.956 A:middle
我们都见过这个

00:14:17.956 --> 00:14:18.696 A:middle
部分区间的标记吗

00:14:19.256 --> 00:14:21.426 A:middle
它是一种非常方便的

00:14:21.426 --> 00:14:22.656 A:middle
方式来编写扩展到

00:14:22.656 --> 00:14:24.000 A:middle
集合末尾的范围

00:14:26.896 --> 00:14:27.116 A:middle
好的

00:14:27.846 --> 00:14:29.986 A:middle
现在 removeSubrange 是

00:14:29.986 --> 00:14:31.826 A:middle
库全局 API 的一部分

00:14:31.826 --> 00:14:33.496 A:middle
因此你可以在网上找到它的文档

00:14:33.496 --> 00:14:36.276 A:middle
但是 halfStablePartition

00:14:36.456 --> 00:14:37.696 A:middle
是一个运行的细节

00:14:38.236 --> 00:14:42.166 A:middle
现在 我们不打算

00:14:42.166 --> 00:14:43.556 A:middle
一一介绍 但是这里有一些

00:14:43.556 --> 00:14:45.116 A:middle
值得注意的地方

00:14:46.516 --> 00:14:48.846 A:middle
首先 它一开始

00:14:48.846 --> 00:14:49.696 A:middle
调用另一个算法

00:14:50.486 --> 00:14:52.596 A:middle
firstIndex(where: )

00:14:52.856 --> 00:14:54.716 A:middle
来查找属于后缀的

00:14:54.716 --> 00:14:55.796 A:middle
第一个元素的位置

00:14:57.176 --> 00:14:58.766 A:middle
接下来 它设置了一个循环变量 j

00:14:58.766 --> 00:15:01.126 A:middle
有一个循环

00:14:58.766 --> 00:15:01.126 A:middle
有一个循环

00:15:01.616 --> 00:15:04.906 A:middle
然后这个循环指数 j 在每次迭代中

00:15:05.046 --> 00:15:06.646 A:middle
会从前向后移动一位

00:15:07.696 --> 00:15:09.196 A:middle
所以 可以肯定的是

00:15:09.196 --> 00:15:10.716 A:middle
j 只对元素进行了一次传递

00:15:11.116 --> 00:15:14.086 A:middle
你几乎可以从这里看到

00:15:14.086 --> 00:15:20.306 A:middle
量级和复杂度

00:15:20.516 --> 00:15:22.106 A:middle
最后 由于该方法

00:15:22.106 --> 00:15:23.526 A:middle
需要重新排列元素

00:15:23.526 --> 00:15:24.726 A:middle
但不更改

00:15:24.726 --> 00:15:26.396 A:middle
集合的长度或结构

00:15:26.396 --> 00:15:27.506 A:middle
因此它只依赖于对

00:15:27.506 --> 00:15:28.606 A:middle
MutableCollection 的遵循

00:15:29.146 --> 00:15:32.676 A:middle
所以 这就是我学到的第一堂课

00:15:33.686 --> 00:15:34.966 A:middle
熟悉 Swift

00:15:34.966 --> 00:15:36.166 A:middle
标准库中的内容

00:15:37.176 --> 00:15:38.606 A:middle
它包含一组

00:15:38.606 --> 00:15:40.416 A:middle
提供文档描述

00:15:40.416 --> 00:15:42.316 A:middle
和性能特征的算法

00:15:43.406 --> 00:15:45.526 A:middle
虽然我们看了一点执行过程

00:15:45.526 --> 00:15:47.416 A:middle
你也可以从中学到很多东西

00:15:47.416 --> 00:15:49.126 A:middle
但由于它是设计好的

00:15:49.156 --> 00:15:50.946 A:middle
所以你不必用我之前的笨方法

00:15:52.426 --> 00:15:53.756 A:middle
官方文档会告诉你

00:15:53.756 --> 00:15:55.046 A:middle
需要知道的一切

00:15:55.046 --> 00:15:58.006 A:middle
以便有效地使用该库

00:15:58.996 --> 00:16:00.126 A:middle
你甚至可以在那找到

00:15:58.996 --> 00:16:00.126 A:middle
你甚至可以在那找到

00:16:00.126 --> 00:16:00.846 A:middle
一个 Playground 教程

00:16:01.906 --> 00:16:03.856 A:middle
我知道 Swift 中有很多内容

00:16:03.856 --> 00:16:05.436 A:middle
所以它的确可能看起来很吓人

00:16:06.196 --> 00:16:07.706 A:middle
但是你不需要记住一切

00:16:08.696 --> 00:16:10.066 A:middle
知道那里有什么

00:16:10.066 --> 00:16:12.156 A:middle
以及如何找到它将

00:16:12.156 --> 00:16:13.326 A:middle
为你省下很多精力

00:16:14.396 --> 00:16:16.466 A:middle
现在 在我们继续之前

00:16:16.466 --> 00:16:18.326 A:middle
我想指出

00:16:18.326 --> 00:16:19.576 A:middle
当 Crusty 做出此更改时

00:16:19.576 --> 00:16:20.276 A:middle
在代码中发生的其他事情

00:16:21.136 --> 00:16:22.816 A:middle
这两个中哪一个最直接地

00:16:22.816 --> 00:16:23.776 A:middle
描述了它的意义

00:16:24.346 --> 00:16:27.166 A:middle
现在 我必须先通读

00:16:27.226 --> 00:16:28.406 A:middle
并思考第一个

00:16:28.406 --> 00:16:29.216 A:middle
才能知道它在做什么

00:16:30.086 --> 00:16:30.376 A:middle
嗯

00:16:30.616 --> 00:16:31.836 A:middle
也许我最好加个注释

00:16:32.806 --> 00:16:33.026 A:middle
好的

00:16:33.026 --> 00:16:33.646 A:middle
看起来怎么样

00:16:34.196 --> 00:16:35.836 A:middle
哦 即使有了评论

00:16:35.836 --> 00:16:37.156 A:middle
反向迭代仍旧有点棘手

00:16:37.156 --> 00:16:38.356 A:middle
而且我也不想

00:16:38.356 --> 00:16:40.826 A:middle
有人因为他们不理解而破坏

00:16:40.826 --> 00:16:40.946 A:middle
这个代码

00:16:41.266 --> 00:16:45.046 A:middle
所以我最好解释一下

00:16:45.256 --> 00:16:45.726 A:middle
好的

00:16:46.126 --> 00:16:47.596 A:middle
当我们一一澄清时

00:16:47.656 --> 00:16:49.866 A:middle
Crusty 改过的代码实际上更好理解

00:16:49.866 --> 00:16:50.956 A:middle
因为它有一个

00:16:50.956 --> 00:16:51.606 A:middle
尾随闭包语法

00:16:51.966 --> 00:16:54.896 A:middle
现在 让我们深呼吸

00:16:54.896 --> 00:16:55.196 A:middle
然后再看

00:16:56.606 --> 00:16:58.346 A:middle
哪一个更明显是正确的

00:16:59.526 --> 00:17:00.956 A:middle
即使带有这些评论

00:16:59.526 --> 00:17:00.956 A:middle
即使带有这些评论

00:17:00.956 --> 00:17:02.016 A:middle
我仍然需要通读第一个

00:17:02.016 --> 00:17:03.936 A:middle
去明白它其实和第二个

00:17:03.936 --> 00:17:05.886 A:middle
做的是同样的事

00:17:05.955 --> 00:17:06.976 A:middle
但是效率更低

00:17:08.056 --> 00:17:09.465 A:middle
使用这个算法可以使代码

00:17:09.465 --> 00:17:10.955 A:middle
在各个方面都做得更好

00:17:11.526 --> 00:17:15.356 A:middle
所以 这是你的代码的

00:17:15.356 --> 00:17:16.955 A:middle
一个准则 也是一个目标

00:17:16.986 --> 00:17:18.486 A:middle
是由 Sean Parent 首先提出的

00:17:19.636 --> 00:17:20.836 A:middle
每当你编写一个循环时

00:17:21.316 --> 00:17:22.526 A:middle
就用对某个算法的调用

00:17:22.526 --> 00:17:23.046 A:middle
来替换它

00:17:23.846 --> 00:17:25.955 A:middle
如果你找不到对应的算法

00:17:25.955 --> 00:17:27.366 A:middle
就自己做一个算法

00:17:27.366 --> 00:17:28.656 A:middle
然后用这个算法来执行循环

00:17:30.656 --> 00:17:32.496 A:middle
实际上 现在对你来说

00:17:32.496 --> 00:17:34.156 A:middle
这似乎是不现实的

00:17:34.196 --> 00:17:36.166 A:middle
但是在谈话的最后

00:17:36.516 --> 00:17:37.056 A:middle
我希望它不再是这样

00:17:38.096 --> 00:17:39.356 A:middle
不过为了获得一点动力

00:17:39.856 --> 00:17:42.246 A:middle
回想一下上一次

00:17:42.246 --> 00:17:43.536 A:middle
你看到乱得像面条一样的代码的时候

00:17:44.066 --> 00:17:46.296 A:middle
是不是充满了循环

00:17:47.506 --> 00:17:50.276 A:middle
我打赌一定是

00:17:50.766 --> 00:17:51.236 A:middle
好吧

00:17:51.386 --> 00:17:52.286 A:middle
大功告成

00:17:52.506 --> 00:17:53.666 A:middle
我已经使代码

00:17:53.666 --> 00:17:56.066 A:middle
变得更短 更快

00:17:56.066 --> 00:17:56.686 A:middle
在各个方面都更好

00:17:56.686 --> 00:17:58.726 A:middle
我准备今天到此为止

00:17:59.376 --> 00:18:00.546 A:middle
“感谢你的帮助 Crusty”

00:17:59.376 --> 00:18:00.546 A:middle
“感谢你的帮助 Crusty”

00:18:00.546 --> 00:18:02.576 A:middle
我说 同时系上

00:18:02.576 --> 00:18:05.036 A:middle
我定制的皮革邮差包上的钛制钩环

00:18:05.036 --> 00:18:07.336 A:middle
但他怀疑地看着我

00:18:07.336 --> 00:18:09.586 A:middle
然后说

00:18:09.586 --> 00:18:10.966 A:middle
“你不认为你可能在别的地方

00:18:10.966 --> 00:18:12.330 A:middle
犯过那样的错误吗”

00:18:14.166 --> 00:18:16.746 A:middle
我叹了口气 把包放下

00:18:16.746 --> 00:18:18.746 A:middle
开始追踪我代码中的循环

00:18:20.016 --> 00:18:21.786 A:middle
然后我发现 在处理层级命令的

00:18:22.106 --> 00:18:24.106 A:middle
文件中 有很多

00:18:24.426 --> 00:18:28.666 A:middle
放到最前 放到最后

00:18:29.596 --> 00:18:31.126 A:middle
向前移动一层

00:18:31.126 --> 00:18:32.686 A:middle
也就是把选定的图形移到

00:18:32.686 --> 00:18:33.486 A:middle
前面的图形上

00:18:34.746 --> 00:18:38.206 A:middle
让我们来多做几次吧

00:18:38.406 --> 00:18:40.536 A:middle
向后移动

00:18:40.536 --> 00:18:41.756 A:middle
放在选定的图形下面

00:18:41.756 --> 00:18:45.486 A:middle
最后

00:18:45.486 --> 00:18:49.776 A:middle
在左边的图形列表中拖拽

00:18:49.776 --> 00:18:52.196 A:middle
现在 这些操作听起来非常简单

00:18:52.746 --> 00:18:56.126 A:middle
直到你意识到

00:18:56.126 --> 00:18:57.566 A:middle
它们都需要对多个选定的图形进行操作

00:18:57.566 --> 00:18:59.096 A:middle
这些图形在列表中

00:18:59.096 --> 00:19:01.316 A:middle
甚至可能都不是连续的

00:18:59.096 --> 00:19:01.316 A:middle
甚至可能都不是连续的

00:19:05.226 --> 00:19:06.486 A:middle
因此结果表明

00:19:06.486 --> 00:19:07.906 A:middle
在操作完成后

00:19:07.906 --> 00:19:09.166 A:middle
将所有选定的元素

00:19:09.166 --> 00:19:10.826 A:middle
放在一起

00:19:10.826 --> 00:19:12.126 A:middle
才是有意义的

00:19:13.126 --> 00:19:14.176 A:middle
所以 当你把图形向前移动时

00:19:14.176 --> 00:19:15.596 A:middle
你把选定的最前面的图形

00:19:15.596 --> 00:19:17.136 A:middle
放在紧邻它的图形前面

00:19:17.136 --> 00:19:18.936 A:middle
然后你把所有其他的图形

00:19:18.936 --> 00:19:20.566 A:middle
放在它后面

00:19:22.386 --> 00:19:23.736 A:middle
当你向后移动图形时

00:19:23.776 --> 00:19:25.496 A:middle
你把选定的最后面的图形

00:19:25.496 --> 00:19:26.926 A:middle
放在紧邻它的图形后面

00:19:26.926 --> 00:19:28.396 A:middle
然后把其他的图形

00:19:28.396 --> 00:19:30.366 A:middle
放在它前面

00:19:33.756 --> 00:19:36.256 A:middle
如果你没有完全跟上

00:19:36.256 --> 00:19:37.626 A:middle
不要担心

00:19:37.626 --> 00:19:38.526 A:middle
我们会回头再讲

00:19:38.856 --> 00:19:41.386 A:middle
但我只想说

00:19:41.386 --> 00:19:42.836 A:middle
我有一些精心设计的代码

00:19:42.836 --> 00:19:44.606 A:middle
来正确地处理所有这些细节 就足够了

00:19:45.866 --> 00:19:47.996 A:middle
例如 这是 bringToFront()

00:19:47.996 --> 00:19:51.256 A:middle
当我看到它时

00:19:51.256 --> 00:19:53.656 A:middle
我十分地确定

00:19:53.656 --> 00:19:55.366 A:middle
这些图形有一个 O(n) 的循环

00:19:55.956 --> 00:19:57.716 A:middle
还包含两个 O(n) 的运算

00:19:57.716 --> 00:20:00.186 A:middle
remove(at:)  insert(at:)

00:19:57.716 --> 00:20:00.186 A:middle
remove(at:)  insert(at:)

00:20:00.186 --> 00:20:02.756 A:middle
这就产生了

00:20:03.246 --> 00:20:04.786 A:middle
没错 n 的二次方

00:20:06.246 --> 00:20:08.526 A:middle
事实上 同样的问题

00:20:08.526 --> 00:20:10.076 A:middle
出现在每一个

00:20:10.076 --> 00:20:11.076 A:middle
我其他的四个命令中

00:20:12.516 --> 00:20:14.046 A:middle
这里的所有执行

00:20:14.386 --> 00:20:16.196 A:middle
都对数组进行循环

00:20:16.196 --> 00:20:17.936 A:middle
执行插入和删除操作

00:20:17.936 --> 00:20:19.126 A:middle
这意味着它们都是二次的

00:20:19.626 --> 00:20:23.096 A:middle
现在 我有点气馁

00:20:23.096 --> 00:20:24.996 A:middle
所以我问 Crusty

00:20:24.996 --> 00:20:26.106 A:middle
他是否愿意和我一起看

00:20:27.406 --> 00:20:29.106 A:middle
他说 “我不能待太晚”

00:20:29.186 --> 00:20:31.156 A:middle
他说 “我今晚有一个

00:20:31.156 --> 00:20:33.096 A:middle
交际舞聚会 但是我想

00:20:33.226 --> 00:20:34.546 A:middle
我们还是抓紧继续吧”

00:20:35.306 --> 00:20:37.486 A:middle
我在 bringToFront() 这里停下来

00:20:38.686 --> 00:20:40.946 A:middle
Crusty 的第一个问题是

00:20:42.156 --> 00:20:44.546 A:middle
“它到底是做什么的”

00:20:45.846 --> 00:20:47.566 A:middle
“好吧” 我说 “这是个 while 循环

00:20:47.566 --> 00:20:49.426 A:middle
j 跟踪插入点

00:20:49.426 --> 00:20:51.266 A:middle
i 跟踪我们正在

00:20:51.266 --> 00:20:51.906 A:middle
查看的元素

00:20:52.226 --> 00:20:54.216 A:middle
“用语言 而不是用代码”

00:20:54.246 --> 00:20:57.126 A:middle
Crusty 说“描述它”

00:20:58.146 --> 00:20:59.286 A:middle
“好吧 我们来看看

00:20:59.776 --> 00:21:01.616 A:middle
它将选定的图形移动到前面

00:20:59.776 --> 00:21:01.616 A:middle
它将选定的图形移动到前面

00:21:01.616 --> 00:21:04.176 A:middle
保持它们的相对顺序”

00:21:04.706 --> 00:21:07.136 A:middle
“把它写在点注释上

00:21:07.136 --> 00:21:08.376 A:middle
然后读给我听”

00:21:10.406 --> 00:21:13.146 A:middle
我是一个手速超快的打字员

00:21:15.236 --> 00:21:17.416 A:middle
“将选定的图形移动到前面

00:21:17.416 --> 00:21:19.286 A:middle
保持它们的相对顺序”

00:21:19.706 --> 00:21:21.766 A:middle
“听起来熟悉吗”

00:21:22.186 --> 00:21:22.796 A:middle
Crusty 说

00:21:24.066 --> 00:21:25.276 A:middle
就在那时我意识到

00:21:25.276 --> 00:21:26.736 A:middle
它很像 halfStablePartition

00:21:26.766 --> 00:21:29.676 A:middle
但它是完全稳定的

00:21:29.676 --> 00:21:32.046 A:middle
我开始激动起来

00:21:32.556 --> 00:21:34.226 A:middle
“你觉得这个叫什么”

00:21:34.906 --> 00:21:36.516 A:middle
我不得不猜

00:21:36.516 --> 00:21:37.026 A:middle
“stablePartition”

00:21:37.566 --> 00:21:38.346 A:middle
“没错

00:21:38.536 --> 00:21:41.126 A:middle
我最喜欢的一个

00:21:41.126 --> 00:21:42.426 A:middle
你可以在这个 Swift 开源项目中

00:21:42.426 --> 00:21:43.946 A:middle
找到一个

00:21:43.946 --> 00:21:45.486 A:middle
执行文件”

00:21:46.356 --> 00:21:48.396 A:middle
因此 我把文件拖进了我的项目中

00:21:48.396 --> 00:21:50.006 A:middle
同时 Crusty 含糊地说

00:21:50.006 --> 00:21:51.266 A:middle
我们添加的注释

00:21:51.266 --> 00:21:52.206 A:middle
应该在一开始就写上

00:21:52.206 --> 00:21:55.756 A:middle
我开始编写代码

00:21:56.936 --> 00:22:00.196 A:middle
写了这么多 就又遇到了一个问题

00:21:56.936 --> 00:22:00.196 A:middle
写了这么多 就又遇到了一个问题

00:22:01.666 --> 00:22:03.716 A:middle
你看 stablePartition 使用了一个谓词

00:22:03.716 --> 00:22:06.306 A:middle
它表示是否将元素

00:22:06.306 --> 00:22:09.126 A:middle
移动到集合的后缀中

00:22:09.946 --> 00:22:11.326 A:middle
所以 要把东西搬到后面

00:22:11.516 --> 00:22:13.496 A:middle
我需要执行

00:22:13.496 --> 00:22:14.046 A:middle
bringToFront()

00:22:15.406 --> 00:22:16.256 A:middle
我看向 Crusty

00:22:17.276 --> 00:22:19.286 A:middle
“脑补一下” 他说

00:22:20.286 --> 00:22:21.986 A:middle
于是 我闭上眼睛

00:22:22.646 --> 00:22:24.176 A:middle
看着那些未被选中的图形

00:22:24.176 --> 00:22:25.936 A:middle
聚集在后面

00:22:25.936 --> 00:22:26.616 A:middle
这就给了我答案

00:22:27.226 --> 00:22:31.096 A:middle
我猜 sendToBack 会更加简单

00:22:31.096 --> 00:22:32.436 A:middle
因为我们只需

00:22:32.436 --> 00:22:33.276 A:middle
反转谓词

00:22:33.836 --> 00:22:34.996 A:middle
我们将选定的图形

00:22:35.056 --> 00:22:38.126 A:middle
移动到后面

00:22:38.346 --> 00:22:40.566 A:middle
现在 我正准备执行

00:22:40.566 --> 00:22:42.476 A:middle
向前移动的命令

00:22:42.476 --> 00:22:43.986 A:middle
我想 Crusty 会和我一样

00:22:43.986 --> 00:22:46.346 A:middle
急于继续

00:22:46.346 --> 00:22:47.436 A:middle
考虑到他晚上的计划

00:22:47.756 --> 00:22:48.376 A:middle
但他阻止了我

00:22:49.296 --> 00:22:50.446 A:middle
“刹车 Snuffy

00:22:51.616 --> 00:22:52.856 A:middle
我不想错过开场探戈

00:22:52.856 --> 00:22:54.676 A:middle
但你不打算看看

00:22:54.676 --> 00:22:55.926 A:middle
它能不能延展尺寸吗”

00:22:57.326 --> 00:22:59.776 A:middle
他有道理 所以我弹出 stablePartition 的

00:22:59.776 --> 00:23:00.766 A:middle
“Quick Help”

00:22:59.776 --> 00:23:00.766 A:middle
“Quick Help”

00:23:00.806 --> 00:23:04.196 A:middle
然后看到它的复杂度

00:23:04.416 --> 00:23:06.046 A:middle
是 O(n log n)

00:23:06.606 --> 00:23:09.356 A:middle
为了有一个 O(n log n) 的概念

00:23:09.356 --> 00:23:11.506 A:middle
我们不妨看看 O(log n)

00:23:12.096 --> 00:23:15.236 A:middle
它从开始很快就进入

00:23:15.236 --> 00:23:17.246 A:middle
平稳状态 n 越大

00:23:17.496 --> 00:23:19.856 A:middle
它增长的越慢

00:23:19.886 --> 00:23:21.716 A:middle
越接近一个常数

00:23:22.526 --> 00:23:24.136 A:middle
所以当你乘 n 时

00:23:24.136 --> 00:23:27.366 A:middle
你所得到延展性图像

00:23:27.566 --> 00:23:29.376 A:middle
与 O(n) 的并不同

00:23:29.876 --> 00:23:31.466 A:middle
但是随着它的增长它

00:23:31.466 --> 00:23:32.946 A:middle
越来越接近线性

00:23:34.146 --> 00:23:36.696 A:middle
所以 O(n log n)

00:23:36.696 --> 00:23:38.556 A:middle
通常被认为

00:23:38.556 --> 00:23:40.066 A:middle
和 O(n) 差不多

00:23:40.896 --> 00:23:42.296 A:middle
我对此十分开心

00:23:43.056 --> 00:23:44.326 A:middle
所以我们继续处理

00:23:44.326 --> 00:23:44.696 A:middle
bringFoward()

00:23:45.246 --> 00:23:49.646 A:middle
现在 就像我们之前说过的

00:23:49.726 --> 00:23:51.626 A:middle
bringFoward() 将最前面选定的图形

00:23:51.626 --> 00:23:53.006 A:middle
向前移动一层

00:23:53.006 --> 00:23:55.296 A:middle
并将后面的其他

00:23:55.296 --> 00:23:56.576 A:middle
被选定的图形聚集起来

00:23:57.876 --> 00:24:00.156 A:middle
但是 Crusty 根本不喜欢

00:23:57.876 --> 00:24:00.156 A:middle
但是 Crusty 根本不喜欢

00:24:00.156 --> 00:24:01.506 A:middle
这种思考方法

00:24:02.146 --> 00:24:03.396 A:middle
“刚开始的时候

00:24:03.396 --> 00:24:05.026 A:middle
那个绕来绕去的东西 让那行代码

00:24:05.026 --> 00:24:06.096 A:middle
像是在跳狐步舞狐步舞”

00:24:06.356 --> 00:24:08.466 A:middle
他说 “你并不需要它”

00:24:09.096 --> 00:24:10.906 A:middle
当我茫然地看着他的时候

00:24:10.906 --> 00:24:12.206 A:middle
他又拿出了薄荷糖

00:24:13.976 --> 00:24:15.616 A:middle
用他五根灵活的手指

00:24:15.616 --> 00:24:17.836 A:middle
执行了

00:24:17.836 --> 00:24:19.926 A:middle
bringForward() 指令

00:24:22.556 --> 00:24:23.506 A:middle
“看到了吗”

00:24:23.776 --> 00:24:24.226 A:middle
他问

00:24:25.416 --> 00:24:26.816 A:middle
我感觉就像 明知道“赌徒三张”是一个陷阱

00:24:26.816 --> 00:24:33.976 A:middle
但我还是踩了进去

00:24:34.256 --> 00:24:35.176 A:middle
“看着熟悉吗”

00:24:36.336 --> 00:24:36.616 A:middle
“不”

00:24:37.826 --> 00:24:40.006 A:middle
他用手帕盖住了前几个

00:24:42.296 --> 00:24:46.366 A:middle
“现在呢”

00:24:46.636 --> 00:24:48.876 A:middle
就在这时我意识到

00:24:48.876 --> 00:24:50.226 A:middle
这就是另一个 stablePartition

00:24:51.416 --> 00:24:51.766 A:middle
好吧

00:24:52.236 --> 00:24:54.046 A:middle
我明白了 我想

00:24:55.856 --> 00:24:58.096 A:middle
如果我们找到选定的

00:24:58.096 --> 00:25:01.716 A:middle
最前面的图形

00:24:58.096 --> 00:25:01.716 A:middle
最前面的图形

00:25:01.746 --> 00:25:05.326 A:middle
然后移动到它前面图形的位置

00:25:05.606 --> 00:25:07.086 A:middle
并隔离从那里开始的数组的部分

00:25:07.086 --> 00:25:10.666 A:middle
我们可以对它进行分区

00:25:12.236 --> 00:25:14.166 A:middle
“但是，你如何只修改

00:25:14.166 --> 00:25:14.776 A:middle
集合中的一部分呢”

00:25:14.976 --> 00:25:15.676 A:middle
我问 Crusty

00:25:16.876 --> 00:25:18.296 A:middle
“你难道没听说过切片吗”

00:25:18.526 --> 00:25:19.946 A:middle
他说 同时接管了键盘

00:25:23.156 --> 00:25:25.106 A:middle
“shapes

00:25:25.726 --> 00:25:26.336 A:middle
[predecessor...]

00:25:27.656 --> 00:25:28.256 A:middle
好了

00:25:28.256 --> 00:25:29.596 A:middle
把它放在你的算法里

00:25:29.596 --> 00:25:30.146 A:middle
然后进行变换”

00:25:30.896 --> 00:25:32.000 A:middle
我立即照做

00:25:37.716 --> 00:25:41.456 A:middle
因此 人类关于如何

00:25:41.456 --> 00:25:43.096 A:middle
正确有效地

00:25:43.096 --> 00:25:44.976 A:middle
计算事物的知识

00:25:44.976 --> 00:25:47.156 A:middle
要比计算机早几千年

00:25:47.156 --> 00:25:48.846 A:middle
至少可以追溯到古埃及

00:25:49.546 --> 00:25:50.656 A:middle
自从计算机发明以来

00:25:50.656 --> 00:25:52.086 A:middle
这一领域的工作

00:25:52.086 --> 00:25:53.696 A:middle
出现了爆炸式增长

00:25:55.186 --> 00:25:56.586 A:middle
如果标准库没有

00:25:56.586 --> 00:25:58.386 A:middle
你所需要的

00:25:58.386 --> 00:26:00.556 A:middle
那么你需要做的

00:25:58.386 --> 00:26:00.556 A:middle
那么你需要做的

00:26:00.556 --> 00:26:03.396 A:middle
可能是测试 阅读文档

00:26:03.396 --> 00:26:04.786 A:middle
通常更正后还要检查一下

00:26:05.746 --> 00:26:07.436 A:middle
要学会如何在网络上

00:26:07.436 --> 00:26:08.746 A:middle
搜索适用于

00:26:08.746 --> 00:26:10.086 A:middle
你的问题领域的研究

00:26:12.716 --> 00:26:12.946 A:middle
好的

00:26:12.946 --> 00:26:13.596 A:middle
回到代码上来

00:26:14.076 --> 00:26:15.656 A:middle
我对这个切片很感兴趣

00:26:15.706 --> 00:26:17.136 A:middle
当我检查它的类型时

00:26:17.136 --> 00:26:20.156 A:middle
我发现它不是一个数组

00:26:20.716 --> 00:26:23.306 A:middle
由于我们是在一个数组上

00:26:23.306 --> 00:26:24.876 A:middle
使用了 stablePartition

00:26:24.876 --> 00:26:27.216 A:middle
bringToFront 以及 sendToBack

00:26:27.216 --> 00:26:28.776 A:middle
现在我们还在一个数组切片上使用它

00:26:28.776 --> 00:26:30.876 A:middle
所以我大胆猜测

00:26:30.876 --> 00:26:32.496 A:middle
它一定是通用的

00:26:32.496 --> 00:26:34.636 A:middle
“当然是

00:26:35.176 --> 00:26:36.446 A:middle
stablePartition

00:26:36.446 --> 00:26:37.846 A:middle
和特定的数组有什么关系”

00:26:39.166 --> 00:26:40.436 A:middle
“没错 没有联系

00:26:41.336 --> 00:26:44.046 A:middle
说到这 豆包

00:26:44.046 --> 00:26:45.416 A:middle
bringForward() 与图形和选择

00:26:45.416 --> 00:26:46.946 A:middle
又有什么关系呢”

00:26:48.616 --> 00:26:51.166 A:middle
“嗯” 我说 “它作用于图形

00:26:51.166 --> 00:26:52.876 A:middle
然后将选定的图形

00:26:52.876 --> 00:26:53.796 A:middle
移到前面”

00:26:54.046 --> 00:26:55.936 A:middle
“没错 也没关系”

00:26:55.936 --> 00:26:56.736 A:middle
他听都没听便说道

00:26:58.636 --> 00:27:00.006 A:middle
“你能在一排薄荷糖上

00:26:58.636 --> 00:27:00.006 A:middle
“你能在一排薄荷糖上

00:27:00.006 --> 00:27:00.926 A:middle
执行向前移动吗

00:27:01.926 --> 00:27:03.106 A:middle
当然 你可以

00:27:04.086 --> 00:27:05.516 A:middle
所以 这和图形

00:27:06.206 --> 00:27:06.500 A:middle
没有关系”

00:27:08.206 --> 00:27:08.446 A:middle
嗯

00:27:08.896 --> 00:27:10.916 A:middle
“你是在建议我们让它

00:27:10.916 --> 00:27:11.376 A:middle
变得通用吗”

00:27:11.556 --> 00:27:12.056 A:middle
我问道

00:27:12.676 --> 00:27:13.626 A:middle
“难道它不早就是

00:27:13.626 --> 00:27:14.426 A:middle
通用的了吗”

00:27:15.416 --> 00:27:16.546 A:middle
用一个新问题回答了这个问题

00:27:16.546 --> 00:27:20.866 A:middle
Crusty 回答道

00:27:20.866 --> 00:27:22.416 A:middle
“唔 你打算怎样

00:27:22.416 --> 00:27:23.330 A:middle
测试这个方法”

00:27:24.946 --> 00:27:26.736 A:middle
“好的” 我说

00:27:26.736 --> 00:27:27.376 A:middle
“我会创造一个画布

00:27:27.616 --> 00:27:29.186 A:middle
我会添加一些随机的图形

00:27:29.186 --> 00:27:30.886 A:middle
我会选定它们中的一些

00:27:30.886 --> 00:27:31.676 A:middle
然后最终”

00:27:32.466 --> 00:27:33.776 A:middle
但我的话没有说完

00:27:33.776 --> 00:27:35.506 A:middle
因为我知道

00:27:35.506 --> 00:27:36.216 A:middle
这是个坏主意

00:27:37.076 --> 00:27:39.126 A:middle
如果我就这么做

00:27:39.126 --> 00:27:40.456 A:middle
我真的会测试我的功能吗

00:27:40.966 --> 00:27:42.066 A:middle
还是我会测试

00:27:42.066 --> 00:27:43.646 A:middle
画布和不同图形的初始化设定

00:27:43.646 --> 00:27:45.606 A:middle
addMethod() 方法

00:27:45.606 --> 00:27:47.776 A:middle
再或者测试

00:27:47.976 --> 00:27:49.136 A:middle
各种形状的 isSelected 属性是否

00:27:49.136 --> 00:27:49.706 A:middle
计算出来

00:27:50.106 --> 00:27:52.356 A:middle
我的确应该建立测试用例

00:27:52.356 --> 00:27:54.506 A:middle
但是理想情况下

00:27:54.736 --> 00:27:56.266 A:middle
那段代码不应取决于其他

00:27:56.266 --> 00:27:57.826 A:middle
我需要再测试的代码

00:27:59.126 --> 00:28:00.506 A:middle
如果我可以将薄荷糖向前移

00:27:59.126 --> 00:28:00.506 A:middle
如果我可以将薄荷糖向前移

00:28:00.506 --> 00:28:02.776 A:middle
那么我也应有可能

00:28:02.776 --> 00:28:04.406 A:middle
用 Playground 中的整数

00:28:04.866 --> 00:28:05.636 A:middle
做一些随机的事

00:28:05.986 --> 00:28:08.226 A:middle
就像这样 用 bringForward() 方法

00:28:08.226 --> 00:28:09.796 A:middle
把能被 3 整除的数提到前面来

00:28:13.276 --> 00:28:14.596 A:middle
现在 在频谱的另一端

00:28:14.596 --> 00:28:16.296 A:middle
我应该可以向它抛出

00:28:16.296 --> 00:28:19.856 A:middle
大量随机生成的测试数据

00:28:19.856 --> 00:28:21.256 A:middle
并确保算法的

00:28:21.256 --> 00:28:22.386 A:middle
可扩展性

00:28:23.246 --> 00:28:24.696 A:middle
只要代码与画布和图形

00:28:24.696 --> 00:28:26.076 A:middle
绑定在一起

00:28:26.116 --> 00:28:27.906 A:middle
这些事情就都不会简单

00:28:29.146 --> 00:28:33.546 A:middle
所以 我向 Crusty 承认他是对的

00:28:33.546 --> 00:28:34.846 A:middle
并开始把这个非通用的

00:28:35.616 --> 00:28:37.106 A:middle
bringForward() 变成通用的算法

00:28:38.436 --> 00:28:40.666 A:middle
第一步是将它

00:28:40.666 --> 00:28:44.896 A:middle
从画布中解耦出来

00:28:44.896 --> 00:28:45.696 A:middle
并将其移动到图形数组中

00:28:47.216 --> 00:28:49.266 A:middle
当然 这个数组就是 shapes

00:28:49.266 --> 00:28:50.556 A:middle
所以我必须用 self

00:28:50.556 --> 00:28:54.366 A:middle
把它替换掉

00:28:54.366 --> 00:28:56.866 A:middle
然后我通过传递一个谓词

00:28:56.866 --> 00:28:58.636 A:middle
将它从选择中解耦出来

00:28:58.736 --> 00:29:00.046 A:middle
该谓词指示是否应该将选定的图形

00:28:58.736 --> 00:29:00.046 A:middle
该谓词指示是否应该将选定的图形

00:29:00.046 --> 00:29:00.866 A:middle
向前移动

00:29:04.716 --> 00:29:06.156 A:middle
一切都在正常编译着

00:29:07.036 --> 00:29:07.386 A:middle
太棒了

00:29:08.266 --> 00:29:10.826 A:middle
此时 我很高兴地发现

00:29:10.826 --> 00:29:12.086 A:middle
在 shapes 上没有依赖

00:29:12.086 --> 00:29:14.266 A:middle
我可以删除

00:29:14.426 --> 00:29:15.406 A:middle
where 子句了

00:29:15.956 --> 00:29:18.106 A:middle
非常好 我想

00:29:18.106 --> 00:29:20.106 A:middle
现在 我可以在任何数组中

00:29:20.106 --> 00:29:20.506 A:middle
执行 bringForward 了

00:29:21.636 --> 00:29:23.386 A:middle
我看了看 Crusty

00:29:23.386 --> 00:29:24.636 A:middle
他一直在角落里

00:29:24.676 --> 00:29:26.876 A:middle
安静地练习恰恰舞

00:29:26.876 --> 00:29:28.586 A:middle
但他似乎认为我还

00:29:29.736 --> 00:29:30.000 A:middle
没有结束

00:29:31.316 --> 00:29:32.996 A:middle
“bringForward() 和数组

00:29:32.996 --> 00:29:37.196 A:middle
有什么关系”他问

00:29:37.436 --> 00:29:38.976 A:middle
“好吧 的确没有” 我叹了口气

00:29:38.976 --> 00:29:40.046 A:middle
然后开始思考

00:29:40.046 --> 00:29:41.206 A:middle
如何移除这个依赖

00:29:42.656 --> 00:29:43.706 A:middle
让我们看看

00:29:43.706 --> 00:29:46.066 A:middle
这有一个 stablePartition()

00:29:46.066 --> 00:29:47.636 A:middle
需要遵循 MutableCollection

00:29:48.186 --> 00:29:49.416 A:middle
所以 也许我只需要将它移动到

00:29:49.416 --> 00:29:52.676 A:middle
MutableCollection 中

00:29:53.006 --> 00:29:53.466 A:middle
嗯

00:29:53.896 --> 00:29:56.076 A:middle
我想 显然索引类型

00:29:56.116 --> 00:29:59.746 A:middle
与 int 类型不匹配 好吧

00:29:59.746 --> 00:30:01.000 A:middle
这应该很好修复 对吧

00:29:59.746 --> 00:30:01.000 A:middle
这应该很好修复 对吧

00:30:04.216 --> 00:30:04.936 A:middle
你是这么做的吗

00:30:06.176 --> 00:30:08.106 A:middle
不要这么做

00:30:09.546 --> 00:30:11.326 A:middle
它编译好了

00:30:11.326 --> 00:30:12.586 A:middle
但是 Crusty 突然停止了跳舞

00:30:12.586 --> 00:30:15.156 A:middle
我知道有些不对劲

00:30:15.366 --> 00:30:16.166 A:middle
“什么” 我说

00:30:16.966 --> 00:30:18.836 A:middle
“菜鸟总是这样做”

00:30:18.836 --> 00:30:20.036 A:middle
Crusty 边摇着头边说

00:30:21.566 --> 00:30:23.216 A:middle
“首先 你让它与 0 的比较

00:30:23.216 --> 00:30:26.056 A:middle
这对于数组切片来说是错误的

00:30:26.686 --> 00:30:29.456 A:middle
所以 你知道数组切片

00:30:29.456 --> 00:30:31.596 A:middle
它们的索引不是

00:30:31.596 --> 00:30:32.216 A:middle
从 0 开始的吗

00:30:32.216 --> 00:30:35.696 A:middle
所有切片的索引

00:30:35.966 --> 00:30:37.506 A:middle
从它们被切片的

00:30:37.506 --> 00:30:38.786 A:middle
底层集合中的

00:30:38.786 --> 00:30:40.246 A:middle
相应索引开始

00:30:40.796 --> 00:30:42.976 A:middle
这种关系十分关键

00:30:42.976 --> 00:30:44.126 A:middle
如果你想要用切片

00:30:44.126 --> 00:30:46.466 A:middle
组成通用算法

00:30:47.056 --> 00:30:47.946 A:middle
所以它真的很重要”

00:30:49.156 --> 00:30:52.406 A:middle
好吧 我知道要修正这个问题

00:30:53.146 --> 00:30:54.126 A:middle
只需将它与开始索引

00:30:54.126 --> 00:30:54.516 A:middle
进行比较

00:30:55.766 --> 00:30:58.346 A:middle
但是真正的问题是

00:30:58.346 --> 00:31:00.056 A:middle
“bringForward() 与拥有整数索引

00:30:58.346 --> 00:31:00.056 A:middle
“bringForward() 与拥有整数索引

00:31:00.056 --> 00:31:01.846 A:middle
有什么关系”

00:31:01.846 --> 00:31:02.576 A:middle
我打断了他

00:31:03.416 --> 00:31:04.416 A:middle
“是的 我知道”

00:31:05.266 --> 00:31:07.466 A:middle
“我必须在 i 之前

00:31:07.466 --> 00:31:10.156 A:middle
得到索引

00:31:10.156 --> 00:31:10.876 A:middle
我可以用减法获得”

00:31:12.856 --> 00:31:14.976 A:middle
Crusty 只是叹了口气

00:31:14.976 --> 00:31:15.906 A:middle
然后又将薄荷糖拿了出来

00:31:17.466 --> 00:31:19.376 A:middle
然后 他把两个手指

00:31:19.376 --> 00:31:22.156 A:middle
放在桌子上 像小人一样走啊走

00:31:22.566 --> 00:31:24.966 A:middle
直到右手指向

00:31:25.136 --> 00:31:27.276 A:middle
第一块绿色的薄荷糖

00:31:27.806 --> 00:31:31.446 A:middle
“整支舞中都没有

00:31:31.446 --> 00:31:32.506 A:middle
向后的舞步” 他说

00:31:33.406 --> 00:31:35.286 A:middle
之后我意识到

00:31:35.286 --> 00:31:37.586 A:middle
Crusty 刚刚向我展示了一个新的算法

00:31:38.636 --> 00:31:39.546 A:middle
“我们叫它

00:31:39.696 --> 00:31:40.986 A:middle
indexBeforeFirst 吧”

00:31:42.066 --> 00:31:43.776 A:middle
“现在 这里的诀窍是

00:31:43.776 --> 00:31:46.086 A:middle
保持注意力集中

00:31:46.086 --> 00:31:46.976 A:middle
假设有人已经为你写了它”

00:31:47.826 --> 00:31:49.116 A:middle
然后他把我们不需要的

00:31:49.116 --> 00:31:50.336 A:middle
代码都删掉了

00:31:50.336 --> 00:31:53.906 A:middle
像这样 这样

00:31:56.616 --> 00:32:00.866 A:middle
“predecessor 就是第一个

00:31:56.616 --> 00:32:00.866 A:middle
“predecessor 就是第一个

00:32:00.866 --> 00:32:02.416 A:middle
在谓词被满足之前的元素

00:32:02.416 --> 00:32:04.286 A:middle
前面的索引

00:32:05.346 --> 00:32:06.656 A:middle
现在 快来看看这读起来

00:32:06.656 --> 00:32:07.046 A:middle
多么动人”

00:32:08.486 --> 00:32:10.946 A:middle
如果你看到了这个代码

00:32:10.946 --> 00:32:11.706 A:middle
你就会发现他是对的

00:32:13.116 --> 00:32:15.006 A:middle
删除所有无关的细节

00:32:15.006 --> 00:32:17.436 A:middle
包括图形 选择

00:32:17.546 --> 00:32:20.066 A:middle
数据以及整数

00:32:20.066 --> 00:32:22.006 A:middle
给我留下更清晰的代码

00:32:22.006 --> 00:32:23.626 A:middle
因为它只处理

00:32:23.696 --> 00:32:24.356 A:middle
问题的本质

00:32:24.926 --> 00:32:27.496 A:middle
“我已经向你展示了

00:32:27.496 --> 00:32:28.956 A:middle
indexBeforeFirst 是如何工作的

00:32:29.266 --> 00:32:32.236 A:middle
试一试你能不能写出来” 他说

00:32:32.706 --> 00:32:34.036 A:middle
所以 我想我现在开始

00:32:34.036 --> 00:32:36.016 A:middle
跟得上他了

00:32:36.016 --> 00:32:37.036 A:middle
因为我第一次做对了

00:32:37.666 --> 00:32:40.996 A:middle
我说过 我是个手速超快的打字员

00:32:41.466 --> 00:32:41.726 A:middle
好吧

00:32:42.236 --> 00:32:45.436 A:middle
所以 返回第一个

00:32:45.436 --> 00:32:48.536 A:middle
successor 与谓词匹配的索引

00:32:49.206 --> 00:32:51.556 A:middle
我非常兴奋地看到

00:32:51.556 --> 00:32:52.396 A:middle
这进展得有多么顺利

00:32:53.436 --> 00:32:54.456 A:middle
“好吧 Crusty” 我说

00:32:54.766 --> 00:32:55.726 A:middle
“让我们做下一个”

00:32:57.516 --> 00:32:58.946 A:middle
“你难道没有忘记什么事吗

00:32:58.946 --> 00:33:00.586 A:middle
豆包” 他问道

00:32:58.946 --> 00:33:00.586 A:middle
豆包” 他问道

00:33:00.586 --> 00:33:02.306 A:middle
我不知道

00:33:02.306 --> 00:33:02.906 A:middle
他在说什么

00:33:03.466 --> 00:33:05.276 A:middle
代码很简洁

00:33:05.276 --> 00:33:05.666 A:middle
而且运行正常

00:33:07.016 --> 00:33:08.336 A:middle
“语义 小子

00:33:09.046 --> 00:33:10.216 A:middle
我怎么能从其他代码中使用它们

00:33:10.216 --> 00:33:11.416 A:middle
如果我不知道

00:33:11.416 --> 00:33:12.156 A:middle
它们是什么意思呢”

00:33:12.786 --> 00:33:17.156 A:middle
于是我意识到

00:33:17.156 --> 00:33:18.926 A:middle
每一次我们使用新的算法

00:33:19.446 --> 00:33:20.326 A:middle
我们都依靠他的文档

00:33:20.326 --> 00:33:21.936 A:middle
得出关于

00:33:21.936 --> 00:33:23.416 A:middle
我们自己代码的

00:33:23.726 --> 00:33:25.296 A:middle
意义和效率的结论

00:33:26.346 --> 00:33:27.846 A:middle
因为大多数算法都是

00:33:27.846 --> 00:33:29.456 A:middle
由其他算法构建的

00:33:29.896 --> 00:33:32.816 A:middle
所以它们依赖于相同的东西

00:33:33.026 --> 00:33:34.826 A:middle
最近 我正在面试一位

00:33:34.826 --> 00:33:36.486 A:middle
未来的实习生并且问他

00:33:36.486 --> 00:33:38.236 A:middle
关于文档的作用

00:33:38.636 --> 00:33:40.226 A:middle
他以一个我不会忘记的

00:33:40.226 --> 00:33:41.156 A:middle
短语开始

00:33:41.966 --> 00:33:44.206 A:middle
“哦 它实在太重要了” 他说

00:33:45.646 --> 00:33:46.816 A:middle
“我们正在构建这些抽象的塔”

00:33:46.816 --> 00:33:48.996 A:middle
我在向你们复述他的话

00:33:48.996 --> 00:33:50.946 A:middle
“我们之所以能够成功构建

00:33:50.946 --> 00:33:52.286 A:middle
而无需经常检查

00:33:52.286 --> 00:33:54.086 A:middle
下面层级的内容

00:33:54.706 --> 00:33:56.036 A:middle
是因为我们构建的部分

00:33:56.036 --> 00:33:57.176 A:middle
是有文档记录的”

00:33:57.666 --> 00:34:01.966 A:middle
现在 作为一名 App 开发者

00:33:57.666 --> 00:34:01.966 A:middle
现在 作为一名 App 开发者

00:34:02.176 --> 00:34:03.746 A:middle
你正在一个塔尖上工作

00:34:03.746 --> 00:34:05.356 A:middle
这个塔贯穿了

00:34:05.356 --> 00:34:07.966 A:middle
你的系统框架 DOS

00:34:07.966 --> 00:34:09.556 A:middle
一直延伸到硬件

00:34:10.146 --> 00:34:11.216 A:middle
这是基于物理定律的

00:34:12.815 --> 00:34:14.096 A:middle
但是一旦你调用了

00:34:14.096 --> 00:34:15.936 A:middle
你自己的方法

00:34:15.936 --> 00:34:18.146 A:middle
它就成为你的基础的一部分

00:34:18.146 --> 00:34:19.666 A:middle
所以 请为你的代码写文档

00:34:20.235 --> 00:34:21.565 A:middle
顺便说一下

00:34:21.565 --> 00:34:23.946 A:middle
那位实习生被录用了

00:34:26.295 --> 00:34:26.406 A:middle
他就坐在那里

00:34:26.616 --> 00:34:28.896 A:middle
所以 我接受了提示

00:34:28.896 --> 00:34:29.936 A:middle
并把 Crusty 的新算法写入了文档

00:34:29.936 --> 00:34:32.956 A:middle
这意味着

00:34:32.956 --> 00:34:33.716 A:middle
我们可以忘记

00:34:33.716 --> 00:34:36.956 A:middle
它如何实现 并使用它

00:34:37.206 --> 00:34:38.306 A:middle
因为我们知道 “Quick Help”

00:34:38.306 --> 00:34:39.416 A:middle
拥有我们所需要的一切

00:34:41.246 --> 00:34:43.496 A:middle
现在 我也记录了 bringForward

00:34:45.956 --> 00:34:46.565 A:middle
酷

00:34:48.136 --> 00:34:49.456 A:middle
现在 因为它似乎

00:34:49.456 --> 00:34:51.626 A:middle
解决了我所有的问题

00:34:51.626 --> 00:34:53.496 A:middle
在这时 我真的很好奇

00:34:53.496 --> 00:34:55.786 A:middle
想看看在 stablePartition 里

00:34:55.786 --> 00:34:56.596 A:middle
发生了什么

00:34:57.806 --> 00:34:59.456 A:middle
结果是我得到了很好的回报

00:34:59.526 --> 00:35:01.416 A:middle
因为这是一个非常漂亮

00:34:59.526 --> 00:35:01.416 A:middle
因为这是一个非常漂亮

00:35:01.416 --> 00:35:02.486 A:middle
而且有指导意义的算法

00:35:03.766 --> 00:35:05.196 A:middle
这个公共的方法

00:35:05.196 --> 00:35:06.846 A:middle
获取集合计数

00:35:06.846 --> 00:35:10.506 A:middle
并将其传递给这个 helper 方法

00:35:10.506 --> 00:35:11.776 A:middle
该 helper 方法使用“分而治之”的策略

00:35:13.056 --> 00:35:15.136 A:middle
首先 它会处理基本情况

00:35:15.136 --> 00:35:17.276 A:middle
当计数小于 2 时

00:35:17.276 --> 00:35:18.436 A:middle
我们便结束了

00:35:18.966 --> 00:35:19.916 A:middle
我们只需要弄清楚

00:35:20.396 --> 00:35:21.656 A:middle
分区点是在

00:35:21.656 --> 00:35:23.046 A:middle
集合的开始处

00:35:23.046 --> 00:35:26.016 A:middle
或者在集合的末尾

00:35:26.116 --> 00:35:28.496 A:middle
接下来 我们将集合

00:35:28.546 --> 00:35:29.416 A:middle
分成两部分

00:35:31.136 --> 00:35:33.696 A:middle
现在 在这一点上

00:35:33.746 --> 00:35:35.136 A:middle
你必须暂时相信

00:35:35.136 --> 00:35:37.146 A:middle
算法是有效的

00:35:37.146 --> 00:35:38.346 A:middle
因为我们要用 stablePartition() 处理

00:35:38.346 --> 00:35:41.446 A:middle
左半边和右半边

00:35:42.136 --> 00:35:46.766 A:middle
现在 如果你看一下这两端

00:35:46.766 --> 00:35:49.166 A:middle
你会发现

00:35:49.166 --> 00:35:50.746 A:middle
所有东西都在正确的位置

00:35:50.746 --> 00:35:54.556 A:middle
但是这个中心区段

00:35:54.556 --> 00:35:56.516 A:middle
有两个部分

00:35:56.516 --> 00:35:57.316 A:middle
需要交换

00:35:58.806 --> 00:36:01.016 A:middle
现在 它们不会总是

00:35:58.806 --> 00:36:01.016 A:middle
现在 它们不会总是

00:36:01.016 --> 00:36:03.126 A:middle
和在这个例子中一样长

00:36:03.126 --> 00:36:06.716 A:middle
幸运的是

00:36:06.716 --> 00:36:07.986 A:middle
“有一个算法可以使用”

00:36:08.906 --> 00:36:10.636 A:middle
我们叫它 rotate()

00:36:11.176 --> 00:36:11.276 A:middle
好的

00:36:14.466 --> 00:36:16.496 A:middle
我不打算在这里深入讨论 rotate 算法

00:36:16.496 --> 00:36:18.226 A:middle
但是它真的很漂亮

00:36:18.256 --> 00:36:19.156 A:middle
如果你感兴趣

00:36:19.156 --> 00:36:22.446 A:middle
你可以在与 stablePartition 同样的文件中

00:36:22.446 --> 00:36:23.436 A:middle
找到它的实现方法

00:36:24.116 --> 00:36:24.216 A:middle
好的

00:36:25.596 --> 00:36:27.146 A:middle
回到图形

00:36:28.186 --> 00:36:32.486 A:middle
现在 这个烂摊子实现了

00:36:32.696 --> 00:36:34.706 A:middle
在图形列表中拖放

00:36:34.706 --> 00:36:36.626 A:middle
这一直是我最复杂

00:36:36.626 --> 00:36:39.326 A:middle
和 Bug 最多的运算之一

00:36:40.336 --> 00:36:41.616 A:middle
我的策略是

00:36:41.616 --> 00:36:43.246 A:middle
分配临时缓冲区

00:36:44.536 --> 00:36:46.486 A:middle
然后在插入点之前

00:36:47.076 --> 00:36:48.506 A:middle
对 shapes 进行循环

00:36:48.736 --> 00:36:50.196 A:middle
提取选定的图形

00:36:50.196 --> 00:36:51.576 A:middle
并调整插入点

00:36:52.526 --> 00:36:54.086 A:middle
然后在不调整插入点的情况下

00:36:54.086 --> 00:36:55.896 A:middle
分别对其余的图形

00:36:55.896 --> 00:36:57.236 A:middle
进行循环

00:36:57.236 --> 00:36:58.596 A:middle
提取选定的图形

00:36:59.126 --> 00:37:02.916 A:middle
最后 重新插入它们

00:36:59.126 --> 00:37:02.916 A:middle
最后 重新插入它们

00:37:06.536 --> 00:37:10.726 A:middle
老实说 我有点害怕触碰代码

00:37:10.726 --> 00:37:12.156 A:middle
因为我觉得我终于做对了

00:37:12.156 --> 00:37:14.276 A:middle
距离我最后一次发现新 Bug

00:37:14.276 --> 00:37:15.536 A:middle
已经差不多有

00:37:15.536 --> 00:37:16.056 A:middle
一个星期了

00:37:16.526 --> 00:37:21.026 A:middle
但是我现在已经在这个过程中

00:37:21.026 --> 00:37:22.726 A:middle
做得很好了

00:37:23.286 --> 00:37:28.976 A:middle
所以我试着把操作可视化一次完成

00:37:29.106 --> 00:37:31.116 A:middle
嘿 看起来很熟悉

00:37:31.326 --> 00:37:34.856 A:middle
让我们再看看

00:37:35.056 --> 00:37:35.486 A:middle
嗯

00:37:36.946 --> 00:37:39.826 A:middle
假设我们先做这个

00:37:39.826 --> 00:37:40.926 A:middle
然后分别处理

00:37:40.926 --> 00:37:41.456 A:middle
各个部分

00:37:43.456 --> 00:37:44.246 A:middle
没错

00:37:44.706 --> 00:37:45.946 A:middle
这就是两个

00:37:45.946 --> 00:37:48.976 A:middle
带有反转谓词的 stablePartition

00:37:49.596 --> 00:37:51.316 A:middle
所以 这个通用的算法

00:37:51.736 --> 00:37:52.846 A:middle
被压缩到了这两行

00:37:52.886 --> 00:37:57.636 A:middle
而这是 Canvas 上剩下的

00:37:58.186 --> 00:38:01.126 A:middle
现在 让我们把它放在

00:37:58.186 --> 00:38:01.126 A:middle
现在 让我们把它放在

00:38:01.126 --> 00:38:02.426 A:middle
旧代码旁边看看

00:38:04.456 --> 00:38:07.886 A:middle
还不错 但是我们得到了

00:38:07.886 --> 00:38:10.396 A:middle
一个可重复使用的

00:38:10.766 --> 00:38:12.346 A:middle
高效文档化的通用算法

00:38:12.346 --> 00:38:13.846 A:middle
这是非常棒的

00:38:14.446 --> 00:38:21.846 A:middle
好的 这是一种需要习得的技能

00:38:21.846 --> 00:38:23.746 A:middle
审视特定于你的 App

00:38:23.746 --> 00:38:25.086 A:middle
领域的细节

00:38:25.086 --> 00:38:27.056 A:middle
了解你的代码从根本上在做什么

00:38:27.056 --> 00:38:29.126 A:middle
并在可重复使用的通用代码中

00:38:29.126 --> 00:38:31.416 A:middle
捕获这些细节

00:38:32.276 --> 00:38:33.776 A:middle
这需要实践

00:38:34.966 --> 00:38:35.636 A:middle
但是 为什么要那么麻烦呢

00:38:36.536 --> 00:38:38.636 A:middle
实践得到的答案是

00:38:38.636 --> 00:38:39.966 A:middle
因为它们是从无关的细节中

00:38:39.966 --> 00:38:41.896 A:middle
解耦出来的

00:38:42.336 --> 00:38:44.126 A:middle
通用的算法更加

00:38:44.126 --> 00:38:46.296 A:middle
可重复使用 经得起考验

00:38:46.296 --> 00:38:47.976 A:middle
甚至比对应的非通用代码

00:38:47.976 --> 00:38:48.706 A:middle
更加简洁

00:38:49.676 --> 00:38:51.336 A:middle
但我也认为

00:38:51.586 --> 00:38:53.156 A:middle
对于任何真正喜欢编程的人来说

00:38:53.296 --> 00:38:54.446 A:middle
这都是非常有益的

00:38:55.646 --> 00:38:56.996 A:middle
它是对真与美的追求

00:38:56.996 --> 00:38:59.406 A:middle
而不是抽象的

00:38:59.406 --> 00:39:01.266 A:middle
不可触及的真理

00:38:59.406 --> 00:39:01.266 A:middle
不可触及的真理

00:39:01.266 --> 00:39:02.876 A:middle
因为实际硬件的约束

00:39:02.876 --> 00:39:03.696 A:middle
让你保持诚实

00:39:04.836 --> 00:39:06.066 A:middle
就像 Crusty 常说的

00:39:07.026 --> 00:39:10.136 A:middle
“编程揭示本真”

00:39:10.346 --> 00:39:12.296 A:middle
因此 将你的计算视为

00:39:12.296 --> 00:39:14.576 A:middle
具有类型

00:39:14.576 --> 00:39:16.186 A:middle
和 App 体系结构的

00:39:16.186 --> 00:39:19.856 A:middle
具有权利和义务的 VIP

00:39:20.316 --> 00:39:22.566 A:middle
标识它 给它一个名字

00:39:22.846 --> 00:39:25.756 A:middle
对它进行单元测试

00:39:25.756 --> 00:39:27.006 A:middle
并记录它的语义和性能

00:39:27.096 --> 00:39:30.556 A:middle
最后 我想把

00:39:30.556 --> 00:39:32.366 A:middle
Sean Parent 的建议

00:39:32.366 --> 00:39:34.136 A:middle
包括上下文引用一下 作为结束语

00:39:34.676 --> 00:39:37.466 A:middle
“如果你想要提高

00:39:37.466 --> 00:39:39.146 A:middle
组织中的代码质量

00:39:39.606 --> 00:39:41.586 A:middle
请将所有的代码标准

00:39:41.586 --> 00:39:44.976 A:middle
替换为一个目标 不要单独写循环”

00:39:46.386 --> 00:39:46.696 A:middle
谢谢大家

00:39:47.516 --> 00:39:52.500 A:middle
[ 掌声 ]
