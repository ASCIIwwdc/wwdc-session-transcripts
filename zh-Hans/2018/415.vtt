WEBVTT

00:00:17.284 --> 00:00:24.291 align:middle line:0
（Xcode构建过程的后台工作
演讲415）

00:00:36.303 --> 00:00:37.571 align:middle line:-1
大家下午好

00:00:38.172 --> 00:00:41.508 align:middle line:-2
欢迎来到
Xcode构建过程的后台工作

00:00:41.742 --> 00:00:43.243 align:middle line:-1
我是Jake Petroules

00:00:43.310 --> 00:00:45.612 align:middle line:-2
我是Xcode构建系统团队的
工程师

00:00:45.913 --> 00:00:47.548 align:middle line:-1
今天我们要讨论

00:00:47.915 --> 00:00:49.416 align:middle line:-1
Xcode构建过程

00:00:51.185 --> 00:00:54.054 align:middle line:-2
首先我要讲讲
Xcode 10的新构建系统

00:00:54.121 --> 00:00:55.756 align:middle line:-1
用Swift的scratch编写

00:00:55.822 --> 00:00:58.525 align:middle line:-1
提供更好的性能和可靠度

00:00:58.959 --> 00:01:00.194 align:middle line:-1
我们要解答如下问题

00:00:58.959 --> 00:01:00.194 align:middle line:-1
我们要解答如下问题

00:01:00.260 --> 00:01:02.496 align:middle line:-2
按住Command + B
会发生什么

00:01:02.563 --> 00:01:04.197 align:middle line:-1
如何架构构建过程

00:01:04.263 --> 00:01:06.900 align:middle line:-2
Xcode如何用
project文件的信息

00:01:06.967 --> 00:01:09.937 align:middle line:-1
决定构建过程的模型和流程

00:01:11.438 --> 00:01:13.907 align:middle line:-1
然后是编译器领域

00:01:14.541 --> 00:01:16.376 align:middle line:-1
看看Clang和Swift

00:01:16.443 --> 00:01:18.679 align:middle line:-1
怎样将源代码加入目标文件

00:01:19.179 --> 00:01:21.481 align:middle line:-2
我们会展示
头文件和模块的运行

00:01:21.582 --> 00:01:24.218 align:middle line:-1
编译器如何在代码中查找声明

00:01:24.284 --> 00:01:26.820 align:middle line:-1
以及Swift编译模型如何不同于

00:01:26.887 --> 00:01:29.489 align:middle line:-2
C、C++
和Objective-C

00:01:30.724 --> 00:01:32.593 align:middle line:-1
最后是连接器

00:01:32.893 --> 00:01:35.863 align:middle line:-1
构建过程的最后一步

00:01:36.330 --> 00:01:39.499 align:middle line:-2
我们会解释什么是符号
及其与源代码的关系

00:01:39.566 --> 00:01:42.536 align:middle line:-2
还有连接器如何将
编译器产生的目标文件

00:01:42.603 --> 00:01:44.805 align:middle line:-1
整合成最终的可执行文件

00:01:44.872 --> 00:01:46.607 align:middle line:-1
提供给app或框架

00:01:48.141 --> 00:01:49.276 align:middle line:-1
我们会使用

00:01:49.343 --> 00:01:51.078 align:middle line:-1
叫PetWall的小app样本

00:01:51.144 --> 00:01:52.980 align:middle line:-1
作为这次演讲的示例

00:01:53.146 --> 00:01:56.016 align:middle line:-2
它只是一个很小的iOS app
用来展示宠物图片

00:01:59.119 --> 00:02:02.189 align:middle line:-2
首先来了解
什么是构建过程

00:01:59.119 --> 00:02:02.189 align:middle line:-2
首先来了解
什么是构建过程

00:02:02.256 --> 00:02:05.592 align:middle line:-2
以及如何用Xcode
创建类似PetWall的app

00:02:06.126 --> 00:02:08.595 align:middle line:-1
这里你看到app对象、框架

00:02:08.662 --> 00:02:11.698 align:middle line:-2
不同的代码文件 都是Swift
和Objective-C

00:02:11.899 --> 00:02:14.134 align:middle line:-1
看起来可能很像你自己的项目

00:02:15.669 --> 00:02:18.105 align:middle line:-1
在构建app的时候

00:02:19.106 --> 00:02:22.009 align:middle line:-1
要经过很多步骤 从源代码

00:02:22.075 --> 00:02:23.610 align:middle line:-1
和项目资源开始

00:02:24.044 --> 00:02:25.679 align:middle line:-1
到提供给客户的打包文件

00:02:25.746 --> 00:02:28.248 align:middle line:-1
或上传到App Store发布

00:02:29.049 --> 00:02:31.785 align:middle line:-1
你要编译和连接源代码

00:02:31.885 --> 00:02:36.924 align:middle line:-2
复制和处理资源 比如头文件
资源目录和Storyboard

00:02:37.224 --> 00:02:39.927 align:middle line:-1
最后是代码签名以及自定义

00:02:39.993 --> 00:02:41.595 align:middle line:-1
shell脚本或make文件

00:02:41.662 --> 00:02:44.398 align:middle line:-1
比如给框架构建API文件

00:02:44.531 --> 00:02:47.267 align:middle line:-1
运行代码检查和验证工具等

00:02:48.402 --> 00:02:49.703 align:middle line:-1
大多数任务

00:02:49.770 --> 00:02:52.339 align:middle line:-2
在构建过程中
由命令行工具运行

00:02:52.406 --> 00:02:56.910 align:middle line:-2
比如Clang、LD、AC工具
IB工具、代码符号等

00:02:57.444 --> 00:02:59.112 align:middle line:-1
这些工具的执行

00:02:59.179 --> 00:03:00.948 align:middle line:-1
需要一组特定的实参

00:02:59.179 --> 00:03:00.948 align:middle line:-1
需要一组特定的实参

00:03:01.181 --> 00:03:02.616 align:middle line:-1
以特定的顺序

00:03:02.683 --> 00:03:05.018 align:middle line:-1
基于Xcode项目的配置

00:03:06.620 --> 00:03:08.188 align:middle line:-1
构建系统的用处

00:03:08.255 --> 00:03:11.258 align:middle line:-1
就是将任务的执行部署自动化

00:03:11.358 --> 00:03:12.926 align:middle line:-1
在每次构建的时候

00:03:13.460 --> 00:03:16.096 align:middle line:-1
由于任务数量成千上万

00:03:16.163 --> 00:03:18.232 align:middle line:-1
构建过程更是数不胜数

00:03:18.298 --> 00:03:20.534 align:middle line:-1
依赖关系十分复杂

00:03:20.701 --> 00:03:22.302 align:middle line:-1
你肯定不想手动输入

00:03:22.369 --> 00:03:24.304 align:middle line:-1
1天敲100遍命令

00:03:25.472 --> 00:03:27.508 align:middle line:-1
那就让构建系统来做

00:03:29.409 --> 00:03:32.079 align:middle line:-2
我说过
构建系统里的任务

00:03:32.145 --> 00:03:34.181 align:middle line:-1
按照特定的顺序进行

00:03:34.381 --> 00:03:37.718 align:middle line:-2
因此我们谈谈这个顺序
怎么决定及其重要性

00:03:38.785 --> 00:03:40.654 align:middle line:-1
构建任务的执行顺序

00:03:40.721 --> 00:03:43.223 align:middle line:-1
取决于信息的依赖关系

00:03:43.290 --> 00:03:44.424 align:middle line:-1
就是任务

00:03:44.725 --> 00:03:46.460 align:middle line:-1
任务需要的输入

00:03:46.693 --> 00:03:48.428 align:middle line:-1
和任务生成的输出

00:03:49.329 --> 00:03:51.164 align:middle line:-1
以编译任务为例

00:03:51.231 --> 00:03:55.402 align:middle line:-2
它需要输入源代码文件
比如PetController.m

00:03:55.469 --> 00:03:59.373 align:middle line:-2
然后输出目标文件
比如PetController.o

00:04:00.340 --> 00:04:01.942 align:middle line:-1
同样 连接器任务

00:04:02.009 --> 00:04:03.911 align:middle line:-1
需要几个目标文件

00:04:03.977 --> 00:04:06.146 align:middle line:-1
由编译器在上个任务中生成

00:04:06.380 --> 00:04:08.949 align:middle line:-1
再生成可执行或lib文件

00:04:09.016 --> 00:04:11.852 align:middle line:-2
比如PetWall运行文件
会存到.app资源文件包

00:04:12.219 --> 00:04:15.322 align:middle line:-1
希望大家已经看出些许端倪

00:04:15.989 --> 00:04:19.726 align:middle line:-2
你能看到信息的依赖关系
是顺着这个图形的走向

00:04:19.793 --> 00:04:22.529 align:middle line:-1
最终形成执行顺序

00:04:22.963 --> 00:04:25.933 align:middle line:-2
现在大家关注下
图形中的编译任务

00:04:25.999 --> 00:04:28.468 align:middle line:-1
很像川流不息的马路

00:04:28.569 --> 00:04:30.237 align:middle line:-1
你看得到编译任务

00:04:30.504 --> 00:04:34.474 align:middle line:-2
在各自的路上互不干涉
可以平行运行

00:04:35.375 --> 00:04:37.911 align:middle line:-2
因为连接器任务
需要所有其他的输入

00:04:38.011 --> 00:04:39.413 align:middle line:-1
它要在最后一位

00:04:41.348 --> 00:04:44.017 align:middle line:-1
构建系统通过依赖关系

00:04:44.084 --> 00:04:46.653 align:middle line:-1
决定任务执行的顺序

00:04:46.720 --> 00:04:49.089 align:middle line:-1
以及平行运行的任务

00:04:49.156 --> 00:04:51.091 align:middle line:-1
我们叫做依赖顺序

00:04:51.658 --> 00:04:53.861 align:middle line:-1
知道了构建过程的定义后

00:04:53.961 --> 00:04:57.097 align:middle line:-1
我们具体讲讲怎么操作

00:04:57.164 --> 00:04:59.700 align:middle line:-1
点击“构建”会发生什么？

00:05:00.434 --> 00:05:03.570 align:middle line:-1
构建系统的第一步是获取构建描述

00:05:03.637 --> 00:05:05.138 align:middle line:-1
Xcode项目文件

00:05:05.239 --> 00:05:08.742 align:middle line:-1
解析项目中的所有文件

00:05:08.809 --> 00:05:11.178 align:middle line:-1
目标app和依赖关系

00:05:11.245 --> 00:05:12.246 align:middle line:-1
构建设置

00:05:12.779 --> 00:05:15.816 align:middle line:-1
转换成一个树形结构叫做定向图

00:05:16.283 --> 00:05:17.985 align:middle line:-1
它显示了所有依赖关系

00:05:18.051 --> 00:05:20.821 align:middle line:-1
项目中的输入和输出文件

00:05:20.954 --> 00:05:23.957 align:middle line:-1
以及处理它们的执行任务

00:05:26.159 --> 00:05:29.596 align:middle line:-1
然后低级执行引擎会处理这张图

00:05:29.663 --> 00:05:34.368 align:middle line:-1
研究依赖关系 决定执行哪个任务

00:05:34.601 --> 00:05:36.770 align:middle line:-1
执行顺序是什么

00:05:36.837 --> 00:05:39.206 align:middle line:-1
以及哪些可以平行运行

00:05:39.273 --> 00:05:41.742 align:middle line:-1
然后继续执行任务

00:05:42.609 --> 00:05:44.711 align:middle line:-1
我说的低级执行引擎

00:05:44.778 --> 00:05:46.380 align:middle line:-2
是新构建系统的
叫做llbuild

00:05:46.446 --> 00:05:48.615 align:middle line:-1
它是开源资源 用GitHub开发

00:05:48.715 --> 00:05:50.517 align:middle line:-1
如果对构建系统开发感兴趣

00:05:50.584 --> 00:05:52.619 align:middle line:-1
请随意研究 看看它如何工作

00:05:52.819 --> 00:05:54.821 align:middle line:-1
它的链接和另一个关于构建系统的

00:05:54.888 --> 00:05:57.124 align:middle line:-1
开源模块 会在演讲最后提到

00:05:58.292 --> 00:06:01.161 align:middle line:-1
现在讲讲已知的依赖关系

00:05:58.292 --> 00:06:01.161 align:middle line:-1
现在讲讲已知的依赖关系

00:06:01.495 --> 00:06:04.331 align:middle line:-1
由于你无法获取过多的依赖关系信息

00:06:04.531 --> 00:06:07.167 align:middle line:-1
构建系统可能会找到更多

00:06:07.234 --> 00:06:09.203 align:middle line:-1
在任务的执行过程中

00:06:09.703 --> 00:06:12.906 align:middle line:-2
比如Clang编译
Objective-C文件时

00:06:12.973 --> 00:06:15.209 align:middle line:-1
如你所料 会生成目标文件

00:06:15.576 --> 00:06:17.778 align:middle line:-1
但是它也会生成另一个文件

00:06:18.445 --> 00:06:19.646 align:middle line:-1
其中包含一个列表

00:06:19.713 --> 00:06:22.249 align:middle line:-1
列出源文件中的头文件

00:06:22.749 --> 00:06:24.351 align:middle line:-1
那么下次构建时

00:06:24.418 --> 00:06:27.020 align:middle line:-1
构建系统会使用这个文件中的信息

00:06:27.087 --> 00:06:29.323 align:middle line:-1
以保证再次编译源文件

00:06:29.389 --> 00:06:32.292 align:middle line:-1
如果你更改了其中任何头文件的话

00:06:32.559 --> 00:06:35.629 align:middle line:-2
这里的关系路径是
PetController.h

00:06:35.696 --> 00:06:39.066 align:middle line:-2
PetController.d
.n直到.o文件

00:06:40.300 --> 00:06:42.970 align:middle line:-1
我们已经讲了很多

00:06:43.170 --> 00:06:47.140 align:middle line:-1
构建系统的主要工作就是执行任务

00:06:47.908 --> 00:06:51.778 align:middle line:-1
当然项目越大 构建时间越长

00:06:52.012 --> 00:06:53.981 align:middle line:-1
你肯定不想把所有任务都运行一遍

00:06:54.047 --> 00:06:55.549 align:middle line:-1
在每次构建的时候

00:06:56.049 --> 00:06:58.418 align:middle line:-1
构建系统实际上可以只执行

00:06:58.485 --> 00:07:00.954 align:middle line:-1
定向图上的任务子集

00:06:58.485 --> 00:07:00.954 align:middle line:-1
定向图上的任务子集

00:07:02.789 --> 00:07:04.992 align:middle line:-1
基于你对项目做出的更改

00:07:05.192 --> 00:07:06.527 align:middle line:-1
对比上次构建过程

00:07:07.127 --> 00:07:09.663 align:middle line:-1
我们称之为累加构建

00:07:09.863 --> 00:07:12.766 align:middle line:-1
准确的依赖关系十分重要

00:07:12.833 --> 00:07:16.069 align:middle line:-1
这样累加构建才能正确高效地工作

00:07:17.971 --> 00:07:20.174 align:middle line:-2
下面看看哪些更改
会影响构建系统

00:07:20.240 --> 00:07:22.009 align:middle line:-1
以及与累加构建的关系

00:07:22.075 --> 00:07:24.778 align:middle line:-1
构建系统如何检测更改呢？

00:07:26.013 --> 00:07:28.949 align:middle line:-2
构建过程中的每个任务
都有相应的签名

00:07:29.116 --> 00:07:30.751 align:middle line:-2
类似于Hash
通过计算

00:07:30.817 --> 00:07:33.120 align:middle line:-1
多个任务相关信息而得出

00:07:34.755 --> 00:07:37.691 align:middle line:-2
这些信息包括
任务输入的统计信息

00:07:37.758 --> 00:07:40.327 align:middle line:-2
比如文件路径
和更改时间标签

00:07:40.494 --> 00:07:43.797 align:middle line:-1
运行命令的命令行指示

00:07:43.864 --> 00:07:45.465 align:middle line:-1
以及其他有关任务的元数据

00:07:45.532 --> 00:07:48.035 align:middle line:-1
比如编译器版本

00:07:49.503 --> 00:07:52.072 align:middle line:-1
构建系统会追踪任务签名

00:07:52.139 --> 00:07:54.074 align:middle line:-1
包括当前和之前的构建

00:07:54.141 --> 00:07:57.911 align:middle line:-2
所以它知道每次构建时
是否要重新运行任务

00:07:59.046 --> 00:08:00.447 align:middle line:-1
如果某个任务的签名

00:07:59.046 --> 00:08:00.447 align:middle line:-1
如果某个任务的签名

00:08:00.514 --> 00:08:03.350 align:middle line:-1
与上次构建时不同

00:08:03.417 --> 00:08:05.619 align:middle line:-1
它就会重新运行这个任务

00:08:06.019 --> 00:08:08.288 align:middle line:-1
如果相同就会跳过

00:08:08.922 --> 00:08:11.792 align:middle line:-1
这就是累加构建的概念

00:08:12.893 --> 00:08:14.595 align:middle line:-1
我们大概了解了

00:08:14.661 --> 00:08:17.164 align:middle line:-1
构建过程的定义和流程

00:08:17.431 --> 00:08:19.566 align:middle line:-1
如何利用构建系统呢？

00:08:21.134 --> 00:08:22.769 align:middle line:-1
先回顾下基本知识

00:08:23.036 --> 00:08:27.574 align:middle line:-2
构建系统按照一定顺序
执行一系列任务

00:08:27.641 --> 00:08:30.477 align:middle line:-2
但要记得
构建过程以定向图表示

00:08:31.879 --> 00:08:35.315 align:middle line:-2
我们不要担心
任务执行的顺序

00:08:35.381 --> 00:08:37.150 align:middle line:-1
这是构建系统的工作

00:08:37.717 --> 00:08:39.419 align:middle line:-1
作为开发者

00:08:39.486 --> 00:08:42.155 align:middle line:-2
我们要考虑的是
任务之间的依赖关系

00:08:42.389 --> 00:08:44.691 align:middle line:-2
让构建系统决定
最佳的执行方法

00:08:44.758 --> 00:08:46.360 align:middle line:-1
根据定向图结构

00:08:46.894 --> 00:08:49.329 align:middle line:-2
这样构建系统
可以正确地给任务排序

00:08:49.396 --> 00:08:50.931 align:middle line:-1
可能的时候并排运行

00:08:50.998 --> 00:08:53.800 align:middle line:-1
以完全利用多核硬件

00:08:54.968 --> 00:08:56.937 align:middle line:-1
依赖关系源自哪里呢？

00:08:57.271 --> 00:08:58.238 align:middle line:-1
对某些任务

00:08:58.305 --> 00:09:00.240 align:middle line:-1
依赖关系

00:08:58.305 --> 00:09:00.240 align:middle line:-1
依赖关系

00:09:00.307 --> 00:09:01.608 align:middle line:-1
来自构建系统自带的数据

00:09:01.842 --> 00:09:05.179 align:middle line:-2
构建系统自带一些规则
比如编译器、连接器

00:09:05.245 --> 00:09:08.315 align:middle line:-2
资源目录
Storyboard处理器等等

00:09:08.549 --> 00:09:11.618 align:middle line:-2
这些规则定义了
哪些是输入文件

00:09:11.685 --> 00:09:13.720 align:middle line:-1
和哪些是输出文件

00:09:15.422 --> 00:09:17.157 align:middle line:-1
还有目标依赖关系

00:09:17.224 --> 00:09:19.993 align:middle line:-2
大致决定了
目标构建的顺序

00:09:20.160 --> 00:09:21.395 align:middle line:-1
有些时候

00:09:21.461 --> 00:09:24.498 align:middle line:-2
构建系统可以编译
不同目标和平行文件

00:09:24.798 --> 00:09:27.034 align:middle line:-2
之前的Xcode
要构建一个app

00:09:27.100 --> 00:09:29.403 align:middle line:-1
就要完成整个app的构建

00:09:29.469 --> 00:09:31.605 align:middle line:-1
然后才能使用

00:09:32.072 --> 00:09:35.609 align:middle line:-2
Xcode X的新构建系统
就要快得多

00:09:35.776 --> 00:09:38.345 align:middle line:-1
编译源阶段会提前开始

00:09:38.412 --> 00:09:40.881 align:middle line:-1
免费提供并行

00:09:41.114 --> 00:09:44.117 align:middle line:-2
但是如果含有
任何运行脚本阶段

00:09:44.184 --> 00:09:45.686 align:middle line:-1
这些阶段完成后

00:09:45.752 --> 00:09:48.155 align:middle line:-1
并行才能开始

00:09:49.389 --> 00:09:52.826 align:middle line:-1
有关依赖的还有隐性依赖关系

00:09:53.293 --> 00:09:55.495 align:middle line:-2
比如在链接库里
列出一个目标

00:09:55.562 --> 00:09:56.864 align:middle line:-1
用二进制构建阶段

00:09:57.331 --> 00:10:00.033 align:middle line:-2
隐性依赖关系
由scheme编辑器生成

00:09:57.331 --> 00:10:00.033 align:middle line:-2
隐性依赖关系
由scheme编辑器生成

00:10:00.100 --> 00:10:01.502 align:middle line:-1
默认为开启

00:10:01.635 --> 00:10:04.571 align:middle line:-2
构建系统会为这个目标
建立隐性依赖关系

00:10:04.638 --> 00:10:06.840 align:middle line:-1
即便它不在目标依赖关系之列

00:10:08.442 --> 00:10:10.577 align:middle line:-1
接下来是构建阶段依赖

00:10:10.911 --> 00:10:11.812 align:middle line:-1
在目标编辑器里

00:10:11.879 --> 00:10:13.881 align:middle line:-1
你会看到几个构建阶段

00:10:14.014 --> 00:10:18.652 align:middle line:-2
复制头文件、编译源
复制资源包等等

00:10:19.086 --> 00:10:21.154 align:middle line:-1
这些任务与每个阶段相关

00:10:21.221 --> 00:10:22.489 align:middle line:-1
通常按组运行

00:10:22.556 --> 00:10:24.892 align:middle line:-1
根据阶段的排列顺序

00:10:25.025 --> 00:10:27.494 align:middle line:-2
构建系统也会忽略它
如果有更好的方法

00:10:27.561 --> 00:10:30.797 align:middle line:-1
比如第三方静态库阶段

00:10:30.864 --> 00:10:32.533 align:middle line:-1
在编译源之前

00:10:33.033 --> 00:10:35.435 align:middle line:-2
注意有的时候
构建阶段顺序不对

00:10:35.502 --> 00:10:37.137 align:middle line:-1
会导致问题或构建失败

00:10:37.204 --> 00:10:38.705 align:middle line:-1
因此为了解依赖关系

00:10:38.772 --> 00:10:41.575 align:middle line:-1
验证构建阶段的顺序

00:10:42.943 --> 00:10:45.112 align:middle line:-1
还有scheme顺序依赖

00:10:45.345 --> 00:10:47.347 align:middle line:-2
如果开启了
并行构建检查

00:10:47.414 --> 00:10:48.615 align:middle line:-1
在方案设置里

00:10:48.682 --> 00:10:50.250 align:middle line:-1
构建性能会更好

00:10:50.317 --> 00:10:52.886 align:middle line:-1
不用担心目标顺序

00:10:52.953 --> 00:10:55.489 align:middle line:-2
但如果关闭
并行构建

00:10:55.556 --> 00:10:59.026 align:middle line:-2
Xcode构建目标时
会按照你排列的

00:10:59.092 --> 00:11:01.461 align:middle line:-2
构建行动顺序
逐个构建

00:10:59.092 --> 00:11:01.461 align:middle line:-2
构建行动顺序
逐个构建

00:11:01.962 --> 00:11:04.131 align:middle line:-2
目标依赖关系
优先级较高

00:11:04.198 --> 00:11:05.866 align:middle line:-2
优先决定
第一个构建目标

00:11:05.933 --> 00:11:08.235 align:middle line:-1
但Xcode会遵从这个排列

00:11:08.569 --> 00:11:12.272 align:middle line:-2
这个让人跃跃欲试
因为它给出了可预期的构建顺序

00:11:12.339 --> 00:11:14.575 align:middle line:-1
即使依赖关系有误

00:11:14.708 --> 00:11:17.511 align:middle line:-2
但这样会牺牲
大量并行空间

00:11:17.711 --> 00:11:19.012 align:middle line:-1
延缓构建速度

00:11:19.179 --> 00:11:22.216 align:middle line:-2
所以我们推荐
开启并行构建

00:11:22.282 --> 00:11:25.519 align:middle line:-2
正确设置依赖关系
不要依赖排序

00:11:27.521 --> 00:11:30.224 align:middle line:-1
最后 依赖关系在于你自己

00:11:30.290 --> 00:11:31.291 align:middle line:-1
开发者

00:11:32.759 --> 00:11:35.863 align:middle line:-2
你可以自定义shell脚本
构建阶段或规则

00:11:35.929 --> 00:11:38.866 align:middle line:-2
明确告诉构建系统
输入和输入都是什么

00:11:39.032 --> 00:11:42.536 align:middle line:-2
以避免重复运行
不必要的脚本任务

00:11:42.603 --> 00:11:45.472 align:middle line:-1
保证正确执行顺序

00:11:45.739 --> 00:11:48.942 align:middle line:-2
你可以用运行脚本阶段编辑器
定义输入和输出

00:11:49.009 --> 00:11:50.077 align:middle line:-1
这些文件的路径

00:11:50.143 --> 00:11:53.113 align:middle line:-2
将作为环境变量
在脚本中激活

00:11:54.681 --> 00:11:58.252 align:middle line:-2
不要依赖项目里
目标依赖关系的自动连接

00:11:58.652 --> 00:12:00.687 align:middle line:-2
Clang编译器
有自动关联功能

00:11:58.652 --> 00:12:00.687 align:middle line:-2
Clang编译器
有自动关联功能

00:12:00.754 --> 00:12:04.324 align:middle line:-2
在构建设置中
自动使用关联框架

00:12:04.525 --> 00:12:07.327 align:middle line:-1
让编译器自动连接框架

00:12:07.394 --> 00:12:09.329 align:middle line:-1
对应导入的模块

00:12:09.396 --> 00:12:13.166 align:middle line:-2
不用在连接库的
构建阶段再明确表示

00:12:13.333 --> 00:12:14.501 align:middle line:-1
但是要注意

00:12:14.568 --> 00:12:16.770 align:middle line:-2
自动关联
不会建立依赖关系

00:12:16.837 --> 00:12:18.805 align:middle line:-1
在构建系统层级

00:12:18.939 --> 00:12:20.974 align:middle line:-2
所以它不能保证
依赖的目标

00:12:21.041 --> 00:12:24.011 align:middle line:-1
在关联之前已经建好

00:12:25.312 --> 00:12:29.216 align:middle line:-1
所以它只能用于平台STK的框架

00:12:29.283 --> 00:12:31.084 align:middle line:-2
比如
Foundation或UIKit

00:12:31.151 --> 00:12:34.354 align:middle line:-2
因为我们知道
它们在构建前就已经存在

00:12:34.721 --> 00:12:36.256 align:middle line:-1
你自己项目里的目标

00:12:36.323 --> 00:12:38.559 align:middle line:-1
要保证明确的库依赖关系

00:12:40.460 --> 00:12:42.296 align:middle line:-1
你也许需要创建项目引用

00:12:42.362 --> 00:12:44.398 align:middle line:-1
将另一个Xcode项目拖放到

00:12:44.464 --> 00:12:46.200 align:middle line:-1
项目文件导航

00:12:46.700 --> 00:12:49.503 align:middle line:-2
说明与其他项目的
目标文件的依赖关系

00:12:51.772 --> 00:12:54.508 align:middle line:-2
总结来说
有了准确的依赖关系

00:12:54.575 --> 00:12:56.944 align:middle line:-2
构建系统就能
更好地并行构建任务

00:12:57.077 --> 00:12:59.746 align:middle line:-1
保证每次构建的结果一致

00:12:59.980 --> 00:13:03.450 align:middle line:-2
这样就能减少构建用时
给开发多点时间

00:12:59.980 --> 00:13:03.450 align:middle line:-2
这样就能减少构建用时
给开发多点时间

00:13:04.218 --> 00:13:06.086 align:middle line:-1
想知道更多快速构建的内容

00:13:06.153 --> 00:13:08.922 align:middle line:-2
如何最大化利用
崭新的iMac Pro内核

00:13:08.989 --> 00:13:12.159 align:middle line:-2
推荐观看演讲
用Xcode加速构建过程

00:13:12.559 --> 00:13:14.561 align:middle line:-2
现在
我要有请Jurgen

00:13:14.628 --> 00:13:16.997 align:middle line:-2
他会带大家
探索编译器的世界

00:13:23.270 --> 00:13:24.204 align:middle line:-1
谢谢 Jake

00:13:26.240 --> 00:13:29.276 align:middle line:-2
现在我们要看看
后台都发生了什么

00:13:29.710 --> 00:13:32.846 align:middle line:-2
当Xcode构建系统
启动Clang编译器的时候

00:13:34.281 --> 00:13:35.148 align:middle line:-1
大家好

00:13:35.215 --> 00:13:36.283 align:middle line:-1
我是Jurgen

00:13:36.617 --> 00:13:39.253 align:middle line:-2
我是Clang前端团队的
编译器工程师

00:13:40.087 --> 00:13:43.690 align:middle line:-2
今天我要讲两个功能
大家可能已经知道了

00:13:44.291 --> 00:13:46.860 align:middle line:-1
第一个是头文件映射

00:13:47.427 --> 00:13:49.997 align:middle line:-1
我们用它传递信息

00:13:50.197 --> 00:13:52.966 align:middle line:-2
从Xcode构建系统
到Clang编译器

00:13:54.067 --> 00:13:56.803 align:middle line:-1
第二个是Clang模块

00:13:57.204 --> 00:13:59.706 align:middle line:-1
我们用它加快构建的速度

00:14:01.041 --> 00:14:04.144 align:middle line:-1
在坐有些人可能只用Swift

00:14:04.645 --> 00:14:05.812 align:middle line:-1
我想告诉你

00:14:06.246 --> 00:14:08.448 align:middle line:-1
Swift在后台也用Clang

00:14:08.849 --> 00:14:11.485 align:middle line:-1
所以你们应该也会感兴趣

00:14:14.621 --> 00:14:15.722 align:middle line:-1
什么Clang？

00:14:16.990 --> 00:14:19.560 align:middle line:-2
Clang是Apple的
官方编译器

00:14:20.027 --> 00:14:23.764 align:middle line:-1
用于所有C语言

00:14:24.264 --> 00:14:28.035 align:middle line:-2
比如C、C++
当然还有Objective-C

00:14:28.135 --> 00:14:30.838 align:middle line:-1
大部分框架都在用的语言

00:14:32.472 --> 00:14:34.107 align:middle line:-1
Jake刚才提过

00:14:35.342 --> 00:14:38.078 align:middle line:-2
编译器一次性
编辑所有输入文件

00:14:38.145 --> 00:14:40.414 align:middle line:-1
生成仅一个输出文件

00:14:40.581 --> 00:14:42.482 align:middle line:-1
之后被连接器使用

00:14:43.417 --> 00:14:47.354 align:middle line:-1
如果要从OS访问API

00:14:47.888 --> 00:14:53.060 align:middle line:-2
或从自己的代码
访问实现文件

00:14:53.427 --> 00:14:56.430 align:middle line:-2
就需要一个叫做
头文件的东西

00:14:57.531 --> 00:14:59.733 align:middle line:-1
头文件是一种承诺

00:15:00.434 --> 00:15:04.638 align:middle line:-2
承诺在其他地方
存在这个实现文件

00:15:04.805 --> 00:15:06.173 align:middle line:-1
它们通常可以匹配

00:15:07.207 --> 00:15:10.611 align:middle line:-1
如果你只更新实现文件

00:15:10.911 --> 00:15:13.413 align:middle line:-2
而忘记头文件
你就食言了

00:15:14.381 --> 00:15:17.718 align:middle line:-2
通常这个问题
不会在编译过程中出现

00:15:17.885 --> 00:15:19.987 align:middle line:-1
因为编译器相信你的承诺

00:15:20.387 --> 00:15:23.090 align:middle line:-1
问题出在链接过程

00:15:24.791 --> 00:15:28.095 align:middle line:-2
编译器通常包含
不止一个头文件

00:15:28.495 --> 00:15:31.798 align:middle line:-2
而且所有编译器
都是这样被调用

00:15:32.366 --> 00:15:35.769 align:middle line:-1
以样本app为例

00:15:35.836 --> 00:15:38.105 align:middle line:-1
看看怎么处理头文件

00:15:40.507 --> 00:15:41.475 align:middle line:-1
这个PetWall

00:15:42.242 --> 00:15:44.311 align:middle line:-1
是多语言app

00:15:44.945 --> 00:15:47.648 align:middle line:-2
app本身
用Swift编写

00:15:48.649 --> 00:15:52.553 align:middle line:-2
框架的语言是
Objective-C

00:15:52.953 --> 00:15:55.422 align:middle line:0
它有个兼容库
美学档案

00:15:55.789 --> 00:15:58.325 align:middle line:0
是C++语言

00:16:00.160 --> 00:16:02.896 align:middle line:-2
时间越长
app内容越多

00:16:02.963 --> 00:16:07.801 align:middle line:-2
所以要重新组织
方便查找文件

00:16:08.135 --> 00:16:09.069 align:middle line:-1
比如

00:16:09.336 --> 00:16:12.806 align:middle line:-2
将所有跟猫有关的文件
移动到子文件

00:16:16.243 --> 00:16:20.147 align:middle line:-1
不要改变任何实现文件

00:16:20.681 --> 00:16:22.249 align:middle line:-1
也是可以的

00:16:22.983 --> 00:16:25.252 align:middle line:-1
那么你想

00:16:26.353 --> 00:16:29.590 align:middle line:-1
Clang是如何找到头文件的

00:16:32.492 --> 00:16:34.094 align:middle line:-1
举个简单的例子

00:16:34.628 --> 00:16:36.697 align:middle line:-1
这是一个实现文件

00:16:37.497 --> 00:16:38.665 align:middle line:-1
在这个代码里

00:16:38.966 --> 00:16:41.902 align:middle line:-2
包含一个头文件
命名为cat.h

00:16:43.103 --> 00:16:46.306 align:middle line:-1
怎么知道Clang做了什么

00:16:46.874 --> 00:16:49.643 align:middle line:-1
一是查看构建日志

00:16:50.711 --> 00:16:56.049 align:middle line:-2
看看Xcode构建系统
在编译这个文件时做了什么

00:16:56.283 --> 00:16:58.252 align:middle line:-1
复制粘贴这个调用代码

00:16:59.119 --> 00:17:02.956 align:middle line:-2
打开命令窗口
输入-v选项

00:16:59.119 --> 00:17:02.956 align:middle line:-2
打开命令窗口
输入-v选项

00:17:03.790 --> 00:17:05.492 align:middle line:-1
-v代表显示

00:17:05.858 --> 00:17:08.795 align:middle line:-1
然后Clang会返回很多信息

00:17:09.396 --> 00:17:12.165 align:middle line:-1
我们只要关注一个

00:17:12.598 --> 00:17:13.567 align:middle line:-1
搜索路径

00:17:15.202 --> 00:17:16.537 align:middle line:-1
我说搜索路径

00:17:17.069 --> 00:17:19.806 align:middle line:-1
大家想到的可能是

00:17:20.107 --> 00:17:23.710 align:middle line:-1
指向源代码的搜索路径

00:17:24.877 --> 00:17:26.713 align:middle line:-1
不是这样的

00:17:27.347 --> 00:17:28.182 align:middle line:-1
相反

00:17:28.615 --> 00:17:30.684 align:middle line:-2
你会看到这个
headermaps

00:17:30.751 --> 00:17:32.252 align:middle line:-1
（寻找猫咪）

00:17:32.319 --> 00:17:36.356 align:middle line:-2
Headermaps
由Xcode构建系统创建

00:17:36.690 --> 00:17:39.493 align:middle line:-1
说明头文件的位置

00:17:40.494 --> 00:17:41.595 align:middle line:-1
仔细看下

00:17:41.662 --> 00:17:45.599 align:middle line:-2
这是最重要的两个
headermap文件

00:17:47.868 --> 00:17:50.637 align:middle line:-1
前两行只是

00:17:51.605 --> 00:17:53.874 align:middle line:-1
插入了框架名称

00:17:54.808 --> 00:17:55.742 align:middle line:-1
给头文件

00:17:56.210 --> 00:17:59.112 align:middle line:-2
这两个头文件
原来是公共文件

00:18:02.349 --> 00:18:05.018 align:middle line:-2
我建议
不要依赖这个功能

00:18:05.385 --> 00:18:06.220 align:middle line:-1
原因是…

00:18:07.487 --> 00:18:10.891 align:middle line:-2
把它放在这里
是为了让现有项目持续运行

00:18:11.625 --> 00:18:15.095 align:middle line:-2
但之后使用Clang模块时
可能会出现问题

00:18:15.462 --> 00:18:20.701 align:middle line:-2
所以我们建议
自己标出框架名称

00:18:20.934 --> 00:18:23.871 align:middle line:-1
在将公共或私有头文件

00:18:23.937 --> 00:18:25.606 align:middle line:-1
从自己的框架中导入时

00:18:27.341 --> 00:18:29.776 align:middle line:-1
第三行是项目头文件

00:18:30.110 --> 00:18:32.145 align:middle line:-1
这个例子中并不需要

00:18:32.746 --> 00:18:33.580 align:middle line:-1
而且…

00:18:33.647 --> 00:18:38.519 align:middle line:-2
headermap是为了
连接回源代码

00:18:39.887 --> 00:18:40.754 align:middle line:-1
如你所见

00:18:40.821 --> 00:18:43.524 align:middle line:-1
公共和私有头文件的操作一样

00:18:44.224 --> 00:18:46.693 align:middle line:-1
总是回归源代码

00:18:46.760 --> 00:18:50.430 align:middle line:-1
这是为了让Clang生成

00:18:50.797 --> 00:18:52.799 align:middle line:-1
有用的报错信息

00:18:53.100 --> 00:18:55.536 align:middle line:-1
用于源目录文件

00:18:55.936 --> 00:18:58.772 align:middle line:-2
而不是从构建目录
复制过来的

00:18:58.839 --> 00:19:00.107 align:middle line:-1
其他内容

00:18:58.839 --> 00:19:00.107 align:middle line:-1
其他内容

00:19:03.210 --> 00:19:06.613 align:middle line:-2
很多人不知道
头文件映射的存在

00:19:06.680 --> 00:19:08.182 align:middle line:-1
就会遇到某些问题

00:19:08.348 --> 00:19:09.683 align:middle line:-1
最常见的是

00:19:10.284 --> 00:19:14.221 align:middle line:-2
忘记将头文件
添加到项目

00:19:15.055 --> 00:19:19.059 align:middle line:-2
它在源目录
但不在项目里

00:19:19.259 --> 00:19:22.329 align:middle line:-2
一定保证将头文件
添加到项目

00:19:23.030 --> 00:19:24.865 align:middle line:-1
另一个问题是

00:19:26.400 --> 00:19:29.937 align:middle line:-2
如果头文件命名一样
它们会彼此重叠

00:19:31.138 --> 00:19:34.007 align:middle line:-2
所以头文件的名称
要有所区别

00:19:34.741 --> 00:19:37.377 align:middle line:-1
这对系统头文件也一样

00:19:37.744 --> 00:19:41.915 align:middle line:-2
如果项目里的本地头文件
与系统头文件名字一样

00:19:42.149 --> 00:19:43.984 align:middle line:-1
它会叠加到系统头文件上

00:19:44.418 --> 00:19:46.320 align:middle line:-1
要注意避免

00:19:47.020 --> 00:19:48.388 align:middle line:-1
提到系统头文件

00:19:48.622 --> 00:19:49.923 align:middle line:-1
怎么查找？

00:19:53.093 --> 00:19:55.062 align:middle line:0
再用PetWall演示下

00:19:56.029 --> 00:19:59.099 align:middle line:0
这里导入
Foundation.h头文件

00:19:59.166 --> 00:20:00.601 align:middle line:0
在SDK里

00:19:59.166 --> 00:20:00.601 align:middle line:0
在SDK里

00:20:01.869 --> 00:20:03.704 align:middle line:0
我们可以像之前一样

00:20:04.638 --> 00:20:06.273 align:middle line:0
就像查找自己项目的头文件

00:20:06.340 --> 00:20:07.975 align:middle line:0
但现在是系统头文件

00:20:08.809 --> 00:20:13.580 align:middle line:0
我说过头文件映射
只用于私有的头文件

00:20:13.881 --> 00:20:15.249 align:middle line:0
所以可以忽略

00:20:15.983 --> 00:20:18.318 align:middle line:0
现在关注导入路径

00:20:18.685 --> 00:20:19.520 align:middle line:0
那么

00:20:19.820 --> 00:20:23.590 align:middle line:0
默认的SDK里有两个目录

00:20:23.891 --> 00:20:25.926 align:middle line:0
第一个是用户的

00:20:26.460 --> 00:20:29.329 align:middle line:0
第二个是系统库框架

00:20:30.297 --> 00:20:31.698 align:middle line:0
先看第一个

00:20:33.433 --> 00:20:35.235 align:middle line:-1
这是正常的包含目录

00:20:35.302 --> 00:20:38.672 align:middle line:-1
我们只要输入搜索关键词

00:20:38.739 --> 00:20:41.642 align:middle line:-2
这里是
Foundation/Foundation.h

00:20:42.276 --> 00:20:44.711 align:middle line:-2
头文件没找到
因为它不在那里

00:20:45.479 --> 00:20:47.614 align:middle line:-2
没关系
再试试第二个

00:20:48.549 --> 00:20:50.851 align:middle line:-1
系统库框架

00:20:52.119 --> 00:20:54.555 align:middle line:-1
这是框架目录

00:20:54.888 --> 00:20:57.324 align:middle line:-1
所以Clang的做法会有些不同

00:20:57.391 --> 00:20:58.225 align:middle line:-1
首先…

00:20:58.825 --> 00:21:03.730 align:middle line:-2
它要确定框架的定义
看看框架是否存在

00:20:58.825 --> 00:21:03.730 align:middle line:-2
它要确定框架的定义
看看框架是否存在

00:21:05.465 --> 00:21:06.300 align:middle line:-1
然后

00:21:06.667 --> 00:21:10.003 align:middle line:-2
从头文件目录中
查找头文件

00:21:10.637 --> 00:21:12.840 align:middle line:-2
这里找到了
不错

00:21:13.674 --> 00:21:16.844 align:middle line:-1
但如果没找到呢？

00:21:17.010 --> 00:21:20.314 align:middle line:-1
比如输入不存在的假冒头文件

00:21:21.648 --> 00:21:24.418 align:middle line:-1
显然不会在头文件目录中找到

00:21:25.819 --> 00:21:28.922 align:middle line:-2
但之后它会查找
私有头文件目录

00:21:30.424 --> 00:21:34.428 align:middle line:-2
Apple的SDK中
不会带有任何私有头文件

00:21:34.962 --> 00:21:36.430 align:middle line:-1
但是你的项目

00:21:36.496 --> 00:21:39.366 align:middle line:-1
和框架中可能公共和私有头文件都有

00:21:39.733 --> 00:21:41.568 align:middle line:-1
所以也会检查

00:21:42.402 --> 00:21:45.005 align:middle line:-2
但这是个假的头文件
所以那里也没有

00:21:46.707 --> 00:21:50.010 align:middle line:-2
现在就有意思了
搜索停止了

00:21:50.377 --> 00:21:53.113 align:middle line:-1
我们不会再查找其他目录

00:21:53.413 --> 00:21:54.248 align:middle line:-1
这是因为

00:21:54.715 --> 00:21:58.352 align:middle line:-1
框架已经被找到了

00:21:59.019 --> 00:22:00.120 align:middle line:-1
一旦框架被找到

00:21:59.019 --> 00:22:00.120 align:middle line:-1
一旦框架被找到

00:22:00.187 --> 00:22:02.956 align:middle line:-2
一般框架目录里
能找到头文件

00:22:03.357 --> 00:22:05.592 align:middle line:-2
如果找不到
搜索就放弃了

00:22:07.928 --> 00:22:11.198 align:middle line:-2
如果好奇
实现文件的模样

00:22:11.632 --> 00:22:14.668 align:middle line:-2
当所有头文件
都被导入和预处理之后

00:22:15.169 --> 00:22:16.770 align:middle line:-1
你可以让Xcode

00:22:17.271 --> 00:22:22.242 align:middle line:-2
创建预处理文件
给实现文件

00:22:24.912 --> 00:22:27.214 align:middle line:-2
这会生成一个
巨大的输出文件

00:22:28.582 --> 00:22:30.684 align:middle line:-1
有多大呢？

00:22:32.853 --> 00:22:34.888 align:middle line:-1
举个简单的例子

00:22:35.923 --> 00:22:37.925 align:middle line:-1
Foundation.h是…

00:22:38.759 --> 00:22:42.229 align:middle line:-1
系统最基本的头文件

00:22:43.463 --> 00:22:45.799 align:middle line:-1
这个头文件很可能被

00:22:45.866 --> 00:22:49.203 align:middle line:-2
直接或间接地
导入其他头文件夹

00:22:49.269 --> 00:22:50.103 align:middle line:-1
就是说…

00:22:50.437 --> 00:22:51.872 align:middle line:-1
每次调用编译器

00:22:51.939 --> 00:22:54.441 align:middle line:-1
都要查找这个头文件

00:22:55.742 --> 00:22:56.910 align:middle line:-1
一天之内

00:22:57.911 --> 00:23:02.049 align:middle line:-2
Clang要查找并处理
800多个头文件夹

00:22:57.911 --> 00:23:02.049 align:middle line:-2
Clang要查找并处理
800多个头文件夹

00:23:02.282 --> 00:23:04.318 align:middle line:-1
只为一个导入声明

00:23:05.519 --> 00:23:10.891 align:middle line:-2
也就是要解析和验证
大于9兆的源代码

00:23:11.792 --> 00:23:15.062 align:middle line:-2
每次调用编译器
都是如此

00:23:15.495 --> 00:23:18.131 align:middle line:-2
这个工作量很大
很冗余

00:23:18.999 --> 00:23:19.833 align:middle line:-1
所以

00:23:20.901 --> 00:23:21.835 align:middle line:-1
怎么改善？

00:23:23.971 --> 00:23:27.875 align:middle line:-2
这里有个功能叫做
预编译头文件

00:23:27.941 --> 00:23:29.910 align:middle line:-1
这是个好办法

00:23:30.544 --> 00:23:31.812 align:middle line:-1
但还有更好的

00:23:32.145 --> 00:23:35.048 align:middle line:-2
几年前
我们发布了Clang模块

00:23:36.283 --> 00:23:40.020 align:middle line:-2
Clang模块只允许我们
为框架查找和解析头文件

00:23:40.087 --> 00:23:41.955 align:middle line:-1
一次

00:23:42.322 --> 00:23:47.528 align:middle line:-2
然后储存到硬盘
缓存并可以再利用

00:23:48.295 --> 00:23:51.031 align:middle line:-1
这可以提升构建速度

00:23:53.867 --> 00:23:54.801 align:middle line:-1
要实现它

00:23:55.369 --> 00:23:57.905 align:middle line:-2
Clang模块
要具备特定的属性

00:23:59.406 --> 00:24:02.943 align:middle line:-2
最重要的一点是
上下文无关

00:23:59.406 --> 00:24:02.943 align:middle line:-2
最重要的一点是
上下文无关

00:24:03.510 --> 00:24:05.045 align:middle line:-1
什么是上下文无关？

00:24:06.947 --> 00:24:08.982 align:middle line:-1
这有两个代码片段

00:24:09.216 --> 00:24:13.053 align:middle line:-1
两个都导入了PetKit模块

00:24:13.887 --> 00:24:18.025 align:middle line:-1
但两个宏观定义不同

00:24:19.693 --> 00:24:22.863 align:middle line:-2
如果用传统方法
导入头文件

00:24:22.930 --> 00:24:24.798 align:middle line:-1
文本也会被导入

00:24:25.299 --> 00:24:26.233 align:middle line:-1
预处理器…

00:24:26.700 --> 00:24:30.304 align:middle line:-2
会遵从这个定义
并应用到头文件夹

00:24:31.205 --> 00:24:32.239 align:middle line:-1
如果这样做

00:24:32.306 --> 00:24:34.441 align:middle line:-1
每个案例的模块

00:24:34.508 --> 00:24:37.044 align:middle line:-2
就不一样
不能重复使用

00:24:37.644 --> 00:24:38.478 align:middle line:-1
所以…

00:24:39.012 --> 00:24:41.481 align:middle line:-2
如果要使用模块
就不能这样做

00:24:41.849 --> 00:24:46.753 align:middle line:-2
模块会忽略
所有文本信息

00:24:47.120 --> 00:24:51.692 align:middle line:-2
这样就能被
所有实现文件重复使用了

00:24:54.027 --> 00:24:55.229 align:middle line:-1
另一个要求是

00:24:56.630 --> 00:24:58.465 align:middle line:-1
模块各自独立

00:24:58.932 --> 00:25:03.036 align:middle line:-2
也就是说
要明确所有依赖关系

00:24:58.932 --> 00:25:03.036 align:middle line:-2
也就是说
要明确所有依赖关系

00:25:04.104 --> 00:25:06.440 align:middle line:-1
这对你有好处

00:25:06.840 --> 00:25:09.877 align:middle line:-1
就是只要你导入一个模块

00:25:10.511 --> 00:25:11.478 align:middle line:-1
它就能工作

00:25:11.545 --> 00:25:14.314 align:middle line:-2
不用考虑还要
添加其他的头文件

00:25:14.381 --> 00:25:15.816 align:middle line:-1
才能运行

00:25:19.186 --> 00:25:22.890 align:middle line:-2
我们怎么知道
或者说Clang怎么知道

00:25:22.956 --> 00:25:24.791 align:middle line:-1
要不要创建模块呢？

00:25:25.993 --> 00:25:29.329 align:middle line:-2
看个简单的例子
NSString.h

00:25:30.531 --> 00:25:33.200 align:middle line:-1
首先Clang要找到框架里的

00:25:33.467 --> 00:25:34.735 align:middle line:-1
这个头文件

00:25:37.037 --> 00:25:38.472 align:middle line:-1
你们知道怎么做了

00:25:38.705 --> 00:25:41.275 align:middle line:-2
这是Foundation.framework
目录

00:25:42.109 --> 00:25:44.111 align:middle line:-1
然后Clang编译器

00:25:44.511 --> 00:25:46.947 align:middle line:-2
会查找模块目录
和模块映射

00:25:47.181 --> 00:25:48.782 align:middle line:-1
它与头文件目录相关

00:25:49.483 --> 00:25:50.317 align:middle line:-1
找到了

00:25:51.552 --> 00:25:53.086 align:middle line:-1
什么是模块映射？

00:25:53.420 --> 00:25:57.524 align:middle line:-2
模块映射描述了
特定的一组头文件夹

00:25:57.724 --> 00:25:59.760 align:middle line:-1
翻译到模块中

00:26:00.961 --> 00:26:01.962 align:middle line:-1
具体讲下

00:26:04.264 --> 00:26:06.066 align:middle line:-1
模块映射很简单

00:26:06.133 --> 00:26:08.502 align:middle line:-2
这是Foundation的
整个模块映射

00:26:08.569 --> 00:26:09.403 align:middle line:-1
就这些

00:26:10.437 --> 00:26:11.805 align:middle line:-1
显然它描述了

00:26:11.939 --> 00:26:14.074 align:middle line:-2
模块的名称
就是Foundation

00:26:14.875 --> 00:26:19.813 align:middle line:-2
它还说明了
哪个头文件属于该模块

00:26:20.614 --> 00:26:23.617 align:middle line:-1
这里只有一个头文件

00:26:23.684 --> 00:26:25.052 align:middle line:-1
Foundation.h

00:26:25.752 --> 00:26:28.922 align:middle line:-2
但这个头文件很特殊
这是umbrella header

00:26:28.989 --> 00:26:31.792 align:middle line:-2
用特殊关键词
umbrella标出

00:26:32.426 --> 00:26:33.260 align:middle line:-1
这是说…

00:26:33.493 --> 00:26:36.830 align:middle line:-2
Clang要查找
这个特殊的头文件

00:26:37.164 --> 00:26:41.034 align:middle line:-2
来确定NSString.h
是不是模块的一部分

00:26:42.269 --> 00:26:43.704 align:middle line:-1
耶 找到了！

00:26:44.271 --> 00:26:45.105 align:middle line:-1
好了

00:26:45.172 --> 00:26:46.940 align:middle line:-1
我们已经确定

00:26:47.007 --> 00:26:50.010 align:middle line:-2
NSString.h是
foundation模块的一部分

00:26:50.577 --> 00:26:54.181 align:middle line:-1
Clang可以升级文本输入

00:26:54.248 --> 00:26:55.649 align:middle line:-1
到模块输入

00:26:56.283 --> 00:26:59.152 align:middle line:-2
为此我们要创建
foundation模块

00:27:01.021 --> 00:27:03.090 align:middle line:-2
如何创建
foundation模块呢？

00:27:03.957 --> 00:27:04.858 align:middle line:-1
首先

00:27:05.292 --> 00:27:07.594 align:middle line:-1
为Clang单独创建位置

00:27:08.462 --> 00:27:11.698 align:middle line:-2
Clang位置里
包含的所有头文件

00:27:11.765 --> 00:27:13.267 align:middle line:-1
都属于foundation模块

00:27:15.135 --> 00:27:18.839 align:middle line:-1
我们不会转移任何现有的上下文

00:27:19.173 --> 00:27:21.275 align:middle line:-1
来自原始的编译器调用

00:27:21.508 --> 00:27:23.076 align:middle line:-1
所以说是上下文无关

00:27:24.044 --> 00:27:25.846 align:middle line:-1
实际上我们转移的

00:27:25.913 --> 00:27:28.315 align:middle line:-1
是传递给Clang的命令行实参

00:27:28.382 --> 00:27:29.583 align:middle line:-1
随后继续传递

00:27:32.152 --> 00:27:34.188 align:middle line:-1
在创建foundation模块时

00:27:36.023 --> 00:27:37.624 align:middle line:-1
模块本身或框架

00:27:37.691 --> 00:27:38.692 align:middle line:-1
框架本身…

00:27:39.393 --> 00:27:41.795 align:middle line:-1
会导入其他框架

00:27:41.995 --> 00:27:42.863 align:middle line:-1
也就是说…

00:27:43.130 --> 00:27:45.032 align:middle line:-1
我们也要构建那些模块

00:27:46.633 --> 00:27:48.001 align:middle line:-1
我们不能停顿

00:27:48.068 --> 00:27:51.438 align:middle line:-2
因为它可能还包含
其他框架

00:27:52.272 --> 00:27:54.575 align:middle line:-2
但是我们已经能看到
它的好处了

00:27:55.175 --> 00:27:57.344 align:middle line:-1
某些导入可能是一样的

00:27:57.644 --> 00:28:00.414 align:middle line:-1
所以总能重复使用那个模块

00:27:57.644 --> 00:28:00.414 align:middle line:-1
所以总能重复使用那个模块

00:28:02.883 --> 00:28:07.054 align:middle line:-2
所有模块要序列化
存到模块缓存区

00:28:09.323 --> 00:28:10.224 align:middle line:-1
我说过…

00:28:11.391 --> 00:28:15.128 align:middle line:-2
命令行实参会向后传递
在创建模块的时候

00:28:15.729 --> 00:28:16.597 align:middle line:-1
就是说…

00:28:17.364 --> 00:28:20.133 align:middle line:-1
这些实参会影响

00:28:20.601 --> 00:28:22.102 align:middle line:-1
模块的内容

00:28:22.636 --> 00:28:24.638 align:middle line:-1
所以我们要散列

00:28:25.038 --> 00:28:26.139 align:middle line:-1
这些实参

00:28:26.607 --> 00:28:30.644 align:middle line:-2
再保存这些
为特定编译器调用而创建的模块

00:28:30.811 --> 00:28:32.846 align:middle line:-1
到散列匹配的目录里

00:28:34.548 --> 00:28:37.284 align:middle line:-1
如果修改编译器实参

00:28:37.351 --> 00:28:38.752 align:middle line:-1
用不同的限制文件

00:28:39.186 --> 00:28:41.822 align:middle line:-2
比如写入
enable cat

00:28:42.823 --> 00:28:44.224 align:middle line:-1
这是不同的散列

00:28:44.491 --> 00:28:47.494 align:middle line:-1
要求Clang重新创建

00:28:47.628 --> 00:28:50.597 align:middle line:0
所有模块
且输入到那个目录

00:28:51.164 --> 00:28:52.132 align:middle line:0
匹配那个散列

00:28:53.300 --> 00:28:57.304 align:middle line:0
为了更多重复利用模块缓存

00:28:57.638 --> 00:29:02.209 align:middle line:0
你要保证实参的一致性
如果可能的话

00:28:57.638 --> 00:29:02.209 align:middle line:0
你要保证实参的一致性
如果可能的话

00:29:05.245 --> 00:29:09.516 align:middle line:0
以上就是如何查找
和创建系统框架模块

00:29:10.350 --> 00:29:12.553 align:middle line:0
但是你的框架呢？

00:29:12.853 --> 00:29:14.888 align:middle line:0
如何为它们创建模块？

00:29:16.924 --> 00:29:18.959 align:middle line:0
回到刚才猫的例子

00:29:19.393 --> 00:29:21.261 align:middle line:0
这时打开模块

00:29:23.397 --> 00:29:25.399 align:middle line:0
如果要用头文件映射

00:29:26.033 --> 00:29:30.070 align:middle line:0
它会映射到源目录

00:29:31.805 --> 00:29:34.508 align:middle line:-2
看看这个源文件
出问题了

00:29:35.409 --> 00:29:37.244 align:middle line:-1
这里没有模块目录

00:29:38.412 --> 00:29:40.013 align:middle line:-1
看上去根本不是框架

00:29:41.248 --> 00:29:44.852 align:middle line:-1
Clang现在不知所措

00:29:45.452 --> 00:29:48.455 align:middle line:-1
答案是一个新的概念

00:29:49.256 --> 00:29:51.825 align:middle line:-2
叫做
Clang的虚拟文件系统

00:29:52.526 --> 00:29:55.896 align:middle line:-2
它会创建一个
虚拟的抽象框架

00:29:56.830 --> 00:29:59.366 align:middle line:-1
方便Clang创建模块

00:29:59.933 --> 00:30:00.767 align:middle line:-1
但是…

00:29:59.933 --> 00:30:00.767 align:middle line:-1
但是…

00:30:01.168 --> 00:30:04.838 align:middle line:-1
抽象框架只能映射到目录文件

00:30:05.372 --> 00:30:06.507 align:middle line:-1
这样

00:30:06.740 --> 00:30:10.210 align:middle line:-1
Clang就能在源代码中报错

00:30:11.812 --> 00:30:13.380 align:middle line:-1
这就是创建模块的方法

00:30:13.881 --> 00:30:15.749 align:middle line:-1
在使用框架的情况下

00:30:18.352 --> 00:30:20.187 align:middle line:-2
大家记得
开始的时候我说过

00:30:20.721 --> 00:30:25.025 align:middle line:-2
如果不确定框架名字
会有问题

00:30:25.959 --> 00:30:28.562 align:middle line:-2
我们就来举个例子
看看是什么问题

00:30:30.564 --> 00:30:33.934 align:middle line:-2
这是很简单的代码样本
只有两个输入

00:30:34.001 --> 00:30:37.671 align:middle line:-2
第一个输入
PetKit模块

00:30:39.106 --> 00:30:40.541 align:middle line:-1
第二个输入

00:30:41.208 --> 00:30:44.411 align:middle line:-2
我们都知道
这是PetKit模块的一部分

00:30:45.012 --> 00:30:47.614 align:middle line:-1
但Clang可能不知道

00:30:47.981 --> 00:30:50.284 align:middle line:-2
因为你没有写明
框架的名称

00:30:51.785 --> 00:30:52.686 align:middle line:-1
这样一来

00:30:53.253 --> 00:30:57.357 align:middle line:-2
你可能会收到
重复定义的报错

00:30:57.925 --> 00:31:01.195 align:middle line:-2
这种情况常见于
将同一个头文件导入了两次

00:30:57.925 --> 00:31:01.195 align:middle line:-2
这种情况常见于
将同一个头文件导入了两次

00:31:03.163 --> 00:31:05.799 align:middle line:-1
Clang在后台辛苦工作

00:31:05.866 --> 00:31:09.336 align:middle line:-2
就为了解决
诸如此类的常见问题

00:31:10.537 --> 00:31:12.339 align:middle line:-1
但它不可能全部解决

00:31:13.240 --> 00:31:14.842 align:middle line:-1
这只是个简单的例子

00:31:15.442 --> 00:31:16.777 align:middle line:-1
稍微调整一下

00:31:18.545 --> 00:31:20.047 align:middle line:-1
修改一下上下文

00:31:21.315 --> 00:31:25.419 align:middle line:-2
模块的导入
完全不受影响

00:31:25.485 --> 00:31:28.055 align:middle line:-2
因为我说过
上下文可以忽略

00:31:29.756 --> 00:31:30.724 align:middle line:-1
cat导入

00:31:30.924 --> 00:31:33.727 align:middle line:-1
还是头文件的文本导入

00:31:33.894 --> 00:31:35.729 align:middle line:-1
它会遵循这个修改

00:31:36.330 --> 00:31:39.867 align:middle line:-1
这时可能就不是双重定义了

00:31:39.933 --> 00:31:42.269 align:middle line:-1
而是矛盾定义

00:31:42.469 --> 00:31:44.137 align:middle line:-1
无法解决

00:31:44.771 --> 00:31:46.306 align:middle line:-1
Clang解决不了

00:31:46.974 --> 00:31:47.808 align:middle line:-1
那么…

00:31:47.941 --> 00:31:49.743 align:middle line:-1
记住我的建议

00:31:49.810 --> 00:31:52.145 align:middle line:-1
永远明确框架名称

00:31:52.513 --> 00:31:55.516 align:middle line:-2
无论是导入公共的
还是私有的头文件

00:31:56.683 --> 00:31:58.218 align:middle line:-1
现在有请Devin

00:31:58.285 --> 00:32:02.256 align:middle line:-2
他为大家讲解Swift和
Swift对Clang模块的使用

00:31:58.285 --> 00:32:02.256 align:middle line:-2
他为大家讲解Swift和
Swift对Clang模块的使用

00:32:09.096 --> 00:32:09.963 align:middle line:-1
谢谢 Jurgen

00:32:11.331 --> 00:32:13.300 align:middle line:-1
我们现在要具体讲解

00:32:13.767 --> 00:32:16.770 align:middle line:-2
Swift和构建系统
如何并肩作战

00:32:17.037 --> 00:32:19.506 align:middle line:-1
在项目中查找声明

00:32:21.475 --> 00:32:23.377 align:middle line:-2
先总结下
Jurgen的演讲

00:32:23.844 --> 00:32:26.914 align:middle line:-2
Clang单独编译
每个Objective-C文件

00:32:27.781 --> 00:32:31.652 align:middle line:-2
如果你要在另一个文件夹
查找一个类

00:32:32.419 --> 00:32:35.789 align:middle line:-1
你要导入声明那个类的头文件

00:32:37.457 --> 00:32:41.061 align:middle line:-1
Swift的设计不需要写入头文件

00:32:41.562 --> 00:32:44.598 align:middle line:-1
为了方便初学者上手应用

00:32:44.865 --> 00:32:49.036 align:middle line:-2
避免了在不同文件里
重复一个声明

00:32:50.370 --> 00:32:52.039 align:middle line:-1
但这就意味着编译器

00:32:52.105 --> 00:32:54.408 align:middle line:-1
要做些额外的记录工作

00:32:54.975 --> 00:32:57.211 align:middle line:-2
下面就讲讲
记录工作怎么做

00:32:59.713 --> 00:33:01.949 align:middle line:-1
回到PetWall app

00:32:59.713 --> 00:33:01.949 align:middle line:-1
回到PetWall app

00:33:02.883 --> 00:33:05.919 align:middle line:-2
在界面控制器里
有个Swift的界面

00:33:07.020 --> 00:33:08.622 align:middle line:-2
Objective-C
app代理

00:33:09.022 --> 00:33:10.524 align:middle line:-1
和Swift单元测试

00:33:11.625 --> 00:33:12.559 align:middle line:-1
为了编译

00:33:12.626 --> 00:33:15.762 align:middle line:-2
哪怕只是上面这个
PetViewController

00:33:16.430 --> 00:33:19.266 align:middle line:-2
编译器也要
进行4个不同的运算

00:33:20.400 --> 00:33:22.803 align:middle line:-1
首先要找到声明

00:33:23.337 --> 00:33:27.641 align:middle line:-2
Swift目标里的
和来自Objective-C的

00:33:29.243 --> 00:33:33.180 align:middle line:-2
它还要生成接口
描述文件内容

00:33:33.480 --> 00:33:36.250 align:middle line:-2
以便声明可以
被找到并用于

00:33:36.316 --> 00:33:39.520 align:middle line:-2
Objective-C
和其他Swift目标

00:33:40.754 --> 00:33:42.189 align:middle line:-1
接下来的部分

00:33:42.256 --> 00:33:46.760 align:middle line:-2
我会演示这个例子
分别阐述这四个任务

00:33:47.694 --> 00:33:50.898 align:middle line:-1
首先是在Swift目标里查找声明

00:33:55.469 --> 00:33:58.138 align:middle line:-2
要编译
PetViewController.swift

00:33:58.705 --> 00:34:02.075 align:middle line:-2
编译器会查找
PetView的初始程序类型

00:33:58.705 --> 00:34:02.075 align:middle line:-2
编译器会查找
PetView的初始程序类型

00:34:02.609 --> 00:34:04.111 align:middle line:-1
以便检查调用

00:34:05.379 --> 00:34:06.947 align:middle line:-1
但在此之前

00:34:07.281 --> 00:34:09.650 align:middle line:-2
它要解析
PetView.swift

00:34:10.117 --> 00:34:11.217 align:middle line:-1
并验证

00:34:11.618 --> 00:34:14.922 align:middle line:-2
以保证初始程序的声明
是正常的

00:34:15.755 --> 00:34:17.824 align:middle line:-2
编译器很聪明
它知道

00:34:18.091 --> 00:34:21.360 align:middle line:-2
不需要检查
初始程序的主体

00:34:22.094 --> 00:34:23.931 align:middle line:-1
但它还要做些工作

00:34:23.996 --> 00:34:26.632 align:middle line:-1
处理文件的接口部分

00:34:29.803 --> 00:34:32.339 align:middle line:-1
这与Clang不同

00:34:32.840 --> 00:34:34.908 align:middle line:-1
编译一个Swift文件

00:34:35.576 --> 00:34:39.313 align:middle line:-2
编译器也要解析
目标中所有其他Swift文件

00:34:39.379 --> 00:34:42.815 align:middle line:-1
以检查与接口有关的部分

00:34:48.255 --> 00:34:51.190 align:middle line:0
在Xcode 9
这会导致重复工作

00:34:51.391 --> 00:34:53.960 align:middle line:0
在增量调试构建中

00:34:54.027 --> 00:34:57.564 align:middle line:0
因为编译器单独编译每个文件

00:34:58.332 --> 00:35:00.834 align:middle line:0
文件的编译可以并行

00:34:58.332 --> 00:35:00.834 align:middle line:0
文件的编译可以并行

00:35:01.168 --> 00:35:04.438 align:middle line:0
但它强制编译器
重复解析每个文件

00:35:05.305 --> 00:35:07.875 align:middle line:0
解析一次
作为实现文件生成.o

00:35:08.242 --> 00:35:10.711 align:middle line:0
解析多次是作为接口

00:35:11.144 --> 00:35:12.646 align:middle line:0
查找声明

00:35:14.181 --> 00:35:16.817 align:middle line:0
Xcode 10减少了这种消耗

00:35:17.451 --> 00:35:20.554 align:middle line:0
通过将文件合并成组

00:35:20.821 --> 00:35:23.190 align:middle line:0
尽可能多得分担工作

00:35:24.858 --> 00:35:27.094 align:middle line:0
在依旧最大化并行的同时

00:35:27.861 --> 00:35:30.197 align:middle line:0
在组中重复利用解析

00:35:31.164 --> 00:35:33.834 align:middle line:0
只在跨组处理时重复

00:35:34.535 --> 00:35:37.971 align:middle line:0
由于组的数量相对较少

00:35:38.372 --> 00:35:42.709 align:middle line:0
就能大幅提升
增量调试构建的速度

00:35:46.146 --> 00:35:49.716 align:middle line:-2
Swift代码
不止调用其他Swift代码

00:35:50.083 --> 00:35:51.818 align:middle line:-1
还能调用Objective-C

00:35:53.587 --> 00:35:55.455 align:middle line:-1
回到PetWall样本app

00:35:55.522 --> 00:35:58.358 align:middle line:-1
我们看到它很重要

00:35:58.458 --> 00:35:59.993 align:middle line:-1
因为它是系统框架

00:36:00.227 --> 00:36:02.896 align:middle line:-2
比如 UIKit
是Objective-C语言

00:36:06.633 --> 00:36:10.204 align:middle line:0
Swift与其他语言不一样

00:36:10.270 --> 00:36:14.408 align:middle line:0
它不需要外部功能接口

00:36:15.809 --> 00:36:17.611 align:middle line:-2
这里你一般要
比如

00:36:17.678 --> 00:36:21.915 align:middle line:-2
编写Swift声明给每个
Objective-C API

00:36:22.983 --> 00:36:23.817 align:middle line:-1
但是

00:36:23.884 --> 00:36:28.055 align:middle line:-2
编译器内置了
Clang的一大部分

00:36:28.121 --> 00:36:29.756 align:middle line:-1
用作库

00:36:30.490 --> 00:36:34.361 align:middle line:-2
这就可以直接导入
Objective-C框架

00:36:37.164 --> 00:36:39.533 align:middle line:-2
Objective-C声明
来自哪里？

00:36:40.300 --> 00:36:44.071 align:middle line:-2
导入器会查看头文件
根据目标类型

00:36:45.806 --> 00:36:49.076 align:middle line:-2
任何目标在导入
Objective-C框架时

00:36:49.943 --> 00:36:52.412 align:middle line:-2
导入器在头文件中
找到声明

00:36:52.479 --> 00:36:55.449 align:middle line:-2
显示的是
Clang对此框架的模块映射

00:36:56.950 --> 00:36:59.953 align:middle line:-2
用Swift和Objective-C
代码混编的框架

00:37:00.454 --> 00:37:03.457 align:middle line:-2
导入器在umbrella头文件中
查找声明

00:37:04.591 --> 00:37:07.294 align:middle line:-1
这个头文件定义了公共接口

00:37:08.262 --> 00:37:10.898 align:middle line:-1
这样 框架内的Swift代码

00:37:10.964 --> 00:37:14.635 align:middle line:-2
就可以调用同一框架内的
公共Objective-C代码

00:37:16.870 --> 00:37:19.173 align:middle line:-2
最后
在app和单元测试中

00:37:19.473 --> 00:37:21.975 align:middle line:-1
可以导入目标的桥接头文件

00:37:22.176 --> 00:37:25.612 align:middle line:-2
允许其中的声明
被Swift调用

00:37:28.348 --> 00:37:29.183 align:middle line:-1
现在…

00:37:29.650 --> 00:37:31.618 align:middle line:-1
导入器找到声明后

00:37:31.885 --> 00:37:34.788 align:middle line:-2
通常会修改它们
让它们变得更口语化

00:37:35.589 --> 00:37:37.891 align:middle line:-2
比如它会导入
Objective-C函数

00:37:37.958 --> 00:37:39.593 align:middle line:-1
用NSError惯用语

00:37:40.027 --> 00:37:41.662 align:middle line:-1
作为throwing函数

00:37:42.062 --> 00:37:44.798 align:middle line:-2
使用Swift内置的
错误处理语言功能

00:37:47.835 --> 00:37:50.537 align:middle line:-2
具体来说
就是输入参数类型名称

00:37:50.804 --> 00:37:52.673 align:middle line:-1
后跟动词和介词

00:37:53.907 --> 00:37:56.443 align:middle line:-2
比如函数
drawPet atPoint

00:37:56.777 --> 00:37:58.045 align:middle line:-1
带有宠物这个词

00:37:58.579 --> 00:38:00.380 align:middle line:-2
对于参数类型
宠物

00:37:58.579 --> 00:38:00.380 align:middle line:-2
对于参数类型
宠物

00:38:00.747 --> 00:38:02.149 align:middle line:-2
后跟一个动词
画

00:38:03.016 --> 00:38:05.853 align:middle line:-1
同样单词point

00:38:06.186 --> 00:38:08.388 align:middle line:-2
代表参数类型
CGPoint

00:38:08.722 --> 00:38:10.257 align:middle line:-1
后跟介词at

00:38:11.992 --> 00:38:14.094 align:middle line:-1
Swift删除了这些词

00:38:14.161 --> 00:38:17.664 align:middle line:-2
只导入函数
draw at

00:38:19.399 --> 00:38:20.567 align:middle line:-1
怎么做到的？

00:38:21.068 --> 00:38:23.036 align:middle line:-1
你可能不知道

00:38:23.804 --> 00:38:28.008 align:middle line:-2
编译器带有一组
常用英文动词和介词列表

00:38:29.643 --> 00:38:33.113 align:middle line:-2
因为它们很难编码
人类语言太复杂

00:38:33.447 --> 00:38:34.982 align:middle line:0
有时会缺词

00:38:35.716 --> 00:38:38.719 align:middle line:0
另外为了
匹配Swift名字转换

00:38:38.952 --> 00:38:41.255 align:middle line:0
导入器会重命名函数

00:38:41.455 --> 00:38:44.057 align:middle line:0
根据词性删除单词

00:38:45.192 --> 00:38:47.895 align:middle line:0
比如
动词feed不在列表上

00:38:47.961 --> 00:38:52.266 align:middle line:0
所以feedPet导入后
不是我们预想的feed

00:38:53.467 --> 00:38:54.535 align:middle line:0
这个时候

00:38:54.601 --> 00:38:57.104 align:middle line:0
可以用注解
NS_Swift_Name

00:38:57.337 --> 00:39:01.508 align:middle line:0
让编译器导入
你要的函数形式

00:38:57.337 --> 00:39:01.508 align:middle line:0
让编译器导入
你要的函数形式

00:39:05.779 --> 00:39:08.315 align:middle line:-2
如果你要看看
Objective-C头文件

00:39:08.382 --> 00:39:09.917 align:middle line:-1
如何导入Swift

00:39:10.317 --> 00:39:13.187 align:middle line:-2
你可以到
Xcode相关项目弹窗

00:39:13.487 --> 00:39:15.989 align:middle line:-1
它在源编辑器的左上角

00:39:16.523 --> 00:39:18.592 align:middle line:-1
选择生成的接口

00:39:18.759 --> 00:39:21.128 align:middle line:-1
就能看到接口的样子

00:39:21.261 --> 00:39:22.863 align:middle line:-1
和不同的Swift版本

00:39:25.465 --> 00:39:27.768 align:middle line:-2
以上就是用Swift
导入Objective-C

00:39:28.302 --> 00:39:29.803 align:middle line:-1
反过来呢？

00:39:30.170 --> 00:39:33.173 align:middle line:-2
Objective-C
怎么导入Swift？

00:39:35.309 --> 00:39:37.878 align:middle line:-2
答案是
Swift会生成一个头文件

00:39:37.945 --> 00:39:39.313 align:middle line:-1
可以进行导入

00:39:39.913 --> 00:39:44.484 align:middle line:-2
这样你可以用Swift编写类
然后用Objective-C调用它们

00:39:45.619 --> 00:39:46.854 align:middle line:-1
看看工作原理

00:39:48.355 --> 00:39:51.225 align:middle line:-2
编译器生成
Objective-C声明

00:39:51.291 --> 00:39:55.963 align:middle line:-2
给Swift类
NSObject和@objc函数

00:39:57.397 --> 00:39:58.665 align:middle line:-1
单元测试的app

00:39:58.899 --> 00:40:02.503 align:middle line:-2
头文件会包含
公共和内部两种声明

00:39:58.899 --> 00:40:02.503 align:middle line:-2
头文件会包含
公共和内部两种声明

00:40:03.003 --> 00:40:07.140 align:middle line:-2
就能在app的Objective-C部分
使用内部Swift

00:40:08.642 --> 00:40:09.810 align:middle line:-1
但是对于框架

00:40:10.110 --> 00:40:13.180 align:middle line:-1
生成的头文件只包含公共声明

00:40:13.380 --> 00:40:15.549 align:middle line:-1
因为它包含于构建的产品

00:40:15.616 --> 00:40:18.085 align:middle line:-1
是框架公共接口的一部分

00:40:20.521 --> 00:40:21.355 align:middle line:-1
右边

00:40:21.421 --> 00:40:24.491 align:middle line:-2
你看到编译器
将Objective-C类连接到

00:40:24.892 --> 00:40:27.227 align:middle line:-1
名字变形的Swift类

00:40:27.728 --> 00:40:30.464 align:middle line:-2
包含模块名称
PetWall

00:40:31.865 --> 00:40:34.101 align:middle line:-1
现在我讲一讲模块

00:40:34.668 --> 00:40:36.436 align:middle line:-2
之后Louis会讲解
命名修饰

00:40:36.904 --> 00:40:38.305 align:middle line:-1
现在大家要知道

00:40:38.505 --> 00:40:41.175 align:middle line:-2
它能防止
运行时间里的冲突

00:40:41.375 --> 00:40:44.478 align:middle line:-2
不让两个模块定义
同名的类

00:40:46.180 --> 00:40:50.017 align:middle line:0
你可以让Swift重命名
Objective-C类

00:40:50.284 --> 00:40:53.520 align:middle line:0
通过传递识别符
到objc属性

00:40:54.188 --> 00:40:55.189 align:middle line:0
如果这样做

00:40:55.389 --> 00:40:58.692 align:middle line:0
你要保证两个名字不冲突

00:40:59.893 --> 00:41:04.998 align:middle line:0
我用了PWL前缀
防止冲突

00:40:59.893 --> 00:41:04.998 align:middle line:0
我用了PWL前缀
防止冲突

00:41:05.632 --> 00:41:11.271 align:middle line:0
这样就能在Objective-C中
引用这个类PWLPetCollar

00:41:14.107 --> 00:41:15.909 align:middle line:-1
编译器用类似的方法

00:41:15.976 --> 00:41:19.413 align:middle line:-1
生成其他Swift目标的接口

00:41:21.248 --> 00:41:22.082 align:middle line:-1
为此

00:41:22.416 --> 00:41:25.285 align:middle line:-2
Swift基于Clang的
模块概念进行构建

00:41:25.352 --> 00:41:26.720 align:middle line:-1
就像Jurgen说的

00:41:27.321 --> 00:41:29.489 align:middle line:-1
然后更深层的融入语言

00:41:30.624 --> 00:41:31.458 align:middle line:-1
Swift里

00:41:31.525 --> 00:41:34.561 align:middle line:-1
模块是可分布的声明单元

00:41:34.828 --> 00:41:39.299 align:middle line:-2
为了使用这些声明
就要导入模块

00:41:40.334 --> 00:41:42.703 align:middle line:-2
你可以导入
Objective-C模块

00:41:42.936 --> 00:41:44.571 align:middle line:-1
比如XEtest

00:41:45.305 --> 00:41:46.440 align:middle line:-1
Xcode里

00:41:46.507 --> 00:41:49.610 align:middle line:-2
每个Swift目标
生成单独的模块

00:41:50.043 --> 00:41:51.378 align:middle line:-1
包括目标app

00:41:52.479 --> 00:41:55.115 align:middle line:-2
所以要导入
app的主模块

00:41:55.182 --> 00:41:57.551 align:middle line:-1
以便进行单元测试

00:42:00.621 --> 00:42:02.022 align:middle line:-1
导入模块时

00:42:02.089 --> 00:42:05.792 align:middle line:-2
编译器反序列化
一个特殊的Swift模块文件

00:42:06.360 --> 00:42:08.128 align:middle line:-2
在使用时
检查它的类型

00:42:09.129 --> 00:42:10.697 align:middle line:-1
例如在单元测试中

00:42:10.764 --> 00:42:13.333 align:middle line:-2
编译器加载
PetViewController

00:42:14.001 --> 00:42:15.736 align:middle line:-1
从PetWall Swift模块里

00:42:16.103 --> 00:42:18.672 align:middle line:-2
以保证控制器的创建
没有问题

00:42:19.773 --> 00:42:22.643 align:middle line:-1
这类似于编译器在目标里查找声明

00:42:22.843 --> 00:42:25.012 align:middle line:-1
我之前展示过的

00:42:25.913 --> 00:42:27.014 align:middle line:-1
除此之外

00:42:27.080 --> 00:42:29.917 align:middle line:-2
编译器会加载一个
总结模块的文件

00:42:30.384 --> 00:42:33.220 align:middle line:-1
而不是直接解析Swift文件

00:42:36.323 --> 00:42:38.759 align:middle line:-2
编译器生成的
Swift模块文件

00:42:38.959 --> 00:42:41.762 align:middle line:-2
很多就像
Objective-C头文件

00:42:42.296 --> 00:42:45.199 align:middle line:-2
但它不是文本模式
而是二进制形式

00:42:46.033 --> 00:42:48.202 align:middle line:-1
它包括内联函数的主体

00:42:48.535 --> 00:42:50.971 align:middle line:-2
很像Objective-C
静态内联函数

00:42:51.238 --> 00:42:53.974 align:middle line:-1
C++头文件实现

00:42:54.842 --> 00:42:55.676 align:middle line:-1
但是

00:42:55.742 --> 00:42:56.844 align:middle line:-1
要注意一点

00:42:56.910 --> 00:43:01.381 align:middle line:-2
就是它包含
私有声明的名称和类型

00:42:56.910 --> 00:43:01.381 align:middle line:-2
就是它包含
私有声明的名称和类型

00:43:02.115 --> 00:43:04.218 align:middle line:-2
这让你可以
在调试器中引用它们

00:43:04.284 --> 00:43:05.619 align:middle line:-1
很方便

00:43:06.253 --> 00:43:07.988 align:middle line:-1
但也意味着

00:43:08.388 --> 00:43:12.359 align:middle line:-2
你不能用私人秘密
来命名私有变量

00:43:15.829 --> 00:43:16.964 align:middle line:-1
对累加构建

00:43:17.331 --> 00:43:19.933 align:middle line:-2
编译器生成
部分Swift模块文件

00:43:20.434 --> 00:43:23.270 align:middle line:-1
然后合并为一个文件

00:43:23.470 --> 00:43:25.939 align:middle line:-1
代表整个模块的内容

00:43:26.974 --> 00:43:29.443 align:middle line:-1
合并过程可能会

00:43:29.510 --> 00:43:32.913 align:middle line:-2
生成一个
Objective-C头文件

00:43:34.515 --> 00:43:35.382 align:middle line:-1
很多时候

00:43:35.449 --> 00:43:37.251 align:middle line:-1
这类似于连接器的操作

00:43:37.317 --> 00:43:39.486 align:middle line:-1
把目标文件整合成

00:43:39.853 --> 00:43:41.855 align:middle line:-1
一个执行文件

00:43:42.322 --> 00:43:43.724 align:middle line:-1
更多关于它的内容

00:43:43.790 --> 00:43:46.393 align:middle line:-1
有请Louis讲讲连接器

00:43:46.827 --> 00:43:47.694 align:middle line:-1
Louis

00:43:48.161 --> 00:43:49.129 align:middle line:-1
谢谢 Devin

00:43:54.835 --> 00:43:57.371 align:middle line:-2
我是Louis Gerbarg
工作重点就是连接器

00:43:57.871 --> 00:44:00.274 align:middle line:-1
这是完成Xcode构建的最后一步

00:43:57.871 --> 00:44:00.274 align:middle line:-1
这是完成Xcode构建的最后一步

00:44:00.607 --> 00:44:01.642 align:middle line:-1
开始吧

00:44:03.076 --> 00:44:06.113 align:middle line:-1
首先浏览一下我要讲的内容

00:44:06.680 --> 00:44:08.782 align:middle line:-1
我会讲什么是连接器

00:44:09.650 --> 00:44:11.251 align:middle line:-1
还有它用做输入的

00:44:11.318 --> 00:44:13.921 align:middle line:-1
dylibs和目标文件及其定义

00:44:14.688 --> 00:44:16.190 align:middle line:-1
还会讲到符号

00:44:16.757 --> 00:44:18.058 align:middle line:-1
及其内容

00:44:18.926 --> 00:44:21.061 align:middle line:-1
最后我会总结一遍

00:44:21.128 --> 00:44:24.298 align:middle line:-2
通过举例
因为内容比较难懂

00:44:25.098 --> 00:44:27.067 align:middle line:-1
如果感到疑惑

00:44:27.501 --> 00:44:29.169 align:middle line:-2
坚持住
希望我能讲明白

00:44:31.438 --> 00:44:32.272 align:middle line:-1
那么…

00:44:32.639 --> 00:44:33.473 align:middle line:-1
什么是连接器？

00:44:33.540 --> 00:44:36.009 align:middle line:-2
我说过
它是最后一个

00:44:36.443 --> 00:44:37.344 align:middle line:-1
构建阶段

00:44:38.145 --> 00:44:40.914 align:middle line:-2
我们要合并
所有的.o文件

00:44:41.381 --> 00:44:45.819 align:middle line:-2
是两个编译器之前生成的
合成一个可执行文件

00:44:47.054 --> 00:44:49.256 align:middle line:-2
全部内容就是
移动和打包代码

00:44:49.323 --> 00:44:51.458 align:middle line:-2
它不能生成代码
这点很重要

00:44:51.525 --> 00:44:54.061 align:middle line:-1
我来举例说明

00:44:55.629 --> 00:44:57.931 align:middle line:-1
我们有两种输入文件

00:44:58.265 --> 00:45:01.268 align:middle line:-2
第一种是dylibs
就是库

00:44:58.265 --> 00:45:01.268 align:middle line:-2
第一种是dylibs
就是库

00:45:01.468 --> 00:45:02.336 align:middle line:-1
有多个…

00:45:03.036 --> 00:45:04.671 align:middle line:-2
第一个应该是
目标文件

00:45:05.539 --> 00:45:06.840 align:middle line:-1
产生于构建过程

00:45:06.907 --> 00:45:08.408 align:middle line:-1
第二种是库

00:45:08.809 --> 00:45:11.178 align:middle line:-2
由多种类型组成
包括dylibs

00:45:11.245 --> 00:45:14.581 align:middle line:-2
tbd
.a文件或静态库

00:45:15.983 --> 00:45:17.918 align:middle line:-1
符号是什么？

00:45:18.485 --> 00:45:22.256 align:middle line:-2
符号是名称
代表代码或数据片段

00:45:24.625 --> 00:45:27.528 align:middle line:-2
这些片段可能会
指向其他符号

00:45:28.295 --> 00:45:29.796 align:middle line:-1
当一个函数

00:45:29.863 --> 00:45:31.098 align:middle line:-1
调用另一个函数

00:45:33.634 --> 00:45:36.904 align:middle line:-2
符号具有属性
会影响连接器的行为

00:45:36.970 --> 00:45:38.338 align:middle line:-1
这有很多

00:45:38.405 --> 00:45:41.909 align:middle line:-2
我只举一个例子
弱符号

00:45:42.242 --> 00:45:45.145 align:middle line:-1
弱符号的注释是指

00:45:45.779 --> 00:45:51.552 align:middle line:-2
它可能会消失
当你在系统上运行

00:45:51.818 --> 00:45:52.886 align:middle line:-1
执行文件时

00:45:53.320 --> 00:45:58.859 align:middle line:-2
这都是可用性标记
表示这个API可用于iOS 12

00:45:58.926 --> 00:46:00.961 align:middle line:-1
那个API可用于iOS 11

00:45:58.926 --> 00:46:00.961 align:middle line:-1
那个API可用于iOS 11

00:46:01.628 --> 00:46:05.232 align:middle line:-2
这就引到了
今天的主题连接器

00:46:05.299 --> 00:46:07.768 align:middle line:-2
连接器决定哪些符号
必须出现

00:46:07.835 --> 00:46:13.006 align:middle line:-2
和哪些符号
可以在运行时间处理

00:46:14.975 --> 00:46:18.378 align:middle line:-2
语言可以将数据编码成符号
通过命名修饰

00:46:18.445 --> 00:46:19.947 align:middle line:-1
Devin已经提到过

00:46:21.181 --> 00:46:22.015 align:middle line:-1
而且…

00:46:22.583 --> 00:46:25.052 align:middle line:-2
C++和Swift中
都能见到

00:46:27.254 --> 00:46:28.088 align:middle line:-1
那么…

00:46:28.155 --> 00:46:29.623 align:middle line:-1
符号就是这些

00:46:30.424 --> 00:46:32.626 align:middle line:-1
代码和数据的名字

00:46:33.360 --> 00:46:34.194 align:middle line:-1
那么…

00:46:34.561 --> 00:46:35.929 align:middle line:-1
编译器生成目标文件

00:46:35.996 --> 00:46:38.265 align:middle line:-1
目标文件就是

00:46:38.732 --> 00:46:41.602 align:middle line:-1
代码和数据的集合

00:46:42.703 --> 00:46:43.871 align:middle line:-1
它们不可执行

00:46:43.937 --> 00:46:47.474 align:middle line:-2
因为是编译的代码
所以还没完成

00:46:47.774 --> 00:46:49.142 align:middle line:-1
还有缺失

00:46:49.209 --> 00:46:51.512 align:middle line:-1
就需要linke整合和修复

00:46:54.114 --> 00:46:57.284 align:middle line:-2
每个文件的片段
以符号表示

00:46:57.351 --> 00:46:58.185 align:middle line:-1
那么…

00:46:58.418 --> 00:47:00.654 align:middle line:-1
print f函数

00:46:58.418 --> 00:47:00.654 align:middle line:-1
print f函数

00:47:01.321 --> 00:47:03.257 align:middle line:-1
就以符号代替代码

00:47:03.790 --> 00:47:06.426 align:middle line:-2
对于其他PetKit函数
一会儿会演示

00:47:06.827 --> 00:47:07.828 align:middle line:-1
也是一样

00:47:09.863 --> 00:47:12.299 align:middle line:-1
片段可能引用未定义符号

00:47:12.366 --> 00:47:14.701 align:middle line:-1
如果.o文件

00:47:15.802 --> 00:47:18.272 align:middle line:-2
引用另一个
.o文件的函数

00:47:18.639 --> 00:47:20.707 align:middle line:-1
这个.o文件就是未定义的

00:47:20.874 --> 00:47:24.144 align:middle line:-2
连接器会查找未定义符号
进行匹配

00:47:26.346 --> 00:47:27.181 align:middle line:-1
那么…

00:47:27.381 --> 00:47:30.551 align:middle line:-1
我说过目标文件是编译器的输出

00:47:30.617 --> 00:47:31.852 align:middle line:-1
什么是库？

00:47:32.486 --> 00:47:34.821 align:middle line:-1
库是定义符号的文件

00:47:34.888 --> 00:47:37.524 align:middle line:-1
但不属于构建的目标

00:47:38.392 --> 00:47:40.961 align:middle line:-1
我们有动态库

00:47:41.595 --> 00:47:42.496 align:middle line:-1
而且…

00:47:42.729 --> 00:47:46.567 align:middle line:-2
这些Mach-O文件
显示代码和数据片段

00:47:46.633 --> 00:47:48.702 align:middle line:-1
供可执行文件使用

00:47:49.536 --> 00:47:52.506 align:middle line:-1
它们是系统的一部分

00:47:52.573 --> 00:47:54.741 align:middle line:-2
这是我们用的框架
你们可能会用

00:47:54.808 --> 00:47:56.109 align:middle line:-1
自己的框架

00:47:58.212 --> 00:48:02.049 align:middle line:-2
还有TBD文件
基于文本的动态库文件

00:47:58.212 --> 00:48:02.049 align:middle line:-2
还有TBD文件
基于文本的动态库文件

00:48:02.115 --> 00:48:03.250 align:middle line:-1
这是什么呢？

00:48:03.984 --> 00:48:04.818 align:middle line:-1
就是…

00:48:05.853 --> 00:48:09.289 align:middle line:-2
在给iOS和macOS
创建SDK的时候

00:48:09.623 --> 00:48:11.758 align:middle line:-1
会有所有这些动态库和函数

00:48:11.825 --> 00:48:14.428 align:middle line:-2
例如MapKit和WebKit
你可能会用到

00:48:14.728 --> 00:48:17.731 align:middle line:-2
但我们不想把
所有这些跟SDK一起加载

00:48:17.798 --> 00:48:19.299 align:middle line:-1
这样体积太大

00:48:19.900 --> 00:48:21.735 align:middle line:-2
编译器和连接器
都不需要

00:48:21.802 --> 00:48:23.070 align:middle line:-1
它只要运行程序

00:48:23.136 --> 00:48:24.905 align:middle line:-2
因此我们创建了
stub dylib

00:48:24.972 --> 00:48:27.307 align:middle line:-1
删除了所有符号的主体

00:48:27.374 --> 00:48:28.742 align:middle line:-1
只保留名字

00:48:29.376 --> 00:48:30.644 align:middle line:-1
完成之后

00:48:30.844 --> 00:48:33.814 align:middle line:-2
转用文本表示
用起来比较简单

00:48:33.881 --> 00:48:39.052 align:middle line:-2
目前它们只用于
分配SDK以减少体积

00:48:40.187 --> 00:48:43.323 align:middle line:-2
如果在项目中看见它们
不要紧张

00:48:43.690 --> 00:48:44.992 align:middle line:-1
它们只是符号

00:48:46.159 --> 00:48:48.161 align:middle line:-1
最后是静态库

00:48:48.428 --> 00:48:49.263 align:middle line:-1
那么…

00:48:50.030 --> 00:48:52.266 align:middle line:-1
静态库是…

00:48:52.332 --> 00:48:56.603 align:middle line:-2
之前用AR工具创建的
.o文件的集合

00:48:56.670 --> 00:49:00.541 align:middle line:-2
也可能是lib
这是它的包装工具

00:48:56.670 --> 00:49:00.541 align:middle line:-2
也可能是lib
这是它的包装工具

00:49:00.941 --> 00:49:02.910 align:middle line:-1
根据AR操作文档

00:49:03.410 --> 00:49:06.680 align:middle line:-1
AR创建并维护文件组

00:49:06.747 --> 00:49:08.382 align:middle line:-1
将它们合并为一个库

00:49:09.316 --> 00:49:12.853 align:middle line:-2
听上去像是
TAR或ZIP文件

00:49:12.920 --> 00:49:13.954 align:middle line:-1
的确是这样

00:49:14.021 --> 00:49:14.855 align:middle line:-1
事实上…

00:49:14.922 --> 00:49:17.024 align:middle line:-1
.a格式是原始的库格式

00:49:17.090 --> 00:49:20.327 align:middle line:-2
在更好的工具产生之前
为UNIX所用

00:49:21.795 --> 00:49:24.364 align:middle line:-1
但现在的编译器和连接器

00:49:24.431 --> 00:49:26.567 align:middle line:-2
可以完全理解它们
所以继续使用

00:49:26.934 --> 00:49:28.936 align:middle line:-1
它就只是个档案文件

00:49:31.872 --> 00:49:35.209 align:middle line:-2
值得注意的是
它们孕育了动态链接

00:49:35.275 --> 00:49:36.143 align:middle line:-1
在过去

00:49:36.210 --> 00:49:39.313 align:middle line:-1
所有代码都被存档

00:49:39.780 --> 00:49:40.881 align:middle line:-1
因此

00:49:41.181 --> 00:49:44.184 align:middle line:-1
不能涵盖所有C库

00:49:44.251 --> 00:49:45.786 align:middle line:-1
只用一个函数

00:49:46.019 --> 00:49:47.421 align:middle line:-1
因此 行为是…

00:49:48.388 --> 00:49:50.591 align:middle line:-1
如果.o文件含有符号

00:49:50.657 --> 00:49:53.026 align:middle line:-2
我们会把整个.o文件
从库中提出来

00:49:53.093 --> 00:49:55.429 align:middle line:-1
但不会带入其他.o文件

00:49:56.230 --> 00:49:57.965 align:middle line:-1
如果在之间引用符号

00:49:58.031 --> 00:49:59.800 align:middle line:-1
只要带入即可

00:49:59.867 --> 00:50:01.935 align:middle line:-1
如果是非符号行为

00:49:59.867 --> 00:50:01.935 align:middle line:-1
如果是非符号行为

00:50:02.002 --> 00:50:03.837 align:middle line:-1
比如静态初始程序

00:50:04.004 --> 00:50:06.006 align:middle line:-2
或将它们以你个人
dylib的形式重新导入

00:50:06.073 --> 00:50:08.408 align:middle line:-1
你要明确地用到

00:50:09.076 --> 00:50:13.146 align:middle line:-2
强制加载或制定加载
让连接器提取所有

00:50:13.213 --> 00:50:15.115 align:middle line:-2
或这些文件
即便之间没有关联

00:50:17.284 --> 00:50:20.954 align:middle line:-2
我们通过一个例子
串联起这些内容

00:50:23.457 --> 00:50:27.961 align:middle line:-1
台上是playSound函数样本

00:50:28.028 --> 00:50:30.797 align:middle line:-2
只看宠物不听声音
有何乐趣呢？

00:50:32.199 --> 00:50:33.066 align:middle line:-1
那么…

00:50:33.767 --> 00:50:35.636 align:middle line:-1
调用playSound

00:50:35.702 --> 00:50:37.804 align:middle line:-2
这个Cat函数
调用playSound

00:50:37.871 --> 00:50:39.173 align:middle line:-1
很简单吧

00:50:39.573 --> 00:50:41.575 align:middle line:-1
来看看生成的程序集

00:50:42.876 --> 00:50:43.810 align:middle line:-1
那么…

00:50:44.144 --> 00:50:46.146 align:middle line:-1
输出文件是cat.o

00:50:46.813 --> 00:50:47.648 align:middle line:-1
现在…

00:50:48.315 --> 00:50:50.150 align:middle line:-1
我们可以看到

00:50:51.218 --> 00:50:55.155 align:middle line:-2
字符串purr.aac
就是AAC声音文件

00:50:55.656 --> 00:50:57.257 align:middle line:-1
它被复制到cat.o

00:50:57.324 --> 00:51:00.794 align:middle line:-2
你会看到
名字为purr的文件不见了

00:50:57.324 --> 00:51:00.794 align:middle line:-2
你会看到
名字为purr的文件不见了

00:51:01.094 --> 00:51:03.030 align:middle line:-1
因为它是静态的

00:51:03.096 --> 00:51:06.033 align:middle line:-2
如果你熟悉C语言
这是非导出命名

00:51:06.099 --> 00:51:07.534 align:middle line:-1
没有人能引用它

00:51:07.768 --> 00:51:09.837 align:middle line:-2
既然如此
我们不需要它了

00:51:09.903 --> 00:51:10.938 align:middle line:-1
排除掉

00:51:14.208 --> 00:51:15.275 align:middle line:-1
然后可以看到

00:51:15.976 --> 00:51:18.212 align:middle line:-1
Cat purr变成了符号

00:51:18.579 --> 00:51:21.481 align:middle line:-1
-[Cat purr]

00:51:23.550 --> 00:51:24.952 align:middle line:-1
跟预想的差不多

00:51:26.253 --> 00:51:28.989 align:middle line:-1
然后我们要把这个变量

00:51:29.056 --> 00:51:30.858 align:middle line:-1
传递到playSound

00:51:31.291 --> 00:51:33.794 align:middle line:-1
这里出现了两个指令

00:51:33.861 --> 00:51:34.862 align:middle line:-1
这是因为…

00:51:35.362 --> 00:51:38.298 align:middle line:-2
我们不知道
这个字符串最后在

00:51:38.365 --> 00:51:39.266 align:middle line:-1
执行文件的位置

00:51:39.333 --> 00:51:41.301 align:middle line:-1
没有具体的位置

00:51:41.602 --> 00:51:44.838 align:middle line:-2
但我们知道RM64
就是这个程序集

00:51:45.506 --> 00:51:46.807 align:middle line:-1
它最多接收两个指令

00:51:46.874 --> 00:51:49.076 align:middle line:-1
编译器留下两个指令

00:51:49.343 --> 00:51:53.146 align:middle line:-2
留下了符号偏离
值为PAGE和PAGEOFF

00:51:53.213 --> 00:51:55.349 align:middle line:-1
连接器之后回来修复

00:51:56.149 --> 00:52:00.687 align:middle line:-2
既然已经
将字符串加载到x0

00:51:56.149 --> 00:52:00.687 align:middle line:-2
既然已经
将字符串加载到x0

00:52:01.855 --> 00:52:05.692 align:middle line:-2
就可以调用playSound
不用写入playSound

00:52:05.759 --> 00:52:10.430 align:middle line:-2
我们写入
__z9playSoundPKc

00:52:11.498 --> 00:52:12.599 align:middle line:-1
这是什么？

00:52:12.666 --> 00:52:13.734 align:middle line:-1
这是变形的符号

00:52:13.800 --> 00:52:16.136 align:middle line:-2
如果仔细看
会看到cat.mm

00:52:16.203 --> 00:52:17.804 align:middle line:-1
这是Objective-C++

00:52:18.405 --> 00:52:21.542 align:middle line:-2
playSound实际是
C++函数

00:52:22.042 --> 00:52:22.876 align:middle line:-1
那么…

00:52:22.943 --> 00:52:24.344 align:middle line:-1
如果你不熟悉

00:52:25.979 --> 00:52:28.715 align:middle line:-2
可以在命令窗口
输入命令

00:52:28.782 --> 00:52:31.151 align:middle line:-2
如果运行
Swift-demangle

00:52:31.385 --> 00:52:33.554 align:middle line:-2
传递符号
然后反修饰

00:52:33.720 --> 00:52:35.856 align:middle line:-2
没有用
它不是Swift符号

00:52:36.456 --> 00:52:39.092 align:middle line:-2
但C++filt
C++反修饰器

00:52:39.226 --> 00:52:40.427 align:middle line:-1
告诉我们它实际上是

00:52:41.328 --> 00:52:42.529 align:middle line:-1
playSound的符号

00:52:42.596 --> 00:52:44.932 align:middle line:-2
除了playSound
它还有一个实参

00:52:44.998 --> 00:52:47.534 align:middle line:-1
就是const char*

00:52:47.601 --> 00:52:52.139 align:middle line:-2
因为C++会将更多信息
编入修饰符号

00:52:53.640 --> 00:52:55.108 align:middle line:-1
现在有了.o文件

00:52:55.509 --> 00:52:57.811 align:middle line:-1
实际构建中会有更多

00:52:58.946 --> 00:53:01.048 align:middle line:-1
那怎么办呢？

00:52:58.946 --> 00:53:01.048 align:middle line:-1
那怎么办呢？

00:53:02.082 --> 00:53:03.717 align:middle line:-2
首先
构建系统

00:53:03.784 --> 00:53:06.653 align:middle line:-2
会将所有的.o
输入到连接器

00:53:06.720 --> 00:53:09.323 align:middle line:-2
连接器会创建文件夹
放置这些文件

00:53:09.756 --> 00:53:11.058 align:middle line:-1
这里构建的PetKit

00:53:11.124 --> 00:53:13.360 align:middle line:-1
是PetWall的内嵌框架

00:53:14.962 --> 00:53:16.463 align:middle line:-1
所以我们只要复制

00:53:16.530 --> 00:53:18.665 align:middle line:-1
创建一个文本片段

00:53:19.299 --> 00:53:22.069 align:middle line:-2
用来保存
app相关的所有代码

00:53:22.703 --> 00:53:24.905 align:middle line:-1
然后复制cat.o到这里

00:53:24.972 --> 00:53:26.673 align:middle line:-1
但是要分成两个部分

00:53:26.907 --> 00:53:29.443 align:middle line:-2
一个给字符串
一个给执行代码

00:53:30.410 --> 00:53:33.514 align:middle line:-1
现在已知它们的文件位置

00:53:33.580 --> 00:53:36.984 align:middle line:-1
连接器就能复写cat.o

00:53:37.584 --> 00:53:40.287 align:middle line:-1
基于特定的偏移值

00:53:40.754 --> 00:53:43.624 align:middle line:-1
你看到第二个指令消失了

00:53:43.690 --> 00:53:47.361 align:middle line:-2
它被一个null指令代替
没有任何行动

00:53:47.961 --> 00:53:52.666 align:middle line:-2
但是它不能被删除
因为我们无法创建或删除代码

00:53:52.733 --> 00:53:56.370 align:middle line:-1
这会打乱所有已经完成的工作

00:53:56.503 --> 00:53:58.739 align:middle line:-1
所以与其删除

00:53:59.273 --> 00:54:02.142 align:middle line:-1
不如用零行动替代

00:53:59.273 --> 00:54:02.142 align:middle line:-1
不如用零行动替代

00:54:02.609 --> 00:54:03.777 align:middle line:-1
最后是分支

00:54:04.845 --> 00:54:06.246 align:middle line:-1
那么分支指令…

00:54:07.581 --> 00:54:08.415 align:middle line:-1
然后…

00:54:09.850 --> 00:54:11.218 align:middle line:-1
要怎么做？

00:54:11.285 --> 00:54:12.886 align:middle line:-1
因为这个未定义符号？

00:54:13.120 --> 00:54:14.855 align:middle line:-1
我们要继续浏览

00:54:14.922 --> 00:54:17.124 align:middle line:-1
所有已经导入的.o文件

00:54:18.325 --> 00:54:20.127 align:middle line:-1
首先是过去的静态库

00:54:20.194 --> 00:54:22.496 align:middle line:-1
这是PetSupport.a

00:54:22.963 --> 00:54:24.865 align:middle line:-1
PetSupport.a里面

00:54:25.566 --> 00:54:28.468 align:middle line:-2
有一些文件
包括PetSounds.o

00:54:29.503 --> 00:54:33.574 align:middle line:-2
大家能看到
playSound对应的符号

00:54:34.741 --> 00:54:35.642 align:middle line:-1
把它拉入

00:54:38.378 --> 00:54:41.048 align:middle line:-2
PetCare.o
不能被拉入

00:54:41.381 --> 00:54:43.851 align:middle line:-1
因为这个.o文件没有符号

00:54:43.917 --> 00:54:45.953 align:middle line:-1
能被app的其他部分

00:54:46.019 --> 00:54:46.987 align:middle line:-1
引用

00:54:48.555 --> 00:54:50.624 align:middle line:-2
所有我们把它拉入
现在需要

00:54:51.859 --> 00:54:53.193 align:middle line:-2
_open
但没有定义

00:54:53.260 --> 00:54:54.895 align:middle line:-1
你看到

00:54:56.096 --> 00:54:57.664 align:middle line:-1
拉入的对话已变成

00:54:57.731 --> 00:54:59.466 align:middle line:-1
open$stub

00:54:59.766 --> 00:55:01.001 align:middle line:-1
为什么呢？

00:54:59.766 --> 00:55:01.001 align:middle line:-1
为什么呢？

00:55:01.768 --> 00:55:04.638 align:middle line:-1
因为我们发现open的复制

00:55:05.806 --> 00:55:09.877 align:middle line:-2
在lib系统的
TBD文件里

00:55:11.178 --> 00:55:14.281 align:middle line:-2
我知道
这不属于系统库

00:55:14.348 --> 00:55:16.016 align:middle line:-2
我不会复制到
我的app

00:55:16.083 --> 00:55:17.217 align:middle line:-1
但我需要…

00:55:17.784 --> 00:55:21.255 align:middle line:-2
在app里放入足够的信息
以方便调用

00:55:21.455 --> 00:55:24.858 align:middle line:-2
所以我们创建假函数
只是个模板

00:55:25.259 --> 00:55:26.426 align:middle line:-1
用来代替

00:55:26.493 --> 00:55:27.928 align:middle line:-2
从lib系统
拿走的函数

00:55:27.995 --> 00:55:29.196 align:middle line:-1
这里就是open

00:55:29.630 --> 00:55:31.064 align:middle line:-1
观察这个函数

00:55:31.665 --> 00:55:35.269 align:middle line:-2
它实际是来自指针
open$pointer

00:55:36.103 --> 00:55:37.137 align:middle line:-1
然后跳过来

00:55:37.304 --> 00:55:40.774 align:middle line:-2
这需要一个函数指针
任何正常的C语言函数指针

00:55:42.609 --> 00:55:43.877 align:middle line:-1
然后创建它

00:55:44.144 --> 00:55:45.212 align:middle line:-1
在数据片段中

00:55:45.579 --> 00:55:48.549 align:middle line:-2
如果有全局变量
就会出现在这里

00:55:49.349 --> 00:55:51.084 align:middle line:-1
但这里是0

00:55:51.351 --> 00:55:54.721 align:middle line:-1
如果空引用就会导致崩溃

00:55:55.956 --> 00:55:58.458 align:middle line:-2
所以添加一个
LINKEDIT部分

00:55:58.525 --> 00:56:00.294 align:middle line:-1
LINKEDIT是元数据

00:55:58.525 --> 00:56:00.294 align:middle line:-1
LINKEDIT是元数据

00:56:00.661 --> 00:56:03.263 align:middle line:-1
连接器会用它

00:56:03.764 --> 00:56:06.433 align:middle line:-1
给操作系统留下信息

00:56:06.500 --> 00:56:09.870 align:middle line:-2
这就是动态连接器
在运行时间解决问题

00:56:10.103 --> 00:56:11.538 align:middle line:-1
了解更多信息

00:56:12.105 --> 00:56:16.443 align:middle line:-2
请观看2016年的演讲
优化app启动时间

00:56:19.246 --> 00:56:20.080 align:middle line:-1
那么…

00:56:21.048 --> 00:56:23.417 align:middle line:-1
简单回顾下今天的内容

00:56:23.483 --> 00:56:27.287 align:middle line:-2
Jake讲述了构建系统
如何用依赖关系

00:56:27.688 --> 00:56:30.624 align:middle line:-1
优化多核构建过程

00:56:33.026 --> 00:56:36.763 align:middle line:-2
Jurgen展示了Clang
和如何查找头文件

00:56:36.830 --> 00:56:39.299 align:middle line:-1
以及如何优化模块构建

00:56:41.001 --> 00:56:42.135 align:middle line:-1
Devin简述了

00:56:42.436 --> 00:56:44.872 align:middle line:-1
Swift对模块的扩展

00:56:45.005 --> 00:56:46.840 align:middle line:-1
所有这些今年的新实施

00:56:46.907 --> 00:56:49.443 align:middle line:-2
比如BF处理
都是为了提升构建速度

00:56:49.810 --> 00:56:51.645 align:middle line:-1
最后连接器接收

00:56:51.712 --> 00:56:52.913 align:middle line:-1
两个编译器的输出

00:56:53.146 --> 00:56:55.015 align:middle line:-1
将它们带入app

00:56:55.249 --> 00:56:57.951 align:middle line:-2
这时Xcode会
代码签名并打包

00:56:58.018 --> 00:56:58.852 align:middle line:-1
与其他…

00:57:00.387 --> 00:57:02.789 align:middle line:-2
app部分糅合
准备分发

00:57:03.957 --> 00:57:04.791 align:middle line:-1
那么…

00:57:05.926 --> 00:57:07.861 align:middle line:-1
这些基本都是开源的

00:57:07.928 --> 00:57:09.329 align:middle line:-1
如果感兴趣

00:57:09.396 --> 00:57:13.433 align:middle line:-2
可以研究Swift或Clang
或llbuild执行引擎

00:57:14.801 --> 00:57:16.036 align:middle line:-1
对这些URL

00:57:16.904 --> 00:57:18.805 align:middle line:-1
谢谢大家的到来

00:57:19.206 --> 00:57:20.040 align:middle line:-1
而且…

00:57:20.641 --> 00:57:23.310 align:middle line:-2
希望你们享受本次WWDC
我们将在实验室见

00:57:23.377 --> 00:57:24.278 align:middle line:-1
谢谢
