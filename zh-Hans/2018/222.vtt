WEBVTT

00:00:16.817 --> 00:00:22.289 align:middle line:0
（你可以信任的数据
更安全的COCOA归档和序列化）

00:00:28.428 --> 00:00:29.263 align:middle line:-1
大家早上好

00:00:30.030 --> 00:00:32.598 align:middle line:-2
感谢你们在喝咖啡前
就参加了我的演讲

00:00:33.267 --> 00:00:35.769 align:middle line:-2
我叫Itai
我在Foundation团队工作

00:00:36.637 --> 00:00:38.005 align:middle line:-1
本次演讲中 我想介绍

00:00:38.071 --> 00:00:40.941 align:middle line:-2
数据在你app中的流向
是如何影响app本身的

00:00:41.441 --> 00:00:43.210 align:middle line:-1
以及你要如何建立在数据中的信任

00:00:43.277 --> 00:00:44.945 align:middle line:-1
来更好地保护你的用户

00:00:45.946 --> 00:00:46.780 align:middle line:-1
让我们开始吧

00:00:48.549 --> 00:00:49.783 align:middle line:-1
app不是生存在真空中的

00:00:50.517 --> 00:00:52.452 align:middle line:-2
为了能让你的app
做些有意义的事情

00:00:52.686 --> 00:00:54.688 align:middle line:-1
它们要从外部资源中提取数据

00:00:54.755 --> 00:00:57.357 align:middle line:-1
像是磁盘 网络 或是用户本身

00:00:57.991 --> 00:01:00.027 align:middle line:-1
然后利用这些数据做些有意义的事情

00:00:57.991 --> 00:01:00.027 align:middle line:-1
然后利用这些数据做些有意义的事情

00:01:00.093 --> 00:01:01.595 align:middle line:-1
再将其呈现给你的用户

00:01:02.863 --> 00:01:04.998 align:middle line:-1
为了让该数据是可消耗的

00:01:05.065 --> 00:01:07.668 align:middle line:-1
它应该以某种已知格式或结构来呈现

00:01:08.769 --> 00:01:10.103 align:middle line:-1
若非这样的格式或结构呢？

00:01:11.872 --> 00:01:16.410 align:middle line:-2
这通常意味着数据被损坏了
或某种程度上是无效的 可以被忽略

00:01:17.544 --> 00:01:18.579 align:middle line:-1
但有时

00:01:18.645 --> 00:01:22.049 align:middle line:-2
这些数据会让你app
所做的设想无效化

00:01:22.583 --> 00:01:25.886 align:middle line:-2
且它会导致你的app不能正常工作
或者甚至是崩溃

00:01:28.021 --> 00:01:29.957 align:middle line:-1
这会给在等待你的app

00:01:30.023 --> 00:01:32.926 align:middle line:-2
在App Store更新的用户
带来不好的体验

00:01:33.827 --> 00:01:36.597 align:middle line:-1
如果在发布时崩溃就更糟糕了

00:01:36.663 --> 00:01:38.298 align:middle line:-1
因为他们甚至连app都用不了

00:01:38.699 --> 00:01:40.734 align:middle line:-1
与此同时 在你等待的时候

00:01:40.801 --> 00:01:42.603 align:middle line:-1
你会得到一波一星评价

00:01:43.170 --> 00:01:44.571 align:middle line:-1
这对谁来说都不是好事

00:01:46.406 --> 00:01:48.408 align:middle line:-1
如果你是个框架开发者的话

00:01:48.475 --> 00:01:49.810 align:middle line:-1
这类事情就更容易被人记住

00:01:50.010 --> 00:01:52.946 align:middle line:-1
因为它可能不仅仅会影响一个app

00:01:53.013 --> 00:01:54.181 align:middle line:-1
还可能影响许多app

00:01:56.683 --> 00:01:58.585 align:middle line:-1
今天我们要介绍的是关于信任的内容

00:01:59.119 --> 00:01:59.953 align:middle line:-1
更具体地说

00:02:00.020 --> 00:02:03.123 align:middle line:-1
我们要讨论的是如何通过保证两件事

00:02:03.190 --> 00:02:04.291 align:middle line:-1
在数据中建立信任

00:02:04.358 --> 00:02:05.692 align:middle line:-1
（令人信任的数据）

00:02:05.759 --> 00:02:07.594 align:middle line:-1
首先就是我们要使用的数据

00:02:07.661 --> 00:02:09.630 align:middle line:-1
没有被除我们之外的人修改过

00:02:10.531 --> 00:02:13.400 align:middle line:-1
第二点就是它要包含我们想要的

00:02:13.467 --> 00:02:15.302 align:middle line:-1
格式和结构

00:02:17.371 --> 00:02:21.175 align:middle line:-2
要实现这些目的
我们要看一下数据的生命周期

00:02:21.842 --> 00:02:25.245 align:middle line:-2
以及我们在生命周期的每个阶段
可以如何验证该数据

00:02:26.713 --> 00:02:30.617 align:middle line:-2
然后我们再看下可以应用的
NS安全编码协议

00:02:30.684 --> 00:02:32.152 align:middle line:-1
来实现哪种类型级别的验证

00:02:33.053 --> 00:02:35.689 align:middle line:-1
然后再对可编码类型进行相同的处理

00:02:37.124 --> 00:02:38.025 align:middle line:-1
让我们开始吧

00:02:38.091 --> 00:02:40.294 align:middle line:-1
（数据建模）

00:02:40.360 --> 00:02:41.628 align:middle line:-1
为了介绍该数据

00:02:41.695 --> 00:02:43.497 align:middle line:-1
我们要建立一个关于app中

00:02:43.564 --> 00:02:45.966 align:middle line:-1
可获取的数据形式的构思模型

00:02:47.935 --> 00:02:49.369 align:middle line:-1
在最基本的层级

00:02:49.436 --> 00:02:52.773 align:middle line:-2
数据是以字节流的形式
出现在我们的app中

00:02:54.341 --> 00:02:56.376 align:middle line:-2
在这个阶段
如果我们不看的话

00:02:56.443 --> 00:02:59.613 align:middle line:-2
是讲不出有关这类数据的更多内容的
我们将其称之为原始数据

00:03:01.615 --> 00:03:03.617 align:middle line:-1
要处理该数据

00:03:03.684 --> 00:03:06.987 align:middle line:-2
我们需要保证
它是遵从已知格式或结构的

00:03:07.354 --> 00:03:08.188 align:middle line:-1
在这种情况下

00:03:08.255 --> 00:03:12.359 align:middle line:-1
每个编码点要对应一个UTF编码点

00:03:12.426 --> 00:03:13.660 align:middle line:-1
抱歉 稍等一下

00:03:13.727 --> 00:03:15.329 align:middle line:-1
让我把它变得更好读一点

00:03:15.395 --> 00:03:16.797 align:middle line:-1
看来这是JSON数据文件

00:03:17.798 --> 00:03:20.601 align:middle line:-1
而在我们保证了该数据

00:03:20.667 --> 00:03:23.237 align:middle line:-2
是我们想处理的某种格式后
我们将其称为格式化数据

00:03:24.972 --> 00:03:27.708 align:middle line:-1
格式化数据本身没有太多意义

00:03:27.774 --> 00:03:30.043 align:middle line:-1
我们要对其创建主要值

00:03:30.110 --> 00:03:32.079 align:middle line:-1
字符串 数组 以及字典

00:03:32.145 --> 00:03:35.249 align:middle line:-2
这样我们就可以在以后的算法中
将其作为构建块使用了

00:03:35.916 --> 00:03:37.518 align:middle line:-1
我们将其称为我们的主要数据

00:03:39.653 --> 00:03:41.855 align:middle line:-1
我们有经常要用到的构建块

00:03:41.922 --> 00:03:45.392 align:middle line:-2
不仅是作为主要值
还有我们自己的模型类型

00:03:46.493 --> 00:03:47.661 align:middle line:-1
在我们这么做之后

00:03:47.728 --> 00:03:50.864 align:middle line:-2
我们会用到这个叫做
结构化数据的内容

00:03:52.633 --> 00:03:57.838 align:middle line:-2
这些我们app中的数据形式
会形成一个抽象时间线

00:03:59.072 --> 00:04:02.309 align:middle line:-2
原始数据是我们所处理的
数据中最不抽象的

00:03:59.072 --> 00:04:02.309 align:middle line:-2
原始数据是我们所处理的
数据中最不抽象的

00:04:02.376 --> 00:04:05.179 align:middle line:-2
而我们自己的
结构化模型类型是最抽象的

00:04:05.445 --> 00:04:06.380 align:middle line:-1
我们现在的目标

00:04:06.980 --> 00:04:09.983 align:middle line:-1
就是尽可能大范围地获取数据

00:04:10.517 --> 00:04:14.221 align:middle line:-2
我们的app可在任何合适点停下来
利用这些数据

00:04:14.555 --> 00:04:16.490 align:middle line:-1
但我们还想要随时处理

00:04:16.557 --> 00:04:17.491 align:middle line:-1
我们自己的模型类型

00:04:18.692 --> 00:04:19.692 align:middle line:-1
现在的目标

00:04:19.760 --> 00:04:23.230 align:middle line:-2
就不仅仅是获得
尽可能大的抽象范围了

00:04:23.297 --> 00:04:25.632 align:middle line:-1
而是在过程中建立信任

00:04:26.466 --> 00:04:28.969 align:middle line:-1
在每个阶段 数据都会变得更复杂

00:04:29.036 --> 00:04:31.605 align:middle line:-2
而且会比我们进行验证
所需要的数据更多

00:04:31.905 --> 00:04:32.739 align:middle line:-1
而在这么做之后

00:04:32.806 --> 00:04:34.741 align:middle line:-2
会得到比所需信任的数据
更多的内容

00:04:36.243 --> 00:04:37.644 align:middle line:-1
对于我们今天的用例而言

00:04:37.711 --> 00:04:40.013 align:middle line:-1
我们不会太过介绍格式化数据

00:04:40.080 --> 00:04:43.150 align:middle line:-2
它通常就是原始数据
和主要数据间的踏脚石

00:04:43.217 --> 00:04:44.651 align:middle line:-1
你不会直接用到它

00:04:45.686 --> 00:04:47.754 align:middle line:-1
例如 给出了原始数据后

00:04:47.821 --> 00:04:50.824 align:middle line:-2
foundations JSON序列化
会给你返回主要数据

00:04:50.891 --> 00:04:52.793 align:middle line:-1
你不会直接看到格式化数据

00:04:52.860 --> 00:04:53.994 align:middle line:-1
也不会用到它

00:04:54.928 --> 00:04:58.498 align:middle line:-2
所以今天我们要介绍的是
原始主要和结构化数据

00:05:00.133 --> 00:05:02.069 align:middle line:-1
让我们从原始数据开始讲起

00:05:02.836 --> 00:05:04.505 align:middle line:-1
正如我们刚才所说的

00:05:04.571 --> 00:05:07.541 align:middle line:-2
原始数据就是进入你app的
一个字节流

00:05:08.475 --> 00:05:11.211 align:middle line:-1
在你检查了该数据并赋予其意义之前

00:05:11.278 --> 00:05:12.379 align:middle line:-1
你用它干不了什么

00:05:12.446 --> 00:05:13.714 align:middle line:-1
（原始数据）

00:05:13.780 --> 00:05:16.750 align:middle line:-1
现在我们或许想知道

00:05:16.817 --> 00:05:18.986 align:middle line:-2
在我们开始检查这个数据前
能看到什么内容

00:05:19.386 --> 00:05:20.721 align:middle line:-1
这样做是不是安全呢？

00:05:22.022 --> 00:05:25.359 align:middle line:-2
我们在用该数据之前
所能验证的一个内容就是它的长度

00:05:26.293 --> 00:05:29.196 align:middle line:-2
比如 你的app
要从磁盘加载1字节的文件

00:05:29.263 --> 00:05:31.231 align:middle line:-1
但是在磁盘中找到了十亿字节的文件

00:05:32.199 --> 00:05:34.401 align:middle line:-1
你是不是应该加载这个数据

00:05:34.468 --> 00:05:35.469 align:middle line:-1
并且开始读取它呢？

00:05:35.969 --> 00:05:37.137 align:middle line:-1
当然不是了

00:05:38.605 --> 00:05:41.175 align:middle line:-1
有时候我们或许不能确定

00:05:41.241 --> 00:05:42.176 align:middle line:-1
数据的长度

00:05:42.242 --> 00:05:43.944 align:middle line:-1
可能它是不被我们拥有的外部数据

00:05:44.011 --> 00:05:45.679 align:middle line:-1
我们不知道会有多少数据

00:05:46.880 --> 00:05:47.714 align:middle line:-1
但是在某些情况下

00:05:47.781 --> 00:05:49.816 align:middle line:-1
我们可以验证校验和

00:05:49.883 --> 00:05:51.418 align:middle line:-1
或是加密签名

00:05:51.718 --> 00:05:53.654 align:middle line:-1
这样就呈现了数据看起来是什么样子

00:05:53.720 --> 00:05:55.189 align:middle line:-1
即使我们不知道内部什么样

00:05:56.056 --> 00:05:58.225 align:middle line:-1
校验和就是对所有数据进行哈希处理

00:05:58.559 --> 00:06:00.360 align:middle line:-1
如果数据有任何的变化

00:05:58.559 --> 00:06:00.360 align:middle line:-1
如果数据有任何的变化

00:06:00.427 --> 00:06:03.063 align:middle line:-1
不管是由于潜在的第三方恶意破坏

00:06:03.130 --> 00:06:04.731 align:middle line:-1
还是常规的数据损坏

00:06:04.798 --> 00:06:07.134 align:middle line:-2
磁盘的坏道
糟糕的网络连接…

00:06:07.734 --> 00:06:11.505 align:middle line:-2
如果数据的任何一个比特变化的话
就会让校验和

00:06:11.572 --> 00:06:12.573 align:middle line:-1
或签名无效

00:06:12.639 --> 00:06:14.875 align:middle line:-1
我们会在读取这些字节之前就知道

00:06:14.942 --> 00:06:17.411 align:middle line:-2
数据是不正确的
你不应该信任它

00:06:19.379 --> 00:06:21.615 align:middle line:-1
我们不总有一个检验和

00:06:21.682 --> 00:06:24.484 align:middle line:-2
可能这个数据不是我们所有的
我们不能提前得到它

00:06:24.551 --> 00:06:27.421 align:middle line:-2
所以在这个阶段
除了读取并且检查数据

00:06:27.788 --> 00:06:29.489 align:middle line:-1
我们不能对它进行更多处理了

00:06:30.657 --> 00:06:33.493 align:middle line:-2
在我们处理完原始数据后
就得到了主要数据

00:06:34.728 --> 00:06:37.431 align:middle line:-2
正如我们之前提到的
我们获取原始数据后

00:06:37.497 --> 00:06:39.566 align:middle line:-2
将其传过
通常会将它去序列化

00:06:39.633 --> 00:06:41.568 align:middle line:-2
像是foundations
JSON序列化

00:06:42.803 --> 00:06:45.372 align:middle line:-2
当我们完成操作时
我们会得到不活跃的字符串和字典

00:06:45.439 --> 00:06:47.774 align:middle line:-2
数字数组
以供我们使用

00:06:48.141 --> 00:06:50.677 align:middle line:-2
若这个过程成功了
我们就能了解该数据两方面内容

00:06:50.744 --> 00:06:52.246 align:middle line:-1
（主要数据）

00:06:52.312 --> 00:06:55.282 align:middle line:-2
第一点就是
该数据确实是我们所期望的正确格式

00:06:55.349 --> 00:06:58.185 align:middle line:-2
例如
XML数据不会通过JSON序列化

00:06:59.720 --> 00:07:01.822 align:middle line:-2
第二点就是
如果我们信任去序列化器

00:06:59.720 --> 00:07:01.822 align:middle line:-2
第二点就是
如果我们信任去序列化器

00:07:02.356 --> 00:07:04.157 align:middle line:-1
我们会知道我们得到的运行时间对象

00:07:04.224 --> 00:07:06.026 align:middle line:-1
会是有效的

00:07:06.560 --> 00:07:09.363 align:middle line:-2
foundations JSON
序列化会给你

00:07:09.429 --> 00:07:11.665 align:middle line:-1
可用的字符串、数字和数组

00:07:12.332 --> 00:07:14.134 align:middle line:-1
它是我们可以信任的独立值

00:07:15.869 --> 00:07:17.070 align:middle line:-1
但在这个阶段 我们可能感到奇怪

00:07:17.137 --> 00:07:19.173 align:middle line:-1
“好吧…我们应该如何使用这个数据

00:07:19.239 --> 00:07:20.741 align:middle line:-1
我们可以信任它的哪些方面

00:07:20.807 --> 00:07:22.643 align:middle line:-1
我们还需要进行什么验证呢？”

00:07:24.711 --> 00:07:28.549 align:middle line:-1
在我们实际看到这个数据前

00:07:28.615 --> 00:07:29.950 align:middle line:-1
我们对它内容没多少了解

00:07:30.517 --> 00:07:33.320 align:middle line:-1
事实上 我们只有开始检查它的时候

00:07:33.387 --> 00:07:34.755 align:middle line:-1
才能更好地了解数据结构

00:07:35.355 --> 00:07:37.558 align:middle line:-2
如果你曾以这种方式
用过动态去序列化的话

00:07:37.624 --> 00:07:39.826 align:middle line:-1
你就会了解它有很多的缺点

00:07:40.460 --> 00:07:42.596 align:middle line:-1
你不能提前得到数据是什么样的

00:07:42.663 --> 00:07:43.830 align:middle line:-1
因为它是非常概括性的

00:07:44.231 --> 00:07:47.034 align:middle line:-1
因此我们想看下该数据包含什么

00:07:47.100 --> 00:07:48.235 align:middle line:-1
我们可以如何使用它

00:07:49.636 --> 00:07:51.104 align:middle line:-1
让我们举例来说一下

00:07:51.872 --> 00:07:54.775 align:middle line:-2
我最近一直在开发一个叫
Sell My Old Junk的app

00:07:54.842 --> 00:07:58.078 align:middle line:-2
它可以让我
把旧货卖给朋友和家人

00:07:58.779 --> 00:08:03.350 align:middle line:-2
当他们有人打开我的app时
我的app会向服务器发一个请求

00:07:58.779 --> 00:08:03.350 align:middle line:-2
当他们有人打开我的app时
我的app会向服务器发一个请求

00:08:03.717 --> 00:08:07.754 align:middle line:-1
它会请求一个目前可以卖给

00:08:07.821 --> 00:08:08.689 align:middle line:-1
我的朋友和家人的物品列表

00:08:08.755 --> 00:08:10.157 align:middle line:-1
（我的app）

00:08:10.224 --> 00:08:12.960 align:middle line:-2
当服务器收到这个请求时
它会回应一个JSON文件

00:08:13.026 --> 00:08:15.562 align:middle line:-2
这就表明
这里就是要卖的产品

00:08:17.297 --> 00:08:20.701 align:middle line:-2
从我的服务器
返回的API就是这样的

00:08:21.568 --> 00:08:24.471 align:middle line:-2
它是一个产品列表的数组
其中有些有意思的字段

00:08:24.538 --> 00:08:25.739 align:middle line:-1
你值得去看一下

00:08:25.806 --> 00:08:27.274 align:middle line:-1
（API响应示例）

00:08:27.341 --> 00:08:30.177 align:middle line:-1
例如 每个列表中有个产品ID

00:08:30.244 --> 00:08:33.013 align:middle line:-1
这是个用来标识产品的唯一正整数

00:08:33.080 --> 00:08:36.216 align:middle line:-2
在本例中
它们是些顺序的整数ID

00:08:37.384 --> 00:08:40.320 align:middle line:-1
每个列表还有字符串型的名字和描述

00:08:40.386 --> 00:08:41.788 align:middle line:-1
还有另外一些有类型的字段

00:08:41.855 --> 00:08:43.056 align:middle line:-1
值得我们看一下

00:08:44.124 --> 00:08:45.959 align:middle line:-1
例如 有一个字段是一个布林值

00:08:46.026 --> 00:08:48.462 align:middle line:-2
它表明了这个列表项
是不是已经被卖掉了

00:08:50.030 --> 00:08:51.398 align:middle line:-1
在其中还有一些内部结构

00:08:51.465 --> 00:08:54.234 align:middle line:-2
我们可能会用到
这个字符串型的标签列表

00:08:56.069 --> 00:08:58.739 align:middle line:-1
还有一些字符串型的字段

00:08:58.805 --> 00:09:01.909 align:middle line:-1
呈现的是我们想看的其他数据形式

00:08:58.805 --> 00:09:01.909 align:middle line:-1
呈现的是我们想看的其他数据形式

00:09:02.176 --> 00:09:04.178 align:middle line:-1
例如 URL和日期

00:09:05.712 --> 00:09:07.080 align:middle line:-1
让我们来使用下这个数据

00:09:07.881 --> 00:09:11.852 align:middle line:-2
我的app中 我可从如URL会话
或其他可能网络环境中抓取到该数据

00:09:11.919 --> 00:09:13.654 align:middle line:-1
我会验证其长度

00:09:13.720 --> 00:09:16.156 align:middle line:-1
我的服务器可能会生成一个校验和

00:09:16.223 --> 00:09:17.658 align:middle line:-1
或加密签名来让我进行验证

00:09:20.060 --> 00:09:20.894 align:middle line:-1
在我完成之后

00:09:20.961 --> 00:09:23.730 align:middle line:-1
我可以将该数据传入JSON序列化

00:09:24.631 --> 00:09:28.168 align:middle line:-2
如果该数据的去序列化失败了
JSON序列化会抛出一个错误

00:09:28.235 --> 00:09:29.937 align:middle line:-1
以供你接下来检查 捕捉并处理

00:09:30.003 --> 00:09:31.772 align:middle line:-1
它可能会给我的用户显示对话框

00:09:33.707 --> 00:09:35.108 align:middle line:-1
我们现在的话

00:09:35.175 --> 00:09:37.945 align:middle line:-1
我们就像获取原始数据

00:09:38.011 --> 00:09:40.347 align:middle line:-1
并将其以抽象范围内变为主要数据

00:09:40.747 --> 00:09:42.916 align:middle line:-2
如果出现了任何问题
我们可以处理那个错误

00:09:44.551 --> 00:09:46.053 align:middle line:-1
现在我们需要使用这个数据了

00:09:46.119 --> 00:09:47.254 align:middle line:-1
我们能如何使用它呢？

00:09:47.754 --> 00:09:51.458 align:middle line:-1
JSON是包含着实际值的变量

00:09:52.025 --> 00:09:53.360 align:middle line:-1
所以我可以将其向下转型成

00:09:53.427 --> 00:09:55.596 align:middle line:-1
我想要的字典数组

00:09:56.763 --> 00:09:58.765 align:middle line:-1
我的app这个部分只关注

00:09:58.832 --> 00:10:00.067 align:middle line:-1
与音乐有关的产品列表

00:09:58.832 --> 00:10:00.067 align:middle line:-1
与音乐有关的产品列表

00:10:00.467 --> 00:10:03.470 align:middle line:-2
这样就会过滤掉
所有不含音乐标签的产品

00:10:03.537 --> 00:10:06.073 align:middle line:-1
这里我有标签列表这个子结构

00:10:06.139 --> 00:10:09.710 align:middle line:-2
我可将其向下转型为一个字符串数组
并且可以使用这个数组

00:10:11.578 --> 00:10:12.513 align:middle line:-1
哎呀

00:10:13.847 --> 00:10:17.384 align:middle line:-2
每个这样的强制向下转型
其实都包含着一个隐藏的致命错误

00:10:18.218 --> 00:10:21.722 align:middle line:-2
如果因为API或是数据
在发送到app前发生了变化

00:10:21.788 --> 00:10:24.558 align:middle line:-1
而导致某个转型失败的话

00:10:24.625 --> 00:10:27.528 align:middle line:-1
可能是由于数据损坏或是恶意篡改

00:10:28.529 --> 00:10:29.763 align:middle line:-1
这些向下转型就会失败

00:10:29.830 --> 00:10:33.166 align:middle line:-2
当它们转型失败的时候就会中止
并且会让我的app崩溃

00:10:33.233 --> 00:10:35.502 align:middle line:-1
这会给我的用户带来糟糕的体验

00:10:36.703 --> 00:10:38.238 align:middle line:-1
让我们看看这是如何发生的

00:10:39.039 --> 00:10:41.508 align:middle line:-1
这里是那个示例API响应

00:10:42.409 --> 00:10:44.511 align:middle line:-1
让我们看下这里的标签列表

00:10:44.578 --> 00:10:45.546 align:middle line:-1
（类型验证）

00:10:45.612 --> 00:10:49.116 align:middle line:-1
比如 这里的第二个标签被修改了

00:10:49.516 --> 00:10:51.618 align:middle line:-1
由字符串变成了数字

00:10:51.685 --> 00:10:53.253 align:middle line:-1
它是由第三方恶意篡改的

00:10:53.320 --> 00:10:55.189 align:middle line:-1
或是由于常规数据损坏

00:10:55.255 --> 00:10:56.356 align:middle line:-1
我们不总能分辨出造成的原因

00:10:57.858 --> 00:11:02.329 align:middle line:-2
向下转型这个标签列表会失败
因为它们不是字符串

00:10:57.858 --> 00:11:02.329 align:middle line:-2
向下转型这个标签列表会失败
因为它们不是字符串

00:11:02.396 --> 00:11:05.299 align:middle line:-2
而且我们在进行转型前
从来没有检查过是不是可以转型

00:11:05.933 --> 00:11:06.967 align:middle line:-1
（先验证 再执行）

00:11:07.034 --> 00:11:08.869 align:middle line:-2
为了避免该问题
我们今天会一直强调

00:11:08.936 --> 00:11:12.139 align:middle line:-1
要先验证 再执行

00:11:13.173 --> 00:11:15.976 align:middle line:-1
不要妄下断言你知道数据是什么结构

00:11:16.043 --> 00:11:17.044 align:middle line:-1
先检查一下

00:11:17.411 --> 00:11:18.712 align:middle line:-1
不要盲目假设

00:11:19.546 --> 00:11:20.714 align:middle line:-1
看看如何进行检查

00:11:21.381 --> 00:11:24.184 align:middle line:-1
这里又是第一个强制向下转型

00:11:24.251 --> 00:11:26.820 align:middle line:-1
不要强制向下转型这些值

00:11:27.421 --> 00:11:28.922 align:middle line:-1
我在这里会有条件地向下转型

00:11:32.659 --> 00:11:34.728 align:middle line:-1
这可以让我验证

00:11:35.596 --> 00:11:38.065 align:middle line:-1
该数据是不是包含我真正想要的内容

00:11:38.298 --> 00:11:39.833 align:middle line:-1
如果转型失败的话

00:11:40.667 --> 00:11:43.270 align:middle line:-2
我就可以对错误进行处理
而不是得到致命错误

00:11:44.505 --> 00:11:48.175 align:middle line:-2
同样地 接下来向下转型
那个字符串列表时

00:11:48.242 --> 00:11:52.279 align:middle line:-2
不要强制向下转型
我会进行有条件地向下转型

00:11:52.579 --> 00:11:54.681 align:middle line:-1
在本例中 不会抛出错误

00:11:54.982 --> 00:11:57.985 align:middle line:-2
而是我会给出一个默认值
来让执行继续

00:11:58.185 --> 00:12:00.587 align:middle line:-1
在本例中 我会忽略掉所有

00:11:58.185 --> 00:12:00.587 align:middle line:-1
在本例中 我会忽略掉所有

00:12:00.654 --> 00:12:02.656 align:middle line:-1
无有效标签列表的产品列表项

00:12:03.190 --> 00:12:05.792 align:middle line:-2
我可以抛出一个错误
但是在这里 我不会这么做

00:12:07.828 --> 00:12:10.797 align:middle line:-1
类型验证不是你能在这个阶段所用的

00:12:10.864 --> 00:12:12.766 align:middle line:-1
唯一验证形式

00:12:13.467 --> 00:12:15.936 align:middle line:-1
例如 如果被替换成空的话

00:12:16.003 --> 00:12:17.504 align:middle line:-1
在JSON中是完全有效的

00:12:17.571 --> 00:12:19.039 align:middle line:-1
（可空性验证）

00:12:19.106 --> 00:12:20.674 align:middle line:-1
我看到过一个类似的崩溃

00:12:22.142 --> 00:12:25.712 align:middle line:-2
在Swift中 强静态类型
系统可空性是类型的一部分

00:12:25.913 --> 00:12:28.382 align:middle line:-1
而且你不能将空向下转型成字符串

00:12:28.582 --> 00:12:30.551 align:middle line:-1
所以这个转型是会失败的

00:12:32.886 --> 00:12:36.323 align:middle line:-1
即使所有值都有正确的类型和可空性

00:12:36.390 --> 00:12:39.026 align:middle line:-1
我们还应该注意其他的验证形式

00:12:39.960 --> 00:12:41.895 align:middle line:-1
例如 我说过每个产品列表项

00:12:41.962 --> 00:12:43.397 align:middle line:-1
都有一个正整数ID

00:12:43.463 --> 00:12:45.465 align:middle line:-1
在我的例子中 它们是顺序的整数

00:12:46.033 --> 00:12:48.468 align:middle line:-1
若这些ID中有负数的话有意义吗？

00:12:49.203 --> 00:12:50.204 align:middle line:-1
是没有意义的

00:12:50.270 --> 00:12:52.840 align:middle line:-1
即使它一直是正数

00:12:52.906 --> 00:12:55.409 align:middle line:-1
如果是很大的正整数值有意义吗？

00:12:56.577 --> 00:12:57.978 align:middle line:-1
我卖不了那么多东西

00:12:58.045 --> 00:12:59.346 align:middle line:-1
所以在本例中是没意义的

00:12:59.413 --> 00:13:02.883 align:middle line:-2
这可能是有人想在我的app中
引起溢出

00:12:59.413 --> 00:13:02.883 align:middle line:-2
这可能是有人想在我的app中
引起溢出

00:13:03.617 --> 00:13:05.352 align:middle line:-1
这是你需要注意的地方

00:13:06.987 --> 00:13:09.656 align:middle line:-1
跟范围验证类似的是长度验证

00:13:10.123 --> 00:13:13.026 align:middle line:-1
每个产品列表项都有一个描述

00:13:13.660 --> 00:13:15.662 align:middle line:-1
那么可以让描述是空的吗？

00:13:15.729 --> 00:13:16.797 align:middle line:-1
（长度验证）

00:13:16.864 --> 00:13:17.698 align:middle line:-1
在我的例子中

00:13:17.764 --> 00:13:20.167 align:middle line:-1
我知道在我上传产品列表项的时候

00:13:20.234 --> 00:13:22.402 align:middle line:-1
我总会放一个描述信息的

00:13:22.469 --> 00:13:23.670 align:middle line:-1
所以在我的例子中

00:13:23.737 --> 00:13:24.705 align:middle line:-1
将其设为空是说不通的

00:13:26.073 --> 00:13:28.008 align:middle line:-1
不过即使它不是空的

00:13:28.075 --> 00:13:30.811 align:middle line:-1
填满长度和内容有意义吗？

00:13:31.278 --> 00:13:32.713 align:middle line:-1
是没有意义的

00:13:32.779 --> 00:13:35.282 align:middle line:-2
这里有地方出错了
我需要看一下

00:13:38.051 --> 00:13:39.553 align:middle line:-1
还有一些验证形式

00:13:39.620 --> 00:13:40.888 align:middle line:-1
是我们需要注意的

00:13:40.954 --> 00:13:43.891 align:middle line:-2
即使所有的字段都有正确的类型
可空性

00:13:43.957 --> 00:13:45.926 align:middle line:-1
有如我们预期的范围和长度

00:13:46.426 --> 00:13:49.296 align:middle line:-1
它们的值和内容也同样重要

00:13:50.297 --> 00:13:53.000 align:middle line:-2
每个产品列表项都有一个URL
我可以将其发送给用户

00:13:53.066 --> 00:13:55.135 align:middle line:-2
让他们看到
关于该产品列表项的更多信息

00:13:56.036 --> 00:13:59.573 align:middle line:-2
我是以字符串形式得到的
但它实际上包含了一个URL

00:13:59.640 --> 00:14:02.609 align:middle line:-1
如果它是任意字符串的话有意义吗？

00:13:59.640 --> 00:14:02.609 align:middle line:-1
如果它是任意字符串的话有意义吗？

00:14:02.910 --> 00:14:04.511 align:middle line:-1
在我的例子中是没有意义的

00:14:04.578 --> 00:14:06.780 align:middle line:-1
我想确保它表示的是URL

00:14:07.648 --> 00:14:10.617 align:middle line:-2
但更重要的是
仅仅因为它看着像是个URL

00:14:10.684 --> 00:14:12.719 align:middle line:-1
并不意味着它会指向我的域名

00:14:12.986 --> 00:14:14.955 align:middle line:-1
而这是我非常注意的一点

00:14:15.556 --> 00:14:17.958 align:middle line:-1
我非常想保证我用户的安全性

00:14:18.025 --> 00:14:20.994 align:middle line:-1
我不想发给他们一个网络钓鱼域名

00:14:21.061 --> 00:14:24.198 align:middle line:-2
虽然看起来像是我的网址
但其实不是

00:14:25.299 --> 00:14:27.601 align:middle line:-1
所以这是我很小心留意的一件事

00:14:27.668 --> 00:14:29.469 align:middle line:-1
（值间验证）

00:14:29.536 --> 00:14:32.873 align:middle line:-1
最后 即使每个字段本身是有效的

00:14:32.940 --> 00:14:35.542 align:middle line:-1
有时候字段间的关系也很重要

00:14:37.010 --> 00:14:39.646 align:middle line:-1
例如 每个产品列表项在被创建

00:14:39.713 --> 00:14:41.381 align:middle line:-1
以及最近更新时都会产生一个日期

00:14:42.216 --> 00:14:43.817 align:middle line:-1
它们本身是有效的

00:14:43.884 --> 00:14:46.220 align:middle line:-1
但是如果最近更新的日期

00:14:46.286 --> 00:14:48.088 align:middle line:-2
早于它的创建日期
这样说得通吗？

00:14:49.122 --> 00:14:50.357 align:middle line:-1
不 在我的例子中

00:14:50.424 --> 00:14:52.860 align:middle line:-2
这可能不会在我的app中
造成安全漏洞

00:14:53.293 --> 00:14:55.095 align:middle line:-1
但这可能是你需要注意的地方

00:14:55.162 --> 00:14:57.464 align:middle line:-2
因为它会在出现问题的时候
很好地给你提醒

00:14:57.531 --> 00:14:59.366 align:middle line:-1
或许我不应该信任这个数据

00:15:00.868 --> 00:15:02.669 align:middle line:-2
让我们来看看
如何开始实现这个功能

00:15:03.704 --> 00:15:06.640 align:middle line:-2
这里我写了个函数
来接收这样一个列表

00:15:06.707 --> 00:15:08.542 align:middle line:-1
并且开始验证所有的内容

00:15:09.843 --> 00:15:12.980 align:middle line:-2
我会获得一个列表
并调出产品ID

00:15:13.714 --> 00:15:14.948 align:middle line:-1
这里我们已经学过了

00:15:15.015 --> 00:15:17.618 align:middle line:-2
不要强制将这个ID
向下转型成整型

00:15:17.684 --> 00:15:19.086 align:middle line:-1
而是要有条件地向下转型

00:15:19.520 --> 00:15:22.389 align:middle line:-2
如果这个转型失败
guard语句会失败并抛出一错误

00:15:23.624 --> 00:15:24.658 align:middle line:-1
现在我不想就此打住

00:15:24.725 --> 00:15:26.159 align:middle line:-1
我想要执行范围验证

00:15:26.226 --> 00:15:28.896 align:middle line:-1
以确保这个产品ID也是有效的

00:15:28.962 --> 00:15:30.664 align:middle line:-1
这个ID是正数而且不会太大

00:15:30.731 --> 00:15:33.066 align:middle line:-2
如果出现问题的话
我会抛出一个错误

00:15:36.970 --> 00:15:39.640 align:middle line:-1
然后我想要检查下URL

00:15:39.706 --> 00:15:43.610 align:middle line:-2
我会将其向下转型为字符串
而不是强制向下转型

00:15:44.311 --> 00:15:45.579 align:middle line:-1
这里我可以检查这个链接

00:15:45.646 --> 00:15:49.082 align:middle line:-2
在我的例子中 我知道
我的服务器不会生成太长的URL

00:15:49.149 --> 00:15:52.519 align:middle line:-2
所以如果我发现了一个很长的URL
我就会知道它是无效的

00:15:54.054 --> 00:15:57.057 align:middle line:-2
在我验证了它之后
我会将它以URL类型

00:15:57.124 --> 00:16:00.327 align:middle line:-2
执行特定域名验证
以确保它真的是一个URL

00:15:57.124 --> 00:16:00.327 align:middle line:-2
执行特定域名验证
以确保它真的是一个URL

00:16:00.394 --> 00:16:01.762 align:middle line:-1
而不是一个垃圾字符串

00:16:01.828 --> 00:16:04.331 align:middle line:-2
同样地 如果出现问题的话
我会抛出一个错误

00:16:05.766 --> 00:16:09.102 align:middle line:-2
我不想止步于此
在我获得一个真正的URL后

00:16:09.169 --> 00:16:12.272 align:middle line:-2
我想要确保它会指向我的域名
而不是钓鱼网站

00:16:12.606 --> 00:16:13.807 align:middle line:-1
我会留意这一点

00:16:15.409 --> 00:16:16.276 align:middle line:-1
在这里

00:16:16.343 --> 00:16:18.912 align:middle line:-2
我可以将相同类型的验证
app到其他字段上

00:16:18.979 --> 00:16:21.215 align:middle line:-2
如果出现问题的话
我会抛出一个错误

00:16:21.715 --> 00:16:22.783 align:middle line:-1
有了这个函数

00:16:22.850 --> 00:16:26.486 align:middle line:0
我可以将其app到所有
我从负载中所加载的产品列表项

00:16:27.487 --> 00:16:30.724 align:middle line:0
如果出现问题的话
我就会停止执行

00:16:33.894 --> 00:16:36.697 align:middle line:-1
这就是我们要如何来验证主要数据

00:16:37.264 --> 00:16:39.399 align:middle line:-1
如我们所见 主要数据是很笼统的

00:16:39.466 --> 00:16:40.601 align:middle line:-1
（结构化数据）

00:16:40.667 --> 00:16:45.739 align:middle line:-2
字符串可以是字符串
但也可以是日期

00:16:46.507 --> 00:16:48.642 align:middle line:-1
也可以是一个URL

00:16:50.577 --> 00:16:54.515 align:middle line:-2
有时候我们希望数据的语义
是和我们有关系的

00:16:54.748 --> 00:16:57.818 align:middle line:-2
我们想确保URL的主机名
是我们的域名

00:16:57.885 --> 00:17:00.020 align:middle line:-1
而使用常规的字符串是做不到的

00:16:57.885 --> 00:17:00.020 align:middle line:-1
而使用常规的字符串是做不到的

00:17:01.555 --> 00:17:05.325 align:middle line:-2
与之相似的 字典可以表示
像是这个列表一样的模型

00:17:05.626 --> 00:17:07.627 align:middle line:-1
或是表示任意的我们根本不了解的

00:17:07.694 --> 00:17:08.962 align:middle line:-1
用户数据

00:17:10.163 --> 00:17:12.465 align:middle line:-1
不用在各个地方执行相同的验证

00:17:12.532 --> 00:17:14.902 align:middle line:-1
来保证所有我们关注的字段是有效的

00:17:14.968 --> 00:17:17.204 align:middle line:-1
而是使用我们自己的模型类型

00:17:17.271 --> 00:17:19.339 align:middle line:-1
保障总是在那里不是很好吗？

00:17:21.108 --> 00:17:22.675 align:middle line:-1
是的 在我们的例子中

00:17:22.976 --> 00:17:25.811 align:middle line:-2
我们想在所有可能的地方
使用结构化数据

00:17:25.878 --> 00:17:28.281 align:middle line:-2
我们可以将主要数据
作为构件块来使用

00:17:28.715 --> 00:17:30.384 align:middle line:-1
不过我们想处理那个数据形式

00:17:31.285 --> 00:17:32.786 align:middle line:-1
让我们来看下要如何实现

00:17:35.522 --> 00:17:37.991 align:middle line:-1
在我app的其他地方有个购买类型

00:17:38.058 --> 00:17:39.393 align:middle line:-1
就像是这样

00:17:40.561 --> 00:17:44.031 align:middle line:-2
当有顾客进行购买时
我会将该数据存储到磁盘上

00:17:44.097 --> 00:17:45.465 align:middle line:-1
然后当他们打开app时

00:17:45.532 --> 00:17:47.434 align:middle line:-1
即使他们没有连接到网络

00:17:47.501 --> 00:17:49.102 align:middle line:-1
也可浏览自己的购买历史纪录

00:17:50.103 --> 00:17:52.239 align:middle line:-1
每条购买记录会追踪

00:17:52.306 --> 00:17:53.407 align:middle line:-1
它所对应产品列表项

00:17:53.473 --> 00:17:56.610 align:middle line:-2
是何时进行的购买
以及一个收据

00:17:58.378 --> 00:18:02.182 align:middle line:-2
我可以像这样 利用NS编码
和NS键归档将其保存到磁盘上

00:17:58.378 --> 00:18:02.182 align:middle line:-2
我可以像这样 利用NS编码
和NS键归档将其保存到磁盘上

00:18:02.249 --> 00:18:03.350 align:middle line:-1
我会对它进行归档

00:18:04.151 --> 00:18:06.320 align:middle line:-2
但正如我们所见
当我们解压数据的时候

00:18:06.386 --> 00:18:09.690 align:middle line:-2
我们在处理原始数据和主要数据时
我们要对它进行验证

00:18:10.724 --> 00:18:12.159 align:middle line:-1
让我们看看

00:18:12.226 --> 00:18:13.794 align:middle line:-1
这里的编码器是如何初始化的

00:18:14.328 --> 00:18:15.796 align:middle line:-1
若你曾写过编码器初始化方法

00:18:15.863 --> 00:18:17.197 align:middle line:-1
这可能让你看上去很熟悉

00:18:17.798 --> 00:18:20.434 align:middle line:-1
我们要先解码这个产品列表项

00:18:20.501 --> 00:18:22.703 align:middle line:-2
我们提到了
要用有条件地向下转型

00:18:22.769 --> 00:18:24.438 align:middle line:-1
而不是强制向下转型

00:18:25.038 --> 00:18:27.841 align:middle line:-2
如果出现问题的话
这是个可出错的初始化器

00:18:27.908 --> 00:18:29.676 align:middle line:-1
我们返回空就好了 对吧？

00:18:31.078 --> 00:18:34.147 align:middle line:-2
如果解码成功了
我会将其分配给我的属性

00:18:34.214 --> 00:18:35.215 align:middle line:-1
然后接着操作

00:18:35.749 --> 00:18:37.351 align:middle line:-1
我会对购买数据做相同的处理

00:18:37.417 --> 00:18:39.419 align:middle line:-1
有条件地向下转型为日期

00:18:39.486 --> 00:18:41.989 align:middle line:-2
如果出现问题了
我会失败 诸如此类

00:18:42.055 --> 00:18:44.124 align:middle line:-2
我对我类型的每个字段
都重复这个操作

00:18:45.959 --> 00:18:48.629 align:middle line:-2
当我想将其中一个购买记录
保存到历史纪录时

00:18:48.695 --> 00:18:50.797 align:middle line:-1
我有一个函数可以让我这么做

00:18:50.864 --> 00:18:54.434 align:middle line:-1
它会将购买记录归档为二进制数据

00:18:55.435 --> 00:18:56.803 align:middle line:-1
随后我将其保存到磁盘上

00:18:56.870 --> 00:18:59.206 align:middle line:-1
或是将该数据保存到数据库等处

00:19:01.108 --> 00:19:03.877 align:middle line:-2
当我想将数据加载回来时
我可以进行相同的操作

00:19:03.944 --> 00:19:08.015 align:middle line:-2
我可以获得原始数据 然后将其传给
KeyedUnarchiver

00:19:08.081 --> 00:19:09.483 align:middle line:-1
然后得到一个返回的对象

00:19:11.418 --> 00:19:15.155 align:middle line:-2
正如我们所说的 在这的每个点
数据都会变得更为复杂

00:19:15.355 --> 00:19:17.791 align:middle line:-1
在我们可能信任它之前

00:19:17.858 --> 00:19:18.792 align:middle line:-1
我们还得对它进行更多验证

00:19:19.459 --> 00:19:21.628 align:middle line:-2
你可能会感到奇怪
“好的 有什么呢？

00:19:21.695 --> 00:19:23.263 align:middle line:-1
还剩下什么可验证的呢？”

00:19:23.931 --> 00:19:26.300 align:middle line:-1
这里的向下转型就是一个不错的点

00:19:27.968 --> 00:19:31.772 align:middle line:-2
这个向下转型是发生于
我们解压对象后

00:19:32.706 --> 00:19:34.174 align:middle line:-1
这怎么会失败呢？

00:19:35.242 --> 00:19:37.578 align:middle line:-1
这表示有些其他的问题出现了

00:19:37.644 --> 00:19:38.946 align:middle line:-1
让我们来看一下

00:19:39.012 --> 00:19:40.614 align:middle line:-1
（有键归档中的模型表示）

00:19:40.681 --> 00:19:42.282 align:middle line:-1
这是个我的归档中的模型对象的

00:19:42.349 --> 00:19:45.185 align:middle line:-1
抽象表示

00:19:46.286 --> 00:19:48.889 align:middle line:-1
这里有所有我们在编程中关心的字段

00:19:49.089 --> 00:19:51.558 align:middle line:-1
每个字段都包含自己的结构 子结构

00:19:51.625 --> 00:19:52.993 align:middle line:-1
以及内容等等

00:19:53.760 --> 00:19:55.095 align:middle line:-1
但这里有意思的是

00:19:55.662 --> 00:20:00.300 align:middle line:-1
这个表示还包含了这个对象的类名

00:19:55.662 --> 00:20:00.300 align:middle line:-1
这个表示还包含了这个对象的类名

00:20:01.535 --> 00:20:04.538 align:middle line:-2
让我们来看下KeyedUnarchiver
是如何使用这个信息的

00:20:05.339 --> 00:20:07.908 align:middle line:-1
我们正在进行一个解码调用

00:20:08.442 --> 00:20:10.611 align:middle line:-2
这会创建一个
KeyedUnarchiver

00:20:10.677 --> 00:20:12.946 align:middle line:-1
并为对象键解码一个对象

00:20:13.013 --> 00:20:14.715 align:middle line:-1
（对象解码）

00:20:14.781 --> 00:20:16.316 align:middle line:-2
当你在KeyedUnarchiver中
执行它时

00:20:16.383 --> 00:20:19.786 align:middle line:-2
KeyedUnarchiver
会在归档的对象中查找该类名

00:20:20.187 --> 00:20:21.221 align:middle line:-1
并将它调出来

00:20:21.655 --> 00:20:24.958 align:middle line:-2
然后在你的app中
动态查找有着相同名字的类

00:20:26.660 --> 00:20:29.463 align:middle line:-1
然后它会分配该类的一个实例

00:20:29.863 --> 00:20:33.367 align:middle line:-2
将其初始化
以便它可以解码自己的内容

00:20:34.735 --> 00:20:38.205 align:middle line:-2
然后它会唤醒对象
让对象可以结束自己的状态

00:20:40.908 --> 00:20:43.043 align:middle line:-1
我们的对象用起来很好

00:20:43.410 --> 00:20:47.147 align:middle line:-2
不过我们可能会感到奇怪
如果数据被恶意篡改

00:20:47.214 --> 00:20:49.917 align:middle line:-2
包含了一个我们不想要的
类的对象呢？

00:20:51.518 --> 00:20:53.620 align:middle line:-1
我们刚执行过的整个过程

00:20:53.987 --> 00:20:55.556 align:middle line:-1
会以不同的类型出现

00:20:56.456 --> 00:20:58.792 align:middle line:-1
我们分配、初始化

00:20:59.126 --> 00:21:01.895 align:middle line:-2
并且唤醒了一个
我们不想要的类的对象

00:20:59.126 --> 00:21:01.895 align:middle line:-2
并且唤醒了一个
我们不想要的类的对象

00:21:02.863 --> 00:21:04.431 align:middle line:-1
这会对app产生何种影响呢？

00:21:06.133 --> 00:21:08.869 align:middle line:-2
正如我们之前所见
这里的有条件地向下转型

00:21:08.936 --> 00:21:12.272 align:middle line:-2
会防止我们意外地使用
这个不想要的类的对象

00:21:12.739 --> 00:21:15.876 align:middle line:-2
我们只会用
我们想要的类型的对象

00:21:15.943 --> 00:21:18.178 align:middle line:-2
向下转型失败的话
我们就会出错

00:21:20.781 --> 00:21:24.284 align:middle line:-2
但解码这样一个对象会对app
产生一个持续的影响

00:21:24.685 --> 00:21:28.655 align:middle line:-2
比方说这个类有个
会改变全局状态的alloc方法

00:21:28.722 --> 00:21:31.792 align:middle line:-2
它可能会分配一个单例
或是改变某个全局数据

00:21:33.460 --> 00:21:35.963 align:middle line:-2
即便我们扔掉了这个对象
如果出错的话

00:21:36.029 --> 00:21:37.865 align:middle line:-1
这会对app产生一个持续的影响

00:21:37.931 --> 00:21:40.267 align:middle line:-1
并且会导致某处出现异常行为

00:21:40.334 --> 00:21:43.737 align:middle line:-1
而且归档可以这种方式被恶意构造

00:21:43.804 --> 00:21:45.539 align:middle line:-1
从而导致我们app发生这种问题

00:21:46.673 --> 00:21:48.976 align:middle line:-2
我们该如何验证这数据
防止这样的问题呢？

00:21:50.277 --> 00:21:52.746 align:middle line:-2
NSSecureCoding协议
这时候就会起作用了

00:21:52.813 --> 00:21:53.814 align:middle line:-1
（NSSECURECODING）

00:21:53.881 --> 00:21:57.317 align:middle line:-2
NSSecureCoding
是继承于NSCoding的协议

00:21:57.918 --> 00:22:01.421 align:middle line:-1
其目标就是为了防止这类攻击

00:21:57.918 --> 00:22:01.421 align:middle line:-1
其目标就是为了防止这类攻击

00:22:01.488 --> 00:22:02.890 align:middle line:-2
（NSSECURECODING
的目标）

00:22:02.956 --> 00:22:06.426 align:middle line:-1
通过让你提前传入类型信息

00:22:06.994 --> 00:22:10.964 align:middle line:-2
它会防止验证归档内容
随意的代码执行

00:22:11.031 --> 00:22:13.834 align:middle line:-1
以确保它只包含你想要的类型

00:22:15.969 --> 00:22:18.138 align:middle line:-2
NSSecureCoding
的标志性内容

00:22:18.205 --> 00:22:21.141 align:middle line:-2
为键解码对象
的两种替代方法

00:22:21.208 --> 00:22:23.844 align:middle line:-1
它可以让你提前传入类型信息

00:22:24.711 --> 00:22:27.681 align:middle line:-2
通过使用该类型信息
NSKeyedUnarchiver可以保证你的安全

00:22:27.748 --> 00:22:28.916 align:middle line:-2
（NSSECURECODING中
的对象解码）

00:22:28.982 --> 00:22:30.584 align:middle line:-1
让我们来看下目前应对键调用

00:22:30.651 --> 00:22:32.052 align:middle line:-1
的解码对象

00:22:32.119 --> 00:22:33.487 align:middle line:-1
这个最上层解码

00:22:34.721 --> 00:22:36.657 align:middle line:-1
如果我们使用变量

00:22:36.723 --> 00:22:38.825 align:middle line:-1
让我们提前传入这个类

00:22:38.892 --> 00:22:40.794 align:middle line:-1
在本例中 我们想解码购买记录

00:22:41.528 --> 00:22:44.932 align:middle line:-2
不用执行整个过程
以及归档中的内容

00:22:45.699 --> 00:22:47.935 align:middle line:-1
你可以先进行类检查

00:22:49.169 --> 00:22:50.971 align:middle line:0
让我们看下这个类检查

00:22:52.906 --> 00:22:55.542 align:middle line:0
在解码的每个阶段
如果开启了安全编码

00:22:55.609 --> 00:22:58.045 align:middle line:0
NSKeyedUnarchiver
会维护一个可以有效解码的

00:22:58.111 --> 00:22:59.580 align:middle line:0
类的列表

00:23:01.114 --> 00:23:03.884 align:middle line:0
当我们进行这么一个调用时
NSKeyedUnarchiver

00:23:03.951 --> 00:23:06.753 align:middle line:0
会利用我们使用的对象
也就是这个类

00:23:07.054 --> 00:23:09.323 align:middle line:0
并从这个类
构造一个允许的类的列表

00:23:10.924 --> 00:23:14.027 align:middle line:0
当我们接着
从归档中解码一个对象时

00:23:14.094 --> 00:23:17.130 align:middle line:0
允许的类列表
会首先检查这个类

00:23:17.431 --> 00:23:18.732 align:middle line:0
如果它没有出现在列表中

00:23:19.499 --> 00:23:21.201 align:middle line:0
这个解码调用就会被拒绝

00:23:22.803 --> 00:23:25.639 align:middle line:0
如果我们在归档中
找到的类的对象

00:23:25.706 --> 00:23:27.074 align:middle line:0
出现在允许的类列表中

00:23:27.608 --> 00:23:29.376 align:middle line:0
我们需要执行几个检查

00:23:30.577 --> 00:23:32.913 align:middle line:0
我们需要保证这个类本身

00:23:32.980 --> 00:23:34.915 align:middle line:0
也遵从于
NSSecureCoding

00:23:35.883 --> 00:23:38.285 align:middle line:0
如果它不遵从的话
我们就没法保证它本身

00:23:38.352 --> 00:23:41.054 align:middle line:0
会在后面安全地
解码它自己的内容

00:23:41.488 --> 00:23:43.991 align:middle line:0
那样的话我们就不能
安全地解码其中的对象了

00:23:44.992 --> 00:23:46.760 align:middle line:0
在我们的例子中
这个购买记录类遵从于该协议

00:23:46.827 --> 00:23:48.595 align:middle line:0
所以它可以安全地解码并追踪

00:23:50.030 --> 00:23:51.031 align:middle line:0
还有其他两种检查

00:23:51.098 --> 00:23:54.301 align:middle line:0
是跟超类、子类关系有关的

00:23:55.669 --> 00:23:58.505 align:middle line:0
如果你有两个类
一个是另一个的子类

00:23:58.572 --> 00:24:00.207 align:middle line:0
两个类都遵从NSCoding

00:23:58.572 --> 00:24:00.207 align:middle line:0
两个类都遵从NSCoding

00:24:00.507 --> 00:24:03.477 align:middle line:0
超类采用了
NSSecureCoding一致性

00:24:03.977 --> 00:24:06.446 align:middle line:0
而子类继承了这个一致性

00:24:07.848 --> 00:24:10.384 align:middle line:-1
子类没有办法

00:24:10.450 --> 00:24:13.187 align:middle line:-2
重写编码器的初始化
来实现安全性方面的功能

00:24:13.754 --> 00:24:15.322 align:middle line:-1
所以这里我们有一个出口

00:24:17.124 --> 00:24:19.660 align:middle line:-2
支持安全编码的方法
可以让你说

00:24:19.726 --> 00:24:22.129 align:middle line:-1
我其实不支持安全编码

00:24:22.329 --> 00:24:25.666 align:middle line:-2
并且你可以把这个功能关了说
“我还没准备好”

00:24:26.834 --> 00:24:29.403 align:middle line:-1
如果你还是说支持

00:24:29.469 --> 00:24:32.206 align:middle line:-1
我们得确保 你或是继承了

00:24:32.272 --> 00:24:35.409 align:middle line:-2
来自超类 对于NSSecureCoding
的完全一致性

00:24:35.709 --> 00:24:37.744 align:middle line:-1
或是你覆盖了这两个方法

00:24:38.078 --> 00:24:40.914 align:middle line:-2
表明
是的 我真的支持安全编码

00:24:40.981 --> 00:24:42.316 align:middle line:-1
这里没有问题

00:24:44.151 --> 00:24:46.720 align:middle line:-2
在我们的例子中
购买记录符合这些需求

00:24:46.787 --> 00:24:48.922 align:middle line:-2
所以我们可以从归档中
安全地对其进行解码

00:24:51.592 --> 00:24:53.560 align:middle line:-1
现在让我们解码一个购买记录

00:24:53.627 --> 00:24:55.596 align:middle line:-1
它本身会解码一个列表项

00:24:55.662 --> 00:24:57.331 align:middle line:-1
并且它会利用相同类型的调用

00:24:57.397 --> 00:24:58.966 align:middle line:-1
来表明它想要一个列表项

00:24:59.366 --> 00:25:00.968 align:middle line:-2
（利用NSSECURECODING
来解码对象）

00:24:59.366 --> 00:25:00.968 align:middle line:-2
（利用NSSECURECODING
来解码对象）

00:25:01.034 --> 00:25:03.003 align:middle line:-2
当它这么做的时候
NSKeyedUnarchiver

00:25:03.070 --> 00:25:05.873 align:middle line:-2
会使用这个类
来构造一个新的允许类列表

00:25:06.340 --> 00:25:08.675 align:middle line:-2
这个新版本的列表的
所有内容都会被检查

00:25:09.877 --> 00:25:12.679 align:middle line:-2
我们解码一个对象时
会执行相同的检查

00:25:12.746 --> 00:25:14.982 align:middle line:-2
在本例中
列表项仍然是可以有效编码的

00:25:17.851 --> 00:25:18.785 align:middle line:-1
但是…

00:25:18.852 --> 00:25:21.488 align:middle line:-1
如果我们试图解码一个不在列表中的

00:25:21.555 --> 00:25:23.390 align:middle line:-2
不想要的类的对象的话
它会被拒绝

00:25:25.726 --> 00:25:28.495 align:middle line:-2
让我们看下
这样的拒绝是什么样的

00:25:28.929 --> 00:25:30.564 align:middle line:-1
这叫做解码失败

00:25:30.631 --> 00:25:32.032 align:middle line:-1
还有几种类型的失败

00:25:32.099 --> 00:25:33.300 align:middle line:-1
我们应该留意一下

00:25:33.734 --> 00:25:35.235 align:middle line:-1
当开启了安全编码时

00:25:35.302 --> 00:25:37.004 align:middle line:-1
我们可以看到像是这样的

00:25:37.070 --> 00:25:38.138 align:middle line:-1
违反安全解码

00:25:38.205 --> 00:25:40.007 align:middle line:-1
还有其他的失败形式

00:25:41.375 --> 00:25:43.677 align:middle line:-1
例如 如果你试图解码对象的话

00:25:43.744 --> 00:25:46.413 align:middle line:-2
可能会出现类型的不匹配
出现在这个位置的归档中

00:25:46.480 --> 00:25:48.715 align:middle line:-1
有一个像是整数的主要值

00:25:49.116 --> 00:25:52.186 align:middle line:-2
或者你试图解码一个
像是整数的主要值

00:25:52.252 --> 00:25:53.754 align:middle line:-1
但我们找到一个

00:25:53.820 --> 00:25:56.256 align:middle line:-2
不兼容类型的对象或是主要值
像是双整形

00:25:57.024 --> 00:25:58.625 align:middle line:-1
这就会导致解码失败

00:25:58.692 --> 00:26:00.460 align:middle line:-1
（解码失败）

00:25:58.692 --> 00:26:00.460 align:middle line:-1
（解码失败）

00:26:00.527 --> 00:26:02.896 align:middle line:-1
这里还有可能出现另一个形式的失败

00:26:02.963 --> 00:26:04.097 align:middle line:-1
那就是归档损坏

00:26:04.164 --> 00:26:05.899 align:middle line:-1
如果归档本身损坏严重

00:26:05.966 --> 00:26:09.369 align:middle line:-2
而且不符合
NSKeyedUnarchiver所期望的格式

00:26:09.436 --> 00:26:11.171 align:middle line:-1
我们就不能解码任何内容

00:26:11.238 --> 00:26:12.806 align:middle line:-1
因此你就会得到相同类型的失败

00:26:14.908 --> 00:26:16.743 align:middle line:-1
出现失败时会发生什么

00:26:16.810 --> 00:26:20.447 align:middle line:-2
是取决于Unarchiver上的
解码失败政策的

00:26:20.848 --> 00:26:21.949 align:middle line:-1
这里有两个选项

00:26:22.850 --> 00:26:24.818 align:middle line:-2
在失败的时候
我们可以抛出一个异常

00:26:25.752 --> 00:26:29.156 align:middle line:-2
或是储存出现问题的有关信息
并继续执行

00:26:29.923 --> 00:26:32.125 align:middle line:-1
抛出异常是当前的默认选项

00:26:34.027 --> 00:26:36.730 align:middle line:-1
如果我们有个来自前面的调用

00:26:36.797 --> 00:26:38.165 align:middle line:-1
试图解码一个列表项

00:26:38.465 --> 00:26:41.468 align:middle line:-2
我们会在归档中
找到一个不想要的类的对象

00:26:42.135 --> 00:26:44.505 align:middle line:-2
它会在底层调用
failWithError这个方法

00:26:44.571 --> 00:26:45.572 align:middle line:-1
这个方法在Unarchiver中

00:26:46.106 --> 00:26:49.343 align:middle line:-2
并会传入一个表明了
在哪出现了什么问题的错误

00:26:50.577 --> 00:26:53.380 align:middle line:-2
在底层 failWithError
要做个决定

00:26:54.314 --> 00:26:56.683 align:middle line:-2
如果解码失败政策
是抛出异常的话

00:26:56.750 --> 00:26:58.619 align:middle line:-1
它就会抛出异常

00:26:59.319 --> 00:27:00.354 align:middle line:-1
如果你在写Swift app

00:26:59.319 --> 00:27:00.354 align:middle line:-1
如果你在写Swift app

00:27:00.420 --> 00:27:01.855 align:middle line:-1
这是你需要留心的东西

00:27:02.422 --> 00:27:05.259 align:middle line:-2
Swift不能捕捉
Objective-C或C++异常

00:27:05.325 --> 00:27:07.628 align:middle line:-2
所以这可能会导致
你的app出现致命错误

00:27:07.895 --> 00:27:11.532 align:middle line:-2
这会导致出现崩溃
并给用户带来糟糕的体验

00:27:13.367 --> 00:27:16.370 align:middle line:-2
如果解码失败政策
是设定错误并返回的话

00:27:16.436 --> 00:27:19.006 align:middle line:-2
该错误会被分配到
Unarchiver的错误属性

00:27:19.506 --> 00:27:21.074 align:middle line:-1
然后会继续执行

00:27:21.742 --> 00:27:24.144 align:middle line:-1
在本例中 因为会继续执行

00:27:24.211 --> 00:27:26.547 align:middle line:-1
解码调用必须得返回某些内容

00:27:26.613 --> 00:27:29.917 align:middle line:-2
所以它会返回空
来表明没有任何内容可以被解码

00:27:31.818 --> 00:27:33.987 align:middle line:-2
如我们所提过的
如果你要解码一个主要类型

00:27:34.054 --> 00:27:37.824 align:middle line:-2
而且我们找到一个
不兼容的对象或是主要类型

00:27:38.225 --> 00:27:39.960 align:middle line:-1
那么就会出现一系列相同的步骤

00:27:40.027 --> 00:27:41.929 align:middle line:-1
本例中 就会不返回空

00:27:41.995 --> 00:27:43.897 align:middle line:-1
我们就返回零

00:27:47.634 --> 00:27:50.204 align:middle line:-2
failWithError是
NSKeyedUnarchiver上的API

00:27:50.270 --> 00:27:53.707 align:middle line:-2
我鼓励你们使用自己的代码
来表明失败的出现

00:27:53.774 --> 00:27:55.142 align:middle line:-1
以及出现了什么问题

00:27:55.609 --> 00:27:57.211 align:middle line:-1
这里不会返回空

00:27:57.277 --> 00:27:59.913 align:middle line:-2
failWithError
首先会记录该信息

00:27:59.980 --> 00:28:01.348 align:middle line:-1
（失败得有意义）

00:27:59.980 --> 00:28:01.348 align:middle line:-1
（失败得有意义）

00:28:01.415 --> 00:28:03.383 align:middle line:-2
如果你这么做的话
需要记住几件事

00:28:04.451 --> 00:28:07.287 align:middle line:-2
如果解码失败政策
是设定一个错误并返回的话

00:28:07.688 --> 00:28:10.357 align:middle line:-2
你要记住
在Unarchiver上设定错误后

00:28:10.424 --> 00:28:11.792 align:middle line:-1
后面就不能重设了

00:28:12.826 --> 00:28:14.995 align:middle line:-1
这是因为一个解码失败

00:28:15.062 --> 00:28:17.331 align:middle line:-1
经常会导致一系列的解码失败

00:28:17.698 --> 00:28:19.800 align:middle line:-2
我们不想丢掉
最初是哪里出现了问题

00:28:22.369 --> 00:28:25.372 align:middle line:-2
其次你要记住 任何给定的
failWithError调用

00:28:25.439 --> 00:28:28.008 align:middle line:-2
要么会抛出一个异常
要么就会继续执行

00:28:28.742 --> 00:28:30.644 align:middle line:-1
所以这两种选项你都要留意

00:28:30.711 --> 00:28:32.246 align:middle line:-2
特别是你在用
Objective-C时

00:28:32.312 --> 00:28:33.947 align:middle line:-1
你可能会捕捉到异常

00:28:34.248 --> 00:28:35.582 align:middle line:-1
有些内容你需要处理一下

00:28:37.084 --> 00:28:39.953 align:middle line:-2
最后 要留意下
空或零返回值

00:28:40.454 --> 00:28:42.956 align:middle line:-2
这两个值在解码失败的时候
都有可能出现

00:28:43.023 --> 00:28:45.626 align:middle line:-2
如果解码失败政策
是设定错误并返回的话

00:28:46.059 --> 00:28:48.061 align:middle line:-1
或是数据刚刚丢失了的话

00:28:48.128 --> 00:28:50.464 align:middle line:-1
或是被编码成空或零

00:28:50.998 --> 00:28:53.033 align:middle line:-1
为了消除这些情况间的歧义

00:28:53.100 --> 00:28:55.002 align:middle line:-2
你要检查Unarchiver
上的错误属性

00:28:57.704 --> 00:28:59.339 align:middle line:-1
我们介绍了很多内容

00:28:59.907 --> 00:29:01.508 align:middle line:-1
让我们将其提炼成一个清单

00:28:59.907 --> 00:29:01.508 align:middle line:-1
让我们将其提炼成一个清单

00:29:01.575 --> 00:29:04.278 align:middle line:-2
看看如何在我们自己的类型上
采用NSSecureCoding

00:29:05.412 --> 00:29:08.348 align:middle line:-2
开始时我们会将
所有键调用的解码对象

00:29:08.415 --> 00:29:11.151 align:middle line:-2
转变成允许我们
提前传入类型信息的变量

00:29:11.218 --> 00:29:12.619 align:middle line:-2
（采用
NSSECURECODING的清单）

00:29:12.686 --> 00:29:15.055 align:middle line:-2
随后如果出现了问题
不要只是返回空

00:29:15.122 --> 00:29:17.191 align:middle line:-2
用failWithError
来表明出现了什么问题

00:29:18.659 --> 00:29:21.995 align:middle line:-2
最后 这是个审计
未来失败点的好机会

00:29:22.062 --> 00:29:24.264 align:middle line:-1
我们还没有对这些点进行过验证

00:29:24.798 --> 00:29:26.033 align:middle line:-1
让我们这么做吧

00:29:27.267 --> 00:29:30.304 align:middle line:-1
这里有个解码调用来解码列表项

00:29:30.504 --> 00:29:33.507 align:middle line:-2
你会发现如果我们
提前传入类型信息的话

00:29:33.574 --> 00:29:35.742 align:middle line:-2
有条件地向下转型
随后会消失

00:29:36.910 --> 00:29:38.745 align:middle line:-1
这个方法有个一般覆盖

00:29:38.812 --> 00:29:41.148 align:middle line:-1
在静态地给出类型信息时

00:29:41.215 --> 00:29:44.084 align:middle line:-1
会让你没法再有条件地向下转型

00:29:44.151 --> 00:29:46.119 align:middle line:-1
你可以一直获得该类的对象

00:29:47.554 --> 00:29:50.657 align:middle line:-1
不要在失败时返回空

00:29:50.724 --> 00:29:52.259 align:middle line:-1
我们想要失败得有意义

00:29:52.492 --> 00:29:56.096 align:middle line:-2
我们可以在失败时 创建一个
表明在哪出现了什么问题的错误

00:29:57.197 --> 00:29:58.031 align:middle line:-1
在本例中

00:29:58.098 --> 00:30:00.634 align:middle line:-2
我们可以使用CocoaError
上的便利内容

00:29:58.098 --> 00:30:00.634 align:middle line:-2
我们可以使用CocoaError
上的便利内容

00:30:00.701 --> 00:30:03.237 align:middle line:-2
来返回一个包含好的
本地化描述的有意义错误

00:30:03.303 --> 00:30:05.339 align:middle line:-1
让我们的用户知道出现了什么问题

00:30:06.840 --> 00:30:09.276 align:middle line:-1
如果需要的话 我们可以给自己

00:30:09.343 --> 00:30:10.944 align:middle line:-2
后面日志上
添加debug描述

00:30:11.011 --> 00:30:12.079 align:middle line:-1
但这个是核心

00:30:12.145 --> 00:30:14.481 align:middle line:-2
返回空之前 我们想用
failWithError方法

00:30:17.017 --> 00:30:20.020 align:middle line:-1
随后我们解码了购买日期

00:30:20.921 --> 00:30:24.224 align:middle line:-1
这里也是个好机会 让我们添加

00:30:24.291 --> 00:30:25.526 align:middle line:-1
之前没有进行的验证

00:30:26.627 --> 00:30:30.063 align:middle line:-2
如果我们可以解码日期的话
我储存这个属性就可以了

00:30:30.497 --> 00:30:33.100 align:middle line:-1
但我想保证这个日期是有效的

00:30:33.433 --> 00:30:35.669 align:middle line:-1
例如 购买是不可能在

00:30:35.736 --> 00:30:37.771 align:middle line:-2
我的app在App Store
上架前就发生的

00:30:38.038 --> 00:30:39.173 align:middle line:-1
这些是你可以检查的内容

00:30:39.239 --> 00:30:43.343 align:middle line:-2
若这里出现问题 我们想在失败时
获得一个有意义的错误

00:30:44.311 --> 00:30:46.079 align:middle line:-1
在本例中 数据没有丢失

00:30:46.146 --> 00:30:48.582 align:middle line:-2
而是数据被损坏了
或者说在某种程度上是无效的

00:30:48.649 --> 00:30:50.217 align:middle line:-1
我们会表明这一点

00:30:51.952 --> 00:30:53.220 align:middle line:-2
（NSSECURECODING
的采用清单）

00:30:53.287 --> 00:30:56.356 align:middle line:-2
现在我们已经
在我们的类型上这么做了

00:30:56.790 --> 00:31:00.160 align:middle line:-2
我们就可以声明
它是支持安全编码的了

00:30:56.790 --> 00:31:00.160 align:middle line:-2
我们就可以声明
它是支持安全编码的了

00:31:00.727 --> 00:31:03.897 align:middle line:-2
最后遵从
NSSecureCoding协议

00:31:03.964 --> 00:31:06.433 align:middle line:-1
来表明我们想要运行时间

00:31:06.500 --> 00:31:08.502 align:middle line:-1
它真的支持安全编码

00:31:10.504 --> 00:31:12.873 align:middle line:-1
然后 恭喜你

00:31:12.940 --> 00:31:14.942 align:middle line:-2
我们获得了
NSSecureCoding徽章

00:31:15.008 --> 00:31:16.543 align:middle line:-1
实际的徽章是分开卖的

00:31:19.446 --> 00:31:22.749 align:middle line:-2
我们觉得 获得你自己的
NSSecureCoding徽章

00:31:22.816 --> 00:31:23.951 align:middle line:-2
并使用它们
对你而言是很重要的

00:31:24.017 --> 00:31:26.620 align:middle line:-2
今年我们添加了新的API
和NSKeyedUnarchiver

00:31:26.687 --> 00:31:29.656 align:middle line:-2
保证了NSSecureCoding
随时可以完成

00:31:30.157 --> 00:31:31.158 align:middle line:-1
（默认安全的API）

00:31:31.225 --> 00:31:33.493 align:middle line:-1
这个新的初始化器和便利方法

00:31:33.560 --> 00:31:35.295 align:middle line:-1
会默认开启安全编码

00:31:35.562 --> 00:31:37.731 align:middle line:-1
并且将默认解码失败政策设定为

00:31:37.798 --> 00:31:39.199 align:middle line:-1
在返回时设定错误

00:31:39.266 --> 00:31:41.902 align:middle line:-1
所以除非你自己更改了解码失败政策

00:31:41.969 --> 00:31:43.937 align:middle line:-1
你不需要担心Swift中的异常

00:31:45.639 --> 00:31:48.609 align:middle line:-1
而旧的初始化器和便利方法

00:31:48.675 --> 00:31:50.878 align:middle line:-1
在新的版本中会设为过期了

00:31:50.944 --> 00:31:52.446 align:middle line:-1
我们真的想让你使用它们

00:31:53.780 --> 00:31:57.251 align:middle line:-2
类似地 我们引入了
与NSKeyedUnarchiver相同的API

00:31:57.484 --> 00:32:00.387 align:middle line:-2
让你可以更容易地在归档时
开启SecureCoding

00:31:57.484 --> 00:32:00.387 align:middle line:-2
让你可以更容易地在归档时
开启SecureCoding

00:32:00.454 --> 00:32:01.788 align:middle line:-1
这是很重要的

00:32:02.122 --> 00:32:05.259 align:middle line:-1
因为它可以保证你不会不小心地归档

00:32:05.325 --> 00:32:07.427 align:middle line:-2
不遵从
NSSecureCoding的对象

00:32:07.494 --> 00:32:09.329 align:middle line:-1
你后面就不能将它解码了

00:32:10.531 --> 00:32:13.467 align:middle line:-2
旧的初始化器和便利方法
也会被设为过期

00:32:13.867 --> 00:32:15.402 align:middle line:-1
这就意味着如果你有

00:32:15.469 --> 00:32:16.436 align:middle line:-1
像是这样的旧代码

00:32:17.037 --> 00:32:19.940 align:middle line:-2
在归档时
打开SecureCoding

00:32:20.507 --> 00:32:21.975 align:middle line:-1
并切换到允许你提前传入类型信息的

00:32:22.042 --> 00:32:24.611 align:middle line:-1
便利方法

00:32:25.579 --> 00:32:28.248 align:middle line:-2
这样你就可以使用
SecureCoding徽章了

00:32:28.682 --> 00:32:29.816 align:middle line:-1
请确保你获得了该徽章

00:32:31.084 --> 00:32:33.253 align:middle line:-1
如果你因为你的类型不能遵从

00:32:33.320 --> 00:32:34.855 align:middle line:-1
还不能支持安全编码的话

00:32:35.255 --> 00:32:38.625 align:middle line:-2
或它们本身是取决于还未遵从的类型
那没关系

00:32:38.692 --> 00:32:40.160 align:middle line:-1
你还是可以在代码中

00:32:40.761 --> 00:32:41.595 align:middle line:-1
使用这些方法

00:32:41.662 --> 00:32:44.064 align:middle line:-1
只需要关掉安全编码需求就可以了

00:32:44.398 --> 00:32:45.232 align:middle line:-1
在解码中

00:32:45.299 --> 00:32:47.901 align:middle line:-1
这些便利中的安全编码一直是启用的

00:32:48.836 --> 00:32:52.272 align:middle line:-2
你可以使用新的初始化器来创建
KeyedUnarchiver

00:32:52.339 --> 00:32:54.641 align:middle line:-1
并手动关闭安全编码

00:32:55.909 --> 00:32:59.079 align:middle line:-1
你可以在需要的时候将解码失败政策

00:32:59.146 --> 00:33:01.181 align:middle line:-1
重设回旧的默认值

00:32:59.146 --> 00:33:01.181 align:middle line:-1
重设回旧的默认值

00:33:02.916 --> 00:33:06.086 align:middle line:-2
在你有了Unarchiver后
你就可以像往常一样解码了

00:33:08.989 --> 00:33:10.691 align:middle line:-1
如果你在开发Swift app

00:33:10.757 --> 00:33:14.228 align:middle line:-2
NSSecureCoding
就不是唯一一个可用来将你模型类型

00:33:14.294 --> 00:33:16.496 align:middle line:-1
与外部表示间相互转换的方法了

00:33:16.563 --> 00:33:17.631 align:middle line:-1
（可编码）

00:33:17.698 --> 00:33:20.167 align:middle line:-2
去年在Swift 4中
我们引入了可编码协议

00:33:20.234 --> 00:33:22.102 align:middle line:-1
可以更容易地实现那些功能

00:33:22.936 --> 00:33:25.172 align:middle line:-2
重要的是 所有NSSecureCoding
的设计决策

00:33:25.239 --> 00:33:29.910 align:middle line:-1
从一开始就出现在可编码中

00:33:31.111 --> 00:33:35.015 align:middle line:-2
可编码从来不会将类型信息
写入归档中

00:33:35.082 --> 00:33:36.850 align:middle line:-1
所以后面没有什么可信任的

00:33:37.217 --> 00:33:40.420 align:middle line:-1
通过让你提前传入要解码的

00:33:40.487 --> 00:33:42.155 align:middle line:-1
静态类型信息

00:33:42.356 --> 00:33:44.525 align:middle line:-1
你可以防止这类攻击

00:33:46.360 --> 00:33:48.128 align:middle line:-1
可编码也有便利方法

00:33:48.195 --> 00:33:51.064 align:middle line:-2
如果你有个类型
它的字段本身都是可编码的

00:33:51.131 --> 00:33:53.433 align:middle line:-1
你就可以得到 初始化需求

00:33:53.500 --> 00:33:55.035 align:middle line:-1
以及编码需求的同步实现

00:33:56.003 --> 00:33:57.571 align:middle line:-1
而同步实现

00:33:57.638 --> 00:33:59.840 align:middle line:-2
会免费为你进行类型检查
和可空性检查

00:34:00.207 --> 00:34:03.177 align:middle line:-2
正如我们所见
很多类型如果是来自外部资源的话

00:34:03.243 --> 00:34:05.746 align:middle line:-2
需要进行额外的验证
就像是我们的这个

00:34:06.747 --> 00:34:08.148 align:middle line:-1
我们需要对其进一步验证

00:34:09.850 --> 00:34:11.851 align:middle line:-1
我们可以通过从解码器覆写其初始化

00:34:11.918 --> 00:34:14.221 align:middle line:-1
来对我们自己的类型进行验证

00:34:14.554 --> 00:34:17.591 align:middle line:-2
在本例中
有个来自前面的JSON响应

00:34:17.658 --> 00:34:19.893 align:middle line:-2
我可以通过创建一个
带有同名字段的类型

00:34:19.960 --> 00:34:22.362 align:middle line:-1
来将它巧妙地转换成可编码类型

00:34:23.697 --> 00:34:25.364 align:middle line:-1
因为所有字段都是可编码的

00:34:25.431 --> 00:34:28.335 align:middle line:-2
我就可以得到初始化
和编码的免费实现

00:34:28.902 --> 00:34:30.504 align:middle line:-1
但我想要覆写初始化

00:34:30.571 --> 00:34:32.172 align:middle line:-1
以确保我所执行的验证

00:34:32.239 --> 00:34:34.208 align:middle line:-2
跟我前面对主要值
所做的验证是一样的

00:34:34.975 --> 00:34:37.244 align:middle line:-1
我能以相同的方法在这里实现它

00:34:38.545 --> 00:34:43.650 align:middle line:-2
我从负载解码ID的旧代码
是将其向下转型为整型

00:34:43.984 --> 00:34:47.353 align:middle line:-2
我在这只要从解码器
解码一个整型就可以了

00:34:48.487 --> 00:34:52.492 align:middle line:-2
如果在负载中找到的类型
是不同的或是丢失的类型

00:34:52.559 --> 00:34:54.895 align:middle line:-2
这就会抛出一个
表明所出现问题的错误

00:34:56.396 --> 00:34:57.664 align:middle line:-1
比这更重要的是

00:34:58.198 --> 00:35:01.268 align:middle line:-2
我在这个验证方法中
添加的自己的验证

00:34:58.198 --> 00:35:01.268 align:middle line:-2
我在这个验证方法中
添加的自己的验证

00:35:02.102 --> 00:35:04.705 align:middle line:-1
这里我想执行相同的验证

00:35:04.771 --> 00:35:06.507 align:middle line:-1
以保证ID是有效的

00:35:06.573 --> 00:35:09.209 align:middle line:-2
这里我可以用一个便利方法
来抛出一个有意义的错误

00:35:09.276 --> 00:35:10.777 align:middle line:-1
来表明所出现的问题

00:35:13.480 --> 00:35:15.182 align:middle line:-1
然后在该验证函数中

00:35:15.249 --> 00:35:18.185 align:middle line:-1
我会以字符串调出创建日期

00:35:18.252 --> 00:35:20.687 align:middle line:-1
然后将其传入日期格式化器

00:35:21.522 --> 00:35:23.524 align:middle line:-1
来获取一个有效的日期

00:35:25.526 --> 00:35:29.763 align:middle line:-2
因为我们使用的是JSON解码器
我们只要直接解码日期就可以了

00:35:29.830 --> 00:35:32.099 align:middle line:-1
我们不需要担心类型转换

00:35:32.733 --> 00:35:35.536 align:middle line:-2
我们可以用JSON解码器
的日期解码政策

00:35:35.602 --> 00:35:38.071 align:middle line:-1
来表明会进行哪种转换

00:35:38.739 --> 00:35:41.875 align:middle line:-2
这样很不错
因为这个转换一行代码就能实现

00:35:42.776 --> 00:35:43.610 align:middle line:-1
而且…

00:35:43.677 --> 00:35:45.646 align:middle line:-1
其他的解码调用也是一行就能实现

00:35:45.712 --> 00:35:47.214 align:middle line:-1
这样我就可以更容易地关注

00:35:47.281 --> 00:35:49.183 align:middle line:-1
我所关心的类型验证

00:35:51.685 --> 00:35:52.986 align:middle line:-1
在这个验证函数中

00:35:53.053 --> 00:35:56.056 align:middle line:-1
我可能已经以字符串数组的形式

00:35:56.123 --> 00:35:57.257 align:middle line:-1
调出了标签的子结构

00:35:57.758 --> 00:36:00.060 align:middle line:-2
然后将这些字符串映射到了
我自己的类型上

00:35:57.758 --> 00:36:00.060 align:middle line:-2
然后将这些字符串映射到了
我自己的类型上

00:36:00.127 --> 00:36:02.296 align:middle line:-1
以供后面的验证所用

00:36:04.064 --> 00:36:05.432 align:middle line:-1
有了可编码

00:36:05.499 --> 00:36:08.101 align:middle line:-2
我就可以利用
标签也是遵从可编码的优势

00:36:08.168 --> 00:36:11.138 align:middle line:-1
所以我就可以直接解码一个标签数组

00:36:11.672 --> 00:36:13.173 align:middle line:-1
这是自动发生的

00:36:13.240 --> 00:36:14.975 align:middle line:-1
这样我就可以不用关注类型转化

00:36:15.042 --> 00:36:17.711 align:middle line:-1
而是关注对我来说重要的验证了

00:36:18.212 --> 00:36:20.848 align:middle line:-2
这可以让我确保
该数据是我能信任的数据

00:36:24.451 --> 00:36:26.253 align:middle line:-1
我们今天介绍了很多内容

00:36:27.187 --> 00:36:28.388 align:middle line:-1
我们从原始数据开始介绍

00:36:28.455 --> 00:36:31.291 align:middle line:-1
然后围绕着抽象范围介绍到

00:36:31.358 --> 00:36:32.292 align:middle line:-1
我们自己的模型类型

00:36:33.393 --> 00:36:36.330 align:middle line:-2
接着我们看了下如何通过验证校验和
或是原始数据的长度

00:36:38.665 --> 00:36:41.568 align:middle line:-1
来建立对于该数据的信任

00:36:41.635 --> 00:36:44.304 align:middle line:-2
我们保证了是通过检查
来证明它是有效的

00:36:44.638 --> 00:36:47.274 align:middle line:-1
甚至检查了它是否遵从于某些格式

00:36:47.341 --> 00:36:49.943 align:middle line:-1
在我们确保它遵从于一个已知格式后

00:36:50.611 --> 00:36:53.914 align:middle line:-2
我们就知道了
那个格式化数据是有效的

00:36:53.981 --> 00:36:55.682 align:middle line:-1
并且得到了主要值

00:36:56.216 --> 00:36:57.117 align:middle line:-1
（总结）

00:36:57.184 --> 00:37:01.021 align:middle line:-1
通过验证那些主要值的内容和结构

00:36:57.184 --> 00:37:01.021 align:middle line:-1
通过验证那些主要值的内容和结构

00:37:01.088 --> 00:37:02.956 align:middle line:-1
我们可以确保这些值是有效的

00:37:03.023 --> 00:37:05.192 align:middle line:-1
并将其转换为我们自己的模型类型

00:37:06.460 --> 00:37:07.761 align:middle line:-1
通过验证这些模型类型间的语义

00:37:07.828 --> 00:37:09.930 align:middle line:-1
和关系

00:37:10.130 --> 00:37:12.065 align:middle line:-1
我们保证了这些数据是有效的

00:37:12.132 --> 00:37:13.667 align:middle line:-1
并且是可以被信任的数据

00:37:15.903 --> 00:37:17.070 align:middle line:-1
然后呢？

00:37:17.137 --> 00:37:18.138 align:middle line:-1
（下一步）

00:37:18.205 --> 00:37:19.273 align:middle line:-1
你已了解这些内容

00:37:19.339 --> 00:37:22.442 align:middle line:-2
我鼓励你们去看看你们的代码
并且就这么去做

00:37:23.410 --> 00:37:25.412 align:middle line:-1
在每个生命周期验证数据

00:37:25.779 --> 00:37:27.781 align:middle line:-1
在该数据生命周期的每个阶段

00:37:28.048 --> 00:37:29.583 align:middle line:-1
检查类型和可空性

00:37:29.650 --> 00:37:33.120 align:middle line:-2
更重要的是 范围和长度
以及域名专属的app

00:37:34.855 --> 00:37:37.124 align:middle line:-2
如果你有NSCoding类型
审计这些类型

00:37:37.191 --> 00:37:38.959 align:middle line:-2
来获得
NSSecureCoding徽章

00:37:39.026 --> 00:37:40.194 align:middle line:-2
不要只是获得这个徽章
你要使用它

00:37:40.260 --> 00:37:42.262 align:middle line:-2
在任何能用的地方
开启安全编码

00:37:43.630 --> 00:37:47.301 align:middle line:-2
最后 在所有可以的地方
采用可编码来处理新的数据类型

00:37:47.367 --> 00:37:49.703 align:middle line:-1
并且保证执行该验证

00:37:50.237 --> 00:37:53.373 align:middle line:-1
保证你只用能信任的数据

00:37:54.374 --> 00:37:55.209 align:middle line:-1
（更多信息）

00:37:55.275 --> 00:37:57.311 align:middle line:-1
有关可编码的更多内容

00:37:57.511 --> 00:37:59.713 align:middle line:-2
请参见去年关于Foundation新特性
这个演讲

00:38:00.080 --> 00:38:01.715 align:middle line:-1
若你有更多关于这个主题的问题

00:38:01.782 --> 00:38:05.285 align:middle line:-2
或想就如何将其app
到自己的app 向我们寻求帮助

00:38:05.352 --> 00:38:06.453 align:middle line:-1
请参加今晚的实验室

00:38:06.520 --> 00:38:09.022 align:middle line:-2
我们有个Foundation实验室
可以帮到你们

00:38:10.390 --> 00:38:12.392 align:middle line:-1
非常感谢大家来参加我的演讲

00:38:13.227 --> 00:38:14.194 align:middle line:-1
祝你们度过愉快的一天
