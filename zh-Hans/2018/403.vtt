WEBVTT

00:00:16.750 --> 00:00:21.588 align:middle line:0
（测试新特性 演讲403）

00:00:25.659 --> 00:00:26.660 align:middle line:-1
上午好

00:00:32.833 --> 00:00:35.736 align:middle line:-2
欢迎参加演讲403
“测试新特性”

00:00:36.436 --> 00:00:38.005 align:middle line:-1
我是Honza Dvorsky

00:00:38.305 --> 00:00:41.542 align:middle line:-2
我将和我的同事
Ethan Vaughan一起

00:00:43.677 --> 00:00:45.179 align:middle line:-1
首先我们将会讨论

00:00:45.245 --> 00:00:48.315 align:middle line:-2
Xcode 9.3中的
代码覆盖改进

00:00:49.550 --> 00:00:53.887 align:middle line:-2
然后讨论测试选择和和排序
这是Xcode 10中的新特性

00:00:54.721 --> 00:00:57.090 align:middle line:-1
最后 Ethan将会上台

00:00:57.157 --> 00:01:01.228 align:middle line:-1
谈谈如何并行运行测试以加速测试

00:00:57.157 --> 00:01:01.228 align:middle line:-1
谈谈如何并行运行测试以加速测试

00:01:02.963 --> 00:01:04.665 align:middle line:-1
我们首先来看代码覆盖

00:01:06.733 --> 00:01:09.770 align:middle line:-2
在Xcode 9.3中
我们完全重写了代码覆盖功能

00:01:10.470 --> 00:01:14.308 align:middle line:-1
性能和准确性有了很大改进

00:01:14.875 --> 00:01:19.146 align:middle line:-2
我们能够添加新功能
这样就能够细粒度地控制

00:01:19.213 --> 00:01:22.082 align:middle line:-1
测试目标 以帮助改进代码覆盖

00:01:23.984 --> 00:01:26.820 align:middle line:-2
我们创建了一个新的
命令行工具xccov

00:01:28.155 --> 00:01:29.356 align:middle line:-1
最后同样重要的是

00:01:29.423 --> 00:01:32.860 align:middle line:-2
我们在源代码编辑器中
提供代码覆盖功能

00:01:34.027 --> 00:01:35.829 align:middle line:-1
让我们来详细了解

00:01:36.730 --> 00:01:37.664 align:middle line:-1
首先

00:01:37.731 --> 00:01:40.901 align:middle line:-2
让你们感受一下
代码覆盖改进有多大

00:01:41.134 --> 00:01:44.171 align:middle line:-2
我们在一大型内部Apple项目上
进行了衡量

00:01:46.240 --> 00:01:49.610 align:middle line:-2
为了解速度提升幅度
我们测量Xcode需花费多长时间

00:01:49.676 --> 00:01:52.579 align:middle line:-2
在源代码编辑器中加载和显示
代码覆盖

00:01:54.414 --> 00:01:57.918 align:middle line:-2
在Xcode 9中
大约需要6.5秒

00:01:59.920 --> 00:02:03.223 align:middle line:-2
在Xcode 9.3中
用时少于0.5秒

00:01:59.920 --> 00:02:03.223 align:middle line:-2
在Xcode 9.3中
用时少于0.5秒

00:02:03.290 --> 00:02:05.325 align:middle line:-1
速度提高95%

00:02:12.132 --> 00:02:15.202 align:middle line:-1
但是我们希望覆盖文件变得更小

00:02:15.469 --> 00:02:17.938 align:middle line:-1
因为Xcode能够写出很多内容

00:02:18.205 --> 00:02:20.307 align:middle line:-2
如果你经常运行测试
应该这样做

00:02:21.208 --> 00:02:24.545 align:middle line:-2
我很高兴告诉大家
改进是非常巨大的

00:02:26.180 --> 00:02:29.416 align:middle line:-2
Xcode 9的覆盖文件大小
超过200兆

00:02:29.983 --> 00:02:33.921 align:middle line:-2
文件很大 但是请注意
这是针对拥有数千个源文件的

00:02:33.987 --> 00:02:35.556 align:middle line:-1
大型项目

00:02:37.758 --> 00:02:41.695 align:middle line:-2
Xcode 9.3写出的文件大小
少于原来的十分之一

00:02:47.167 --> 00:02:48.502 align:middle line:-1
我相信你们会喜欢这一点

00:02:48.569 --> 00:02:50.938 align:middle line:-1
如果你们维护一个连续集成机器

00:02:51.205 --> 00:02:53.473 align:middle line:-2
或者磁盘空间不足
优点将会十分明显

00:02:54.508 --> 00:02:56.176 align:middle line:-1
但是最大的优点不仅在于

00:02:56.243 --> 00:02:59.746 align:middle line:-2
覆盖文件变得更小
读写变得更快

00:02:59.980 --> 00:03:02.249 align:middle line:-1
它们比以前更准确了

00:02:59.980 --> 00:03:02.249 align:middle line:-1
它们比以前更准确了

00:03:03.817 --> 00:03:05.619 align:middle line:-1
头文件就是这样的例子之一

00:03:06.019 --> 00:03:09.756 align:middle line:-2
Xcode 9不能正确收集
和显示头文件中的代码覆盖

00:03:10.257 --> 00:03:13.393 align:middle line:-2
对于使用C++的代码库来说
这是一个问题

00:03:13.760 --> 00:03:14.962 align:middle line:-1
因为在C++语言中

00:03:15.028 --> 00:03:18.432 align:middle line:-2
有相当一部分可执行代码
位于头文件中

00:03:19.700 --> 00:03:22.603 align:middle line:-2
如果这个问题影响到你
那么你将会很高兴听到

00:03:22.669 --> 00:03:25.873 align:middle line:-2
Xcode现在能够正确地
收集和显示实现及头文件

00:03:25.939 --> 00:03:28.342 align:middle line:-1
的代码覆盖

00:03:29.576 --> 00:03:32.012 align:middle line:-1
现在 让我们来看代码覆盖功能

00:03:33.447 --> 00:03:35.315 align:middle line:-1
第一个功能是目标选择

00:03:36.583 --> 00:03:37.851 align:middle line:-1
这是一个新选项

00:03:37.918 --> 00:03:41.221 align:middle line:-1
不仅控制启用或禁用代码覆盖

00:03:41.822 --> 00:03:43.123 align:middle line:-1
并且控制何时启用

00:03:43.190 --> 00:03:46.894 align:middle line:-1
可以控制包含哪些目标

00:03:48.028 --> 00:03:51.698 align:middle line:-2
如果你的项目使用第三方代码
而且你不希望测试它们

00:03:52.065 --> 00:03:54.468 align:middle line:-1
或者你在一家公司工作

00:03:54.535 --> 00:03:56.170 align:middle line:-1
其他团队提供已经测试的框架

00:03:56.236 --> 00:04:00.040 align:middle line:-1
这项功能就很有用

00:03:56.236 --> 00:04:00.040 align:middle line:-1
这项功能就很有用

00:04:02.309 --> 00:04:06.380 align:middle line:-1
在方案测试计划中

00:04:06.680 --> 00:04:07.814 align:middle line:-1
能自定义包含的目标

00:04:08.782 --> 00:04:12.886 align:middle line:-1
这意味代码覆盖可以包含所有目标

00:04:13.187 --> 00:04:14.788 align:middle line:-1
也可以手动挑选其中一部分

00:04:17.224 --> 00:04:19.793 align:middle line:-1
为了改进工作流程

00:04:19.860 --> 00:04:22.362 align:middle line:-2
我们创建了一个名为xccov的
新命令行工具

00:04:24.231 --> 00:04:27.301 align:middle line:-2
可以很容易地自动
集成到脚本中

00:04:27.601 --> 00:04:31.238 align:middle line:-2
它产生人工可识读
和机器可分析的输出

00:04:32.339 --> 00:04:36.910 align:middle line:-2
在更高层面
它提供覆盖数据的详细视图

00:04:37.878 --> 00:04:40.480 align:middle line:-1
我已经多次提到代码覆盖数据

00:04:40.547 --> 00:04:42.449 align:middle line:-1
让我们来看底层原理

00:04:43.917 --> 00:04:46.353 align:middle line:-2
启用代码覆盖后
在运行测试时

00:04:46.687 --> 00:04:48.789 align:middle line:-1
Xcode生成两个文件

00:04:49.723 --> 00:04:51.758 align:middle line:-1
首先是覆盖报告

00:04:52.025 --> 00:04:55.662 align:middle line:-1
或xccovreport文件扩展

00:04:56.630 --> 00:05:01.568 align:middle line:-2
包含每个目标、源文件
和功能的覆盖率

00:04:56.630 --> 00:05:01.568 align:middle line:-2
包含每个目标、源文件
和功能的覆盖率

00:05:03.403 --> 00:05:05.439 align:middle line:-1
第二个是覆盖存档文件

00:05:05.806 --> 00:05:10.310 align:middle line:-2
在报告中包含每个文件的
原始执行次数

00:05:13.347 --> 00:05:17.117 align:middle line:-2
这些覆盖文件位于
项目的衍生数据目录

00:05:17.618 --> 00:05:18.819 align:middle line:-1
此外

00:05:18.886 --> 00:05:22.523 align:middle line:-2
如果将结果包路径标识符
传递到Xcode生成项目

00:05:23.056 --> 00:05:26.193 align:middle line:-1
这些文件也会被放入结果捆绑包之中

00:05:28.262 --> 00:05:29.696 align:middle line:-1
让我们来看一个例子

00:05:30.030 --> 00:05:35.402 align:middle line:-2
我们看Hello World
app的覆盖数据

00:05:36.170 --> 00:05:38.805 align:middle line:-1
可以看到每个目标

00:05:39.873 --> 00:05:42.276 align:middle line:-1
甚至每个方法的

00:05:43.177 --> 00:05:44.411 align:middle line:-1
总体覆盖情况

00:05:45.679 --> 00:05:46.613 align:middle line:-1
当然

00:05:47.614 --> 00:05:50.050 align:middle line:-1
通过传递正确的旗帜标识

00:05:50.884 --> 00:05:54.321 align:middle line:-2
可以在JSON中
获得相同的信息

00:05:56.023 --> 00:05:58.892 align:middle line:-1
这样就可以与其他工具集成

00:06:00.060 --> 00:06:02.329 align:middle line:-1
可以看到 xccov非常灵活

00:06:02.396 --> 00:06:04.998 align:middle line:-1
因此我鼓励你们阅读它的文档

00:06:06.834 --> 00:06:09.770 align:middle line:-1
现在 我们来讨论使用方法…

00:06:09.837 --> 00:06:14.041 align:middle line:-2
可在命令行上查看代码覆盖
这是最方便的方法

00:06:14.107 --> 00:06:16.944 align:middle line:-1
在源代码旁边查看

00:06:18.512 --> 00:06:20.981 align:middle line:-1
可以控制是否显示代码覆盖

00:06:21.048 --> 00:06:24.918 align:middle line:-2
只需选择编辑器
显示或隐藏代码覆盖

00:06:28.589 --> 00:06:29.723 align:middle line:-1
启用之后

00:06:29.790 --> 00:06:32.593 align:middle line:-2
将在源代码编辑器中
看到代码覆盖刷新视图

00:06:33.293 --> 00:06:34.628 align:middle line:-1
整行高亮显示

00:06:34.695 --> 00:06:37.698 align:middle line:-2
当鼠标悬停在右侧的
执行次数上时

00:06:38.765 --> 00:06:41.201 align:middle line:-1
能够最方便地查看

00:06:41.268 --> 00:06:43.871 align:middle line:-1
你的哪些代码已经测试

00:06:44.204 --> 00:06:45.839 align:middle line:-1
哪些仍然需要进一步测试

00:06:47.674 --> 00:06:50.477 align:middle line:-2
现在 让我来实际演示
这些改进特性

00:07:01.221 --> 00:07:03.924 align:middle line:-2
这里有一个项目
名称为Dev Cast

00:07:04.324 --> 00:07:05.626 align:middle line:-1
这是一个简单的消息app

00:07:05.692 --> 00:07:08.595 align:middle line:-1
这是去年开发的iOS版本

00:07:08.962 --> 00:07:11.298 align:middle line:-1
今年 我想要开发一个Mac版本

00:07:12.232 --> 00:07:15.769 align:middle line:-2
我想要在iOS和Mac版本
之间共享业务逻辑

00:07:15.836 --> 00:07:18.472 align:middle line:-2
因此将它全部放入
名为DevCastkit的框架

00:07:19.373 --> 00:07:21.808 align:middle line:-1
今天 我的目标是探索

00:07:21.875 --> 00:07:24.578 align:middle line:-1
甚至改进这个框架的代码覆盖

00:07:25.612 --> 00:07:26.580 align:middle line:-1
现在

00:07:26.647 --> 00:07:29.449 align:middle line:-2
我不会收集代码覆盖
我只需要开启它

00:07:30.484 --> 00:07:34.755 align:middle line:-2
选择方案
选择“编辑方案”

00:07:35.422 --> 00:07:36.690 align:middle line:-1
进入测试操作

00:07:37.858 --> 00:07:39.092 align:middle line:-1
进入选项

00:07:40.694 --> 00:07:43.397 align:middle line:-1
在这里 我启用代码覆盖

00:07:47.601 --> 00:07:50.504 align:middle line:-2
现在我进入产品测试
运行我的测试

00:07:51.338 --> 00:07:56.310 align:middle line:0
现在 创建我的框架
我的测试包和我的Mac app

00:07:56.643 --> 00:07:57.978 align:middle line:0
然后运行我的测试

00:07:59.947 --> 00:08:02.282 align:middle line:-2
现在 测试完成
让我们来看结果

00:07:59.947 --> 00:08:02.282 align:middle line:-2
现在 测试完成
让我们来看结果

00:08:02.349 --> 00:08:03.984 align:middle line:-1
我们转到报告导航器

00:08:04.885 --> 00:08:06.787 align:middle line:-1
查看最新的报告覆盖报告

00:08:08.755 --> 00:08:11.425 align:middle line:-1
我可以看到

00:08:11.725 --> 00:08:15.262 align:middle line:-1
两个目标 Mac app和框架

00:08:15.963 --> 00:08:20.267 align:middle line:-2
现在 Mac app仅用作
运行测试的容器

00:08:20.634 --> 00:08:23.437 align:middle line:-1
我并不担心低代码覆盖率

00:08:23.504 --> 00:08:27.241 align:middle line:-2
事实上 我并不想
在这个报告里看到这一点

00:08:28.709 --> 00:08:31.011 align:middle line:-1
因此我可以再次编辑方案

00:08:33.647 --> 00:08:34.881 align:middle line:-1
在测试操作中

00:08:36.683 --> 00:08:39.318 align:middle line:-1
并不收集所有目标的覆盖率

00:08:39.886 --> 00:08:41.655 align:middle line:-1
我更改为只覆盖一些目标

00:08:42.890 --> 00:08:45.425 align:middle line:-1
这为我提供一个硬性覆盖列表

00:08:45.759 --> 00:08:48.462 align:middle line:-1
仅添加我感兴趣的目标

00:08:48.529 --> 00:08:49.630 align:middle line:-1
也就是框架

00:08:53.800 --> 00:08:55.536 align:middle line:-1
再次运行测试

00:08:59.540 --> 00:09:01.642 align:middle line:-1
查看经过更新的覆盖率报告

00:08:59.540 --> 00:09:01.642 align:middle line:-1
查看经过更新的覆盖率报告

00:09:03.010 --> 00:09:03.911 align:middle line:-1
现在你可以看到

00:09:03.977 --> 00:09:06.713 align:middle line:-1
覆盖率报告中只有框架的结果

00:09:06.780 --> 00:09:07.814 align:middle line:-1
这正是我想要的

00:09:08.182 --> 00:09:10.617 align:middle line:-1
现在 我专注于这个目标

00:09:11.618 --> 00:09:14.421 align:middle line:-1
看 覆盖率现在是84%

00:09:14.821 --> 00:09:17.157 align:middle line:-2
这还不错
但是我还可以做得更好

00:09:17.758 --> 00:09:20.694 align:middle line:-2
为了理解需要更多地
注意哪些文件

00:09:21.094 --> 00:09:22.596 align:middle line:-1
我将会显示目标的覆盖率

00:09:23.697 --> 00:09:27.467 align:middle line:-1
看到第一个文件的覆盖率仅有66%

00:09:28.468 --> 00:09:31.205 align:middle line:-2
我点击这里的箭头
转到这个文件

00:09:33.907 --> 00:09:34.741 align:middle line:-1
在这里

00:09:35.209 --> 00:09:37.344 align:middle line:-1
我将查看我的本地服务器类

00:09:38.245 --> 00:09:39.213 align:middle line:-1
在右侧

00:09:39.279 --> 00:09:42.216 align:middle line:-1
我可以看到每个代码块的执行次数

00:09:42.649 --> 00:09:43.717 align:middle line:-1
因此我可以看到

00:09:43.784 --> 00:09:47.888 align:middle line:-1
测试所覆盖的类可执行代码

00:09:47.955 --> 00:09:48.789 align:middle line:-1
这很不错

00:09:49.356 --> 00:09:52.826 align:middle line:-2
不幸的是 我的一个常用功能
即 获取最新消息

00:09:52.893 --> 00:09:56.463 align:middle line:-2
完全没有被我的测试调用
因此我不知道这个功能是否正常工作

00:09:57.731 --> 00:10:01.068 align:middle line:-2
为了解决这个问题
我会转到相应的测试文件

00:09:57.731 --> 00:10:01.068 align:middle line:-2
为了解决这个问题
我会转到相应的测试文件

00:10:03.737 --> 00:10:05.038 align:middle line:-1
我添加一个新测试

00:10:07.741 --> 00:10:11.578 align:middle line:-2
此测试将一些消息
放入本地服务器

00:10:11.645 --> 00:10:13.680 align:middle line:-1
然后 我获得最近的消息

00:10:13.747 --> 00:10:15.916 align:middle line:-2
正如我所预期的
验证返回的消息是否

00:10:17.351 --> 00:10:19.086 align:middle line:-1
在添加新测试之后

00:10:19.586 --> 00:10:21.488 align:middle line:0
我再次运行测试

00:10:25.959 --> 00:10:29.830 align:middle line:-2
很好 测试完成
我再次转到覆盖率报告

00:10:30.497 --> 00:10:35.369 align:middle line:-2
现在 查看我的框架
可以看到覆盖率为100%

00:10:35.435 --> 00:10:36.870 align:middle line:-1
这正是我想要的

00:10:38.272 --> 00:10:41.575 align:middle line:-2
来看我如何使用
目标选择功能

00:10:41.642 --> 00:10:43.777 align:middle line:-1
来专注于一些目标的测试

00:10:44.444 --> 00:10:48.115 align:middle line:-2
然后 我使用覆盖率文件
准确地了解将专注于哪个文件

00:10:48.715 --> 00:10:49.550 align:middle line:-1
最后

00:10:49.616 --> 00:10:52.252 align:middle line:-2
我在源代码编辑器中
使用代码覆盖集成功能

00:10:52.319 --> 00:10:55.322 align:middle line:-2
来了解我的哪些代码部分
仍然需要覆盖

00:10:56.723 --> 00:10:59.026 align:middle line:-2
这就是Xcode中的
代码覆盖改进

00:11:06.433 --> 00:11:08.635 align:middle line:-1
讲完代码覆盖之后

00:11:09.736 --> 00:11:12.039 align:middle line:-2
让我们来看Xcode 10中的
一些新特性

00:11:13.040 --> 00:11:14.942 align:middle line:-1
首先 来看我们如何更好地

00:11:15.576 --> 00:11:17.611 align:middle line:-1
选择和排序我们的测试

00:11:19.346 --> 00:11:20.581 align:middle line:-1
为什么这很重要？

00:11:20.981 --> 00:11:26.253 align:middle line:-2
你的套件中的所有测试
并非都是为了一个目的

00:11:26.620 --> 00:11:30.591 align:middle line:-2
每次运行测试时
你可能需要快速运行

00:11:30.657 --> 00:11:31.925 align:middle line:-1
所有1000个测试单元

00:11:32.226 --> 00:11:35.929 align:middle line:-2
但是在夜间 可能只需要
运行10个长时运行用户界面测试

00:11:36.864 --> 00:11:38.065 align:middle line:-2
现在 可以通过禁用
方案中的特定测试

00:11:38.131 --> 00:11:40.601 align:middle line:-1
来实现这个目的

00:11:42.469 --> 00:11:45.739 align:middle line:-1
方案编码禁用测试列表

00:11:46.039 --> 00:11:49.009 align:middle line:-2
这样XE测试就知道
需要跳过哪些测试

00:11:49.910 --> 00:11:52.012 align:middle line:-1
这会伴随着一个有趣的副作用

00:11:52.346 --> 00:11:54.047 align:middle line:-1
无论你何时编写一个新测试

00:11:54.114 --> 00:11:56.350 align:middle line:-2
它都会被自动添加到
包含相应测试的

00:11:56.416 --> 00:11:58.519 align:middle line:-1
所有方案之中

00:11:59.186 --> 00:12:00.587 align:middle line:-1
但是 如果你不想要这样做

00:11:59.186 --> 00:12:00.587 align:middle line:-1
但是 如果你不想要这样做

00:12:00.654 --> 00:12:04.491 align:middle line:-2
你必须检查所有方案
手动禁用测试

00:12:05.759 --> 00:12:06.827 align:middle line:-1
因此在Xcode 10中

00:12:06.894 --> 00:12:10.631 align:middle line:-2
我们引入新的方案模式
并不编码运行测试列表

00:12:12.633 --> 00:12:14.635 align:middle line:-1
如果将方案切换到此模式

00:12:14.701 --> 00:12:18.005 align:middle line:-2
只有手动挑选的测试
才会在方案中运行

00:12:21.208 --> 00:12:24.044 align:middle line:-2
可以在方案编辑器测试操作中
控制此模式

00:12:25.279 --> 00:12:28.448 align:middle line:-2
在测试目标列表中
有一个新的弹出选项

00:12:28.515 --> 00:12:29.349 align:middle line:-1
你可以声明

00:12:29.416 --> 00:12:32.486 align:middle line:-1
方案是否应该自动包括新测试

00:12:33.320 --> 00:12:34.888 align:middle line:-1
这样 一些方案

00:12:34.955 --> 00:12:37.357 align:middle line:-2
可以继续运行
你编写的任何新测试

00:12:37.758 --> 00:12:41.128 align:middle line:-2
其他方案仅运行
手动挑选的测试列表

00:12:43.397 --> 00:12:44.631 align:middle line:-1
我们讨论了

00:12:44.698 --> 00:12:48.035 align:middle line:-2
如何更好地控制
哪些测试 何时运行

00:12:48.335 --> 00:12:51.271 align:middle line:-1
但是测试顺序也很重要

00:12:53.106 --> 00:12:56.543 align:middle line:-2
默认情况下 Xcode中的
测试按名称排序

00:12:57.444 --> 00:12:59.913 align:middle line:-1
这意味着 除非更名测试

00:12:59.980 --> 00:13:01.782 align:middle line:-2
否则它们始终
以相同的顺序运行

00:12:59.980 --> 00:13:01.782 align:middle line:-2
否则它们始终
以相同的顺序运行

00:13:02.816 --> 00:13:04.952 align:middle line:-1
这种决定方法是一把双刃剑

00:13:05.686 --> 00:13:07.487 align:middle line:-1
这样很容易遗漏漏洞

00:13:07.554 --> 00:13:11.925 align:middle line:-2
因为一个测试显式地
依赖于在它之前运行的另一个测试

00:13:13.460 --> 00:13:15.629 align:middle line:-1
让我们来看这一个例子

00:13:16.697 --> 00:13:18.765 align:middle line:-1
假设你有测试A、B和C

00:13:19.399 --> 00:13:22.135 align:middle line:-2
它们按照此顺序运行
而且始终获得通过

00:13:22.603 --> 00:13:24.738 align:middle line:-1
但是详细地观察测试

00:13:25.072 --> 00:13:27.908 align:middle line:-2
你会发现测试A
创建一个数据库

00:13:29.176 --> 00:13:32.579 align:middle line:-2
然后 测试B会运行
将数据写入数据库

00:13:33.647 --> 00:13:36.984 align:middle line:-2
然后测试C运行
删除数据

00:13:40.721 --> 00:13:44.258 align:middle line:-2
这些测试获得通过
是因为它们按照特定顺序运行

00:13:44.791 --> 00:13:48.695 align:middle line:-2
--如果打乱它们的顺序
例如 重新命名

00:13:49.796 --> 00:13:51.365 align:middle line:-1
然后再次运行

00:13:51.431 --> 00:13:54.801 align:middle line:-2
测试B可能会将数据
写入一个不存在的数据库

00:13:54.868 --> 00:13:56.370 align:middle line:-1
你的测试将会失败

00:13:57.738 --> 00:14:00.574 align:middle line:-1
为了防止这样的问题

00:13:57.738 --> 00:14:00.574 align:middle line:-1
为了防止这样的问题

00:14:00.641 --> 00:14:04.912 align:middle line:-2
必须始终正确设置测试
取消它们自己的状态

00:14:06.313 --> 00:14:10.050 align:middle line:-1
不仅会让它变得更可靠

00:14:10.117 --> 00:14:12.953 align:middle line:-2
而且让你的测试独立于
所有其它测试运行

00:14:13.921 --> 00:14:16.690 align:middle line:-2
在开发和调试期间
这十分有用

00:14:18.525 --> 00:14:19.660 align:middle line:-1
为了帮助你确保

00:14:19.726 --> 00:14:22.729 align:middle line:-2
测试之间不存在
不必要的依赖关系

00:14:23.130 --> 00:14:26.767 align:middle line:-2
在Xcode 10中 我们引入
新的测试随机化模式

00:14:28.268 --> 00:14:29.536 align:middle line:-1
如果启用此模式

00:14:29.603 --> 00:14:33.006 align:middle line:-2
在每次运行之前
将会为测试设置随机顺序

00:14:34.341 --> 00:14:37.144 align:middle line:-2
如果在此模式下
测试获得通过

00:14:37.211 --> 00:14:40.747 align:middle line:-2
就能够更加确信
它们确实可靠 而且是独立的

00:14:42.649 --> 00:14:45.552 align:middle line:-2
可以在方案编辑器中
启用随机模式

00:14:45.853 --> 00:14:47.888 align:middle line:-1
与前面讲过的其他特性一样

00:14:50.324 --> 00:14:53.360 align:middle line:-2
这些就是Xcode 10中
新的测试选择和排序

00:14:55.796 --> 00:14:58.131 align:middle line:-1
现在 我很高兴地

00:14:59.366 --> 00:15:02.469 align:middle line:-2
为你们介绍Xcode中的
新并行测试功能

00:14:59.366 --> 00:15:02.469 align:middle line:-2
为你们介绍Xcode中的
新并行测试功能

00:15:02.636 --> 00:15:05.239 align:middle line:-2
欢迎Ethan Vaughan
Ethan

00:15:12.246 --> 00:15:13.380 align:middle line:-1
谢谢Honza

00:15:15.015 --> 00:15:19.052 align:middle line:-2
你们的许多开发周期
可能是这样的

00:15:19.586 --> 00:15:23.924 align:middle line:-2
编写代码、调试
然后运行测试

00:15:24.157 --> 00:15:27.027 align:middle line:-1
然后提交 将更改存入存储库

00:15:27.828 --> 00:15:29.863 align:middle line:-1
在存入之前运行测试

00:15:30.130 --> 00:15:33.433 align:middle line:-2
可以进行回归分析
然后生成版本

00:15:35.903 --> 00:15:38.405 align:middle line:-1
但是 这个流程有一个瓶颈

00:15:38.672 --> 00:15:41.508 align:middle line:-1
即测试运行时间

00:15:42.142 --> 00:15:43.777 align:middle line:-1
你们可能有一些测试套件

00:15:43.844 --> 00:15:47.080 align:middle line:-1
运行时间长达30分钟甚至数小时

00:15:47.915 --> 00:15:51.952 align:middle line:-2
如果需要花费过多的时间
等待测试运行结束

00:15:52.019 --> 00:15:54.621 align:middle line:-1
将会形成严重的工作流程瓶颈

00:15:55.856 --> 00:15:59.193 align:middle line:-1
我们希望尽量提高测试运行速度

00:15:59.459 --> 00:16:02.696 align:middle line:-1
缩短这个重要的开发环节

00:15:59.459 --> 00:16:02.696 align:middle line:-1
缩短这个重要的开发环节

00:16:03.263 --> 00:16:09.136 align:middle line:-2
因此去年我们在Xcode 9中
引入一项新特性 帮助更快运行测试

00:16:09.636 --> 00:16:11.805 align:middle line:-1
此特性名为并行目标位置测试

00:16:12.306 --> 00:16:14.708 align:middle line:-1
能够同时在多个目标位置

00:16:14.775 --> 00:16:17.177 align:middle line:-1
运行你的所有测试

00:16:18.045 --> 00:16:19.913 align:middle line:-1
你需要使用命令行

00:16:19.980 --> 00:16:23.483 align:middle line:-2
将多个目标位置说明符
传递给xcodebuild

00:16:25.586 --> 00:16:30.490 align:middle line:-2
以前若你运行测试 比如
在iPhone X和iPad上

00:16:31.091 --> 00:16:34.428 align:middle line:-2
xcodebuild将会
在iPhone X上运行所有测试

00:16:34.494 --> 00:16:36.630 align:middle line:-1
然后在iPad上运行所有测试

00:16:37.364 --> 00:16:40.100 align:middle line:-1
设备不能同时运行测试

00:16:42.169 --> 00:16:44.805 align:middle line:-2
但是在Xcode 9中
我们更改了这个模式

00:16:44.872 --> 00:16:48.509 align:middle line:-2
默认情况下
可以在多个设备上同时运行测试

00:16:49.109 --> 00:16:52.012 align:middle line:-1
这可以极大缩短执行时间

00:16:52.079 --> 00:16:52.913 align:middle line:-1
这很不错

00:16:54.548 --> 00:16:57.217 align:middle line:-1
但是这个方法有一些限制

00:16:58.852 --> 00:17:02.656 align:middle line:-2
首先 只有在多个目标位置
进行测试时 才会有优势

00:16:58.852 --> 00:17:02.656 align:middle line:-2
首先 只有在多个目标位置
进行测试时 才会有优势

00:17:03.423 --> 00:17:06.827 align:middle line:-2
举例来说 如果运行
Mac app的单元测试

00:17:07.261 --> 00:17:08.328 align:middle line:-1
就没有帮助作用

00:17:09.863 --> 00:17:12.432 align:middle line:-2
只能在xcodebuild中
使用此功能

00:17:12.766 --> 00:17:16.837 align:middle line:-1
因此 这主要在连续集成环境中有用

00:17:16.904 --> 00:17:18.972 align:middle line:-2
比如Xcode Server
或Jenkins

00:17:21.208 --> 00:17:24.744 align:middle line:-2
我很高兴告诉你们
有一种更快的新测试运行方法

00:17:24.810 --> 00:17:26.579 align:middle line:-1
名为“并行分布式测试”

00:17:28.515 --> 00:17:30.217 align:middle line:-1
利用并行分布式测试功能

00:17:30.284 --> 00:17:33.487 align:middle line:-2
可以在一个目标位置
并行执行多个测试

00:17:34.688 --> 00:17:38.025 align:middle line:-2
以前 在单一目标位置
进行测试是这样的

00:17:38.292 --> 00:17:42.329 align:middle line:-1
依次连续执行测试

00:17:44.298 --> 00:17:47.634 align:middle line:-1
分布式测试允许同时运行多个测试

00:17:47.935 --> 00:17:49.636 align:middle line:-1
因此 现在测试是这样的

00:17:51.004 --> 00:17:54.374 align:middle line:-2
此外 Xcode和
xcodebuild都支持此功能

00:17:54.775 --> 00:17:58.178 align:middle line:-2
无论在哪里运行测试
都会获得最佳的性能

00:18:00.280 --> 00:18:03.617 align:middle line:-2
为了理解Xcode
并行运行测试的原理

00:18:03.984 --> 00:18:06.687 align:middle line:-1
我们首先来看测试是如何执行的

00:18:07.087 --> 00:18:08.689 align:middle line:-1
在运行时发生了什么？

00:18:10.591 --> 00:18:12.192 align:middle line:-1
我们先来看单元测试

00:18:12.926 --> 00:18:16.363 align:middle line:-1
单元测试被编译成一个测试包

00:18:17.731 --> 00:18:23.203 align:middle line:-2
在运行时层面 Xcode启动
一个app实例 作为测试运行器

00:18:24.671 --> 00:18:28.375 align:middle line:-2
运行器加载测试包
执行所有测试

00:18:29.877 --> 00:18:31.545 align:middle line:-1
单元测试就是这样执行的

00:18:32.346 --> 00:18:33.714 align:middle line:-1
那么用户界面测试呢？

00:18:34.214 --> 00:18:35.916 align:middle line:-1
对于用户界面测试 原理基本相似

00:18:36.483 --> 00:18:38.719 align:middle line:-1
测试被编译成为一个捆绑包

00:18:39.286 --> 00:18:42.723 align:middle line:-2
但是捆绑包由Xcode
创建的自定义app加载

00:18:43.357 --> 00:18:45.759 align:middle line:-1
你的app不再运行测试

00:18:46.593 --> 00:18:49.329 align:middle line:-1
相反 测试自动控制你的app

00:18:49.763 --> 00:18:53.433 align:middle line:-2
通过启动app
与不同的用户界面部分进行交互

00:18:55.135 --> 00:18:57.437 align:middle line:-1
如果想要详细了解此流程

00:18:57.738 --> 00:19:00.374 align:middle line:0
请你们观看2016年的演讲

00:18:57.738 --> 00:19:00.374 align:middle line:0
请你们观看2016年的演讲

00:19:00.774 --> 00:19:02.476 align:middle line:-1
此演讲进行了更详细的讲解

00:19:04.044 --> 00:19:06.647 align:middle line:-2
现在 我们已经了解
我们的测试是如何执行的

00:19:07.114 --> 00:19:10.017 align:middle line:-2
最后让我们看看
Xcode如何并行运行测试

00:19:11.385 --> 00:19:12.686 align:middle line:-1
如前所述

00:19:12.753 --> 00:19:16.190 align:middle line:-2
Xcode启动一个测试运行器
以执行我们的测试

00:19:17.191 --> 00:19:19.393 align:middle line:-1
但是不同于启动一个运行器

00:19:19.726 --> 00:19:21.995 align:middle line:-1
Xcode将启动多个运行器

00:19:22.429 --> 00:19:25.232 align:middle line:-2
每个运行器
执行一个测试子集

00:19:26.366 --> 00:19:29.903 align:middle line:-2
事实上 Xcode动态
分配测试给运行器

00:19:30.337 --> 00:19:33.473 align:middle line:-1
在机器上实现最高的利用效率

00:19:35.309 --> 00:19:36.543 align:middle line:-1
让我们来了解详细过程

00:19:38.011 --> 00:19:42.616 align:middle line:-2
Xcode分配测试到运行器时
将按类进行分配

00:19:43.450 --> 00:19:45.953 align:middle line:-2
每个运行器接收
一个测试类以执行

00:19:46.553 --> 00:19:50.257 align:middle line:-2
它将执行这个类
然后执行另一个类

00:19:51.291 --> 00:19:54.561 align:middle line:-2
在测试完成时
所有类执行之后

00:19:56.463 --> 00:20:00.267 align:middle line:-2
你可能会想
为什么Xcode按类分配测试

00:19:56.463 --> 00:20:00.267 align:middle line:-2
你可能会想
为什么Xcode按类分配测试

00:20:00.534 --> 00:20:03.637 align:middle line:-2
而不是将单个测试方法
分配给运行器

00:20:04.605 --> 00:20:06.340 align:middle line:-1
这有多方面的原因

00:20:07.641 --> 00:20:11.545 align:middle line:-2
首先 类内部的测试之间
可能存在隐藏的依赖关系

00:20:11.612 --> 00:20:13.180 align:middle line:-1
Honza前面已经讲过

00:20:13.847 --> 00:20:18.385 align:middle line:-2
如果Xcode接收类内部的测试
并将它们分配给不同的运行器

00:20:18.852 --> 00:20:21.154 align:middle line:-1
可能难以诊断测试问题

00:20:23.357 --> 00:20:27.995 align:middle line:-2
其次 每个测试类
层级设置和分解方法

00:20:28.328 --> 00:20:30.564 align:middle line:-1
可能会执行大量的计算

00:20:31.398 --> 00:20:34.368 align:middle line:-2
通过将类内部的有限数量
的测试分配给一个运行器

00:20:34.801 --> 00:20:37.771 align:middle line:-1
XE测试仅需一次调用这些方法

00:20:38.005 --> 00:20:39.473 align:middle line:-1
可以显著节省时间

00:20:42.409 --> 00:20:46.547 align:middle line:-2
现在 我想谈谈在模拟器上
并行进行测试的一些要点

00:20:48.348 --> 00:20:50.651 align:middle line:-1
在模拟器上并行运行测试时

00:20:51.084 --> 00:20:53.954 align:middle line:-2
Xcode开始接收
你选择的模拟器

00:20:54.254 --> 00:20:57.891 align:middle line:-1
创建多个独特的模拟器副本或克隆

00:20:58.959 --> 00:21:01.895 align:middle line:-1
这些克隆

00:20:58.959 --> 00:21:01.895 align:middle line:-1
这些克隆

00:21:01.962 --> 00:21:03.664 align:middle line:-1
与原始模拟器相同

00:21:04.731 --> 00:21:08.769 align:middle line:-2
如有必要 Xcode将自动创建
和删除这些克隆

00:21:10.037 --> 00:21:12.172 align:middle line:-1
在多次克隆模拟器之后

00:21:12.573 --> 00:21:15.609 align:middle line:-2
Xcode在每个克隆上
启动测试运行器

00:21:16.076 --> 00:21:18.979 align:middle line:-1
然后 运行器开始执行测试类

00:21:19.413 --> 00:21:20.814 align:middle line:-1
正如我们前面所说的那样

00:21:22.516 --> 00:21:24.218 align:middle line:-1
由于在模拟器的

00:21:24.284 --> 00:21:26.386 align:middle line:-1
多个克隆上执行测试

00:21:26.653 --> 00:21:29.056 align:middle line:-1
这会存在一些问题

00:21:30.991 --> 00:21:35.028 align:middle line:-2
首先 在测试期间
不会使用原始模拟器

00:21:35.863 --> 00:21:38.432 align:middle line:-1
相反 它作为一个模板模拟器

00:21:39.099 --> 00:21:42.436 align:middle line:-2
可以使用你想要的设置
和内容配置它

00:21:42.503 --> 00:21:46.006 align:middle line:-2
在创建克隆时
这些内容被复制到克隆

00:21:47.608 --> 00:21:50.444 align:middle line:-1
接下来 你的app将会有多个副本

00:21:51.144 --> 00:21:55.015 align:middle line:-1
每个副本都有自己的数据容器

00:21:55.983 --> 00:21:59.786 align:middle line:-2
这意味着 如果一个测试类
修改磁盘上的文件

00:22:00.120 --> 00:22:04.291 align:middle line:-2
这些文件修改
对于另一个测试类来说也是可见的

00:22:04.358 --> 00:22:07.494 align:middle line:-2
因为它可以访问
完全分离的数据容器

00:22:08.896 --> 00:22:12.399 align:middle line:-2
在实践中
类在不同的克隆上执行

00:22:12.666 --> 00:22:16.770 align:middle line:-2
这对于你的测试来说
可能是可见的 必须知道这一点

00:22:18.939 --> 00:22:21.008 align:middle line:-2
那么 你可以在哪里
并行运行测试呢？

00:22:21.675 --> 00:22:24.378 align:middle line:-2
可以在macOS上并行
运行单元测试

00:22:24.678 --> 00:22:29.249 align:middle line:-2
也可在iOS 和tvOS模拟器上
并行运行单元和用户界面测试

00:22:30.884 --> 00:22:34.922 align:middle line:-2
对此 我想要为你们在实战中
演示并行分布式测试

00:22:48.168 --> 00:22:50.304 align:middle line:-2
这是
Solar System app

00:22:50.671 --> 00:22:53.674 align:middle line:-2
在以前的演讲中
你们可能见过这个app

00:22:54.274 --> 00:22:57.911 align:middle line:-2
作为这个app的开发者之一
我想要运行所有的测试

00:22:57.978 --> 00:23:00.581 align:middle line:-1
然后提交并将我的更改推送入存储库

00:22:57.978 --> 00:23:00.581 align:middle line:-1
然后提交并将我的更改推送入存储库

00:23:01.615 --> 00:23:03.650 align:middle line:-1
但是 随着我添加更多的测试

00:23:03.717 --> 00:23:05.619 align:middle line:-1
将需要更多的时间

00:23:05.686 --> 00:23:07.654 align:middle line:-1
这成为工作流程中的瓶颈

00:23:08.422 --> 00:23:10.357 align:middle line:-2
让我们来看并行测试
如何解决这个问题

00:23:11.625 --> 00:23:13.927 align:middle line:-1
我切换到Xcode项目

00:23:14.494 --> 00:23:16.230 align:middle line:-1
我已经运行我的测试

00:23:16.296 --> 00:23:18.131 align:middle line:-1
我想看它们用了多少时间

00:23:21.502 --> 00:23:22.336 align:middle line:-1
好的

00:23:22.870 --> 00:23:24.371 align:middle line:-1
让我们返回到测试报告

00:23:25.239 --> 00:23:27.241 align:middle line:-2
在这里 可以看到
在每个方法旁边

00:23:27.307 --> 00:23:30.143 align:middle line:-1
显示执行每个方法所用的时间

00:23:31.245 --> 00:23:33.080 align:middle line:-1
接下来 对于每个测试类

00:23:33.146 --> 00:23:35.883 align:middle line:-1
我们显示测试通过和失败百分比

00:23:36.583 --> 00:23:39.319 align:middle line:-1
以及测试类的执行时间

00:23:40.420 --> 00:23:42.189 align:middle line:-1
最后 在右上角

00:23:42.256 --> 00:23:45.425 align:middle line:-1
可以看到所有测试的运行时间

00:23:46.226 --> 00:23:48.729 align:middle line:-1
在这里 可以看到测试用时14秒

00:23:49.630 --> 00:23:51.632 align:middle line:-1
现在 我想启用并行测试

00:23:51.932 --> 00:23:53.600 align:middle line:-1
我可以进入方案

00:23:54.134 --> 00:23:56.837 align:middle line:-1
选择方案 然后编辑方案

00:23:57.771 --> 00:23:59.506 align:middle line:-1
接下来 我点击测试操作

00:24:00.107 --> 00:24:03.377 align:middle line:-1
点击测试目标旁边的选项按钮

00:24:04.611 --> 00:24:07.581 align:middle line:-1
最后 选中“并行执行”复选框

00:24:08.448 --> 00:24:11.018 align:middle line:-1
就可以启用并行测试

00:24:11.985 --> 00:24:16.056 align:middle line:-2
现在 选择“产品测试”
运行我们的测试

00:24:19.560 --> 00:24:21.461 align:middle line:0
你们应该查看文档

00:24:21.828 --> 00:24:24.698 align:middle line:0
Xcode启动
Mac app多个副本

00:24:24.965 --> 00:24:26.633 align:middle line:0
并行运行单元测试

00:24:27.701 --> 00:24:29.736 align:middle line:-1
很好 看来已经完成了

00:24:29.803 --> 00:24:34.007 align:middle line:-2
现在 我们返回到报告
选择最近的报告

00:24:36.076 --> 00:24:39.313 align:middle line:-1
以前 测试所用时间为14秒

00:24:39.379 --> 00:24:40.914 align:middle line:-1
现在仅用时5秒

00:24:41.248 --> 00:24:43.116 align:middle line:-1
启用并行测试后

00:24:43.183 --> 00:24:46.453 align:middle line:-1
测试执行时间节省了超过50%

00:24:53.760 --> 00:24:57.331 align:middle line:-2
Solar System app
不仅有Mac版本

00:24:57.664 --> 00:24:59.466 align:middle line:-1
而且有iOS版本

00:25:00.167 --> 00:25:03.270 align:middle line:-2
我的任务之一是
编写一个用户界面测试套件

00:25:03.337 --> 00:25:06.406 align:middle line:-2
以使用我的iOS app的
各种屏幕

00:25:07.040 --> 00:25:10.711 align:middle line:-1
我现已为iOS方案启动并行测试

00:25:11.144 --> 00:25:13.313 align:middle line:-1
现在我切换到此模式

00:25:16.683 --> 00:25:20.120 align:middle line:-2
然后我选择“产品测试”
运行测试

00:25:22.990 --> 00:25:25.526 align:middle line:-1
现在 我们切换到模拟器

00:25:26.493 --> 00:25:27.794 align:middle line:-1
在这里 可以看到

00:25:27.861 --> 00:25:31.598 align:middle line:-2
Xcode创建我所选定模拟器
的多个克隆

00:25:32.366 --> 00:25:35.969 align:middle line:-1
这些克隆使用原始模拟器的名称

00:25:36.336 --> 00:25:38.005 align:middle line:-1
因此容易进行区分

00:25:39.273 --> 00:25:42.876 align:middle line:-2
在每个模拟器上
Xcode启动一个测试运行器

00:25:43.777 --> 00:25:46.914 align:middle line:-1
每个运行器执行套件中的不同测试类

00:26:00.027 --> 00:26:01.795 align:middle line:-1
执行我的测试时

00:26:02.229 --> 00:26:05.799 align:middle line:-1
我将切换回Xcode显示测试日志

00:26:06.500 --> 00:26:10.103 align:middle line:-1
可以找到测试报告的相关测试日志

00:26:11.338 --> 00:26:13.040 align:middle line:-1
在日志中可以清楚地看到

00:26:13.373 --> 00:26:16.510 align:middle line:-1
你的类如何被分配给不同的运行器

00:26:18.278 --> 00:26:20.948 align:middle line:-2
在日志中 可以看到
每个运行器的条目

00:26:21.949 --> 00:26:23.350 align:middle line:-1
在每个给定运行器下方

00:26:23.417 --> 00:26:26.520 align:middle line:-1
可以看到当前正在执行的测试类

00:26:28.021 --> 00:26:30.190 align:middle line:-1
当测试完全结束后

00:26:30.257 --> 00:26:33.393 align:middle line:-1
在这里可以看到类是如何分配的

00:26:33.460 --> 00:26:36.029 align:middle line:-1
让你了解整个并行执行流程的概况

00:26:37.397 --> 00:26:39.299 align:middle line:-1
让我们回到幻灯片

00:26:48.475 --> 00:26:51.044 align:middle line:-1
让我们简要回顾在演示中学到的知识

00:26:52.045 --> 00:26:56.083 align:middle line:-2
首先 我们看到
如何在方案编辑器中启用并行测试

00:26:57.351 --> 00:27:00.120 align:middle line:-2
接下来 我们介绍如何
查看测试报告中的结果

00:26:57.351 --> 00:27:00.120 align:middle line:-2
接下来 我们介绍如何
查看测试报告中的结果

00:27:00.521 --> 00:27:03.590 align:middle line:-1
以及在测试日志中查看类的分配方式

00:27:05.626 --> 00:27:09.663 align:middle line:-2
然后我们看到Xcode启动
Mac app的多个实例

00:27:09.730 --> 00:27:11.498 align:middle line:-1
以并行运行单元测试

00:27:13.000 --> 00:27:16.003 align:middle line:-1
最后 我们看到模拟器的多个克隆

00:27:16.370 --> 00:27:18.105 align:middle line:-1
它们并行运行用户界面测试

00:27:20.541 --> 00:27:22.009 align:middle line:-1
如前所述

00:27:22.342 --> 00:27:25.512 align:middle line:-2
xcodebuild也很好地
支持并行测试

00:27:26.446 --> 00:27:30.450 align:middle line:-2
我们添加了一些新命令行选项
允许你控制测试行为

00:27:30.517 --> 00:27:32.386 align:middle line:-1
现在 我想指出两点

00:27:34.021 --> 00:27:36.890 align:middle line:-2
首先 我们设有
并行测试工作线程计数

00:27:37.257 --> 00:27:39.793 align:middle line:-1
允许你控制工作线程的数量

00:27:39.860 --> 00:27:43.397 align:middle line:-2
或并行测试期间
应该启动的运行器数量

00:27:44.765 --> 00:27:48.502 align:middle line:-2
通常情况下 Xcode将会
根据机器资源和工作负荷

00:27:48.569 --> 00:27:51.939 align:middle line:-1
确定最优的运行器数量

00:27:52.873 --> 00:27:56.910 align:middle line:-2
这意味着 机器内核数量越多
运行器数量就越多

00:27:58.111 --> 00:28:01.281 align:middle line:-2
但是 如果你发现默认的
运行器数量不符合你的需求

00:27:58.111 --> 00:28:01.281 align:middle line:-2
但是 如果你发现默认的
运行器数量不符合你的需求

00:28:01.348 --> 00:28:03.750 align:middle line:-1
可以使用命令行选项进行重写

00:28:05.986 --> 00:28:08.222 align:middle line:-1
接下来 我们启用并行测试

00:28:08.288 --> 00:28:10.757 align:middle line:-1
允许你重写方案中的设置

00:28:10.824 --> 00:28:13.861 align:middle line:-1
以显式启用或禁用并行测试

00:28:16.864 --> 00:28:18.799 align:middle line:-1
在大多数情况下

00:28:18.866 --> 00:28:21.702 align:middle line:-2
只需要启用
就可以获得并行测试的好处

00:28:22.469 --> 00:28:24.171 align:middle line:-1
这里有一些提示和技巧

00:28:24.438 --> 00:28:26.640 align:middle line:-1
帮助你充分利用此功能

00:28:28.041 --> 00:28:29.676 align:middle line:-1
首先 应考虑

00:28:29.743 --> 00:28:32.779 align:middle line:-1
将长时运行测试类拆分为两个类

00:28:34.248 --> 00:28:36.984 align:middle line:-1
因为测试类并行执行

00:28:37.384 --> 00:28:40.521 align:middle line:-2
测试时间不会超过
最长时间运行类所用的时间

00:28:41.889 --> 00:28:45.459 align:middle line:-2
并行运行测试时
可能发现这样的情况

00:28:45.792 --> 00:28:49.363 align:middle line:-1
一个类占用全部执行时间

00:28:50.430 --> 00:28:52.799 align:middle line:-1
如果拆分这个类

00:28:53.300 --> 00:28:57.070 align:middle line:-1
Xcode可以在不同的运行器之间

00:28:57.137 --> 00:28:58.705 align:middle line:-1
更均衡地分配测试执行工作

00:28:58.772 --> 00:29:00.974 align:middle line:-1
从而缩短执行总用时

00:28:58.772 --> 00:29:00.974 align:middle line:-1
从而缩短执行总用时

00:29:02.242 --> 00:29:03.610 align:middle line:-1
你并不需要

00:29:03.677 --> 00:29:05.946 align:middle line:-1
拆分所有的类

00:29:06.380 --> 00:29:09.716 align:middle line:-2
这没有必根本
但是如果你发现这样的瓶颈

00:29:09.983 --> 00:29:11.185 align:middle line:-1
可以尝试这样做

00:29:13.887 --> 00:29:17.858 align:middle line:-2
接下来 将性能测试
放入它们自己的捆绑包

00:29:17.925 --> 00:29:19.526 align:middle line:-1
并禁用并行测试

00:29:20.661 --> 00:29:22.362 align:middle line:-1
这似乎不够直观

00:29:22.429 --> 00:29:26.300 align:middle line:-1
但是性能测试对系统活动十分敏感

00:29:26.800 --> 00:29:29.069 align:middle line:-1
如果并行地进行测试

00:29:29.136 --> 00:29:31.371 align:middle line:-1
可能无法达到性能指标

00:29:33.473 --> 00:29:37.511 align:middle line:-1
最后应该理解并行测试并不安全

00:29:38.478 --> 00:29:41.014 align:middle line:-1
大多数测试都可以并行完成

00:29:41.481 --> 00:29:44.284 align:middle line:-1
但是如果多个测试访问共享系统资源

00:29:44.351 --> 00:29:45.886 align:middle line:-1
比如文件或数据库

00:29:46.286 --> 00:29:48.989 align:middle line:-1
需要引入显式同步机制

00:29:49.056 --> 00:29:50.757 align:middle line:-1
以允许它们同时运行

00:29:52.226 --> 00:29:53.961 align:middle line:-1
说到测试提示和技巧

00:29:54.027 --> 00:29:56.864 align:middle line:-1
如果想要详细了解如何测试你的代码

00:29:57.297 --> 00:29:59.900 align:middle line:-1
我建议你们参加星期五的演讲

00:29:59.967 --> 00:30:02.903 align:middle line:-2
由我的同事Stuart
和Brian主讲 希望不要错过

00:29:59.967 --> 00:30:02.903 align:middle line:-2
由我的同事Stuart
和Brian主讲 希望不要错过

00:30:05.439 --> 00:30:06.473 align:middle line:-1
最后总结

00:30:06.540 --> 00:30:09.076 align:middle line:-1
今天我讨论了代码覆盖

00:30:09.409 --> 00:30:12.112 align:middle line:-1
性能和准确性改进

00:30:13.280 --> 00:30:17.050 align:middle line:-2
接下来 我们讨论了新的
测试选择和排序功能

00:30:17.451 --> 00:30:20.287 align:middle line:-1
让你能够准确控制运行哪些测试

00:30:20.654 --> 00:30:22.689 align:middle line:-1
并且控制测试运行顺序

00:30:23.724 --> 00:30:26.660 align:middle line:-1
最后 我们介绍了并行分布式测试

00:30:26.960 --> 00:30:30.464 align:middle line:-2
此功能让你能够把测试类
分配给不同的运行器

00:30:30.531 --> 00:30:31.965 align:middle line:-1
以并行执行

00:30:33.400 --> 00:30:34.368 align:middle line:-1
要了解详细信息

00:30:34.434 --> 00:30:37.938 align:middle line:0
建议从developer.apple.com
下载我们的幻灯片

00:30:38.005 --> 00:30:40.407 align:middle line:0
也可以在今天下午前往
实验室与我们见面

00:30:41.241 --> 00:30:42.843 align:middle line:-1
祝大家度过一个愉快的WWDC
