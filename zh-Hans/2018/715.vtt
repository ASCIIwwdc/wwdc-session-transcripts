WEBVTT

00:00:17.784 --> 00:00:19.820 align:middle line:0
（Network.framework简介
套接字的现代替代品）

00:00:19.887 --> 00:00:20.721 align:middle line:0
（演讲715）

00:00:20.787 --> 00:00:21.655 align:middle line:-1
早上好

00:00:22.990 --> 00:00:24.191 align:middle line:-1
我叫Josh Graessley

00:00:24.258 --> 00:00:26.293 align:middle line:-1
我很高兴今天早上能来到这里

00:00:26.360 --> 00:00:28.228 align:middle line:-2
向你介绍
Network.framework

00:00:30.531 --> 00:00:33.467 align:middle line:-2
Network.framework
是套接字的现代替代品

00:00:33.934 --> 00:00:37.738 align:middle line:-1
今天我们将讨论现代化传输API

00:00:37.804 --> 00:00:39.773 align:middle line:-1
这将提供一些背景知识以便你理解

00:00:39.840 --> 00:00:43.110 align:middle line:-2
Network.framework是什么
以及它如何结合到系统中

00:00:43.377 --> 00:00:46.146 align:middle line:-1
以及你的app是否应该使用它

00:00:47.247 --> 00:00:48.782 align:middle line:-1
我们将通过引导你完成

00:00:48.849 --> 00:00:51.285 align:middle line:-1
第一次连接来向你介绍其API

00:00:52.186 --> 00:00:54.621 align:middle line:-1
我们将讨论如何使用此API

00:00:54.688 --> 00:00:56.890 align:middle line:-1
来真正优化你的数据传输

00:00:56.957 --> 00:01:00.127 align:middle line:-1
并提供远超套接字所能提供的性能

00:00:56.957 --> 00:01:00.127 align:middle line:-1
并提供远超套接字所能提供的性能

00:01:01.261 --> 00:01:02.663 align:middle line:-1
我们将讨论这个API

00:01:02.729 --> 00:01:05.232 align:middle line:-2
如何帮助你应对
一些复杂的移动性挑战

00:01:05.399 --> 00:01:07.935 align:middle line:-2
最后我们将提供一些
关于你如何参与进来

00:01:08.001 --> 00:01:09.269 align:middle line:-1
并开始使用的信息

00:01:10.270 --> 00:01:11.104 align:middle line:-1
首先…

00:01:11.238 --> 00:01:15.108 align:middle line:-2
我想花一点时间谈论
现代化传输API

00:01:15.642 --> 00:01:17.177 align:middle line:-1
当我说传输API时

00:01:17.244 --> 00:01:19.112 align:middle line:-1
我在谈论这样的API

00:01:19.179 --> 00:01:21.381 align:middle line:-1
即它可以让你在网络上两个端点之间

00:01:21.448 --> 00:01:23.350 align:middle line:-1
发送和接收任意数据

00:01:23.684 --> 00:01:25.152 align:middle line:-1
这是一个相当广泛的定义

00:01:25.219 --> 00:01:28.188 align:middle line:-1
有很多API可能属于此类别

00:01:30.290 --> 00:01:32.659 align:middle line:-1
也许其中应用最广泛的就是套接字

00:01:32.826 --> 00:01:35.229 align:middle line:-1
我们使用套接字已经有30多年了

00:01:35.395 --> 00:01:36.897 align:middle line:-1
而且我认为

00:01:36.964 --> 00:01:38.899 align:middle line:-1
说套接字改变了世界并不夸张

00:01:39.266 --> 00:01:40.801 align:middle line:-1
但世界一直在变化

00:01:41.068 --> 00:01:42.202 align:middle line:-1
其结果是

00:01:42.736 --> 00:01:46.840 align:middle line:-2
使用套接字为今天的互联网
编写app真的很难

00:01:47.241 --> 00:01:50.410 align:middle line:-2
在三个主要领域中
若想很好地使用套接字

00:01:50.477 --> 00:01:51.812 align:middle line:-1
非常困难

00:01:53.146 --> 00:01:55.249 align:middle line:-1
第一个是建立连接

00:01:55.516 --> 00:01:58.986 align:middle line:-1
有很多原因导致使用套接字

00:01:59.119 --> 00:02:00.954 align:middle line:-1
来建立连接非常困难

00:01:59.119 --> 00:02:00.954 align:middle line:-1
来建立连接非常困难

00:02:01.455 --> 00:02:03.957 align:middle line:-1
首先 套接字连接到地址

00:02:04.191 --> 00:02:06.927 align:middle line:-1
所以大多数时候你需要有一个主机名

00:02:06.994 --> 00:02:09.663 align:middle line:-2
并且你必须将该主机名
解析为一个地址

00:02:10.497 --> 00:02:11.832 align:middle line:-1
当你这样做时

00:02:11.899 --> 00:02:13.700 align:middle line:-1
你通常会得到多个地址

00:02:13.800 --> 00:02:17.404 align:middle line:-2
你会得到一些IPv4地址
一些IPv6地址

00:02:18.071 --> 00:02:19.206 align:middle line:-1
现在你遇到了这个挑战

00:02:19.273 --> 00:02:21.008 align:middle line:-1
你应该尝试连接哪个地址

00:02:21.074 --> 00:02:21.942 align:middle line:-1
以什么顺序

00:02:22.009 --> 00:02:23.877 align:middle line:-1
你在尝试下一个之前等待多久

00:02:24.244 --> 00:02:26.413 align:middle line:-1
你可以花费数年时间来完善这一点

00:02:26.680 --> 00:02:28.215 align:middle line:-2
我知道
因为我们就是这样做的

00:02:30.150 --> 00:02:32.719 align:middle line:-1
一旦你解决了双协议栈主机问题

00:02:33.020 --> 00:02:35.088 align:middle line:-1
你还会遇到更多其它问题

00:02:35.389 --> 00:02:36.957 align:middle line:-1
有些网络使用一种

00:02:37.024 --> 00:02:39.660 align:middle line:-1
叫做代理自动配置或PAC的东西

00:02:40.027 --> 00:02:42.529 align:middle line:-2
在这些网络上
你会得到一个JavaScript

00:02:42.696 --> 00:02:44.898 align:middle line:-2
并且你必须将一个URL
传递给JavaScript

00:02:45.098 --> 00:02:47.434 align:middle line:-2
然后JavaScript
将运行并返回一结果

00:02:47.634 --> 00:02:50.070 align:middle line:-1
其中说明你可以直接连接

00:02:50.137 --> 00:02:52.406 align:middle line:-1
或是你必须使用这个SOCKS代理

00:02:52.472 --> 00:02:54.608 align:middle line:-1
或者那个HTTP连接代理

00:02:54.875 --> 00:02:57.144 align:middle line:-2
这样你的app就必须
支持SOCKS代理

00:02:57.211 --> 00:02:58.979 align:middle line:-1
和HTTP连接代理

00:02:59.313 --> 00:03:01.248 align:middle line:-1
这真的很难做好

00:02:59.313 --> 00:03:01.248 align:middle line:-1
这真的很难做好

00:03:01.949 --> 00:03:03.150 align:middle line:-1
最困难的事情

00:03:03.217 --> 00:03:05.419 align:middle line:-1
是你可能没有其中一个网络以供测试

00:03:05.619 --> 00:03:08.288 align:middle line:-2
所以你可能会收到
一位客户的错误报告

00:03:08.555 --> 00:03:10.757 align:middle line:-1
他们可能会抱怨它在他们的环境下

00:03:10.824 --> 00:03:11.859 align:middle line:-1
无法正常工作

00:03:12.092 --> 00:03:14.194 align:middle line:-1
你可能想要添加代码来解决问题

00:03:14.695 --> 00:03:15.529 align:middle line:-1
但…

00:03:15.729 --> 00:03:16.730 align:middle line:-1
尽管你修改了代码

00:03:16.797 --> 00:03:18.265 align:middle line:-1
你却无法测试它

00:03:18.332 --> 00:03:20.100 align:middle line:-1
你最终必须构建整个环境

00:03:20.167 --> 00:03:22.002 align:middle line:-1
来重现其所在的相同环境

00:03:22.503 --> 00:03:23.971 align:middle line:-1
这是一个真正的挑战

00:03:24.738 --> 00:03:27.074 align:middle line:-1
所以用套接字连接真的很难

00:03:28.542 --> 00:03:30.978 align:middle line:-1
使用套接字的第二个挑战

00:03:31.044 --> 00:03:32.346 align:middle line:-1
是数据传输

00:03:32.946 --> 00:03:35.449 align:middle line:-1
使用套接字传输数据非常困难

00:03:35.516 --> 00:03:36.583 align:middle line:-1
这有很多原因

00:03:37.885 --> 00:03:41.722 align:middle line:-1
主要的问题是读写模型本身

00:03:42.656 --> 00:03:45.259 align:middle line:-2
如果你使用阻塞套接字
那很简单

00:03:45.759 --> 00:03:46.960 align:middle line:-1
但是你要绑定一个线程

00:03:47.094 --> 00:03:49.730 align:middle line:-2
而在等待读取或写入数据时
绑定一个线程

00:03:49.796 --> 00:03:51.431 align:middle line:-1
真的不是一个好主意

00:03:52.099 --> 00:03:54.301 align:middle line:-1
你可以切换到非阻塞

00:03:54.368 --> 00:03:56.470 align:middle line:-1
但最终你会遇到更多其它挑战

00:03:57.371 --> 00:03:58.605 align:middle line:-1
当你使用非阻塞时

00:03:58.672 --> 00:04:00.707 align:middle line:-2
你可能告诉内核
我想要100个字节

00:03:58.672 --> 00:04:00.707 align:middle line:-2
你可能告诉内核
我想要100个字节

00:04:00.841 --> 00:04:03.577 align:middle line:-2
而内核可能会回答说
我现在只有10个字节

00:04:03.644 --> 00:04:04.778 align:middle line:-1
你为何不稍后再回来呢

00:04:04.945 --> 00:04:06.113 align:middle line:-1
你必须建立一个状态机

00:04:06.180 --> 00:04:07.548 align:middle line:-1
以跟踪你读取的字节数

00:04:07.614 --> 00:04:09.016 align:middle line:-1
与你想要读取的字节数

00:04:09.216 --> 00:04:11.885 align:middle line:-2
这个工作量可能会很大
而且要想使其表现良好

00:04:11.952 --> 00:04:13.153 align:middle line:-1
可能是一个真正的挑战

00:04:14.555 --> 00:04:15.689 align:middle line:-1
最重要的是

00:04:15.756 --> 00:04:17.991 align:middle line:-1
你真的不应该直接读写套接字

00:04:18.058 --> 00:04:20.627 align:middle line:-1
因为你应该使用安全传输层协议

00:04:20.694 --> 00:04:21.728 align:middle line:-1
即TLS之类的东西

00:04:24.097 --> 00:04:25.766 align:middle line:-1
套接字不支持TLS

00:04:25.832 --> 00:04:28.001 align:middle line:-1
所以你可能正在使用其它一些库

00:04:28.402 --> 00:04:30.971 align:middle line:-1
它们会为你处理TLS

00:04:31.038 --> 00:04:33.040 align:middle line:-1
并替你读取和写入套接字

00:04:33.106 --> 00:04:35.943 align:middle line:-2
或者你也可以编写
该库和套接字之间的胶水代码

00:04:36.109 --> 00:04:37.744 align:middle line:-1
而且你必须弄清楚如何预先放入

00:04:37.811 --> 00:04:40.113 align:middle line:-2
那些复杂的连接逻辑
并让所有这些正常工作

00:04:41.515 --> 00:04:43.283 align:middle line:-1
这里有很多东西可能非常困难

00:04:45.285 --> 00:04:48.088 align:middle line:-2
最后 使用套接字对移动性
带来极大的挑战

00:04:48.388 --> 00:04:49.690 align:middle line:-1
这有多种原因

00:04:51.225 --> 00:04:55.262 align:middle line:-2
我认为这很大程度上归结于
当套接字刚出现时

00:04:56.029 --> 00:04:58.632 align:middle line:-1
许多设备需要不止一个人来移动它们

00:04:58.699 --> 00:05:00.434 align:middle line:-1
而且它们只用一根网线连接

00:04:58.699 --> 00:05:00.434 align:middle line:-1
而且它们只用一根网线连接

00:05:00.501 --> 00:05:03.904 align:middle line:-2
并且它们只有一个静态IP地址
一切都很稳定和简单

00:05:04.304 --> 00:05:08.375 align:middle line:-2
而今天我们的口袋里
装有这些功能强大的设备

00:05:08.442 --> 00:05:11.612 align:middle line:-1
其可能同时开启多射频

00:05:11.945 --> 00:05:14.381 align:middle line:-2
并且其中一些正在从一个网络
迁移到另一个网络

00:05:14.515 --> 00:05:17.317 align:middle line:-2
而你的app必须很好地处理
所有这些转换

00:05:17.384 --> 00:05:19.686 align:middle line:-1
来为你的客户提供无缝体验

00:05:22.656 --> 00:05:24.925 align:middle line:-1
套接字无法帮你解决此问题

00:05:25.092 --> 00:05:28.161 align:middle line:-2
你可以使用路由套接字
但这非常非常困难

00:05:28.495 --> 00:05:30.631 align:middle line:-1
我们认为传输API可以做得更好

00:05:32.165 --> 00:05:35.469 align:middle line:-2
幸运的是 在我们的平台上
作为app开发者

00:05:35.536 --> 00:05:38.071 align:middle line:-2
你在URLSession中
有一个很棒的API

00:05:39.006 --> 00:05:42.409 align:middle line:-2
URLSession
为你处理所有这些问题

00:05:43.110 --> 00:05:46.346 align:middle line:-2
它真正专注于HTTP
但它也有流任务

00:05:46.547 --> 00:05:49.917 align:middle line:-2
它能为你提供
对TCP和TLS连接的原始访问

00:05:51.151 --> 00:05:52.486 align:middle line:-1
现在你可能正在看这幅图

00:05:52.786 --> 00:05:55.222 align:middle line:-1
并且如果你没有通过查看

00:05:55.289 --> 00:05:56.590 align:middle line:-1
WWDC app中的描述而作弊

00:05:56.924 --> 00:06:00.527 align:middle line:-2
你可能认为URLSession
是基于与你自己使用的

00:05:56.924 --> 00:06:00.527 align:middle line:-2
你可能认为URLSession
是基于与你自己使用的

00:06:00.594 --> 00:06:02.095 align:middle line:-1
相同的原语所构建的

00:06:03.297 --> 00:06:04.932 align:middle line:-1
但事实并非如此

00:06:05.899 --> 00:06:09.236 align:middle line:-2
URLSession建立在我们称之为
Network.framework的基础之上

00:06:10.037 --> 00:06:13.407 align:middle line:-2
URLSession
关注的是所有的HTTP内容

00:06:13.907 --> 00:06:17.578 align:middle line:-2
它将很多传输功能委托给
Network.framework

00:06:20.948 --> 00:06:22.749 align:middle line:-2
我们研发
Network.framework

00:06:22.816 --> 00:06:24.017 align:middle line:-1
已经有许多年了

00:06:24.218 --> 00:06:26.653 align:middle line:-2
在支持URLSession方面
我们学到了很多东西

00:06:26.954 --> 00:06:29.556 align:middle line:-2
并且我们把很多这些经验
带到了IETF

00:06:29.623 --> 00:06:33.126 align:middle line:-1
我们的许多工程师经常参加IETF

00:06:33.193 --> 00:06:35.028 align:middle line:-1
并与其它公司的工程师见面

00:06:35.229 --> 00:06:36.930 align:middle line:-1
他们讨论了许多

00:06:36.997 --> 00:06:38.799 align:middle line:-2
我们在传输服务工作组中
学到的东西

00:06:39.032 --> 00:06:41.401 align:middle line:-2
在这些讨论中
我们得到了一些很好的反馈

00:06:41.468 --> 00:06:43.670 align:middle line:-2
我们研究这些反馈
并基于此

00:06:43.737 --> 00:06:44.605 align:middle line:-2
改进
Network.framework

00:06:45.439 --> 00:06:47.908 align:middle line:-1
我们很高兴地宣布

00:06:47.975 --> 00:06:52.179 align:middle line:-2
今年你的app
现在可以直接利用这个库

00:06:58.552 --> 00:07:01.154 align:middle line:-1
我们知道人们喜欢套接字的原因之一

00:06:58.552 --> 00:07:01.154 align:middle line:-1
我们知道人们喜欢套接字的原因之一

00:07:01.221 --> 00:07:04.825 align:middle line:-2
是它给予人们
对几乎所有东西的精细控制

00:07:05.125 --> 00:07:06.527 align:middle line:-1
而他们真的不想失去这点

00:07:07.294 --> 00:07:08.896 align:middle line:-2
因此我们在开发
Network.framework时

00:07:08.962 --> 00:07:11.932 align:middle line:-2
我们希望确保默认情况下
它能做正确的事情

00:07:12.065 --> 00:07:13.534 align:middle line:-1
而套接字不会这样做

00:07:13.800 --> 00:07:16.303 align:middle line:-2
但同时它也给了你
套接字的所有功能

00:07:16.470 --> 00:07:20.207 align:middle line:-2
并且它是以一种渐进的方式
即你转动的旋钮越多

00:07:20.274 --> 00:07:21.575 align:middle line:-1
它变得越复杂

00:07:22.142 --> 00:07:23.744 align:middle line:-1
它为你提供所需的所有功能

00:07:24.044 --> 00:07:25.746 align:middle line:-1
但你不必为复杂性付出代价

00:07:25.812 --> 00:07:27.548 align:middle line:-1
除非你真的需要它

00:07:30.317 --> 00:07:34.154 align:middle line:-2
Network.framework
具有令人难以置信的智能连接搭建过程

00:07:34.755 --> 00:07:36.823 align:middle line:-1
它能处理双协议栈用例

00:07:36.890 --> 00:07:38.592 align:middle line:-1
它能处理仅IPv6网络

00:07:38.825 --> 00:07:39.793 align:middle line:-1
它能处理PAC

00:07:39.860 --> 00:07:41.128 align:middle line:-1
它也能处理代理

00:07:41.595 --> 00:07:42.429 align:middle line:-1
它会…

00:07:42.729 --> 00:07:45.666 align:middle line:-1
帮助你连接在不使用它的情况下

00:07:45.732 --> 00:07:46.567 align:middle line:-1
很难处理的网络

00:07:47.034 --> 00:07:49.937 align:middle line:-2
它具有令人难以置信的
优化数据传输路径

00:07:50.237 --> 00:07:51.939 align:middle line:-1
其性能要远远超过

00:07:52.005 --> 00:07:54.808 align:middle line:-2
套接字可以达到的效果
稍后Tommy会介绍一下这点

00:07:56.210 --> 00:07:57.945 align:middle line:-1
它支持内置安全性

00:07:58.245 --> 00:08:01.281 align:middle line:-1
它默认支持TLS和DTLS

00:07:58.245 --> 00:08:01.281 align:middle line:-1
它默认支持TLS和DTLS

00:08:01.348 --> 00:08:02.916 align:middle line:-1
它使用起来非常简单

00:08:04.184 --> 00:08:06.253 align:middle line:-1
它对移动性有很好的支持

00:08:06.320 --> 00:08:08.622 align:middle line:-1
它提供有关网络更改的通知

00:08:08.689 --> 00:08:12.125 align:middle line:-1
其与你的app正在建立的连接相关

00:08:14.761 --> 00:08:19.032 align:middle line:-2
它可以在iOS、macOS
和tvOS上

00:08:19.166 --> 00:08:20.367 align:middle line:-2
作为带有自动引用计数的
C API使用

00:08:20.434 --> 00:08:24.571 align:middle line:-2
它很容易在Objective C中使用
且它还有令人难以置信的Swift API

00:08:26.807 --> 00:08:29.009 align:middle line:-2
我想把话筒交给
Tommy Pauly

00:08:29.076 --> 00:08:30.978 align:middle line:-1
他会引导你完成你的第一次连接

00:08:31.378 --> 00:08:32.212 align:middle line:-1
谢谢

00:08:38.719 --> 00:08:39.986 align:middle line:-1
好的 大家好

00:08:40.053 --> 00:08:41.121 align:middle line:-1
我叫Tommy Pauly

00:08:41.188 --> 00:08:43.823 align:middle line:-1
我在Apple的网络团队工作

00:08:44.658 --> 00:08:47.995 align:middle line:-1
我相信很多人都很高兴能够看到

00:08:48.061 --> 00:08:52.165 align:middle line:-2
如何开始在你的app中
使用Network.framework

00:08:53.267 --> 00:08:54.902 align:middle line:-1
开始学习并立即尝试的最好方式

00:08:55.169 --> 00:08:57.771 align:middle line:-1
就是尝试建立你的第一个连接

00:08:58.539 --> 00:09:00.841 align:middle line:-1
你将从本地设备建立连接

00:08:58.539 --> 00:09:00.841 align:middle line:-1
你将从本地设备建立连接

00:09:01.108 --> 00:09:02.009 align:middle line:-1
到你的服务器

00:09:02.543 --> 00:09:05.479 align:middle line:-1
或本地网络上的其它对等设备

00:09:07.114 --> 00:09:08.348 align:middle line:-1
但你可能在想

00:09:08.916 --> 00:09:11.318 align:middle line:-1
哪种连接适合使用

00:09:11.385 --> 00:09:12.452 align:middle line:-1
Network.framework呢

00:09:12.653 --> 00:09:13.887 align:middle line:-1
有什么用例？

00:09:14.521 --> 00:09:20.027 align:middle line:-2
让我们首先探讨一些可能正在使用
套接字的app

00:09:20.460 --> 00:09:23.197 align:middle line:-2
它们若能在以后利用
Network.framework

00:09:23.263 --> 00:09:24.965 align:middle line:-1
将会大有裨益

00:09:26.900 --> 00:09:28.669 align:middle line:-1
我要强调的第一种

00:09:29.136 --> 00:09:30.370 align:middle line:-1
是游戏app

00:09:30.971 --> 00:09:35.042 align:middle line:-2
游戏app通常使用UDP
在两台设备间实时发送

00:09:35.108 --> 00:09:38.412 align:middle line:-1
关于游戏状态的数据

00:09:39.446 --> 00:09:42.182 align:middle line:-1
它们非常重视优化延迟

00:09:42.316 --> 00:09:44.985 align:middle line:-2
并确保没有任何滞后
或任何被丢弃的东西

00:09:45.953 --> 00:09:47.688 align:middle line:-1
如果你有这样的app

00:09:48.288 --> 00:09:50.190 align:middle line:-2
你会爱上
Network.framework

00:09:50.257 --> 00:09:52.693 align:middle line:-1
因为它允许你真正优化UDP

00:09:52.893 --> 00:09:56.830 align:middle line:-1
发送和接收比以往更快

00:09:56.897 --> 00:09:58.765 align:middle line:-1
以及具有尽可能短的延迟时间

00:10:00.968 --> 00:10:01.969 align:middle line:-1
另一种能够得益于

00:10:02.035 --> 00:10:04.438 align:middle line:-2
Network.framework的
app类别

00:10:04.838 --> 00:10:06.440 align:middle line:-1
是直播app

00:10:06.673 --> 00:10:08.775 align:middle line:-1
直播app

00:10:08.842 --> 00:10:10.477 align:middle line:-1
通常在app中结合使用UDP

00:10:10.777 --> 00:10:12.579 align:middle line:-1
和TCP

00:10:13.313 --> 00:10:17.484 align:middle line:-2
但这里的关键点是
它正在实时地生成数据

00:10:17.885 --> 00:10:20.654 align:middle line:-1
如果你有新的视频帧或音频帧

00:10:20.821 --> 00:10:23.056 align:middle line:-1
你需要确保它们步调一致

00:10:23.190 --> 00:10:24.992 align:middle line:-1
而且你不会在设备或网络上

00:10:25.058 --> 00:10:27.461 align:middle line:-1
造成很多缓冲

00:10:28.629 --> 00:10:31.698 align:middle line:-2
Network.framework中
用于读写的异步模型

00:10:31.999 --> 00:10:33.834 align:middle line:-1
可以完美的应用于

00:10:34.067 --> 00:10:36.036 align:middle line:-1
确保你能够减少这种缓冲

00:10:38.238 --> 00:10:42.075 align:middle line:-2
我要强调的最后一个用例
是邮件和消息app

00:10:42.910 --> 00:10:45.879 align:middle line:-1
这些app将使用更传统的协议

00:10:45.946 --> 00:10:48.081 align:middle line:-1
即TCP上的TLS

00:10:48.916 --> 00:10:51.051 align:middle line:-1
然而优雅地处理网络转换

00:10:51.118 --> 00:10:53.587 align:middle line:-1
对于像这样的app来说非常重要

00:10:55.355 --> 00:10:59.026 align:middle line:-2
通常 如果你有一个消息传递app
你的用户会在他走出大楼时

00:10:59.092 --> 00:11:00.494 align:middle line:-1
使用你的app

00:10:59.092 --> 00:11:00.494 align:middle line:-1
使用你的app

00:11:00.561 --> 00:11:03.096 align:middle line:-2
给他的朋友发消息让他们知道
他正在路上

00:11:03.630 --> 00:11:06.333 align:middle line:-1
你想确保你能够处理这种转变

00:11:06.400 --> 00:11:07.801 align:middle line:-1
从大楼内的Wi-Fi网络

00:11:07.868 --> 00:11:09.670 align:middle line:-1
切换到他即将进入的蜂窝网络

00:11:10.037 --> 00:11:12.339 align:middle line:-1
并且你没有用很长时间来将消息

00:11:12.406 --> 00:11:13.874 align:middle line:-1
送到他的朋友那里

00:11:15.342 --> 00:11:18.212 align:middle line:-2
这些只是可能会使用
像这样的低级网络的

00:11:18.278 --> 00:11:20.647 align:middle line:-1
三种类型的app

00:11:21.481 --> 00:11:24.585 align:middle line:-2
还有许多其它类型的app
可以利用它

00:11:24.651 --> 00:11:26.453 align:middle line:-1
所以如果你有一个这些类型的app

00:11:26.854 --> 00:11:29.389 align:middle line:-1
或当前使用套接字的其它一些用例

00:11:29.456 --> 00:11:33.627 align:middle line:-2
我邀请你继续跟随我
并了解你的app可以如何受益

00:11:34.795 --> 00:11:37.464 align:middle line:-1
首先我想专注于最后一个用例

00:11:37.631 --> 00:11:40.167 align:middle line:-1
最简单的邮件和消息app用例

00:11:40.234 --> 00:11:42.569 align:middle line:-1
并看下他们如何建立连接

00:11:44.538 --> 00:11:47.174 align:middle line:-1
当你想建立与服务器的连接时

00:11:47.241 --> 00:11:52.646 align:middle line:-2
假设这是一个邮件连接 即带有
TLS安全功能的iMap协议

00:11:53.447 --> 00:11:56.517 align:middle line:-2
你从主机名
mail.example.com开始

00:11:57.251 --> 00:12:00.087 align:middle line:-2
你有一个要连接的端口
即端口993

00:11:57.251 --> 00:12:00.087 align:middle line:-2
你有一个要连接的端口
即端口993

00:12:00.687 --> 00:12:03.757 align:middle line:-2
并且你希望使用TLS
以及TCP协议

00:12:05.058 --> 00:12:07.594 align:middle line:-1
那么传统的套接字是如何做的呢

00:12:08.362 --> 00:12:09.997 align:middle line:-1
这样的事情开始了

00:12:10.397 --> 00:12:11.565 align:middle line:-1
你得到该主机名

00:12:11.999 --> 00:12:14.868 align:middle line:-2
你会调用一些DNS API
来解析该主机名

00:12:15.068 --> 00:12:16.770 align:middle line:-1
若它是getaddrinfo()

00:12:17.271 --> 00:12:19.072 align:middle line:-1
你将得到一个或多个地址

00:12:19.139 --> 00:12:21.642 align:middle line:-1
你必须决定要先连接哪一个

00:12:22.476 --> 00:12:25.345 align:middle line:-2
你将调用socket()
附带适当的地址族

00:12:26.346 --> 00:12:28.715 align:middle line:-1
你将设置一系列套接字选项

00:12:29.049 --> 00:12:33.020 align:middle line:-2
假设你希望使用非阻塞套接字
像Josh之前提到的那样

00:12:34.655 --> 00:12:39.159 align:middle line:-2
调用connect()启动TCP
然后等待可写事件

00:12:39.927 --> 00:12:42.429 align:middle line:-2
而且这是在你使用TLS
做任何事情之前

00:12:42.496 --> 00:12:44.531 align:middle line:-1
那又是一大堆其它问题

00:12:46.400 --> 00:12:48.535 align:middle line:-2
这在Network.framework中
看起来如何呢？

00:12:48.669 --> 00:12:50.938 align:middle line:-1
我们希望它看起来很熟悉

00:12:51.905 --> 00:12:53.106 align:middle line:-1
但更简单一些

00:12:53.707 --> 00:12:56.276 align:middle line:-2
所以你做的第一件事
就是创建一个连接对象

00:12:56.343 --> 00:12:58.812 align:middle line:-1
连接对象基于两件事

00:12:59.046 --> 00:12:59.980 align:middle line:-1
第一个是端点

00:13:00.047 --> 00:13:02.182 align:middle line:-1
它定义了你要访问的目标

00:13:02.549 --> 00:13:05.886 align:middle line:-1
这可能是像以前那样的IP地址

00:13:06.253 --> 00:13:09.923 align:middle line:-2
但通常 就像在这个例子中
我们有一个主机名和一个端口

00:13:10.157 --> 00:13:13.026 align:middle line:-2
所以我们的端点
可以只包含主机名和端口

00:13:13.427 --> 00:13:16.163 align:middle line:-2
这也可能是
我想连接的Bonjour服务

00:13:17.397 --> 00:13:19.233 align:middle line:-1
接下来是参数

00:13:19.499 --> 00:13:22.002 align:middle line:-1
参数定义了我想要使用的协议

00:13:22.202 --> 00:13:24.872 align:middle line:-1
TLS、DTLS、UDP、TCP

00:13:25.372 --> 00:13:27.841 align:middle line:-1
它定义了我想要用的协议选项

00:13:28.609 --> 00:13:31.445 align:middle line:-1
以及我想用来连接的路径

00:13:31.645 --> 00:13:34.915 align:middle line:-2
即我是想使用任何东西连接呢
还是只想使用Wi-Fi呢？

00:13:36.250 --> 00:13:38.452 align:middle line:-1
一旦你配置好连接后

00:13:38.852 --> 00:13:41.255 align:middle line:-2
你只需要调用start()
来开始连接

00:13:41.588 --> 00:13:44.391 align:middle line:-1
然后等待连接进入就绪状态

00:13:44.791 --> 00:13:45.659 align:middle line:-1
这就是为了建立完整TLS连接

00:13:45.726 --> 00:13:48.061 align:middle line:-1
你需要做的所有事情

00:13:48.862 --> 00:13:51.298 align:middle line:-2
而且我认为你会喜欢
这在Swift中的样子

00:13:52.766 --> 00:13:53.600 align:middle line:-1
这就是你所要做的

00:13:53.667 --> 00:13:56.170 align:middle line:-1
你首先导入Network模块

00:13:57.404 --> 00:14:00.474 align:middle line:-2
然后你创建一个
NWConnection对象

00:13:57.404 --> 00:14:00.474 align:middle line:-2
然后你创建一个
NWConnection对象

00:14:00.707 --> 00:14:02.042 align:middle line:-1
所以一个NWConnection

00:14:02.376 --> 00:14:04.244 align:middle line:-1
无论是在Swift还是C中

00:14:04.511 --> 00:14:07.247 align:middle line:-1
都是读取和写入数据的基本对象

00:14:08.415 --> 00:14:11.685 align:middle line:-2
在这个例子中
我们可以方便地使用主机和端口

00:14:11.818 --> 00:14:13.020 align:middle line:-1
来初始化你的端点

00:14:13.287 --> 00:14:16.356 align:middle line:-2
所以我给它我的主机名
mail.example.com

00:14:16.857 --> 00:14:18.292 align:middle line:-1
以及端口 在这个例子中

00:14:18.358 --> 00:14:19.760 align:middle line:-1
这是一个众所周知的端口

00:14:20.027 --> 00:14:21.295 align:middle line:-1
即iMaps

00:14:21.528 --> 00:14:23.830 align:middle line:-2
所以我可以把它放在Swift中
非常简单

00:14:23.897 --> 00:14:27.100 align:middle line:-2
但我也可以在那里输入
任何其它数值文字

00:14:28.569 --> 00:14:30.737 align:middle line:-1
然后我通过传入参数来定义

00:14:30.804 --> 00:14:32.005 align:middle line:-1
我想要使用的协议

00:14:32.706 --> 00:14:34.374 align:middle line:-1
由于这是客户端连接

00:14:34.441 --> 00:14:37.544 align:middle line:-1
我只想要默认 TLS和TCP参数

00:14:38.111 --> 00:14:40.681 align:middle line:-2
只需要输入.tls
就这么简单

00:14:40.948 --> 00:14:43.050 align:middle line:-1
现在我有了一个完整的TLS连接

00:14:45.118 --> 00:14:47.554 align:middle line:-2
我做的下一件事就是设置
stateUpdateHandler

00:14:47.621 --> 00:14:50.724 align:middle line:-1
来处理我的连接可能经历的所有切换

00:14:51.592 --> 00:14:53.961 align:middle line:-2
你要处理的第一个
并且是最重要的状态

00:14:54.127 --> 00:14:55.362 align:middle line:-1
就是就绪状态

00:14:55.863 --> 00:14:59.967 align:middle line:-2
就绪意味着你的app已准备好
在此连接上读取和写入数据

00:15:00.033 --> 00:15:01.301 align:middle line:-1
连接已经完全建立

00:15:01.802 --> 00:15:04.471 align:middle line:-1
如果你使用的是TCP和TLS

00:15:04.538 --> 00:15:06.507 align:middle line:-1
这意味着TLS握手已完成

00:15:08.342 --> 00:15:11.345 align:middle line:-1
我们也会告知你等待状态

00:15:11.778 --> 00:15:16.416 align:middle line:-2
去年在URLSession中
我们引入了waitsForConnectivity

00:15:16.583 --> 00:15:20.153 align:middle line:-2
而NWConnection的
等待状态与之完全相同

00:15:20.420 --> 00:15:22.556 align:middle line:-1
而且默认情况下它始终处于启用状态

00:15:22.789 --> 00:15:24.758 align:middle line:-1
因此当你创建连接并启动它时

00:15:24.825 --> 00:15:27.828 align:middle line:-2
如果没有可用的网络
我们不会失败

00:15:28.095 --> 00:15:30.664 align:middle line:-2
我们只是告诉你
我们正在等待网络变为可用

00:15:30.731 --> 00:15:32.833 align:middle line:-1
我们会给你一个有用的原因代码

00:15:33.300 --> 00:15:36.803 align:middle line:-2
但你不必再做任何其它事情
来自己处理网络切换

00:15:37.404 --> 00:15:40.607 align:middle line:-1
移动性是此API的重要组成部分

00:15:41.842 --> 00:15:44.144 align:middle line:-1
如果出现严重错误 我们也会通知你

00:15:44.211 --> 00:15:47.247 align:middle line:-2
假设我们必须从服务器重置
或TLS失败了

00:15:47.314 --> 00:15:49.116 align:middle line:-1
我们会将其作为失败事件告知你

00:15:50.517 --> 00:15:51.652 align:middle line:-1
一旦你设置好了这些

00:15:52.252 --> 00:15:53.487 align:middle line:-1
只需调用start()

00:15:53.754 --> 00:15:58.358 align:middle line:-1
并提供你希望接收回调的调度队列

00:16:00.360 --> 00:16:03.096 align:middle line:-2
我想深入探讨一下
当调用start()时会发生什么

00:16:03.163 --> 00:16:04.464 align:middle line:-1
实际发生了什么

00:16:05.499 --> 00:16:06.767 align:middle line:-2
NWConnection的
内部结构

00:16:07.201 --> 00:16:09.269 align:middle line:-1
是一个小状态机

00:16:09.770 --> 00:16:11.905 align:middle line:-2
当我们从设置状态开始
并调用start()时

00:16:12.372 --> 00:16:14.775 align:middle line:-1
我们进入准备状态

00:16:14.842 --> 00:16:16.310 align:middle line:-1
（连接生命周期）

00:16:16.376 --> 00:16:18.145 align:middle line:-1
准备状态

00:16:18.612 --> 00:16:22.783 align:middle line:-2
它不仅仅是在TCP套接字上
调用connect()

00:16:23.550 --> 00:16:24.952 align:middle line:-1
对于TCP套接字

00:16:25.018 --> 00:16:28.655 align:middle line:-1
这会将SYN数据包发送到

00:16:28.722 --> 00:16:29.656 align:middle line:-1
想要连接的服务器

00:16:30.824 --> 00:16:32.926 align:middle line:-2
但当你在NWConnection上
调用start()时

00:16:32.993 --> 00:16:36.330 align:middle line:-2
它实际上处理了
Josh之前提到的所有事情

00:16:37.531 --> 00:16:39.233 align:middle line:-1
它会评估你所在的网络

00:16:39.299 --> 00:16:42.369 align:middle line:-1
并尝试为你提供最快的连接

00:16:42.769 --> 00:16:44.538 align:middle line:-1
我想继续深入讨论一下

00:16:44.972 --> 00:16:48.475 align:middle line:-2
所以这就是我们所说的
智能连接搭建

00:16:49.943 --> 00:16:51.678 align:middle line:-1
当你调用start()时

00:16:52.012 --> 00:16:53.213 align:middle line:-1
我们所做的第一件事是

00:16:53.780 --> 00:16:55.115 align:middle line:-1
我们获取你的端点

00:16:55.749 --> 00:16:57.584 align:middle line:-1
然后我们评估当前可用的

00:16:57.651 --> 00:16:59.119 align:middle line:-1
所有网络是什么

00:16:59.786 --> 00:17:02.556 align:middle line:-2
在这个例子中
我们有Wi-Fi和蜂窝网络

00:16:59.786 --> 00:17:02.556 align:middle line:-2
在这个例子中
我们有Wi-Fi和蜂窝网络

00:17:03.056 --> 00:17:07.361 align:middle line:-2
通常我们更喜欢Wi-Fi网络
因为它对用户来说成本更低

00:17:08.028 --> 00:17:09.463 align:middle line:-1
所以我们先看看那个

00:17:10.998 --> 00:17:14.667 align:middle line:-2
然后我们检查一下
该网络上是否有任何特殊配置

00:17:14.734 --> 00:17:16.569 align:middle line:-1
有VPN吗？有代理吗？

00:17:16.637 --> 00:17:18.405 align:middle line:-1
我们将为你评估

00:17:19.339 --> 00:17:20.240 align:middle line:-1
在这个例子中

00:17:20.473 --> 00:17:25.212 align:middle line:-2
假设有一个配置了
自动配置文件的代理

00:17:25.512 --> 00:17:27.748 align:middle line:-1
如果代理不适用于你的连接

00:17:28.048 --> 00:17:30.250 align:middle line:-1
它也可以直连

00:17:30.551 --> 00:17:32.619 align:middle line:-1
所以我们将评估这两个选项

00:17:33.554 --> 00:17:35.222 align:middle line:-1
我们将检查是否需要使用代理

00:17:35.689 --> 00:17:37.057 align:middle line:-1
继续并连接到它

00:17:37.424 --> 00:17:38.892 align:middle line:-1
在那里创建一个TCP连接

00:17:39.893 --> 00:17:40.928 align:middle line:-1
但如果我们不需要它

00:17:41.228 --> 00:17:43.297 align:middle line:-1
我们将替你执行DNS

00:17:43.864 --> 00:17:44.898 align:middle line:-1
直接连接

00:17:45.165 --> 00:17:48.368 align:middle line:-1
取回所有回复的DNS IP地址

00:17:48.702 --> 00:17:49.837 align:middle line:-1
并连接到它们

00:17:50.704 --> 00:17:53.307 align:middle line:-1
一个接一个地让它们并行执行

00:17:53.373 --> 00:17:56.510 align:middle line:-2
我们比较它们的速度
来为你提供最快的连接

00:17:59.379 --> 00:18:01.415 align:middle line:-1
然后 如果Wi-Fi出现问题

00:17:59.379 --> 00:18:01.415 align:middle line:-1
然后 如果Wi-Fi出现问题

00:18:01.481 --> 00:18:04.017 align:middle line:-1
假设Wi-Fi信号质量非常糟糕

00:18:04.084 --> 00:18:05.752 align:middle line:-1
因为你离开了大楼

00:18:07.287 --> 00:18:10.657 align:middle line:-2
我们实际上可以利用
称为Wi-Fi协助的功能

00:18:10.924 --> 00:18:14.061 align:middle line:-1
并无缝回退到蜂窝网络

00:18:14.595 --> 00:18:16.296 align:middle line:-1
在那里进行DNS解析

00:18:16.630 --> 00:18:19.566 align:middle line:-1
并一个接一个地尝试连接

00:18:20.267 --> 00:18:24.571 align:middle line:-1
所以这样你的连接搭建非常有弹性

00:18:24.638 --> 00:18:25.973 align:middle line:-1
处理VPN

00:18:26.240 --> 00:18:27.441 align:middle line:-1
为你处理代理

00:18:27.875 --> 00:18:29.943 align:middle line:-1
并为你提供可能的最佳连接

00:18:31.912 --> 00:18:32.846 align:middle line:-1
现在 当然

00:18:33.080 --> 00:18:35.516 align:middle line:-1
你可能不想尝试所有这些选项

00:18:35.582 --> 00:18:38.652 align:middle line:-1
你可能希望限制连接搭建的行为

00:18:39.620 --> 00:18:42.656 align:middle line:-2
所以我们有许多不同的旋钮
和控件让你这样做

00:18:42.723 --> 00:18:44.958 align:middle line:-1
我今天要强调其中的三个

00:18:46.827 --> 00:18:50.330 align:middle line:-1
首先 你可能不想使用昂贵的网络

00:18:50.397 --> 00:18:51.565 align:middle line:-1
比如蜂窝网络

00:18:51.632 --> 00:18:55.369 align:middle line:-1
因为此连接仅适合使用Wi-Fi

00:18:56.003 --> 00:18:58.405 align:middle line:-1
所以在连接的参数中

00:18:59.006 --> 00:19:02.643 align:middle line:-1
具有控制你所使用接口的选项

00:18:59.006 --> 00:19:02.643 align:middle line:-1
具有控制你所使用接口的选项

00:19:03.010 --> 00:19:04.545 align:middle line:-1
所以如果你不想使用蜂窝

00:19:04.611 --> 00:19:08.982 align:middle line:-2
只需将cellular添加到
prohibitedInterfaceTypes中

00:19:10.684 --> 00:19:12.019 align:middle line:-1
实际上将一般的

00:19:12.085 --> 00:19:15.022 align:middle line:-1
昂贵网络都禁止掉甚至要更好

00:19:15.255 --> 00:19:20.694 align:middle line:-2
因为这也会屏蔽掉 比如说
Mac上个人热点

00:19:22.930 --> 00:19:25.766 align:middle line:-1
另一种限制连接搭建的方法是

00:19:25.966 --> 00:19:28.569 align:middle line:-1
明确指定你想要使用的

00:19:28.635 --> 00:19:29.803 align:middle line:-1
IP地址系列

00:19:30.370 --> 00:19:34.208 align:middle line:-2
假设你非常喜欢IPv6
因为它更快 而且它是未来的趋势

00:19:34.408 --> 00:19:36.743 align:middle line:-1
你根本不想在连接上使用IPv4

00:19:37.244 --> 00:19:39.713 align:middle line:-1
为此你可以使用参数

00:19:39.847 --> 00:19:42.616 align:middle line:-1
找到其中针对IP的选项

00:19:42.850 --> 00:19:45.485 align:middle line:-2
并且在这里你可以看到
该选项

00:19:45.552 --> 00:19:46.854 align:middle line:-1
与你在当前套接字中的

00:19:47.254 --> 00:19:48.388 align:middle line:-1
套接字选项相类似

00:19:48.455 --> 00:19:52.092 align:middle line:-1
你还可以明确指定要使用的IP版本

00:19:52.626 --> 00:19:56.163 align:middle line:-1
这会影响你的连接以及DNS解析

00:19:57.564 --> 00:20:00.100 align:middle line:-1
最后 你可能不想

00:19:57.564 --> 00:20:00.100 align:middle line:-1
最后 你可能不想

00:20:00.267 --> 00:20:01.401 align:middle line:-1
在你的连接上使用代理

00:20:01.468 --> 00:20:03.470 align:middle line:-1
也许你的连接不适合

00:20:03.537 --> 00:20:05.172 align:middle line:-1
使用SOCKS代理

00:20:05.639 --> 00:20:09.276 align:middle line:-2
在这种情况下
你也可以简单地禁止使用代理

00:20:10.844 --> 00:20:13.547 align:middle line:-1
这就是准备状态中所发生的事情

00:20:14.648 --> 00:20:17.451 align:middle line:-2
我之前提到过
事情可能会出错

00:20:17.518 --> 00:20:19.920 align:middle line:-2
在尝试建立连接时
你可能没有可用的网络

00:20:20.320 --> 00:20:24.291 align:middle line:-2
我们在进入准备状态之后所做的是
如果我们发现没有好的选择

00:20:24.358 --> 00:20:27.794 align:middle line:-2
DNS失败 没有网络
也许你处于飞行模式

00:20:27.995 --> 00:20:30.697 align:middle line:-2
我们将进入等待状态
并让你知道其原因

00:20:31.398 --> 00:20:35.369 align:middle line:-2
并且每次网络发生变化时
我们都会回到准备状态

00:20:35.435 --> 00:20:38.038 align:middle line:-1
这时系统认为

00:20:38.238 --> 00:20:40.340 align:middle line:-2
“现在你的连接说不定
能建立成功了呢”

00:20:40.641 --> 00:20:42.176 align:middle line:-1
我们将为你处理所有这些事情

00:20:42.309 --> 00:20:44.711 align:middle line:-1
并且每次我们重新尝试时都会通知你

00:20:46.446 --> 00:20:49.750 align:middle line:-1
最终你会有希望成功建立连接

00:20:49.950 --> 00:20:52.085 align:middle line:-1
此时我们将进入就绪状态

00:20:53.187 --> 00:20:55.122 align:middle line:-1
就像我之前提到的那样

00:20:55.455 --> 00:20:57.858 align:middle line:-1
就绪状态是你的连接完全建立的时候

00:20:57.925 --> 00:21:02.663 align:middle line:-2
此时已准备好了你的协议栈中
一直到上层的协议 例如TLS

00:20:57.925 --> 00:21:02.663 align:middle line:-2
此时已准备好了你的协议栈中
一直到上层的协议 例如TLS

00:21:03.430 --> 00:21:05.098 align:middle line:-1
此时你可以读和写

00:21:05.766 --> 00:21:08.435 align:middle line:-1
这也是我们对你所经历的网络切换

00:21:08.969 --> 00:21:12.172 align:middle line:-1
进行回调的地方

00:21:12.439 --> 00:21:15.709 align:middle line:-2
因此如果你的连接已建立
然后你更改了网络

00:21:15.943 --> 00:21:19.680 align:middle line:-2
我们会为你提供相应的更新
以便你可以优雅地处理移动性

00:21:20.113 --> 00:21:22.416 align:middle line:-1
我们稍后再继续讨论这个问题

00:21:24.718 --> 00:21:25.886 align:middle line:-1
如果连接出错

00:21:25.953 --> 00:21:28.188 align:middle line:-1
无论是在连接建立期间

00:21:28.422 --> 00:21:29.923 align:middle line:-1
还是已经连接后

00:21:29.990 --> 00:21:31.792 align:middle line:-1
你会得到一个错误并进入失败状态

00:21:32.826 --> 00:21:34.828 align:middle line:-1
然后一旦你用完了连接

00:21:34.895 --> 00:21:36.196 align:middle line:-1
假设你已经把它关闭了

00:21:36.263 --> 00:21:38.365 align:middle line:-1
或者你从另一端收到了关闭请求

00:21:38.632 --> 00:21:40.601 align:middle line:-1
并且你想要使连接无效

00:21:40.667 --> 00:21:43.570 align:middle line:-2
你可以调用cancel()
我们就会进入取消状态

00:21:43.637 --> 00:21:46.507 align:middle line:-2
这必定是我们将传递给
你的对象的最后事件

00:21:46.640 --> 00:21:50.410 align:middle line:-1
以便你可以清理所使用的任何内存

00:21:50.477 --> 00:21:52.579 align:middle line:-1
并继续进行下一步

00:21:53.847 --> 00:21:56.750 align:middle line:-2
就是这样 这是对
Network.framework中连接对象的

00:21:57.050 --> 00:21:59.119 align:middle line:-1
基本生命周期的概述

00:21:59.453 --> 00:22:02.656 align:middle line:-2
为了向你展示如何使用它
来构建一个简单的app

00:21:59.453 --> 00:22:02.656 align:middle line:-2
为了向你展示如何使用它
来构建一个简单的app

00:22:02.856 --> 00:22:04.858 align:middle line:-1
我想邀请Eric上台

00:22:13.400 --> 00:22:14.301 align:middle line:-1
谢谢Tommy

00:22:14.535 --> 00:22:15.502 align:middle line:-1
我是Eric Kinnear

00:22:15.569 --> 00:22:17.671 align:middle line:-1
我也来自Apple的网络团队

00:22:17.738 --> 00:22:20.674 align:middle line:-1
我非常高兴能与你一起

00:22:20.841 --> 00:22:22.209 align:middle line:-2
使用Network.framework
构建一个示例app

00:22:22.976 --> 00:22:25.145 align:middle line:-1
我们将使用Tommy先前提到的

00:22:25.212 --> 00:22:26.613 align:middle line:-1
视频直播用例

00:22:26.980 --> 00:22:30.784 align:middle line:-2
构建一个可以在一台设备上
使用来自摄像头的输入

00:22:30.951 --> 00:22:34.188 align:middle line:-2
并通过网络发送
以便在另一台设备上显示的app

00:22:35.289 --> 00:22:38.592 align:middle line:-1
由于我们将持续生成实时视频帧

00:22:38.659 --> 00:22:42.362 align:middle line:-2
我们将使用UDP通过网络
发送这些数据包

00:22:43.096 --> 00:22:44.131 align:middle line:-1
那我们该怎么做呢？

00:22:46.133 --> 00:22:47.100 align:middle line:0
首先…

00:22:47.334 --> 00:22:49.136 align:middle line:0
我们需要与相机进行捕捉会话

00:22:49.303 --> 00:22:52.272 align:middle line:0
以便我们可以从图像传感器
接收视频帧

00:22:53.006 --> 00:22:56.310 align:middle line:0
为了这个例子 我们不打算使用
任何视频编解码器

00:22:56.376 --> 00:22:57.578 align:middle line:0
或其它压缩算法

00:22:57.811 --> 00:23:00.180 align:middle line:0
我们只是从相机中取出原始字节

00:22:57.811 --> 00:23:00.180 align:middle line:0
我们只是从相机中取出原始字节

00:23:00.314 --> 00:23:03.050 align:middle line:0
通过网络发送它们
并在另一端进行显示

00:23:04.351 --> 00:23:07.120 align:middle line:0
为此我们需要将这些帧分割成

00:23:07.187 --> 00:23:10.624 align:middle line:0
我们可以用UDP数据
发送的较小块

00:23:11.859 --> 00:23:14.194 align:middle line:0
当然 要想在网络上发送
这些UDP数据包

00:23:14.328 --> 00:23:15.295 align:middle line:0
我们需要一个连接

00:23:16.830 --> 00:23:19.566 align:middle line:0
对于另一台设备
我们需要一个监听器

00:23:19.766 --> 00:23:21.502 align:middle line:0
它可以接收传入的连接

00:23:22.269 --> 00:23:24.471 align:middle line:0
并从网络上读取数据包

00:23:25.038 --> 00:23:27.307 align:middle line:0
此后我们只是逆转了之前的过程

00:23:27.674 --> 00:23:30.677 align:middle line:0
重新组装视频帧并将其发送到显示器

00:23:30.744 --> 00:23:32.246 align:middle line:0
以便我们能在屏幕上看到它们

00:23:34.047 --> 00:23:37.284 align:middle line:0
为了简单起见
我们已经抽象出了相机

00:23:37.351 --> 00:23:38.719 align:middle line:0
和显示功能

00:23:38.886 --> 00:23:42.089 align:middle line:0
这样我们就可以专注于使用
Network.framework的部分

00:23:43.524 --> 00:23:45.492 align:middle line:0
这里有一个我们尚未涉及的内容

00:23:45.626 --> 00:23:46.593 align:middle line:0
它就是监听器

00:23:46.727 --> 00:23:48.395 align:middle line:0
所以我们现在花点时间来了解它

00:23:50.230 --> 00:23:53.534 align:middle line:-2
监听器功能
由NWListener类提供

00:23:53.901 --> 00:23:56.537 align:middle line:-1
你可以使用与你用于配置连接的

00:23:56.703 --> 00:23:58.472 align:middle line:-1
相同的参数对象来创建它

00:23:59.706 --> 00:24:03.810 align:middle line:-2
设置一个监听器来发布
一项Bonjour服务非常简单

00:23:59.706 --> 00:24:03.810 align:middle line:-2
设置一个监听器来发布
一项Bonjour服务非常简单

00:24:04.044 --> 00:24:06.446 align:middle line:-2
在这个例子中
我们将使用_camera._udp

00:24:08.949 --> 00:24:11.485 align:middle line:-1
当监听器收到新连接时

00:24:11.618 --> 00:24:14.087 align:middle line:-1
它会将该连接传递给你提供的

00:24:14.254 --> 00:24:15.622 align:middle line:-1
newConnectionHandler块中

00:24:16.423 --> 00:24:19.693 align:middle line:-1
这是你执行针对该连接的

00:24:19.760 --> 00:24:20.727 align:middle line:-1
所选配置的机会

00:24:20.961 --> 00:24:22.429 align:middle line:-1
然后你需要调用start()

00:24:22.496 --> 00:24:24.998 align:middle line:-1
来让这个连接知道是时候开始了

00:24:26.800 --> 00:24:29.169 align:middle line:-2
同样你也需在你的监听器上
调用start()

00:24:29.336 --> 00:24:31.071 align:middle line:-1
也像连接一样

00:24:31.205 --> 00:24:32.472 align:middle line:-1
你需要提供一个调度队列

00:24:32.539 --> 00:24:34.341 align:middle line:-1
即你希望在哪里调度这些回调

00:24:35.809 --> 00:24:36.777 align:middle line:-1
这就是监听器

00:24:36.977 --> 00:24:38.879 align:middle line:-1
如果你仔细想想 我们刚实现了

00:24:38.946 --> 00:24:41.915 align:middle line:-2
相当于在UDP套接字上
调用listen()的效果

00:24:42.850 --> 00:24:45.919 align:middle line:-2
除了listen()
无法在UDP套接字上工作

00:24:47.387 --> 00:24:49.556 align:middle line:-2
我们已准备好在Xcode中
构建app了

00:24:50.524 --> 00:24:52.092 align:middle line:-1
这是我们的app

00:24:52.492 --> 00:24:54.228 align:middle line:-1
我们这里有一堆文件

00:24:54.394 --> 00:24:57.164 align:middle line:-1
它们已经处理了相机和显示功能

00:24:57.664 --> 00:25:00.400 align:middle line:-2
所以我们将只关注
UDPClient类

00:24:57.664 --> 00:25:00.400 align:middle line:-2
所以我们将只关注
UDPClient类

00:25:00.734 --> 00:25:02.269 align:middle line:-1
和UDPServer类

00:25:03.103 --> 00:25:04.304 align:middle line:-1
UDPClient

00:25:04.438 --> 00:25:07.641 align:middle line:-1
将负责创建与另一端的连接

00:25:07.708 --> 00:25:09.243 align:middle line:-1
并发送帧

00:25:10.177 --> 00:25:13.313 align:middle line:-1
同样的 服务器负责创建监听器

00:25:13.814 --> 00:25:15.349 align:middle line:-1
接受传入的连接

00:25:15.782 --> 00:25:17.351 align:middle line:-1
从该连接中读取数据

00:25:17.518 --> 00:25:18.785 align:middle line:-1
并将其发送到屏幕

00:25:19.620 --> 00:25:20.687 align:middle line:-1
让我们从客户端开始

00:25:22.422 --> 00:25:25.626 align:middle line:-2
我的客户端类有个接收一个名字的
初始化函数

00:25:25.926 --> 00:25:28.629 align:middle line:-1
它是描述我们要连接的

00:25:28.695 --> 00:25:29.963 align:middle line:-1
Bonjour服务名称的字符串

00:25:31.598 --> 00:25:32.799 align:middle line:-2
我通过调用
NWConnection

00:25:33.634 --> 00:25:35.369 align:middle line:-1
并传入服务端点

00:25:35.769 --> 00:25:37.471 align:middle line:-1
来创建我的连接

00:25:38.005 --> 00:25:39.706 align:middle line:-1
使用提供给我的名称

00:25:40.207 --> 00:25:42.242 align:middle line:-2
并将_camera._udp
作为类型

00:25:43.644 --> 00:25:45.979 align:middle line:-1
我们还传递了默认的UDP参数

00:25:47.714 --> 00:25:50.584 align:middle line:-2
正如Tommy所说我们可以使用
stateUpdateHandler

00:25:52.286 --> 00:25:55.155 align:middle line:-1
来检查就绪状态和失败状态

00:25:55.989 --> 00:25:59.726 align:middle line:-2
这里 当我们的连接就绪
我们将调用sendInitialFrame()

00:26:00.027 --> 00:26:01.361 align:middle line:-1
我们稍后再实现它

00:26:02.596 --> 00:26:05.566 align:middle line:-2
因为我们使用的是UDP
并且没有其它握手过程

00:26:05.866 --> 00:26:08.936 align:middle line:-1
我们将一些数据通过网络发送到

00:26:09.536 --> 00:26:10.504 align:middle line:-1
其它设备

00:26:10.838 --> 00:26:12.372 align:middle line:-1
并在我们开始生成大量视频帧

00:26:12.506 --> 00:26:14.541 align:middle line:-1
并将其放到网络中之前

00:26:14.608 --> 00:26:15.909 align:middle line:-1
等待它的回应

00:26:19.413 --> 00:26:22.082 align:middle line:-2
我们需要记住在我们的连接上
调用start()

00:26:22.316 --> 00:26:24.351 align:middle line:-1
并且传入上面创建的队列

00:26:26.153 --> 00:26:27.688 align:middle line:-2
让我们实现
sendInitialFrame()

00:26:32.392 --> 00:26:34.962 align:middle line:-2
这里我们使用
文字字节“hello”

00:26:35.229 --> 00:26:37.097 align:middle line:-1
创建一个数据对象

00:26:38.065 --> 00:26:39.766 align:middle line:-1
要在连接上发送内容

00:26:40.133 --> 00:26:41.768 align:middle line:-2
我们可以调用
connection.send()

00:26:41.969 --> 00:26:44.671 align:middle line:-1
并提供该数据对象作为内容

00:26:45.772 --> 00:26:49.243 align:middle line:-2
我们提供了一个完成处理程序
以便检查发送过程中

00:26:49.409 --> 00:26:51.211 align:middle line:-1
可能遇到的错误

00:26:53.113 --> 00:26:55.816 align:middle line:-2
由于我们预期该内容可以
立即得到回应

00:26:55.883 --> 00:26:58.285 align:middle line:-2
我们马上调用
connection.receive()

00:26:58.485 --> 00:27:00.754 align:middle line:-1
来从连接中读取传入的数据

00:26:58.485 --> 00:27:00.754 align:middle line:-1
来从连接中读取传入的数据

00:27:01.455 --> 00:27:04.525 align:middle line:-2
在该完成处理程序中
我们验证该内容是否存在

00:27:04.825 --> 00:27:07.427 align:middle line:-2
如果存在
我们让app的其它部分知道

00:27:07.561 --> 00:27:08.529 align:middle line:-1
我们已经连接上了

00:27:08.595 --> 00:27:10.197 align:middle line:-1
它应该调出相机硬件

00:27:10.264 --> 00:27:11.632 align:middle line:-1
并开始生成帧

00:27:13.934 --> 00:27:15.269 align:middle line:-1
生成这些帧时

00:27:15.536 --> 00:27:19.306 align:middle line:-2
app的其余部分知道
在UDPClient类上调用send()

00:27:22.709 --> 00:27:26.046 align:middle line:-2
并向其传递一个表示
我们想要发送的视频帧的

00:27:26.113 --> 00:27:27.181 align:middle line:-1
数据对象数组

00:27:29.016 --> 00:27:30.951 align:middle line:-1
由于我们要在很短的时间内

00:27:31.018 --> 00:27:34.154 align:middle line:-2
进行大量发送操作
我们将在一个我们传入

00:27:34.221 --> 00:27:36.056 align:middle line:-2
connection.batch
的块内做这件事

00:27:37.591 --> 00:27:40.194 align:middle line:-2
在这个块中 我们将遍历该
数据对象数组的每一帧

00:27:40.627 --> 00:27:45.299 align:middle line:-2
并将每个数据对象都传递给
connection.send()

00:27:45.766 --> 00:27:46.967 align:middle line:-1
与上面类似

00:27:47.301 --> 00:27:49.536 align:middle line:-1
我们使用完成处理程序来检查

00:27:49.670 --> 00:27:50.971 align:middle line:-1
发送时遇到的任何错误

00:27:51.939 --> 00:27:52.773 align:middle line:-1
就是这样

00:27:53.106 --> 00:27:55.709 align:middle line:-2
我们已经有了UDPClient类
并且我们已经准备好了

00:27:57.678 --> 00:27:58.679 align:middle line:-1
让我们来看看服务器

00:27:59.780 --> 00:28:01.982 align:middle line:-1
在服务器端 我们需要一个监听器

00:27:59.780 --> 00:28:01.982 align:middle line:-1
在服务器端 我们需要一个监听器

00:28:02.182 --> 00:28:03.817 align:middle line:-1
它可以接收传入的连接

00:28:04.151 --> 00:28:06.987 align:middle line:-2
我们需要回应
我们刚从客户端发出的握手请求

00:28:07.287 --> 00:28:10.557 align:middle line:-2
我们需要从网络上读取数据
以便我们可以将其推送到显示器

00:28:11.225 --> 00:28:12.492 align:middle line:-1
从监听器开始

00:28:16.196 --> 00:28:19.800 align:middle line:-2
我们只是使用默认的UDP参数
创建一个NWListener

00:28:21.134 --> 00:28:23.203 align:middle line:-1
如果我愿意的话 这也是

00:28:23.270 --> 00:28:25.205 align:middle line:-1
使用这些参数告诉监听器

00:28:25.272 --> 00:28:27.007 align:middle line:-1
监听特定的本地端口的时机

00:28:27.274 --> 00:28:29.977 align:middle line:-2
但由于我们用Bonjour服务
我们不需要这样做

00:28:33.514 --> 00:28:34.715 align:middle line:-1
为了设置该服务

00:28:34.948 --> 00:28:37.217 align:middle line:-2
我将listener的
服务属性设置为

00:28:38.185 --> 00:28:40.554 align:middle line:-2
_camera._udp类型的
服务对象

00:28:41.121 --> 00:28:42.789 align:middle line:-1
注意我没有在此处传递名称

00:28:43.090 --> 00:28:46.326 align:middle line:-2
因为我希望系统为我提供
默认的设备名称

00:28:47.661 --> 00:28:49.296 align:middle line:-2
我还为serviceRegistration
UpdateHandler

00:28:49.363 --> 00:28:51.498 align:middle line:-1
提供了一个块

00:28:52.065 --> 00:28:53.901 align:middle line:-1
它将在系统发布的

00:28:53.967 --> 00:28:57.204 align:middle line:-1
端点集发生改变时被调用

00:28:57.905 --> 00:29:00.641 align:middle line:-1
这里 我对添加端点的情况感兴趣

00:28:57.905 --> 00:29:00.641 align:middle line:-1
这里 我对添加端点的情况感兴趣

00:29:00.974 --> 00:29:02.776 align:middle line:-1
如果它是服务类型

00:29:03.010 --> 00:29:06.446 align:middle line:-2
我将告诉app的其余部分
它所发布的名称

00:29:06.513 --> 00:29:09.116 align:middle line:-1
即我要求系统提供的默认设备名称

00:29:09.183 --> 00:29:10.851 align:middle line:-1
以便我可以在UI中显示它

00:29:10.984 --> 00:29:12.753 align:middle line:-1
并让我的用户在其它地方输入它

00:29:19.960 --> 00:29:22.729 align:middle line:-2
我要在监听器上设置一个新的
连接处理程序

00:29:22.963 --> 00:29:24.431 align:middle line:-1
它在每次监听器收到新的

00:29:24.498 --> 00:29:26.099 align:middle line:-1
传入连接时都会被调用

00:29:27.534 --> 00:29:29.603 align:middle line:-1
我可以对这些连接进行一些配置

00:29:29.736 --> 00:29:31.238 align:middle line:-1
但这里使用默认配置就够了

00:29:31.305 --> 00:29:33.974 align:middle line:-2
因此我只需调用connection.start()
并传入一个队列

00:29:36.376 --> 00:29:40.581 align:middle line:-2
我在这里通知app的其余部分
我已收到传入连接

00:29:40.781 --> 00:29:42.850 align:middle line:-1
以便它可以开始预热显示管道

00:29:42.983 --> 00:29:45.252 align:middle line:-1
并准备好显示视频帧

00:29:46.320 --> 00:29:49.723 align:middle line:-2
我也会调用自身receive()
我稍后再实现它

00:29:49.857 --> 00:29:51.725 align:middle line:-1
来开始从网络中读取该数据

00:29:51.792 --> 00:29:53.427 align:middle line:-1
并将其发送到显示管道

00:29:55.596 --> 00:29:57.664 align:middle line:-1
就像连接一样 监听器也有

00:30:00.934 --> 00:30:02.302 align:middle line:-1
stateUpdateHandler

00:30:02.369 --> 00:30:05.172 align:middle line:-1
我将用它来检查就绪状态和失败状态

00:30:07.474 --> 00:30:09.409 align:middle line:-1
别忘了启动我的监听器

00:30:09.943 --> 00:30:11.712 align:middle line:-2
为此我调用
listener.start()

00:30:11.912 --> 00:30:13.847 align:middle line:-1
并传入我们在上面创建的队列

00:30:15.716 --> 00:30:18.919 align:middle line:-2
现在我准备好了监听器
我只需要从网络上读取数据

00:30:19.186 --> 00:30:20.654 align:middle line:-1
并实现该receive函数

00:30:24.858 --> 00:30:27.261 align:middle line:-2
我们在这里首先调用
connection.receive()

00:30:27.461 --> 00:30:29.096 align:middle line:-1
并传入完成处理程序

00:30:29.563 --> 00:30:31.365 align:middle line:-1
当数据进入该连接时

00:30:31.765 --> 00:30:33.333 align:middle line:-1
我们将检查我们是否尚未连接

00:30:33.867 --> 00:30:35.035 align:middle line:-1
如果我们没有连接

00:30:35.169 --> 00:30:38.539 align:middle line:-2
这可能是客户端通过发送
所启动的握手过程

00:30:40.240 --> 00:30:42.809 align:middle line:-2
我们只需调用
connection.send()

00:30:43.177 --> 00:30:47.047 align:middle line:-2
并将相同的内容传回去
以便它回显给客户端

00:30:47.581 --> 00:30:49.049 align:middle line:-1
然后我们记录下连接已经建立

00:30:49.283 --> 00:30:51.952 align:middle line:-2
在此后的
所有receive()回调中

00:30:52.186 --> 00:30:54.521 align:middle line:-1
我们将告诉app的其余部分

00:30:54.688 --> 00:30:56.456 align:middle line:-1
我们收到了这个帧

00:30:56.657 --> 00:30:58.559 align:middle line:-1
它应该将其发送到显示管道

00:30:58.825 --> 00:31:00.227 align:middle line:-1
以便我们能在屏幕上看到它

00:30:58.825 --> 00:31:00.227 align:middle line:-1
以便我们能在屏幕上看到它

00:31:01.862 --> 00:31:05.098 align:middle line:-2
最后 如果没有错误
我们再次调用receive()

00:31:05.299 --> 00:31:08.569 align:middle line:-2
以便我们接收后续帧
并将其发送到显示器

00:31:08.635 --> 00:31:11.672 align:middle line:-1
并将这些独立的图像拼接成视频

00:31:13.307 --> 00:31:15.042 align:middle line:-2
就是这样
我们有了UDPClient

00:31:15.342 --> 00:31:17.878 align:middle line:-2
也有了UDPServer
让我们试一试

00:31:20.480 --> 00:31:23.116 align:middle line:-1
我将在我的手机上运行客户端

00:31:23.383 --> 00:31:26.954 align:middle line:-2
并在Mac上运行服务器
以便我们可以在大屏幕上看到它

00:31:28.288 --> 00:31:29.756 align:middle line:-1
这里 服务器刚刚启动

00:31:30.290 --> 00:31:32.993 align:middle line:-2
我们看到它正作为
Demo Mac进行公布

00:31:33.393 --> 00:31:35.529 align:middle line:-1
这是我让系统其余部分

00:31:35.929 --> 00:31:37.331 align:middle line:-1
给我这个名称的地方

00:31:38.098 --> 00:31:39.199 align:middle line:-1
在我的手机上

00:31:39.266 --> 00:31:40.167 align:middle line:-1
如果我点击连接

00:31:41.201 --> 00:31:42.135 align:middle line:-1
一瞬间

00:31:42.336 --> 00:31:47.007 align:middle line:-2
我就可以通过UDP Live看到
通过网络流式传输的视频帧

00:31:58.252 --> 00:32:02.890 align:middle line:-2
我们刚才看到了我能够多么快地
启动一个UDPClient

00:31:58.252 --> 00:32:02.890 align:middle line:-2
我们刚才看到了我能够多么快地
启动一个UDPClient

00:32:02.956 --> 00:32:04.825 align:middle line:-1
并连接到Bonjour服务

00:32:05.792 --> 00:32:07.327 align:middle line:-1
它可以发送握手

00:32:07.661 --> 00:32:09.096 align:middle line:-1
等待其被处理

00:32:09.830 --> 00:32:11.532 align:middle line:-1
获取来自相机的视频帧

00:32:11.598 --> 00:32:12.966 align:middle line:-1
并通过网络发送它们

00:32:14.334 --> 00:32:18.672 align:middle line:-2
服务器端启动了
一个Bonjour监听器

00:32:18.972 --> 00:32:22.276 align:middle line:-2
它公布了一项服务
并接收传入的连接

00:32:22.342 --> 00:32:23.510 align:middle line:-1
然后对握手进行回应

00:32:23.677 --> 00:32:26.280 align:middle line:-2
并将它们全部发送到显示器
以便我们可以看到它们

00:32:27.147 --> 00:32:29.616 align:middle line:-1
现在为了更详细的介绍

00:32:29.683 --> 00:32:30.817 align:middle line:-1
优化该数据传输过程

00:32:30.884 --> 00:32:32.686 align:middle line:-1
我想邀请Tommy回到舞台上

00:32:38.859 --> 00:32:40.027 align:middle line:-1
谢谢 Eric

00:32:40.994 --> 00:32:42.129 align:middle line:-1
这是一个非常酷的演示

00:32:42.196 --> 00:32:45.432 align:middle line:-2
它很容易实现
现在我们已经介绍了基础知识

00:32:45.499 --> 00:32:48.001 align:middle line:-1
我们知道如何建立出站连接

00:32:48.068 --> 00:32:49.937 align:middle line:-1
如何接收入站连接

00:32:50.604 --> 00:32:53.240 align:middle line:-2
但Network.framework的
真正关键部分

00:32:53.307 --> 00:32:54.708 align:middle line:-1
也是这里的杀手级特性

00:32:54.775 --> 00:32:57.644 align:middle line:-1
是其优化性能的方式

00:32:57.711 --> 00:33:00.280 align:middle line:-1
我们将超越套接字所能够做的事情

00:32:57.711 --> 00:33:00.280 align:middle line:-1
我们将超越套接字所能够做的事情

00:33:01.548 --> 00:33:04.985 align:middle line:-2
我想先谈谈
你在app中与网络连接

00:33:05.052 --> 00:33:07.154 align:middle line:-1
进行交互的

00:33:07.621 --> 00:33:08.989 align:middle line:-1
最基本的方式

00:33:09.590 --> 00:33:11.692 align:middle line:-1
即发送和接收数据

00:33:12.659 --> 00:33:14.828 align:middle line:-1
这些调用非常简单

00:33:15.162 --> 00:33:18.465 align:middle line:-2
但是关于你如何处理
发送和接收的细微差别

00:33:18.665 --> 00:33:22.536 align:middle line:-1
将对app的响应能力

00:33:22.603 --> 00:33:26.473 align:middle line:-2
以及设备和网络上正在进行多少缓冲
有着巨大影响

00:33:27.808 --> 00:33:29.710 align:middle line:-1
所以我想介绍的第一个例子

00:33:29.977 --> 00:33:31.445 align:middle line:-1
是当我们在app中

00:33:31.845 --> 00:33:32.679 align:middle line:-1
发送数据时

00:33:32.746 --> 00:33:34.848 align:middle line:-1
就像Eric刚向你展示的那样

00:33:35.182 --> 00:33:36.350 align:middle line:-1
一些正在直播的东西

00:33:36.416 --> 00:33:38.819 align:middle line:-1
一些动态生成数据的东西

00:33:39.620 --> 00:33:43.557 align:middle line:-2
但在这个例子中 让我们谈谈
使用TCP流来发送的情况

00:33:43.857 --> 00:33:46.293 align:middle line:-1
即可以在网络上恢复的TCP流

00:33:46.493 --> 00:33:48.395 align:middle line:-1
它具有可以发送的特定时间窗口

00:33:48.529 --> 00:33:49.830 align:middle line:-1
我们该如何处理该情况呢

00:33:51.598 --> 00:33:54.368 align:middle line:-1
这是一个发送单帧的函数

00:33:54.434 --> 00:33:57.871 align:middle line:-1
这是你的app生成的某些数据帧

00:33:59.439 --> 00:34:01.074 align:middle line:-1
你在连接上发送它的方式

00:33:59.439 --> 00:34:01.074 align:middle line:-1
你在连接上发送它的方式

00:34:01.141 --> 00:34:03.477 align:middle line:-2
是通过调用
connection.send()

00:34:03.544 --> 00:34:04.811 align:middle line:-1
并传入该数据

00:34:05.712 --> 00:34:10.217 align:middle line:-2
如果你习惯在连接上
使用套接字发送数据

00:34:10.851 --> 00:34:13.020 align:middle line:-1
你要么使用阻塞套接字

00:34:13.085 --> 00:34:14.755 align:middle line:-1
在这种情况下

00:34:15.121 --> 00:34:16.889 align:middle line:-1
如果你要发送100个字节的数据

00:34:17.224 --> 00:34:20.960 align:middle line:-2
如果发送缓冲区中没有空间
它实际上会阻塞你的线程

00:34:21.027 --> 00:34:23.830 align:middle line:-1
并等待网络连接消耗掉这些数据

00:34:25.065 --> 00:34:27.701 align:middle line:-1
或者 如果你使用的是非阻塞套接字

00:34:28.869 --> 00:34:31.772 align:middle line:-2
该发送过程实际上可能
不会发送你的全部数据

00:34:31.839 --> 00:34:33.639 align:middle line:-2
它会说
“哦 我先只发送50个字节

00:34:33.706 --> 00:34:35.909 align:middle line:-1
过一段时间再发送剩下的50字节”

00:34:36.443 --> 00:34:39.346 align:middle line:-1
这要求你和你的app需要处理很多

00:34:39.612 --> 00:34:42.783 align:middle line:-1
关于你实际发送了多少数据的状态

00:34:44.484 --> 00:34:46.085 align:middle line:-2
所以NWConnection
的好处在于

00:34:46.152 --> 00:34:48.388 align:middle line:-1
你可以一次发送所有数据

00:34:48.455 --> 00:34:49.822 align:middle line:-1
你不必担心这些问题

00:34:50.524 --> 00:34:51.992 align:middle line:-1
并且它不会阻塞任何东西

00:34:53.025 --> 00:34:54.795 align:middle line:-1
然而你必须处理

00:34:55.195 --> 00:34:57.164 align:middle line:-1
如果连接正在恢复该怎么办

00:34:57.231 --> 00:35:00.634 align:middle line:-2
因为我们不想不必要地
将大量数据

00:34:57.231 --> 00:35:00.634 align:middle line:-2
因为我们不想不必要地
将大量数据

00:35:00.701 --> 00:35:01.735 align:middle line:-1
发送到此连接

00:35:01.802 --> 00:35:05.138 align:middle line:-2
如果你想要一个响应性强的
实时数据流的话

00:35:06.240 --> 00:35:07.274 align:middle line:-1
这里的关键

00:35:07.741 --> 00:35:09.543 align:middle line:-1
是我们提供给你的回调块

00:35:10.244 --> 00:35:12.179 align:middle line:-2
它被称为
contentProcessed

00:35:12.679 --> 00:35:17.050 align:middle line:-2
每当网络栈消耗你的数据时
我们都会调用它

00:35:17.551 --> 00:35:20.254 align:middle line:-1
这并不意味着必须发送数据

00:35:20.320 --> 00:35:21.822 align:middle line:-1
或另一方进行确认

00:35:22.055 --> 00:35:25.959 align:middle line:-1
它完全等同于阻塞套接字的调用

00:35:26.026 --> 00:35:27.127 align:middle line:-1
返回的情况

00:35:27.461 --> 00:35:30.998 align:middle line:-2
或非阻塞套接字
能够消耗你发送的

00:35:31.064 --> 00:35:31.965 align:middle line:-1
所有字节的情况

00:35:33.333 --> 00:35:36.737 align:middle line:-2
在此完成处理程序中
你可以检查两件事

00:35:37.471 --> 00:35:38.305 align:middle line:-1
首先

00:35:38.372 --> 00:35:39.506 align:middle line:-1
你可以检查错误

00:35:39.907 --> 00:35:40.774 align:middle line:-1
如果有错误

00:35:40.841 --> 00:35:43.277 align:middle line:-2
这意味着在我们尝试发送你的数据时
出现了问题

00:35:43.610 --> 00:35:46.346 align:middle line:-1
这通常表示整体连接失败

00:35:47.948 --> 00:35:51.919 align:middle line:-2
然后 如果没有错误
这是一个绝佳的机会

00:35:52.152 --> 00:35:55.956 align:middle line:-2
来查看你的app中
是否有更多数据要生成

00:35:56.023 --> 00:35:58.892 align:middle line:-1
所以如果你正在生成实时数据帧

00:35:59.593 --> 00:36:01.562 align:middle line:-2
你应该发送它并从视频流中
获取另一帧

00:35:59.593 --> 00:36:01.562 align:middle line:-2
你应该发送它并从视频流中
获取另一帧

00:36:01.628 --> 00:36:03.630 align:middle line:-1
因为现在正是你将下一个数据包

00:36:03.697 --> 00:36:04.631 align:middle line:-1
放入队列的时机

00:36:04.965 --> 00:36:07.901 align:middle line:-1
这使你可以一步一步地发送所有数据

00:36:08.702 --> 00:36:11.305 align:middle line:-2
正如你在这里看到的
我们实际上使用此异步发送回调

00:36:11.605 --> 00:36:16.677 align:middle line:-2
形成了一个循环
从而持续从我们的连接中消耗数据

00:36:16.743 --> 00:36:19.813 align:middle line:-1
并非常优雅地处理它

00:36:22.516 --> 00:36:24.818 align:middle line:-1
关于发送我想指出的另一件事

00:36:25.252 --> 00:36:29.156 align:middle line:-2
是Eric之前展示的
对UDP app很有效的技巧

00:36:29.223 --> 00:36:32.659 align:middle line:-1
这类app需要一次发送多个数据报

00:36:33.861 --> 00:36:36.263 align:middle line:-1
如果你需要发送一大堆很小的数据

00:36:36.330 --> 00:36:38.999 align:middle line:-1
或独立数据包

00:36:40.100 --> 00:36:43.370 align:middle line:-2
你可以使用我们添加的
称为connection.batch的东西

00:36:43.604 --> 00:36:48.008 align:middle line:-2
UDP套接字以前一次只能发送
一个数据包

00:36:48.542 --> 00:36:50.043 align:middle line:-1
这可能效率很低

00:36:50.110 --> 00:36:52.880 align:middle line:-2
因为如果我需要发送
100个UDP数据包

00:36:53.146 --> 00:36:56.116 align:middle line:-2
它们每个都是不同的系统调用
不同的副本

00:36:56.183 --> 00:36:57.918 align:middle line:-1
并且导致内核中大量的上下文切换

00:36:59.186 --> 00:37:01.989 align:middle line:-1
但如果你在那个块中调用batch

00:36:59.186 --> 00:37:01.989 align:middle line:-1
但如果你在那个块中调用batch

00:37:02.289 --> 00:37:05.759 align:middle line:-2
你想调用send或receive
多少次都可以

00:37:05.893 --> 00:37:08.996 align:middle line:-1
并且连接将停止处理任何数据

00:37:09.630 --> 00:37:11.698 align:middle line:-1
直到你完成此batch块

00:37:11.865 --> 00:37:13.967 align:middle line:-1
并尝试将所有这些数据报

00:37:14.034 --> 00:37:17.371 align:middle line:-1
作为单个批次传入系统

00:37:17.604 --> 00:37:21.241 align:middle line:-2
理想情况下
只有一个上下文切换到内核中

00:37:21.308 --> 00:37:22.743 align:middle line:-1
并最终从接口发送出去

00:37:23.043 --> 00:37:25.345 align:middle line:-1
这使你非常非常有效率

00:37:27.414 --> 00:37:28.315 align:middle line:-1
以上就是发送

00:37:28.715 --> 00:37:32.152 align:middle line:-1
接收与发送一样是异步的

00:37:32.352 --> 00:37:35.088 align:middle line:-1
而异步性质则会给你

00:37:35.155 --> 00:37:36.523 align:middle line:-1
能够让你调整app的背压

00:37:38.492 --> 00:37:42.196 align:middle line:-2
在这个例子中
我有一个基于TCP的协议

00:37:42.763 --> 00:37:45.299 align:middle line:-1
并且app想要读取某种类型的

00:37:45.699 --> 00:37:49.203 align:middle line:-1
记录格式非常常见

00:37:50.571 --> 00:37:54.508 align:middle line:-1
假设你的协议有一个10字节的头部

00:37:54.708 --> 00:37:57.177 align:middle line:-2
它告诉你有关你将要收到的
内容的一些信息

00:37:57.311 --> 00:37:59.513 align:middle line:-1
比如你将要接收的主体长度

00:38:00.547 --> 00:38:03.984 align:middle line:-2
因此你想首先读取该头部
然后读取你的其它内容

00:38:04.251 --> 00:38:05.586 align:middle line:-1
也许你的内容很长

00:38:05.652 --> 00:38:07.754 align:middle line:-1
假设有几兆字节

00:38:08.956 --> 00:38:12.159 align:middle line:-2
使用传统的套接字时
你可能会尝试读取10个字节

00:38:12.626 --> 00:38:14.428 align:middle line:-1
你可能得到10个字节或更少

00:38:14.494 --> 00:38:16.463 align:middle line:-2
你须继续读取
直到获得正好10个字节

00:38:16.530 --> 00:38:17.364 align:middle line:-1
从而读取头部信息

00:38:17.965 --> 00:38:20.167 align:middle line:-1
然后你还要读取几兆字节

00:38:20.534 --> 00:38:21.435 align:middle line:-1
你会读取一些数据

00:38:21.502 --> 00:38:23.136 align:middle line:-1
进行一大堆不同的read调用

00:38:23.203 --> 00:38:26.607 align:middle line:-2
并且需要在你的app
和堆栈之间来回切换

00:38:28.575 --> 00:38:31.612 align:middle line:-2
使用NWConnection的情况下
当你调用receive()时

00:38:32.212 --> 00:38:35.682 align:middle line:-1
你可以提供你想要接收的最小数据

00:38:35.749 --> 00:38:36.950 align:middle line:-1
和最大数据

00:38:37.618 --> 00:38:40.687 align:middle line:-2
所以你实际上可以指定
如果你想要接收正好10字节的话

00:38:40.754 --> 00:38:42.689 align:middle line:-2
因为那是你的协议所规定的
你可以说

00:38:43.090 --> 00:38:45.392 align:middle line:-2
“我想要最小10字节
最大10字节

00:38:45.459 --> 00:38:46.793 align:middle line:-1
即给我正好10个字节”

00:38:47.194 --> 00:38:48.829 align:middle line:-1
而我们只会在以下情况发生时

00:38:49.162 --> 00:38:52.466 align:middle line:-2
才对你进行回调
即要么从连接读取数据发生错误

00:38:52.799 --> 00:38:55.035 align:middle line:-1
要么我们正好读了10个字节

00:38:55.502 --> 00:38:57.971 align:middle line:-1
然后你就可以读取

00:38:58.038 --> 00:39:00.674 align:middle line:-1
头部中你需要的内容 比如长度

00:38:58.038 --> 00:39:00.674 align:middle line:-1
头部中你需要的内容 比如长度

00:39:01.241 --> 00:39:02.876 align:middle line:-1
然后假设你想继续读取

00:39:03.377 --> 00:39:04.545 align:middle line:-1
几兆字节

00:39:04.611 --> 00:39:07.247 align:middle line:-2
你基本上只需做同样的事情
来读取你的主体

00:39:07.814 --> 00:39:08.916 align:middle line:-1
你只需传入

00:39:08.982 --> 00:39:11.885 align:middle line:-1
你想要从连接中读取的数量

00:39:11.952 --> 00:39:13.587 align:middle line:-1
这可以让你不必

00:39:13.654 --> 00:39:15.088 align:middle line:-1
在堆和app之间来回切换

00:39:15.222 --> 00:39:18.325 align:middle line:-2
这是通过在所有数据准备好时
只进行一次回调来做到的

00:39:19.626 --> 00:39:22.963 align:middle line:-1
所以这是一种优化交互的好方法

00:39:24.598 --> 00:39:25.899 align:middle line:-1
除了发送和接收

00:39:26.300 --> 00:39:28.168 align:middle line:-1
我还想强调一下

00:39:28.235 --> 00:39:29.369 align:middle line:-1
你的网络参数中的

00:39:30.070 --> 00:39:31.271 align:middle line:-1
几个高级选项

00:39:31.338 --> 00:39:33.507 align:middle line:-1
它们允许你配置连接

00:39:33.740 --> 00:39:36.176 align:middle line:-1
从而当你实际发送和接收数据时

00:39:36.443 --> 00:39:38.579 align:middle line:-1
具有合适的启动时间

00:39:38.645 --> 00:39:40.147 align:middle line:-1
以及网络上的行为

00:39:41.114 --> 00:39:42.115 align:middle line:-1
第一个

00:39:42.316 --> 00:39:45.319 align:middle line:-1
是我们在WWDC中多次讨论的内容

00:39:45.652 --> 00:39:46.753 align:middle line:-1
它是ECN

00:39:46.820 --> 00:39:48.822 align:middle line:0
即显式拥塞通知

00:39:49.990 --> 00:39:53.827 align:middle line:0
它为你提供了一种平滑连接的方法

00:39:54.161 --> 00:39:57.965 align:middle line:0
即让终端主机知道

00:39:58.165 --> 00:39:59.733 align:middle line:0
何时发生了网络拥塞

00:39:59.967 --> 00:40:01.635 align:middle line:0
从而使我们可以很好地调整速度

00:39:59.967 --> 00:40:01.635 align:middle line:0
从而使我们可以很好地调整速度

00:40:02.569 --> 00:40:07.274 align:middle line:0
最棒的是默认情况下
所有的TCP连接都会启用ECN

00:40:07.441 --> 00:40:08.675 align:middle line:0
你无需做任何事情

00:40:09.376 --> 00:40:12.846 align:middle line:0
但过去在基于UDP的协议上

00:40:13.213 --> 00:40:15.182 align:middle line:0
使用ECN非常困难

00:40:15.983 --> 00:40:18.285 align:middle line:0
所以我想在这里向你展示
如何做到这一点

00:40:19.686 --> 00:40:23.624 align:middle line:0
你要做的第一件事是
创建一个ipMetadata对象

00:40:23.690 --> 00:40:27.561 align:middle line:0
ECN由IP数据包中的标志控制

00:40:28.028 --> 00:40:29.830 align:middle line:0
所以这个ipMetadata对象

00:40:29.897 --> 00:40:33.333 align:middle line:0
允许你在每个数据包上设置各种标志

00:40:34.201 --> 00:40:37.037 align:middle line:0
并且你可以把它包装成
一个context对象

00:40:37.204 --> 00:40:40.407 align:middle line:0
它描述了你想与某次send调用

00:40:40.574 --> 00:40:42.476 align:middle line:0
相关联的若干协议的所有选项

00:40:42.976 --> 00:40:46.947 align:middle line:0
以及该特定消息的相对优先级

00:40:48.115 --> 00:40:51.451 align:middle line:0
然后使用
此context作为额外参数

00:40:51.518 --> 00:40:52.619 align:middle line:0
传入send调用中

00:40:53.120 --> 00:40:55.222 align:middle line:0
就在你的content参数后面

00:40:55.956 --> 00:40:57.224 align:middle line:0
所以现在当你发送它时

00:40:57.424 --> 00:41:00.360 align:middle line:0
由此内容生成的任何数据包

00:40:57.424 --> 00:41:00.360 align:middle line:0
由此内容生成的任何数据包

00:41:00.427 --> 00:41:02.996 align:middle line:0
都将包含你想要标记的所有标志

00:41:03.197 --> 00:41:04.198 align:middle line:0
所以这很容易

00:41:05.265 --> 00:41:07.367 align:middle line:0
而且你也可以在收到连接时

00:41:07.434 --> 00:41:09.503 align:middle line:0
获取这些相同的标志

00:41:09.570 --> 00:41:12.506 align:middle line:0
你将在收到的数据包中得到
与其关联同样的context对象

00:41:12.739 --> 00:41:15.709 align:middle line:0
你将能够读出你想得到的

00:41:15.776 --> 00:41:16.777 align:middle line:0
特定的低级标志

00:41:19.246 --> 00:41:21.815 align:middle line:0
类似地 我们也有服务类

00:41:22.349 --> 00:41:27.020 align:middle line:0
这是一个在URLSession中
也存在的属性

00:41:27.187 --> 00:41:30.924 align:middle line:0
它定义你的流量的相对优先级

00:41:31.425 --> 00:41:34.328 align:middle line:0
这会影响我们在发送数据时

00:41:34.394 --> 00:41:36.230 align:middle line:0
流量在本地接口上排队的方式

00:41:36.663 --> 00:41:40.033 align:middle line:0
及在Cisco Fastlane
网络上流量的工作方式

00:41:41.435 --> 00:41:45.839 align:middle line:0
你可以通过使用参数对象中的
serviceClass参数

00:41:46.106 --> 00:41:50.677 align:middle line:0
来将服务类标记为整个连接上的属性

00:41:51.378 --> 00:41:55.315 align:middle line:0
在这个例子中 我们展示了
如何使用后台服务类

00:41:55.649 --> 00:41:58.252 align:middle line:0
这是将你的连接标记为

00:41:58.585 --> 00:42:00.187 align:middle line:0
较低优先级的好方法

00:41:58.585 --> 00:42:00.187 align:middle line:0
较低优先级的好方法

00:42:00.254 --> 00:42:03.624 align:middle line:0
我们不希望它妨碍用户交互式数据

00:42:03.957 --> 00:42:06.560 align:middle line:0
所以如果你需要后台数据传输
我们真的很鼓励你

00:42:06.793 --> 00:42:09.096 align:middle line:0
将它们标记为后台服务类

00:42:10.731 --> 00:42:14.401 align:middle line:0
但你也可以对那些UDP连接
在每个数据包的基础上

00:42:14.635 --> 00:42:16.136 align:middle line:0
标记服务类

00:42:16.904 --> 00:42:18.505 align:middle line:0
假设你有一个连接

00:42:18.705 --> 00:42:22.176 align:middle line:0
其中在同一个UDP流上包含

00:42:22.242 --> 00:42:23.810 align:middle line:0
语音和信号数据

00:42:24.878 --> 00:42:28.515 align:middle line:0
在这种情况下
你可以创建我之前介绍的

00:42:28.582 --> 00:42:29.950 align:middle line:0
ipMetadata对象

00:42:30.517 --> 00:42:33.554 align:middle line:0
在这里标记你的服务类
而不是之前的ECN标志

00:42:34.121 --> 00:42:36.223 align:middle line:0
将其附加到context上
然后将其发送出去

00:42:36.456 --> 00:42:39.493 align:middle line:0
这样你就在每个数据包的基础上
标记了优先级

00:42:43.096 --> 00:42:45.098 align:middle line:0
你可以优化连接的另一种方式

00:42:45.866 --> 00:42:49.303 align:middle line:-1
是减少为了建立它们所需的往返次数

00:42:50.103 --> 00:42:52.372 align:middle line:-2
所以在这里我想强调
两种方法来做到这一点

00:42:53.073 --> 00:42:56.109 align:middle line:-1
第一种是在你的连接上启用快速打开

00:42:56.677 --> 00:42:59.680 align:middle line:-1
TCP快速打开允许你

00:42:59.980 --> 00:43:03.517 align:middle line:-2
在TCP发出的第一个数据包中
发送初始数据

00:42:59.980 --> 00:43:03.517 align:middle line:-2
在TCP发出的第一个数据包中
发送初始数据

00:43:03.584 --> 00:43:04.484 align:middle line:-1
即在SYN包中

00:43:04.751 --> 00:43:06.687 align:middle line:-1
这样你就不必等待整个握手过程完成

00:43:06.854 --> 00:43:08.922 align:middle line:-1
才开始发送你的app数据

00:43:10.390 --> 00:43:13.694 align:middle line:-1
为此 你的app

00:43:13.760 --> 00:43:15.729 align:middle line:-1
需要与连接达成协议

00:43:15.929 --> 00:43:19.833 align:middle line:-2
并说明你将提供此初始数据
以发送出去

00:43:20.601 --> 00:43:21.502 align:middle line:-1
为了启用它

00:43:21.568 --> 00:43:24.338 align:middle line:-2
你需要在参数上
标记allowFastOpen

00:43:24.905 --> 00:43:26.440 align:middle line:-1
然后创建连接

00:43:27.341 --> 00:43:29.309 align:middle line:-1
在你调用start()之前

00:43:29.376 --> 00:43:33.814 align:middle line:-2
你实际上可以调用send()
并将你的初始数据发送出去

00:43:35.349 --> 00:43:38.085 align:middle line:-2
现在我想指出
这里的完成处理程序

00:43:38.151 --> 00:43:41.588 align:middle line:-1
被替换为该数据为幂等的标志

00:43:41.655 --> 00:43:44.491 align:middle line:-1
幂等意味着可以安全地重新发送数据

00:43:44.558 --> 00:43:47.594 align:middle line:-2
因为初始数据可能会
通过网络重新发送

00:43:47.794 --> 00:43:50.764 align:middle line:-2
因此如果重新发送的话
你不希望它有任何副作用

00:43:53.033 --> 00:43:54.601 align:middle line:-1
然后你只需调用start()

00:43:54.935 --> 00:43:57.171 align:middle line:-1
当我们正在启动连接时

00:43:57.237 --> 00:43:59.106 align:middle line:-1
我们之前提到过的所有尝试

00:43:59.173 --> 00:44:03.677 align:middle line:-2
如果可以的话 我们将使用
该初始数据在TCP快速打开中发送

00:43:59.173 --> 00:44:03.677 align:middle line:-2
如果可以的话 我们将使用
该初始数据在TCP快速打开中发送

00:44:05.179 --> 00:44:08.849 align:middle line:-2
我还想指出使用TCP快速打开的
另一种方法

00:44:09.082 --> 00:44:12.586 align:middle line:-1
它不要求你的app发送自己的数据

00:44:14.655 --> 00:44:17.357 align:middle line:-1
如果你在TCP之上使用TLS

00:44:17.958 --> 00:44:20.928 align:middle line:-2
来自TLS的第一条消息
即客户端hello

00:44:21.161 --> 00:44:25.098 align:middle line:0
实际上可以用作
TCP快速打开的初始数据

00:44:25.866 --> 00:44:29.937 align:middle line:0
如果你只想启用此功能
而不提供自己的快速打开数据

00:44:31.071 --> 00:44:33.774 align:middle line:0
只需找到针对TCP的选项

00:44:34.241 --> 00:44:36.577 align:middle line:0
并在那里标记你想要
启用快速打开

00:44:37.044 --> 00:44:40.914 align:middle line:0
它会在连接建立期间自动将

00:44:40.981 --> 00:44:43.217 align:middle line:0
来自TLS的第一条消息发送出去

00:44:47.120 --> 00:44:48.355 align:middle line:-1
你还可以做另外一件事

00:44:48.422 --> 00:44:50.290 align:middle line:-1
来优化你的连接建立过程

00:44:50.357 --> 00:44:51.491 align:middle line:-1
并节省一次往返

00:44:51.859 --> 00:44:53.727 align:middle line:-1
这是Stuart

00:44:53.794 --> 00:44:55.095 align:middle line:-1
在前一个演讲中提到的

00:44:55.596 --> 00:44:58.031 align:middle line:-1
我们称之为乐观DNS

00:44:58.665 --> 00:45:02.769 align:middle line:-1
这允许你使用以前过期的DNS回复

00:44:58.665 --> 00:45:02.769 align:middle line:-1
这允许你使用以前过期的DNS回复

00:45:02.903 --> 00:45:05.038 align:middle line:-1
其生存时间可能很短

00:45:06.473 --> 00:45:08.041 align:middle line:-1
并尝试连接到它们

00:45:08.242 --> 00:45:12.646 align:middle line:-2
同时我们并行执行一个
新的DNS查询

00:45:13.614 --> 00:45:14.448 align:middle line:-1
所以…

00:45:14.581 --> 00:45:18.151 align:middle line:-1
如果你之前收到的地址

00:45:18.452 --> 00:45:20.420 align:middle line:-1
虽然过期但却仍然有效

00:45:21.021 --> 00:45:24.358 align:middle line:-2
并且你将expiredDNSBehavior
标记为allow

00:45:24.625 --> 00:45:25.993 align:middle line:-1
当你调用start()时

00:45:26.059 --> 00:45:27.961 align:middle line:-1
我们将首先尝试连接这些地址

00:45:28.028 --> 00:45:31.164 align:middle line:-1
而不必等待新的DNS查询完成

00:45:31.398 --> 00:45:35.035 align:middle line:-1
这可以减少大量的连接建立时间

00:45:35.769 --> 00:45:39.173 align:middle line:-1
但如果你的服务器的确改变了地址

00:45:39.506 --> 00:45:42.309 align:middle line:-2
因为我们正在尝试
多种不同的连接选项

00:45:42.876 --> 00:45:44.378 align:middle line:-1
如果第一个不起作用

00:45:44.511 --> 00:45:46.013 align:middle line:-1
我们会优雅地等待

00:45:46.313 --> 00:45:48.315 align:middle line:-1
新的DNS查询返回

00:45:48.448 --> 00:45:50.617 align:middle line:-1
并再次尝试这些地址

00:45:51.418 --> 00:45:53.053 align:middle line:-1
所以这是一种非常简单的方法

00:45:53.120 --> 00:45:55.722 align:middle line:-1
如果它适合你的服务器配置

00:45:56.089 --> 00:45:58.759 align:middle line:-1
你就可以更快地建立连接

00:46:01.995 --> 00:46:04.331 align:middle line:-1
我想谈的关于性能的下一个领域

00:46:04.398 --> 00:46:07.868 align:middle line:-2
你实际上并不需要在app中
执行任何操作就可以得到

00:46:08.135 --> 00:46:12.673 align:middle line:-2
这是你在使用URLSession
或Network.framework连接时

00:46:12.940 --> 00:46:14.474 align:middle line:-1
自动得到的东西

00:46:15.275 --> 00:46:17.077 align:middle line:-1
这就是用户态网络

00:46:17.644 --> 00:46:21.582 align:middle line:-2
这是我们去年在WWDC上
介绍的内容

00:46:22.182 --> 00:46:25.886 align:middle line:-1
并在iOS和tvOS上都启用了它

00:46:26.286 --> 00:46:28.622 align:middle line:-1
我们在这里完全避开了套接字层

00:46:28.689 --> 00:46:31.825 align:middle line:-1
我们将传输栈移到你的app中

00:46:32.426 --> 00:46:34.528 align:middle line:-1
为了让你知道它是做什么的

00:46:35.062 --> 00:46:36.830 align:middle line:-1
我想先介绍一下通常的

00:46:36.897 --> 00:46:38.632 align:middle line:-1
传统栈模型是什么样的

00:46:40.100 --> 00:46:42.703 align:middle line:0
假设你正在通过网络接收数据包

00:46:42.836 --> 00:46:44.371 align:middle line:0
这里是Wi-Fi接口

00:46:44.805 --> 00:46:46.573 align:middle line:0
该数据包先进入驱动程序

00:46:46.740 --> 00:46:51.345 align:middle line:0
然后被发送到内核中的
TCP接收缓冲区

00:46:52.746 --> 00:46:55.682 align:middle line:0
然后当你的app读取套接字时

00:46:56.083 --> 00:46:59.653 align:middle line:0
将进行一次上下文切换
并将数据从内核复制到

00:46:59.720 --> 00:47:00.621 align:middle line:0
你的app中

00:46:59.720 --> 00:47:00.621 align:middle line:0
你的app中

00:47:01.388 --> 00:47:03.290 align:middle line:0
接着一般情况下如果你使用了TLS

00:47:03.357 --> 00:47:06.293 align:middle line:0
它必须进行另一次转换来解密该数据

00:47:06.493 --> 00:47:08.929 align:middle line:0
然后才能将其发送到app

00:47:10.264 --> 00:47:13.500 align:middle line:0
那么当我们进行用户态网络时
这看起来如何呢？

00:47:16.170 --> 00:47:17.137 align:middle line:0
你可以看到

00:47:17.237 --> 00:47:19.907 align:middle line:0
主要的变化是我们将传输栈

00:47:19.973 --> 00:47:21.208 align:middle line:0
即TCP和UDP

00:47:21.542 --> 00:47:22.709 align:middle line:0
向上移到你的app中

00:47:22.943 --> 00:47:24.278 align:middle line:0
这有什么好处呢？

00:47:24.945 --> 00:47:27.181 align:middle line:0
现在当一个数据包从网络进入时

00:47:27.347 --> 00:47:29.082 align:middle line:0
像以前一样先进入驱动程序

00:47:29.316 --> 00:47:31.852 align:middle line:0
但我们将其移动到一块内存映射区域

00:47:32.219 --> 00:47:33.854 align:middle line:0
你的app可以

00:47:34.354 --> 00:47:36.723 align:middle line:0
自动从中获取这些数据包

00:47:36.924 --> 00:47:39.893 align:middle line:0
不需要复制
也没有做额外的上下文切换

00:47:40.027 --> 00:47:42.429 align:middle line:0
并自动开始处理数据包

00:47:42.729 --> 00:47:44.831 align:middle line:0
这样我们需要做的唯一转换

00:47:44.898 --> 00:47:47.935 align:middle line:0
就是我们为TLS无论如何
都要做的解密

00:47:49.469 --> 00:47:52.439 align:middle line:0
这确实可以减少用于

00:47:52.506 --> 00:47:54.474 align:middle line:-1
发送和接收数据包的CPU时间

00:47:54.975 --> 00:47:57.344 align:middle line:-1
特别是对于UDP这类协议

00:47:57.578 --> 00:48:00.147 align:middle line:-1
你需要直接在你的app中使用它

00:47:57.578 --> 00:48:00.147 align:middle line:-1
你需要直接在你的app中使用它

00:48:00.314 --> 00:48:01.815 align:middle line:-1
来回发送大量数据包

00:48:03.150 --> 00:48:05.419 align:middle line:-2
为了说明这是如何工作的
及它可以产生的效果

00:48:05.652 --> 00:48:07.120 align:middle line:-1
我想给你看一个视频

00:48:07.754 --> 00:48:12.526 align:middle line:-2
它是使用Eric之前向你展示的
那个app拍摄的

00:48:12.793 --> 00:48:15.896 align:middle line:-2
并通过用户态网络
来演示UDP的性能

00:48:17.965 --> 00:48:19.233 align:middle line:-2
在这个例子中
我们将会有

00:48:19.299 --> 00:48:21.301 align:middle line:-1
两个视频同时播放

00:48:22.970 --> 00:48:27.040 align:middle line:-1
左侧的设备正在接收一个视频流

00:48:27.808 --> 00:48:28.642 align:middle line:-1
其来自…

00:48:28.709 --> 00:48:31.011 align:middle line:-1
使用套接字编写的app

00:48:32.079 --> 00:48:33.480 align:middle line:-1
右边的设备

00:48:33.547 --> 00:48:36.016 align:middle line:-1
将接收完全相同的视频流

00:48:37.317 --> 00:48:38.218 align:middle line:-1
其来自一个设备上的

00:48:38.652 --> 00:48:39.553 align:middle line:-1
一个app

00:48:40.120 --> 00:48:41.889 align:middle line:-2
该app使用
Network.framework编写

00:48:41.955 --> 00:48:45.058 align:middle line:-1
因此它可以利用用户态网络栈

00:48:46.927 --> 00:48:48.729 align:middle line:-2
在这个例子中
我们将视频以流式传输

00:48:48.929 --> 00:48:51.465 align:middle line:-1
它只是原始帧 并没有被压缩

00:48:51.532 --> 00:48:52.833 align:middle line:-1
它没很好质量或其它东西

00:48:52.900 --> 00:48:54.801 align:middle line:-1
但是有大量数据包来回传递

00:48:55.702 --> 00:48:58.038 align:middle line:-1
在此演示中 我们不会降低视频质量

00:48:58.572 --> 00:49:02.009 align:middle line:-1
无论是在我们遇到争用时

00:48:58.572 --> 00:49:02.009 align:middle line:-1
无论是在我们遇到争用时

00:49:02.075 --> 00:49:04.244 align:middle line:-2
还是当我们无法足够快的
发送数据包时

00:49:04.511 --> 00:49:05.712 align:middle line:-1
或是不丢弃任何东西时

00:49:05.979 --> 00:49:07.814 align:middle line:-1
而是在必要时放慢速度

00:49:08.148 --> 00:49:10.150 align:middle line:-1
你的app可能在实际中不会这样做

00:49:10.217 --> 00:49:12.586 align:middle line:-1
但它突出了这两种栈之间的

00:49:13.387 --> 00:49:15.656 align:middle line:-1
性能区别

00:49:16.056 --> 00:49:16.990 align:middle line:-1
现在让我们看看吧

00:49:21.895 --> 00:49:23.564 align:middle line:-1
它们使用的数据完全相同

00:49:24.464 --> 00:49:26.099 align:middle line:-1
以它们各自尽可能快的速度

00:49:26.166 --> 00:49:27.334 align:middle line:-1
在网络上

00:49:28.235 --> 00:49:29.236 align:middle line:-1
发送完全相同的帧

00:49:31.638 --> 00:49:32.573 align:middle line:-1
我们看到右边的那个

00:49:32.639 --> 00:49:35.242 align:middle line:-1
很容易就超过了左边的那个

00:49:37.044 --> 00:49:38.779 align:middle line:-1
事实上 如果你看看其差异

00:49:38.846 --> 00:49:40.581 align:middle line:-1
我们仅在接收端就看到了

00:49:40.647 --> 00:49:43.183 align:middle line:-1
30%的开销削减

00:49:44.284 --> 00:49:49.256 align:middle line:-2
这是因为在比较套接字
和用户态网络时

00:49:49.323 --> 00:49:51.892 align:middle line:-2
我们看到它们发送和接收
UDP数据包

00:49:52.259 --> 00:49:54.595 align:middle line:-1
所需的CPU百分比存在巨大差异

00:49:55.095 --> 00:49:56.897 align:middle line:-1
这只是一个例子

00:49:57.431 --> 00:49:59.666 align:middle line:-1
这不会是每个app的样子

00:49:59.733 --> 00:50:01.568 align:middle line:-1
因为你将以不同方式进行压缩

00:49:59.733 --> 00:50:01.568 align:middle line:-1
因为你将以不同方式进行压缩

00:50:01.635 --> 00:50:04.438 align:middle line:-1
你将会尝试提高连接的效率

00:50:05.138 --> 00:50:07.975 align:middle line:-2
但如果你有一个
生成实时数据的app

00:50:08.041 --> 00:50:11.545 align:middle line:-2
尤其是如果你使用UDP
来发送和接收大量数据包

00:50:11.879 --> 00:50:15.449 align:middle line:-2
我邀请你尝试在你的app中
使用Network.framework

00:50:15.816 --> 00:50:17.084 align:middle line:-1
并在工具软件中运行它

00:50:17.651 --> 00:50:20.621 align:middle line:-2
测量当你使用Network.framework
与套接字时

00:50:20.687 --> 00:50:22.823 align:middle line:-1
它们各自的CPU使用量的差异

00:50:23.056 --> 00:50:24.992 align:middle line:-1
我认为你会对所看到的结果感到满意

00:50:30.531 --> 00:50:32.766 align:middle line:-1
我们今天要讨论的最后一个话题

00:50:33.000 --> 00:50:36.436 align:middle line:-1
是解决网络移动性问题的方法

00:50:36.904 --> 00:50:39.273 align:middle line:-2
这是我们使用
Network.framework

00:50:40.274 --> 00:50:41.875 align:middle line:-1
尝试解决的关键领域

00:50:42.643 --> 00:50:44.711 align:middle line:-1
它的第一步

00:50:45.345 --> 00:50:47.915 align:middle line:-1
只是确保我们能够优雅地开始连接

00:50:48.715 --> 00:50:51.118 align:middle line:-2
我们已经提到了这一点
但我想稍微回顾一下

00:50:51.752 --> 00:50:52.953 align:middle line:-1
等待状态

00:50:53.487 --> 00:50:56.523 align:middle line:-1
是在你的连接刚建立时

00:50:57.191 --> 00:50:59.226 align:middle line:-1
处理网络切换的关键

00:50:59.593 --> 00:51:01.862 align:middle line:-1
当你正在做DNS或TCP时

00:50:59.593 --> 00:51:01.862 align:middle line:-1
当你正在做DNS或TCP时

00:51:02.095 --> 00:51:03.764 align:middle line:-1
它会指出当前无连接

00:51:03.830 --> 00:51:06.533 align:middle line:-1
或连接已更改

00:51:07.534 --> 00:51:12.105 align:middle line:-2
我们鼓励你避免使用
可达性之类的API

00:51:12.272 --> 00:51:15.609 align:middle line:-1
来在建立连接之前检查网络状态

00:51:16.210 --> 00:51:19.813 align:middle line:-2
这将导致竞争条件
并可能无法提供准确的信息

00:51:19.880 --> 00:51:22.182 align:middle line:-1
来描述连接中实际发生的事情

00:51:23.917 --> 00:51:25.853 align:middle line:-1
如果你需要确保你的连接

00:51:25.919 --> 00:51:28.488 align:middle line:-1
不会通过蜂窝网络建立

00:51:29.356 --> 00:51:30.190 align:middle line:-1
不要…

00:51:30.324 --> 00:51:33.460 align:middle line:-2
预先检查设备当前是否运行在
蜂窝网络上

00:51:33.527 --> 00:51:34.828 align:middle line:-1
因为那可能会改变

00:51:35.362 --> 00:51:38.198 align:middle line:-2
只需使用
NWParameters来限制

00:51:38.332 --> 00:51:40.067 align:middle line:-1
你要使用的接口类型

00:51:41.368 --> 00:51:42.870 align:middle line:-1
一旦你启动了你的连接

00:51:43.504 --> 00:51:44.571 align:middle line:-1
并处于就绪状态

00:51:44.638 --> 00:51:47.007 align:middle line:-1
我们会为你提供一系列事件

00:51:47.341 --> 00:51:50.077 align:middle line:-1
来让你知道网络何时发生变化

00:51:51.545 --> 00:51:54.615 align:middle line:-1
第一个被称为连接可行性

00:51:55.482 --> 00:51:56.583 align:middle line:0
可行性

00:51:57.050 --> 00:52:00.587 align:middle line:0
表示你的连接能够通过该接口
发送和接收数据

00:51:57.050 --> 00:52:00.587 align:middle line:0
表示你的连接能够通过该接口
发送和接收数据

00:52:01.355 --> 00:52:03.624 align:middle line:0
即它有一个有效的路由

00:52:05.192 --> 00:52:07.060 align:middle line:0
为了演示这一点

00:52:07.528 --> 00:52:09.162 align:middle line:0
若当设备连到Wi-Fi网络时

00:52:09.396 --> 00:52:12.366 align:middle line:0
你开始建立连接

00:52:13.667 --> 00:52:14.601 align:middle line:0
然后

00:52:14.668 --> 00:52:17.004 align:middle line:0
你的用户走进电梯

00:52:17.304 --> 00:52:18.639 align:middle line:0
他们失去了信号

00:52:19.206 --> 00:52:21.341 align:middle line:0
此时我们将会给你一个事件

00:52:21.775 --> 00:52:25.112 align:middle line:0
让你知道连接不再可用

00:52:25.812 --> 00:52:27.581 align:middle line:0
那么这时你应该怎么做呢？

00:52:29.016 --> 00:52:29.917 align:middle line:0
两件事

00:52:30.350 --> 00:52:32.686 align:middle line:0
我们建议 如果这对你的app来说
合适的话

00:52:32.753 --> 00:52:35.923 align:middle line:0
你可以让用户知道他们目前没有连接

00:52:36.223 --> 00:52:38.258 align:middle line:0
如果他们试图发送和接收数据

00:52:38.325 --> 00:52:39.893 align:middle line:0
现在这将无法正常工作

00:52:41.161 --> 00:52:43.897 align:middle line:0
但是 你不一定要拆掉该连接

00:52:44.731 --> 00:52:46.967 align:middle line:0
反正此时你也没有

00:52:47.034 --> 00:52:48.635 align:middle line:0
可用的更好的接口

00:52:48.902 --> 00:52:51.371 align:middle line:0
并且之前的Wi-Fi接口
可能会回来

00:52:51.805 --> 00:52:54.074 align:middle line:0
通常 如果你走出电梯

00:52:54.141 --> 00:52:55.409 align:middle line:0
并回到同一个Wi-Fi网络范围

00:52:55.542 --> 00:52:58.078 align:middle line:0
你的连接立即可以在断开的地方恢复

00:53:00.581 --> 00:53:04.418 align:middle line:0
我们给你的另一个事件
是更优路径通知

00:53:05.786 --> 00:53:07.354 align:middle line:0
我们还是使用刚才的例子

00:53:07.554 --> 00:53:09.690 align:middle line:0
即你通过Wi-Fi网络连接

00:53:10.724 --> 00:53:14.428 align:middle line:0
假设你走出一幢建筑
现在失去了Wi-Fi信号

00:53:14.494 --> 00:53:16.864 align:middle line:0
但你现在可以使用蜂窝网络

00:53:17.397 --> 00:53:19.399 align:middle line:0
此时我们会让你知道两件事

00:53:20.033 --> 00:53:23.437 align:middle line:0
首先 你的连接不再像之前一样可用

00:53:23.637 --> 00:53:27.274 align:middle line:0
但我们也会告诉你
现在有一条更优的路径可用

00:53:27.441 --> 00:53:28.842 align:middle line:0
如果你再次连接

00:53:29.042 --> 00:53:31.011 align:middle line:0
你就能够使用蜂窝网络

00:53:32.446 --> 00:53:33.714 align:middle line:0
这里的建议是

00:53:34.515 --> 00:53:37.184 align:middle line:0
如果这对你的连接合适的话

00:53:37.351 --> 00:53:39.753 align:middle line:0
尝试迁移到新连接

00:53:39.820 --> 00:53:42.256 align:middle line:0
如果你能恢复刚才正在进行的工作

00:53:44.091 --> 00:53:48.428 align:middle line:0
但只有在新连接完全就绪后
才应该关闭原始连接

00:53:48.629 --> 00:53:50.731 align:middle line:0
同样 Wi-Fi网络可能会回来

00:53:51.598 --> 00:53:54.368 align:middle line:0
或蜂窝网络连接可能会失败

00:53:56.503 --> 00:53:58.105 align:middle line:0
我想在这里强调的最后一种情况

00:53:59.039 --> 00:54:02.442 align:middle line:0
是用户最初通过蜂窝网络连接

00:53:59.039 --> 00:54:02.442 align:middle line:0
是用户最初通过蜂窝网络连接

00:54:02.509 --> 00:54:06.346 align:middle line:0
然后用户走进建筑物
现在他们可以访问Wi-Fi网络

00:54:07.014 --> 00:54:08.582 align:middle line:0
在这种情况下 你的连接

00:54:08.649 --> 00:54:10.083 align:middle line:0
即原来的那个完全没问题

00:54:10.150 --> 00:54:11.285 align:middle line:0
它仍然可用

00:54:11.418 --> 00:54:13.854 align:middle line:0
但你现在也有更优的路径可用

00:54:15.656 --> 00:54:18.792 align:middle line:0
同样的 在这种情况下
如果你可以迁移你的连接

00:54:18.859 --> 00:54:22.729 align:middle line:0
这可能是尝试建立新连接并使用它

00:54:22.796 --> 00:54:23.997 align:middle line:0
来发送数据的好时机

00:54:24.431 --> 00:54:26.533 align:middle line:-1
这将为用户节省流量账单

00:54:28.435 --> 00:54:31.238 align:middle line:-1
但请继续使用原始连接

00:54:31.405 --> 00:54:33.106 align:middle line:-1
直到你完全建立新的连接

00:54:34.274 --> 00:54:35.976 align:middle line:-1
我们来看下代码的样子

00:54:36.210 --> 00:54:38.579 align:middle line:-2
你可以在连接上设置一个
viabilityUpdateHandler

00:54:38.846 --> 00:54:41.048 align:middle line:-1
它会返回一个布尔值

00:54:41.114 --> 00:54:43.217 align:middle line:-1
来让你知道当时连接是否可用

00:54:43.984 --> 00:54:46.086 align:middle line:-1
以及一个betterPathUpdateHandler

00:54:46.153 --> 00:54:48.856 align:middle line:-1
它告诉你何时有更优的路径可用

00:54:49.089 --> 00:54:50.524 align:middle line:-1
或不再可用

00:54:53.427 --> 00:54:57.397 align:middle line:-2
现在 处理网络移动性的
更好解决方案

00:54:57.464 --> 00:54:59.933 align:middle line:-1
是我们前几年所谈到的

00:55:00.200 --> 00:55:03.604 align:middle line:-1
多路径连接 多路径TCP

00:55:04.204 --> 00:55:07.941 align:middle line:-2
如果你能够在服务器上
启用多路径TCP

00:55:08.675 --> 00:55:12.779 align:middle line:-1
并且在客户端启用参数中的

00:55:12.846 --> 00:55:13.847 align:middle line:-1
multipathServiceType

00:55:14.414 --> 00:55:16.750 align:middle line:-1
那么你的连接将随着网络的变换

00:55:16.817 --> 00:55:18.685 align:middle line:-1
而在它们之间自动迁移

00:55:18.986 --> 00:55:22.122 align:middle line:-1
这是一种非常棒的无缝体验

00:55:22.322 --> 00:55:23.857 align:middle line:-1
你的app不需要处理任何工作

00:55:24.858 --> 00:55:28.762 align:middle line:-2
这也是URLSession中
可用的相同服务类型

00:55:30.731 --> 00:55:34.768 align:middle line:-2
关于Network.framework
我想在此强调几点

00:55:35.569 --> 00:55:38.772 align:middle line:-2
若你在NWParameters中
限制可以使用的接口类型

00:55:39.173 --> 00:55:42.543 align:middle line:-1
这将适用于MPTCP

00:55:42.876 --> 00:55:45.979 align:middle line:-2
所以在使用多路径连接时
你仍然可以选择

00:55:46.046 --> 00:55:47.481 align:middle line:-1
不使用蜂窝网络

00:55:47.848 --> 00:55:51.251 align:middle line:-2
这样我们只会在可用的
不同Wi-Fi网络之间

00:55:51.318 --> 00:55:52.553 align:middle line:-1
进行无缝迁移

00:55:54.721 --> 00:55:58.091 align:middle line:-2
此外 之前我提到的
连接可行性处理程序

00:55:58.392 --> 00:56:00.260 align:middle line:-1
与多路径TCP略有不同

00:55:58.392 --> 00:56:00.260 align:middle line:-1
与多路径TCP略有不同

00:56:01.028 --> 00:56:04.331 align:middle line:-2
因为每当我们更改网络时
我们都会自动为你迁移

00:56:04.865 --> 00:56:06.633 align:middle line:-1
你的连接

00:56:06.700 --> 00:56:09.403 align:middle line:-2
只有在你完全没有可用的网络时
才是不可用的

00:56:13.273 --> 00:56:16.777 align:middle line:-1
因此在等待连接之间

00:56:17.845 --> 00:56:20.647 align:middle line:-1
可用性 更优路径 MPTCP

00:56:21.014 --> 00:56:23.884 align:middle line:-1
我们真的希望你的app中

00:56:24.084 --> 00:56:27.087 align:middle line:-2
所有这些使用
SCNetworkReachability

00:56:27.254 --> 00:56:29.456 align:middle line:-1
来手动检查网络更改的用例

00:56:29.823 --> 00:56:30.991 align:middle line:-1
都能被替换掉

00:56:31.491 --> 00:56:32.993 align:middle line:-1
然而我们的确意识到了

00:56:33.360 --> 00:56:36.663 align:middle line:-1
在有些情况下你仍然想知道

00:56:37.164 --> 00:56:39.466 align:middle line:-2
有哪些可用的网络
以及它什么时候改变

00:56:40.667 --> 00:56:46.440 align:middle line:-2
为此Network.framework提供了
一个新的名为NWPathMonitor的API

00:56:47.641 --> 00:56:48.909 align:middle line:-1
这个PathMonitor

00:56:49.209 --> 00:56:51.378 align:middle line:-1
并不监视可达性

00:56:51.445 --> 00:56:54.181 align:middle line:-1
或尝试预测给定主机的可达性

00:56:54.414 --> 00:56:55.315 align:middle line:-1
而只是让你知道

00:56:55.382 --> 00:56:57.484 align:middle line:-1
你的设备上接口的当前状态是什么

00:56:57.651 --> 00:56:59.820 align:middle line:-1
以及它们何时改变

00:57:01.054 --> 00:57:03.524 align:middle line:-1
它允许你遍历

00:57:03.590 --> 00:57:05.559 align:middle line:-1
你可以连接的所有接口

00:57:05.792 --> 00:57:07.995 align:middle line:-2
以备你想要在其中每个上面
都建立连接

00:57:09.129 --> 00:57:12.332 align:middle line:-2
并且只要这些网络发生变化
它就会通知你

00:57:13.200 --> 00:57:16.503 align:middle line:-2
这可能非常有用
如果你想要更新UI

00:57:16.570 --> 00:57:18.839 align:middle line:-1
来让用户知道他们是否已连接的话

00:57:19.873 --> 00:57:22.209 align:middle line:-1
如Stuart在上次演讲中提到的

00:57:22.409 --> 00:57:23.744 align:middle line:-1
可能有这样的场景

00:57:23.810 --> 00:57:26.813 align:middle line:-1
其中用户需要填写一个很长的表格

00:57:26.880 --> 00:57:29.416 align:middle line:-1
但他们可不想在填完的时候

00:57:29.483 --> 00:57:31.885 align:middle line:-1
才意识到他们没有连接

00:57:32.819 --> 00:57:36.056 align:middle line:-1
因此在这些情况下使用

00:57:36.323 --> 00:57:39.459 align:middle line:-2
只是等待连接的
NWPathMonitor是不够的

00:57:39.927 --> 00:57:43.096 align:middle line:-2
所以在所有这些情况下
我们真的希望看到人们

00:57:43.263 --> 00:57:44.331 align:middle line:-1
不再使用可达性

00:57:44.598 --> 00:57:48.535 align:middle line:-1
并比以往更优雅地处理网络转换

00:57:50.804 --> 00:57:52.339 align:middle line:-1
接下来 我想邀请Josh

00:57:52.406 --> 00:57:55.108 align:middle line:-1
回到舞台上来并告诉你如何参与

00:57:55.242 --> 00:57:56.610 align:middle line:-2
并开始使用
Network.framework

00:58:02.482 --> 00:58:03.317 align:middle line:-1
谢谢 Tommy

00:58:03.817 --> 00:58:07.387 align:middle line:-2
我们有一个很棒的新API
我们认为你会爱上它

00:58:08.222 --> 00:58:09.990 align:middle line:-1
我想谈谈为了立即开始使用它

00:58:10.057 --> 00:58:11.091 align:middle line:-1
你可以做的事情

00:58:11.158 --> 00:58:13.093 align:middle line:-1
但首先我要谈一些

00:58:13.160 --> 00:58:14.728 align:middle line:-1
我们希望你不要做的事情

00:58:14.795 --> 00:58:16.864 align:middle line:-1
以便我们可以真正利用这些新技术

00:58:16.930 --> 00:58:18.365 align:middle line:-1
比如用户态网络

00:58:19.733 --> 00:58:22.269 align:middle line:-2
若你使用的是macOS
并且有一个网络内核扩展

00:58:22.336 --> 00:58:24.538 align:middle line:-1
而且你正在该网络内核扩展中

00:58:24.605 --> 00:58:27.975 align:middle line:-2
执行某些用其它方法实现不了的操作
请立即与我们联系

00:58:28.041 --> 00:58:29.843 align:middle line:-1
我们会为你提供更好的选择

00:58:30.077 --> 00:58:32.412 align:middle line:-1
因为网络内核扩展不兼容

00:58:32.479 --> 00:58:33.780 align:middle line:-1
用户态网络

00:58:35.315 --> 00:58:37.451 align:middle line:-2
你需要注意
对于URLSession

00:58:38.585 --> 00:58:41.088 align:middle line:-1
代理自动配置将不再支持

00:58:41.154 --> 00:58:42.856 align:middle line:-1
FTP和文件URL

00:58:42.923 --> 00:58:45.392 align:middle line:-1
以后唯一支持的URL方案

00:58:45.459 --> 00:58:48.161 align:middle line:-1
将是HTTP和HTTPS

00:58:49.496 --> 00:58:52.332 align:middle line:-1
我们希望你停止使用

00:58:52.399 --> 00:58:53.901 align:middle line:-2
Core Foundation层
的许多API

00:58:53.967 --> 00:58:55.469 align:middle line:-1
它们最终会被弃用

00:58:55.536 --> 00:58:57.571 align:middle line:-1
虽然它们尚未标记为已弃用

00:58:57.971 --> 00:59:02.409 align:middle line:-2
它们是CFStreamCreatePairWith
开头的任何与套接字相关的东西

00:58:57.971 --> 00:59:02.409 align:middle line:-2
它们是CFStreamCreatePairWith
开头的任何与套接字相关的东西

00:59:02.743 --> 00:59:03.911 align:middle line:-1
以及CFSocket

00:59:04.645 --> 00:59:07.748 align:middle line:-1
它们不能很好利用我们通过

00:59:07.814 --> 00:59:08.682 align:middle line:-2
Network.framework
引入的

00:59:08.982 --> 00:59:10.517 align:middle line:-1
许多关于连接建立的优化

00:59:10.584 --> 00:59:12.920 align:middle line:-1
并且也无法利用新的用户态网络

00:59:12.986 --> 00:59:14.488 align:middle line:-1
我们真的希望你能摆脱它们

00:59:14.555 --> 00:59:18.358 align:middle line:-2
以利用Network.framework
和URLSession带来的

00:59:18.425 --> 00:59:21.094 align:middle line:-1
强大的连接性改进

00:59:21.461 --> 00:59:22.896 align:middle line:-1
和性能改进

00:59:24.364 --> 00:59:27.534 align:middle line:-2
还有一些Foundation API
我们也希望你不再使用

00:59:27.601 --> 00:59:33.240 align:middle line:-2
如果你使用NSStream、NSNetService
或NSSocketPort这些API中的任意一种

00:59:33.373 --> 00:59:36.743 align:middle line:-2
请改为使用Network.framework
或URLSession

00:59:37.611 --> 00:59:39.746 align:middle line:-2
最后 如果你使用的是
SCNetworkReachability

00:59:40.514 --> 00:59:42.182 align:middle line:-1
我们觉得等待连接模型

00:59:42.249 --> 00:59:45.419 align:middle line:-2
是一个更好的模型
所以我们真的希望你改为使用它

00:59:46.053 --> 00:59:48.121 align:middle line:-1
对于那些等待连接并不合适的

00:59:48.188 --> 00:59:49.223 align:middle line:-1
少数情况

00:59:49.289 --> 00:59:52.259 align:middle line:-2
以后NWPathMonitor
是一个更好的解决方案

00:59:53.393 --> 00:59:55.462 align:middle line:-1
我们已经说了一些不希望你做的事情

00:59:55.529 --> 00:59:57.764 align:middle line:-2
现在我想专注于
我们真的希望你做的事情

00:59:58.632 --> 00:59:59.566 align:middle line:-1
从此以后

00:59:59.633 --> 01:00:02.002 align:middle line:-1
我们平台上的网络首选API

00:59:59.633 --> 01:00:02.002 align:middle line:-1
我们平台上的网络首选API

01:00:02.069 --> 01:00:04.571 align:middle line:-2
是URLSession
和Network.framework

01:00:04.705 --> 01:00:07.641 align:middle line:-2
URLSession
主要针对HTTP

01:00:07.708 --> 01:00:11.411 align:middle line:-1
但流任务提供了非常简单的

01:00:11.478 --> 01:00:12.813 align:middle line:-1
TCP和TLS连接

01:00:13.881 --> 01:00:15.449 align:middle line:-1
如果你需要更先进的东西

01:00:15.749 --> 01:00:17.417 align:middle line:-2
Network.framework
为你提供了

01:00:17.484 --> 01:00:20.954 align:middle line:-2
对TCP、TLS
UDP、DTLS的更好支持

01:00:21.088 --> 01:00:23.123 align:middle line:-1
它处理监听入站连接

01:00:23.190 --> 01:00:24.691 align:middle line:-1
以及出站连接

01:00:24.758 --> 01:00:27.794 align:middle line:-2
并且我们用PathMonitor
来处理一些移动性问题

01:00:29.530 --> 01:00:31.965 align:middle line:-1
下一步 我们真的希望看到你采用

01:00:32.499 --> 01:00:34.668 align:middle line:-2
Network.framework
和URLSession

01:00:35.002 --> 01:00:37.771 align:middle line:-1
你的客户将会赞赏

01:00:38.172 --> 01:00:40.440 align:middle line:-1
你建立的连接有多么可靠

01:00:40.674 --> 01:00:42.209 align:middle line:-1
并赞赏更好的性能所带来的

01:00:42.276 --> 01:00:43.343 align:middle line:-1
更长的电池续航时间

01:00:45.145 --> 01:00:47.047 align:middle line:-1
当你做这些事时 请关注于

01:00:48.215 --> 01:00:49.850 align:middle line:-1
你如何处理发送和接收

01:00:49.917 --> 01:00:51.618 align:middle line:-1
来真正优化其性能

01:00:52.052 --> 01:00:54.388 align:middle line:-1
并多花些时间来获得

01:00:54.454 --> 01:00:57.324 align:middle line:-1
对可行性和更优路径变化的支持

01:00:57.391 --> 01:00:58.992 align:middle line:-1
它对于提供无缝的网络体验

01:00:59.059 --> 01:01:01.128 align:middle line:-1
至关重要

01:00:59.059 --> 01:01:01.128 align:middle line:-1
至关重要

01:01:02.863 --> 01:01:05.732 align:middle line:-2
现在我们知道Network.framework
还不支持UDP组播

01:01:06.066 --> 01:01:07.434 align:middle line:-1
所以若你正使用UDP组播

01:01:07.501 --> 01:01:09.336 align:middle line:-1
我们真的很想了解你的用例

01:01:09.403 --> 01:01:11.438 align:middle line:-1
以便以后我们可以将这些考虑在内

01:01:12.606 --> 01:01:14.208 align:middle line:-1
此外 如果你有任何其它问题

01:01:14.274 --> 01:01:15.409 align:middle line:-1
或增强请求

01:01:15.742 --> 01:01:17.044 align:middle line:-1
我们很乐意听取你的意见

01:01:17.110 --> 01:01:19.413 align:middle line:-1
请联系开发人员支持

01:01:19.847 --> 01:01:20.781 align:middle line:-1
或到访我们的实验室

01:01:20.848 --> 01:01:24.518 align:middle line:-2
午饭后两点我们有一个实验室
并在明天上午九点还有一个

01:01:25.853 --> 01:01:27.721 align:middle line:0
更多详细信息 请参阅此URL

01:01:28.989 --> 01:01:31.792 align:middle line:0
别忘了明天早上和午餐后的实验室

01:01:31.859 --> 01:01:34.428 align:middle line:0
非常感谢
祝你们度过愉快的WWDC
