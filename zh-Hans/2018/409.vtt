WEBVTT

00:00:17.417 --> 00:00:22.856 align:middle line:0
（LLVM新特性 演讲409）

00:00:27.427 --> 00:00:30.297 align:middle line:-2
早上好 欢迎来到
LLVM新特性的演讲

00:00:31.265 --> 00:00:33.901 align:middle line:-2
我是Jim Grosbach
你友好的尖尖发型的老板街坊

00:00:33.967 --> 00:00:38.805 align:middle line:-2
今天在我们将深入了解
为大家带来的所有激动人心的

00:00:38.872 --> 00:00:41.008 align:middle line:-2
新事物的技术细节之前
我先在此给你们讲些

00:00:41.074 --> 00:00:44.311 align:middle line:-1
关于LLVM的背景知识

00:00:45.379 --> 00:00:49.716 align:middle line:-1
首先 LLVM不仅仅是编译器

00:00:50.217 --> 00:00:53.153 align:middle line:-1
它是Clang编译器

00:00:53.220 --> 00:00:56.089 align:middle line:-1
和我们每天都使用的C族语言的背景

00:00:56.456 --> 00:01:01.929 align:middle line:-2
它也为静态分析器 杀毒软件
LLDB调试器提供了动力

00:00:56.456 --> 00:01:01.929 align:middle line:-2
它也为静态分析器 杀毒软件
LLDB调试器提供了动力

00:01:02.362 --> 00:01:05.232 align:middle line:-1
并且是GPU着色器编译器下的

00:01:05.498 --> 00:01:11.171 align:middle line:-2
所有Apple移动平台的
优化代码生成框架

00:01:11.939 --> 00:01:16.343 align:middle line:-2
除此之外
它还为你可能时不时听说过的

00:01:16.410 --> 00:01:19.813 align:middle line:-2
一个叫做Swift的额外小项目
提供了动力

00:01:21.014 --> 00:01:24.918 align:middle line:-2
和Swift一样
LLVM也是一个开源项目

00:01:26.353 --> 00:01:30.557 align:middle line:0
我们都在我们的LLVM
这个飞龙的监视下工作

00:01:30.824 --> 00:01:32.826 align:middle line:-1
他通常是个很友好的家伙

00:01:32.893 --> 00:01:35.863 align:middle line:-2
不过我得提醒你
如果你称他为龙的话

00:01:35.963 --> 00:01:38.165 align:middle line:-2
他可能会变得有点暴躁
所以不要那样做

00:01:39.499 --> 00:01:43.303 align:middle line:-2
作为一个开源项目
LLVM是一个合作伙伴

00:01:44.137 --> 00:01:47.341 align:middle line:-1
我们与来自世界各地

00:01:47.407 --> 00:01:50.677 align:middle line:-2
不同行业的合作伙
学者、研究人员和爱好者合作

00:01:50.744 --> 00:01:56.483 align:middle line:-1
还有世界各地更多的人

00:01:56.583 --> 00:01:59.319 align:middle line:-2
这真是太棒了
我们共同努力

00:01:59.386 --> 00:02:02.089 align:middle line:-1
创造出最伟大的工具

00:01:59.386 --> 00:02:02.089 align:middle line:-1
创造出最伟大的工具

00:02:02.322 --> 00:02:03.790 align:middle line:-1
来推动科技的发展

00:02:04.825 --> 00:02:09.395 align:middle line:-1
如果你对编译器有兴趣的话

00:02:09.729 --> 00:02:12.766 align:middle line:-1
我们乐意邀请你加入我们

00:02:13.267 --> 00:02:16.170 align:middle line:-2
你可以去访问LLVM的网站
llvm.org

00:02:16.603 --> 00:02:20.941 align:middle line:-2
或者你可以在今天晚些时候
在LLVM实验室和我们交谈

00:02:21.008 --> 00:02:23.977 align:middle line:-2
我们的许多来自Apple的
编译器工程师都将在那里

00:02:24.044 --> 00:02:27.848 align:middle line:-1
我肯定会非常高兴地与你讲解

00:02:27.915 --> 00:02:30.117 align:middle line:-1
与所有编译器相关

00:02:30.384 --> 00:02:31.652 align:middle line:-1
任何一切你想知道的事情

00:02:32.986 --> 00:02:37.591 align:middle line:-2
今天我们有一套很好的东西
要和你们分享

00:02:37.658 --> 00:02:40.160 align:middle line:-1
我们有自动引用计数的更新

00:02:40.227 --> 00:02:44.464 align:middle line:-2
这使得编译器
更容易帮助你进行内存管理

00:02:44.731 --> 00:02:49.937 align:middle line:-2
Xcode 10中有了新诊断方法
静态分析器中有了新检查方法

00:02:50.170 --> 00:02:53.974 align:middle line:-2
在构建时它能够帮助
更快地捕获项目中的错误

00:02:54.208 --> 00:02:56.376 align:middle line:-1
从而提高代码的质量

00:02:56.710 --> 00:02:58.979 align:middle line:-2
我们的编译器功能
无论是对于Apple平台

00:02:59.046 --> 00:03:01.949 align:middle line:-2
还是你的app
都可以提高它们的安全性

00:02:59.046 --> 00:03:01.949 align:middle line:-2
还是你的app
都可以提高它们的安全性

00:03:02.249 --> 00:03:05.419 align:middle line:-2
以及还有新的特性
使你能够利用硬件结构上的

00:03:05.485 --> 00:03:07.588 align:middle line:-1
所有真正伟大的新东西

00:03:07.654 --> 00:03:09.389 align:middle line:-1
以便能够从我们的平台

00:03:09.456 --> 00:03:11.692 align:middle line:-1
和架构中

00:03:11.992 --> 00:03:13.994 align:middle line:-1
获得我们都想要的性能

00:03:14.728 --> 00:03:17.664 align:middle line:-1
因此 我想邀请我的同事

00:03:18.098 --> 00:03:19.533 align:middle line:-1
Alex上来谈谈ARC

00:03:20.400 --> 00:03:21.301 align:middle line:-1
Alex

00:03:21.368 --> 00:03:23.136 align:middle line:0
（ARC最新情况）

00:03:27.908 --> 00:03:28.842 align:middle line:-1
谢谢Jim

00:03:29.676 --> 00:03:31.445 align:middle line:-1
自从我们在几年前引入了

00:03:31.512 --> 00:03:34.214 align:middle line:-1
自动引用计数以来

00:03:34.915 --> 00:03:37.184 align:middle line:0
它大大简化了
Object-C编程

00:03:38.051 --> 00:03:41.088 align:middle line:0
一些限制使得从旧的

00:03:41.355 --> 00:03:45.225 align:middle line:0
手动保留释放模式迁移到
ARC变得更加困难

00:03:45.292 --> 00:03:48.395 align:middle line:-2
我很高兴地说
我们现在已经解除了这样的限制

00:03:49.029 --> 00:03:51.064 align:middle line:0
Xcode 10支持

00:03:51.131 --> 00:03:54.635 align:middle line:0
C结构中的
ARC对象指针字段

00:03:54.701 --> 00:03:56.670 align:middle line:-1
（C结构中的ARC对象指针！）

00:04:00.507 --> 00:04:02.176 align:middle line:-1
让我们来看一个例子

00:04:02.242 --> 00:04:04.811 align:middle line:-2
假设我们想编写一个
食品订购app

00:04:05.379 --> 00:04:09.149 align:middle line:-2
我们想要创建一个
表示菜单项的数据结构

00:04:09.216 --> 00:04:10.617 align:middle line:-1
（工程师）

00:04:10.684 --> 00:04:14.521 align:middle line:-2
对于Xcode 9和更早的版本
实际上我们不可能

00:04:14.588 --> 00:04:18.591 align:middle line:-2
使用一个带有ARC对象指针字段的
C结构

00:04:18.992 --> 00:04:22.829 align:middle line:-2
所以我们必须在这里使用一个C
一个Objective-C类

00:04:24.264 --> 00:04:27.935 align:middle line:-2
而现在Xcode 10
允许我们实际创建一个

00:04:28.135 --> 00:04:30.671 align:middle line:-1
具有ARC对象指针字段的C结构

00:04:34.474 --> 00:04:37.644 align:middle line:-1
让我们继续写我们的食品订购app

00:04:38.045 --> 00:04:41.248 align:middle line:-2
让我们创建一个
为我们订购免费食物的函数

00:04:41.615 --> 00:04:45.719 align:middle line:-2
在这个函数中
让我们创建一个价格为零的

00:04:45.919 --> 00:04:47.054 align:middle line:-1
MenuItem类的变量项目

00:04:48.388 --> 00:04:51.124 align:middle line:-1
然后 让我们把这个项目传递到

00:04:51.191 --> 00:04:53.393 align:middle line:-2
另一个实际上
为我们订购食物的函数中去

00:04:54.761 --> 00:04:59.733 align:middle line:-1
创建项时编译器必须合成那个

00:05:00.033 --> 00:05:03.871 align:middle line:0
保留项目中
ARC对象指针字段的代码

00:05:05.038 --> 00:05:06.707 align:middle line:-1
幻灯片上的代码注释演示了

00:05:07.074 --> 00:05:10.444 align:middle line:-1
编译器所合成的代码

00:05:11.044 --> 00:05:14.848 align:middle line:-1
此代码确保在实际使用项目之前

00:05:15.182 --> 00:05:18.785 align:middle line:-1
不会提前发布项目的名称和价格

00:05:21.255 --> 00:05:24.858 align:middle line:0
在函数的末尾
“项目”超出了作用域

00:05:25.292 --> 00:05:27.227 align:middle line:0
并从栈中被释放

00:05:27.394 --> 00:05:30.664 align:middle line:0
因此编译器必须合成

00:05:30.864 --> 00:05:34.601 align:middle line:0
释放条目中
ARC对象指针字段的代码

00:05:35.536 --> 00:05:40.841 align:middle line:-2
这可以确保在项目释放时
不会泄露它的名称和价格

00:05:42.943 --> 00:05:47.147 align:middle line:-2
以前在使用手动保留释放模式时
可以使用

00:05:47.581 --> 00:05:50.184 align:middle line:-2
Objective-C
对象指针字段

00:05:50.984 --> 00:05:54.521 align:middle line:-1
但是你必须自己编写保留和释放

00:05:55.122 --> 00:05:59.293 align:middle line:-1
使用ARC编译器会为你

00:05:59.459 --> 00:06:02.930 align:middle line:-2
隐藏所有这些复杂性
并合成那个保留和释放字段的代码

00:05:59.459 --> 00:06:02.930 align:middle line:-2
隐藏所有这些复杂性
并合成那个保留和释放字段的代码

00:06:03.630 --> 00:06:05.666 align:middle line:-1
所以编译器实际上是你的朋友

00:06:05.999 --> 00:06:09.136 align:middle line:-1
它对栈上的变量

00:06:09.203 --> 00:06:10.904 align:middle line:-1
以及其他结构中的字段

00:06:11.772 --> 00:06:14.575 align:middle line:-1
以及Objective-C类中的

00:06:14.875 --> 00:06:18.245 align:middle line:-2
实例变量
都进行了正确的管理

00:06:19.680 --> 00:06:23.684 align:middle line:-1
但是有一个地方

00:06:23.750 --> 00:06:26.587 align:middle line:-2
我们需要做一些额外的工作
来支持使用

00:06:27.788 --> 00:06:29.489 align:middle line:-2
ARC对象指针字段的结构
这个地方就是堆

00:06:30.624 --> 00:06:31.992 align:middle line:-1
让我们回到我们的结构

00:06:32.125 --> 00:06:36.096 align:middle line:-2
我们假设
你希望在堆中分配一个菜单项数组

00:06:36.797 --> 00:06:41.835 align:middle line:-2
若这是Objective-C接口
我们就可以在此用NSArray

00:06:42.536 --> 00:06:45.205 align:middle line:-2
但它不是 所以让我们使用
malloc和free

00:06:46.173 --> 00:06:49.176 align:middle line:-1
现在这段代码实际上有两个问题

00:06:49.977 --> 00:06:54.815 align:middle line:-1
首先内存在分配时不是零初始化的

00:06:55.048 --> 00:06:58.185 align:middle line:-1
这意味着它们的指针是无效的

00:06:58.585 --> 00:07:01.822 align:middle line:-1
这将导致程序在运行时

00:06:58.585 --> 00:07:01.822 align:middle line:-1
这将导致程序在运行时

00:07:01.889 --> 00:07:03.323 align:middle line:-1
出现不希望的运行时行为

00:07:05.225 --> 00:07:09.062 align:middle line:-1
第二个问题是在释放内存之前

00:07:09.129 --> 00:07:12.065 align:middle line:-1
ARC对象指针字段未被清除

00:07:12.499 --> 00:07:17.070 align:middle line:-1
这将导致你的程序运行时内存泄漏

00:07:19.139 --> 00:07:25.212 align:middle line:-2
要解决第一个问题
可将对malloc的调用替换为对calloc的调用

00:07:25.746 --> 00:07:29.449 align:middle line:-1
这将确保你的内存是零初始化的

00:07:30.050 --> 00:07:34.688 align:middle line:-2
这将消除所有那些令人不快的
意想不到的运行时问题

00:07:35.722 --> 00:07:39.059 align:middle line:0
要解决第二个问题

00:07:39.459 --> 00:07:41.728 align:middle line:0
你可以在循环分配到内存之前

00:07:42.129 --> 00:07:45.532 align:middle line:0
编写一个循环以清除项目中的
所有ARC对象指针字段

00:07:46.266 --> 00:07:49.803 align:middle line:-1
这将确保在释放条目时

00:07:49.937 --> 00:07:52.239 align:middle line:-1
条目中的名称和价格不会泄漏

00:07:56.009 --> 00:07:58.478 align:middle line:-1
现在这是一个令人兴奋的新特性

00:07:59.046 --> 00:08:03.217 align:middle line:-2
如果你们当中
由于缺少这样的特性

00:07:59.046 --> 00:08:03.217 align:middle line:-2
如果你们当中
由于缺少这样的特性

00:08:03.517 --> 00:08:06.119 align:middle line:-1
而推迟迁移到ARC中的话

00:08:06.186 --> 00:08:10.524 align:middle line:-2
我希望Xcode 10中
对ARC对象指针字段的支持

00:08:10.991 --> 00:08:12.860 align:middle line:-1
可以帮助你重新考虑你的选择

00:08:14.027 --> 00:08:18.732 align:middle line:-2
我们来看看Objective-C
指针和一般的结构

00:08:18.799 --> 00:08:23.270 align:middle line:-2
看看在Xcode 10中
在不同的语言模式中

00:08:23.570 --> 00:08:26.273 align:middle line:-1
在哪里以及如何使用这些结构

00:08:27.774 --> 00:08:31.745 align:middle line:-2
在Xcode 10中
你可以使用具有

00:08:31.812 --> 00:08:34.248 align:middle line:-1
Objective-C

00:08:34.515 --> 00:08:36.216 align:middle line:-2
对象指针字段的结构
来跨越不同的语言模式

00:08:36.549 --> 00:08:41.788 align:middle line:-2
例如你可以在C、Objective-C
甚至Objective-C++中

00:08:41.855 --> 00:08:43.789 align:middle line:-1
使用相同的结构

00:08:44.791 --> 00:08:50.330 align:middle line:-2
而且即使在ARC或
手动保留释放模式下编译代码时

00:08:50.564 --> 00:08:52.666 align:middle line:-1
它也会正常工作

00:08:54.067 --> 00:08:58.839 align:middle line:-2
在Xcode 10中
实际上我们在调用函数之间

00:08:59.306 --> 00:09:04.745 align:middle line:-2
统一了
Objective-C++ ABI

00:08:59.306 --> 00:09:04.745 align:middle line:-2
统一了
Objective-C++ ABI

00:09:04.811 --> 00:09:07.915 align:middle line:-2
这些函数接收或返回具有
Objective-C++中的ARC对象指针字段的结构

00:09:08.715 --> 00:09:12.653 align:middle line:-2
这是通过Xcode 10中的
ABI更改来完成的

00:09:13.053 --> 00:09:17.291 align:middle line:-2
这种ABI变化影响了
Objective-C++中的函数

00:09:17.858 --> 00:09:21.195 align:middle line:-1
这些函数通过值返回或接受

00:09:21.528 --> 00:09:26.466 align:middle line:-1
具有ARC对象指针字段的结构

00:09:26.533 --> 00:09:28.635 align:middle line:-2
而没有像构造函数或析构函数
那样的特殊成员函数

00:09:30.037 --> 00:09:33.106 align:middle line:-1
现在如果你不确定这对你意味着什么

00:09:33.173 --> 00:09:36.643 align:middle line:-2
或者你的代码是否受到
此ABI更改的影响

00:09:37.077 --> 00:09:39.713 align:middle line:-1
请查看Xcode的发行说明

00:09:39.947 --> 00:09:41.882 align:middle line:-1
描述了此ABI更改的

00:09:42.182 --> 00:09:45.352 align:middle line:-1
效果和影响

00:09:45.419 --> 00:09:48.922 align:middle line:-2
（结构中的
OBJECTIVE-C对象）

00:09:48.989 --> 00:09:50.224 align:middle line:-1
对于ARC对象指针字段

00:09:50.290 --> 00:09:54.494 align:middle line:-1
和C结构 我们有一个警告

00:09:55.629 --> 00:09:57.431 align:middle line:-1
它们在Swift中没有支持

00:09:57.698 --> 00:09:59.733 align:middle line:-1
因此如果你尝试使用一个具有

00:09:59.967 --> 00:10:02.669 align:middle line:-2
Swift中
ARC对象指针字段的结构

00:09:59.967 --> 00:10:02.669 align:middle line:-2
Swift中
ARC对象指针字段的结构

00:10:03.203 --> 00:10:07.040 align:middle line:-2
你只会得到一个编译错误
因为找不到该结构

00:10:07.107 --> 00:10:10.344 align:middle line:-2
（对于某些函数的ABI更改
通过值传递或返回结构）

00:10:10.410 --> 00:10:13.814 align:middle line:-2
（Swift不支持使用
ARC对象指针字段导入结构）

00:10:13.881 --> 00:10:19.019 align:middle line:-2
除了像支持ARC对指针字段的
新特性之外

00:10:19.453 --> 00:10:24.358 align:middle line:-2
Xcode 10
还附带了许多新的编译器诊断

00:10:24.825 --> 00:10:28.061 align:middle line:-2
在Xcode 10中
我们实际上有超过100个新的警告

00:10:28.762 --> 00:10:30.797 align:middle line:-1
今天我想谈谈其中的两个

00:10:30.864 --> 00:10:31.965 align:middle line:-1
（Xcode 10中的新诊断）

00:10:32.032 --> 00:10:34.902 align:middle line:-2
第一个警告可能对那些混合了
Swift和Objective-C代码

00:10:35.602 --> 00:10:39.072 align:middle line:-1
的人感兴趣

00:10:39.840 --> 00:10:44.444 align:middle line:-2
因如你所知Swift代码
可以导入Objective-C

00:10:45.312 --> 00:10:50.017 align:middle line:-2
Xcode允许你
通过生成一个使用

00:10:50.217 --> 00:10:54.855 align:middle line:-2
Objective-C声明描述
Swift接口的头文件来实现这点

00:10:54.922 --> 00:10:56.456 align:middle line:-2
（SWIFT和
OBJECTIVE-C互操作性）

00:10:56.523 --> 00:10:59.860 align:middle line:-2
你可以将这个头文件导入到你自己的
Objective-C代码中

00:11:00.360 --> 00:11:04.031 align:middle line:-1
以便访问底层的Swift声明

00:11:04.798 --> 00:11:06.333 align:middle line:-1
现在让我们更具体地讨论一下

00:11:06.400 --> 00:11:09.636 align:middle line:-1
如何将Swift的闭包参数

00:11:09.703 --> 00:11:11.438 align:middle line:-1
导入到Objective-C中

00:11:12.172 --> 00:11:13.841 align:middle line:-1
现在屏幕上

00:11:14.107 --> 00:11:17.945 align:middle line:-2
你看到了一个叫Executor的
Swift协议的例子

00:11:18.712 --> 00:11:22.716 align:middle line:-2
该协议定义了一个名为
performOperation的函数成员

00:11:22.883 --> 00:11:25.986 align:middle line:-2
它接受一个名为
handler的闭包参数

00:11:27.487 --> 00:11:31.225 align:middle line:0
现在Swift中闭包参数
在默认情况下是不转义的

00:11:31.491 --> 00:11:35.362 align:middle line:0
这意味着在函数返回后

00:11:35.429 --> 00:11:37.097 align:middle line:0
它们不应该被保留或调用

00:11:38.599 --> 00:11:43.770 align:middle line:0
现在当符合
Objective-C时

00:11:43.871 --> 00:11:47.374 align:middle line:0
程序员很容易忘记这个契约是存在的

00:11:48.175 --> 00:11:51.178 align:middle line:-1
例如 正如你现在幻灯片上看到的

00:11:51.512 --> 00:11:55.215 align:middle line:-2
在Objective-C中
我们有一个调度执行器接口

00:11:55.282 --> 00:11:57.751 align:middle line:-1
并且符合Executor协议

00:11:58.352 --> 00:12:00.921 align:middle line:-2
因此它提供了
performOperation方法

00:11:58.352 --> 00:12:00.921 align:middle line:-2
因此它提供了
performOperation方法

00:12:01.321 --> 00:12:03.390 align:middle line:-1
该方法接受与Swift的

00:12:03.457 --> 00:12:06.827 align:middle line:-2
处理程序闭包参数对应的
处理程序块参数

00:12:07.427 --> 00:12:09.863 align:middle line:-2
但仅仅通过查看
Objective-C代码

00:12:10.097 --> 00:12:11.865 align:middle line:-1
我们无法知道

00:12:11.932 --> 00:12:14.568 align:middle line:-1
处理程序参数是否可以转义

00:12:16.003 --> 00:12:21.341 align:middle line:-2
Xcode 10
现在提供了一个警告

00:12:21.708 --> 00:12:24.878 align:middle line:-2
帮助我们记住这个参数
实际上不是转义的

00:12:27.481 --> 00:12:31.151 align:middle line:-2
为了修正这个警告 你可以使用
NS_NOESCAPE注释

00:12:31.218 --> 00:12:33.587 align:middle line:-1
来注释你的块参数

00:12:34.588 --> 00:12:35.856 align:middle line:-1
你还应该用

00:12:35.923 --> 00:12:39.059 align:middle line:-2
NS_NOESCAPE注释
来注释方法的实现

00:12:39.126 --> 00:12:42.796 align:middle line:-1
或方法实现中的参数

00:12:44.164 --> 00:12:49.770 align:middle line:-2
NS_NOESCAPE注释只是
一个对程序员的提醒

00:12:50.204 --> 00:12:54.741 align:middle line:-1
以确保在执行操作方法返回后

00:12:54.808 --> 00:12:57.578 align:middle line:-1
你不存储或调用处理程序块

00:12:59.012 --> 00:13:02.316 align:middle line:-1
因此这是为了帮助你记住

00:12:59.012 --> 00:13:02.316 align:middle line:-1
因此这是为了帮助你记住

00:13:02.382 --> 00:13:07.454 align:middle line:-2
Swift和Object-C代码
之间存在这样的契约

00:13:09.990 --> 00:13:13.260 align:middle line:-2
现在第二个警告
可能对那些使用

00:13:14.228 --> 00:13:15.929 align:middle line:-1
更低级别代码并关心

00:13:15.996 --> 00:13:20.601 align:middle line:-1
结构在内存中的布局方式的人感兴趣

00:13:21.835 --> 00:13:23.470 align:middle line:-1
让我们来看看一个结构

00:13:23.770 --> 00:13:28.809 align:middle line:-2
在C语言中结构必须遵循严格的
布局和对齐规则

00:13:29.810 --> 00:13:32.679 align:middle line:-2
在这个特殊的结构中
你可以在幻灯片上看到

00:13:32.813 --> 00:13:35.916 align:middle line:-2
编译器必须在
结构的第二个和第三个字段之间

00:13:36.250 --> 00:13:39.253 align:middle line:-1
插入一个2字节的填充

00:13:40.721 --> 00:13:44.024 align:middle line:-1
有时你可能想要放松这些规则

00:13:44.124 --> 00:13:47.528 align:middle line:-2
编译器提供了一个
pragma pack指令

00:13:47.594 --> 00:13:51.965 align:middle line:-1
你可以用它来控制布局和结构的对齐

00:13:52.032 --> 00:13:54.434 align:middle line:-2
（用#PRAGMA PACK
填充结构构件）

00:13:54.501 --> 00:13:59.173 align:middle line:-2
现在这个示例中我们使用
pragma pack push 1指令

00:13:59.706 --> 00:14:03.277 align:middle line:-1
来删除这个固定的布局

00:13:59.706 --> 00:14:03.277 align:middle line:-1
来删除这个固定的布局

00:14:03.343 --> 00:14:06.280 align:middle line:-1
并确保我们的结构是紧凑的

00:14:07.347 --> 00:14:10.984 align:middle line:-1
这在序列化结构或通过网络

00:14:11.051 --> 00:14:13.654 align:middle line:-1
传输结构时非常有用

00:14:14.788 --> 00:14:19.760 align:middle line:-2
现在pragma pack通常
与push和pop指令一起使用

00:14:20.360 --> 00:14:25.465 align:middle line:-2
但是程序员很容易忘记将
pop插入到代码中

00:14:27.234 --> 00:14:29.770 align:middle line:-2
Xcode 10现在会警告那些
没有相应的

00:14:30.404 --> 00:14:34.074 align:middle line:-2
pragma pack pop
指令的代码

00:14:34.875 --> 00:14:37.511 align:middle line:-1
它会将你指向push的位置

00:14:37.578 --> 00:14:39.680 align:middle line:-2
（找到不平衡的
#PRAGMA PACK指令）

00:14:39.746 --> 00:14:41.114 align:middle line:-1
为了修复这个警告

00:14:41.315 --> 00:14:44.685 align:middle line:-1
你应该查看push指令的位置

00:14:45.285 --> 00:14:47.221 align:middle line:-1
并将pop指令

00:14:47.554 --> 00:14:50.457 align:middle line:-1
插入到代码中的相应位置

00:14:51.725 --> 00:14:55.963 align:middle line:-2
在我们的例子中我们可以在
填充结构之后直接插入pop

00:14:57.130 --> 00:14:58.732 align:middle line:-1
一旦我们这样做了

00:14:59.566 --> 00:15:03.570 align:middle line:-1
新的布局规则将只适用于填充结构

00:14:59.566 --> 00:15:03.570 align:middle line:-1
新的布局规则将只适用于填充结构

00:15:03.804 --> 00:15:07.674 align:middle line:-2
因此它们不会影响程序中的
任何其他结构

00:15:11.812 --> 00:15:17.017 align:middle line:-2
我提到的这两个新警告
在Xcode 10中默认启用

00:15:17.951 --> 00:15:22.589 align:middle line:-2
它们可以帮助你
编写更正确更健壮的代码

00:15:23.390 --> 00:15:26.627 align:middle line:-1
为了更多地讨论更正确更健壮的代码

00:15:26.860 --> 00:15:28.962 align:middle line:-1
我想请George上台

00:15:29.029 --> 00:15:29.963 align:middle line:0
他将讨论

00:15:30.030 --> 00:15:33.233 align:middle line:0
Xcode 10中
新的静态分析改进

00:15:34.101 --> 00:15:35.002 align:middle line:0
George

00:15:35.068 --> 00:15:37.070 align:middle line:0
（CLANG静态分析器）

00:15:41.508 --> 00:15:42.442 align:middle line:-1
谢谢 Alex

00:15:42.876 --> 00:15:45.546 align:middle line:-1
我想向你介绍一些

00:15:45.612 --> 00:15:49.449 align:middle line:-2
我们为Clang静态分析器
Xcode 10所做的改进

00:15:50.284 --> 00:15:52.786 align:middle line:-2
Clang静态分析器
是一个很好的工具

00:15:52.853 --> 00:15:56.490 align:middle line:-2
可以在你的程序中找到边缘案例
难以再现的漏洞

00:15:57.224 --> 00:15:59.927 align:middle line:-1
静态分析器不仅为你查找漏洞

00:16:00.227 --> 00:16:03.030 align:middle line:-1
还在列出漏洞的路径的

00:16:03.096 --> 00:16:04.932 align:middle line:-1
Xcode中显示其可视化

00:16:05.566 --> 00:16:10.604 align:middle line:-2
NSMutableArray中
添加了nil 可能在稍后导致崩溃

00:16:11.071 --> 00:16:14.274 align:middle line:-2
静态分析器向你展示了
这个崩溃的路径

00:16:14.341 --> 00:16:16.577 align:middle line:-2
这样你就可以看到
app是如何被修复的

00:16:18.045 --> 00:16:22.049 align:middle line:-2
我想告诉你们
我们所做的三项新的改进

00:16:23.083 --> 00:16:28.055 align:middle line:-2
首先我们有了一个新的检查
用来检测伟大的中央调度反模式

00:16:28.422 --> 00:16:31.692 align:middle line:-2
这可能会导致不良的性能
和挂起你的app

00:16:32.359 --> 00:16:35.729 align:middle line:-2
其次我们有一项新的检查
用于检测

00:16:35.996 --> 00:16:39.132 align:middle line:-1
动释放池中的自动释放变量的误用

00:16:39.433 --> 00:16:41.802 align:middle line:-1
这可能会导致释放后使用崩溃

00:16:42.970 --> 00:16:46.473 align:middle line:-2
最后我们改进了
Clang静态分析器的

00:16:46.540 --> 00:16:47.975 align:middle line:-1
性能和可视

00:16:49.376 --> 00:16:52.079 align:middle line:-1
那么让我们从一个

00:16:52.145 --> 00:16:54.081 align:middle line:-1
检测伟大的中央调度反模式检查开始

00:16:54.915 --> 00:16:58.852 align:middle line:-1
我们平台上的许多API都是异步的

00:16:59.186 --> 00:17:01.822 align:middle line:-1
但有时开发人员出于某种原因

00:16:59.186 --> 00:17:01.822 align:middle line:-1
但有时开发人员出于某种原因

00:17:01.889 --> 00:17:04.491 align:middle line:-1
希望以同步的方式使用它们

00:17:05.559 --> 00:17:06.693 align:middle line:-1
可能是因为他们的代码

00:17:06.760 --> 00:17:08.896 align:middle line:-1
已经在后台队列上运行了

00:17:09.496 --> 00:17:11.832 align:middle line:-1
或者是因为函数在必需的值可用之前

00:17:11.898 --> 00:17:13.934 align:middle line:-1
根本无法继续运行

00:17:14.734 --> 00:17:16.336 align:middle line:-1
而那里诱人的解决方案是

00:17:16.403 --> 00:17:19.473 align:middle line:-1
使用信号量来确保同步

00:17:20.273 --> 00:17:22.776 align:middle line:-1
这就是这个例子中的情况

00:17:23.042 --> 00:17:27.314 align:middle line:-2
所以这里有一个SXPC对象
self.connection

00:17:27.814 --> 00:17:31.685 align:middle line:-2
我们使用它的属性
remoteObjectProxy

00:17:31.885 --> 00:17:34.922 align:middle line:-1
从另一个进程异步地

00:17:35.088 --> 00:17:36.590 align:middle line:-1
获取递归任务的名称

00:17:37.558 --> 00:17:42.629 align:middle line:-2
然后我们等待一个信号量
它是回调内部的一个信号

00:17:43.297 --> 00:17:46.700 align:middle line:-1
这有助于确保在函数返回任务名时

00:17:47.434 --> 00:17:49.002 align:middle line:-1
任务名是可用的

00:17:49.770 --> 00:17:53.674 align:middle line:0
因此这种方法是可行的
但它具有一定的性能含义

00:17:54.408 --> 00:17:55.809 align:middle line:0
因此这里的主要问题是

00:17:55.876 --> 00:18:00.447 align:middle line:0
当你在某个异步进程上
等待使用信号量时

00:17:55.876 --> 00:18:00.447 align:middle line:0
当你在某个异步进程上
等待使用信号量时

00:18:00.814 --> 00:18:02.482 align:middle line:0
你可能会等待一个优先级

00:18:02.549 --> 00:18:04.852 align:middle line:0
比你的队列低得多的队列

00:18:05.118 --> 00:18:06.687 align:middle line:0
这会导致优先级反转

00:18:06.920 --> 00:18:09.289 align:middle line:0
这会恶化性能并导致挂起

00:18:10.057 --> 00:18:13.794 align:middle line:-1
而且以这种方式使用信号量

00:18:13.994 --> 00:18:17.598 align:middle line:-2
也会产生无用的线程
从而进一步降低性能

00:18:18.966 --> 00:18:21.268 align:middle line:-1
为了帮助你解决这个问题

00:18:21.435 --> 00:18:24.471 align:middle line:-1
现在静态分析器对这种情况提出警告

00:18:26.807 --> 00:18:29.076 align:middle line:-1
帮助了解问题发生的地点

00:18:29.142 --> 00:18:31.478 align:middle line:-1
（伟大的中央调度性能反模式）

00:18:31.545 --> 00:18:33.514 align:middle line:-1
现在让我们看看如何解决这个问题

00:18:34.014 --> 00:18:38.385 align:middle line:-2
在最好的情况下
有一个可供使用的同步API

00:18:38.452 --> 00:18:39.720 align:middle line:-1
可以替代使用

00:18:40.187 --> 00:18:44.491 align:middle line:-2
因此对于SXPC连接
有了一个类似的API

00:18:44.558 --> 00:18:47.127 align:middle line:-1
即synchronousRemoteObjectProxy

00:18:47.661 --> 00:18:51.164 align:middle line:-2
当使用它时
它消除了对信号量的需求

00:18:51.398 --> 00:18:53.000 align:middle line:-1
运行速度要快得多

00:18:55.135 --> 00:18:59.273 align:middle line:-1
或者如果没有这样的同步API可用

00:18:59.740 --> 00:19:03.143 align:middle line:-2
你可以重构app
以使用安装的连续程序

00:18:59.740 --> 00:19:03.143 align:middle line:-2
你可以重构app
以使用安装的连续程序

00:19:03.410 --> 00:19:06.180 align:middle line:-1
只需在回调中调用所需的函数即可

00:19:09.216 --> 00:19:11.285 align:middle line:-1
这个检查在默认情况下是不启用的

00:19:11.552 --> 00:19:14.087 align:middle line:-1
但是我们鼓励你在构建设置中启用它

00:19:14.254 --> 00:19:17.824 align:middle line:-2
以确保在你的app中
不会出现这样的问题

00:19:17.891 --> 00:19:19.560 align:middle line:-1
并尽可能快地运行

00:19:21.328 --> 00:19:23.363 align:middle line:-1
现在让我们讨论第二个检查

00:19:23.430 --> 00:19:25.866 align:middle line:-1
用于检测

00:19:25.933 --> 00:19:28.502 align:middle line:-2
比自动释放池的生命周期
更长的自动释放变量

00:19:30.404 --> 00:19:35.175 align:middle line:-2
自动释放限定符指定
一旦控件退出自动释放池

00:19:35.409 --> 00:19:37.878 align:middle line:-1
就必须释放该值

00:19:38.545 --> 00:19:42.816 align:middle line:-2
这里有一个例子
我们在自动释放池中

00:19:43.016 --> 00:19:44.451 align:middle line:-1
创建一个错误变量

00:19:44.685 --> 00:19:47.254 align:middle line:-1
一旦控件在自动释放池之外

00:19:47.321 --> 00:19:50.490 align:middle line:-1
个变量就会被释放 然后被销毁

00:19:51.058 --> 00:19:55.128 align:middle line:-2
自动释放池是
Objective-C的有用特性

00:19:55.395 --> 00:19:58.565 align:middle line:-1
它有助于控制app的大内存占用

00:19:58.632 --> 00:20:01.602 align:middle line:-1
并确保在必要时销毁临时内存

00:19:58.632 --> 00:20:01.602 align:middle line:-1
并确保在必要时销毁临时内存

00:20:03.036 --> 00:20:06.373 align:middle line:-1
然而它可能会导致意外的崩溃

00:20:07.040 --> 00:20:09.042 align:middle line:-1
而且它们更令人意外

00:20:09.109 --> 00:20:12.212 align:middle line:-2
因为你甚至不需要在app中
编写“自动释放”这个词

00:20:12.279 --> 00:20:14.681 align:middle line:-1
就可以发生这些崩溃

00:20:15.082 --> 00:20:18.318 align:middle line:-1
例如这里有一个验证函数

00:20:19.019 --> 00:20:21.588 align:middle line:-1
它接受out参数NSError

00:20:22.289 --> 00:20:23.624 align:middle line:-1
而out参数

00:20:23.690 --> 00:20:27.494 align:middle line:-2
在Objective-C中
默认为ARC

00:20:28.095 --> 00:20:32.866 align:middle line:-2
所以当我们把这个out参数
写在自动释放池中时

00:20:35.269 --> 00:20:39.206 align:middle line:-2
然后函数退出时
错误值就被释放了

00:20:39.840 --> 00:20:43.610 align:middle line:-2
如果调用者试图
读取这个错误变量的值

00:20:43.810 --> 00:20:46.747 align:middle line:-1
他们可能会释放后使用中崩溃

00:20:46.813 --> 00:20:48.849 align:middle line:-1
（OUT参数和自动存储池）

00:20:48.916 --> 00:20:50.684 align:middle line:-1
（获块中的自恢复变量）

00:20:50.751 --> 00:20:55.856 align:middle line:-2
这种模式已经很难被发现
但是当你甚至不控制

00:20:55.989 --> 00:20:58.559 align:middle line:-1
拥有自动存储池的app的部分时

00:20:58.625 --> 00:21:00.127 align:middle line:-1
这种模式会变得更糟

00:20:58.625 --> 00:21:00.127 align:middle line:-1
这种模式会变得更糟

00:21:00.694 --> 00:21:05.566 align:middle line:-2
这里有一个类似的函数
它也接受out参数错误

00:21:06.166 --> 00:21:09.837 align:middle line:-2
然后调用
一个enumerateObjectsUsingBlock

00:21:09.937 --> 00:21:12.706 align:middle line:-2
这是一个流行的
foundation API

00:21:12.773 --> 00:21:15.709 align:middle line:-1
它在集合的每个元素上调用一个块

00:21:16.476 --> 00:21:18.979 align:middle line:-1
但是enumerateObjectsUsingBlock

00:21:19.479 --> 00:21:23.550 align:middle line:-2
实际上把x称为返回的
自动释放返回池中的一个给定块

00:21:24.051 --> 00:21:25.919 align:middle line:-1
因此这里也出现了一个类似的问题

00:21:26.286 --> 00:21:30.123 align:middle line:-1
当我们在块中创建一个错误值

00:21:30.190 --> 00:21:31.925 align:middle line:-1
并将其写入out参数时

00:21:32.559 --> 00:21:34.194 align:middle line:-2
当控件到达
enumerateObjectsUsingBlock时

00:21:34.261 --> 00:21:38.131 align:middle line:-1
它实际上会被释放

00:21:39.533 --> 00:21:42.636 align:middle line:-1
然后当调用者试图阅读它时

00:21:42.803 --> 00:21:45.205 align:middle line:-1
它们也可能会释放后使用中崩溃

00:21:47.975 --> 00:21:51.044 align:middle line:-2
在此之前
我们已经介绍了编译器警告

00:21:51.378 --> 00:21:55.048 align:middle line:-1
它在块中捕获隐式自动发出的参数时

00:21:55.115 --> 00:21:56.517 align:middle line:-1
发出警告

00:21:56.984 --> 00:21:58.118 align:middle line:-1
编译器警告

00:21:58.185 --> 00:22:01.355 align:middle line:-1
建议显式地使这些参数自动发送

00:21:58.185 --> 00:22:01.355 align:middle line:-1
建议显式地使这些参数自动发送

00:22:02.089 --> 00:22:04.691 align:middle line:-2
但是我们注意到
这样的问题一直在发生

00:22:05.526 --> 00:22:07.160 align:middle line:-1
所以在Xcode 10中

00:22:07.227 --> 00:22:10.864 align:middle line:-2
我们引入了一个功能更强大的
Clang静态分析器警告

00:22:11.865 --> 00:22:14.168 align:middle line:-1
它知道哪些API

00:22:15.169 --> 00:22:17.871 align:middle line:-1
调用了自动释放池中提供的块

00:22:18.172 --> 00:22:20.073 align:middle line:-1
并对此类情况进行警告

00:22:21.108 --> 00:22:22.843 align:middle line:-2
（Xcode 10：
检查自动释放误用）

00:22:23.610 --> 00:22:25.679 align:middle line:-1
现在让我们看看如何解决这个问题

00:22:26.213 --> 00:22:27.814 align:middle line:-1
这里最简单的方法就是

00:22:28.081 --> 00:22:30.417 align:middle line:-1
引入一个强大的局部变量

00:22:31.084 --> 00:22:33.320 align:middle line:-1
然后当你在块中时

00:22:33.654 --> 00:22:36.857 align:middle line:-1
将一个值写入内部的强变量中

00:22:37.624 --> 00:22:40.194 align:middle line:-1
将一个值写入内部的强变量中

00:22:40.561 --> 00:22:42.696 align:middle line:-1
只复制到out参数

00:22:42.863 --> 00:22:45.432 align:middle line:-1
并且你知道它不在自动释放池中

00:22:45.499 --> 00:22:48.202 align:middle line:-1
因此写入自动释放变量是安全的

00:22:50.103 --> 00:22:53.140 align:middle line:-1
（改进性能和报告可视化）

00:22:53.207 --> 00:22:57.077 align:middle line:-1
最后我们还改进了

00:22:57.144 --> 00:22:58.545 align:middle line:-2
Clang静态分析器的性能
和可视化

00:22:59.580 --> 00:23:03.283 align:middle line:-2
因此在Xcode 10中
我们改进了分析器

00:22:59.580 --> 00:23:03.283 align:middle line:-2
因此在Xcode 10中
我们改进了分析器

00:23:03.350 --> 00:23:05.519 align:middle line:-1
以更有效的方式探索你的程序

00:23:05.752 --> 00:23:10.991 align:middle line:-2
现在它在相同的分析时间内
发现的漏洞比以前多出15%

00:23:12.392 --> 00:23:16.630 align:middle line:-2
它不仅发现了更多的漏洞
而且它现在生成的漏洞

00:23:17.264 --> 00:23:19.933 align:middle line:-1
报告往往更小也更容易理解

00:23:20.033 --> 00:23:23.737 align:middle line:-2
我的意思是
有时候在Xcode 10中

00:23:24.638 --> 00:23:25.739 align:middle line:-1
你会得到

00:23:25.806 --> 00:23:28.509 align:middle line:-1
很多步骤和箭头的例子

00:23:28.575 --> 00:23:30.744 align:middle line:-1
这些例子有些难以理解

00:23:31.445 --> 00:23:35.282 align:middle line:-2
在Xcode的新版本中的
许多示例中

00:23:35.849 --> 00:23:39.820 align:middle line:-2
我们提供了一个更小的错误路径
它更容易查看

00:23:39.887 --> 00:23:41.655 align:middle line:-1
你可以更快地看到问题

00:23:43.390 --> 00:23:47.261 align:middle line:-1
因此为了在项目中使用静态分析器

00:23:47.327 --> 00:23:53.734 align:middle line:-2
你可以使用产品 分析
甚至可以在构建期间启用分析

00:23:53.967 --> 00:23:56.637 align:middle line:-1
以确保分析器问题不被忽略

00:23:57.271 --> 00:23:59.573 align:middle line:-1
所以我鼓励你使用静态分析器

00:23:59.973 --> 00:24:02.409 align:middle line:-2
它是一个很好的工具
可以在用户使用之前发现你的错误

00:23:59.973 --> 00:24:02.409 align:middle line:-2
它是一个很好的工具
可以在用户使用之前发现你的错误

00:24:03.110 --> 00:24:06.980 align:middle line:0
现在我的同事Ahmed
将会讨论低水平的改进

00:24:07.047 --> 00:24:10.250 align:middle line:0
（加强安全）

00:24:10.317 --> 00:24:11.151 align:middle line:0
谢谢George

00:24:14.555 --> 00:24:18.058 align:middle line:-2
如Alex和George告诉你的
我们在编译器中有很多警告

00:24:18.125 --> 00:24:20.894 align:middle line:-1
和静态分析器检查

00:24:21.428 --> 00:24:23.197 align:middle line:-1
但是你也有杀毒软件

00:24:23.363 --> 00:24:25.432 align:middle line:-2
和所有这些工具
可以帮助你发现很多漏洞

00:24:25.499 --> 00:24:26.667 align:middle line:-1
包括安全漏洞

00:24:28.135 --> 00:24:31.238 align:middle line:0
所以我相信你们都有很多测试
并且使用所有这些工具

00:24:31.538 --> 00:24:34.374 align:middle line:0
来发现这些测试中的所有漏洞

00:24:35.008 --> 00:24:37.578 align:middle line:0
但是对于一些最恶劣的安全漏洞

00:24:38.111 --> 00:24:41.148 align:middle line:-2
如果它们以某种方式
通过了所有的测试

00:24:41.381 --> 00:24:43.517 align:middle line:-2
我们希望确保它们
不会在发布版构建中出现

00:24:45.152 --> 00:24:49.156 align:middle line:-2
因此对于那些
我们在代码生成器中有缓解的东西

00:24:49.223 --> 00:24:51.358 align:middle line:-1
即使在发布版本中我们也希望如此

00:24:52.593 --> 00:24:54.862 align:middle line:-2
我是Ahmed
我做代码生成器工作

00:24:54.962 --> 00:24:58.332 align:middle line:-2
今天我将告诉大家
Xcode 10中新的缓解措施

00:25:00.033 --> 00:25:01.001 align:middle line:-1
要了解它是如何工作的

00:25:01.068 --> 00:25:02.936 align:middle line:-1
我们就需要了解栈是如何工作的

00:25:04.972 --> 00:25:08.709 align:middle line:-2
这里我有一个简单的C函数
叫做dlog

00:25:09.309 --> 00:25:13.080 align:middle line:-2
我用它来打印
我传入dlog错误的字符串

00:25:14.781 --> 00:25:17.284 align:middle line:-2
在这种情况下
用字符串hello来调用它

00:25:18.352 --> 00:25:19.319 align:middle line:-1
它的工作方式是

00:25:19.386 --> 00:25:23.957 align:middle line:-1
我们需分配一些内存来跟踪这个调用

00:25:26.126 --> 00:25:28.996 align:middle line:-1
我们把它分配到一个叫做栈的区域

00:25:29.730 --> 00:25:33.500 align:middle line:-1
栈向空指针或地址0方向向下延伸

00:25:35.903 --> 00:25:38.172 align:middle line:-2
因此当我们执行
dlog“hello”调用时

00:25:38.705 --> 00:25:40.741 align:middle line:-1
这会分配所谓的堆栈帧

00:25:41.441 --> 00:25:43.944 align:middle line:-1
堆栈帧包含类似返回地址的内容

00:25:44.211 --> 00:25:46.480 align:middle line:-2
这样我们就知道
如何返回main

00:25:47.714 --> 00:25:50.884 align:middle line:-2
但它也包含其他东西
如参数和局部变量

00:25:51.718 --> 00:25:55.088 align:middle line:-2
因此例如
如果我有一个日志文件路径局部变量

00:25:56.056 --> 00:25:57.658 align:middle line:-1
它就驻留在堆栈框架中

00:26:00.260 --> 00:26:04.331 align:middle line:-2
如果我尝试对这个dlog文件
函数进行另一个函数调用

00:26:05.766 --> 00:26:07.901 align:middle line:-2
那么这个函数
就会分配它自己的堆栈帧

00:26:09.369 --> 00:26:12.506 align:middle line:-2
当它完成时
它将重新分配堆栈帧

00:26:12.639 --> 00:26:14.107 align:middle line:-1
并返回给调用者

00:26:16.810 --> 00:26:20.013 align:middle line:-1
现在我们更详细地看看这个堆栈框架

00:26:21.515 --> 00:26:25.385 align:middle line:-1
假设我将函数改成一个本地缓冲区

00:26:25.452 --> 00:26:27.321 align:middle line:-1
这是一个4字节的字符数组

00:26:29.790 --> 00:26:31.959 align:middle line:-1
我正在尝试通过先做一个

00:26:32.226 --> 00:26:36.530 align:middle line:-2
我传递到缓冲区中的字符串的
strcpy来准备调试字符串

00:26:38.565 --> 00:26:44.571 align:middle line:-2
strcpy来准备调试字符串
H-E-L-L

00:26:46.039 --> 00:26:49.276 align:middle line:-2
但问题是在这一点上
我们已经写了4个字节

00:26:49.877 --> 00:26:53.280 align:middle line:-2
我们已经用尽了在我们的缓冲区中
可用的所有4个字节

00:26:54.581 --> 00:26:57.184 align:middle line:-2
所以如果我们继续
这就是Strcpy所做的

00:26:57.518 --> 00:26:59.720 align:middle line:-1
那么我们将重写返回地址

00:27:01.054 --> 00:27:02.589 align:middle line:-1
这是一个很大的安全问题

00:27:02.856 --> 00:27:07.427 align:middle line:-2
如果攻击者控制了
我正在复制的字符串 这并不难

00:27:07.961 --> 00:27:09.763 align:middle line:-1
那么它可以控制返回地址

00:27:10.197 --> 00:27:11.932 align:middle line:-1
如果它能控制返回地址

00:27:11.999 --> 00:27:14.368 align:middle line:-2
那么他们就基本上控制了
程序下一步做什么

00:27:14.434 --> 00:27:15.836 align:middle line:-1
所以这是很大的安全问题

00:27:18.772 --> 00:27:21.909 align:middle line:-1
因此如果你有一个测试捕捉到了这个

00:27:22.509 --> 00:27:24.278 align:middle line:-1
并且运行了地址消毒器

00:27:24.878 --> 00:27:27.881 align:middle line:-2
那么你将有一个简单的方法
来解决这个问题

00:27:28.415 --> 00:27:30.551 align:middle line:-1
实际上 我在这里应该做的是

00:27:30.784 --> 00:27:33.420 align:middle line:-1
strncpy 它知道大小

00:27:33.854 --> 00:27:36.957 align:middle line:-2
甚至更好 使用更高级别的API
NSString或STD字符串

00:27:39.026 --> 00:27:42.229 align:middle line:-2
但是有时候这些漏洞
仍然可以在发布版构建中存活下来

00:27:43.063 --> 00:27:47.835 align:middle line:-2
我们通过使用
所谓的堆栈保护器来避免它们

00:27:49.770 --> 00:27:51.972 align:middle line:-2
栈保护器改变了堆栈框架的布局
添加一个新的字段

00:27:52.039 --> 00:27:54.007 align:middle line:-1
金丝雀

00:27:55.642 --> 00:27:57.477 align:middle line:-1
这样当我们写的时候

00:27:58.378 --> 00:28:01.715 align:middle line:-1
我们会在函数返回之前有一些代码

00:27:58.378 --> 00:28:01.715 align:middle line:-1
我们会在函数返回之前有一些代码

00:28:02.015 --> 00:28:04.117 align:middle line:-1
来检查金丝雀是否有效

00:28:06.186 --> 00:28:09.623 align:middle line:-2
所以如我们继续用strcpy来写
我们首先要覆盖金丝雀

00:28:11.491 --> 00:28:14.962 align:middle line:-1
然后在返回之前先检查金丝雀

00:28:15.696 --> 00:28:16.964 align:middle line:-1
然后就会终止

00:28:17.664 --> 00:28:21.235 align:middle line:-2
因此我们将一个潜在的
可利用的安全漏洞

00:28:21.401 --> 00:28:24.771 align:middle line:-2
转化为可靠的崩溃
这对攻击者是不利的

00:28:26.573 --> 00:28:28.642 align:middle line:-1
这就是所谓的堆栈保护器

00:28:31.545 --> 00:28:32.746 align:middle line:-1
（堆栈保护器）

00:28:32.813 --> 00:28:35.983 align:middle line:-1
它检测到某些类型的堆栈缓冲区溢出

00:28:36.049 --> 00:28:37.651 align:middle line:-1
就是我们刚才看到的攻击

00:28:38.418 --> 00:28:41.388 align:middle line:-2
在许多版本的Xcode中
它已经默认启用了

00:28:44.391 --> 00:28:47.261 align:middle line:-1
下来我要讲一个更复杂的例子

00:28:47.327 --> 00:28:49.029 align:middle line:-1
我们引入了一个新的缓解措施

00:28:50.697 --> 00:28:54.201 align:middle line:-2
假设我取了我的函数
也是我的dlog函数

00:28:55.068 --> 00:28:58.005 align:middle line:-2
我改变了缓冲区
现在它是一个可变长度的数组

00:28:59.106 --> 00:29:01.508 align:middle line:-1
长度来自一个叫做len的参数

00:28:59.106 --> 00:29:01.508 align:middle line:-1
长度来自一个叫做len的参数

00:29:04.044 --> 00:29:09.716 align:middle line:-2
假设在一个特定的调用中
len是很大的 比如15000

00:29:10.984 --> 00:29:14.054 align:middle line:-2
所以现在堆栈帧必须至少有
15000字节长

00:29:16.924 --> 00:29:19.693 align:middle line:-1
但是内存并不是立即可用的

00:29:20.127 --> 00:29:22.062 align:middle line:-1
所以内存被分成了几页

00:29:22.663 --> 00:29:25.732 align:middle line:-1
而堆栈只在需要时才增长

00:29:26.633 --> 00:29:30.804 align:middle line:-2
例如当我们试图访问
堆栈下一页中

00:29:30.871 --> 00:29:35.075 align:middle line:-2
缓冲区的10000个字节时
这仍然是不可用的

00:29:35.509 --> 00:29:37.211 align:middle line:-1
所以它在CPU中做了一个

00:29:37.277 --> 00:29:38.879 align:middle line:-1
与操作系统对话的页面错误

00:29:39.012 --> 00:29:41.915 align:middle line:-1
操作系统看到我们有权力增长堆栈

00:29:42.049 --> 00:29:44.084 align:middle line:-2
并且它增长了它
我们可以继续编写

00:29:44.918 --> 00:29:46.486 align:middle line:-1
这些都发生在引擎盖下面

00:29:49.056 --> 00:29:53.560 align:middle line:-2
但是 如果攻击者控制了长度
它使长度变得很大

00:29:53.994 --> 00:29:56.230 align:middle line:-1
大到足以跨越许多页

00:29:57.865 --> 00:29:59.199 align:middle line:-1
所以现在就有了一个新问题

00:29:59.867 --> 00:30:04.438 align:middle line:-2
内存不是无限的
所以如果我们继续在这个堆栈中分配

00:29:59.867 --> 00:30:04.438 align:middle line:-2
内存不是无限的
所以如果我们继续在这个堆栈中分配

00:30:04.505 --> 00:30:05.439 align:middle line:-1
最终我们会到达

00:30:05.506 --> 00:30:07.641 align:middle line:-1
另一个已经分配的内存区域

00:30:08.008 --> 00:30:09.343 align:middle line:-1
通常是堆

00:30:10.811 --> 00:30:13.413 align:middle line:-2
当我们这样做的时候
我们将会与堆发生冲突

00:30:13.714 --> 00:30:15.349 align:middle line:-2
与已使用的
任何东西发生冲突

00:30:15.415 --> 00:30:17.451 align:middle line:-2
这通常是像
malloc和new此类东西

00:30:20.587 --> 00:30:23.790 align:middle line:-2
如果我们试着看看
strcpy例子会发生什么

00:30:24.591 --> 00:30:27.794 align:middle line:-2
然后我们试着
把字节一个一个地写下来

00:30:30.097 --> 00:30:32.766 align:middle line:-1
我们做H-E-L等等

00:30:33.667 --> 00:30:35.502 align:middle line:-1
从CPU的角度来看

00:30:35.569 --> 00:30:37.704 align:middle line:-1
生成的代码和操作系统

00:30:37.771 --> 00:30:38.805 align:middle line:-1
这都没问题

00:30:39.006 --> 00:30:42.943 align:middle line:-2
因为我们只是在写一个已经可用的
和已经被分配的页面

00:30:44.811 --> 00:30:47.681 align:middle line:-2
但实际上并非如此
因为这是堆的一部分

00:30:47.748 --> 00:30:50.784 align:middle line:-1
这不是本地堆栈分配数组的一部分

00:30:51.552 --> 00:30:53.353 align:middle line:-2
所以当我们写东西的时候
我们实际上是在覆盖

00:30:53.420 --> 00:30:56.256 align:middle line:-1
一些完全不相关的信息

00:30:56.323 --> 00:30:59.693 align:middle line:-2
比如我不知道一个布尔值
用来检查我们是否应该检查密码

00:31:00.327 --> 00:31:02.663 align:middle line:-1
这是另一个重要的安全漏洞

00:31:06.967 --> 00:31:09.736 align:middle line:-1
这是我们用一个新特性来缓解的

00:31:10.871 --> 00:31:14.007 align:middle line:-1
这个特性是通过在函数的入口

00:31:14.474 --> 00:31:15.676 align:middle line:-1
发出些新代码来工作的

00:31:16.910 --> 00:31:20.380 align:middle line:-1
这个函数检查堆栈框架是否可以使用

00:31:21.381 --> 00:31:24.451 align:middle line:-1
所以它询问操作系统堆栈的最大空间

00:31:25.285 --> 00:31:27.821 align:middle line:-1
如果你尝试做一个大于那个的分配

00:31:27.888 --> 00:31:29.456 align:middle line:-1
那么它实际上就会终止

00:31:31.124 --> 00:31:35.028 align:middle line:-2
这将把一个潜在的
可利用的安全漏洞

00:31:35.395 --> 00:31:38.665 align:middle line:-2
变成了可靠的崩溃
这对攻击者没有好处

00:31:41.101 --> 00:31:43.670 align:middle line:-2
所以这就是堆栈检查
它检测所说的堆栈冲突

00:31:43.737 --> 00:31:46.206 align:middle line:-1
你可能听说过它

00:31:46.907 --> 00:31:48.809 align:middle line:-1
在Xcode 10中默认启用它

00:31:48.876 --> 00:31:49.877 align:middle line:-1
（堆栈检查）

00:31:49.943 --> 00:31:52.779 align:middle line:-2
（检测“堆栈冲突”
在Xcode 10中默认启用）

00:31:53.347 --> 00:31:57.384 align:middle line:-2
接下来我想谈谈我们在
Xcode 10中添的一组新特性

00:31:57.751 --> 00:32:00.787 align:middle line:-2
这就是对新扩展的支持：
设置扩展

00:31:57.751 --> 00:32:00.787 align:middle line:-2
这就是对新扩展的支持：
设置扩展

00:32:02.990 --> 00:32:06.059 align:middle line:-2
那么大家都知道
我们有很多很棒的Apple设备

00:32:06.793 --> 00:32:10.764 align:middle line:-2
Xcode的一个伟大之处在于
只要使用少量的构建设置

00:32:10.998 --> 00:32:13.467 align:middle line:-2
你就可以针对
这些设备中的每一个设定代码

00:32:15.202 --> 00:32:18.872 align:middle line:-2
因此在macOS、iOS
watchOS等等的引擎盖下

00:32:19.139 --> 00:32:24.278 align:middle line:-2
我们对每个都进行了调整
这样它就可以使用特定硬件上

00:32:24.511 --> 00:32:26.013 align:middle line:-1
所有可用的东西

00:32:26.413 --> 00:32:29.449 align:middle line:-2
因此无论我们在哪里运行
它都能保证它的最大的性能

00:32:31.185 --> 00:32:35.289 align:middle line:-2
因此如果你的app
具有极高的性能要求

00:32:35.455 --> 00:32:37.724 align:middle line:-1
这也是你可能要做的事情

00:32:39.760 --> 00:32:41.895 align:middle line:-1
因此我们有三个功能可以讨论

00:32:42.095 --> 00:32:45.332 align:middle line:-2
它们可以用在iMac Pro
和iPhone 8 Plus和X上

00:32:47.067 --> 00:32:48.569 align:middle line:-1
让我们从iMac Pro开始

00:32:51.305 --> 00:32:54.107 align:middle line:-2
iMac Pro
有Intel Xeon的CPU

00:32:55.976 --> 00:32:59.880 align:middle line:-2
它有一组名为
AVX-512的新特性

00:33:02.049 --> 00:33:05.853 align:middle line:-2
AVX-512是一组
带有矢量寄存器的新指令

00:33:08.689 --> 00:33:13.493 align:middle line:-1
这些是X86-64的好

00:33:13.627 --> 00:33:19.633 align:middle line:-2
在X86-64中 我们只能假设
我们有128位矢量可用

00:33:20.033 --> 00:33:23.837 align:middle line:-2
这在任何Mac电脑上都是可以保证的
这是 Intel提供的

00:33:25.105 --> 00:33:28.175 align:middle line:-2
现在任何新的Mac电脑
都有了更多的功能

00:33:28.742 --> 00:33:32.846 align:middle line:-2
但是iMac Pro是第一个有
512位寄存器的

00:33:35.682 --> 00:33:39.653 align:middle line:-2
在Xcode Clang中
启用了自动矢量化器

00:33:40.454 --> 00:33:43.090 align:middle line:-2
这很好
因为它意味着

00:33:43.156 --> 00:33:45.192 align:middle line:-1
我们可以在向量中有更多的元素

00:33:46.126 --> 00:33:48.228 align:middle line:-1
这样可以大大提高吞吐量

00:33:51.198 --> 00:33:53.166 align:middle line:-1
AVX-512还有其他好处

00:33:53.567 --> 00:33:57.538 align:middle line:-1
例如我们不仅有更大的向量

00:33:57.905 --> 00:33:59.239 align:middle line:-1
我们还有更多的向量

00:33:59.840 --> 00:34:03.343 align:middle line:-2
所以在X86-64上我们只有16
现在我们有32

00:33:59.840 --> 00:34:03.343 align:middle line:-2
所以在X86-64上我们只有16
现在我们有32

00:34:03.710 --> 00:34:05.412 align:middle line:-1
所以是大量的数据需要处理

00:34:07.247 --> 00:34:09.783 align:middle line:-1
即使由于某种原因自动向量器

00:34:09.850 --> 00:34:13.253 align:middle line:-1
无法使用这些向量

00:34:13.620 --> 00:34:16.290 align:middle line:-1
那么我们仍然有更多的技能寄存器

00:34:16.356 --> 00:34:18.692 align:middle line:-2
甚至对于那些只会浮动或加倍的代码
也是如此

00:34:20.127 --> 00:34:22.329 align:middle line:-1
在AVX-512中有很多性能优势

00:34:24.197 --> 00:34:26.900 align:middle line:-1
以让我们看看我们如何

00:34:27.000 --> 00:34:29.536 align:middle line:-2
利用我的计算
量大、昂贵的函数来开发它

00:34:31.772 --> 00:34:35.509 align:middle line:-2
所以我要做的第一件事就是
保留现有的功能

00:34:36.076 --> 00:34:39.880 align:middle line:-2
因为这将是我在所有Mac上
运行的可以依靠的东西

00:34:41.681 --> 00:34:43.684 align:middle line:-1
接下来我可以尝试专门化我的函数

00:34:44.217 --> 00:34:46.786 align:middle line:-1
一种方法是使用目标属性

00:34:49.188 --> 00:34:51.692 align:middle line:-2
这告诉编译器
可以假设

00:34:51.757 --> 00:34:55.395 align:middle line:-2
这个函数有AVX-512
它只运行在iMac Pro上

00:34:57.364 --> 00:35:01.735 align:middle line:-2
因此如果你使用simd.h 例如
simd_float4 128位向量类型

00:34:57.364 --> 00:35:01.735 align:middle line:-2
因此如果你使用simd.h 例如
simd_float4 128位向量类型

00:35:02.636 --> 00:35:05.572 align:middle line:-2
现在我们可以使用相同的代码
在AVX-512 版本上

00:35:05.839 --> 00:35:06.840 align:middle line:-1
获得更好的性能

00:35:09.109 --> 00:35:11.445 align:middle line:-1
如果你使用更大的向量类型

00:35:11.512 --> 00:35:13.514 align:middle line:-1
比如 simd浮点数16

00:35:13.580 --> 00:35:16.583 align:middle line:-2
那么现在你的性能要比
AVX-512版本好得多

00:35:17.117 --> 00:35:19.453 align:middle line:-2
AVX-512版本中
512位矢量实际是负的

00:35:22.022 --> 00:35:24.691 align:middle line:-1
如果你一直伸入到到X86本质

00:35:24.925 --> 00:35:27.694 align:middle line:-2
那么现在你可以开始使用新的
AVX-512方差

00:35:28.095 --> 00:35:29.796 align:middle line:-1
和M512类型

00:35:32.866 --> 00:35:35.602 align:middle line:-1
因此如果你想专攻更大的代码单元

00:35:35.669 --> 00:35:40.307 align:middle line:-2
那么不仅是单个函数
还有文件、目标、库

00:35:40.707 --> 00:35:43.577 align:middle line:-1
然后你可以使用附加向量扩展构建

00:35:43.644 --> 00:35:46.113 align:middle line:-1
设置的新的AVX-512值

00:35:46.180 --> 00:35:49.349 align:middle line:-2
（在XCODE中
启用AVX-512）

00:35:49.416 --> 00:35:51.919 align:middle line:-2
所以当你这样做的时候
有一些事情要记住

00:35:51.985 --> 00:35:56.790 align:middle line:-2
如果你熟悉AVX-1和AVX-2
这些都是非常相似的问题

00:35:56.857 --> 00:35:58.759 align:middle line:-1
（AVX-512考虑）

00:35:58.825 --> 00:36:02.629 align:middle line:-2
所以你只能从
AVX-512函数传递或

00:35:58.825 --> 00:36:02.629 align:middle line:-2
所以你只能从
AVX-512函数传递或

00:36:03.197 --> 00:36:05.265 align:middle line:-2
向AVX-512函数传递大的向量
比如256位和更大的位

00:36:05.566 --> 00:36:09.436 align:middle line:-2
因此如果ABI与
一般的和特殊的方差是不一样的话

00:36:09.770 --> 00:36:11.138 align:middle line:-1
你就不能把它们传递给它们

00:36:14.107 --> 00:36:17.144 align:middle line:-1
此外这些向量很大

00:36:17.211 --> 00:36:20.681 align:middle line:-2
而且它们足够大
以至于它们的自然对齐度太大

00:36:20.948 --> 00:36:23.083 align:middle line:-2
无法像malloc
这样的东西来保证

00:36:23.150 --> 00:36:25.786 align:middle line:-2
因此在将这些分配到
堆栈以外的任何地方时

00:36:26.353 --> 00:36:27.754 align:middle line:-1
都必须考虑到这一点

00:36:30.457 --> 00:36:32.659 align:middle line:-2
所以总的来说
所有这些都是

00:36:32.726 --> 00:36:36.196 align:middle line:-1
我们在操作系统中已经历过的

00:36:36.263 --> 00:36:39.733 align:middle line:-1
例如你可以使用加速框架

00:36:39.800 --> 00:36:41.368 align:middle line:-1
就容易多了

00:36:41.568 --> 00:36:43.871 align:middle line:-1
因为我们已经专门为每一个微架构

00:36:44.004 --> 00:36:45.739 align:middle line:-1
提供了所有的功能

00:36:48.542 --> 00:36:49.810 align:middle line:-1
这就是AVX-512

00:36:51.545 --> 00:36:56.149 align:middle line:-2
iPhone 8、8 Plus
和X都有新功能

00:36:59.286 --> 00:37:03.457 align:middle line:-2
那么第一个功能是
ARM v8.1原子

00:36:59.286 --> 00:37:03.457 align:middle line:-2
那么第一个功能是
ARM v8.1原子

00:37:04.958 --> 00:37:09.696 align:middle line:-2
这得益于iPhone X
的一个伟大的东西

00:37:10.497 --> 00:37:12.232 align:middle line:-1
这是A11 Bionic芯片

00:37:16.370 --> 00:37:22.843 align:middle line:-2
因此与A10相比
A11 Bionic芯片有很棒的新功能

00:37:23.043 --> 00:37:28.182 align:middle line:-2
它支持六个CPU
六个核心同时运行

00:37:28.949 --> 00:37:30.083 align:middle line:-1
这在iOS系统中

00:37:32.452 --> 00:37:34.288 align:middle line:-1
是第一个而且由于你有更多的内核

00:37:34.354 --> 00:37:36.823 align:middle line:-1
所以你可能同时拥有更多的线程

00:37:37.124 --> 00:37:37.991 align:middle line:-1
使用更多的线程

00:37:38.058 --> 00:37:41.328 align:middle line:-2
你可能需要更多的同步
来使这些线程协作

00:37:42.729 --> 00:37:44.498 align:middle line:-1
这是用原子实现的

00:37:45.699 --> 00:37:49.570 align:middle line:-2
A11 Bionic还引入了
一个新的原子指令系列

00:37:49.837 --> 00:37:54.808 align:middle line:-1
更好地优化了新的额外的核心

00:37:57.344 --> 00:37:58.745 align:middle line:-1
让我们来看看它是如何工作的

00:38:00.681 --> 00:38:05.085 align:middle line:-2
原子的工作方式
是通过一个小的代码序列

00:38:05.853 --> 00:38:09.489 align:middle line:-2
假设我有一个线程
它试图访问主存储器

00:38:10.424 --> 00:38:13.093 align:middle line:-1
所以它在那里有一个原子共享变量

00:38:13.694 --> 00:38:15.362 align:middle line:-1
它只是想要增加它

00:38:15.429 --> 00:38:17.431 align:middle line:-1
（原子）

00:38:17.497 --> 00:38:21.134 align:middle line:-2
因此在引擎盖下
代码生成器将发出一个小代码序列

00:38:22.002 --> 00:38:25.405 align:middle line:-2
该代码首先对高速缓存
行进行独占访问

00:38:25.939 --> 00:38:27.774 align:middle line:-1
这是完全包含

00:38:27.941 --> 00:38:30.844 align:middle line:-1
该原子变量的一个小的内存区域

00:38:33.747 --> 00:38:36.783 align:middle line:-2
现在我们拥有独占访问权
可以从变量加载

00:38:37.351 --> 00:38:40.254 align:middle line:-1
并且可以在临时加载值上进行增量

00:38:40.754 --> 00:38:42.456 align:middle line:-1
并将结果存储起来

00:38:44.825 --> 00:38:47.427 align:middle line:-2
我们知道这是安全的
因为我们有独占访问权

00:38:47.694 --> 00:38:49.930 align:middle line:-1
所以在计算临时结果时

00:38:50.030 --> 00:38:52.366 align:middle line:-1
没有其他线程可以更改值

00:38:53.934 --> 00:38:57.804 align:middle line:-2
但是现在假设有另一个线程
也要访问同一缓存行中的

00:38:57.871 --> 00:39:00.107 align:middle line:-1
相同变量或另一个变量

00:38:57.871 --> 00:39:00.107 align:middle line:-1
相同变量或另一个变量

00:39:02.709 --> 00:39:04.211 align:middle line:-1
所以两者都会尝试

00:39:04.278 --> 00:39:06.780 align:middle line:-1
对这个变量进行排他性访问

00:39:07.614 --> 00:39:10.517 align:middle line:-2
这是不可能的
这就是排他性的意思

00:39:12.219 --> 00:39:15.656 align:middle line:-1
因此它们都将无法获得独家访问权

00:39:16.557 --> 00:39:19.426 align:middle line:-2
它们将不得不再次尝试
直到其中一个成功

00:39:22.029 --> 00:39:23.730 align:middle line:-1
这对性能来说并不是好东西

00:39:25.966 --> 00:39:31.171 align:middle line:-2
因此在ARM v8.1中
它是A10 CPU中的体系结构

00:39:31.371 --> 00:39:33.974 align:middle line:-2
我们有新的指令
在一步内完成所有这些操作

00:39:34.408 --> 00:39:37.010 align:middle line:-1
在某些情况下这可以极大地提高性能

00:39:38.412 --> 00:39:41.215 align:middle line:-2
因此这也是你可以
使用每个函数专门化方法或

00:39:41.448 --> 00:39:45.986 align:middle line:-1
针对整个目标而专门化代码的东西

00:39:47.120 --> 00:39:49.122 align:middle line:-2
只有当你有自己的C11
或C++ 11原子时

00:39:49.189 --> 00:39:52.125 align:middle line:-1
它才是真正有用的东西

00:39:53.093 --> 00:39:56.697 align:middle line:-2
因此一般来说
使用更高级别的库

00:39:56.763 --> 00:39:59.533 align:middle line:-2
例如像GCD或PThread
或os_unfair_lock等容易得多

00:40:00.901 --> 00:40:03.070 align:middle line:-2
这些已经对
ARM v8.1进行了调整

00:40:03.303 --> 00:40:05.506 align:middle line:-1
但它们也与操作系统合作

00:40:05.606 --> 00:40:07.107 align:middle line:-1
以获得更好的性能

00:40:11.144 --> 00:40:15.349 align:middle line:-2
A11 CPU的另一个特性是
16位浮点数

00:40:16.250 --> 00:40:20.587 align:middle line:-1
大家都很熟悉两种标准的浮点类型

00:40:20.654 --> 00:40:22.956 align:middle line:-1
所以我们有两者64位

00:40:23.290 --> 00:40:24.958 align:middle line:-1
和浮点32位

00:40:26.093 --> 00:40:29.897 align:middle line:-2
所以在A11中我们也有
16位浮点数16

00:40:30.931 --> 00:40:37.104 align:middle line:-2
它的范围和精度都要小得多
所以它在很多情况下都不那么有用

00:40:38.038 --> 00:40:39.339 align:middle line:-1
但在某些情况下 比如机器学习

00:40:39.406 --> 00:40:41.441 align:middle line:-2
或当你试图通过Metal
与GPU交谈时

00:40:41.608 --> 00:40:44.378 align:middle line:-2
这是很棒的
因为它更小 计算更快

00:40:45.445 --> 00:40:47.714 align:middle line:-2
如果把它们放到向量中
这就更对了

00:40:47.948 --> 00:40:50.450 align:middle line:-2
在此你可以把它们更多的放在
同一个ARM向量中

00:40:53.353 --> 00:40:55.956 align:middle line:-1
因此这也是你可以专门化代码的东西

00:40:56.890 --> 00:40:59.826 align:middle line:-1
一般来说需要记住的是

00:41:00.494 --> 00:41:02.429 align:middle line:-1
这些特性并不是随处可见的

00:41:03.463 --> 00:41:06.533 align:middle line:-2
因此当你想使用它们时
必须始终确保它们

00:41:06.600 --> 00:41:08.569 align:middle line:-2
在运行的设备上是动态可用的
并且可以使用

00:41:08.635 --> 00:41:09.937 align:middle line:-1
sysctlbyname

00:41:10.337 --> 00:41:12.239 align:middle line:-1
来实现

00:41:12.306 --> 00:41:14.074 align:middle line:-1
（检测指令集扩展）

00:41:14.141 --> 00:41:16.577 align:middle line:-2
因此总的来说
我们已经在

00:41:16.643 --> 00:41:18.946 align:middle line:-2
系统框架中完成了所有工作
靠这些就更容易了

00:41:21.849 --> 00:41:24.084 align:middle line:-1
这是三个新的指令集扩展

00:41:24.484 --> 00:41:26.320 align:middle line:-2
在iMac Pro
AVX-512上

00:41:26.386 --> 00:41:30.824 align:middle line:-2
在iPhone X、8和8 Plus上
我们有原子和16位浮点数

00:41:30.891 --> 00:41:33.360 align:middle line:-1
（新指令集扩展）

00:41:33.827 --> 00:41:36.563 align:middle line:-2
这就是Xcode中
所有新特性的一部分

00:41:37.264 --> 00:41:41.668 align:middle line:-2
所以从C结构的ARC对象指针
到改进的静态分析器

00:41:41.969 --> 00:41:43.837 align:middle line:-2
Xcode 10中
有很多很棒的东西

00:41:45.005 --> 00:41:47.174 align:middle line:-1
还有一些我们甚至没有讨论过的东西

00:41:47.441 --> 00:41:49.610 align:middle line:-1
比如超过100个新的警告

00:41:49.810 --> 00:41:53.614 align:middle line:-1
支持C++ 17标准库函数

00:41:55.782 --> 00:41:57.284 align:middle line:-1
如果你想了解更多

00:41:57.351 --> 00:42:00.487 align:middle line:-2
我们将很快有视频和幻灯片
在网站上提供

00:41:57.351 --> 00:42:00.487 align:middle line:-2
我们将很快有视频和幻灯片
在网站上提供

00:42:01.088 --> 00:42:04.424 align:middle line:-2
如果你出席了本场会议
今天下午和我们一起去实验室吧

00:42:04.892 --> 00:42:05.893 align:middle line:-1
谢谢大家
