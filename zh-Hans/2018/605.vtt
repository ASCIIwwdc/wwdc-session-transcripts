WEBVTT

00:00:17.484 --> 00:00:21.822 align:middle line:0
（在SwiftShot内
创建增强现实游戏）

00:00:21.889 --> 00:00:23.123 align:middle line:0
（演讲605）

00:00:29.530 --> 00:00:33.233 align:middle line:-2
大家好 我是Alex 我是
Apple工具基础小组的一名员工

00:00:33.300 --> 00:00:36.403 align:middle line:-2
通常我们会做一些有意思的东西
比如操作系统和编译器

00:00:36.803 --> 00:00:38.739 align:middle line:-1
但今年我们做了一些不同的东西

00:00:38.972 --> 00:00:40.641 align:middle line:-2
我们创建了一个叫做
SwiftShot的游戏

00:00:41.041 --> 00:00:45.179 align:middle line:-2
有些人可能在今天早些时候见过它了
你可能在楼下玩过这个游戏了

00:00:46.213 --> 00:00:48.849 align:middle line:-1
但重要的部分是SwiftShot

00:00:48.916 --> 00:00:52.352 align:middle line:-2
是ARKit中一些新功能的
一个展示

00:00:53.053 --> 00:00:56.990 align:middle line:-2
ARKit 2现在可在
成千上万台设备上可用了

00:00:57.558 --> 00:01:00.727 align:middle line:-1
提供了一个增强AR体验的平台

00:00:57.558 --> 00:01:00.727 align:middle line:-1
提供了一个增强AR体验的平台

00:01:01.161 --> 00:01:04.197 align:middle line:-1
你可以通过它实现尽可能多的观众

00:01:04.864 --> 00:01:06.033 align:middle line:-1
并没有什么特别的设置

00:01:06.533 --> 00:01:10.003 align:middle line:-2
只是把设备的摄像头指向
某个表面然后就开始游戏

00:01:12.072 --> 00:01:13.841 align:middle line:-1
它已经集成到iOS中

00:01:14.875 --> 00:01:17.945 align:middle line:-2
第一方和第三方引擎 比如
SceneKit和SpriteKit

00:01:18.278 --> 00:01:21.481 align:middle line:-2
以及第三方
比如Unreal和Unity

00:01:22.115 --> 00:01:23.884 align:middle line:-1
在这点上都是完全集成

00:01:28.689 --> 00:01:29.756 align:middle line:-1
这是一个演讲概述

00:01:30.123 --> 00:01:32.492 align:middle line:-1
首先我们要讲一些游戏设计原则

00:01:32.559 --> 00:01:35.762 align:middle line:-2
针对增强现实
是我们在开发过程中学到的东西

00:01:36.864 --> 00:01:40.601 align:middle line:-1
我们要深入到内部 特别是

00:01:40.667 --> 00:01:43.837 align:middle line:-2
要讲到WorldMap分享
它是ARKit 2中的新功能

00:01:44.505 --> 00:01:47.875 align:middle line:-2
我们还要讲网络和物理
以及我们要如何使用它们

00:01:49.109 --> 00:01:52.145 align:middle line:-2
首先让我们 你知道的
深入了解一下游戏

00:02:25.879 --> 00:02:30.918 align:middle line:-1
（胜利！）

00:02:31.685 --> 00:02:32.519 align:middle line:-1
好的

00:02:34.488 --> 00:02:37.724 align:middle line:-2
让我们稍微讲一下
针对增强现实设计游戏

00:02:40.460 --> 00:02:43.163 align:middle line:-1
游戏设置高于一切

00:02:45.032 --> 00:02:46.900 align:middle line:-2
你该问自己
如果你正在设计一款游戏

00:02:46.967 --> 00:02:51.939 align:middle line:-2
如果它只是70年代的图形
或平面、灰色的方块

00:02:52.005 --> 00:02:55.475 align:middle line:-1
这个游戏会有意思和令人兴奋吗？

00:02:56.343 --> 00:02:59.513 align:middle line:-1
值得用那种插图来设计原型

00:03:00.180 --> 00:03:02.082 align:middle line:-1
搞定游戏设置

00:03:02.149 --> 00:03:04.551 align:middle line:-2
因为如果那些无聊的灰色方框
有意思的话

00:03:04.852 --> 00:03:07.454 align:middle line:-2
那么当你稍后添加这些图形
和声音时也会很有意思

00:03:08.922 --> 00:03:10.724 align:middle line:-1
你应该花点时间改良一下

00:03:10.791 --> 00:03:14.928 align:middle line:-2
不要说服你自己说
如果我只增加5%的图形

00:03:14.995 --> 00:03:17.798 align:middle line:-2
或者哪一个功能
游戏就会突然变得有意思了

00:03:18.465 --> 00:03:20.734 align:middle line:-1
因为你知道的有许多被遗弃的游戏

00:03:20.801 --> 00:03:22.803 align:middle line:-1
从一开始就一点儿意思都没有

00:03:22.870 --> 00:03:24.938 align:middle line:-1
因此请不要尝试愚弄你自己

00:03:27.040 --> 00:03:28.242 align:middle line:-1
让我们从游戏设置开始

00:03:31.445 --> 00:03:32.613 align:middle line:-1
保持游戏简短

00:03:34.014 --> 00:03:36.650 align:middle line:-1
你正在寻找一个典型的移动设备体验

00:03:37.284 --> 00:03:38.552 align:middle line:-1
轻松进入 轻松退出

00:03:41.455 --> 00:03:46.293 align:middle line:-2
你想保留各种各样的内容
新鲜、避免心理疲劳

00:03:46.360 --> 00:03:49.196 align:middle line:-2
就游戏玩家而言
他们不想一遍一遍地重复同一件事

00:03:52.332 --> 00:03:54.701 align:middle line:-2
我们所了解到的其中一件事就是
观看游戏看起来

00:03:54.768 --> 00:03:56.203 align:middle line:-1
跟玩游戏一样有意思

00:03:56.503 --> 00:03:59.106 align:middle line:-2
坐在场外并观看游戏
就像它是一场运动比赛

00:03:59.173 --> 00:04:00.340 align:middle line:-1
从这边到那边

00:03:59.173 --> 00:04:00.340 align:middle line:-1
从这边到那边

00:04:00.974 --> 00:04:03.510 align:middle line:-1
那就是一种很愉悦的体验

00:04:03.977 --> 00:04:04.978 align:middle line:-1
你们需要思考这一点

00:04:07.814 --> 00:04:10.717 align:middle line:-1
游戏是社交和私人互动的关键形式

00:04:12.619 --> 00:04:16.055 align:middle line:-1
增强现实可以提供一种私人触碰

00:04:16.490 --> 00:04:19.793 align:middle line:-2
你以前可能有过这种感觉
在玩比如说传统卡牌游戏时

00:04:19.860 --> 00:04:21.562 align:middle line:-1
和家里的长辈一起围在桌子旁边

00:04:22.029 --> 00:04:25.666 align:middle line:-2
但现在有一种技术
可以帮助你改善这种体验

00:04:29.036 --> 00:04:33.707 align:middle line:-2
做一个3D游戏并把它放在
你面前的桌子上还远远不够

00:04:34.374 --> 00:04:37.077 align:middle line:-2
通过增强现实
你知道设备是如何放置的

00:04:37.644 --> 00:04:40.514 align:middle line:-1
你还对用户的环境有了一些了解

00:04:40.881 --> 00:04:43.116 align:middle line:-1
你应该尝试在游戏中利用这一点

00:04:43.183 --> 00:04:46.620 align:middle line:-2
并营造一种
以增强现实为首要的良好体验

00:04:52.192 --> 00:04:56.163 align:middle line:-2
你的设备可以用作一个摄像头
用于查看聚焦对象的内部

00:04:57.064 --> 00:04:59.600 align:middle line:-1
在本例中 这是一个3D解谜游戏

00:04:59.666 --> 00:05:02.135 align:middle line:-1
我们想修复一个坏掉的花瓶

00:04:59.666 --> 00:05:02.135 align:middle line:-1
我们想修复一个坏掉的花瓶

00:05:02.202 --> 00:05:03.370 align:middle line:-1
我们可以四处查看

00:05:03.670 --> 00:05:06.607 align:middle line:-2
了解哪个碎片在哪里
并尽我们最大努力进行修复

00:05:07.574 --> 00:05:09.676 align:middle line:-2
在SwiftShot中
用了类似概念

00:05:10.010 --> 00:05:13.380 align:middle line:-2
重点是你正在玩游戏的桌子
并且你可以在桌子周围四处走动

00:05:13.947 --> 00:05:17.384 align:middle line:-2
但桌子并不只是用于
增强现实的一个追踪表面

00:05:17.451 --> 00:05:18.952 align:middle line:-1
它是游戏设置不可分割的部分

00:05:19.920 --> 00:05:23.891 align:middle line:-1
桌子的高度实际上很重要

00:05:23.957 --> 00:05:26.994 align:middle line:-2
因此你会在游戏中
看到有不同高度的弹弓

00:05:27.060 --> 00:05:31.465 align:middle line:-2
在砖堆顶部
以便给你提供更好的射击

00:05:31.532 --> 00:05:34.735 align:middle line:-1
或稍微利用一下玩家的闪避和穿梭

00:05:37.771 --> 00:05:41.408 align:middle line:-2
另一个原则是你的设备即是
你用来四处查看的摄像机

00:05:43.343 --> 00:05:44.211 align:middle line:-1
在本例中

00:05:46.246 --> 00:05:48.115 align:middle line:-1
我们要寻找藏在荒野中的独角兽

00:05:48.348 --> 00:05:50.817 align:middle line:-1
并且我们会给它们拍照片

00:05:53.387 --> 00:05:55.622 align:middle line:-1
它们就在你周围而非里面

00:06:00.060 --> 00:06:02.729 align:middle line:-2
设备还可以是
进入另一个时空的大门

00:06:02.963 --> 00:06:05.332 align:middle line:-1
你不需要直接看摄像机所看到的东西

00:06:06.333 --> 00:06:08.168 align:middle line:-1
可以彻底替换你所处的环境

00:06:08.535 --> 00:06:11.538 align:middle line:-1
可能会打破或完全修改物理定律

00:06:12.272 --> 00:06:13.740 align:middle line:-2
无论你需做什么
要让它有意思

00:06:14.208 --> 00:06:16.977 align:middle line:-2
在本例中 我们可以看到星星
即使在白天也很亮

00:06:21.381 --> 00:06:23.450 align:middle line:-1
同时 你的设备自身就可以是控制器

00:06:26.019 --> 00:06:28.355 align:middle line:-1
你可以让自己融合到虚拟世界中

00:06:29.022 --> 00:06:30.591 align:middle line:-1
把设备作为控制器

00:06:30.858 --> 00:06:34.494 align:middle line:-1
在这个例子中 我们用磁力拿起砖头

00:06:34.561 --> 00:06:35.896 align:middle line:-1
并把它们放在立方体中

00:06:36.663 --> 00:06:38.632 align:middle line:-2
这就是SwiftShot中
交互作用的重点

00:06:39.766 --> 00:06:42.102 align:middle line:-1
你想鼓励设备进行缓慢的移动

00:06:42.903 --> 00:06:45.606 align:middle line:-2
那就会给相机提供最佳图像
而不是运动模糊的图像

00:06:45.672 --> 00:06:47.274 align:middle line:-1
然后就能在追踪时做到最好

00:06:48.709 --> 00:06:51.211 align:middle line:-1
不管这些设备有多么细、多么轻

00:06:51.879 --> 00:06:54.681 align:middle line:-2
用手臂的力量四处摇晃它们
看起来会有些累

00:06:54.748 --> 00:06:56.917 align:middle line:-1
因此你要寻找慢并且从容的动作

00:06:59.786 --> 00:07:02.089 align:middle line:-1
你想鼓励玩家在场地四周移动

00:06:59.786 --> 00:07:02.089 align:middle line:-1
你想鼓励玩家在场地四周移动

00:07:02.623 --> 00:07:05.526 align:middle line:-1
在本例中 我们对敌人的弹弓射击

00:07:05.592 --> 00:07:07.394 align:middle line:-1
被那些砖块阻碍了

00:07:07.995 --> 00:07:10.397 align:middle line:-1
所以我们要移动到另一个弹弓处

00:07:10.631 --> 00:07:11.865 align:middle line:-1
清除障碍

00:07:19.339 --> 00:07:21.275 align:middle line:-1
控制反馈对于沉浸式体验来说很重要

00:07:22.943 --> 00:07:26.613 align:middle line:-2
在SwiftShot中
我们通过音频和触觉来提供反馈

00:07:27.548 --> 00:07:31.818 align:middle line:-2
有各种各样的动态行为
手机上有拉伸弹弓带的声音

00:07:32.452 --> 00:07:36.957 align:middle line:-2
和触觉效果
给你一种你正在打弹弓的感觉

00:07:37.391 --> 00:07:40.127 align:middle line:-1
我们稍后再具体讲动态音频

00:07:43.263 --> 00:07:45.832 align:middle line:-2
接下来我要邀请
David Paschich上台

00:07:45.899 --> 00:07:48.235 align:middle line:-2
他会深入讲解SwiftShot
具体信息 谢谢

00:07:50.237 --> 00:07:51.071 align:middle line:-1
David？

00:07:54.074 --> 00:07:55.542 align:middle line:-1
谢谢Alex 大家好

00:07:56.977 --> 00:08:00.347 align:middle line:-2
我只是想重复一下
Alex刚才所说的内容

00:07:56.977 --> 00:08:00.347 align:middle line:-2
我只是想重复一下
Alex刚才所说的内容

00:08:00.414 --> 00:08:02.983 align:middle line:-2
我们从参加SwiftShot演讲的人那儿
得到的响应是非常令人吃惊的

00:08:03.050 --> 00:08:06.386 align:middle line:-1
我们看到有些人已经下载它

00:08:06.453 --> 00:08:08.488 align:middle line:-2
创建它和用示例代码替换它
我们很欣慰

00:08:08.555 --> 00:08:10.991 align:middle line:-1
那么谢谢大家 我们真的非常激动

00:08:11.925 --> 00:08:15.162 align:middle line:-1
我首先想要谈谈

00:08:15.229 --> 00:08:16.230 align:middle line:-1
用于创建SwiftShot的技术

00:08:17.064 --> 00:08:18.799 align:middle line:-2
第一个也是最重要的一个
是ARKit

00:08:19.132 --> 00:08:21.869 align:middle line:-2
可以让我们把内容
渲染到玩家周围的物理世界中

00:08:21.935 --> 00:08:24.571 align:middle line:-1
让他们沉浸到游戏体验中

00:08:26.640 --> 00:08:31.612 align:middle line:-2
我们用SceneKit来管理
和绘制内容 用高级3D渲染

00:08:31.678 --> 00:08:33.580 align:middle line:-1
和现实物理来实现有趣的游戏设置

00:08:35.148 --> 00:08:39.586 align:middle line:-2
Metal可以让我们更好地利用
GPU设备

00:08:39.653 --> 00:08:43.924 align:middle line:-2
它在SceneKit内
用于着色和渲染

00:08:43.991 --> 00:08:47.361 align:middle line:-1
也用于旗子模拟 我稍后会讲到

00:08:48.829 --> 00:08:51.465 align:middle line:-2
GameplayKit
给我们的游戏对象

00:08:51.865 --> 00:08:52.699 align:middle line:-1
提供了组件架构实体

00:08:52.766 --> 00:08:55.869 align:middle line:-2
它让我们在游戏的对象之间
轻松地分享行为

00:08:57.671 --> 00:09:00.541 align:middle line:-1
多点连通提供了网络层

00:08:57.671 --> 00:09:00.541 align:middle line:-1
多点连通提供了网络层

00:09:01.208 --> 00:09:04.144 align:middle line:-1
包括发现周围的设备和同步

00:09:04.711 --> 00:09:06.113 align:middle line:-1
以及加密

00:09:07.581 --> 00:09:10.684 align:middle line:-2
AV Foundation
既控制音乐气氛

00:09:10.751 --> 00:09:13.020 align:middle line:-1
又给设备提供声音效果

00:09:13.086 --> 00:09:15.022 align:middle line:-1
真的给你营造了那种沉浸式体验

00:09:16.089 --> 00:09:18.959 align:middle line:-2
最后我们在Swift中
创建了完整的app

00:09:19.393 --> 00:09:22.329 align:middle line:-1
Swift的键入安全性、性能

00:09:24.031 --> 00:09:26.466 align:middle line:-1
和高级功能 比如协议扩展

00:09:26.533 --> 00:09:28.235 align:middle line:-1
可以让我们更多地关注游戏设置

00:09:28.302 --> 00:09:29.903 align:middle line:-1
不那么担心崩溃

00:09:29.970 --> 00:09:32.239 align:middle line:-1
和代码层之间的界面不匹配

00:09:35.309 --> 00:09:37.177 align:middle line:-1
那就是我们所使用的iOS技术

00:09:37.578 --> 00:09:38.946 align:middle line:-1
谈谈我们如何使用这些技术

00:09:39.012 --> 00:09:41.348 align:middle line:-1
帮助我们实施游戏中的某些功能

00:09:41.782 --> 00:09:44.051 align:middle line:-1
建立共享坐标空间、

00:09:44.751 --> 00:09:48.922 align:middle line:-1
网络、物理、资产重要性和管理

00:09:49.756 --> 00:09:52.125 align:middle line:-1
旗子模拟和动态音频

00:09:55.162 --> 00:09:58.098 align:middle line:-1
我们要从设置共享坐标空间开始讲

00:09:59.466 --> 00:10:02.569 align:middle line:-2
游戏体验的关键因素是让玩家
看到同一个空间中的同一个对象

00:09:59.466 --> 00:10:02.569 align:middle line:-2
游戏体验的关键因素是让玩家
看到同一个空间中的同一个对象

00:10:02.636 --> 00:10:04.471 align:middle line:-1
在各自的设备上

00:10:04.838 --> 00:10:07.374 align:middle line:-1
为此我们需要一个共享坐标空间

00:10:07.975 --> 00:10:11.445 align:middle line:-2
允许他们以跟现实世界中
相同的方式谈论位置信息

00:10:13.647 --> 00:10:16.750 align:middle line:-2
ARKit提供了一系列
可用于设置这个的功能

00:10:17.384 --> 00:10:20.854 align:middle line:-2
在iOS 11.3中
我们引入了图像识别

00:10:20.921 --> 00:10:23.423 align:middle line:-1
允许你的app识别你周围的图像

00:10:24.758 --> 00:10:28.262 align:middle line:-2
现在在iOS 12中
我们添加了两个额外的技术：

00:10:28.529 --> 00:10:31.031 align:middle line:-1
对象检测和世界地图共享

00:10:32.332 --> 00:10:34.768 align:middle line:-1
图像检测和对象检测

00:10:34.835 --> 00:10:37.871 align:middle line:-2
都可以让你针对用户在现实世界中
看到的东西添加内容

00:10:37.938 --> 00:10:41.208 align:middle line:-2
但它们要求你必须对这些对象
进行预录 用于稍后的识别

00:10:41.675 --> 00:10:43.777 align:middle line:-1
你可在Lego演示的演讲稿中看到

00:10:43.844 --> 00:10:46.046 align:middle line:-1
识别建造模型和添加内容

00:10:48.015 --> 00:10:50.851 align:middle line:-2
对于这款游戏 我们想让用户
在有桌子的任何地方玩游戏

00:10:50.918 --> 00:10:52.853 align:middle line:-1
比如咖啡馆、他们的厨房等等

00:10:53.120 --> 00:10:54.588 align:middle line:-2
我们的实现方式是
WorldMap共享

00:10:55.689 --> 00:10:58.492 align:middle line:-2
你还可以在游戏以外的app中
app此技术

00:10:58.559 --> 00:11:01.728 align:middle line:-2
比如在零售环境
或博物馆中的固定安装

00:10:58.559 --> 00:11:01.728 align:middle line:-2
比如在零售环境
或博物馆中的固定安装

00:11:02.763 --> 00:11:06.400 align:middle line:-2
楼下游戏室内 我们用了
iBeacon 因此设备就知道

00:11:06.466 --> 00:11:11.772 align:middle line:-2
它们相邻的桌子是哪个并为该区域
加载正确的WorldMap

00:11:12.272 --> 00:11:14.007 align:middle line:-1
那真的会让体验变得很魔幻

00:11:16.577 --> 00:11:17.911 align:middle line:-1
SwiftShot的一个特性

00:11:17.978 --> 00:11:19.746 align:middle line:-2
你可能用过
如果你自己创建过app

00:11:19.813 --> 00:11:24.451 align:middle line:-2
即允许玩家把游戏板
放在虚拟世界中的能力

00:11:24.885 --> 00:11:27.354 align:middle line:-2
在楼下的桌子上
我们使用了预加载地图

00:11:27.421 --> 00:11:29.756 align:middle line:-2
但这里有一个例子
关于创建你自己的游戏板

00:11:29.823 --> 00:11:31.425 align:middle line:-1
并把它放在虚拟世界中

00:11:33.894 --> 00:11:35.028 align:middle line:-1
这是如何创建

00:11:36.029 --> 00:11:38.799 align:middle line:-2
正如你在视频中所看到的
你从扫描表面开始

00:11:38.866 --> 00:11:40.934 align:middle line:-1
让ARKit创建该区域的地图

00:11:42.603 --> 00:11:44.872 align:middle line:-1
然后你可以把那个地图序列化为数据

00:11:44.938 --> 00:11:46.507 align:middle line:-1
并把它转换到另一台设备上

00:11:47.975 --> 00:11:51.178 align:middle line:-2
目标设备就会把地图加载到
ARKit中并使用它

00:11:51.245 --> 00:11:52.880 align:middle line:-1
来识别同一个表面

00:11:53.247 --> 00:11:56.416 align:middle line:-2
在那点上
我们拥有现实世界中的共享基准点

00:11:56.483 --> 00:12:00.687 align:middle line:-2
两台设备都可以把游戏板
渲染到那个世界中的同一个位置

00:11:56.483 --> 00:12:00.687 align:middle line:-2
两台设备都可以把游戏板
渲染到那个世界中的同一个位置

00:12:02.856 --> 00:12:04.458 align:middle line:-1
实施的第一个步骤

00:12:04.525 --> 00:12:07.294 align:middle line:-2
从第一台设备上的
ARSession中获取世界地图

00:12:08.161 --> 00:12:12.866 align:middle line:0
这就是iOS 12在ARSession中
对一个新API的调用 getCurrentWorldMap

00:12:13.367 --> 00:12:15.135 align:middle line:0
它创建了一个
ARWorldMap对象

00:12:15.202 --> 00:12:17.771 align:middle line:0
根据会话当前对你周围世界的了解

00:12:18.172 --> 00:12:20.340 align:middle line:0
然后把它返回到一个异步回调中

00:12:20.941 --> 00:12:22.776 align:middle line:0
然后我们使用
NSKeyedArchiver

00:12:23.677 --> 00:12:25.879 align:middle line:0
把它序列化为数据对象

00:12:26.380 --> 00:12:28.882 align:middle line:0
然后你可以保存数据
或把它发送到网络上

00:12:31.585 --> 00:12:33.187 align:middle line:-1
一旦你拥有那个数据对象

00:12:33.520 --> 00:12:36.056 align:middle line:-2
然后你要决定如何把它
从一台设备转到另台设备上

00:12:36.557 --> 00:12:39.026 align:middle line:-2
对于特设游戏
比如你在视频中看到的游戏

00:12:39.459 --> 00:12:41.595 align:middle line:-2
SwiftShot使用
点对点网络连接

00:12:41.662 --> 00:12:43.497 align:middle line:-1
我们会在立刻获得更多细节

00:12:44.565 --> 00:12:46.567 align:middle line:-1
当第二胎设备连接到网络会话中时

00:12:47.000 --> 00:12:50.370 align:middle line:-2
第一台设备序列化WorldMap
并把它发送到网络上

00:12:50.838 --> 00:12:52.806 align:middle line:-1
这对于博弈游戏的情况来说很棒

00:12:52.873 --> 00:12:56.243 align:middle line:-2
用户在任何拥有一个表面的地方
都能玩游戏

00:12:58.846 --> 00:13:01.615 align:middle line:-2
对于楼下的游戏桌而言
我们用了一个不同的方式

00:12:58.846 --> 00:13:01.615 align:middle line:-2
对于楼下的游戏桌而言
我们用了一个不同的方式

00:13:01.682 --> 00:13:04.384 align:middle line:-1
我们在设置期间花了一些时间

00:13:04.451 --> 00:13:06.520 align:middle line:-2
让大会录制每张桌子的
WorldMap

00:13:06.954 --> 00:13:08.322 align:middle line:-1
确保我们从多角度本地化

00:13:08.388 --> 00:13:10.591 align:middle line:-1
那个共享坐标空间

00:13:11.191 --> 00:13:13.327 align:middle line:-1
每张桌子都有自己的唯一特性

00:13:13.393 --> 00:13:16.063 align:middle line:-1
并且灯光和位置都稍微有点不一样

00:13:17.030 --> 00:13:19.833 align:middle line:-2
然后我们把文件保存到
每台设备上的本地存储中

00:13:20.634 --> 00:13:23.270 align:middle line:-2
因为使用中的设备
是由我们的会议团队管理的

00:13:23.337 --> 00:13:25.405 align:middle line:-1
我们可以使用移动设备管理

00:13:25.472 --> 00:13:30.878 align:middle line:-2
来确保同样的文件
出现在游戏中的每台设备上

00:13:32.546 --> 00:13:36.450 align:middle line:-2
要让方案更加流畅
你在每台桌子上使用iBeacon

00:13:36.717 --> 00:13:40.721 align:middle line:-2
通过用特定的WorldMap
关联iBeacon的标识符

00:13:40.787 --> 00:13:42.890 align:middle line:-2
SwiftShot app
的每个实例

00:13:42.956 --> 00:13:44.858 align:middle line:-2
都可自动加载正确的
WorldMap

00:13:45.626 --> 00:13:49.463 align:middle line:-2
现在如果你正在创建一个消费者app
你也可以使用

00:13:49.763 --> 00:13:52.966 align:middle line:-1
像iOS的按需资源一样的东西

00:13:53.033 --> 00:13:56.770 align:middle line:-2
或你自己的云共享方案
在设备间共享WorldMap

00:13:57.171 --> 00:14:00.474 align:middle line:-2
这将允许你
比如说选择正确的WorldMap

00:13:57.171 --> 00:14:00.474 align:middle line:-2
这将允许你
比如说选择正确的WorldMap

00:14:00.541 --> 00:14:03.477 align:middle line:-1
针对世界上的某个特定的零售位置

00:14:04.311 --> 00:14:06.213 align:middle line:-1
这里真的有很多的可能性

00:14:06.280 --> 00:14:08.982 align:middle line:-2
可以剪裁用户的体验
并创建一些真正很棒的体验

00:14:12.152 --> 00:14:14.521 align:middle line:-2
那些是获取
WorldMap数据的一些方式

00:14:14.588 --> 00:14:15.856 align:middle line:-1
从一台设备到另一台设备

00:14:16.356 --> 00:14:19.259 align:middle line:-2
让我们谈谈
你要如何在第二台设备上加载它

00:14:19.860 --> 00:14:21.995 align:middle line:-2
在本例中 我们使用了
NSKeyUnarchiveder

00:14:22.496 --> 00:14:27.034 align:middle line:-2
来重新加载WorldMap
根据我们所接收的数据

00:14:28.202 --> 00:14:30.838 align:middle line:-2
然后我们创建了一个
ARWorldTracking配置

00:14:31.171 --> 00:14:34.074 align:middle line:-2
并把WorldMap
添加到那个配置对象中

00:14:34.141 --> 00:14:35.576 align:middle line:-1
按照我们希望的方式设置

00:14:36.777 --> 00:14:39.046 align:middle line:-1
最后 我们请求ARSession

00:14:39.112 --> 00:14:43.750 align:middle line:-2
运行那个配置
重新设置现有的锚点并追踪

00:14:44.918 --> 00:14:48.755 align:middle line:-2
然后目标设备上的ARKit
就开始扫描你周围的世界

00:14:48.822 --> 00:14:51.592 align:middle line:-1
从原始地图中关联这些功能点

00:14:52.659 --> 00:14:53.994 align:middle line:-1
通过它在那看到的那些东西

00:14:54.061 --> 00:14:55.562 align:middle line:-1
一旦可以这么做了

00:14:55.629 --> 00:14:57.397 align:middle line:-1
你就得到了那个共享坐标空间

00:14:57.664 --> 00:15:01.235 align:middle line:-2
两台设备上的000
都在现实世界中的同一个位置

00:14:57.664 --> 00:15:01.235 align:middle line:-2
两台设备上的000
都在现实世界中的同一个位置

00:15:04.137 --> 00:15:06.240 align:middle line:-1
快速提一下WorldMap隐私权

00:15:06.807 --> 00:15:08.475 align:middle line:-1
在录制WorldMap的过程中

00:15:08.942 --> 00:15:11.311 align:middle line:-1
我们考虑到了你周围世界的特征

00:15:11.378 --> 00:15:13.881 align:middle line:-1
对象的物理排列等等

00:15:14.982 --> 00:15:17.217 align:middle line:-1
因为它的确包含地理信息

00:15:17.284 --> 00:15:20.654 align:middle line:-2
比如经度和纬度 因此
你的app不需要请求

00:15:20.721 --> 00:15:22.856 align:middle line:-1
位置允许使用ARKit

00:15:23.824 --> 00:15:26.326 align:middle line:-1
它可能包括可识别的私人信息

00:15:26.393 --> 00:15:27.828 align:middle line:-1
关于用户所处的环境

00:15:28.662 --> 00:15:31.431 align:middle line:-2
因此我们建议你处理
序列化WorldMap时要采用

00:15:31.498 --> 00:15:34.935 align:middle line:-2
与处理其它
由用户创建的私人数据的相同的方式

00:15:36.136 --> 00:15:39.773 align:middle line:-1
这意味着你要确保你加密了数据

00:15:40.541 --> 00:15:42.943 align:middle line:-1
无论是休息时或是当在网络中移动时

00:15:43.644 --> 00:15:45.245 align:middle line:-1
你可能还想让用户知道

00:15:45.312 --> 00:15:48.081 align:middle line:-2
你是否计划保存
那个WorldMap信息

00:15:48.148 --> 00:15:52.019 align:middle line:-2
在app的单一会话
结束后的一段时间内

00:15:53.253 --> 00:15:57.691 align:middle line:-2
在SwiftShot中
我们可以利用iOS的内置加密

00:15:58.058 --> 00:16:00.794 align:middle line:-1
在玩家休息时加密数据

00:15:58.058 --> 00:16:00.794 align:middle line:-1
在玩家休息时加密数据

00:16:01.361 --> 00:16:06.633 align:middle line:-2
我要谈一下
我们如何在网络上实现加密

00:16:09.236 --> 00:16:13.240 align:middle line:-2
现在除了针对SwiftShot
设置共享坐标空间

00:16:13.307 --> 00:16:14.508 align:middle line:-1
我们还需告诉另台设备

00:16:14.575 --> 00:16:16.910 align:middle line:-1
用户选择在哪里定位游戏板

00:16:17.711 --> 00:16:19.346 align:middle line:-2
为此我们使用了
一个ARAnchor

00:16:20.280 --> 00:16:22.749 align:middle line:-2
当你创建ARAnchor时
你要提供一个名称

00:16:22.816 --> 00:16:25.452 align:middle line:-1
以及位置和旋转信息

00:16:25.519 --> 00:16:26.987 align:middle line:-1
作为4 x 4转换

00:16:28.722 --> 00:16:32.693 align:middle line:-2
然后ARKit就会在我们生成的
ARWorldMap中包含锚点

00:16:32.759 --> 00:16:36.296 align:middle line:-2
并将其序列化 然后我们就可把那个
游戏板信息迁移到

00:16:36.363 --> 00:16:37.598 align:middle line:-1
另一台设备上

00:16:39.499 --> 00:16:40.834 align:middle line:-1
系统ARAnchor类

00:16:40.901 --> 00:16:43.871 align:middle line:-1
只有我们所创建的名称和定向

00:16:44.171 --> 00:16:46.340 align:middle line:-1
我们可以查询我们感兴趣的锚点

00:16:46.406 --> 00:16:47.541 align:middle line:-1
通过名称 在另一方面

00:16:48.208 --> 00:16:51.378 align:middle line:-2
对于我们的app来说
我们需要包含一些额外信息

00:16:51.445 --> 00:16:56.049 align:middle line:-2
针对另一台设备
就是用户选择的游戏板的尺寸

00:16:56.283 --> 00:17:00.287 align:middle line:-2
决定他们是否在 你知道的
一张小桌子顶部和表面上玩

00:16:56.283 --> 00:17:00.287 align:middle line:-2
决定他们是否在 你知道的
一张小桌子顶部和表面上玩

00:17:00.354 --> 00:17:03.757 align:middle line:-2
或者他们想把游戏板
变成篮球场那么大的尺寸

00:17:06.627 --> 00:17:09.096 align:middle line:-2
我们思考了一下
把那个添加到我们的网络协议中

00:17:09.162 --> 00:17:12.266 align:middle line:-2
和WorldMap一起
但是我们遇到了一个更好的方案

00:17:13.200 --> 00:17:17.171 align:middle line:-2
我们创建了ARAnchor
的自定义子类 称其为游戏板锚点

00:17:17.871 --> 00:17:21.040 align:middle line:-2
并把那个信息添加到那个类中
即游戏板的尺寸

00:17:22.175 --> 00:17:25.546 align:middle line:-1
然后我们确保我们实施了

00:17:25.945 --> 00:17:28.916 align:middle line:-2
NSCoding所需的类
或覆盖它们

00:17:29.183 --> 00:17:32.819 align:middle line:-2
当对象被序列化时
以便包含那个信息

00:17:33.387 --> 00:17:36.590 align:middle line:-2
现在信息被直接包含在
WorldMap内

00:17:36.790 --> 00:17:38.825 align:middle line:-1
当我们把它迁移到另一台设备上时

00:17:39.193 --> 00:17:40.861 align:middle line:-1
这样很简单 也很直截了当

00:17:42.095 --> 00:17:44.998 align:middle line:-2
有一件事需要记住
这给我们增加了一点困扰

00:17:45.465 --> 00:17:51.305 align:middle line:-2
当你用Swift来做这样的子类时
当你序列化子类时

00:17:51.672 --> 00:17:52.773 align:middle line:-1
模块的名称

00:17:52.840 --> 00:17:55.609 align:middle line:-1
或app的名称会包含在类的名称之中

00:17:55.976 --> 00:17:57.244 align:middle line:-1
你要引起注意

00:17:57.311 --> 00:18:00.681 align:middle line:-2
如果你计划在不同app之间
移动WorldMap

00:17:57.311 --> 00:18:00.681 align:middle line:-2
如果你计划在不同app之间
移动WorldMap

00:18:01.048 --> 00:18:03.517 align:middle line:-2
NSKeyedArchiver
可以帮助你调整

00:18:05.185 --> 00:18:09.056 align:middle line:-2
那么这是WorldMap共享
它是iOS 12中的新特性

00:18:09.122 --> 00:18:11.992 align:middle line:-2
我们真的期待看到你们大家
能用它做出来什么东西

00:18:14.494 --> 00:18:16.763 align:middle line:-2
接下来让我们谈谈
我们嵌入到游戏中的网络

00:18:17.798 --> 00:18:20.701 align:middle line:-2
我们使用了iOS的
多点连通性API

00:18:20.767 --> 00:18:23.837 align:middle line:-2
自从iOS 7开始就存在于
系统中了 目的是嵌入网络

00:18:24.638 --> 00:18:25.806 align:middle line:-1
多点连通性

00:18:25.873 --> 00:18:29.276 align:middle line:-2
允许我们在本地网络上设置一个
点对点会话

00:18:29.543 --> 00:18:31.812 align:middle line:-1
允许会话中的设备进行通讯

00:18:31.879 --> 00:18:33.647 align:middle line:-1
而无需通过专用服务器

00:18:34.481 --> 00:18:37.851 align:middle line:-2
现在在我们的app中
我们指定其中一台设备作为服务器

00:18:38.051 --> 00:18:40.187 align:middle line:-1
但是我们为我们的app所做的事

00:18:40.254 --> 00:18:41.688 align:middle line:-1
它并不是协议所固有的

00:18:43.023 --> 00:18:46.326 align:middle line:-1
加密和验证内嵌到多点连通性中

00:18:46.860 --> 00:18:48.695 align:middle line:-1
在我们的例子中 我们没有使用验证

00:18:48.762 --> 00:18:51.465 align:middle line:-2
因为我们想得到非常迅速地
进入和退出的体验

00:18:51.532 --> 00:18:53.066 align:middle line:-1
但我们使用了加密

00:18:53.767 --> 00:18:57.604 align:middle line:-1
我们发现打开加密真的不会影响性能

00:18:57.671 --> 00:19:01.542 align:middle line:-1
无论是在网络数据尺寸还是计算方面

00:18:57.671 --> 00:19:01.542 align:middle line:-1
无论是在网络数据尺寸还是计算方面

00:19:01.608 --> 00:19:03.277 align:middle line:-1
因此没有什么原因让我们不使用它

00:19:05.078 --> 00:19:09.483 align:middle line:-2
多点连通性
还给API提供了广告和发现

00:19:10.217 --> 00:19:12.052 align:middle line:-1
我们用它来推广可用的游戏

00:19:12.119 --> 00:19:13.854 align:middle line:-1
并允许玩家选择一个游戏加入

00:19:15.255 --> 00:19:16.790 align:middle line:-1
这就是我们如何设置会话的

00:19:17.524 --> 00:19:18.725 align:middle line:-1
首先在一台设备上

00:19:18.792 --> 00:19:22.162 align:middle line:-1
用户决定把自己设置为app的主机

00:19:23.330 --> 00:19:26.033 align:middle line:-2
他们可以扫描世界
把游戏板放在那个世界中

00:19:27.234 --> 00:19:31.538 align:middle line:-2
然后设备就开启一个新会话
一个多点连通性会话

00:19:31.605 --> 00:19:34.374 align:middle line:-2
并开始在本地网络上
把它推广到其它设备

00:19:36.109 --> 00:19:39.179 align:middle line:-2
另一台设备上的用户
查看了一个可用游戏列表

00:19:39.980 --> 00:19:43.817 align:middle line:-2
当他选择了某个游戏时 他的设备
就发送一个请求 请求加入现有会话

00:19:45.552 --> 00:19:47.888 align:middle line:-1
一旦第一台设备接受请求

00:19:47.955 --> 00:19:50.657 align:middle line:-2
多点连通性就设置一个
真正的点对点网络

00:19:51.058 --> 00:19:52.993 align:middle line:-1
网络中的任何设备

00:19:53.060 --> 00:19:55.229 align:middle line:-1
都可以向网络中的任意设备发送信息

00:19:55.929 --> 00:19:59.499 align:middle line:-2
在SwiftShot中
我们指定了开启会话的设备

00:19:59.566 --> 00:20:01.468 align:middle line:-1
作为游戏状态的事实来源

00:19:59.566 --> 00:20:01.468 align:middle line:-1
作为游戏状态的事实来源

00:20:01.702 --> 00:20:05.172 align:middle line:-2
这是我们在网络协议顶层
所做出的决策

00:20:05.239 --> 00:20:07.274 align:middle line:-1
它并不是多点连通性所固有的

00:20:10.077 --> 00:20:11.578 align:middle line:-1
一旦设置好会话

00:20:11.645 --> 00:20:15.482 align:middle line:-2
多点连通性就让我们以三种方式
在点之间发送数据：

00:20:15.916 --> 00:20:17.117 align:middle line:-1
作为数据包

00:20:17.651 --> 00:20:20.654 align:middle line:-2
作为资源
在本地存储上把URL归档

00:20:21.054 --> 00:20:22.155 align:middle line:-1
以及作为数据流

00:20:22.723 --> 00:20:25.659 align:middle line:-2
你可以发送数据对象
向网络中的所有点推送

00:20:25.993 --> 00:20:28.795 align:middle line:-1
而资源和数据流是设备对设备的操作

00:20:29.730 --> 00:20:35.102 align:middle line:-2
在SwiftShot中
我们主要把数据包用于共享游戏事件

00:20:35.169 --> 00:20:37.671 align:middle line:-1
以及物理状态 我们稍后再谈

00:20:38.839 --> 00:20:41.108 align:middle line:-2
然后我们使用资源
来迁移WorldMap

00:20:42.176 --> 00:20:44.111 align:middle line:-2
然后它就结束了
我们的app不需要数据流

00:20:46.079 --> 00:20:48.015 align:middle line:-1
在底层 多点连通性

00:20:48.081 --> 00:20:50.617 align:middle line:-2
依赖于UDP
用于在设备间进行迁移

00:20:51.285 --> 00:20:55.656 align:middle line:-2
这就提供了低延迟
对于游戏这样的app来说非常棒

00:20:56.490 --> 00:20:58.825 align:middle line:-1
现在固有的UDP并不能保证交付

00:20:59.259 --> 00:21:02.763 align:middle line:-2
因此多点连通性
允许你做出决策并确定

00:20:59.259 --> 00:21:02.763 align:middle line:-2
因此多点连通性
允许你做出决策并确定

00:21:02.829 --> 00:21:06.767 align:middle line:-1
可靠或不可靠地发送特定数据包

00:21:07.434 --> 00:21:08.735 align:middle line:-1
如果你选择可靠地发送

00:21:09.203 --> 00:21:11.972 align:middle line:-1
多点连通性会替你不断重试

00:21:12.039 --> 00:21:14.441 align:middle line:-1
因此你不需要在代码中担忧这个问题

00:21:15.843 --> 00:21:18.712 align:middle line:-1
即使当你向会话中的所有成员推广时

00:21:21.648 --> 00:21:23.350 align:middle line:-1
现在我们有一个网络层

00:21:23.417 --> 00:21:25.619 align:middle line:-2
我们要在网络层顶部
创建我们的app协议

00:21:26.386 --> 00:21:29.823 align:middle line:-2
带相关联类型SwiftEnums
让这个过程变得非常简单

00:21:30.757 --> 00:21:32.759 align:middle line:-1
每个例子中都有一个数据结构

00:21:33.126 --> 00:21:36.196 align:middle line:-2
确保类型的安全性
当信息在系统中移动时

00:21:37.464 --> 00:21:39.600 align:middle line:-1
其中有些可以进一步枚举

00:21:39.833 --> 00:21:42.636 align:middle line:-2
比如在本例中
gameAction包括

00:21:42.703 --> 00:21:46.440 align:middle line:-2
像玩家抓取弹弓
弹丸发射等等这样的东西

00:21:47.307 --> 00:21:49.810 align:middle line:-2
PhysicsSyncData
是一个结构 我们稍后再具体谈谈

00:21:49.877 --> 00:21:51.645 align:middle line:-1
我们是如何进行编码的

00:21:53.480 --> 00:21:55.449 align:middle line:-1
Swift让这个过程变得很简单

00:21:55.516 --> 00:21:58.552 align:middle line:-2
对于结构 如果结构中的全部成员
都是可编码的

00:21:58.919 --> 00:22:01.822 align:middle line:-2
你所要做的就是把那个结构
标记为可编码

00:21:58.919 --> 00:22:01.822 align:middle line:-2
你所要做的就是把那个结构
标记为可编码

00:22:01.889 --> 00:22:03.624 align:middle line:-2
然后Swift编译器
会替你做剩下的事

00:22:04.057 --> 00:22:06.426 align:middle line:-1
创建全部基础结构用于序列化

00:22:07.995 --> 00:22:09.863 align:middle line:0
Swift并不会针对枚举这样做

00:22:09.930 --> 00:22:12.132 align:middle line:0
因此我们得自己来实施

00:22:12.466 --> 00:22:16.436 align:middle line:0
实施初始化和编码方法

00:22:16.503 --> 00:22:18.805 align:middle line:0
从可编码协议中

00:22:20.908 --> 00:22:22.709 align:middle line:-1
然后序列化就非常简单了

00:22:22.776 --> 00:22:26.280 align:middle line:-2
只需要创建一个属性列表编码器
并让它编码对象

00:22:27.314 --> 00:22:30.984 align:middle line:-2
然后我们可以在多点连通性会话内
发送一个数据包

00:22:32.486 --> 00:22:34.188 align:middle line:-1
现在这里有一个合乎情理的提问

00:22:34.254 --> 00:22:37.224 align:middle line:-1
它对尺寸和性能会有什么影响？

00:22:38.592 --> 00:22:42.663 align:middle line:-2
二进制属性列表非常紧凑
并且编码器的速度也非常快

00:22:43.664 --> 00:22:44.998 align:middle line:-1
但有时候 你知道的

00:22:45.332 --> 00:22:49.269 align:middle line:-2
温和的实施在许多方面
都针对开发者时间进行了优化

00:22:49.336 --> 00:22:51.805 align:middle line:-1
有时候是你在对象上的最宝贵的资源

00:22:54.074 --> 00:22:55.776 align:middle line:-1
现在我们遇到了一些限制

00:22:55.843 --> 00:22:59.179 align:middle line:-2
当我们开始创建下一个功能时
我们要谈谈该如何克服这个问题

00:23:01.882 --> 00:23:04.318 align:middle line:-1
接下来让我们谈谈游戏中的物理模拟

00:23:04.952 --> 00:23:07.688 align:middle line:-2
像SwiftShot一样的游戏
物理非常关键

00:23:07.754 --> 00:23:11.158 align:middle line:-2
对于创建
源于现实的有趣的交互作用来说

00:23:11.225 --> 00:23:14.027 align:middle line:-2
在对象和游戏之间
它是一个很棒的体验

00:23:14.094 --> 00:23:17.130 align:middle line:-2
拉动弹弓
然后对准游戏中的一个对象发射

00:23:17.197 --> 00:23:18.532 align:middle line:-1
并缴获对手的弹弓

00:23:19.700 --> 00:23:21.368 align:middle line:-1
那其实是源自物理模拟

00:23:23.670 --> 00:23:25.672 align:middle line:-2
我们用了SceneKit
内置物理引擎

00:23:26.039 --> 00:23:27.641 align:middle line:-1
它集成了渲染引擎

00:23:27.708 --> 00:23:30.444 align:middle line:-1
在场景中自动更新对象的位置

00:23:30.911 --> 00:23:33.113 align:middle line:-1
如果发生碰撞就通过委托提醒我们

00:23:34.581 --> 00:23:37.050 align:middle line:-2
在我们的实施中
我们决定最好的方式是

00:23:37.117 --> 00:23:41.722 align:middle line:-2
让会话中的一台设备
担任事实来源或服务器

00:23:42.256 --> 00:23:46.260 align:middle line:-2
它会把物理状态的定期更新
发送到网络中的其它设备上

00:23:46.326 --> 00:23:50.931 align:middle line:-1
通过多点连通性推送方法

00:23:52.699 --> 00:23:56.970 align:middle line:-1
现在其它设备也拥有物理模拟了

00:23:57.704 --> 00:24:00.741 align:middle line:-2
这是因为我们并不是发送
游戏中每一个对象的信息

00:23:57.704 --> 00:24:00.741 align:middle line:-2
这是因为我们并不是发送
游戏中每一个对象的信息

00:24:01.074 --> 00:24:04.511 align:middle line:-2
只发送那些与游戏设置相关的
对象的信息 比如方框

00:24:04.578 --> 00:24:06.413 align:middle line:-1
落弹数和弹弩

00:24:06.914 --> 00:24:11.018 align:middle line:-2
还有一些东西
比如模拟绳子和投石器的摇摆

00:24:11.084 --> 00:24:16.089 align:middle line:-2
微粒等等
这些只是在每台设备上本地实现的

00:24:16.156 --> 00:24:19.660 align:middle line:-2
因为它对于游戏来说并不是关键因素
它们可出现在每台设备上的同一位置

00:24:24.031 --> 00:24:26.867 align:middle line:-2
现在在我们的实现过程中
我们发现的其中一件事就是

00:24:26.934 --> 00:24:29.870 align:middle line:-1
物理引擎的响应很不一样

00:24:29.937 --> 00:24:31.572 align:middle line:-1
取决于对象的比例

00:24:32.206 --> 00:24:34.107 align:middle line:-1
那么物理模拟认为

00:24:34.174 --> 00:24:37.678 align:middle line:-2
对象比你在现实世界中看到的尺寸
要大十倍

00:24:38.278 --> 00:24:41.181 align:middle line:-2
我们发现
那会提供最佳的游戏设置体验

00:24:41.248 --> 00:24:42.416 align:middle line:-1
和最好的性能

00:24:43.150 --> 00:24:44.685 align:middle line:-1
我们需要改善一些物理定律

00:24:44.751 --> 00:24:47.988 align:middle line:-2
让一切看起来都正常 但是你知道的
当你创建游戏时

00:24:48.055 --> 00:24:50.357 align:middle line:-2
若看起来还不错 感觉也不错
而且它还有意思

00:24:50.691 --> 00:24:51.558 align:middle line:-1
那就对了

00:24:53.760 --> 00:24:56.930 align:middle line:-2
现在要共享那个物理状态
并确保一切看起来都正常

00:24:56.997 --> 00:24:59.166 align:middle line:-1
我们需要共享四个信息：

00:24:59.633 --> 00:25:00.501 align:middle line:-1
位置

00:24:59.633 --> 00:25:00.501 align:middle line:-1
位置

00:25:02.269 --> 00:25:03.203 align:middle line:-1
速度

00:25:04.638 --> 00:25:07.541 align:middle line:-1
角速度和定向

00:25:08.342 --> 00:25:10.711 align:middle line:-2
对于游戏中的每一个对象来说
信息量相当大

00:25:11.144 --> 00:25:14.348 align:middle line:-2
因此我们最小化实际要用到的位数
是至关重要的

00:25:14.982 --> 00:25:17.417 align:middle line:-1
我会以位置作为例子具体讲一下

00:25:18.886 --> 00:25:22.356 align:middle line:-2
SceneKit把位置表示为
一个矢量 是三个浮点值

00:25:23.257 --> 00:25:24.725 align:middle line:-1
这是原生格式

00:25:24.791 --> 00:25:27.895 align:middle line:-1
在运行时间给计算提供了最好的性能

00:25:30.163 --> 00:25:32.766 align:middle line:-1
然而 其实还有更多不必要的位数

00:25:32.833 --> 00:25:34.401 align:middle line:-1
用于指定对象的位置

00:25:35.169 --> 00:25:39.273 align:middle line:-2
一个30位的浮点有8位指数
和23位小数

00:25:39.740 --> 00:25:42.442 align:middle line:-1
对于正负十的范围 相对于38米

00:25:43.043 --> 00:25:44.912 align:middle line:-2
这比我们需要在游戏中使用的长度
长多了

00:25:47.347 --> 00:25:51.385 align:middle line:-2
那么因为物理模拟认为
我们的桌子有27米长

00:25:51.985 --> 00:25:55.055 align:middle line:-2
我们说过你知道的
80米会提供给我们足够的缓冲空间

00:25:55.122 --> 00:25:56.523 align:middle line:-2
在桌子周围
无论哪一边都行

00:25:58.625 --> 00:26:03.096 align:middle line:0
当我们写代码时
那么我们就能消除信号位

00:25:58.625 --> 00:26:03.096 align:middle line:0
当我们写代码时
那么我们就能消除信号位

00:26:03.530 --> 00:26:06.867 align:middle line:0
通过把那个正常化到0和80米之间

00:26:06.934 --> 00:26:08.669 align:middle line:0
即使我们的原始位置在桌子的中心

00:26:09.403 --> 00:26:10.704 align:middle line:0
现在所有值都是正值

00:26:12.172 --> 00:26:15.108 align:middle line:0
然后我们把那个值削减到0和1之间

00:26:15.676 --> 00:26:17.578 align:middle line:0
那样我们就不需要指数信息

00:26:17.644 --> 00:26:20.747 align:middle line:0
协议内固有的指数信息

00:26:22.649 --> 00:26:24.484 align:middle line:-1
最后 我们把这个数

00:26:24.551 --> 00:26:26.453 align:middle line:-1
按比例缩减为可用的位数

00:26:26.954 --> 00:26:32.926 align:middle line:0
从而所有值都是一个浮点值
并且所有的0都是浮点0

00:26:34.094 --> 00:26:38.532 align:middle line:0
这就给我们提供了毫米比例精度
我们发现它已经足够

00:26:38.966 --> 00:26:41.735 align:middle line:0
用于实现游戏中流畅、同步的体验

00:26:43.403 --> 00:26:46.607 align:middle line:-2
现在我们对你所看到的其它值
应用了一个类似的技巧

00:26:46.673 --> 00:26:49.543 align:middle line:-1
速度、角速度和定向

00:26:51.078 --> 00:26:53.680 align:middle line:-1
缩减范围和位数

00:26:53.747 --> 00:26:56.183 align:middle line:-1
以便确保我们对信息的传输

00:26:56.250 --> 00:26:57.551 align:middle line:-1
保持了最小的数据量

00:26:58.051 --> 00:27:02.589 align:middle line:-2
总之 我们对每个对象
减少了半数以上的位数

00:26:58.051 --> 00:27:02.589 align:middle line:-2
总之 我们对每个对象
减少了半数以上的位数

00:27:04.658 --> 00:27:06.793 align:middle line:-1
现在即使我们压缩了位数

00:27:07.761 --> 00:27:10.330 align:middle line:-1
属性列表仍然有大量的超额负载

00:27:10.397 --> 00:27:11.865 align:middle line:-1
对于它的元数据而言

00:27:12.633 --> 00:27:13.834 align:middle line:-1
按名称发送每一个字段

00:27:14.801 --> 00:27:18.238 align:middle line:-2
我们说过那是无缘无故的
我们都知道这些对象是什么

00:27:18.572 --> 00:27:19.940 align:middle line:-1
这不是我们需要的信息

00:27:20.707 --> 00:27:25.746 align:middle line:-1
为此我们实施了一个新的序列化策略

00:27:26.146 --> 00:27:27.181 align:middle line:-1
称之为BitStream

00:27:28.382 --> 00:27:30.417 align:middle line:-2
BitStream
用于把信息打包到

00:27:30.484 --> 00:27:31.952 align:middle line:-1
尽可能少的字节中

00:27:32.319 --> 00:27:35.022 align:middle line:-1
同时提供快速的序列化和反序列化

00:27:35.856 --> 00:27:37.925 align:middle line:-1
现在我们的实施是为特定目的创建的

00:27:37.991 --> 00:27:39.560 align:middle line:-1
用于传递二进制数据

00:27:40.093 --> 00:27:42.162 align:middle line:-1
以低延迟 在一个类似这样的app中

00:27:42.896 --> 00:27:47.568 align:middle line:-2
这样的策略对于需要持久的数据来说
效果不会太好

00:27:48.001 --> 00:27:50.270 align:middle line:-1
或者是你需要追踪架构

00:27:50.337 --> 00:27:51.772 align:middle line:-1
并随时间观察它的变化的数据

00:27:52.439 --> 00:27:55.676 align:middle line:-2
但对于类似这样的短暂的app来说
用它正合适

00:27:58.178 --> 00:28:01.114 align:middle line:-1
要实施它 我们创建了两个协议

00:27:58.178 --> 00:28:01.114 align:middle line:-1
要实施它 我们创建了两个协议

00:28:01.181 --> 00:28:03.951 align:middle line:-2
BitStream Encodable
和BitStream Decodable

00:28:04.651 --> 00:28:06.520 align:middle line:-2
把两个结合起来就能得到
BitStream Codable

00:28:07.387 --> 00:28:11.124 align:middle line:-2
然后我们用它标记
我们需要序列化的所有对象

00:28:11.191 --> 00:28:13.594 align:middle line:-1
使用那个协议 帮助我们获得实施

00:28:14.027 --> 00:28:17.898 align:middle line:-2
那既包括我们自己的数据对象
也包括我们从系统中使用的对象

00:28:17.965 --> 00:28:22.269 align:middle line:-1
比如simD浮点矢量类型

00:28:25.272 --> 00:28:27.908 align:middle line:-1
那么这是压缩浮点的实施

00:28:28.509 --> 00:28:31.578 align:middle line:-1
压缩器配置了最小和最大范围

00:28:31.645 --> 00:28:33.347 align:middle line:-1
以及我们想要使用的位数

00:28:35.115 --> 00:28:39.253 align:middle line:-2
它把值压缩到那个范围
然后把它转化为一个整数值

00:28:39.319 --> 00:28:41.722 align:middle line:-1
用于编码 使用指定位数

00:28:42.823 --> 00:28:45.859 align:middle line:-2
场景中每个对象的每个组件
都是以这种方式压缩的

00:28:46.593 --> 00:28:48.829 align:middle line:-1
我们之前还使用额外位数

00:28:48.896 --> 00:28:51.298 align:middle line:-2
来表示对象自上次更新后
是否发生了移动

00:28:51.999 --> 00:28:54.735 align:middle line:-2
如果它没有移动过
我们就不再重复发送那个信息

00:28:57.271 --> 00:28:59.940 align:middle line:-2
那么让我们返回我们的行动枚举
有三个不同的行动

00:29:00.007 --> 00:29:02.042 align:middle line:-2
谈谈如何通过
BitStream来实现

00:29:03.844 --> 00:29:07.514 align:middle line:-2
对于常规的codable
如果你正在做你自己的序列化

00:29:07.581 --> 00:29:11.385 align:middle line:-2
你要在枚举中的不同情况下
指定枚举的编码关键字

00:29:12.186 --> 00:29:16.857 align:middle line:-2
对于BitStream
我们用了整数值而非字符串值

00:29:18.525 --> 00:29:23.330 align:middle line:0
然后再我们的编码方法中
我们可以先附加那个值

00:29:23.397 --> 00:29:27.601 align:middle line:0
接着是与那个枚举情况
相关联的数据结构

00:29:28.468 --> 00:29:31.205 align:middle line:0
现在 如果你查找这个代码
这里有一个陷阱

00:29:31.805 --> 00:29:36.577 align:middle line:0
我们知道这个例子有三种不同的情况

00:29:37.211 --> 00:29:39.213 align:middle line:-1
我们只需要两个位元来编码它

00:29:40.681 --> 00:29:45.452 align:middle line:-2
但当我们添加另一情况后会怎样呢？
四个位元对应四种情况仍然还不错

00:29:45.752 --> 00:29:49.923 align:middle line:-2
我们添加了第五种情况
现在我们就要修改那个

00:29:49.990 --> 00:29:53.427 align:middle line:-2
我们每次这样做时
我们用的是三个位元而非两个

00:29:54.061 --> 00:29:57.197 align:middle line:-2
现在这就有点乏味了
这个代码有点重复了

00:29:57.264 --> 00:29:59.666 align:middle line:-2
并且你知道的
这里的内容可能会发生错误

00:29:59.733 --> 00:30:02.703 align:middle line:-2
如果我们不记得这个
我们只能得到一个糟糕的结果

00:29:59.733 --> 00:30:02.703 align:middle line:-2
如果我们不记得这个
我们只能得到一个糟糕的结果

00:30:03.804 --> 00:30:05.339 align:middle line:-1
那么让我们查看一下

00:30:05.405 --> 00:30:08.909 align:middle line:-1
想想Swift是否可以提供帮助

00:30:11.078 --> 00:30:15.482 align:middle line:-2
我们用了Swift 4.2新特性
叫做情况可迭代

00:30:16.450 --> 00:30:21.688 align:middle line:-2
我们在我们的枚举类型中
添加了协议一致性

00:30:22.489 --> 00:30:26.827 align:middle line:-2
当你这样做时 Swift
就会添加一个类型的新静态成员

00:30:26.894 --> 00:30:29.897 align:middle line:-2
叫做全部情况
包括枚举中的每一种情况

00:30:30.664 --> 00:30:34.034 align:middle line:-1
让就让我们自动获得情况数量

00:30:34.968 --> 00:30:38.772 align:middle line:-2
然后我们添加了另一个扩展
这一次是在原生的可描绘类型上

00:30:38.839 --> 00:30:42.543 align:middle line:-1
所有带数字类型的枚举都会遵循它

00:30:43.110 --> 00:30:46.346 align:middle line:-1
这种情况可迭代 并且数字是整数

00:30:47.047 --> 00:30:50.117 align:middle line:-1
为此我们要自动获取情况的数量

00:30:50.184 --> 00:30:54.254 align:middle line:-2
并算出表达全部那些情况
需要多少位元数

00:30:56.356 --> 00:31:01.128 align:middle line:-2
最后我们添加了通用方法
在可写入BitStream类型上

00:30:56.356 --> 00:31:01.128 align:middle line:-2
最后我们添加了通用方法
在可写入BitStream类型上

00:31:01.195 --> 00:31:02.763 align:middle line:-1
允许我们编码那个枚举

00:31:03.397 --> 00:31:07.467 align:middle line:-2
它会附加那个类型的东西
并且会使用那个新的静态属性来计算

00:31:07.534 --> 00:31:09.736 align:middle line:-1
所需要使用的位元数

00:31:11.705 --> 00:31:13.740 align:middle line:-1
现在我们的编码方法变得更简单了

00:31:14.208 --> 00:31:17.845 align:middle line:-2
在适当的代码键上
我们只使用了附加枚举

00:31:17.911 --> 00:31:19.346 align:middle line:-1
Swift会替我们完成剩下的事

00:31:19.980 --> 00:31:23.717 align:middle line:-2
当我们向枚举中添加更多情况时
BitField会自动扩展

00:31:23.984 --> 00:31:26.286 align:middle line:-1
如果我们移除情况 它会自动缩小

00:31:26.520 --> 00:31:27.754 align:middle line:-1
我们不用担心它

00:31:31.658 --> 00:31:34.695 align:middle line:-2
BitStreamCodable
到底有多快多紧凑呢？

00:31:35.028 --> 00:31:38.298 align:middle line:-2
我们运行一些测试
使用XE测试支持用于性能测试

00:31:38.665 --> 00:31:42.503 align:middle line:-2
使用代表性的信息
我们发送关于对象移动的信息

00:31:44.004 --> 00:31:47.841 align:middle line:-2
结果令人印象深刻：十分之一的尺寸
两倍速度的编码

00:31:47.908 --> 00:31:49.376 align:middle line:-1
十倍速度的解码

00:31:50.177 --> 00:31:54.581 align:middle line:-2
现在当我们谈到从75毫秒
降低到6毫秒时

00:31:54.648 --> 00:31:56.116 align:middle line:-1
看起来微不足道

00:31:56.917 --> 00:32:00.254 align:middle line:-2
但游戏中有大约200个对象
我们要非常频繁地操作

00:31:56.917 --> 00:32:00.254 align:middle line:-2
但游戏中有大约200个对象
我们要非常频繁地操作

00:32:00.320 --> 00:32:03.023 align:middle line:-2
从而确保每一个参与者
都能流畅地玩游戏

00:32:03.524 --> 00:32:04.992 align:middle line:-1
通过使用这个编码格式

00:32:05.058 --> 00:32:08.495 align:middle line:-2
我们就能以60帧/秒
来实现物理更新

00:32:08.562 --> 00:32:11.164 align:middle line:-2
确保游戏中的每一个人
都能拥有流畅的体验

00:32:13.400 --> 00:32:16.737 align:middle line:-2
现在 我已经讲过了
我们对codable做了一些事

00:32:16.803 --> 00:32:20.174 align:middle line:-2
还有BitStream Codable
你可能会有一个问题

00:32:20.240 --> 00:32:22.075 align:middle line:-1
因为我们用了两种不同的方式来编码

00:32:22.309 --> 00:32:24.077 align:middle line:-1
那意味着需要两种不同的代码路径

00:32:24.144 --> 00:32:25.012 align:middle line:-1
在我们的app中

00:32:26.113 --> 00:32:29.149 align:middle line:-2
Swift再次给我们提供了帮助
算出如何把它们结合在一起

00:32:30.117 --> 00:32:33.086 align:middle line:-1
然后我们添加了受约束的扩展

00:32:33.153 --> 00:32:36.390 align:middle line:-2
因此BitStream Codable中
任何对象都可编码

00:32:36.657 --> 00:32:39.860 align:middle line:-2
我们提供了BitStream
编码的默认实施

00:32:40.460 --> 00:32:45.199 align:middle line:-2
然后我们只需要继续
并使用一个二进制属性列表编码器

00:32:45.832 --> 00:32:48.168 align:middle line:-2
来编码数据并把它放在
BitStream中

00:32:49.236 --> 00:32:52.105 align:middle line:0
然后任何对象
任何结构都是可编码的

00:32:52.172 --> 00:32:54.575 align:middle line:0
我们只需要添加它并把它标记为
BitStream Codable

00:32:54.908 --> 00:32:58.011 align:middle line:0
现在这个实施并不是那么快速和紧凑

00:32:58.078 --> 00:33:01.315 align:middle line:0
如果我们继续并让一切对象都直接
BitStream Codable

00:32:58.078 --> 00:33:01.315 align:middle line:0
如果我们继续并让一切对象都直接
BitStream Codable

00:33:01.849 --> 00:33:04.651 align:middle line:0
但我们发现我们不需要针对
游戏中的每一个对象这样做

00:33:04.718 --> 00:33:06.587 align:middle line:0
只针对最频繁的信息即可

00:33:06.653 --> 00:33:10.691 align:middle line:-2
这让我们的移动非常快速
并让它在游戏中保持运行

00:33:12.526 --> 00:33:13.961 align:middle line:-1
那么这是我们如何处理物理

00:33:14.228 --> 00:33:17.097 align:middle line:-2
接下来我想谈谈如何针对游戏等级
处理资产

00:33:17.164 --> 00:33:20.033 align:middle line:-1
楼下有很多人提到了这个问题

00:33:22.002 --> 00:33:24.404 align:middle line:-1
你知道的 资产包括3D模块、纹理

00:33:24.471 --> 00:33:25.772 align:middle line:-1
动画等等

00:33:26.406 --> 00:33:28.342 align:middle line:-2
Apple中有些文本角度的
艺术作品

00:33:28.709 --> 00:33:31.445 align:middle line:-2
并且它们使用了一些商业工具
来针对游戏创建视觉效果

00:33:31.512 --> 00:33:33.280 align:middle line:-1
砖块、弹弩等等

00:33:34.047 --> 00:33:38.185 align:middle line:-2
然后他们把资产导出为
常用的DAE文件格式

00:33:38.252 --> 00:33:40.921 align:middle line:-1
我们想要让商业工具支持USDZ

00:33:41.255 --> 00:33:42.789 align:middle line:-2
但对于这个游戏
还没达到目标

00:33:44.424 --> 00:33:49.162 align:middle line:-2
在Swift中创建了命令行工具
使用SceneKit API

00:33:49.229 --> 00:33:52.733 align:middle line:-2
将对象从DAE转换为
SceneKit文件

00:33:53.133 --> 00:33:56.937 align:middle line:-2
因为SceneKit在iOS
和macOS上提供相同的API

00:33:57.337 --> 00:34:01.241 align:middle line:-2
我们可以把这个工具
作为macOS上创建过程的一部分

00:33:57.337 --> 00:34:01.241 align:middle line:-2
我们可以把这个工具
作为macOS上创建过程的一部分

00:34:01.308 --> 00:34:04.945 align:middle line:-2
并在app的iOS创建中直接包括
SceneKit文件

00:34:06.780 --> 00:34:09.949 align:middle line:-2
我们把数据结构化
这样每个单一的组块类型

00:34:10.016 --> 00:34:11.518 align:middle line:-1
都在自己的文件中

00:34:12.018 --> 00:34:14.521 align:middle line:-2
然后对于每个等级
我们把那些组块结合在一起

00:34:15.455 --> 00:34:18.492 align:middle line:-1
这就允许我们迭代外观和物理行为

00:34:18.559 --> 00:34:21.628 align:middle line:-2
每一个单一组块的
然后把它们拉到一起

00:34:21.695 --> 00:34:24.097 align:middle line:-1
针对那些等级 并迭代游戏设置设计

00:34:24.364 --> 00:34:26.333 align:middle line:-2
尝试些不同等级 你会看到
如果你浏览

00:34:26.400 --> 00:34:28.135 align:middle line:-1
app的源代码的话

00:34:30.370 --> 00:34:33.639 align:middle line:-1
要进一步优化不同的距离

00:34:33.907 --> 00:34:38.045 align:middle line:-2
根据所需要的等级细节
SceneKit支持改变所用资产

00:34:39.079 --> 00:34:42.149 align:middle line:-2
附近的对象使用较多的多边形
和较多的详细纹理

00:34:42.216 --> 00:34:45.652 align:middle line:-2
而远处的对象使用较少的多边形
和较少的详细纹理

00:34:45.985 --> 00:34:48.388 align:middle line:-1
这样就真正优化了场景的渲染

00:34:51.190 --> 00:34:54.027 align:middle line:-2
然而 我们仍然希望游戏设置
保持一致性

00:34:54.460 --> 00:34:56.929 align:middle line:-1
因此我们分别制定了物理实体

00:34:57.865 --> 00:35:00.234 align:middle line:-2
SceneKit提供一系列
内置物理实体类型

00:34:57.865 --> 00:35:00.234 align:middle line:-2
SceneKit提供一系列
内置物理实体类型

00:35:00.300 --> 00:35:02.603 align:middle line:-1
比如立方体、球体、圆柱体

00:35:03.303 --> 00:35:06.073 align:middle line:-2
如果你使用这些
你就会获得最佳性能

00:35:06.807 --> 00:35:08.475 align:middle line:-1
如果你不指定其中一个

00:35:08.542 --> 00:35:12.579 align:middle line:-2
SceneKit将自动为你创建
一个凸壳 你就得用那个

00:35:12.913 --> 00:35:16.850 align:middle line:-1
但可能会得到较慢的性能实施

00:35:17.150 --> 00:35:19.953 align:middle line:-1
通过添加这些对象 当它们可用

00:35:20.020 --> 00:35:23.023 align:middle line:-2
并且当它们的存在有意义时
我们真的会加速游戏的性能

00:35:25.959 --> 00:35:28.762 align:middle line:-1
那么这是一些关于物理成品的示例

00:35:29.329 --> 00:35:30.898 align:middle line:-1
第一个是游戏中的一个组块

00:35:30.964 --> 00:35:34.034 align:middle line:-2
在本例中 一个带纹理的圆柱体
营造了一种木纹效果

00:35:35.068 --> 00:35:37.237 align:middle line:-1
接下来是弹弓 悬带是松弛的

00:35:37.905 --> 00:35:40.474 align:middle line:-2
我们在RunTime时
用着色器添加了团队颜色

00:35:40.541 --> 00:35:43.477 align:middle line:-2
并针对弹弓在游戏设置中的动作
创建了一些自定义动画

00:35:44.912 --> 00:35:48.415 align:middle line:-2
最后我们引入了一些额外的资产
并不包含在游戏设置中

00:35:48.749 --> 00:35:50.284 align:middle line:-1
即便我们要牺牲掉它们

00:35:50.350 --> 00:35:53.153 align:middle line:-2
我们希望你拥有它们
并在你自己的示例代码中使用它们

00:35:56.190 --> 00:35:59.493 align:middle line:-2
因此我们包括在内的另一个
有意思的东西是这个旗子动画

00:35:59.726 --> 00:36:01.828 align:middle line:-2
它很好地改善了
游戏环境中的沉浸体验

00:35:59.726 --> 00:36:01.828 align:middle line:-2
它很好地改善了
游戏环境中的沉浸体验

00:36:02.596 --> 00:36:04.831 align:middle line:-1
我们想要一个真实的刮风的效果

00:36:05.165 --> 00:36:08.168 align:middle line:-2
现在我们可以在物理引擎外部
使用布料模拟

00:36:09.469 --> 00:36:13.040 align:middle line:-2
但相反 我们决定使用GPU
并用Metal实现

00:36:15.275 --> 00:36:18.011 align:middle line:-2
我们从由技术设计师创建的
SceneKit资产开始

00:36:18.478 --> 00:36:22.449 align:middle line:-2
要在旗子上获取Apple标识
我们在Runtime时应用了纹理

00:36:23.684 --> 00:36:26.253 align:middle line:-2
然后在Metal设备周围
创建了一个Swift类

00:36:26.787 --> 00:36:30.424 align:middle line:-2
Swift代码创建了metal
命令队列并插入

00:36:30.490 --> 00:36:33.193 align:middle line:-1
从游戏状态中获取的信息 比如风向

00:36:34.561 --> 00:36:37.164 align:middle line:-2
那个命令队列运行的是
自定义Metal计算着色器

00:36:37.798 --> 00:36:39.900 align:middle line:-1
它来自用C创建的老程序

00:36:40.133 --> 00:36:44.805 align:middle line:-2
但因Metal基于现代的C++
所以这是一个很简单的转换

00:36:45.772 --> 00:36:49.776 align:middle line:-2
然后我们还运行了另一个计算着色器
来计算表面的法线

00:36:49.843 --> 00:36:52.346 align:middle line:-2
这样我们就得到了一个很棒
很流畅的旗子效果

00:36:52.579 --> 00:36:54.915 align:middle line:-1
而不需要在场景中有大量的多边形

00:36:55.582 --> 00:36:57.251 align:middle line:-1
旗子效果看起来真的很棒

00:36:58.252 --> 00:37:01.722 align:middle line:-2
每一帧 着色器都会把
匹配的几何结构更新为

00:36:58.252 --> 00:37:01.722 align:middle line:-2
每一帧 着色器都会把
匹配的几何结构更新为

00:37:01.788 --> 00:37:02.789 align:middle line:-1
它的新位置

00:37:03.257 --> 00:37:05.459 align:middle line:-1
通过以这种方式利用GPU

00:37:05.526 --> 00:37:09.730 align:middle line:-2
我们得到了一个很棒的效果
而它也不会影响主CPU

00:37:12.399 --> 00:37:15.769 align:middle line:-2
最后我想谈谈
SwiftShot中的音频实施

00:37:16.670 --> 00:37:19.806 align:middle line:-2
音频可以让任何游戏变得
更加拟真和迷人

00:37:20.674 --> 00:37:23.443 align:middle line:-1
我们知道我们想提供真实的声音效果

00:37:23.510 --> 00:37:26.813 align:middle line:-2
并在虚拟世界中适当地投放
从而得到真正拟真的体验

00:37:26.880 --> 00:37:28.315 align:middle line:-1
并给用户提供很好的反馈

00:37:28.382 --> 00:37:30.017 align:middle line:-1
关于他们要如何与那个世界交互

00:37:30.884 --> 00:37:33.453 align:middle line:-1
我们还想确保这个速度够快并关注

00:37:33.520 --> 00:37:36.390 align:middle line:-1
添加多少音频会增加我们app的大小

00:37:37.057 --> 00:37:39.326 align:middle line:-2
那么我们遇到了一个
我们认为很棒的方案

00:37:40.294 --> 00:37:42.963 align:middle line:-1
我们创建了一些代表性的声音示例

00:37:43.030 --> 00:37:46.099 align:middle line:-2
通过我们从团队员工的孩子们那儿
借来的玩具

00:37:47.301 --> 00:37:52.439 align:middle line:-2
然后我们录制了那些声音
并把它们结合到一个AU预设文件中

00:37:52.739 --> 00:37:56.343 align:middle line:-2
并用这些声音在AV Foundation中
创建自定义Midi乐器

00:37:56.677 --> 00:37:58.712 align:middle line:-2
使用AV Audio Unit
Midi Instrument

00:37:59.413 --> 00:38:02.115 align:middle line:-2
那样就能在合适的时候
快速播放合适的声音

00:37:59.413 --> 00:38:02.115 align:middle line:-2
那样就能在合适的时候
快速播放合适的声音

00:38:02.182 --> 00:38:04.551 align:middle line:-1
以响应用户在游戏中的输入和碰撞

00:38:06.987 --> 00:38:08.655 align:middle line:-1
我们并不只是播放原声音

00:38:09.122 --> 00:38:11.992 align:middle line:-2
为了给用户提供良好的反馈
我们拉动弹弓

00:38:12.059 --> 00:38:14.194 align:middle line:-1
我们用多种方式区分了声音

00:38:14.795 --> 00:38:18.398 align:middle line:-2
我们修改了音高
根据他们向后拉动弹弓的距离

00:38:21.702 --> 00:38:24.705 align:middle line:-2
并且我们区分了音量
根据你向后拉动的速度

00:38:24.771 --> 00:38:27.708 align:middle line:-2
且在RunTime时实现
通过选择合适的Midi记录

00:38:27.774 --> 00:38:30.310 align:middle line:-1
然后使用一些额外的Midi命令

00:38:30.377 --> 00:38:31.879 align:middle line:-1
在播放那个声音之前进行替换

00:38:32.379 --> 00:38:34.815 align:middle line:-1
那么让我们听一下这个是…很安静

00:38:53.700 --> 00:38:57.604 align:middle line:-1
现在我们还想确保当你使用弹弓时

00:38:57.671 --> 00:39:01.208 align:middle line:-1
我们还向用户提供一些音频反馈

00:38:57.671 --> 00:39:01.208 align:middle line:-1
我们还向用户提供一些音频反馈

00:39:01.275 --> 00:39:03.377 align:middle line:-1
关于他们是否在弹弓的射程范围内

00:39:03.443 --> 00:39:04.845 align:middle line:-1
以及他们是否捕获了东西

00:39:04.912 --> 00:39:06.747 align:middle line:-1
这是你在一开始听到的哔哔声

00:39:07.347 --> 00:39:09.783 align:middle line:-2
因为那些对于用户来说
都属于用户界面反馈

00:39:10.217 --> 00:39:12.119 align:middle line:-1
设备才会发出那些声音

00:39:12.186 --> 00:39:14.488 align:middle line:-1
仅当用户与弹弓进行交互时

00:39:14.922 --> 00:39:18.158 align:middle line:-2
然而我们还希望
游戏中的每个人都了解

00:39:18.225 --> 00:39:21.028 align:middle line:-2
弹弓那儿发生了什么
无论其他人是否拉动弹弓

00:39:21.094 --> 00:39:23.297 align:middle line:-2
或做出类似操作
但我们希望那些声音小点儿

00:39:23.797 --> 00:39:27.334 align:middle line:-2
那么我们使用了位置性音频
这样如果我的对手

00:39:27.401 --> 00:39:30.571 align:middle line:-2
正在拉动他们的弹弓
我也能从我的设备上听到那个声音

00:39:30.637 --> 00:39:32.840 align:middle line:-2
但音量较小
且它被正确投放到了虚拟世界中

00:39:35.175 --> 00:39:38.679 align:middle line:-2
对于碰撞砖块
我们采用了一个类似但稍不同的方法

00:39:39.112 --> 00:39:43.917 align:middle line:-1
我们真的想要一个刺耳的效果

00:39:43.984 --> 00:39:46.887 align:middle line:-2
砖块通常不会出现在
任何一名玩家附近

00:39:46.954 --> 00:39:51.091 align:middle line:-2
所以SceneKit位置性支持
可以让这个声音变得很棒

00:39:52.092 --> 00:39:53.727 align:middle line:-1
每台设备都会独立发声

00:39:54.628 --> 00:39:56.797 align:middle line:-1
你不用担心设备之间的同步性

00:39:56.864 --> 00:39:59.766 align:middle line:-2
因为我们希望它是个刺耳的声音
砖块粉碎的声音

00:40:00.434 --> 00:40:02.469 align:middle line:-1
我们使用了自定义Midi乐器

00:40:03.003 --> 00:40:05.005 align:middle line:-1
采用了少量声音 然后把它们区分开

00:40:05.339 --> 00:40:07.841 align:middle line:-2
在本例中是按照碰撞冲量的力量
来区分攻击率的

00:40:07.908 --> 00:40:10.878 align:middle line:-2
碰撞冲量
来自SceneKit物理引擎

00:40:13.614 --> 00:40:15.883 align:middle line:-1
这些声音在3D坐标中进行了本地化

00:40:15.949 --> 00:40:17.885 align:middle line:-1
根据设备在场景中的位置

00:40:17.951 --> 00:40:20.921 align:middle line:-2
因此桌子最远处的碰撞
比近处的碰撞声音要小

00:40:21.522 --> 00:40:22.689 align:middle line:-1
让我们来听一下

00:40:38.572 --> 00:40:39.406 align:middle line:-1
再发射一次

00:40:40.574 --> 00:40:41.408 align:middle line:-1
好了

00:40:42.376 --> 00:40:43.210 align:middle line:-1
很棒

00:40:46.346 --> 00:40:48.282 align:middle line:-1
那么我们想分享另一个小技巧

00:40:48.348 --> 00:40:50.117 align:middle line:-1
是我们在实现这个的过程中发现的

00:40:50.784 --> 00:40:52.352 align:middle line:-1
在设置声音的过程中

00:40:52.419 --> 00:40:55.389 align:middle line:-2
我们发现我们需要
在Runtime时运行一个脚本

00:40:55.455 --> 00:40:59.159 align:middle line:-2
用于在属性列表上做一些
文件名称路径转换 用于EAU预设

00:41:00.260 --> 00:41:02.563 align:middle line:-2
我们发现我们可以用Swift
创建那个工具

00:41:02.896 --> 00:41:04.798 align:middle line:-1
但却把它设置为一个命令行工具

00:41:05.532 --> 00:41:06.967 align:middle line:-1
你注意到顶部了吗

00:41:07.034 --> 00:41:10.304 align:middle line:-2
脚本顶部传统的Unix shebang
样式状态

00:41:10.671 --> 00:41:14.374 align:middle line:-2
会告诉你的shell
启动Swift来运行这个

00:41:15.509 --> 00:41:18.679 align:middle line:-2
这样我们就可以将Swift
作为一个脚本语言

00:41:19.947 --> 00:41:22.282 align:middle line:-2
你可以通过Swift Playground
来开发其中一个

00:41:22.749 --> 00:41:26.053 align:middle line:-2
可以交互地编写代码
并确保代码的正确性

00:41:26.920 --> 00:41:31.058 align:middle line:-2
写好后 你只需要保存到一个文件中
并在顶部添加shebang行

00:41:31.491 --> 00:41:34.228 align:middle line:-1
并让文件在文件系统中可执行

00:41:35.229 --> 00:41:38.966 align:middle line:-2
现在你得到了一个命令行工具
你可以用来 你知道的

00:41:39.032 --> 00:41:42.803 align:middle line:-2
在app外使用或在Xcode中
通过RunScript语句使用

00:41:43.770 --> 00:41:48.242 align:middle line:-1
很简单 它会让你获取全部系统框架

00:41:48.308 --> 00:41:50.544 align:middle line:-1
在本例中 我们可直接编辑属性列表

00:41:51.044 --> 00:41:51.979 align:middle line:-1
这是一个非常棒的技巧

00:41:52.045 --> 00:41:54.515 align:middle line:-1
我们希望你们能好好利用它

00:41:57.417 --> 00:42:00.754 align:middle line:-2
那么今天 我希望你们了解了
AR如何提供新机会

00:41:57.417 --> 00:42:00.754 align:middle line:-2
那么今天 我希望你们了解了
AR如何提供新机会

00:42:00.821 --> 00:42:02.789 align:middle line:-1
给迷人的游戏和其它体验

00:42:03.657 --> 00:42:06.026 align:middle line:-2
我们鼓励你们从一开始设计
就考虑到AR

00:42:06.493 --> 00:42:08.662 align:middle line:-1
请记住对于游戏来说 玩才是重点

00:42:08.729 --> 00:42:11.198 align:middle line:-1
你不能在最后才体验游戏的趣味性

00:42:13.100 --> 00:42:16.904 align:middle line:-2
我们真心希望你会下载SwiftShot
开发者示例代码

00:42:16.970 --> 00:42:19.206 align:middle line:-1
并使用它来指导你创建你自己的app

00:42:19.506 --> 00:42:23.277 align:middle line:-2
我们计划在iOS 12的
每次更新中都更新它

00:42:23.343 --> 00:42:24.478 align:middle line:-1
只要我们发布新版本

00:42:25.045 --> 00:42:28.081 align:middle line:-1
最后如果你还没有机会这么做

00:42:28.148 --> 00:42:30.851 align:middle line:-2
希望你去楼下游戏室
和我们一起玩SwiftShot

00:42:32.486 --> 00:42:35.923 align:middle line:0
要获取更多信息 这场演讲之后
就有一个ARKit研究会

00:42:35.989 --> 00:42:37.257 align:middle line:0
今晚还有一次聚会

00:42:37.858 --> 00:42:40.727 align:middle line:0
我也很开心地宣布
对于参加了这场大会的你们

00:42:41.061 --> 00:42:44.097 align:middle line:0
我们在本周五的中午到下午两点
有一场SwiftShot联赛

00:42:44.164 --> 00:42:47.267 align:middle line:-1
我们希望你们能来参加 非常感谢
